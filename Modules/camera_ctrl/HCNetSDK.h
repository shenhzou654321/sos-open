#ifndef _HC_NET_SDK_H_
#define _HC_NET_SDK_H_

#ifndef __PLAYRECT_defined
#define __PLAYRECT_defined
typedef struct __PLAYRECT
{
    int x;
    int y;
    int uWidth;
    int uHeight;
}PLAYRECT;
#endif

#if (defined(_WIN32)) //windows
#define NET_DVR_API  extern "C"__declspec(dllimport)
typedef  unsigned __int64 UINT64;
typedef  signed __int64 INT64;
#elif defined(__linux__) || defined(__APPLE__) //linux
typedef     unsigned long    DWORD;
typedef     unsigned short  WORD;
typedef     unsigned short  USHORT;
typedef     short           SHORT;
typedef     int             LONG;
typedef  	unsigned char	BYTE;
#define     BOOL int
typedef     unsigned int   	UINT;
typedef 	void* 			LPVOID;
typedef 	void* 			HANDLE;
typedef     unsigned int*  LPDWORD;
typedef  unsigned long long UINT64;
typedef  signed long long INT64;

#ifndef    TRUE
#define    TRUE	1
#endif
#ifndef    FALSE
#define	   FALSE 0
#endif
#ifndef    NULL
#define	   NULL 0
#endif

#define __stdcall
#define CALLBACK

#define NET_DVR_API extern "C"
typedef unsigned int   COLORKEY;
typedef unsigned int   COLORREF;

#ifndef __HWND_defined
#define __HWND_defined
#if defined(__linux__)
typedef unsigned int HWND;
#else
typedef void* HWND;
#endif
#endif


#ifndef __HDC_defined
#define __HDC_defined
#if defined(__linux__)
typedef struct __DC
{
    void*   surface;        //SDL Surface
    HWND    hWnd;           // HDC window handle
}DC;
typedef DC* HDC;
#else
typedef void* HDC;
#endif
#endif

typedef struct tagInitInfo
{
    int uWidth;
    int uHeight;
}INITINFO;
#endif

//�궨��
#define MAX_NAMELEN			    16		//DVR���ص�½��
#define MAX_RIGHT			    32		//�豸֧�ֵ�Ȩ�ޣ�1-12��ʾ����Ȩ�ޣ�13-32��ʾԶ��Ȩ�ޣ�
#define NAME_LEN			    32      //�û����
#define PASSWD_LEN			    16      //���볤��
#define MAX_PASSWD_LEN_EX		    64      //���볤��64λ
#define GUID_LEN				16      //GUID����
#define DEV_TYPE_NAME_LEN		24      //�豸������Ƴ���
#define SERIALNO_LEN		    48      //���кų���
#define MACADDR_LEN			    6       //mac��ַ����
#define MAX_ETHERNET		    2       //�豸������̫����
#define MAX_NETWORK_CARD        4       //�豸�����������Ŀ
#define PATHNAME_LEN		    128     //·������
#define MAX_PRESET_V13          16      //Ԥ�õ�
#define MAX_NUMBER_LEN			32		//������󳤶�
#define MAX_NAME_LEN			128		//�豸�����󳤶�
#define MAX_INDEX_LED           8       //LED�������ֵ 2013-11-19
#define	MAX_CUSTOM_DIR			64      //�Զ���Ŀ¼��󳤶�
#define URL_LEN_V40             256		//���URL����
#define CLOUD_NAME_LEN          48      //�ƴ洢�������û����
#define CLOUD_PASSWD_LEN        48      //�ƴ洢���������볤��
#define MAX_SENSORNAME_LEN      64      //��������Ƴ���
#define MAX_SENSORCHAN_LEN      32      //������ͨ������
#define MAX_DESCRIPTION_LEN     32      //��������������
#define MAX_DEVNAME_LEN_EX      64      //�豸��Ƴ�����չ

//2013-11-19
#define MAX_DEVNAME_LEN         32      //�豸�����󳤶�
#define MAX_LED_INFO            256     //��Ļ������ʾ��Ϣ��󳤶�
#define MAX_TIME_LEN            32      //ʱ����󳤶�
#define MAX_CARD_LEN            24      //������󳤶�
#define MAX_OPERATORNAME_LEN    32      //������Ա�����󳤶�

//�첽��¼�ص�״̬�궨��
#define ASYN_LOGIN_SUCC			1		//�첽��¼�ɹ�
#define ASYN_LOGIN_FAILED		0		//�첽��¼ʧ��


#define MAX_TIMESEGMENT_V30	    8       //9000�豸���ʱ�����
#define MAX_TIMESEGMENT		    4       //8000�豸���ʱ�����
#define MAX_ICR_NUM             8       //ץ�Ļ�����˹�ƬԤ�õ���2013-07-09

#define MAX_SHELTERNUM			4       //8000�豸����ڵ�������
#define MAX_DAYS				7       //ÿ������
#define PHONENUMBER_LEN			32      //pppoe���ź�����󳤶�

#define MAX_DISKNUM_V30			33		//9000�豸���Ӳ����/* ���33��Ӳ��(����16������SATAӲ�̡�1��eSATAӲ�̺�16��NFS��) */
#define MAX_DISKNUM		        16      //8000�豸���Ӳ����
#define MAX_DISKNUM_V10		    8       //1.2�汾֮ǰ�汾

#define MAX_WINDOW_V30			32      //9000�豸������ʾ��󲥷Ŵ�����
#define MAX_WINDOW_V40			64      //Netra 2.3.1��չ
#define MAX_WINDOW				16      //8000�豸���Ӳ����
#define MAX_VGA_V30				4       //9000�豸���ɽ�VGA��
#define MAX_VGA			    	1       //8000�豸���ɽ�VGA��

#define MAX_USERNUM_V30			32      //9000�豸����û���
#define MAX_USERNUM			    16      //8000�豸����û���
#define MAX_EXCEPTIONNUM_V30	32      //9000�豸����쳣������
#define MAX_EXCEPTIONNUM		16      //8000�豸����쳣������
#define MAX_LINK				6       //8000�豸��ͨ�������Ƶ��������
#define MAX_ITC_EXCEPTIONOUT	32      //ץ�Ļ���󱨾����

#define MAX_DECPOOLNUM			4       //��·������ÿ������ͨ������ѭ��������
#define MAX_DECNUM				4       //��·��������������ͨ����ʵ��ֻ��һ�����������������
#define MAX_TRANSPARENTNUM		2       //��·���������������͸��ͨ����
#define MAX_CYCLE_CHAN			16      //��·�����������Ѳͨ����
#define MAX_CYCLE_CHAN_V30      64      //�����Ѳͨ������չ��
#define MAX_DIRNAME_LENGTH		80      //���Ŀ¼����
#define MAX_WINDOWS				16      //��󴰿���


#define MAX_STRINGNUM_V30		8		//9000�豸���OSD�ַ�������
#define MAX_STRINGNUM			4       //8000�豸���OSD�ַ�������
#define MAX_STRINGNUM_EX		8       //8000������չ
#define MAX_AUXOUT_V30			16      //9000�豸����������
#define MAX_AUXOUT			    4       //8000�豸����������
#define MAX_HD_GROUP			16      //9000�豸���Ӳ������
#define MAX_HD_GROUP_V40    	32      //�豸���Ӳ������
#define MAX_NFS_DISK			8       //8000�豸���NFSӲ����

#define IW_ESSID_MAX_SIZE	    32      //WIFI��SSID�ų���
#define IW_ENCODING_TOKEN_MAX	32      //WIFI��������ֽ���
#define MAX_SERIAL_NUM			64	    //���֧�ֵ�͸��ͨ��·��
#define MAX_DDNS_NUMS	        10      //9000�豸������ddns��
#define MAX_DOMAIN_NAME		    64		/* �������� */
#define MAX_EMAIL_ADDR_LEN	    48      //���email��ַ����
#define MAX_EMAIL_PWD_LEN		32      //���email���볤��
#define MAX_SLAVECAMERA_NUM     8       //����������
#define MAX_CALIB_NUM           6       //�궨��ĸ���
#define MAX_LEDDISPLAYINFO_LEN  1024    //���LED����ʾ����
#define MAXPROGRESS		        100     //�ط�ʱ�����ٷ���
#define MAX_SERIALNUM	        2       //8000�豸֧�ֵĴ����� 1-232�� 2-485
#define CARDNUM_LEN		        20      //���ų���
#define CARDNUM_LEN_OUT			32      //�ⲿ�ṹ�忨�ų���
#define MAX_VIDEOOUT_V30        4       //9000�豸����Ƶ�����
#define MAX_VIDEOOUT	        2       //8000�豸����Ƶ�����

#define MAX_PRESET_V30			256		/* 9000�豸֧�ֵ���̨Ԥ�õ��� */
#define MAX_TRACK_V30			256		/* 9000�豸֧�ֵ���̨�켣�� */
#define MAX_CRUISE_V30			256		/* 9000�豸֧�ֵ���̨Ѳ���� */
#define MAX_PRESET				128		/* 8000�豸֧�ֵ���̨Ԥ�õ��� */
#define MAX_TRACK				128		/* 8000�豸֧�ֵ���̨�켣�� */
#define MAX_CRUISE				128		/* 8000�豸֧�ֵ���̨Ѳ���� */

#define MAX_PRESET_V40			300		/* ��̨֧�ֵ����Ԥ�õ��� */
#define MAX_CRUISE_POINT_NUM    128     /* ���֧�ֵ�Ѳ����ĸ��� */

#define CRUISE_MAX_PRESET_NUMS	32 	    /* һ��Ѳ������Ѳ���� */
#define MAX_FACE_PIC_NUM        30      /*������ͼ����*/
#define LOCKGATE_TIME_NUM       4       //��բʱ��θ���

#define MAX_SERIAL_PORT         8       //9000�豸֧��232������
#define MAX_PREVIEW_MODE        8       /* �豸֧�����Ԥ��ģʽ��Ŀ 1����,4����,9����,16����.... */
#define MAX_MATRIXOUT           16      /* ���ģ������������ */
#define LOG_INFO_LEN            11840   /* ��־������Ϣ */
#define DESC_LEN                16      /* ��̨�����ַ��� */
#define PTZ_PROTOCOL_NUM        200     /* 9000���֧�ֵ���̨Э���� */

#define MAX_AUDIO			    1       //8000�����Խ�ͨ����
#define MAX_AUDIO_V30			2       //9000�����Խ�ͨ����
#define MAX_CHANNUM			    16      //8000�豸���ͨ����
#define MAX_ALARMIN			    16      //8000�豸��󱨾�������
#define MAX_ALARMOUT		    4       //8000�豸��󱨾������
//9000 IPC����
#define MAX_ANALOG_CHANNUM      32      //���32��ģ��ͨ��
#define MAX_ANALOG_ALARMOUT     32      //���32·ģ�ⱨ�����
#define MAX_ANALOG_ALARMIN      32      //���32·ģ�ⱨ������

#define MAX_IP_DEVICE           32      //�����������IP�豸��
#define MAX_IP_DEVICE_V40       64      // �����������IP�豸�� �������64�� IVMS 2000�����豸
#define MAX_IP_CHANNEL          32      //�����������IPͨ����
#define MAX_IP_ALARMIN          128     //����������౨��������
#define MAX_IP_ALARMOUT         64      //����������౨�������
#define MAX_IP_ALARMIN_V40      4096    //����������౨��������
#define MAX_IP_ALARMOUT_V40     4096    //����������౨�������

#define MAX_RECORD_FILE_NUM     20      // ÿ��ɾ����߿�¼������ļ���
//SDK_V31 ATM
#define MAX_ACTION_TYPE	        12	    //�Զ���Э����ӽ�����Ϊ�����Ϊ����
#define MAX_ATM_PROTOCOL_NUM    256   //ÿ�����뷽ʽ��Ӧ��ATM���Э����
#define ATM_CUSTOM_PROTO        1025   //�Զ���Э�� ֵΪ1025
#define ATM_PROTOCOL_SORT       4       //ATMЭ�����
#define ATM_DESC_LEN            32      //ATM�����ַ���
// SDK_V31 ATM

#define MAX_EVENTID_LEN         64   //�¼�ID����
#define MAX_IPV6_LEN  			64   //IPv6��ַ��󳤶�

#define MAX_CHANNUM_V40         512
#define INVALID_VALUE_UINT32    0xffffffff   //��Чֵ
#define MAX_MULTI_AREA_NUM      24

//SDK ¼������
#define COURSE_NAME_LEN				32	//�γ����
#define INSTRUCTOR_NAME_LEN			16	//�ڿν�ʦ
#define COURSE_DESCRIPTION_LEN		256	//�γ���Ϣ

#define MAX_TIMESEGMENT_V40			16	//ÿ�ڿ���Ϣ


#define MAX_MIX_CHAN_NUM		16	/*Ŀǰ֧�ֵ�������ͨ�����ͨ�� + MIC + LINE IN + ���4��С����*/
#define MAX_LINE_IN_CHAN_NUM	16	//���line inͨ����
#define MAX_MIC_CHAN_NUM		16	//���MICͨ����
#define INQUEST_CASE_NO_LEN		64	//��Ѷ������ų���
#define INQUEST_CASE_NAME_LEN	64	//��Ѷ������Ƴ���
#define CUSTOM_INFO_LEN			64	//�Զ�����Ϣ����
#define INQUEST_CASE_LEN		64	//��Ѷ��Ϣ����


#define MAX_FILE_ID_LEN         128	//��ͼ����Ŀ���ļ�ID����󳤶�
#define MAX_PIC_NAME_LEN        128 //ͼƬ��Ƴ���

/* ���֧�ֵ�ͨ���� ���ģ��������IP֧�� */
#define MAX_CHANNUM_V30               ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL )//64
#define MAX_ALARMOUT_V40             (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ALARMOUT_V30              ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT )//96
#define MAX_ALARMIN_V30               ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN )//160
#define MAX_ALARMIN_V40             (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ANALOG_ALARM_WITH_VOLT_LIMIT	16 //�ܵ�ѹ�޶���ģ�ⱨ�����������

#define MAX_ROIDETECT_NUM       8    //֧�ֵ�ROI������
#define MAX_LANERECT_NUM        5    //�����ʶ��������
#define MAX_FORTIFY_NUM         10   //��󲼷�����
#define MAX_INTERVAL_NUM        4    //���ʱ��������
#define MAX_CHJC_NUM            3    //�����ʡ�ݼ���ַ����
#define MAX_VL_NUM              5    //���������Ȧ����
#define MAX_DRIVECHAN_NUM       16   //��󳵵���
#define MAX_COIL_NUM            3    //�����Ȧ����
#define MAX_SIGNALLIGHT_NUM     6   //����źŵƸ���
#define LEN_16					16
#define LEN_32					32
#define LEN_31					31
#define MAX_CABINET_COUNT       8    //���֧�ֻ������
#define MAX_ID_LEN              48
#define MAX_PARKNO_LEN          16
#define MAX_ALARMREASON_LEN     32
#define MAX_UPGRADE_INFO_LEN    48 //��ȡ���ļ�ƥ����Ϣ(ģ����)
#define MAX_CUSTOMDIR_LEN       32 //�Զ���Ŀ¼����
#define MAX_LED_INFO_LEN        512//LED���ݳ���
#define MAX_VOICE_INFO_LEN      128//�����������ݳ���
#define MAX_LITLE_INFO_LEN      64 //ֽƱ�������ݳ���
#define MAX_CUSTOM_INFO_LEN     64 //ֽƱ�Զ�����Ϣ���ݳ���
#define MAX_PHONE_NUM_LEN       16 //��ϵ�绰���ݳ���
#define MAX_APP_SERIALNUM_LEN   32 //Ӧ�����кų���

#define MAX_TRANSPARENT_CHAN_NUM      4   //ÿ���������?�������͸��ͨ����
#define MAX_TRANSPARENT_ACCESS_NUM    4   //ÿ������˿������������������

//ITS
#define MAX_PARKING_STATUS       8    //��λ״̬ 0����޳���1����г���2���ѹ��(���ȼ����), 3���⳵λ
#define MAX_PARKING_NUM	         4    //һ��ͨ�����4����λ (�����ҳ�λ ����0��3)

#define MAX_ITS_SCENE_NUM        16   //��󳡾�����
#define MAX_SCENE_TIMESEG_NUM    16   //��󳡾�ʱ�������
#define MAX_IVMS_IP_CHANNEL      128  //���IPͨ����
#define DEVICE_ID_LEN            48   //�豸��ų���
#define MONITORSITE_ID_LEN       48   //�����ų���
#define MAX_AUXAREA_NUM          16   //�������������Ŀ
#define MAX_SLAVE_CHANNEL_NUM    16   //����ͨ������
#define MAX_DEVDESC_LEN          64   //�豸������Ϣ��󳤶�

#define MAX_SCH_TASKS_NUM        10
#define MAX_SECRETKEY_LEN           512     //�����Կ����
#define MAX_INDEX_CODE_LEN          64      //�����ų���

#define MAX_SERVERID_LEN            64 //��������ID�ĳ���
#define MAX_SERVERDOMAIN_LEN        128 //������������󳤶�
#define MAX_AUTHENTICATEID_LEN      64 //��֤ID��󳤶�
#define MAX_AUTHENTICATEPASSWD_LEN  32 //��֤������󳤶�
#define MAX_SERVERNAME_LEN          64 //���������û���
#define MAX_COMPRESSIONID_LEN       64 //����ID����󳤶�
#define MAX_SIPSERVER_ADDRESS_LEN   128 //SIP��������ַ֧�������IP��ַ
//ѹ�߱���
#define MAX_PlATE_NO_LEN            32   //���ƺ�����󳤶� 2013-09-27
#define UPNP_PORT_NUM			    12	  //upnp�˿�ӳ��˿���Ŀ

#define MAX_PEOPLE_DETECTION_NUM    8  //�����Ա���������

#define MAX_NOTICE_NUMBER_LEN       32   //��������󳤶�
#define MAX_NOTICE_THEME_LEN        64   //����������󳤶�
#define MAX_NOTICE_DETAIL_LEN       1024 //����������󳤶�
#define MAX_NOTICE_PIC_NUM          6    //������Ϣ���ͼƬ����
#define MAX_DEV_NUMBER_LEN          32   //�豸�����󳤶�

#define DOOR_NAME_LEN                   32  //�����
#define STRESS_PASSWORD_LEN             8   //в�����볤��
#define SUPER_PASSWORD_LEN              8   //�������볤��
#define GROUP_COMBINATION_NUM           8   //Ⱥ�������

#define HOLIDAY_GROUP_NAME_LEN          32  //��������Ƴ���
#define MAX_HOLIDAY_PLAN_NUM            16  //�����������ռƻ���
#define TEMPLATE_NAME_LEN               32  //�ƻ�ģ����Ƴ���
#define MAX_HOLIDAY_GROUP_NUM           16   //�ƻ�ģ������������
#define DOOR_NAME_LEN                   32  //�����
#define STRESS_PASSWORD_LEN             8   //в�����볤��
#define SUPER_PASSWORD_LEN              8   //в�����볤��
#define GROUP_NAME_LEN                  32  //Ⱥ����Ƴ���
#define GROUP_COMBINATION_NUM           8   //Ⱥ�������
#define MULTI_CARD_GROUP_NUM            4   //���������ؿ�����
#define ACS_CARD_NO_LEN                 32  //�Ž�ų���
#define CARD_PASSWORD_LEN               8   //�����볤��
#define MAX_DOOR_NUM                    32  //�������
#define MAX_CARD_RIGHT_PLAN_NUM         4   //��Ȩ�����ƻ�����
#define MAX_CARD_READER_NUM             64  //����������
#define MAX_SNEAK_PATH_NODE             8   //�������������
#define MAX_MULTI_DOOR_INTERLOCK_GROUP  8   //�����Ż�������
#define MAX_INTER_LOCK_DOOR_NUM         8   //һ�����Ż����������������
#define MAX_CASE_SENSOR_NUM             8   //���case sensor��������
#define MAX_DOOR_NUM_256                256 //�������
#define MAX_READER_ROUTE_NUM            16  //���ˢ��ѭ��·��
#define MAX_FINGER_PRINT_NUM            10  //���ָ�Ƹ���
#define MAX_CARD_READER_NUM_512    		512 //����������

#define PER_RING_PORT_NUM				2   //ÿ�����Ķ˿���
#define SENSORNAME_LEN                  32  //��������Ƴ���
#define MAX_SENSORDESCR_LEN             64  //��������������
#define MAX_DNS_SERVER_NUM              2 //���DNS����

#define WEP_KEY_MAX_SIZE                32 //���WEP������Կ����
#define WEP_KEY_MAX_NUM                 4  //���WEP������Կ����
#define WPA_KEY_MAX_SIZE                64 //���WPA������Կ����

#define MAX_IDCODE_LEN      128 //  ʶ������󳤶�
#define MAX_VERSIIN_LEN     64  //�汾��󳤶�
#define MAX_IDCODE_NUM      32  // ʶ�������
#define SDK_LEN_2048        2048

#define RECT_POINT_NUM	                4	//���ν���

//MCU��ص�
#define MAX_SEARCH_ID_LEN               36  //������ʶ����󳤶�
#define TERMINAL_NAME_LEN               64  //�ն���Ƴ���
#define MAX_URL_LEN                     512 //URL����

#define MAX_OUTPUT_PORT_NUM				32	//��·�������������˿���
#define MAX_SINGLE_PORT_RECVCARD_NUM	64	//�����˿����ӵ������տ���
#define MAX_GAMMA_X_VALUE				256	//GAMMA��X��ȡֵ����


#define PLAYLIST_NAME_LEN				64			//���ű���Ƴ���
#define PLAYLIST_ITEM_NUM				64			//��������Ŀ
/*******************ȫ�ִ����� begin**********************/
#define NET_DVR_NOERROR 					0	//û�д���
#define NET_DVR_PASSWORD_ERROR 				1	//�û����������
#define NET_DVR_NOENOUGHPRI 				2	//Ȩ�޲���
#define NET_DVR_NOINIT 						3	//û�г�ʼ��
#define NET_DVR_CHANNEL_ERROR 				4	//ͨ���Ŵ���
#define NET_DVR_OVER_MAXLINK 				5	//���ӵ�DVR�Ŀͻ��˸�������
#define NET_DVR_VERSIONNOMATCH				6	//�汾��ƥ��
#define NET_DVR_NETWORK_FAIL_CONNECT		7	//���ӷ�����ʧ��
#define NET_DVR_NETWORK_SEND_ERROR			8	//�����������ʧ��
#define NET_DVR_NETWORK_RECV_ERROR			9	//�ӷ������������ʧ��
#define NET_DVR_NETWORK_RECV_TIMEOUT		10	//�ӷ�����������ݳ�ʱ
#define NET_DVR_NETWORK_ERRORDATA			11	//���͵��������
#define NET_DVR_ORDER_ERROR					12	//���ô������
#define NET_DVR_OPERNOPERMIT				13	//�޴�Ȩ��
#define NET_DVR_COMMANDTIMEOUT				14	//DVR����ִ�г�ʱ
#define NET_DVR_ERRORSERIALPORT				15	//���ںŴ���
#define NET_DVR_ERRORALARMPORT				16	//�����˿ڴ���
#define NET_DVR_PARAMETER_ERROR 			17  //�������
#define NET_DVR_CHAN_EXCEPTION				18	//������ͨ�����ڴ���״̬
#define NET_DVR_NODISK						19	//û��Ӳ��
#define NET_DVR_ERRORDISKNUM				20	//Ӳ�̺Ŵ���
#define NET_DVR_DISK_FULL					21	//������Ӳ����
#define NET_DVR_DISK_ERROR					22	//������Ӳ�̳���
#define NET_DVR_NOSUPPORT					23	//��������֧��
#define NET_DVR_BUSY						24	//������æ
#define NET_DVR_MODIFY_FAIL					25	//�������޸Ĳ��ɹ�
#define NET_DVR_PASSWORD_FORMAT_ERROR		26	//���������ʽ����ȷ
#define NET_DVR_DISK_FORMATING				27	//Ӳ�����ڸ�ʽ����������������
#define NET_DVR_DVRNORESOURCE				28	//DVR��Դ����
#define	NET_DVR_DVROPRATEFAILED				29  //DVR����ʧ��
#define NET_DVR_OPENHOSTSOUND_FAIL 			30  //��PC����ʧ��
#define NET_DVR_DVRVOICEOPENED 				31  //�����������Խ���ռ��
#define	NET_DVR_TIMEINPUTERROR				32  //ʱ�����벻��ȷ
#define	NET_DVR_NOSPECFILE					33  //�ط�ʱ������û��ָ�����ļ�
#define NET_DVR_CREATEFILE_ERROR			34	//�����ļ�����
#define	NET_DVR_FILEOPENFAIL				35  //���ļ�����
#define	NET_DVR_OPERNOTFINISH				36  //�ϴεĲ�����û�����
#define	NET_DVR_GETPLAYTIMEFAIL				37  //��ȡ��ǰ���ŵ�ʱ�����
#define	NET_DVR_PLAYFAIL					38  //���ų���
#define NET_DVR_FILEFORMAT_ERROR			39  //�ļ���ʽ����ȷ
#define NET_DVR_DIR_ERROR					40	//·������
#define NET_DVR_ALLOC_RESOURCE_ERROR		41  //��Դ�������
#define NET_DVR_AUDIO_MODE_ERROR			42	//��ģʽ����
#define NET_DVR_NOENOUGH_BUF				43	//������̫С
#define NET_DVR_CREATESOCKET_ERROR		 	44	//����SOCKET����
#define NET_DVR_SETSOCKET_ERROR				45	//����SOCKET����
#define NET_DVR_MAX_NUM						46	//����ﵽ���
#define NET_DVR_USERNOTEXIST				47	//�û�������
#define NET_DVR_WRITEFLASHERROR				48  //дFLASH����
#define NET_DVR_UPGRADEFAIL					49  //DVR��ʧ��
#define NET_DVR_CARDHAVEINIT				50  //���뿨�Ѿ���ʼ����
#define NET_DVR_PLAYERFAILED				51	//���ò��ſ���ĳ������ʧ��
#define NET_DVR_MAX_USERNUM					52  //�豸���û���ﵽ���
#define NET_DVR_GETLOCALIPANDMACFAIL		53  //��ÿͻ��˵�IP��ַ�������ַʧ��
#define NET_DVR_NOENCODEING					54	//��ͨ��û�б���
#define NET_DVR_IPMISMATCH					55	//IP��ַ��ƥ��
#define NET_DVR_MACMISMATCH					56	//MAC��ַ��ƥ��
#define NET_DVR_UPGRADELANGMISMATCH			57	//���ļ����Բ�ƥ��
#define NET_DVR_MAX_PLAYERPORT				58	//������·��ﵽ���
#define NET_DVR_NOSPACEBACKUP				59	//�����豸��û���㹻�ռ���б���
#define NET_DVR_NODEVICEBACKUP				60	//û���ҵ�ָ���ı����豸
#define NET_DVR_PICTURE_BITS_ERROR			61	//ͼ����λ�����24ɫ
#define NET_DVR_PICTURE_DIMENSION_ERROR		62	//ͼƬ��*�?�ޣ� ��128*256
#define NET_DVR_PICTURE_SIZ_ERROR			63	//ͼƬ��С���ޣ���100K
#define NET_DVR_LOADPLAYERSDKFAILED			64	//���뵱ǰĿ¼��Player Sdk����
#define NET_DVR_LOADPLAYERSDKPROC_ERROR		65	//�Ҳ���Player Sdk��ĳ���������
#define NET_DVR_LOADDSSDKFAILED				66	//���뵱ǰĿ¼��DSsdk����
#define NET_DVR_LOADDSSDKPROC_ERROR		    67	//�Ҳ���DsSdk��ĳ���������
#define NET_DVR_DSSDK_ERROR					68	//����Ӳ�����DsSdk��ĳ������ʧ��
#define NET_DVR_VOICEMONOPOLIZE				69	//����ռ
#define NET_DVR_JOINMULTICASTFAILED			70	//����ಥ��ʧ��
#define NET_DVR_CREATEDIR_ERROR				71	//������־�ļ�Ŀ¼ʧ��
#define NET_DVR_BINDSOCKET_ERROR			72	//���׽���ʧ��
#define NET_DVR_SOCKETCLOSE_ERROR			73	//socket�����жϣ��˴���ͨ�������������жϻ�Ŀ�ĵز��ɴ�
#define NET_DVR_USERID_ISUSING			    74	//ע��ʱ�û�ID���ڽ���ĳ����
#define NET_DVR_SOCKETLISTEN_ERROR			75	//����ʧ��
#define NET_DVR_PROGRAM_EXCEPTION			76	//�����쳣
#define NET_DVR_WRITEFILE_FAILED			77	//д�ļ�ʧ��
#define NET_DVR_FORMAT_READONLY				78  //��ֹ��ʽ��ֻ��Ӳ��
#define NET_DVR_WITHSAMEUSERNAME		    79  //�û����ýṹ�д�����ͬ���û���
#define NET_DVR_DEVICETYPE_ERROR            80  /*�������ʱ�豸�ͺŲ�ƥ��*/
#define NET_DVR_LANGUAGE_ERROR              81  /*�������ʱ���Բ�ƥ��*/
#define NET_DVR_PARAVERSION_ERROR           82  /*�������ʱ����汾��ƥ��*/
#define NET_DVR_IPCHAN_NOTALIVE             83  /*Ԥ��ʱ���IPͨ��������*/
#define NET_DVR_RTSP_SDK_ERROR				84	/*���ظ���IPCͨѶ��StreamTransClient.dllʧ��*/
#define NET_DVR_CONVERT_SDK_ERROR			85	/*����ת���ʧ��*/
#define NET_DVR_IPC_COUNT_OVERFLOW			86  /*��������ip����ͨ����*/
#define NET_DVR_MAX_ADD_NUM                 87  /*��ӱ�ǩ(һ���ļ�Ƭ��64)�ȸ���ﵽ���*/
#define NET_DVR_PARAMMODE_ERROR             88 //ͼ����ǿ�ǣ�����ģʽ��������Ӳ������ʱ���ͻ��˽����������ʱ����ֵ��
#define NET_DVR_CODESPITTER_OFFLINE			89 //��Ƶ�ۺ�ƽ̨�������������
#define NET_DVR_BACKUP_COPYING				90  //�豸���ڱ���
#define NET_DVR_CHAN_NOTSUPPORT             91  // ͨ����֧�ָò���
#define NET_DVR_CALLINEINVALID              92  // �߶���λ��̫���л򳤶��߲�����б
#define NET_DVR_CALCANCELCONFLICT           93  // ȡ��궨��ͻ����������˹���ȫ�ֵ�ʵ�ʴ�С�ߴ����
#define NET_DVR_CALPOINTOUTRANGE            94 	// �궨�㳬����Χ
#define NET_DVR_FILTERRECTINVALID           95  // �ߴ�����������Ҫ��
#define NET_DVR_DDNS_DEVOFFLINE             96  //�豸û��ע�ᵽddns��
#define NET_DVR_DDNS_INTER_ERROR            97  //DDNS �������ڲ�����
#define NET_DVR_FUNCTION_NOT_SUPPORT_OS     98  //�˹��ܲ�֧�ָò���ϵͳ
#define NET_DVR_DEC_CHAN_REBIND             99  //����ͨ������ʾ�����������
#define NET_DVR_INTERCOM_SDK_ERROR          100 //���ص�ǰĿ¼�µ������Խ���ʧ��
#define NET_DVR_NO_CURRENT_UPDATEFILE       101 //û����ȷ�����
#define NET_DVR_USER_NOT_SUCC_LOGIN         102  //�û���û��½�ɹ�
#define NET_DVR_USE_LOG_SWITCH_FILE			103  //����ʹ����־�����ļ�
#define NET_DVR_POOL_PORT_EXHAUST			104  //�˿ڳ������ڰ󶨵Ķ˿��Ѻľ�
#define	NET_DVR_PACKET_TYPE_NOT_SUPPORT		105	//������װ��ʽ����
#define NET_DVR_IPPARA_IPID_ERROR           106  //IP��������ʱIPID����

#define NET_DVR_LOAD_HCPREVIEW_SDK_ERROR           107         //Ԥ���������ʧ��
#define NET_DVR_LOAD_HCVOICETALK_SDK_ERROR         108         //�����������ʧ��
#define NET_DVR_LOAD_HCALARM_SDK_ERROR             109         //�����������ʧ��
#define NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR          110         //�ط��������ʧ��
#define NET_DVR_LOAD_HCDISPLAY_SDK_ERROR           111         //��ʾ�������ʧ��
#define NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR          112         //��ҵӦ���������ʧ��
#define NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR     113         //ͨ�����ù����������ʧ��
#define NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR        114         //�豸���ú����������ʧ��

#define NET_DVR_CORE_VER_MISMATCH                  121    //�����������ʱ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCPREVIEW        122    //Ԥ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCVOICETALK      123    //���������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCALARM          124    //���������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK       125    //�ط������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCDISPLAY        126    //��ʾ�����core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY       127    //��ҵӦ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR  128    //ͨ�����ù��������core�汾��ƥ��

#define NET_DVR_COM_VER_MISMATCH_HCPREVIEW         136    //Ԥ�������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCVOICETALK       137    //���������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCALARM           138    //���������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCPLAYBACK        139    //�ط������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCDISPLAY         140    //��ʾ�����HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCINDUSTRY        141    //��ҵӦ�������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR   142    //ͨ�����ù��������HCNetSDK�汾��ƥ��

#define NET_DVR_ALIAS_DUPLICATE				150	//�����ظ�  //2011-08-31 ͨ�����������к��������豸���°汾ddns������
#define	NET_DVR_INVALID_COMMUNICATION		151	//��Чͨ��
#define	NET_DVR_USERNAME_NOT_EXIST			152	//�û�����ڣ��û�����ڣ�IPC5.1.7�з�����ȥ�ˣ�����ɾ����������Ĳ�Ʒ����������ò��ϣ�
#define	NET_DVR_USER_LOCKED			        153 //�û�����
#define NET_DVR_INVALID_USERID              154 //��Ч�û�ID
#define NET_DVR_LOW_LOGIN_VERSION           155 //��¼�汾��
#define NET_DVR_LOAD_LIBEAY32_DLL_ERROR     156 //����libeay32.dll��ʧ��
#define NET_DVR_LOAD_SSLEAY32_DLL_ERROR     157 //����ssleay32.dll��ʧ��
#define NET_ERR_LOAD_LIBICONV           158 //����libiconv��ʧ��

#define NET_DVR_SERVER_NOT_EXIST         164 //��Ӧ�ķ������Ҳ���,����ʱ����Ĺ�ұ�Ż��߷��������ʹ���
#define NET_DVR_TEST_SERVER_FAIL_CONNECT			165	//���Ӳ��Է�����ʧ��
#define NET_DVR_NAS_SERVER_INVALID_DIR				166	//NAS����������Ŀ¼ʧ�ܣ�Ŀ¼��Ч
#define NET_DVR_NAS_SERVER_NOENOUGH_PRI				167	//NAS����������Ŀ¼ʧ�ܣ�û��Ȩ��
#define NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS			168	//������ʹ��������û������DNS���������������Ч��
#define	NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY		169	//û��������أ�������ɷ����ʼ�ʧ�ܡ�
#define	NET_DVR_TEST_SERVER_PASSWORD_ERROR			170	//�û������벻��ȷ�����Է��������û�����������
#define	NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP	171	//�豸��smtp�����������쳣
#define	NET_DVR_FTP_SERVER_FAIL_CREATE_DIR			172	//FTP����������Ŀ¼ʧ��
#define	NET_DVR_FTP_SERVER_NO_WRITE_PIR				173	//FTP������û��д��Ȩ��
#define	NET_DVR_IP_CONFLICT							174	//IP��ͻ
#define NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE      175  //�洢�ؿռ�����
#define NET_DVR_STORAGEPOOL_INVALID      176  //�Ʒ������洢����Ч,û�����ô洢�ػ��ߴ洢��ID����
#define NET_DVR_EFFECTIVENESS_REBOOT     177  //��Ч��Ҫ����
#define NET_ERR_ANR_ARMING_EXIST         178  //�������������Ѿ�����(�ô���������HIK˽�в������ӽ���������£��ظ������Ķ�������ʱ�����ء�)
#define NET_ERR_UPLOADLINK_EXIST         179  //�������ϴ������Ѿ�����(EHOMEЭ���HIK SDKЭ���ǲ���ͬʱ֧�ֶ�����ģ���һ��Э����ڵ�ʱ������һ�����ӽ�������������������롣)
// 2010-5-28
// ���д�����
#define RAID_ERROR_INDEX	                200
#define NET_DVR_NAME_NOT_ONLY               (RAID_ERROR_INDEX + 0)  // ����Ѵ���
#define NET_DVR_OVER_MAX_ARRAY              (RAID_ERROR_INDEX + 1 ) // ���дﵽ����
#define NET_DVR_OVER_MAX_VD                 (RAID_ERROR_INDEX + 2 ) // ������̴ﵽ����
#define NET_DVR_VD_SLOT_EXCEED              (RAID_ERROR_INDEX + 3 ) // ������̲�λ����
#define NET_DVR_PD_STATUS_INVALID           (RAID_ERROR_INDEX + 4 ) // �ؽ����������������״̬����
#define NET_DVR_PD_BE_DEDICATE_SPARE        (RAID_ERROR_INDEX + 5 ) // �ؽ����������������Ϊָ���ȱ�
#define NET_DVR_PD_NOT_FREE                 (RAID_ERROR_INDEX + 6 ) // �ؽ���������������̷ǿ���
#define NET_DVR_CANNOT_MIG2NEWMODE          (RAID_ERROR_INDEX + 7 ) // ���ܴӵ�ǰ����������Ǩ�Ƶ��µ���������
#define NET_DVR_MIG_PAUSE                   (RAID_ERROR_INDEX + 8 ) // Ǩ�Ʋ�������ͣ
#define NET_DVR_MIG_CANCEL                  (RAID_ERROR_INDEX + 9 ) // ����ִ�е�Ǩ�Ʋ�����ȡ��
#define NET_DVR_EXIST_VD                    (RAID_ERROR_INDEX + 10) // �����������ϴ���������̣��޷�ɾ������
#define NET_DVR_TARGET_IN_LD_FUNCTIONAL     (RAID_ERROR_INDEX + 11) // �����������Ϊ���������ɲ����ҹ�����
#define NET_DVR_HD_IS_ASSIGNED_ALREADY      (RAID_ERROR_INDEX + 12) // ָ����������̱�����Ϊ�������
#define NET_DVR_INVALID_HD_COUNT            (RAID_ERROR_INDEX + 13) // �������������ָ����RAID�ȼ���ƥ��
#define NET_DVR_LD_IS_FUNCTIONAL            (RAID_ERROR_INDEX + 14) // �������޷��ؽ�
#define NET_DVR_BGA_RUNNING                 (RAID_ERROR_INDEX + 15) // ��������ִ�еĺ�̨����
#define NET_DVR_LD_NO_ATAPI                 (RAID_ERROR_INDEX + 16) // �޷���ATAPI�̴����������
#define NET_DVR_MIGRATION_NOT_NEED          (RAID_ERROR_INDEX + 17) // ��������Ǩ��
#define NET_DVR_HD_TYPE_MISMATCH            (RAID_ERROR_INDEX + 18) // ������̲�����ͬ������
#define NET_DVR_NO_LD_IN_DG                 (RAID_ERROR_INDEX + 19) // ��������̣��޷����д������
#define NET_DVR_NO_ROOM_FOR_SPARE           (RAID_ERROR_INDEX + 20) // ���̿ռ��С���޷���ָ��Ϊ�ȱ���
#define NET_DVR_SPARE_IS_IN_MULTI_DG        (RAID_ERROR_INDEX + 21) // �����ѱ�����Ϊĳ�����ȱ���
#define NET_DVR_DG_HAS_MISSING_PD           (RAID_ERROR_INDEX + 22) // ����ȱ����

// x86 64bit nvr���� 2012-02-04
#define NET_DVR_NAME_EMPTY					(RAID_ERROR_INDEX + 23) /*���Ϊ��*/
#define NET_DVR_INPUT_PARAM					(RAID_ERROR_INDEX + 24) /*�����������*/
#define NET_DVR_PD_NOT_AVAILABLE			(RAID_ERROR_INDEX + 25) /*������̲�����*/
#define NET_DVR_ARRAY_NOT_AVAILABLE			(RAID_ERROR_INDEX + 26) /*���в�����*/
#define NET_DVR_PD_COUNT					(RAID_ERROR_INDEX + 27) /*�����������ȷ*/
#define NET_DVR_VD_SMALL					(RAID_ERROR_INDEX + 28) /*�������̫С*/
#define NET_DVR_NO_EXIST					(RAID_ERROR_INDEX + 29) /*������*/
#define NET_DVR_NOT_SUPPORT					(RAID_ERROR_INDEX + 30) /*��֧�ָò���*/
#define NET_DVR_NOT_FUNCTIONAL	 			(RAID_ERROR_INDEX + 31) /*����״̬������״̬*/
#define NET_DVR_DEV_NODE_NOT_FOUND			(RAID_ERROR_INDEX + 32) /*��������豸�ڵ㲻����*/
#define NET_DVR_SLOT_EXCEED					(RAID_ERROR_INDEX + 33) /*��λ�ﵽ����*/
#define NET_DVR_NO_VD_IN_ARRAY				(RAID_ERROR_INDEX + 34) /*�����ϲ������������*/
#define NET_DVR_VD_SLOT_INVALID				(RAID_ERROR_INDEX + 35) /*������̲�λ��Ч*/
#define NET_DVR_PD_NO_ENOUGH_SPACE			(RAID_ERROR_INDEX + 36) /*����������̿ռ䲻��*/
#define NET_DVR_ARRAY_NONFUNCTION			(RAID_ERROR_INDEX + 37) /*ֻ�д�����״̬�����в��ܽ���Ǩ��*/
#define NET_DVR_ARRAY_NO_ENOUGH_SPACE		(RAID_ERROR_INDEX + 38) /*���пռ䲻��*/
#define NET_DVR_STOPPING_SCANNING_ARRAY		(RAID_ERROR_INDEX + 39) /*����ִ�а�ȫ���̻�����ɨ��*/
#define NET_DVR_NOT_SUPPORT_16T             (RAID_ERROR_INDEX + 40) /*��֧�ִ�������16T������*/
#define NET_DVR_ARRAY_FORMATING             (RAID_ERROR_INDEX + 41) /*����ִ�и�ʽ���������޷�ɾ��*/
#define NET_DVR_QUICK_SETUP_PD_COUNT        (RAID_ERROR_INDEX + 42) /*һ������������Ҫ��������*/

//�豸δ����ʱ����¼ʧ�ܣ����ش�����
#define	NET_DVR_ERROR_DEVICE_NOT_ACTIVATED    250//�豸δ����
//��SDK�����豸�������û�������߼����ʱ��Ϊ��������ʱ��������
#define  NET_DVR_ERROR_RISK_PASSWORD          251 //�з��յ�����
//�Ѽ�����豸���ٴμ���ʱ���ش�����
#define	NET_DVR_ERROR_DEVICE_HAS_ACTIVATED    252//�豸�Ѽ���


// ���ܴ�����
#define VCA_ERROR_INDEX                     300 // ���ܴ���������
#define NET_DVR_ID_ERROR                    (VCA_ERROR_INDEX + 0)   // ����ID������
#define NET_DVR_POLYGON_ERROR               (VCA_ERROR_INDEX + 1)   // ����β����Ҫ��
#define NET_DVR_RULE_PARAM_ERROR            (VCA_ERROR_INDEX + 2)   // ����������
#define NET_DVR_RULE_CFG_CONFLICT           (VCA_ERROR_INDEX + 3)   // ������Ϣ��ͻ
#define NET_DVR_CALIBRATE_NOT_READY         (VCA_ERROR_INDEX + 4)   // ��ǰû�б궨��Ϣ
#define NET_DVR_CAMERA_DATA_ERROR           (VCA_ERROR_INDEX + 5)   // �����������
#define NET_DVR_CALIBRATE_DATA_UNFIT        (VCA_ERROR_INDEX + 6)	// ���Ȳ�����б�������ڱ궨
#define NET_DVR_CALIBRATE_DATA_CONFLICT     (VCA_ERROR_INDEX + 7)	// �궨���?��Ϊ���е㹲�߻���λ��̫����
#define NET_DVR_CALIBRATE_CALC_FAIL         (VCA_ERROR_INDEX + 8)	// �����궨����ֵ����ʧ��
#define	NET_DVR_CALIBRATE_LINE_OUT_RECT		(VCA_ERROR_INDEX + 9)	// �������궨�߳���������Ӿ��ο�
#define NET_DVR_ENTER_RULE_NOT_READY		(VCA_ERROR_INDEX + 10)	// û�����ý�������
#define NET_DVR_AID_RULE_NO_INCLUDE_LANE	(VCA_ERROR_INDEX + 11)	// ��ͨ�¼�������û�а�����������ֵӵ�º����У�
#define NET_DVR_LANE_NOT_READY				(VCA_ERROR_INDEX + 12)	// ��ǰû�����ó���
#define NET_DVR_RULE_INCLUDE_TWO_WAY		(VCA_ERROR_INDEX + 13)	// �¼������а�2�ֲ�ͬ����
#define NET_DVR_LANE_TPS_RULE_CONFLICT      (VCA_ERROR_INDEX + 14)  // ��������ݹ����ͻ
#define NET_DVR_NOT_SUPPORT_EVENT_TYPE      (VCA_ERROR_INDEX + 15)  // ��֧�ֵ��¼�����
#define NET_DVR_LANE_NO_WAY                 (VCA_ERROR_INDEX + 16)  // ����û�з���
#define NET_DVR_SIZE_FILTER_ERROR           (VCA_ERROR_INDEX + 17)  // �ߴ���˿򲻺���
#define NET_DVR_LIB_FFL_NO_FACE             (VCA_ERROR_INDEX + 18) // �����㶨λʱ�����ͼ��û������
#define NET_DVR_LIB_FFL_IMG_TOO_SMALL       (VCA_ERROR_INDEX + 19) // �����㶨λʱ�����ͼ��̫С
#define NET_DVR_LIB_FD_IMG_NO_FACE          (VCA_ERROR_INDEX + 20) // ����ͼ���������ʱ�����ͼ��û������
#define NET_DVR_LIB_FACE_TOO_SMALL          (VCA_ERROR_INDEX + 21) // ��ģʱ����̫С
#define NET_DVR_LIB_FACE_QUALITY_TOO_BAD    (VCA_ERROR_INDEX + 22) // ��ģʱ����ͼ������̫��
#define NET_DVR_KEY_PARAM_ERR               (VCA_ERROR_INDEX + 23) //�߼��������ô���
#define NET_DVR_CALIBRATE_DATA_ERR          (VCA_ERROR_INDEX + 24) //�궨����Ŀ���󣬻����ֵ���󣬻���㳬����ƽ��
#define NET_DVR_CALIBRATE_DISABLE_FAIL      (VCA_ERROR_INDEX + 25) //�����ù�������ȡ��궨
#define NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE   (VCA_ERROR_INDEX + 26) //�����˿�Ŀ����Сֵ������С���˿�Ŀ�����ֵ��������
#define NET_DVR_LIB_FD_REGION_TOO_LARGE     (VCA_ERROR_INDEX + 27) //��ǰ�������Χ��󡣼�������Ϊͼ���2/3
#define NET_DVR_TRIAL_OVERDUE               (VCA_ERROR_INDEX + 28) //���ð��������ѽ���
#define NET_DVR_CONFIG_FILE_CONFLICT        (VCA_ERROR_INDEX + 29) //�豸�����������ļ���ͻ�����ܹ����������з��������ò����������ʾ��
//�㷨����ش�����
#define NET_DVR_FR_FPL_FAIL                 (VCA_ERROR_INDEX + 30)   // ���������㶨λʧ��
#define NET_DVR_FR_IQA_FAIL                 (VCA_ERROR_INDEX + 31)   // ��������ʧ��
#define NET_DVR_FR_FEM_FAIL                 (VCA_ERROR_INDEX + 32)   // ����������ȡʧ��
#define NET_DVR_FPL_DT_CONF_TOO_LOW         (VCA_ERROR_INDEX + 33)   // �����㶨λʱ����������Ŷȹ��
#define NET_DVR_FPL_CONF_TOO_LOW            (VCA_ERROR_INDEX + 34)   // �����㶨λ���Ŷȹ��
#define NET_DVR_E_DATA_SIZE                 (VCA_ERROR_INDEX + 35)  // ��ݳ��Ȳ�ƥ��
#define NET_DVR_FR_MODEL_VERSION_ERR        (VCA_ERROR_INDEX + 36)  // ����ģ������е�ģ�Ͱ汾����
#define NET_DVR_FR_FD_FAIL                  (VCA_ERROR_INDEX + 37)  // ʶ������������ʧ��
#define NET_DVR_FA_NORMALIZE_ERR            (VCA_ERROR_INDEX + 38)  // ������һ������
//���������
#define NET_DVR_DOG_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 39)  // ���ܹ���ǰ��ȡ���豸���Ͳ�ƥ��
#define NET_DVR_DEV_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 40)  // ǰ��ȡ���豸�汾��ƥ��
#define NET_DVR_PUSTREAM_ALREADY_EXISTS     (VCA_ERROR_INDEX + 41)  // �豸������ͨ���Ѿ���ӹ��ǰ���豸
#define NET_DVR_SEARCH_CONNECT_FAILED       (VCA_ERROR_INDEX + 42)  // ���Ӽ���������ʧ��
#define NET_DVR_INSUFFICIENT_DISK_SPACE     (VCA_ERROR_INDEX + 43)  // �ɴ洢��Ӳ�̿ռ䲻��
#define NET_DVR_DATABASE_CONNECTION_FAILED  (VCA_ERROR_INDEX + 44)  // ��ݿ�����ʧ��
#define NET_DVR_DATABASE_ADM_PW_ERROR       (VCA_ERROR_INDEX + 45)  // ��ݿ��û����������
#define NET_DVR_DECODE_YUV                  (VCA_ERROR_INDEX + 46)  // ����ʧ��

#define NET_DVR_RTSP_ERROR_NOENOUGHPRI          401  //��Ȩ�ޣ�����������401ʱ��ת�����������
#define NET_DVR_RTSP_ERROR_ALLOC_RESOURCE       402  //������Դʧ��
#define NET_DVR_RTSP_ERROR_PARAMETER            403  //�������
#define NET_DVR_RTSP_ERROR_NO_URL               404  //ָ����URL��ַ�����ڣ�����������404ʱ��ת�����������
#define NET_DVR_RTSP_ERROR_FORCE_STOP           406  //�û���;ǿ���˳�

#define NET_DVR_RTSP_GETPORTFAILED			    407  //rtsp �õ��˿ڴ���
#define NET_DVR_RTSP_DESCRIBERROR			    410  //rtsp decribe ��������
#define NET_DVR_RTSP_DESCRIBESENDTIMEOUT		411  //rtsp decribe ���ͳ�ʱ
#define NET_DVR_RTSP_DESCRIBESENDERROR			412  //rtsp decribe ����ʧ��
#define NET_DVR_RTSP_DESCRIBERECVTIMEOUT		413  //rtsp decribe ���ճ�ʱ
#define NET_DVR_RTSP_DESCRIBERECVDATALOST		414  //rtsp decribe ������ݴ���
#define NET_DVR_RTSP_DESCRIBERECVERROR			415  //rtsp decribe ����ʧ��
#define NET_DVR_RTSP_DESCRIBESERVERERR			416  //rtsp decribe ���������ش���״̬

#define NET_DVR_RTSP_SETUPERROR			        420  //rtsp setup ��������
#define NET_DVR_RTSP_SETUPSENDTIMEOUT			421  //rtsp setup ���ͳ�ʱ
#define NET_DVR_RTSP_SETUPSENDERROR				422  //rtsp setup ���ʹ���
#define NET_DVR_RTSP_SETUPRECVTIMEOUT			423  //rtsp setup ���ճ�ʱ
#define NET_DVR_RTSP_SETUPRECVDATALOST			424  //rtsp setup ������ݴ���
#define NET_DVR_RTSP_SETUPRECVERROR				425  //rtsp setup ����ʧ��
#define NET_DVR_RTSP_OVER_MAX_CHAN				426  //��������������������߷�������Դ���㣬����������453ʱ��ת����������롣
#define NET_DVR_RTSP_SETUPSERVERERR			    427  //rtsp setup ���������ش���״̬

#define NET_DVR_RTSP_PLAYERROR			        430  //rtsp play ��������
#define NET_DVR_RTSP_PLAYSENDTIMEOUT			431  //rtsp play ���ͳ�ʱ
#define NET_DVR_RTSP_PLAYSENDERROR				432  //rtsp play ���ʹ���
#define NET_DVR_RTSP_PLAYRECVTIMEOUT			433  //rtsp play ���ճ�ʱ
#define NET_DVR_RTSP_PLAYRECVDATALOST			434  //rtsp play ������ݴ���
#define NET_DVR_RTSP_PLAYRECVERROR				435  //rtsp play ����ʧ��
#define NET_DVR_RTSP_PLAYSERVERERR				436  //rtsp play ���������ش���״̬

#define NET_DVR_RTSP_TEARDOWNERROR			    440  //rtsp teardown ��������
#define NET_DVR_RTSP_TEARDOWNSENDTIMEOUT		441  //rtsp teardown ���ͳ�ʱ
#define NET_DVR_RTSP_TEARDOWNSENDERROR			442  //rtsp teardown ���ʹ���
#define NET_DVR_RTSP_TEARDOWNRECVTIMEOUT		443  //rtsp teardown ���ճ�ʱ
#define NET_DVR_RTSP_TEARDOWNRECVDATALOST		444  //rtsp teardown ������ݴ���
#define NET_DVR_RTSP_TEARDOWNRECVERROR			445  //rtsp teardown ����ʧ��
#define NET_DVR_RTSP_TEARDOWNSERVERERR			446  //rtsp teardown ���������ش���״̬

#define  NET_PLAYM4_NOERROR					    500	//no error
#define	 NET_PLAYM4_PARA_OVER				    501	//input parameter is invalid;
#define  NET_PLAYM4_ORDER_ERROR				    502	//The order of the function to be called is error.
#define	 NET_PLAYM4_TIMER_ERROR				    503	//Create multimedia clock failed;
#define  NET_PLAYM4_DEC_VIDEO_ERROR			    504	//Decode video data failed.
#define  NET_PLAYM4_DEC_AUDIO_ERROR			    505	//Decode audio data failed.
#define	 NET_PLAYM4_ALLOC_MEMORY_ERROR		    506	//Allocate memory failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR			    507	//Open the file failed.
#define  NET_PLAYM4_CREATE_OBJ_ERROR		    508	//Create thread or event failed
#define  NET_PLAYM4_CREATE_DDRAW_ERROR		    509	//Create DirectDraw object failed.
#define  NET_PLAYM4_CREATE_OFFSCREEN_ERROR      510	//failed when creating off-screen surface.
#define  NET_PLAYM4_BUF_OVER			        511	//buffer is overflow
#define  NET_PLAYM4_CREATE_SOUND_ERROR	        512	//failed when creating audio device.
#define	 NET_PLAYM4_SET_VOLUME_ERROR	        513	//Set volume failed
#define  NET_PLAYM4_SUPPORT_FILE_ONLY	        514	//The function only support play file.
#define  NET_PLAYM4_SUPPORT_STREAM_ONLY	        515	//The function only support play stream.
#define  NET_PLAYM4_SYS_NOT_SUPPORT		        516	//System not support.
#define  NET_PLAYM4_FILEHEADER_UNKNOWN          517	//No file header.
#define  NET_PLAYM4_VERSION_INCORRECT	        518	//The version of decoder and encoder is not adapted.
#define  NET_PALYM4_INIT_DECODER_ERROR          519	//Initialize decoder failed.
#define  NET_PLAYM4_CHECK_FILE_ERROR	        520	//The file data is unknown.
#define  NET_PLAYM4_INIT_TIMER_ERROR	        521	//Initialize multimedia clock failed.
#define	 NET_PLAYM4_BLT_ERROR			        522	//Blt failed.
#define  NET_PLAYM4_UPDATE_ERROR		        523	//Update failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR_MULTI       524   //openfile error, streamtype is multi
#define  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO       525   //openfile error, streamtype is video
#define  NET_PLAYM4_JPEG_COMPRESS_ERROR         526   //JPEG compress error
#define  NET_PLAYM4_EXTRACT_NOT_SUPPORT         527	//Don't support the version of this file.
#define  NET_PLAYM4_EXTRACT_DATA_ERROR          528	//extract video data failed.

//ת��װ�������
#define  NET_CONVERT_ERROR_NOT_SUPPORT          581  //convert not support

//�����Խ��������
#define  NET_AUDIOINTERCOM_OK                   600  //�޴���
#define  NET_AUDIOINTECOM_ERR_NOTSUPORT         601 //��֧��
#define  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY      602 //�ڴ��������
#define  NET_AUDIOINTECOM_ERR_PARAMETER			603 //�������
#define  NET_AUDIOINTECOM_ERR_CALL_ORDER        604 //���ô������
#define  NET_AUDIOINTECOM_ERR_FIND_DEVICE       605 //δ�����豸
#define  NET_AUDIOINTECOM_ERR_OPEN_DEVICE       606 //���ܴ��豸��
#define  NET_AUDIOINTECOM_ERR_NO_CONTEXT        607 //�豸�����ĳ���
#define  NET_AUDIOINTECOM_ERR_NO_WAVFILE        608 //WAV�ļ�����
#define  NET_AUDIOINTECOM_ERR_INVALID_TYPE      609 //��Ч��WAV��������
#define  NET_AUDIOINTECOM_ERR_ENCODE_FAIL       610 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_DECODE_FAIL       611 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_NO_PLAYBACK       612 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_DENOISE_FAIL      613 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_UNKOWN            619 //δ֪����

#define NET_QOS_OK								 700					//no error
#define NET_QOS_ERROR							 (NET_QOS_OK - 1)		//qos error
#define NET_QOS_ERR_INVALID_ARGUMENTS			 (NET_QOS_OK - 2)		//invalid arguments
#define NET_QOS_ERR_SESSION_NOT_FOUND			 (NET_QOS_OK - 3)		//session net found
#define NET_QOS_ERR_LIB_NOT_INITIALIZED          (NET_QOS_OK - 4)		//lib not initialized
#define NET_QOS_ERR_OUTOFMEM                     (NET_QOS_OK - 5)		//outtofmem
#define NET_QOS_ERR_PACKET_UNKNOW                (NET_QOS_OK - 10)		//packet unknow
#define NET_QOS_ERR_PACKET_VERSION               (NET_QOS_OK - 11)		//packet version error
#define NET_QOS_ERR_PACKET_LENGTH                (NET_QOS_OK - 12)		//packet length error
#define NET_QOS_ERR_PACKET_TOO_BIG               (NET_QOS_OK - 13)		//packet too big
#define NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH (NET_QOS_OK - 20)		//schedparams invalid bandwidth
#define NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION      (NET_QOS_OK - 21)		//schedparams bad fraction
#define NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL (NET_QOS_OK - 22)	//schedparams bad minimum interval

#define NET_ERROR_TRUNK_LINE						711 //��ϵͳ�ѱ���ɸ���
#define NET_ERROR_MIXED_JOINT						712 //���ܽ��л��ƴ��
#define NET_ERROR_DISPLAY_SWITCH					713 //���ܽ�����ʾͨ���л�
#define NET_ERROR_USED_BY_BIG_SCREEN				714 //������Դ������ռ��
#define NET_ERROR_USE_OTHER_DEC_RESOURCE			715 //����ʹ�����������ϵͳ��Դ
#define NET_ERROR_DISP_MODE_SWITCH                  716 //��ʾͨ����ʾ״̬�л���
#define NET_ERROR_SCENE_USING						717	//��������ʹ��
#define NET_ERR_NO_ENOUGH_DEC_RESOURCE              718 //������Դ����
#define NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE        719 //������Դ����
#define NET_ERR_NO_ENOUGH_VIDEO_MEMORY              720 //�Դ���Դ����
#define NET_ERR_MAX_VIDEO_NUM                       721 //һ�϶���Դ����
#define NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL      722 //���ڿ�Խ�˳�������ںͷǳ��������
#define NET_ERR_FREE_SHOW_WIN_SPLIT                 723 //���Դ��ڲ�֧�ַ���
#define NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW         724 //�������������Ĵ��ڲ�֧�ֿ�������
#define NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT   725 //����͸���ȵĴ��ڲ�֧�ַ���
#define NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT   726 //����������Ĵ��ڲ�֧��͸��������
#define NET_ERR_MAX_LOGO_NUM                        727 //logo��ﵽ����
#define NET_ERR_MAX_WIN_LOOP_NUM                    728 //��Ѳ������ﵽ����
#define NET_ERR_VIRTUAL_LED_VERTICAL_CROSS          729 //����LED�����������
#define NET_ERR_MAX_VIRTUAL_LED_HEIGHT              730 //����LED�߶ȳ���
#define NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER       731 //����LED���ݰ�Ƿ��ַ�
#define NET_ERR_BASEMAP_NOT_EXIST                   732 //��ͼͼƬ������
#define NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED         733 //LED��Ļ��֧������LED
#define NET_ERR_LED_RESOLUTION_NOT_SUPPORT          734 //LED�ֱ��ʲ�֧��
#define NET_ERR_PLAN_OVERDUE                        735	//Ԥ�����ڣ������ٵ���

#define NET_ERR_TERMINAL_BUSY						780	//�ն�æ���ն˴��ڻ�����

#define NET_ERR_DATA_RETURNED_ILLEGAL               790 //�豸���ص���ݲ��Ϸ�


#define NET_DVR_DEV_NET_OVERFLOW		            800	//�������������豸��������
#define NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK  801 //¼���ļ���¼���޷�����
#define NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK      802 //����Ӳ��̫С�޷���ʽ��

//N+1������
#define NET_SDK_ERR_REMOTE_DISCONNECT				803 //Զ���޷�����
#define NET_SDK_ERR_RD_ADD_RD						804 //��������ӱ���
#define NET_SDK_ERR_BACKUP_DISK_EXCEPT				805 //�������쳣
#define NET_SDK_ERR_RD_LIMIT						806 //�������Ѵ�����
#define NET_SDK_ERR_ADDED_RD_IS_WD					807 //��ӵı����ǹ�����
#define NET_SDK_ERR_ADD_ORDER_WRONG					808 //���˳����?����û�б����������Ϊ�������ӹ�����
#define NET_SDK_ERR_WD_ADD_WD						809 //����������ӹ�����
#define NET_SDK_ERR_WD_SERVICE_EXCETP				810 //������CVR�����쳣
#define NET_SDK_ERR_RD_SERVICE_EXCETP				811 //����CVR�����쳣
#define NET_SDK_ERR_ADDED_WD_IS_RD					812 //��ӵĹ������Ǳ���
#define NET_SDK_ERR_PERFORMANCE_LIMIT				813 //���ܴﵽ����
#define NET_SDK_ERR_ADDED_DEVICE_EXIST				814 //��ӵ��豸�Ѿ�����

//��Ѷ�������
#define NET_SDK_ERR_INQUEST_RESUMING				815 //��Ѷ�ָ���
#define NET_SDK_ERR_RECORD_BACKUPING				816 //��Ѷ������
#define NET_SDK_ERR_DISK_PLAYING					817 //���̻ط���
#define NET_SDK_ERR_INQUEST_STARTED					818 //��Ѷ�ѿ���
#define NET_SDK_ERR_LOCAL_OPERATING					819 //���ز���������
#define NET_SDK_ERR_INQUEST_NOT_START				820 //��Ѷδ����
//Netra3.1.0������
#define NET_SDK_ERR_CHAN_AUDIO_BIND                 821  //ͨ��δ�󶨻�������Խ�ʧ��
//�ƴ洢������
#define NET_DVR_N_PLUS_ONE_MODE                     822 //�豸��ǰ����N+1ģʽ
#define NET_DVR_CLOUD_STORAGE_OPENED                823 //�ƴ洢ģʽ�ѿ���

#define NET_DVR_ERR_OPER_NOT_ALLOWED                824   //�豸����N+0���ӹ�״̬��������ò���
#define NET_DVR_ERR_NEED_RELOCATE	                825   //�豸����N+0���ӹ�״̬����Ҫ��ȡ�ض�����Ϣ�������²���

//ͥ�����������
#define NET_SDK_ERR_IR_PORT_ERROR                   830 //��������ڴ���
#define NET_SDK_ERR_IR_CMD_ERROR                    831 //��������ڵ�����Ŵ���
#define NET_SDK_ERR_NOT_INQUESTING                  832 //�豸���ڷ���Ѷ״̬
#define NET_SDK_ERR_INQUEST_NOT_PAUSED              833 //�豸���ڷ���ͣ״̬
//2011-10-25���������������루900-950��
#define  NET_ERR_CUT_INPUTSTREAM_OVERLIMIT       	900 //�ź�Դ�ü���ֵ����
#define  NET_ERR_WINCHAN_IDX				        901	// ����ͨ���Ŵ���
#define  NET_ERR_WIN_LAYER						    902	// ���ڲ�����󣬵�����Ļ����า�ǵĴ��ڲ���
#define  NET_ERR_WIN_BLK_NUM			            903	// ���ڵĿ�����󣬵������ڿɸ��ǵ���Ļ����
#define  NET_ERR_OUTPUT_RESOLUTION	                904	// ����ֱ��ʴ���
#define  NET_ERR_LAYOUT							    905	// ���ֺŴ���
#define  NET_ERR_INPUT_RESOLUTION    	            906 // ����ֱ��ʲ�֧��
#define  NET_ERR_SUBDEVICE_OFFLINE                  907 // ���豸������
#define  NET_ERR_NO_DECODE_CHAN                     908 // û�п��н���ͨ��
#define  NET_ERR_MAX_WINDOW_ABILITY                 909 // ������������, �ֲ�ʽ�����������н������豸�������޻�����ʾ�������������޵���
#define  NET_ERR_ORDER_ERROR                        910 // ����˳������
#define  NET_ERR_PLAYING_PLAN    					911 // ����ִ��Ԥ��
#define  NET_ERR_DECODER_USED						912 // ���������ʹ��
#define	 NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW			913	// ��������������
#define	 NET_ERR_SAME_USER_NAME						914	// �û�����ͬ
#define	 NET_ERR_INVALID_USER_NAME					915	// ��Ч�û���
#define	 NET_ERR_MATRIX_USING						916	// �����������ʹ��
#define	 NET_ERR_DIFFERENT_CHAN_TYPE				917	// ͨ�����Ͳ�ͬ���������ͨ���Ϳ�����������Ϊ��ͬ�����ͣ�
#define	 NET_ERR_INPUT_CHAN_BINDED					918	// ����ͨ���Ѿ�����������
#define	 NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW		919	// ����ʹ�õľ������ͨ������������������󶨵�ͨ������
#define	 NET_ERR_MAX_SIGNAL_NUM						920	// �����ź�Դ����ﵽ����
#define  NET_ERR_INPUT_CHAN_USING					921	// ����ͨ������ʹ��
#define  NET_ERR_MANAGER_LOGON 					    922	// ����Ա�Ѿ���½������ʧ��
#define  NET_ERR_USERALREADY_LOGON 				    923	// ���û��Ѿ���½������ʧ��
#define  NET_ERR_LAYOUT_INIT 						924	// �������ڳ�ʼ��������ʧ��
#define	 NET_ERR_BASEMAP_SIZE_NOT_MATCH				925	// ��ͼ��С����
#define  NET_ERR_WINDOW_OPERATING					926	// ��������ִ��������������β���ʧ��
#define  NET_ERR_SIGNAL_UPLIMIT						927 // �ź�Դ��������ﵽ����
#define  NET_ERR_SIGNAL_MAX_ENLARGE_TIMES           928 // �ź�Դ�Ŵ�����
#define  NET_ERR_ONE_SIGNAL_MULTI_CROSS             929 // �����ź�Դ���ܶ�ο���
#define  NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN          930 // �������ź�Դ�����ظ�����
#define  NET_ERR_MAX_VIRTUAL_LED_WIDTH              931 //����LED��ȴ�������ֵ
#define  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN           932 //����LED�ַ����������ֵ
#define	 NET_ERR_SINGLE_OUTPUTPARAM_CONFIG			933//��֧�ֵ�����ʾ�����������
#define  NET_ERR_MULTI_WIN_BE_COVER     			934//��������ڱ�����
#define  NET_ERR_WIN_NOT_EXIST						935 //���ڲ�����
#define  NET_ERR_WIN_MAX_SIGNALSOURCE				936//�����ź�Դ�������ֵ
#define  NET_ERR_MULTI_WIN_MOVE						937//�Զ���������ƶ�
#define  NET_ERR_MULTI_WIN_YPBPR_SDI				938 // YPBPR ��SDI�ź�Դ��֧��9/16����
#define  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE			939  //��ͬ�����������
#define  NET_ERR_SPLIT_WIN_CROSS					940//�Կ������ڷ���
#define  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN			941  //��δ�������ڷ���
#define  NET_ERR_SPLIT_WIN_MANY_WIN					942  //�Ե�����������ж�����ڵĴ��ڷ���
#define  NET_ERR_WINDOW_SIZE_OVERLIMIT              943   //���ڴ�С����
#define  NET_ERR_INPUTSTREAM_ALREADY_JOINT       	944    //�ź�Դ�Ѽ���ƴ��
#define  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT      	945    //ƴ���ź�Դ������

#define  NET_ERR_LED_RESOLUTION						946  //LED �ֱ��ʴ�������ֱ���
#define  NET_ERR_JOINT_SCALE_OVERLIMIT              947  //ƴ���ź�Դ�Ĺ�ģ����
#define  NET_ERR_INPUTSTREAM_ALREADY_DECODE			948  //�ź�Դ����ǽ
#define  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE     949  //�ź�Դ��֧��ץͼ
#define  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN			950  //ƴ���ź�Դ��֧�ַ���

//�����������루951-999��
#define NET_ERR_MAX_WIN_OVERLAP						951 //�ﵽ��󴰿��ص���
#define NET_ERR_STREAMID_CHAN_BOTH_VALID			952 //stream ID��ͨ����ͬʱ��Ч
#define NET_ERR_NO_ZERO_CHAN						953 //�豸����ͨ��
#define NEED_RECONNECT								955 //��Ҫ�ض���ת����ϵͳʹ�ã�
#define NET_ERR_NO_STREAM_ID						956 //��ID������
#define NET_DVR_TRANS_NOT_START						957 //ת��δ����
#define NET_ERR_MAXNUM_STREAM_ID					958 //��ID��ﵽ����
#define NET_ERR_WORKMODE_MISMATCH					959 //����ģʽ��ƥ��
#define NET_ERR_MODE_IS_USING						960 //�ѹ����ڵ�ǰģʽ
#define NET_ERR_DEV_PROGRESSING						961 //�豸���ڴ�����
#define NET_ERR_PASSIVE_TRANSCODING					962 //���ڱ���ת��

#define NET_ERR_RING_NOT_CONFIGURE       			964 //����δ����

//�����������������
#define XML_ABILITY_NOTSUPPORT                      1000  //��֧�������ڵ��ȡ
#define	XML_ANALYZE_NOENOUGH_BUF				    1001		//����ڴ治��
#define	XML_ANALYZE_FIND_LOCALXML_ERROR			    1002		//�޷��ҵ���Ӧ�ı���xml
#define	XML_ANALYZE_LOAD_LOCALXML_ERROR			    1003		//���ر���xml����
#define	XML_NANLYZE_DVR_DATA_FORMAT_ERROR		    1004		//�豸������ݸ�ʽ����
#define	XML_ANALYZE_TYPE_ERROR					    1005		//���������ʹ���
#define	XML_ANALYZE_XML_NODE_ERROR				    1006		//XML�����ڵ��ʽ����
#define XML_INPUT_PARAM_ERROR                       1007  //���������XML�ڵ�ֵ����

//���ô����루1100��1200��
#define NET_ERR_PLT_USERID                          1100 //��֤ƽ̨userid����
#define NET_ERR_TRANS_CHAN_START                    1101 //͸��ͨ���Ѵ򿪣���ǰ�����޷����
#define NET_ERR_DEV_UPGRADING						1102 //�豸������
#define NET_ERR_MISMATCH_UPGRADE_PACK_TYPE          1103 //������Ͳ�ƥ��
#define NET_ERR_DEV_FORMATTING                      1104 //�豸���ڸ�ʽ��
#define NET_ERR_MISMATCH_UPGRADE_PACK_VERSION       1105 //���汾��ƥ��

//2012-10-16 �����豸�����루1200~1300��
#define NET_ERR_SEARCHING_MODULE                    1201 // �����������ģ��
#define NET_ERR_REGISTERING_MODULE                  1202 // ����ע�����ģ��
#define NET_ERR_GETTING_ZONES						1203 // ���ڻ�ȡ�������
#define NET_ERR_GETTING_TRIGGERS					1204 // ���ڻ�ȡ������
#define NET_ERR_ARMED_STATUS						1205 // ϵͳ���ڲ���״̬
#define	NET_ERR_PROGRAM_MODE_STATUS					1206 // ϵͳ���ڱ��ģʽ
#define	NET_ERR_WALK_TEST_MODE_STATUS				1207 // ϵͳ���ڲ���ģʽ
#define	NET_ERR_BYPASS_STATUS						1208 // ��·״̬
#define NET_ERR_DISABLED_MODULE_STATUS				1209 // ����δʹ��
#define	NET_ERR_NOT_SUPPORT_OPERATE_ZONE			1210 // ����֧�ָò���
#define NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR			1211 // ģ���ַ���ܱ��޸�
#define NET_ERR_UNREGISTERED_MODULE					1212 // ģ��δע��
#define NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF		1213 // ������ϵͳ��������
#define NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM		1214 // ������ϵͳ����������
#define NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM	1215 // ��ϵͳ��������ϵͳ����
#define	NET_ERR_ZONE_FAULT_STATUS					1216 // �����ڹ���״̬
#define NET_ERR_SAME_EVENT_TYPE					1217 // �¼�������������������¼�������������ر�������ͬ�¼�����
#define NET_ERR_ZONE_ALARM_STATUS					1218 // �����ڱ���״̬
#define NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT			1219 //��չ���߶�·
#define NET_ERR_PWD_CONFLICT                        1220  //�����ͻ

//��Ϣ��������
#define NET_ERR_GET_ALL_RETURN_OVER					1300  //��ȡ���з�����Ŀ����
#define NET_ERR_RESOURCE_USING                      1301  //��Ϣ������Դ����ʹ�ã������޸�
#define NET_ERR_FILE_SIZE_OVERLIMIT	                1302  //�ļ���С����


//2012-12-20ץ�Ļ�����루1400-1499��
#define NET_DVR_ERR_LANENUM_EXCEED                  1400  //�����������
#define NET_DVR_ERR_PRAREA_EXCEED                   1401  //��ʶ������
#define NET_DVR_ERR_LIGHT_PARAM                     1402  //�źŵƽ���������
#define NET_DVR_ERR_LANE_LINE_INVALID               1403  //���������ô���
#define NET_DVR_ERR_STOP_LINE_INVALID               1404  //ֹͣ�����ô���
#define NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID        1405  //��/��ת�ֽ������ô���
#define NET_DVR_ERR_LANE_NO_REPEAT                  1406  //���ӳ������ظ�
#define NET_DVR_ERR_PRAREA_INVALID                  1407  //��ʶ����β����Ҫ��
#define NET_DVR_ERR_LIGHT_NUM_EXCEED                1408  //��Ƶ��⽻ͨ���źŵ���Ŀ�������ֵ
#define NET_DVR_ERR_SUBLIGHT_NUM_INVALID            1409  //��Ƶ��⽻ͨ���źŵ��ӵ���Ŀ���Ϸ�
#define NET_DVR_ERR_LIGHT_AREASIZE_INVALID          1410  //��Ƶ��⽻ͨ�������źŵƿ��С���Ϸ�
#define NET_DVR_ERR_LIGHT_COLOR_INVALID             1411  //��Ƶ��⽻ͨ�������źŵ���ɫ���Ϸ�
#define NET_DVR_ERR_LIGHT_DIRECTION_INVALID         1412  //��Ƶ��⽻ͨ������Ʒ������Բ��Ϸ�
#define NET_DVR_ERR_LACK_IOABLITY					1413  //IO��ʵ��֧�ֵ���������

#define NET_DVR_ERR_FTP_PORT                        1414  //FTP�˿ںŷǷ����˿ں��ظ������쳣��
#define NET_DVR_ERR_FTP_CATALOGUE                   1415  //FTPĿ¼��Ƿ������ö༶Ŀ¼���༶Ŀ¼��ֵΪ�գ�
#define NET_DVR_ERR_FTP_UPLOAD_TYPE                 1416  //FTP�ϴ����ͷǷ�����ftpֻ֧��ȫ��/˫ftpֻ֧�ֿ��ں�Υ�£�
#define NET_DVR_ERR_FLASH_PARAM_WRITE               1417  //���ò���ʱдFLASHʧ��
#define NET_DVR_ERR_FLASH_PARAM_READ                1418  //���ò���ʱ��FLASHʧ��
#define NET_DVR_ERR_PICNAME_DELIMITER               1419  //FTPͼƬ����ָ���Ƿ�
#define NET_DVR_ERR_PICNAME_ITEM                    1420  //FTPͼƬ������Ƿ������� �ָ���
#define NET_DVR_ERR_PLATE_RECOGNIZE_TYPE            1421  //��ʶ�������ͷǷ� �����κͶ������Ч��У�飩
#define NET_DVR_ERR_CAPTURE_TIMES                   1422  //ץ�Ĵ���Ƿ� ����Чֵ��0��5��
#define NET_DVR_ERR_LOOP_DISTANCE                   1423  //��Ȧ����Ƿ� ����Чֵ��0��2000ms��
#define NET_DVR_ERR_LOOP_INPUT_STATUS               1424  //��Ȧ����״̬�Ƿ� ����Чֵ��
#define NET_DVR_ERR_RELATE_IO_CONFLICT              1425  //������IO������ͻ
#define NET_DVR_ERR_INTERVAL_TIME                   1426  //���ļ��ʱ��Ƿ� ��0��6000ms��
#define NET_DVR_ERR_SIGN_SPEED                      1427  //��־����ֵ�Ƿ����󳵱�־���ٲ��ܴ���С����־���� ��
#define NET_DVR_ERR_PIC_FLIP                        1428  //ͼ�����÷�ת �����ý���Ӱ�죩
#define NET_DVR_ERR_RELATE_LANE_NUMBER              1429  //������������� (�ظ� ��ЧֵУ��1��99)
#define NET_DVR_ERR_TRIGGER_MODE                    1430  //����ץ�Ļ�ģʽ�Ƿ�
#define NET_DVR_ERR_DELAY_TIME                      1431  //������ʱʱ�����(2000ms)
#define NET_DVR_ERR_EXCEED_RS485_COUNT              1432  //�������485��������
#define NET_DVR_ERR_RADAR_TYPE                      1433  //�״����ʹ���
#define NET_DVR_ERR_RADAR_ANGLE                     1434  //�״�Ƕȴ���
#define NET_DVR_ERR_RADAR_SPEED_VALID_TIME          1435  //�״���Чʱ�����
#define NET_DVR_ERR_RADAR_LINE_CORRECT              1436  //�״����Խ���������
#define NET_DVR_ERR_RADAR_CONST_CORRECT             1437  //�״ﳣ������������
#define NET_DVR_ERR_RECORD_PARAM                    1438  //¼�������Ч��Ԥ¼ʱ�䲻����10s��
#define NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION 1439   //��Ƶ����źŵ������źŵƸ�����û�й�ѡ�źŵƷ������ɫ��
#define NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION   1440   //��Ƶ����źŵ������źŵƸ�����û�л��������
#define NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM         1441   //��ʶ����ʡ�ݲ���ĺϷ���

#define NET_DVR_ERR_SPEED_TIMEOUT                 1442	//IO���ٳ�ʱʱ��Ƿ�����Чֵ����0��
#define NET_DVR_ERR_NTP_TIMEZONE                  1443	//ntpʱ��������
#define NET_DVR_ERR_NTP_INTERVAL_TIME             1444	//ntpУʱ�������
#define NET_DVR_ERR_NETWORK_CARD_NUM              1445	//����������Ŀ����
#define NET_DVR_ERR_DEFAULT_ROUTE                 1446	//Ĭ��·�ɴ���
#define NET_DVR_ERR_BONDING_WORK_MODE             1447	//bonding����ģʽ����
#define NET_DVR_ERR_SLAVE_CARD                    1448	//slave�����
#define NET_DVR_ERR_PRIMARY_CARD                  1449	//Primary�����
#define NET_DVR_ERR_DHCP_PPOE_WORK                1450	//dhcp��pppoE����ͬʱ����
#define NET_DVR_ERR_NET_INTERFACE                 1451	//����ӿڴ���
#define NET_DVR_ERR_MTU                           1452	//MTU����
#define NET_DVR_ERR_NETMASK                       1453	//�����������
#define NET_DVR_ERR_IP_INVALID                    1454	//IP��ַ���Ϸ�
#define NET_DVR_ERR_MULTICAST_IP_INVALID          1455	//�ಥ��ַ���Ϸ�
#define NET_DVR_ERR_GATEWAY_INVALID               1456	//��ز��Ϸ�
#define NET_DVR_ERR_DNS_INVALID                   1457	//DNS���Ϸ�
#define NET_DVR_ERR_ALARMHOST_IP_INVALID          1458	//�澯�����ַ���Ϸ�
#define NET_DVR_ERR_IP_CONFLICT                   1459	//IP��ͻ
#define NET_DVR_ERR_NETWORK_SEGMENT               1460	//IP��֧��ͬ���
#define NET_DVR_ERR_NETPORT                       1461	//�˿ڴ���

#define NET_DVR_ERR_PPPOE_NOSUPPORT               1462  //PPPOE��֧��
#define NET_DVR_ERR_DOMAINNAME_NOSUPPORT          1463  //����֧��
#define NET_DVR_ERR_NO_SPEED                      1464  //δ���ò��ٹ���
#define NET_DVR_ERR_IOSTATUS_INVALID              1465  //IO״̬����
#define NET_DVR_ERR_BURST_INTERVAL_INVALID        1466  //���ļ���Ƿ�
#define NET_DVR_ERR_RESERVE_MODE                  1467  //����ģʽ����

#define NET_DVR_ERR_LANE_NO                       1468  //���ӳ����Ŵ���
#define NET_DVR_ERR_COIL_AREA_TYPE                1469  //��Ȧ�������ʹ���
#define NET_DVR_ERR_TRIGGER_AREA_PARAM            1470  //��������������
#define NET_DVR_ERR_SPEED_LIMIT_PARAM             1471  //Υ�����ٲ������
#define NET_DVR_ERR_LANE_PROTOCOL_TYPE            1472  //��������Э�����ʹ���

#define NET_DVR_ERR_INTERVAL_TYPE                 1473  //���ļ�����ͷǷ�
#define NET_DVR_ERR_INTERVAL_DISTANCE             1474  //���ļ������Ƿ�
#define NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE       1475  //RS485�������ͷǷ�
#define NET_DVR_ERR_RS485_ASSOCIATE_LANENO        1476  //RS485���������ŷǷ�
#define NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485   1477  //�����Ź������RS485��
#define NET_DVR_ERR_LIGHT_DETECTION_REGION        1478  //��Ƶ����źŵ������źŵƸ����Ǽ���������Ϊ0

#define NET_DVR_ERR_DN2D_NOSUPPORT            1479  //��֧��ץ��֡2D����
#define NET_DVR_ERR_IRISMODE_NOSUPPORT        1480  //��֧�ֵľ�ͷ����
#define NET_DVR_ERR_WB_NOSUPPORT              1481  //��֧�ֵİ�ƽ��ģʽ
#define NET_DVR_ERR_IO_EFFECTIVENESS          1482  //IO�ڵ���Ч��
#define NET_DVR_ERR_LIGHTNO_MAX               1483  //�źŵƼ���������/�ƵƳ���(16)
#define NET_DVR_ERR_LIGHTNO_CONFLICT          1484  //�źŵƼ���������/�ƵƳ�ͻ

#define NET_DVR_ERR_CANCEL_LINE				1485  //ֱ�д�����
#define NET_DVR_ERR_STOP_LINE               1486  //������ֹͣ��
#define NET_DVR_ERR_RUSH_REDLIGHT_LINE      1487  //����ƴ�����
#define NET_DVR_ERR_IOOUTNO_MAX             1488  //IO����ڱ��Խ��

#define NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX	1489  //IO�������ǰʱ�䳬��
#define NET_DVR_ERR_IOOUTNO_IOWORKTIME      1490  //IO�������Ч����ʱ�䳬��
#define NET_DVR_ERR_IOOUTNO_FREQMULTI       1491  //IO���������ģʽ�±�Ƶ����
#define NET_DVR_ERR_IOOUTNO_DUTYRATE        1492  //IO���������ģʽ��ռ�ձȳ���
#define NET_DVR_ERR_VIDEO_WITH_EXPOSURE     1493  //��������Ч��������ʽ��֧����Ƶ
#define NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET   1494  //���������Զ�ʹ������ƽ��ڳ������Ȳ���ģʽ����Ч

#define NET_DVR_ERR_RECOGNIZE_TYPE_PARAM            1495 //ʶ�����ͷǷ� ����ʶ�������󳵡�С�����������򡢳���ʶ��ȣ�
#define NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM      1496 //��ʶ����Ƿ� ��ʶ��������ʱ�жϳ���
#define NET_DVR_ERR_PORT_CONFLICT                   1497 //�˿��г�ͻ
#define NET_DVR_ERR_LOOP_IP                         1498 //IP��������Ϊ�ػ���ַ
#define NET_DVR_ERR_DRIVELINE_SENSITIVE             1499 //ѹ�������ȳ���(��Ƶ�羯ģʽ��)


//2013-3-6VQD�����루1500��1550��
#define NET_ERR_VQD_TIME_CONFLICT					1500 //VQD���ʱ��γ�ͻ
#define NET_ERR_VQD_PLAN_NO_EXIST					1501 //VQD��ϼƻ�������
#define NET_ERR_VQD_CHAN_NO_EXIST					1502 //VQD��ص㲻����
#define NET_ERR_VQD_CHAN_MAX						1503 //VQD�ƻ����Ѵ�����
#define NET_ERR_VQD_TASK_MAX						1504 //VQD�������Ѵ�����

//ץ�Ļ������������չ(1600~1900)
#define NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES        1600 //ץ��ģʽΪƵ��ʱ���ץ������Ϊ2��(IVTģʽ��)
#define NET_DVR_ERR_REDAR_TYPE_CONFLICT             1601 //��ͬ485�ڹ����״����ͳ�ͻ
#define NET_DVR_ERR_LICENSE_PLATE_NULL              1602 //���ƺ�Ϊ��
#define NET_DVR_ERR_WRITE_DATABASE                  1603 //д����ݿ�ʧ��
#define NET_DVR_ERR_LICENSE_EFFECTIVE_TIME          1604 //������Чʱ�����
//��Ƶ�羯
#define NET_DVR_ERR_PRERECORDED_STARTTIME_LONG      1605 //Ԥ¼��ʼʱ�����Υ��ץ������
//��Ͽ���
#define NET_DVR_ERR_TRIGGER_RULE_LINE               1606 //���������ߴ���
#define NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL 1607 //��/�Ҵ����߲���ֱ
#define NET_DVR_ERR_FLASH_LAMP_MODE                 1608 //�������˸ģʽ����
#define NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM            1609 //Υ��ץ���������
#define NET_DVR_ERR_ILLEGAL_DETECTION_TYPE          1610 //Υ�¼�����ʹ���
#define NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH   1611 //���򴥷��߸߶ȴ���
#define NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS    1612 //���ģʽ��ֻ֧�ֻ����ץ������

//�Ž����������
#define NET_ERR_TIME_OVERLAP                        1900 //ʱ����ص�
#define NET_ERR_HOLIDAY_PLAN_OVERLAP                1901 //���ռƻ��ص�
#define NET_ERR_CARDNO_NOT_SORT                     1902 //����δ����
#define NET_ERR_CARDNO_NOT_EXIST                    1903 //���Ų�����
#define NET_ERR_ILLEGAL_CARDNO                      1904 //���Ŵ���
#define NET_ERR_ZONE_ALARM                          1905 //�����ڲ���״̬(�����޸Ĳ�����)
#define NET_ERR_ZONE_OPERATION_NOT_SUPPORT          1906 //����֧�ָò���
#define NET_ERR_INTERLOCK_ANTI_CONFLICT             1907 //���Ż���ͷ�Ǳ��ͬʱ���ô���
#define NET_ERR_DEVICE_CARD_FULL                    1908 //�������ﵽ10W�󷵻أ�


//���ӶԽ�������
#define NET_DVR_ERR_OUTDOOR_COMMUNICATION		    1950 //���ſڻ�ͨ���쳣
#define NET_DVR_ERR_ROOMNO_UNDEFINED				1951 //δ���÷����
#define NET_DVR_ERR_NO_CALLING		    1952 //�޺���
#define NET_DVR_ERR_RINGING				1953 //����
#define NET_DVR_ERR_IS_CALLING_NOW		1954 //����ͨ��

//��˴����� ��2100 - 3000��
#define NET_DVR_ERR_FILE_NOT_COMPLETE               2100    //���ص��ļ�������
#define NET_DVR_ERR_IPC_EXIST                       2101    //��IPC�Ѿ�����
#define NET_DVR_ERR_ADD_IPC                         2102    //��ͨ�������IPC
#define NET_DVR_ERR_OUT_OF_RES                      2103    //��������������
#define NET_DVR_ERR_CONFLICT_TO_LOCALIP             2104    //IPC��ip��ַ��DVR��ip��ַ��ͻ
#define NET_DVR_ERR_IP_SET                          2105    //�Ƿ�ip��ַ
#define NET_DVR_ERR_PORT_SET                        2106    //�Ƿ��Ķ˿ں�


/*******************ȫ�ִ����� end**********************/

/*************************************************
NET_DVR_IsSupport()����ֵ
1��9λ�ֱ��ʾ������Ϣ��λ����TRUE)��ʾ֧�֣�
**************************************************/
#define NET_DVR_SUPPORT_DDRAW			0x01//֧��DIRECTDRAW�����֧�֣��򲥷������ܹ�����
#define NET_DVR_SUPPORT_BLT				0x02//�Կ�֧��BLT���������֧�֣��򲥷������ܹ�����
#define NET_DVR_SUPPORT_BLTFOURCC		0x04//�Կ�BLT֧����ɫת�������֧�֣��������������������RGBת����
#define NET_DVR_SUPPORT_BLTSHRINKX		0x08//�Կ�BLT֧��X����С�����֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSHRINKY		0x10//�Կ�BLT֧��Y����С�����֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSTRETCHX		0x20//�Կ�BLT֧��X��Ŵ����֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSTRETCHY		0x40//�Կ�BLT֧��Y��Ŵ����֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_SSE				0x80//CPU֧��SSEָ�Intel Pentium3����֧��SSEָ�
#define NET_DVR_SUPPORT_MMX				0x100//CPU֧��MMXָ���Intel Pentium3����֧��SSEָ�

/**********************��̨�������� begin*************************/
#define LIGHT_PWRON		2	/* ��ͨ�ƹ��Դ */
#define WIPER_PWRON		3	/* ��ͨ��ˢ���� */
#define FAN_PWRON		4	/* ��ͨ���ȿ��� */
#define HEATER_PWRON	5	/* ��ͨ���������� */
#define AUX_PWRON1		6	/* ��ͨ�����豸���� */
#define AUX_PWRON2		7	/* ��ͨ�����豸���� */
#define SET_PRESET		8	/* ����Ԥ�õ� */
#define CLE_PRESET		9	/* ���Ԥ�õ� */

#define ZOOM_IN			11	/* �������ٶ�SS���(���ʱ��) */
#define ZOOM_OUT		12	/* �������ٶ�SS��С(���ʱ�С) */
#define FOCUS_NEAR      13  /* �������ٶ�SSǰ�� */
#define FOCUS_FAR       14  /* �������ٶ�SS��� */
#define IRIS_OPEN       15  /* ��Ȧ���ٶ�SS���� */
#define IRIS_CLOSE      16  /* ��Ȧ���ٶ�SS��С */

#define TILT_UP			21	/* ��̨��SS���ٶ����� */
#define TILT_DOWN		22	/* ��̨��SS���ٶ��¸� */
#define PAN_LEFT		23	/* ��̨��SS���ٶ���ת */
#define PAN_RIGHT		24	/* ��̨��SS���ٶ���ת */
#define UP_LEFT			25	/* ��̨��SS���ٶ���������ת */
#define UP_RIGHT		26	/* ��̨��SS���ٶ���������ת */
#define DOWN_LEFT		27	/* ��̨��SS���ٶ��¸�����ת */
#define DOWN_RIGHT		28	/* ��̨��SS���ٶ��¸�����ת */
#define PAN_AUTO		29	/* ��̨��SS���ٶ������Զ�ɨ�� */

#define FILL_PRE_SEQ	30	/* ��Ԥ�õ����Ѳ������ */
#define SET_SEQ_DWELL	31	/* ����Ѳ����ͣ��ʱ�� */
#define SET_SEQ_SPEED	32	/* ����Ѳ���ٶ� */
#define CLE_PRE_SEQ		33	/* ��Ԥ�õ��Ѳ��������ɾ�� */
#define STA_MEM_CRUISE	34	/* ��ʼ��¼�켣 */
#define STO_MEM_CRUISE	35	/* ֹͣ��¼�켣 */
#define RUN_CRUISE		36	/* ��ʼ�켣 */
#define RUN_SEQ			37	/* ��ʼѲ�� */
#define STOP_SEQ		38	/* ֹͣѲ�� */
#define GOTO_PRESET		39	/* ����ת��Ԥ�õ� */

#define DEL_SEQ         43  /* ɾ��Ѳ��·�� */
#define STOP_CRUISE		44	/* ֹͣ�켣 */
#define DELETE_CRUISE	45	/* ɾ�����켣 */
#define DELETE_ALL_CRUISE 46/* ɾ�����й켣 */

#define PAN_CIRCLE      50   /* ��̨��SS���ٶ��Զ�Բ��ɨ�� */
#define DRAG_PTZ        51   /* �϶�PTZ */
#define LINEAR_SCAN     52   /* ����ɨ�� */ //2014-03-15
#define CLE_ALL_PRESET  53   /* Ԥ�õ�ȫ����� */
#define CLE_ALL_SEQ     54   /* Ѳ��ȫ����� */
#define CLE_ALL_CRUISE  55   /* �켣ȫ����� */

#define POPUP_MENU      56   /* ��ʾ�����˵� */

#define TILT_DOWN_ZOOM_IN	58	/* ��̨��SS���ٶ��¸�&&�������ٶ�SS���(���ʱ��) */
#define TILT_DOWN_ZOOM_OUT  59  /* ��̨��SS���ٶ��¸�&&�������ٶ�SS��С(���ʱ�С) */
#define PAN_LEFT_ZOOM_IN	60  /* ��̨��SS���ٶ���ת&&�������ٶ�SS���(���ʱ��)*/
#define PAN_LEFT_ZOOM_OUT   61  /* ��̨��SS���ٶ���ת&&�������ٶ�SS��С(���ʱ�С)*/
#define PAN_RIGHT_ZOOM_IN	62  /* ��̨��SS���ٶ���ת&&�������ٶ�SS���(���ʱ��) */
#define PAN_RIGHT_ZOOM_OUT  63  /* ��̨��SS���ٶ���ת&&�������ٶ�SS��С(���ʱ�С) */
#define UP_LEFT_ZOOM_IN     64  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS���(���ʱ��)*/
#define UP_LEFT_ZOOM_OUT    65  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS��С(���ʱ�С)*/
#define UP_RIGHT_ZOOM_IN	66  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS���(���ʱ��)*/
#define UP_RIGHT_ZOOM_OUT   67  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS��С(���ʱ�С)*/
#define DOWN_LEFT_ZOOM_IN   68  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS���(���ʱ��) */
#define DOWN_LEFT_ZOOM_OUT  69  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS��С(���ʱ�С) */
#define DOWN_RIGHT_ZOOM_IN	70  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS���(���ʱ��) */
#define DOWN_RIGHT_ZOOM_OUT	71  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS��С(���ʱ�С) */
#define TILT_UP_ZOOM_IN	    72	/* ��̨��SS���ٶ�����&&�������ٶ�SS���(���ʱ��) */
#define TILT_UP_ZOOM_OUT	73	/* ��̨��SS���ٶ�����&&�������ٶ�SS��С(���ʱ�С) */
/**********************��̨�������� end*************************/

#define DVR_VEHICLE_CONTROL_LIST   0x1 //�����ڰ����������(���͵��������)2013-11-04


/*************************************************
�ط�ʱ���ſ�������궨��
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl�ĺ궨��
����֧�ֲ鿴����˵���ʹ���
**************************************************/
#define NET_DVR_PLAYSTART		1//��ʼ����
#define NET_DVR_PLAYSTOP		2//ֹͣ����
#define NET_DVR_PLAYPAUSE		3//��ͣ����
#define NET_DVR_PLAYRESTART		4//�ָ�����
#define NET_DVR_PLAYFAST		5//���
#define NET_DVR_PLAYSLOW		6//���
#define NET_DVR_PLAYNORMAL		7//���ٶ�
#define NET_DVR_PLAYFRAME		8//��֡��
#define NET_DVR_PLAYSTARTAUDIO	9//������
#define NET_DVR_PLAYSTOPAUDIO	10//�ر�����
#define NET_DVR_PLAYAUDIOVOLUME	11//��������
#define NET_DVR_PLAYSETPOS		12//�ı��ļ��طŵĽ��
#define NET_DVR_PLAYGETPOS		13//��ȡ�ļ��طŵĽ��
#define NET_DVR_PLAYGETTIME		14//��ȡ��ǰ�Ѿ����ŵ�ʱ��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_PLAYGETFRAME	15//��ȡ��ǰ�Ѿ����ŵ�֡��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_GETTOTALFRAMES  16//��ȡ��ǰ�����ļ��ܵ�֡��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_GETTOTALTIME    17//��ȡ��ǰ�����ļ��ܵ�ʱ��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_THROWBFRAME		20//��B֡
#define NET_DVR_SETSPEED		24//���������ٶ�
#define NET_DVR_KEEPALIVE		25//�������豸������(���ص�������2�뷢��һ��)
#define NET_DVR_PLAYSETTIME		26//�����ʱ�䶨λ
#define NET_DVR_PLAYGETTOTALLEN	27//��ȡ��ʱ��طŶ�Ӧʱ����ڵ������ļ����ܳ���
#define NET_DVR_PLAY_FORWARD    29 //�����л�Ϊ���
#define NET_DVR_PLAY_REVERSE    30 //����л�Ϊ����
#define NET_DVR_SET_DECODEFFRAMETYPE 31
#define NET_DVR_SET_TRANS_TYPE	32 //����ת���ʽ
#define NET_DVR_PLAY_CONVERT    33 //�ط�ת��
#define NET_DVR_START_DRAWFRAME 34 //��ʼ��֡�ط�
#define NET_DVR_STOP_DRAWFRAME  35 //ֹͣ��֡�ط�


#define PLAYM4_DECODE_NORMAIL              0   //�����
#define PLAYM4_DECODE_KEY_FRAME            1   //ֻ��I֡
#define PLAYM4_DECODE_NONE                 2   //ȫ����
#define PLAYM4_DECODE_TEMPORAL_LAYER_0     3   //��1/2
#define PLAYM4_DECODE_TEMPORAL_LAYER_1     4   //��1/4


//Զ�̰��������£�
/* key value send to CONFIG program */
#define KEY_CODE_1      1
#define KEY_CODE_2      2
#define KEY_CODE_3      3
#define KEY_CODE_4      4
#define KEY_CODE_5      5
#define KEY_CODE_6      6
#define KEY_CODE_7      7
#define KEY_CODE_8      8
#define KEY_CODE_9      9
#define KEY_CODE_0      10
#define KEY_CODE_POWER  11
#define KEY_CODE_MENU   12
#define KEY_CODE_ENTER  13
#define KEY_CODE_CANCEL 14
#define KEY_CODE_UP     15
#define KEY_CODE_DOWN   16
#define KEY_CODE_LEFT   17
#define KEY_CODE_RIGHT  18
#define KEY_CODE_EDIT   19
#define KEY_CODE_ADD    20
#define KEY_CODE_MINUS  21
#define KEY_CODE_PLAY   22
#define KEY_CODE_REC    23
#define KEY_CODE_PAN    24
#define KEY_CODE_M      25
#define KEY_CODE_A      26
#define KEY_CODE_F1     27
#define KEY_CODE_F2     28

/* for PTZ control */
#define KEY_PTZ_UP_START        KEY_CODE_UP
#define KEY_PTZ_UP_STOP         32

#define KEY_PTZ_DOWN_START      KEY_CODE_DOWN
#define KEY_PTZ_DOWN_STOP       33

#define KEY_PTZ_LEFT_START      KEY_CODE_LEFT
#define KEY_PTZ_LEFT_STOP       34

#define KEY_PTZ_RIGHT_START     KEY_CODE_RIGHT
#define KEY_PTZ_RIGHT_STOP      35

#define KEY_PTZ_AP1_START       KEY_CODE_EDIT /*��Ȧ+*/
#define KEY_PTZ_AP1_STOP        36

#define KEY_PTZ_AP2_START       KEY_CODE_PAN /*��Ȧ-*/
#define KEY_PTZ_AP2_STOP        37

#define KEY_PTZ_FOCUS1_START    KEY_CODE_A /*�۽�+*/
#define KEY_PTZ_FOCUS1_STOP     38

#define KEY_PTZ_FOCUS2_START    KEY_CODE_M /*�۽�-*/
#define KEY_PTZ_FOCUS2_STOP     39

#define KEY_PTZ_B1_START        40 /*�䱶+*/
#define KEY_PTZ_B1_STOP         41

#define KEY_PTZ_B2_START        42 /*�䱶-*/
#define KEY_PTZ_B2_STOP         43

//9000����
#define KEY_CODE_11             44
#define KEY_CODE_12             45
#define KEY_CODE_13             46
#define KEY_CODE_14             47
#define KEY_CODE_15             48
#define KEY_CODE_16             49

#define AUDIOTALKTYPE_G722       0
#define AUDIOTALKTYPE_G711_MU    1
#define AUDIOTALKTYPE_G711_A	 2
#define AUDIOTALKTYPE_MP2L2      5
#define AUDIOTALKTYPE_G726		 6
#define AUDIOTALKTYPE_AAC		 7
#define AUDIOTALKTYPE_PCM		 8

//packet type
#define FILE_HEAD			0 //file head
#define VIDEO_I_FRAME		1 //video I frame
#define VIDEO_B_FRAME		2 //video B frame
#define VIDEO_P_FRAME		3 //video P frame
#define AUDIO_PACKET		10 //audio packet
#define PRIVT_PACKET        11 //private packet
//E frame
#define HIK_H264_E_FRAME    (1 << 6)   // ��ǰE֡������,��P֡Ҳû�õ�

/*************************������������ begin*******************************/
//����NET_DVR_SetDVRConfig��NET_DVR_GetDVRConfig,ע�����Ӧ�����ýṹ

#define NET_DVR_GET_DEVICECFG		100		//��ȡ�豸����
#define NET_DVR_SET_DEVICECFG		101		//�����豸����
#define NET_DVR_GET_NETCFG			102		//��ȡ�������
#define NET_DVR_SET_NETCFG			103		//�����������
#define NET_DVR_GET_PICCFG			104		//��ȡͼ�����
#define NET_DVR_SET_PICCFG			105		//����ͼ�����
#define NET_DVR_GET_COMPRESSCFG		106		//��ȡѹ������
#define NET_DVR_SET_COMPRESSCFG		107		//����ѹ������
#define NET_DVR_GET_RECORDCFG		108		//��ȡ¼��ʱ�����
#define NET_DVR_SET_RECORDCFG		109		//����¼��ʱ�����
#define NET_DVR_GET_DECODERCFG		110		//��ȡ����������
#define NET_DVR_SET_DECODERCFG		111		//���ý���������
#define NET_DVR_GET_RS232CFG 		112		//��ȡ232���ڲ���
#define NET_DVR_SET_RS232CFG		113		//����232���ڲ���
#define NET_DVR_GET_ALARMINCFG 		114		//��ȡ�����������
#define NET_DVR_SET_ALARMINCFG		115		//���ñ����������
#define NET_DVR_GET_ALARMOUTCFG 	116		//��ȡ�����������
#define NET_DVR_SET_ALARMOUTCFG		117		//���ñ����������
#define NET_DVR_GET_TIMECFG 		118		//��ȡDVRʱ��
#define NET_DVR_SET_TIMECFG			119		//����DVRʱ��
#define NET_DVR_GET_PREVIEWCFG 		120		//��ȡԤ������
#define NET_DVR_SET_PREVIEWCFG		121		//����Ԥ������
#define NET_DVR_GET_VIDEOOUTCFG 	122		//��ȡ��Ƶ�������
#define NET_DVR_SET_VIDEOOUTCFG		123		//������Ƶ�������
#define NET_DVR_GET_USERCFG 		124		//��ȡ�û�����
#define NET_DVR_SET_USERCFG			125		//�����û�����
#define NET_DVR_GET_EXCEPTIONCFG 	126		//��ȡ�쳣����
#define NET_DVR_SET_EXCEPTIONCFG	127		//�����쳣����
#define NET_DVR_GET_ZONEANDDST		128		//��ȡʱ�����ʱ�Ʋ���
#define NET_DVR_SET_ZONEANDDST		129		//����ʱ�����ʱ�Ʋ���

//ע��������ֻ֧��4��OSD�����ͣ�ͨ������V30���µ��豸�汾��
#define NET_DVR_GET_SHOWSTRING		130		//��ȡ�����ַ����
#define NET_DVR_SET_SHOWSTRING		131		//���õ����ַ����

#define NET_DVR_GET_EVENTCOMPCFG	132		//��ȡ�¼�����¼�����
#define NET_DVR_SET_EVENTCOMPCFG	133		//�����¼�����¼�����
#define NET_DVR_GET_FTPCFG			134		//��ȡץͼ��FTP����(����)
#define NET_DVR_SET_FTPCFG			135		//����ץͼ��FTP����(����)
#define NET_DVR_GET_AUXOUTCFG		140		//��ȡ�������������������(HS�豸�������2006-02-28)
#define NET_DVR_SET_AUXOUTCFG		141		//���ñ������������������(HS�豸�������2006-02-28)
#define NET_DVR_GET_PREVIEWCFG_AUX 	142		//��ȡ-sϵ��˫���Ԥ������(-sϵ��˫���2006-04-13)
#define NET_DVR_SET_PREVIEWCFG_AUX	143		//����-sϵ��˫���Ԥ������(-sϵ��˫���2006-04-13)

#define NET_DVR_GET_PASSWORD_MANAGE_CFG 144		//��ȡ�����������
#define NET_DVR_SET_PASSWORD_MANAGE_CFG	145		//���������������
#define NET_DVR_UNLOCK_USER 			146		//�û�����
#define NET_DVR_GET_SECURITY_CFG 		147		//��ȡ��ȫ��֤����
#define NET_DVR_SET_SECURITY_CFG 		148		//���ð�ȫ��֤����
#define	NET_DVR_GET_LOCKED_INFO_LIST	149		//��ȡ���б�����Ϣ


/*********************************���ܲ��ֽӿ� begin***************************************/
//��Ϊ��Ӧ��NET_VCA_RULECFG��
#define NET_DVR_SET_RULECFG		    152	//������Ϊ��������
#define NET_DVR_GET_RULECFG	        153	//��ȡ��Ϊ��������
//���궨����NET_DVR_TRACK_CFG ��
#define NET_DVR_SET_TRACK_CFG       160//�����������ò���
#define NET_DVR_GET_TRACK_CFG       161//��ȡ�������ò���

//���ܷ�����ȡ�����ýṹ
#define NET_DVR_SET_IVMS_STREAMCFG	162		//�������ܷ�����ȡ������
#define NET_DVR_GET_IVMS_STREAMCFG	163		//��ȡ���ܷ�����ȡ������
//���ܿ��Ʋ���ṹ
#define NET_DVR_SET_VCA_CTRLCFG		164	 //�������ܿ��Ʋ���
#define NET_DVR_GET_VCA_CTRLCFG		165	 //��ȡ���ܿ��Ʋ���
//��������NET_VCA_MASK_REGION_LIST
#define NET_DVR_SET_VCA_MASK_REGION	166	 //���������������
#define NET_DVR_GET_VCA_MASK_REGION	167	 //��ȡ�����������

//ATM�������� NET_VCA_ENTER_REGION
#define NET_DVR_SET_VCA_ENTER_REGION 168	 //���ý����������
#define NET_DVR_GET_VCA_ENTER_REGION 169	 //��ȡ�����������

//�궨������NET_VCA_LINE_SEGMENT_LIST
#define NET_DVR_SET_VCA_LINE_SEGMENT 170	 //���ñ궨��
#define NET_DVR_GET_VCA_LINE_SEGMENT 171	 //��ȡ�궨��

// ivms��������NET_IVMS_MASK_REGION_LIST
#define NET_DVR_SET_IVMS_MASK_REGION 172	 //����IVMS�����������
#define NET_DVR_GET_IVMS_MASK_REGION 173	 //��ȡIVMS�����������
// ivms����������NET_IVMS_ENTER_REGION
#define NET_DVR_SET_IVMS_ENTER_REGION 174	 //����IVMS�����������
#define NET_DVR_GET_IVMS_ENTER_REGION 175	 //��ȡIVMS�����������

#define NET_DVR_SET_IVMS_BEHAVIORCFG  176	//�������ܷ�������Ϊ�������
#define NET_DVR_GET_IVMS_BEHAVIORCFG  177	//��ȡ���ܷ�������Ϊ�������

// IVMS �طż���
#define NET_DVR_IVMS_SET_SEARCHCFG		178	//����IVMS�طż�������
#define NET_DVR_IVMS_GET_SEARCHCFG		179	//��ȡIVMS�طż�������

#define NET_DVR_SET_POSITION_TRACK      180     // ���ó�������������Ϣ
#define NET_DVR_GET_POSITION_TRACK      181     // ��ȡ��������������Ϣ

#define NET_DVR_SET_CALIBRATION         182    // ���ñ궨��Ϣ
#define NET_DVR_GET_CALIBRATION         183    // ��ȡ�궨��Ϣ

#define NET_DVR_SET_PDC_RULECFG         184    // ����������ͳ�ƹ���
#define NET_DVR_GET_PDC_RULECFG         185    // ��ȡ������ͳ�ƹ���

#define NET_DVR_SET_PU_STREAMCFG        186     // ����ǰ��ȡ���豸��Ϣ
#define NET_DVR_GET_PU_STREAMCFG        187     // ��ȡǰ��ȡ���豸��Ϣ

#define NET_VCA_SET_SIZE_FILTER         194     // ����ȫ�ֳߴ������
#define NET_VCA_GET_SIZE_FILTER         195     // ��ȡȫ�ֳߴ������

#define NET_DVR_SET_TRACK_PARAMCFG      196     // �������ز˵�����
#define NET_DVR_GET_TRACK_PARAMCFG      197     // ��ȡ���ز˵�����

#define NET_DVR_SET_DOME_MOVEMENT_PARAM 198     // ��������о����
#define NET_DVR_GET_DOME_MOVEMENT_PARAM 199     // ��ȡ����о����

#define NET_DVR_GET_PICCFG_EX		200		//��ȡͼ�����(SDK_V14��չ����)
#define NET_DVR_SET_PICCFG_EX		201		//����ͼ�����(SDK_V14��չ����)
#define NET_DVR_GET_USERCFG_EX 		202		//��ȡ�û�����(SDK_V15��չ����)
#define NET_DVR_SET_USERCFG_EX		203		//�����û�����(SDK_V15��չ����)
#define NET_DVR_GET_COMPRESSCFG_EX	204		//��ȡѹ������(SDK_V15��չ����2006-05-15)
#define NET_DVR_SET_COMPRESSCFG_EX	205		//����ѹ������(SDK_V15��չ����2006-05-15)


#define NET_DVR_GET_NETAPPCFG		222		//��ȡ����Ӧ�ò��� NTP/DDNS/EMAIL
#define NET_DVR_SET_NETAPPCFG		223		//��������Ӧ�ò��� NTP/DDNS/EMAIL
#define NET_DVR_GET_NTPCFG			224		//��ȡ����Ӧ�ò��� NTP
#define NET_DVR_SET_NTPCFG			225		//��������Ӧ�ò��� NTP
#define NET_DVR_GET_DDNSCFG			226		//��ȡ����Ӧ�ò��� DDNS
#define NET_DVR_SET_DDNSCFG			227		//��������Ӧ�ò��� DDNS
//��ӦNET_DVR_EMAILPARA
#define NET_DVR_GET_EMAILCFG		228		//��ȡ����Ӧ�ò��� EMAIL
#define NET_DVR_SET_EMAILCFG		229		//��������Ӧ�ò��� EMAIL

#define NET_DVR_GET_NFSCFG			230		/* NFS disk config */
#define NET_DVR_SET_NFSCFG			231		/* NFS disk config */

/*ע��������Ϊ���ƣ�ֻ֧��8��OSD�����ͣ��������V30�豸�汾֮ǰ��
NET_DVR_GET_SHOWSTRING ��NET_DVR_SET_SHOWSTRING �����������ʹ�ã�*/
#define NET_DVR_GET_SHOWSTRING_EX	238		//��ȡ�����ַ������չ(֧��8���ַ�)
#define NET_DVR_SET_SHOWSTRING_EX	239		//���õ����ַ������չ(֧��8���ַ�)
#define NET_DVR_GET_NETCFG_OTHER	244		//��ȡ�������
#define NET_DVR_SET_NETCFG_OTHER	245		//�����������

//��ӦNET_DVR_EMAILCFG�ṹ
#define NET_DVR_GET_EMAILPARACFG	250		//Get EMAIL parameters
#define NET_DVR_SET_EMAILPARACFG	251		//Setup EMAIL parameters


#define NET_DVR_GET_DDNSCFG_EX		274	//��ȡ��չDDNS����
#define NET_DVR_SET_DDNSCFG_EX		275	//������չDDNS����

#define	NET_DVR_SET_PTZPOS			292		//��̨����PTZλ��
#define	NET_DVR_GET_PTZPOS			293		//��̨��ȡPTZλ��
#define	NET_DVR_GET_PTZSCOPE		294		//��̨��ȡPTZ��Χ

#define NET_DVR_GET_AP_INFO_LIST	305//��ȡ����������Դ����
#define NET_DVR_SET_WIFI_CFG		306	//����IP����豸���߲���
#define NET_DVR_GET_WIFI_CFG		307	//��ȡIP����豸���߲���
#define NET_DVR_SET_WIFI_WORKMODE	308	//����IP����豸��ڹ���ģʽ����
#define NET_DVR_GET_WIFI_WORKMODE	309	//��ȡIP����豸��ڹ���ģʽ����
#define	NET_DVR_GET_WIFI_STATUS		310	//��ȡ�豸��ǰwifi����״̬
/*********************************���ܽ�ͨ�¼�begin***************************************/
#define NET_DVR_GET_REFERENCE_REGION            400      //��ȡ�ο�����
#define NET_DVR_SET_REFERENCE_REGION            401      //���òο�����

#define NET_DVR_GET_TRAFFIC_MASK_REGION         402     //��ȡ��ͨ�¼���������
#define NET_DVR_SET_TRAFFIC_MASK_REGION         403     //���ý�ͨ�¼���������
#define NET_DVR_SET_AID_RULECFG                 404     //���ý�ͨ�¼��������
#define NET_DVR_GET_AID_RULECFG                 405     //��ȡ��ͨ�¼��������

#define NET_DVR_SET_TPS_RULECFG                 406     //���ý�ͨͳ�ƹ������
#define NET_DVR_GET_TPS_RULECFG                 407     //��ȡ��ͨͳ�ƹ������

#define NET_DVR_SET_LANECFG				        408		//���ó�������
#define	NET_DVR_GET_LANECFG				        409		//��ȡ��������
#define NET_DVR_GET_VCA_RULE_COLOR_CFG          410     //��ȡ���ܹ����������ɫ����
#define NET_DVR_SET_VCA_RULE_COLOR_CFG          411     //�������ܹ����������ɫ����
#define NET_DVR_GET_SWITCH_LAMP_CFG             412     //��ȡ���صƼ��������ò���
#define NET_DVR_SET_SWITCH_LAMP_CFG             413     //���ÿ��صƼ��������ò���


/*********************************���ܽ�ͨ�¼�end***************************************/
#define NET_DVR_SET_FACEDETECT_RULECFG          420         // ��������������
#define NET_DVR_GET_FACEDETECT_RULECFG          421         // ��ȡ����������

#define NET_DVR_SET_VEHICLE_RECOG_TASK          422      //��������ʶ�������ύ
#define NET_DVR_GET_VEHICLE_RECOG_TASK          423      //��������ʶ�������ȡ

#define NET_DVR_SET_TIMECORRECT			        432      //Уʱ���ã�ֻ��Уʱ����������¼Уʱ���ã�
#define	NET_DVR_GET_CONNECT_LIST	            433         //��ȡ�����豸�б���Ϣ

/***************************DS9000��������(_V30) begin *****************************/
//����(NET_DVR_NETCFG_V30�ṹ)
#define NET_DVR_GET_NETCFG_V30		            1000		//��ȡ�������
#define NET_DVR_SET_NETCFG_V30		            1001		//�����������

//ͼ��(NET_DVR_PICCFG_V30�ṹ)
#define NET_DVR_GET_PICCFG_V30		            1002		//��ȡͼ�����
#define NET_DVR_SET_PICCFG_V30		            1003		//����ͼ�����

//¼��ʱ��(NET_DVR_RECORD_V30�ṹ)
#define NET_DVR_GET_RECORDCFG_V30	            1004		//��ȡ¼�����
#define NET_DVR_SET_RECORDCFG_V30	            1005		//����¼�����

//�û�(NET_DVR_USER_V30�ṹ)
#define NET_DVR_GET_USERCFG_V30 	            1006		//��ȡ�û�����
#define NET_DVR_SET_USERCFG_V30		            1007		//�����û�����

//¼��ʱ��(NET_DVR_RECORD_V40�ṹ)
#define NET_DVR_GET_RECORDCFG_V40	            1008		//��ȡ¼�����(��չ)
#define NET_DVR_SET_RECORDCFG_V40	            1009		//����¼�����(��չ)

//9000DDNS��������(NET_DVR_DDNSPARA_V30�ṹ)
#define     NET_DVR_GET_DDNSCFG_V30		        1010		//��ȡDDNS(9000��չ)
#define     NET_DVR_SET_DDNSCFG_V30		        1011		//����DDNS(9000��չ)

//EMAIL����(NET_DVR_EMAILCFG_V30�ṹ)
#define NET_DVR_GET_EMAILCFG_V30		        1012	 //��ȡEMAIL����
#define NET_DVR_SET_EMAILCFG_V30		        1013	 //����EMAIL����

#define NET_GET_CRUISEPOINT_V40					1018     //��ȡѲ��·������

//Ѳ������ (NET_DVR_CRUISE_PARA�ṹ)
#define 	NET_DVR_GET_CRUISE			        1020
#define 	NET_DVR_SET_CRUISE			        1021


//��������ṹ���� (NET_DVR_ALARMINCFG_V30�ṹ)
#define 	NET_DVR_GET_ALARMINCFG_V30			1024
#define 	NET_DVR_SET_ALARMINCFG_V30			1025

//��������ṹ���� (NET_DVR_ALARMOUTCFG_V30�ṹ)
#define 	NET_DVR_GET_ALARMOUTCFG_V30			1026
#define 	NET_DVR_SET_ALARMOUTCFG_V30			1027

//��Ƶ����ṹ���� (NET_DVR_VIDEOOUT_V30�ṹ)
#define 	NET_DVR_GET_VIDEOOUTCFG_V30			1028
#define 	NET_DVR_SET_VIDEOOUTCFG_V30			1029


/*������֧��8��OSD�����ͣ����豸�汾ΪV30����ʱ��������ͨ���豸�汾��ƥ�䣬
ͬʱ����֮ǰ��NET_DVR_GET_SHOWSTRING ��NET_DVR_SET_SHOWSTRING ���������ʹ�ã�*/
//�����ַ�ṹ���� (NET_DVR_SHOWSTRING_V30�ṹ)
#define 	NET_DVR_GET_SHOWSTRING_V30			1030
#define 	NET_DVR_SET_SHOWSTRING_V30			1031

//�쳣�ṹ���� (NET_DVR_EXCEPTION_V30�ṹ)
#define 	NET_DVR_GET_EXCEPTIONCFG_V30		1034
#define 	NET_DVR_SET_EXCEPTIONCFG_V30		1035

//����232�ṹ���� (NET_DVR_RS232CFG_V30�ṹ)
#define 	NET_DVR_GET_RS232CFG_V30			1036
#define 	NET_DVR_SET_RS232CFG_V30			1037

//����Ӳ�̽���ṹ���� (NET_DVR_NET_DISKCFG�ṹ)
#define		NET_DVR_GET_NET_DISKCFG				1038		//����Ӳ�̽����ȡ
#define		NET_DVR_SET_NET_DISKCFG				1039		//����Ӳ�̽�������
//ѹ������ (NET_DVR_COMPRESSIONCFG_V30�ṹ)
#define     NET_DVR_GET_COMPRESSCFG_V30	        1040
#define     NET_DVR_SET_COMPRESSCFG_V30	        1041

//��ȡ485���������� (NET_DVR_DECODERCFG_V30�ṹ)
#define     NET_DVR_GET_DECODERCFG_V30		    1042		//��ȡ����������
#define     NET_DVR_SET_DECODERCFG_V30		    1043		//���ý���������

//��ȡԤ������ (NET_DVR_PREVIEWCFG_V30�ṹ)
#define     NET_DVR_GET_PREVIEWCFG_V30		    1044		//��ȡԤ������
#define     NET_DVR_SET_PREVIEWCFG_V30		    1045		//����Ԥ������

//����Ԥ������ (NET_DVR_PREVIEWCFG_AUX_V30�ṹ)
#define     NET_DVR_GET_PREVIEWCFG_AUX_V30		1046		//��ȡ����Ԥ������
#define     NET_DVR_SET_PREVIEWCFG_AUX_V30		1047		//���ø���Ԥ������

//IP�������ò��� ��NET_DVR_IPPARACFG�ṹ��
#define     NET_DVR_GET_IPPARACFG               1048        //��ȡIP����������Ϣ
#define     NET_DVR_SET_IPPARACFG               1049        //����IP����������Ϣ

//IP��������������ò��� ��NET_DVR_IPALARMINCFG�ṹ��
#define     NET_DVR_GET_IPALARMINCFG            1050        //��ȡIP�����������������Ϣ
#define     NET_DVR_SET_IPALARMINCFG            1051        //����IP�����������������Ϣ

//IP��������������ò��� ��NET_DVR_IPALARMOUTCFG�ṹ��
#define     NET_DVR_GET_IPALARMOUTCFG           1052        //��ȡIP�����������������Ϣ
#define     NET_DVR_SET_IPALARMOUTCFG           1053        //����IP�����������������Ϣ

//Ӳ�̹���Ĳ����ȡ (NET_DVR_HDCFG�ṹ)
#define     NET_DVR_GET_HDCFG			        1054	    //��ȡӲ�̹������ò���
#define     NET_DVR_SET_HDCFG			        1055	    //����Ӳ�̹������ò���
//�������Ĳ����ȡ (NET_DVR_HDGROUP_CFG�ṹ)
#define     NET_DVR_GET_HDGROUP_CFG			    1056	    //��ȡ����������ò���
#define     NET_DVR_SET_HDGROUP_CFG			    1057	    //��������������ò���

//�豸������������(NET_DVR_COMPRESSION_AUDIO�ṹ)
#define     NET_DVR_GET_COMPRESSCFG_AUD         1058        //��ȡ�豸�����Խ��������
#define     NET_DVR_SET_COMPRESSCFG_AUD         1059        //�����豸�����Խ��������

//IP�������ò��� ��NET_DVR_IPPARACFG_V31�ṹ��
#define     NET_DVR_GET_IPPARACFG_V31           1060        //��ȡIP����������Ϣ
#define     NET_DVR_SET_IPPARACFG_V31           1061        //����IP����������Ϣ

// ͨ����Դ���� (NET_DVR_IPPARACFG_V40�ṹ)
#define NET_DVR_GET_IPPARACFG_V40               1062        // ��ȡIP��������
#define NET_DVR_SET_IPPARACFG_V40               1063        // ����IP��������

#define NET_DVR_GET_CCDPARAMCFG                 1067       //IPC��ȡCCD��������
#define NET_DVR_SET_CCDPARAMCFG                 1068       //IPC����CCD��������

#define NET_DVR_GET_IOINCFG		                1070    //��ȡץ�Ļ�IO�������
#define NET_DVR_SET_IOINCFG		                1071	 //����ץ�Ļ�IO�������

#define NET_DVR_GET_IOOUTCFG		            1072    //��ȡץ�Ļ�IO�������
#define NET_DVR_SET_IOOUTCFG		            1073	 //����ץ�Ļ�IO�������

#define NET_DVR_GET_FLASHCFG		            1074    //��ȡIO������������
#define NET_DVR_SET_FLASHCFG		            1075	 //����IO������������

#define NET_DVR_GET_LIGHTSNAPCFG		        1076    //��ȡץ�Ļ���̵Ʋ���
#define NET_DVR_SET_LIGHTSNAPCFG	        	1077	 //����ץ�Ļ���̵Ʋ���

#define NET_DVR_GET_MEASURESPEEDCFG		        1078    //��ȡץ�Ļ���ٲ���
#define NET_DVR_SET_MEASURESPEEDCFG		        1079	 //����ץ�Ļ���ٲ���

#define NET_DVR_GET_IMAGEOVERLAYCFG	            1080//��ȡץ�Ļ�ͼ�������Ϣ����
#define NET_DVR_SET_IMAGEOVERLAYCFG	            1081//����ץ�Ļ�ͼ�������Ϣ����

#define NET_DVR_GET_SNAPCFG	                    1082//��ȡ��IO����ץ�Ĺ�������
#define NET_DVR_SET_SNAPCFG	                    1083//���õ�IO����ץ�Ĺ�������

#define NET_DVR_GET_VTPPARAM		            1084//��ȡ������Ȧ����
#define NET_DVR_SET_VTPPARAM		            1085//����������Ȧ����

#define NET_DVR_GET_SNAPENABLECFG				1086//��ȡץ�Ļ�ʹ�ܲ���
#define NET_DVR_SET_SNAPENABLECFG				1087//����ץ�Ļ�ʹ�ܲ���

#define NET_DVR_GET_POSTEPOLICECFG              1088//��ȡ���ڵ羯����
#define NET_DVR_SET_POSTEPOLICECFG              1089//���ÿ��ڵ羯����

#define NET_DVR_GET_JPEGCFG_V30					1090//��ȡץͼ��JPEG����(����)
#define NET_DVR_SET_JPEGCFG_V30					1091//����ץͼ��JPEG����(����)

#define NET_DVR_GET_SPRCFG	                    1092//��ȡ����ʶ�����
#define NET_DVR_SET_SPRCFG	                    1093//���ó���ʶ�����
#define NET_DVR_GET_PLCCFG                      1094//��ȡ�������Ȳ�������
#define NET_DVR_SET_PLCCFG                      1095//���ó������Ȳ�������

#define NET_DVR_GET_DEVICESTATECFG              1096//��ȡ�豸��ǰ״̬����
#define NET_DVR_SET_CALIBRATE_TIME              1097//������չʱ��Уʱ
#define NET_DVR_GET_CALIBRATE_TIME              1098//��ȡ��չʱ��Уʱ

#define NET_DVR_GET_DEVICECFG_V40	            1100//��ȡ��չ�豸����
#define NET_DVR_SET_DEVICECFG_V40	            1101//������չ�豸����

#define NET_DVR_GET_ZEROCHANCFG   	            1102	//��ȡ��ͨ��ѹ������
#define NET_DVR_SET_ZEROCHANCFG  	            1103	//������ͨ��ѹ������

#define NET_DVR_GET_ZERO_PREVIEWCFG_V30         1104    // ��ȡ��ͨ��Ԥ����������
#define NET_DVR_SET_ZERO_PREVIEWCFG_V30         1105    // ������ͨ��Ԥ����������

#define NET_DVR_SET_ZERO_ZOOM	                1106     //������ͨ������������
#define NET_DVR_GET_ZERO_ZOOM	                1107     //��ȡ��ͨ������������

#define	NET_DVR_NATASSOCIATECFG_GET	            1110    //��ȡNAT���������Ϣ
#define	NET_DVR_NATASSOCIATECFG_SET	            1111     //����NAT���������Ϣ

#define NET_DVR_GET_SNMPCFG   	                1112    //��ȡSNMP����
#define NET_DVR_SET_SNMPCFG  	                1113    //����SNMP����

#define NET_DVR_GET_SNMPCFG_V30   	            1114        //��ȡSNMPv30����
#define NET_DVR_SET_SNMPCFG_V30  	            1115        //����SNMPv30����

#define	NET_DVR_VIDEOPLATFORMALARMCFG_GET	    1130  //��ȡ��Ƶ�ۺ�ƽ̨��������
#define	NET_DVR_VIDEOPLATFORMALARMCFG_SET	    1131  //������Ƶ�ۺ�ƽ̨��������

#define NET_DVR_GET_RAID_ADAPTER_INFO           1134    // ��ȡ��������Ϣ
#define NET_DVR_SET_RAID_ADAPTER_INFO           1135    // ������������Ϣ

#define	NET_DVR_MATRIX_BIGSCREENCFG_GET		    1140//��ȡ����ƴ�Ӳ���
#define	NET_DVR_MATRIX_BIGSCREENCFG_SET		    1141//���ô���ƴ�Ӳ���

#define NET_DVR_GET_MB_PLATFORMPARA			    1145 //��ȡƽ̨��¼����
#define NET_DVR_SET_MB_PLATFORMPARA			    1146 //����ƽ̨��¼����
#define NET_DVR_GET_MB_DEVSTATUS                1147 //��ȡ�ƶ��豸״̬

#define  NET_DVR_GET_DECODER_JOINT_CHAN	        1151//��ȡ�������ͨ��
#define  NET_DVR_SET_DECODER_JOINT_CHAN	        1152//���ý������ͨ��

//��������
#define NET_DVR_GET_NETCFG_MULTI                1161        //��ȡ��������
#define NET_DVR_SET_NETCFG_MULTI                1162        //���ö�������

#define NET_DVR_GET_CMSPARA			            1170//��ȡƽ̨����
#define NET_DVR_SET_CMSPARA			            1171//����ƽ̨����
#define NET_DVR_GET_DIALSTATUS		            1172//��ȡ����״̬����
#define NET_DVR_GET_SMSRELATIVEPARA	            1173//��ȡ������ز���
#define NET_DVR_SET_SMSRELATIVEPARA	            1174//���ö�����ز���
#define NET_DVR_GET_PINSTATUS		            1175//��ȡPin״̬
#define NET_DVR_SET_PINCMD			            1176//����PIN����
#define NET_DVR_SET_SENSOR_CFG					1180//����ģ��������
#define NET_DVR_GET_SENSOR_CFG					1181//��ȡģ��������
#define NET_DVR_SET_ALARMIN_PARAM				1182//���ñ����������
#define NET_DVR_GET_ALARMIN_PARAM				1183//��ȡ�����������
#define NET_DVR_SET_ALARMOUT_PARAM				1184//���ñ����������
#define NET_DVR_GET_ALARMOUT_PARAM				1185//��ȡ�����������
#define NET_DVR_SET_SIREN_PARAM					1186//���þ��Ų���
#define NET_DVR_GET_SIREN_PARAM					1187//��ȡ���Ų���
#define NET_DVR_SET_ALARM_RS485CFG				1188//���ñ�������485����
#define NET_DVR_GET_ALARM_RS485CFG				1189//��ȡ��������485����
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS		1190//��ȡ����������Ҫ״̬
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS		1191//��ȡ������������״̬
#define NET_DVR_SET_ALARMHOST_ENABLECFG			1192//��ȡ��������ʹ��״̬
#define NET_DVR_GET_ALARMHOST_ENABLECFG			1193//���ñ�������ʹ��״̬
#define NET_DVR_SET_ALARM_CAMCFG				1194//������Ƶ�ۺ�ƽ̨��������CAM��������
#define NET_DVR_GET_ALARM_CAMCFG				1195//������Ƶ�ۺ�ƽ̨��������CAM��������
#define NET_DVR_GET_GATEWAY_CFG                 1196//��ȡ�Ž��������
#define NET_DVR_SET_GATEWAY_CFG                 1197//�����Ž��������
#define NET_DVR_GET_POS_TEXT_CFG                1198//��ȡPOS��������
#define NET_DVR_SET_POS_TEXT_CFG                1199//����POS��������

#define NET_DVR_GET_ALARMDIALMODECFG			1198//��ȡ��������Ų���
#define NET_DVR_SET_ALARMDIALMODECFG			1199//���ñ�������Ų���
#define	NET_DVR_SET_WINCFG			            1202//���ڲ�������
#define NET_DVR_GET_ALARMHOSTDIALSETUPMODE		1204//��ȡ������������÷�ʽ
#define NET_DVR_SET_ALARMHOSTDIALSETUPMODE		1205//���ñ�����������÷�ʽ

//��Ƶ���������������(��Ƶ�������� V1.3)
#define NET_DVR_SET_SUBSYSTEM_ALARM				1210	//������ϵͳ��/����
#define NET_DVR_GET_SUBSYSTEM_ALARM				1211	//��ȡ��ϵͳ��/����
#define NET_DVR_GET_WHITELIST_ALARM				1215	//��ȡ�������
#define NET_DVR_SET_WHITELIST_ALARM				1216	//���ð������
#define	NET_DVR_GET_ALARMHOST_MODULE_LIST		1222	//��ȡ����ģ��
#define NET_DVR_SET_PRIOR_ALARM					1223	//������ϵͳ��/����
#define NET_DVR_GET_PRIOR_ALARM					1224	//��ȡ��ϵͳ��/����
#define NET_DVR_SET_TAMPER_ALARMIN_PARAM		1225	// ���÷���������
#define NET_DVR_GET_TAMPER_ALARMIN_PARAM		1226	// ��ȡ����������

#define NET_DVR_GET_HOLIDAY_PARAM_CFG           1240// ��ȡ�ڼ��ղ���
#define NET_DVR_SET_HOLIDAY_PARAM_CFG           1241// ���ýڼ��ղ���

#define NET_DVR_GET_MOTION_HOLIDAY_HANDLE       1242// ��ȡ�ƶ������ձ������?ʽ
#define NET_DVR_SET_MOTION_HOLIDAY_HANDLE       1243// ��ȡ�ƶ������ձ������?ʽ

#define NET_DVR_GET_VILOST_HOLIDAY_HANDLE       1244// ��ȡ��Ƶ�źŶ�ʧ���ձ������?ʽ
#define NET_DVR_SET_VILOST_HOLIDAY_HANDLE       1245// ��ȡ��Ƶ�źŶ�ʧ���ձ������?ʽ

#define NET_DVR_GET_HIDE_HOLIDAY_HANDLE         1246// ��ȡ�ڸǼ��ձ������?ʽ
#define NET_DVR_SET_HIDE_HOLIDAY_HANDLE         1247// �����ڸǼ��ձ������?ʽ

#define NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE      1248// ��ȡ����������ձ������?ʽ
#define NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE      1249// ���ñ���������ձ������?ʽ
#define NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE     1250// ��ȡ����������ձ������?ʽ
#define NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE     1251// ���ñ���������ձ������?ʽ
#define NET_DVR_GET_HOLIDAY_RECORD              1252// ��ȡ����¼�����
#define NET_DVR_SET_HOLIDAY_RECORD              1253// ���ü���¼�����
#define NET_DVR_GET_NETWORK_BONDING             1254// ��ȡBONDING�������
#define NET_DVR_SET_NETWORK_BONDING             1255// ����BONDING�������
#define NET_DVR_GET_LINK_STATUS                 1256// ��ȡͨ��IP����״̬
#define NET_DVR_GET_DISK_QUOTA_CFG              1278// ��ȡ���������Ϣ
#define NET_DVR_SET_DISK_QUOTA_CFG              1279// ���ô��������Ϣ
#define NET_DVR_GET_JPEG_CAPTURE_CFG            1280// ��ȡDVRץͼ����
#define NET_DVR_SET_JPEG_CAPTURE_CFG            1281// ����DVRץͼ����
#define NET_DVR_GET_SCHED_CAPTURECFG            1282// ��ȡץͼ�ƻ�
#define NET_DVR_SET_SCHED_CAPTURECFG            1283// ����ץͼ�ƻ�
#define NET_DVR_GET_VGA_PREVIEWCFG              1284// ��ȡVGAԤ������
#define NET_DVR_SET_VGA_PREVIEWCFG              1285// ����VGAԤ������
#define NET_DVR_GET_VIDEO_INPUT_EFFECT          1286// ��ȡͨ����Ƶ����ͼ�����
#define NET_DVR_SET_VIDEO_INPUT_EFFECT          1287// ����ͨ����Ƶ����ͼ�����

#define NET_DVR_GET_STORAGE_SERVER_SWITCH	    1290//��ȡ�洢����������״̬
#define NET_DVR_SET_STORAGE_SERVER_SWITCH	    1291//���ô洢����������״̬


#define NET_DVR_GET_OPTICAL_CHANNEL				1300//��ȡ�����ϵͳͨ��������Ϣ
#define NET_DVR_SET_OPTICAL_CHANNEL				1301//���ù����ϵͳͨ��������Ϣ
#define NET_DVR_GET_FIBER_CASCADE				1302//��ȡ���˼���ģʽ
#define NET_DVR_SET_FIBER_CASCADE				1303//���ù��˼���ģʽ
#define NET_DVR_GET_SPARTAN_STATUS				1304//��ȡ����״̬
#define NET_DVR_SET_SPARTAN_STATUS				1305//���ó���״̬
#define NET_DVR_GET_ETHERNET_CHANNEL			1306//��ȡ�˿ھۺϲ���
#define NET_DVR_SET_ETHERMET_CHANNEL			1307//���ö˿ھۺϲ���
#define NET_DVR_OPTICAL_REBOOT					1320//��˻�����
#define NET_DVR_SET_AUDIOCHAN_CFG				1321//������Ƶ�л�����
#define NET_DVR_GET_AUDIOCHAN_CFG				1322//��ȡ��Ƶ�л�����
//SDI����1.0
#define NET_DVR_SET_MATRIX_BASE_CFG             1332 //���þ�������
#define NET_DVR_GET_MATRIX_BASE_CFG             1333 //��ȡ��������
#define NET_DVR_SWITCH_MATRIX_IO                1334 //������������л�
#define NET_DVR_GET_MATRIX_IO_RELATION          1335 //��ȡ�����������������ϵ

#define	NET_DVR_BIGSCREENASSOCIATECFG_GET		1511 //��ȡ������������
#define	NET_DVR_BIGSCREENASSOCIATECFG_SET		1512 //���ô�����������

//1200��
#define	NET_DVR_GETSCREENINFO		            1601 //��ȡ������Ϣ����
#define	NET_DVR_SETSCREENINFO		            1602 //���ô�����Ϣ����
#define	NET_DVR_GET_SCREEN_WINCFG	            1603//�������ڲ����ȡ
#define	NET_DVR_LAYOUTLIST_GET 		            1605//��ȡ�����б�
#define	NET_DVR_SET_LAYOUTCFG		            1606 //��������
#define	NET_DVR_LAYOUTCTRL			            1607//���ֿ��ƣ�1-open��2-close
#define	NET_DVR_INPUTLIST_GET		            1608 //��ȡ�����ź�Դ�б�
#define	NET_DVR_SET_INPUTSTREAMCFG	            1609 //�����ź�Դ����
#define	NET_DVR_OUTPUT_SET			            1610 //�����������
#define	NET_DVR_OUTPUT_GET			            1611 //��������ȡ
#define	NET_DVR_SET_OSDCFG			            1612 //OSD��������
#define	NET_DVR_GET_OSDCFG			            1613 //OSD�����ȡ
#define	NET_DVR_BIGSCREEN_GETSERIAL             1614//��ȡ����������Ϣ
#define	NET_DVR_GET_PLANLIST		            1615//��ȡԤ���б�
#define	NET_DVR_SET_PLAN			            1616//����Ԥ��
#define	NET_DVR_CTRL_PLAN			            1617//����Ԥ��
#define	NET_DVR_GET_DEVICE_RUN_STATUS           1618//��ȡ�豸����״̬
#define NET_DVR_GET_EXTERNAL_MATRIX_CFG		    1619//��ȡ������Ϣ
#define	NET_DVR_SET_EXTERNAL_MATRIX_CFG		    1620//���þ�����Ϣ
#define	NET_DVR_GET_OUTPUT_SCREEN_RELATION	    1621//��ȡ�������Ļ�İ󶨹�ϵ
#define	NET_DVR_SET_OUTPUT_SCREEN_RELATION	    1622//�����������Ļ�İ󶨹�ϵ
#define NET_DVR_GET_VCS_USER_CFG			    1623//��ȡ�û���Ϣ����
#define	NET_DVR_SET_VCS_USER_CFG			    1624//�����û���Ϣ����
#define	NET_DVR_CONTROL_SCREEN				    1625//��Ļ����

#define NET_DVR_GET_DEV_BASEINFO			    1650//��ȡ�����豸��Ϣ
#define NET_DVR_SET_DEV_BASEINFO			    1651//���õ����豸��Ϣ
#define NET_DVR_GET_DEV_NETINFO				    1652//��ȡ�豸��������Ϣ
#define NET_DVR_SET_DEV_NETINFO				    1653//�����豸��������Ϣ
#define NET_DVR_GET_SIGNAL_SOURCE_INFO		    1654//��ȡ�ź�Դ��Ϣ
#define NET_DVR_SET_SIGNAL_SOURCE_INFO		    1655//�����ź�Դ��Ϣ
#define NET_DVR_ADJUST_PIC_V40				    1656//ͼ��΢��
#define NET_DVR_RESTORE_V40					    1657//�ָ�Ĭ�ϲ���
#define	NET_DVR_SET_NET_SIGNAL				    1658//���������ź�Դ
#define NET_DVR_REBOOT_V40					    1659//����
#define NET_DVR_CONTROL_PICTURE_V41				1660//ͼƬ����V41

#define NET_DVR_GET_AUTO_REBOOT_CFG             1710//��ȡ�Զ���������
#define NET_DVR_SET_AUTO_REBOOT_CFG             1711//�����Զ���������
#define NET_DVR_GET_TRUNK_USE_STATE 			1713//��ȡָ������ʹ��״̬
#define NET_DVR_SET_PTZ_CTRL_INFO 				1714//����PTZ���Ʋ���
#define NET_DVR_GET_PTZ_CTRL_INFO 				1715//��ȡPTZ���Ʋ���
#define NET_DVR_GET_PTZ_STATUS 					1716//��ȡPTZ״̬
#define	NET_DVR_GET_DISP_ROUTE_LIST				1717//��ȡ��ʾ·���б�

#define NET_DVR_GET_DEC_RESOURCE_LIST			1720//��ȡ���ý�����Դ�б�
#define NET_DVR_SET_DEC_RESOURCE_LIST			1721//Ԥ���������Դ
#define NET_DVR_GET_DEC_YUV						1722//��ȡ����ͨ������YUV�������
#define NET_DVR_SET_DEC_YUV						1723//���ý���ͨ������YUV�������
#define NET_DVR_GET_DEC_RESOUCE					1724//����Ƶ�ۺ�ƽ̨���������Դ
#define NET_DVR_FREE_DEC_RESOURCE				1725//�ͷŽ�����Դ

#define NET_DVR_SET_VIDEOWALLDISPLAYMODE        1730//���õ���ǽƴ��ģʽ
#define NET_DVR_GET_VIDEOWALLDISPLAYMODE        1731//��ȡ����ǽƴ��ģʽ
#define NET_DVR_GET_VIDEOWALLDISPLAYNO          1732//��ȡ�豸��ʾ�����
#define	NET_DVR_SET_VIDEOWALLDISPLAYPOSITION	1733//������ʾ���λ�ò���
#define	NET_DVR_GET_VIDEOWALLDISPLAYPOSITION	1734//��ȡ��ʾ���λ�ò���
#define NET_DVR_GET_VIDEOWALLWINDOWPOSITION     1735//��ȡ����ǽ���ڲ���
#define NET_DVR_SET_VIDEOWALLWINDOWPOSITION     1736//���õ���ǽ���ڲ���
#define	NET_DVR_VIDEOWALLWINDOW_CLOSEALL	    1737//����ǽ�ر����д���
#define	NET_DVR_SET_VIRTUALLED			        1738//����LED����
#define	NET_DVR_GET_VIRTUALLED			        1739//����LED��ȡ
#define NET_DVR_GET_IMAGE_CUT_MODE              1740//��ȡͼ���и�ģʽ
#define NET_DVR_SET_IMAGE_CUT_MODE              1741//����ͼ���и�ģʽ
#define NET_DVR_GET_USING_SERIALPORT            1742//��ȡ��ǰʹ�ô���
#define NET_DVR_SET_USING_SERIALPORT            1743//���õ�ǰʹ�ô���
#define NET_DVR_SCENE_CONTROL                   1744//��������
#define NET_DVR_GET_CURRENT_SCENE               1745//��ȡ��ǰ������
#define NET_DVR_GET_VW_SCENE_PARAM              1746//��ȡ����ǽ����ģʽ����
#define NET_DVR_SET_VW_SCENE_PARAM              1747//���õ���ǽ����ģʽ����
#define NET_DVR_DISPLAY_CHANNO_CONTROL          1748//����ǽ��ʾ��ſ���
#define NET_DVR_GET_WIN_DEC_INFO                1749//��ȡ���ڽ�����Ϣ��������
#define NET_DVR_SET_VW_AUDIO_CFG		        1752    //������Ƶ�л�����
#define	NET_DVR_GET_VW_AUDIO_CFG		        1753    //��ȡ��Ƶ�л�����
#define NET_DVR_GET_GBT28181_DECCHANINFO_CFG    1754    //��ȡGBT28181Э������豸�Ľ���ͨ����Ϣ
#define NET_DVR_SET_GBT28181_DECCHANINFO_CFG    1755    //����GBT28181Э������豸�Ľ���ͨ����Ϣ
#define	NET_DVR_SET_MAINBOARD_SERIAL			1756  //�������ذ崮�ڲ���
#define	NET_DVR_GET_MAINBOARD_SERIAL			1757  //��ȡ���ذ崮�ڲ���
#define NET_DVR_GET_SUBBOARD_INFO               1758  //��ȡ�Ӱ���Ϣ
#define NET_DVR_GET_SUBBOARD_EXCEPTION          1759  //��ȡ�쳣�Ӱ��쳣��Ϣ

#define NET_DVR_GET_CAMERACHAN_SERIALCFG	1760   //��ȡCameraͨ���󶨴�������
#define NET_DVR_SET_CAMERACHAN_SERIALCFG	1761   //����Cameraͨ���󶨴�������
#define NET_DVR_GET_MATRIX_STATUS			1762   //��ȡ��Ƶ�ۺ�ƽ̨״̬
#define	NET_SET_MULTIFUNCTION_SERIALCFG 	1763  //���ö๦�ܴ�������
#define	NET_GET_MULTIFUNCTION_SERIALCFG	    1764  //��ȡ�๦�ܴ�������
#define NET_DVR_PTZ_3D_SPEED				1765  // 3ά���ٶȵ���̨����

#define  NET_DVR_GET_SIGNAL_JOINT			1766   //��ȡ�ź�Դ������
#define  NET_DVR_SET_SIGNAL_JOINT			1767   //�����ź�Դ������
#define  NET_DVR_SIGNAL_CUT					1768   //�ź�Դ�ü�
#define  NET_DVR_DYNAMIC_DECODE_BATCH		1769     //������̬����
#define  NET_DVR_DECSWITCH_SET_BATCH		1770    //�������ý���ͨ������
#define  NET_DVR_DECSWITCH_GET_BATCH		1771    //������ȡ����ͨ������
#define  NET_DVR_GET_ALL_SIGNAL_JOINT		1772   //��ȡ�����ź�Դ������
#define	 NET_DVR_GET_PLAYING_PLAN			1773    //��ȡ����ִ��Ԥ��
#define  NET_DVR_WALL_RELATION_GET			1774   //��ȡ�豸ǽ������ǽ�Ĺ���
#define  NET_DVR_WALL_RELATION_SET			1775   //�����豸ǽ������ǽ�Ĺ���
#define	 NET_DVR_SET_INPUTSTREAMCFG_V40		1776   //�����ź�Դ����
#define  NET_DVR_PTZCFG_INPUTSTREAM_GET		1777  //��ȡ����Դ������̨��������
#define  NET_DVR_PTZCFG_INPUTSTREAM_SET		1778  //��������Դ������̨��������
#define  NET_DVR_SIGNAL_CUTPARAM_GET		1779  //��ȡ�ź�Դ�ü�����

#define NET_DVR_GET_SUBSYSTEM_NETCFG            1780    //��ȡ��ϵͳ�����
#define NET_DVR_SET_SUBSYSTEM_NETCFG  	        1781    //������ϵͳ�����
#define	NET_DVR_DEL_SIGNAL_JOINT			    1782	//ɾ��ƴ���ź�Դ

#define NET_DVR_GET_PICTURE_INFO				1783     //��ȡͼƬ��Ϣ
#define NET_DVR_SET_PICTURE_INFO				1784     //����ͼƬ��Ϣ
#define NET_DVR_GET_VIDEO_INFO					1785     //��ȡ��Ƶ��Ϣ
#define NET_DVR_SET_VIDEO_INFO					1786     //������Ƶ��Ϣ
#define NET_DVR_SET_PLAYLIST					1787     //���ò����б�
#define NET_DVR_GET_PLAYLIST					1788     //��ȡ�����б�
#define NET_DVR_GET_ALL_PLAYLIST				1789     //��ȡ���в����б�
#define NET_DVR_PLAYITEM_CONTROL				1790     //���������
#define NET_DVR_SET_PLAYPLAN_TEMPLATE			1791     //���ò��żƻ�ģ��
#define NET_DVR_GET_PLAYPLAN_TEMPLATE			1792     //��ȡ���żƻ�
#define NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE		1793	 //��ȡ���в��żƻ�
#define NET_DVR_SET_WINDOW_PLAYPLAN				1794     //���ô��ڲ��żƻ�
#define NET_DVR_GET_WINDOW_PLAYPLAN				1795     //��ȡ���ڲ��żƻ�
#define NET_DVR_TOPLAY_ITEM						1796     //ָ������
#define NET_DVR_DEVICE_PLAY_CONTROL				1797     //�豸���ſ���
#define NET_DVR_GET_PLAY_INFO					1798     //��ȡ��ǰ������Ϣ
#define NET_DVR_GET_ALL_PICTURE_INFO			1799     //��ȡͼƬ��Ϣ
#define NET_DVR_GET_ALL_VIDEO_INFO				1800     //��ȡ��Ƶ��Ϣ
#define NET_DVR_DELETE_VIDEO_FILE				1801     //ɾ����Ƶ


#define NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG	    2001//���������ȡ��ϵͳ����
#define NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG	    2002//��������������ϵͳ����
#define NET_DVR_GETEXTENDALARMININFO    	    2003//��ȡ��������Ϣ
#define NET_DVR_MODIFYALARMINNO 	            2004//�޸ķ�������Ϣ
#define NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG	2005//��ȡ���������������
#define	NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG	2006//�������������������
#define	NET_DVR_GET_ALARMHOST_NETCFG		    2007//��ȡ�����������
#define	NET_DVR_SET_ALARMHOST_NETCFG		    2008//���������������
#define NET_DVR_GET_LED_SCREEN_CFG		        2009// ��ȡLED��Ļ����
#define NET_DVR_SET_LED_SCREEN_CFG	        	2010// ����LED��Ļ����
#define NET_DVR_GET_LED_CONTENT_CFG		        2011// ��ȡLED��������
#define	NET_DVR_SET_LED_CONTENT_CFG		        2012// ����LED��������
#define NET_DVR_TURNON_LED				        2013// ��LED��
#define NET_DVR_TURNOFF_LED				        2014// �ر�LED��
#define NET_DVR_GET_LED_TIMER_SWITCH	        2015// ��ȡLED����ʱ���ز���
#define NET_DVR_SET_LED_TIMER_SWITCH	        2016// ����LED����ʱ���ز���
#define NET_DVR_SET_LED_BRIGHTNESS		        2017// �ֶ�����LED������
#define NET_DVR_GET_LED_TIMER_BRIGHTNESS		    2018//���÷�ʱLED������
#define NET_DVR_SET_LED_TIMER_BRIGHTNESS		    2019//��ȡ��ʱLED������
#define NET_DVR_LED_CHECKTIME						2020//LEDУʱ
#define NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM	2021//��ȡ��Ƶ���汨���¼�
#define NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM	2022//������Ƶ���汨���¼�
#define	NET_DVR_GET_LED_STATUS						2023//��ȡLED��״̬
#define NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM         2027//�ر���ϵͳ������ʾ��
#define NET_DVR_SET_SUBSYSTEM_BYPASS				2028//��ϵͳ��·
#define NET_DVR_CANCEL_SUBSYSTEM_BYPASS				2029//��ϵͳ��·�ָ�

#define NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX		2030//��ȡ��ϵͳ��չ����
#define	NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX		2031//������ϵͳ��չ����
#define NET_DVR_GET_ALARMHOST_PRINTER_CFG			2032//��ȡ��ӡ���ӡʹ��
#define	NET_DVR_SET_ALARMHOST_PRINTER_CFG			2033//���ô�ӡ���ӡʹ��
#define	NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM 2034//��ȡָ����ϵͳ�ڵ����з���
#define	NET_DVR_GET_ALARMHOST_TRIGGER_LIST			2035//��ȡ���д�����
#define	NET_DVR_ARM_ALARMHOST_SUBSYSTEM				2036//���������Ͷ���ϵͳ����
#define	NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2037// ��ȡ�¼����������������
#define NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2038// �����¼����������������
#define	NET_DVR_GET_ALARMHOST_FAULT_CFG				2039// ��ȡ���ϴ�������
#define NET_DVR_SET_ALARMHOST_FAULT_CFG				2040// ���ù��ϴ�������
#define NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE 		2041//�Զ�����
#define	NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE	2042//�Զ�ע��
#define NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM 2043//�ر�ȫ�ֹ�����ʾ��

#define NET_DVR_GET_SAFETYCABIN_WORK_MODE			2044 //��ȡ�����չ���ģʽ����
#define NET_DVR_SET_SAFETYCABIN_WORK_MODE			2045 //���÷����չ���ģʽ����
#define NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG   2046 //��ȡ���������ź�̽�����
#define NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG   2047 //���÷��������ź�̽�����

#define  NET_DVR_GET_ALARMHOST_MODULE_CFG			2048//��ȡģ����Ϣ
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG			2049//����ģ����Ϣ(Ԥ��)

#define	 NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE		2050//��ȡ485����豸״̬
#define  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2051//��������豸������ֵ
#define  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2052//��ȡ����豸������ֵ
#define  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG				2053// ��ȡģ������������
#define  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG				2054// ����ģ������������
#define	 NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG				2055// ���ñ�������485��λ����
#define  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG				2056// ��ȡ��������485��λ����

#define NET_DVR_GET_ALL_VARIABLE_INFO	  2057   // ��ȡ���б���Ԫ����Ϣ
#define NET_DVR_GET_ALARM_POINT_CFG       2058   // ��ȡ�����Ϣ
#define NET_DVR_SET_ALARM_POINT_CFG       2059   // ���õ����Ϣ
#define NET_DVR_GET_HISTORY_VALUE		  2060   // ��ȡ��ʷ���
#define NET_DVR_GET_ALARMHOST_ALARM_MODE  2061   // ��ȡ����ϴ���ʽ
#define NET_DVR_SET_ALARMHOST_ALARM_MODE  2062   // ��������ϴ���ʽ
#define NET_DVR_GET_ALARMHOST_SENSOR_VALUE 2063   // ��ȡģ����ʵʱ���

#define NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40	2064   // ��ȡ����ϴ���ʽ
#define NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40	2065   // ��������ϴ���ʽ
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG	    2068   // ��ȡʱ���������
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG     2069   // ����ʱ���������
#define NET_DVR_GET_CMS_CFG 					2070
#define	NET_DVR_SET_CMS_CFG						2071
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40	2072   // ��ȡ��Ҫ״̬V40

/*************************************��Ƶ��������1.3 begin*************************************/
#define NET_DVR_GET_ALARM_CAPTRUE_CFG 				2074	//��ȡ����ץͼ��������
#define	NET_DVR_SET_ALARM_CAPTRUE_CFG				2075	//���ñ���ץͼ��������
#define NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40		2078   // ��ȡ����ʱ���������V40
#define NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40		2079   // ���õ���ʱ���������V40
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40	    2080   // ��ȡʱ���������V40
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40     2081   // ����ʱ���������V40
/*************************************��Ƶ��������1.3 end**************************************/


#define NET_DVR_GET_WEEK_PLAN_CFG               2100    //��ȡ��״̬�ܼƻ�����
#define NET_DVR_SET_WEEK_PLAN_CFG               2101	//������״̬�ܼƻ�����
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN    2102    //��ȡ��״̬���ռƻ�����
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN    2103    //������״̬���ռƻ�����
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP   2104    //��ȡ��״̬���������
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP   2105	//������״̬���������
#define NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE   2106    //��ȡ��״̬�ƻ�ģ�����
#define NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE   2107    //������״̬�ƻ�ģ�����
#define NET_DVR_GET_DOOR_CFG                    2108    //��ȡ�Ų���
#define NET_DVR_SET_DOOR_CFG                    2109	//�����Ų���
#define NET_DVR_GET_DOOR_STATUS_PLAN            2110    //��ȡ��״̬�ƻ�����
#define NET_DVR_SET_DOOR_STATUS_PLAN            2111	//������״̬�ƻ�����
#define NET_DVR_GET_GROUP_CFG                   2112    //��ȡȺ�����
#define NET_DVR_SET_GROUP_CFG                   2113    //����Ⱥ�����
#define NET_DVR_GET_MULTI_CARD_CFG              2114    //��ȡ���ؿ�����
#define NET_DVR_SET_MULTI_CARD_CFG              2115	//���ö��ؿ�����
#define NET_DVR_GET_CARD_CFG                    2116    //��ȡ������
#define NET_DVR_SET_CARD_CFG                    2117	//���ÿ�����
#define NET_DVR_CLEAR_ACS_PARAM			        2118	//����Ž��������
#define NET_DVR_GET_SNEAK_CFG	                2119	//��ȡ��Ǳ�ز���
#define NET_DVR_SET_SNEAK_CFG                   2120    //���÷�Ǳ�ز���
#define NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG    2121	//��ȡ���Ż������
#define NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG    2122    //���ö��Ż������
#define NET_DVR_GET_ACS_WORK_STATUS	            2123	//��ȡ�Ž�������״̬
#define NET_DVR_GET_VERIFY_WEEK_PLAN            2124    //��ȡ��������֤��ʽ�ܼƻ�����
#define NET_DVR_SET_VERIFY_WEEK_PLAN            2125    //���ö�������֤��ʽ�ܼƻ�����
#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN        2126    //��ȡ��Ȩ���ܼƻ�����
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN        2127    //���ÿ�Ȩ���ܼƻ�����
#define NET_DVR_GET_VERIFY_HOLIDAY_PLAN         2128    //��ȡ��������֤��ʽ���ռƻ�����
#define NET_DVR_SET_VERIFY_HOLIDAY_PLAN         2129    //���ö�������֤��ʽ���ռƻ�����
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN     2130    //��ȡ��Ȩ�޼��ռƻ�����
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN     2131    //���ÿ�Ȩ�޼��ռƻ�����
#define NET_DVR_GET_VERIFY_HOLIDAY_GROUP        2132    //��ȡ��������֤��ʽ���������
#define NET_DVR_SET_VERIFY_HOLIDAY_GROUP        2133    //���ö�������֤��ʽ���������
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP    2134    //��ȡ��Ȩ�޼��������
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP    2135    //���ÿ�Ȩ�޼��������
#define NET_DVR_GET_VERIFY_PLAN_TEMPLATE        2136    //��ȡ��������֤��ʽ�ƻ�ģ�����
#define NET_DVR_SET_VERIFY_PLAN_TEMPLATE        2137    //���ö�������֤��ʽ�ƻ�ģ�����
#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE    2138    //��ȡ��Ȩ�޼ƻ�ģ�����
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE    2139    //���ÿ�Ȩ�޼ƻ�ģ�����
#define NET_DVR_GET_CARD_READER_CFG	            2140	//��ȡ����������
#define NET_DVR_SET_CARD_READER_CFG             2141    //���ö���������
#define NET_DVR_GET_CARD_READER_PLAN            2142    //��ȡ��������֤�ƻ�����
#define NET_DVR_SET_CARD_READER_PLAN            2143    //���ö�������֤�ƻ�����
#define NET_DVR_GET_CASE_SENSOR_CFG	            2144	//��ȡ�¼�����������
#define NET_DVR_SET_CASE_SENSOR_CFG             2145    //�����¼�����������
#define NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG  2146    //��ȡ��������Ǳ�ز���
#define NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG  2147    //���ö�������Ǳ�ز���
#define NET_DVR_GET_PHONE_DOOR_RIGHT_CFG        2148    //��ȡ�ֻ������Ȩ�޲���
#define NET_DVR_SET_PHONE_DOOR_RIGHT_CFG        2149    //��ȡ�ֻ������Ȩ�޲���
#define NET_DVR_GET_FINGERPRINT_CFG             2150    //��ȡָ�Ʋ���
#define NET_DVR_SET_FINGERPRINT_CFG             2151    //����ָ�Ʋ���
#define NET_DVR_DEL_FINGERPRINT_CFG             2152    //ɾ��ָ�Ʋ���
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG      2153    //��ȡ�¼������������ò���
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG      2154    //�����¼������������ò���
#define NET_DVR_GET_ANTI_SNEAK_HOST_CFG	        2155	//��ȡ�����鷴Ǳ�ز���
#define NET_DVR_SET_ANTI_SNEAK_HOST_CFG         2156    //���������鷴Ǳ�ز���
#define NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG  2157    //��ȡ�������������Ǳ�ز���
#define NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG  2158    //�����������������Ǳ�ز���
#define NET_DVR_GET_ACS_CFG                     2159    //��ȡ�Ž��������
#define NET_DVR_SET_ACS_CFG                     2160    //�����Ž��������
#define NET_DVR_GET_CARD_PASSWD_CFG	            2161	//��ȡ�����뿪��ʹ������
#define NET_DVR_SET_CARD_PASSWD_CFG             2162    //���ÿ����뿪��ʹ������
#define NET_DVR_GET_CARD_USERINFO_CFG           2163    //��ȡ���Ź����û���Ϣ����
#define NET_DVR_SET_CARD_USERINFO_CFG           2164    //���ÿ��Ź����û���Ϣ����

#define NET_DVR_GET_ACS_EXTERNAL_DEV_CFG     2165   //��ȡ�Ž�������������
#define NET_DVR_SET_ACS_EXTERNAL_DEV_CFG     2166   //�����Ž�������������
#define NET_DVR_GET_PERSONNEL_CHANNEL_CFG    2167   //��ȡ��Աͨ������
#define NET_DVR_SET_PERSONNEL_CHANNEL_CFG    2168   //������Աͨ������


#define NET_DVR_GET_SAFETYCABIN_STATE			2197    //��ȡ������״̬
#define NET_DVR_GET_RS485_CASCADE_CFG			2198   //��ȡRs485�����豸����
#define NET_DVR_SET_RS485_CASCADE_CFG			2199   //����Rs485�����豸����

/*************************************��Ƶ��������2.0 begin*************************************/
#define NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG		2200	//��ȡң����Ȩ�޲���
#define NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG		2201	//����ң����Ȩ�޲���
#define NET_DVR_GET_KEYBOARD_ALARM_CFG					2202	//��ȡ���̱�����������
#define NET_DVR_SET_KEYBOARD_ALARM_CFG					2203	//���ü��̱�����������
#define	NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO	2204	//����ҵ���ѯ
#define	NET_DVR_GET_ALL_REMOTECONTROLLER_LIST			2205	//��ȡ����ң����
#define	NET_DVR_GET_PREVIEW_DELAY_CFG					2206	//��ȡ�ӳ�Ԥ����������
#define	NET_DVR_SET_PREVIEW_DELAY_CFG					2207	//�����ӳ�Ԥ����������
#define NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG			2208	//��ȡ����������Ƶͨ������
#define NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG			2209	//���÷���������Ƶͨ������
#define NET_DVR_GET_CENTER_SERVER_CFG					2210	//��ȡ�������ķ�����
#define NET_DVR_SET_CENTER_SERVER_CFG					2211	//���ñ������ķ�����
/*************************************��Ƶ��������2.0 end**************************************/

/**********************************������������V3.0****************************************/
#define NET_DVR_GET_ALL_ALARM_RS485CFG			2705	// ��ȡ485����
#define NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG		2706		// ��ȡ���б�������485��λ����
#define NET_DVR_GET_DEVICE_SELF_CHECK_STATE		2707	//��ȡ�豸�Լ칦��
#define NET_DVR_GET_ALL_ALARM_POINT_CFG			2708	// ��ȡ���е�Ų���
#define NET_DVR_GET_ALL_ALARM_SENSOR_CFG		2709	// ��ȡ����ģ��������
#define NET_DVR_GET_ALL_ALARM_SENSOR_JOINT		2710	//��ȡ����ģ������������
#define NET_DVR_GET_AIR_CONDITION_PARAM			2711	//��ȡ�յ�����
#define NET_DVR_GET_OUT_SCALE_CFG				2712        //��ȡ�������������
#define NET_DVR_SET_OUT_SCALE_CFG				2713        //�����������������
#define NET_DVR_GET_ALARM_CHAN_ABLITITY			2714        //��ȡ�������ͨ����
/**********************************������������V3.0****************************************/

//������������D2000 V1.0
#define NET_DVR_GET_ALARMCENTER_NETCFG			2715        //��ȡ�������������������
#define NET_DVR_SET_ALARMCENTER_NETCFG			2716        //��ȡ�������������������


#define NET_ITC_GET_TRIGGERCFG                  3003  //��ȡ��������
#define NET_ITC_SET_TRIGGERCFG                  3004  //���ô�������
#define NET_ITC_GET_IOOUT_PARAM_CFG	            3005  //��ȡIO�������3.1��֮��汾��
#define NET_ITC_SET_IOOUT_PARAM_CFG	            3006  //����IO�������3.1��֮��汾��

#define NET_DVR_GET_CAMERA_SETUPCFG		        3007  //��ȡ���������
#define NET_DVR_SET_CAMERA_SETUPCFG		        3008  //�������������

#define NET_ITC_GET_TRIGGER_DEFAULTCFG          3013  //��ȡ����ģʽ�Ƽ�����
#define NET_DVR_GET_STATUS_DETECTCFG            3015  //��ȡ״̬���ʹ�ܲ���
#define NET_DVR_SET_STATUS_DETECTCFG            3016  //����״̬���ʹ�ܲ���
#define NET_ITC_GET_VIDEO_TRIGGERCFG            3017  //��ȡ��Ƶ�羯��������
#define NET_ITC_SET_VIDEO_TRIGGERCFG            3018  //������Ƶ�羯��������
#define NET_DVR_GET_TPS_ALARMCFG			    3019  //��ȡ��ͨͳ�Ʊ�������
#define NET_DVR_SET_TPS_ALARMCFG			    3020  //���ý�ͨͳ�Ʊ�������


#define NET_DVR_GET_REDAREACFG                  3100   //��ȡ���̵��������
#define NET_DVR_SET_REDAREACFG                  3101   //���ú��̵��������
#define	NET_DVR_GET_TEST_SPOT					3102   //��ȡSPOT�ڲ����ܲ���͵�ǰ�ڼ���
#define	NET_DVR_SET_TEST_SPOT					3103   //����SPOT�ڲ����ܲ���͵�ǰ�ڼ���
#define NET_DVR_GET_CABINETCFG					3104   //���������û�ȡ
#define NET_DVR_SET_CABINETCFG					3105   //��������������
#define NET_DVR_VEHICLE_CHECK_START				3106   //��������ݻش�
#define NET_DVR_SET_CAPTUREPIC_CFG				3107   //����ץͼ������������
#define NET_DVR_GET_CAPTUREPIC_CFG				3108   //����ץͼ���û�ȡ����
#define NET_DVR_SET_MOBILEPLATE_RECOG_CFG		3109   //���س���ʶ��������������
#define NET_DVR_GET_MOBILEPLATE_RECOG_CFG		3110   //���س���ʶ�����û�ȡ����
#define NET_DVR_SET_MOBILE_RADAR_CFG			3111   //�����״�������������
#define NET_DVR_GET_MOBILE_RADAR_CFG			3112   //�����״����û�ȡ����
#define NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG	3113   //���غ����ضԱ�������������
#define NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG	3114   //���غ����ضԱ����û�ȡ����

#define  NET_ITC_GET_ICRCFG						3115   //��ȡICR�����л�
#define  NET_ITC_SET_ICRCFG						3116   //����ICR�����л�
#define  NET_ITC_GET_RS485_ACCESSINFO			3117   //��ȡRs485���������豸����Ϣ
#define  NET_ITC_SET_RS485_ACCESSINFO			3118   //����Rs485���������豸����Ϣ
#define  NET_ITC_GET_EXCEPTIONCFG 				3119   //��ȡ�쳣����
#define  NET_ITC_SET_EXCEPTIONCFG				3120   //�����쳣����
#define  NET_ITC_GET_FTPCFG						3121   //��ȡITC  FTP���ò���
#define  NET_ITC_SET_FTPCFG						3122   //����ITC FTP���ò���

#define  NET_DVR_VEHICLE_CONTROL_LIST_START     3123   //���ó����ڰ�����Ϣ
#define  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST   3124   //��ȡ���г����ڰ�����Ϣ
#define  NET_DVR_VEHICLE_DELINFO_CTRL           3125   //ɾ���豸�ں�����ݿ���Ϣ
#define  NET_DVR_GET_ENTRANCE_PARAMCFG			3126   //��ȡ����ڿ��Ʋ���
#define  NET_DVR_SET_ENTRANCE_PARAMCFG			3127   //���ó���ڿ��Ʋ���
#define  NET_DVR_BARRIERGATE_CTRL               3128   //Զ�̿��Ƶ�բ
#define  NET_DVR_GATELAMP_CTRL                  3129   //�����ƹ���
#define  NET_DVR_GET_CURTRIGGERMODE             3130   //��ȡ�豸��ǰ����ģʽ
#define  NET_DVR_GET_GPSDATACFG					3131   //��ȡGPS����
#define  NET_DVR_SET_GPSDATACFG					3132   //����GPS����
#define  NET_DVR_VEHICLELIST_CTRL_START			3133   //���ó����ڰ�����Ϣ

#define  NET_DVR_GET_GUARDCFG                   3134   //��ȡ����ʶ����ƻ�
#define  NET_DVR_SET_GUARDCFG                   3135   //���ó���ʶ����ƻ�
#define  NET_DVR_GET_SNAPINFO_CFG               3136   //��ȡץ��ͼƬ����
#define  NET_DVR_SET_SNAPINFO_CFG               3137   //����ץ��ͼƬ����
#define  NET_DVR_GET_SNAPINFO_CFG_V40           3138   //��ȡץ��ͼƬ������չ
#define  NET_DVR_SET_SNAPINFO_CFG_V40           3139   //����ץ��ͼƬ������չ
#define  NET_DVR_SET_CURTRIGGERMODE				3140   //�����豸��ǰ����ģʽ(��IPC/D֧��)
#define	 NET_DVR_GET_TRAFFIC_DATA	            3141   //�����ӻ�ȡ��ͨ���
#define	 NET_DVR_GET_TRAFFIC_FLOW	            3142   //�����ӻ�ȡ��ͨ����
#define  NET_DVR_PARKING_VEHICLE_SEND           3143   //ͣ��������Ϣ�·�
#define  NET_DVR_PARKING_CARD_SEND              3144   //ͣ�����·�
#define	 NET_DVR_PARKING_CARD_CTRL	            3145   //ͣ����ͣ�������ƽӿ�

#define NET_DVR_GET_AUDIO_INPUT                 3201   //��ȡ��Ƶ�������
#define NET_DVR_SET_AUDIO_INPUT                 3202  //������Ƶ�������
#define NET_DVR_GET_CAMERA_DEHAZE_CFG           3203   //��ȡ͸���������
#define NET_DVR_SET_CAMERA_DEHAZE_CFG           3204  //����͸���������
#define NET_DVR_REMOTECONTROL_ALARM             3205  //Զ�̿���ң��������
#define NET_DVR_REMOTECONTROL_DISALARM          3206  //Զ�̿���ң��������
#define NET_DVR_REMOTECONTROL_STUDY             3207  //Զ�̿���ң����ѧϰ
#define NET_DVR_WIRELESS_ALARM_STUDY            3208  //Զ�̿������߱���ѧϰ
#define NET_IPC_GET_AUX_ALARMCFG                3209   //��ȡ������������
#define NET_IPC_SET_AUX_ALARMCFG                3210  //���ø�����������
#define NET_DVR_GET_PREVIEW_DISPLAYCFG	        3211  //��ȡԤ����ʾ����
#define NET_DVR_SET_PREVIEW_DISPLAYCFG	     	3212  //����Ԥ����ʾ����
#define NET_DVR_REMOTECONTROL_PTZ            	3213  //Զ�̿���PTZ
#define NET_DVR_REMOTECONTROL_PRESETPOINT   	3214   //Զ�̿���Ԥ�õ�
#define NET_DVR_REMOTECONTROL_CRUISE         	3215   //Զ�̿���Ѳ��

#define NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG  3216 //Զ�̻�ȡ������ѹ������
#define NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG  3217 //Զ�����ö�����ѹ������

#define NET_DVR_GET_WPSCFG	                    3218  //��ȡWPS����
#define NET_DVR_SET_WPSCFG	                    3219  //����WPS����
#define NET_DVR_WPS_CONNECT                     3220  //Զ������WPS����
#define NET_DVR_GET_DEVICE_PIN                  3221  //��ȡ�豸PIN��
#define NET_DVR_UPDATE_PIN                      3223  //�����豸PIN��
#define NET_DVR_GET_PRESETCFG           		3224  //��ȡԤ�õ����
#define NET_DVR_GET_PTZCRUISECFG        		3225  //��ȡѲ��·������
#define NET_DVR_GET_PRESET_NUM		    		3226  //��ȡԤ�õ����
#define NET_DVR_GET_PTZCRUISE_NUM				3227  //��ȡѲ��·������

#define NET_DVR_GET_MOTION_TRACK_CFG			3228  //��ȡ���ٲ���
#define NET_DVR_SET_MOTION_TRACK_CFG			3229  //���ø��ٲ���

#define NET_DVR_GET_IPADDR_FILTERCFG		    3232  //��ȡIP��ַ���˲���
#define NET_DVR_SET_IPADDR_FILTERCFG		    3233  //����IP��ַ���˲���

#define NET_DVR_GET_LOGO_OVERLAYCFG	            3234  //��ȡLOGOͼƬ���Ӳ���
#define NET_DVR_SET_LOGO_OVERLAYCFG	            3235  //����LOGOͼƬ���Ӳ���

#define NET_DVR_GET_IPV6_LIST                   3236  //��ȡ���ȫ��IPV6��ַ��Ϣ
#define NET_DVR_GET_AUDIOOUT_VOLUME             3237  //��ȡ�����Ƶ��С
#define NET_DVR_SET_AUDIOOUT_VOLUME             3238  //���������Ƶ��С
#define NET_DVR_GET_FUZZY_UPGRADE               3239  //��ȡģ����ƥ����Ϣ

#define NET_DVR_GET_BV_CORRECT_PARAM            3240  //��ȡ���У�����
#define NET_DVR_SET_BV_CORRECT_PARAM            3241  //�������У�����
#define NET_DVR_GET_OUTPUT_VIDEO_TYPE           3242  //��ȡ�����Ƶ����
#define NET_DVR_SET_OUTPUT_VIDEO_TYPE           3243  //���������Ƶ����

#define NET_DVR_FISHEYE_CFG                     3244  //���۳���������
#define NET_DVR_GET_PTZ_POINT                   3245  //��ȡPTZ�����
#define NET_DVR_SET_PTZ_POINT                   3246  //����PTZ�����
#define NET_DVR_REMOTECONTROL_DEV_PARAM         3247  //�����豸��¼�ͻ��˲���
#define NET_DVR_GET_FISHEYE_STREAM_STATUS       3248  //��ȡ��������״̬

#define NET_DVR_GET_GBT28181_ACCESS_CFG			3249  //��ȡGBT28181Э���������
#define NET_DVR_SET_GBT28181_ACCESS_CFG			3250  //����GBT28181Э���������
#define NET_DVR_GET_GBT28181_CHANINFO_CFG		3251  //��ȡGBT28181Э������豸��ͨ����Ϣ
#define NET_DVR_SET_GBT28181_CHANINFO_CFG		3252  //����GBT28181Э������豸��ͨ����Ϣ
#define NET_DVR_GET_GBT28181_ALARMINCFG			3253  //��ȡGBT28181Э������豸�ı�����Ϣ
#define NET_DVR_SET_GBT28181_ALARMINCFG			3254  //����GBT28181Э������豸�ı�����Ϣ
#define NET_DVR_GET_ISP_CAMERAPARAMCFG			3255  //��ȡISPǰ�˲�������
#define NET_DVR_SET_ISP_CAMERAPARAMCFG			3256  //����ISPǰ�˲�������
#define NET_DVR_GET_DEVSERVER_CFG				3257  //��ȡģ���������
#define NET_DVR_SET_DEVSERVER_CFG				3258  //����ģ���������

//2013-11-25
#define	NET_DVR_GET_WIPERINFO_CFG				3259     //��ˢ���û�ȡ
#define	NET_DVR_SET_WIPERINFO_CFG				3260     //��ˢ��������
#define NET_DVR_GET_TRACK_DEV_PARAM             3261   //��ȡ�����豸����
#define NET_DVR_SET_TRACK_DEV_PARAM             3262   //���ø����豸����
#define NET_DVR_GET_PTZ_TRACK_PARAM             3263   //��ȡPTZ���ٲ���
#define NET_DVR_SET_PTZ_TRACK_PARAM             3264   //����PTZ���ٲ���
#define NET_DVR_GET_CENTER_POINT_CFG		    3265   //��ȡ���ĵ����
#define NET_DVR_SET_CENTER_POINT_CFG		    3266   //�������ĵ����
#define NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES		3267	//��ȡ���ĵ��������
#define NET_DVR_GET_FISHEYE_CAPABILITIES		3268		//��ȡ��������

#define NET_DVR_GET_BASICPARAMCFG				3270 //��ȡPTZ���û������Ϣ
#define NET_DVR_SET_BASICPARAMCFG				3271 //����PTZ���û������Ϣ
#define NET_DVR_GET_PTZOSDCFG					3272 //��ȡPTZ OSD���ò�����Ϣ
#define NET_DVR_SET_PTZOSDCFG					3273 //����PTZ OSD���ò�����Ϣ
#define NET_DVR_GET_POWEROFFMEMCFG				3274 //��ȡ�������ģʽ������Ϣ
#define NET_DVR_SET_POWEROFFMEMCFG				3275 //���õ������ģʽ������Ϣ
#define NET_DVR_GET_LIMITCFG					3276 //��ȡ��λ����������Ϣ
#define NET_DVR_SET_LIMITCFG					3277 //������λ����������Ϣ
#define NET_DVR_PTZLIMIT_CTRL				    3278 //�����λ�������

#define NET_DVR_PTZ_CLEARCTRL	                3279 //���������Ϣ���ƽӿ�
#define NET_DVR_GET_PRIORITIZECFG	            3281 //��ȡ��̨����������Ϣ
#define NET_DVR_SET_PRIORITIZECFG	            3282 //������̨����������Ϣ
#define NET_DVR_PTZ_INITIALPOSITIONCTRL	        3283 //�㷽λ�ǿ���
#define NET_DVR_GET_PRIVACY_MASKSCFG            3285 //��ȡ��˽�ڱβ���
#define NET_DVR_SET_PRIVACY_MASKSCFG            3286 //������˽�ڱβ���
#define NET_DVR_GET_PTZLOCKCFG					3287 //��ȡ��̨����Ϣ
#define NET_DVR_SET_PTZLOCKCFG					3288 //������̨����Ϣ
#define NET_DVR_PTZ_ZOOMRATIOCTRL	            3289 //���ø��ٱ���
#define NET_DVR_GET_PTZLOCKINFO					3290 //��ȡ��̨��ʣ������
#define NET_DVR_GET_PRIVACY_MASKS_ENABLECFG	    3291 //��ȡȫ��ʹ��
#define NET_DVR_SET_PRIVACY_MASKS_ENABLECFG	    3292 //����ȫ��ʹ��
#define NET_DVR_GET_SMARTTRACKCFG	            3293 //��ȡ�����˶�����������Ϣ
#define NET_DVR_SET_SMARTTRACKCFG	            3294 //���������˶�����������Ϣ
#define NET_DVR_GET_EPTZ_CFG		            3295 //��ȡEPTZ����
#define NET_DVR_SET_EPTZ_CFG		            3296 //����EPTZ����
#define NET_DVR_GET_EPTZ_CFG_CAPABILITIES		3297 //��ȡEPTZ��������

#define NET_DVR_GET_LOW_LIGHTCFG                3303//��ȡ������ն�������Ϣ
#define NET_DVR_SET_LOW_LIGHTCFG                3304//���ÿ�����ն�������Ϣ
#define NET_DVR_GET_FOCUSMODECFG                3305//��ȡ����۽�ģʽ��Ϣ
#define NET_DVR_SET_FOCUSMODECFG                3306//���ÿ���۽�ģʽ��Ϣ
#define NET_DVR_GET_INFRARECFG                  3307//��ȡ�������������Ϣ
#define NET_DVR_SET_INFRARECFG                  3308//���ÿ������������Ϣ
#define NET_DVR_GET_AEMODECFG                   3309//��ȡ��������������Ϣ
#define NET_DVR_SET_AEMODECFG                   3310//���ÿ�������������Ϣ
#define NET_DVR_CONTROL_RESTORE_SUPPORT         3311 //�ָ�ǰ��Ĭ�ϲ���(�����������е�ǰ�˲���������صĶ��ָ�)
#define NET_DVR_CONTROL_RESTART_SUPPORT         3312 //�����о����
#define NET_DVR_CONTROL_PTZ_PATTERN             3313//��̨����ɨ��
#define NET_DVR_GET_PTZ_PARKACTION_CFG          3314//��ȡ��̨�������
#define NET_DVR_SET_PTZ_PARKACTION_CFG          3315//������̨�������
#define NET_DVR_CONTROL_PTZ_MANUALTRACE         3316//�ֶ����ٶ�λ
#define NET_DVR_GET_ROI_DETECT_NUM				3349 //��ȡROI�����������Ŀ
#define NET_DVR_GET_ROI_DETECT					3350 //��ȡROI�����������
#define NET_DVR_SET_ROI_DETECT					3351 //����ROI�����������
#define NET_DVR_GET_FACE_DETECT					3352 //��ȡ�����������
#define NET_DVR_SET_FACE_DETECT					3353 //���������������
#define NET_DVR_GET_CORRIDOR_MODE				3354 //��ȡ����ģʽ��������
#define NET_DVR_SET_CORRIDOR_MODE				3355 //��������ģʽ��������
#define NET_DVR_GET_SCENECHANGE_DETECTIONCFG    3356 //��ȡ�����������
#define NET_DVR_SET_SCENECHANGE_DETECTIONCFG	3357 //���ó����������
#define NET_DVR_GET_TRAVERSE_PLANE_DETECTION    3360
#define NET_DVR_SET_TRAVERSE_PLANE_DETECTION    3361
#define NET_DVR_GET_FIELD_DETECTION				3362 //��ȡ�����������
#define NET_DVR_SET_FIELD_DETECTION				3363 //���������������
#define NET_DVR_GET_DEFOCUSPARAM				3364 //��ȡ�齹����������
#define NET_DVR_SET_DEFOCUSPARAM				3365 //�����齹����������
#define NET_DVR_GET_AUDIOEXCEPTIONPARAM			3366 //��ȡ��Ƶ�쳣����
#define NET_DVR_SET_AUDIOEXCEPTIONPARAM			3367 //������Ƶ�쳣����
#define NET_DVR_GET_CCDPARAMCFG_EX              3368 //��ȡCCD��������
#define NET_DVR_SET_CCDPARAMCFG_EX              3369 //����CCD��������
#define NET_DVR_START_GET_INPUTVOLUME			3370//��ʼ��ȡ����
#define NET_DVR_SET_SCH_TASK					3380 //�������ʱ����
#define NET_DVR_GET_SCH_TASK					3381  //��ȡ���ʱ����
#define NET_DVR_SET_PRESET_NAME					3382 //����Ԥ�õ����
#define NET_DVR_GET_PRESET_NAME					3383 //��ȡԤ�õ����
#define NET_DVR_SET_AUDIO_NAME					3384 //�����������
#define NET_DVR_GET_AUDIO_NAME					3385  //��ȡ�������
#define NET_DVR_RESUME_INITRACKPOS              3386  //�ָ����ٳ�ʼλ
#define NET_DVR_NTP_SERVER_TEST					3387	//NTP����������
#define	NET_DVR_NAS_SERVER_TEST					3388	//NAS����������
#define	NET_DVR_EMAIL_SERVER_TEST				3389	//Email����������
#define	NET_DVR_FTP_SERVER_TEST					3390	//FTP����������
#define	NET_DVR_IP_TEST							3391	//IP����
#define NET_DVR_GET_NET_DISKCFG_V40 			3392 //����Ӳ�̽����ȡv40
#define NET_DVR_SET_NET_DISKCFG_V40				3393 //����Ӳ�̽�������v40
#define	NET_DVR_GET_IOOUT_CFG					3394//��ȡ����Ʋ���
#define	NET_DVR_SET_IOOUT_CFG				    3395//���ò���Ʋ���
#define	NET_DVR_GET_SIGNAL_SYNC				    3396//��ȡ�źŵ�ͬ�����ò���
#define	NET_DVR_SET_SIGNAL_SYNC				    3397//�����źŵ�ͬ�����ò���

#define	NET_DVR_GET_EZVIZ_ACCESS_CFG		    3398//��ȡEZVIZ�������
#define	NET_DVR_SET_EZVIZ_ACCESS_CFG		    3399//����EZVIZ�������
#define	NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG	    3400//��ȡ��ʱ���ܸ��ٲ���
#define	NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG	    3401//���ö�ʱ���ܸ��ٲ���
#define	NET_DVR_MAKE_I_FRAME				    3402//ǿ��I֡
#define NET_DVR_GET_ALARM_RELATE	            3403//��ȡ��������ͨ�����ܲ���
#define NET_DVR_SET_ALARM_RELATE	            3404//���ñ�������ͨ�����ܲ���
#define NET_DVR_GET_PDC_RULECFG_V42             3405  //����������ͳ�ƹ���(��չ)
#define NET_DVR_SET_PDC_RULECFG_V42             3406  //��ȡ������ͳ�ƹ���(��չ)
#define NET_DVR_GET_HEATMAP_CFG                 3407  //�����ȶ�ͼ��������
#define NET_DVR_SET_HEATMAP_CFG                 3408  //��ȡ�ȶ�ͼ��������
#define NET_DVR_REMOTECONTROL_LINEARSCAN        3409   //�������ұ߽���� 2014-03-15
#define NET_DVR_DPC_CTRL                        3410//����У�����
#define NET_DVR_FFC_MANUAL_CTRL                 3411//�Ǿ�����У��(FFC)�ֶ�ģʽ
#define NET_DVR_FFC_BACKCOMP_CTRL               3412//�Ǿ�����У��(FFC)��������
#define NET_DVR_GET_FOCUSING_POSITION_STATE     3413//��ȡ�۽���λ״̬����
#define NET_DVR_GET_PRIVATE_PROTOCOL_CFG	    3414   //��ȡ ˽�йؼ���Ϣ�ϴ����ýӿ�����
#define NET_DVR_SET_PRIVATE_PROTOCOL_CFG	    3415   //���� ˽�йؼ���Ϣ�ϴ����ýӿ�����
#define NET_DVR_COMPLETE_RESTORE_CTRL           3420    //������ȫ�ָ�����ֵ

#define NET_DVR_CLOUDSTORAGE_SERVER_TEST        3421  //�ƴ洢����������
#define NET_DVR_PHONE_NUM_TEST                  3422  //�绰�������
#define NET_DVR_GET_REMOTECONTROL_STATUS        3423  //��ȡ���߲���״̬
#define NET_DVR_GET_MONITOR_LOCATION_INFO	    3424  //��ȡ������Ϣ
#define NET_DVR_SET_MONITOR_LOCATION_INFO	    3425  //���ü�����Ϣ


#define	NET_DVR_GET_SMART_CAPABILITIES	            3500	//��ȡSmart����
#define	NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES	    3501	//��ȡ�¼���������
#define	NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES	3502	//��ȡ���������������
#define	NET_DVR_GET_REGION_ENTR_DETECTION	        3503	//��ȡ������������
#define	NET_DVR_SET_REGION_ENTR_DETECTION	        3504	//���ý�����������
#define	NET_DVR_GET_REGION_ENTR_REGION	            3505	//��ȡ��������ĵ�����������
#define	NET_DVR_SET_REGION_ENTR_REGION	            3506	//���ý�������ĵ�����������
#define	NET_DVR_GET_REGION_ENTR_TRIGGER	            3507	//��ȡ����������������
#define	NET_DVR_SET_REGION_ENTR_TRIGGER	            3508	//���ý���������������
#define	NET_DVR_GET_REGION_ENTR_SCHEDULE	        3509	//��ȡ�������򲼷�ʱ������
#define	NET_DVR_SET_REGION_ENTR_SCHEDULE	        3510	//���ý������򲼷�ʱ������
#define	NET_DVR_GET_REGION_EXITINT_CAPABILITIES	    3511	//��ȡ�뿪�����������
#define	NET_DVR_GET_REGION_EXITING_DETECTION	    3512	//��ȡ�뿪��������
#define	NET_DVR_SET_REGION_EXITING_DETECTION	    3513	//�����뿪��������
#define	NET_DVR_GET_REGION_EXITING_REGION	        3514	//��ȡ�뿪����ĵ�����������
#define	NET_DVR_SET_REGION_EXITING_REGION	        3515	//�����뿪����ĵ�����������
#define	NET_DVR_GET_REGION_EXIT_TRIGGER	            3516	//��ȡ�뿪������������
#define	NET_DVR_SET_REGION_EXIT_TRIGGER	            3517	//�����뿪������������
#define	NET_DVR_GET_REGION_EXIT_SCHEDULE	        3518	//��ȡ�뿪���򲼷�ʱ������
#define	NET_DVR_SET_REGION_EXIT_SCHEDULE	        3519	//�����뿪���򲼷�ʱ������
#define	NET_DVR_GET_LOITERING_CAPABILITIES	        3520	//��ȡ�ǻ��������
#define	NET_DVR_GET_LOITERING_DETECTION	            3521	//��ȡ�ǻ��������
#define	NET_DVR_SET_LOITERING_DETECTION	            3522	//�����ǻ��������
#define	NET_DVR_GET_LOITERING_REGION	            3523	//��ȡ�ǻ��ĵ�����������
#define	NET_DVR_SET_LOITERING_REGION            	3524	//�����ǻ��ĵ�����������
#define	NET_DVR_GET_LOITERING_TRIGGER	            3525	//��ȡ�ǻ���������
#define	NET_DVR_SET_LOITERING_TRIGGER	            3526	//�����ǻ���������
#define	NET_DVR_GET_LOITERING_SCHEDULE	            3527	//��ȡ�ǻ�����ʱ������
#define	NET_DVR_SET_LOITERING_SCHEDULE	            3528	//�����ǻ�����ʱ������
#define	NET_DVR_GET_GROUPDETECTION_CAPABILITIES	    3529	//��ȡ��Ա�ۼ��������
#define	NET_DVR_GET_GROUP_DETECTION	                3530	//��ȡ��Ա�ۼ��������
#define	NET_DVR_SET_GROUP_DETECTION	                3531	//������Ա�ۼ��������
#define	NET_DVR_GET_GROUPDETECTION_REGION	        3532	//��ȡ��Ա�ۼ��ĵ�����������
#define	NET_DVR_SET_GROUPDETECTION_REGION	        3533	//������Ա�ۼ��ĵ�����������
#define	NET_DVR_GET_GROUPDETECTION_TRIGGER	        3534	//��ȡ��Ա�ۼ���������
#define	NET_DVR_SET_GROUPDETECTION_TRIGGER	        3535	//������Ա�ۼ���������
#define	NET_DVR_GET_GROUPDETECTION_SCHEDULE	        3536	//��ȡ��Ա�ۼ�����ʱ������
#define	NET_DVR_SET_GROUPDETECTION_SCHEDULE	        3537	//������Ա�ۼ�����ʱ������
#define	NET_DVR_GET_RAPIDMOVE_CAPABILITIES	        3538	//��ȡ�����˶��������
#define	NET_DVR_GET_RAPIDMOVE_DETECTION	            3539	//��ȡ�����˶��������
#define	NET_DVR_SET_RAPIDMOVE_DETECTION	            3540	//���ÿ����˶��������
#define	NET_DVR_GET_RAPIDMOVE_REGION	            3541	//��ȡ�����˶��ĵ�����������
#define	NET_DVR_SET_RAPIDMOVE_REGION	            3542	//���ÿ����˶��ĵ�����������
#define	NET_DVR_GET_RAPIDMOVE_TRIGGER	            3543	//��ȡ�����˶���������
#define	NET_DVR_SET_RAPIDMOVE_TRIGGER	            3544	//���ÿ����˶���������
#define	NET_DVR_GET_RAPIDMOVE_SCHEDULE	            3545	//��ȡ�����˶��Ĳ���ʱ������
#define	NET_DVR_SET_RAPIDMOVE_SCHEDULE	            3546	//���ÿ����˶��Ĳ���ʱ������
#define	NET_DVR_GET_PATKING_CAPABILITIES	        3547	//��ȡͣ���������
#define	NET_DVR_GET_PARKING_DETECTION           	3548	//��ȡͣ���������
#define	NET_DVR_SET_PARKING_DETECTION	            3549	//����ͣ���������
#define	NET_DVR_GET_PARKING_REGION	                3550	//��ȡͣ�����ĵ�����������
#define	NET_DVR_SET_PARKING_REGION	                3551	//����ͣ�����ĵ�����������
#define	NET_DVR_GET_PARKING_TRIGGER	                3552	//��ȡͣ�������������
#define	NET_DVR_SET_PARKING_TRIGGER	                3553	//����ͣ�������������
#define	NET_DVR_GET_PARKING_SCHEDULE	            3554	//��ȡͣ�����Ĳ���ʱ������
#define	NET_DVR_SET_PARKING_SCHEDULE	            3555	//����ͣ�����Ĳ���ʱ������
#define	NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES	3556	//��ȡ��Ʒ�����������
#define	NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION	3557	//��ȡ��Ʒ�����������
#define	NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION	3558	//������Ʒ�����������
#define	NET_DVR_GET_UNATTENDED_BAGGAGE_REGION	    3559	//��ȡ��Ʒ�������ĵ�����������
#define	NET_DVR_SET_UNATTENDED_BAGGAGE_REGION	    3560	//������Ʒ�������ĵ�����������
#define	NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER	    3561	//��ȡ��Ʒ���������������
#define	NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER	    3562	//������Ʒ���������������
#define	NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE	    3563	//��ȡ��Ʒ�������Ĳ���ʱ������
#define	NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE	    3564	//������Ʒ�������Ĳ���ʱ������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES	3565	//��ȡ��Ʒ��ȡ�������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION	    3566	//��ȡ��Ʒ��ȡ�������
#define	NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION	    3567	//������Ʒ��ȡ�������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_REGION	        3568	//��ȡ��Ʒ��ȡ���ĵ�����������
#define	NET_DVR_SET_ATTENDEDBAGGAGE_REGION	        3569	//������Ʒ��ȡ���ĵ�����������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER	        3570	//��ȡ��Ʒ��ȡ�����������
#define	NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER	        3571	//������Ʒ��ȡ�����������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE	    3572	//��ȡ��Ʒ�������Ĳ���ʱ������
#define	NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE	    3573	//������Ʒ��ȡ���Ĳ���ʱ������
#define	NET_DVR_GET_REGIONCLIP_CAPABILITIES	        3574	//��ȡ����ü�����
#define	NET_DVR_GET_REGION_CLIP 	                3575	//��ȡ����ü�����
#define	NET_DVR_SET_REGION_CLIP 	                3576	//��������ü�����
#define	NET_DVR_GET_NETWORK_CAPABILITIES	        3577	//��ȡ��������
#define	NET_DVR_GET_WIRELESS_DIAL 	                3578	//��ȡ���߲�������
#define	NET_DVR_SET_WIRELESS_DIAL 	                3579	//�������߲�������
#define	NET_DVR_GET_WIRELESSDIAL_CAPABILITIES	    3580	//��ȡ���߲��Ų�������
#define	NET_DVR_GET_WIRELESSDIAL_SCHEDULE	        3581	//��ȡ���żƻ�����
#define	NET_DVR_SET_WIRELESSDIAL_SCHEDULE	        3582	//���ò��żƻ�����
#define	NET_DVR_GET_WIRELESSDIAL_STATUS 	        3583	//��ȡ����״̬
#define	NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES	3584	//��ȡ����������Ⲽ��ʱ������
#define	NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES	3585	//��ȡ�뿪������Ⲽ��ʱ������
#define	NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES	3586	//��ȡ�ǻ���Ⲽ��ʱ������
#define	NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES	3587	//��ȡ��Ա�ۼ���Ⲽ��ʱ������
#define	NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES	3588	//��ȡ�����˶���Ⲽ��ʱ������
#define	NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES	3589	//��ȡͣ����Ⲽ��ʱ������
#define	NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES	3590	//��ȡ��Ʒ������Ⲽ��ʱ������
#define	NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES	3591	//��ȡ��Ʒ��ȡ��Ⲽ��ʱ������
#define	NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES	3592	//��ȡ���żƻ�����
#define	NET_DVR_WIRELESSDIAL_CONNECT	3593	//�������������������

#define	NET_DVR_GET_LITESTORAGE	                3594	//��ȡ��洢����
#define	NET_DVR_SET_LITESTORAGE	                3595	//������洢����
#define	NET_DVR_GET_LITESTORAGE_CAPABILITIES	3596	//��ȡ��洢����

#define	NET_DVR_GET_VEHICLE_CAPABILITIES	3597	//��ȡ�������궨����
#define	NET_DVR_GET_VEHICLE_CALIBRATION 	3598	//��ȡ�������궨

#define	NET_DVR_GET_SLAVECAMERA_CAPABILITIES	3599    //��ȡ�������IP��Ϣ��������
#define	NET_DVR_GET_SLAVECAMERA					3600	//��ȡ�������IP��Ϣ����
#define	NET_DVR_SET_SLAVECAMERA					3601	//���ô������IP��Ϣ����
#define	NET_DVR_GET_SLAVECAMERA_STATUS			3602	//��ȡ�����������״̬
#define	NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES	3603  //��ȡ�����������&&�궨����
#define	NET_DVR_GET_SLAVECAMERA_CALIB			3604	//��ȡ�������궨����
#define	NET_DVR_SET_SLAVECAMERA_CALIB			3605	//���ô������궨����
#define NET_DVR_GET_PHY_RATIO					3606	//��ȡ���?�������Ϣ
#define NET_DVR_SET_PHY_RATIO					3607	//�������?�������Ϣ
#define NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES   3608  //��ȡ���Ӹ�������
#define	NET_DVR_SET_TRACKINGRATIO				3610	//���ô��������ٱ���
#define	NET_DVR_GET_TRACKING					3611	//��ȡ���Ӹ��ٹ�������������
#define	NET_DVR_SET_TRACKING					3612	//�������Ӹ��ٹ�������������
#define	NET_DVR_GET_TRACKING_CAPABILITIES		3613    //��ȡ���Ӹ��ٹ�����������������
#define	NET_DVR_GET_DDNS_COUNTRY_ABILITY	    3800//��ȡ�豸֧�ֵ�DDNS��������б�
#define	NET_DVR_GET_THERMAL_CAPABILITIES	    3634	//��ȡ�ȳ���Thermal������
#define	NET_DVR_GET_FIREDETECTION_CAPABILITIES	3635    //��ȡ�������������
#define	NET_DVR_GET_FIREDETECTION               3636	//��ȡ��������
#define	NET_DVR_SET_FIREDETECTION               3637	//���û�������
#define	NET_DVR_GET_FIREDETECTION_TRIGGER   	3638    //��ȡ�������������
#define	NET_DVR_SET_FIREDETECTION_TRIGGER	    3639	//���û������������

#define	NET_DVR_GET_PXOFFLINE_CAPABILITIES      3652	//��ȡͣ����Ʊ���ѻ��²������� ����
#define	NET_DVR_SET_PXOFFLINE_CFG	            3653	//����ͣ����Ʊ���ѻ��²���������Ϣ
#define	NET_DVR_GET_PXOFFLINE_CFG	            3654	//��ȡͣ����Ʊ���ѻ��²���������Ϣ
#define	NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES  3655  //��ȡͣ���������ֽƱ��Ϣ�·� ����
#define	NET_DVR_SET_PAPERCHARGEINFO	            3656	//����ͣ���������ֽƱ��Ϣ�·�
#define	NET_DVR_GET_PARKINGSAPCE_CAPABILITIES	3657	//��ȡͣ���������ͣ��λ��Ϣ�·� ����
#define	NET_DVR_SET_PARKINGSAPCE_INFO	        3658	//����ͣ���������ͣ��λ��Ϣ�·�
#define	NET_DVR_GET_PXMULTICTRL_CAPABILITIES	3659	//��ȡͣ����Ʊ������豸��ǶȲ������� ����
#define	NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES	3661	//��ȡͣ����Ʊ�������������
#define	NET_DVR_SET_CHARGE_ACCOUNTINFO          3662	//���ýɷѽ����Ϣ
#define	NET_DVR_SET_PXMULTICTRL_CFG	            3663	//����ͣ����Ʊ������豸��ǶȲ���������Ϣ
#define	NET_DVR_GET_PXMULTICTRL_CFG	            3664	//��ȡͣ����Ʊ������豸��ǶȲ���������Ϣ
#define	NET_DVR_GET_TME_CHARGERULE              3665	//��ȡͣ��������ڳ����շѹ������
#define	NET_DVR_SET_TME_CHARGERULE	            3666	//����ͣ��������ڳ����շѹ������
#define	NET_DVR_GET_TME_CHARGERULE_CAPABILITIES 3667	//��ȡͣ��������� �����շ���Ϣ��������
#define	NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES  3668	//��ȡͣ����Ʊ�������������
#define	NET_DVR_GET_ILLEGALCARDFILTERING_CFG    3669	//��ȡͣ����Ʊ���������
#define	NET_DVR_SET_ILLEGALCARDFILTERING_CFG    3670	//����ͣ����Ʊ���������
#define	NET_DVR_GET_LEDDISPLAY_CAPABILITIES	    3671	//��ȡLED��Ļ��ʾ�������ò�������
#define	NET_DVR_SET_LEDDISPLAY_CFG              3672	//����LED��Ļ��ʾ����
#define	NET_DVR_GET_LEDDISPLAY_CFG              3673	//��ȡLED��Ļ��ʾ����
#define	NET_DVR_GET_VOICEBROADCAST_CAPABILITIES	3674	//��ȡ�����������Ʋ������ò�������
#define	NET_DVR_SET_VOICEBROADCAST_CFG          3675	//���������������Ʋ���
#define	NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES	3676//��ȡֽƱ��ӡ��ʽ��������
#define	NET_DVR_GET_PAPERPRINTFORMAT_CFG	    3677    //��ȡֽƱ��ӡ��ʽ��������
#define	NET_DVR_SET_PAPERPRINTFORMAT_CFG	    3678    //����ֽƱ��ӡ��ʽ��������
#define	NET_DVR_GET_LOCkGATE_CAPABILITIES   	3679	//��ȡ������բ��������
#define	NET_DVR_GET_LOCKGATE_CFG            	3680    //��ȡ������բ��������
#define	NET_DVR_SET_LOCKGATE_CFG	            3681    //����������բ��������
#define NET_DVR_GET_PARKING_DATASTATE		    3682    //��ȡ���ͬ��״̬
#define NET_DVR_SET_PARKING_DATASTATE           3683    //�������ͬ��״̬
#define	NET_DVR_GET_TME_CAPABILITIES	        3684    //��ȡͣ����������豸 ����

#define	NET_DVR_GET_POSITION                    3698    // ��ȡ��λ�������ò���
#define	NET_DVR_SET_POSITION	                3699    // ���÷�λ�������ò���
#define	NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES	3700//��ȡ���в�������
#define	NET_DVR_GET_CENTRALIZEDCTRL	            3701//��ȡ���в��ز�������
#define	NET_DVR_SET_CENTRALIZEDCTRL          	3702//���ü��в��ز�������
#define	NET_DVR_GET_COMPASS_CAPABILITIES    	3703//��ȡ������������
#define	NET_DVR_GET_VANDALPROOFALARM          	3704//��ȡ���ƻ�������������
#define	NET_DVR_SET_VANDALPROOFALARM        	3705//���÷��ƻ�������������
#define	NET_DVR_COMPASS_CALIBRATE_CTRL	        3706//�������̽�����ƽӿ�
#define	NET_DVR_COMPASS_NORTH_CTRL	            3707//��������ָ������ƽӿ�
#define	NET_DVR_GET_AZIMUTHINFO	                3708//��ȡ��λ�ǶȲ�������


#define	NET_DVR_GET_SATELLITETIME	            3709//��ȡ���Ƕ�λ��������
#define	NET_DVR_SET_SATELLITETIME            	3710//�������Ƕ�λ��������
#define	NET_DVR_GET_GISINFO                 	3711//��ȡ��ǰ����GIS��Ϣ���
#define	NET_DVR_GET_STREAMING_CAPABILITIES	    3712//��ȡ��Ƶ��������
#define	NET_DVR_GET_REFRESHFRAME_CAPABILITIES	3713//��ȡˢ��֡������
#define	NET_DVR_STREAMING_REFRESH_FRAME	        3714//ȡ��Ԥ����ǿ��ˢ��֡
#define	NET_DVR_FACECAPTURE_STATISTICS	        3715//��������Աͳ��
#define	NET_DVR_GET_WIRELESSSERVER_CAPABILITIES	3716    //��ȡ�ȵ㹦������Э�������
#define	NET_DVR_GET_WIRELESSSERVER	            3717	//��ȡ�ȵ㹦������Э��
#define	NET_DVR_SET_WIRELESSSERVER	            3718	//�����ȵ㹦������Э��
#define	NET_DVR_GET_CONNECT_LIST_CAPABILITIES	3719    //��ȡ�����豸�б���Ϣ������
#define	NET_DVR_GET_THSCREEN_CAPABILITIES	    3720 //��ȡ��ʪ������Э�������
#define	NET_DVR_GET_THSCREEN	                3721 //��ȡ��ʪ������Э��
#define	NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES	3722//��ȡ��������Э�������
#define	NET_DVR_GET_EXTERNALDEVICE              3723//��ȡ��������Э��
#define	NET_DVR_SET_EXTERNALDEVICE	            3724//������������Э��
#define	NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES	 3725   //��ȡLED��ʾ��Ϣ������
#define	NET_DVR_SET_LEDDISPLAYINFO	             3726   //����LED��ʾ��Ϣ
#define	NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES 3727   //��ȡ���ò��������Э������� (���֧�֣����ʵ�֣��������������豸�ڲ���)
#define	NET_DVR_GET_SUPPLEMENTLIGHT	             3728	//��ȡ���ò��������Э��
#define	NET_DVR_SET_SUPPLEMENTLIGHT	             3729	//�������ò��������Э��
#define	NET_DVR_SET_THSCREEN	                 3730 //������ʪ������Э��
#define	NET_DVR_GET_LOWPOWER_CAPABILITIES        3731   //��ȡ�͹�������Э�������
#define	NET_DVR_GET_LOWPOWER	                 3732	//��ȡ�͹�������Э��
#define	NET_DVR_SET_LOWPOWER	                 3733	//���õ͹�������Э��
#define	NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES     3734   //��ȡ�䱶��������Э�������
#define	NET_DVR_GET_ZOOMLINKAGE	                 3735	//��ȡ�䱶��������Э��
#define	NET_DVR_SET_ZOOMLINKAGE	                 3736	//���ñ䱶��������Э��
#define	NET_DVR_THSCREEN_TIMING	                 3737	//��ʪ��
#define NET_DVR_GET_OSD_BATTERY_POWER_CFG		3741		//��ȡOSD��ص�����ʾ����
#define NET_DVR_SET_OSD_BATTERY_POWER_CFG		3742		//����OSD��ص�����ʾ����
#define	NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES	3743//OSD��ص�����ʾ���������
#define	NET_DVR_GET_VANDALPROOFALARM_TRIGGER	3744    //��ȡ���ƻ�������������
#define	NET_DVR_SET_VANDALPROOFALARM_TRIGGER	3745    //���÷��ƻ�������������
#define	NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES	3746    //��ȡȫ��ͼ�������
#define	NET_DVR_GET_PANORAMAIMAGE	            3747    //��ȡȫ��ͼ������Э��
#define	NET_DVR_SET_PANORAMAIMAGE	            3748    //����ȫ��ͼ������Э��
#define	NET_DVR_GET_STREAMENCRYPTION	        3749    //��ȡ������������
#define	NET_DVR_SET_STREAMENCRYPTION	        3750    //����������������
#define	NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES 3751  //��ȡ������������
#define	NET_DVR_GET_REVISE_GPS_CAPABILITIES     3752    //��ȡУ׼GPS��γ������
#define	NET_DVR_GET_REVISE_GPS                  3753    //��ȡУ׼GPS��γ������
#define	NET_DVR_SET_REVISE_GPS                  3754    //����У׼GPS��γ������
#define NET_DVR_GET_PDC_RECOMMEND		        3755    //��ȡ����ͳ�Ʊ�ʾ�Ƽ�ֵ
#define NET_DVR_REMOVE_FLASHSTORAGE		        3756    //�������������
#define	NET_DVR_GET_COUNTING_CAPABILITIES	    3757	//��ȡ������ͳ������
#define	NET_DVR_SET_SENSOR_ADJUSTMENT	        3758	//����Sensor ���ڲ����Э��
#define	NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES	    3759	//��ȡSensor ���ڲ����Э�������
#define	NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG 	    3760    //��ȡwifi�ȵ��������(�����)
#define	NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG 	    3761    //����wifi�ȵ��������(�����)

#define	NET_DVR_GET_ONLINEUSER_INFO	3762	//�����ӻ�ȡ�û�������Ϣ
/********************************��������ʶ��****************************/
#define NET_DVR_GET_FACESNAPCFG                 5001  //��ȡ����ץ�Ĳ���
#define NET_DVR_SET_FACESNAPCFG                 5002  //��������ץ�Ĳ���
#define NET_DVR_GET_DEVACCESS_CFG               5005  //��ȡ�����豸����
#define NET_DVR_SET_DEVACCESS_CFG               5006  //���ý����豸����
#define NET_DVR_GET_SAVE_PATH_CFG               5007  //��ȡ�洢��Ϣ����
#define NET_DVR_SET_SAVE_PATH_CFG               5008  //���ô洢��Ϣ����
#define NET_VCA_GET_RULECFG_V41			        5011  //��ȡ��Ϊ��������(��չ)
#define NET_VCA_SET_RULECFG_V41			        5012  //������Ϊ��������(��չ)
#define NET_DVR_GET_AID_RULECFG_V41             5013  //��ȡ��ͨ�¼��������
#define NET_DVR_SET_AID_RULECFG_V41             5014  //���ý�ͨ�¼��������
#define NET_DVR_GET_TPS_RULECFG_V41             5015  //��ȡ��ͨͳ�ƹ������(��չ)
#define NET_DVR_SET_TPS_RULECFG_V41             5016  //���ý�ͨͳ�ƹ������(��չ)
#define NET_VCA_GET_FACEDETECT_RULECFG_V41      5017  //��ȡATM����������(��չ)
#define NET_VCA_SET_FACEDETECT_RULECFG_V41      5018  //����ATM����������(��չ)
#define NET_DVR_GET_PDC_RULECFG_V41             5019  //����������ͳ�ƹ���(��չ)
#define NET_DVR_SET_PDC_RULECFG_V41             5020  //��ȡ������ͳ�ƹ���(��չ)
#define NET_DVR_GET_TRIAL_VERSION_CFG           5021  //��ȡ���ð���Ϣ
#define NET_DVR_GET_VCA_CTRLINFO_CFG            5022  //������ȡ���ܿ��Ʋ���
#define NET_DVR_SET_VCA_CTRLINFO_CFG            5023  //�����������ܿ��Ʋ���
#define NET_DVR_SYN_CHANNEL_NAME                5024  //ͬ��ͨ����
#define NET_DVR_GET_RESET_COUNTER               5025  //��ȡͳ����������������������ͨͳ�ƣ�
#define NET_DVR_SET_RESET_COUNTER               5026  //����ͳ����������������������ͨͳ�ƣ�
#define NET_DVR_GET_OBJECT_COLOR                5027  //��ȡ������ɫ����
#define NET_DVR_SET_OBJECT_COLOR                5028  //����������ɫ����
#define NET_DVR_GET_AUX_AREA                    5029  //��ȡ��������
#define NET_DVR_SET_AUX_AREA                    5030  //���ø�������
#define NET_DVR_GET_CHAN_WORKMODE               5031  //��ȡͨ������ģʽ
#define NET_DVR_SET_CHAN_WORKMODE               5032  //����ͨ������ģʽ
#define NET_DVR_GET_SLAVE_CHANNEL               5033  //��ȡ��ͨ������
#define NET_DVR_SET_SLAVE_CHANNEL               5034  //���ô�ͨ������
#define NET_DVR_GET_VQD_EVENT_RULE              5035  //��ȡ��Ƶ��������¼�����
#define NET_DVR_SET_VQD_EVENT_RULE              5036  //������Ƶ��������¼�����
#define NET_DVR_GET_BASELINE_SCENE              5037  //��ȡ��׼��������
#define NET_DVR_SET_BASELINE_SCENE              5038  //���û�׼��������
#define NET_DVR_CONTROL_BASELINE_SCENE          5039  //��׼��������
#define NET_DVR_SET_VCA_DETION_CFG				5040  //���������ƶ���������
#define NET_DVR_GET_VCA_DETION_CFG				5041  //��ȡ�����ƶ���������
#define NET_DVR_GET_STREAM_ATTACHINFO_CFG       5042  //��ȡ����������Ϣ����
#define NET_DVR_SET_STREAM_ATTACHINFO_CFG       5043  //��������������Ϣ����

#define NET_DVR_GET_BV_CALIB_TYPE               5044  //��ȡ˫Ŀ�궨����
#define NET_DVR_CONTROL_BV_SAMPLE_CALIB         5045  //˫Ŀ��궨
#define NET_DVR_GET_BV_SAMPLE_CALIB_CFG         5046  //��ȡ˫Ŀ�궨����
#define NET_DVR_GET_RULECFG_V42	                5049  //��ȡ��Ϊ��������(֧��16��������չ)
#define NET_DVR_SET_RULECFG_V42	                5050  //������Ϊ��������(֧��16��������չ)
#define NET_DVR_SET_VCA_DETION_CFG_V40			5051  //���������ƶ���������
#define NET_DVR_GET_VCA_DETION_CFG_V40  		5052  //��ȡ�����ƶ���������
/********************************��������ʶ�� end****************************/

//2014-12-03
#define	NET_DVR_GET_T1TEST_CFG   5053     //���߲������ýӿڣ���ȡ��
#define	NET_DVR_SET_T1TEST_CFG   5054     ////���߲������ýӿڣ����ã�

/********************************ITS****************************/
#define NET_ITS_GET_OVERLAP_CFG_V50		        5055  //��ȡ�ַ���Ӳ���������չ
#define NET_ITS_SET_OVERLAP_CFG_V50		        5056  //�����ַ���Ӳ���������չ

#define NET_DVR_GET_PARKLAMP_STATE				5057  //��ȡͣ�����źŵ�״̬��Ϣ
#define NET_DVR_GET_CLOUDSTORAGE_CFG			5058  //��ȡ�ƴ洢���ò���
#define NET_DVR_SET_CLOUDSTORAGE_CFG			5059  //�����ƴ洢���ò���

#define NET_ITS_GET_BASE_INFO		            5060  //��ȡ�ն˻���Ϣ
#define NET_DVR_GET_SENSOR_INFO                 5061  //��������Ϣ��ѯ
#define	NET_DVR_SET_SENSOR_SWITCH	            5062  //������Զ�̿���
#define NET_ITS_GET_IMGMERGE_CFG	            5063  //��ȡͼƬ�ϳ����ò���
#define NET_ITS_SET_IMGMERGE_CFG	            5064  //����ͼƬ�ϳ����ò���
#define NET_ITS_GET_UPLOAD_CFG		            5065  //��ȡ����ϴ�����
#define NET_ITS_SET_UPLOAD_CFG		            5066  //��������ϴ�����
#define	NET_DVR_GET_SENSOR_PORT_CAPABILITIES	5067  //��ȡ����������
#define NET_ITS_GET_WORKSTATE		            5069  //��ȡ�ն˹���״̬
#define NET_ITS_GET_IPC_CHAN_CFG	            5070  //��ȡͨ��IPC��Ϣ
#define NET_ITS_SET_IPC_CHAN_CFG	            5071  //����ͨ��IPC��Ϣ
#define NET_ITS_GET_OVERLAP_CFG		            5072  //��ȡ�ַ���Ӳ�������
#define NET_ITS_SET_OVERLAP_CFG	            	5073  //�����ַ���Ӳ�������
#define NET_DVR_GET_TRIGGEREX_CFG               5074  //��ȡITC��չ����
#define NET_DVR_SET_TRIGGEREX_CFG               5075  //����ITC��չ����
#define NET_ITS_GET_ROAD_INFO	            	5076  //��ȡ·����Ϣ

#define NET_ITS_REMOTE_DEVICE_CONTROL			5077//����Զ���豸����
#define NET_ITS_GET_GATEIPC_CHAN_CFG			5078//��ȡ����ڲ���
#define NET_ITS_SET_GATEIPC_CHAN_CFG			5079//���ó���ڲ���
#define NET_ITS_TRANSCHAN_START					5080//ͬ����ݷ�������������
#define NET_ITS_GET_ECTWORKSTATE				5081//��ȡ������ն˹���״̬
#define NET_ITS_GET_ECT_CHAN_INFO				5082//��ȡ������ն�ͨ��״̬
#define NET_DVR_GET_HEATMAP_RESULT              5083//�ȶ�ͼ��ݲ���
#define NET_DVR_SET_ITS_EXDEVCFG				5084 //����ITS����豸��Ϣ
#define NET_DVR_GET_ITS_EXDEVCFG				5085 //��ȡITS����豸��Ϣ
#define NET_DVR_GET_ITS_EXDEVSTATUS				5086 //��ȡITS��������豸��Ϣ
#define NET_DVR_SET_ITS_ENDEVCMD                5087 //����ITS�ն˳���ڿ�������
#define NET_DVR_SET_ENISSUED_DATADEL            5088 //����ITS�ն˳���ڿ������
#define NET_DVR_GET_PDC_RESULT                  5089//��������ݲ�ѯ 2014-03-21
#define NET_ITS_GET_LAMP_CTRLCFG				5090  //��ȡ�����õƲ���
#define NET_ITS_SET_LAMP_CTRLCFG				5091  //���������õƲ���
#define NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG     5092  //��ȡ���⳵λ����
#define NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG     5093  //�������⳵λ����
#define NET_ITS_SET_LAMP_EXTERNAL_CFG			5095  //����������ò���
#define NET_ITS_SET_COMPEL_CAPTURE				5096  //���ó�λǿ��ץͼ
#define NET_DVR_SET_TIMESIGN_CFG                5097  //������չУʱ�Զ�����
#define NET_DVR_GET_TIMESIGN_CFG                5098  //��ȡ��չУʱ�Զ�����
#define NET_DVR_GET_SIGNALLAMP_STATUS           5099  //�źŵƼ��
/********************************ITS end****************************/

#define NET_DVR_GET_MONITOR_PLAN_VQD			5100  //�����ӻ�ȡ��Ϸ������ƻ�
#define NET_DVR_GET_MONITORID_VQD               5101  //�����ӻ�ȡ��Ӧ�ƻ��ڵļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_INFO                5102  //�������üƻ��ڵļ�ص���Ϣ
#define NET_DVR_DEL_MONITOR_PLAN_VQD            5103  //ɾ��ƻ�
#define NET_DVR_GET_MONITOR_VQD_STATUS          5104  //ƽ̨��ѯ��Ϸ�������״̬
#define NET_DVR_GET_RECORD_INFO                 5105  //��ȡ��ԴͼƬ��ѯ
#define NET_DVR_GET_MONITOR_VQDCFG              5106  //��ȡ�������ļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_VQDCFG              5107  //���÷������ļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_PLAN_VQDCFG         5108  //���ù���ƻ�(�����ļƻ�)

#define NET_DVR_SCENE_CHANGE_UPDATE				5109   //���������ݸ���

/*************************���ܶೡ��********************************/
#define NET_DVR_GET_SCENE_CFG                   5201  //��ȡ������Ϣ
#define NET_DVR_SET_SCENE_CFG                   5202  //���ó�����Ϣ
#define NET_DVR_GET_SCENE_REFERENCE_REGION      5203  //��ȡ�ο�����
#define NET_DVR_SET_SCENE_REFERENCE_REGION      5204  //���òο�����
#define NET_DVR_GET_SCENE_CALIBRATION           5205  //��ȡ�궨��Ϣ
#define NET_DVR_SET_SCENE_CALIBRATION           5206  //���ñ궨��Ϣ
#define NET_DVR_GET_SCENE_MASK_REGION           5207  //��ȡ��������
#define NET_DVR_SET_SCENE_MASK_REGION           5208  //������������
#define	NET_DVR_GET_SCENE_LANECFG		        5209  //��ȡ��������
#define NET_DVR_SET_SCENE_LANECFG		        5210  //���ó�������
#define NET_DVR_GET_SCENE_AID_RULECFG           5211  //��ȡ��ͨ�¼��������
#define NET_DVR_SET_SCENE_AID_RULECFG           5212  //���ý�ͨ�¼��������
#define NET_DVR_GET_SCENE_TPS_RULECFG           5213  //��ȡ��ͨͳ�ƹ������
#define NET_DVR_SET_SCENE_TPS_RULECFG           5214  //���ý�ͨͳ�ƹ������
#define NET_DVR_GET_SCENE_TIME_CFG              5215  //��ȡͨ���ĳ���ʱ�������
#define NET_DVR_SET_SCENE_TIME_CFG              5216  //����ͨ���ĳ���ʱ�������
#define NET_DVR_GET_FORENSICS_MODE              5217  //��ȡȡ֤��ʽ����
#define NET_DVR_SET_FORENSICS_MODE              5218  //����ȡ֤��ʽ����
#define NET_DVR_FORCESTOP_FORENSICS_CTRL        5219  //ǿ��ֹͣȡ֤
#define NET_DVR_GET_ALARM_PROCESS_CFG           5220   //��ȡ�����������
#define NET_DVR_SET_ALARM_PROCESS_CFG           5221   //���ñ����������
#define NET_DVR_GET_BLACKLIST_ALARM_INFO        5222   //��ȡ�ڰ������켣
#define NET_DVR_GET_STORAGE_RESOURCE_CFG		5225   //��ȡ�洢��Դ����
#define NET_DVR_SET_STORAGE_RESOURCE_CFG		5226   //���ô洢��Դ����
#define NET_DVR_DEL_BLACKLIST_ALARM_RECORD		5227   //Զ��ɾ��������¼
#define NET_DVR_SET_BLACKLIST_GROUP_INFO		5229   //Զ�̷����б��������
#define NET_DVR_DEL_BLACKLIST_GROUP_INFO    	5230   //Զ��ɾ������б�
#define NET_DVR_GET_BLACKLIST_GROUP_INFO        5231   //Զ�̻�ȡȫ�������б�
#define NET_DVR_SET_BLACKLIST_GROUP_RECORD_CFG	5232   //�����¼��������
#define NET_DVR_GET_BLACKLIST_GROUP_RECORD_CFG	5234   //Զ�̻�ȡ�����¼����
#define NET_DVR_DEL_BLACKLIST_GROUP_RECORD_CFG	5235   //Զ��ɾ������¼����
#define	NET_DVR_GET_AREA_MONITOR_CFG            5236   //��ȡ�����ص����
#define	NET_DVR_SET_AREA_MONITOR_CFG            5237   //���������ص����
#define	NET_DVR_DEL_AREA_MONITOR_CFG            5238   //ɾ�������ص�
#define NET_DVR_RETRIEVAL_SNAP_RECORD	        5240   //ץ�Ŀ����
#define NET_DVR_GET_ALARMLIST	                5241   //��ȡ�����б�
#define NET_DVR_DETECT_IMAGE		            5242   //����ͼƬ���
#define NET_DVR_GET_SNAP_RECORD 	            5243   //��ȡץ�ļ�¼
#define NET_DVR_DEL_SNAP_RECORD 	            5244   //ɾ��ץ�ļ�¼
#define NET_DVR_GET_FACE_RECORD 				5245   //Զ�̻�ȡ������¼�б�
#define NET_DVR_SET_FACE_RECORD	                5246   //���������¼
#define NET_DVR_DEL_FACE_RECORD	                5247   //ɾ��������¼
#define NET_DVR_GET_FACE_DATABASE				5248   //��ȡ���������ò���
#define NET_DVR_SET_FACE_DATABASE				5249   //�������������ò���
#define NET_DVR_DEL_FACE_DATABASE				5250   //ɾ��������
#define NET_DVR_RETRIEVAL_FACE_DATABASE	        5251   //���������
#define NET_DVR_SET_BLACKLIST_REL_DEV_CFG		5252   //�豸������������
#define NET_DVR_DEL_BLACKLIST_REL_DEV			5253   //ɾ�� �豸�����������Ϣ
/*************************���ܶೡ��end*****************************/

#define NET_DVR_GET_DISK_RAID_INFO              6001  //��ȡ����Raid��Ϣ
#define NET_DVR_SET_DISK_RAID_INFO              6002  //���ô���Raid��Ϣ

#define NET_DVR_GET_DVR_SYNCHRONOUS_IPC         6005  //��ȡ���Ƿ�Ϊǰ��IPCͬ���豸����
#define NET_DVR_SET_DVR_SYNCHRONOUS_IPC         6006  //���ã��Ƿ�Ϊǰ��IPCͬ���豸����

#define NET_DVR_SET_DVR_IPC_PASSWD              6008  //���ã�IPC�û�������
#define NET_DVR_GET_DEVICE_NET_USING_INFO       6009  //��ȡ����ǰ�豸������Դʹ�����

#define NET_DVR_SET_DVR_IPC_NET                 6012  //���ã�����ǰ��IPC�������ַ

#define NET_DVR_GET_RECORD_CHANNEL_INFO         6013  //��ȡ��¼��ͨ����Ϣ
#define NET_DVR_SET_RECORD_CHANNEL_INFO         6014  //���ã�¼��ͨ����Ϣ


#define NET_DVR_MOUNT_DISK						6015     // ���ش���
#define NET_DVR_UNMOUNT_DISK				    6016     // ж�ش���

// CVR
#define NET_DVR_GET_STREAM_SRC_INFO				6017  //��ȡ������Դ��Ϣ
#define NET_DVR_SET_STREAM_SRC_INFO				6018  //���ã�����Դ��Ϣ
#define NET_DVR_GET_STREAM_RECORD_INFO			6019  //��ȡ����¼����Ϣ
#define NET_DVR_SET_STREAM_RECORD_INFO			6020  //���ã���¼����Ϣ
#define NET_DVR_GET_STREAM_RECORD_STATUS		6021  //��ȡ����¼��״̬
#define NET_DVR_SET_STREAM_RECORD_STATUS		6022  //���ã���¼��״̬
#define NET_DVR_GET_STREAM_INFO					6023  //��ȡ����ӵ���ID��Ϣ
#define NET_DVR_GET_STREAM_SRC_INFO_V40			6024  //��ȡ������Դ��Ϣ
#define NET_DVR_SET_STREAM_SRC_INFO_V40  		6025  //���ã�����Դ��Ϣ
#define NET_DVR_GET_RELOCATE_INFO               6026  //��ȡN+0ģʽ���ض�����Ϣ
#define NET_DVR_START_GOP_INFO_PASSBACK         6032  //������Ϣ����
#define NET_DVR_GET_CHANS_RECORD_STATUS_CFG     6035    //��ȡͨ��¼��״̬��Ϣ
#define NET_DVR_SET_CHANS_RECORD_STATUS_CFG     6036    //����ͨ��¼��״̬��Ϣ
//NVR��96xx
#define NET_DVR_GET_IP_ALARM_GROUP_NUM          6100  //��ȡ��IPͨ�����������������
#define NET_DVR_GET_IP_ALARM_IN                 6101  //��ȡ��IPͨ������������Ϣ
#define NET_DVR_GET_IP_ALARM_OUT                6102  //��ȡ��IPͨ�����������Ϣ

//9000 v2.2
#define NET_DVR_GET_FTPCFG_SECOND		        6103  	//��ȡͼƬ�ϴ�FTP����
#define NET_DVR_SET_FTPCFG_SECOND		        6104  	//����ͼƬ�ϴ�FTP����

#define NET_DVR_GET_DEFAULT_VIDEO_EFFECT		6105	   // ��ȡ��Ƶ����Ч�����Ĭ��ֵ
#define NET_DVR_SET_VIDEO_EFFECT				6106       // ����ͨ����Ƶ����ͼ�����
#define NET_DVR_DEL_INVALID_DISK				6107       // ɾ����Ч����

#define NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG	6109	//��ȡ��֡ͨ���������
#define NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG	6110	//���ó�֡ͨ���������

#define NET_DVR_GET_NAT_CFG                     6111     //��ȡNATӳ�����
#define NET_DVR_SET_NAT_CFG                     6112     //����NATӳ�����
#define NET_DVR_GET_AES_KEY                     6113     //��ȡ�豸AES������Կ
#define NET_DVR_GET_POE_CFG                     6114     //��ȡPOE����
#define NET_DVR_SET_POE_CFG                     6115     //����POE����
#define NET_DVR_GET_CUSTOM_PRO_CFG              6116     //��ȡ�Զ���Э�����
#define NET_DVR_SET_CUSTOM_PRO_CFG              6117     //�����Զ���Э�����
#define NET_DVR_GET_STREAM_CABAC                6118     //��ȡ����ѹ������ѡ��
#define NET_DVR_SET_STREAM_CABAC                6119     //��������ѹ������ѡ��
#define NET_DVR_GET_ESATA_MINISAS_USAGE_CFG	    6120  //��ȡeSATA��miniSAS��;
#define NET_DVR_SET_ESATA_MINISAS_USAGE_CFG	    6121  //����eSATA��miniSAS��;

#define NET_DVR_GET_HDCFG_V40			        6122  //��ȡӲ����Ϣ����
#define NET_DVR_SET_HDCFG_V40			        6123  //����Ӳ����Ϣ����
#define NET_DVR_GET_POE_CHANNEL_ADD_MODE        6124     //��ȡPOEͨ����ӷ�ʽ
#define NET_DVR_SET_POE_CHANNEL_ADD_MODE        6125     //����POEͨ����ӷ�ʽ
#define NET_DVR_GET_DIGITAL_CHANNEL_STATE       6126     //��ȡ�豸����ͨ��״̬
#define   NET_DVR_GET_BONJOUR_CFG               6127 // ��ȡBonjour��Ϣ
#define   NET_DVR_SET_BONJOUR_CFG               6128 // ����Bonjour��Ϣ


#define NET_DVR_GET_SOCKS_CFG	                6130//��ȡSOCKS��Ϣ
#define NET_DVR_SET_SOCKS_CFG  	                6131//����SOCKS��Ϣ

#define	NET_DVR_GET_QOS_CFG	                    6132//��ȡQoS��Ϣ
#define NET_DVR_SET_QOS_CFG	                    6133//����QoS��Ϣ

#define NET_DVR_GET_HTTPS_CFG		            6134//��ȡHTTPS��Ϣ
#define NET_DVR_SET_HTTPS_CFG		            6135//����HTTPS��Ϣ

#define NET_DVR_GET_WD1_CFG                     6136//Զ�̻�ȡWD1ʹ�ܿ���
#define NET_DVR_SET_WD1_CFG                     6137//Զ������WD1ʹ�ܿ���

#define NET_DVR_CREATE_CERT                     6138//����֤��
#define NET_DVR_DELETE_CERT                     6139//ɾ��֤��


#define NET_DVR_GET_RECORD_LOCK_PERCENTAGE	    6140  //��ȡ¼��������
#define NET_DVR_SET_RECORD_LOCK_PERCENTAGE      6141  //����¼��������

#define NET_DVR_CMD_TRIGGER_PERIOD_RECORD	    6144 //�ⲿ�����ָ��ʱ��¼��
#define NET_DVR_UPLOAD_CERT                     6145    //�ϴ�֤��
#define NET_DVR_DOWNLOAD_CERT                   6146     //����֤��
#define NET_DVR_GET_CERT                        6147     //��ȡ֤��

#define NET_DVR_GET_POS_FILTER_CFG				6148	//��ȡPOS���˹���
#define NET_DVR_SET_POS_FILTER_CFG				6149	//����POS���˹���
#define NET_DVR_GET_CONNECT_POS_CFG				6150    //��ȡDVR��POS���ӷ�ʽ
#define NET_DVR_SET_CONNECT_POS_CFG				6151	//����DVR��POS���ӷ�ʽ
#define NET_DVR_GET_CHAN_FILTER_CFG				6152	//��ȡ������ͨ��������Ϣ
#define NET_DVR_SET_CHAN_FILTER_CFG				6153    //���ù�����ͨ��������Ϣ


#define NET_DVR_GET_FTPCFG_V40		            6162	//��ȡFTP��Ϣ
#define NET_DVR_SET_FTPCFG_V40		            6163	//����FTP��Ϣ

#define NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION 6164   //��ȡ����¼��ֲ�
#define NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO  6165   //��ȡ������豸ͨ����Ϣ
#define NET_DVR_GET_PREVIEW_SWITCH_CFG			6166   //��ȡ�豸����Ԥ���л�����
#define NET_DVR_SET_PREVIEW_SWITCH_CFG			6167   //�����豸����Ԥ���л�����

//Netra3.0.0
#define NET_DVR_GET_N_PLUS_ONE_WORK_MODE			6168	//��ȡN+1����ģʽ
#define NET_DVR_SET_N_PLUS_ONE_WORK_MODE			6169	//����N+1����ģʽ

#define NET_DVR_GET_HD_STATUS	 					6170	//��ȡӲ��״̬
#define NET_DVR_SET_HD_STATUS	 					6171	//����Ӳ��״̬

#define NET_DVR_IMPORT_IPC_CFG_FILE					6172    //����IPC�����ļ�
#define NET_DVR_EXPORT_IPC_CFG_FILE					6173    //����IPC�����ļ�
#define NET_DVR_UPGRADE_IPC							6174    //��IPͨ��

#define NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED		6175	//��ȡRAID��̨�����ٶ�
#define NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED		6176	//����RAID��̨�����ٶ�

//marvell 256·NVR
#define NET_DVR_GET_EXCEPTIONCFG_V40                6177    //��ȡ�쳣��������
#define NET_DVR_SET_EXCEPTIONCFG_V40                6178    //�����쳣��������
#define NET_DVR_GET_PICCFG_V40                      6179    //��ȡͼ����� ֧�ֱ䳤	NetSDK_
#define NET_DVR_SET_PICCFG_V40                      6180    //����ͼ����� ֧�ֱ䳤
#define NET_DVR_GET_ALARMINCFG_V40                  6181    //��ȡ�����������֧�ֱ䳤
#define NET_DVR_SET_ALARMINCFG_V40                  6182    //��ȡ�����������֧�ֱ䳤
#define NET_DVR_GET_IPALARMINCFG_V40                6183    //��ȡIP�����������������Ϣ
#define NET_DVR_GET_IPALARMOUTCFG_V40               6185    //��ȡIP�����������������Ϣ
#define NET_DVR_GET_USERCFG_V40                     6187    //��ȡ�û�����
#define NET_DVR_SET_USERCFG_V40                     6188    //�����û�����
#define NET_DVR_GET_WORK_STATUS                     6189    //��ȡ�豸����״̬
#define NET_DVR_GET_JPEG_CAPTURE_CFG_V40            6190    //��ȡDVRץͼ����
#define NET_DVR_SET_JPEG_CAPTURE_CFG_V40            6191    //����DVRץͼ����
#define NET_DVR_GET_HDGROUP_CFG_V40                 6192    //��ȡ����������ò���
#define NET_DVR_SET_HDGROUP_CFG_V40                 6193    //��������������ò���
#define NET_DVR_GET_SMD_HOLIDAY_HANDLE              6194	//��ȡ�������ܼ��ռƻ�
#define NET_DVR_SET_SMD_HOLIDAY_HANDLE              6195	//���ü������ܼ��ռƻ�
#define NET_DVR_GET_PIC_MODEL_CFG                   6196    //��ȡͼƬ��ģ���ò���
#define NET_DVR_SET_PIC_MODEL_CFG                   6197	//����ͼƬ��ģ���ò���
#define NET_DVR_START_LOCAL_MOUSE_EVENT             6198    //�����豸��������¼���¼
#define NET_DVR_START_SIMULARE_MOUSE_EVENT          6199    //Զ��ģ������¼�

//91ϵ��HD-SDI����DVR
#define NET_DVR_GET_ACCESS_CAMERA_INFO          6201 // ��ȡǰ�������Ϣ
#define NET_DVR_SET_ACCESS_CAMERA_INFO          6202 // ����ǰ�������Ϣ
#define NET_DVR_PULL_DISK					    6203 // ��ȫ����
#define NET_DVR_SCAN_RAID					    6204 // ɨ������
// CVR 2.0.X
#define NET_DVR_GET_USER_RIGHT_CFG				6210        // ��ȡ�û�Ȩ��
#define NET_DVR_SET_USER_RIGHT_CFG				6211        // �����û�Ȩ��

#define NET_DVR_ONE_KEY_CONFIG			        6212		// һ������CVR
#define NET_DVR_RESTART_SERVICE					6213        // ����CVR����

#define NET_DVR_GET_MAX_MACHINE_NUM_CFG			6214		// ��ȡ����������
#define NET_DVR_SET_MAX_MACHINE_NUM_CFG			6215		// ���ñ���������

#define NET_DVR_ADD_DEVICE						6216		//N+1ģʽ����豸
#define NET_DVR_DEL_DEVICE						6217		//N+1ģʽɾ���豸

#define NET_DVR_GET_DATA_CALLBACK_CFG			6218		// ��ȡ��ݻ�Ǩ״̬
#define NET_DVR_SET_DATA_CALLBACK_CFG			6219		// ������ݻ�Ǩ״̬

#define NET_DVR_CLONE_LUN						6220	//��¡LUN��
#define NET_DVR_EXPAND_LUN						6221	//��չ��������LUN��

#define NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO		6222    //��ȡN+1�豸��Ϣ
#define NET_DVR_MODIFY_DVR_NET_DISK				6223	//�޸�DVR����
//#define NET_DVR_DEL_DVR_NET_DISK				6224	//ɾ��DVR����

#define NET_DVR_CREATE_NAS						6225	//����NAS
#define NET_DVR_DELETE_NAS						6226	//ɾ��NAS

#define NET_DVR_OPEN_ISCSI	 					6227	//����iSCSI
#define NET_DVR_CLOSE_ISCSI						6228	//�ر�iSCSI

#define NET_DVR_GET_FC					        6229    //��ȡ������Ϣ
#define NET_DVR_OPEN_FC	 						6230	//����FC
#define NET_DVR_CLOSE_FC	 					6231	//�ر�FC
#define NET_DVR_ONE_KEY_CONFIG_SAN				6232   // һ������SAN, ��һ������CVR�߼�һ��

#define NET_DVR_GET_RECORD_PACK				    6301    //��ȡ¼�������
#define NET_DVR_SET_RECORD_PACK				    6302    //����¼�������

#define NET_DVR_GET_CLOUD_STORAGE_CFG           6303 	//��ȡ�豸��ǰ����ģʽ
#define NET_DVR_SET_CLOUD_STORAGE_CFG           6304    //�����豸��ǰ����ģʽ
#define NET_DVR_GET_GOP_INFO                    6305    //��ȡGOP��Ϣ
#define NET_DVR_GET_PHY_DISK_INFO               6306     //��ȡ���������Ϣ
//¼�������ⲿ����
#define NET_DVR_GET_RECORDING_AUTO_TRACK_CFG	6307	//��ȡSDI�Զ�����������Ϣ
#define NET_DVR_SET_RECORDING_AUTO_TRACK_CFG	6308	//����SDI�Զ�����������Ϣ

#define NET_DVR_GET_RECORDING_PUBLISH_CFG		6309  //��ȡһ����Ϣ
#define NET_DVR_SET_RECORDING_PUBLISH_CFG		6310  //����һ����Ϣ


#define NET_DVR_RECORDING_ONEKEY_CONTROL		6311  //¼���������

#define NET_DVR_GET_RECORDING_END_TIME	6312  //��ȡ¼��ʣ��ʱ��

#define NET_DVR_RECORDING_PUBLISH				6313  //һ��¼��

#define NET_DVR_GET_CURRICULUM_CFG			6314	//��ȡ�α�������Ϣ
#define NET_DVR_SET_CURRICULUM_CFG			6315  //���ÿα�������Ϣ

#define NET_DVR_GET_COURSE_INDEX_CFG		6316	//��ȡ�γ���Ϣ����
#define NET_DVR_SET_COURSE_INDEX_CFG		6317  //���ÿγ���Ϣ����

#define	NET_DVR_GET_PPT_CHANNEL				6318	//��ȡPPT֧��ͨ����
#define	NET_DVR_GET_PPT_DETECT_CFG			6319	//��ȡPPT������
#define	NET_DVR_SET_PPT_DETECT_CFG			6320	//����PPT������

#define NET_DVR_GET_RECORDINGHOST_CFG			6321	//��ȡ¼������������Ϣ
#define NET_DVR_SET_RECORDINGHOST_CFG			6322	//����¼������������Ϣ
#define NET_DVR_GET_BACKUP_RECORD_CFG           6323	//��ȡһ���������Ϣ
#define NET_DVR_SET_BACKUP_RECORD_CFG           6324    //����һ���������Ϣ

//ͥ������
#define NET_DVR_GET_AUDIO_ACTIVATION_CFG        6326    //��ȡ�����������ò���
#define NET_DVR_SET_AUDIO_ACTIVATION_CFG        6327    //���������������ò���
#define NET_DVR_GET_DECODERCFG_V40              6328    //��ȡ������������Ϣ
#define NET_DVR_SET_DECODERCFG_V40	            6329	//���ý�����������Ϣ

#define NET_DVR_INFRARED_OUTPUT_CONTROL         6330   //�����������
#define NET_DVR_GET_INFRARED_CMD_NAME_CFG       6331   //��ȡ����������Ʋ�������
#define NET_DVR_SET_INFRARED_CMD_NAME_CFG       6332   //���ú���������Ʋ�������
#define NET_DVR_START_INFRARED_LEARN            6333   //Զ�̺���ѧ��

#define NET_DVR_GET_TRIAL_SYSTEM_CFG	        6334   //��ȡͥ������ϵͳ��Ϣ
#define NET_DVR_SET_CASE_INFO					6335	//������Ϣ¼��
#define NET_DVR_GET_TRIAL_MICROPHONE_STATUS		6336  //��ȡ��˷�״̬��Ϣ
#define NET_DVR_SET_TRIAL_MICROPHONE_STATUS		6337  //��ȡ��˷�״̬��Ϣ
#define NET_DVR_GET_TRIAL_HOST_STATUS			6338  //��ȡͥ������״̬��Ϣ
#define NET_DVR_GET_LAMP_OUT					6339  //��ȡLAMP�������Ϣ
#define NET_DVR_SET_LAMP_OUT					6340  //����LAMP�������Ϣ
#define NET_DVR_LAMP_REMOTE_CONTROL				6341  // LAMP����
#define NET_DVR_REMOTE_CONTROL_PLAY				6342  //Զ�̿��Ʊ��ػط�
#define NET_DVR_GET_LOCAL_INPUT_CFG				6343  //��ȡͥ������״̬��Ϣͥ�������������Ϣ
#define NET_DVR_SET_LOCAL_INPUT_CFG				6344  //����ͥ�������������Ϣ
#define NET_DVR_GET_CASE_INFO					6345  //��ȡ��ǰ������Ϣ

//��Ѷ���ⲿ����
#define NET_DVR_INQUEST_GET_CDW_STATUS 			6350  //��ȡ��Ѷ���¼״̬-������
#define NET_DVR_GET_MIX_AUDIOIN_CFG             6351  //��ȡ��������ڲ�������
#define NET_DVR_SET_MIX_AUDIOIN_CFG             6352  //���û�������ڲ�������
#define NET_DVR_GET_MIX_AUDIOOUT_CFG            6353  //��ȡ��������ڲ�������
#define NET_DVR_SET_MIX_AUDIOOUT_CFG            6354  //���û�������ڲ�������
#define NET_DVR_GET_AUDIOIN_VOLUME_CFG          6355  //��ȡ��Ƶ������������ڲ�������
#define NET_DVR_SET_AUDIOIN_VOLUME_CFG          6356  //������Ƶ������������ڲ�������
#define NET_DVR_GET_AREA_MASK_CFG               6357  //��ȡ�������������
#define NET_DVR_SET_AREA_MASK_CFG               6358  //�����������������
#define NET_DVR_GET_AUDIO_DIACRITICAL_CFG       6359  //��ȡ��Ƶ��������
#define NET_DVR_SET_AUDIO_DIACRITICAL_CFG       6360  //������Ƶ��������
#define NET_DVR_GET_WIFI_DHCP_ADDR_CFG          6361  //��WIFI DHCP ��ַ��Χ��������
#define NET_DVR_SET_WIFI_DHCP_ADDR_CFG          6362  //��WIFI DHCP ��ַ��Χ��������
#define NET_DVR_GET_WIFI_CLIENT_LIST_INFO       6363  //��ȡwifi�ȵ������ӵ��豸��Ϣ
#define NET_DVR_REMOTECONTROL_POWER_ON	        6364  //Զ�̿���
#define NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG	  6365  //��ȡ����������ͨ����������
#define NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG     6366  //���ö���������ͨ����������
#define NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG	    6367  //��ȡ�豸������Ƶ����ڷֱ���
#define NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG	    6368  //�����豸������Ƶ����ڷֱ���
#define NET_DVR_GET_AUDIOOUT_VOLUME_CFG         6369  //��ȡ��Ƶ������������ڲ�������
#define NET_DVR_SET_AUDIOOUT_VOLUME_CFG         6370  //������Ƶ������������ڲ�������
#define NET_DVR_INQUEST_PAUSE_CDW               6371  //��ͣ��¼
#define NET_DVR_INQUEST_RESUME_CDW              6372  //�ָ���¼
#define NET_DVR_GET_INPUT_CHAN_CFG              6373  //��ȡ����ͨ������
#define NET_DVR_SET_INPUT_CHAN_CFG              6374  //��������ͨ������
#define  NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG	6375	//��ȡ��Ѷ����Ƶ�����������
#define  NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG	6376	//������Ѷ����Ƶ�����������
#define	 NET_DVR_CASE_INFO_CTRL					6377	//������Ϣ��ʾ����
#define  NET_DVR_GET_INQUEST_USER_RIGHT			6378	//��ȡ��Ѷ���û�Ȩ��
#define  NET_DVR_SET_INQUEST_USER_RIGHT			6379	//������Ѷ���û�Ȩ��
#define NET_DVR_GET_INQUEST_CASE_INFO			6380	//��ȡ��Ѷ������Ϣ����
#define NET_DVR_SET_INQUEST_CASE_INFO			6381	//������Ѷ������Ϣ����

#define	NET_DVR_GET_FILM_MODE_CFG           	6387	//��ȡ��Ӱģʽ
#define	NET_DVR_SET_FILM_MODE_CFG           	6388	//���õ�Ӱģʽ
#define	NET_DVR_GET_FILM_MODE_CFG_CAP	        6389	//��ȡ��Ӱģʽ��������

#define	NET_DVR_GET_DIRECTED_STRATEGY_CFG   	6390	//��ȡ������������
#define	NET_DVR_SET_DIRECTED_STRATEGY_CFG	    6391	//���õ�����������
#define	NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP	6392	//��ȡ��Ӱģʽ��������
#define	NET_DVR_GET_FRAME_CFG            	    6393	//��ȡ����߿�
#define	NET_DVR_SET_FRAME_CFG	                6394	//���û���߿�
#define	NET_DVR_GET_FRAME_CFG_CAP	            6395	//��ȡ����߿���������
#define	NET_DVR_GET_AUDIO_EFFECTIVE_CFG	        6396	//��ȡ��Ƶ�Ż�����
#define	NET_DVR_SET_AUDIO_EFFECTIVE_CFG	        6397	//������ƵЧ�����
#define	NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP	    6398	//��ȡ��ƵЧ���Ż���������
#define	NET_DVR_GET_RECORD_VIDEO_CFG      	    6399	//��ȡ¼����Ƶ����
#define	NET_DVR_SET_RECORD_VIDEO_CFG	        6400	//����¼����Ƶ����


#define NET_DVR_GET_OUTPUT_CFG                  6401        //��ȡ��ʾ�������
#define NET_DVR_SET_OUTPUT_CFG                  6402        //������ʾ�������
#define NET_DVR_CODER_DISPLAY_START             6403        //��ʼ���
#define NET_DVR_CODER_DISPLAY_STOP              6404        //ֹͣ���
#define NET_DVR_GET_WINDOW_STATUS               6405        //��ȡ��ʾ����״̬

//VQD���ܽӿ�
#define NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG       6406        //��ȡVQDѭ��������ò���
#define NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG       6407        //����VQDѭ��������ò���
#define NET_DVR_GET_VQD_DIAGNOSE_INFO           6408        //�ֶ���ȡVQD�����Ϣ

#define	NET_DVR_RECORDING_PUBLISH_FILE	        6421	    //�ļ�����
#define	NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP	6422	    //��ȡ�ļ���������
#define	NET_DVR_GET_PUBLISH_PROGRESS        	6423   	    //��ȡ�������
#define	NET_DVR_GET_RECORD_VIDEO_CFG_CAP        6424	    //��ȡ¼����Ƶ��������
#define	NET_DVR_GET_RTMP_CFG	                6425	    //��ȡRTMP����
#define	NET_DVR_SET_RTMP_CFG                	6426    	//����RTMP����
#define	NET_DVR_GET_RTMP_CFG_CAP              	6427    	//��ȡRTMP��������
#define	NET_DVR_DEL_BACKGROUND_PIC	            6428	    //ɾ��ͼƬ�ļ�
#define	NET_DVR_GET_BACKGROUND_PIC_CFG	        6429	    //��ѯ����ͼƬ�ļ�
#define	NET_DVR_GET_BACKGROUND_PIC_INFO	        6430	    //��ȡ����ͼƬ��Ϊ����ͼƬ
#define	NET_DVR_SET_BACKGROUND_PIC_INFO	        6431	    //��������ͼƬ��Ϊ����ͼƬ
#define	NET_DVR_GET_BACKGROUND_PIC_INFO_CAP  	6432   	    //��ȡ����ͼƬ��Ϊ����ͼƬ��������
#define	NET_DVR_GET_RECORD_HOST_CAP	            6433    	//��ȡ¼������������

#define	NET_DVR_SYNC_IPC_PASSWD	              6621	    //ͬ��IPC������NVRһ��

#define	NET_DVR_GET_VEHICLE_BLACKLST_SCHEDULE 6622	//��ȡ������ʱ������
#define	NET_DVR_SET_VEHICLE_BLACKLST_SCHEDULE 6623	//���ú�����ʱ������

#define	NET_DVR_GET_VEHICLE_WHITELST_SCHEDULE 6624	//��ȡ������ʱ������
#define	NET_DVR_SET_VEHICLE_WHITELST_SCHEDULE 6625	//���ð�����ʱ������

#define	NET_DVR_GET_VEHICLE_BLACKLIST_EVENT_TRIGGER	 6626	//��ȡ��������������
#define	NET_DVR_SET_VEHICLE_BLACKLIST_EVENT_TRIGGER	 6627	//���ú�������������

#define	NET_DVR_GET_VEHICLE_WHITELIST_EVENT_TRIGGER	 6628	//��ȡ��������������
#define	NET_DVR_SET_VEHICLE_WHITELIST_EVENT_TRIGGER	 6629	//���ð�������������

#define	NET_DVR_GET_TRAFFIC_CAP	6630	//��ȡץ�����������
#define	NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER	 6631	//��ȡȫ��������Ⲽ����������
#define	NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER	 6632	//����ȫ��������Ⲽ����������
#define	NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER	 6633	//��ȡ��������������
#define	NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER	 6634	//������������������

#define	NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER	 6635	//��ȡ�洢���������������
#define	NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER	 6636	//���ô洢���������������
#define	NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES	6637	//��ȡ�洢������Ⲽ��ʱ������
#define	NET_DVR_GET_STORAGEDETECTION_SCHEDULE	     6638	//��ȡ�洢��������ʱ������
#define	NET_DVR_SET_STORAGEDETECTION_SCHEDULE	     6639	//���ô洢��������ʱ������
#define	NET_DVR_GET_STORAGEDETECTION_STATE	         6640	//��ȡ�洢����״̬

#define	NET_DVR_GET_FACECAPTURE_EVENT_TRIGGER	     6641	//��ȡ����ץ����������
#define	NET_DVR_SET_FACECAPTURE_EVENT_TRIGGER	     6642	//��������ץ����������
#define	NET_DVR_GET_FACECAPTURE_SCHEDULE_CAPABILITIES 6643	//��ȡ����ץ�Ĳ���ʱ������
#define	NET_DVR_GET_FACECAPTURE_SCHEDULE	         6644	//��ȡ����ץ�Ĳ���ʱ������
#define	NET_DVR_SET_FACECAPTURE_SCHEDULE	         6645	//��������ץ�Ĳ���ʱ������
#define	NET_DVR_GET_STORAGEDETECTION_RWLOCK	         6646	//��ȡ�洢���Ķ�д������
#define	NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES	6647	//��ȡ�洢���Ķ�д����������
#define	NET_DVR_SET_STORAGEDETECTION_RWLOCK	         6648	//���ô洢���Ķ�д������
#define	NET_DVR_GET_PTZTRACKSTATUS					 6649	//��ȡ�����������״̬

#define	NET_DVR_SET_STORAGEDETECTION_UNLOCK	         6653	//���ô洢���Ľ�������
#define	NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES	6654	//��ȡ�洢���Ľ�����������

#define	NET_DVR_GET_DEVICE_LAN_ENCODE			6501        //��ȡ�豸�����Ա���
#define NET_DVR_GET_GBT28181_SERVICE_CFG        6503        //��ȡGB28181����������
#define NET_DVR_SET_GBT28181_SERVICE_CFG        6504        //����GB28181����������
#define NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES 6505      //��ȡGB28181����������


#define	NET_DVR_GET_VIDEO_IMAGE_DB_CFG		6601		//��ȡ��ͼ����Ϣ
#define	NET_DVR_SET_VIDEO_IMAGE_DB_CFG		6602		//������ͼ����Ϣ
#define	NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP	6603		//��ȡ��ͼ���������
#define	NET_DVR_GET_FILE_INFO_BY_ID			6604		//����ļ�ID��ȡ��ͼ�����ļ���Ϣ
#define	NET_DVR_QUERY_FILE_INFO_CAP			6605		//����ļ����ѯ�ļ���Ϣ����
#define	NET_DVR_DEL_FILE_FROM_DB			6606		//����ͼ����ɾ���ļ�
#define	NET_DVR_GET_VIDEO_IMAGE_DB_CAP		6607		//��ȡ��ͼ��������

#define NET_DVR_GET_FIGURE	                6640        //��ȡ����ͼ

#define	NET_DVR_GET_MANUALRANGING_CAPABILITIES	6675    //��ȡ�ֶ������������

#define	NET_DVR_SET_MANUALRANGING           6677	    //�����ֶ�������


#define NET_DVR_GET_MB_POWERCTRLPARA		    8000//��ȡ�������Ʋ���
#define	NET_DVR_SET_MB_POWERCTRLPARA		    8001 //�����������Ʋ���
#define NET_DVR_GET_AUTOBACKUPPARA			    8002//��ȡ�Զ����ݲ���
#define NET_DVR_SET_AUTOBACKUPPARA			    8003 //�����Զ����ݲ���
#define NET_DVR_GET_MB_GPSPARA				    8004//��ȡGPS����
#define NET_DVR_SET_MB_GPSPARA				    8005 //����GPS����
#define NET_DVR_GET_MB_SENSORINPARA			    8006//��ȡSENSOR����
#define NET_DVR_SET_MB_SENSORINPARA			    8007 //����SENSOR����
#define NET_DVR_GET_GSENSORPARA				    8008//��ȡGSENSOR����
#define NET_DVR_SET_GSENSORPARA				    8009 //����GSENSOR����
#define NET_DVR_GET_MB_DOWNLOADSVRPARA		    8010//��ȡ���ط���������
#define NET_DVR_SET_MB_DOWNLOADSVRPARA		    8011//�������ط���������
#define NET_DVR_GET_PLATERECOG_PARA			    8012//��ȡ����ʶ�����
#define NET_DVR_SET_PLATERECOG_PARA			    8013//���ó���ʶ�����
#define NET_DVR_GET_ENFORCESYS_PARA			    8014//��ȡ����������
#define NET_DVR_SET_ENFORCESYS_PARA		    	8015//���ó���������
#define NET_DVR_GET_GPS_DATA					8016 //��ȡGPS���
#define NET_DVR_GET_ANALOG_ALARMINCFG			8017//��ȡģ�ⱨ���������
#define NET_DVR_SET_ANALOG_ALARMINCFG			8018//����ģ�ⱨ���������

/*****************************����ǽ start****************************/
#define	NET_DVR_MATRIX_WALL_SET		            9001  //���õ���ǽ����Ļ����
#define	NET_DVR_MATRIX_WALL_GET	                9002  //��ȡ����ǽ����Ļ����
#define	NET_DVR_WALLWIN_GET			            9003  //����ǽ�л�ȡ���ڲ���
#define	NET_DVR_WALLWIN_SET			            9004  //����ǽ�����ô��ڲ���
#define	NET_DVR_WALLWINPARAM_SET		        9005  //���õ���ǽ������ز���
#define	NET_DVR_WALLWINPARAM_GET		        9006  //��ȡ����ǽ������ز���
#define NET_DVR_WALLSCENEPARAM_GET				9007  //���ó���ģʽ����
#define NET_DVR_WALLSCENEPARAM_SET				9008  //��ȡ����ģʽ����
#define NET_DVR_MATRIX_GETWINSTATUS             9009  //��ȡ���ڽ���״̬
#define	NET_DVR_GET_WINASSOCIATEDDEVINFO		9010  //����ǽ�л�ȡ��Ӧ��Դ��Ϣ
#define	NET_DVR_WALLOUTPUT_GET		            9011  //����ǽ�л�ȡ��ʾ�������
#define	NET_DVR_WALLOUTPUT_SET		            9012  //����ǽ��������ʾ�������
#define NET_DVR_GET_UNITEDMATRIXSYSTEM          9013  //����ǽ�л�ȡ��Ӧ��Դ
#define NET_DVR_GET_WALL_CFG					9014  //��ȡ����ǽȫ�ֲ���
#define NET_DVR_SET_WALL_CFG					9015  //���õ���ǽȫ�ֲ���
#define NET_DVR_CLOSE_ALL_WND					9016  //�ر����д���
#define NET_DVR_SWITCH_WIN_TOP                  9017  //�����ö�
#define NET_DVR_SWITCH_WIN_BOTTOM               9018  //�����õ�

#define	NET_DVR_CLOSE_ALL_WND_V41				9019  //����ǽ�ر����д���v41���ж������ǽ��
#define	NET_DVR_GET_WALL_WINDOW_V41				9020  //��ȡ����ǽ�еĴ���v41
#define	NET_DVR_SET_WALL_WINDOW_V41				9021  //���õ���ǽ�еĴ���v41
#define	NET_DVR_GET_CURRENT_SCENE_V41			9022  //��ȡ��ǰ����ǽ������ʹ�õĳ���v41
#define	NET_DVR_GET_WALL_SCENE_PARAM_V41		9023  //��ȡ��ǰ����ǽ������ʹ�õĳ���v41
#define	NET_DVR_SET_WALL_SCENE_PARAM_V41		9024  //���õ�ǰ����ǽ������ʹ�õĳ���v41
#define NET_DVR_GET_MATRIX_LOGO_CFG             9025  //��ȡlogo����
#define NET_DVR_SET_MATRIX_LOGO_CFG             9026  //����logo����
#define NET_DVR_GET_WIN_LOGO_CFG				9027  //��ȡ����logo����
#define NET_DVR_SET_WIN_LOGO_CFG				9028  //���ô���logo����
#define NET_DVR_DELETE_LOGO                     9029  //ɾ��logo
#define NET_DVR_SET_DISPLAY_EFFECT_CFG			9030  //������ʾ���Ч�����v41
#define NET_DVR_GET_DISPLAY_EFFECT_CFG			9031  //��ȡ��ʾ���Ч�����v41
#define NET_DVR_DEC_PLAY_REMOTE_FILE			9032  //���벥��Զ���ļ�
#define NET_DVR_GET_WIN_ZOOM_STATUS             9033  //��ȡ���ڵ��ӷŴ�״̬
#define NET_DVR_GET_ALL_MATRIX_LOGOCFG          9034  //��ȡ����logo����

/*****************************����ǽ end******************************/

/*******************************LCDƴ���� begin******************************************/
#define NET_DVR_SIMULATE_REMOTE_CONTROL         9035    //ģ��ң�ذ��� 2013-09-05
#define NET_DVR_SET_SCREEN_SIGNAL_CFG			9036	//������Ļ�ź�Դ����
#define	NET_DVR_GET_SCREEN_SIGNAL_CFG			9037	//��ȡ��Ļ�ź�Դ����
#define NET_DVR_SET_SCREEN_SPLICE_CFG  			9038	//������Ļƴ��
#define	NET_DVR_GET_SCREEN_SPLICE_CFG			9039	//��ȡ��Ļƴ��
#define NET_DVR_GET_SCREEN_FAN_WORK_MODE 		9040	//��ȡ���ȹ�����ʽ
#define NET_DVR_SET_SCREEN_FAN_WORK_MODE 		9041	//���÷��ȹ�����ʽ
#define NET_DVR_SHOW_SCREEN_WORK_STATUS  		9044	//��ʾ��Ļ״̬
#define NET_DVR_GET_VGA_CFG  					9045	//��ȡVGA�ź�����
#define NET_DVR_SET_VGA_CFG  					9046	//����VGA�ź�����
#define NET_DVR_GET_SCREEN_MENU_CFG				9048   //��ȡ��Ļ�˵�����
#define NET_DVR_SET_SCREEN_MENU_CFG  			9049	//������Ļ�˵�����
#define NET_DVR_SET_SCREEN_DISPLAY_CFG  	    9050	//������ʾ���� 2013-08-28
#define	NET_DVR_GET_SCREEN_DISPLAY_CFG	        9051	//��ȡ��ʾ���� 2013-08-28
#define NET_DVR_SET_PIP_CFG  					9060	//���û��л�����
#define	NET_DVR_GET_PIP_CFG						9061	//��ȡ���л�����
#define NET_DVR_SET_DEFOG_LCD  					9073	//����͸�����
#define	NET_DVR_GET_DEFOG_LCD					9074	//��ȡ͸�����
#define NET_DVR_SHOW_IP  						9075	//��ʾIP
#define NET_DVR_SCREEN_MAINTENANCE_WALL			9076	//��Ļάǽ
#define NET_DVR_SET_SCREEN_POS  				9077	//������Ļλ�ò���
#define	NET_DVR_GET_SCREEN_POS					9078	//��ȡ��Ļλ�ò���
/*******************************LCDƴ���� end******************************************/

/*******************************LCDƴ����V1.2 begin******************************************/
#define	NET_DVR_SCREEN_INDEX_SET	            9079    //��Ļ������ز�������
#define	NET_DVR_SCREEN_INDEX_GET                9080    //��Ļ������ز����ȡ
#define NET_DVR_SCREEN_SPLICE_SET               9081    //������Ļƴ�Ӳ���
#define NET_DVR_SCREEN_SPLICE_GET               9082    //��ȡ��Ļƴ�Ӳ���
#define NET_DVR_SET_SCREEN_PARAM                9083    //������Ļ��ز���
#define NET_DVR_GET_SCREEN_PARAM                9084    //��ȡ��Ļ��ز���
#define NET_DVR_SET_SWITCH_CFG                  9085    //���ö�ʱ���ػ����
#define NET_DVR_GET_SWITCH_CFG                  9086    //��ȡ��ʱ���ػ����
#define NET_DVR_SET_POWERON_DELAY_CFG           9087    //������ʱ�������
#define NET_DVR_GET_POWERON_DELAY_CFG           9088    //��ȡ��ʱ�������
#define	NET_DVR_SET_SCREEN_POSITION	            9089    //������Ļλ�ò���
#define	NET_DVR_GET_SCREEN_POSITION	            9090    //��ȡ��Ļλ�ò���
#define NET_DVR_SCREEN_SCENE_CONTROL            9091    //��Ļ��������
#define NET_DVR_GET_CURRENT_SCREEN_SCENE        9092    //��ȡ��ǰ��Ļ������
#define NET_DVR_GET_SCREEN_SCENE_PARAM          9093    //��ȡ��Ļ����ģʽ����
#define NET_DVR_SET_SCREEN_SCENE_PARAM          9094    //������Ļ����ģʽ����
#define NET_DVR_GET_EXTERNAL_MATRIX_RELATION    9095    //��ȡ��Ӿ����������������ϵ
#define NET_DVR_GET_LCD_AUDIO_CFG			    9096 	//��ȡLCD��Ļ��Ƶ����
#define NET_DVR_SET_LCD_AUDIO_CFG			    9097 	//����LCD��Ļ��Ƶ����
#define NET_DVR_GET_LCD_WORK_STATE		        9098 	//��ȡLCD��Ļ����״̬
#define NET_DVR_GET_BOOT_LOGO_CFG	            9099    //��ȡLCD��Ļ����logo��ʾ����
#define NET_DVR_SET_BOOT_LOGO_CFG	            9100    //����LCD��Ļ����logo��ʾ����

/*******************************LCDƴ����V1.2 end ******************************************/



#define NET_DVR_GET_STREAM_DST_COMPRESSIONINFO	9101  //��ȡĿ��ѹ������
#define NET_DVR_SET_STREAM_DST_COMPRESSIONINFO  9102  //����Ŀ��ѹ������
#define NET_DVR_GET_STREAM_TRANS_STATUS			9103  //��ȡ��״̬
#define NET_DVR_GET_DEVICE_TRANS_STATUS			9104  //��ȡ�豸ת��״̬
#define NET_DVR_GET_ALLSTREAM_SRC_INFO  		9105  //��ȡ��������Ϣ
#define NET_DVR_GET_BIG_SCREEN_AUDIO	        9106  //��ȡ������Ƶ��Ϣ
#define NET_DVR_SET_BIG_SCREEN_AUDIO	        9107  //���ô�����Ƶ��Ϣ
#define NET_DVR_GET_DEV_WORK_MODE				9108  //��ȡת���豸����ģʽ
#define NET_DVR_SET_DEV_WORK_MODE				9109  //����ת���豸����ģʽ
#define NET_DVR_APPLY_TRANS_CHAN                9110  //����ID����ת��ͨ��
#define NET_DVR_GET_DISPCHAN_CFG                9111  //������ȡ��ʾͨ������
#define NET_DVR_SET_DISPCHAN_CFG                9112  //����������ʾͨ������

#define NET_DVR_GET_DEC_CHAN_STATUS				9113  //��ȡ����ͨ������״̬
#define NET_DVR_GET_DISP_CHAN_STATUS			9114  //��ȡ��ʾͨ��״̬
#define NET_DVR_GET_ALARMIN_STATUS				9115  //��ȡ��������״̬
#define NET_DVR_GET_ALARMOUT_STATUS				9116  //��ȡ�������״̬
#define NET_DVR_GET_AUDIO_CHAN_STATUS			9117  //��ȡ�����Խ�״̬

#define	NET_DVR_GET_VIDEO_AUDIOIN_CFG			9118   //��ȡ��Ƶ����Ƶ�������
#define NET_DVR_SET_VIDEO_AUDIOIN_CFG			9119   //������Ƶ����Ƶ�������

#define	NET_DVR_SET_BASEMAP_CFG					9120  //���õ�ͼ����
#define NET_DVR_GET_BASEMAP_CFG					9121  //��ȡ��ͼ����
#define NET_DVR_GET_VIRTUAL_SCREEN_CFG          9122  //��ȡ������������ϵͳ����
#define NET_DVR_SET_VIRTUAL_SCREEN_CFG          9123  //���ó�����������ϵͳ����
#define NET_DVR_GET_BASEMAP_WIN_CFG				9124  //��ȡ��ͼ���ڲ���
#define NET_DVR_SET_BASEMAP_WIN_CFG				9125  //���õ�ͼ���ڲ���
#define NET_DVR_DELETE_PICTURE					9126  //ɾ���ͼ
#define NET_DVR_GET_BASEMAP_PIC_INFO			9127  //��ȡ��ͼͼƬ��Ϣ
#define	NET_DVR_SET_BASEMAP_WIN_CFG_V40         9128  //���õ�ͼ���ڲ���V40
#define NET_DVR_GET_BASEMAP_WIN_CFG_V40         9129  //��ȡ��ͼ���ڲ���V40

#define NET_DVR_GET_DEC_VCA_CFG					9130	//��ȡ���������ܱ�������
#define NET_DVR_SET_DEC_VCA_CFG					9131	//���ý��������ܱ�������
#define NET_DVR_GET_TERMINAL_CONFERENCE_STATUS	9136	//��ȡ�ն˻���״̬
#define NET_DVR_GET_TERMINAL_INPUT_CFG_CAP		9137	//��ȡ�ն������������
#define NET_DVR_GET_TERMINAL_INPUT_CFG			9138	//��ȡ�ն���Ƶ�����������
#define NET_DVR_SET_TERMINAL_INPUT_CFG			9139	//�����ն���Ƶ�����������

#define NET_DVR_GET_CONFERENCE_REGION_CAP		9140	//��ȡ�ն˻�����������
#define NET_DVR_GET_CONFERENCE_REGION			9141	//��ȡ�ն˻����������
#define NET_DVR_SET_CONFERENCE_REGION			9142	//�����ն˻����������
#define NET_DVR_GET_TERMINAL_CALL_CFG_CAP		9143	//��ȡ�ն˺�����������
#define NET_DVR_GET_TERMINAL_CALL_CFG			9144	//��ȡ�ն˺��в���
#define NET_DVR_SET_TERMINAL_CALL_CFG			9145	//�����ն˺��в���
#define NET_DVR_GET_TERMINAL_CTRL_CAP			9146	//��ȡ�ն˺��п�������
#define NET_DVR_TERMINAL_CTRL					9147	//�ն˺��п���
#define	NET_DVR_GET_CALL_QUERY_CAP				9148	//��ȡ�����������
#define NET_DVR_GET_CALLINFO_BY_COND			9149	//��������ѯ���м�¼
#define NET_DVR_GET_VCS_CAP						9152	//��ȡMCU������

#define	NET_DVR_SET_FUSION_SCALE			    9150    //����ͼ���ںϹ�ģ
#define NET_DVR_GET_FUSION_SCALE        	    9151    //��ȡͼ���ںϹ�ģ
#define NET_DVR_SET_FUSION_CFG			        9052    //����ͼ���ںϲ���
#define NET_DVR_GET_FUSION_CFG        	        9053    //��ȡͼ���ںϲ���
#define	NET_DVR_GET_LLDP_CFG	                9160    //��ȡLLDP����
#define	NET_DVR_SET_LLDP_CFG	                9161    //����LLDP����
#define NET_DVR_GET_LLDP_CAP	                9162    //��ȡLLDP������
#define	NET_DVR_GET_FIBER_CONVERT_BASIC_INFO	9163    //��ȡ�����շ�������Ϣ
#define	NET_DVR_GET_FIBER_CONVERT_WORK_STATE	9164    //��ȡ�����շ�������״
#define	NET_DVR_GET_FIBER_CONVERT_TOPOLOGY      9165    //��ȡ�����շ���������Ϣ
#define	NET_DVR_GET_FC_PORT_REMARKS	            9166    //��ȡ�����շ����˿�ע�Ͳ���
#define	NET_DVR_SET_FC_PORT_REMARKS	            9167    //���ù����շ����˿�ע�Ͳ���
#define NET_DVR_GET_PORT_REMARKS_CAP	        9168    //��ȡ�����շ����˿�ע��������
#define NET_DVR_GET_OUTPUT_PIC_INFO             9200    //��ȡ�����ͼƬ����
#define NET_DVR_SET_OUTPUT_PIC_INFO             9201    //���������ͼƬ����
#define NET_DVR_GET_OUTPUT_PIC_WIN_CFG          9202    //��ȡ�����ͼƬ���ڲ���
#define NET_DVR_SET_OUTPUT_PIC_WIN_CFG          9203    //���������ͼƬ���ڲ���
#define NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG      9204    //��ȡ���������ͼƬ���ڲ���
#define NET_DVR_DELETE_OUPUT_PIC                9205    //ɾ�������ͼƬ
#define NET_DVR_GET_OUTPUT_OSD_CFG              9206    //��ȡ�����OSD����
#define NET_DVR_SET_OUTPUT_OSD_CFG              9207    //���������OSD����
#define NET_DVR_GET_OUTPUT_ALL_OSD_CFG          9208    //��ȡ���������OSD����
#define NET_DVR_GET_CHAN_RELATION               9209    //��ȡ����ͨ��������Դ����
#define NET_DVR_SET_CHAN_RELATION               9210    //���ñ���ͨ��������Դ����
#define NET_DVR_GET_ALL_CHAN_RELATION           9211    //��ȡ���б���ͨ��������Դ����
#define NET_DVR_GET_NS_RING_CFG    				9212    //��ȡ���˰廷������
#define NET_DVR_SET_NS_RING_CFG   				9213    //���ù��˰廷������
#define NET_DVR_GET_NS_RING_STATUS  			9214    //��ȡ���˰廷��״̬
#define NET_DVR_GET_OPTICAL_PORT_INFO			9220    //��ȡ�����Ϣ
#define NET_DVR_SET_OPTICAL_PORT_INFO			9221    //���ù����Ϣ
#define NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG		9222    //��ȡ����ͨ�������������Դ����
#define NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG		9223    //���ñ���ͨ�������������Դ����
#define  NET_DVR_GET_WIN_ROAM_SWITCH_CFG        9224    //��ȡ�������������ο��ز���
#define  NET_DVR_SET_WIN_ROAM_SWITCH_CFG        9225    //���ý������������ο��ز���

/*******************************С���LED��ʾ�� begin***************************************/
#define NET_DVR_GET_LED_OUTPUT_CFG				9230    //��ȡ���Ϳ��������
#define NET_DVR_SET_LED_OUTPUT_CFG				9231    //���÷��Ϳ��������
#define NET_DVR_GET_LED_OUTPUT_PORT_CFG			9232    //��ȡLED���Ϳ�����˿ڲ���
#define NET_DVR_SET_LED_OUTPUT_PORT_CFG			9233    //����LED���Ϳ�����˿ڲ���
#define NET_DVR_GET_LED_DISPLAY_AREA_CFG		9234    //��ȡLED���Ϳ���ʾ����
#define NET_DVR_SET_LED_DISPLAY_AREA_CFG		9235    //����LED���Ϳ���ʾ����
#define NET_DVR_GET_LED_PORT_CFG				9236    //��ȡLED���Ϳ��˿ڲ���
#define NET_DVR_SET_LED_PORT_CFG				9237    //����LED���Ϳ��˿ڲ���
#define NET_DVR_GET_LED_DISPLAY_CFG				9238    //��ȡLED���Ϳ���ʾ����
#define NET_DVR_SET_LED_DISPLAY_CFG				9239    //����LED���Ϳ���ʾ����
#define NET_DVR_GET_ALL_LED_PORT_CFG			9240    //��ȡLED���Ϳ�ĳ�������Ӧ
#define NET_DVR_SAVE_LED_CONFIGURATION			9241	//����̻�
#define NET_DVR_GET_LED_TEST_SIGNAL_CFG			9242	//��ȡLED�������źŲ���
#define NET_DVR_SET_LED_TEST_SIGNAL_CFG			9243	//����LED�������źŲ���
#define NET_DVR_GET_LED_NOSIGNAL_CFG			9244	//��ȡLED�����ź���ʾģʽ����
#define NET_DVR_SET_LED_NOSIGNAL_CFG			9245	//����LED�����ź���ʾģʽ����
#define NET_DVR_GET_LED_INPUT_CFG				9246	//��ȡLED���Ϳ��������
#define NET_DVR_SET_LED_INPUT_CFG				9247	//����LED���Ϳ��������
#define NET_DVR_GET_LED_RECV_GAMMA_CFG			9248	//��ȡ���տ�GAMMA�����
#define NET_DVR_SET_LED_RECV_GAMMA_CFG			9249	//���ý��տ�GAMMA�����
#define NET_DVR_GET_LED_RECV_CFG				9250	//��ȡ���տ������
#define NET_DVR_SET_LED_RECV_CFG				9251	//���ý��տ������
#define NET_DVR_GET_LED_RECV_ADVANCED_CFG		9252	//��ȡ���տ��߼�����
#define NET_DVR_SET_LED_RECV_ADVANCED_CFG		9253	//���ý��տ��߼�����
#define NET_DVR_GET_LED_SCREEN_DISPLAY_CFG		9254	//��ȡLED����ʾ����
#define NET_DVR_SET_LED_SCREEN_DISPLAY_CFG		9255	//����LED����ʾ����
/*******************************С���LED��ʾ�� end*****************************************/

#define NET_DVR_GET_CURRENT_VALID_PORT          9300    //��ȡ��ǰ��Ч��,�������ӵĶ˿�

#define	NET_DVR_SET_ONLINE_UPGRADE		        9301	//����������
#define NET_DVR_GET_ONLINEUPGRADE_PROGRESS      9302    //��ȡ��������
#define	NET_DVR_GET_FIRMWARECODE		        9303	//��ȡʶ����
#define NET_DVR_GET_ONLINEUPGRADE_SERVER        9304    //��ȡ�������״̬
#define NET_DVR_GET_ONLINEUPGRADE_VERSION       9305    //��ȡ�°汾��Ϣ
#define NET_DVR_GET_RECOMMEN_VERSION            9306    //����Ƿ��Ƽ���˰汾
#define NET_DVR_GET_ONLINEUPGRADE_ABILITY       9309    //��ȡ������������

#define NET_DVR_GET_RS485_WORK_MODE             10001 //��ȡRS485���ڹ���ģʽ
#define NET_DVR_SET_RS485_WORK_MODE             10002 //����RS485���ڹ���ģʽ
#define NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG     10003 //��ȡ�����͸��ͨ������
#define NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG     10004 //���������͸��ͨ������

#define  NET_DVR_GET_SIP_CFG					11001   //IP���ӻ����ȡSIP����
#define  NET_DVR_SET_SIP_CFG					11002   //IP���ӻ�������SIP����
#define  NET_DVR_GET_IP_VIEW_DEVCFG				11003   //��ȡIP�Խ��ֻ�����
#define  NET_DVR_SET_IP_VIEW_DEVCFG				11004   //����IP�Խ��ֻ�����
#define  NET_DVR_GET_IP_VIEW_AUDIO_CFG			11005   //��ȡIP�Խ��ֻ���Ƶ����
#define  NET_DVR_SET_IP_VIEW_AUDIO_CFG			11006   //����IP�Խ��ֻ���Ƶ����
#define	 NET_DVR_GET_IP_VIEW_CALL_CFG			11007   //��ȡIP�Խ��ֻ���в���
#define  NET_DVR_SET_IP_VIEW_CALL_CFG			11008   //����IP�Խ��ֻ���в���
#define	 NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG		11009	//��ȡ�����������ò���
#define	 NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG		11010	//���������������ò���
#define	 NET_DVR_GET_BUTTON_DOWN_ALARM_CFG		11011	//��ȡ��ť���¸澯���ò���
#define	 NET_DVR_SET_BUTTON_DOWN_ALARM_CFG		11012	//���ð�ť���¸澯���ò���

#define  NET_DVR_GET_ISCSI_CFG                  11070   // ��ȡISCSI�洢����Э��
#define  NET_DVR_SET_ISCSI_CFG                  11071   // ��ȡISCSI�洢����Э��

#define NET_DVR_GET_SECURITYMODE                12004   //��ȡ��ǰ��ȫģʽ
//2013-11-21 ��ȡ�豸��ǰ���¶Ⱥ�ʪ��
#define  NET_DVR_GET_TEMP_HUMI                  12005

//2014-02-15 ����IPC�Զ���������Ŀ
#define  NET_DVR_SET_ALARMSOUNDMODE             12006   //���ñ�������ģʽ
#define  NET_DVR_GET_ALARMSOUNDMODE             12007   //��ȡ��������ģʽ
/*******************************¥����ӶԽ��� start***********************************/
#define NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG  16001  //��ȡ���ӶԽ��豸���
#define NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG  16002  //���ÿ��ӶԽ��豸���
#define NET_DVR_SET_PRIVILEGE_PASSWORD           16003  //����Ȩ������������Ϣ
#define NET_DVR_GET_OPERATION_TIME_CFG           16004  //��ȡ����ʱ������
#define NET_DVR_SET_OPERATION_TIME_CFG           16005  //���ò���ʱ������
#define NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG 16006  //��ȡ���������豸����
#define NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG 16007  //���ù��������豸����
#define NET_DVR_REMOTECONTROL_NOTICE_DATA        16008  //������Ϣ�·�
#define NET_DVR_REMOTECONTROL_GATEWAY            16009  //Զ�̿���
#define NET_DVR_REMOTECONTROL_OPERATION_AUTH     16010  //����Ȩ����֤

#define NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG      16016  //��ȡIO�������
#define NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG      16017  //����IO�������
#define NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG     16018  //��ȡIO�������
#define NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG     16019  //����IO�������
#define NET_DVR_GET_ELEVATORCONTROL_CFG          16020  //��ȡ�ݿ�������
#define NET_DVR_SET_ELEVATORCONTROL_CFG          16021  //�����ݿ�������
#define NET_DVR_GET_VIDEOINTERCOM_STREAM         16022  //��ȡ���ӶԽ���ͨ������
#define NET_DVR_SET_VIDEOINTERCOM_STREAM         16023  //���ÿ��ӶԽ���ͨ������
#define NET_DVR_GET_WDR_CFG                      16024  //��ȡ�?̬��������
#define NET_DVR_SET_WDR_CFG                      16025  //���ÿ?̬��������
#define NET_DVR_GET_VIS_DEVINFO                  16026  //��ȡ���豸�����Ϣ
#define NET_DVR_GET_VIS_REGISTER_INFO            16027  //��ȡ���豸ע����豸��Ϣ
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V40      16028  //��ȡ�ݿ�������-��չ
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V40      16029  //�����ݿ�������-��չ
#define NET_DVR_GET_CALL_ROOM_CFG				 16030  //��ȡ�������ס������
#define NET_DVR_SET_CALL_ROOM_CFG				 16031  //���ð������ס������
#define NET_DVR_VIDEO_CALL_SIGNAL_PROCESS        16032  //���ӻ��Խ������
#define NET_DVR_GET_CALLER_INFO                  16033  //��ȡ���г�����Ϣ
#define NET_DVR_GET_CALL_STATUS                  16034  //��ȡͨ��״̬
#define NET_DVR_GET_SERVER_DEVICE_INFO           16035  //��ȡ�豸�б�
#define NET_DVR_SET_CALL_SIGNAL                  16036  //���ӶԽ��ֻ�˷�������
#define NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG       16037    //��ȡ���ӶԽ������¼�����
#define NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG       16038    //���ÿ��ӶԽ������¼�����


#define	NET_DVR_DEBUGINFO_START	                 18000	//���豸������Ϣ��������

/*******************************¥����ӶԽ��� end***********************************/

#define NET_DVR_T1_TEST_CMD                    131073 //�������������ã�ͨ�����������ı�������־�����ʲô.��ݳ��Ȳ��ô���1024
//������ʽΪ��<T1TestCmd type="0"/>//�ָ��豸Ĭ�ϲ���ػ�

// ���ֶ��Ʋ˵����ģʽ�ⲿ����
#define NET_DVR_GET_MEMU_OUTPUT_MODE			155649			// ��ȡ�˵����ģʽ
#define NET_DVR_SET_MEMU_OUTPUT_MODE			155650			// ���ò˵����ģʽ


#define NET_DVR_GET_SELFCHECK_RESULT        20000    //��ȡ�豸�Լ���
#define NET_DVR_SET_TEST_COMMAND            20001    //���ò��Կ�������
#define NET_DVR_SET_TEST_DEVMODULE          20002    //���ò���Ӳ��ģ���������
#define NET_DVR_GET_TEST_DEVMODULE          20003    //��ȡ����Ӳ��ģ���������

#define NET_DVR_SET_AUTOFOCUS_TEST          20004    //�����Զ��Խ����� 2013-10-26
#define NET_DVR_CHECK_USER_STATUS           20005    //����û��Ƿ�����

#define NET_DVR_GET_DIAL_SWITCH_CFG         20200    //��ȡ���뿪����Ϣ

/***************************DS9000��������(_V30) end *****************************/

#define	NET_DVR_SET_IPDEVICE_ACTIVATED       13000//ͨ��NVR����ǰ���豸
#define NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS    13001   //��ȡ����ͨ����Ӧ�豸��ȫ״̬
#define	NET_DVR_GET_ACTIVATE_IPC_ABILITY     13003	//��ȡNVR����IPC������


#define NET_DVR_GET_TEST_VERSION_HEAD           268435441   //��ȡ���԰汾ͷ
#define NET_DVR_SET_TEST_VERSION_HEAD           268435442   //���ò��԰汾ͷ
#define NET_DVR_GET_TEST_VERSION_HEAD_V1        268435443   //��ȡ���԰汾ͷ-�ڶ���
#define NET_DVR_SET_TEST_VERSION_HEAD_V1        268435444   //���ò��԰汾ͷ-�ڶ���
#define NET_DVR_GET_TEST_VERSION_HEAD_V2        268435445   //��ȡ���԰汾ͷ-�����
#define NET_DVR_SET_TEST_VERSION_HEAD_V2        268435446   //���ò��԰汾ͷ-�����

#define NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0    268435447   //��ȡ���԰汾ͷ,��ǰ����һ���汾
#define NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0    268435448   //���ò��԰汾ͷ,��ǰ����һ���汾


#define MAX_LOCAL_ADDR_LEN			 96		//SOCKS��󱾵���θ���
#define	MAX_COUNTRY_NAME_LEN		  4		//��Ҽ�д��Ƴ���

/************************DVR��־ begin***************************/

/* ���� */
//������
#define MAJOR_ALARM						0x1
//������
#define MINOR_ALARM_IN					0x1		/* �������� */
#define MINOR_ALARM_OUT					0x2		/* ������� */
#define MINOR_MOTDET_START				0x3		/* �ƶ���ⱨ����ʼ */
#define MINOR_MOTDET_STOP				0x4		/* �ƶ���ⱨ������ */
#define MINOR_HIDE_ALARM_START			0x5		/* �ڵ�������ʼ */
#define MINOR_HIDE_ALARM_STOP			0x6		/* �ڵ��������� */
#define MINOR_VCA_ALARM_START			0x7		/*���ܱ�����ʼ*/
#define MINOR_VCA_ALARM_STOP			0x8		/*���ܱ���ֹͣ*/
#define MINOR_ITS_ALARM_START           0x09    // ��ͨ�¼�������ʼ
#define MINOR_ITS_ALARM_STOP            0x0A    // ��ͨ�¼���������
//2010-11-10 ���籨����־
#define MINOR_NETALARM_START            0x0b    /*���籨����ʼ*/
#define MINOR_NETALARM_STOP             0x0c    /*���籨������*/
//2010-12-16 ��������־����"MINOR_ALARM_IN"���ʹ��
#define MINOR_NETALARM_RESUME			0x0d	/*���籨���ָ�*/
//2012-4-5 IPC PIR�����ߡ����ȱ���
#define MINOR_WIRELESS_ALARM_START      0x0e  /* ���߱�����ʼ */
#define MINOR_WIRELESS_ALARM_STOP  	    0x0f /* ���߱������� */
#define MINOR_PIR_ALARM_START   	    0x10  /* �����Ӧ������ʼ */
#define MINOR_PIR_ALARM_STOP   		    0x11  /* �����Ӧ�������� */
#define MINOR_CALLHELP_ALARM_START  	0x12  /* ���ȱ�����ʼ */
#define MINOR_CALLHELP_ALARM_STOP  		0x13  /* ���ȱ������� */
#define MINOR_IPCHANNEL_ALARMIN_START   0x14  //����ͨ���������뿪ʼ��PCNVR�ڽ��յ�����ͨ����MINOR_ALARM_IN��������ͨ���������뿪ʼ����10s�����ղ���MINOR_ALARM_IN����������ͨ�������������
#define MINOR_IPCHANNEL_ALARMIN_STOP    0x15  //����ͨ���������뿪ʼ��ͬ��
#define MINOR_DETECTFACE_ALARM_START    0x16  /* ������ⱨ����ʼ */
#define MINOR_DETECTFACE_ALARM_STOP  	0x17  /* ������ⱨ������ */
#define MINOR_VQD_ALARM_START           0x18  //VQD����
#define MINOR_VQD_ALARM_STOP            0x19  //VQD��������
#define MINOR_VCA_SECNECHANGE_DETECTION 0x1a  //������ⱨ�� 2013-07-16

#define MINOR_SMART_REGION_EXITING_BEGIN            0x1b  //�뿪������⿪ʼ
#define MINOR_SMART_REGION_EXITING_END              0x1c  //�뿪����������
#define MINOR_SMART_LOITERING_BEGIN                 0x1d  //�ǻ���⿪ʼ
#define MINOR_SMART_LOITERING_END                   0x1e  //�ǻ�������

#define MINOR_VCA_ALARM_LINE_DETECTION_BEGIN        0x20
#define MINOR_VCA_ALARM_LINE_DETECTION_END          0x21
#define MINOR_VCA_ALARM_INTRUDE_BEGIN				0x22  //������⿪ʼ
#define MINOR_VCA_ALARM_INTRUDE_END				   	0x23  //����������
#define MINOR_VCA_ALARM_AUDIOINPUT                	0x24   //��Ƶ�쳣����
#define MINOR_VCA_ALARM_AUDIOABNORMAL             	0x25   //��ǿͻ��
#define MINOR_VCA_DEFOCUS_DETECTION_BEGIN           0x26  //�齹��⿪ʼ
#define MINOR_VCA_DEFOCUS_DETECTION_END            	0x27  //�齹������

//����NVR
#define MINOR_EXT_ALARM                             0x28/*IPC�ⲿ����*/
#define MINOR_VCA_FACE_ALARM_BEGIN					0x29	/*������⿪ʼ*/
#define MINOR_SMART_REGION_ENTRANCE_BEGIN           0x2a  //����������⿪ʼ
#define MINOR_SMART_REGION_ENTRANCE_END             0x2b  //��������������
#define MINOR_SMART_PEOPLE_GATHERING_BEGIN          0x2c  //��Ա�ۼ���⿪ʼ
#define MINOR_SMART_PEOPLE_GATHERING_END            0x2d  //��Ա�ۼ�������
#define MINOR_SMART_FAST_MOVING_BEGIN               0x2e  //�����˶���⿪ʼ
#define MINOR_SMART_FAST_MOVING_END                 0x2f  //�����˶�������

#define MINOR_VCA_FACE_ALARM_END					0x30	/*����������*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN			0x31   /*���������⿪ʼ*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_END			0x32   /*�������������*/
#define MINOR_VCA_ALARM_AUDIOINPUT_BEGIN			0x33   /*��Ƶ�쳣���뿪ʼ*/
#define MINOR_VCA_ALARM_AUDIOINPUT_END				0x34   /*��Ƶ�쳣�������*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN			0x35  /*��ǿͻ����⿪ʼ*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_END			0x36  /*��ǿͻ��������*/

#define MINOR_VCA_LECTURE_DETECTION_BEGIN           0x37  //�ڿ���⿪ʼ����
#define MINOR_VCA_LECTURE_DETECTION_END             0x38  //�ڿ�������
#define MINOR_VCA_ALARM_AUDIOSTEEPDROP              0x39  //��ǿ���� 2014-03-21
#define MINOR_VCA_ANSWER_DETECTION_BEGIN            0x3a  //�ش�������⿪ʼ����
#define MINOR_VCA_ANSWER_DETECTION_END              0x3b  //�ش�����������

#define MINOR_SMART_PARKING_BEGIN                   0x3c   //ͣ����⿪ʼ
#define MINOR_SMART_PARKING_END                     0x3d   //ͣ��������
#define MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN        0x3e   //��Ʒ������⿪ʼ
#define MINOR_SMART_UNATTENDED_BAGGAGE_END          0x3f   //��Ʒ����������
#define MINOR_SMART_OBJECT_REMOVAL_BEGIN            0x40   //��Ʒ��ȡ��⿪ʼ
#define MINOR_SMART_OBJECT_REMOVAL_END              0x41   //��Ʒ��ȡ������
#define MINOR_SMART_VEHICLE_ALARM_START             0x46   //���Ƽ�⿪ʼ
#define MINOR_SMART_VEHICLE_ALARM_STOP              0x47   //���Ƽ�����
#define MINOR_THERMAL_FIREDETECTION                 0x48   //�ȳ���������⿪ʼ
#define MINOR_THERMAL_FIREDETECTION_END             0x49   //�ȳ�������������
#define MINOR_SMART_VANDALPROOF_BEGIN               0x50   //���ƻ���⿪ʼ
#define MINOR_SMART_VANDALPROOF_END                 0x51   //���ƻ�������

//0x400-0x1000 �Ž�
#define MINOR_ALARMIN_SHORT_CIRCUIT                 0x400  //�����·����
#define MINOR_ALARMIN_BROKEN_CIRCUIT                0x401  //�����·����
#define MINOR_ALARMIN_EXCEPTION                     0x402  //�����쳣����
#define MINOR_ALARMIN_RESUME                        0x403  //�����ָ�
#define MINOR_HOST_DESMANTLE_ALARM                  0x404  //������𱨾�
#define MINOR_HOST_DESMANTLE_RESUME                 0x405  //�������ָ�
#define MINOR_CARD_READER_DESMANTLE_ALARM           0x406  //���������𱨾�
#define MINOR_CARD_READER_DESMANTLE_RESUME          0x407  //����������ָ�
#define MINOR_CASE_SENSOR_ALARM                     0x408  //�¼����뱨��
#define MINOR_CASE_SENSOR_RESUME                    0x409  //�¼�����ָ�
#define MINOR_STRESS_ALARM                          0x40a  //в�ȱ���
#define MINOR_OFFLINE_ECENT_NEARLY_FULL             0x40b  //�����¼���90%����
#define MINOR_CARD_MAX_AUTHENTICATE_FAIL            0x40c  //������֤ʧ�ܳ��α���
#define MINOR_SD_CARD_FULL                          0x40d  //SD���洢��
#define MINOR_LINKAGE_CAPTURE_PIC                   0x40e  //����ץ���¼�����

/* �쳣 */
//������
#define MAJOR_EXCEPTION					0x2
//������
#define MINOR_RAID_ERROR				0x20	/* �����쳣 */
#define MINOR_VI_LOST					0x21	/* ��Ƶ�źŶ�ʧ */
#define MINOR_ILLEGAL_ACCESS			0x22	/* �Ƿ����� */
#define MINOR_HD_FULL					0x23	/* Ӳ���� */
#define MINOR_HD_ERROR					0x24	/* Ӳ�̴��� */
#define MINOR_DCD_LOST					0x25	/* MODEM ����(������ʹ��) */
#define MINOR_IP_CONFLICT				0x26	/* IP��ַ��ͻ */
#define MINOR_NET_BROKEN				0x27	/* ����Ͽ�*/
#define MINOR_REC_ERROR                 0x28    /* ¼����� */
#define MINOR_IPC_NO_LINK               0x29    /* IPC�����쳣 */
#define MINOR_VI_EXCEPTION              0x2a    /* ��Ƶ�����쳣(ֻ���ģ��ͨ��) */
#define MINOR_IPC_IP_CONFLICT           0x2b    /*ipc ip ��ַ ��ͻ*/
#define MINOR_SENCE_EXCEPTION           0x2c    // �����쳣

#define MINOR_PIC_REC_ERROR  			0x2d    /* ץͼ����--��ȡͼƬ�ļ�ʧ��*/
#define MINOR_VI_MISMATCH    			0x2e    /* ��Ƶ��ʽ��ƥ��*/
#define MINOR_RESOLUTION_MISMATCH		0x2f	/*ǰ��/¼��ֱ��ʲ�ƥ��  */

//2009-12-16 ������Ƶ�ۺ�ƽ̨��־����
#define MINOR_FANABNORMAL				0x31	/* ��Ƶ�ۺ�ƽ̨������״̬�쳣 */
#define MINOR_FANRESUME					0x32	/* ��Ƶ�ۺ�ƽ̨������״̬�ָ��� */
#define MINOR_SUBSYSTEM_ABNORMALREBOOT	0x33	/* ��Ƶ�ۺ�ƽ̨��6467�쳣���� */
#define MINOR_MATRIX_STARTBUZZER		0x34	/* ��Ƶ�ۺ�ƽ̨��dm6467�쳣������������ */

//2010-01-22 ������Ƶ�ۺ�ƽ̨�쳣��־������
#define MINOR_NET_ABNORMAL				0x35	/*����״̬�쳣*/
#define MINOR_MEM_ABNORMAL				0x36	/*�ڴ�״̬�쳣*/
#define MINOR_FILE_ABNORMAL				0x37	/*�ļ�״̬�쳣*/
#define MINOR_PANEL_ABNORMAL			0x38 /*ǰ��������쳣*/
#define MINOR_PANEL_RESUME				0x39 /*ǰ���ָ���*/
#define MINOR_RS485_DEVICE_ABNORMAL		0x3a 	/*RS485����״̬�쳣*/
#define MINOR_RS485_DEVICE_REVERT		0x3b    /*RS485����״̬�쳣�ָ�*/

//2012-2-18 ���Ӵ����������쳣��־������
#define MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT   0x3c            //�Ӱ��쳣����
#define	MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT	0x3d			//�Ӱ����
#define	MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT	0x3e			//�Ӱ�γ�
#define	MINOR_SCREEN_ABNARMALTEMPERATURE		0x3f			//�¶��쳣
//2012-07-26 ��Ƶ�ۺ�ƽ̨v2.1
#define MINOR_HIGH_TEMPERATURE_PROTECT          0x40 //�Ӱ���ȱ���

//Netra 2.2.2
#define MINOR_RECORD_OVERFLOW                   0x41              /*���������*/
#define MINOR_DSP_ABNORMAL                      0x42              //DSP�쳣

//Netra 3.0.0
#define MINOR_ANR_RECORD_FAIED                 0x43         /*ANR¼��ʧ��*/
#define MINOR_SPARE_WORK_DEVICE_EXCEPT         0x44			/*�ȱ��豸�������쳣*/
#define MINOR_START_IPC_MAS_FAILED             0x45			/*����IPC MASʧ��*/
//������ 256·NVR
#define MINOR_IPCM_CRASH                       0x46         /*IPCM�쳣����*/
#define MINOR_POE_POWER_EXCEPTION              0x47         /*POE �����쳣*/
#define MINOR_UPLOAD_DATA_CS_EXCEPTION         0x48          //�ƴ洢����ϴ�ʧ��/
#define MINOR_DIAL_EXCEPTION                   0x49         /*�����쳣*/
#define MINOR_DEV_EXCEPTION_OFFLINE            0x50  //�豸�쳣����
#define MINOR_UPGRADEFAIL                      0x51 //Զ�����豸ʧ��
#define MINOR_AI_LOST						   0x52	/* ��Ƶ�źŶ�ʧ */
#define MINOR_SYNC_IPC_PASSWD				   0x53	/* ͬ��IPC�����쳣 */
#define MINOR_EZVIZ_OFFLINE			 		   0x54	/* өʯ�����쳣*/

//0x400-0x1000 �Ž��쳣����
#define MINOR_DEV_POWER_ON                     0x400  //�豸�ϵ�����
#define MINOR_DEV_POWER_OFF                    0x401  //�豸����ر�
#define MINOR_WATCH_DOG_RESET                  0x402  //���Ź���λ
#define MINOR_LOW_BATTERY                      0x403  //���ص�ѹ��
#define MINOR_BATTERY_RESUME                   0x404  //���ص�ѹ�ָ���
#define MINOR_AC_OFF                           0x405  //������ϵ�
#define MINOR_AC_RESUME                        0x406  //������ָ�
#define MINOR_NET_RESUME                       0x407  //����ָ�
#define MINOR_FLASH_ABNORMAL                   0x408  //FLASH��д�쳣
#define MINOR_CARD_READER_OFFLINE              0x409  //����������
#define MINOR_CARD_READER_RESUME               0x40a  //���������߻ָ�
#define MINOR_INDICATOR_LIGHT_OFF              0x40b  //ָʾ�ƹر�
#define MINOR_INDICATOR_LIGHT_RESUME           0x40c  //ָʾ�ƻָ�
#define MINOR_CHANNEL_CONTROLLER_OFF           0x40d  //ͨ������������
#define MINOR_CHANNEL_CONTROLLER_RESUME        0x40e  //ͨ���������ָ�

//[add]by silujie 2013-3-22 14:16
//0x2000~0x3fff Ϊ�豸������־
//0x4000~0x5000 Ϊ�豸�쳣��־
#define MINOR_SUBSYSTEM_IP_CONFLICT		0x4000		//�Ӱ�IP��ͻ
#define MINOR_SUBSYSTEM_NET_BROKEN		0x4001		//�Ӱ����
#define	MINOR_FAN_ABNORMAL				0x4002		//�����쳣
#define	MINOR_BACKPANEL_TEMPERATURE_ABNORMAL		0x4003		//�����¶��쳣

#define	MINOR_SDCARD_ABNORMAL	        0x4004		//SD��������
#define	MINOR_SDCARD_DAMAGE		        0x4005		//SD����


/* ���� */
//������
#define MAJOR_OPERATION					0x3

//������
#define MINOR_VCA_MOTIONEXCEPTION		0x29  //��������쳣
#define MINOR_START_DVR					0x41	/* ���� */
#define MINOR_STOP_DVR					0x42	/* �ػ� */
#define MINOR_STOP_ABNORMAL				0x43	/* �쳣�ػ� */
#define MINOR_REBOOT_DVR                0x44    /*���������豸*/

#define MINOR_LOCAL_LOGIN				0x50	/* ���ص�½ */
#define MINOR_LOCAL_LOGOUT				0x51	/* ����ע���½ */
#define MINOR_LOCAL_CFG_PARM			0x52	/* �������ò��� */
#define MINOR_LOCAL_PLAYBYFILE          0x53	/* ���ذ��ļ��طŻ����� */
#define MINOR_LOCAL_PLAYBYTIME          0x54	/* ���ذ�ʱ��طŻ�����*/
#define MINOR_LOCAL_START_REC			0x55	/* ���ؿ�ʼ¼�� */
#define MINOR_LOCAL_STOP_REC			0x56	/* ����ֹͣ¼�� */
#define MINOR_LOCAL_PTZCTRL				0x57	/* ������̨���� */
#define MINOR_LOCAL_PREVIEW				0x58	/* ����Ԥ�� (������ʹ��)*/
#define MINOR_LOCAL_MODIFY_TIME         0x59	/* �����޸�ʱ��(������ʹ��) */
#define MINOR_LOCAL_UPGRADE             0x5a	/* ������ */
#define MINOR_LOCAL_RECFILE_OUTPUT      0x5b    /* ���ر���¼���ļ� */
#define MINOR_LOCAL_FORMAT_HDD          0x5c    /* ���س�ʼ��Ӳ�� */
#define MINOR_LOCAL_CFGFILE_OUTPUT      0x5d    /* �������������ļ� */
#define MINOR_LOCAL_CFGFILE_INPUT       0x5e    /* ���뱾�������ļ� */
#define MINOR_LOCAL_COPYFILE            0x5f    /* ���ر����ļ� */
#define MINOR_LOCAL_LOCKFILE            0x60    /* ������¼���ļ� */
#define MINOR_LOCAL_UNLOCKFILE          0x61    /* ���ؽ���¼���ļ� */
#define MINOR_LOCAL_DVR_ALARM           0x62    /* �����ֶ����ʹ�������*/
#define MINOR_IPC_ADD                   0x63    /* �������IPC */
#define MINOR_IPC_DEL                   0x64    /* ����ɾ��IPC */
#define MINOR_IPC_SET                   0x65    /* ��������IPC */
#define MINOR_LOCAL_START_BACKUP		0x66	/* ���ؿ�ʼ���� */
#define MINOR_LOCAL_STOP_BACKUP			0x67	/* ����ֹͣ����*/
#define MINOR_LOCAL_COPYFILE_START_TIME 0x68	/* ���ر��ݿ�ʼʱ��*/
#define MINOR_LOCAL_COPYFILE_END_TIME	0x69	/* ���ر��ݽ���ʱ��*/
#define MINOR_LOCAL_ADD_NAS             0x6a	/*�����������Ӳ�� ��nfs��iscsi��*/
#define MINOR_LOCAL_DEL_NAS             0x6b	/* ����ɾ��nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_SET_NAS             0x6c	/* ��������nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_RESET_PASSWD        0x6d    /* ���ػָ�����ԱĬ������*/

#define MINOR_REMOTE_LOGIN				0x70	/* Զ�̵�¼ */
#define MINOR_REMOTE_LOGOUT				0x71	/* Զ��ע���½ */
#define MINOR_REMOTE_START_REC			0x72	/* Զ�̿�ʼ¼�� */
#define MINOR_REMOTE_STOP_REC			0x73	/* Զ��ֹͣ¼�� */
#define MINOR_START_TRANS_CHAN			0x74	/* ��ʼ͸������ */
#define MINOR_STOP_TRANS_CHAN			0x75	/* ֹͣ͸������ */
#define MINOR_REMOTE_GET_PARM			0x76	/* Զ�̻�ȡ���� */
#define MINOR_REMOTE_CFG_PARM			0x77	/* Զ�����ò��� */
#define MINOR_REMOTE_GET_STATUS         0x78	/* Զ�̻�ȡ״̬ */
#define MINOR_REMOTE_ARM				0x79	/* Զ�̲��� */
#define MINOR_REMOTE_DISARM				0x7a	/* Զ�̳��� */
#define MINOR_REMOTE_REBOOT				0x7b	/* Զ������ */
#define MINOR_START_VT					0x7c	/* ��ʼ�����Խ� */
#define MINOR_STOP_VT					0x7d	/* ֹͣ�����Խ� */
#define MINOR_REMOTE_UPGRADE			0x7e	/* Զ���� */
#define MINOR_REMOTE_PLAYBYFILE         0x7f	/* Զ�̰��ļ��ط� */
#define MINOR_REMOTE_PLAYBYTIME         0x80	/* Զ�̰�ʱ��ط� */
#define MINOR_REMOTE_PTZCTRL			0x81	/* Զ����̨���� */
#define MINOR_REMOTE_FORMAT_HDD         0x82    /* Զ�̸�ʽ��Ӳ�� */
#define MINOR_REMOTE_STOP               0x83    /* Զ�̹ػ� */
#define MINOR_REMOTE_LOCKFILE			0x84	/* Զ�����ļ� */
#define MINOR_REMOTE_UNLOCKFILE         0x85	/* Զ�̽����ļ� */
#define MINOR_REMOTE_CFGFILE_OUTPUT     0x86    /* Զ�̵��������ļ� */
#define MINOR_REMOTE_CFGFILE_INTPUT     0x87    /* Զ�̵��������ļ� */
#define MINOR_REMOTE_RECFILE_OUTPUT     0x88    /* Զ�̵���¼���ļ� */
#define MINOR_REMOTE_DVR_ALARM          0x89    /* Զ���ֶ����ʹ�������*/
#define MINOR_REMOTE_IPC_ADD			0x8a	/* Զ�����IPC */
#define MINOR_REMOTE_IPC_DEL			0x8b	/* Զ��ɾ��IPC */
#define MINOR_REMOTE_IPC_SET			0x8c	/* Զ������IPC */
#define MINOR_REBOOT_VCA_LIB            0x8d    /*�������ܿ�*/
#define MINOR_REMOTE_ADD_NAS            0x8e   /* Զ�����nas�� ��nfs��iscsi��*/
#define MINOR_REMOTE_DEL_NAS            0x8f   /* Զ��ɾ��nas�� ��nfs��iscsi��*/
#define MINOR_REMOTE_SET_NAS            0x90   /* Զ������nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_OPERATE_LOCK        0x9d			/* ���ز�����             */
#define MINOR_LOCAL_OPERATE_UNLOCK      0x9e            /* ���ز��������         */
#define MINOR_REMOTE_DELETE_HDISK       0x9a            /* Զ��ɾ���쳣�����ڵ�Ӳ�� */
#define MINOR_REMOTE_LOAD_HDISK         0x9b            /* Զ�̼���Ӳ��             */
#define MINOR_REMOTE_UNLOAD_HDISK       0x9c            /* Զ��ж��Ӳ��   */


//2010-05-26 ������ѶDVR��־����
#define MINOR_LOCAL_START_REC_CDRW      0x91   /* ���ؿ�ʼѶ�� */
#define MINOR_LOCAL_STOP_REC_CDRW       0x92   /* ����ֹͣѶ�� */
#define MINOR_REMOTE_START_REC_CDRW     0x93   /* Զ�̿�ʼѶ�� */
#define MINOR_REMOTE_STOP_REC_CDRW      0x94   /* Զ��ֹͣѶ�� */

#define MINOR_LOCAL_PIC_OUTPUT			0x95   /* ���ر���ͼƬ�ļ� */
#define MINOR_REMOTE_PIC_OUTPUT			0x96   /* Զ�̱���ͼƬ�ļ� */

//2011-07-26 ����81��ѶDVR��־����
#define MINOR_LOCAL_INQUEST_RESUME      0x97   /* ���ػָ���Ѷ�¼�*/
#define MINOR_REMOTE_INQUEST_RESUME     0x98   /* Զ�ָ̻���Ѷ�¼�*/

//2013-01-23 ����86������ѶNVR������־
#define MINOR_LOCAL_ADD_FILE            0x99        /*���ص����ļ�*/
#define MINOR_LOCAL_DEL_FILE            0x9f        /*����ɾ����Ѷ*/
#define MINOR_REMOTE_INQUEST_ADD_FILE   0x100       /*Զ�̵����ļ�*/
#define MINOR_REMOTE_INQUEST_DEL_FILE   0x101       /*Զ��ɾ���ļ�*/

//2009-12-16 ������Ƶ�ۺ�ƽ̨��־����
#define MINOR_SUBSYSTEMREBOOT           0xa0	/*��Ƶ�ۺ�ƽ̨��dm6467 ������*/
#define MINOR_MATRIX_STARTTRANSFERVIDEO 0xa1	/*��Ƶ�ۺ�ƽ̨�������л���ʼ����ͼ��*/
#define MINOR_MATRIX_STOPTRANSFERVIDEO	0xa2	/*��Ƶ�ۺ�ƽ̨�������л�ֹͣ����ͼ��*/
#define MINOR_REMOTE_SET_ALLSUBSYSTEM   0xa3	/*��Ƶ�ۺ�ƽ̨����������6467��ϵͳ��Ϣ*/
#define MINOR_REMOTE_GET_ALLSUBSYSTEM   0xa4	/*��Ƶ�ۺ�ƽ̨����ȡ����6467��ϵͳ��Ϣ*/
#define MINOR_REMOTE_SET_PLANARRAY      0xa5	/*��Ƶ�ۺ�ƽ̨�����üƻ���Ѳ��*/
#define MINOR_REMOTE_GET_PLANARRAY      0xa6	/*��Ƶ�ۺ�ƽ̨����ȡ�ƻ���Ѳ��*/
#define MINOR_MATRIX_STARTTRANSFERAUDIO 0xa7	/*��Ƶ�ۺ�ƽ̨�������л���ʼ������Ƶ*/
#define MINOR_MATRIX_STOPRANSFERAUDIO   0xa8	/*��Ƶ�ۺ�ƽ̨�������л�ֹͣ������Ƶ*/
#define MINOR_LOGON_CODESPITTER         0xa9	/*��Ƶ�ۺ�ƽ̨����½�����*/
#define MINOR_LOGOFF_CODESPITTER        0xaa	/*��Ƶ�ۺ�ƽ̨���˳������*/

//2010-01-22 ������Ƶ�ۺ�ƽ̨�н�����������־
#define MINOR_START_DYNAMIC_DECODE 		0xb0	/*��ʼ��̬����*/
#define MINOR_STOP_DYNAMIC_DECODE		0xb1	/*ֹͣ��̬����*/
#define MINOR_GET_CYC_CFG				0xb2	/*��ȡ������ͨ����Ѳ����*/
#define MINOR_SET_CYC_CFG				0xb3	/*���ý���ͨ����Ѳ����*/
#define MINOR_START_CYC_DECODE			0xb4	/*��ʼ��Ѳ����*/
#define MINOR_STOP_CYC_DECODE			0xb5	/*ֹͣ��Ѳ����*/
#define MINOR_GET_DECCHAN_STATUS		0xb6	/*��ȡ����ͨ��״̬*/
#define MINOR_GET_DECCHAN_INFO			0xb7	/*��ȡ����ͨ����ǰ��Ϣ*/
#define MINOR_START_PASSIVE_DEC			0xb8	/*��ʼ��������*/
#define MINOR_STOP_PASSIVE_DEC			0xb9	/*ֹͣ��������*/
#define MINOR_CTRL_PASSIVE_DEC			0xba	/*���Ʊ�������*/
#define MINOR_RECON_PASSIVE_DEC			0xbb	/*������������*/
#define MINOR_GET_DEC_CHAN_SW			0xbc	/*��ȡ����ͨ���ܿ���*/
#define MINOR_SET_DEC_CHAN_SW			0xbd	/*���ý���ͨ���ܿ���*/
#define MINOR_CTRL_DEC_CHAN_SCALE		0xbe	/*����ͨ�����ſ���*/
#define MINOR_SET_REMOTE_REPLAY			0xbf	/*����Զ�̻ط�*/
#define MINOR_GET_REMOTE_REPLAY			0xc0	/*��ȡԶ�̻ط�״̬*/
#define MINOR_CTRL_REMOTE_REPLAY		0xc1	/*Զ�̻طſ���*/
#define MINOR_SET_DISP_CFG				0xc2	/*������ʾͨ��*/
#define MINOR_GET_DISP_CFG				0xc3	/*��ȡ��ʾͨ������*/
#define MINOR_SET_PLANTABLE				0xc4	/*���üƻ���Ѳ��*/
#define MINOR_GET_PLANTABLE				0xc5	/*��ȡ�ƻ���Ѳ��*/
#define MINOR_START_PPPPOE				0xc6	/*��ʼPPPoE����*/
#define MINOR_STOP_PPPPOE				0xc7	/*����PPPoE����*/
#define MINOR_UPLOAD_LOGO				0xc8	/*�ϴ�LOGO*/
//��ģʽ������־
#define MINOR_LOCAL_PIN					0xc9    /* ����PIN���ܲ��� */
#define MINOR_LOCAL_DIAL				0xca    /* �����ֶ������Ͽ����� */
#define MINOR_SMS_CONTROL				0xcb    /* ���ſ��������� */
#define MINOR_CALL_ONLINE				0xcc    /* ���п������� */
#define MINOR_REMOTE_PIN				0xcd    /* Զ��PIN���ܲ��� */
//2010-12-16 ��������־
#define MINOR_REMOTE_BYPASS             0xd0    /* Զ����·*/
#define MINOR_REMOTE_UNBYPASS           0xd1    /* Զ����·�ָ�*/
#define MINOR_REMOTE_SET_ALARMIN_CFG    0xd2    /* Զ�����ñ����������*/
#define MINOR_REMOTE_GET_ALARMIN_CFG    0xd3    /* Զ�̻�ȡ�����������*/
#define MINOR_REMOTE_SET_ALARMOUT_CFG   0xd4    /* Զ�����ñ����������*/
#define MINOR_REMOTE_GET_ALARMOUT_CFG   0xd5    /* Զ�̻�ȡ�����������*/
#define MINOR_REMOTE_ALARMOUT_OPEN_MAN  0xd6    /* Զ���ֶ������������*/
#define MINOR_REMOTE_ALARMOUT_CLOSE_MAN 0xd7    /* Զ���ֶ��رձ������*/
#define MINOR_REMOTE_ALARM_ENABLE_CFG   0xd8    /* Զ�����ñ��������RS485����ʹ��״̬*/
#define MINOR_DBDATA_OUTPUT				0xd9	/* ������ݿ��¼ */
#define MINOR_DBDATA_INPUT				0xda	/* ������ݿ��¼ */
#define MINOR_MU_SWITCH					0xdb	/* �����л� */
#define MINOR_MU_PTZ					0xdc	/* ����PTZ���� */
#define MINOR_DELETE_LOGO               0xdd    /* ɾ��logo */

#define MINOR_LOCAL_CONF_REB_RAID       0x101           /*���������Զ��ؽ�*/
#define MINOR_LOCAL_CONF_SPARE          0x102           /*���������ȱ�*/
#define MINOR_LOCAL_ADD_RAID            0x103           /*���ش�������*/
#define MINOR_LOCAL_DEL_RAID            0x104           /*����ɾ������*/
#define MINOR_LOCAL_MIG_RAID            0x105           /*����Ǩ������*/
#define MINOR_LOCAL_REB_RAID            0x106           /* �����ֶ��ؽ�����*/
#define MINOR_LOCAL_QUICK_CONF_RAID     0x107           /*����һ������*/
#define MINOR_LOCAL_ADD_VD              0x108           /*���ش����������*/
#define MINOR_LOCAL_DEL_VD              0x109           /*����ɾ���������*/
#define MINOR_LOCAL_RP_VD               0x10a           /*�����޸��������*/
#define MINOR_LOCAL_FORMAT_EXPANDVD     0X10b           /*������չ�����������*/
#define MINOR_LOCAL_RAID_UPGRADE        0X10c           /*����raid����*/
#define MINOR_LOCAL_STOP_RAID           0x10d           /*������ͣRAID����(����ȫ����)*/
#define MINOR_REMOTE_CONF_REB_RAID      0x111           /*Զ�������Զ��ؽ�*/
#define MINOR_REMOTE_CONF_SPARE         0x112            /*Զ�������ȱ�*/
#define MINOR_REMOTE_ADD_RAID           0x113           /*Զ�̴�������*/
#define MINOR_REMOTE_DEL_RAID           0x114           /*Զ��ɾ������*/
#define MINOR_REMOTE_MIG_RAID           0x115           /*Զ��Ǩ������*/
#define MINOR_REMOTE_REB_RAID           0x116           /* Զ���ֶ��ؽ�����*/
#define MINOR_REMOTE_QUICK_CONF_RAID    0x117           /*Զ��һ������*/
#define MINOR_REMOTE_ADD_VD             0x118           /*Զ�̴����������*/
#define MINOR_REMOTE_DEL_VD             0x119           /*Զ��ɾ���������*/
#define MINOR_REMOTE_RP_VD              0x11a           /*Զ���޸��������*/
#define MINOR_REMOTE_FORMAT_EXPANDVD    0X11b           /*Զ�������������*/
#define MINOR_REMOTE_RAID_UPGRADE       0X11c           /*Զ��raid����*/
#define MINOR_REMOTE_STOP_RAID          0x11d           /*Զ����ͣRAID����(����ȫ����)*/
#define MINOR_LOCAL_START_PIC_REC       0x121          /*���ؿ�ʼץͼ*/
#define MINOR_LOCAL_STOP_PIC_REC        0x122          /*����ֹͣץͼ*/
#define MINOR_LOCAL_SET_SNMP            0x125           /*��������SNMP*/
#define MINOR_LOCAL_TAG_OPT             0x126          /*���ر�ǩ����*/
#define MINOR_REMOTE_START_PIC_REC      0x131          /*Զ�̿�ʼץͼ*/
#define MINOR_REMOTE_STOP_PIC_REC       0x132           /*Զ��ֹͣץͼ*/
#define MINOR_REMOTE_SET_SNMP           0x135            /*Զ������SNMP*/
#define MINOR_REMOTE_TAG_OPT            0x136             /*Զ�̱�ǩ����*/

// 9000 v2.2.0
#define MINOR_LOCAL_VOUT_SWITCH         0x140   /* ����������л�����*/
#define MINOR_STREAM_CABAC         		0x141   /* ����ѹ������ѡ�����ò���*/

//Netra 3.0.0
#define MINOR_LOCAL_SPARE_OPT       	0x142   /*����N+1 �ȱ���ز���*/
#define MINOR_REMOTE_SPARE_OPT    		0x143   /*Զ��N+1 �ȱ���ز���*/
#define MINOR_LOCAL_IPCCFGFILE_OUTPUT	0x144  	/* ���ص���ipc�����ļ�*/
#define MINOR_LOCAL_IPCCFGFILE_INPUT  	0x145   /* ���ص���ipc�����ļ� */
#define MINOR_LOCAL_IPC_UPGRADE         0x146   /* ������IPC */
#define MINOR_REMOTE_IPCCFGFILE_OUTPUT  0x147   /* Զ�̵���ipc�����ļ�*/
#define MINOR_REMOTE_IPCCFGFILE_INPUT   0x148   /* Զ�̵���ipc�����ļ�*/
#define MINOR_REMOTE_IPC_UPGRADE        0x149   /* Զ����IPC */



#define MINOR_SET_MULTI_MASTER          0x201    /*���ô�������*/
#define MINOR_SET_MULTI_SLAVE           0x202    /*���ô�������*/
#define MINOR_CANCEL_MULTI_MASTER       0x203    /*ȡ���������*/
#define MINOR_CANCEL_MULTI_SLAVE        0x204    /*ȡ���������*/

#define MINOR_DISPLAY_LOGO				0x205    /*��ʾLOGO*/
#define MINOR_HIDE_LOGO                 0x206    /*����LOGO*/
#define MINOR_SET_DEC_DELAY_LEVEL       0x207    /*����ͨ����ʱ��������*/
#define MINOR_SET_BIGSCREEN_DIPLAY_AREA 0x208    /*���ô�����ʾ����*/
#define MINOR_CUT_VIDEO_SOURCE          0x209    /*������ƵԴ�и�����*/
#define MINOR_SET_BASEMAP_AREA          0x210    /*������ͼ��������*/
#define MINOR_DOWNLOAD_BASEMAP          0x211    /*���ش�����ͼ*/
#define MINOR_CUT_BASEMAP               0x212    /*��ͼ�и�����*/
#define MINOR_CONTROL_ELEC_ENLARGE      0x213    /*���ӷŴ����(�Ŵ��ԭ)*/
#define MINOR_SET_OUTPUT_RESOLUTION     0x214    /*��ʾ����ֱ�������*/
#define MINOR_SET_TRANCSPARENCY         0X215    /*ͼ��͸��������*/
#define MINOR_SET_OSD                   0x216    /*��ʾOSD����*/
#define MINOR_RESTORE_DEC_STATUS        0x217    /*�ָ���ʼ״̬(�����л�ʱ������ָ���ʼ״̬)*/

//2011-11-11 ���Ӵ���������������־������
#define MINOR_SCREEN_SET_INPUT			0x251    /*�޸�����Դ*/
#define MINOR_SCREEN_SET_OUTPUT			0x252    /*�޸����ͨ��*/
#define MINOR_SCREEN_SET_OSD			0x253    /*�޸�����LED*/
#define MINOR_SCREEN_SET_LOGO			0x254    /*�޸�LOGO*/
#define MINOR_SCREEN_SET_LAYOUT			0x255    /*���ò���*/
#define	MINOR_SCREEN_PICTUREPREVIEW		0x256	 /*���Բ���*/

//2012-06-14 CVCS2.0, �������õȲ�����V1.0�� V1.1���Ѿ����ˣ���ʱ���豸��־��û�ж���
#define MINOR_SCREEN_GET_OSD			0x257   /*��ȡ����LED*/
#define MINOR_SCREEN_GET_LAYOUT			0x258   /*��ȡ����*/
#define MINOR_SCREEN_LAYOUT_CTRL		0x259   /*���ֿ���*/
#define MINOR_GET_ALL_VALID_WND			0x260	/*��ȡ������Ч����*/
#define MINOR_GET_SIGNAL_WND			0x261	/*��ȡ����������Ϣ*/
#define MINOR_WINDOW_CTRL				0x262	/*���ڿ���*/
#define MINOR_GET_LAYOUT_LIST			0x263	/*��ȡ�����б�*/
#define MINOR_LAYOUT_CTRL				0x264	/*���ֿ���*/
#define MINOR_SET_LAYOUT				0x265	/*���ò���*/
#define MINOR_GET_SIGNAL_LIST			0x266	/*��ȡ�����ź�Դ�б�*/
#define MINOR_GET_PLAN_LIST				0x267	/*��ȡԤ���б�*/
#define MINOR_SET_PLAN					0x268	/*�޸�Ԥ��*/
#define MINOR_CTRL_PLAN					0x269	/*����Ԥ��*/
#define MINOR_CTRL_SCREEN				0x270	/*��Ļ����*/
#define MINOR_ADD_NETSIG				0x271	/*����ź�Դ*/
#define MINOR_SET_NETSIG				0x272	/*�޸��ź�Դ*/
#define MINOR_SET_DECBDCFG				0x273	/*���ý�������*/
#define MINOR_GET_DECBDCFG				0x274	/*��ȡ��������*/
#define MINOR_GET_DEVICE_STATUS			0x275	/*��ȡ�豸��Ϣ*/
#define MINOR_UPLOAD_PICTURE			0x276	/*��ͼ�ϴ�*/
#define MINOR_SET_USERPWD				0x277	/*�����û�����*/
#define MINOR_ADD_LAYOUT				0x278	/*��Ӳ���*/
#define MINOR_DEL_LAYOUT				0x279	/*ɾ���*/
#define MINOR_DEL_NETSIG				0x280	/*ɾ���ź�Դ*/
#define MINOR_ADD_PLAN					0x281	/*���Ԥ��*/
#define MINOR_DEL_PLAN					0x282	/*ɾ��Ԥ��*/
#define MINOR_GET_EXTERNAL_MATRIX_CFG	0x283	//��ȡ��Ӿ�������
#define MINOR_SET_EXTERNAL_MATRIX_CFG	0x284	//������Ӿ�������
#define	MINOR_GET_USER_CFG				0x285	//��ȡ�û�����
#define	MINOR_SET_USER_CFG				0x286	//�����û�����
#define	MINOR_GET_DISPLAY_PANEL_LINK_CFG 0x287	//��ȡ��ʾǽ��������
#define	MINOR_SET_DISPLAY_PANEL_LINK_CFG 0x288	//������ʾǽ��������

#define	MINOR_GET_WALLSCENE_PARAM	    0x289		//��ȡ����ǽ����
#define	MINOR_SET_WALLSCENE_PARAM	    0x28a		//���õ���ǽ����
#define	MINOR_GET_CURRENT_WALLSCENE		0x28b		//��ȡ��ǰʹ�ó���
#define	MINOR_SWITCH_WALLSCENE			0x28c		//�����л�
#define	MINOR_SIP_LOGIN					0x28d		//SIPע��ɹ�
#define MINOR_VOIP_START				0x28e		//VOIP�Խ���ʼ
#define MINOR_VOIP_STOP					0x28f		//VOIP�Խ�ֹͣ
#define MINOR_WIN_TOP                   0x290       //����ǽ�����ö�
#define MINOR_WIN_BOTTOM                0x291       //����ǽ�����õ�

// Netra 2.2.2
#define MINOR_LOCAL_LOAD_HDISK          0x300            //���ؼ���Ӳ��
#define MINOR_LOCAL_DELETE_HDISK        0x301            //����ɾ���쳣�����ڵ�Ӳ��

//KY2013 3.0.0
#define MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH	0X302 //�����������л�
#define MINOR_LOCAL_HARD_DISK_CHECK				0x303 //��������Ӳ���Լ�

//Netra3.1.0
#define MINOR_LOCAL_CFG_DEVICE_TYPE		0x310	//���������豸����
#define MINOR_REMOTE_CFG_DEVICE_TYPE	0x311	//Զ�������豸����
#define MINOR_LOCAL_CFG_WORK_HOT_SERVER	0x312	//�������ù������ȱ�������
#define MINOR_REMOTE_CFG_WORK_HOT_SERVER 0x313	//Զ�����ù������ȱ�������
#define MINOR_LOCAL_DELETE_WORK			0x314	//����ɾ������
#define MINOR_REMOTE_DELETE_WORK		0x315	//Զ��ɾ������
#define	MINOR_LOCAL_ADD_WORK			0x316	//������ӹ�����
#define MINOR_REMOTE_ADD_WORK			0x317	//Զ����ӹ�����
#define MINOR_LOCAL_IPCHEATMAP_OUTPUT   0x318            /* ���ص����ȶ�ͼ�ļ�      */
#define MINOR_LOCAL_IPCHEATFLOW_OUTPUT  0x319          /* ���ص����ȶ������ļ�      */
#define MINOR_REMOTE_SMS_SEND           0x350    /*Զ�̷��Ͷ���*/
#define MINOR_LOCAL_SMS_SEND            0x351   /*���ط��Ͷ���*/
#define MINOR_ALARM_SMS_SEND            0x352    /*���Ͷ��ű���*/
#define MINOR_SMS_RECV                  0x353     /*���ն���*/
//����ע��0x350��0x351��ָ�˹���GUI��IE�ؼ��ϱ༭�����Ͷ��ţ�
#define MINOR_LOCAL_SMS_SEARCH          0x354  /*������������*/
#define MINOR_REMOTE_SMS_SEARCH         0x355   /*Զ����������*/
#define MINOR_LOCAL_SMS_READ            0x356   /*���ز鿴����*/
#define MINOR_REMOTE_SMS_READ           0x357   /*Զ�̲鿴����*/
#define MINOR_REMOTE_DIAL_CONNECT       0x358   /*Զ�̿����ֶ�����*/
#define MINOR_REMOTE_DIAL_DISCONN       0x359   /*Զ��ֹͣ�ֶ�����*/
#define MINOR_LOCAL_WHITELIST_SET       0x35A   /*�������ð���*/
#define MINOR_REMOTE_WHITELIST_SET      0x35B   /*Զ�����ð���*/
#define MINOR_LOCAL_DIAL_PARA_SET       0x35C   /*�������ò��Ų���*/
#define MINOR_REMOTE_DIAL_PARA_SET      0x35D   /*Զ�����ò��Ų���*/
#define MINOR_LOCAL_DIAL_SCHEDULE_SET   0x35E   /*�������ò��żƻ�*/
#define MINOR_REMOTE_DIAL_SCHEDULE_SET  0x35F   /*Զ�����ò��żƻ�*/
#define MINOR_PLAT_OPER                 0x360   /* ƽ̨����*/

//0x400-0x1000 �Ž��������
#define MINOR_REMOTE_OPEN_DOOR          0x400   //Զ�̿���
#define MINOR_REMOTE_CLOSE_DOOR         0x401   //Զ�̹���
#define MINOR_REMOTE_ALWAYS_OPEN        0x402   //Զ�̳���
#define MINOR_REMOTE_ALWAYS_CLOSE       0x403   //Զ�̳���
#define MINOR_REMOTE_CHECK_TIME         0x404   //Զ���ֶ�Уʱ
#define MINOR_NTP_CHECK_TIME            0x405   //NTP�Զ�Уʱ
#define MINOR_REMOTE_CLEAR_CARD         0x406   //Զ����տ���
#define MINOR_REMOTE_RESTORE_CFG        0x407   //Զ�ָ̻�Ĭ�ϲ���
#define MINOR_ALARMIN_ARM               0x408   //�����
#define MINOR_ALARMIN_DISARM            0x409   //�����
#define MINOR_LOCAL_RESTORE_CFG         0x40a   //���ػָ�Ĭ�ϲ���
#define MINOR_REMOTE_CAPTURE_PIC        0x40b  //Զ��ץ��
#define MINOR_MOD_NET_REPORT_CFG        0x40c   //�޸��������Ĳ�������
#define MINOR_MOD_GPRS_REPORT_PARAM     0x40d   //�޸�GPRS���Ĳ�������
#define MINOR_MOD_REPORT_GROUP_PARAM    0x40e   //�޸��������������
#define	MINOR_UNLOCK_PASSWORD_OPEN_DOOR  0x40f  //���������

//2012-03-05 ITC������־����
#define MINOR_SET_TRIGGERMODE_CFG          0x1001    /*���ô���ģʽ����*/
#define MINOR_GET_TRIGGERMODE_CFG          0x1002    /*��ȡ����ģʽ����*/
#define MINOR_SET_IOOUT_CFG                0x1003    /*����IO�������*/
#define MINOR_GET_IOOUT_CFG                0x1004    /*��ȡIO�������*/
#define MINOR_GET_TRIGGERMODE_DEFAULT      0x1005    /*��ȡ����ģʽ�Ƽ�����*/
#define MINOR_GET_ITCSTATUS                0x1006    /*��ȡ״̬������*/
#define MINOR_SET_STATUS_DETECT_CFG        0x1007    /*����״̬������*/
#define MINOR_GET_STATUS_DETECT_CFG        0x1008    /*��ȡ״̬������*/
#define MINOR_SET_VIDEO_TRIGGERMODE_CFG    0x1009  /*������Ƶ����ģʽ����*/
#define MINOR_GET_VIDEO_TRIGGERMODE_CFG    0x100a   /*��ȡ��Ƶ����ģʽ����*/

//2013-04-19 ITS������־����
#define MINOR_LOCAL_ADD_CAR_INFO            0x2001  /*������ӳ�����Ϣ*/
#define MINOR_LOCAL_MOD_CAR_INFO            0x2002  /*�����޸ĳ�����Ϣ*/
#define MINOR_LOCAL_DEL_CAR_INFO            0x2003  /*����ɾ������Ϣ*/
#define MINOR_LOCAL_FIND_CAR_INFO           0x2004  /*���ز��ҳ�����Ϣ*/
#define MINOR_LOCAL_ADD_MONITOR_INFO        0x2005  /*������Ӳ�����Ϣ*/
#define MINOR_LOCAL_MOD_MONITOR_INFO        0x2006  /*�����޸Ĳ�����Ϣ*/
#define MINOR_LOCAL_DEL_MONITOR_INFO        0x2007  /*����ɾ�����Ϣ*/
#define MINOR_LOCAL_FIND_MONITOR_INFO       0x2008  /*���ز�ѯ������Ϣ*/
#define MINOR_LOCAL_FIND_NORMAL_PASS_INFO   0x2009  /*���ز�ѯ��ͨ����Ϣ*/
#define MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO 0x200a  /*���ز�ѯ�쳣ͨ����Ϣ*/
#define MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO   0x200b  /*���ز�ѯ��ͨ����Ϣ*/
#define MINOR_LOCAL_PIC_PREVIEW             0x200c  /*����ͼƬԤ��*/
#define MINOR_LOCAL_SET_GATE_PARM_CFG       0x200d  /*���ñ������ó���ڲ���*/
#define MINOR_LOCAL_GET_GATE_PARM_CFG       0x200e  /*��ȡ�������ó���ڲ���*/
#define MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG 0x200f  /*���ñ�����������ϴ�����*/
#define MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG 0x2010  /*��ȡ������������ϴ�����*/

//2013-11-19������־����
#define MINOR_LOCAL_DEVICE_CONTROL                         0x2011   /*�����豸����(���ؿ���բ)*/
#define MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO               0x2012   /*�����������豸��Ϣ */
#define MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO	           0x2013   /*�����޸�����豸��Ϣ */
#define MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO               0x2014   /*����ɾ������豸��Ϣ */
#define MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO              0x2015   /*���ز�ѯ����豸��Ϣ */
#define MINOR_LOCAL_ADD_CHARGE_RULE                        0x2016   /*��������շѹ��� */
#define MINOR_LOCAL_MOD_CHARGE_RULE                        0x2017   /*�����޸��շѹ��� */
#define MINOR_LOCAL_DEL_CHARGE_RULE                        0x2018   /*����ɾ���շѹ��� */
#define MINOR_LOCAL_FIND_CHARGE_RULE                       0x2019   /*���ز�ѯ�շѹ��� */
#define MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO               0x2020   /*����ͳ����ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT       0x2021   /*���ص�����ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO             0x2022   /*����ͳ���쳣ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT     0x2023   /*���ص����쳣ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO           0x2024   /*����ͳ������ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT   0x2025   /*���ص�������ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_FIND_CAR_CHARGEINFO                    0x2026   /*���ز�ѯ���շ���Ϣ */
#define MINOR_LOCAL_COUNT_CAR_CHARGEINFO                   0x2027   /*����ͳ�ƹ��շ���Ϣ */
#define MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT           0x2028   /*���ص������շ���Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_FIND_SHIFTINFO                         0x2029   /*���ز�ѯ���Ӱ���Ϣ */
#define MINOR_LOCAL_FIND_CARDINFO                          0x2030   /*���ز�ѯ��Ƭ��Ϣ */
#define MINOR_LOCAL_ADD_RELIEF_RULE                        0x2031   /*������Ӽ������ */
#define MINOR_LOCAL_MOD_RELIEF_RULE                        0x2032   /*�����޸ļ������ */
#define MINOR_LOCAL_DEL_RELIEF_RULE                        0x2033   /*����ɾ�������� */
#define MINOR_LOCAL_FIND_RELIEF_RULE                       0x2034   /*���ز�ѯ������� */
#define MINOR_LOCAL_GET_ENDETCFG                           0x2035   /*���ػ�ȡ����ڿ��ƻ����߼������ */
#define MINOR_LOCAL_SET_ENDETCFG                           0x2036   /*�������ó���ڿ��ƻ����߼������*/
#define MINOR_LOCAL_SET_ENDEV_ISSUEDDATA                   0x2037   /*�������ó���ڿ��ƻ��·���Ƭ��Ϣ */
#define MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA                   0x2038   /*������ճ���ڿ��ƻ��·���Ƭ��Ϣ */

#define MINOR_REMOTE_DEVICE_CONTROL                        0x2101   /*Զ���豸����*/
#define MINOR_REMOTE_SET_GATE_PARM_CFG                     0x2102   /*����Զ�����ó���ڲ���*/
#define MINOR_REMOTE_GET_GATE_PARM_CFG                     0x2103   /*��ȡԶ�����ó���ڲ���*/
#define MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG               0x2104   /*����Զ����������ϴ�����*/
#define MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG               0x2105   /*��ȡԶ����������ϴ�����*/
#define MINOR_REMOTE_GET_BASE_INFO                         0x2106   /*Զ�̻�ȡ�ն˻���Ϣ*/
#define MINOR_REMOTE_GET_OVERLAP_CFG                       0x2107   /*Զ�̻�ȡ�ַ���Ӳ�������*/
#define MINOR_REMOTE_SET_OVERLAP_CFG                       0x2108   /*Զ�������ַ���Ӳ�������*/
#define MINOR_REMOTE_GET_ROAD_INFO                         0x2109   /*Զ�̻�ȡ·����Ϣ*/
#define MINOR_REMOTE_START_TRANSCHAN                       0x210a   /*Զ�̽���ͬ����ݷ�����*/
#define MINOR_REMOTE_GET_ECTWORKSTATE                      0x210b   /*Զ�̻�ȡ������ն˹���״̬*/
#define MINOR_REMOTE_GET_ECTCHANINFO                       0x210c   /*Զ�̻�ȡ������ն�ͨ��״̬*/

//Զ�̿��� 2013-11-19
#define MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO              0x210d   /*Զ���������豸��Ϣ */
#define MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO              0x210e   /*Զ���޸�����豸��Ϣ */
#define MINOR_REMOTE_GET_ENDETCFG                          0x210f   /*Զ�̻�ȡ����ڿ��ƻ����߼������ */
#define MINOR_REMOTE_SET_ENDETCFG                          0x2110   /*Զ�����ó���ڿ��ƻ����߼������*/
#define MINOR_REMOTE_ENDEV_ISSUEDDATA                      0x2111   /*Զ�����ó���ڿ��ƻ��·���Ƭ��Ϣ */
#define MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA                  0x2112   /*Զ����ճ���ڿ��ƻ��·���Ƭ��Ϣ */

//ITS 0x2115~0x2120 ͣ������λ��Ŀ
#define MINOR_REMOTE_ON_CTRL_LAMP           0x2115  /*����Զ�̿��Ƴ�λָʾ��*/
#define MINOR_REMOTE_OFF_CTRL_LAMP          0x2116  /*�ر�Զ�̿��Ƴ�λָʾ��*/
//Netra3.1.0
#define MINOR_SET_VOICE_LEVEL_PARAM         0x2117  /*����������С */
#define MINOR_SET_VOICE_INTERCOM_PARAM      0x2118  /*��������¼�� */
#define MINOR_SET_INTELLIGENT_PARAM         0x2119  /*��������*/
#define MINOR_LOCAL_SET_RAID_SPEED          0x211a  /*��������raid�ٶ�*/
#define MINOR_REMOTE_SET_RAID_SPEED         0x211b /*Զ������raid�ٶ�*/
//Nerta3.1.2
#define MINOR_REMOTE_CREATE_STORAGE_POOL    0x211c   //Զ����Ӵ洢��
#define MINOR_REMOTE_DEL_STORAGE_POOL       0x211d    //Զ��ɾ��洢��

#define MINOR_REMOTE_DEL_PIC                0x2120   //Զ��ɾ��ͼƬ���
#define MINOR_REMOTE_DEL_RECORD             0x2121   //Զ��ɾ��¼�����
#define MINOR_REMOTE_CLOUD_ENABLE           0x2123  //Զ��������ϵͳ����
#define MINOR_REMOTE_CLOUD_DISABLE          0x2124  //Զ��������ϵͳ����
#define MINOR_REMOTE_CLOUD_MODIFY_PARAM     0x2125  //Զ���޸Ĵ洢�ز���
#define MINOR_REMOTE_CLOUD_MODIFY_VOLUME    0x2126  //Զ���޸Ĵ洢������
#define MINOR_REMOTE_GET_GB28181_SERVICE_PARAM    0x2127  //Զ�̻�ȡGB28181�������
#define MINOR_REMOTE_SET_GB28181_SERVICE_PARAM    0x2128  //Զ������GB28181�������
#define MINOR_LOCAL_GET_GB28181_SERVICE_PARAM     0x2129  //���ػ�ȡGB28181�������
#define MINOR_LOCAL_SET_GB28181_SERVICE_PARAM     0x212a  //��������B28181�������
#define MINOR_REMOTE_SET_SIP_SERVER               0x212b  //Զ������SIP SERVER
#define MINOR_LOCAL_SET_SIP_SERVER                0x212c  //��������SIP SERVER
#define MINOR_LOCAL_BLACKWHITEFILE_OUTPUT         0x212d  //���غڰ�����
#define MINOR_LOCAL_BLACKWHITEFILE_INPUT          0x212e  //���غڰ�����
#define MINOR_REMOTE_BALCKWHITECFGFILE_OUTPUT     0x212f  //Զ�̺ڰ�����
#define MINOR_REMOTE_BALCKWHITECFGFILE_INPUT      0x2130  //Զ�̺ڰ�����


#define MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE		0x2200	/*Զ�̴���/�޸���ͼ��ռ�*/
#define MINOR_REMOTE_DELETE_VIEWLIB_FILE			0x2201	/*Զ��ɾ����ͼ���ļ�*/
#define MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE			0x2202	/*Զ��������ͼ���ļ�*/
#define MINOR_REMOTE_UPLOAD_VIEWLIB_FILE			0x2203	/*Զ���ϴ���ͼ���ļ�*/
#define MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE		0x2204	/*���ش���/�޸���ͼ��ռ�*/

#define MINOR_LOCAL_SET_DEVICE_ACTIVE   0x3000  //���ؼ����豸
#define MINOR_REMOTE_SET_DEVICE_ACTIVE  0x3001  //Զ�̼����豸
#define MINOR_LOCAL_PARA_FACTORY_DEFAULT    0x3002  //���ػظ���������
#define MINOR_REMOTE_PARA_FACTORY_DEFAULT   0x3003  //Զ�ָ̻���������


/*��־������Ϣ*/
//������
#define MAJOR_INFORMATION               0x4     /*������Ϣ*/
//������
#define MINOR_HDD_INFO                  0xa1 /*Ӳ����Ϣ*/
#define MINOR_SMART_INFO                0xa2 /*SMART��Ϣ*/
#define MINOR_REC_START                 0xa3 /*��ʼ¼��*/
#define MINOR_REC_STOP                  0xa4 /*ֹͣ¼��*/
#define MINOR_REC_OVERDUE				0xa5 /*����¼��ɾ��*/
#define MINOR_LINK_START				0xa6 //����ǰ���豸
#define MINOR_LINK_STOP					0xa7 //�Ͽ�ǰ���豸��
#define MINOR_NET_DISK_INFO				0xa8 //����Ӳ����Ϣ
#define MINOR_RAID_INFO                 0xa9 //raid�����Ϣ
#define MINOR_RUN_STATUS_INFO           0xaa /*ϵͳ����״̬��Ϣ*/

//Netra3.0.0
#define MINOR_SPARE_START_BACKUP		0xab   /*�ȱ�ϵͳ��ʼ����ָ��������*/
#define MINOR_SPARE_STOP_BACKUP			0xac   /*�ȱ�ϵͳֹͣ����ָ��������*/
#define MINOR_SPARE_CLIENT_INFO         0xad   /*�ȱ��ͻ�����Ϣ*/
#define MINOR_ANR_RECORD_START			0xae   /*ANR¼��ʼ*/
#define MINOR_ANR_RECORD_END			0xaf   /*ANR¼�����*/
#define MINOR_ANR_ADD_TIME_QUANTUM		0xb0	/*ANR���ʱ���*/
#define MINOR_ANR_DEL_TIME_QUANTUM		0xb1	/*ANRɾ��ʱ���*/

#define MINOR_PIC_REC_START             0xb3  /* ��ʼץͼ*/
#define MINOR_PIC_REC_STOP              0xb4  /* ֹͣץͼ*/
#define MINOR_PIC_REC_OVERDUE           0xb5  /* ����ͼƬ�ļ�ɾ�� */
//Netra3.1.0
#define  MINOR_CLIENT_LOGIN             0xb6   /*��¼�������ɹ�*/
#define  MINOR_CLIENT_RELOGIN			0xb7   /*���µ�¼������*/
#define  MINOR_CLIENT_LOGOUT			0xb8   /*�˳��������ɹ�*/
#define  MINOR_CLIENT_SYNC_START		0xb9   /*¼��ͬ����ʼ*/
#define  MINOR_CLIENT_SYNC_STOP			0xba   /*¼��ͬ����ֹ*/
#define  MINOR_CLIENT_SYNC_SUCC			0xbb   /*¼��ͬ���ɹ�*/
#define  MINOR_CLIENT_SYNC_EXCP			0xbc   /*¼��ͬ���쳣*/
#define  MINOR_GLOBAL_RECORD_ERR_INFO   0xbd   /*ȫ�ִ����¼��Ϣ*/
#define  MINOR_BUFFER_STATE             0xbe   /*������״̬��־��¼*/
#define  MINOR_DISK_ERRORINFO_V2        0xbf   /*Ӳ�̴�����ϸ��ϢV2*/
#define  MINOR_CS_DATA_EXPIRED          0xc0   //�ƴ洢��ݹ���
#define  MINOR_PLAT_INFO                0xc1   //ƽ̨������Ϣ
#define  MINOR_DIAL_STAT                0xc2   /*����״̬*/

#define MINOR_UNLOCK_RECORD             0xc3   //�����¼
#define MINOR_VIS_ALARM                 0xc4   //����
#define MINOR_TALK_RECORD               0xc5   //ͨ����¼
/*�¼�*/
//������
#define MAJOR_EVENT                             0x5     /*�¼�*/
//������
#define MINOR_LEGAL_CARD_PASS                   0x01    //�Ϸ�����֤ͨ��
#define MINOR_CARD_AND_PSW_PASS                 0x02    //ˢ����������֤ͨ��
#define MINOR_CARD_AND_PSW_FAIL                 0x03    //ˢ����������֤ʧ��
#define MINOR_CARD_AND_PSW_TIMEOUT              0x04    //���������֤��ʱ
#define MINOR_CARD_AND_PSW_OVER_TIME            0x05    //ˢ�������볬��
#define MINOR_CARD_NO_RIGHT                     0x06    //δ����Ȩ��
#define MINOR_CARD_INVALID_PERIOD               0x07    //��Чʱ��
#define MINOR_CARD_OUT_OF_DATE                  0x08    //���Ź���
#define MINOR_INVALID_CARD                      0x09    //�޴˿���
#define MINOR_ANTI_SNEAK_FAIL                   0x0a    //��Ǳ����֤ʧ��
#define MINOR_INTERLOCK_DOOR_NOT_CLOSE          0x0b    //������δ�ر�
#define MINOR_NOT_BELONG_MULTI_GROUP            0x0c    //�������ڶ�����֤Ⱥ��
#define MINOR_INVALID_MULTI_VERIFY_PERIOD       0x0d    //�����ڶ�����֤ʱ�����
#define MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL     0x0e    //������֤ģʽ����Ȩ����֤ʧ��
#define MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL    0x0f    //������֤ģʽԶ����֤ʧ��
#define MINOR_MULTI_VERIFY_SUCCESS              0x10    //������֤�ɹ�
#define MINOR_LEADER_CARD_OPEN_BEGIN            0x11    //�׿����ſ�ʼ
#define MINOR_LEADER_CARD_OPEN_END              0x12    //�׿����Ž���
#define MINOR_ALWAYS_OPEN_BEGIN                 0x13    //����״̬��ʼ
#define MINOR_ALWAYS_OPEN_END                   0x14    //����״̬����
#define MINOR_LOCK_OPEN                         0x15    //�����
#define MINOR_LOCK_CLOSE                        0x16    //����ر�
#define MINOR_DOOR_BUTTON_PRESS                 0x17    //���Ű�ť��
#define MINOR_DOOR_BUTTON_RELEASE               0x18    //���Ű�ť�ſ�
#define MINOR_DOOR_OPEN_NORMAL                  0x19    //���ţ��Ŵţ�
#define MINOR_DOOR_CLOSE_NORMAL                 0x1a    //����ţ��Ŵţ�
#define MINOR_DOOR_OPEN_ABNORMAL                0x1b    //���쳣�򿪣��Ŵţ�
#define MINOR_DOOR_OPEN_TIMEOUT                 0x1c    //�Ŵ򿪳�ʱ���Ŵţ�
#define MINOR_ALARMOUT_ON                       0x1d    //���������
#define MINOR_ALARMOUT_OFF                      0x1e    //��������ر�
#define MINOR_ALWAYS_CLOSE_BEGIN                0x1f    //����״̬��ʼ
#define MINOR_ALWAYS_CLOSE_END                  0x20    //����״̬����
#define MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN     0x21    //���ض�����֤��ҪԶ�̿���
#define MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS  0x22  //������֤����������֤�ɹ��¼�
#define MINOR_MULTI_VERIFY_REPEAT_VERIFY        0x23    //������֤�ظ���֤�¼�
#define MINOR_MULTI_VERIFY_TIMEOUT       		0x24    //������֤�ظ���֤�¼�
#define MINOR_DOORBELL_RINGING                  0x25    //������
#define MINOR_FINGERPRINT_COMPARE_PASS          0x26    //ָ�Ʊȶ�ͨ��
#define MINOR_FINGERPRINT_COMPARE_FAIL          0x27    //ָ�Ʊȶ�ʧ��
#define MINOR_CARD_FINGERPRINT_VERIFY_PASS              0x28    //ˢ����ָ����֤ͨ��
#define MINOR_CARD_FINGERPRINT_VERIFY_FAIL              0x29    //ˢ����ָ����֤ʧ��
#define MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT           0x2a    //ˢ����ָ����֤��ʱ
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS       0x2b    //ˢ����ָ�Ƽ�������֤ͨ��
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL       0x2c    //ˢ����ָ�Ƽ�������֤ʧ��
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT    0x2d    //ˢ����ָ�Ƽ�������֤��ʱ
#define MINOR_FINGERPRINT_PASSWD_VERIFY_PASS            0x2e    //ָ�Ƽ�������֤ͨ��
#define MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL            0x2f    //ָ�Ƽ�������֤ʧ��
#define MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT         0x30    //ָ�Ƽ�������֤��ʱ
#define MINOR_FINGERPRINT_INEXISTENCE                   0x31    //ָ�Ʋ�����
#define MINOR_CARD_PLATFORM_VERIFY                   0x32    //ˢ��ƽ̨��֤


typedef enum tagALARMHOST_MAJOR_TYPE
{
    MAJOR_ALARMHOST_ALARM = 1,
        MAJOR_ALARMHOST_EXCEPTION,
        MAJOR_ALARMHOST_OPERATION,
        MAJ0R_ALARMHOST_EVENT
}ALARMHOST_MAJOR_TYPE;

typedef enum tagALARMHOST_MINOR_TYPE
{
    // ����
    MINOR_SHORT_CIRCUIT =0x01,      // ��·����
        MINOR_BROKEN_CIRCUIT,           // ��·����
        MINOR_ALARM_RESET,              // ������λ
        MINOR_ALARM_NORMAL,				// �����ָ���
        MINOR_PASSWORD_ERROR,			// �����������3�������������
        MINOR_ID_CARD_ILLEGALLY,		// �Ƿ���Ӧ��ID
        MINOR_KEYPAD_REMOVE,			// ���̷���
        MINOR_KEYPAD_REMOVE_RESTORE,	// ���̷���λ
        MINOR_DEV_REMOVE,				// �豸����
        MINOR_DEV_REMOVE_RESTORE,		// �豸����λ
        MINOR_BELOW_ALARM_LIMIT1,		// ģ�������ڱ�����1
        MINOR_BELOW_ALARM_LIMIT2,		// ģ�������ڱ�����2
        MINOR_BELOW_ALARM_LIMIT3,		// ģ�������ڱ�����3
        MINOR_BELOW_ALARM_LIMIT4,		// ģ�������ڱ�����4
        MINOR_ABOVE_ALARM_LIMIT1,		// ģ�������ڱ�����1
        MINOR_ABOVE_ALARM_LIMIT2,		// ģ�������ڱ�����2
        MINOR_ABOVE_ALARM_LIMIT3,		// ģ�������ڱ�����3
        MINOR_ABOVE_ALARM_LIMIT4,		// ģ�������ڱ�����4
        MINOR_URGENCYBTN_ON,			// ������ť����
        MINOR_URGENCYBTN_OFF,			// ������ť��λ
        MINOR_VIRTUAL_DEFENCE_BANDIT,			//�����˾�
        MINOR_VIRTUAL_DEFENCE_FIRE,				//������
        MINOR_VIRTUAL_DEFENCE_URGENT,			//��������
        MINOR_ALARMHOST_MOTDET_START,			//�ƶ���ⱨ����ʼ
        MINOR_ALARMHOST_MOTDET_STOP,			//�ƶ���ⱨ������
        MINOR_ALARMHOST_HIDE_ALARM_START,		//�ڵ�������ʼ
        MINOR_ALARMHOST_HIDE_ALARM_STOP,		//�ڵ���������
        MINOR_ALARMHOST_UPS_ALARM,				//UPS����
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM, //�����?��
        MINOR_ALARMHOST_SWITCH_POWER_ALARM,		//���ص�Դ����
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,	  //������ϵͳ����
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM, //��������Ա?��
        MINOR_ALARMHOST_TEMP_HUMI_ALARM,			//��ʪ�ȴ���������
        MINOR_ALARMHOST_UPS_ALARM_RESTORE,	//UPS�����ָ�
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE, //�����?���ָ�
        MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,	  //���ص�Դ�����ָ�
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,	  //������ϵͳ�����ָ�
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE, //��������Ա?���ָ�
        MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,		  //��ʪ�ȴ����������ָ�
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,			//ˮλ����������
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,	//ˮλ�����������ָ�
        MINOR_ALARMHOST_DUST_NOISE_ALARM,					//�ﳾ�����������
        MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,			//�ﳾ������������ָ�
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,			//�����ɼ��Ǳ���
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,	//�����ɼ��Ǳ����ָ�

        MINOR_ALARMHOST_TRIGGER_TAMPER,				//̽��������
        MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,				//̽��������ָ�

        // �쳣
        MINOR_POWER_ON      = 0x01,	// �ϵ�
        MINOR_POWER_OFF,				// ����
        MINOR_WDT_RESET,				// WDT ��λ
        MINOR_LOW_BATTERY_VOLTAGE,		// ���ص�ѹ��
        MINOR_AC_LOSS,					// ������ϵ�
        MINOR_AC_RESTORE,				// ������ָ�
        MINOR_RTC_EXCEPTION,			// RTCʵʱʱ���쳣
        MINOR_NETWORK_CONNECT_FAILURE,	// �������Ӷ�
        MINOR_NETWORK_CONNECT_RESTORE,	// �������ӻָ�
        MINOR_TEL_LINE_CONNECT_FAILURE,	// �绰�����Ӷ�
        MINOR_TEL_LINE_CONNECT_RESTORE,	// �绰�����ӻָ�
        MINOR_EXPANDER_BUS_LOSS,		// ��չ����ģ�����
        MINOR_EXPANDER_BUS_RESTORE,		// ��չ����ģ����߻ָ�
        MINOR_KEYPAD_BUS_LOSS,			// ��������ģ�����
        MINOR_KEYPAD_BUS_RESTORE,		// ��������ģ����߻ָ�
        MINOR_SENSOR_FAILURE,			// ģ��������������
        MINOR_SENSOR_RESTORE,			// ģ�����������ָ�
        MINOR_RS485_CONNECT_FAILURE,	// RS485ͨ�����Ӷ�
        MINOR_RS485_CONNECT_RESTORE,	// RS485ͨ�����Ӷϻָ�
        MINOR_BATTERT_VOLTAGE_RESTORE,  // ���ص�ѹ�ָ���
        MINOR_WIRED_NETWORK_ABNORMAL,	//���������쳣
        MINOR_WIRED_NETWORK_RESTORE,	//��������ָ���
        MINOR_GPRS_ABNORMAL,			//GPRSͨ���쳣
        MINOR_GPRS_RESTORE,				//GPRS�ָ���
        MINOR_3G_ABNORMAL,				//3Gͨ���쳣
        MINOR_3G_RESTORE,				//3G�ָ���
        MINOR_SIM_CARD_ABNORMAL,		//SIM���쳣
        MINOR_SIM_CARD_RESTORE,			//SIM���ָ���
        MINOR_ALARMHOST_VI_LOST,		// ��Ƶ�źŶ�ʧ
        MINOR_ALARMHOST_ILLEGAL_ACCESS,	// �Ƿ�����
        MINOR_ALARMHOST_HD_FULL,		// Ӳ����
        MINOR_ALARMHOST_HD_ERROR,		// Ӳ�̴���
        MINOR_ALARMHOST_DCD_LOST,		// MODEM ����(������ʹ��)
        MINOR_ALARMHOST_IP_CONFLICT,	// IP��ַ��ͻ
        MINOR_ALARMHOST_NET_BROKEN,		// ����Ͽ�
        MINOR_ALARMHOST_REC_ERROR,      // ¼�����
        MINOR_ALARMHOST_VI_EXCEPTION,   // ��Ƶ�����쳣(ֻ���ģ��ͨ��)
        MINOR_ALARMHOST_FORMAT_HDD_ERROR, //Զ�̸�ʽ��Ӳ��ʧ��
        MINOR_ALARMHOST_USB_ERROR,		//USBͨ�Ź���
        MINOR_ALARMHOST_USB_RESTORE,	//USBͨ�Ź��ϻָ�
        MINOR_ALARMHOST_PRINT_ERROR,	//��ӡ�����
        MINOR_ALARMHOST_PRINT_RESTORE,	//��ӡ����ϻָ�
        MINOR_SUBSYSTEM_COMMUNICATION_ERROR, //�Ӱ�ͨѶ����
        MINOR_ALARMHOST_IPC_NO_LINK,				/* IPC���ӶϿ�  */
        MINOR_ALARMHOST_IPC_IP_CONFLICT,			/*ipc ip ��ַ ��ͻ*/
        MINOR_ALARMHOST_VI_MISMATCH,				/*��Ƶ��ʽ��ƥ��*/

        // ����
        MINOR_GUARD         = 0x01,		// ��ͨ����
        MINOR_UNGUARD,					// ��ͨ����
        MINOR_BYPASS,					// ��·
        MINOR_DURESS_ACCESS,			// Ю��
        MINOR_ALARMHOST_LOCAL_REBOOT,	// ��������
        MINOR_ALARMHOST_REMOTE_REBOOT,	// Զ������
        MINOR_ALARMHOST_LOCAL_UPGRADE,	// ������
        MINOR_ALARMHOST_REMOTE_UPGRADE,	// Զ����
        MINOR_RECOVERY_DEFAULT_PARAM,	// �ָ�Ĭ�ϲ���
        MINOR_ALARM_OUTPUT,				// ���Ʊ������
        MINOR_ACCESS_OPEN,				// �����Ž�
        MINOR_ACCESS_CLOSE,				// �����Ž��
        MINOR_SIREN_OPEN,				// ���ƾ��ſ�
        MINOR_SIREN_CLOSE,				// ���ƾ��Ź�
        MINOR_MOD_ZONE_CONFIG,			// �޸ķ�������
        MINOR_MOD_ALARMOUT_CONIFG,		// ���Ʊ����������
        MINOR_MOD_ANALOG_CONFIG,		// �޸�ģ��������
        MINOR_RS485_CONFIG,				// �޸�485ͨ������
        MINOR_PHONE_CONFIG,				// �޸Ĳ�������
        MINOR_ADD_ADMIN,				// ���ӹ���Ա
        MINOR_MOD_ADMIN_PARAM,			// �޸Ĺ���Ա����
        MINOR_DEL_ADMIN,				// ɾ�����Ա
        MINOR_ADD_NETUSER,				// ���Ӻ�˲���Ա
        MINOR_MOD_NETUSER_PARAM,		// �޸ĺ�˲���Ա����
        MINOR_DEL_NETUSER,				// ɾ���˲���Ա
        MINOR_ADD_OPERATORUSER,			// ����ǰ�˲���Ա
        MINOR_MOD_OPERATORUSER_PW,		// �޸�ǰ�˲���Ա����
        MINOR_DEL_OPERATORUSER,			// ɾ��ǰ�˲���Ա
        MINOR_ADD_KEYPADUSER,			// ���Ӽ���/�������û�
        MINOR_DEL_KEYPADUSER,			// ɾ�����/�������û�
        MINOR_REMOTEUSER_LOGIN,			// Զ���û���½
        MINOR_REMOTEUSER_LOGOUT,		// Զ���û�ע��
        MINOR_REMOTE_GUARD,				// Զ�̲���
        MINOR_REMOTE_UNGUARD,			// Զ�̳���
        MINOR_MOD_HOST_CONFIG,          // �޸���������
        MINOR_RESTORE_BYPASS,			// ��·�ָ�
        MINOR_ALARMOUT_OPEN,			// �����������
        MINOR_ALARMOUT_CLOSE,			// ��������ر�
        MINOR_MOD_SUBSYSTEM_PARAM,		// �޸���ϵͳ��������
        MINOR_GROUP_BYPASS,				// ����·
        MINOR_RESTORE_GROUP_BYPASS,		// ����·�ָ�
        MINOR_MOD_GRPS_PARAM,			// �޸�GPRS����
        MINOR_MOD_NET_REPORT_PARAM,		// �޸������ϱ���������
        MINOR_MOD_REPORT_MOD,			// �޸��ϴ���ʽ����
        MINOR_MOD_GATEWAY_PARAM,		// �޸��Ž��������
        MINOR_ALARMHOST_REMOTE_START_REC,		// Զ�̿�ʼ¼��
        MINOR_ALARMHOST_REMOTE_STOP_REC,		// Զ��ֹͣ¼��
        MINOR_ALARMHOST_START_TRANS_CHAN,		// ��ʼ͸������
        MINOR_ALARMHOST_STOP_TRANS_CHAN,		// ֹͣ͸������
        MINOR_ALARMHOST_START_VT,				// ��ʼ�����Խ�
        MINOR_ALARMHOST_STOP_VTM,				// ֹͣ�����Խ�
        MINOR_ALARMHOST_REMOTE_PLAYBYFILE,		// Զ�̰��ļ��ط�
        MINOR_ALARMHOST_REMOTE_PLAYBYTIME,      // Զ�̰�ʱ��ط�
        MINOR_ALARMHOST_REMOTE_PTZCTRL,			// Զ����̨����
        MINOR_ALARMHOST_REMOTE_FORMAT_HDD,      // Զ�̸�ʽ��Ӳ��
        MINOR_ALARMHOST_REMOTE_LOCKFILE,		// Զ�����ļ�
        MINOR_ALARMHOST_REMOTE_UNLOCKFILE,      // Զ�̽����ļ�
        MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // Զ�̵��������ļ�
        MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // Զ�̵��������ļ�
        MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // Զ�̵���¼���ļ�

        MINOR_ALARMHOST_STAY_ARM,						//���ز���
        MINOR_ALARMHOST_QUICK_ARM,						//��ʱ����
        MINOR_ALARMHOST_AUTOMATIC_ARM,					//�Զ�����
        MINOR_ALARMHOST_AUTOMATIC_DISARM,				//�Զ�����
        MINOR_ALARMHOST_KEYSWITCH_ARM,					//Կ�׷����
        MINOR_ALARMHOST_KEYSWITCH_DISARM,				//Կ�׷����
        MINOR_ALARMHOST_CLEAR_ALARM,					//��
        MINOR_ALARMHOST_MOD_FAULT_CFG,					//�޸�ϵͳ��������
        MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,	//�޸��¼����������������
        MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,			//�������ģ��
        MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,		//����ע�����ģ��
        MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,			//�رռ��̱�����ʾ��
        MINOR_ALARMHOST_MOD_3G_PARAM,					//�޸�3G����
        MINOR_ALARMHOST_MOD_PRINT_PARAM, //�޸Ĵ�ӡ�����
        MINOR_SD_CARD_FORMAT,		//SD����ʽ��
        MINOR_SUBSYSTEM_UPGRADE,		//�Ӱ�̼���

        MINOR_ALARMHOST_PLAN_ARM_CFG,	//�ƻ���������������
        MINOR_ALARMHOST_PHONE_ARM,		//�ֻ��
        MINOR_ALARMHOST_PHONE_STAY_ARM,	//�ֻ����ز���
        MINOR_ALARMHOST_PHONE_QUICK_ARM,//�ֻ�ʱ����
        MINOR_ALARMHOST_PHONE_DISARM,	//�ֻ��
        MINOR_ALARMHOST_PHONE_CLEAR_ALARM,	//�ֻ���
        MINOR_ALARMHOST_WHITELIST_CFG,	//��������
        MINOR_ALARMHOST_TIME_TRIGGER_CFG,			//��ʱ���ش���������
        MINOR_ALARMHOST_CAPTRUE_CFG,				//ץͼ��������
        MINOR_ALARMHOST_TAMPER_CFG,				//��������������

		MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = 0xf0,		//���ؼ����豸
		MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = 0xf1,		//Զ�̼����豸
		MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = 0xf2,	//���ػظ���������
		MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = 0xf3,	//Զ�ָ̻���������

        // �¼�
        MINOR_SCHOOLTIME_IRGI_B = 0x01,		// B��Уʱ
        MINOR_SCHOOLTIME_SDK,				// SDKУʱ
        MINOR_SCHOOLTIME_SELFTEST,			// ��ʱ�Լ�Уʱ
        MINOR_SUBSYSTEM_ABNORMALINSERT,		//�Ӱ����
        MINOR_SUBSYSTEM_ABNORMALPULLOUT,		//�Ӱ�γ�

        MINOR_AUTO_ARM,					//�Զ�����
        MINOR_AUTO_DISARM,				//�Զ�����
        MINOR_TIME_TIGGER_ON,			//��ʱ����������
        MINOR_TIME_TIGGER_OFF,			//��ʱ�رմ�����
        MINOR_AUTO_ARM_FAILD,			//�Զ�����ʧ��
        MINOR_AUTO_DISARM_FAILD,		//�Զ�����ʧ��
        MINOR_TIME_TIGGER_ON_FAILD,		//��ʱ����������ʧ��
        MINOR_TIME_TIGGER_OFF_FAILD,	//��ʱ�رմ�����ʧ��
        MINOR_MANDATORY_ALARM,			//ǿ�Ʋ���
}ALARMHOST_MINOR_TYPE;


//����־��������ΪMAJOR_OPERATION=03��������ΪMINOR_LOCAL_CFG_PARM=0x52����MINOR_REMOTE_GET_PARM=0x76
//����MINOR_REMOTE_CFG_PARM=0x77ʱ��dwParaType:����������Ч���京�����£�
#define PARA_VIDEOOUT	0x1
#define PARA_IMAGE		0x2
#define PARA_ENCODE		0x4
#define PARA_NETWORK	0x8
#define PARA_ALARM		0x10
#define PARA_EXCEPTION	0x20
#define PARA_DECODER	0x40    /*������*/
#define PARA_RS232		0x80
#define PARA_PREVIEW	0x100
#define PARA_SECURITY	0x200
#define PARA_DATETIME	0x400
#define PARA_FRAMETYPE	0x800    /*֡��ʽ*/
#define PARA_DETECTION  0x1000   //�������
#define PARA_VCA_RULE   0x1001  //��Ϊ����
#define PARA_VCA_CTRL   0x1002  //�������ܿ�����Ϣ
#define PARA_VCA_PLATE  0x1003 // ����ʶ��

#define PARA_CODESPLITTER 0x2000 /*���������*/
//2010-01-22 ������Ƶ�ۺ�ƽ̨��־��Ϣ������
#define PARA_RS485		  0x2001			/* RS485������Ϣ*/
#define PARA_DEVICE		  0x2002			/* �豸������Ϣ*/
#define PARA_HARDDISK	  0x2003			/* Ӳ��������Ϣ */
#define PARA_AUTOBOOT	  0x2004			/* �Զ�����������Ϣ*/
#define PARA_HOLIDAY	  0x2005			/* �ڼ���������Ϣ*/
#define PARA_IPC		  0x2006			/* IPͨ������ */
/*************************������������ end*******************************/


/*******************�����ļ�����־�����ֵ*************************/
#define NET_DVR_FILE_SUCCESS		    1000	//����ļ���Ϣ
#define NET_DVR_FILE_NOFIND			    1001	//û���ļ�
#define NET_DVR_ISFINDING			    1002	//���ڲ����ļ�
#define	NET_DVR_NOMOREFILE			    1003	//�����ļ�ʱû�и����ļ�
#define	NET_DVR_FILE_EXCEPTION		    1004	//�����ļ�ʱ�쳣

/*********************�ص��������� begin************************/

//�����ص�����
#define COMM_ALARM                           0x1100	//8000������Ϣ�����ϴ�

//��ӦNET_VCA_RULE_ALARM
#define COMM_ALARM_RULE                      0x1102	 //��Ϊ����������Ϣ
#define COMM_ALARM_PDC                       0x1103  //����ͳ�Ʊ�����Ϣ
#define COMM_ALARM_VIDEOPLATFORM             0x1104  //��Ƶ�ۺ�ƽ̨����
#define COMM_ALARM_ALARMHOST                 0x1105  //���籨������
#define COMM_ALARM_FACE                      0x1106  //�������ʶ�𱨾���Ϣ
#define COMM_RULE_INFO_UPLOAD                0x1107  // �¼������Ϣ�ϴ�
#define COMM_ALARM_AID                       0x1110  //��ͨ�¼�������Ϣ
#define COMM_ALARM_TPS                       0x1111  //��ͨ����ͳ�Ʊ�����Ϣ
//��������ץ�Ľ���ϴ�
#define COMM_UPLOAD_FACESNAP_RESULT          0x1112  //����ʶ�����ϴ�
#define COMM_ALARM_TFS                       0x1113  //��ͨȡ֤������Ϣ
#define COMM_ALARM_TPS_V41                   0x1114  //��ͨ����ͳ�Ʊ�����Ϣ��չ
#define COMM_ALARM_AID_V41                   0x1115  //��ͨ�¼�������Ϣ��չ
#define COMM_ALARM_VQD_EX                    0x1116	 //��Ƶ������ϱ���
#define COMM_SENSOR_VALUE_UPLOAD             0x1120  //ģ�������ʵʱ�ϴ�
#define COMM_SENSOR_ALARM                    0x1121  //ģ���������ϴ�
#define COMM_SWITCH_ALARM                    0x1122	 //����������
#define COMM_ALARMHOST_EXCEPTION             0x1123  //����������ϱ���
#define COMM_ALARMHOST_OPERATEEVENT_ALARM    0x1124  //�����¼������ϴ�
#define COMM_ALARMHOST_SAFETYCABINSTATE      0x1125	 //������״̬
#define COMM_ALARMHOST_ALARMOUTSTATUS        0x1126	 //���������/����״̬
#define COMM_ALARMHOST_CID_ALARM 		 	 0x1127	 //���汨���ϴ�
#define	COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM 0x1128	 //������������豸�����ϴ�
#define COMM_ALARMHOST_DATA_UPLOAD           0x1129	 //��������ϴ�
#define COMM_FACECAPTURE_STATISTICS_RESULT   0x112a  //����ץ��ͳ���ϴ�
#define COMM_SCENECHANGE_DETECTION_UPLOAD	 0x1130	 //��������ϴ�(����)2013-7-16
#define COMM_CROSSLINE_ALARM                 0x1131    //ѹ�߱���(����) 2013-09-27
#define COMM_UPLOAD_VIDEO_INTERCOM_EVENT     0x1132  //���ӶԽ��¼���¼�ϴ�
#define COMM_ALARM_VIDEO_INTERCOM  	         0x1133  //���ӶԽ������ϴ�
#define COMM_ALARM_AUDIOEXCEPTION			 0x1150	 //����������Ϣ
#define COMM_ALARM_DEFOCUS                   0x1151	 //�齹������Ϣ
#define COMM_ALARM_BUTTON_DOWN_EXCEPTION	 0x1152	 //��ť���±�����Ϣ
#define COMM_ALARM_ALARMGPS                  0x1202  //GPS������Ϣ�ϴ�
#define	COMM_TRADEINFO                       0x1500  //ATMDVR�����ϴ�������Ϣ
#define COMM_UPLOAD_PLATE_RESULT             0x2800	 //�ϴ�������Ϣ
#define COMM_ITC_STATUS_DETECT_RESULT        0x2810  //ʵʱ״̬������ϴ�(���ܸ���IPC)
#define COMM_IPC_AUXALARM_RESULT             0x2820  //PIR���������߱��������ȱ����ϴ�
#define COMM_UPLOAD_PICTUREINFO              0x2900	 //�ϴ�ͼƬ��Ϣ
#define COMM_SNAP_MATCH_ALARM                0x2902  //����ȶԽ���ϴ�
#define COMM_ITS_PLATE_RESULT                0x3050  //�ն�ͼƬ�ϴ�
#define	COMM_ITS_TRAFFIC_COLLECT             0x3051  //�ն�ͳ������ϴ�
#define COMM_ITS_GATE_VEHICLE                0x3052  //����ڳ���ץ������ϴ�
#define COMM_ITS_GATE_FACE                   0x3053  //���������ץ������ϴ�
#define COMM_ITS_GATE_COSTITEM				 0x3054  //����ڹ��շ���ϸ 2013-11-19
#define COMM_ITS_GATE_HANDOVER				 0x3055  //����ڽ��Ӱ���� 2013-11-19
#define COMM_ITS_PARK_VEHICLE                0x3056  //ͣ��������ϴ�
#define COMM_ITS_BLACKLIST_ALARM             0x3057  //�������ϴ�

#define COMM_VEHICLE_CONTROL_LIST_DSALARM    0x3058  //�ڰ��������Ҫͬ������2013-11-04
#define COMM_VEHICLE_CONTROL_ALARM           0x3059  //��������2013-11-04
#define COMM_FIRE_ALARM                      0x3060  //�������2013-11-04

#define COMM_ITS_GATE_ALARMINFO              0x3061  //����ڿ��ƻ�����ϴ�

#define COMM_VEHICLE_RECOG_RESULT            0x3062  //��������ʶ�����ϴ� 2014-11-12
#define COMM_PLATE_RESULT_V50                0x3063  //�����ϴ� V50

#define COMM_GATE_CHARGEINFO_UPLOAD          0x3064  //����ڸ�����Ϣ�ϴ�
#define COMM_TME_VEHICLE_INDENTIFICATION     0x3065  //TME����ץͼ�ϴ�
#define COMM_GATE_CARDINFO_UPLOAD            0x3066  //����ڿ�Ƭ��Ϣ�ϴ�

#define COMM_ALARM_SENSORINFO_UPLOAD	     0x3077	 //�������ϴ���Ϣ
#define COMM_ALARM_CAPTURE_UPLOAD	         0x3078	 //ץ��ͼƬ�ϴ�

#define COMM_ITS_RADARINFO                   0x3079  //�״ﱨ���ϴ�

#define COMM_SIGNAL_LAMP_ABNORMAL            0x3080  //�źŵ��쳣����ϴ�

#define COMM_ALARM_TPS_REAL_TIME             0x3081  //TPSʵʱ������ϴ�
#define COMM_ALARM_TPS_STATISTICS            0x3082  //TPSͳ�ƹ�����ϴ�

#define COMM_ALARM_V30				         0x4000	 //9000������Ϣ�����ϴ�
#define COMM_IPCCFG			                 0x4001	 //9000�豸IPC�������øı䱨����Ϣ�����ϴ�
#define COMM_IPCCFG_V31			             0x4002	 //9000�豸IPC�������øı䱨����Ϣ�����ϴ���չ 9000_1.1
#define COMM_IPCCFG_V40                      0x4003  // IVMS 2000 ��������� NVR IPC�������øı�ʱ������Ϣ�ϴ�
#define COMM_ALARM_DEVICE                    0x4004  //�豸�������ݣ�����ͨ��ֵ����256����չ
#define COMM_ALARM_CVR						 0x4005  //CVR 2.0.X�ⲿ��������
#define COMM_ALARM_HOT_SPARE				 0x4006  //�ȱ��쳣������N+1ģʽ�쳣������
#define COMM_ALARM_V40				         0x4007	//�ƶ���⣬��Ƶ��ʧ���ڵ���IO�ź����ȱ�����Ϣ�����ϴ����������Ϊ�ɱ䳤

#define COMM_UPLOAD_HEATMAP_RESULT           0x4008 //�ȶ�ͼ�����ϴ� 2014-03-21
#define COMM_ALARM_DEVICE_V40                0x4009  //�豸����������չ
#define COMM_ALARM_FACE_DETECTION            0x4010 //������ⱨ��
#define COMM_ALARM_TARGET_LEFT_REGION        0x4011 //���Ŀ���뿪������򱨾�(��ʦ����ѧ��(���������л�¼��������Ƽ��ѧ������))
#define COMM_GISINFO_UPLOAD                  0x4012 //GIS��Ϣ�ϴ�
#define COMM_VANDALPROOF_ALARM               0x4013 //�ϴ����ƻ�������Ϣ
#define COMM_PEOPLE_DETECTION_UPLOAD         0x4014 //��Ա�����Ϣ�ϴ�
#define COMM_ALARM_STORAGE_DETECTION         0x4015 //�洢���ܼ�ⱨ���ϴ�
#define	COMM_ITS_ROAD_EXCEPTION		         0x4500	 //·���豸�쳣����
#define	COMM_ITS_EXTERNAL_CONTROL_ALARM		 0x4520  //��ر���

#define COMM_FIREDETECTION_ALARM             0x4991 //����ⱨ��

#define	COMM_SCREEN_ALARM                    0x5000  //������������������
#define COMM_DVCS_STATE_ALARM			     0x5001  //�ֲ�ʽ���������������ϴ�
#define COMM_ALARM_ACS			             0x5002  //�Ž�����
#define COMM_ALARM_FIBER_CONVERT			 0x5003  //�����շ�������
#define COMM_ALARM_DEC_VCA                   0x5010   //���ܽ��뱨��
#define COMM_ALARM_LCD						 0x5011	  //��Ļ����
#define COMM_CONFERENCE_CALL_ALARM		     0x5012	 //������и澯

#define COMM_ID_INFO_ALARM                   0x5200  //���֤��Ϣ�ϴ�
#define COMM_PASSNUM_INFO_ALARM              0x5201  //ͨ�������ϱ�

#define COMM_ALARM_VQD						 0x6000  //VQD���������ϴ�
#define COMM_PUSH_UPDATE_RECORD_INFO 		 0x6001  //��ģʽ¼����Ϣ�ϴ�
#define COMM_SWITCH_LAMP_ALARM               0x6002  //���صƼ��
#define COMM_DIAGNOSIS_UPLOAD                0x5100  //��Ϸ�����VQD�����ϴ�

/*************�����쳣����(��Ϣ��ʽ, �ص���ʽ(����))****************/
#define EXCEPTION_EXCHANGE			    0x8000	//�û�����ʱ�쳣
#define EXCEPTION_AUDIOEXCHANGE		    0x8001	//�����Խ��쳣
#define EXCEPTION_ALARM				    0x8002	//�����쳣
#define EXCEPTION_PREVIEW			    0x8003	//����Ԥ���쳣
#define EXCEPTION_SERIAL			    0x8004	//͸��ͨ���쳣
#define EXCEPTION_RECONNECT			    0x8005	//Ԥ��ʱ����
#define EXCEPTION_ALARMRECONNECT	    0x8006	//����ʱ����
#define EXCEPTION_SERIALRECONNECT	    0x8007	//͸��ͨ������
#define SERIAL_RECONNECTSUCCESS         0x8008	//͸��ͨ�������ɹ�
#define EXCEPTION_PLAYBACK	            0x8010	//�ط��쳣
#define EXCEPTION_DISKFMT	            0x8011	//Ӳ�̸�ʽ��
#define EXCEPTION_PASSIVEDECODE         0x8012  //���������쳣
#define EXCEPTION_EMAILTEST             0x8013  //�ʼ������쳣
#define EXCEPTION_BACKUP                0x8014  //�����쳣
#define PREVIEW_RECONNECTSUCCESS        0x8015  //Ԥ��ʱ�����ɹ�
#define ALARM_RECONNECTSUCCESS          0x8016  //����ʱ�����ɹ�
#define RESUME_EXCHANGE				    0x8017	//�û������ָ�
#define NETWORK_FLOWTEST_EXCEPTION      0x8018  //������������쳣
#define EXCEPTION_PICPREVIEWRECONNECT	0x8019	//ͼƬԤ������
#define PICPREVIEW_RECONNECTSUCCESS		0x8020	//ͼƬԤ�������ɹ�
#define EXCEPTION_PICPREVIEW			0x8021	//ͼƬԤ���쳣
#define	EXCEPTION_MAX_ALARM_INFO		0x8022	//������Ϣ�����Ѵ�����
#define	EXCEPTION_LOST_ALARM			0x8023  //������ʧ
#define EXCEPTION_PASSIVETRANSRECONNECT 0x8024  //����ת������
#define PASSIVETRANS_RECONNECTSUCCESS   0x8025  //����ת�������ɹ�
#define EXCEPTION_PASSIVETRANS          0x8026  //����ת���쳣
#define SUCCESS_PUSHDEVLOGON            0x8030  //��ģʽ�豸ע��ɹ�
#define EXCEPTION_RELOGIN			    0x8040	//�û��ص�½
#define RELOGIN_SUCCESS		            0x8041	//�û��ص�½�ɹ�
#define EXCEPTION_PASSIVEDECODE_RECONNNECT  0x8042  //������������

#define EXCEPTION_RELOGIN_FAILED                0x8044   //�ص�½ʧ�ܣ�ֹͣ�ص�½
#define EXCEPTION_PREVIEW_RECONNECT_CLOSED      0x8045   //�ر�Ԥ����������
#define EXCEPTION_ALARM_RECONNECT_CLOSED        0x8046   //�رձ�����������
#define EXCEPTION_SERIAL_RECONNECT_CLOSED       0x8047   //�ر�͸��ͨ����������
#define EXCEPTION_PIC_RECONNECT_CLOSED          0x8048   //�رջ�����������
#define EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED 0x8049 //�رձ���������������
#define EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED 0x804a  //�رձ���ת����������

/********************Ԥ���ص�����*********************/
#define NET_DVR_SYSHEAD			1	//ϵͳͷ���
#define NET_DVR_STREAMDATA		2	//��Ƶ����ݣ�����������������Ƶ�ֿ�����Ƶ����ݣ�
#define NET_DVR_AUDIOSTREAMDATA	3	//��Ƶ�����
#define NET_DVR_STD_VIDEODATA	4	//��׼��Ƶ�����
#define NET_DVR_STD_AUDIODATA	5	//��׼��Ƶ�����
#define NET_DVR_SDP             6   //SDP��Ϣ(Rstp����ʱ��Ч)
#define NET_DVR_CHANGE_FORWARD  10  //�����ı�Ϊ���
#define NET_DVR_CHANGE_REVERSE  11  //�����ı�Ϊ����
#define NET_DVR_PRIVATE_DATA    112 //˽�����,����������Ϣ

//�豸�ͺ�(DVR����)
/* �豸���� */
#define DVR							1				/*����δ�����dvr���ͷ���DVR*/
#define ATMDVR						2				/*atm dvr*/
#define DVS							3				/*DVS*/
#define DEC							4				/* 6001D */
#define ENC_DEC						5				/* 6001F */
#define DVR_HC						6				/*8000HC*/
#define DVR_HT						7				/*8000HT*/
#define DVR_HF						8				/*8000HF*/
#define DVR_HS						9				/* 8000HS DVR(no audio) */
#define DVR_HTS						10              /* 8016HTS DVR(no audio) */
#define DVR_HB						11              /* HB DVR(SATA HD) */
#define DVR_HCS						12              /* 8000HCS DVR */
#define DVS_A						13              /* ��ATAӲ�̵�DVS */
#define DVR_HC_S					14              /* 8000HC-S */
#define DVR_HT_S					15              /* 8000HT-S */
#define DVR_HF_S					16              /* 8000HF-S */
#define DVR_HS_S					17              /* 8000HS-S */
#define ATMDVR_S					18              /* ATM-S */
#define DVR_7000H					19				/*7000Hϵ��*/
#define DEC_MAT						20              /*��·������*/
#define DVR_MOBILE					21				/* mobile DVR */
#define DVR_HD_S					22              /* 8000HD-S */
#define DVR_HD_SL					23				/* 8000HD-SL */
#define DVR_HC_SL					24				/* 8000HC-SL */
#define DVR_HS_ST					25				/* 8000HS_ST */
#define DVS_HW						26              /* 6000HW */
#define DS630X_D					27              /* ��·������ */
#define DS640X_HD					28				/*640X���������*/
#define DS610X_D                    29              /*610X������*/
#define IPCAM						30				/*IP �����*/
#define MEGA_IPCAM					31				/*����IP�����*/
#define IPCAM_X62MF					32				/*862MF���Խ���9000�豸*/
#define ITCCAM                      35              /*���ܸ������������*/
#define IVS_IPCAM                   36              /*���ܷ����������������*/
#define ZOOMCAM                     38              /*һ���*/
#define IPDOME                      40              /*IP �������*/
#define IPDOME_MEGA200              41              /*IP 200��������*/
#define IPDOME_MEGA130              42              /*IP 130��������*/
#define IPDOME_AI                   43              /*IP �������ܿ���*/
#define TII_IPCAM                   44              /*�����ȳ��������*/
#define IPTC_DOME       	        45              /*�����ȳ���˫Ŀ���*/
#define ITS_WMS      	            48              /*������ݹ��������*/
#define IPMOD						50				/*IP ģ��*/
#define TRAFFIC_YTDOME              51              //��ͨ������̨�������״���٣�
#define TRAFFIC_RDDOME              52              //��ͨ������̨�����״���٣�
#define IDS6501_HF_P                60              // 6501 ����
#define IDS6101_HF_A                61              //����ATM
#define IDS6002_HF_B                62          //˫����٣�DS6002-HF/B
#define IDS6101_HF_B	            63              //��Ϊ������DS6101-HF/B DS6101-HF/B_SATA
#define IDS52XX		                64          //���ܷ�����IVMS
#define IDS90XX						65				// 9000����
#define IDS8104_AHL_S_HX            66          // ��������ʶ�� ATM
#define IDS8104_AHL_S_H             67              // ˽������ʶ�� ATM
#define IDS91XX						68				// 9100����
#define IIP_CAM_B                   69              // ������ΪIP�����
#define IIP_CAM_F                   70              //��������IP�����
#define DS71XX_H					71				/* DS71XXH_S */
#define DS72XX_H_S					72				/* DS72XXH_S */
#define DS73XX_H_S					73				/* DS73XXH_S */
#define DS72XX_HF_S                 74              //DS72XX_HF_S
#define DS73XX_HFI_S                75              //DS73XX_HFI_S
#define DS76XX_H_S					76				/* DVR,e.g. DS7604_HI_S */
#define DS76XX_N_S					77				/* NVR,e.g. DS7604_NI_S */
#define DS_TP3200_EC       	        78              /*������ܼ����*/
#define DS81XX_HS_S					81				/* DS81XX_HS_S */
#define DS81XX_HL_S					82				/* DS81XX_HL_S */
#define DS81XX_HC_S					83				/* DS81XX_HC_S */
#define DS81XX_HD_S					84				/* DS81XX_HD_S */
#define DS81XX_HE_S					85				/* DS81XX_HE_S */
#define DS81XX_HF_S					86				/* DS81XX_HF_S */
#define DS81XX_AH_S					87				/* DS81XX_AH_S */
#define DS81XX_AHF_S				88				/* DS81XX_AHF_S */
#define DS90XX_HF_S		            90              /*DS90XX_HF_S*/
#define DS91XX_HF_S					91              /*DS91XX_HF_S*/
#define DS91XX_HD_S					92              /*91XXHD-S(MD)*/
#define IDS90XX_A					93				// 9000���� ATM
#define IDS91XX_A					94				// 9100���� ATM
#define DS95XX_N_S					95              /*DS95XX_N_S NVR �����κ����*/
#define DS96XX_N_SH					96              /*DS96XX_N_SH NVR*/
#define DS90XX_HF_SH                97              /*DS90XX_HF_SH */
#define DS91XX_HF_SH                98              /*DS91XX_HF_SH */
#define DS_B10_XY                   100             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�(X:�����Ƭ��Y:�����Ƭ��)*/
#define DS_6504HF_B10               101             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_6504D_B10                102             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_1832_B10                 103             /*��Ƶ�ۺ�ƽ̨�ڲ������*/
#define DS_6401HFH_B10              104             /*��Ƶ�ۺ�ƽ̨�ڲ����˰�*/
#define DS_65XXHC					105				//65XXHC DVS
#define DS_65XXHC_S					106				//65XXHC-SATA DVS
#define DS_65XXHF					107				//65XXHF DVS
#define DS_65XXHF_S					108				//65XXHF-SATA DVS
#define DS_6500HF_B                 109             //65 rack DVS
#define IVMS_6200_C                 110             // iVMS-6200(/C)
#define IVMS_6200_B                 111             // iVMS-6200(/B)
#define DS_72XXHV_ST15				112				//72XXHV_ST  ��˼3515ƽ̨ DVR
#define DS_72XXHV_ST20				113				//72XXHV_ST  ��˼3520ƽ̨ DVR
#define IVMS_6200_T			        114             // IVMS-6200(/T)
#define IVMS_6200_BP                115             // IVMS-6200(/BP)
#define DS_81XXHC_ST				116				//DS_81XXHC_ST
#define DS_81XXHS_ST				117				//DS_81XXHS_ST
#define DS_81XXAH_ST				118				//DS_81XXAH_ST
#define DS_81XXAHF_ST				119				//DS_81XXAHF_ST
#define DS_66XXDVS				    120				//66XX DVS

#define DS_1964_B10                 121             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_B10N04_IN				122             /*��Ƶ�ۺ�ƽ̨�ڲ���������*/
#define DS_B10N04_OUT				123             /*��Ƶ�ۺ�ƽ̨�ڲ��������*/
#define DS_B10N04_INTEL             124             /*��Ƶ�ۺ�ƽ̨�ڲ�����*/
#define DS_6408HFH_B10E_RM          125             //V6����
#define DS_B10N64F1_RTM             126             //V6��������DSP
#define DS_B10N64F1D_RTM            127             //V6������DSP
#define DS_B10_SDS                  128             //��Ƶ�ۺ�ƽ̨���������
#define DS_B10_DS                   129             //��Ƶ�ۺ�ƽ̨�������
#define DS_6401HFH_B10V    			130     	    //VGA���������
#define DS_6504D_B10B               131             /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define DS_6504D_B10H               132             /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define DS_6504D_B10V               133             /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
#define DS_6408HFH_B10S			    134             //��Ƶ�ۺ�ƽ̨SDI�Ӱ�
#define DS_18XX_N      				135             /* ����������*/
#define DS_6504HF_B10F_CLASS        136				//��˻�SD
#define DS_18XX_PTZ					141				/*����������Ʒ*/
#define DS_19AXX					142				/*ͨ�ñ����������Ʒ*/
#define DS_19BXX					143				/*���ñ�������*/
#define DS_19CXX					144				/*�������б�������*/
#define DS_19DXX					145				/*������ر�������*/
#define DS_19XX                     146             /*1900ϵ�б�������*/
#define DS_19SXX					147				/*��Ƶ��������*/
#define DS_1HXX						148				/*CS���Ʒ*/ //������

//2011-11-30
#define	DS_C10H						161				/*����������*/
#define DS_C10N_BI					162				//BNC������
#define DS_C10N_DI					163				//rbg������
#define DS_C10N_SI					164				//����������
#define DS_C10N_DO					165				//��ʾ������
#define DS_C10N_SERVER				166				//�ֲ�ʽ������


#define IDS_8104_AHFL_S_H           171             // 8104ATM
#define IDS_65XX_HF_A               172             // 65 ATM
#define IDS90XX_HF_RH               173             // 9000 ����RH
#define IDS91XX_HF_RH               174             // 9100 ����RH�豸
#define IDS_65XX_HF_B               175             // 65 ��Ϊ����
#define IDS_65XX_HF_P               176             // 65 ����ʶ��
#define IVMS_6200_F 		        177             // IVMS-6200(/F)
#define IVMS_6200_A                 178             //iVMS-6200(/A)
#define IVMS_6200_F_S 		        179             // IVMS-6200(/F_S)���������������

#define DS90XX_HF_RH                181             // 9000 RH    648
#define DS91XX_HF_RH                182             // 9100 RH�豸 648
#define DS78XX_S					183             // 78ϵ���豸 6446
#define DS81XXHW_S					185				// 81 Resolution 960 KY2011
#define DS81XXHW_ST					186             // DS81XXHW_ST  KY2011
#define DS91XXHW_ST					187             // DS91XXHW_ST  KY2011
#define DS91XX_ST					188             // DS91XX_ST netra
#define DS81XX_ST					189             // DS81XX_ST netra
#define DS81XXHX_ST					190             // DS81XXHDI_ST,DS81XXHE_ST ky2012
#define DS73XXHX_ST					191             // DS73XXHI_ST ky2012
#define DS81XX_SH                   192             // ��Ѷ81SH,81SHF
#define DS81XX_SN                   193             // ��Ѷ81SNL

#define DS96XXN_ST                  194             //NVR:DS96xxN_ST
#define DS86XXN_ST                  195             //NVR:DS86xxN_ST
#define DS80XXHF_ST                 196             //DVR:DS80xxHF_ST
#define DS90XXHF_ST                 197             //DVR:DS90xxHF_ST
#define DS76XXN_ST                  198             //NVR:DS76xxN_ST

#define DS_9664N_RX                 199         //NVR:DS_9664N_RX
#define ENCODER_SERVER				200			// ���뿨������
#define DECODER_SERVER              201         // ���뿨������
#define PCNVR_SERVER                202         // PCNVR�洢������
#define CVR_SERVER                  203         // ��ŵCVR������Լ���������ΪDVR_S-1
#define DS_91XXHFH_ST				204         // 91ϵ��HD-SDI����DVR
#define DS_66XXHFH					205         // 66���������
#define	TRAFFIC_TS_SERVER			210	       //�ն˷�����
#define	TRAFFIC_VAR					211	       //��Ƶ������¼��
#define IPCALL                      212        //IP���ӶԽ��ֻ�
#define SAN_SERVER                  213         //��CVR_SERVER��ͬ�ĳ���ֻ��ģʽ��ͬ

#define DS_B11_M_CLASS 			    301             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�*/
#define DS_B12_M_CLASS 		 		302             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�*/
#define DS_6504HF_B11_CLASS 		303             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_6504HF_B12_CLASS 		304              /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define  DS_6401HFH_B11V_CLASS 	    305     //VGA����
#define  DS_6401HFH_B12V_CLASS 	    306     //VGA����
#define  DS_6408HFH_B11S_CLASS 	    307     //SDI
#define  DS_6408HFH_B12S_CLASS  	308     //SDI
#define  DS_6504D_B11H_CLASS        309   /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B11B_CLASS        310    /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B12B_CLASS        311       /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B11V_CLASS        312      /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
#define  DS_6504D_B12V_CLASS        313     /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
//B10����
#define  DS_6401HFH_B10R_CLASS 	    314     //B10 RGB����
#define  DS_6401HFH_B10D_CLASS 	    315     //B10 DVI����
#define  DS_6401HFH_B10H_CLASS 	    316     //B10 HDMI����
//B11����
#define  DS_6401HFH_B11R_CLASS 	    317     //B11 RGB����
#define  DS_6401HFH_B11D_CLASS 	    318     //B11 DVI����
#define  DS_6401HFH_B11H_CLASS 	    319     //B11 HDMI����
//B12����
#define  DS_6401HFH_B12R_CLASS 	    320     //B12 RGB����
#define  DS_6401HFH_B12D_CLASS 	    321     //B12 DVI����
#define  DS_6401HFH_B12H_CLASS 	    322     //B12 HDMI����
#define  DS_65XXD_B10Ex_CLASS		323     //netra�������

//B10 V2.1����
#define  DS_6516HW_B10_CLASS		324     //netra���߱���
#define  DS_6401HFH_B10F_RX_CLASS   326		//�����˻���루֧��1/2·��˻���룩
#define  DS_6502HW_B10F_RX_CLASS	327		//960H��˻���루֧��1/4/8·��˻���룩
//2012-5-16����
#define  DS_6504D_B11Ex_CLASS		328     //netra�������
#define  DS_6504D_B12Ex_CLASS		329     //netra�������
#define  DS_6512_B11_CLASS			330     //netra���߱���
#define  DS_6512_B12_CLASS			331     //netra���߱���
#define  DS_6504D_B10H_CLASS        332     //��Ƶ�ۺ�ƽ̨�ڲ����������

#define  DS_65XXT_B10_CLASS         333     //��Ƶ�ۺ�ƽ̨ת����ϵͳ
#define  DS_65XXD_B10_CLASS         335     //��Ƶ�ۺ�ƽ̨���ܽ����
#define  DS_IVMSE_B10X_CLASS        336     //X86��������ϵͳ
#define  DS_6532D_B10ES_CLASS		337     //��ǿ�ͽ����_SDI(B10)
#define  DS_6508HFH_B10ES_CLASS		338     //SDI���������ϵͳ
#define  DS_82NCG_CLASS			    340     //��������е���ϵͳ
#define  DS_82VAG_CLASS			    341     //��������е���ϵͳ
#define  DS_1802XXF_B10_CLASS       342     //��ڽ�����ϵͳ
#define  iDS_6504_B10EVAC_CLASS     343     //������ϵͳ
#define  iDS_6504_B10EDEC_CLASS     344     //������ϵͳ
#define  DS_6402HFH_B10EV_CLASS     345     //netra����(VGA)
#define  DS_6402HFH_B10ED_CLASS     346     //netra����(DVI)
#define  DS_6402HFH_B10EH_CLASS     347     //netra����(HDMI)
#define  DS_6404HFH_B10T_RX_CLASS   348     //���˽������
#define  DS_6504D_AIO_CLASS     	349	    //netra�������
#define  DS_IVMST_B10_CLASS			350	    //X86ת����ϵͳ
#define  DS_6402_AIO_CLASS          351     //netra����
#define  DS_iVMSE_AIO_CLASS         352     //x86��������ϵͳ
#define  DS_AIO_M_CLASS             353     //һ���


#define  DS_6508HF_B10E_CLASS		355		//BNC���������ϵͳ
#define  DS_6404HFH_B10ES_CLASS		356		//SDI���������ϵͳ
#define  DS_6402HFH_B10ER_CLASS		358		//RGB���������ϵͳ
#define  DS_6404HFH_B10T_RM_CLASS	361		//�������������ϵͳ
#define  DS_6516D_B10EB_CLASS		362		//BNC���������ϵͳ
#define  DS_6516D_B10ES_CLASS		363		//SDI���������ϵͳ

//DVI/HDMI/VGA���Խ��빫��һ������
#define  DS_6508D_B10FH_CLASS		364
#define  DS_6508D_B10FD_CLASS		364
#define  DS_6508D_B10FV_CLASS		364

#define  DS_6508_B11E_CLASS			365		//BNC���������ϵͳ
#define  DS_6402_B11ES_CLASS		366		//SDI���������ϵͳ
#define  DS_6402_B11EV_CLASS		367		//VGA���������ϵͳ
#define  DS_6402_B11ER_CLASS		368		//RGB���������ϵͳ
#define  DS_6402_B11ED_CLASS		369		//DVI���������ϵͳ
#define  DS_6402_B11EH_CLASS		370		//HDMI���������ϵͳ
#define  DS_6516D_B11EB_CLASS		371		//BNC���������ϵͳ
#define  DS_6516D_B11ES_CLASS		372		//SDI���������ϵͳ

#define  DS_6508_B12E_CLASS         373     //BNC���������ϵͳ
#define	 DS_6402_B12ES_CLASS		375		//SDI���������ϵͳ
#define  DS_6402_B12EV_CLASS		376		//VGA���������ϵͳ
#define  DS_6402_B12ER_CLASS		377		//RGB���������ϵͳ
#define  DS_6402_B12ED_CLASS		378		//DVI���������ϵͳ
#define  DS_6402_B12EH_CLASS		379		//HDMI���������ϵͳ
#define  DS_6516D_B12EB_CLASS		380		//BNC���������ϵͳ

#define  DS_iVMSE_AIO_8100x_CLASS   381     //������ҵһ���X86��ϵͳ
#define  DS_iVMSE_AIO_87x_CLASS     382     //����¥��һ���X86��ϵͳ
#define  DS_6532D_B11ES_CLASS		384		//��ǿ�ͽ����_SDI(B11)
#define  DS_6532D_B12ES_CLASS		385		//��ǿ�ͽ����_SDI(B12)
//B20����
#define  DS_B20_MSU_NP              400     //B20���ذ�
#define  DS_6416HFH_B20S            401     //SDI�������
#define  DS_6416HFH_B20_RM          402     //��������������
#define  DS_6564D_B20D              403     //DVI����
#define  DS_6564D_B20H              404     //HDMI����
#define  DS_6564D_B20V              405     //VGA����
#define  DS_B20_6516D_DEV_CLASS     406     //B20������ϵͳ
#define  DS_6408HFH_B20V            407     //VGA�����
#define  DS_MMC_B20_CLASS           408     //B20����
#define  DS_CARD_CHIP_B20_CLASS     409     //B20�����Ӱ�
#define  DS_6564D_B20B_DEV_CLASS    410     //BNC������ϵͳ
#define  DS_6564D_B20S_DEV_CLASS    411     //SDI������ϵͳ
#define  DS_6532HF_B20B_DEV_CLASS   412     //BNC������ϵͳ
#define  DS_6408HFH_B20D_DEV_CLASS  413     //DVI������ϵͳ
#define  DS_6408HFH_B20H_DEV_CLASS  414     //HDMI������ϵͳ
#define  DS_IVMSE_B20_CLASS			415     //X86��������ϵͳ
#define  DS_6402HFH_B20Y_DEV_CLASS  416     //YUV������ϵͳ
#define  DS_6508HW_B20_DEV_CLASS    417     //HW������ϵͳ
#define  DS_B20N128Fx_B20_DEV_CLASS 418     //DS_B20N128Fx_M������
#define  DS_AIO_MCU_NP_DEV_CLASS    419     //IO���ذ�
#define  DS_6402_AIO_EV_DEV_CLASS   420     //VGA����
#define  DS_6508D_AIO_EV_DEV_CLASS  421     //VGA����
#define  DS_6508D_AIO_ED_DEV_CLASS  422     //DVI����
#define  DS_6508D_AIO_EH_DEV_CLASS  423     //HDMI����
#define  DS_6508HD_B20F_DEV_CLASS	424     //��Ƶ��ǿ��
#define  DS_6402HFH_B20ES_DEV_CLASS 425     //3G SID����
#define  DS_6532D_B20_DEV_CLASS     426     //B20������ϵͳ
#define  DS_IVMST_B20_DEV_CLASS     427     //X86��������ϵͳ
#define  DS_6416HFH_B20DD_DEV_CLASS 428     //DVI˫��·
#define  DS_6441VS_B20_DEV_CLASS    429		//���ƴ������
#define  DS_6404HFH_B20T_CLASS 		431		//TVI
#define  DS_FS22_B20_DEV_CLASS 		432	    //��������ϵͳ
#define  DS_IVMSE_B20UH_DEV_CLASS   433     //������X86����
#define  IDS_6524J_B20_DEV_CLASS    434
#define  IDS_6532B_B20_DEV_CLASS    435
#define DS_6404HFH_B20Fx_DEV_CLASS  436	    //��˻������ϵͳ
#define DS_N128x_B20Fy_CLASS		437     //������ϵͳ
#define DS_181600F_B20_CLASS		438     //���������ϵͳ
#define  DS_6904UD_B20H_CLASS       439     //�����������ϵͳ

#define DS_B21_MCU_NP_CLASS         440		//B21����
#define DS_B21_S10_x_CLASS          441	    //B21���� x = A/S/D
#define DS_6402HFH_B21D_CLASS		442     //B21������ϵͳ
#define DS_6508HD_B21D_CLASS		443     //B21������ϵͳ
#define DS_iVMSE_B21HW_CLASS		444     //B21 X86��ϵͳ

#define  DS_C10S                    501     //C10S ����ʽ����������

#define  DS_C10N_SDI				551		//SDI������
#define  DS_C10N_BIW				552		//8·BNC������
#define  DS_C10N_DON				553		//��ʾ������
#define  DS_C10N_TVI                554     //TVI�����
#define  DS_C10N_DI2                555     //DVI 2·�����
#define  DS_C10N_AUDIO_OUT          556     //DVI��HDMI��VGA��������Ƶ
#define  DS_C10N_AUDIO_IN           557     //DVI��HDMI��VGA��������Ƶ

//�����豸
#define DS_19M00_MN					601     //���������������ģ��
#define DS_KH8302_A                 602  //���ڻ�
#define DS_KD8101_2                 603  //�ſڻ�
#define DS_KM8301                   604  //�����
#define DS_KVXXXX_XX                605  //�����ſڻ�


#define DS64XXHD_T					701		//64-T���������
#define DS_65XXD                    703     //65���ܽ�����
#define DS63XXD_T					704		//63-T���������
#define SCE_SERVER                  705     //ץ��������
#define DS_64XXHD_S                 706     //64XXHD-S���������
#define DS_68XXT					707     //�๦������Ƶת����
#define DS_65XXD_T                  708     //65D-T���ܽ�����
#define DS_65XXHD_T                 709     //65HD-T���ܽ�����
#define DS_69XXUD                   710     //69XXUD�����������
#define DS_65XXUD                   711     //65XXUD������
#define DS_65XXUD_L                 712     //65XXUD_L������

#define DS_D20XX                    750     //LCD��Ļ ���뿨
//SDI����
#define DS_C50S                     751     //SDI����
#define DS_D50XX                    752     //LCD��Ļ ���뿨

#define DS_D40						760		//LED�����Ϳ�
#define DS_65VMXX                   770     //��Ƶ���������
#define DS_65VTXX                   771     //��Ƶ�����ն�
#define	DS_65VTA		            772		//��Ƶ����һ��ʽ�ն�
#define DS_65VT_RX                  773     //������ѧ�ն�
#define DS_CS_SERVER                800     //������������
#define DS_K260X                    850     //�Ž�����
#define DS_6800M					900     //68M������
#define DS_68NTH					901     //��Ϣ��������
#define DS_D60S                     902     //��Ϣ����������
#define	DS_D10						931		//��Ͷ��ʾ�豸
#define DS_3K0X_NM					951		//�����շ���
#define SCREEN_LINK_SERVER          971     //��Ļ������
//һ�廯��̨
#define IP_PTSYS_MEGA200			1001   //IP 200��һ�廯��̨
#define IPCAM_FISHEYE               1002   //���������
#define IPCAM_FISHEYE_E             1003   //���������������

//68xxϵ��˫Ŀ3D���
#define IPCAM_BINOCULAR             1004   //˫Ŀ�����

#define IPCAM_365					1010	//֧��365��ƽ̨��IPC CAM
#define IPCAM_R0					1011	//֧��A5S��ƽ̨��IPC CAM
#define IPCAM_R1					1012    //֧��385��ƽ̨��IPC CAM
#define IPCAM_R2					1013    //֧��R2��ƽ̨��IPC CAM
#define IPCAM_R3					1014    //֧��8127��ƽ̨��IPC CAM
#define IPCAM_R4					1015    //֧��S2��ƽ̨��IPC CAM

#define IPDOME_365					1110    //֧��365��ƽ̨��IPD CAM
#define IPDOME_R0					1111    //֧��A5S��ƽ̨��IPD CAM
#define IPDOME_R1					1112    //֧��385��ƽ̨��IPD CAM
#define IPDOME_R2					1113    //֧��R2��ƽ̨��IPD CAM
#define IPDOME_R3					1114    //֧��8127��ƽ̨��IPD CAM
#define IPDOME_R4					1115    //֧��S2��ƽ̨��IPD CAM
#define ITCCAM_R3					1211    //֧��8127��ƽ̨��ITCCAM

//�����豸���� 2013-11-19
#define TRAFFIC_ECT					1400  //ECT�豸����
#define TRAFFIC_PARKING_SERVER		1401  //ͣ����������
#define TRAFFIC_TME					1402  //����ڿ��ƻ�
// DVR
#define DS90XXHW_ST					2001	// DS90XXHW_ST���DVR
#define DS72XXHX_SH                 2002	// DS-72xxHV_SH, DS-72xxHF-SH
#define DS_92XX_HF_ST				2003	// DS-92XX-HF-ST
#define DS_91XX_HF_XT				2004	// 9100DVR_HF_XT
#define DS_90XX_HF_XT               2005	// 9000DVR_HF_XT
#define DS_73XXHX_SH				2006	// 7300DVR_HX_SH
#define DS_72XXHFH_ST				2007	// 7200DVR_HFH_ST
//DS_67ϵ��

#define DS_67XXHF_SATA              2008 // DS-67XXHF-SATA
#define DS_67XXHW                   2009 // DS-67XXHW
#define DS_67XXHW_SATA              2010 // DS-67XXHW-SATA
#define DS_67XXHF                   2011 // DS-67XXHF

//Netra2.3
#define DS_72XXHF_SV                2012  // DS-72xxHF-SV
#define DS_72XXHW_SV                2013   // DS-72xxHW-SV

#define DS_81XXHX_SH                2014   // 8100DVR_HX_SH

#define DS_71XXHX_SL				2015	//С��DVR

#define DS_76XXH_ST					2016	//DS_76XXH_ST


#define DS_73XXHFH_ST   			2017   //73HFHϵ��
#define DS_81XXHFH_ST   			2018   //81HFHϵ�� ST

#define DS_72XXHFH_SL				2019	//hi3521
#define DS_FDXXCGA_FLT				2020    //2��λATM

#define IDS_91XX_HF_ST_A            2100    //iDS-9100HF-ST/A
#define IDS_91XX_HF_ST_B            2101    //iDS-9100HF-ST/B
#define IDS_90XX_HF_ST_A            2102    //iDS-9000HF-ST/A
#define IDS_90XX_HF_ST_B            2103    //iDS-9000HF-ST/B
#define IDS_81XX_HF_ST_A            2104    //iDS-8100HF-ST/A
#define IDS_81XX_HF_ST_B            2105    //iDS-8100HF-ST/B
#define IDS_80XX_HF_ST_A            2106    //iDS-8000HF-ST/A
#define IDS_80XX_HF_ST_B            2107    //iDS-8000HF-ST/B
#define IDS_8104_AHFL_ST            2108    //���ܻ��ATM��

#define DS_72XXHXH_SH_21			2220   // 72HXH_SHϵ��_21
#define DS_72XXHXH_SH_31			2221  // 72XXHXH_SH_31
#define DS_73XXHXH_SH_31			2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31			2223  // 81XXHXH_SH_31


// NVR
#define DS_77XXN_ST				    2201	//  NVR DS-77XXHF-ST
#define DS_95XX_N_ST			    2202	//  95XXN_ST NVR
#define DS_85XX_N_ST			    2203	//  85XXN_ST NVR
#define DS_96XX_N_XT			    2204	// 9600NVR_N_XT
#define DS_76XX_N_SE				2205	// 7600NVR_N_SE

//������Ѷ��
#define DS_86XXSN_SX				2206	// 8608NVR_SX������4������DS-8608SNL-SP��DS-8608SNL-ST��DS-8608SN-SP��DS-8608SN-ST��L��ʾ��LCD��P��POE

//#define DS_96XX_N_RX				2207  //DS-96XX-N-RX
#define DS_71XXN_SL					2208  //DS-71XXN-SL ���ò�Ʒ
#define CS_N1_1XX					2209  //CS_N1_1XX��������ҵ������

#define DS_71XXN_SN					2210	//71XX_N_SN  ���������ò�Ʒ
#define CS_N1_2XX					2211	//N1_2XX		������ҵ������
#define DS_76XX_N_SHT				2212	//76XX_N_SHT  ��˻��߲�Ʒ
#define DS_96XXX_N_E                2213    //��������NVR(256)

#define	DS_76XXN_EX					2214 /* 76 78ϵ��NVR��ע������ 4 8 16·��E1һ��λ�� 8 16 32· E2����λ�� /N /P�豸*/
#define DS_77XXN_E4					2215/* 77ϵ��NVR��   ע������8 16 32·�� /N /P�豸*/
#define DS_86XXN_E8					2216/* 86ϵ��NVR��   ע������8 16 32·�� /N /P�豸*/
#define DS_9616N_H8                 2217   //DS_9616N_H8
#define DS_72XXHX_EX_GXY            2218   //��ʾ72ϵ������DVR��Ʒ������72�����xx��ʾͨ����H���XĿǰ����HW,Ϊ�˺�����չ������E�����X��ʾ������λ��G XY��ʾ������������
#define DS_76XXN_EX_GXY             2219   //��ʾ��76ϵ������NVR��Ʒ������76�����xx��ʾͨ����E�����X��ʾ������λ��G XY��ʾ������������
#define DS_72XXHXH_SH_21			2220   //  72XXHXH_SH_21
#define DS_72XXHXH_SH_31			2221  //  72XXHXH_SH_31
#define DS_73XXHXH_SH_31			2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31			2223  //  81XXHXH_SH_31
#define DS_96XXN_FX                 2230
#define DS_86XXN_FX                 2231
#define DS_96XXXN_HX                2232  //96ϵ�и������豸


#define DS_86XXN_I					2233	//DS_86XXN_I
#define DS_77XX_N_I					2234	//DS_77XX_N_I
#define DS_76XX_N_I					2235	//DS_76XX_N_I
#define DS_78XX_N_I					2236	//DS_78XX_N_I

//PCNVR
#define PCNVR_IVMS_4200             2301	// PCNVR_IVMS_4200


//���ܷ�����
#define IVMS_6200_TP                2401   //IVMS-6200 ��ͨ�յ�������
#define IVMS_6200_TF                2402   //IVMS-6200 ��ͨȡ֤������
#define IVMS_6200_D                 2403   //iVMS-6200(/D)
#define IDS_81XXAHW_ST              2405   //iDS-81xxAHW-ST
#define IDS_81XXAHW_SP              2406   //iDS-81xxAHW-SP
#define IDS_81XXAHWL_ST             2407   //iDS-81xxAHWL-ST
#define IDS_81XXAHWL_SP             2408   //iDS-81xxAHWL-SP
#define IDS_9616N_H8                2409   //iDS_9616N_H8
#define IVMS_6200_SMD               2500   //IVMS_6200_SMD
//HISI3531ƽ̨���ATM DVR�� ����L��ʾ��Һ������P��ʾ��poe
#define DS_81XXAHW_ST				2501
#define DS_81XXAHW_SP				2502
#define DS_81XXAHWL_ST				2503
#define DS_81XXAHWL_SP				2504

#define DS_6904UD_AIOE_H_CLASS      4002    //B20һ���
#define DS_6402HFH_B21B_CLASS       4005    //B21 ����
#define DS_6902UD_B21H_CLASS        4006    //B21 HDMI����
#define DS_6902UD_B21D_CLASS        4007    //B21 DVI����
#define DS_6902UD_B21V_CLASS        4008    //B21 VGA����


/**********************�豸���� end***********************/
/******************************��������ȡ*********************************/
//������ȡ����
#define DEVICE_SOFTHARDWARE_ABILITY         0x001  //�豸��Ӳ������
#define DEVICE_NETWORK_ABILITY              0x002  //�豸��������
#define DEVICE_ENCODE_ALL_ABILITY           0x003  //�豸���б�������
#define	DEVICE_ENCODE_CURRENT               0x004  //�豸��ǰ��������
#define IPC_FRONT_PARAMETER			        0x005	 //ipcǰ�˲���1.0
#define IPC_UPGRADE_DESCRIPTION		        0x006	 //ipc����Ϣ
#define DEVICE_RAID_ABILITY                 0x007  //RAID����
#define DEVICE_ENCODE_ALL_ABILITY_V20       0x008	 //�豸���б�������2.0
#define IPC_FRONT_PARAMETER_V20		        0x009	 //ipcǰ�˲���2.0
#define DEVICE_ALARM_ABILITY                0x00a  //��������
#define DEVICE_DYNCHAN_ABILITY		        0x00b  //�豸����ͨ������
#define DEVICE_USER_ABILITY                 0x00c  //�豸�û������������
#define DEVICE_NETAPP_ABILITY               0x00d  //�豸����Ӧ�ò�������
#define DEVICE_VIDEOPIC_ABILITY             0x00e  //�豸ͼ���������
#define DEVICE_JPEG_CAP_ABILITY             0x00f  //�豸JPEGץͼ����
#define DEVICE_SERIAL_ABILITY               0x010  //RS232��RS485��������
#define DEVICE_ABILITY_INFO			        0x011	 //�豸ͨ���������ͣ�����������ݷ��͵������ڵ������
#define STREAM_ABILITY                      0x012  //������
#define SYSTEM_MANAGEMENT_ABILITY           0x013  //�豸ϵͳ��������
#define IP_VIEW_DEV_ABILITY					0x014  //IP���ӶԽ��ֻ�����
#define VCA_DEV_ABILITY 	                0x100  //�豸���ܷ�����������
#define VCA_CHAN_ABILITY                    0x110  //��Ϊ��������
#define MATRIXDECODER_ABILITY               0x200  //��·��������ʾ����������
#define VIDEOPLATFORM_ABILITY               0x210 //��Ƶ�ۺ�ƽ̨������
#define VIDEOPLATFORM_SBUCODESYSTEM_ABILITY 0x211 //��Ƶ�ۺ�ƽ̨������ϵͳ������
#define WALL_ABILITY                        0x212  //����ǽ������
#define MATRIX_ABILITY                      0x213  //SDI��������
#define DECODECARD_ABILITY                  0x220 //���뿨������������
#define VIDEOPLATFORM_ABILITY_V40           0x230 //��Ƶ�ۺ�ƽ̨������
#define MATRIXMANAGEDEVICE_ABILITY          0x240 //����������������
#define MATRIXDECODER_ABILITY_V41           0x260 //������������
#define DECODER_ABILITY                     0x261 //������xml������
#define DECODECARD_ABILITY_V41              0x270 //���뿨������������V41
#define CODECARD_ABILITY                    0x271  //���뿨������
#define SNAPCAMERA_ABILITY                  0x300  //ץ�Ļ�������
#define ITC_TRIGGER_MODE_ABILITY            0x301  //����IPC�豸�Ĵ���ģʽ����
#define COMPRESSIONCFG_ABILITY              0x400  //��ȡѹ��������������
#define COMPRESSION_LIMIT                   0x401  //��ȡ��������ѹ��������������
#define PIC_CAPTURE_ABILITY			        0x402  //��ͼƬ�ֱ�����������
#define ALARMHOST_ABILITY                   0x500 //���籨������������
#define IT_DEVICE_ABILITY                   0x501  //���ܽ�ͨ������
#define	SCREENCONTROL_ABILITY		        0x600 	//����������������
#define	SCREENSERVER_ABILITY                0x610 	//����������������
#define FISHEYE_ABILITY                     0x700   //����������
#define LCD_SCREEN_ABILITY					0x800	//LCD��Ļ���� 2013-10-12
#define ACS_ABILITY                         0x801   //�Ž�����
#define MERGEDEV_ABILITY                    0x802   //������������
#define CAM_FUSION_ABILITY                  0x803   //���ƴ������
#define NET_RING_ABILITY					0x806	//����������
#define LED_ABILITY							0x807	//LED��������
#define PUBLISHDEV_ABILITY					0x80a	//��Ϣ��������
/*************************************************
�������ýṹ������(����_V30Ϊ9000����)
**************************************************/

//�Ӱ��쳣��Ϣ
//������
#define EXCEPTION_MAJOR_MAINBOARD_BOOT		            0x1  //������������
//������
#define EXCEPTION_MINOR_PCIE_SCAN                    	0x1  // pcie��·ɨ���쳣
#define EXCEPTION_MINOR_DOWNLOAD_SUBBOARD     		    0xa  //�����Ӱ�����쳣

//������
#define EXCEPTION_MAJOR_SUBBOARD_BOOT		            0x2  //�Ӱ���������
//������
#define EXCEPTION_MINOR_INEXISTENCE                   	0x1  //PCI-Eɨ������ǰ�Ӱ岻����
#define EXCEPTION_MINOR_UBOOT_DOWNLOAD                  0xa  // uboot�����쳣
#define EXCEPTION_MINOR_UBOOT_INIT                      0xe  //uboot��ʼ���쳣
#define EXCEPTION_MINOR_ROOTFS_DOWNLOAD                 0x14  //rootfs.img�����쳣
#define EXCEPTION_MINOR_UIMAGE_DOWNLOAD                 0x19  //uImage�����쳣
#define EXCEPTION_MINOR_UBOOT_SETBOOTFLAG               0x1e  // uboot������־λ��λ�쳣
#define EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD            0x23  // rootfs�����쳣
#define EXCEPTION_MINOR_NEED_FILE_FINISH                0x28  //�Ӱ������ļ������쳣

//������
#define EXCEPTION_MAJOR_SUBBOARD_HARDWARE			    0x3  //�Ӱ�Ӳ������
//������
#define EXCEPTION_MINOR_AD           					0x1  //AD�쳣
#define EXCEPTION_MINOR_DA             					0xa  // DA�쳣
#define EXCEPTION_MINOR_TIMER							0xb	 //ʱ���쳣

//������
#define EXCEPTION_MAJOR_FPGA							0x4  //FPGA����
//������
#define EXCEPTION_MINOR_IDLE          					0x1  //�޷�IDLE
#define EXCEPTION_MINOR_LANE             				0xa  // LANE OKʧ��
#define EXCEPTION_MINOR_REGISTER_ALL_F             	    0xe  //FPGA�Ĵ���ȫF
#define EXCEPTION_MINOR_MEMORY_INIT_FAIL             	0x14 //FPGA�ڴ��ʼ��ʧ��
//������
#define EXCEPTION_MAJOR_DSP								0x5  //DSP����

//������
#define EXCEPTION_MAJOR_ARM								0x6  //ARM����

//������
#define EXCEPTION_MAJOR_BACKBOARD						0x7  //��������
//������
#define EXCEPTION_MINOR_BLACKBOARD_TYPE       	        0x1  //��ȡ���������쳣
#define EXCEPTION_MINOR_SERDES       					0xa  //��Ƶ����оƬ
#define EXCEPTION_MINOR_CLOCK             	            0xe  //ʱ�ӹ���
#define EXCEPTION_MINOR_SYNCH             	            0x14  //ͬ���źŹ���

//������
#define EXCEPTION_MAJOR_SUBBOARD_NET					0x8  //�Ӱ�����
//������
#define EXCEPTION_MINOR_IP_CONFLICT       			    0x1  //IP��ͻ
#define EXCEPTION_MINOR_DISCONNECT             		    0x14  // ����

//����
#define MAX_PORT_NUM            64  //���˿���
#define MAX_SINGLE_CARD_PORT_NO 4   //�����շ����������˿���
#define MAX_FUNC_CARD_NUM       32  //�����շ�������ܿ���
#define MAX_SINGLE_CARD_PORT_NO 4   //�����շ����������˿���
#define MAX_FUNC_CARD_NUM       32  //�����շ�������ܿ���
#define MAX_FC_CARD_NUM         33  //�����շ��������
#define MAX_REMARKS_LEN         128 //ע����󳤶�

typedef enum tagCharEncodeType
{
    ENUM_MEM_CHAR_ENCODE_ERR  = -1,         //Error
    ENUM_MEM_CHAR_ENCODE_NO   = 0,          //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN   = 1,          //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK  = 2,          //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,          //BIG5
    ENUM_MEM_CHAR_ENCODE_JP   = 4,          //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR   = 5,          //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,          //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1  = 7,    //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
}CHAR_ENCODE_TYPE;


/////////////////////////////////////////////////////////////////////////
//Уʱ�ṹ����
typedef struct
{
    DWORD dwYear;		//��
    DWORD dwMonth;		//��
    DWORD dwDay;		//��
    DWORD dwHour;		//ʱ
    DWORD dwMinute;		//��
    DWORD dwSecond;		//��
}NET_DVR_TIME, *LPNET_DVR_TIME;

typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
    WORD wMilliSec;
    BYTE byRes1[2];
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME,*LPNET_DVR_CALIBRATE_TIME;

#define    MAX_TIMESIGN_LEN    32 //�Զ���Уʱ�����Ϣ����
typedef  struct tagNET_DVR_TIMESIGN_CFG
{
    DWORD  dwSize;
    BYTE  byCustomSetTimeSign[MAX_TIMESIGN_LEN/*32*/];//�Զ���Уʱ���
    BYTE  byRes[96];
}NET_DVR_TIMESIGN_CFG,*LPNET_DVR_TIMESIGN_CFG;


typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX,*LPNET_DVR_TIME_EX;

//ʱ���(�ӽṹ)
typedef struct
{
    //��ʼʱ��
    BYTE byStartHour;
    BYTE byStartMin;
    //����ʱ��
    BYTE byStopHour;
    BYTE byStopMin;
}NET_DVR_SCHEDTIME, *LPNET_DVR_SCHEDTIME;

/*�豸�������쳣���?ʽ*/
/*�豸�������쳣���?ʽ*/
#define NOACTION			0x0				/*����Ӧ*/
#define WARNONMONITOR		0x1				/*�������Ͼ���*/
#define WARNONAUDIOOUT		0x2				/*��������*/
#define UPTOCENTER			0x4				/*�ϴ�����*/
#define TRIGGERALARMOUT		0x8				/*�����������*/
#define TRIGGERCATPIC		0x10			/*����ץͼ���ϴ�E-mail*/
#define SEND_PIC_FTP        0x200           /*ץͼ���ϴ�ftp*/

typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD	wLength;		//�ṹ����
    BYTE	byVersion ;	/*�ߵ�4λ�ֱ���ߵͰ汾�������ݰ汾�ͳ��Ƚ�����չ����ͬ�İ汾�ĳ��Ƚ�������*/
    BYTE	byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    /*0x400: �齻��� ���� �۽�ģʽ���ṩ�������ԭ���豸�Զ���ɣ�IPC5.1.0*/
    /*0x800: PTZ��������(������Ŀ��)*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧����
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //��������ͨ��
    BYTE    byRes[64];           //����
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V40
{
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x80: ��������¼��(Ŀǰֻ��PCNVR֧��) */
    /*0x100: ����������̨Ԥ�õ� (Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    /*0x400: �齻��� ���� �۽�ģʽ���ṩ�������ԭ���豸�Զ���ɣ�IPC5.1.0*/
    /*0x800: PTZ��������(������Ŀ��)*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOutChanNum; //�����ı������ͨ���� ʵ��֧����
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //��������ͨ��
    BYTE    byRes[64];           //����
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;

//�������쳣����ṹ(�ӽṹ)(�ദʹ��)(9000��չ)
typedef struct
{
    DWORD	dwHandleType;	/*���?ʽ,���?ʽ��"��"���*/
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    BYTE byRelAlarmOut[MAX_ALARMOUT_V30];
    //�������������ͨ��,�������������,Ϊ1��ʾ���������
}NET_DVR_HANDLEEXCEPTION_V30, *LPNET_DVR_HANDLEEXCEPTION_V30;

//�������쳣����ṹ(�ӽṹ)(�ദʹ��)
typedef struct
{
    DWORD	dwHandleType;			/*���?ʽ,���?ʽ��"��"���*/
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: Jpegץͼ���ϴ�EMail*/
    BYTE byRelAlarmOut[MAX_ALARMOUT];  //�������������ͨ��,�������������,Ϊ1��ʾ���������
}NET_DVR_HANDLEEXCEPTION, *LPNET_DVR_HANDLEEXCEPTION;

//DVR�豸����
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR���
    DWORD dwDVRID;				//DVR ID,����ң���� //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;		//�Ƿ�ѭ��¼��,0:����; 1:��
    //���²��ɸ��
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    DWORD dwSoftwareVersion;			//����汾��,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwSoftwareBuildDate;			//����������,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;		    //DSP����汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwDSPSoftwareBuildDate;		// DSP����������,0xYYYYMMDD
    DWORD dwPanelVersion;				// ǰ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwHardwareVersion;	// Ӳ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    BYTE byAlarmInPortNum;		//DVR�����������
    BYTE byAlarmOutPortNum;		//DVR�����������
    BYTE byRS232Num;			//DVR 232���ڸ���
    BYTE byRS485Num;			//DVR 485���ڸ���
    BYTE byNetworkPortNum;		//����ڸ���
    BYTE byDiskCtrlNum;			//DVR Ӳ�̿���������
    BYTE byDiskNum;				//DVR Ӳ�̸���
    BYTE byDVRType;				//DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;				//DVR ͨ������
    BYTE byStartChan;			//��ʼͨ����,����DVS-1,DVR - 1
    BYTE byDecordChans;			//DVR ����·��
    BYTE byVGANum;				//VGA�ڵĸ���
    BYTE byUSBNum;				//USB�ڵĸ���
    BYTE byAuxoutNum;			//���ڵĸ���
    BYTE byAudioNum;			//�����ڵĸ���
    BYTE byIPChanNum;			//�������ͨ����
}NET_DVR_DEVICECFG, *LPNET_DVR_DEVICECFG;

/*
IP��ַ
*/
typedef struct
{
    char	sIpV4[16];						/* IPv4��ַ */
    BYTE	byIPv6[128];						/* ���� */
}NET_DVR_IPADDR, *LPNET_DVR_IPADDR;

/*
������ݽṹ(�ӽṹ)(9000��չ)
*/
typedef struct
{
    NET_DVR_IPADDR	struDVRIP;          					//DVR IP��ַ
    NET_DVR_IPADDR	struDVRIPMask;  //DVR IP��ַ����
    DWORD	dwNetInterface;   								//����ӿ�1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M����Ӧ
    WORD	wDVRPort;										//�˿ں�
    WORD	wMTU;											//����MTU���ã�Ĭ��1500��
    BYTE	byMACAddr[MACADDR_LEN];							// �����ַ
    BYTE    byRes[2];              //����
}NET_DVR_ETHERNET_V30, *LPNET_DVR_ETHERNET_V30;

/*
������ݽṹ(�ӽṹ)
*/
typedef struct
{
    char sDVRIP[16];          //DVR IP��ַ
    char sDVRIPMask[16];      //DVR IP��ַ����
    DWORD dwNetInterface;     //����ӿ� 1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M����Ӧ
    WORD wDVRPort;		      //�˿ں�
    BYTE byMACAddr[MACADDR_LEN];		//�������������ַ
}NET_DVR_ETHERNET;

//pppoe�ṹ
typedef struct
{
    DWORD	dwPPPOE;										//0-������,1-����
    BYTE	sPPPoEUser[NAME_LEN];							//PPPoE�û���
    char	sPPPoEPassword[PASSWD_LEN];						// PPPoE����
    NET_DVR_IPADDR	struPPPoEIP;							//PPPoE IP��ַ
}NET_DVR_PPPOECFG, *LPNET_DVR_PPPOECFG;

//�������ýṹ(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30	struEtherNet[MAX_ETHERNET];		//��̫���
    NET_DVR_IPADDR	struRes1[2];					/*����*/
    NET_DVR_IPADDR	struAlarmHostIpAddr;					/* ��������IP��ַ */
    BYTE	byRes2[4];								/* ���� */
    WORD	wAlarmHostIpPort;								/* ��������˿ں� */
    BYTE    byUseDhcp;                                      /* �Ƿ�����DHCP 0xff-��Ч 0-������ 1-����*/
    BYTE	byIPv6Mode;								//IPv6���䷽ʽ��0-·�ɹ��棬1-�ֶ����ã�2-����DHCP����
    NET_DVR_IPADDR	struDnsServer1IpAddr;					/* ���������1��IP��ַ */
    NET_DVR_IPADDR	struDnsServer2IpAddr;					/* ���������2��IP��ַ */
    BYTE	byIpResolver[MAX_DOMAIN_NAME];					/* IP���������������IP��ַ */
    WORD	wIpResolverPort;								/* IP�����������˿ں� */
    WORD	wHttpPortNo;									/* HTTP�˿ں� */
    NET_DVR_IPADDR	struMulticastIpAddr;					/* �ಥ���ַ */
    NET_DVR_IPADDR	struGatewayIpAddr;						/* ��ص�ַ */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE	byEnablePrivateMulticastDiscovery;  //˽�жಥ������0~Ĭ�ϣ�1~���ã�2-����
    BYTE	byEnableOnvifMulticastDiscovery;  //Onvif�ಥ������0~Ĭ�ϣ�1~���ã�2-����
    BYTE    byRes[62];
} NET_DVR_NETCFG_V30, *LPNET_DVR_NETCFG_V30;

//����������ṹ
typedef struct
{
    NET_DVR_IPADDR struDVRIP;           //DVR IP��ַ
    NET_DVR_IPADDR struDVRIPMask;           //DVR IP��ַ����
    DWORD dwNetInterface;    //����ӿ�1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M/1000M����Ӧ
    BYTE byCardType;  //�����ͣ�0-��ͨ��1-������2-������
    BYTE byRes1;
    WORD wMTU;             //����MTU���ã�Ĭ��1500��
    BYTE byMACAddr[MACADDR_LEN]; //�����ַ��ֻ������ʾ
    BYTE byRes2[2]; //����
    BYTE byUseDhcp;                          /* �Ƿ�����DHCP */
    BYTE byRes3[3];
    NET_DVR_IPADDR struGatewayIpAddr;     /* ��ص�ַ */
    NET_DVR_IPADDR struDnsServer1IpAddr; /* ���������1��IP��ַ */
    NET_DVR_IPADDR struDnsServer2IpAddr; /* ���������2��IP��ַ */
}NET_DVR_ETHERNET_MULTI, *LPNET_DVR_ETHERNET_MULTI;

//�����������ýṹ
typedef struct
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;        //Ĭ��·�ɣ�0��ʾstruEtherNet[0]��1��ʾstruEtherNet[1]
    BYTE   byNetworkCardNum;      //�豸ʵ�ʿ����õ�����Ŀ
    BYTE   byWorkMode;   //0-��ͨ����ģʽ��1-���������ģʽ
    BYTE   byRes; //����
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD]; //��̫���
    NET_DVR_IPADDR         struManageHost1IpAddr;     /* ����������IP��ַ */
    NET_DVR_IPADDR         struManageHost2IpAddr;     /* ����������IP��ַ */
    NET_DVR_IPADDR	       struAlarmHostIpAddr; /* ��������IP��ַ */
    WORD wManageHost1Port;     /* ����������˿ں� */
    WORD wManageHost2Port;     /* ����������˿ں� */
    WORD wAlarmHostIpPort;     /* ��������˿ں� */
    BYTE  byIpResolver[MAX_DOMAIN_NAME];     /* IP���������������IP��ַ */
    WORD wIpResolverPort; /* IP�����������˿ں� */
    WORD wDvrPort; //ͨѶ�˿� Ĭ��8000
    WORD wHttpPortNo; /* HTTP�˿ں� */
    WORD wDvrPort2; //ͨѶ�˿�2
    BYTE byRes2[4];
    NET_DVR_IPADDR   struMulticastIpAddr; /* �ಥ���ַ */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE byRes3[24];
}NET_DVR_NETCFG_MULTI, *LPNET_DVR_NETCFG_MULTI;

//�������ýṹ
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET struEtherNet[MAX_ETHERNET];		/* ��̫��� */
    char sManageHostIP[16];		//Զ�̹��������ַ
    WORD wManageHostPort;		//Զ�̹�������˿ں�
    char sIPServerIP[16];            //IPServer��������ַ
    char sMultiCastIP[16];     //�ಥ���ַ
    char sGatewayIP[16];       	//��ص�ַ
    char sNFSIP[16];			//NFS����IP��ַ
    BYTE sNFSDirectory[PATHNAME_LEN];//NFSĿ¼
    DWORD dwPPPOE;				//0-������,1-����
    BYTE sPPPoEUser[NAME_LEN];	//PPPoE�û���
    char sPPPoEPassword[PASSWD_LEN];// PPPoE����
    char sPPPoEIP[16];			//PPPoE IP��ַ(ֻ��)
    WORD wHttpPort;				//HTTP�˿ں�
}NET_DVR_NETCFG, *LPNET_DVR_NETCFG;

//sip����
typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //ʹ���Զ�ע�ᣬ0-��ʹ�ܣ�1-ʹ��
    BYTE byLoginStatus;  //ע��״̬��0-δע�ᣬ1-��ע�ᣬ�˲���ֻ�ܻ�ȡ
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP������IP
    WORD wServerPort;    //SIP�������˿�
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //ע���û���
    BYTE byPassWord[PASSWD_LEN]; //ע������
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //�豸��ʾ���
    WORD wLocalPort;     //���ض˿�
    BYTE byLoginCycle;   //ע�����ڣ�1-99����
    BYTE byRes[129];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

//IP���ӶԽ��ֻ�����
typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //Ĭ����������Χ1-6
    BYTE  byRingVolume;  //������������Χ0-9
    BYTE  byInputVolume; //��������ֵ����Χ0-6
    BYTE  byOutputVolume; //�������ֵ����Χ0-9
    WORD  wRtpPort;  //Rtp�˿�
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //Ԥ����ʱ���ã�0-30��
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG,*LPNET_DVR_IP_VIEW_DEVCFG;

//Ip���ӶԽ���Ƶ��ز�������
typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;
    BYTE  byAudioEncPri1; //��Ƶ�������ȼ�1��0-G722��1-G711_U��2-G711_A�� 5-MPEG2,6-G726��7-AAC
    BYTE  byAudioEncPri2; //��Ƶ�������ȼ�2����sip��������֧����Ƶ����1ʱ��ʹ����Ƶ����2��0-G722��1-G711_U��2-G711_A�� 5-MPEG2,6-G726��7-AAC
    WORD  wAudioPacketLen1; //��Ƶ����1��ݰ��
    WORD  wAudioPacketLen2; //��Ƶ����2��ݰ��
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG,*LPNET_DVR_IP_VIEW_AUDIO_CFG;

//IP�ֻ���жԽ��������ýṹ��
typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize ;
    BYTE  byEnableAutoResponse; //ʹ���Զ�Ӧ��,0-��ʹ�ܣ�1-ʹ��
    BYTE  byAudoResponseTime; //�Զ�Ӧ��ʱ�䣬0-30��
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //������������1��0-��������1-����
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //���к���1
    BYTE  byEnableAlarmNumber2; //������������2��0-��������1-����
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //���к���2�����к���1ʧ�᳢ܻ�Ժ��к���2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG,*LPNET_DVR_IP_VIEW_CALL_CFG;

//ͨ��ͼ��ṹ
//�ƶ����(�ӽṹ)(���鷽ʽ��չ)
typedef struct
{
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwCurRecordChanNum;    //��ǰʵ�������õĹ���¼��ͨ����
    DWORD     dwRelRecordChan[MAX_CHANNUM_V30];	 /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - MAX_CHANNUM_V30-1��Ч������м�����0xffffffff,�������Ч*/
    BYTE       byRes[64];          //����
}NET_DVR_RECORDCHAN, *LPNET_DVR_RECORDCHAN;

//�ƶ����(�ӽṹ)(9000��չ)
typedef struct
{
    BYTE byMotionScope[64][96];									/*�������,0-96λ,��ʾ64��,����96*64��С���,Ϊ1��ʾ���ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;										/*�ƶ����������, 0 - 5,Խ��Խ����,oxff�ر�*/
    BYTE byEnableHandleMotion;									/* �Ƿ����ƶ���� 0���� 1����*/
    BYTE byEnableDisplay;	/*�����ƶ���������ʾ��0-��1-��*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;				/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];									/* ����������¼��ͨ��*/
}NET_DVR_MOTION_V30, *LPNET_DVR_MOTION_V30;

//�ƶ����(�ӽṹ)
typedef struct
{
    BYTE byMotionScope[18][22];	/*�������,����22*18��С���,Ϊ1��ʾ�ĺ�����ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;		/*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byEnableHandleMotion;	/* �Ƿ����ƶ���� */
    BYTE byEnableDisplay;	/*�����ƶ���������ʾ��0-��1-��*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
}NET_DVR_MOTION, *LPNET_DVR_MOTION;

//�ڵ�����(�ӽṹ)(9000��չ)  �����С704*576
typedef struct
{
    DWORD dwEnableHideAlarm;				/* �Ƿ������ڵ����� ,0-��,1-�������� 2-�������� 3-��������*/
    WORD wHideAlarmAreaTopLeftX;			/* �ڵ������x��� */
    WORD wHideAlarmAreaTopLeftY;			/* �ڵ������y��� */
    WORD wHideAlarmAreaWidth;				/* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;				/*�ڵ�����ĸ�*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
}NET_DVR_HIDEALARM_V30, *LPNET_DVR_HIDEALARM_V30;
//�ڵ�����(�ӽṹ)  �����С704*576
typedef struct
{
    DWORD dwEnableHideAlarm;				/* �Ƿ������ڵ����� ,0-��,1-�������� 2-�������� 3-��������*/
    WORD wHideAlarmAreaTopLeftX;			/* �ڵ������x��� */
    WORD wHideAlarmAreaTopLeftY;			/* �ڵ������y��� */
    WORD wHideAlarmAreaWidth;				/* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;				/*�ڵ�����ĸ�*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
}NET_DVR_HIDEALARM, *LPNET_DVR_HIDEALARM;

//�źŶ�ʧ����(�ӽṹ)(9000��չ)
typedef struct
{
    BYTE byEnableHandleVILost;	/* �Ƿ����źŶ�ʧ���� */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
}NET_DVR_VILOST_V30, *LPNET_DVR_VILOST_V30;

//�źŶ�ʧ����(�ӽṹ)
typedef struct
{
    BYTE byEnableHandleVILost;	/* �Ƿ����źŶ�ʧ���� */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
}NET_DVR_VILOST, *LPNET_DVR_VILOST;

//�ڵ�����(�ӽṹ)
typedef struct
{
    WORD wHideAreaTopLeftX;				/* �ڵ������x��� */
    WORD wHideAreaTopLeftY;				/* �ڵ������y��� */
    WORD wHideAreaWidth;				/* �ڵ�����Ŀ� */
    WORD wHideAreaHeight;				/*�ڵ�����ĸ�*/
}NET_DVR_SHELTER, *LPNET_DVR_SHELTER;

typedef struct
{
    BYTE byBrightness;  	/*����,0-255*/
    BYTE byContrast;    	/*�Աȶ�,0-255*/
    BYTE bySaturation;  	/*���Ͷ�,0-255*/
    BYTE byHue;    			/*ɫ��,0-255*/
}NET_DVR_COLOR, *LPNET_DVR_COLOR;

typedef struct
{
    BYTE byRed;		//RGB��ɫ������еĺ�ɫ
    BYTE byGreen;	//RGB��ɫ������е���ɫ
    BYTE byBlue;	//RGB��ɫ������е���ɫ
    BYTE byRes;		//����
}NET_DVR_RGB_COLOR, *LPNET_DVR_RGB_COLOR;

//���ֵ��һ��,������ֵΪ��ǰ����İٷֱȴ�С, ����ΪС������λ
//�����ṹ
typedef struct tagNET_VCA_POINT
{
    float fX;                                // X�����, 0.001~1
    float fY;                                //Y�����, 0.001~1
}NET_VCA_POINT, *LPNET_VCA_POINT;

//ͨ��ͼ��ṹ(9000��չ)
typedef struct
{
    DWORD dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD dwVideoFormat;	/* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE  byReservedData[64];/*����*/
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ�����,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;				/* ͨ�������ʾλ�õ�x��� */
    WORD wShowNameTopLeftY;				/* ͨ�������ʾλ�õ�y��� */
    //��Ƶ�źŶ�ʧ����
    NET_DVR_VILOST_V30 struVILost;
    NET_DVR_VILOST_V30 struRes;		/*����*/
    //	BYTE byRes1[328];
    //�ƶ����
    NET_DVR_MOTION_V30 struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM_V30 struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;		/* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;				/* OSD��x��� */
    WORD wOSDTopLeftY;				/* OSD��y��� */
    BYTE byOSDType;					/* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;				/* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;				/* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    BYTE byHourOSDType;				/* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
    BYTE byFontSize;//�����С��16*16(��)/8*16(Ӣ)��1-32*32(��)/16*32(Ӣ)��2-64*64(��)/32*64(Ӣ)  3-48*48(��)/24*48(Ӣ) 0xff-����Ӧ(adaptive)
    BYTE byOSDColorType;	//0-Ĭ�ϣ��ڰף���1-�Զ���
    BYTE byAlignment;//���뷽ʽ 0-����Ӧ��1-�Ҷ���, 2-�����
    BYTE byOSDMilliSecondEnable;//��Ƶ����ʱ��֧�ֺ��룻0~������, 1-����
    NET_DVR_RGB_COLOR struOsdColor;//OSD��ɫ
    BYTE byRes[56];
}NET_DVR_PICCFG_V30, *LPNET_DVR_PICCFG_V30;

//ͨ��ͼ��ṹSDK_V14��չ
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;	/* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE byBrightness;  	/*����,0-255*/
    BYTE byContrast;    	/*�Աȶ�,0-255*/
    BYTE bySaturation;  	/*���Ͷ�,0-255 */
    BYTE byHue;    			/*ɫ��,0-255*/
    //��ʾͨ����
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ�����,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;				/* ͨ�������ʾλ�õ�x��� */
    WORD wShowNameTopLeftY;				/* ͨ�������ʾλ�õ�y��� */
    //�źŶ�ʧ����
    NET_DVR_VILOST struVILost;
    //�ƶ����
    NET_DVR_MOTION struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;		/* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;				/* OSD��x��� */
    WORD wOSDTopLeftY;				/* OSD��y��� */
    BYTE byOSDType;					/* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;				/* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;				/* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    BYTE byHourOsdType;		/* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
}NET_DVR_PICCFG_EX, *LPNET_DVR_PICCFG_EX;

//ͨ��ͼ��ṹ(SDK_V13��֮ǰ�汾)
typedef struct
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;	/* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE byBrightness;  	/*����,0-255*/
    BYTE byContrast;    	/*�Աȶ�,0-255*/
    BYTE bySaturation;  	/*���Ͷ�,0-255 */
    BYTE byHue;    			/*ɫ��,0-255*/
    //��ʾͨ����
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ�����,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;				/* ͨ�������ʾλ�õ�x��� */
    WORD wShowNameTopLeftY;				/* ͨ�������ʾλ�õ�y��� */
    //�źŶ�ʧ����
    NET_DVR_VILOST struVILost;
    //�ƶ����
    NET_DVR_MOTION struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;		/* �Ƿ������ڵ� ,0-��,1-��*/
    WORD wHideAreaTopLeftX;				/* �ڵ������x��� */
    WORD wHideAreaTopLeftY;				/* �ڵ������y��� */
    WORD wHideAreaWidth;				/* �ڵ�����Ŀ� */
    WORD wHideAreaHeight;				/*�ڵ�����ĸ�*/
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;				/* OSD��x��� */
    WORD wOSDTopLeftY;				/* OSD��y��� */
    BYTE byOSDType;					/* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;				/* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;				/* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    char reservedData2;
}NET_DVR_PICCFG, *LPNET_DVR_PICCFG;

typedef enum _BITRATE_ENCODE_INDEX_
{
    BITRATE_ENCODE_def = 0,
        BITRATE_ENCODE_8kps = 1,
        BITRATE_ENCODE_16kps = 2,
        BITRATE_ENCODE_32kps = 3,
        BITRATE_ENCODE_64kps = 4,
        BITRATE_ENCODE_128kps = 5,
        BITRATE_ENCODE_192kps = 6,
        BITRATE_ENCODE_40kps = 7,
        BITRATE_ENCODE_48kps = 8,
        BITRATE_ENCODE_56kps = 9,
        BITRATE_ENCODE_80kps = 10,
        BITRATE_ENCODE_96kps = 11,
        BITRATE_ENCODE_112kps = 12,
        BITRATE_ENCODE_144kps = 13,
        BITRATE_ENCODE_160kps = 14
}BITRATE_ENCODE_INDEX;

//����ѹ������(�ӽṹ)(9000��չ)
typedef struct
{
    BYTE byStreamType;		//�������� 0-��Ƶ��, 1-������, ��ʾ�¼�ѹ������ʱ���λ��ʾ�Ƿ�����ѹ������
                            /*�ֱ���0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,
                            4-2CIF                      5��������,                 6-QVGA(320*240),        7-QQVGA(160*120),
                            12-384*288                  13-576*576,
                            16-VGA��640*480��,          17-UXGA��1600*1200��,      18-SVGA(800*600),       19-HD720p(1280*720��,
                            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,
                            24-1920*1920,               27-HD1080i,
                            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,
                            32-2448*1200,               33-2448*800,               34-XGA��1024*768����    35-SXGA��1280*1024��,
                            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),
                            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,
                            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,
                            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,
                            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
                            56-2304*1296                57-WXGA(1280*800),         58-1600*600,			   59-1600*900,
                            60-2752*2208,				61-����,                   62-4000*3000,           63-4096*2160,
                            64-3840*2160,				65-4000*2250,              66-3072*1728,           67-2592*1944,
                            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
                            72-160*128,                 73-324*240,                74-324*256,             75-336*256,
                            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216,
                            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
                            84-325*256,                 85-256*192,                86-640*360,			   87-1776x1340,
                            88-1936x1092,				89-2080x784,			   90-2144x604,            91-1920*1200,
                            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
                            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
                            100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
                            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
                            108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
                            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
                            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
                            120-480*768,                121-768*480,               122-320*512,             123-512*320,
                            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
                            128-512*272,                129-2592*2592
                            0xff-Auto(ʹ�õ�ǰ�����ֱ���)
    */
    BYTE byResolution;
    BYTE byBitrateType;		//�������� 0:������, 1:������,0xfe:�Զ�����Դһ��
    BYTE byPicQuality;		//ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��,�Զ�����Դһ��
                            /*��Ƶ����:0-������1-16K(����)��2-32K��3-48k��4-64K��5-80K��6-96K��7-128K��8-160k��9-192K��10-224K��
                            11-256K��12-320K��13-384K��14-448K��15-512K��16-640K��17-768K��18-896K��19-1024K��20-1280K��21-1536K��22-1792K��23-2048K��
    24-3072K��25-4096K��26-8192K��27-16384K�����λ(31λ)�ó�1��ʾ���Զ���������0��30λ��ʾ����ֵ����Сֵ16k,0xfffffffe���Զ�����Դһ��*/
    DWORD dwVideoBitrate;
    DWORD dwVideoFrameRate;	//֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; V2.0�汾���¼�14-15; 15-18; 16-22;
    //17-25��18-30��19-35��20-40��21-45��22-50��23-55��24-60��25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,0xfffffffe-�Զ�����Դһ��
    WORD  wIntervalFrameI;  //I֡���,0xfffe �Զ�����Դһ��
    BYTE  byIntervalBPFrame;//0-BBP֡; 1-BP֡; 2-��P֡(2006-08-11 ���ӵ�P֡�����ýӿڣ����Ը���ʵʱ����ʱ����)��0xfe-�Զ�����Դһ��
    BYTE  byres1;        //����
    BYTE  byVideoEncType;   //��Ƶ�������� 0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��8-MPEG2��9-SVAC, 10-��׼h265, 0xfe-�Զ�����Դһ�£���0xff-��Ч
    BYTE  byAudioEncType;   //��Ƶ�������� 0-G722;1-G711_U;2-G711_A;5-MP2L2;6-G276;7-AAC;8-PCM;0xff-��Ч
    BYTE  byVideoEncComplexity; //��Ƶ���븴�Ӷȣ�0-�ͣ�1-�У�2��,0xfe:�Զ�����Դһ��
    BYTE  byEnableSvc; //0 - ������SVC���ܣ�1- ����SVC����; 2-�Զ�����SVC����
    BYTE  byFormatType; //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP,9-RTP+PS����꣺GB28181����0xff-��Ч
    BYTE  byAudioBitRate; //��Ƶ���� �ο� BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;//����ƽ�� 1��100��1�ȼ���ʾ����(Clear)��100��ʾƽ��(Smooth)��
    BYTE  byAudioSamplingRate;//��Ƶ������0-Ĭ��,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;//�����ܱ��� 0-�رգ�1-��
    BYTE  byres;
    //ƽ�����ʣ���SmartCodecʹ�ܿ�������Ч��, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
    //���λ(15λ)�ó�1��ʾ���Զ�������, 0-14λ��ʾ����ֵ(MIN- 0 K)��
    WORD  wAverageVideoBitrate;
}NET_DVR_COMPRESSION_INFO_V30, *LPNET_DVR_COMPRESSION_INFO_V30;

//ͨ��ѹ������(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;    //¼�� ��Ӧ8000����ͨ
    NET_DVR_COMPRESSION_INFO_V30 struRes;//���� char reserveData[28];
    NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;       //�¼�����ѹ������
    NET_DVR_COMPRESSION_INFO_V30 struNetPara;               //��(������)
}NET_DVR_COMPRESSIONCFG_V30, *LPNET_DVR_COMPRESSIONCFG_V30;

//����ѹ������(�ӽṹ)
typedef struct
{
    BYTE byStreamType;		//��������0-��Ƶ��,1-������,��ʾѹ������ʱ���λ��ʾ�Ƿ�����ѹ������
    BYTE byResolution;  	//�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(����ר��)
    BYTE byBitrateType;		//��������0:�����ʣ�1:������
    BYTE  byPicQuality;		//ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��
    DWORD dwVideoBitrate; 	//��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;	//֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20;
}NET_DVR_COMPRESSION_INFO, *LPNET_DVR_COMPRESSION_INFO;

//ͨ��ѹ������
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara; //¼��/�¼�����¼��
    NET_DVR_COMPRESSION_INFO struNetPara;	//��/����
}NET_DVR_COMPRESSIONCFG, *LPNET_DVR_COMPRESSIONCFG;

//����ѹ������(�ӽṹ)(��չ) ����I֡���
typedef struct
{
    BYTE byStreamType;		//��������0-��Ƶ��, 1-������
    BYTE byResolution;  	//�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(����ר��)
    BYTE byBitrateType;		//��������0:�����ʣ�1:������
    BYTE  byPicQuality;		//ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��
    DWORD dwVideoBitrate; 	//��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;	//֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0����14-15, 15-18, 16-22;
    WORD  wIntervalFrameI;  //I֡���
    //2006-08-11 ���ӵ�P֡�����ýӿڣ����Ը���ʵʱ����ʱ����
    BYTE  byIntervalBPFrame;//0-BBP֡; 1-BP֡; 2-��P֡
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX, *LPNET_DVR_COMPRESSION_INFO_EX;

//ͨ��ѹ������(��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara; //¼��
    NET_DVR_COMPRESSION_INFO_EX struNetPara;	//��
}NET_DVR_COMPRESSIONCFG_EX, *LPNET_DVR_COMPRESSIONCFG_EX;


//ʱ���¼���������(�ӽṹ)
typedef struct
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;	//0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&����, 5:�����, 6: ����¼��,10-PIR������11-���߱�����12-���ȱ�����13-���б���,14-���ܽ�ͨ�¼���15Խ����⣬16����������⣬17��Ƶ�쳣���
    char reservedData[3];
}NET_DVR_RECORDSCHED, *LPNET_DVR_RECORDSCHED;

//ȫ��¼���������(�ӽṹ)
typedef struct
{
    WORD wAllDayRecord;				/* �Ƿ�ȫ��¼�� 0-�� 1-��*/
                                    BYTE byRecordType;				/* ¼������ 0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����, 6: ����¼��,
                                                                    10-PIR������11-���߱�����12-���ȱ�����13-�ƶ�|��������|PIR|���߱���|���ȱ���,14-���ܽ�ͨ�¼�,15-Խ�����,16-��������,17-�����쳣,
                                    18-����������,19-������⣨Խ�����|��������|��������|�뿪����|����ʶ��,20���������, 21-POS¼��*/
                                    char reservedData;
}NET_DVR_RECORDDAY, *LPNET_DVR_RECORDDAY;

//ͨ��¼���������(9000��չ)
typedef struct
{
    DWORD	dwSize;
    DWORD	dwRecord;  						/*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY	struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED	struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD	dwRecordTime;					/* ¼����ʱ���� 0-5�룬 1-10�룬 2-30�룬 3-1���ӣ� 4-2���ӣ� 5-5���ӣ� 6-10����*/
    DWORD	dwPreRecordTime;				/* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
    DWORD	dwRecorderDuration;				/* ¼�񱣴���ʱ�� */
    BYTE	byRedundancyRec;	/*�Ƿ�����¼��,��Ҫ���˫���ݣ�0/1*/
    BYTE	byAudioRec;		/*¼��ʱ����������ʱ�Ƿ��¼��Ƶ��ݣ������д˷���*/
    BYTE	byStreamType;  // 0-��������1-��������2-��������ͬʱ 3-������
    BYTE	byPassbackRecord;  // 0:���ش�¼�� 1���ش�¼��
    WORD	wLockDuration;  // ¼����ʱ������λСʱ 0��ʾ����0xffff��ʾ������¼��ε�ʱ��������ĳ���ʱ����¼�񣬽�������
    BYTE	byRecordBackup;  // 0:¼�񲻴浵 1��¼��浵
    BYTE 	bySVCLevel;	//SVC��֡���ͣ�0-���飬1-�����֮һ 2-���ķ�֮��
    BYTE    byRecordManage;   //¼����ȣ�0-���ã� 1-������; ����ʱ���ж�ʱ¼�񣻲�����ʱ�����ж�ʱ¼�񣬵���¼��ƻ�����ʹ�ã������ƶ���⣬�ش������ڰ�����¼��ƻ�����
    BYTE	byExtraSaveAudio;		//��Ƶ�������0-�ǵ�����棬1-�������
    BYTE	byReserve[2];
}NET_DVR_RECORD_V30, *LPNET_DVR_RECORD_V30;

//ʱ���¼���������(�ӽṹ)
typedef struct
{
    NET_DVR_SCHEDTIME  struRecordTime;
    /*¼�����ͣ�0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����,
    6-���ܱ���¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼�,14-���ܽ�ͨ�¼�,
    15-Խ�����,16-��������,17-�����쳣,18-����������,
    19-�������(Խ�����|��������|�������|�����쳣|����������),20���������,21-POS¼��,
    22-�����������, 23-�뿪�������,24-�ǻ����,25-��Ա�ۼ����,26-�����˶����,27-ͣ�����,
    28-��Ʒ�������,29-��Ʒ��ȡ���,30-����⣬31-���ƻ����,32-��ܶ�Ź�¼�(˾��),33-�����¼�(˾��), 34-�˯�¼�(˾��)
    35-��ֻ���, 36-����Ԥ����37-���±���,*/
    BYTE byRecordType;
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

//ȫ��¼���������(�ӽṹ)
typedef struct
{
    BYTE byAllDayRecord; /* �Ƿ�ȫ��¼�� 0-�� 1-��*/
                         /*¼�����ͣ�0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����,
                         6-���ܱ���¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼�,14-���ܽ�ͨ�¼�,
                         15-Խ�����,16-��������,17-�����쳣,18-����������,
                         19-�������(Խ�����|��������|�������|�����쳣|����������),20���������,21-POS¼��,
                         22-�����������, 23-�뿪�������,24-�ǻ����,25-��Ա�ۼ����,26-�����˶����,27-ͣ�����,
                         28-��Ʒ�������,29-��Ʒ��ȡ���,30-����⣬31-���ƻ����,32-��ܶ�Ź�¼�(˾��),33-�����¼�(˾��), 34-�˯�¼�(˾��)
                         35-��ֻ���, 36-����Ԥ����37-���±���,*/
    BYTE byRecordType;
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct
{
    DWORD	dwSize;
    DWORD	dwRecord;  						/*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY_V40	struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40 struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD	dwRecordTime;					/* ¼����ʱ���� 0-5�룬 1-10�룬 2-30�룬 3-1���ӣ� 4-2���ӣ� 5-5���ӣ� 6-10����*/
    DWORD	dwPreRecordTime;				/* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
    DWORD	dwRecorderDuration;				/* ¼�񱣴���ʱ�� */
    BYTE	byRedundancyRec;	/*�Ƿ�����¼��,��Ҫ���˫���ݣ�0/1*/
    BYTE	byAudioRec;		/*¼��ʱ����������ʱ�Ƿ��¼��Ƶ��ݣ������д˷���*/
    BYTE	byStreamType;  // 0-��������1-��������2-��������ͬʱ 3-������
    BYTE	byPassbackRecord;  // 0:���ش�¼�� 1���ش�¼��
    WORD	wLockDuration;  // ¼����ʱ������λСʱ 0��ʾ����0xffff��ʾ������¼��ε�ʱ��������ĳ���ʱ����¼�񣬽�������
    BYTE	byRecordBackup;  // 0:¼�񲻴浵 1��¼��浵
    BYTE 	bySVCLevel;	//SVC��֡���ͣ�0-���飬1-�����֮һ 2-���ķ�֮��
    BYTE    byRecordManage;   //¼����ȣ�0-���ã� 1-������; ����ʱ���ж�ʱ¼�񣻲�����ʱ�����ж�ʱ¼�񣬵���¼��ƻ�����ʹ�ã������ƶ���⣬�ش������ڰ�����¼��ƻ�����
    BYTE	byExtraSaveAudio;//��Ƶ�����洢
    BYTE	byRes[126];
}NET_DVR_RECORD_V40, *LPNET_DVR_RECORD_V40;

//ͨ��¼���������
typedef struct
{
    DWORD dwSize;
    DWORD dwRecord;  /*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;	/* ¼��ʱ�䳤�� */
    DWORD dwPreRecordTime;	/* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
}NET_DVR_RECORD, *LPNET_DVR_RECORD;

//��̨Э���ṹ����
typedef struct
{
    DWORD dwType;               /*����������ֵ*/
    BYTE  byDescribe[DESC_LEN]; /*���������������8000�е�һ��*/
}NET_DVR_PTZ_PROTOCOL;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_PTZ_PROTOCOL struPtz[PTZ_PROTOCOL_NUM];/*���200��PTZЭ��*/
    DWORD   dwPtzNum;           /*��Ч��ptzЭ����Ŀ����0��ʼ(������ʱ��1)*/
    BYTE    byRes[8];
}NET_DVR_PTZCFG, *LPNET_DVR_PTZCFG;

/***************************��̨����(end)******************************/
typedef struct tagNET_DVR_SERIALSTART_V40   //͸��ͨ��
{
    DWORD  dwSize;         //�ṹ���С
    DWORD  dwSerialType;    //���ںţ�1-232���ڣ�2-485���ڣ�
    BYTE   bySerialNum;   //���ڱ��
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40,*LPNET_DVR_SERIALSTART_V40;

//ͨ��������(��̨)�������� ��չ
typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;       //�ṹ���С
    DWORD	 dwBaudRate;	   //������ 0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE	 byDataBit;	   //����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE	 byStopBit;	   //ֹͣλ 0��1λ��1��2λ
    BYTE	 byParity;	   //У�� 0����У�飬1����У�飬2��żУ��
    BYTE	 byFlowcontrol;  //0���ޣ�1��������,2-Ӳ����
    WORD	 wDecoderType;	//����������*/
    WORD	 wDecoderAddress;	//��������ַ��0-255
    BYTE	 bySetPreset [MAX_PRESET_V30];  //Ԥ�õ��Ƿ�����,0-û������,1-����
    BYTE	 bySetCruise[MAX_CRUISE_V30];  //Ѳ���Ƿ�����: 0-û������,1-����
    BYTE	 bySetTrack [MAX_TRACK_V30];	//�켣�Ƿ�����,0-û������,1-����
    BYTE	 bySerialNO;          //���ڱ��
    BYTE     byWorkMode; 	   /*����ģʽ�� 1-���󴮿ڿ��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PPPģʽ 5-����̨ģʽ 6-����ֱ�� 7-���̿��� 8-��ذ���� 9-������̨*/
    BYTE     byRes[254];         //����
}NET_DVR_DECODERCFG_V40,*LPNET_DVR_DECODERCFG_V40;

//ͨ��������(��̨)��������(9000��չ)
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;//������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;// ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    WORD wDecoderType;//����������, ��0��ʼ����ӦptzЭ���б��NET_DVR_IPC_PROTO_LIST�õ�
    WORD wDecoderAddress;	/*��������ַ:0 - 255*/
    BYTE bySetPreset[MAX_PRESET_V30];		/* Ԥ�õ��Ƿ�����,0-û������,1-����*/
    BYTE bySetCruise[MAX_CRUISE_V30];		/* Ѳ���Ƿ�����: 0-û������,1-���� */
    BYTE bySetTrack[MAX_TRACK_V30];		    /* �켣�Ƿ�����,0-û������,1-����*/
}NET_DVR_DECODERCFG_V30, *LPNET_DVR_DECODERCFG_V30;

//ͨ��������(��̨)��������
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;       //������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;         // ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;         // ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;          // У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;     // 0���ޣ�1��������,2-Ӳ����
    WORD wDecoderType;      //����������  NET_DVR_IPC_PROTO_LIST�еõ�
    WORD wDecoderAddress;	/*��������ַ:0 - 255*/
    BYTE bySetPreset[MAX_PRESET];		/* Ԥ�õ��Ƿ�����,0-û������,1-����*/
    BYTE bySetCruise[MAX_CRUISE];		/* Ѳ���Ƿ�����: 0-û������,1-���� */
    BYTE bySetTrack[MAX_TRACK];		/* �켣�Ƿ�����,0-û������,1-����*/
}NET_DVR_DECODERCFG, *LPNET_DVR_DECODERCFG;

//ppp��������(�ӽṹ)
typedef struct
{
    NET_DVR_IPADDR struRemoteIP;	//Զ��IP��ַ
    NET_DVR_IPADDR struLocalIP;		//����IP��ַ
    char sLocalIPMask[16];			//����IP��ַ����
    BYTE sUsername[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    BYTE byPPPMode;					//PPPģʽ, 0��������1������
    BYTE byRedial;					//�Ƿ�ز� ��0-��,1-��
    BYTE byRedialMode;				//�ز�ģʽ,0-�ɲ�����ָ��,1-Ԥ�ûز�����
    BYTE byDataEncrypt;				//��ݼ���,0-��,1-��
    DWORD dwMTU;					//MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //�绰����
}NET_DVR_PPPCFG_V30, *LPNET_DVR_PPPCFG_V30;

//ppp��������(�ӽṹ)
typedef struct
{
    char sRemoteIP[16];				//Զ��IP��ַ
    char sLocalIP[16];				//����IP��ַ
    char sLocalIPMask[16];			//����IP��ַ����
    BYTE sUsername[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    BYTE byPPPMode;					//PPPģʽ, 0��������1������
    BYTE byRedial;					//�Ƿ�ز� ��0-��,1-��
    BYTE byRedialMode;				//�ز�ģʽ,0-�ɲ�����ָ��,1-Ԥ�ûز�����
    BYTE byDataEncrypt;				//��ݼ���,0-��,1-��
    DWORD dwMTU;					//MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //�绰����
}NET_DVR_PPPCFG, *LPNET_DVR_PPPCFG;

//RS232���ڲ�������(9000��չ)
typedef struct
{
    DWORD dwBaudRate;   /*������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;*/
    BYTE byDataBit;     /* ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ */
    BYTE byStopBit;     /* ֹͣλ 0��1λ��1��2λ */
    BYTE byParity;      /* У�� 0����У�飬1����У�飬2��żУ�� */
    BYTE byFlowcontrol; /* 0���ޣ�1��������,2-Ӳ���� */
    DWORD dwWorkMode;   //����ģʽ��0��232��������PPP���ţ�1��232�������ڲ�����ƣ�2��͸��ͨ�� 3- ptzģʽ,��Ѷ��ʪ�ȴ�����, 4-������ģʽ  5-���󴮿ڿ��� 6-��Ļ���� 7-����ֱ�� 8-���̿��� 9-��ذ���� 10-������̨
}NET_DVR_SINGLE_RS232;

typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate;   /*������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;*/
    BYTE byDataBit;     /* ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ */
    BYTE byStopBit;     /* ֹͣλ 0��1λ��1��2λ */
    BYTE byParity;      /* У�� 0����У�飬1����У�飬2��żУ�� */
    BYTE byFlowcontrol; /* 0���ޣ�1��������,2-Ӳ���� */
    BYTE byVirtualSerialPort;  //���⴮�ڱ��
    BYTE byRes[3];
}NET_DVR_USB_RS232,*LPNET_DVR_USB_RS232;

//RS232���ڲ�������(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*ע�⣺�˽ṹ�޸��ˣ�ԭ���ǵ����ṹ�������޸�Ϊ������ṹ*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30, *LPNET_DVR_RS232CFG_V30;

//RS232���ڲ�������
typedef struct
{
    DWORD dwSize;
    DWORD dwBaudRate;//������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;// ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    DWORD dwWorkMode;// ����ģʽ��0��խ����(232��������PPP����)��1������̨(232�������ڲ������)��2��͸��ͨ��
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG, *LPNET_DVR_RS232CFG;


typedef struct
{
    DWORD dwEnablePresetChan;	/*����Ԥ�õ��ͨ��, 0xfffffff��ʾ������Ԥ�õ�*/
    DWORD dwPresetPointNo;		/*����Ԥ�õ�ͨ����Ӧ��Ԥ�õ����, 0xfffffff��ʾ������Ԥ�õ㡣*/
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct
{
    DWORD dwEnableCruiseChan;	/*����Ѳ����ͨ��*/
    DWORD dwCruiseNo;		/*Ѳ��ͨ����Ӧ��Ѳ�����, 0xfffffff��ʾ��Ч*/
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct
{
    DWORD dwEnablePtzTrackChan;	/*������̨�켣��ͨ��*/
    DWORD dwPtzTrackNo;		/*��̨�켣ͨ����Ӧ�ı��, 0xfffffff��ʾ��Ч*/
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;


//���������������(256·NVR��չ)
typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];	/* ��� */
    BYTE byAlarmType;	            //����������,0������,1������
    BYTE byAlarmInHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byRes1;                    //����
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOutChanNum; //�����ı������ͨ���� ʵ��֧����
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //��������ͨ��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    /*������¼��ͨ��*/
    DWORD   dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD   dwCurRecordChanNum;    //��ǰʵ�������õĹ���¼��ͨ����
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];	 /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - dwCurRecordChanNum -1��Ч������м�����0xffffffff,�������Ч*/
    DWORD   dwMaxEnablePtzCtrlNun; //�������õ���̨��������(ֻ��)
    DWORD   dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ
    BYTE    byRes2[516];					/*����*/
    DWORD   dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ
    DWORD   dwEnablePtzTrackChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ
    BYTE    byRes[256];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

//���������������(9000��չ)
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];	/* ��� */
    BYTE byAlarmType;	            //����������,0������,1������
    BYTE byAlarmInHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byRes1;
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byEnablePreset[MAX_CHANNUM_V30];		/* �Ƿ����Ԥ�õ� 0-��,1-��*/
    BYTE byPresetNo[MAX_CHANNUM_V30];			/* ���õ���̨Ԥ�õ����,һ������������Ե��ö��ͨ������̨Ԥ�õ�, 0xff��ʾ������Ԥ�õ㡣*/
    BYTE byRes2[192];					/*����*/
    BYTE byEnableCruise[MAX_CHANNUM_V30];		/* �Ƿ����Ѳ�� 0-��,1-��*/
    BYTE byCruiseNo[MAX_CHANNUM_V30];			/* Ѳ�� */
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];		/* �Ƿ���ù켣 0-��,1-��*/
    BYTE byPTZTrack[MAX_CHANNUM_V30];			/* ���õ���̨�Ĺ켣��� */
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30, *LPNET_DVR_ALARMINCFG_V30;


typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    DWORD dwAlarmType;              /*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ��3���ƶ���⣬4��Ӳ��δ��ʽ��,5-дӲ�̳���,6-�ڵ�������7-��ʽ��ƥ��, 8-�Ƿ����ʣ�9-��Ƶ�ź��쳣��10-¼���쳣��11-���ܳ����仯��12-�����쳣��13-ǰ��/¼��ֱ��ʲ�ƥ��*/
    NET_DVR_TIME_EX struAlarmTime;	//������ʱ��
    union
    {
        BYTE	byUnionLen[128];
        struct
        {
            DWORD	dwAlarmInputNo;		//�����ı�������ͨ���ţ�һ��ֻ��һ��
            DWORD	dwTrigerAlarmOutNum;	/*�����ı�������������ں������䳤��ݲ��������д����ı������ͨ���ţ����ֽڱ�ʾһ��*/
            DWORD	dwTrigerRecordChanNum;	/*������¼��ͨ���������ں������䳤��ݲ��������д�����¼��ͨ���ţ����ֽڱ�ʾһ��*/
        }struIOAlarm;	// ��������dwAlarmTypeΪ0ʱ��Ч
        struct
        {
            DWORD	dwAlarmChanNum;	/*����ͨ����ݸ������ں������䳤��ݲ��������з���ı���ͨ���ţ����ֽڱ�ʾһ��*/
        }struAlarmChannel;	// dwAlarmTypeΪ2��3��6��9��10��13ʱ��Ч
        struct
        {
            DWORD	dwAlarmHardDiskNum;	/*������Ӳ����ݳ��ȣ����ں������䳤��ݲ��������з�����Ӳ�̺ţ��Ľڱ�ʾһ��*/
        }struAlarmHardDisk;	// dwAlarmTypeΪ1,4,5ʱ��Ч
        struct
        {
            BYTE       bySubAlarmType;  //���������ͣ�1-һ���ӳ�¼��
            BYTE       byRes1[3]; //����
            NET_DVR_TIME_EX  struRecordEndTime; //¼������ʱ��
            BYTE    byRes[116]; //����
        }struRecordingHost;  //¼������ר�ñ���
    }uStruAlarm;
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

//�ϴ�������Ϣ(256·NVR��չ)
typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER 	struAlarmFixedHeader;	//�����̶�����
    DWORD*		        		pAlarmData;	//�����ɱ䲿������
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

//���������������
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];	/* ��� */
    BYTE byAlarmType;	//����������,0������,1������
    BYTE byAlarmInHandle;	/* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byRes;
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byEnablePreset[MAX_CHANNUM];		/* �Ƿ����Ԥ�õ� 0-��,1-��*/
    BYTE byPresetNo[MAX_CHANNUM];			/* ���õ���̨Ԥ�õ����,һ������������Ե��ö��ͨ������̨Ԥ�õ�, 0xff��ʾ������Ԥ�õ㡣*/
    BYTE byEnableCruise[MAX_CHANNUM];		/* �Ƿ����Ѳ�� 0-��,1-��*/
    BYTE byCruiseNo[MAX_CHANNUM];			/* Ѳ�� */
    BYTE byEnablePtzTrack[MAX_CHANNUM];		/* �Ƿ���ù켣 0-��,1-��*/
    BYTE byPTZTrack[MAX_CHANNUM];			/* ���õ���̨�Ĺ켣��� */
}NET_DVR_ALARMINCFG, *LPNET_DVR_ALARMINCFG;

//ģ�ⱨ�������������
typedef struct
{
    DWORD 	dwSize;
    BYTE		byEnableAlarmHandle; //���?������
    BYTE		byRes1[3];
    BYTE		byAlarmInName[NAME_LEN]; //ģ�ⱨ���������
    WORD		wAlarmInUpper; //ģ�������ѹ���ޣ�ʵ��ֵ��10����Χ0~360
    WORD		wAlarmInLower; //ģ�������ѹ���ޣ�ʵ��ֵ��10����Χ0~360
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    BYTE		byRelRecordChan[MAX_CHANNUM_V30]; //��������¼��ͨ��
    BYTE		byRes2[100];
}NET_DVR_ANALOG_ALARMINCFG, *LPNET_DVR_ANALOG_ALARMINCFG;

//�ϴ�������Ϣ(9000��չ)
typedef struct
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣,
                      10-¼���쳣,11- ���ܳ����仯,12-�����쳣,13-ǰ��/¼��ֱ��ʲ�ƥ��,14-���������Դʧ��,15-�������, 16-POE�����쳣����,17-������쳣,
    18-��������쳣����,19-��Ƶ��ʧ*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*����������˿ڣ�Ϊ1��ʾ��Ӧ���*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*������¼��ͨ����Ϊ1��ʾ��Ӧ¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmTypeΪ2��3,6,9,10,14,19ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]��Ӧ��1��Ӳ��*/
    #ifdef SDK_CHEZAI
    NET_DVR_ADDIT_POSITION GPS_pos;  /* GPS��λ��Ϣ */
    #endif
}NET_DVR_ALARMINFO_V30, *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;   //�ṹ��
    DWORD  dwExceptionCase;   //����ԭ��   0-�����쳣
    NET_DVR_IPADDR  struDeviceIP;    //�����쳣���豸IP��ַ
    BYTE    byRes[256];         //����
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*����������˿ڣ���һλΪ1��ʾ��Ӧ��һ�����*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*������¼��ͨ������һλΪ1��ʾ��Ӧ��һ·¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmTypeΪ2��3,6,9,10ʱ����ʾ�ĸ�ͨ����dwChannel[0]λ��Ӧ��1��ͨ��*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]λ��Ӧ��1��Ӳ��*/
}NET_DVR_ALARMINFO, *LPNET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IPC�����������
/* IP�豸�ṹ */
typedef struct
{
    DWORD dwEnable;				    /* ��IP�豸�Ƿ����� */
    BYTE sUserName[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];	    /* ���� */
    NET_DVR_IPADDR struIP;			/* IP��ַ */
    WORD wDVRPort;			 	    /* �˿ں� */
    BYTE byRes[34];				/* ���� */
}NET_DVR_IPDEVINFO, *LPNET_DVR_IPDEVINFO;

#define  DEV_ID_LEN  		 32    //�豸ID����

//ipc�����豸��Ϣ��չ��֧��ip�豸���������
typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;				    //��IP�豸�Ƿ���Ч
    BYTE byProType;					//Э�����ͣ�0-˽��Э�飬1-����Э�飬2-����
    BYTE byEnableQuickAdd;        // 0 ��֧�ֿ������  1 ʹ�ÿ������
    // ���������Ҫ�豸IP��Э�����ͣ�������Ϣ���豸Ĭ��ָ��
    BYTE byRes1;					//�����ֶΣ���0
    BYTE sUserName[NAME_LEN];		//�û���
    BYTE sPassword[PASSWD_LEN];	    //����
    BYTE byDomain[MAX_DOMAIN_NAME];	//�豸����
    NET_DVR_IPADDR struIP;			//IP��ַ
    WORD wDVRPort;			 	    // �˿ں�
    BYTE  szDeviceID[DEV_ID_LEN];  //�豸ID
    BYTE byRes2[2];				//�����ֶΣ���0
}NET_DVR_IPDEVINFO_V31, *LPNET_DVR_IPDEVINFO_V31;

/* IPͨ��ƥ����� */
typedef struct
{
    BYTE byEnable;					/* ��ͨ���Ƿ����� */
    BYTE byIPID;					//IP�豸ID��8λ�����豸IDΪ0ʱ��ʾͨ��������
    BYTE byChannel;					/* ͨ���� */
    BYTE byIPIDHigh;                // IP�豸ID�ĸ�8λ
    BYTE byTransProtocol;		    //����Э������0-TCP/auto(�������豸����)��1-UDP 2-�ಥ 3-��TCP 4-auto
    BYTE byres[31];					/* ���� */
} NET_DVR_IPCHANINFO, *LPNET_DVR_IPCHANINFO;

/* IP�������ýṹ */
typedef struct
{
    DWORD dwSize;			                            /* �ṹ��С */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];    /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-32ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];	/* IPͨ�� */
}NET_DVR_IPPARACFG, *LPNET_DVR_IPPARACFG;
/* ��չIP�������ýṹ */
typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;			                            /* �ṹ��С */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];    /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-32ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];	/* IPͨ�� */
}NET_DVR_IPPARACFG_V31, *LPNET_DVR_IPPARACFG_V31;

typedef  struct tagNET_DVR_IPSERVER_STREAM
{
    BYTE    byEnable;   // �Ƿ�����
    BYTE    byRes[3];               // �����ֽ�
    NET_DVR_IPADDR struIPServer;    //IPServer ��ַ
    WORD    wPort;                  //IPServer �˿�
    WORD    wDvrNameLen;            // DVR ��Ƴ���
    BYTE    byDVRName[NAME_LEN];    // DVR���
    WORD    wDVRSerialLen;          // ���кų���
    WORD    byRes1[2];              // �����ֽ�
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR���кų���
    BYTE    byUserName[NAME_LEN];   // DVR ��½�û���
    BYTE    byPassWord[PASSWD_LEN]; // DVR��½����
    BYTE    byChannel;              // DVR ͨ��
    BYTE    byRes2[11];             //  �����ֽ�
}NET_DVR_IPSERVER_STREAM, *LPNET_DVR_IPSERVER_STREAM;

//��ý�������������
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE	byValid;			/*�Ƿ����*/
    BYTE	byRes1[3];
    NET_DVR_IPADDR  struDevIP;
    WORD	wDevPort;			/*��ý��������˿�*/
    BYTE	byTransmitType;		/*����Э������ 0-TCP��1-UDP*/
    BYTE	byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

//�豸ͨ����Ϣ
typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR 	struIP;		    //DVR IP��ַ
    WORD 	wDVRPort;			 	//�˿ں�
    BYTE 	byChannel;				//ͨ����
    BYTE	byTransProtocol;		//����Э������0-TCP��1-UDP
    BYTE	byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE	byFactoryType;			/*ǰ���豸��������,ͨ��ӿڻ�ȡ*/
    BYTE	byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ�����Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE	bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE	byResolution;	//; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã��������������ݸò�����������Դ
    BYTE	byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];	//�豸����
    BYTE	sUserName[NAME_LEN];	//��������½�ʺ�
    BYTE	sPassword[PASSWD_LEN];	//�����������
}NET_DVR_DEV_CHAN_INFO,*LPNET_DVR_DEV_CHAN_INFO;

//ֱ��ͨ����ý��ȡ��
typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD								dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG	struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO				struDevChanInfo;
}NET_DVR_PU_STREAM_CFG,*LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   // �Ƿ�����
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;            //��ý���������ַ
    WORD   wStreamServerPort;           //��ý��������˿�
    BYTE   byStreamServerTransmitType;  //��ý�崫��Э������ 0-TCP��1-UDP
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;          //IPSERVER��ַ
    WORD   wIPServerPort;        //IPserver�˿ں�
    BYTE   byRes3[2];
    BYTE   sDVRName[NAME_LEN];   //DVR���
    WORD   wDVRNameLen;            // DVR��Ƴ���
    WORD   wDVRSerialLen;          // ���кų���
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    // DVR���к�
    BYTE   sUserName[NAME_LEN];   // DVR ��½�û���
    BYTE   sPassWord[PASSWD_LEN]; // DVR��½����
    WORD   wDVRPort;   //DVR�˿ں�
    BYTE   byRes4[2];
    BYTE   byChannel;              // DVR ͨ��
    BYTE   byTransProtocol; //����Э������0-TCP��1-UDP
    BYTE   byTransMode; //��������ģʽ 0�������� 1��������
    BYTE   byFactoryType; //ǰ���豸��������,ͨ��ӿڻ�ȡ
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

#define URL_LEN     240   //URL����
typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable;
    BYTE    strURL[URL_LEN];
    BYTE	byTransPortocol ; // ����Э������ 0-tcp  1-UDP
    WORD    wIPID;  //�豸ID�ţ�wIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE	byChannel;  //ͨ����
    BYTE    byRes[7];
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;				 // �Ƿ�����
    BYTE    byRes[3];               // �����ֽ�
    BYTE    byDDNSDomain[64];		// hiDDNS������
    WORD    wPort;                  // hiDDNS �˿�
    WORD    wAliasLen;              // �����
    BYTE    byAlias[NAME_LEN];		 // ����
    WORD    wDVRSerialLen;          // ���кų���
    BYTE    byRes1[2];              // �����ֽ�
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR���к�
    BYTE    byUserName[NAME_LEN];   // DVR ��½�û���
    BYTE    byPassWord[PASSWD_LEN]; // DVR��½����
    BYTE    byChannel;              // DVRͨ��
    BYTE    byRes2[11];             // ������
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;				/* ��ͨ���Ƿ����� */
    BYTE    byRes1;
    WORD    wIPID;                  //IP�豸ID
    DWORD 	dwChannel;				//ͨ����
    BYTE	byTransProtocol;		//����Э������0-TCP��1-UDP
    BYTE	byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE	byFactoryType;			/*ǰ���豸��������,ͨ��ӿڻ�ȡ*/
    BYTE	byRes[241];
}NET_DVR_IPCHANINFO_V40,*LPNET_DVR_IPCHANINFO_V40;

// ��ŵCVR
#define MAX_ID_COUNT    256
#define MAX_STREAM_ID_COUNT    1024
#define STREAM_ID_LEN   32
#define PLAN_ID_LEN  32
#define DEVICE_NO_LEN  24
#define MAX_VOLUMENAME_LEN 32  //¼������
#define MAX_VAG_CHANNO_LEN  32  //VAGЭ��ȡ��ʱͨ���ű��볤��

#define MAX_STREAM_ID_NUM	30		//�����ID��Ŀ

// ����Ϣ - 72�ֽڳ�
typedef struct tagNET_DVR_STREAM_INFO
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID���
    DWORD dwChannel;                //�����豸ͨ��������0xffffffffʱ����ʾ������
    BYTE  byRes[32];                //����
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{
    BYTE    byEnable;
    BYTE    byLocalBackUp; //�Ƿ񱾵ر���
    BYTE    byRes[2];
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;   //Э������
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //ǰ��IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD    wPort;
    BYTE    byRes1[122];             //����
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;

typedef union tagNET_DVR_GET_STREAM_UNION
{
    NET_DVR_IPCHANINFO      struChanInfo;	/*IPͨ����Ϣ*/
    NET_DVR_IPSERVER_STREAM struIPServerStream;  // IPServerȥ��
    NET_DVR_PU_STREAM_CFG   struPUStream;     //  ͨ��ǰ���豸��ȡ��ý��ȥ��
    NET_DVR_DDNS_STREAM_CFG struDDNSStream;     //ͨ��IPServer����ý��ȡ��
    NET_DVR_PU_STREAM_URL   struStreamUrl;        //ͨ����ý�嵽urlȡ��
    NET_DVR_HKDDNS_STREAM	struHkDDNSStream;   //ͨ��hiDDNSȥȡ��
    NET_DVR_IPCHANINFO_V40 struIPChan; //ֱ�Ӵ��豸ȡ������չ��
}NET_DVR_GET_STREAM_UNION, *LPNET_DVR_GET_STREAM_UNION;

typedef enum
{
    NET_SDK_IP_DEVICE = 0,
        NET_SDK_STREAM_MEDIA,
        NET_SDK_IPSERVER,
        NET_SDK_DDNS_STREAM_CFG,
        NET_SDK_STREAM_MEDIA_URL,
        NET_SDK_HKDDNS,
        NET_SDK_IP_DEVICE_ADV,
        NET_SDK_IP_DEVICE_V40,
        NET_SDK_RTSP
}GET_STREAM_TYPE;

typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //ȡ����ʽGET_STREAM_TYPE��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��,3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸����
    //4-ͨ����ý����URLȥȡ��,5-ͨ��hkDDNSȡ����6-ֱ�Ӵ��豸ȡ��(��չ)��ʹ��NET_DVR_IPCHANINFO_V40�ṹ, 7-ͨ��RTSPЭ�鷽ʽ����ȡ��
    BYTE    byRes[3];        //�����ֽ�
    NET_DVR_GET_STREAM_UNION uGetStream;    // ��ͬȡ����ʽ�ṹ��
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;

//��չIP���������豸
typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;			                /* �ṹ��С */
    DWORD	   dwGroupNum;					//	 �豸֧�ֵ�������
    DWORD      dwAChanNum;					//���ģ��ͨ������
    DWORD      dwDChanNum;                  //����ͨ������
    DWORD      dwStartDChan;		            //��ʼ����ͨ��
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-64ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      /* IP�豸 */
    NET_DVR_STREAM_MODE  struStreamMode[MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 // �����ֽ�
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;


//ΪCVR��չ�ı�������
typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;  //0-������(ͨ��)�ź���������1-˽�о���𻵣�2- NVR�����˳���
    //3-������״̬�쳣��4-ϵͳʱ���쳣��5-¼���ʣ��������ͣ�
    //6-������(ͨ��)�ƶ���ⱨ����7-������(ͨ��)�ڵ���������8-¼��ʧ����; 9-��Ƶʵʱ��ⱨ��; 10-��Դʹ���ʸ澯; 11- CVR�Զ��޸��쳣�� 12-¼���쳣
    NET_DVR_TIME   struTime;     //����ʱ��
    BYTE       byRes[32];    //����
    DWORD      dwNumber;     //��Ŀ
    WORD       *pNO;         //dwNumber��WORD; ÿ��WORD��ʾһ��ͨ���ţ����ߴ��̺�, ��ЧʱΪ0
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

/* ����������� */
typedef struct
{
    BYTE byIPID;					/* IP�豸IDȡֵ1- MAX_IP_DEVICE */
    BYTE byAlarmOut;				/* ��������� */
    BYTE byRes[18];					/* ���� */
}NET_DVR_IPALARMOUTINFO, *LPNET_DVR_IPALARMOUTINFO;

/* IP����������ýṹ */
typedef struct
{
    DWORD dwSize;			                        /* �ṹ��С */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];/* IP������� */
}NET_DVR_IPALARMOUTCFG, *LPNET_DVR_IPALARMOUTCFG;

/* IP����������� */
typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;					/* IP�豸ID */
    DWORD dwAlarmOut;				/* IP�豸ID��Ӧ�ı�������� */
    BYTE  byRes[32];				/* ���� */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;/*�����������*/

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;  //�ṹ�峤��
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];/*IP�������*/
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40; /*IP�������*/

/* ����������� */
typedef struct
{
    BYTE byIPID;					/* IP�豸IDȡֵ1- MAX_IP_DEVICE */
    BYTE byAlarmIn;					/* ��������� */
    BYTE byRes[18];					/* ���� */
}NET_DVR_IPALARMININFO, *LPNET_DVR_IPALARMININFO;

/* IP�����������ýṹ */
typedef struct
{
    DWORD dwSize;			                        /* �ṹ��С */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];/* IP�������� */
}NET_DVR_IPALARMINCFG, *LPNET_DVR_IPALARMINCFG;

/* IP����������� */
typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;					/* IP�豸ID */
    DWORD dwAlarmIn;				/* IP�豸ID��Ӧ�ı�������� */
    BYTE  byRes[32];				/* ���� */
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;   /* ����������� */

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;  //�ṹ�峤��
    DWORD   dwCurIPAlarmInNum;  //��ǰ�����������
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];/* IP��������*/
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40; /*IP����������Դ*/

//ipc alarm info
typedef struct tagNET_DVR_IPALARMINFO
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];            /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];	        /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */
}NET_DVR_IPALARMINFO, *LPNET_DVR_IPALARMINFO;

//ipc���øı䱨����Ϣ��չ 9000_1.1
typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];            /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];	        /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */
}NET_DVR_IPALARMINFO_V31, *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];           // IP�豸
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];           /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];	        /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */
    BYTE                    byRes[20];                          // �����ֽ�
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;

typedef enum _HD_STAT_
{
    HD_STAT_OK					=	0,    /* �� */
        HD_STAT_UNFORMATTED			=	1,    /* δ��ʽ�� */
        HD_STAT_ERROR           	=	2,    /* ���� */
        HD_STAT_SMART_FAILED    	=	3,    /* SMART״̬ */
        HD_STAT_MISMATCH        	=	4,    /* ��ƥ�� */
        HD_STAT_IDLE            	=	5,    /* ����*/
        NET_HD_STAT_OFFLINE     	=	6,    /* �����̴���δ����״̬ */
        HD_RIADVD_EXPAND            =   7,    /* ������̿����� */
        HD_STAT_REPARING            =   10,   /* Ӳ�������޸�(9000 2.0) */
        HD_STAT_FORMATING           =   11,   /* Ӳ�����ڸ�ʽ��(9000 2.0) */
}HD_STAT;


//����Ӳ����Ϣ����
typedef struct
{
    DWORD dwHDNo;         /*Ӳ�̺�, ȡֵ0~MAX_DISKNUM_V30-1*/
    DWORD dwCapacity;     /*Ӳ������(��������)*/
    DWORD dwFreeSpace;    /*Ӳ��ʣ��ռ�(��������)*/
    DWORD dwHdStatus;     //Ӳ��״̬(��������) HD_STAT 0-��, 1-δ��ʽ��, 2-����, 3-SMART״̬,
    //4-��ƥ��, 5-���� 6-����Ӳ�̲����� 7-������̿����� 10-Ӳ�������޸�
    //11-Ӳ�����ڸ�ʽ�� 12-Ӳ�����ڵȴ��ʽ�� 13-Ӳ����ж�� 14-����Ӳ�̲�����
    //15-����ɾ��(����Ӳ��),16-����
    BYTE  byHDAttr;       /*0-��ͨ, 1-����; 2-ֻ�� 3-�浵��CVRר�ã���4-���ɶ�д*/
    BYTE  byHDType;		  /*0-����Ӳ��,1-ESATAӲ��,2-NASӲ��,3-iSCSIӲ�� 4-Array�������,5-SD��*/
    BYTE  byDiskDriver;   // ֵ �����ASCII�ַ�
    BYTE  byRes1;
    DWORD dwHdGroup;      /*�����ĸ����� 1-MAX_HD_GROUP*/
    BYTE  byRecycling;   // �Ƿ�ѭ������ 0����ѭ�����ã�1��ѭ������
    BYTE  byRes2[3];
    DWORD  dwStorageType;    //��λ��ʾ 0-��֧�� ��0-֧��
    // dwStorageType & 0x1 ��ʾ�Ƿ�����ͨ¼��ר�ô洢��
    // dwStorageType & 0x2  ��ʾ�Ƿ��ǳ�֡¼��ר�ô洢��
    // dwStorageType & 0x4 ��ʾ�Ƿ���ͼƬ¼��ר�ô洢��

    DWORD dwPictureCapacity; //Ӳ��ͼƬ����(��������)����λ:MB
    DWORD dwFreePictureSpace; //ʣ��ͼƬ�ռ�(��������)����λ:MB
    BYTE  byRes3[104];
}NET_DVR_SINGLE_HD, *LPNET_DVR_SINGLE_HD;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;          /*Ӳ����(��������)*/
    NET_DVR_SINGLE_HD struHDInfo[MAX_DISKNUM_V30];//Ӳ����ز�������Ҫ����������Ч��
}NET_DVR_HDCFG, *LPNET_DVR_HDCFG;

//����������Ϣ������չ
typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD 	dwHDGroupNo;       /*�����(��������) 1-MAX_HD_GROUP*/
    DWORD  	dwRelRecordChan[MAX_CHANNUM_V40];  //������¼��ͨ������ֵ��ʾ������0xffffffffʱ������Ϊ��Ч
    BYTE   	byRes[64];				/* ���� */
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD  	dwSize;                //�ṹ���С
    DWORD     dwMaxHDGroupNum; 		  //�豸֧�ֵ����������-ֻ��
    DWORD     dwCurHDGroupNum;       /*��ǰ���õ�������*/
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //Ӳ����ز�������Ҫ����������Ч��
    BYTE   	byRes[128]; //����
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;

//����������Ϣ����
typedef struct
{
    DWORD dwHDGroupNo;       /*�����(��������) 1-MAX_HD_GROUP*/
    BYTE byHDGroupChans[MAX_CHANNUM_V30]; /*�����Ӧ��¼��ͨ��, 0-��ʾ��ͨ����¼�󵽸����飬1-��ʾ¼�󵽸�����*/
    BYTE byRes[8];
}NET_DVR_SINGLE_HDGROUP, *LPNET_DVR_SINGLE_HDGROUP;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDGroupCount;        /*��������(��������)*/
    NET_DVR_SINGLE_HDGROUP struHDGroupAttr[MAX_HD_GROUP];//Ӳ����ز�������Ҫ����������Ч��
}NET_DVR_HDGROUP_CFG, *LPNET_DVR_HDGROUP_CFG;


//�������Ų���Ľṹ
typedef struct
{
    DWORD dwSize;
    DWORD dwMajorScale;    /* ����ʾ 0-�����ţ�1-����*/
    DWORD dwMinorScale;    /* ����ʾ 0-�����ţ�1-����*/
    DWORD dwRes[2];
}NET_DVR_SCALECFG, *LPNET_DVR_SCALECFG;



//DVR�������(9000��չ)
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];	/* ��� */
    DWORD dwAlarmOutDelay;	/* �������ʱ��(-1Ϊ���ޣ��ֶ��ر�) */
    //0-5��,1-10��,2-30��,3-1����,4-2����,5-5����,6-10����,7-�ֶ�
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30];/* �����������ʱ��� */
    BYTE byRes[16];
}NET_DVR_ALARMOUTCFG_V30, *LPNET_DVR_ALARMOUTCFG_V30;

//DVR�������
typedef struct
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];	/* ��� */
    DWORD dwAlarmOutDelay;	/* �������ʱ��(-1Ϊ���ޣ��ֶ��ر�) */
    //0-5��,1-10��,2-30��,3-1����,4-2����,5-5����,6-10����,7-�ֶ�, 8-1��, 9-3��
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];/* �����������ʱ��� */
}NET_DVR_ALARMOUTCFG, *LPNET_DVR_ALARMOUTCFG;

//DVR����Ԥ������(9000��չ)
/*�л���ָ�ڵ�ǰԤ��ģʽ���л���ʾ���棬�����л�Ԥ��ģʽ������byPreviewNumberΪ0��1���棩��bySwitchSeq[0][0] = 1,bySwitchSeq[0][1] = 2,bySwitchSeq[0][2] = 3
�򱾵ػ���һֱ��1���棬Ȼ����������水1,2,3ͨ��˳���л�*/
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber;//Ԥ��ģʽ,0-1����,1-4����,2-9����,3-16����,0xff:�����
    BYTE byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
    WORD wSwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30];//�л�˳��,���lSwitchSeq[i]Ϊ 0xff��ʾ����
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30, *LPNET_DVR_PREVIEWCFG_V30;

//DVR����Ԥ������
typedef struct
{
    DWORD dwSize;
    BYTE byPreviewNumber;//Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16����,0xff:�����
    BYTE byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
    WORD wSwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_WINDOW];//�л�˳��,���lSwitchSeq[i]Ϊ 0xff��ʾ����
}NET_DVR_PREVIEWCFG, *LPNET_DVR_PREVIEWCFG;

//DVR��Ƶ���
typedef struct
{
    WORD wResolution;							/* �ֱ��� */
    WORD wFreq;									/* ˢ��Ƶ�� */
    DWORD dwBrightness;							/* ���� */
}NET_DVR_VGAPARA;

/*
* MATRIX�������ṹ
*/
typedef struct
{
    WORD	wOrder[MAX_ANALOG_CHANNUM];		/* Ԥ��˳��, 0xff��ʾ��Ӧ�Ĵ��ڲ�Ԥ�� */
    WORD	wSwitchTime;				/* Ԥ���л�ʱ�� */
    BYTE	res[14];
}NET_DVR_MATRIXPARA_V30, *LPNET_DVR_MATRIXPARA_V30;

typedef struct
{
    WORD wDisplayLogo;						/* ��ʾ��Ƶͨ���� */
    WORD wDisplayOsd;						/* ��ʾʱ�� */
}NET_DVR_MATRIXPARA;

typedef struct
{
    BYTE byVideoFormat;						/* �����ʽ,0-PAL,1-NTSC */
    BYTE byMenuAlphaValue;					/* �˵��뱳��ͼ��Աȶ� */
    WORD wScreenSaveTime;					/* ��Ļ����ʱ�� 0-�Ӳ�,1-1����,2-2����,3-5����,4-10����,5-20����,6-30���� */
    WORD wVOffset;							/* ��Ƶ���ƫ�� */
    WORD wBrightness;						/* ��Ƶ������� */
    BYTE byStartMode;						/* ��������Ƶ���ģʽ(0:�˵�,1:Ԥ��)*/
    BYTE byEnableScaler;                    /* �Ƿ��������� (0-������, 1-����)*/
}NET_DVR_VOOUT;

//DVR��Ƶ���(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];	/* VGA���� */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];		/* MATRIX���� */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30, *LPNET_DVR_VIDEOOUT_V30;

//DVR��Ƶ���
typedef struct
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];	/* VGA���� */
    NET_DVR_MATRIXPARA struMatrixPara;		/* MATRIX���� */
}NET_DVR_VIDEOOUT, *LPNET_DVR_VIDEOOUT;


//���û�����(�ӽṹ)(��չ)
typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE	sUserName[NAME_LEN];			/* �û���ֻ����16�ֽ� */
    BYTE	sPassword[PASSWD_LEN];			/* ���� */
    BYTE    byLocalRight[MAX_RIGHT];	/* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(���ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */
    BYTE    byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(���ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];			/* Զ�̿���Ԥ����ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];			/* ���ؿ���¼���ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];			/* Զ�̿���¼���ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];			/* ���ؿ��Իطŵ�ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];			/* Զ�̿��Իطŵ�ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];				/* ���ؿ���PTZ��ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];				/* Զ�̿���PTZ��ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];			/* ���ر���Ȩ��ͨ������ǰ���˳�����У�����0xffffffff�����Ϊ��Ч*/
    NET_DVR_IPADDR	struUserIP;				/* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE     byMACAddr[MACADDR_LEN];	/* �����ַ */
    BYTE     byPriority;				/* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
                                        /* �ޡ�����ʾ��֧�����ȼ�������
                                        �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��
                                        ״̬,���غ�Զ�̹ػ�/����
                                        �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�
                                        Զ�̻ط�,�����Խ���Զ��Ԥ�������ر���,����/Զ�̹ػ�/����
    �ߡ�������Ա */
    BYTE	byAlarmOnRight;         // ��������ڲ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE	byAlarmOffRight;         // ��������ڳ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE	byBypassRight;           // �����������·Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��

    BYTE	byRes[118];
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;


//���û�����(�ӽṹ)(9000��չ)
typedef struct
{
    BYTE sUserName[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    BYTE byLocalRight[MAX_RIGHT];	/* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(���ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */
    BYTE byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(���ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */
    BYTE byNetPreviewRight[MAX_CHANNUM_V30];		/* Զ�̿���Ԥ����ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalPlaybackRight[MAX_CHANNUM_V30];	/* ���ؿ��Իطŵ�ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetPlaybackRight[MAX_CHANNUM_V30];	/* Զ�̿��Իطŵ�ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalRecordRight[MAX_CHANNUM_V30];		/* ���ؿ���¼���ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetRecordRight[MAX_CHANNUM_V30];		/* Զ�̿���¼���ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalPTZRight[MAX_CHANNUM_V30];		/* ���ؿ���PTZ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetPTZRight[MAX_CHANNUM_V30];			/* Զ�̿���PTZ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalBackupRight[MAX_CHANNUM_V30];		/* ���ر���Ȩ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    NET_DVR_IPADDR struUserIP;		/* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];	/* �����ַ */
    BYTE byPriority;				/* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
                                    /*
                                    �ޡ�����ʾ��֧�����ȼ�������
                                    �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��״̬,���غ�Զ�̹ػ�/����
                                    �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�Զ�̻ط�,�����Խ���Զ��Ԥ��
                                    ���ر���,����/Զ�̹ػ�/����
                                    �ߡ�������Ա
    */
    BYTE	byAlarmOnRight;         // ��������ڲ���Ȩ��
    BYTE	byAlarmOffRight;        // ��������ڳ���Ȩ��
    BYTE	byBypassRight;          // �����������·Ȩ��
    BYTE	byRes[14];
}NET_DVR_USER_INFO_V30, *LPNET_DVR_USER_INFO_V30;

//���û�����(SDK_V15��չ)(�ӽṹ)
typedef struct
{
    BYTE sUserName[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    DWORD dwLocalRight[MAX_RIGHT];	/* Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(���ʽ�����������ػ�)*/
    DWORD dwLocalPlaybackRight;		/* ���ؿ��Իطŵ�ͨ�� bit0 -- channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];	/* Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(���ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    DWORD dwNetPreviewRight;		/* Զ�̿���Ԥ����ͨ�� bit0 -- channel 1*/
    DWORD dwNetPlaybackRight;		/* Զ�̿��Իطŵ�ͨ�� bit0 -- channel 1*/
    char sUserIP[16];				/* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];	/* �����ַ */
}NET_DVR_USER_INFO_EX, *LPNET_DVR_USER_INFO_EX;

//���û�����(�ӽṹ)
typedef struct
{
    BYTE sUserName[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    DWORD dwLocalRight[MAX_RIGHT];	/* Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(���ʽ�����������ػ�)*/
    DWORD dwRemoteRight[MAX_RIGHT];	/* Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(���ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    char sUserIP[16];				/* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];	/* �����ַ */
}NET_DVR_USER_INFO, *LPNET_DVR_USER_INFO;

//DVR�û�����(��չ)
typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;  //�ṹ���С
    DWORD dwMaxUserNum; //�豸֧�ֵ�����û���-ֻ��
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* �û����� */
}NET_DVR_USER_V40,*LPNET_DVR_USER_V40;

//DVR�û�����(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_V30 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V30, *LPNET_DVR_USER_V30;

//DVR�û�����(SDK_V15��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX, *LPNET_DVR_USER_EX;

//DVR�û�����
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER, *LPNET_DVR_USER;

typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize ;             //�ṹ���С
    DWORD             dwMaxGroupNum ;    //�豸֧�ֵ��������
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];
    BYTE   		 	byRes[128];          //����
}NET_DVR_EXCEPTION_V40,*LPNET_DVR_EXCEPTION_V40; /*�쳣����������չ�ṹ��*/

//DVR�쳣����(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*����0-����,1- Ӳ�̳���,2-���߶�,3-��������IP ��ַ��ͻ, 4-�Ƿ�����, 5-����/�����Ƶ��ʽ��ƥ��, 6-��Ƶ�ź��쳣, 7-¼���쳣 8-�����쳣��9-ǰ��/¼��ֱ��ʲ�ƥ���쳣��10-�г�����(����ר��) 11-�ȱ��쳣��N+1ʹ�ã�12-�¶ȣ�13-��ϵͳ�쳣��14-�����쳣, 15-POE�����쳣*/
}NET_DVR_EXCEPTION_V30, *LPNET_DVR_EXCEPTION_V30;



//DVR�쳣����
typedef struct
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*����0-����,1- Ӳ�̳���,2-���߶�,3-��������IP ��ַ��ͻ,4-�Ƿ�����, 5-����/�����Ƶ��ʽ��ƥ��, 6-��Ƶ�ź��쳣*/
}NET_DVR_EXCEPTION, *LPNET_DVR_EXCEPTION;

//ͨ��״̬(9000��չ)
typedef struct
{
    BYTE byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE bySignalStatic; //���ӵ��ź�״̬,0-��,1-�źŶ�ʧ
    BYTE byHardwareStatic;//ͨ��Ӳ��״̬,0-��,1-�쳣,����DSP����
    BYTE byRes1;		//����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    NET_DVR_IPADDR struClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
    DWORD dwIPLinkNum;//����ͨ��ΪIP���룬��ô��ʾIP���뵱ǰ��������
    BYTE byExceedMaxLink;		// �Ƿ񳬳��˵�·6·������ 0 - δ����, 1-����
    BYTE byRes[3];        // �����ֽ�
    DWORD dwAllBitRate;	  //����ʵ������֮��
    DWORD dwChannelNo;    //��ǰ��ͨ���ţ�0xffffffff��ʾ��Ч
}NET_DVR_CHANNELSTATE_V30, *LPNET_DVR_CHANNELSTATE_V30;

//ͨ��״̬
typedef struct
{
    BYTE byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE bySignalStatic; //���ӵ��ź�״̬,0-��,1-�źŶ�ʧ
    BYTE byHardwareStatic;//ͨ��Ӳ��״̬,0-��,1-�쳣,����DSP����
    char reservedData;		//����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    DWORD dwClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
}NET_DVR_CHANNELSTATE, *LPNET_DVR_CHANNELSTATE;

//Ӳ��״̬
typedef struct
{
    DWORD dwVolume;//Ӳ�̵�����
    DWORD dwFreeSpace;//Ӳ�̵�ʣ��ռ�
    DWORD dwHardDiskStatic; //Ӳ�̵�״̬,��λ:1-����,2-����,3-����Ӳ�̳���,4-δ��ʽ��, 5-δ����״̬(����Ӳ��),6-Ӳ�����ڸ�ʽ��
}NET_DVR_DISKSTATE, *LPNET_DVR_DISKSTATE;

typedef struct tagNET_DVR_WORKSTATE_V40
{
    DWORD   dwSize ;            //�ṹ���С
    DWORD   dwDeviceStatic; 	 //�豸��״̬,0-��,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬,һ�����ֻ�ܻ�ȡ33��Ӳ����Ϣ
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//ͨ����״̬����ǰ���˳������
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/]; //�б����ı�������ڣ���ֵ��ʾ�����±�ֵ˳�����У�ֵΪ0xffffffffʱ��ǰ������ֵ��Ч
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/]; //�б�������ı�������ڣ���ֵ��ʾ�����±�ֵ˳�����У�ֵΪ0xffffffffʱ��ǰ������ֵ��Ч
    DWORD   dwLocalDisplay;			//������ʾ״̬,0-��,1-����
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];		//��λ��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ���У���0λ��ʾ��1������ͨ��
    BYTE    byRes[126]; 				//����
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40; /*�豸����״̬��չ�ṹ��*/

typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize ;  //�ṹ�峤��
    BYTE    byFindHardByCond; /*0-����ȫ������(��һ�����ֻ�ܲ���33��)����ʱdwFindHardStatusNum��Ч*/
    BYTE    byFindChanByCond ;  /*0-����ȫ��ͨ������ʱdwFindChanNum��Ч*/
    BYTE    byRes1[2] ;//����
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/] ; /*Ҫ���ҵ�Ӳ�̺ţ���ֵ��ʾ����ֵ����˳�����У� ����0xffffffff����Ϊ������Ч */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/] ; /*Ҫ���ҵ�ͨ���ţ���ֵ��ʾ����ֵ����˳�����У� ����0xffffffff����Ϊ������Ч */
    BYTE 	byRes[64] ; //����
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

//DVR����״̬(9000��չ)
typedef struct
{
    DWORD dwDeviceStatic; 	//�豸��״̬,0-��,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30];//ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30]; //�����˿ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD  dwLocalDisplay;//������ʾ״̬,0-��,1-����
    BYTE  byAudioChanStatus[MAX_AUDIO_V30];//��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30, *LPNET_DVR_WORKSTATE_V30;

//DVR����״̬
typedef struct
{
    DWORD dwDeviceStatic; 	//�豸��״̬,0-��,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM];//ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN]; //�����˿ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD  dwLocalDisplay;//������ʾ״̬,0-��,1-����
}NET_DVR_WORKSTATE, *LPNET_DVR_WORKSTATE;



//��־��Ϣ(9000��չ)
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD	dwMajorType;	//������ 1-����; 2-�쳣; 3-����; 0xff-ȫ��
    DWORD	dwMinorType;//������ 0-ȫ��;
    BYTE	sPanelUser[MAX_NAMELEN]; //���������û���
    BYTE	sNetUser[MAX_NAMELEN];//����������û���
    NET_DVR_IPADDR	struRemoteHostAddr;//Զ�������ַ
    DWORD	dwParaType;//��������,9000�豸MINOR_START_VT/MINOR_STOP_VTʱ����ʾ�����Խ��Ķ��Ӻ�
    DWORD	dwChannel;//ͨ����
    DWORD	dwDiskNumber;//Ӳ�̺�
    DWORD	dwAlarmInPort;//��������˿�
    DWORD	dwAlarmOutPort;//��������˿�
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;

//��־��Ϣ
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD	dwMajorType;	//������ 1-����; 2-�쳣; 3-����; 0xff-ȫ��
    DWORD	dwMinorType;//������ 0-ȫ��;
    BYTE	sPanelUser[MAX_NAMELEN]; //���������û���
    BYTE	sNetUser[MAX_NAMELEN];//����������û���
    char	sRemoteHostAddr[16];//Զ�������ַ
    DWORD	dwParaType;//��������
    DWORD	dwChannel;//ͨ����
    DWORD	dwDiskNumber;//Ӳ�̺�
    DWORD	dwAlarmInPort;//��������˿�
    DWORD	dwAlarmOutPort;//��������˿�
}NET_DVR_LOG, *LPNET_DVR_LOG;

/************************DVR��־ end***************************/

/************************������������������־���� begin************************************************/
typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;		// ������
    WORD            wMinorType;		// ������
    NET_DVR_TIME    struStartTime;	// ��ʼʱ��
    NET_DVR_TIME    struEndTime;	// ����ʱ��
    BYTE            byRes[8];		// �����ֽ�
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME	struLogTime;                //  ��־ʱ��
    BYTE		    sUserName[NAME_LEN];     // �����û�
    NET_DVR_IPADDR	struIPAddr;                 // ����IP��ַ
    WORD		    wMajorType;                 // ������
    WORD		    wMinorType;                 // ������
    WORD	    	wParam;	                    // ��������
    BYTE		    byRes[10];
    DWORD		    dwInfoLen;	                // ������Ϣ����
    char			sInfo[LOG_INFO_LEN];       // ������Ϣ
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

/*************************������������������־���� end***********************************************/

//�������״̬(9000��չ)
typedef struct
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30, *LPNET_DVR_ALARMOUTSTATUS_V30;

//�������״̬
typedef struct
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS, *LPNET_DVR_ALARMOUTSTATUS;

//������Ϣ
typedef struct
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];	//�豸���
    DWORD dwChannelNumer;	//ͨ����
    BYTE CardNumber[32];	//����
    char cTradeType[12];	//��������
    DWORD dwCash;			//���׽��
}NET_DVR_TRADEINFO, *LPNET_DVR_TRADEINFO;


//ATMר��
/****************************ATM(begin)***************************/
#define NCR		0
#define DIEBOLD	1
#define WINCOR_NIXDORF	2
#define SIEMENS	3
#define OLIVETTI	4
#define FUJITSU	5
#define HITACHI	6
#define SMI		7
#define IBM		8
#define BULL	9
#define YiHua	10
#define LiDe	11
#define GDYT	12
#define Mini_Banl	13
#define GuangLi	14
#define DongXin	15
#define ChenTong	16
#define NanTian	17
#define XiaoXing	18
#define GZYY	19
#define QHTLT	20
#define DRS918	21
#define KALATEL	22
#define NCR_2	23
#define NXS		24


/*֡��ʽ*/
typedef struct
{
    BYTE code[12];		/* ���� */
}NET_DVR_FRAMETYPECODE;


//ATM����
typedef struct
{
    DWORD dwSize;
    char sATMIP[16];						/* ATM IP��ַ */
    DWORD dwATMType;						/* ATM���� */
    DWORD dwInputMode;						/* ���뷽ʽ	0-�������� 1-������� 2-����ֱ������ 3-����ATM��������*/
    DWORD dwFrameSignBeginPos;              /* ���ı�־λ����ʼλ��*/
    DWORD dwFrameSignLength;				/* ���ı�־λ�ĳ��� */
    BYTE  byFrameSignContent[12];			/* ���ı�־λ������ */
    DWORD dwCardLengthInfoBeginPos;			/* ���ų�����Ϣ����ʼλ�� */
    DWORD dwCardLengthInfoLength;			/* ���ų�����Ϣ�ĳ��� */
    DWORD dwCardNumberInfoBeginPos;			/* ������Ϣ����ʼλ�� */
    DWORD dwCardNumberInfoLength;			/* ������Ϣ�ĳ��� */
    DWORD dwBusinessTypeBeginPos;           /* �������͵���ʼλ�� */
    DWORD dwBusinessTypeLength;				/* �������͵ĳ��� */
    NET_DVR_FRAMETYPECODE frameTypeCode[10];/* ���� */
}NET_DVR_FRAMEFORMAT, *LPNET_DVR_FRAMEFORMAT;
//SDK_V31 ATM

/*��������*/
typedef struct	tagNET_DVR_FILTER
{
    BYTE			        byEnable;			//0,������;1,����
    BYTE					byMode;				//0,ASCII;1,HEX
    BYTE                    byFrameBeginPos;    // ��Ҫ����Ŀ���ַ���ʼλ��
    BYTE					byRes;           // �����ֽ�
    BYTE 					byFilterText[16];	//�����ַ�
    BYTE					byRes2[12];         // �����ֽ�
}NET_DVR_FILTER, *LPNET_DVR_FILTER;

//��ݰ���� ��ݰ��ʶ
typedef struct	tagNET_DVR_IDENTIFICAT
{
    BYTE					byStartMode;		//��ʼ�ַ�ģʽ:0,ASCII;1,HEX
    BYTE					byEndMode;			//�����ַ�ģʽ��0,ASCII;1,HEX
    BYTE					byRes[2];           //�����ֽ�
    NET_DVR_FRAMETYPECODE	struStartCode;		//��ݰ���ʼ��ʶ�ַ�
    NET_DVR_FRAMETYPECODE	struEndCode;		//��ݰ�����ʶ�ַ�
    BYTE					byRes1[12];         //�����ֽ�
}NET_DVR_IDENTIFICAT, *LPNET_DVR_IDENTIFICAT;

typedef struct	tagNET_DVR_PACKAGE_LOCATION/*������Ϣλ��*/
{
    BYTE 					byOffsetMode;			/*����λ����Ϣģʽ 0,token(�ַ��־ģʽ);1,fix���̶�ģʽ��*/
    BYTE                    byRes1[3];				// �����ֽ�
    DWORD  				    dwOffsetPos;			/*modeΪ1��ʱ��ʹ��,�̶�ƫ�ƴ�С*/
    NET_DVR_FRAMETYPECODE	struTokenCode;			/*��־λ*/
    BYTE					byMultiplierValue;		/*��־λ���ٴγ���*/
    BYTE					byEternOffset;			/*�����ַ�ƫ����*/
    BYTE					byCodeMode;			    /*0,ASCII;1,HEX*/
    BYTE 					byRes2[9];			    //�����ֽ�
}NET_DVR_PACKAGE_LOCATION, *LPNET_DVR_PACKAGE_LOCATION;


typedef struct	tagNET_DVR_PACKAGE_LENGTH//������Ϣ����
{
    BYTE					byLengthMode;			//�������ͣ�0,�ɱ䳤��;1,�̶�����;2,�����(�ӿ����л�ȡ)
    BYTE                    byRes1[3];              // �����ֽ�
    DWORD  			    	dwFixLength;			    //modeΪ1��ʱ��ʹ��,�̶����ȴ�С
    DWORD					dwMaxLength;            //������Ϣ��󳤶�  byLengthModeΪ0ʱʹ��
    DWORD					dwMinLength;            //������Ϣ��С����  byLengthModeΪ0ʱʹ��
    BYTE					byEndMode;			    //�ɱ䳤�� �ս��ģʽ 0,ASCII;1,HEX
    BYTE                    byRes2[3];              //�����ֽ�
    NET_DVR_FRAMETYPECODE	struEndCode;		//�ɱ䳤���ս��
    DWORD					dwLengthPos;			//lengthModeΪ2��ʱ��ʹ�ã����ų����ڱ����е�λ��
    DWORD					dwLengthLen;			//lengthModeΪ2��ʱ��ʹ�ã����ų��ȵĳ���
    BYTE					byRes3[8];              // �����ֽ�
}NET_DVR_PACKAGE_LENGTH,* LPNET_DVR_PACKAGE_LENGTH;

typedef struct	tagNET_DVR_OSD_POSITION//OSD ���ӵ�λ��
{
    BYTE					byPositionMode;		//���ӷ�񣬹�2�֣�0������ʾ��1���Զ���
    BYTE                    byRes1[3];          // �����ֽ�
    DWORD 					dwPosX;				//x��꣬���ӷ��Ϊ�Զ���ʱʹ��
    DWORD					dwPosY;				//y��꣬���ӷ��Ϊ�Զ���ʱʹ��
    BYTE					byRes2[8];          //�����ֽ�
}NET_DVR_OSD_POSITION, *LPNET_DVR_OSD_POSITION;

typedef struct	tagNET_DVR_DATE_FORMAT//������ʾ��ʽ
{
    BYTE					byMonth;			    //Month,0.mm;1.mmm;2.mmmm
    BYTE 					byDay;				    //Day,0.dd;
    BYTE 					byYear;				    //Year,0.yy;1.yyyy
    BYTE					byDateForm;			    //0~5�������յ��������
    BYTE					byRes[20];              // �����ֽ�
    char					chSeprator[4];		    //�ָ���
    char	    			chDisplaySeprator[4];	//��ʾ�ָ���
    BYTE	    			byDisplayForm;			//0~5��3��item���������
    BYTE					res[27];                // �����ֽ�
}NET_DVR_DATE_FORMAT, *LPNET_DVR_DATE_FORMAT;
typedef struct	tagNET_DVRT_TIME_FORMAT//ʱ����ʾ��ʽ
{
    BYTE					byTimeForm;				//1. HH MM SS;0. HH MM
    BYTE 					byRes1[23];             // �����ֽ�
    BYTE                    byHourMode;             //0,12;1,24
    BYTE                    byRes2[3];              // �����ֽ�
    char					chSeprator[4]; 			//���ķָ�����ʱû��
    char					chDisplaySeprator[4];	//��ʾ�ָ���
    BYTE	    			byDisplayForm;			//0~5��3��item���������
    BYTE                    byRes3[3];              // �����ֽ�
    BYTE					byDisplayHourMode;		//0,12;1,24
    BYTE					byRes4[19];             // �����ֽ�
}NET_DVR_TIME_FORMAT, *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{
    BYTE                    byChannel[64];//���ӵ�ͨ�� ÿ���ֽڱ�ʶһ��ͨ���� ����byChannel[0]ֵΪ1��Ӧ����ͨ��1��0��ʾ������ͨ��1��
    DWORD					dwDelayTime;			//������ʱʱ��
    BYTE					byEnableDelayTime;		//�Ƿ����õ�����ʱ
    BYTE					byRes[11];          // �����ֽ�
}NET_DVR_OVERLAY_CHANNEL, *LPNET_DVR_OVERLAY_CHANNEL;

// ATM ������Ϊ��Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{
    NET_DVR_PACKAGE_LOCATION	struPackageLocation;// ����λ����Ϣ
    NET_DVR_OSD_POSITION		struOsdPosition;    // OSD ����λ��
    NET_DVR_FRAMETYPECODE		struActionCode;		//����������Ϊ��
    NET_DVR_FRAMETYPECODE		struPreCode;		//�����ַ�ǰ���ַ�
    BYTE					byActionCodeMode;		//����������Ϊ��ģʽ0,ASCII;1,HEX
    BYTE					byRes[7];               // �����ֽ�
}NET_DVR_ATM_PACKAGE_ACTION, *LPNET_DVR_ATM_PACKAGE_ACTION;

// ATM ����DATA��Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{
    NET_DVR_PACKAGE_LOCATION	struPackageLocation;// �����ڱ����е�λ����Ϣ
    NET_DVR_DATE_FORMAT		    struDateForm;		//������ʾ��ʽ
    NET_DVR_OSD_POSITION		struOsdPosition;	// OSD����λ����Ϣ
    BYTE				    	res[8]; 			// �����ֽ�
}NET_DVR_ATM_PACKAGE_DATE, *LPNET_DVR_ATM_PACKAGE_DATE;


//ATM����ʱ����Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{
    NET_DVR_PACKAGE_LOCATION	location;		// ʱ���ڱ����е�λ����Ϣ
    NET_DVR_TIME_FORMAT		    struTimeForm;	// ʱ����ʾ��ʽ
    NET_DVR_OSD_POSITION		struOsdPosition;// OSD ����λ����Ϣ
    BYTE					    byRes[8];		// �����ֽ�
}NET_DVR_ATM_PACKAGE_TIME, *LPNET_DVR_ATM_PACKAGE_TIME;


// ATM ��������Ϣ�����ţ����׽�������ţ�
typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{
    NET_DVR_PACKAGE_LOCATION	struPackageLocation; //����λ����Ϣ
    NET_DVR_PACKAGE_LENGTH	struPackageLength;		//������Ϣ
    NET_DVR_OSD_POSITION		struOsdPosition;	// OSD����λ����Ϣ
    NET_DVR_FRAMETYPECODE		struPreCode;		//�����ַ�ǰ���ַ�
    BYTE					res[8];					//�����ֽ�
}NET_DVR_ATM_PACKAGE_OTHERS, *LPNET_DVR_ATM_PACKAGE_OTHERS;


//�û��Զ���Э��
typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;  //���ı�־
    NET_DVR_FILTER             struFilter; //��ݰ��������
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara; //���ӿ�������
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE]; //���ӽ�����Ϊ���� 0-9 ���ζ�ӦInCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara; //���ӽ��׽������
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara; //���ӽ����������
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan; //����ͨ������
    NET_DVR_ATM_PACKAGE_DATE   struRes1; //�������ڣ�����
    NET_DVR_ATM_PACKAGE_TIME   struRes2; //����ʱ�䣬����
    BYTE                       byRes3[124];        //����
}NET_DVR_ATM_USER_DEFINE_PROTOCOL, *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{
    DWORD                        dwSize;                 //�ṹ��С
    BYTE					    byEnable;				/*�Ƿ�����0,������;1,����*/
    BYTE					    byInputMode;			/**���뷽ʽ:0-�������1����Э�顢2-���ڼ���3-����Э��*/
    BYTE					    byRes1[34];              //�����ֽ�
    NET_DVR_IPADDR		    	struAtmIp;				/*ATM ��IP �������ʱʹ�� */
    WORD					    wAtmPort;				/* ����Э�鷽ʽʱ��ʹ��*/
    BYTE					    byRes2[2];              // �����ֽ�
    DWORD					    dwAtmType;				/*ATMЭ�����ͣ���NET_DVR_ATM_PROTOCOL�ṹ�л�ȡ���������Ϊ�Զ���ʱʹ���û��Զ���Э��*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol; //�û��Զ���Э�飬��ATM����Ϊ�Զ�ʱ��Ҫʹ�øö���
    BYTE					    byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30, *LPNET_DVR_ATM_FRAMEFORMAT_V30;


typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType; //ATMЭ�����ͣ�ͬʱ��Ϊ������� ATM �����е�dwAtmType �Զ���ʱΪ1025
    char chDesc[ATM_DESC_LEN]; //ATMЭ�������
}NET_DVR_ATM_PROTO_TYPE, *LPNET_DVR_ATM_PROTO_TYPE; //Э����Ϣ��ݽṹ

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM Э���б�
{
    DWORD                  dwAtmProtoNum;           // Э���б�ĸ���
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM]; //Э���б���Ϣ
}NET_DVR_ATM_PROTO_LIST, *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList; // �������Э������
    NET_DVR_ATM_PROTO_LIST struSerialListenList; //���ڼ���Э������
    NET_DVR_ATM_PROTO_LIST struNetProtoList;     //����Э������
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;   //����Э������
    NET_DVR_ATM_PROTO_TYPE struCustomProto;        //�Զ���Э��
}NET_DVR_ATM_PROTOCOL, *LPNET_DVR_ATM_PROTOCOL;
// SDK_V31

/*****************************DS-6001D/F(begin)***************************/
//DS-6001D Decoder
typedef struct
{
    BYTE byEncoderIP[16];		//�����豸���ӵķ�����IP
    BYTE byEncoderUser[16];		//�����豸���ӵķ��������û���
    BYTE byEncoderPasswd[16];	//�����豸���ӵķ�����������
    BYTE bySendMode;			//�����豸���ӷ�����������ģʽ
    BYTE byEncoderChannel;		//�����豸���ӵķ�������ͨ����
    WORD wEncoderPort;			//�����豸���ӵķ������Ķ˿ں�
    BYTE reservedData[4];		//����
}NET_DVR_DECODERINFO, *LPNET_DVR_DECODERINFO;

typedef struct
{
    BYTE byEncoderIP[16];		//�����豸���ӵķ�����IP
    BYTE byEncoderUser[16];		//�����豸���ӵķ��������û���
    BYTE byEncoderPasswd[16];	//�����豸���ӵķ�����������
    BYTE byEncoderChannel;		//�����豸���ӵķ�������ͨ����
    BYTE bySendMode;			//�����豸���ӵķ�����������ģʽ
    WORD wEncoderPort;			//�����豸���ӵķ������Ķ˿ں�
    DWORD dwConnectState;		//�����豸���ӷ�������״̬
    BYTE reservedData[4];		//����
}NET_DVR_DECODERSTATE, *LPNET_DVR_DECODERSTATE;

/*�����豸�����붨��*/
#define NET_DEC_STARTDEC		1
#define NET_DEC_STOPDEC			2
#define NET_DEC_STOPCYCLE		3
#define NET_DEC_CONTINUECYCLE	4
/*���ӵ�ͨ������*/
typedef struct
{
    char sDVRIP[16];				/* DVR IP��ַ */
    WORD wDVRPort;			 		/* �˿ں� */
    BYTE sUserName[NAME_LEN];		/* �û��� */
    BYTE sPassword[PASSWD_LEN];		/* ���� */
    BYTE byChannel;					/* ͨ���� */
    BYTE byLinkMode;				/* ����ģʽ */
    BYTE byLinkType;				/* �������� 0�������� 1�������� */
}NET_DVR_DECCHANINFO, *LPNET_DVR_DECCHANINFO;

/*ÿ������ͨ��������*/
typedef struct
{
    BYTE	byPoolChans;			/*ÿ·����ͨ���ϵ�ѭ��ͨ������, ���4ͨ�� 0��ʾû�н���*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE	byEnablePoll;			/*�Ƿ���Ѳ 0-�� 1-��*/
    BYTE	byPoolTime;				/*��Ѳʱ�� 0-���� 1-10�� 2-15�� 3-20�� 4-30�� 5-45�� 6-1���� 7-2���� 8-5���� */
}NET_DVR_DECINFO, *LPNET_DVR_DECINFO;

/*����豸��������*/
typedef struct
{
    DWORD	dwSize;
    DWORD	dwDecChanNum; 		/*����ͨ��������*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG, *LPNET_DVR_DECCFG;

//2005-08-01
/* �����豸͸��ͨ������ */
typedef struct
{
    DWORD dwEnableTransPort;	/* �Ƿ�����͸��ͨ�� 0�������� 1������*/
    char sDecoderIP[16];		/* DVR IP��ַ */
    WORD wDecoderPort;			/* �˿ں� */
    WORD wDVRTransPort;			/* ����ǰ��DVR�Ǵ�485/232�����1��ʾ232����,2��ʾ485���� */
    char cReserve[4];
}NET_DVR_PORTINFO, *LPNET_DVR_PORTINFO;

typedef struct
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM]; /* ����0��ʾ232 ����1��ʾ485 */
}NET_DVR_PORTCFG, *LPNET_DVR_PORTCFG;

/* ���������ļ��ط� */
typedef struct
{
    DWORD dwSize;
    char sDecoderIP[16];		/* DVR IP��ַ */
    WORD wDecoderPort;			/* �˿ں� */
    WORD wLoadMode;				/* �ط�����ģʽ 1�������� 2����ʱ�� */
    union
    {
        BYTE byFile[100];		/* �طŵ��ļ��� */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];	/*������Ƶ�û���*/
            BYTE sPassword[PASSWD_LEN];	/* ���� */
            NET_DVR_TIME struStartTime;	/* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;	/* ��ʱ��طŵĽ���ʱ�� */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE, *LPNET_DVR_PLAYREMOTEFILE;

/*��ǰ�豸��������״̬*/
typedef struct
{
    DWORD dwWorkType;		/*������ʽ��1����Ѳ��2����̬���ӽ��롢3���ļ��ط����� 4����ʱ��ط�����*/
    char sDVRIP[16];		/*���ӵ��豸ip*/
    WORD wDVRPort;			/*���Ӷ˿ں�*/
    BYTE byChannel;			/* ͨ���� */
    BYTE byLinkMode;		/* ����ģʽ */
    DWORD	dwLinkType;		/*�������� 0�������� 1��������*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];	/*������Ƶ�û���*/
            BYTE sPassword[PASSWD_LEN];	/* ���� */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD	dwChannel;
            BYTE	sUserName[NAME_LEN];	/*������Ƶ�û���*/
            BYTE	sPassword[PASSWD_LEN];	/* ���� */
            NET_DVR_TIME struStartTime;		/* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;		/* ��ʱ��طŵĽ���ʱ�� */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS, *LPNET_DVR_DECCHANSTATUS;

typedef struct
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS, *LPNET_DVR_DECSTATUS;
/*****************************DS-6001D/F(end)***************************/

//���ַ����(�ӽṹ)
typedef struct
{
    WORD wShowString;				// Ԥ����ͼ�����Ƿ���ʾ�ַ�,0-����ʾ,1-��ʾ �����С704*576,�����ַ�Ĵ�СΪ32*32
    WORD wStringSize;				/* �����ַ�ĳ��ȣ����ܴ���44���ַ� */
    WORD wShowStringTopLeftX;		/* �ַ���ʾλ�õ�x��� */
    WORD wShowStringTopLeftY;		/* �ַ������ʾλ�õ�y��� */
    char sString[44];				/* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRINGINFO, *LPNET_DVR_SHOWSTRINGINFO;

//�����ַ�(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];				/* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING_V30, *LPNET_DVR_SHOWSTRING_V30;

//�����ַ���չ(8���ַ�)
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];				/* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING_EX, *LPNET_DVR_SHOWSTRING_EX;

//�����ַ�
typedef struct
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];				/* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING, *LPNET_DVR_SHOWSTRING;

/****************************DS9000�����ṹ(begin)******************************/
/*
EMAIL����ṹ
*/
typedef struct
{
    DWORD		dwSize;
    BYTE		sAccount[NAME_LEN];				/* �˺�*/
    BYTE		sPassword[MAX_EMAIL_PWD_LEN];			/*���� */
    struct
    {
        BYTE	sName[NAME_LEN];				/* ���������� */
        BYTE	sAddress[MAX_EMAIL_ADDR_LEN];		/* �����˵�ַ */
    }struSender;
    BYTE		sSmtpServer[MAX_EMAIL_ADDR_LEN];	/* smtp������ */
    BYTE		sPop3Server[MAX_EMAIL_ADDR_LEN];	/* pop3������ */
    struct
    {
        BYTE	sName[NAME_LEN];				/* �ռ������� */
        BYTE	sAddress[MAX_EMAIL_ADDR_LEN];		/* �ռ��˵�ַ */
    }struReceiver[3];							/* ����������3���ռ��� */
    BYTE		byAttachment;					/* �Ƿ��� */
    BYTE		bySmtpServerVerify;				/* ���ͷ�����Ҫ�������֤ */
    BYTE        byMailInterval;                 /* mail interval */
    BYTE        byEnableSSL;					//ssl�Ƿ�����9000_1.1
    WORD        wSmtpPort;						//gmail��465����ͨ��Ϊ25
    BYTE		byEnableTLS;					/*TLS�Ƿ�����*/
    BYTE        byStartTLS;                     /*�Ƿ�����StartTLS*/
    BYTE		byRes[72];						/*����*/
} NET_DVR_EMAILCFG_V30, *LPNET_DVR_EMAILCFG_V30;

/*
DVRʵ��Ѳ����ݽṹ
*/
typedef struct
{
    DWORD 	dwSize;
    BYTE	byPresetNo[CRUISE_MAX_PRESET_NUMS];		/* Ԥ�õ�� */
    BYTE 	byCruiseSpeed[CRUISE_MAX_PRESET_NUMS];	/* Ѳ���ٶ� */
    WORD	wDwellTime[CRUISE_MAX_PRESET_NUMS];		/* ͣ��ʱ�� */
    BYTE	byEnableThisCruise;						/* �Ƿ����� */
    BYTE	res[15];
}NET_DVR_CRUISE_PARA, *LPNET_DVR_CRUISE_PARA;
/****************************DS9000�����ṹ(end)******************************/

//ʱ���
typedef struct
{
    DWORD dwMonth;		//�� 0-11��ʾ1-12����
    DWORD dwWeekNo;		//�ڼ��� 0����1�� 1����2�� 2����3�� 3����4�� 4�����һ��
    DWORD dwWeekDate;	//���ڼ� 0�������� 1������һ 2�����ڶ� 3�������� 4�������� 5�������� 6��������
    DWORD dwHour;		//Сʱ	��ʼʱ��0��23 ����ʱ��1��23
    DWORD dwMin;		//��	0��59
}NET_DVR_TIMEPOINT;

//����ʱ����
typedef struct
{
    DWORD dwSize;
    DWORD dwZoneIndex; //Ӧ�ò����ʹ��NET_DVR_NTPPARA �е�cTimeDifferenceH ��cTimeDifferenceM ������ʱ��˴��û�ȡ��ֵ��䣬�����û��ṩ����༭��
    BYTE byRes1[12];			//����
    DWORD dwEnableDST;		//�Ƿ�������ʱ�� 0�������� 1������
    BYTE byDSTBias;	//����ʱƫ��ֵ��30min, 60min, 90min, 120min, �Է��Ӽƣ�����ԭʼ��ֵ
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;	//��ʱ�ƿ�ʼʱ��
    NET_DVR_TIMEPOINT struEndPoint;	//��ʱ��ֹͣʱ��
}NET_DVR_ZONEANDDST, *LPNET_DVR_ZONEANDDST;

//ͼƬ����
typedef struct
{
/*ע�⣺��ͼ��ѹ���ֱ���ΪVGAʱ��֧��0=CIF, 1=QCIF, 2=D1ץͼ��
���ֱ���Ϊ3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
    ��֧�ֵ�ǰ�ֱ��ʵ�ץͼ*/

    /* ����ͨ����������ȡ
	   0-CIF��           1-QCIF��           2-D1��         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)��
       6-VGA��           7-XVGA��           8-HD900p��     9-HD1080��     10-2560*1920��
       11-1600*304��     12-2048*1536��     13-2448*2048,  14-2448*1200�� 15-2448*800��
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576��
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    75-336*256,
       78-384*256,		 79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272
       0xff-Auto(ʹ�õ�ǰ�����ֱ���)
    */
    WORD	wPicSize;
    WORD	wPicQuality;			/* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
}NET_DVR_JPEGPARA, *LPNET_DVR_JPEGPARA;

/* aux video out parameter */
//���������������
typedef struct
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                       /* ѡ�񱨾������󱨾�ͨ���л�ʱ�䣺1��������ͨ��: 0:�����/1:��1/2:��2/3:��3/4:��4 */
    DWORD dwAlarmChanSwitchTime;                /* :1�� - 10:10�� */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];			/* ��������л�ʱ��: 0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s */
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];	/* �������Ԥ��˳��, 0xff��ʾ��Ӧ�Ĵ��ڲ�Ԥ�� */
}NET_DVR_AUXOUTCFG, *LPNET_DVR_AUXOUTCFG;


//ntp
typedef struct
{
    BYTE sNTPServer[64];   /* Domain Name or IP addr of NTP server */
    WORD wInterval;		 /* adjust time interval(hours) */
    BYTE byEnableNTP;    /* enable NPT client 0-no��1-yes*/
    signed char cTimeDifferenceH; /* ���ʱ�׼ʱ��� Сʱƫ��-12 ... +13 */
    signed char cTimeDifferenceM;/* ���ʱ�׼ʱ��� ����ƫ��0, 30, 45*/
    BYTE res1;
    WORD wNtpPort;         /* ntp server port 9000���� �豸Ĭ��Ϊ123*/
    BYTE res2[8];
}NET_DVR_NTPPARA, *LPNET_DVR_NTPPARA;

//ddns
typedef struct
{
    BYTE sUsername[NAME_LEN];  /* DDNS�˺��û���/���� */
    BYTE sPassword[PASSWD_LEN];
    BYTE sDomainName[64];       /* ���� */
    BYTE byEnableDDNS;			/*�Ƿ�Ӧ�� 0-��1-��*/
    BYTE res[15];
}NET_DVR_DDNSPARA, *LPNET_DVR_DDNSPARA;


typedef struct
{
    BYTE byHostIndex;					/* 0-˽��DDNS 1��Dyndns 2��PeanutHull(�����)*/
    BYTE byEnableDDNS;					/*�Ƿ�Ӧ��DDNS 0-��1-��*/
    WORD wDDNSPort;						/* DDNS�˿ں� */
    BYTE sUsername[NAME_LEN];			/* DDNS�û���*/
    BYTE sPassword[PASSWD_LEN];			/* DDNS���� */
    BYTE sDomainName[MAX_DOMAIN_NAME];	/* �豸�䱸�������ַ */
    BYTE sServerName[MAX_DOMAIN_NAME];	/* DDNS ��Ӧ�ķ�������ַ��������IP��ַ������ */
    BYTE byRes[16];
}NET_DVR_DDNSPARA_EX, *LPNET_DVR_DDNSPARA_EX;

//9000��չ
typedef struct
{
    BYTE byEnableDDNS;
    BYTE byHostIndex;/*0-IPServer 1��Dyndns 2��PeanutHull(�����)��3- NO-IP, 4- hiDDNS*/
    BYTE byRes1[2];
    struct
    {
        BYTE sUsername[NAME_LEN];			/* DDNS�˺��û���*/
        BYTE sPassword[PASSWD_LEN];			/* ���� */
        BYTE sDomainName[MAX_DOMAIN_NAME];	/* �豸�䱸�������ַ */
        BYTE sServerName[MAX_DOMAIN_NAME];	/* DDNSЭ���Ӧ�ķ�������ַ��������IP��ַ������ */
        WORD wDDNSPort;						/* �˿ں� */
        WORD	wCountryID;		//��ұ�ţ�����byHostIndex = 4ʱ��Ч��0��ʾĬ��
                                BYTE byStatus;                      /* DDNS����״̬��ֻ������
                                                                    0-������
                                                                    1-���ӷ�����ʧ��(connServerfail)��
                                                                    2-������������Ϣʧ��(solveServerMesFail)��
                                                                    3-�������������ʧ��(connHeartSrvfail)��
                                                                    4-���������������Ϣʧ��(solveHeartSrvMesFail)��
                                                                    5-�������������ʧ��(connHostSrvfail)��
                                                                    6-���������������Ϣʧ��(solveHostSrvMesFail)��
                                                                    7-DDNS״̬��(updateSuccess)��
                                                                    8-δ����(disable)��
                                                                    9-ע������ɹ�(registHostSuccess)��
                                                                    10-DNS���������ô���(DNSSrvError)��
                                                                    11-����ռ��(DomainConflict)��
                                                                    12-����(����)���Ϸ�(invalidAlias)��
                                                                    13-��Ȩʧ��(authenticationFail)
                                                                    14-ע�����������(registServerError)
                                                                    15-ע��ʧ��(registFail)
                                */
                                BYTE byRes[7];
    } struDDNS[MAX_DDNS_NUMS];
    BYTE byRes2[16];
}NET_DVR_DDNSPARA_V30, *LPNET_DVR_DDNSPARA_V30;

//email
typedef struct
{
    BYTE sUsername[64];  /* �ʼ��˺�/���� */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];   /* email */
    BYTE sEventMailAddr1[64];  /* �ϴ�����/�쳣�ȵ�email */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA, *LPNET_DVR_EMAILPARA;

//�����������
typedef struct
{
    DWORD  dwSize;
    char  sDNSIp[16];                /* DNS��������ַ */
    NET_DVR_NTPPARA  struNtpClientParam;      /* NTP���� */
    NET_DVR_DDNSPARA struDDNSClientParam;     /* DDNS���� */
    BYTE res[464];			/* ���� */
}NET_DVR_NETAPPCFG, *LPNET_DVR_NETAPPCFG;

//nfs�ṹ����
typedef struct
{
    char sNfsHostIPAddr[16];
    BYTE sNfsDirectory[PATHNAME_LEN];        // PATHNAME_LEN = 128
}NET_DVR_SINGLE_NFS, *LPNET_DVR_SINGLE_NFS;

typedef struct
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG, *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{
    DWORD dwSize;                   // �ṹ��С
    WORD wVrmPort;                  // VRM ����˿�
    BYTE byEnable;                  // �Ƿ����� ISCSI�洢
    BYTE byRes[69];                 // �����ֽ�
    NET_DVR_IPADDR struVrmAddr;          // VRM ip��ַ 16λ
    char chNvtIndexCode[64];        //nvt index Code
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;

//Ѳ��������(˽��IP����ר��)
typedef struct
{
    BYTE	PresetNum;	//Ԥ�õ�
    BYTE	Dwell;		//ͣ��ʱ��
    BYTE	Speed;		//�ٶ�
    BYTE	Reserve;	//����
}NET_DVR_CRUISE_POINT, *LPNET_DVR_CRUISE_POINT;

typedef struct
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];			//���֧��32��Ѳ����
}NET_DVR_CRUISE_RET, *LPNET_DVR_CRUISE_RET;

/************************************��·������(begin)***************************************/
typedef struct
{
    DWORD	dwSize;
    char	sFirstDNSIP[16];
    char	sSecondDNSIP[16];
    char	sRes[32];
}NET_DVR_NETCFG_OTHER, *LPNET_DVR_NETCFG_OTHER;

typedef struct
{
    char 	sDVRIP[16];				/* DVR IP��ַ */
    WORD 	wDVRPort;			 	/* �˿ں� */
    BYTE 	byChannel;				/* ͨ���� */
    BYTE	byTransProtocol;			/* ����Э������ 0-TCP, 1-UDP */
    BYTE	byTransMode;				/* ��������ģʽ 0�������� 1��������*/
    BYTE	byRes[3];
    BYTE	sUserName[NAME_LEN];			/* ��������½�ʺ� */
    BYTE	sPassword[PASSWD_LEN];			/* ����������� */
}NET_DVR_MATRIX_DECINFO, *LPNET_DVR_MATRIX_DECINFO;

//����/ֹͣ��̬����
typedef struct
{
    DWORD	dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;		/* ��̬����ͨ����Ϣ */
}NET_DVR_MATRIX_DYNAMIC_DEC, *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct
{
    DWORD 	dwSize;
    DWORD   dwIsLinked;         /* ����ͨ��״̬ 0������ 1���������� 2�������� 3-���ڽ��� */
    DWORD   dwStreamCpRate;     /* Stream copy rate, X kbits/second */
    char    cRes[64];		/* ���� */
}NET_DVR_MATRIX_DEC_CHAN_STATUS, *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct
{
    DWORD	dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;		/* ����ͨ����Ϣ */
    DWORD	dwDecState;	/* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;		/* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;		/* ��ʱ��ط�ֹͣʱ�� */
    char    sFileName[128];		/* ���ļ��ط��ļ��� */
}NET_DVR_MATRIX_DEC_CHAN_INFO, *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

//���ӵ�ͨ������ 2007-11-05
typedef struct
{
    DWORD dwEnable;					/* �Ƿ����� 0���� 1������*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;		/* ��Ѳ����ͨ����Ϣ */
}NET_DVR_MATRIX_DECCHANINFO, *LPNET_DVR_MATRIX_DECCHANINFO;

//2007-11-05 ����ÿ������ͨ��������
typedef struct
{
    DWORD	dwSize;
    DWORD	dwPoolTime;			/*��Ѳʱ�� */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO, *LPNET_DVR_MATRIX_LOOP_DECINFO;

//2007-12-22
typedef struct
{
    BYTE	baudrate; 	/* ������ */
    BYTE	databits;		/* ���λ */
    BYTE	stopbits;		/* ֹͣλ */
    BYTE	parity;		/* ��żУ��λ */
    BYTE	flowcontrol;	/* ���� */
    BYTE	res[3];
}TTY_CONFIG, *LPTTY_CONFIG;

typedef struct
{
    BYTE byTranChanEnable;	/* ��ǰ͸��ͨ���Ƿ�� 0���ر� 1���� */
                            /*
                            *	��·������������1��485���ڣ�1��232���ڶ�������Ϊ͸��ͨ��,�豸�ŷ������£�
                            *	0 RS485
                            *	1 RS232 Console
    */
    BYTE	byLocalSerialDevice;			/* Local serial device */
                                            /*
                                            *	Զ�̴��������������,һ��RS232��һ��RS485
                                            *	1��ʾ232����
                                            *	2��ʾ485����
    */
    BYTE	byRemoteSerialDevice;			/* Remote output serial device */
    BYTE	res1;							/* ���� */
    char	sRemoteDevIP[16];				/* Remote Device IP */
    WORD	wRemoteDevPort;				/* Remote Net Communication Port */
    BYTE	res2[2];						/* ���� */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct
{
    DWORD dwSize;
    BYTE 	by232IsDualChan; /* ������·232͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE	by485IsDualChan; /* ������·485͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE	res[2];	/* ���� */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM];/*ͬʱ֧�ֽ���MAX_SERIAL_NUM��͸��ͨ��*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007-12-24 Merry Christmas Eve...
typedef struct
{
    DWORD	dwSize;
    char	sDVRIP[16];		/* DVR IP��ַ */
    WORD	wDVRPort;			/* �˿ں� */
    BYTE	byChannel;			/* ͨ���� */
    BYTE 	byReserve;
    BYTE	sUserName[NAME_LEN];		/* �û��� */
    BYTE	sPassword[PASSWD_LEN];		/* ���� */
    DWORD	dwPlayMode;   	/* 0�����ļ� 1����ʱ��*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

/* �ļ��������� */
#define NET_DVR_PLAYSTART		1//��ʼ����
#define NET_DVR_PLAYSTOP		2//ֹͣ����
#define NET_DVR_PLAYPAUSE		3//��ͣ����
#define NET_DVR_PLAYRESTART		4//�ָ�����
#define NET_DVR_PLAYFAST		5//���
#define NET_DVR_PLAYSLOW		6//���
#define NET_DVR_PLAYNORMAL		7//���ٶ�
#define NET_DVR_PLAYSTARTAUDIO	9//������
#define NET_DVR_PLAYSTOPAUDIO	10//�ر�����
#define NET_DVR_PLAYSETPOS		12//�ı��ļ��طŵĽ��

typedef struct
{
    DWORD	dwSize;
    DWORD	dwPlayCmd;		/* �������� ���ļ���������*/
    DWORD	dwCmdParam;		/* ����������� */
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;		/* ��ǰ���ŵ�ý���ļ����� */
    DWORD dwCurMediaFilePosition;	/* ��ǰ�����ļ��Ĳ���λ�� */
    DWORD dwCurMediaFileDuration;	/* ��ǰ�����ļ�����ʱ�� */
    DWORD dwCurPlayTime;			/* ��ǰ�Ѿ����ŵ�ʱ�� */
    DWORD dwCurMediaFIleFrames;		/* ��ǰ�����ļ�����֡�� */
    DWORD dwCurDataType;			/* ��ǰ�����������ͣ�19-�ļ�ͷ��20-����ݣ� 21-���Ž����־ */
    BYTE res[72];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

//2009-4-11 added by likui ��·������new
typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD	wTransProtol;		//����Э�飬0-TCP, 1-UDP, 2-MCAST
    WORD	wPassivePort;		//UDP�˿�, TCPʱĬ��
    NET_DVR_IPADDR  struMcastIP;	//TCP,UDPʱ��Ч, MCASTʱΪ�ಥ��ַ
    BYTE	byStreamType;/* ��ݲ���ģʽ:REAL_TIME_STREAM(1)ʵʱ��,RECORD_STREAM(2)�ļ��� */
    BYTE	byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE, *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30
{
    BYTE  byTranChanEnable;	        /* ��ǰ͸��ͨ���Ƿ�� 0���ر� 1���� */
    BYTE  byLocalSerialDevice;      /* Local serial device */
									/*
                                    *  ��·������������1��485���ڣ�1��232���ڶ�������Ϊ͸��ͨ��,�豸�ŷ������£�
                                    *  0 RS485
                                    *  1 RS232 Console
									*  2 Dual Scom
	                                */
    BYTE  byRemoteSerialDevice;		/* Remote output serial device */
									/*
                                    *  Զ�̴��������������,һ��RS232��һ��RS485
                                    *  1 ��ʾ232����
                                    *  2 ��ʾ485����
	                                */
    BYTE  byRes1;					/* ���� */
    NET_DVR_IPADDR struRemoteDevIP; /* Remote Device IP */
    WORD  wRemoteDevPort;		    /* Remote Net Communication Port */
    BYTE  byIsEstablished;			/* ͸��ͨ�������ɹ���־��0-û�гɹ���1-�����ɹ� */
    BYTE  byRes2;				    /* ���� */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE  byUsername[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
	DWORD dwLocalSerialNo;          /* ���ش��� */
	DWORD dwRemoteSerialNo;         /* Զ�̴��� */
    BYTE  byRes3[8];
} NET_DVR_MATRIX_TRAN_CHAN_INFO_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG
{
    DWORD dwSize;
    BYTE  by232IsDualChan; /* ������·232͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE  by485IsDualChan; /* ������·485͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE  byRes[2];	       /* ���� */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*ͬʱ֧�ֽ���MAX_SERIAL_NUM��͸��ͨ��*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;

typedef struct
{
    DWORD								dwEnable;	/* �Ƿ����� 0���� 1������*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG	streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO 		struDevChanInfo;		/* ��Ѳ����ͨ����Ϣ */
}NET_DVR_MATRIX_CHAN_INFO_V30,*LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD							dwSize;
    DWORD							dwPoolTime;		/*��Ѳ���*/
    NET_DVR_MATRIX_CHAN_INFO_V30	struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE               				byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30,*LPNET_DVR_MATRIX_LOOP_DECINFO_V30;


typedef struct tagDEC_MATRIX_CHAN_INFO_V30
{
    DWORD	dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;	/*��ý�����������*/
    NET_DVR_DEV_CHAN_INFO 			  struDevChanInfo;		/* ����ͨ����Ϣ */
    DWORD	dwDecState;		/* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;		/* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;		/* ��ʱ��ط�ֹͣʱ�� */
    char    sFileName[128];		/* ���ļ��ط��ļ��� */
    DWORD   dwGetStreamMode;	/*ȡ��ģʽ:1-������2-����*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE	byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

#define MAX_RESOLUTIONNUM    64 //֧�ֵ����ֱ�����Ŀ
typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];     /*VGA֧�ֵĴ���ģʽ��VGA1�����ɻ�����*/
    BYTE  byBNCWindowMode[4];       	/*BNC֧�ֵĴ���ģʽ*/
    BYTE  byDspNums;
    BYTE  byHDMINums;//HDMI��ʾͨ�������25��ʼ��
    BYTE  byDVINums;//DVI��ʾͨ�������29��ʼ��
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM];//���������ö�ٶ���,һ���ֽڴ��һ���ֱ�����//��֧�֣�1��֧�֣�0����֧��
    BYTE  byHDMIWindowMode[4][8];//HDMI֧�ֵĴ���ģʽ
    BYTE  byDVIWindowMode[4][8];//DVI֧�ֵĴ���ģʽ
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY, *LPNET_DVR_MATRIX_ABILITY;
//�ϴ�logo�ṹ
typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD		dwCorordinateX;	//ͼƬ��ʾ����X���
    DWORD		dwCorordinateY;	//ͼƬ��ʾ����Y���
    WORD        wPicWidth; //ͼƬ��
    WORD        wPicHeight; //ͼƬ��
    BYTE        byRes1[4];
    BYTE        byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE        byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE		byRes2[6];				//����
    DWORD		dwLogoSize;//LOGO��С������BMP���ļ�ͷ
}NET_DVR_DISP_LOGOCFG,*LPNET_DVR_DISP_LOGOCFG;

/*��������*/
#define NET_DVR_ENCODER_UNKOWN 0 /*δ֪�����ʽ*/
#define NET_DVR_ENCODER_H264   1 /*˽�� 264*/
#define NET_DVR_ENCODER_S264   2 /*Standard H264*/
#define NET_DVR_ENCODER_MPEG4  3 /*MPEG4*/
#define NET_DVR_ORIGINALSTREAM 4 /*Original Stream*/
#define NET_DVR_PICTURE		   5/*Picture*/
#define NET_DVR_ENCODER_MJPEG  6
#define NET_DVR_ENCODER_MPEG2  7
#define NET_DVR_ENCODER_H265   8
/* ����ʽ */
#define NET_DVR_STREAM_TYPE_UNKOWN   0     /*δ֪����ʽ*/
#define NET_DVR_STREAM_TYPE_PRIVT    1     /*˽�и�ʽ*/
#define NET_DVR_STREAM_TYPE_TS       7   /* TS��� */
#define NET_DVR_STREAM_TYPE_PS       8   /* PS��� */
#define NET_DVR_STREAM_TYPE_RTP      9    /* RTP��� */
#define NET_DVR_STREAM_TYPE_ORIGIN   10 //δ���(��Ƶ�ۺ�ƽ̨������ϵͳ��)

/*����ͨ��״̬*/
typedef struct
{
    BYTE  byDecodeStatus; /*��ǰ״̬:0:δ������1����������*/
    BYTE  byStreamType;    /*��������*/
    BYTE  byPacketType;     /*���ʽ*/
    BYTE  byRecvBufUsage; /*���ջ���ʹ����*/
    BYTE  byDecBufUsage; /*���뻺��ʹ����*/
    BYTE  byFpsDecV; /*��Ƶ����֡��*/
    BYTE  byFpsDecA; /*��Ƶ����֡��*/
    BYTE  byCpuLoad;     /*DSP CPUʹ����*/
    BYTE  byRes1[4];
    DWORD dwDecodedV; /*�������Ƶ֡*/
    DWORD dwDecodedA; /*�������Ƶ֡*/
    WORD wImgW; /*��������ǰ��ͼ���С,��*/
    WORD wImgH; //��
    BYTE byVideoFormat; /*��Ƶ��ʽ:0-NON,NTSC--1,PAL--2*/
    BYTE  byRes2[3];
    DWORD  dwDecChan;       /*��ȡȫ������ͨ��״̬ʱ��Ч������ʱ����0*/
    BYTE  byRes3[20];
}NET_DVR_MATRIX_CHAN_STATUS, *LPNET_DVR_MATRIX_CHAN_STATUS;

/*��ʾͨ��״̬*/
#define NET_DVR_MAX_DISPREGION 16         /*ÿ����ʾͨ����������ʾ�Ĵ���*/
//�ֱ���
//
typedef enum
{
    /*VGA*/
    VGA_NOT_AVALIABLE,
        VGA_THS8200_MODE_SVGA_60HZ,    //(800*600)
        VGA_THS8200_MODE_SVGA_75HZ,    //(800*600)
        VGA_THS8200_MODE_XGA_60HZ,     //(1024*768)
        VGA_THS8200_MODE_XGA_75HZ,     //(1024*768)
        VGA_THS8200_MODE_SXGA_60HZ,    //(1280*1024)
        VGA_THS8200_MODE_720P_60HZ,    //(1280*720)
        VGA_THS8200_MODE_1080I_60HZ,   //(1920*1080)
        VGA_THS8200_MODE_1080P_30HZ,   //(1920*1080)
        VGA_THS8200_MODE_UXGA_30HZ,    //(1600*1200)
        /*HDMI*/
        HDMI_SII9134_MODE_XGA_60HZ,	   //(1024*768)
        HDMI_SII9134_MODE_SXGA_60HZ,   //(1280*1024)
        HDMI_SII9134_MODE_SXGA2_60HZ,  //(1280*960)
        HDMI_SII9134_MODE_720P_60HZ,   //(1280*720)
        HDMI_SII9134_MODE_720P_50HZ,   //(1280*720)
        HDMI_SII9134_MODE_1080I_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080I_50HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_25HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_30HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_50HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_UXGA_60HZ,   //(1600*1200)
        /*DVI*/
        DVI_SII9134_MODE_XGA_60HZ,	   //(1024*768)
        DVI_SII9134_MODE_SXGA_60HZ,	   //(1280*1024)
        DVI_SII9134_MODE_SXGA2_60HZ,   //(1280*960)
        DVI_SII9134_MODE_720P_60HZ,	   //(1280*720)
        DVI_SII9134_MODE_720P_50HZ,    //(1280*720)
        DVI_SII9134_MODE_1080I_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080I_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_25HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_30HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_UXGA_60HZ,     //(1600*1200)
        VGA_DECSVR_MODE_SXGA2_60HZ,
        HDMI_DECSVR_MODE_1080P_24HZ,
        DVI_DECSVR_MODE_1080P_24HZ,
        YPbPr_DECSVR_MODE_720P_60HZ,
        YPbPr_DECSVR_MODE_1080I_60HZ
}VGA_MODE;

//��֡�ʶ���
#define           LOW_DEC_FPS_1_2                51
#define           LOW_DEC_FPS_1_4                52
#define           LOW_DEC_FPS_1_8                53
#define           LOW_DEC_FPS_1_16               54

/*��Ƶ��ʽ��׼*/
typedef enum
{
    VS_NON = 0,
        VS_NTSC = 1,
        VS_PAL = 2
}VIDEO_STANDARD;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{
    DWORD	dwSize;
    BYTE	byAudio;			/*��Ƶ�Ƿ���,0-��1-��*/
    BYTE    byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE 	byVgaResolution;      /*VGA�ķֱ���*/
    BYTE	byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD	dwWindowMode;		/*����ģʽ,����������ȡ,Ŀǰ֧��1,2,4,9,16*/
    BYTE	byJoinDecChan[MAX_WINDOWS];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE	byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    union
    {
        BYTE byRes[16];
        struct
        {
            /*�����Ӵ��ڶ�Ӧ����ͨ�����Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
            BYTE	 byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE	 byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*��ֹ����壬0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-�����������ʾͨ������*/
    BYTE		byUnionType;
    BYTE		byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
}NET_DVR_VGA_DISP_CHAN_CFG,*LPNET_DVR_VGA_DISP_CHAN_CFG;


/*��ʾͨ��״̬*/
#define NET_DVR_MAX_DISPREGION 16 /*ÿ����ʾͨ����������ʾ�Ĵ���*/
typedef struct
{
    BYTE  byDispStatus;          /*��ʾ״̬��0��δ��ʾ��1��������ʾ*/
    BYTE  byBVGA;                /*0-BNC��1-VGA�� 2-HDMI��3-DVI*/
    BYTE  byVideoFormat;        /*��Ƶ��ʽ:1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;        /*��ǰ����ģʽ*/
    BYTE  byJoinDecChan[MAX_WINDOWS];        /*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE  byFpsDisp[NET_DVR_MAX_DISPREGION]; /*ÿ���ӻ������ʾ֡��*/
    BYTE  byScreenMode;			//��Ļģʽ0-��ͨ 1-����
    BYTE  byRes2[31];
}NET_DVR_DISP_CHAN_STATUS, *LPNET_DVR_DISP_CHAN_STATUS;

#define MAX_DECODECHANNUM   32//��·������������ͨ����
#define MAX_DISPCHANNUM   24//��·�����������ʾͨ����

/*�������豸״̬*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM]; /*����ͨ��״̬*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];  /*��ʾͨ��״̬*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];         /*��������״̬*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];       /*�������״̬*/
    BYTE byAudioInChanStatus;          /*�����Խ�״̬*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS,*LPNET_DVR_DECODER_WORK_STATUS;

//2009-12-1 ���ӱ������벥�ſ���
typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD	dwSize;
    DWORD	dwPlayCmd;		/* �������� ���ļ���������*/
    DWORD	dwCmdParam;		/* ����������� */
    BYTE	byRes[16];//Reverse
}NET_DVR_PASSIVEDECODE_CONTROL,*LPNET_DVR_PASSIVEDECODE_CONTROL;

#define		PASSIVE_DEC_PAUSE			1	/*����������ͣ(���ļ�����Ч)*/
#define		PASSIVE_DEC_RESUME			2	/*�ָ���������(���ļ�����Ч)*/
#define 	PASSIVE_DEC_FAST          	3   /*���ٱ�������(���ļ�����Ч)*/
#define 	PASSIVE_DEC_SLOW			4   /*���ٱ�������(���ļ�����Ч)*/
#define 	PASSIVE_DEC_NORMAL      	5   /*�������(���ļ�����Ч)*/
#define 	PASSIVE_DEC_ONEBYONE      	6  /*�������뵥֡����(����)*/
#define 	PASSIVE_DEC_AUDIO_ON 		7   /*��Ƶ����*/
#define 	PASSIVE_DEC_AUDIO_OFF		8  	 /*��Ƶ�ر�*/
#define		PASSIVE_DEC_RESETBUFFER	    9    /*��ջ�����*/
//2009-12-16 ���ӿ��ƽ���������ͨ������
typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{
    DWORD	dwSize;
    BYTE	byDecChanScaleStatus;/*����ͨ����ʾ���ſ���,1��ʾ������ʾ��0��ʾ��ʵ��ʾ*/
    BYTE    byDecodeDelay;//������ʱ��0-Ĭ�ϣ�1-ʵʱ�Ժã�2-ʵʱ�ԽϺã�3-ʵʱ���У��������У�4-�����ԽϺã�5-�����Ժã�0xff-�Զ�����
    BYTE    byEnableSpartan;//����ʹ�ܣ�0-�أ�1-��
    BYTE    byLowLight;      //���նȡ�0-�أ�1-8�����նȵȼ����ȼ�Խ��ǿ��Խ��
    BYTE    byNoiseReduction; //3D���룬0-�أ�1-����2-�Զ�
    BYTE    byDefog;         //͸�?0-�أ�1-7���͸��ȼ����ȼ�Խ��ǿ��Խ��
    BYTE    byEnableVcaDec; //�Ƿ��������ܽ��룬0-�����ã���0-����
    BYTE    byRes1;
    DWORD   dwAllCtrlType;	//�����Ӵ���һ����������ͣ�����ʱ��Ч����λ��ʾ
	//dwAllCtrlType & 0x01,�����ر����ܽ���
	BYTE	byRes[56];
}NET_DVR_MATRIX_DECCHAN_CONTROL,*LPNET_DVR_MATRIX_DECCHAN_CONTROL;

/************************************��·������(end)***************************************/
//2009-8-19 ��Ƶ�ۺ�ƽ̨�ӿں���
/************************************��Ƶ�ۺ�ƽ̨(begin)***************************************/
#define MAX_SUBSYSTEM_NUM	80   //һ������ϵͳ�������ϵͳ����
#define MAX_SERIALLEN		36  //������кų���
#define MAX_LOOPPLANNUM		16//���ƻ��л���
#define DECODE_TIMESEGMENT 4//�ƻ�����ÿ��ʱ�����
typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE		bySubSystemType;//��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��
    BYTE		byChan;//��ϵͳͨ������������ϵͳ�����485�����������˲���ֻ�ܻ�ȡ��
    BYTE		byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-�����
    BYTE		byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;		/*IP��ַ�����޸ģ�*/
    WORD		wSubSystemPort;        //��ϵͳ�˿ںţ����޸ģ�
    BYTE		byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask;//��������
    NET_DVR_IPADDR	struGatewayIpAddr;	/* ��ص�ַ*/
    BYTE		sUserName[NAME_LEN];	/* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE		sPassword[PASSWD_LEN];	/*���루�˲���ֻ�ܻ�ȡ��*/
    char		sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char 		sDnsAddress[MAX_DOMAIN_NAME];/*DNS�����IP��ַ*/
    BYTE		sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
}NET_DVR_SUBSYSTEMINFO, *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO, *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct  tagNET_DVR_LOOPPLAN_SUBCFG
{
    DWORD 						    dwSize;
    DWORD							dwPoolTime;		/*��Ѳ�������λ����*/
    NET_DVR_MATRIX_CHAN_INFO_V30 struChanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE               				byRes[16];
}NET_DVR_LOOPPLAN_SUBCFG,*LPNET_DVR_LOOPPLAN_SUBCFG;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD 	dwSize;
    BYTE	byAlarmMode;//�����������ͣ�1-��Ѳ��2-����
    WORD	wLoopTime;//��Ѳʱ��, ��λ����
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG,*LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD			dwSize;
    NET_DVR_IPADDR   struIP;		/*�����IP��ַ*/
    WORD		wPort;        			//������˿ں�
    BYTE		byRes1[6];
    BYTE		sUserName[NAME_LEN];	/* �û��� */
    BYTE		sPassword[PASSWD_LEN];	/*���� */
    BYTE        byChan;//�����485��
    BYTE		by485Port;//485�ڵ�ַ
    BYTE		byRes2[14];
} NET_DVR_CODESPLITTERINFO, *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE	byAssociateType;//�������ͣ�1-����
    WORD	wAlarmDelay;//������ʱ��0��5�룻1��10�룻2��30�룻3��1���ӣ�4��2���ӣ�5��5���ӣ�6��10���ӣ�
    BYTE	byAlarmNum;//�����ţ������ֵ��Ӧ�ø�����ͬ�ı�������ͬ��ֵ
    BYTE	byRes[8];
} NET_DVR_ASSOCIATECFG,*LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD						    dwSize;
    NET_DVR_ASSOCIATECFG   		struAssociateCfg;//������̬��������ṹ
    NET_DVR_PU_STREAM_CFG		struPuStreamCfg;//��̬����ṹ
    BYTE							byRes[8];
}NET_DVR_DYNAMICDECODE,*LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime;//
    BYTE  byDecodeType;/*0-�ޣ�1-��Ѳ���룬2-��̬����*/
    BYTE  byLoopGroup;//��Ѳ���
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec;//��̬����
} NET_DVR_DECODESCHED, *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT];//��һ��Ϊ��ʼ����9000һ��
    BYTE byRes[8];
} NET_DVR_PLANDECODE,*LPNET_DVR_PLANDECODE;

//end
/************************************��Ƶ�ۺ�ƽ̨(end)***************************************/
typedef struct
{	/* 12 bytes */
    DWORD	dwSize;
    char	sUserName[32];
    char 	sPassWord[32];
    char 	sFromName[32];			/* Sender *///�ַ��еĵ�һ���ַ�����һ���ַ�����"@",�����ַ���Ҫ��"@"�ַ�
    char 	sFromAddr[48];			/* Sender address */
    char 	sToName1[32];			/* Receiver1 */
    char 	sToName2[32];			/* Receiver2 */
    char 	sToAddr1[48];			/* Receiver address1 */
    char 	sToAddr2[48];			/* Receiver address2 */
    char	sEmailServer[32];		/* Email server address */
    BYTE	byServerType;			/* Email server type: 0-SMTP, 1-POP, 2-IMTP��*/
    BYTE	byUseAuthen;			/* Email server authentication method: 1-enable, 0-disable */
    BYTE	byAttachment;			/* enable attachment */
    BYTE	byMailinterval;			/* mail interval 0-2s, 1-3s, 2-4s. 3-5s*/
} NET_DVR_EMAILCFG, *LPNET_DVR_EMAILCFG;

typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;	//��ʱ¼��
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;	//�¼�����¼��
}NET_DVR_COMPRESSIONCFG_NEW, *LPNET_DVR_COMPRESSIONCFG_NEW;

//���λ����Ϣ
typedef struct
{
    WORD wAction;//��ȡʱ���ֶ���Ч
    WORD wPanPos;//ˮƽ����
    WORD wTiltPos;//��ֱ����
    WORD wZoomPos;//�䱶����
}NET_DVR_PTZPOS, *LPNET_DVR_PTZPOS;

//���Χ��Ϣ
typedef struct
{
    WORD wPanPosMin;//ˮƽ����min
    WORD wPanPosMax;//ˮƽ����max
    WORD wTiltPosMin;//��ֱ����min
    WORD wTiltPosMax;//��ֱ����max
    WORD wZoomPosMin;//�䱶����min
    WORD wZoomPosMax;//�䱶����max
}NET_DVR_PTZSCOPE, *LPNET_DVR_PTZSCOPE;

//rtsp���� ipcameraר��
typedef struct
{
    DWORD dwSize;         //����
    WORD  wPort;          //rtsp����������˿�
    BYTE  byReserve[54];  //Ԥ��
}NET_DVR_RTSPCFG, *LPNET_DVR_RTSPCFG;

/********************************�ӿڲ���ṹ(begin)*********************************/

//NET_DVR_Login()����ṹ
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];   //���к�
    BYTE byAlarmInPortNum;		        //DVR�����������
    BYTE byAlarmOutPortNum;		        //DVR�����������
    BYTE byDiskNum;				        //DVRӲ�̸���
    BYTE byDVRType;				        //DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;				        //DVR ͨ������
    BYTE byStartChan;			        //��ʼͨ����,����DVS-1,DVR - 1
}NET_DVR_DEVICEINFO, *LPNET_DVR_DEVICEINFO;

//NET_DVR_Login_V30()����ṹ
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    BYTE byAlarmInPortNum;		        //�����������
    BYTE byAlarmOutPortNum;		        //�����������
    BYTE byDiskNum;				    //Ӳ�̸���
    BYTE byDVRType;				    //�豸����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;				    //ģ��ͨ������
    BYTE byStartChan;			        //��ʼͨ����,����DVS-1,DVR - 1
    BYTE byAudioChanNum;                //����ͨ����
    BYTE byIPChanNum;					//�������ͨ�������λ
    BYTE byZeroChanNum;			//��ͨ��������� //2010-01-16
    BYTE byMainProto;			//����������Э������ 0-private, 1-rtsp,2-ͬʱ֧��private��rtsp
    BYTE bySubProto;				//����������Э������0-private, 1-rtsp,2-ͬʱ֧��private��rtsp
    BYTE bySupport;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧�֣�
    //bySupport & 0x1, ��ʾ�Ƿ�֧����������
    //bySupport & 0x2, ��ʾ�Ƿ�֧�ֱ���
    //bySupport & 0x4, ��ʾ�Ƿ�֧��ѹ������������ȡ
    //bySupport & 0x8, ��ʾ�Ƿ�֧�ֶ���
    //bySupport & 0x10, ��ʾ֧��Զ��SADP
    //bySupport & 0x20, ��ʾ֧��Raid������
    //bySupport & 0x40, ��ʾ֧��IPSAN Ŀ¼����
    //bySupport & 0x80, ��ʾ֧��rtp over rtsp
    BYTE bySupport1;        // ���������䣬λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport1 & 0x1, ��ʾ�Ƿ�֧��snmp v30
    //bySupport1 & 0x2, ֧����ֻطź�����
    //bySupport1 & 0x4, �Ƿ�֧�ֲ������ȼ�
    //bySupport1 & 0x8, �����豸�Ƿ�֧�ֲ���ʱ�����չ
    //bySupport1 & 0x10, ��ʾ�Ƿ�֧�ֶ�������33����
    //bySupport1 & 0x20, ��ʾ�Ƿ�֧��rtsp over http
    //bySupport1 & 0x80, ��ʾ�Ƿ�֧�ֳ����±�����Ϣ2012-9-28, �һ���ʾ�Ƿ�֧��NET_DVR_IPPARACFG_V40�ṹ��
    BYTE bySupport2; /*������λ����Ϊ0��ʾ��֧�֣���0��ʾ֧��
                     bySupport2 & 0x1, ��ʾ�������Ƿ�֧��ͨ��URLȡ������
                     bySupport2 & 0x2,  ��ʾ֧��FTPV40
                     bySupport2 & 0x4,  ��ʾ֧��ANR
                     bySupport2 & 0x8,  ��ʾ֧��CCD��ͨ����������
                     bySupport2 & 0x10,  ��ʾ֧�ֲ��������ش���Ϣ����֧��ץ�Ļ� ���ϱ����ṹ��
                     bySupport2 & 0x20,  ��ʾ�Ƿ�֧�ֵ�����ȡ�豸״̬����
    bySupport2 & 0x40,  ��ʾ�Ƿ������������豸*/
    WORD wDevType;              //�豸�ͺ�
    BYTE bySupport3; //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport3 & 0x1, ��ʾ�Ƿ������
    // bySupport3 & 0x4 ��ʾ֧�ְ������ã� ����� ͨ��ͼ�������������IP�������롢����������
    // �û������豸����״̬��JPEGץͼ����ʱ��ʱ��ץͼ��Ӳ���������
    //bySupport3 & 0x8Ϊ1 ��ʾ֧��ʹ��TCPԤ����UDPԤ�����ಥԤ���е�"��ʱԤ��"�ֶ���������ʱԤ��������ʹ�����ַ�ʽ������ʱԤ��������bySupport3 & 0x8Ϊ0ʱ����ʹ�� "˽����ʱԤ��"Э�顣
    //bySupport3 & 0x10 ��ʾ֧��"��ȡ����������Ҫ״̬��V40��"��
    //bySupport3 & 0x20 ��ʾ�Ƿ�֧��ͨ��DDNS�������ȡ��

    BYTE byMultiStreamProto;//�Ƿ�֧�ֶ�����,��λ��ʾ,0-��֧��,1-֧��,bit1-����3,bit2-����4,bit7-��������bit-8������
    BYTE byStartDChan;		//��ʼ����ͨ����,0��ʾ��Ч
    BYTE byStartDTalkChan;	//��ʼ���ֶԽ�ͨ���ţ������ģ��Խ�ͨ���ţ�0��ʾ��Ч
    BYTE byHighDChanNum;		//����ͨ�������λ
    BYTE bySupport4;        //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport4 & 0x4��ʾ�Ƿ�֧��ƴ��ͳһ�ӿ�
    // bySupport4 & 0x80 ֧���豸�ϴ����ı���ʹ�ܡ���ʾ�жϵ��ýӿ��� NET_DVR_PDC_RULE_CFG_V42���� NET_DVR_PDC_RULE_CFG_V41
    BYTE byLanguageType;// ֧����������,��λ��ʾ,ÿһλ0-��֧��,1-֧��
    //  byLanguageType ����0 ��ʾ ���豸
    //  byLanguageType & 0x1��ʾ֧������
    //  byLanguageType & 0x2��ʾ֧��Ӣ��
    BYTE byVoiceInChanNum;   //��Ƶ����ͨ����
    BYTE byStartVoiceInChanNo; //��Ƶ������ʼͨ���� 0��ʾ��Ч
    BYTE  bySupport5;  //��λ��ʾ,0-��֧��,1-֧��,bit0-֧�ֶ�����
    //bySupport5 &0x01��ʾ֧��wEventTypeEx ,����dwEventType ���¼����ͣ�֧����Ϊ�¼���չ��--��ռס����ֹ��ͻ
    //bySupport5 &0x04��ʾ�Ƿ�֧��ʹ����չ�ĳ���ģʽ�ӿ�
    /*
       bySupport5 &0x08 �豸���ظ�ֵ��ʾ�Ƿ�֧�ּƻ�¼������V40�ӿ�Э��(DVR_SET_RECORDCFG_V40/ DVR_GET_RECORDCFG_V40)(�ڸ�Э�����豸֧����������13������)
       ֮ǰ�Ĳ��ַ������豸��֧��¼������13��������¼������13�����֧�֣�ͳһת����¼������3���ݴ��?SDKͨ������̽�⴦��)
    */
    BYTE  bySupport6;   //��������λ��ʾ��0-��֧��,1-֧��
    //bySupport6 0x1  ��ʾ�豸�Ƿ�֧��ѹ��
    //bySupport6 0x2 ��ʾ�Ƿ�֧����ID��ʽ��������Դ��չ���DVR_SET_STREAM_SRC_INFO_V40
    //bySupport6 0x4 ��ʾ�Ƿ�֧���¼�����V40�ӿ�
    //bySupport6 0x8 ��ʾ�Ƿ�֧����չ���������������
    //bySupport6 0x40��ʾͼƬ��ѯ���V40��չ
    BYTE  byMirrorChanNum;    //����ͨ������<¼�����������ڱ�ʾ����ͨ��>
    WORD wStartMirrorChanNo;  //��ʼ����ͨ����
    BYTE bySupport7;   //����,��λ��ʾ,0-��֧��,1-֧��
    // bySupport7 & 0x1  ��ʾ�豸�Ƿ�֧�� INTER_VCA_RULECFG_V42 ��չ
    // bySupport7 & 0x2  ��ʾ�豸�Ƿ�֧�� IPC HVT ģʽ��չ
    // bySupport7 & 0x04  ��ʾ�豸�Ƿ�֧�� ������ʱ��
    // bySupport7 & 0x08  ��ʾ������̨PTZλ��ʱ���Ƿ�֧�ִ�ͨ����
    // bySupport7 & 0x10  ��ʾ�豸�Ƿ�֧��˫ϵͳ���
    // bySupport7 & 0x20  ��ʾ�豸�Ƿ�֧�� OSD�ַ���� V50
    // bySupport7 & 0x40  ��ʾ�豸�Ƿ�֧�� ���Ӹ��٣��������
    // bySupport7 & 0x80  ��ʾ�豸�Ƿ�֧�� ���ļ���
    BYTE  byRes2;		//����
}NET_DVR_DEVICEINFO_V30, *LPNET_DVR_DEVICEINFO_V30;

typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //�豸֧�����ܣ����ֶ���SDK����豸����ֵ����ֵ�ġ�bySupportLockΪ1ʱ��dwSurplusLockTime��byRetryLoginTime��Ч
    BYTE  byRetryLoginTime;	    //ʣ��ɳ��Ե�½�Ĵ����û����������ʱ���˲�����Ч
    BYTE  byPasswordLevel;      //admin���밲ȫ�ȼ�0-��Ч��1-Ĭ�����룬2-��Ч����,3-���սϸߵ����롣���û�������Ϊ����Ĭ�����루12345�����߷��սϸߵ�����ʱ���ϲ�ͻ�����Ҫ��ʾ�û�������롣
    BYTE  byRes1;
    DWORD dwSurplusLockTime;	//ʣ��ʱ�䣬��λ�룬�û���ʱ���˲�����Ч
    BYTE  byCharEncodeType;     //�ַ��������
    BYTE byRes2[255];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

typedef void (CALLBACK *fLoginResultCallBack) (LONG lUserID, DWORD dwResult, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo , void* pUser);

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64


typedef struct
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byRes1;
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType; //0:��ʹ�ô��?1��ʹ�ñ�׼���?2��ʹ��EHome����
    BYTE byUseUTCTime;	//0-������ת����Ĭ��,1-�ӿ����������ȫ��ʹ��UTCʱ��,SDK���UTCʱ�����豸ʱ���ת��,2-�ӿ����������ȫ��ʹ��ƽ̨����ʱ�䣬SDK���ƽ̨����ʱ�����豸ʱ���ת��
    BYTE byRes2[2];
    LONG iProxyID;    //�����������ţ���Ӵ����������Ϣʱ�����Ӧ�ķ����������±�ֵ
    BYTE byRes3[120];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;

//sdk���绷��ö�ٱ���������Զ����
typedef enum _SDK_NET_ENV
{
    LOCAL_AREA_NETWORK = 0,
        WIDE_AREA_NETWORK
}SDK_NETWORK_ENVIRONMENT;

//��ʾģʽ
typedef enum
{
    NORMALMODE = 0,
        OVERLAYMODE
}DISPLAY_MODE;

//����ģʽ
typedef enum
{
    PTOPTCPMODE = 0,
        PTOPUDPMODE,
        MULTIMODE,
        RTPMODE,
        RESERVEDMODE
}SEND_MODE;

//ץͼģʽ
typedef enum
{
    BMP_MODE = 0,		//BMPģʽ
        JPEG_MODE = 1		//JPEGģʽ
}CAPTURE_MODE;

//ʵʱ����ģʽ
typedef enum
{
    MONOPOLIZE_MODE = 1,//��ռģʽ
        SHARE_MODE = 2		//����ģʽ
}REALSOUND_MODE;

//�����Ԥ������
typedef struct
{
    LONG lChannel;//ͨ����
    LONG lLinkMode;//���λ(31)Ϊ0��ʾ��������Ϊ1��ʾ�ӣ�0��30λ��ʾ�������ӷ�ʽ: 0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-RTP/RTSP,5-RSTP/HTTP
    HWND hPlayWnd;//���Ŵ��ڵľ��,ΪNULL��ʾ������ͼ��
    char* sMultiCastIP;//�ಥ���ַ
    BYTE byProtoType; //Ӧ�ò�ȡ��Э�飬0-˽��Э�飬1-RTSPЭ��
    BYTE byRes[3];
}NET_DVR_CLIENTINFO, *LPNET_DVR_CLIENTINFO;

//SDK״̬��Ϣ(9000����)
typedef struct
{
    DWORD dwTotalLoginNum;		//��ǰlogin�û���
    DWORD dwTotalRealPlayNum;	//��ǰrealplay·��
    DWORD dwTotalPlayBackNum;	//��ǰ�طŻ�����·��
    DWORD dwTotalAlarmChanNum;	//��ǰ��������ͨ��·��
    DWORD dwTotalFormatNum;		//��ǰӲ�̸�ʽ��·��
    DWORD dwTotalFileSearchNum;	//��ǰ��־���ļ�����·��
    DWORD dwTotalLogSearchNum;	//��ǰ��־���ļ�����·��
    DWORD dwTotalSerialNum;	    //��ǰ͸��ͨ��·��
    DWORD dwTotalUpgradeNum;	//��ǰ��·��
    DWORD dwTotalVoiceComNum;	//��ǰ����ת��·��
    DWORD dwTotalBroadCastNum;	//��ǰ�����㲥·��
    DWORD dwTotalListenNum;	    //��ǰ�������·��
    DWORD dwEmailTestNum;       //��ǰ�ʼ�����·��
    DWORD dwBackupNum;          // ��ǰ�ļ�����·��
    DWORD dwTotalInquestUploadNum; //��ǰ��Ѷ�ϴ�·��
    DWORD dwRes[6];
}NET_DVR_SDKSTATE, *LPNET_DVR_SDKSTATE;

//SDK����֧����Ϣ(9000����)
typedef struct
{
    DWORD dwMaxLoginNum;		//���login�û��� MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;		//���realplay·�� WATCH_NUM
    DWORD dwMaxPlayBackNum;		//���طŻ�����·�� WATCH_NUM
    DWORD dwMaxAlarmChanNum;	//���������ͨ��·�� ALARM_NUM
    DWORD dwMaxFormatNum;		//���Ӳ�̸�ʽ��·�� SERVER_NUM
    DWORD dwMaxFileSearchNum;	//����ļ�����·�� SERVER_NUM
    DWORD dwMaxLogSearchNum;	//�����־����·�� SERVER_NUM
    DWORD dwMaxSerialNum;	    //���͸��ͨ��·�� SERVER_NUM
    DWORD dwMaxUpgradeNum;	    //�����·�� SERVER_NUM
    DWORD dwMaxVoiceComNum;		//�������ת��·�� SERVER_NUM
    DWORD dwMaxBroadCastNum;	//��������㲥·�� MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL, *LPNET_DVR_SDKABL;

//�����豸��Ϣ
typedef struct
{
    BYTE byUserIDValid;                 /* userid�Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE bySerialValid;                 /* ���к��Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byVersionValid;                /* �汾���Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byDeviceNameValid;             /* �豸�����Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byMacAddrValid;                /* MAC��ַ�Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byLinkPortValid;               /* login�˿��Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byDeviceIPValid;               /* �豸IP�Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE bySocketIPValid;               /* socket ip�Ƿ���Ч 0-��Ч��1-��Ч */
    LONG lUserID;                       /* NET_DVR_Login()����ֵ, ����ʱ��Ч */
    BYTE sSerialNumber[SERIALNO_LEN];	/* ���к� */
    DWORD dwDeviceVersion;			    /* �汾��Ϣ ��16λ��ʾ���汾����16λ��ʾ�ΰ汾*/
    char sDeviceName[NAME_LEN];		    /* �豸���� */
    BYTE byMacAddr[MACADDR_LEN];		/* MAC��ַ */
    WORD wLinkPort;                     /* link port */
    char sDeviceIP[128];    			/* IP��ַ */
    char sSocketIP[128];    			/* ���������ϴ�ʱ��socket IP��ַ */
    BYTE byIpProtocol;                  /* IpЭ�� 0-IPV4, 1-IPV6 */
    BYTE byRes2[11];
}NET_DVR_ALARMER, *LPNET_DVR_ALARMER;

//Ӳ������ʾ�������(�ӽṹ)
typedef struct
{
    long bToScreen;
    long bToVideoOut;
    long nLeft;
    long nTop;
    long nWidth;
    long nHeight;
    long nReserved;
}NET_DVR_DISPLAY_PARA, *LPNET_DVR_DISPLAY_PARA;

//Ӳ����Ԥ������
typedef struct
{
    LONG lChannel;//ͨ����
    LONG lLinkMode; //���λ(31)Ϊ0��ʾ��������Ϊ1��ʾ�ӣ�0��30λ��ʾ�������ӷ�ʽ:0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-�绰�ߣ�5��128k���6��256k���7��384k���8��512k���
    char* sMultiCastIP;
    NET_DVR_DISPLAY_PARA struDisplayPara;
}NET_DVR_CARDINFO, *LPNET_DVR_CARDINFO;

//¼���ļ�����
typedef struct
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
}NET_DVR_FIND_DATA, *LPNET_DVR_FIND_DATA;

//¼���ļ�����(9000)
typedef struct
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
    BYTE byLocked;//9000�豸֧��,1��ʾ���ļ��Ѿ�����,0��ʾ����ļ�
    BYTE byFileType;  //�ļ�����:0����ʱ¼��,1-�ƶ���� ��2������������
    //3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ���,14-���ܽ�ͨ�¼�
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30, *LPNET_DVR_FINDDATA_V30;

//¼���ļ�����(cvr)
typedef struct
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
    BYTE byLocked;//9000�豸֧��,1��ʾ���ļ��Ѿ�����,0��ʾ����ļ�
    BYTE byFileType;  //�ļ�����:0����ʱ¼��,1-�ƶ���� ��2������������
    //3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ���,14-���ܽ�ͨ�¼�
    BYTE byQuickSearch; //0:��ͨ��ѯ���1�����٣������ѯ���
    BYTE byRes;
    DWORD dwFileIndex; //�ļ������
    BYTE byStreamType;
    BYTE byRes1[127];
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;

//¼���ļ�����(���)
typedef struct
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD, *LPNET_DVR_FINDDATA_CARD;


//¼���ļ����������ṹ
typedef struct
{
    LONG lChannel;//ͨ����
    DWORD dwFileType;//¼���ļ�����
	   //����ţ�0xff��ȫ����0����ʱ¼��,1-�ƶ���� ��2������������3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7-����¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    //��ţ�0xff��ȫ����0����ʱ¼��1-�ƶ���⣬2���ӽ��3������������4��������5-�������6���ֶ�¼��7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    DWORD dwIsLocked;//�Ƿ��� 0-���ļ�,1-���ļ�, 0xff��ʾ�����ļ�
    DWORD dwUseCardNo;//�Ƿ�ʹ�ÿ���
    BYTE sCardNumber[32];//����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
}NET_DVR_FILECOND, *LPNET_DVR_FILECOND;

//��̨����ѡ��Ŵ���С(˽�� ����ר��)
typedef struct
{
    int xTop;     //������ʼ���x���
    int yTop;     //���������y���
    int xBottom;  //���������x���
    int yBottom;  //���������y���
    int bCounter; //����
}NET_DVR_POINT_FRAME, *LPNET_DVR_POINT_FRAME;

//�����Խ�����
typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;   //��Ƶ�������� 0-OggVorbis;1-G711_U;2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM
    BYTE  byAudioSamplingRate;//��Ƶ������ 0-Ĭ�ϣ�1-16kHZ��2-32kHZ��3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// ��Ƶ���� �ο� BITRATE_ENCODE_INDEX
    BYTE  byres[4];//���ﱣ����Ƶ��ѹ������
    BYTE  bySupport;//bySupport Bit0��ʾ Mp2l2ǰ4���ֽڵĺ����ʾ����������Ƶ��ݳ���
}NET_DVR_COMPRESSION_AUDIO, *LPNET_DVR_COMPRESSION_AUDIO;

//2009-7-22


#define IW_ESSID_MAX_SIZE						 32
#define WIFI_WEP_MAX_KEY_COUNT					 4
#define WIFI_WEP_MAX_KEY_LENGTH					 33
#define WIFI_WPA_PSK_MAX_KEY_LENGTH				 63
#define WIFI_WPA_PSK_MIN_KEY_LENGTH				 8
#define WIFI_MAX_AP_COUNT						 20
#define WIFI_WPA_PSK_MAX_HEXKEY_LENGTH           68   //WPA16������Կ��󳤶�

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;						/* 0 mange ģʽ;1 ad-hocģʽ���μ�NICMODE */
    DWORD  dwSecurity;           /*0 �����ܣ�1 wep���ܣ�2 wpa-psk;3 wpa-Enterprise;4-WPA2_PSK�μ�WIFISECURITY*/
    DWORD  dwChannel;            /*1-11��ʾ11��ͨ��*/
    DWORD  dwSignalStrength;    /*0-100�ź���������Ϊ��ǿ*/
    DWORD  dwSpeed;               /*����,��λ��0.01mbps*/
}NET_DVR_AP_INFO,*LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;        /*����AP������������20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST,*LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{
    char sIpAddress[16];				/*IP��ַ*/
    char sIpMask[16];					/*����*/
    BYTE	byMACAddr[MACADDR_LEN];		/*�����ַ��ֻ������ʾ*/
    BYTE	byCloseWifi;		//�Ƿ�ر�wifi���ӣ�0-���رգ�1-�ر�
    BYTE	bRes;
    DWORD	dwEnableDhcp;				/*�Ƿ�����dhcp  0������ 1����*/
    DWORD	dwAutoDns;					/*�������dhcp�Ƿ��Զ���ȡdns,0���Զ���ȡ 1�Զ���ȡ�����������������dhcpĿǰ�Զ���ȡdns*/
    char sFirstDns[16];						 /*��һ��dns����*/
    char sSecondDns[16];					 /*�ڶ���dns����*/
    char sGatewayIpAddr[16]; 				/* ��ص�ַ*/
    BYTE   bRes2[8];
}NET_DVR_WIFIETHERNET,*LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;        /*wifi���*/
    char sEssid[IW_ESSID_MAX_SIZE];	 /*SSID*/
    DWORD dwMode;      /* 0 mange ģʽ;1 ad-hocģʽ���μ�*/
    DWORD dwSecurity; /*0-������;1-WEP����;2-WPA-personal; 3-WPA-enterprise;4-WPA2-personal;5-WPA2-enterprise */
    union
    {
        struct
        {
            DWORD dwAuthentication;/*0 -����ʽ 1-����ʽ*/
            DWORD dwKeyLength;/* 0 -64λ��1- 128λ��2-152λ*/
            DWORD dwKeyType;/*0 16����;1 ASCI */
            DWORD dwActive;/*0 ����0---3��ʾ����һ����Կ*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct
        {
            DWORD dwKeyLength;/*8-63��ASCII�ַ�*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2ģʽ�¼�������,0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//����Կ��֧��8-63��ASCII�ַ��Լ�64��ʮ�����ַ���Կ��
			//��byKeyTypeΪ0ʱ������sKeyInfo����byKeyTypeΪ1ʱ������sNewKeyInfo
			//��Կ���ͣ�0 ~ ����Կ���ͣ�ֻ֧��8-63��ASCII�ַ�1 ~����Կ���ͣ�֧��8-63��ASCII�ַ��Լ�64��ʮ�����ַ���Կ��
            BYTE byKeyType;
            BYTE byRes[7];
        }wpa_psk;
        struct
        {
            BYTE byEncryptType;  /*��������,0-AES, 1-TKIP*/
            BYTE byAuthType; //��֤���ͣ�0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byAuthType; //�ڲ���֤��ʽ��0-PAP��1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity [NAME_LEN]; //�������
                    BYTE byUserName[NAME_LEN]; //�û���
                    BYTE byPassword[NAME_LEN]; //����
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterprisģʽ����
                struct
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byAuthType; //�ڲ���֤��ʽ��0-GTC��1-MD5��2-MSCHAPV2
                    BYTE byPeapVersion; //PEAP�汾��0-�汾0��1-�汾1
                    BYTE byPeapLabel; //PEAP��ǩ��0-�ϱ�ǩ��1-�±�ǩ
                    BYTE byAnonyIdentity[NAME_LEN]; //�������
                    BYTE byUserName[NAME_LEN]; //�û���
                    BYTE byPassword[NAME_LEN]; //����
                    BYTE byRes[44];
                }EAP_PEAP; //WPA-enterprise/WPA2-enterprisģʽ����
                struct
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byRes1[3];
                    BYTE byIdentity[NAME_LEN]; //���
                    BYTE byPrivateKeyPswd[NAME_LEN]; //˽Կ����
                    BYTE byRes[76];
                }EAP_TLS;
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterprisģʽ����
    }key;
}NET_DVR_WIFI_CFG_EX,*LPNET_DVR_WIFI_CFG_EX;

//wifi���ýṹ
typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG,*LPNET_DVR_WIFI_CFG;

//wifi����״̬
typedef	 struct  tagNET_DVR_WIFI_CONNECT_STATUS
{
    DWORD		dwSize;
    BYTE		byCurStatus;	//1-�����ӣ�2-δ���ӣ�3-��������
    BYTE		byRes1[3];		//����
    DWORD		dwErrorCode;	// byCurStatus = 2ʱ��Ч,1-�û�����������,2-�޴�·����,3-δ֪����
    BYTE		byRes[244];
}NET_DVR_WIFI_CONNECT_STATUS,*LPNET_DVR_WIFI_CONNECT_STATUS;

//wifi����ģʽ
typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode; /*0 �Զ��л�ģʽ��1 ����ģʽ*/
}NET_DVR_WIFI_WORKMODE,*LPNET_DVR_WIFI_WORKMODE;

//�ṹ����궨��
#define VCA_MAX_POLYGON_POINT_NUM		10		//����������֧��10����Ķ����
#define MAX_RULE_NUM					8		//����������
#define MAX_RULE_NUM_V42                16      //������������չ
#define MAX_TARGET_NUM    				30		//���Ŀ�����
#define MAX_CALIB_PT 					6		//���궨�����
#define MIN_CALIB_PT 					4		//��С�궨�����
#define MAX_TIMESEGMENT_2	    		2		//���ʱ�����
#define DATA_INDEX_LEN                  64      //�����ˮ��
#define MAX_TRAFFIC_PICTURE_NUM         8      //��ͨͼƬ����
#define MAX_LICENSE_LEN					16		//���ƺ���󳤶�
#define MAX_CARDNO_LEN                  48      //������󳤶� 2013-11-04
#define MAX_OPERATE_INDEX_LEN           32      //��������󳤶�2014-03-03
#define MAX_PLATE_NUM					3		//���Ƹ���
#define MAX_MASK_REGION_NUM				4       //����ĸ���������
#define MAX_SEGMENT_NUM					6       //�����궨���������Ŀ
#define MIN_SEGMENT_NUM					3       //�����궨��С������Ŀ
#define MAX_REL_SNAPCHAN_NUM            3       //������ץͼͨ����
#define MAX_PIC_SWITCH_STORAGE_SERVER   64      //�ƴ洢�������洢�����ͼƬ������
#define MAX_INFO_SWITCH_STORAGE_SERVER  64      //�ƴ洢�������洢����󸽼���Ϣ������
#define RTMP_URL_LEN                    128     //RTMP URL ����
#define MAX_ID_LEN_128                  128     //�����ļ�ID����
#define MAX_DEBUGCMD_LEN                1024    //�豸����������󳤶�
#define MAX_DEBUGINFO_LEN               1400    //�豸������Ϣ��󳤶�
#define MAX_VEHICLE_ID_LEN              32      //�������ʶ����

//���ܿ�����Ϣ
#define MAX_VCA_CHAN  16//�������ͨ����
typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;		//�Ƿ�������
    BYTE   byVCAType;	    //�����������ͣ�VCA_CHAN_ABILITY_TYPE
    BYTE   byStreamWithVCA; //�������Ƿ��������Ϣ
    BYTE   byMode;			//ģʽ��ATM����ʱ����VCA_CHAN_MODE_TYPE ,TFS����ʱ����TFS_CHAN_MODE_TYPE
    BYTE   byControlType;   //�������ͣ���λ��ʾ��0-��1-��
    // byControlType &1 �Ƿ�����ץ�Ĺ���
    BYTE   byPicWithVCA ;// ����ץͼ����Ŀ����Ϣ(Ŀ���)��0-�����ӣ�Ĭ�ϣ���1-���ӣ�
    BYTE   byRes[2]; 		//����������Ϊ0
}NET_VCA_CTRLINFO, * LPNET_VCA_CTRLINFO;

//���ܿ�����Ϣ�ṹ
typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN]; 	//������Ϣ,����0��Ӧ�豸����ʼͨ��
    BYTE byRes[16];
}NET_VCA_CTRLCFG, * LPNET_VCA_CTRLCFG;

//�����豸������
typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;              //�ṹ����
    BYTE byVCAChanNum;         //����ͨ������
    BYTE byPlateChanNum;       //����ͨ������
    BYTE byBBaseChanNum;       //��Ϊ������
    BYTE byBAdvanceChanNum;    //��Ϊ�߼������
    BYTE byBFullChanNum;       //��Ϊ��������
    BYTE byATMChanNum;		   //����ATM����
    BYTE byPDCChanNum;         //����ͳ��ͨ������
    BYTE byITSChanNum;         //��ͨ�¼�ͨ������
    BYTE byBPrisonChanNum;     //��Ϊ�����(����)ͨ������
    BYTE byFSnapChanNum;       //����ץ��ͨ������
    BYTE byFSnapRecogChanNum;  //����ץ�ĺ�ʶ��ͨ������
    BYTE byFRetrievalChanNum;  //�������������
    BYTE bySupport;            //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport & 0x1����ʾ�Ƿ�֧�����ܸ��� 2012-3-22
    //bySupport & 0x2����ʾ�Ƿ�֧��128·ȡ����չ2012-12-27
    BYTE byFRecogChanNum;      //����ʶ��ͨ������
    BYTE byBPPerimeterChanNum; //��Ϊ�����(�ܽ�)ͨ������
    BYTE byTPSChanNum;         //��ͨ�յ�ͨ������
    BYTE byTFSChanNum;         //��·Υ��ȡ֤ͨ������
    BYTE byFSnapBFullChanNum;  //����ץ�ĺ���Ϊ����ͨ������
    BYTE byHeatMapChanNum;     //�ȶ�ͼͨ������
    BYTE bySmartVehicleNum;    //SMART�¼�+�������ͨ������
    BYTE bySmartHVTNum;       //SMART�¼�+���м��ͨ������
    BYTE bySmartNum;          //SMART�¼�����
    BYTE byVehicleNum;        //�������ͨ������
    BYTE bySmartRoadDetectionNum ; // SMART�¼�+��·���ͨ������
    BYTE bySmartFaceDetectionNum ; // SMART�¼�+�������ͨ������
    BYTE bySmartHeatMapNum ; // SMART�¼�+�ȶ�ͼͨ������
    BYTE byRes[14];
}NET_VCA_DEV_ABILITY, *LPNET_VCA_DEV_ABILITY;


//��Ϊ������������
typedef enum _VCA_ABILITY_TYPE_
{
    TRAVERSE_PLANE_ABILITY      = 0x01,       //��Խ������
        ENTER_AREA_ABILITY          = 0x02,       //��������
        EXIT_AREA_ABILITY           = 0x04,       //�뿪����
        INTRUSION_ABILITY           = 0x08,       //����
        LOITER_ABILITY              = 0x10,       //�ǻ�
        LEFT_TAKE_ABILITY           = 0x20,       //��Ʒ������ȡ
        PARKING_ABILITY             = 0x40,       //ͣ��
        RUN_ABILITY                 = 0x80,       //�����ƶ�
        HIGH_DENSITY_ABILITY        = 0x100,      //��Ա�ۼ�
        LF_TRACK_ABILITY			= 0x200,      //������
        VIOLENT_MOTION_ABILITY		= 0x400,      //�����˶����
        REACH_HIGHT_ABILITY			= 0x800,      //�ʸ߼��
        GET_UP_ABILITY				= 0x1000,     //������
        LEFT_ABILITY                = 0x2000,     //��Ʒ����
        TAKE_ABILITY                = 0x4000,     //��Ʒ��ȡ
        LEAVE_POSITION              = 0x8000,     //���
        TRAIL_ABILITY               = 0x10000,    //β��
        KEY_PERSON_GET_UP_ABILITY   = 0x20000,    //�ص���Ա������
        STANDUP_ABILITY             = 0x40000,   //����
        FALL_DOWN_ABILITY           = 0x80000,    //����
        AUDIO_ABNORMAL_ABILITY      = 0x100000,   //��ǿͻ��
        ADV_REACH_HEIGHT_ABILITY    = 0x200000,   //�����ʸ�
        TOILET_TARRY_ABILITY        = 0x400000,   //��޳�ʱ
        YARD_TARRY_ABILITY          = 0x800000,   //�ŷ糡����
        ADV_TRAVERSE_PLANE_ABILITY  = 0x1000000,  //���߾�����
        LECTURE_ABILITY			    = 0x2000000,  //�ڿ�
        ANSWER_ABILITY				= 0x4000000,  //�ش�����
        HUMAN_ENTER_ABILITY         = 0x10000000, //�˿���ATM ,ֻ��ATM_PANELģʽ��֧��
        OVER_TIME_ABILITY           = 0x20000000, //������ʱ,ֻ��ATM_PANELģʽ��֧��
        STICK_UP_ABILITY            = 0x40000000, //��ֽ��
        INSTALL_SCANNER_ABILITY     = 0x80000000  //��װ������
}VCA_ABILITY_TYPE;

typedef enum _VCA_ABILITY_TYPE_EX_
{
	PEOPLENUM_CHANGE_ABILITY = 0x00000002, //����仯���
	SPACING_CHANGE_ABILITY = 0x00000004,    //���仯���
    EVENT_COMBINED_ABILITY = 0x00000008,    //����¼�����
    EVENT_SIT_QUIETLY =		0x00000010    //����
}VCA_ABILITY_TYPE_EX;

//����ͨ������
typedef enum _VCA_CHAN_ABILITY_TYPE_
{
    VCA_BEHAVIOR_BASE     =  1,          //��Ϊ�������
    VCA_BEHAVIOR_ADVANCE  =  2,          //��Ϊ�����߼���
    VCA_BEHAVIOR_FULL     =  3,          //��Ϊ���������
    VCA_PLATE     		  =  4,          //��������
    VCA_ATM               =  5,          //ATM����
    VCA_PDC               =  6,          //������ͳ��
    VCA_ITS               =  7,          //���� ��ͨ�¼�
    VCA_BEHAVIOR_PRISON   =  8,          //��Ϊ���������(����)
    VCA_FACE_SNAP         =  9,          //����ץ������
    VCA_FACE_SNAPRECOG    = 10,          //����ץ�ĺ�ʶ������
    VCA_FACE_RETRIEVAL    = 11,          //�������������
    VCA_FACE_RECOG        = 12,          //����ʶ������
    VCA_BEHAVIOR_PRISON_PERIMETER =  13, // ��Ϊ��������� (�ܽ�)
    VCA_TPS               = 14,          //��ͨ�յ�
    VCA_TFS               = 15,          //��·Υ��ȡ֤
    VCA_BEHAVIOR_FACESNAP = 16,          //����ץ�ĺ���Ϊ��������
    VCA_HEATMAP           =  17,         //�ȶ�ͼ
    VCA_SMART_VEHICLE_DETECTION  =  18,  // SMART�¼�+�������
    VCA_SMART_HVT_DETECTION      =  19,  // SMART�¼�+���м��
    VCA_SMART_EVENT          =  20,      // SMART�¼�
    VCA_VEHICLE_DETECTION    =  21,      // �������
	VCA_SMART_ROAD_DETECTION =  22,      // SMART�¼�+��·���
    VCA_SMART_FACE_DETECTION =  23,      // SMART�¼�+�������
    VCA_SMART_HEATMAP        =  24       // SMART�¼�+�ȶ�ͼ
}VCA_CHAN_ABILITY_TYPE;

//����ATMģʽ����(ATM��������)
typedef enum _VCA_CHAN_MODE_TYPE_
{
    VCA_ATM_PANEL     =  0,  //ATM���
        VCA_ATM_SURROUND  =  1,  //ATM����
        VCA_ATM_FACE      =  2,	 //ATM����
        VCA_ATM_SAFETYCABIN = 3  //ATM������
}VCA_CHAN_MODE_TYPE;

//��ͨȡ֤TFSͨ��ģʽ(TFS��������)
typedef enum _TFS_CHAN_MODE_TYPE_
{
    TFS_CITYROAD    =  0,  //TFS ���е�·
        TFS_FREEWAY     =  1   //TFS ���ٵ�·
}TFS_CHAN_MODE_TYPE;

//��Ϊ��������ģʽ
typedef enum _BEHAVIOR_SCENE_MODE_TYPE_
{
    BEHAVIOR_SCENE_DEFAULT = 0, //ϵͳĬ��
        BEHAVIOR_SCENE_WALL = 1,    //Χǽ
        BEHAVIOR_SCENE_INDOOR = 2   //����
}BEHAVIOR_SCENE_MODE_TYPE;

//����ģʽ
typedef enum _BEHAVIOR_PRISON_MODE_TYPE_
{
    BEHAVIOR_PRISON 				= 0, //����
        BEHAVIOR_HEARING  				= 1, //��Ѷ��
        BEHAVIOR_RECFIELD 		        = 2  //�ŷ糡
}BEHAVIOR_PRISON_MODE_TYPE,LPBEHAVIOR_PRISON_MODE_TYPE;


//ͨ�������������
typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;	    //VCA_CHAN_ABILITY_TYPEö��ֵ
    BYTE byMode;		//ģʽ��ATM ����ʱ����VCA_CHAN_MODE_TYPE,TFS����ʱ����TFS_CHAN_MODE_TYPE,��VCA_TYPE Ϊ��ͨ�¼�ʱ����TRAFFIC_SCENE_MODE
    BYTE byRes[2]; 	    //����������Ϊ0
}NET_VCA_CHAN_IN_PARAM, *LPNET_VCA_CHAN_IN_PARAM;


//��Ϊ�������ṹ
typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;		 //�ṹ����
    DWORD dwAbilityType; //֧�ֵ��������ͣ���λ��ʾ����VCA_ABILITY_TYPE����
    BYTE  byMaxRuleNum;	 //��������
    BYTE  byMaxTargetNum; //���Ŀ����
    BYTE  bySupport;		// ֧�ֵĹ�������   ��λ��ʾ
    // bySupport & 0x01 ֧�ֱ궨����
    BYTE  byRes[5];         //����������Ϊ0
    DWORD dwAbilityTypeEx;  //֧�ֵ��������ͣ���λ��ʾ����VCA_ABILITY_TYPE_EX����
}NET_VCA_BEHAVIOR_ABILITY, *LPNET_VCA_BEHAVIOR_ABILITY;

//���������ݸ��²���
typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD	dwSize;
    BYTE	byIDCount;	//ʵ����ID��
	BYTE	byRes1[3];
    BYTE	byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
	BYTE	byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// ��ͨ�������ṹ
typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD 	dwSize;             // �ṹ���С
    DWORD 	dwAbilityType;      // ֧�ֵ������б�  ����ITS_ABILITY_TYPE
    BYTE 	byMaxRuleNum;	 	//��������
    BYTE 	byMaxTargetNum; 	//���Ŀ����
   	BYTE	byRes[10];		    // ����
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;

/***********************************end*******************************************/

/************************************���ܲ���ṹ*********************************/
//���ܹ��ýṹ
//���ֵ��һ��,������ֵΪ��ǰ����İٷֱȴ�С, ����ΪС������λ

//�����ṹ
typedef struct tagNET_VCA_RECT
{
    float fX;               //�߽�����Ͻǵ��X�����, 0.001~1
    float fY;               //�߽�����Ͻǵ��Y�����, 0.001~1
    float fWidth;           //�߽��Ŀ��, 0.001~1
    float fHeight;          //�߽��ĸ߶�, 0.001~1
}NET_VCA_RECT, *LPNET_VCA_RECT;

//��Ϊ�����¼�����
typedef enum _VCA_EVENT_TYPE_
{
    VCA_TRAVERSE_PLANE     = 0x1,        //��Խ������
        VCA_ENTER_AREA         = 0x2,        //Ŀ���������,֧���������
        VCA_EXIT_AREA		   = 0x4,        //Ŀ���뿪����,֧���������
        VCA_INTRUSION          = 0x8,        //�ܽ�����,֧���������
        VCA_LOITER             = 0x10,       //�ǻ�,֧���������
        VCA_LEFT_TAKE          = 0x20,       //��Ʒ������ȡ,֧���������
        VCA_PARKING	           = 0x40,       //ͣ��,֧���������
        VCA_RUN	               = 0x80,       //�����ƶ�,֧���������
        VCA_HIGH_DENSITY       = 0x100,      //��������Ա�ۼ�,֧���������
        VCA_VIOLENT_MOTION     = 0x200,		 //�����˶����
        VCA_REACH_HIGHT        = 0x400,		 //�ʸ߼��
        VCA_GET_UP             = 0x800,	     //������
        VCA_LEFT               = 0x1000,     //��Ʒ����
        VCA_TAKE               = 0x2000,     //��Ʒ��ȡ
        VCA_LEAVE_POSITION     = 0x4000,     //���
        VCA_TRAIL              = 0x8000,     //β��
        VCA_KEY_PERSON_GET_UP  = 0x10000,    //�ص���Ա������
        VCA_STANDUP            = 0x20000,    //����
        VCA_FALL_DOWN          = 0x80000,    //���ؼ��
        VCA_AUDIO_ABNORMAL     = 0x100000,   //��ǿͻ����
        VCA_ADV_REACH_HEIGHT   = 0x200000,   //�����ʸ�
        VCA_TOILET_TARRY       = 0x400000,   //��޳�ʱ
        VCA_YARD_TARRY         = 0x800000,   //�ŷ糡����
        VCA_ADV_TRAVERSE_PLANE = 0x1000000,  //���߾�����
        VCA_LECTURE            = 0x2000000,  //�ڿ�
        VCA_ANSWER             = 0x4000000,  //�ش�����
        VCA_HUMAN_ENTER        = 0x10000000, //�˿���ATM           ֻ��ATM_PANELģʽ��֧��
        VCA_OVER_TIME          = 0x20000000, //������ʱ            ֻ��ATM_PANELģʽ��֧��
        VCA_STICK_UP           = 0x40000000, //��ֽ��,֧���������
        VCA_INSTALL_SCANNER    = 0x80000000  //��װ������,֧���������
}VCA_EVENT_TYPE;

//��Ϊ�����¼�������չ
typedef enum _VCA_RULE_EVENT_TYPE_EX_
{
    ENUM_VCA_EVENT_TRAVERSE_PLANE     = 1,   //��Խ������
        ENUM_VCA_EVENT_ENTER_AREA         = 2,   //Ŀ���������,֧���������
        ENUM_VCA_EVENT_EXIT_AREA          = 3,   //Ŀ���뿪����,֧���������
        ENUM_VCA_EVENT_INTRUSION          = 4,   //�ܽ�����,֧���������
        ENUM_VCA_EVENT_LOITER             = 5,   //�ǻ�,֧���������
        ENUM_VCA_EVENT_LEFT_TAKE          = 6,   //��Ʒ������ȡ,֧���������
        ENUM_VCA_EVENT_PARKING            = 7,   //ͣ��,֧���������
        ENUM_VCA_EVENT_RUN                = 8,   //�����ƶ�,֧���������
        ENUM_VCA_EVENT_HIGH_DENSITY       = 9,   //��������Ա�ۼ�,֧���������
        ENUM_VCA_EVENT_VIOLENT_MOTION     = 10,  //�����˶����
        ENUM_VCA_EVENT_REACH_HIGHT        = 11,  //�ʸ߼��
        ENUM_VCA_EVENT_GET_UP             = 12,  //������
        ENUM_VCA_EVENT_LEFT               = 13,  //��Ʒ����
        ENUM_VCA_EVENT_TAKE               = 14,  //��Ʒ��ȡ
        ENUM_VCA_EVENT_LEAVE_POSITION     = 15,  //���
        ENUM_VCA_EVENT_TRAIL              = 16,  //β��
        ENUM_VCA_EVENT_KEY_PERSON_GET_UP  = 17,  //�ص���Ա������
        ENUM_VCA_EVENT_STANDUP            = 18,  //����
        ENUM_VCA_EVENT_FALL_DOWN          = 20,  //���ؼ��
        ENUM_VCA_EVENT_AUDIO_ABNORMAL     = 21,  //��ǿͻ����
        ENUM_VCA_EVENT_ADV_REACH_HEIGHT   = 22,  //�����ʸ�
        ENUM_VCA_EVENT_TOILET_TARRY       = 23,  //��޳�ʱ
        ENUM_VCA_EVENT_YARD_TARRY         = 24,  //�ŷ糡����
        ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //���߾�����
        ENUM_VCA_EVENT_LECTURE            = 26,  //�ڿΣ��Ḷ̌�
        ENUM_VCA_EVENT_ANSWER             = 27,  //�ش����⣨�Ḷ̌�
        ENUM_VCA_EVENT_HUMAN_ENTER        = 29,  //�˿���ATM,ֻ��ATM_PANELģʽ��֧��
        ENUM_VCA_EVENT_OVER_TIME          = 30,  //������ʱ,ֻ��ATM_PANELģʽ��֧��
        ENUM_VCA_EVENT_STICK_UP           = 31,  //��ֽ��,֧���������
        ENUM_VCA_EVENT_INSTALL_SCANNER    = 32,  //��װ������,֧���������
        ENUM_VCA_EVENT_PEOPLENUM_CHANGE   = 35,  //����仯�¼�
        ENUM_VCA_EVENT_SPACING_CHANGE     = 36,  //���仯�¼�
        ENUM_VCA_EVENT_COMBINED_RULE      = 37,   //��Ϲ����¼�
	    ENUM_VCA_EVENT_SIT_QUIETLY        = 38   //һ������������	���¼�
} VCA_RULE_EVENT_TYPE_EX;

//�����洩Խ��������
typedef enum _VCA_CROSS_DIRECTION_
{
    VCA_BOTH_DIRECTION,  // ˫��
        VCA_LEFT_GO_RIGHT,   // ��������
        VCA_RIGHT_GO_LEFT    // ��������
}VCA_CROSS_DIRECTION;

//�߽ṹ
typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;    //���
    NET_VCA_POINT struEnd;      //�յ�
}NET_VCA_LINE, *LPNET_VCA_LINE;

//����ͽṹ��
typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                  //��Ч�� ���ڵ���3������3����һ��������Ϊ����Ч�����߽�����Ϊ����Ч����
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM]; //����α߽��,���ʮ��
}NET_VCA_POLYGON, *LPNET_VCA_POLYGON;

//���������
typedef struct tagNET_VCA_TRAVERSE_PLANE
{
    NET_VCA_LINE struPlaneBottom;          //������ױ�
    VCA_CROSS_DIRECTION dwCrossDirection;  //��Խ����: 0-˫��1-�����ң�2-���ҵ���
    BYTE bySensitivity;                    //�����Ȳ���Χ[1,5]
    BYTE byPlaneHeight;                    //������߶�
    BYTE byDetectionTarget;	//0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes2[37];                       //������
}NET_VCA_TRAVERSE_PLANE, *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//����Χ
    //���򴥷�˳��0-˳������򴥷���1-˳�򴥷�
    DWORD   dwDuration;         //����ʱ��  ��λs ��Χ1-3600
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

//����/�뿪�������
typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1,5]
    BYTE byDetectionTarget;	//0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes[6];
}NET_VCA_AREA, *LPNET_VCA_AREA;

//��ݱ����ӳ�ʱ������ʶ�����д�ͼƬ�����������IO����һ�£�1�뷢��һ����
//���ֲ���
typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration;            //��Ϊ�¼�����ʱ����ֵ: 1-120�룬����5�룬�ж�����Ч������ʱ��  ��ATMϵͳ�д����ļ���ֵΪ 1-1000��
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byRate;               //ռ�ȣ�����������δ����Ŀ��ߴ�Ŀ��ռ�������ı��أ���һ��Ϊ����
    BYTE byDetectionTarget;	//0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes[3];             //����
}NET_VCA_INTRUSION, *LPNET_VCA_INTRUSION;

//�ǻ�����
typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��1-120�룬����10��
    BYTE bySensitivity;            //�����Ȳ���Χ[1,5]
    BYTE byRes[5];
}NET_VCA_LOITER, *LPNET_VCA_LOITER;

//��Ʒ����/��Ʒ��ȡ����
typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��1-120�룬����10��
    BYTE bySensitivity;            //�����Ȳ���Χ[1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT, *LPNET_VCA_TAKE_LEFT;

//ͣ������
typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;	//����Χ
    WORD wDuration;				//����ʱ����ֵ��1-100�룬����10��
    BYTE bySensitivity;            //�����Ȳ���Χ[1,5]
    BYTE byRes[5];
}NET_VCA_PARKING, *LPNET_VCA_PARKING;

//�����ƶ�����
typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion;	//����Χ
    float  fRunDistance;		//�˿����ƶ�������, ��Χ: [0.1, 1.00] ����ģʽ ʵ��ģʽ(1,20)m/s
    BYTE bySensitivity;            //�����Ȳ���Χ[1,5]
    BYTE byMode;     // 0 ����ģʽ  1 ʵ��ģʽ
    BYTE byDetectionTarget;	//0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes;
}NET_VCA_RUN, *LPNET_VCA_RUN;

//��Ա�ۼ�����
typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;		//����Χ
    float           fDensity;       //�ۼ�����, ��Χ: [0.1, 1.0]
    BYTE			bySensitivity;	//�����Ȳ���Χ[1,5]
    BYTE            byRes;          // �����ֽ�
    WORD            wDuration;      // ������Ա�ۼ�������ֵ 20-360s
}NET_VCA_HIGH_DENSITY, *LPNET_VCA_HIGH_DENSITY;

//�����˶�����
typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wDuration;           //���������˶�������ֵ��1-50��
    BYTE  bySensitivity;       //�����Ȳ���Χ[1,5]
    BYTE  byMode;              //0-����Ƶģʽ��1-����Ƶ����ģʽ��2-����Ƶģʽ
    BYTE  byRes[4];            //����
}NET_VCA_VIOLENT_MOTION, *LPNET_VCA_VIOLENT_MOTION;

// �ʸ߲���
typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;   //�ʸ߾�����
    WORD wDuration; //�����ʸ߱�����ֵ��1-120��
    BYTE	byRes[6];           // �����ֽ�
}NET_VCA_REACH_HIGHT, *LPNET_VCA_REACH_HIGHT;

// �𴲲���
typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion; //����Χ
    WORD	wDuration;	        //�����𴲱�����ֵ1-100 ��
    BYTE    byMode;             //������ģʽ,0-��ͨ��ģʽ,1-�ߵ���ģʽ,2-��ͨ����������ģʽ
    BYTE    bySensitivity;      //�����Ȳ���Χ[1,10]
    BYTE	byRes[4];		    //�����ֽ�
}NET_VCA_GET_UP, * LPNET_VCA_GET_UP;

// ��Ʒ����
typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion; // ����Χ
    WORD       wDuration;       // ������Ʒ����������ֵ 10-100��
    BYTE       bySensitivity;   // �����Ȳ���Χ[1,5]
    BYTE       byRes[5];        // �����ֽ�
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

// ��Ʒ��ȡ
typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // ����Χ
    WORD            wDuration;      // ������Ʒ��ȡ������ֵ10-100��
    BYTE            bySensitivity;  // �����Ȳ���Χ[1,5]
    BYTE            byRes[5];       // �����ֽ�
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion;    // ����Χ
    WORD               wDuration;  // ��������ʱ����ֵ 4s-60000s
    BYTE   byRes[6];   // �����ֽ�
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];			//�����ֽ�
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

//��ֽ������
typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��4-60�룬����10��
    BYTE  bySensitivity;       //�����Ȳ���Χ[1,5]
    BYTE byRes[5];
}NET_VCA_STICK_UP, *LPNET_VCA_STICK_UP;

//����������
typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //��������ʱ�䣺4-60��
    BYTE bySensitivity;       //�����Ȳ���Χ[1,5]
    BYTE byRes[5];
}NET_VCA_SCANNER, *LPNET_VCA_SCANNER;

//����¼�
typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //����Χ
    WORD   wLeaveDelay;  //���˱���ʱ�䣬��λ��s��ȡֵ1-1800
    WORD   wStaticDelay; //˯������ʱ�䣬��λ��s��ȡֵ1-1800
    BYTE   byMode;       //ģʽ��0-����¼���1-˯���¼���2-���˯���¼�
    BYTE   byPersonType; //ֵ���������ͣ�0-����ֵ�ڣ�1-˫��ֵ��
    BYTE   byRes[2];     //����
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

//β�����
typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wRes;      /* ���� */
    BYTE  bySensitivity;       /* �����Ȳ���Χ[1,5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

//���ز���
typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wDuration;      /* �����¼���ֵ 1-60s*/
    BYTE  bySensitivity;       /* �����Ȳ���Χ[1,5] */
    BYTE  byHeightThreshold; //�߶���ֵ����Χ[0,250]��Ĭ��90����λ������
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

//����
typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //����Χ
    BYTE  bySensitivity;     //�����Ȳ���Χ[1,100]
    BYTE  byHeightThreshold; //�߶���ֵ����Χ[0,250]��Ĭ��130����λ������
    WORD  wDuration;         //�����¼���ֵ[1,3600]��Ĭ��2����λ����
    BYTE  byRes[4];          //����
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;


//����仯
typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //����Χ
    BYTE  bySensitivity;  //�����Ȳ���Χ[1,100]
    BYTE  byPeopleNumThreshold; //������ֵ����Χ[0,5]��Ĭ��1
    BYTE  byDetectMode; //��ⷽʽ����������ֵ��Ƚϡ�1-���ڣ�2-С�ڣ�3-���ڣ�4-������
    BYTE  byNoneStateEffective; //����״̬�Ƿ���Ч��0-��Ч��1-��Ч
    WORD  wDuration;  //����ʱ����ֵ[1,3600]��Ĭ��2����λ����
    BYTE  byRes[2];   //����
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

//���仯
typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //����Χ
    float fSpacingThreshold; //�����ֵ����Χ[0,10.0]��Ĭ��1.0����λ����
    BYTE  bySensitivity;  //�����Ȳ���Χ[1,100]
    BYTE  byDetectMode; //��ⷽʽ��������ֵ��Ƚϡ�1-���ڣ�2-С��
    WORD  wDuration;  //����ʱ����ֵ[1,3600]��Ĭ��2����λ����
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;


//��ǿͻ�����
typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //����ǿ��
    BYTE bySensitivity;  //�����Ȳ���Χ[1,100]
    BYTE byAudioMode;    //�������ģʽ��0-�����ȼ�⣬1-�ֱ���ֵ��⣬2-��������ֱ���ֵ���
    BYTE byEnable;       //ʹ�ܣ��Ƿ���(��ǿͻ�䣬����)
    BYTE byThreshold;    //������ֵ[1,100]
    BYTE byRes[54];      //����
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

//��ǿ���� 2014-03-21
typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* �����Ȳ���Χ[1,100] */
    BYTE  byEnable;        //ʹ�ܣ��Ƿ���(��ǿͻ�䣬����)
    BYTE  byRes[6];
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;


typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;//ʹ�ܣ��Ƿ���
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;
    NET_DVR_SCHEDTIME	        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;     //�쳣���?ʽ
    DWORD                       dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD                       dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //��ǿ����
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDelay;        //��޳�ʱʱ��[1,3600]����λ����
    BYTE byRes[6];
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDelay;        //�ŷ糡����ʱ��[1,120]����λ����
    BYTE byRes[6];
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //�ʸ�����
    DWORD   dwCrossDirection;   //��Խ����(���VCA_CROSS_DIRECTION): 0-˫��1-������2-���ҵ���
    BYTE	byRes[4];		    // �����ֽ�
}NET_VCA_ADV_REACH_HEIGHT, * LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //����������
    DWORD   dwCrossDirection;   //��Խ����(���VCA_CROSS_DIRECTION): 0-˫��1-������2-���ҵ���
    BYTE    bySensitivity;      //�����Ȳ���Χ[1,5]
    BYTE	byRes[3];		    //�����ֽ�
} NET_VCA_ADV_TRAVERSE_PLANE,*LPNET_VCA_ADV_TRAVERSE_PLANE;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //��Ϊ�¼�����ʱ����ֵ: 1-10�룬����1�룬�ж�����Ч������ʱ��
    BYTE bySensitivity; //�����Ȳ���Χ[1-100]
    BYTE byAlarmState;//ֻ���ֶν��治��ʾ��0-����,1-������ʼ,2-��������
    BYTE byTrackingMode ;//����ģʽ��0-�Զ�(Ĭ��) , 1-ˮƽ, 2-��ֱ
    BYTE byZoomMode;//�䱶ģʽ, 0-�̶�(Ĭ��), 1-�Զ�
    BYTE byZoomOver;//0-����,1-�䱶��λ(�����ϴ�¼��������Ϊ�л������ж�����)
    BYTE byRes;
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;//�����Ȳ���Χ[1-100]
    BYTE byAlarmState;//ֻ���ֶν��治��ʾ��0-����,1-������ʼ,2-��������
    BYTE byZoomOver;//0-����,1-�䱶��λ(�����ϴ�¼��������Ϊ�л������ж�����)
    BYTE byRes[5];             //����
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

//��������ṹ��
typedef struct tagNET_VCA_RELATE_RULE_PARAM
{
    BYTE  byRuleID;  //������� 0-��ʾ��
    BYTE  byRes;  //����
    WORD  wEventType;		//��Ϊ�¼����ͣ��ο�VCA_RULE_EVENT_TYPE_EX��
}NET_VCA_RELATE_RULE_PARAM,*LPNET_VCA_RELATE_RULE_PARAM;

typedef struct tagNET_VCA_COMBINED_RULE_
{
    //���򴥷�˳��0-˳������򴥷���1-˳�򴥷�
    BYTE    byRuleSequence;
    BYTE    byRes[7];
    DWORD  dwMinInterval;	//��Сʱ��������λ����
    DWORD  dwMaxInterval;  //���ʱ��������λ����
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//����1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//����2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;


//�����¼�����
typedef union tagNET_VCA_EVENT_UNION
{
    DWORD                      uLen[23];			//����
    NET_VCA_TRAVERSE_PLANE     struTraversePlane;   //��Խ���������
    NET_VCA_AREA    	       struArea;            //����/�뿪�������
    NET_VCA_INTRUSION          struIntrusion;       //���ֲ���
    NET_VCA_LOITER             struLoiter;          //�ǻ�����
    NET_VCA_TAKE_LEFT          struTakeTeft;		//��Ʒ����/��Ʒ��ȡ����
    NET_VCA_PARKING            struParking;	        //ͣ������
    NET_VCA_RUN                struRun;	            //�����ƶ�����
    NET_VCA_HIGH_DENSITY       struHighDensity;	    //��Ա�ۼ�����
    NET_VCA_VIOLENT_MOTION     struViolentMotion;	//�����˶�
    NET_VCA_REACH_HIGHT	       struReachHight;      //�ʸ�
    NET_VCA_GET_UP		       struGetUp;           //��
    NET_VCA_LEFT               struLeft;            //��Ʒ����
    NET_VCA_TAKE               struTake;            // ��Ʒ��ȡ
    NET_VCA_HUMAN_ENTER        struHumanEnter;      //��Ա����
    NET_VCA_OVER_TIME          struOvertime;        //������ʱ
    NET_VCA_STICK_UP 	       struStickUp;		    //��ֽ��
    NET_VCA_SCANNER 	       struScanner;		    //����������
    NET_VCA_LEAVE_POSITION     struLeavePos;        //��ڲ���
    NET_VCA_TRAIL              struTrail;           //β�����
    NET_VCA_FALL_DOWN          struFallDown;        //���ز���
    NET_VCA_AUDIO_ABNORMAL     struAudioAbnormal;   //��ǿͻ��
    NET_VCA_ADV_REACH_HEIGHT   struReachHeight;     //�����ʸ߲���
    NET_VCA_TOILET_TARRY       struToiletTarry;     //��޳�ʱ����
    NET_VCA_YARD_TARRY         struYardTarry;       //�ŷ糡��������
    NET_VCA_ADV_TRAVERSE_PLANE struAdvTraversePlane;//���߾��������
    NET_VCA_LECTURE            struLecture;		    //�ڿ��¼�
    NET_VCA_ANSWER             struAnswer;			//�ش������¼�
    NET_VCA_STANDUP			   struStandUp;         //��������
    NET_VCA_PEOPLENUM_CHANGE   struPeopleNumChange; //����仯����
    NET_VCA_SPACING_CHANGE     struSpacingChange;   //���仯����
    NET_VCA_COMBINED_RULE      struCombinedRule;    //��Ϲ������
    NET_VCA_SIT_QUIETLY        struSitQuietly;      //�������
}NET_VCA_EVENT_UNION, *LPNET_VCA_EVENT_UNION;

// �ߴ����������
typedef enum _VCA_SIZE_FILTER_MODE_
{
    IMAGE_PIX_MODE, //������ش�С����
        REAL_WORLD_MODE, //���ʵ�ʴ�С����
        DEFAULT_MODE 	// Ĭ��ģʽ
}SIZE_FILTER_MODE;
//�ߴ������
typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;			//�Ƿ񼤻�ߴ������ 0-�� ��0-��
    BYTE    byMode;		 //������ģʽSIZE_FILTER_MODE
    BYTE    byRes[2];        //��������0
    NET_VCA_RECT struMiniRect;    //��СĿ���,ȫ0��ʾ������
    NET_VCA_RECT struMaxRect;	  //���Ŀ���,ȫ0��ʾ������
}NET_VCA_SIZE_FILTER, *LPNET_VCA_SIZE_FILTER;

//�������ṹ
typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;					//�Ƿ񼤻����,0-��,��0-��
    BYTE   byRes[7];         			//����������Ϊ0�ֶ�
    BYTE   byRuleName[NAME_LEN];		//�������
    VCA_EVENT_TYPE dwEventType;			//��Ϊ�����¼�����
    NET_VCA_EVENT_UNION uEventParam;	//��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	  //���?ʽ
    BYTE byRelRecordChan[MAX_CHANNUM_V30];			//����������¼��ͨ��,Ϊ1��ʾ������ͨ��
}NET_VCA_ONE_RULE, *LPNET_VCA_ONE_RULE;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;			//�ṹ����
    BYTE   byPicProType;	//����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE   byUpLastAlarm; //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE   byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE   byRes;
    NET_DVR_JPEGPARA  struPictureParam; 		//ͼƬ���ṹ
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];  //��������
}NET_VCA_RULECFG, *LPNET_VCA_RULECFG;

//ǰ���豸��ַ��Ϣ�����ܷ����Ǳ�ʾ����ǰ���豸�ĵ�ַ��Ϣ�������豸��ʾ����ĵ�ַ
/*
�������豸ģ��ͨ��(IPC/DVR/DVS/IVMS)������ʱ�������ֶ���д�豸��IP��ַ���˿ڣ�byChannel��byIvmsChannel ��Ϊ��ǰ��ģ��ͨ����
eg:
struDevIP =  ģ��ͨ����Ӧ�豸��IP��ַ
wPort  =  ģ��ͨ����Ӧ�豸�Ķ˿�
byChannel =  ������Ӧģ��ͨ����ͨ����
byIvmsChannel = ������Ӧģ��ͨ����ͨ����

  �������豸����ͨ��(DVR/DVS/IVMS)������ʱ�������ֶ���д����ͨ�������豸��IP��ַ���˿ڣ�byChannelΪ����ͨ�������豸��ͨ���ţ�byIvmsChannelΪ����ͨ����
  eg:
  struDevIP =  ����ͨ�������豸��IP��ַ
  wPort  =  ����ͨ�������豸�Ķ˿�
  byChannel =  ����ͨ�������豸��ͨ����
  byIvmsChannel = ����ͨ����
*/
typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP; //ǰ���豸��ַ��
    WORD wPort; 			//ǰ���豸�˿ںţ�
    BYTE byChannel;  		//ǰ���豸ͨ����
    BYTE byIvmsChannel;		// Ivms ͨ��
}NET_VCA_DEV_INFO, *LPNET_VCA_DEV_INFO;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize; //�ṹ��С
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	    dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    BYTE     byTargetType;//���Ŀ������ 0-��ЧĿ�꣬1-��ʦ
    BYTE     byLeftDirection;//���Ŀ���뿪��������0-����,1-��,2-��,3-��,4-��
    BYTE     byRes[126];
}NET_DVR_TARGET_LEFT_REGION_ALARM,*LPNET_DVR_TARGET_LEFT_REGION_ALARM;

//�ߴ���˲���
typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //�ߴ���˲��� 0 - ������ 1-�߶ȺͿ�ȹ���,2-������
    BYTE    byRes[11];       //����
}NET_VCA_FILTER_STRATEGY,*LPNET_VCA_FILTER_STRATEGY;

//���򴥷�����
typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //����Ĵ�����ʽ��0- �����ã�1- �켣�� 2- Ŀ�����
    BYTE   byTriggerPoint;  //�����㣬������ʽΪ�켣��ʱ��Ч 0- ��,1-��,2-��
    BYTE   byRes1[2];       //����
    float  fTriggerArea;    //����Ŀ�����ٷֱ� [0,100]��������ʽΪĿ�����ʱ��Ч
    BYTE   byRes2[4];       //����
}NET_VCA_RULE_TRIGGER_PARAM,*LPNET_VCA_RULE_TRIGGER_PARAM;

//�������ṹ
typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //�Ƿ񼤻����,0-��,��0-��
    BYTE   byRes1[4];  //����������Ϊ0�ֶ�
    BYTE   byEventTypeFlag;  //��־��Ϊ�¼������ֶε���Ч�ԣ�0-dwEventType��Ч��1-wEventTypeEx��Ч
    //ע�����ֶ�byEventTypeFlagֻ�����ò���ʱ��Ч�����豸��ȡ����ʱ����ֱ�Ӵ�wEventTypeEx��ȡ�¼����ͣ������жϴ��ֶε�ֵ
    WORD   wEventTypeEx; //��Ϊ�¼�������չ�����ڴ����ֶ�dwEventType���ο�VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //�������
    VCA_EVENT_TYPE dwEventType;	//��Ϊ�¼����ͣ�������Ϊ�˼��ݣ�������ʹ��wEventTypeEx��ȡ�¼�����
    NET_VCA_EVENT_UNION uEventParam; //��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	//���?ʽ
    BYTE   byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    WORD   wAlarmDelay; //���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2]; //����
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //�ߴ���˲���
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //���򴥷�����
    BYTE   byRes[32];
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;			//�ṹ����
    BYTE    byPicProType;	//����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE    byUpLastAlarm; //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE    byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE    byRes1;
    NET_DVR_JPEGPARA struPictureParam; 		//ͼƬ���ṹ
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //��������
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE   byRes[26];
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

//�������ṹ
typedef struct NET_VCA_ONE_RULE_V42_
{
    BYTE  	 	byActive;       //�Ƿ񼤻����, 0-�񣬷�0-��
    BYTE  	 	byRes1[5];   	//����������Ϊ0�ֶ�
    WORD 	 	wEventType;		//��Ϊ�¼����ͣ��ο�VCA_RULE_EVENT_TYPE_EX
    BYTE		byRuleName[NAME_LEN/*32*/];		//�������
    NET_VCA_EVENT_UNION  uEventParam;		    //��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  		//�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*���?ʽ*/
    //�쳣���?ʽ�б������������Ű󶨣������Ϊ0ʱ����ʾ�����ı�������ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ�����ı�������ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں���ı���������Ч
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];	/* ����������¼��ͨ�������ֽڵ�ͨ���ţ���ʼֵ�� 0xffffffff��*/
    //������¼��ͨ��������Ű󶨣������Ϊ0ʱ����ʾ������ͨ���ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ������ͨ���ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں���Ĺ���ͨ������Ч
    WORD 	 	wAlarmDelay; //���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE  	 	byRes2[2];   		//����
    NET_VCA_FILTER_STRATEGY 	struFilterStrategy;  //�ߴ���˲���
    NET_VCA_RULE_TRIGGER_PARAM 	struTriggerParam; //���򴥷�����
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;


typedef struct    tagNET_DVR_PTZ_POSITION
{
    // �Ƿ����ó����������ó�����Ϊ�����ʱ����ֶ���Ч���������������ó���λ����Ϣʱ��Ϊʹ��λ
    BYTE byEnable;
    BYTE byRes1[3];  //����
    BYTE byPtzPositionName[NAME_LEN]; //����λ�����
    NET_DVR_PTZPOS struPtzPos; //ptz ���
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION, *LPNET_DVR_PTZ_POSITION;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD			dwSize;             //�ṹͼ��С
    BYTE   	     	byPicProType;	    	//����ʱͼƬ���?ʽ 0-������ 1-�ϴ�
    BYTE    		byUpLastAlarm; 		//�Ƿ����ϴ����һ�εı�����0-��1-��
    BYTE	 		byPicRecordEnable;   //�Ƿ�����ͼƬ�洢, 0-������, 1-����
    BYTE    		byRes1;
    NET_DVR_JPEGPARA 	struPicParam; 	    //ͼƬ���ṹ
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42 /*16*/];   	/* ��������*/
    WORD			wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE            byTrackEnable; //�Ƿ����ø���
    BYTE            byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //����λ����Ϣ
    WORD            wTrackDuration; //���ٳ���ʱ�䣬��λs
    BYTE            byRes[62];//����
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;


//��Ŀ��ṹ��
typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;				//Ŀ��ID ,��Ա�ۼ���߱���ʱΪ0
    NET_VCA_RECT struRect;      //Ŀ��߽��
    BYTE      byRes[4];			//����
}NET_VCA_TARGET_INFO, *LPNET_VCA_TARGET_INFO;

//�򻯵Ĺ�����Ϣ, �����Ļ���Ϣ
typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;		        //����ID,0-7
    BYTE   byRes;	            //����
    WORD   wEventTypeEx;            //��Ϊ�¼�������չ�����ڴ����ֶ�dwEventType���ο�VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN];    //�������
    VCA_EVENT_TYPE  dwEventType;    //��Ϊ�¼����ͣ�������Ϊ�˼��ݣ�������ʹwEventTypeEx��ȡ�¼�����
    NET_VCA_EVENT_UNION uEventParam;//�¼�����
}NET_VCA_RULE_INFO, *LPNET_VCA_RULE_INFO;

//��Ϊ��������ϱ��ṹ
typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;						//�ṹ����
    DWORD    dwRelativeTime;				//���ʱ��
    DWORD    dwAbsTime;						//���ʱ��
    NET_VCA_RULE_INFO     struRuleInfo;		//�¼�������Ϣ
    NET_VCA_TARGET_INFO  struTargetInfo;	//����Ŀ����Ϣ
    NET_VCA_DEV_INFO  	 struDevInfo;		//ǰ���豸��Ϣ
    DWORD dwPicDataLen;						//����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ���*/
    BYTE       byPicType;		//  0-��ͨͼƬ 1-�Ա�ͼƬ
    BYTE       byRelAlarmPicNum; //����ͨ������ͼƬ����
    BYTE       bySmart;//IDS�豸����0(Ĭ��ֵ)��Smart Functiom Return 1
    BYTE       byRes;		// �����ֽ�
    DWORD      dwAlarmID;     //����ID�����Ա�ʶͨ��������������ϱ�����0��ʾ��Ч
    BYTE       byRes2[8];		//����
    BYTE       *pImage;       //ָ��ͼƬ��ָ��
}NET_VCA_RULE_ALARM, *LPNET_VCA_RULE_ALARM;

//��Ϊ��������DSP��Ϣ���ӽṹ
typedef struct tagNET_VCA_DRAW_MODE
{
    DWORD  dwSize;
    BYTE	byDspAddTarget;			//�����Ƿ����Ŀ��
    BYTE    byDspAddRule;			//�����Ƿ���ӹ���
    BYTE	byDspPicAddTarget;		//ץͼ�Ƿ����Ŀ��
    BYTE	byDspPicAddRule;		//ץͼ�Ƿ���ӹ���
    BYTE	byRes[4];
}NET_VCA_DRAW_MODE, *LPNET_VCA_DRAW_MODE;

//��������
typedef enum tagOBJECT_TYPE_ENUM
{
    ENUM_OBJECT_TYPE_COAT  = 1  //����
}OBJECT_TYPE_ENUM;

//������ɫ�����ṹ��
typedef struct tagNET_DVR_OBJECT_COLOR_COND
{
    DWORD  dwChannel;   //ͨ����
    DWORD  dwObjType;   //�������ͣ��μ�OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //����
}NET_DVR_OBJECT_COLOR_COND,*LPNET_DVR_OBJECT_COLOR_COND;

//ͼƬ����
typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //ͼƬ���ͣ�1-jpg
    BYTE   byRes1[3];        //����
    DWORD  dwPicWidth;       //ͼƬ���
    DWORD  dwPicHeight;      //ͼƬ�߶�
    DWORD  dwPicDataLen;     //ͼƬ���ʵ�ʴ�С
    DWORD  dwPicDataBuffLen; //ͼƬ��ݻ������С
    BYTE*  byPicDataBuff;    //ͼƬ��ݻ�����
    BYTE   byRes2[40];       //����
}NET_DVR_PIC,*LPNET_DVR_PIC;

//��ɫ������
typedef union tagNET_DVR_OBJECT_COLOR_UNION
{
    NET_DVR_COLOR  struColor;   //��ɫֵ
    NET_DVR_PIC    struPicture; //ͼƬ
    BYTE           byRes[64];   //����
}NET_DVR_OBJECT_COLOR_UNION,*LPNET_DVR_OBJECT_COLOR_UNION;

//������ɫ����ṹ��
typedef struct tagNET_DVR_OBJECT_COLOR
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byColorMode;  //ȡɫ��ʽ��1-��ɫֵ��2-ͼƬ
    BYTE   byRes1[2];    //����
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //������ɫ�����壬ȡֵ������ȡɫ��ʽ
    BYTE   byRes2[64];   //����
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;

//��������
typedef enum tagAREA_TYPE_ENUM
{
    ENUM_OVERLAP_REGION  = 1,//��ͬ����
        ENUM_BED_LOCATION  = 2   //����λ��
}AREA_TYPE_ENUM;

//��������
typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //�������ͣ��μ�AREA_TYPE_ENUM
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byRes1[3];     //����
    NET_VCA_POLYGON struPolygon; //����
    BYTE   byRes2[16];   //����
}NET_DVR_AUXAREA,*LPNET_DVR_AUXAREA;

//���������б�
typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD	 dwSize;	// �ṹ���С
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //��������
    BYTE	byRes2[64];	// ����
}NET_DVR_AUXAREA_LIST,*LPNET_DVR_AUXAREA_LIST;

//ͨ������ģʽ
typedef enum tagCHAN_WORKMODE_ENUM
{
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //����ģʽ
        ENUM_CHAN_WORKMODE_MASTER  = 2,      //��ģʽ
        ENUM_CHAN_WORKMODE_SLAVE  = 3        //��ģʽ
}CHAN_WORKMODE_ENUM;

//ͨ������ģʽ����ṹ��
typedef struct tagNET_DVR_CHANNEL_WORKMODE
{
    DWORD dwSize;        //�ṹ���С
    BYTE  byWorkMode;    //����ģʽ���μ�CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //����
}NET_DVR_CHANNEL_WORKMODE,*LPNET_DVR_CHANNEL_WORKMODE;

//�豸ͨ������ṹ��
typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];	//�豸IP������
    WORD   wDVRPort;			 	    //�˿ں�
    BYTE   byRes1[2];                   //����
    BYTE   sUserName[NAME_LEN];	        //�����û���
    BYTE   sPassword[PASSWD_LEN];       //��������
    DWORD  dwChannel;                   //ͨ����
    BYTE   byRes2[32];                  //����
}NET_DVR_CHANNEL,*LPNET_DVR_CHANNEL;

//��ͨ����Ϣ������
typedef union tagNET_DVR_SLAVE_CHANNEL_UNION
{
    BYTE            byRes[152];        //�������С
    DWORD           dwLocalChannel;    //����ͨ��
    NET_DVR_CHANNEL struRemoteChannel; //Զ��ͨ��
}NET_DVR_SLAVE_CHANNEL_UNION,*LPNET_DVR_SLAVE_CHANNEL_UNION;

//��ͨ������ṹ��
typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //��ͨ�����ͣ�1-����ͨ����2-Զ��ͨ��
    BYTE   byRes1[3];    //����
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //��ͨ�������壬ȡֵ������byChanType
    BYTE   byRes2[64];   //����
}NET_DVR_SLAVE_CHANNEL_PARAM,*LPNET_DVR_SLAVE_CHANNEL_PARAM;


//��ͨ���������ýṹ��
typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{
    DWORD dwSize;   //�ṹ���С
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//��ͨ������
    BYTE  byRes[64];  //����
}NET_DVR_SLAVE_CHANNEL_CFG,*LPNET_DVR_SLAVE_CHANNEL_CFG;

//��Ƶ������ϼ���¼�
typedef enum tagVQD_EVENT_ENUM
{
    ENUM_VQD_EVENT_BLUR           = 1,  //ͼ��ģ��
        ENUM_VQD_EVENT_LUMA           = 2,  //�����쳣
        ENUM_VQD_EVENT_CHROMA         = 3,  //ͼ��ƫɫ
        ENUM_VQD_EVENT_SNOW           = 4,  //ѩ������
        ENUM_VQD_EVENT_STREAK         = 5,  //���Ƹ���
        ENUM_VQD_EVENT_FREEZE         = 6,  //���涳��
        ENUM_VQD_EVENT_SIGNAL_LOSS    = 7,  //�źŶ�ʧ
        ENUM_VQD_EVENT_PTZ            = 8,  //��̨ʧ��
        ENUM_VQD_EVENT_SCNENE_CHANGE  = 9,  //����ͻ��
        ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10, //��Ƶ�쳣
        ENUM_VQD_EVENT_VIDEO_BLOCK    = 11, //��Ƶ�ڵ�
}VQD_EVENT_ENUM;

//��Ƶ��������¼������ṹ��
typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //ͨ����
    DWORD dwEventType; //����¼����ͣ��μ�VQD_EVENT_ENUM
    BYTE  byRes[64];   //����
}NET_DVR_VQD_EVENT_COND,*LPNET_DVR_VQD_EVENT_COND;

//��Ƶ��������¼�����
typedef struct tagNET_DVR_VQD_EVENT_PARAM
{
    BYTE   byThreshold;    //������ֵ����Χ[0,100]
    BYTE   byTriggerMode;  //1-������2-���δ���
    BYTE   byUploadPic;    //0-���ϴ�ͼƬ��1-�ϴ�ͼƬ�������Ƿ��ϴ�ͼƬ���º󶼿��Դ��豸��ȡ���¼����Ӧ���µ�һ�ű���ͼƬ���μ�ӿ�NET_DVR_StartDownload
    BYTE   byRes1;         //����
    DWORD  dwTimeInterval; //��������ʱ��������Χ[0,3600] ��λ����
    BYTE   byRes2[64];     //����
}NET_DVR_VQD_EVENT_PARAM,*LPNET_DVR_VQD_EVENT_PARAM;

//��Ƶ��������¼�����
typedef struct tagNET_DVR_VQD_EVENT_RULE
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byRes1[3];    //����
    NET_DVR_VQD_EVENT_PARAM struEventParam; //��Ƶ��������¼�����
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//���ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //���?ʽ
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //����������¼��ͨ����1��ʾ������ͨ����0��ʾ������
    BYTE   byRes2[128];    //����
}NET_DVR_VQD_EVENT_RULE,*LPNET_DVR_VQD_EVENT_RULE;

//��׼��������
typedef struct tagNET_DVR_BASELINE_SCENE
{
    DWORD dwSize;     //�ṹ���С
    BYTE  byEnable;   //0-�����ã�1-����
    BYTE  byRes[63];  //����
}NET_DVR_BASELINE_SCENE,*LPNET_DVR_BASELINE_SCENE;

//��׼������������ṹ��
typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{
    DWORD dwSize;     //�ṹ���С
    DWORD dwChannel;  //ͨ����
    BYTE  byCommand;  //�������ͣ�1-���ֶα������ݲ�ʹ�ã�2-���»�׼����
    BYTE  byRes[127];  //����
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM,*LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//��Ƶ������ϱ����ṹ��
typedef struct tagNET_DVR_VQD_ALARM
{
    DWORD  dwSize;                //�ṹ���С
    DWORD  dwRelativeTime;        //���ʱ��
    DWORD  dwAbsTime;	          //���ʱ��
    NET_VCA_DEV_INFO struDevInfo; //ǰ���豸��Ϣ
    DWORD  dwEventType;           //�¼����ͣ��ο�VQD_EVENT_ENUM
    float  fThreshold;            //������ֵ[0.000,1.000]
    DWORD  dwPicDataLen;          //ͼƬ���ȣ�Ϊ0��ʾû��ͼƬ
    BYTE   *pImage;               //ָ��ͼƬ��ָ��
    BYTE   byRes[128];            //����
}NET_DVR_VQD_ALARM,*LPNET_DVR_VQD_ALARM;

//�궨���ӽṹ
typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;     //�궨�㣬�������ǹ��
    NET_DVR_PTZPOS struPtzPos;  //��������PTZ���
    BYTE	byRes[8];
}NET_DVR_CB_POINT, LPNET_DVR_CB_POINT;

//�궨�������ýṹ
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{
    BYTE byPointNum;			//��Ч�궨�����
    BYTE byRes[3];
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //�궨����
}NET_DVR_TRACK_CALIBRATION_PARAM, *LPNET_DVR_TRACK_CALIBRATION_PARAM;

//������ýṹ
typedef struct tagNET_DVR_TRACK_CFG
{
    DWORD dwSize;				//�ṹ����
    BYTE byEnable;				//�궨ʹ��
    BYTE byFollowChan;          // �����ƵĴ�ͨ��
    BYTE byDomeCalibrate;			//�������ܸ������궨��1���� 0������
    BYTE byRes;					// �����ֽ�
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam; //�궨����
}NET_DVR_TRACK_CFG, *LPNET_DVR_TRACK_CFG ;

//����ģʽ
typedef enum _TRACK_MODE_
{
    MANUAL_CTRL = 0,  //�ֶ�����
        ALARM_TRACK    //������������
}TRACK_MODE;

//�ֶ����ƽṹ
typedef struct tagNET_DVR_MANUAL_CTRL_INFO
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO, *LPNET_DVR_MANUAL_CTRL_INFO ;

//����ģʽ�ṹ
typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;		//�ṹ����
    BYTE byTrackMode;   //����ģʽ
    BYTE byRuleConfMode;   //�������ø���ģʽ0-�������ø��٣�1-Զ�����ø���
    BYTE byRes[2];   //��������0
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl;//�ֶ����ٽṹ
    }uModeParam;
}NET_DVR_TRACK_MODE,*LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;	    /*����ʱͼƬ���?ʽ 0-������ 1-�ϴ�*/
    BYTE    byRes[3];           //�����ֽ�
    NET_DVR_JPEGPARA struPicParam; 				/*ͼƬ���ṹ*/
}NET_DVR_ALARM_JPEG, *LPNET_DVR_ALARM_JPEG;

/**********************ipc/d5.3.0********************************/
typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;//���?�����
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//���Ӹ��� �������ID���[1,4]
    BYTE             byRes[63];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE 				byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    WORD				wPort;			/*�˿�*/
    BYTE               byLoginStatus; /*���豸�ĵ�½״̬ 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME/*64*/];//��������ַ������
            BYTE			byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;/*IP��ַ*/		//IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64
    BYTE				szUserName[NAME_LEN/*32*/];		/*�û���*/
    BYTE				szPassWord[PASSWD_LEN/*16*/];		/*����*/
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus ;//����״̬ 0- δ���ӣ�1-����
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];//�����±�0��ʾ�������ID 1,��������
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{
    float fPan;
    float fTilt;
    float fZoom;
    BYTE  byRes[8];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;//�궨���
    BYTE      byRes[16];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE 			 byCalibMode;//�궨ģʽ: 0-����,1-�Զ��궨, 2-�ֶ��궨
    BYTE             byRes[3];
    //�����±�0��ʾ�������ID 1����������
    //�ֶ��궨ģʽ��֧�����ã�����&&��ȡ�����Զ�ģʽ��֧�ֻ�ȡ����
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];//ֻ���ֶ��궨ģʽ����Ч
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;		//�ṹ����
    BYTE byEnable;      //ʹ�� 0-false,1-true
    BYTE byMode;        //ģʽ 0-�رգ�1-�ֶ���2-�Զ�
    WORD  wTrackingTime;//����ʱ�䣺[0,60]s
    NET_VCA_POLYGON struRegion;//�ֶ�����Ŀ������Χ
    BYTE byRes[64];
}NET_DVR_TRACKING,*LPNET_DVR_TRACKING;

/**********************ipc/d5.3.0********************************/

//��������Ϊ��������ṹ
//�������ṹ
typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;           /* �Ƿ񼤻����,0-��, ��0-�� */
    BYTE	byRes1[7];	//����������Ϊ0�ֶ�
    BYTE   byRuleName[NAME_LEN]; //�������
    VCA_EVENT_TYPE dwEventType;   //��Ϊ�����¼�����
    NET_VCA_EVENT_UNION uEventParam;//��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    BYTE byRes2[68]; /*����������Ϊ0*/
}NET_IVMS_ONE_RULE, *LPNET_IVMS_ONE_RULE;

// �����ǹ���ṹ
typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];   //��������
}NET_IVMS_RULECFG, *LPNET_IVMS_RULECFG;

// IVMS��Ϊ�������ýṹ
typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;	    //����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam; 				//ͼƬ���ṹ
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT];//ÿ��ʱ��ζ�Ӧ����
} NET_IVMS_BEHAVIORCFG, *LPNET_IVMS_BEHAVIORCFG;

//���ܷ�����ȡ���ƻ��ӽṹ
typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME 	struTime;       //ʱ�����
    NET_DVR_PU_STREAM_CFG struPUStream; //ǰ��ȡ������
}NET_IVMS_DEVSCHED, *LPNET_IVMS_DEVSCHED;

//���ܷ����ǲ������ýṹ
typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED	struDevSched[MAX_DAYS][MAX_TIMESEGMENT];//��ʱ�������ǰ��ȡ���Լ�������Ϣ
} NET_IVMS_STREAMCFG, *LPNET_IVMS_STREAMCFG;

//��������
typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;			//�Ƿ񼤻�, 0-�񣬷�0-��
    BYTE byRes[3];         //��������0
    NET_VCA_POLYGON  struPolygon; //���ζ����
}NET_VCA_MASK_REGION, * LPNET_VCA_MASK_REGION;

//������������ṹ
typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;     //�ṹ����
    BYTE byRes[4];     //��������0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM]; //������������
}NET_VCA_MASK_REGION_LIST, *LPNET_VCA_MASK_REGION_LIST;


//ATM�����������
typedef struct tagNET_VCA_ENTER_REGION//��ֹ����ATM���
{
    DWORD dwSize;
    BYTE byEnable;			//�Ƿ񼤻0-�񣬷�0-��
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon; //��������
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION, * LPNET_VCA_ENTER_REGION;

//IVMS������������
typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;    //�ṹ����
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][ MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST, *LPNET_IVMS_MASK_REGION_LIST;

//IVMS��ATM�����������
typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][ MAX_TIMESEGMENT]; //��������
}NET_IVMS_ENTER_REGION, *LPNET_IVMS_ENTER_REGION;

// ivms ����ͼƬ�ϴ��ṹ
typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;
}NET_IVMS_ALARM_JPEG, *LPNET_IVMS_ALARM_JPEG;

// IVMS ���������
typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay;// Զ�̻ط�
    NET_IVMS_ALARM_JPEG         struAlarmJpeg; // �����ϴ�ͼƬ����
    NET_IVMS_RULECFG           struRuleCfg;   //IVMS ��Ϊ��������
}NET_IVMS_SEARCHCFG, *LPNET_IVMS_SEARCHCFG;

//�궨����ṹ��
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{
    BYTE byPointNum;    //��Ч�궨�����
    BYTE byRes[3];		//����
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //�궨����
    NET_DVR_PTZPOS struHorizonPtzPos;  //���ˮƽ��PTZ���
    BYTE byRes2[256];    //����
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

//�����豸���ò���
typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{
    DWORD  dwSize;         //�ṹ���С
    BYTE   byEnable;       //���ô˸����豸, 0-������, 1 -����
    BYTE   byTransMode;    //ͨѶ��ʽ��0-����SDK��1-485����
    BYTE   byRes1[2];	   //����
    NET_DVR_CHANNEL  struTrackDevChan; //���������豸����
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //�����豸�궨����
    BYTE    byRes2[256];    //����
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;
/************************************end******************************************/
//NAS��֤����
typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE	sUserName[NAME_LEN];		/* �û��� 32*/
    BYTE	sPassword[PASSWD_LEN];		/* ���� 16*/
    BYTE	byRes1[4];	//����
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;

typedef union tagNET_DVR_MOUNT_PARAM_UNION
{
    BYTE  uLen[52];                    //������ṹ��С
    NET_DVR_IDENTIFICATION_PARAM struIdentificationParam;//(SMB/CIFSʱ��Ч)
} NET_DVR_MOUNT_PARAM_UNION, *LPNET_DVR_MOUNT_PARAM_UNION;

typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0������,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;

typedef union tagNET_DVR_MOUNTMETHOD_PARAM_UNION
{
    BYTE  uLen[56]; //������ṹ��С
    NET_DVR_NAS_MOUNT_PARAM struNasMountParam;//NAS���ط�ʽ (byNetDiskTypeΪNFS(NAS)ʱ��Ч)
}NET_DVR_MOUNTMETHOD_PARAM_UNION, *LPNET_DVR_MOUNTMETHOD_PARAM_UNION;

//����Ӳ�̽ṹ����
typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;						//����Ӳ������, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];							//����
    NET_DVR_IPADDR struNetDiskAddr;			//����Ӳ�̵�ַ
    BYTE sDirectory[PATHNAME_LEN];			// PATHNAME_LEN = 128
    WORD wPort;							    //iscsi�ж˿ڣ�����ΪĬ��
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];				//����
}NET_DVR_SINGLE_NET_DISK_INFO, *LPNET_DVR_SINGLE_NET_DISK_INFO;

#define MAX_NET_DISK	16//�������Ӳ�̸���

typedef struct tagNET_DVR_NET_DISKCFG
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG, *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;						//����Ӳ������, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];							//����
    BYTE sDirectory[PATHNAME_LEN];			// PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];	/*���� 64*/
    WORD wPort;							    //iscsi�ж˿ڣ�����ΪĬ��
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE	byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40, *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;
//�¼�����
//������
typedef enum _MAIN_EVENT_TYPE_
{
    EVENT_MOT_DET = 0,		//�ƶ����
        EVENT_ALARM_IN = 1,		//��������
        EVENT_VCA_BEHAVIOR = 2,	// ��Ϊ����
        EVENT_INQUEST = 3,       //��Ѷ�¼�
        EVENT_VCA_DETECTION = 4, //�������
        EVENT_POS = 5,
        EVENT_TRIAL_CASE = 6,//ͥ�󰸼���Ϣ
        EVENT_STREAM_INFO = 100  //��ID��Ϣ
}MAIN_EVENT_TYPE;

#define INQUEST_START_INFO        0x1001       /*Ѷ�ʿ�ʼ��Ϣ*/
#define INQUEST_STOP_INFO         0x1002       /*Ѷ��ֹͣ��Ϣ*/
#define INQUEST_TAG_INFO          0x1003       /*�ص�����Ϣ*/
#define INQUEST_SEGMENT_INFO      0x1004       /*��ѶƬ��״̬��Ϣ*/
#define INQUEST_CASE_INFO		  0x1005		// ������Ϣ����

typedef enum _VCA_DETECTION_MINOR_TYPE_
{
    EVENT_VCA_TRAVERSE_PLANE     = 1,           //Խ�����
        EVENT_FIELD_DETECTION,		                //�����������
        EVENT_AUDIO_INPUT_ALARM,                    //��Ƶ�����쳣
        EVENT_SOUND_INTENSITY_ALARM,                //��ǿͻ�����
        EVENT_FACE_DETECTION,                       //�������
        EVENT_VIRTUAL_FOCUS_ALARM,                  //�齹���
        EVENT_SCENE_CHANGE_ALARM,                   //����������
        EVENT_PIR_ALARM,                            //PIR����
        EVENT_ENTER_REGION,                           //��������
        EVENT_EXIT_REGION,                            //Ŀ���뿪����
        EVENT_LOITERING,                               //�ǻ�
        EVENT_GROUPDETECTION,                       //��������Ա�ۼ�,֧���������
        EVENT_RAPIDMOVE,                            //�����ƶ�
        EVENT_PARK,                              //ͣ��
        EVENT_UNATTENDED_BAGGAGE,                   //��Ʒ����
        EVENT_ATTENDEDBAGGAGE,                      //��Ʒ��ȡ
        EVENT_VEHICLE_DETECTION,					 //�������
        EVENT_ALL = 0xffffffff				        //��ʾȫ��
}VCA_DETECTION_MINOR_TYPE;



//��Ϊ���������Ͷ�Ӧ�Ĵ����ͣ� 0xffff��ʾȫ��
typedef enum _BEHAVIOR_MINOR_TYPE_
{
    EVENT_TRAVERSE_PLANE     = 0,    // ��Խ������
        EVENT_ENTER_AREA,				//Ŀ���������,֧���������
        EVENT_EXIT_AREA,				//Ŀ���뿪����,֧���������
        EVENT_INTRUSION,				 // �ܽ�����,֧���������
        EVENT_LOITER,				 //�ǻ�,֧���������
        EVENT_LEFT_TAKE,				//��Ʒ������ȡ,֧���������
        EVENT_PARKING,					//ͣ��,֧���������
        EVENT_RUN,					//�����ƶ�,֧���������
        EVENT_HIGH_DENSITY,				 //��������Ա�ۼ�,֧���������
        EVENT_STICK_UP,				//��ֽ��,֧���������
        EVENT_INSTALL_SCANNER,				//��װ������,֧���������
        EVENT_OPERATE_OVER_TIME,        // ������ʱ
        EVENT_FACE_DETECT,              // �쳣����
        EVENT_LEFT,                     // ��Ʒ����
        EVENT_TAKE,                      // ��Ʒ��ȡ
        EVENT_LEAVE_POSITION,         //����¼�
        EVENT_TRAIL_INFO = 16,            //β��
        EVENT_FALL_DOWN_INFO = 19,                 //����
        EVENT_OBJECT_PASTE	    =20,		// ����ճ������
        EVENT_FACE_CAPTURE_INFO = 21,                //������
        EVENT_MULTI_FACES_INFO = 22,                  //��������
        EVENT_AUDIO_ABNORMAL_INFO = 23             //��ǿͻ��
}BEHAVIOR_MINOR_TYPE;

//������6��Ӧ�Ĵ�����
typedef enum _TRIAL_CASE_MINOR_TYPE_
{
    TRIAL_START_INFO  = 0x1001,    // ͥ��ʼ�¼�
        TRIAL_STOP_INFO   = 0x1002,		//ͥ������¼�
        TRIAL_TAG_INFO    = 0x1003,		//ͥ���ص��ע�¼�
        TRIAL_SEGMENT_INFO = 0x1004,	// ͥ��Ƭ��״̬��Ϣ
        TRIAL_JUDGE_CASE_INFO=0x1005 //ͥ�󰸼���Ϣ
}TRIAL_CASE_MINOR_TYPE;

// ������100����Ӧ��С����
typedef enum _STREAM_INFO_MINOR_TYPE_
{
    EVENT_STREAM_ID  = 0,					// ��ID
        EVENT_TIMING = 1,					// ��ʱ¼��
        EVENT_MOTION_DETECT = 2,			// �ƶ����
        EVENT_ALARM = 3,					// ����¼��
        EVENT_ALARM_OR_MOTION_DETECT = 4,	// �������ƶ����
        EVENT_ALARM_AND_MOTION_DETECT = 5,	// �������ƶ����
        EVENT_COMMAND_TRIGGER = 6,			// �����
        EVENT_MANNUAL = 7,					// �ֶ�¼��
        EVENT_BACKUP_VOLUME = 8,			// �浵��¼��
		STREAM_EVENT_SEMAPHORE,				//�ź���
		STREAM_EVENT_HIDE,					//�ڵ�
		STREAM_EVENT_INVERSE,				//����
		STREAM_EVENT_VIDEO_LOST,			//��Ƶ��ʧ
		STREAM_EVENT_WIRELESS_ALARM,		//���߱���
		STREAM_EVENT_PIR_ALARM,				//PIR����
		STREAM_EVENT_CALLHELP_ALARM,		//���ȱ���

		STREAM_EVENT_FACESNAP,				//����ץ��
		STREAM_EVENT_FACE_DETECTION,		//�������
		STREAM_EVENT_ITS_PLATE,				//�������
		STREAM_EVENT_PDC,					//������ͳ��
		STREAM_EVENT_SCENECHANGE_DETECTION,	//�������
		STREAM_EVENT_DEFOCUS_DETECTION,		//�齹���
		STREAM_EVENT_AUDIOEXCEPTION,		//��Ƶ�쳣

		//����Ϊ��Ϊ������COMM_ALARM_RULE���������ͣ������VCA_EVENT_TYPE
		VCA_EVENT_TRAVERSE_PLANE,			//��Խ������
		VCA_EVENT_INTRUSION,				//�ܽ�����
		VCA_EVENT_ENTER_AREA,				//��������
		VCA_EVENT_EXIT_AREA,				//�뿪����
		VCA_EVENT_LOITER,					//�ǻ����
		VCA_EVENT_HIGH_DENSITY,				//��Ա�ۼ�
		VCA_EVENT_RUN,						//�����ƶ�
		VCA_EVENT_PARKING,					//�Ƿ�ͣ��
		VCA_EVENT_LEFT,						//��Ʒ����
	VCA_EVENT_TAKE							//��Ʒ��ȡ
}STREAM_INFO_MINOR_TYPE;

// typedef enum tagITS_MINOR_TYPE
// {
//     ITS_EVENT_CONGESTION    = 0,    // ӵ��
//     ITS_EVENT_PARKING,              // ͣ��
//     ITS_EVENT_INVERSE,              // ����
//     ITS_EVENT_PEDESTRIAN,           // ����
//     ITS_EVENT_DEBRIS                // �������������Ƭ
// }ITS_MINOR_TYPE;


#define SEARCH_EVENT_INFO_LEN   300	//�¼���Ϣ����
#define CASE_NO_LEN				64
#define CASE_NAME_LEN			128
#define LITIGANT_LEN			32
#define CHIEF_JUDGE_LEN 		32
#define	 SEARCH_CASE_NO_LEN		56
#define  SEARCH_CASE_NAME_LEN	100
#define  SEARCH_LITIGANT_LEN	32
#define  SEARCH_CHIEF_JUDGE_LEN 32
#define	 CASE_NO_RET_LEN		52
#define  CASE_NAME_RET_LEN		64
#define	 LITIGANT_RET_LEN		24
#define	 CHIEF_JUDGE_RET_LEN	24
//�¼���������
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;			//0-�ƶ���⣬1-��������, 2-�����¼�
    WORD wMinorType;			//����������- ��������ͱ仯��0xffff��ʾȫ��
    NET_DVR_TIME struStartTime;	//�����Ŀ�ʼʱ�䣬ֹͣʱ��: ͬʱΪ(0, 0) ��ʾ�������ʱ�俪ʼ���������ǰ���4000���¼�
    NET_DVR_TIME struEndTime;	//
    BYTE			byLockType;		// 0xff-ȫ����0-δ��1-��
    BYTE 			byValue;			//0-��λ��ʾ��1-��ֵ��ʾ
    BYTE 			byRes[130];		// ����
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];
        struct//��������
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];    //��������ţ�byAlarmInNo[0]����1���ʾ�����ɱ�������1�������¼�
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30];
        }struAlarmParam;

        struct//��������--��ֵ
        {
            WORD wAlarmInNo[128];     /*��������ţ���ֵ��ʾ,���ý���������*/
            BYTE byRes[44]; //����
        }struAlarmParamByValue;

        struct//�ƶ����
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30];//�ƶ����ͨ����byMotDetChanNo[0]����1���ʾ������ͨ��1�����ƶ���ⴥ�����¼�
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30];
        }struMotionParam;

        struct//�ƶ����--��ֵ
        {
            WORD wMotDetChanNo[64];		/* �ƶ����ͨ������ֵ��ʾ ,���ý���������*/
            BYTE byRes[172];				/*����*/
        }struMotionParamByValue;

        struct//��Ϊ����
        {
            BYTE byChanNo[MAX_CHANNUM_V30];	//�����¼���ͨ��
            BYTE byRuleID;					//����ID��0xff��ʾȫ��
            BYTE byRes1[43];				//����
        }struVcaParam;

        struct //��Ϊ����--��ֵ��ʽ����
        {
            WORD wChanNo[64];	 //��Ϊ������Ӧ��ͨ������ֵ��ʾ,���ý���������
            BYTE byRuleID;      //��Ϊ�������ͣ�����0xff��ʾȫ������0��ʼ
            BYTE byRes[171];	 /*����*/
        }struVcaParamByValue;

        struct//��Ѷ�¼���������
        {
            BYTE byRoomIndex;    //��Ѷ�ұ��,��ֵ��ʾ����1��ʼ
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //����
        } struInquestParam;
        struct  //��������������
        {
            BYTE byChan [256];//������������ͨ���ţ��������±��ʾ��byChan[0]����1���ʾ������ͨ��1�����ƶ���ⴥ�����¼�
        }struVCADetectByBit;

        struct//�������������� ��ͨ���Ű�ֵ��ʾ
        {
            DWORD dwChanNo[MAX_CHANNUM_V30-1];// ����ͨ����,��ֵ��ʾ��0xffffffff��Ч���Һ������Ҳ��ʾ��Чֵ
            BYTE byAll;//0-��ʾ����ȫ����1-��ʾȫ����
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // ��id��Ϣ��72�ֽڳ�
            DWORD				dwCmdType;  // �ⲿ�������ͣ�NVR�����ƴ洢ʹ��
            BYTE				byBackupVolumeNum; //�浵��ţ�CVRʹ��
            BYTE				byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE	byCaseNo[SEARCH_CASE_NO_LEN];  //�������
            BYTE	byCaseName[SEARCH_CASE_NAME_LEN]; //������ƣ�
            BYTE	byLitigant1[SEARCH_LITIGANT_LEN]; //������1��
            BYTE	byLitigant2[SEARCH_LITIGANT_LEN]; //������2��
            BYTE	byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];//���г�
            BYTE	byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE	byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM, *LPNET_DVR_SEARCH_EVENT_PARAM;

#define  MAX_POS_KEYWORDS_NUM               3  	    //֧�ֹؼ��ֲ�������
#define  MAX_POS_KEYWORD_LEN                128 	    //ÿ���ؼ��ֳ���
#define  SEARCH_EVENT_INFO_LEN_V40     	    800

//�¼���������
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;			//0-�ƶ���⣬1-��������, 2-�����¼� 5-pos¼��
    WORD wMinorType;			//����������- ��������ͱ仯��0xffff��ʾȫ��
    NET_DVR_TIME struStartTime;	//�����Ŀ�ʼʱ�䣬ֹͣʱ��: ͬʱΪ(0, 0) ��ʾ�������ʱ�俪ʼ���������ǰ���4000���¼�
    NET_DVR_TIME struEndTime;	//
    BYTE			byLockType;		// 0xff-ȫ����0-δ��1-��
    BYTE 			byRes[131];		// ����
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct//��������
        {
            /*��������ţ���ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wAlarmInNo[128];
            BYTE byRes[544]; //����
        }struAlarmParam;

        struct//�ƶ����
        {
            /* �ƶ����ͨ������ֵ��ʾ ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];				/*����*/
        }struMotionParam;

        struct //��Ϊ����
        {
            //��Ϊ������Ӧ��ͨ������ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //��Ϊ�������ͣ�����0xff��ʾȫ������0��ʼ
            BYTE byRes[671];	 /*����*/
        }struVcaParam;

        struct//��Ѷ�¼���������
        {
            BYTE byRoomIndex;    //��Ѷ�ұ��,��1��ʼ
            BYTE byRes[799];     //����
        } struInquestParam;

        struct//�������������� ��ͨ���Ű�ֵ��ʾ
        {
            BYTE byAll;				//����ȫ��ͨ����0-�񣬴�ʱdwChanNo������Ч��
            //1-����ȫ��ͨ������ʱdwChanNo������Ч��
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// ����ͨ����,��ֵ��ʾ��0xffff��Ч���Һ������Ҳ��ʾ��Чֵ
            BYTE byRes[668];
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // ��id��Ϣ��72�ֽڳ�
            DWORD				dwCmdType;  // �ⲿ�������ͣ�NVR�����ƴ洢ʹ��
            BYTE				byBackupVolumeNum; //�浵��ţ�CVRʹ��
            BYTE				byRes[723];
        }struStreamIDParam;

        struct //pos¼��
        {
            WORD   wChannel[MAX_CHANNUM_V30];   	 //ͨ������ֵ��ʾ,���������У�����0xffffʱ��ʾ�������ֵ��Ч
            BYTE     byAllChan;        //�Ƿ����ȫ��ͨ����0-�񣬴�ʱwChannel��Ч��1-ȫ��ͨ������ʱwChannel��Ч
            BYTE	  byCaseSensitive;  	//0-����ִ�Сд�� 1-��ִ�Сд
            BYTE	  byCombinateMode;  //�ؼ�����Ϸ�ʽ��0-��1-��
            BYTE	  byRes1;  			//����
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
 											//�ؼ��ֲ���ʱ������
            BYTE    byRes[284];  		//����
        }struPosAlarm;

        struct
        {
            BYTE	byCaseNo[SEARCH_CASE_NO_LEN];       //�������
            BYTE	byCaseName[SEARCH_CASE_NAME_LEN];   //�������
            BYTE	byLitigant1[SEARCH_LITIGANT_LEN];   //������1
            BYTE	byLitigant2[SEARCH_LITIGANT_LEN];   //������2
            BYTE	byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];   //���г�
            BYTE	byCaseType;
            BYTE	byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;


//���ҷ��ؽ��
typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;			//������
    WORD wMinorType;			//������
    NET_DVR_TIME struStartTime;	//�¼���ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ�䣬�����¼�ʱ�Ϳ�ʼʱ��һ��
    BYTE byChan[MAX_CHANNUM_V30];
    BYTE byChanEx[32];   //����ͨ������λ��ʾ��ʹ�ø��ֶκ�byChan���Բ�ʹ��
    BYTE byRes[4];
    union
    {
        struct//����������
        {
            DWORD dwAlarmInNo;     //���������
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//�ƶ������
        {
            DWORD dwMotDetNo;	//�ƶ����ͨ��
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//��Ϊ�������
        {
            DWORD dwChanNo;					//�����¼���ͨ����
            BYTE byRuleID;					//����ID
            BYTE byRes1[3];					//����
            BYTE byRuleName[NAME_LEN];		//�������
            NET_VCA_EVENT_UNION uEvent;     //��Ϊ�¼�����
        }struVcaRet;
        struct//��Ѷ�¼�
        {
            BYTE  byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE  byDriveIndex;    //��¼����,��1��ʼ
            BYTE  byRes1[6];       //����
            DWORD dwSegmentNo;     //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            WORD  wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            WORD  wSegmentState;   //��Ƭ��״̬ 0 ��¼��1 ��¼�쳣��2 ����¼��Ѷ
            BYTE  byRes2[288];     //����
        }struInquestRet;
        struct //��id¼���ѯ���
        {
            DWORD dwRecordType;	//¼������ 0-��ʱ¼�� 1-�ƶ���� 2-����¼�� 3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼�� 7-�𶯱��� 8-�������� 9-���ܱ��� 10-�ش�¼��
            DWORD dwRecordLength;	//¼���С
            BYTE  byLockFlag;    // ���־ 0��û�� 1����
            BYTE  byDrawFrameType;    // 0���ǳ�֡¼�� 1����֡¼��
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN]; 	//�ļ���
            DWORD dwFileIndex;    		// �浵���ϵ��ļ�����
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE	byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE	byDriveIndex;    //��¼����,��1��ʼ
            WORD	wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            DWORD	dwSegmentNo;    //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            BYTE	bySegmentState;   //��Ƭ��״̬��0-��¼��1-��¼�쳣��2-����¼��Ѷ
            BYTE	byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE	byRes[2];
            BYTE	byCaseNo[CASE_NO_RET_LEN];  //�������
            BYTE	byCaseName[CASE_NAME_RET_LEN]; //������ƣ�
            BYTE	byLitigant1[LITIGANT_RET_LEN]; //������1��
            BYTE	byLitigant2[LITIGANT_RET_LEN]; //������2��
            BYTE	byChiefJudge[CHIEF_JUDGE_RET_LEN];//���г�
            BYTE	byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET, *LPNET_DVR_SEARCH_EVENT_RET;

//���ҷ��ؽ��
typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;			//������
    WORD wMinorType;			//������
    NET_DVR_TIME struStartTime;	//�¼���ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ�䣬�����¼�ʱ�Ϳ�ʼʱ��һ��
    WORD  wChan[MAX_CHANNUM_V40/*512*/];	//������ͨ���ţ�0xffff��ʾ������Ч
    BYTE byRes[36];
    union
    {
        BYTE  byLen[800];               //�����峤��
        struct//����������
        {
            DWORD dwAlarmInNo;     //���������
            BYTE byRes[796];
        }struAlarmRet;
        struct//�ƶ������
        {
            DWORD dwMotDetNo;	//�ƶ����ͨ��
            BYTE byRes[796];
        }struMotionRet;
        struct//��Ϊ�������
        {
            DWORD dwChanNo;					//�����¼���ͨ����
            BYTE byRuleID;					//����ID
            BYTE byRes1[3];					//����
            BYTE byRuleName[NAME_LEN];		//�������
            NET_VCA_EVENT_UNION uEvent;     //��Ϊ�¼�����
            BYTE byRes[668];                    //����
        }struVcaRet;

        struct//��Ѷ�¼�
        {
            BYTE  byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE  byDriveIndex;    //��¼����,��1��ʼ
            BYTE  byRes1[6];       //����
            DWORD dwSegmentNo;     //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            WORD  wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            WORD  wSegmentState;   //��Ƭ��״̬ 0 ��¼��1 ��¼�쳣��2 ����¼��Ѷ
            BYTE  byRes2[784];     //����
        }struInquestRet;

        struct //��id¼���ѯ���
        {
            DWORD dwRecordType;	//¼������ 0-��ʱ¼�� 1-�ƶ���� 2-����¼�� 3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼�� 7-�𶯱��� 8-�������� 9-���ܱ��� 10-�ش�¼��
            DWORD dwRecordLength;	//¼���С
            BYTE  byLockFlag;    // ���־ 0��û�� 1����
            BYTE  byDrawFrameType;    // 0���ǳ�֡¼�� 1����֡¼��
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN]; 	//�ļ���
            DWORD dwFileIndex;    		// �浵���ϵ��ļ�����
            BYTE  byRes[752];
        }struStreamIDRet;

        struct//POS¼���ѯ���
        {
            DWORD dwChanNo;		//��������pos�¼���ͨ��
            BYTE  byRes[796];
        }struPosRet;

        struct
        {
            BYTE	byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE	byDriveIndex;    //��¼����,��1��ʼ
            WORD	wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            DWORD	dwSegmentNo;    //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            BYTE	bySegmentState;   //��Ƭ��״̬��0-��¼��1-��¼�쳣��2-����¼��Ѷ
            BYTE	byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE	byRes[2];
            BYTE	byCaseNo[CASE_NO_RET_LEN];  //�������
            BYTE	byCaseName[CASE_NAME_RET_LEN]; //������ƣ�
            BYTE	byLitigant1[LITIGANT_RET_LEN]; //������1��
            BYTE	byLitigant2[LITIGANT_RET_LEN]; //������2��
            BYTE	byChiefJudge[CHIEF_JUDGE_RET_LEN];//���г�
            BYTE	byRes1[600];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;


//SDK_V35  2009-10-26

// �궨��������
typedef enum tagCALIBRATE_TYPE
{
    PDC_CALIBRATE  = 0x01,  // PDC �궨
        BEHAVIOR_OUT_CALIBRATE  = 0x02, //��Ϊ���ⳡ���궨
        BEHAVIOR_IN_CALIBRATE = 0x03,    // ��Ϊ���ڳ����궨
        ITS_CALBIRETE       = 0x04,      //  ��ͨ�¼��궨
        BV_DIRECT_CALIBRATE      = 0x05,   //˫Ŀֱ�ӱ궨
        PDC_LINE_CALIBRATE  = 0x06  //PDC �� �궨
}CALIBRATE_TYPE;

#define MAX_RECT_NUM  6
typedef struct tagNET_DVR_RECT_LIST
{
    BYTE    byRectNum;    // ���ο�ĸ���
    BYTE    byRes1[11];  //�����ֽ�
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM]; // ���Ϊ6��Rect
}NET_DVR_RECT_LIST, *LPNET_DVR_RECT_LIST;

// PDC �궨����
typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;       // �궨���ο��б�
    BYTE           byRes[120];       // �����ֽ�
}NET_DVR_PDC_CALIBRATION, *LPNET_DVR_PDC_CALIBRATION;


// �궨�ߵ��������������ʾ��ǰ�궨����ʵ�ʱ�ʾ���Ǹ߶��߻��ǳ����ߡ�
typedef enum tagLINE_MODE
{
    HEIGHT_LINE,        //�߶�����
        LENGTH_LINE        //��������
}LINE_MODE;
/*
�����ñ궨��Ϣ��ʱ�������Ӧλ������ʹ�ܣ���������ز���
��û������ʹ�ܣ���궨����Ի�ȡ��ص���������
*/
typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;     // �Ƿ�ʹ�����������߶���
    BYTE    byEnableAngle;      // �Ƿ�ʹ��������������Ƕ�
    BYTE    byEnableHorizon;    // �Ƿ�ʹ������������ƽ��
    BYTE    byRes[5];   // �����ֽ�
    float   fCameraHeight;    // �����߶�
    float   fCameraAngle;     // ��������Ƕ�
    float   fHorizon;         // �����еĵ�ƽ��
}NET_DVR_CAMERA_PARAM, *LPNET_DVR_CAMERA_PARAM;
/*
��fValue��ʾĿ��߶ȵ�ʱ��struStartPoint��struEndPoint�ֱ��ʾĿ��ͷ����ͽŲ��㡣
��fValue��ʾ�߶γ��ȵ�ʱ��struStartPoint��struEndPoint�ֱ��ʾ�߶���ʼ����յ㣬
mode��ʾ��ǰ���߱�ʾ�߶��߻��ǳ����ߡ�
*/
typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;     // ���� LINE_MODE
    BYTE            byRes[3];       // �����ֽ�
    NET_VCA_POINT   struStartPoint;
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT, *LPNET_DVR_LINE_SEGMENT;

#define  MAX_LINE_SEG_NUM 8

/*
�궨����Ŀǰ��Ҫ4-8�����ߣ��Ի�ȡ�������ز���
*/
typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;          // ���߸���
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];    // ����������
    NET_DVR_CAMERA_PARAM    struCameraParam;    // ��������
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION, *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

/*
�ýṹ���ʾIAS���ܿ�궨��
���а���һ��Ŀ����һ����Ӧ�ĸ߶ȱ궨�ߣ�
Ŀ���Ϊվ����������Ӿ��ο򣻸߶������ʶ����ͷ���㵽�ŵ�ı궨�ߣ�
�ù�һ������ʾ��
*/
typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;   // Ŀ���
    NET_DVR_LINE_SEGMENT struLineSegment;    // �߶ȱ궨��
}NET_DVR_IN_CAL_SAMPLE, *LPNET_DVR_IN_CAL_SAMPLE;

#define  MAX_SAMPLE_NUM 5

typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION
{
    DWORD    dwCalSampleNum;      //  �궨�����
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM]; // �궨��������
    NET_DVR_CAMERA_PARAM    struCameraParam;    // ��������
    BYTE byRes[16];
}NET_DVR_BEHAVIOR_IN_CALIBRATION, *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

#define  CALIB_PT_NUM 4
typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum; //�궨����
    NET_VCA_POINT struPoint[CALIB_PT_NUM]; //ͼ�����
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];        // �����ֽ�
}NET_DVR_ITS_CALIBRATION, *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{
    DWORD  dwCameraHeight;  //�����߶ȣ���λcm
    float  fPitchAngle;     //������ӽǶ�[0��, 60��],
    float  fInclineAngle;   //�������б�Ƕ�[-20��,20��]
    BYTE   byRes1[228];     //����
}NET_DVR_BV_DIRECT_CALIBRATION,*LPNET_DVR_BV_DIRECT_CALIBRATION;

// PDC �궨����
typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[224];// �����ֽ�
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;

// �궨����������
// �������ر궨������Է��ڸýṹ����
typedef union tagNET_DVR_CALIBRATION_PRARM_UNION
{
    BYTE byRes[240];                    //������ṹ��С
    NET_DVR_PDC_CALIBRATION struPDCCalibration;  //PDC �궨����
    NET_DVR_BEHAVIOR_OUT_CALIBRATION  struBehaviorOutCalibration;  //  ��Ϊ���ⳡ���궨  ��ҪӦ����IVS��
    NET_DVR_BEHAVIOR_IN_CALIBRATION  struBehaviorInCalibration;     // ��Ϊ���ڳ����궨����ҪӦ��IAS��
    NET_DVR_ITS_CALIBRATION struITSCalibration;
    NET_DVR_BV_DIRECT_CALIBRATION struBvDirectCalibration; //˫Ŀֱ�ӱ궨
    NET_DVR_PDC_LINE_CALIBRATION struPDCLineCalibration; //PDC �߱궨����
}NET_DVR_CALIBRATION_PRARM_UNION, *LPNET_DVR_CALIBRATION_PRARM_UNION;


// �궨���ýṹ
typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;               //�궨�ṹ��С
    BYTE    byEnable;           // �Ƿ����ñ궨
    BYTE    byCalibrationType;    // �궨���� ��ݲ�ͬ��������������ѡ��ͬ�ı궨 �ο�CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;  // �궨����������
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG, *LPNET_DVR_CALIBRATION_CFG;

//����ͳ�Ʒ���ṹ��
typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint; //����ͳ�Ʒ�����ʼ��
    NET_VCA_POINT struEndPoint;    // ����ͳ�Ʒ�������
}NET_DVR_PDC_ENTER_DIRECTION, *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;              //�ṹ��С
    BYTE            byEnable;             // �Ƿ񼤻����;
    BYTE            byRes1[23];       // �����ֽ�
    NET_VCA_POLYGON          struPolygon;            // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // �������뷽��
} NET_DVR_PDC_RULE_CFG, *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;              //�ṹ��С
    BYTE            byEnable;             // �Ƿ񼤻����;
    BYTE            byRes1[23];       // �����ֽ�
    NET_VCA_POLYGON struPolygon;            // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // �������뷽��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_TIME_EX struDayStartTime; //���쿪ʼʱ�䣬ʱ������Ч
    NET_DVR_TIME_EX struNightStartTime; //ҹ�?ʼʱ�䣬ʱ������Ч
    BYTE            byRes[100];       // �����ֽ�
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

/********* IPC5.1.7 ������ͳ�ƹ��� Begin 2014-03-21***********/
//�����ṹ
typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize; //�ṹ��С
    DWORD  dwChannel; //ͨ����
    //DWORD dwID;  �������ೡ������
    BYTE  byRes[64];
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

//���ýṹ
typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize; //�ṹ��С
    BYTE   byEnable; //�Ƿ񼤻����;
    BYTE   byOSDEnable;//����ͳ��OSD��ʾ�Ƿ�����,  0-��1-��
    BYTE   byCurDetectType;//��ǰ����������ͣ�0-����Σ�1-�����
    BYTE   byRes1; // �����ֽ�
    NET_VCA_POINT   struOSDPoint;//����ͳ����ʾOSD��ʾ���Ͻ����
    //�������������ϴ����ڣ�0-15��1-1��2-5��3-10��4-20��5-30��6-60����λ������
    BYTE   byDataUploadCycle;
    //ÿ���ϴ�����ʹ�ܣ�0-�رգ�1-������
    BYTE   bySECUploadEnable;
    BYTE   byRes2[10];// �����ֽ�
    NET_VCA_POLYGON          struPolygon; // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // �������뷽��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_TIME_EX struDayStartTime; //���쿪ʼʱ�䣬ʱ������Ч
    NET_DVR_TIME_EX struNightStartTime; //ҹ�?ʼʱ�䣬ʱ������Ч
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*���?ʽ ��֧���ϴ�����*/
    BYTE   byDetecteSensitivity;//Ŀ���������ȣ���Χ1-100��Ĭ��50
    BYTE   byGenerateSpeedSpace;//Ŀ������ٶȣ����򣩣���Χ1-100��Ĭ��50
    BYTE   byGenerateSpeedTime;// Ŀ������ٶȣ�ʱ�򣩣���Χ1-100��Ĭ��50
    BYTE   byCountSpeed;// �����ٶȣ���Χ1-100��Ĭ��50
    BYTE   byDetecteType;// Ŀ�������ͣ�0-�Զ���1-��ͷ��2-ͷ�磬Ĭ��0-�Զ����Զ�ģʽ��DSP�����㷨�Ĳ������ø��㷨��
    BYTE   byTargetSizeCorrect;//Ŀ��ߴ�����Χ1-100��Ĭ��50
    BYTE   byRes3[2];// �����ֽ�
    NET_VCA_LINE  struLine;//�����
    BYTE   byRes[236];// �����ֽ�
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;
/********* IPC5.1.7 ������ͳ�ƹ��� End 2014-03-21***********/

//���ð���Ϣ�ṹ��
typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //������ʣ��ʱ�䣬0xffff��ʾ��Ч����λ����
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byRes[64];
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byMode; //��Чģʽ��0-��ʱ��1-�ֶ�
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//�������ʱ�䣬ʱ������Ч
    BYTE  byRes[64];
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;     //�Ƿ�������
    BYTE   byVCAType;       //�����������ͣ�VCA_CHAN_ABILITY_TYPE
    BYTE   byStreamWithVCA; //�������Ƿ��������Ϣ
    BYTE   byMode;			//ģʽ��ATM ����ʱ����VCA_CHAN_MODE_TYPE ,TFS ����ʱ���� TFS_CHAN_MODE_TYPE����Ϊ���������ʱ����BEHAVIOR_SCENE_MODE_TYPE
    BYTE   byControlType;   //�������ͣ���λ��ʾ��0-��1-��
    //byControlType &1 �Ƿ�����ץ�Ĺ���
    //byControlType &2 �Ƿ���������ǰ���豸
    BYTE   byRes[83]; 		//����������Ϊ0
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;

//����������ͳ�Ʋ���  ������Ϊ�ڲ��ؼ��ֲ���
// HUMAN_GENERATE_RATE
// Ŀ������ٶȲ������PDC�����Ŀ����ٶȡ��ٶ�Խ�죬Ŀ��Խ������ɡ���������Ƶ���������ϲ�ԱȶȽϵ�ʱ���������õĹ��������Сʱ��Ӧ�ӿ�Ŀ������ٶȣ� ����Ŀ���©�죻��������Ƶ�жԱȶȽϸ�ʱ�����߹�������ϴ�ʱ��Ӧ�ý���Ŀ������ٶȣ��Լ�����졣Ŀ������ٶȲ�����5����1���ٶ�����5����죬Ĭ�ϲ���Ϊ3��
//
// DETECT_SENSITIVE
// Ŀ���������ȿ��Ʋ������PDC����һ���������򱻼��ΪĿ��������ȡ�������Խ�ߣ���������Խ���ױ����ΪĿ�꣬������Խ����Խ�Ѽ��ΪĿ�ꡣ��������Ƶ���������ϲ�ԱȶȽϵ�ʱ��Ӧ��߼�������ȣ� ����Ŀ���©�죻��������Ƶ�жԱȶȽϸ�ʱ��Ӧ�ý��ͼ�������ȣ��Լ�����졣��Ӧ������5��������1��������ͣ�5����ߣ�Ĭ�ϼ���Ϊ3��
// TRAJECTORY_LEN
// �켣��ɳ��ȿ��Ʋ����ʾ��ɹ켣ʱҪ��Ŀ������λ�����ء���Ӧ������5��������1����ɳ�������켣�������5����ɳ�����̣��켣�����죬Ĭ�ϼ���Ϊ3��
// TRAJECT_CNT_LEN
// �켣����ȿ��Ʋ����ʾ�켣����ʱҪ��Ŀ������λ�����ء���Ӧ������5��������1������Ҫ�󳤶�����켣��������5������Ҫ�󳤶���̣��켣������죬Ĭ�ϼ���Ϊ3��
// PREPROCESS
// ͼ��Ԥ������Ʋ���0 - �����?1 - ���?Ĭ��Ϊ0��
// CAMERA_ANGLE
// �����Ƕ�������� 0 - ��б�� 1 - ��ֱ��Ĭ��Ϊ0��
typedef enum tagPDC_PARAM_KEY
{
    HUMAN_GENERATE_RATE = 50,              // Ŀ������ٶ� ��50��ʼ
        DETECT_SENSITIVE    = 51,               // ���������
}PDC_PARAM_KEY;

typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                 // Ŀ��id
    NET_VCA_RECT struTargetRect;               // Ŀ���
    BYTE      byRes1[8];        // �����ֽ�
}NET_DVR_PDC_TARGET_INFO, *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                   //Ŀ�����
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];   //Ŀ����Ϣ����
    BYTE    byRes2[8];                  // �����ֽ�
}NET_DVR_PDC_TARGET_IN_FRAME, *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;          // PDC�����������ϴ��ṹ���С
    BYTE                        byMode;          // 0 ��֡ͳ�ƽ�� 1��Сʱ���ͳ�ƽ��
    BYTE                        byChannel;       // �����ϴ�ͨ����
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE                        bySmart;         //רҵ���ܷ���0��Smart ���� 1
    BYTE                        byRes1;          // �����ֽ�
    /********* IPC5.1.7 �������� End 2014-03-21***********/
    NET_VCA_DEV_INFO  	 struDevInfo;		     //ǰ���豸��Ϣ
    union
    {
        struct   // ��֡ͳ�ƽ��ʱʹ��
        {
            DWORD   dwRelativeTime;     // ���ʱ��
            DWORD   dwAbsTime;          // ���ʱ��
            BYTE    byRes[92];
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // ͳ����ʼʱ��
            NET_DVR_TIME                      tmEnd;  //  ͳ�ƽ���ʱ��
            BYTE byRes[92];
        }struStatTime;
    }uStatModeParam;  // ��Ϊһ�������� ��֡��ʱ�����֡��Ŀ����Ϣ ��Сʱ���ͳ�ƽ����Ҫͳ��ʱ�� ����
    DWORD                       dwLeaveNum;        // �뿪����
    DWORD                       dwEnterNum;        // ��������
    BYTE                        byRes2[40];           // �����ֽ�
}NET_DVR_PDC_ALRAM_INFO, *LPNET_DVR_PDC_ALRAM_INFO;


//  ��������Ϣ��ѯ
typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD       dwLeaveNum;
    DWORD       dwEnterNum;
    BYTE        byRes1[256];
}NET_DVR_PDC_QUERY, *LPNET_DVR_PDC_QUERY;

typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;             // �ṹ��С
    NET_DVR_PTZ_POSITION    struPtzPosition;    // ����λ����Ϣ
    NET_VCA_RULECFG         struVcaRuleCfg;     //��Ϊ��������
    BYTE                    byRes2[80];         // �����ֽ�
}NET_DVR_POSITION_RULE_CFG, *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // �ṹ��С
    NET_DVR_PTZ_POSITION    struPtzPosition;    // ����λ����Ϣ
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //��Ϊ��������
    BYTE  byTrackEnable; //�Ƿ����ø���
    BYTE  byRes1;
    WORD wTrackDuration; //���ٳ���ʱ�䣬��λs
    BYTE                    byRes2[76];         // �����ֽ�
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;


typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;	// �Ƿ����ó�����λ����
    BYTE				byRes1[3];
    NET_DVR_PTZPOS      struUp;     // ����λ
    NET_DVR_PTZPOS      struDown;   // ����λ
    NET_DVR_PTZPOS      struLeft;   // ����λ
    NET_DVR_PTZPOS      struRight;  // ����λ
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE, *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    // ��������
    BYTE    byRes1;
    WORD	wDwell;	// ͣ��ʱ��
    BYTE    byRes2[4];   // �����ֽ�
}NET_DVR_POSITION_INDEX, *LPNET_DVR_POSITION_INDEX;

#define  MAX_POSITION_NUM 10
typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD dwSize;
    BYTE    byNum; // ��������
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG, *LPNET_DVR_POSITION_TRACK_CFG;

//Ѳ��·��������Ϣ
typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;         // ͣ��ʱ�� 30-300
    BYTE   byPositionID;   // ������1-10��Ĭ��0��ʾ��Ѳ���㲻��ӳ���
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO, *LPNET_DVR_PATROL_SCENE_INFO;

// ����Ѳ������������Ϣ
typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                 // �ṹ��С
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];    // Ѳ��·��
    BYTE   byRes[16];                              // �����ֽ�
}NET_DVR_PATROL_TRACKCFG, *LPNET_DVR_PATROL_TRACKCFG;

//���ع���˵����ýṹ��
typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // �ṹ��С
    WORD    wAlarmDelayTime;    // ������ʱʱ�䣬Ŀǰ���ֻ֧��ȫ������ ��Χ1-120��
    WORD    wTrackHoldTime;     // �������ٳ���ʱ��  ��Χ0-300��
    BYTE    byTrackMode;        //  ���� IPDOME_TRACK_MODE
    BYTE	 byPreDirection;	// ���ٷ���Ԥ�� 0-������ 1-����
    BYTE 	 byTrackSmooth;	    // ��������  0-������ 1-����
    BYTE	 byZoomAdjust;	// ����ϵ����� �μ��±�
    BYTE	byMaxTrackZoom;	//�����ٱ���ϵ��,0-��ʾĬ�ϱ���ϵ��,�ȼ�6-�궨ֵ*1.0(Ĭ��),1-5Ϊ��С�궨ֵ��ֵԽС����С�ı���Խ��,7-15Ϊ�Ŵ�ֵԽ�󣬷Ŵ�ı���Խ��
    BYTE   byStopTrackWhenFindFace;  //������⵽���Ƿ�ֹͣ���� 0-�� 1-��
    BYTE   byStopTrackThreshold;   //������ֹ������ֵ
    BYTE   byRes[9];          //  �����ֽ�
}NET_DVR_TRACK_PARAMCFG, *LPNET_DVR_TRACK_PARAMCFG;

// ����о����
typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;   // ��������ϵ��
    BYTE    byRes[42];  // �����ֽ�
}NET_DVR_DOME_MOVEMENT_PARAM, *LPNET_DVR_DOME_MOVEMENT_PARAM;

/********************************���ܽ�ͨ�¼� begin****************************************/
#define  MAX_REGION_NUM			8       // �����б������Ŀ
#define  MAX_TPS_RULE			8       // �����������Ŀ
#define  MAX_AID_RULE			8      // ����¼�������Ŀ
#define  MAX_LANE_NUM			8		// ��󳵵���Ŀ

//��ͨ�¼����ͣ�
typedef enum tagTRAFFIC_AID_TYPE
{
    CONGESTION          = 0x01,    //ӵ��
        PARKING             = 0x02,    //ͣ��
        INVERSE             = 0x04,    //����
        PEDESTRIAN          = 0x08,    //����
        DEBRIS              = 0x10,    //������ ��������Ƭ
        SMOKE               = 0x20,    //����
        OVERLINE            = 0x40,     //ѹ��
        VEHICLE_CONTROL_LIST  = 0x80,  //�������
        SPEED                 = 0x100,  //����
        LANECHANGE         = 0x200,      //���
        TURNAROUND         = 0x400,     //��ͷ
        VEHICLE_OCCUPANCY_NONVEHICLE = 0x800, //��ռ�÷ǻ�λ
        GASSER            = 0x1000    //����
}TRAFFIC_AID_TYPE;

typedef enum tagTRAFFIC_SCENE_MODE
{
    FREEWAY = 0,	//  ���ٻ��ⳡ��
        TUNNEL,         //  �����������
        BRIDGE          //  ������������
}TRAFFIC_SCENE_MODE;

typedef enum tagITS_ABILITY_TYPE
{
    ITS_CONGESTION_ABILITY             = 0x01,      //ӵ��
        ITS_PARKING_ABILITY                = 0x02,      //ͣ��
        ITS_INVERSE_ABILITY                = 0x04,      //����
        ITS_PEDESTRIAN_ABILITY             = 0x08,      //����
        ITS_DEBRIS_ABILITY                 = 0x10,      //������ ��������Ƭ
        ITS_SMOKE_ABILITY                  = 0x20,      //����-���
        ITS_OVERLINE_ABILITY               = 0x40,      //ѹ��
        ITS_VEHICLE_CONTROL_LIST_ABILITY   = 0x80,		//�������
        ITS_SPEED_ABILITY				   = 0x100,	    //����
        ITS_LANECHANGE_ABILITY             = 0x200,     //���
        ITS_TURNAROUND_ABILITY             = 0x400,      //��ͷ
        ITS_LANE_VOLUME_ABILITY            = 0x010000,  //��������
        ITS_LANE_VELOCITY_ABILITY          = 0x020000,  //����ƽ���ٶ�
        ITS_TIME_HEADWAY_ABILITY           = 0x040000,  //��ͷʱ��
        ITS_SPACE_HEADWAY_ABILITY          = 0x080000,  //��ͷ���
        ITS_TIME_OCCUPANCY_RATIO_ABILITY   = 0x100000,  //����ռ���ʣ���ʱ����)
        ITS_SPACE_OCCUPANCY_RATIO_ABILITY  = 0x200000,  //����ռ���ʣ��ٷֱȼ��㣨�ռ���)
        ITS_LANE_QUEUE_ABILITY             = 0x400000,  //�Ŷӳ���
        ITS_VEHICLE_TYPE_ABILITY           = 0x800000,  //��������
        ITS_TRAFFIC_STATE_ABILITY          = 0x1000000  //��ͨ״̬
}ITS_ABILITY_TYPE;

// ��ͨͳ�Ʋ���
typedef enum tagITS_TPS_TYPE
{
    LANE_VOLUME           = 0x01,    //��������
        LANE_VELOCITY         = 0x02,    //�����ٶ�
        TIME_HEADWAY          = 0x04,    //��ͷʱ��
        SPACE_HEADWAY         = 0x08,    //��ͷ���
        TIME_OCCUPANCY_RATIO  = 0x10,    //����ռ���� (ʱ����)
        SPACE_OCCUPANCY_RATIO = 0x20,    //����ռ���ʣ��ٷֱȼ���(�ռ���)
        QUEUE                 = 0x40,    //�Ŷӳ���
        VEHICLE_TYPE          = 0x80,    //��������
        TRAFFIC_STATE         = 0x100    //��ͨ״̬
}ITS_TPS_TYPE;

typedef struct tagNET_DVR_REGION_LIST
{
    DWORD	dwSize;	// �ṹ���С
    BYTE    byNum;      // �������
    BYTE    byRes1[3];    // �����ֽ�
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM]; // ����
    BYTE	byRes2[20];	// �����ֽ�
}NET_DVR_REGION_LIST,*LPNET_DVR_REGION_LIST;


// ����ṹ��
typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // ������ʼ��
    NET_VCA_POINT struEndPoint;     // ��������
}NET_DVR_DIRECTION, *LPNET_DVR_DIRECTION;

// ��������
typedef struct tagNET_DVR_ONE_LANE
{
    BYTE	byEnable;                   // �����Ƿ�����
    BYTE	byRes1[11];	                // �����ֽ�
    BYTE    byLaneName[NAME_LEN];       // �����������
    NET_DVR_DIRECTION struFlowDirection;// �����ڳ�������
    NET_VCA_POLYGON struPolygon;		// ��������
}NET_DVR_ONE_LANE, *LPNET_DVR_ONE_LANE;

// ��������
typedef struct tagNET_DVR_LANE_CFG
{
    DWORD	dwSize;	// �ṹ���С
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];	// �������� �����±���Ϊ����ID��
    BYTE	byRes1[40];	 // �����ֽ�
}NET_DVR_LANE_CFG, *LPNET_DVR_LANE_CFG;

// ��ͨ�¼�����
typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;       // Υͣ���������  10-120s
    WORD    wPedestrianDuration;    // ���˳���ʱ��    1-120s
    WORD    wDebrisDuration;        // ���������ʱ��  10-120s
    WORD    wCongestionLength;      // ӵ�³�����ֵ    5-200���ף�
    WORD    wCongestionDuration;    // ӵ�³������    10-120s
    WORD    wInverseDuration;       // ���г���ʱ��    1-10s
    WORD    wInverseDistance;       // ���о�����ֵ ��λm ��Χ[2-100] Ĭ�� 10��
    WORD    wInverseAngleTolerance; // ����Ƕ�ƫ�� 90-180��,��������������ļн�
    WORD    wIllegalParkingTime;    // Υͣʱ��[4,60]����λ������ ,TFS(��ͨΥ��ȡ֤) ����ģʽ��
    WORD    wIllegalParkingPicNum;  // ΥͣͼƬ����[1,6], TFS(��ͨΥ��ȡ֤) ����ģʽ��
    BYTE    byMergePic;             // ͼƬƴ��,TFS ����ģʽ�� 0- ��ƴ�� 1- ƴ��
    BYTE    byRes1[23];             // �����ֽ�
}NET_DVR_AID_PARAM, *LPNET_DVR_AID_PARAM;

// ������ͨ�¼�����ṹ��
typedef struct tagNET_DVR_ONE_AID_RULE
{
    BYTE    byEnable;                   // �Ƿ������¼�����
    BYTE    byRes1[3];                  // �����ֽ�
    BYTE    byRuleName[NAME_LEN];       // �������
    DWORD   dwEventType;                // ��ͨ�¼�������� TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; // �ߴ������
    NET_VCA_POLYGON     struPolygon;    // ��������
    NET_DVR_AID_PARAM   struAIDParam;   //  �¼�����
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	  //���?ʽ
    BYTE byRelRecordChan[MAX_CHANNUM_V30];        //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes2[20];
}NET_DVR_ONE_AID_RULE, *LPNET_DVR_ONE_AID_RULE;

// ��ͨ�¼�����
typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;                    // �ṹ���С
    BYTE    byPicProType;              //����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];                 // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam; //ͼƬ���ṹ
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];
    BYTE    byRes2[32];
}NET_DVR_AID_RULECFG, *LPNET_DVR_AID_RULECFG;

// ������ͨ�¼�����ṹ��(��չ)
typedef struct tagNET_DVR_ONE_AID_RULE_V41
{
    BYTE                        byEnable;                 // �Ƿ������¼�����
    BYTE						byLaneNo;                 // ����������
    BYTE                        byRes1[2];                // �����ֽ�
    BYTE                        byRuleName[NAME_LEN];     // �������
    DWORD                       dwEventType;              // ��ͨ�¼�������� TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // �ߴ������
    NET_VCA_POLYGON             struPolygon;              // ��������
    NET_DVR_AID_PARAM           struAIDParam;             // �¼�����
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// ����ʱ���
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	          //���?ʽ
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //����������¼��ͨ����1��ʾ������ͨ����0��ʾ������
    BYTE                        byRes2[60];               //����
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

// ��ͨ�¼�����(��չ)
typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // �ṹ���С
    BYTE    byPicProType;               // ����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];                  // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam; 	// ͼƬ���ṹ
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //��������
    BYTE    byRes2[128];                //����
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

// ��ͨͳ�Ʋ���ṹ��
typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;                   //�Ƿ�ʹ�ܳ�����ͨ�������
    BYTE	byLaneID;		            //����ID
    BYTE    byRes1[2];
    DWORD   dwCalcType;                 //ͳ�Ʋ�������ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; //�ߴ������
    NET_VCA_POLYGON struVitrualLoop;    //������Ȧ
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	//���?ʽ,һ��Ϊ�����Ƿ��ϴ����ģ������ܲ���Ҫ
    BYTE    byRes2[20];                         //�����ֽ�
}NET_DVR_ONE_TPS_RULE, *LPNET_DVR_ONE_TPS_RULE;

// ��ͨ����ͳ�ƹ������ýṹ��
typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;              // �ṹ��С
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE]; // �±��Ӧ��ͨ����ID
    BYTE    byRes2[40];         // �����ֽ�
}NET_DVR_TPS_RULECFG, *LPNET_DVR_TPS_RULECFG;

// ��ͨͳ�Ʋ���ṹ��(��չ)
typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //�Ƿ�ʹ�ܳ�����ͨ�������
    BYTE	byLaneID;		              //����ID
    BYTE    byRes1[2];                    //����
    DWORD   dwCalcType;                   // ͳ�Ʋ�������ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_VCA_POLYGON      struVitrualLoop; //������Ȧ
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	   //���?ʽ
    BYTE    byRes2[60];                   // �����ֽ�
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;


// ��ͨ����ͳ�ƹ������ýṹ��(��չ)
typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         // �ṹ��С
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; // �±��Ӧ��ͨ����ID
    BYTE    byRes[128];     // ����
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;

// ��ͨ�¼���Ϣ
typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;   // ������ţ�Ϊ�������ýṹ�±꣬0-16
    BYTE            byRes1[3];
    BYTE            byRuleName[NAME_LEN]; //  �������
    DWORD           dwAIDType;  // �����¼�����
    NET_DVR_DIRECTION   struDirect; // ����ָ������
    BYTE    bySpeedLimit; //����ֵ����λkm/h[0,255]
    BYTE    byCurrentSpeed; //��ǰ�ٶ�ֵ����λkm/h[0,255]
    BYTE            byRes2[38];  // �����ֽ�
}NET_DVR_AID_INFO, *LPNET_DVR_AID_INFO;

// ��ͨ�¼�����
typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;         // �ṹ����
    DWORD               dwRelativeTime;	// ���ʱ��
    DWORD               dwAbsTime;		// ���ʱ��
    NET_VCA_DEV_INFO  	struDevInfo;	// ǰ���豸��Ϣ
    NET_DVR_AID_INFO    struAIDInfo;    // ��ͨ�¼���Ϣ
    DWORD               dwPicDataLen;   // ����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ���
    BYTE                *pImage;        // ָ��ͼƬ��ָ��
    BYTE                byRes[40];      // �����ֽ�
}NET_DVR_AID_ALARM, *LPNET_DVR_AID_ALARM;

// �������нṹ��
typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;       //����ͷ
    NET_VCA_POINT   struTail;       //����β
    DWORD           dwLength;      //ʵ�ʶ��г��� ��λΪ�� [0-500]
}NET_DVR_LANE_QUEUE, *LPNET_DVR_LANE_QUEUE;

typedef enum tagTRAFFIC_DATA_VARY_TYPE
{
    NO_VARY,         //�ޱ仯
        VEHICLE_ENTER,   //��������������Ȧ
        VEHICLE_LEAVE,   //�����뿪������Ȧ
        UEUE_VARY        //���б仯
}TRAFFIC_DATA_VARY_TYPE;

typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];  //�����������
    BYTE    byRuleID;              //������ţ�Ϊ�������ýṹ�±꣬0-7
    BYTE    byVaryType;            //������ͨ����仯���� ���� TRAFFIC_DATA_VARY_TYPE
    BYTE	byLaneType;			   //�������л�����
    BYTE	byRes1;
    DWORD    dwLaneVolume;         //�������� ��ͳ���ж��ٳ���ͨ��
    DWORD   dwLaneVelocity;        //�����ٶȣ��������
    DWORD   dwTimeHeadway;         //��ͷʱ�࣬�������
    DWORD   dwSpaceHeadway;        //��ͷ��࣬����������
    float   fSpaceOccupyRation;    //����ռ���ʣ��ٷֱȼ��㣨�ռ���)
    NET_DVR_LANE_QUEUE  struLaneQueue;    //�������г���
    NET_VCA_POINT       struRuleLocation; //��Ȧ��������ĵ�λ��
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM, *LPNET_DVR_LANE_PARAM;


typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;   // ��ͨ����ĳ�����Ŀ
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO, *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD             dwSize;          //�ṹ���С
    DWORD             dwRelativeTime;  //���ʱ��
    DWORD             dwAbsTime;       //���ʱ��
    NET_VCA_DEV_INFO  struDevInfo;     //ǰ���豸��Ϣ
    NET_DVR_TPS_INFO  struTPSInfo;     //��ͨ�¼���Ϣ
    BYTE              byRes1[32];      //�����ֽ�
}NET_DVR_TPS_ALARM, *LPNET_DVR_TPS_ALARM;

typedef enum tagTRAFFIC_DATA_VARY_TYPE_EX_ENUM
{
    ENUM_TRAFFIC_VARY_NO             = 0x00,   //�ޱ仯
        ENUM_TRAFFIC_VARY_VEHICLE_ENTER  = 0x01,   //��������������Ȧ
        ENUM_TRAFFIC_VARY_VEHICLE_LEAVE  = 0x02,   //�����뿪������Ȧ
        ENUM_TRAFFIC_VARY_QUEUE          = 0x04,   //���б仯
        ENUM_TRAFFIC_VARY_STATISTIC      = 0x08,   //ͳ����ݱ仯��ÿ���ӱ仯һ�ΰ���ƽ���ٶȣ������ռ�/ʱ��ռ���ʣ���ͨ״̬��
}TRAFFIC_DATA_VARY_TYPE_EX_ENUM;

typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; // �����������
    BYTE               byRuleID;             // ������ţ�Ϊ�������ýṹ�±꣬0-7
    BYTE	           byLaneType;		     // �������л�����
    BYTE               byTrafficState;       // �����Ľ�ͨ״̬��0-��Ч��1-��ͨ��2-ӵ����3-����
    BYTE               byLaneNo;            //������
    DWORD              dwVaryType;           // ������ͨ����仯���Ͳ���  TRAFFIC_DATA_VARY_TYPE_EX_ENUM����λ���
    DWORD              dwTpsType;            // ��ݱ仯���ͱ�־����ʾ��ǰ�ϴ���ͳ�Ʋ����У���Щ�����Ч������ITS_TPS_TYPE,��λ���
    DWORD              dwLaneVolume;	     // ����������ͳ���ж��ٳ���ͨ��
    DWORD              dwLaneVelocity;       // �����ٶȣ��������
    DWORD              dwTimeHeadway ;       // ��ͷʱ�࣬�������
    DWORD              dwSpaceHeadway;       // ��ͷ��࣬����������
    float              fSpaceOccupyRation;   // ����ռ���ʣ��ٷֱȼ��㣨�ռ���)
    float              fTimeOccupyRation;    // ʱ��ռ���ʣ��ٷֱȼ���
    DWORD              dwLightVehicle;       // С�ͳ�����
    DWORD              dwMidVehicle;         // ���ͳ�����
    DWORD              dwHeavyVehicle;       // ���ͳ�����
    NET_DVR_LANE_QUEUE struLaneQueue;        // �������г���
    NET_VCA_POINT      struRuleLocation;     // ����λ��������Ȧ������
    DWORD			   dwOversizeVehicle;    // ���ͳ�����
    BYTE               byRes2[60];           // ����
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;


typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          // ��ͨ����ĳ�����Ŀ
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE];
    BYTE                    byRes[32];         //����
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

// ������������
typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              // �ṹ���С
    BYTE           byEnable;            // �Ƿ�����
    BYTE           byEventType;			//�����¼����ͣ� 0-�쳣����; 1-������;2-�쳣����&������;
    BYTE           byUpLastAlarm;       //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE           byUpFacePic; //�Ƿ��ϴ�������ͼ��0-��1-��
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon;    // ��������������
    BYTE           byPicProType;	//����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE           bySensitivity;   // ����������
    WORD            wDuration;      // ������������ʱ����ֵ
    NET_DVR_JPEGPARA    struPictureParam; 		//ͼƬ���ṹ
    NET_VCA_SIZE_FILTER struSizeFilter;         //�ߴ������
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	  //���?ʽ
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];			//����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE           byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE            byRes2[39];         //�����ֽ�
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{
    BYTE byEnable; //�Ƿ������л�
    BYTE byBackChannel; //����ͨ���ţ����ͨ����
    BYTE byPosition; //����λ�ã�0-����,1-����,2-����,3-����
    BYTE byPIPDiv; //����ϵ��(��������:��廭��)��0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              // �ṹ���С
    BYTE  byEnable;            // �Ƿ�����
    BYTE  byEventType;			//�����¼����ͣ� 0-�쳣����; 1-������;2-�쳣����&������;
    BYTE  byUpLastAlarm;       //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE  byUpFacePic; //�Ƿ��ϴ�������ͼ��0-��1-��
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    // ��������������
    BYTE  byPicProType;	//����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE  bySensitivity;   // ����������
    WORD  wDuration;      // ������������ʱ����ֵ
    NET_DVR_JPEGPARA    struPictureParam; 		//ͼƬ���ṹ
    NET_VCA_SIZE_FILTER struSizeFilter;         //�ߴ������
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;	  //���?ʽ
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];			//����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE  byPicRecordEnable;  /*2012-10-22�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7���л�����
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE  byRes[22];         //�����ֽ�
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD   dwSize;         //�ṹ��С
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	dwAbsTime;		//���ʱ��
    BYTE    byRuleName[NAME_LEN];   //�������
    NET_VCA_TARGET_INFO  struTargetInfo;//����Ŀ����Ϣ
    NET_VCA_DEV_INFO  	 struDevInfo;//ǰ���豸��Ϣ
    DWORD   dwPicDataLen;	//����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ���*/
    BYTE    byAlarmPicType;	// 0-�쳣��������ͼƬ 1- ����ͼƬ,2-��������
    BYTE    byPanelChan;    /*2012-3-1����ͨ�����������ͨ��*/
    BYTE    byRelAlarmPicNum; //����ͨ������ͼƬ����
    BYTE    byRes1;
    DWORD   dwFacePicDataLen;//����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ���*/
    DWORD   dwAlarmID;    //����ID�����Ա�ʶͨ��������������ϱ�����0��ʾ��Ч
    BYTE    byRes2[44];   // �����ֽ�
    BYTE    *pFaceImage; //ָ������ͼָ��
    BYTE    *pImage;   						//ָ��ͼƬ��ָ��
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD   uLen[3];        	// �������СΪ12�ֽ�
    DWORD  dwHumanIn;  	//�����˽ӽ� 0 - ���� 1- ����
    float       fCrowdDensity;  // ��Ա�ۼ�ֵ
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

// Ŀǰֻ�����������¼�����Ա�ۼ��¼�ʵʱ�����ϴ�
typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;				// Rule ID
    BYTE   byRes[3];				// �����ֽ�
    BYTE   byRuleName[NAME_LEN];	// �������
    DWORD       dwEventType;    		// ����VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;  //
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE			byNum;		// �¼�ʵʱ��Ϣ����
    BYTE			byRes1[3];			// �����ֽ�
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];	// �¼�ʵʱ��Ϣ
}NET_DVR_EVENT_INFO_LIST,*LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD 			dwSize;				// �ṹ���С
    DWORD 		dwRelativeTime; 	// ���ʱ��
    DWORD		dwAbsTime;			// ���ʱ��
    NET_VCA_DEV_INFO  	struDevInfo;		// ǰ���豸��Ϣ
    NET_DVR_EVENT_INFO_LIST struEventInfoList;	//�¼���Ϣ�б�
    BYTE			byRes2[40];			// �����ֽ�
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

//��������ʱ���
typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 -��Ч,1�C��Ч
    BYTE     byRes1[3];                    //����
    DWORD    dwSceneID;                    //����ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //������Чʱ��
    BYTE     byRes2[16];                   //����
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME ;

//������Чʱ�������
typedef struct tagNET_DVR_SCENE_TIME_CFG
{
    DWORD  dwSize;                                               //�ṹ��С
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //����ʱ�������
    BYTE   byRes[64];                                            //����
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;


//��������������Ϣ
typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{
    BYTE   byEnable;                 //�Ƿ����øó���,0-������ 1- ����
    BYTE   byDirection;              //��ⷽ�� 1-���У�2-���У�3-˫��4-�ɶ�������5-�����򱱣�6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE   byRes1[2];                //����
    DWORD  dwSceneID;                //����ID(ֻ��), 0 - ��ʾ�ó�����Ч
    BYTE   bySceneName[NAME_LEN];    //�������
    NET_DVR_PTZPOS struPtzPos;       //ptz ���
    DWORD  dwTrackTime;              //������ʱ��[5,300] �룬TFS(��ͨȡ֤)ģʽ����Ч
    BYTE   byRes2[24];               //����
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;

//�������ýṹ��
typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //�ṹ��С
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //����������Ϣ
    BYTE   byRes[40];                                      //����
}NET_DVR_SCENE_CFG,*LPNET_DVR_SCENE_CFG;

//�ೡ����������
typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //�ṹ��С
    LONG    lChannel;     //ͨ����
    DWORD   dwSceneID;    //����ID, 0-��ʾ�ó�����Ч
    BYTE    byRes[48];    //����
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

//ȡ֤��ʽ
typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //�ṹ��С
    BYTE   byMode;      // 0-�ֶ�ȡ֤ ,1-�Զ�ȡ֤��2-���Զ����ٺ;�̬ȡ֤
    BYTE   byRes[23];   //����
}NET_DVR_FORENSICS_MODE,*LPNET_DVR_FORENSICS_MODE;

//����������Ϣ
typedef struct tagNET_DVR_SCENE_INFO_
{
    DWORD           dwSceneID;              //����ID, 0 - ��ʾ�ó�����Ч
    BYTE            bySceneName[NAME_LEN];  //�������
    BYTE            byDirection;            //��ⷽ�� 1-���У�2-���У�3-˫��4-�ɶ�������5-�����򱱣�6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE            byRes1[3];              //����
    NET_DVR_PTZPOS  struPtzPos;             //Ptz ���
    BYTE            byRes2[64] ;            //����
}NET_DVR_SCENE_INFO,*LPNET_DVR_SCENE_INFO;

//��ͨ�¼�����(��չ)
typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //�ṹ����
    DWORD              dwRelativeTime;	    //���ʱ��
    DWORD              dwAbsTime;			//���ʱ��
    NET_VCA_DEV_INFO   struDevInfo;		    //ǰ���豸��Ϣ
    NET_DVR_AID_INFO   struAIDInfo;         //��ͨ�¼���Ϣ
    NET_DVR_SCENE_INFO struSceneInfo;       //������Ϣ
    DWORD              dwPicDataLen;        //ͼƬ����
    BYTE               *pImage; 			//ָ��ͼƬ��ָ��
    // 0-���ֱ���ϴ�; 1-�ƴ洢������URL(3.7Ver)ԭ�ȵ�ͼƬ��ݱ��URL��ݣ�ͼƬ���ȱ��URL����
    BYTE               byDataType;
    BYTE               byLaneNo;  //����������
    WORD               wMilliSecond;        //ʱ�����
    //�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE  		 	   byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE  		 	   byDeviceID[DEVICE_ID_LEN/*48*/];//�豸���
    BYTE			   byRes[28]; // �����ֽ�
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

//��ͨͳ����Ϣ����(��չ)
typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwRelativeTime;  // ���ʱ��
    DWORD                 dwAbsTime;       // ���ʱ��
    NET_VCA_DEV_INFO      struDevInfo;     // ǰ���豸��Ϣ
    NET_DVR_TPS_INFO_V41  struTPSInfo;     // ��ͨ����ͳ����Ϣ
    //�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE  		 byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE  		 byDeviceID[DEVICE_ID_LEN/*48*/];//�豸���
    DWORD                dwStartTime;  // ��ʼͳ��ʱ��
    DWORD                dwStopTime;	// ����ͳ��ʱ��
    BYTE                   byRes[24];      // ����
} NET_DVR_TPS_ALARM_V41,*LPNET_DVR_TPS_ALARM_V41;

/*******************************���ܽ�ͨ�¼� end*****************************************/

#define XXX_MAJOR_VERSION      2

/* �Ӱ汾�ţ������Ż����ֲ��ṹ����ģ���ڼ������������汾����ʱ���������31 */

#define XXX_SUB_VERSION        3

/* ����汾�ţ�����bug����������31 */

#define XXX_REVISION_VERSION   4

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;		// ���汾��
    WORD    wMinorVersion;		// �ΰ汾��
    WORD    wRevisionNumber;	// �����
    WORD    wBuildNumber;		// �����
    WORD	wVersionYear;		//	�汾����-��
    BYTE	byVersionMonth;		//	�汾����-��
    BYTE	byVersionDay;		//	�汾����-��
    BYTE	byRes[8];			// �����ֽ�
}NET_DVR_VCA_VERSION, *LPNET_DVR_VCA_VERSION;


/******************************���� end***********************************/

/******************************����ʶ�� begin******************************************/
typedef struct tagNET_DVR_PLATE_PARAM
{
    BYTE    byPlateRecoMode;    //����ʶ���ģʽ,Ĭ��Ϊ1(��Ƶ����ģʽ)
    BYTE    byBelive;		    //�������Ŷ���ֵ, ֻ������Ƶʶ��ʽ, ��ݱ������ӳ̶�����, �󴥷��ʸ߾����, ©���ʸ߾����, ������80-90��Χ��
    BYTE    byRes[22];          //�����ֽ�
}NET_DVR_PALTE_PARAM, *LPNET_DVR_PALTE_PARAM;

typedef struct tagNET_DVR_PLATECFG
{
    DWORD		dwSize;
    DWORD    dwEnable;				           /* �Ƿ�������Ƶ����ʶ�� 0���� 1���� */
    BYTE    byPicProType;	//����ʱͼƬ���?ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];  // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam; 		//ͼƬ���ṹ
    NET_DVR_PALTE_PARAM struPlateParam;   // ����ʶ���������
    NET_DVR_HANDLEEXCEPTION struHandleType;	   /* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE    byRelRecordChan[MAX_CHANNUM];        //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE   byRes[20];   // �����ֽ�
}NET_DVR_PLATECFG, *LPNET_DVR_PLATECFG;

// ����ʶ�����ӽṹ
typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;					//��������
    BYTE  byColor;						//������ɫ
    BYTE  byBright;						//��������
    BYTE  byLicenseLen;					//�����ַ����
    BYTE  byEntireBelieve;				//������Ƶ����Ŷȣ�-100
    BYTE  byRegion;     // ��������ֵ 0-������1-ŷ��(EU)��2-��������(ER)��3-ŷ��&����˹(EU&CIS) ,0xff-����
    BYTE  byCountry;     // �������ֵ������ö��COUNTRY_INDEX����֧��"COUNTRY_ALL = 0xff, //ALL  ȫ��"��
    BYTE  byRes[33];					//����
    NET_VCA_RECT	struPlateRect;		//����λ��
    char sLicense[MAX_LICENSE_LEN];		//���ƺ���
    BYTE byBelieve[MAX_LICENSE_LEN];	//����ʶ���ַ�����Ŷȣ����⵽����"��A12345", ���Ŷ�Ϊ,20,30,40,50,60,70�����ʾ"��"����ȷ�Ŀ�����ֻ��%��"A"�ֵ���ȷ�Ŀ�������%
}NET_DVR_PLATE_INFO, *LPNET_DVR_PLATE_INFO;

typedef struct tagNET_DVR_PLATERECO_RESULE
{
    DWORD dwSize;
    DWORD    dwRelativeTime;				//���ʱ��
    DWORD    dwAbsTime;						//���ʱ��
    NET_VCA_DEV_INFO struDevInfo;           // ǰ���豸��Ϣ
    NET_DVR_PLATE_INFO struPlateInfo;
    DWORD dwPicDataLen;						//����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ���*/
    DWORD dwRes[4];							//����������Ϊ0
    BYTE  *pImage;   						//ָ��ͼƬ��ָ��
}NET_DVR_PLATERECO_RESULE, *LPNET_DVR_PLATERECO_RESULE;

/******************************����ʶ�� end******************************************/

/*******************************��Ƶ�ۺ�ƽ̨***********************************/
typedef struct
{
    NET_DVR_TIME strLogTime;
    DWORD	dwMajorType;	//Main type 1-alarm; 2-abnormal; 3-operation; 0xff-all
    DWORD	dwMinorType;	//Hypo-Type 0-all;
    BYTE	sPanelUser[MAX_NAMELEN]; //user ID for local panel operation
    BYTE	sNetUser[MAX_NAMELEN];//user ID for network operation
    NET_DVR_IPADDR	struRemoteHostAddr;//remote host IP
    DWORD	dwParaType;//parameter type
    DWORD	dwChannel;//channel number
    DWORD	dwDiskNumber;//HD number
    DWORD	dwAlarmInPort;//alarm input port
    DWORD	dwAlarmOutPort;//alarm output port
    DWORD   dwInfoLen;
    BYTE    byDevSequence;//��λ��
    BYTE    byMacAddr[MACADDR_LEN];//MAC��ַ,6
    BYTE    sSerialNumber[SERIALNO_LEN];//���кţ�48
    char    sInfo[LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1 ];
}NET_DVR_LOG_MATRIX, *LPNET_DVR_LOG_MATRIX;

//2009-11-21 ��Ƶ�ۺ�ƽ̨
typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition;//����������0-����λ��������1-�����к�������2-��MAC��ַ��������
    //��λ�ţ�0-79����Ӧ��ϵͳ�Ĳ�λ�ţ�
    //0xff����ʾ�������е���־������78K������6467��
    //0xfe����ʾ����78K�ϵ���־��0xfd��������־��0xfc������־����
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN];//���кţ�48
    BYTE  byMacAddr[MACADDR_LEN];//MAC��ַ,6
} NET_DVR_VEDIOPLATLOG, *LPNET_DVR_VEDIOPLATLOG;

typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion;//�������汾�ţ���16λ��ʾ���汾����16λ��ʾ�ΰ汾
    DWORD dwSupportMaxVideoFrameRate;//��λ(K)
                                     /*��λ:
                                     0:��ʱ¼��
                                     1:��ʱ|�¼�����¼��
                                     2:�ƶ����¼��
                                     3:���翪��������¼��
                                     4:�ƶ����|���翪��������¼��
                                     5:�ƶ����&���翪��������¼��
                                     6:�ܽ��������¼��
                                     7:������ⴥ��¼��
                                     8:����ʶ�𴥷�¼��
    9:�ֶ�¼��*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode;//��λ:��0λ:��ʾ����������1λ:��ʾ������
    BYTE  bySupportStringRow;//֧���ַ��������
    BYTE  bySupportHideNum;//֧����Ƶ�ڵ�����
    BYTE  byRes1;
    /*0-DCIF��1-CIF��2-QCIF��3-4CIF��4-2CIF��6-QVGA(320*240), 16-VGA��17-UXGA��18-SVGA��19-HD720p��20-XVGA��21-HD900p��22-SXGAp��27-HD1080i��28-2560*1920��29-1600*304��30-2048*1536��31-2448*2048��32-2448*1200��33-2448*800 ��34-XGA��1024x768����35-SXGA��1280x1024��*/
    BYTE  byMainStreamSupportResolution[8];//������֧�ֵķֱ��ʣ���λ
    BYTE  bySubStreamSupportResolution[8];//������֧�ֵķֱ��ʣ���λ
    BYTE  byEventStreamSupportResolution[8];//�¼���������֧�ֵķֱ��ʣ���λ
    BYTE  byNotSupportPreview;//�Ƿ�֧��Ԥ��,1-��֧�֣�0-֧��
    BYTE  byNotSupportStorage;//�Ƿ�֧�ִ洢,1-��֧�֣�0-֧��
    BYTE  byRes2[98];//����
}NET_DVR_CODESYSTEMABILITY, *LPNET_DVR_CODESYSTEMABILITY;

/********************************end*******************************************/

/******************************ץ�Ļ�*******************************************/
//IO��������
typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus;//�����IO��״̬��0-�½��أ�1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE	byRes[3];//�����ֽ�
}NET_DVR_IO_INCFG, *LPNET_DVR_IO_INCFG;

//IO�������
typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus;//IOĬ��״̬��0-�͵�ƽ��1-�ߵ�ƽ
    BYTE    byIoOutStatus;//IO��Чʱ״̬��0-�͵�ƽ��1-�ߵ�ƽ��2-����
    WORD    wAheadTime;//���IO��ǰʱ�䣬��λus
    DWORD   dwTimePluse;//������ʱ�䣬��λus
    DWORD   dwTimeDelay;//IO��Ч����ʱ�䣬��λus
    BYTE    byFreqMulti;		//��Ƶ����ֵ��Χ[1,15]
    BYTE    byDutyRate;		//ռ�ձȣ�[0,40%]
    BYTE    byRes[2];
}NET_DVR_IO_OUTCFG, *LPNET_DVR_IO_OUTCFG;

//���������
typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;//�������˸ģʽ��0-������1-����2-��������3-����
    BYTE   byRelatedIoIn;//����ƹ���������IO�ţ�������ʱ�˲�����Ч��
    BYTE   byRecognizedLane;  /*������IO�ţ���λ��ʾ��bit0��ʾIO1�Ƿ������0-��������1-����*/
    BYTE   byDetectBrightness;/*�Զ��������ʹ�������0-����⣻1-���*/
    BYTE   byBrightnessThreld;/*ʹ�������������ֵ����Χ[0,100],������ֵ��*/
    BYTE   byStartHour;		//��ʼʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE   byStartMinute;		//��ʼʱ��-��,ȡֵ��Χ0-59
    BYTE   byEndHour;		 	//����ʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE   byEndMinute;		//����ʱ��-��,ȡֵ��Χ0-59
    BYTE   byFlashLightEnable;	//���������ʱ��ʹ��:0-��;1-��
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

//���̵ƹ��ܣ�2��IO����һ�飩
typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE	byLightIoIn;//���̵Ƶ�IO ��
    BYTE	byTrigIoIn;//������IO��
    BYTE	byRelatedDriveWay;//����IO�����ĳ�����
    BYTE	byTrafficLight; //0-�ߵ�ƽ��ƣ��͵�ƽ�̵ƣ�1-�ߵ�ƽ�̵ƣ��͵�ƽ���
    BYTE 	bySnapTimes1; //���ץ�Ĵ���1��0-��ץ�ģ���0-���Ĵ������5��
    BYTE 	bySnapTimes2; //�̵�ץ�Ĵ���2��0-��ץ�ģ���0-���Ĵ������5��
    BYTE	byRes1[2];
    WORD	wIntervalTime1[MAX_INTERVAL_NUM];//������ļ��ʱ�䣬ms
    WORD	wIntervalTime2[MAX_INTERVAL_NUM];//�̵����ļ��ʱ�䣬ms
    BYTE	byRecord;//���������¼���־��0-��¼��1-¼��
    BYTE	bySessionTimeout;//���������¼��ʱʱ�䣨�룩
    BYTE	byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ��(��)
    BYTE	byVideoDelay;//�����¼��Ƭ����ʱʱ�䣨�룩
    BYTE	byRes2[32];//�����ֽ�
}NET_DVR_LIGHTSNAPCFG, *LPNET_DVR_LIGHTSNAPCFG;

//���ٹ���(2��IO����һ�飩
typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE	byTrigIo1;   //���ٵ�1��Ȧ
    BYTE	byTrigIo2;   //���ٵ�2��Ȧ
    BYTE	byRelatedDriveWay;//����IO�����ĳ�����
    BYTE	byTestSpeedTimeOut;//����ģʽ��ʱʱ�䣬��λs
    DWORD   dwDistance;//��Ȧ����,cm
    BYTE	byCapSpeed;//����ģʽ�����ٶȣ���λkm/h
    BYTE	bySpeedLimit;//����ֵ����λkm/h
    BYTE 	bySnapTimes1; //��Ȧ1ץ�Ĵ���0-��ץ�ģ���0-���Ĵ������5��
    BYTE 	bySnapTimes2; //��Ȧ2ץ�Ĵ���0-��ץ�ģ���0-���Ĵ������5��
    WORD	wIntervalTime1[MAX_INTERVAL_NUM];//��Ȧ1���ļ��ʱ�䣬ms
    WORD	wIntervalTime2[MAX_INTERVAL_NUM];//��Ȧ2���ļ��ʱ�䣬ms
    BYTE	byRes[32];//�����ֽ�
}NET_DVR_MEASURESPEEDCFG, *LPNET_DVR_MEASURESPEEDCFG;


//��������
typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND,*LPNET_DVR_CLOUDSTORAGE_COND;

//���ýṹ
typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// �ƴ洢����ڵ��
    BYTE    byRes[4];
}NET_DVR_POOLPARAM,*LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD  dwSize;
    BYTE    byEnable;//0-��������1-����
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort;
    BYTE    byRes1[2];
    char  szUser[CLOUD_NAME_LEN/*48*/]; //�û���
    char  szPassword[CLOUD_PASSWD_LEN/*48*/]; 	// ����
    NET_DVR_POOLPARAM  struPoolInfo[16];//����0��ʾ����¼��أ�����1��ʾΥ��¼��أ�����2��ʾ���������ݳأ�IPC/D��
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG,*LPNET_DVR_CLOUDSTORAGE_CFG;

typedef  struct  tagNET_DVR_PARKLAMP_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;   //ͨ����
    BYTE   byParkingIndex;   //��Գ�λ�ţ�1��4��
    BYTE   byRes[15]; 	//����
}NET_DVR_PARKLAMP_COND, *LPNET_DVR_PARKLAMP_COND;

typedef  struct  tagNET_DVR_PARKLAMP_INFOCFG
{
    DWORD dwSize;
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    char  sParkingNo[MAX_LICENSE_LEN/*16*/];//��λ���(ʵ�ʵĳ�λ���)
    BYTE   byLampFlicker;//0~����˸ 1 ����˸ (��λָʾ����˸)
    BYTE   byLampColor;//0- �� 1-�� 2-��  3-��  4-�� 5-Ʒ�� 6-�� 7-��ɫ  (��λָʾ����ɫ)
    BYTE   byStatus; //��λ״̬ 0-�޳���1-�г�
    BYTE   byColorDepth; //������ɫ��ǳ��0-��ɫ��1-ǳɫ
    BYTE   byColor;//������ɫ��0-����ɫ��1-��ɫ��2-��ɫ��3-��ɫ��4-��ɫ��5-��ɫ��6-������7-��ɫ��8-��ɫ��9-��ɫ��10-��ɫ��11-��ɫ��12-��ɫ��0xff-δ���г�����ɫʶ��
    //����Ʒ������ʶ�� �ο�ö������ VLR_VEHICLE_CLASS
    BYTE   byVehicleLogoRecog;
    BYTE   byRes[250];//����
}NET_DVR_PARKLAMP_INFOCFG, *LPNET_DVR_PARKLAMP_INFOCFG;

//��Ƶ��������
typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel; /*0-100*/
    BYTE byContrastLevel; /*0-100*/
    BYTE bySharpnessLevel; /*0-100*/
    BYTE bySaturationLevel; /*0-100*/
    BYTE byHueLevel; /*0-100,��������*/
    BYTE byEnableFunc; //ʹ�ܣ���λ��ʾ��bit0-SMART IR(������)��bit1-���ն�,bit2-ǿ������ʹ�ܣ�0-��1-��
    BYTE byLightInhibitLevel; //ǿ�����Ƶȼ���[1-3]��ʾ�ȼ�
    BYTE byGrayLevel; //�Ҷ�ֵ��0-[0-255]��1-[16-235]
}NET_DVR_VIDEOEFFECT, *LPNET_DVR_VIDEOEFFECT;

//��������
typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel; /*���棺0-100*/
    BYTE byGainUserSet; /*�û��Զ������棻0-100������ץ�Ļ���CCDģʽ�µ�ץ������*/
    BYTE byRes[2];
    DWORD dwMaxGainValue;/*�������ֵ����λdB*/
}NET_DVR_GAIN, *LPNET_DVR_GAIN;

//��ƽ������
typedef struct tagNET_DVR_WHITEBALANCE
{
BYTE byWhiteBalanceMode; /*0-�ֶ���ƽ�⣨MWB��,1-�Զ���ƽ��1��AWB1��,2-�Զ���ƽ��2 (AWB2),3-�Զ����Ƹ���Ϊ���ƽ��(Locked WB)��
                         4-����(Indoor)��5-����(Outdoor)6-�չ��(Fluorescent Lamp)��7-�Ƶ�(Sodium Lamp)��
                         8-�Զ�����(Auto-Track)9-һ�ΰ�ƽ��(One Push)��10-�����Զ�(Auto-Outdoor)��
                         11-�Ƶ��Զ� (Auto-Sodiumlight)��12-ˮ���(Mercury Lamp)��13-�Զ���ƽ��(Auto)��
14-�׳�� (IncandescentLamp)��15-ů���(Warm Light Lamp)��16-��Ȼ��(Natural Light) */
BYTE byWhiteBalanceModeRGain; /*�ֶ���ƽ��ʱ��Ч���ֶ���ƽ�� R����*/
BYTE byWhiteBalanceModeBGain; /*�ֶ���ƽ��ʱ��Ч���ֶ���ƽ�� B����*/
BYTE byRes[5];
}NET_DVR_WHITEBALANCE, *LPNET_DVR_WHITEBALANCE;

//�ع����
typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode; /*0 �ֶ��ع� 1�Զ��ع�*/
    BYTE  byAutoApertureLevel; /* �Զ���Ȧ������, 0-10 */
    BYTE  byRes[2];
    DWORD dwVideoExposureSet; /* �Զ�����Ƶ�ع�ʱ�䣨��λus��*//*ע:�Զ��ع�ʱ��ֵΪ�ع�����ֵ ����20-1s(1000000us)*/
    DWORD dwExposureUserSet; /* �Զ����ع�ʱ��,��ץ�Ļ���Ӧ��ʱ��CCDģʽʱ��ץ�Ŀ����ٶ�*/
    DWORD dwRes;
} NET_DVR_EXPOSURE, *LPNET_DVR_EXPOSURE;

//�?̬����
typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled; /*�?̬��0 dsibale  1 enable 2 auto*/
    BYTE byWDRLevel1; /*0-F*/
    BYTE byWDRLevel2; /*0-F*/
    BYTE byWDRContrastLevel; /*0-100*/
    BYTE byRes[16];
} NET_DVR_WDR, *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;   //�ṹ���С
    NET_DVR_WDR  struWDR; //������Ϣ
}NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;


//��ҹת����������
typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType; /*��ҹ�л���0-���죬1-ҹ�?2-�Զ���3-��ʱ��4-�������봥��*/
    BYTE bySwitchScheduleEnabled; /*0 dsibale  1 enable,(����)*/
    //��ʱģʽ����
    BYTE byBeginTime; /*��ʼʱ�䣨Сʱ����0-23*/
    BYTE byEndTime; /*����ʱ�䣨Сʱ����0-23*/
    //ģʽ2
    BYTE byDayToNightFilterLevel; //0-7
    BYTE byNightToDayFilterLevel; //0-7
    BYTE byDayNightFilterTime;//(60��)
    //��ʱģʽ����
    BYTE byBeginTimeMin; //��ʼʱ�䣨�֣���0-59
    BYTE byBeginTimeSec; //��ʼʱ�䣨�룩��0-59
    BYTE byEndTimeMin; //����ʱ�䣨�֣���0-59
    BYTE byEndTimeSec; //����ʱ�䣨�룩��0-59
    //�������봥��ģʽ����
    BYTE byAlarmTrigState; //�������봥��״̬��0-���죬1-ҹ��
} NET_DVR_DAYNIGHT, *LPNET_DVR_DAYNIGHT;

//GammaУ��
typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled; /*0 dsibale  1 enable*/
    BYTE byGammaCorrectionLevel; /*0-100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT, *LPNET_DVR_GAMMACORRECT;

//���ⲹ������
typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode; /*���ⲹ��:0 off 1 UP��2 DOWN��3 LEFT��4 RIGHT��5MIDDLE��6�Զ��壬10-����11-�Զ���12-�����򱳹ⲹ��*/
    BYTE byBacklightLevel; /*0x0-0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1; //��X���1��
    DWORD dwPositionY1; //��Y���1��
    DWORD dwPositionX2; //��X���2��
    DWORD dwPositionY2; //��Y���2��
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT, *LPNET_DVR_BACKLIGHT;

//���ֽ��빦��
typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable; /*0-�����ã�1-��ͨģʽ���ֽ��룬2-ר��ģʽ���ֽ���*/
    BYTE byDigitalNoiseRemoveLevel; /*��ͨģʽ���ֽ��뼶��0x0-0xF*/
    BYTE bySpectralLevel;       /*ר��ģʽ�¿���ǿ�ȣ�0-100*/
    BYTE byTemporalLevel;   /*ר��ģʽ��ʱ��ǿ�ȣ�0-100*/
    BYTE byDigitalNoiseRemove2DEnable;         /* ץ��֡2D���룬0-�����ã�1-���� */
    BYTE byDigitalNoiseRemove2DLevel;            /* ץ��֡2D���뼶��0-100 */
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE, *LPNET_DVR_NOISEREMOVE;

//CMOSģʽ��ǰ�˾�ͷ����
typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;   //ץ��ģʽ��0-ץ��ģʽ1��1-ץ��ģʽ2
    BYTE byBrightnessGate;//������ֵ
    BYTE byCaptureGain1;   //ץ������1,0-100
    BYTE byCaptureGain2;   //ץ������2,0-100
    DWORD dwCaptureShutterSpeed1;//ץ�Ŀ����ٶ�1
    DWORD dwCaptureShutterSpeed2;//ץ�Ŀ����ٶ�2
    BYTE  byRes[4];
}NET_DVR_CMOSMODECFG, *LPNET_DVR_CMOSMODECFG;

//ǰ�˲�������
typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*���ȡ��Աȶȡ����Ͷȡ���ȡ�ɫ������*/
    NET_DVR_GAIN struGain;/*�Զ�����*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*��ƽ��*/
    NET_DVR_EXPOSURE struExposure; /*�ع����*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*GammaУ��*/
    NET_DVR_WDR struWdr;/*�?̬*/
    NET_DVR_DAYNIGHT struDayNight;/*��ҹת��*/
    NET_DVR_BACKLIGHT struBackLight;/*���ⲹ��*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*���ֽ���*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
        0-�Զ���Ȧ,
        1-�ֶ���Ȧ,
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-HIK 3.8-16mm F1.5��HV3816P-8MPIR)
        6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        7-HIK 2.7-12mm F1.2��TV2712P-MPIR��
    */
    BYTE byIrisMode;
    BYTE byMirror ;  /* ����0 off��1- leftright��2- updown��3-center */
    BYTE byDigitalZoom;  /*��������:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*������,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*�ڵ�ƽ���� ,  0-255*/
    BYTE byEptzGate;// EPTZ���ر���:0-�����õ�����̨��1-���õ�����̨
    BYTE byLocalOutputGate;//����������ر���0-��������ر�1-����BNC����� 2-HDMI����ر�
    //20-HDMI_720P50�����
    //21-HDMI_720P60�����
    //22-HDMI_1080I60�����
    //23-HDMI_1080I50�����
    //24-HDMI_1080P24�����
    //25-HDMI_1080P25�����
    //26-HDMI_1080P30�����
    //27-HDMI_1080P50�����
    //28-HDMI_1080P60�����
    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60
    BYTE byCoderOutputMode;//������fpga���ģʽ0ֱͨ3���ذ��
    BYTE byLineCoding; //�Ƿ����б��룺0-��1-��
    BYTE byDimmerMode; //����ģʽ��0-���Զ���1-�Զ�
    BYTE byPaletteMode; //��ɫ�壺0-���ȣ�1-���ȣ�2-��ɫ��2������8-��ɫ��8
    BYTE byEnhancedMode; //��ǿ��ʽ��̽�������ܱߣ���0-����ǿ��1-1��2-2��3-3��4-4
    BYTE byDynamicContrastEN;    //��̬�Աȶ���ǿ 0-1
    BYTE byDynamicContrast;    //��̬�Աȶ� 0-100
    BYTE byJPEGQuality;    //JPEGͼ������ 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOSģʽ��ǰ�˲������ã���ͷģʽ����������ȡ
    BYTE byFilterSwitch; //�˲����أ�0-�����ã�1-����
    BYTE byFocusSpeed; //��ͷ�����ٶȣ�0-10
    BYTE byAutoCompensationInterval; //��ʱ�Զ����Ų�����1-120����λ������
    BYTE bySceneMode;  //����ģʽ��0-���⣬1-���ڣ�2-Ĭ�ϣ�3-����
}NET_DVR_CAMERAPARAMCFG, *LPNET_DVR_CAMERAPARAMCFG;

//͸��
typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //ģʽ��0-�����ã�1-�Զ�ģʽ��2-����ģʽ
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6];
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

//���ӷ���
typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;//ʹ�� 0- �����ã�1- ����
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6];
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

//����ģʽ
typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; //�Ƿ���������ģʽ 0�������ã� 1������
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

// SMART IR(������)���ò���
typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0���ֶ���1���Զ�
    BYTE  byIRDistance;//�������ȼ�(�ȼ������������)level:1~100 Ĭ��:50���ֶ�ģʽ�����ӣ�
    BYTE  byShortIRDistance;// ���ƾ���ȼ�(1~100)
    BYTE  byLongIRDistance;// Զ��ƾ���ȼ�(1~100)
}NET_DVR_SMARTIR_PARAM,*LPNET_DVR_SMARTIR_PARAM;

//��byIrisMode ΪP-Iris1ʱ��Ч�����ú����Ȧ��С�ȼ�������ģʽ
typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0-�Զ���1-�ֶ�
    BYTE  byPIrisAperture;//�����Ȧ��С�ȼ�(�ȼ�,��Ȧ��С�����)level:1~100 Ĭ��:50���ֶ�ģʽ�����ӣ�
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM,*LPNET_DVR_PIRIS_PARAM;


//����������� 2014-02-25
typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE	byControlMode;		//����ģʽ			0-��Ч��1-�Զ���2-�ֶ� Ĭ���Զ�
    BYTE	bySensitivity;		//�����������		0-100 Ĭ��50
    BYTE	byTriggerMode;		//����ƴ���ģʽ	0-��Ч��1-��о������2-�������� Ĭ�ϻ�о����
    BYTE	byBrightness;		//����ģʽΪ�ֶ�ģʽ����Ч�����������		0-255 Ĭ��100
    BYTE	byAngle;			//����ƽǶ�		0-��Ч����Χ1-36  Ĭ��12����������䷶ΧΪһ��ԲȦ�����ڼ���Ƕ��ǵ������Բ�İ뾶�Ĵ�С
    BYTE    byLimitBrightness;  //����ģʽΪ�Զ�ģʽ����Ч��������������� 0~100 ��������2014-01-26
    BYTE    byEnabled ;         //�ֶ����Ƽ����ʹ�� 0-�رգ�1-����
	BYTE    byIllumination;     //�����ǿ������0~100
	BYTE    byLightAngle;       //����Ƕ� 0~100
	BYTE	byRes[7];           //����
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off
    BYTE   byMode;
    //��ʱ��:��������ʾ����λ���ӣ�ѡ����10,20,30,40,50,60,120,180,240��
    BYTE   byRes1;
    WORD   wCompensateTime; //��ʱģʽ����Ч
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM,*LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM   //��sensor�����
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//��ͨģʽ�ȼ���Χ[1,100]����ͨģʽ����Ч
    BYTE  byExpertLevel;//ר��ģʽ�ȼ���Χ[1,100]��ר��ģʽ����Ч
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM,*LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//���ȵȼ�[1,100]���ֶ�ģʽ����Ч
    BYTE  byGainLevel; //����ȼ�[1,100]���ֶ�ģʽ����Ч
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM,*LPNET_DVR_AGC_PARAM;

//ץ�Ļ�CCD���� ��64�ֽ�
typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG
{
    BYTE byWDRMode;   // �?̬ģʽ;0~�رգ�1~���ֿ?̬ 2~�?̬
    BYTE byWDRType;    // �?̬�л�ģʽ; 0~ǿ�����ã�1~��ʱ�����ã�2~����������
    BYTE byWDRLevel;   // �?̬�ȼ���0~6�����Ӧ1-7��Ĭ������2����3������
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //��ʼ�?̬ʱ��
    NET_DVR_TIME_EX struEndTime; //����?̬ʱ��
    BYTE byDayNightBrightness; //��ҹת��������ֵ��0-100��Ĭ��50��
    BYTE byRes[43];
} NET_DVR_SNAP_CAMERAPARAMCFG,*LPNET_DVR_SNAP_CAMERAPARAMCFG;

//��ѧ͸�����
typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~�����ù�ѧ͸�?1~���ù�ѧ͸��
    BYTE byRes[7];
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

//ǰ�˲�������
typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*���ȡ��Աȶȡ����Ͷȡ���ȡ�ɫ������*/
    NET_DVR_GAIN struGain;/*�Զ�����*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*��ƽ��*/
    NET_DVR_EXPOSURE struExposure; /*�ع����*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*GammaУ��*/
    NET_DVR_WDR struWdr;/*�?̬*/
    NET_DVR_DAYNIGHT struDayNight;/*��ҹת��*/
    NET_DVR_BACKLIGHT struBackLight;/*���ⲹ��*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*���ֽ���*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    BYTE byIrisMode; /*0-�Զ���Ȧ 1-�ֶ���Ȧ, 2-P-Iris1, 3-Union 3-9mm F1.6-2.7 (T5280-PQ1), 4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1),5-HIK 3.8-16mm F1.5��HV3816P-8MPIR��*/
    BYTE byMirror ;  /* ����0 off��1- leftright��2- updown��3-center 4-Auto*/
    BYTE byDigitalZoom;  /*��������:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*������,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*�ڵ�ƽ���� ,  0-255*/
    BYTE byEptzGate;// EPTZ���ر���:0-�����õ�����̨��1-���õ�����̨
    BYTE byLocalOutputGate;//����������ر���0-��������ر�1-����BNC����� 2-HDMI����ر�
    //20-HDMI_720P50�����
    //21-HDMI_720P60�����
    //22-HDMI_1080I60�����
    //23-HDMI_1080I50�����
    //24-HDMI_1080P24�����
    //25-HDMI_1080P25�����
    //26-HDMI_1080P30�����
    //27-HDMI_1080P50�����
    //28-HDMI_1080P60�����
    BYTE byCoderOutputMode;//������fpga���ģʽ0ֱͨ3���ذ��
    BYTE byLineCoding; //�Ƿ����б��룺0-��1-��
    BYTE byDimmerMode; //����ģʽ��0-���Զ���1-�Զ�
    BYTE byPaletteMode; //��ɫ�壺0-���ȣ�1-���ȣ�2-��ɫ��2������8-��ɫ��8, 9-�ں�1,10-�ʺ�,11-�ں�2,12-���1,13-���2,14-���ɫ,15-ɫ��1,16-ɫ��2,17-���,18-��,19-����,20-����
    BYTE byEnhancedMode; //��ǿ��ʽ��̽�������ܱߣ���0-����ǿ��1-1��2-2��3-3��4-4
    BYTE byDynamicContrastEN;    //��̬�Աȶ���ǿ 0-1
    BYTE byDynamicContrast;    //��̬�Աȶ� 0-100
    BYTE byJPEGQuality;    //JPEGͼ������ 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOSģʽ��ǰ�˲������ã���ͷģʽ����������ȡ
    BYTE byFilterSwitch; //�˲����أ�0-�����ã�1-����
    BYTE byFocusSpeed; //��ͷ�����ٶȣ�0-10
    BYTE byAutoCompensationInterval; //��ʱ�Զ����Ų�����1-120����λ������
    BYTE bySceneMode;  //����ģʽ��0-���⣬1-���ڣ�2-Ĭ�ϣ�3-����
    NET_DVR_DEFOGCFG struDefogCfg;//͸�����
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//���ӷ���
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//����ģʽ
    BYTE   byExposureSegmentEnable; //0~������,1~����  �ع�ʱ�������ʽ���״��������ع����ϵ���ʱ��������ع�ʱ�䵽�м�ֵ��Ȼ��������浽�м�ֵ��������ع⵽���ֵ�����������浽���ֵ
    BYTE   byBrightCompensate;//������ǿ [0~100]
    /*
    0-�رա�1-640*480@25fps��2-640*480@30ps��3-704*576@25fps��4-704*480@30fps��5-1280*720@25fps��6-1280*720@30fps��
    7-1280*720@50fps��8-1280*720@60fps��9-1280*960@15fps��10-1280*960@25fps��11-1280*960@30fps��
    12-1280*1024@25fps��13--1280*1024@30fps��14-1600*900@15fps��15-1600*1200@15fps��16-1920*1080@15fps��
    17-1920*1080@25fps��18-1920*1080@30fps��19-1920*1080@50fps��20-1920*1080@60fps��21-2048*1536@15fps��22-2048*1536@20fps��
    23-2048*1536@24fps��24-2048*1536@25fps��25-2048*1536@30fps��26-2560*2048@25fps��27-2560*2048@30fps��
    28-2560*1920@7.5fps��29-3072*2048@25fps��30-3072*2048@30fps��31-2048*1536@12.5��32-2560*1920@6.25��
    33-1600*1200@25��34-1600*1200@30��35-1600*1200@12.5��36-1600*900@12.5��37-1280*960@12.5fps��38-800*600@25fps��39-800*600@30fps40��
    4000*3000@12.5fps��41-4000*3000@15fps��42-4096*2160@20fps��43-3840x2160@20fps ��44-960*576@25fps��45-960*480@30fps��46-752*582@25fps��
    47-768*494@30fps��48-2560*1440@25fps��49-2560*1440@30fps ��50-720P@100fps��51-720P@120fps��52-2048*1536@50fps��53-2048*1536@60fps��
    54-3840*2160@25fps��55-3840*2160@30fps��56-4096*2160@25fps��57-4096*2160@30fps ��58-1280*1024@50fps��59-1280*1024@60fps��
    60-3072*2048@50fps��61-3072*2048@60fps��62-3072*1728@25fps��63-3072*1728@30fps��64-3072*1728@50fps��65-3072*1728@60fps��66-336*256@50fps��67-336*256@60fps��
    68-384*288@50fps��69-384*288@60fps ��70- 640 * 512@50fps ��71- 640 * 512@60fps��72-2592*1944@25fps��73-2592*1944@30fps��74-2688*1536@25fps��75-2688*1536@30fps
    76-2592*1944@20fps��77-2592*1944@15fps��78-2688*1520@20fps��79-2688*1520@15fps��80-2688*1520@25fps��81-2688*1520@30fps��82- 2720*2048@25fps�� 83- 2720*2048@30fps��
    84-336*256@25fps��85- 384*288@25fps��86-640*512@25fps��87-1280*960@50fps��88-1280*960@60fps��89-1280*960@100fps��90-1280*960@120fps��91-4000*3000@20fps��
    92-1920*1200@25fps��93-1920*1200@30fps��94-2560*1920@25fps��95-2560*1920@20fps��96-2560*1920@30fps��97-1280*1920@25fps��98-1280*1920@30fps
    99-4000*3000@24fps��100-4000*3000@25fps��101-4000*3000@10fps��102- 384*288@30fps��103-2560*1920@15fps��104-2400*3840@25fps��105-1200*1920@25fps
    106-4096*1800@30fps��107-3840*1680@30fps��108-2560*1120@30fps��109-704*320@30fps��110-1280*560@30fps��111-4096*1800@25fps��112-3840*1680@25fps
    113-2560*1120@25fps��114-704*320@25fps��115-1280*560@25fps��116-2400*3840@24fps��117-3840*2400@24fps��118-3840*2400@25fps��119-2560*1920@12.5fps
    120-2560*2048@12fps��121-2560*2048@15fps��122-2560*1536@25fps��123-2560*1536@30fps��124-2256*2048@25fps��125-2256*2048@30fps��126-2592*2592@12.5fps��127-2592*2592@15fps
    */
    BYTE   byCaptureModeN; //��Ƶ����ģʽ��N�ƣ�
    BYTE   byCaptureModeP; //��Ƶ����ģʽ��P�ƣ�
    NET_DVR_SMARTIR_PARAM struSmartIRParam; //����Ź�������Ϣ
    NET_DVR_PIRIS_PARAM struPIrisParam;//PIris������Ϣ��ӦbyIrisMode�ֶδ�2-PIris1��ʼ��Ч
    //2014-02-25 ��������
    NET_DVR_LASER_PARAM_CFG struLaserParam;	//�������
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//��ͷ���У�� 0-�ر�,1-����
    BYTE   byRes1[3];
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD ; //ץ�Ļ�CCD����ֻ����ץ�Ļ�
	NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//��ѧ͸�����
    BYTE   byRes2[180];
}NET_DVR_CAMERAPARAMCFG_EX, *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD   dwSize;
    BYTE	byState;//�۽���λ״̬���� 0-����λ��1-��λ
    BYTE	byRes[31];
}NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;

typedef enum _VCA_PLATE_COLOR_
{
    VCA_BLUE_PLATE  = 0,   //��ɫ����
        VCA_YELLOW_PLATE,      //��ɫ����
        VCA_WHITE_PLATE,       //��ɫ����
        VCA_BLACK_PLATE,       //��ɫ����
        VCA_GREEN_PLATE,       //��ɫ����
        VCA_BKAIR_PLATE,       //�񺽺�ɫ����
        VCA_OTHER = 0xff       //����
}VCA_PLATE_COLOR;

//��������
typedef enum _VCA_PLATE_TYPE_
{
    VCA_STANDARD92_PLATE = 0,	//��׼���ó����
        VCA_STANDARD02_PLATE,		//02ʽ���ó���
        VCA_WJPOLICE_PLATE,		    //�侯��
        VCA_JINGCHE_PLATE,			//����
        STANDARD92_BACK_PLATE, 	    //���ó�˫��β��
        VCA_SHIGUAN_PLATE,          //ʹ�ݳ���
        VCA_NONGYONG_PLATE,         //ũ�ó�
        VCA_MOTO_PLATE              //Ħ�г�
}VCA_PLATE_TYPE;

//����ʶ����
typedef enum _VTR_RESULT
{
    VTR_RESULT_OTHER      =  0,  //δ֪
    VTR_RESULT_BUS        =  1,  //�ͳ�
    VTR_RESULT_TRUCK      =  2,  //����
    VTR_RESULT_CAR        =  3,  //�γ�
    VTR_RESULT_MINIBUS    =  4,  //���
    VTR_RESULT_SMALLTRUCK =  5,  //С����
    VTR_RESULT_HUMAN      =  6,  //����
    VTR_RESULT_TUMBREL    =  7,  //���ֳ�
    VTR_RESULT_TRIKE      =  8,  //���ֳ�
    VTR_RESULT_SUV_MPV    =  9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS =  10,  //���Ϳͳ�
    VTR_RESULT_MOTOR_VEHICLE = 11, //��
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //�ǻ�
	VTR_RESULT_SMALLCAR   = 13,   //С�ͽγ�
	VTR_RESULT_MICROCAR   = 14,   //΢�ͽγ�
	VTR_RESULT_PICKUP     = 15    //Ƥ����
}VTR_RESULT;


//������ɫ
typedef enum _VCR_CLR_CLASS
{
    VCR_CLR_UNSUPPORT  = 0,	  //��֧��
        VCR_CLR_WHITE	   = 1,   //��
        VCR_CLR_SILVER 	   = 2,   //��
        VCR_CLR_GRAY       = 3,	  //��
        VCR_CLR_BLACK      = 4,	  //��
        VCR_CLR_RED	       = 5,	  //��
        VCR_CLR_DARKBLUE   = 6,	  //����
        VCR_CLR_BLUE       = 7,	  //��
        VCR_CLR_YELLOW     = 8,	  //��
        VCR_CLR_GREEN      = 9,	  //��
        VCR_CLR_BROWN      = 10,  //��
        VCR_CLR_PINK       = 11,  //��
        VCR_CLR_PURPLE     = 12,  //��
        VCR_CLR_DARKGRAY   = 13,  //���
        VCR_CLR_CYAN	   = 14  //��ɫ
}VCR_CLR_CLASS;

//������������ 2013-11-04
typedef enum _VCA_OPERATE_TYPE_
{
    VCA_LICENSE_TYPE       = 0x1,  //���ƺ���
        VCA_PLATECOLOR_TYPE    = 0x2,  //������ɫ
        VCA_CARDNO_TYPE        = 0x4,  //����
        VCA_PLATETYPE_TYPE     = 0x8,  //��������
        VCA_LISTTYPE_TYPE      = 0x10, //����������
        VCA_INDEX_TYPE         = 0x20, //�����ˮ�� 2014-02-25
        VCA_OPERATE_INDEX_TYPE = 0x40  //������ 2014-03-03
}VCA_OPERATE_TYPE;

typedef enum _VCA_ILLEGAL_TYPE_
{
    VCA_POSTPIC_TYPE          = 0x1, //����ͼƬ
        VCA_LOWSPEED_TYPE         = 0x2,  //����
        VCA_HIGHSPEED_TYPE        = 0x4,  //����
        VCA_RETROGRADE_TYPE       = 0x8,  //����
        VCA_RUSH_REDLIGHT_TYPE    = 0x10,   //�����
        VCA_PRESS_LANE_TYPE       = 0x20, //ѹ������
        VCA_VIOLATE_GUIDE_TYPE    = 0x40,//��������
        VCA_ROAD_STRAND_TYPE      = 0x80,//·������(�豸��֧��)
        VCA_VEHICLE_ILLEGAL_LANE_TYPE  = 0x100,//��ռ��
        VCA_ILLEGAL_LANE_CHANGE_TYPE   = 0x200,//Υ�����
        VCA_ILLEGAL_LANE_DRIVE_TYPE    = 0x400,//��������
        VCA_VIOLATE_BAN_TYPE           = 0x800,//Υ������
        VCA_CROSS_PARKING_TYPE         = 0x1000,//·��ͣ��
        VCA_GREEN_PARKING_TYPE         = 0x2000//�̵�ͣ��
}VCA_ILLEGAL_TYPE;

typedef enum _VCA_VEHICLE_TYPE_
{
    VCA_OTHER_TYPE          = 0x1,  //������
        VCA_SMALLCAR_TYPE       = 0x2,  //С�ͳ�
        VCA_BIGCAR_TYPE         = 0x4,  //���ͳ�
        VCA_BUS_TYPE            = 0x8,  //�ͳ�
        VCA_TRUCK_TYPE          = 0x10,  //����
        VCA_CAR_TYPE            = 0x20,   //�γ�
        VCA_MINIBUS_TYPE        = 0x40,   //���
        VCA_SMALL_TRUCK_TYPE    = 0x80  //С����
}VCA_VEHICLE_TYPE;

//����Ʒ��������
typedef enum _VLR_VEHICLE_CLASS
{
    VLR_OTHER       = 0,    //����
        VLR_VOLKSWAGEN  = 1,    //����
        VLR_BUICK       = 2,    //���
        VLR_BMW         = 3,    //����
        VLR_HONDA       = 4,    //����
        VLR_PEUGEOT     = 5,    //����
        VLR_TOYOTA      = 6,    //����
        VLR_FORD        = 7,    //����
        VLR_NISSAN      = 8,    //�ղ�
        VLR_AUDI        = 9,    //�µ�
        VLR_MAZDA       = 10,   //���Դ�
        VLR_CHEVROLET   = 11,   //ѩ����
        VLR_CITROEN     = 12,   //ѩ����
        VLR_HYUNDAI     = 13,   //�ִ�
        VLR_CHERY       = 14,   //����
        VLR_KIA         = 15,   //����
        VLR_ROEWE       = 16,   //����
        VLR_MITSUBISHI  = 17,   //����
        VLR_SKODA       = 18,   //˹�´�
        VLR_GEELY       = 19,   //����
        VLR_ZHONGHUA    = 20,   //�л�
        VLR_VOLVO       = 21,   //�ֶ���
        VLR_LEXUS       = 22,   //�׿���˹
        VLR_FIAT        = 23,   //������
        VLR_EMGRAND     = 24,   //�ۺ�(����)
        VLR_DONGFENG    = 25,   //����
        VLR_BYD         = 26,   //���ǵ�
        VLR_SUZUKI      = 27,   //��ľ
        VLR_JINBEI      = 28,   //��
        VLR_HAIMA       = 29,   //����
        VLR_SGMW        = 30,   //����
        VLR_JAC         = 31,   //����
        VLR_SUBARU      = 32,   //˹��³
        VLR_ENGLON      = 33,   //Ӣ��(����)
        VLR_GREATWALL   = 34,   //����
        VLR_HAFEI       = 35,   //����
        VLR_ISUZU       = 36,   //��ʮ��(����)
        VLR_SOUEAST     = 37,   //����
        VLR_CHANA       = 38,   //����
        VLR_FOTON       = 39,   //����
        VLR_XIALI       = 40,   //����(һ��)
        VLR_BENZ        = 41,   //����
        VLR_FAW         = 42,   //һ��
        VLR_NAVECO      = 43,   //��ά��
        VLR_LIFAN       = 44,   //����
        VLR_BESTURN     = 45,   //һ����(һ��)
        VLR_CROWN       = 46,   //�ʹ�(����)
        VLR_RENAULT     = 47,   //��ŵ
        VLR_JMC         = 48,   //JMC(����)
        VLR_MG          = 49,   //MG���
        VLR_KAMA        = 50,   //����
        VLR_ZOTYE       = 51,   //��̩
        VLR_CHANGHE     = 52,   //���
        VLR_XMKINGLONG  = 53,   //���Ž���(����)
        VLR_HUIZHONG    = 54,   //�Ϻ�����(������)
        VLR_SZKINGLONG  = 55,   //���ݽ���
        VLR_HIGER       = 56,   //����
        VLR_YUTONG      = 57,   //��ͨ
        VLR_CNHTC       = 58,   //�й�����
        VLR_BEIBEN      = 59,   //�����ؿ�
        VLR_XINGMA      = 60,   //��������
        VLR_YUEJIN      = 61,   //Ծ��
        VLR_HUANGHAI    = 62,   //�ƺ�
        VLR_OLDWALL     = 63,   //�Ͽ��
        VLR_CHANACOMMERCIAL = 64,   //��������
        VLR_PORSCHE                   = 65,               // ��ʱ��
        VLR_CADILLAC                  = 66,               // ��������
        VLR_INFINITI                  = 67,               // Ӣ�����
        VLR_GLEAGLE                   = 68,               // ����ȫ��ӥ(����)
        VLR_JEEP                      = 69,               // JEEP(����)
        VLR_LANDROVER                 = 70,               // ·��
        VLR_CHANGFENG                 = 71,               // ����
        VLR_BENNI                     = 72,               // ��������(����)
        VLR_ERA                       = 73,               // ����ʱ��(ʱ��)
        VLR_TAURUS                    = 74,               // ������ţ��(��������)
        VLR_EADO                      = 75,               // �����ݶ�
        VLR_SHANQI                    = 76,               // ����
        VLR_HONGYAN                   = 77,               // ������(������ά�º���)
        VLR_DRAGON                    = 78,               // ������(��������)
        VLR_JACTEXT                   = 79,               // ����JAC (����)
        VLR_JACBUS                    = 80,               // �����ִ�ͳ� (����)
        VLR_ANKAI                     = 81,               // �����ͳ�
        VLR_SHENLONG                  = 82,               // ����ͳ�
        VLR_DAEWOO                    = 83,               // ����ͳ�
        VLR_WUZHENG                   = 84,               // ������
        VLR_MAN                       = 85,               // MAN��
        VLR_ZHONGTONG                 = 86,               // ��ͨ�ͳ�
        VLR_BAOJUN                    = 87,               // ����
        VLR_BQWEIWANG                 = 88,               // ��������
        VLR_TRUMPCHE                  = 89,               // ����
        VLR_LUFENG                    = 90,               // ½��
        VLR_HMZHENGZHOU               = 91,               // ����֣��
        VLR_BEIJING                   = 92,               // ������
        VLR_ZHONGSHUN                 = 93,               // ��˳
        VLR_WEILIN                    = 94,               // ������
        VLR_OPEL                      = 95,               // ŷ��
        VLR_KARRY                     = 96,               // ����
        VLR_SMA                       = 97,               // ������
        VLR_SMATEXT                   = 98,               // ����������SMA
        VLR_YUWIN                     = 99,               // ����Ԧʤ
        VLR_MINI                      = 100,               // ����MINI
        VLR_MARK                      = 101,               // ����MARKX
        VLR_HAVAL                     = 102,               // ����HAVAL
        VLR_OGA                       = 103,               // ک��
        VLR_VENUCIA                   = 104,               // ����
        VLR_BYD2                      = 105,               // ���ǵ���ʽ2 (���ǵ�)
        VLR_SMART                     = 106,               // ����SMART
        VLR_BAW                       = 107,               // ���������쳧BAW
        VLR_LUXGEN                    = 108,               // ���ǽ�
        VLR_YEMA                      = 109,               // Ұ��
        VLR_ZTE                       = 110,               // ����
        VLR_EVERUS                    = 111,               // ����
        VLR_CHRYSLER                  = 112,               // ����˹��
        VLR_GONOW                     = 113,               // ������
        VLR_SHJIANG                   = 114,               // �ɻ���
        VLR_RUILIN                    = 115,               // ����
        VLR_FORTA                     = 116,               // ����
        VLR_GAGUAR                    = 117,               // �ݱ�
        VLR_HEIBAO                    = 118,               // �ڱ�
        VLR_TKING                     = 119,               // �ƿ�
        VLR_TKINGTEXT                 = 120,               // �ƿ�����
        VLR_FODAY                     = 121,               // ����
        VLR_LOTUS                     = 122,               // ������
        VLR_NANJUN                    = 123,               // �Ͽ�
        VLR_SHUANGHUAN                = 124,               // ˫����
        VLR_SAIBAO                    = 125,               // ������
        VLR_HAWTAI                    = 126,               // ��̩
        VLR_LIFO                      = 127,               // ��Դ�ɵ�
        VLR_JONWAY                    = 128,               // ��Դ��
        VLR_FULONGMA                  = 129,               // ������
        VLR_WEILI                     = 130,               // Ϋ��
        VLR_ANCHI                     = 131,               // ��������
        VLR_PAIXI                     = 132,               // ��ϲ
        VLR_HIGERTEXT                 = 133,               // ����HIGER����
        VLR_RIYECAR                   = 134,               // ������Ұ�Ῠ
        VLR_RIYETRUCK                 = 135,               // ������Ұ�ؿ�
        VLR_JIANGNAN                  = 136,               // ����
        VLR_OLDZOTYE                  = 137,               // �Ͽ���̩
        VLR_OLDXIALI                  = 138,               // �Ͽ�����
        VLR_NEWAOCHI                  = 139,               // �°³�
        VLR_CDW                       = 140,               // ��������
        VLR_CDWTEXT                   = 141,               // ������������
        VLR_CIIMO                     = 142,               // ����˼��
        VLR_CHANADS                   = 143,               // �����а���
        VLR_DS                        = 144,               // ����
        VLR_ROHENS                    = 145,               // �ִ��Ͷ�˹����
        VLR_YANTAI                    = 146,               // ��̨
        VLR_SHUANGLONG                = 147,               // ˫��
        VLR_FENGLING                  = 148,               // ʱ�����
        VLR_XINKAI                    = 149,               // �¿�
        VLR_GMC                       = 150,               // GMC
        VLR_DATONG                    = 151,               // �����ͨ
        VLR_BQYINXIANG                = 152,               // ��������
        VLR_NEWCHERY                  = 153,               // ������
        VLR_MUDAN                     = 154,               // ĵ��
        VLR_DAYUN                     = 155,               // ������
        VLR_DONGWO                    = 156,               // ������
        VLR_UNION                     = 157,               // ������
        VLR_CHUNZHOU                  = 158,               // ���޿ͳ�
        VLR_SANY                      = 159,               // ��һ�ع�
        VLR_YAXING                    = 160,               // ���ǿͳ�
        VLR_HENGTONG                  = 161,               // ��ͨ�ͳ�
        VLR_SHAOLIN                   = 162,               // ���ֿͳ�
        VLR_YOUNG                     = 163,               // ����ͳ�
        VLR_STOM                      = 164,               // ʮͨ
        VLR_SANHUAN                   = 165,               // ��
        VLR_XUGONG                    = 166,               // �칤
        VLR_BEIFANG                   = 167,               // ������
        VLR_JIANGHUAN                 = 168,               // ��������
        VLR_BJFARM                    = 169,               // ����ũ��
        VLR_NEWDADI                   = 170,               // �´����
        VLR_SUNWIN                    = 171,               // ���ֿͳ�
        VLR_YINGTIAN                  = 172,               // Ӣ��
        VLR_QINGQI                    = 173,               // ����
        VLR_CHUFENG                   = 174,               // ������
        VLR_SCANIA                    = 175,               // ˹������
        VLR_JIULONG                   = 176,               // ����ͳ�
        VLR_YOUYI                     = 177,               // ����ͳ�
        VLR_SHANGRAO                  = 178,               // ���Ŀͳ�
        VLR_JIJIANG                   = 179,               // ����
        VLR_YANGZI                    = 180,               // ���ӿͳ�
        VLR_XIWO                      = 181,               // ���ֿͳ�
        VLR_CHANGJIANG                = 182,               // �����ͳ�
        VLR_WUYI                      = 183,               // ����
        VLR_CHENGDU                   = 184,               // �ɶ��ͳ�
        VLR_TIANMA                    = 185,               // ����
        VLR_BAOLONG                   = 186,               // ����
        VLR_NEWYATU                   = 187,               // ����;
        VLR_BARUI                     = 188,               // ���ǰ���
        VLR_GUANZHI                   = 189,               // ����
        VLR_XIYATE                    = 190,               // ������
        VLR_BINLI                     = 191,               // ����
        VLR_DADI                      = 192,               // ���
        VLR_FUQI                      = 193,               // ����
        VLR_HANGTIAN                  = 194,               // ������
        VLR_HENGTIAN                  = 195,               // ������
        VLR_JMCCAR                    = 196,               // ��������
        VLR_KAERSEN                   = 197,               // ����ɭ��
        VLR_KAWEI                     = 198,               // ������
        VLR_LANBOJINI                 = 199,               // ��������
        VLR_MASHALADI                 = 200,               // ��ɯ����
        VLR_SHUCHI                    = 201,               // ��ۿͳ�
        VLR_SHILI                     = 202,               // ʵ���ͳ�
        VLR_HUABEI                    = 203,               // �пͻ���
        VLR_YIZHENG                   = 204,               // ��������
        VLR_CHUNLAN                   = 205,               // ������
        VLR_DAFA                      = 206,               // ����
        VLR_SHENYE                    = 207,               // ��Ұ��
        VLR_FALALI                    = 208,               // ��������
        VLR_FUXING                    = 209,               // ������
        VLR_ANYUAN                    = 210,               // ��Դ�ͳ�
        VLR_JINGHUA                   = 211,               // �����ͳ�
        VLR_TAIHU                     = 212,               // ̫���ͳ�
        VLR_WUZHOULONG                = 213,               // ������
        VLR_CHANGLONG                 = 214,               // ��¡�ͳ�
        VLR_YUEXI                     = 215,               // �����ͳ�
        VLR_SHENMA                    = 216,               // ����ͳ�
        VLR_LUSHAN                    = 217,               // ®ɽ��
        VLR_WANFENG                   = 218,               // �����
        VLR_GZYUNBAO                  = 219,               // �����Ʊ�
        VLR_ZHONGDA                   = 220,               // �д���
        VLR_THREEWHEEL                = 221,               // ���ֳ�
        VLR_TWOWHEEL                  = 222,               // ���ֳ�
        VLR_JBC                       = 223,              // ��JBC
        VLR_YZJIANG                   = 224,               // ���ӽ��ͳ�
        VLR_CNJ                       = 225,               // �Ͽ�CNJ
        VLR_FORLAND                   = 226,               // ����ʱ������
        VLR_FARMCAR                   = 227,               // ũ�ó�
        VLR_DONGFANGHONG              = 228,               // ������
        VLR_STEYR                     = 229,               // ˹̫����
        VLR_HONGQI                    = 230,               // ����
        VLR_USER1       = 231,   //�û�1
        VLR_USER2       = 232,   //�û�2
        VLR_USER3       = 233,   //�û�3
        VLR_USER4       = 234,   //�û�4
        VLR_USER5       = 235,   //�û�5
        VLR_USER6       = 236,   //�û�6
        VLR_USER7       = 237,   //�û�7
        VLR_USER8       = 238    //�û�8
}VLR_VEHICLE_CLASS;

/********************����Ʒ��������Begin*************************/
//������Ʒ������
typedef enum _VSB_VOLKSWAGEN_CLASS
{
    VSB_VOLKSWAGEN_OTHER          = 0,   // ��������
        VSB_VOLKSWAGEN_LAVIDA         = 1,   // ����
        VSB_VOLKSWAGEN_CROSSLAVIDA    = 2,   // �ʾ�
        VSB_VOLKSWAGEN_TIGUAN         = 3,   // ;��
        VSB_VOLKSWAGEN_TOURAN         = 4,   // ;��
        VSB_VOLKSWAGEN_SANTANA        = 5,   // ɣ����
        VSB_VOLKSWAGEN_SANTANA2000    = 6,   // ɣ����2000
        VSB_VOLKSWAGEN_SANTANA3000    = 7,   // ɣ����3000
        VSB_VOLKSWAGEN_VISTA          = 8,   // ɣ����-־��
        VSB_VOLKSWAGEN_PASSAT         = 9,   // ������
        VSB_VOLKSWAGEN_PASSATLINGYU   = 10,  // ������-��Ԧ
        VSB_VOLKSWAGEN_POLO           = 11,  // ����
        VSB_VOLKSWAGEN_POLOCROSS      = 12,  // ����-�˶���
        VSB_VOLKSWAGEN_POLOGTI        = 13,  // ����-GTI
        VSB_VOLKSWAGEN_SAGITAR        = 14,  // ����
        VSB_VOLKSWAGEN_MAGOTAN        = 15,  // ����
        VSB_VOLKSWAGEN_JETTA          = 16,  // �ݴ�
        VSB_VOLKSWAGEN_BORA           = 17,  // ����
        VSB_VOLKSWAGEN_NEWGOLF        = 18,  // �¸߶��
        VSB_VOLKSWAGEN_GOLFGTI        = 19,  // �߶��-GTI
        VSB_VOLKSWAGEN_GOL            = 20,  // �߶�
        VSB_VOLKSWAGEN_CADDY          = 21,  // ����
        VSB_VOLKSWAGEN_PHAETON        = 22,  // ����
        VSB_VOLKSWAGEN_TOUREG         = 23,  // ;��
        VSB_VOLKSWAGEN_SCIROCCO       = 24,  // �п�
        VSB_VOLKSWAGEN_BEETLE         = 25,  // �׿ǳ�
        VSB_VOLKSWAGEN_SHARAN         = 26,  // ����
        VSB_VOLKSWAGEN_MULTIVAN       = 27,  // ������
        VSB_VOLKSWAGEN_CARBONCOPY     = 28,  // һ�����-CC
        VSB_VOLKSWAGEN_VISTACHANGDA   = 29,  // ɣ����־��-����
        VSB_VOLKSWAGEN_BORASPORTLINE  = 30,   // ����-SPORTLINE
        VSR_VOLKSWAGEN_CC_1             =31,   //����-CC-2012,2011,2010
        VSR_VOLKSWAGEN_Cross_POLO_1     = 32,   //����-Cross-POLO-2010,2007
        VSR_VOLKSWAGEN_Cross_POLO_2     = 33,   //����-Cross-POLO-2014,2012
        VSR_VOLKSWAGEN_MULTIVAN_1       = 34,   //����-Multivan-2014,2012,2011
        VSR_VOLKSWAGEN_POLO_1           = 35,   //����-POLO-2006,2005,2004,2003,2002
        VSR_VOLKSWAGEN_POLO_2           = 36,   //����-POLO-2013,2012,2011
        VSR_VOLKSWAGEN_POLO_JINQU_1     = 37,   //����-POLO��ȡ-2009,2008,2007,2006
        VSR_VOLKSWAGEN_POLO_JINQU_2     = 38,   //����-POLO��ȡ-2011
        VSR_VOLKSWAGEN_Tiguan_1         = 39,   //����-Tiguan-2011,2009
        VSR_VOLKSWAGEN_Tiguan_2         = 40,   //����-Tiguan-2014,2013,2012
        VSR_VOLKSWAGEN_XIALANG_1        = 41,   //����-����-2013,2012
        VSR_VOLKSWAGEN_BAOLAI_1         = 42,   //����-����-2005,2004
        VSR_VOLKSWAGEN_BAOLAI_2         = 43,   //����-����-2006
        VSR_VOLKSWAGEN_BAOLAI_3         = 44,   //����-����-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_BAOLAI_4         = 45,   //����-����-2014,2013
        VSR_VOLKSWAGEN_SHANGKU_1        = 46,   //����-�п�-2014,2013
        VSR_VOLKSWAGEN_PASATE_1         = 47,   //����-������-2003���,2001��Ԧ
        VSR_VOLKSWAGEN_PASATE_2         = 48,   //����-������-2007,2006,2005��Ԧ
        VSR_VOLKSWAGEN_PASATE_3         = 49,   //����-������-2009,2008,2007,2005,2004,2003,2001,2000
        VSR_VOLKSWAGEN_PASATE_4         = 50,   //����-������-2011,2009��Ԧ
        VSR_VOLKSWAGEN_PASATE_5         = 51,   //����-������-2014,2013,2012,2011
        VSR_VOLKSWAGEN_JIEDA_1          = 52,   //����-�ݴ�-2005CIF���,2002
        VSR_VOLKSWAGEN_JIEDA_2          = 53,   //����-�ݴ�-2009,2008,2006,2005,2004
        VSR_VOLKSWAGEN_JIEDA_3          = 54,   //����-�ݴ�-2012,2010
        VSR_VOLKSWAGEN_JIEDA_4          = 55,   //����-�ݴ�-2013
        VSR_VOLKSWAGEN_LANGYI_1         = 56,   //����-����-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_LANGYI_2         = 57,   //����-����-2013
        VSR_VOLKSWAGEN_SANGTANA_1       = 58,   //����-ɣ����-2007,2002,2000,1999,1995
        VSR_VOLKSWAGEN_SANGTANA_2       = 59,   //����-ɣ����-2014,2013
        VSR_VOLKSWAGEN_SANGTANA_3       = 60,   //����-ɣ����2000-2003,2001,2000,1999,1998,1996
        VSR_VOLKSWAGEN_SANGTANA_4       = 61,   //����-ɣ����3000-2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,   //����-ɣ����־��(vista)-2011,2010,2009,2008
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,   //����-ɣ����־��(vista)-2006
        VSR_VOLKSWAGEN_JIAKECHONG_1     = 64,   //����-�׿ǳ�-2010,2009,2008,2007,2006,2005
        VSR_VOLKSWAGEN_JIAKECHONG_2     = 65,   //����-�׿ǳ�-2014,2013
        VSR_VOLKSWAGEN_HUITENG_2        = 66,   //����-����-2010,2009,2007,2006
        VSR_VOLKSWAGEN_MAITENG_1        = 67,   //����-����-2011,2010,2009,2008,2007
        VSR_VOLKSWAGEN_MAITENG_2        = 68,   //����-����-2013,2012
        VSR_VOLKSWAGEN_TUAN_3           = 69,   //����-;��-2006,2005,2004
        VSR_VOLKSWAGEN_TUAN_1           = 70,   //����-;��-2010,2009,2008
        VSR_VOLKSWAGEN_TUAN_2           = 71,   //����-;��-2013,2012,2011
        VSR_VOLKSWAGEN_TUGUAN_1         = 72,   //����-;��-2012,2011,2010
        VSR_VOLKSWAGEN_TURUI_1          = 73,   //����-;��-2006,2005,2003
        VSR_VOLKSWAGEN_TURUI_2          = 74,   //����-;��-2014,2013,2012,2011
        VSR_VOLKSWAGEN_SUTENG_1         = 75,   //����-����-2010,2009,2007,2006
        VSR_VOLKSWAGEN_SUTENG_2         = 76,   //����-����-2011
        VSR_VOLKSWAGEN_SUTENG_3         = 77,   //����-����-2014,2013,2012
        VSR_VOLKSWAGEN_GAOERFU_1        = 78,   //����-�߶��-2008,2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_GAOERFU_2        = 79,   //����-�߶��-2012,2011���,2012,2011,2010
        VSR_VOLKSWAGEN_GAOERFU_3        = 80,   //����-�߶��GTI-2013,2012,2011,2010
        VSR_VOLKSWAGEN_LANGYI_3         = 81,   //����-����-2014
        VSR_VOLKSWAGEN_HUITENG_1        = 82   //����-����-2004
} VSB_VOLKSWAGEN_CLASS;

//�����Ʒ������
typedef enum _VBR_BUICK_CLASS
{
    VBR_BUICK_OTHER        = 0,   // ��������
        VBR_BUICK_ENCORE       = 1,   // ������
        VBR_BUICK_GL8          = 2,   // GL8
        VBR_BUICK_LEGAL        = 3,   // ����
        VBR_BUICK_LACROSS      = 4,   // ��Խ
        VBR_BUICK_EXCELLE      = 5,   // ��Խ
        VBR_BUICK_EXCELLEGT    = 6,   // Ӣ��GT
        VBR_BUICK_WXCELLEXT    = 7,   // Ӣ��XT
        VBR_BUICK_ENCLAVE      = 8,   // ������
        VBR_BUICK_ROYAUM       = 9,   // ����
        VBR_BUICK_SAIL         = 10,  // �����ŷ
        VBR_BUICK_EXCELLEHRV   = 11,  // ��ԽHRV
        VBR_BUICK_PARKAVENUE   = 12,  // ������
        VBR_BUICK_CENTURY      = 13,   // ������
        VBR_BUICK_GL8_1          = 14,   // ���-GL8-2004,2003
        VBR_BUICK_GL8_2          = 15,   // ���-GL8-2007,2006,2005
        VBR_BUICK_GL8_3          = 16,   // ���-GL8-2010_2008_2006_2005½��
        VBR_BUICK_GL8_4          = 17,   // ���-GL8-2014,2013,2012,2011
        VBR_BUICK_GL8_5          = 18,   // ���-GL8-2014_2013_2011������
        VBR_BUICK_ENCORE_1       = 19,   // ���-������-2014,2013
        VBR_BUICK_ENCLAVE_1      = 20,   // ���-������-2013,2010,2009
        VBR_BUICK_LEGAL_1        = 21,   // ���-����-2001,2000,1999
        VBR_BUICK_LEGAL_2        = 22,   // ���-����-2008,2006,2005,2004,2002
        VBR_BUICK_LEGAL_3        = 23,   // ���-����-2013,2012,2011,2010,2009
        VBR_BUICK_LEGAL_4        = 24,   // ���-����-2013_2012_2011�˶���
        VBR_BUICK_LEGAL_5        = 25,   // ���-����-2014
        VBR_BUICK_LEGAL_6        = 26,   // ���-����-2014�˶���
        VBR_BUICK_LACROSS_1      = 27,   // ���-��Խ-2008,2007,2006
        VBR_BUICK_LACROSS_2      = 28,   // ���-��Խ-2012,2011,2010,2009
        VBR_BUICK_LACROSS_3      = 29,   // ���-��Խ-2013
        VBR_BUICK_EXCELLE_1      = 30,   // ���-��Խ-2006,2005,2004
        VBR_BUICK_EXCELLE_2      = 31,   // ���-��Խ-2008_2006_2005_2004HRV
        VBR_BUICK_EXCELLE_3      = 32,   // ���-��Խ-2011,2009,2008
        VBR_BUICK_EXCELLE_4      = 33,   // ���-��Խ-2013
        VBR_BUICK_PARKAVENUE_1   = 34,   // ���-������-2011,2010,2009,2008,2007
        VBR_BUICK_SAIL_1         = 35,   // ���-��ŷ-2004,2003
        VBR_BUICK_EXCELLEGT_1    = 36,   // ���-Ӣ��GT-2013,2012,2011,2010
        VBR_BUICK_WXCELLEXT_1    = 37,   // ���-Ӣ��XT-2014,2013,2012,2010
        VBR_BUICK_CENTURY_1      = 38,   // ���-������-2000
        VBR_BUICK_RONGYU_1       = 39   // ���-����-2005,2004
}VBR_BUICK_CLASS;

//������Ʒ������
typedef enum _VSB_BMW_CLASS
{
    VSB_BMW_OTHER       = 0,   // ��������
        VSB_BMW_3SERIES     = 1,   // ����3ϵ
        VSB_BMW_5SERIES     = 2,   // ����5ϵ
        VSB_BMW_X1          = 3,   // ����X1
        VSB_BMW_1SERIES     = 4,   // ����1ϵ
        VSB_BMW_7SERIES     = 5,   // ����7ϵ
        VSB_BMW_X3          = 6,   // ����X3
        VSB_BMW_X5          = 7,   // ����X5
        VSB_BMW_X6          = 8,   // ����X6
        VSB_BMW_Z4          = 9,   // ����Z4
        VSB_BMW_MINI        = 10,  // ����
        VSB_BMW_6SERIES     = 11,   //����6ϵ
        VSB_BMW_YIXI_1      = 12,     // ����-1ϵ-2011,2010,2008,2007
        VSB_BMW_YIXI_2      = 13,     // ����-1ϵ-2013,2012
        VSB_BMW_SANXI_1     = 14,     // ����-3ϵ-2004
        VSB_BMW_SANXI_2     = 15,     // ����-3ϵ-2007,2005
        VSB_BMW_SANXI_3     = 16,     // ����-3ϵ-2012,2011,2010,2009
        VSB_BMW_SANXI_4     = 17,     // ����-3ϵ-2014,2013
        VSB_BMW_WUXI_1      = 18,     // ����-5ϵ-2010,2009,2008
        VSB_BMW_WUXI_2      = 19,     // ����-5ϵ-2013,2012,2011
        VSB_BMW_LIUXI_1     = 20,     // ����-6ϵ-δ֪
        VSB_BMW_QIXI_1      = 21,     // ����-7ϵ-2011,2010,2009
        VSB_BMW_QIXI_2      = 22,     // ����-7ϵ-2013
        VSB_BMW_X1_1        = 23,     // ����-X1-2012,2010
        VSB_BMW_X1_2        = 24,     // ����-X1-2014,2013
        VSB_BMW_X3_1        = 25,     // ����-X3-2009,2008,2006
        VSB_BMW_X3_2        = 26,     // ����-X3-2013,2012,2011
        VSB_BMW_X5_1        = 27,     // ����-X5-2010,2009,2008
        VSB_BMW_X5_2        = 28,     // ����-X5-2013,2012,2011
        VSB_BMW_X5_3        = 29,     // ����-X5-2013�˶���
        VSB_BMW_X6_1        = 30,     // ����-X6-2013,2012,2011,2009,2008
        VSB_BMW_Z4_1        = 31     // ����-Z4-2004
}VSB_BMW_CLASS;

//������Ʒ������
typedef enum _VSB_HONDA_CLASS
{
    VSB_HONDA_OTHER       = 0,   // ��������
        VSB_HONDA_CRV         = 1,   // ����CR-V(˼��)
        VSB_HONDA_JADE        = 2,   // �ܵ�
        VSB_HONDA_CIVIC       = 3,   // ˼��
        VSB_HONDA_SPIRIOR     = 4,   // ˼���
        VSB_HONDA_CIIMO       = 5,   // ˼��
        VSB_HONDA_ELYSION     = 6,   // ������
        VSB_HONDA_OBYSSEY     = 7,   // �����
        VSB_HONDA_FIT         = 8,   // �ɶ�
        VSB_HONDA_NEWCITY     = 9,   // �淶
        VSB_HONDA_CROSSTOUR   = 10,  // ��ʫͼ
        VSB_HONDA_CRIDER      = 11,  // ����
        VSB_HONDA_ACCORD      = 12,  // �Ÿ�
        VSB_HONDA_CITY        = 13,  // ˼��
        VSB_HONDA_ANTILOCK    = 14,  // ���µ�
        VSB_HONDA_CRZ         = 15,   // ����CR-Z
        VSB_HONDA_CRV_1       = 16,   // ����-CR-V-2004
        VSB_HONDA_CRV_2       = 17,   // ����-CR-V-2005
        VSB_HONDA_CRV_3       = 18,   // ����-CR-V-2008,2007
        VSB_HONDA_CRV_4       = 19,   // ����-CR-V-2010
        VSB_HONDA_CRV_5       = 20,   // ����-CR-V-2013,2012
        VSB_HONDA_CRIDER_1    = 21,   // ����-����-2014,2013
        VSB_HONDA_OBYSSEY_1   = 22,   // ����-�µ���-2002
        VSB_HONDA_OBYSSEY_2   = 23,   // ����-�µ���-2006,2005,2004
        VSB_HONDA_OBYSSEY_3   = 24,   // ����-�µ���-2008,2007
        VSB_HONDA_OBYSSEY_4   = 25,   // ����-�µ���-2011������
        VSB_HONDA_CIVIC_1     = 26,   // ����-˼��-2007
        VSB_HONDA_CIVIC_5     = 27,   // ����-˼��-1996
        VSB_HONDA_CIVIC_2     = 28,   // ����-˼��-2008,2006
        VSB_HONDA_CIVIC_3     = 29,   // ����-˼��-2009
        VSB_HONDA_CIVIC_4     = 30,   // ����-˼��-2013,2012,2011
        VSB_HONDA_CITY_1      = 31,   // ����-˼��-2008,2007,2006
        VSB_HONDA_SPIRIOR_1   = 32,   // ����-˼���-2009
        VSB_HONDA_SIMING_1    = 33,   // ����-˼��-2012
        VSB_HONDA_JIEDE_1     = 34,   // ����-�ܵ�-2013
        VSB_HONDA_CROSSTOUR_1 = 35,   // ����-��ʫͼ-2013,2012,2010
        VSB_HONDA_AILISHEN_1  = 36,   // ����-������-2012
        VSB_HONDA_NEWCITY_1   = 37,   // ����-�淶-2009
        VSB_HONDA_NEWCITY_2   = 38,   // ����-�淶-2011
        VSB_HONDA_NEWCITY_3   = 39,   // ����-�淶-2014,2012
        VSB_HONDA_ACCORD_1    = 40,   // ����-�Ÿ�-1996
        VSB_HONDA_ACCORD_2    = 41,   // ����-�Ÿ�-1999
        VSB_HONDA_ACCORD_3    = 42,   // ����-�Ÿ�-2001
        VSB_HONDA_ACCORD_4    = 43,   // ����-�Ÿ�-2003
        VSB_HONDA_ACCORD_5    = 44,   // ����-�Ÿ�-2008
        VSB_HONDA_ACCORD_6    = 45,   // ����-�Ÿ�-2010
        VSB_HONDA_ACCORD_7    = 46,   // ����-�Ÿ�-2011
        VSB_HONDA_ACCORD_8    = 47,   // ����-�Ÿ�-2012
        VSB_HONDA_ACCORD_9    = 48,   // ����-�Ÿ�-2013
        VSB_HONDA_ACCORD_10   = 49,   // ����-�Ÿ�-2014
        VSB_HONDA_FIT_1       = 50,   // ����-�ɶ�-2004
        VSB_HONDA_FIT_2       = 51,   // ����-�ɶ�-2004����
        VSB_HONDA_FIT_3       = 52,   // ����-�ɶ�-2005
        VSB_HONDA_FIT_4       = 53,   // ����-�ɶ�-2007
        VSB_HONDA_FIT_5       = 54,   // ����-�ɶ�-2008
        VSB_HONDA_FIT_6       = 55   // ����-�ɶ�-2013,2011
}VSB_HONDA_CLASS;

//������Ʒ������
typedef enum _VSB_PEUGEOT_CLASS
{
    VSB_PEUGEOT_OTHER      = 0,   // ��������
        VSB_PEUGEOT_2008       = 1,   // ����2008
        VSB_PEUGEOT_207        = 2,   // ����207
        VSB_PEUGEOT_SENNA      = 3,   // ����
        VSB_PEUGEOT_3008       = 4,   // ����3008
        VSB_PEUGEOT_301        = 5,   // ����301
        VSB_PEUGEOT_307        = 6,   // ����307
        VSB_PEUGEOT_308        = 7,   // ����308
        VSB_PEUGEOT_408        = 8,   // ����408
        VSB_PEUGEOT_508        = 9,   // ����508
        VSB_PEUGEOT_206        = 10,  // ����206
        VSB_PEUGEOT_407        = 11,   // ����407
        VSB_PEUGEOT_206_1      = 12, // ����-206-δ֪
        VSB_PEUGEOT_207_1      = 13, // ����-207����-2011,2010,2009
        VSB_PEUGEOT_207_2      = 14, // ����-207����-2013
        VSB_PEUGEOT_3008_1     = 15, // ����-3008-2014,2013
        VSB_PEUGEOT_301_1      = 16, // ����-301-δ֪
        VSB_PEUGEOT_307_1      = 17, // ����-307����-2007,2006,2005,2004
        VSB_PEUGEOT_307_2      = 18, // ����-307����-2010,2009,2008
        VSB_PEUGEOT_307_3      = 19, // ����-307����-2013_2012_2011CROSS
        VSB_PEUGEOT_308_1      = 20, // ����-308-2014,2013,2012
        VSB_PEUGEOT_407_1      = 21, // ����-407-δ֪
        VSB_PEUGEOT_408_1      = 22, // ����-408-2012,2011,2010
        VSB_PEUGEOT_408_2      = 23, // ����-408-2013
        VSB_PEUGEOT_508_1      = 24, // ����-508-2014,2013,2012,2011
        VSB_PEUGEOT_207_3      = 25, // ����-207����-2011,2010,2009
        VSB_PEUGEOT_307_4      = 26 // ����-307����-2013,2012,2010,2009,2008

}VSB_PEUGEOT_CLASS;

//������Ʒ������
typedef enum _VSB_TOYOTA_CLASS
{
    VSB_TOYOTA_OTHER            = 0,   // ��������
        VSB_TOYOTA_HIGHLANDER       = 1,   // ������
        VSB_TOYOTA_CAMRY            = 2,   // ������
        VSB_TOYOTA_YARIS            = 3,   // ����ʿ
        VSB_TOYOTA_YARISL           = 4,   // YARIS L����
        VSB_TOYOTA_VERSO            = 5,   // ����
        VSB_TOYOTA_HUAGUAN          = 6,   // ����
        VSB_TOYOTA_CROWN            = 7,   // �ʹ�
        VSB_TOYOTA_COROLLA          = 8,   // ������
        VSB_TOYOTA_COSTER           = 9,   // ��˹��
        VSB_TOYOTA_PRADO            = 10,  // ������
        VSB_TOYOTA_PRIUS            = 11,  // ����˹
        VSB_TOYOTA_RAV4             = 12,  // ����RAV4
        VSB_TOYOTA_REZI             = 13,  // ��־
        VSB_TOYOTA_VIOS             = 14,  // ����
        VSB_TOYOTA_PREVIA           = 15,  // ����ά��
        VSB_TOYOTA_HIACE            = 16,  // ��ʨ
        VSB_TOYOTA_86               = 17,  // ����86
        VSB_TOYOTA_SPEQUOIA         = 18,  // ��ɼ
        VSB_TOYOTA_LANDCRUISER      = 19,  // ½��Ѳ��(���¿�·��)
        VSB_TOYOTA_SIENNA           = 20,  // ����
        VSB_TOYOTA_CAMRYHYBRID      = 21,  // ������-HYBRID
        VSB_TOYOTA_GRACE            = 22,  // ����˹
        VSB_TOYOTA_ALPHARD          = 23,   // ����
        VSB_TOYOTA_RAV4_1           = 24,   // ����-RAV4-2012�ֶ������,2011,2010,2009
        VSB_TOYOTA_RAV4_2           = 25,   // ����-RAV4-2013
        VSB_TOYOTA_86_1             = 26,   // ����-����86-δ֪
        VSB_TOYOTA_JIAMEI_2         = 27,   // ����-����-2001,2000,1999,1998
        VSB_TOYOTA_JIAMEI_3         = 28,   // ����-����-2004,2003,2002
        VSB_TOYOTA_LANDEKLZ_1       = 29,   // ����-���¿�·��-2011�ж���,2010,2007
        VSB_TOYOTA_KAIMEIRUI_1      = 30,   // ����-������-2008,2007,2006
        VSB_TOYOTA_KAIMEIRUI_2      = 31,   // ����-������-2012����
        VSB_TOYOTA_KAIMEIRUI_3      = 32,   // ����-������-2012�����,2011,2010,2009
        VSB_TOYOTA_KAIMEIRUI_4      = 33,   // ����-������-2013,2012
        VSB_TOYOTA_KAIMEIRUI_5      = 34,   // ����-������-2013�����
        VSB_TOYOTA_KAIMEIRUI_6      = 35,   // ����-������-2014,2012����
        VSB_TOYOTA_KALUOLA_1        = 36,   // ����-������-2010,2009,2008,2007,2006
        VSB_TOYOTA_KALUOLA_2        = 37,   // ����-������-2013,2012,2011
        VSB_TOYOTA_AIERFA_1         = 38,   // ����-����-2011,2010
        VSB_TOYOTA_AIERFA_2         = 39,   // ����-����-2013,2012
        VSB_TOYOTA_WEICHI_1         = 40,   // ����-����-2004,2003
        VSB_TOYOTA_WEICHI_2         = 41,   // ����-����-2007,2006,2005
        VSB_TOYOTA_WEICHI_3         = 42,   // ����-����-2009,2008
        VSB_TOYOTA_WEICHI_4         = 43,   // ����-����-2013,2012,2011,2010
        VSB_TOYOTA_WEICHI_5         = 44,   // ����-����-2014
        VSB_TOYOTA_PULADUO_1        = 45,   // ����-������-2007,2006,2005,2004
        VSB_TOYOTA_PULADUO_2        = 46,   // ����-������-2010
        VSB_TOYOTA_PULADUO_3        = 47,   // ����-������-2014
        VSB_TOYOTA_PURUIWEIYA_1     = 48,   // ����-����ά��-2004
        VSB_TOYOTA_PURUIWEIYA_4     = 49,   // ����-����ά��-2005
        VSB_TOYOTA_PURUIWEIYA_2     = 50,   // ����-����ά��-2006
        VSB_TOYOTA_PURUIWEIYA_3     = 51,   // ����-����ά��-2012,2010,2008,2007
        VSB_TOYOTA_KESIDA_1         = 52,   // ����-��˹��-2007
        VSB_TOYOTA_KESIDA_2         = 53,   // ����-��˹��-2011
        VSB_TOYOTA_HANLANDA_1       = 54,   // ����-������-2011,2009
        VSB_TOYOTA_HANLANDA_2       = 55,   // ����-������-2012
        VSB_TOYOTA_HANLANDA_3       = 56,   // ����-������-2013
        VSB_TOYOTA_HAISHI_1         = 57,   // ����-��ʨ-2001
        VSB_TOYOTA_HUANGGUAN_1      = 58,   // ����-�ʹ�-1999
        VSB_TOYOTA_HUANGGUAN_2      = 59,   // ����-�ʹ�-2009,2008,2007,2006,2005
        VSB_TOYOTA_HUANGGUAN_3      = 60,   // ����-�ʹ�-2010
        VSB_TOYOTA_HUANGGUAN_4      = 61,   // ����-�ʹ�-2012,2011
        VSB_TOYOTA_HONGSHAN_1       = 62,   // ����-��ɼ-δ֪
        VSB_TOYOTA_HUAGUAN_1        = 63,   // ����-����-2006,2005,2004
        VSB_TOYOTA_HUAGUAN_2        = 64,   // ����-����-2009,2008,2007
        VSB_TOYOTA_HUAGUAN_3        = 65,   // ����-����-2011,2010
        VSB_TOYOTA_YIZHI_1          = 66,   // ����-����-2014,2012,2011
        VSB_TOYOTA_RUIZHI_1         = 67,   // ����-��־-2006,2005
        VSB_TOYOTA_RUIZHI_2         = 68,   // ����-��־-2009,2008,2007
        VSB_TOYOTA_RUIZHI_3         = 69,   // ����-��־-2010��Ȱ�
        VSB_TOYOTA_RUIZHI_4         = 70,   // ����-��־-2012,2010
        VSB_TOYOTA_LUDIXUNYANG_1    = 71,   // ����-½��Ѳ��-δ֪
        VSB_TOYOTA_YALISHI_1        = 72,   // ����-����ʿ-2009,2008,2007
        VSB_TOYOTA_YALISHI_2        = 73,   // ����-����ʿ-2012,2011,2010
        VSB_TOYOTA_RAV4_3           = 74,   // ����-RAV4-2013����,��Ӣ,���,2012
        VSB_TOYOTA_YARiSL_1         = 75,   // ����-YARiS-L
        VSB_TOYOTA_JIAMEI_1         = 76,   // ����-����-1996
        VSB_TOYOTA_PLATZ_1          = 77,   // ����-PLATZ-1999
        VSB_TOYOTA_LANDEKLZ_2       = 78   // ����-���¿�·��-2014,2012�ж���,2012
}VSB_TOYOTA_CLASS;

//������Ʒ������
typedef enum _VSB_FORD_CLASS
{
    VSB_FORD_OTHER       = 0,   // ��������
        VSB_FORD_FOCUS       = 1,   // ����˹
        VSB_FORD_FIESTA      = 2,   // ���껪
        VSB_FORD_SMAX        = 3,   // ���˹
        VSB_FORD_MONDEO      = 4,   // �ɵ�ŷ
        VSB_FORD_ECOSPORT    = 5,   // �?
        VSB_FORD_ESCAPE      = 6,   // �?
        VSB_FORD_ZHISHENG    = 7,   // ��ʤ
        VSB_FORD_ESCORT      = 8,   // ���˹
        VSB_FORD_EXPLORER    = 9,   // ����̽����
        VSB_FORD_EDGE        = 10,  // ���
        VSB_FORD_TRANSIT     = 11,   // ȫ˳
        VSB_FORD_QUANSHUN_1      = 12,    // ����-ȫ˳-δ֪
        VSB_FORD_JIANIANHUA_1    = 13,    // ����-���껪����-2006,2005,2004
        VSB_FORD_JIANIANHUA_2    = 14,    // ����-���껪����-2011,2010,2009
        VSB_FORD_JIANIANHUA_3    = 15,    // ����-���껪����-2013
        VSB_FORD_JIANIANHUA_4    = 16,    // ����-���껪����-2012
        VSB_FORD_TANXIANZHE_1    = 17,    // ����-̽����-2013,2011
        VSB_FORD_FOCUS_1         = 18,    // ����-����˹����-2005
        VSB_FORD_FOCUS_2         = 19,    // ����-����˹����-2005������
        VSB_FORD_FOCUS_3         = 20,    // ����-����˹����-2008,2007,2006
        VSB_FORD_FOCUS_4         = 21,    // ����-����˹����-2013,2012����,2011,2009
        VSB_FORD_FOCUS_5         = 22,    // ����-����˹����-2012
        VSB_FORD_FOCUS_6         = 23,    // ����-����˹����-2012��,ʱ��,2011,2010,2009,2008
        VSB_FORD_YIBO_1          = 24,    // ����-�?-2013
        VSB_FORD_YIHU_1          = 25,    // ����-�?-2013
        VSB_FORD_MENGDIOU_1      = 26,    // ����-�ɵ�ŷ-2003
        VSB_FORD_MENGDIOU_2      = 27,    // ����-�ɵ�ŷ-2005,2004
        VSB_FORD_MENGDIOU_3      = 28,    // ����-�ɵ�ŷ-2006
        VSB_FORD_MENGDIOU_4      = 29,    // ����-�ɵ�ŷ-2013
        VSB_FORD_MENGDIOU_5      = 30,    // ����-�ɵ�ŷ-��ʤ-2010,2008,2007
        VSB_FORD_MENGDIOU_6      = 31,    // ����-�ɵ�ŷ-��ʤ-2011
        VSB_FORD_RUIJIE_1        = 32,    // ����-���-2012,2011
        VSB_FORD_MAIKESI_1       = 33    // ����-���˹-2008,2007
}VSB_FORD_CLASS;

//�ղ���Ʒ������
typedef enum _VSB_NISSAN_CLASS
{
    VSB_NISSAN_OTHER              = 0,   // ��������
        VSB_NISSAN_XTRAIL             = 1,   // �濥
        VSB_NISSAN_MURANO             = 2,   // ¥��
        VSB_NISSAN_LIVINA             = 3,   // ����
        VSB_NISSAN_MARCH              = 4,   // ���
        VSB_NISSAN_TIIDA              = 5,   // ���
        VSB_NISSAN_TEANA              = 6,   // ����
        VSB_NISSAN_QASHQAI            = 7,   // �п�
        VSB_NISSAN_SYLPHY             = 8,   // ����
        VSB_NISSAN_SUNNY              = 9,   // ����
        VSB_NISSAN_D22PICKUP          = 10,  // D22Ƥ��
        VSB_NISSAN_D22VAN             = 11,  // D22��ʽ��
        VSB_NISSAN_CABSTAR            = 12,  // ����˹��
        VSB_NISSAN_HV200              = 13,  // NV200
        VSB_NISSAN_PALADIN            = 14,  // ������
        VSB_NISSAN_YIDA               = 15,  // �ô�
        VSB_NISSAN_DUCK               = 16,  // ����
        VSB_NISSAN_CEFIRO             = 17,  // ���
        VSB_NISSAN_FENGSHENBLUEBIRD   = 18,  // ��������
        VSB_NISSAN_FENGSHENSUNNY      = 19,  // ��������
        VSB_NISSAN_SUCCE              = 20,  // ˧��
        VSB_NISSAN_FUGA               = 21,  // ����
        VSB_NISSAN_BLUEBIRD4          = 22,  // ����4��
        VSB_NISSAN_VENUCIA            = 23,  // ����
        VSB_NISSAN_QUEST              = 24,  // ��ʿ
        VSB_NISSAN_GENISS             = 25,   // ����
        VSB_NISSAN_NV200_1            = 26,  // �ղ�-NV200-2013,2012,2011,2010
        VSB_NISSAN_TIANLAI_1          = 27,  // �ղ�-����-2005,2004
        VSB_NISSAN_TIANLAI_2          = 28,  // �ղ�-����-2007,2006
        VSB_NISSAN_TIANLAI_3          = 29,  // �ղ�-����-2010,2008
        VSB_NISSAN_TIANLAI_4          = 30,  // �ղ�-����-2012,2011
        VSB_NISSAN_TIANLAI_5          = 31,  // �ղ�-����-2012�ư�ȫ��,2011����
        VSB_NISSAN_TIANLAI_6          = 32,  // �ղ�-����-2014,2013
        VSB_NISSAN_QIJUN_1            = 33,  // �ղ�-�濥-2010,2008
        VSB_NISSAN_QIJUN_2            = 34,  // �ղ�-�濥-2012,2011���
        VSB_NISSAN_PALADING_1         = 35,  // �ղ�-������-2013,2011,2006,2004
        VSB_NISSAN_LOULAN_1           = 36,  // �ղ�-¥��-2013,2011
        VSB_NISSAN_LOULAN_2           = 37,  // �ղ�-���-2010
        VSB_NISSAN_LANNIAO_1          = 38,  // �ղ�-����-2002
        VSB_NISSAN_LANNIAO_2          = 39,  // �ղ�-����-2003
        VSB_NISSAN_LANNIAO_3          = 40,  // �ղ�-����-2004
        VSB_NISSAN_GUISHI_1           = 41,  // �ղ�-��ʿ-2005
        VSB_NISSAN_XUANYI_1           = 42,  // �ղ�-����-2006
        VSB_NISSAN_XUANYI_2           = 43,  // �ղ�-����-2012����,2009,2007
        VSB_NISSAN_XUANYI_3           = 44,  // �ղ�-����-2014,2012
        VSB_NISSAN_XIAOKE_1           = 45,  // �ղ�-�п�-2009,2008
        VSB_NISSAN_XIAOKE_2           = 46,  // �ղ�-�п�-2013,2012,2011
        VSB_NISSAN_SUNNY_3            = 47,  // �ղ�-����-2004
        VSB_NISSAN_SUNNY_1            = 48,  // �ղ�-����-2006,2005
        VSB_NISSAN_SUNNY_2            = 49,  // �ղ�-����-2012,2011
        VSB_NISSAN_YIDA_1             = 50,  // �ղ�-�ô�-2008,2006,2005
        VSB_NISSAN_YIDA_2             = 51,  // �ղ�-�ô�-δ֪
        VSB_NISSAN_FENGDU_1           = 52,  // �ղ�-���-δ֪
        VSB_NISSAN_FENGYA_1           = 53,  // �ղ�-����-δ֪
        VSB_NISSAN_LIWEI_1            = 54,  // �ղ�-����-2008,2007
        VSB_NISSAN_LIWEI_2            = 55,  // �ղ�-����-2009
        VSB_NISSAN_LIWEI_3            = 56,  // �ղ�-����-2010
        VSB_NISSAN_LIWEI_4            = 57,  // �ղ�-����-2011,2010����,2008������
        VSB_NISSAN_JUNYI_1            = 58,  // �ղ�-����-2006
        VSB_NISSAN_QIDA_1             = 59,  // �ղ�-���-2006,2005
        VSB_NISSAN_QIDA_2             = 60,  // �ղ�-���-2009,2008
        VSB_NISSAN_QIDA_3             = 61,  // �ղ�-���-2013,2012,2011
        VSB_NISSAN_RUIQI_1            = 62   // �ղ�-����Ƥ��-2009������
}VSB_NISSAN_CLASS;

//�µ���Ʒ������
typedef enum _VSB_AUDI_CLASS
{
    VSB_AUDI_OTHER        = 0,   // ��������
        VSB_AUDI_A3           = 1,   // �µ�A3
        VSB_AUDI_A4L          = 2,   // �µ�A4L
        VSB_AUDI_A6L          = 3,   // �µ�A6L
        VSB_AUDI_Q3           = 4,   // �µ�Q3
        VSB_AUDI_Q5           = 5,   // �µ�Q5
        VSB_AUDI_A1           = 6,   // �µ�A1
        VSB_AUDI_A4           = 7,   // �µ�A4
        VSB_AUDI_A5           = 8,   // �µ�A5
        VSB_AUDI_A6           = 9,   // �µ�A6
        VSB_AUDI_A7           = 10,  // �µ�A7
        VSB_AUDI_A8L          = 11,  // �µ�A8L
        VSB_AUDI_Q7           = 12,  // �µ�Q7
        VSB_AUDI_S5           = 13,  // �µ�S5
        VSB_AUDI_TT           = 14,  // �µ�TT
        VSB_AUDI_100          = 15,  // �µ�100
        VSB_AUDI_200          = 16,  // �µ�200
        VSB_AUDI_S7           = 17,  // �µ�S7
        VSB_AUDI_S8           = 18,  // �µ�S8
        VSB_AUDI_100_1        = 19,   // �µ�-100-δ֪
        VSB_AUDI_200_1        = 20,   // �µ�-200-δ֪
        VSB_AUDI_A1_1         = 21,   // �µ�-A1-2014,2013,2012
        VSB_AUDI_A3_1         = 22,   // �µ�-A3-2013,2010���ʰ�
        VSB_AUDI_A3_2         = 23,   // �µ�-A3-2013������,2011,2010
        VSB_AUDI_A4_1         = 24,   // �µ�-A4-2005���,2000��ڰ�
        VSB_AUDI_A4_2         = 25,   // �µ�-A4-2007,2006���,2004���
        VSB_AUDI_A4L_1        = 26,   // �µ�-A4L-2013
        VSB_AUDI_A5_1         = 27,   // �µ�-A5-2011,2010
        VSB_AUDI_A6_1         = 28,   // �µ�-A6-1996,1995,1991
        VSB_AUDI_A6L_1        = 29,   // �µ�-A6L-2008,2007,2006,2005
        VSB_AUDI_A6L_2        = 30,   // �µ�-A6L-2011,2010,2009
        VSB_AUDI_A6L_3        = 31,   // �µ�-A6L-2014,2013,2012
        VSB_AUDI_A7_1         = 32,   // �µ�-A7-2014,2013��ȡ��,2012,2011
        VSB_AUDI_A8L_1        = 33,   // �µ�-A8L-2006
        VSB_AUDI_A8L_2        = 34,   // �µ�-A8L-2009,2008
        VSB_AUDI_A8L_3        = 35,   // �µ�-A8L-2011
        VSB_AUDI_A8L_4        = 36,   // �µ�-A8L-2013,2012
        VSB_AUDI_Q3_1         = 37,   // �µ�-Q3-2014,2013,2012
        VSB_AUDI_Q5_1         = 38,   // �µ�-Q5-2012,2010�˶�
        VSB_AUDI_Q5_2         = 39,   // �µ�-Q5-2012������,2010ԽҰ��
        VSB_AUDI_Q5_3         = 40,   // �µ�-Q5-2012��ȡ��,2011,2010,2009
        VSB_AUDI_Q5_4         = 41,   // �µ�-Q5-2013
        VSB_AUDI_Q7_1         = 42,   // �µ�-Q7-2007
        VSB_AUDI_Q7_2         = 43,   // �µ�-Q7-2014,2013
        VSB_AUDI_S7_1         = 44,   // �µ�-S7-2013
        VSB_AUDI_S8_1         = 45,   // �µ�-S8-2013
        VSB_AUDI_TT_2         = 46,   // �µ�-TT-2010,2008,2007
        VSB_AUDI_TT_3         = 47,   // �µ�-TT-2012,2011
        VSB_AUDI_TT_4         = 48,   // �µ�-TT-2013,2013,2011TTS
        VSB_AUDI_TT_1         = 49   // �µ�-TT-2008TTS
}VSB_AUDI_CLASS;

//���Դ���Ʒ������
typedef enum _VSB_MAZDA_CLASS
{
    VSB_MAZDA_OTHER         = 0,   // ��������
        VSB_MAZDA_CX5           = 1,   // ���Դ�CX5
        VSB_MAZDA_2             = 2,   // ���Դ�2
        VSB_MAZDA_3             = 3,   // ���Դ�3
        VSB_MAZDA_6             = 4,   // ���Դ�6
        VSB_MAZDA_8             = 5,   // ���Դ�8
        VSB_MAZDA_COREWING      = 6,   // ���
        VSB_MAZDA_CX7           = 7,   // ���Դ�CX7
        VSB_MAZDA_X5            = 8,   // ���Դ�X5
        VSB_MAZDA_5             = 9,   // ���Դ�5
        VSB_MAZDA_PREMACY       = 10,  // �Ͽ�������
        VSB_MAZDA_MPV           = 11,   // ���Դ�MPV
        VSB_MAZDA_CX5_1         = 12,   // ���Դ�-CX-5-2014,2013,2012���
        VSB_MAZDA_CX7_1         = 13,   // ���Դ�-CX-7-2014,2013,2011,2010
        VSB_MAZDA_2_1           = 14,   // ���Դ�-Mazda2����-2011,2009,2008,2007A
        VSB_MAZDA_3_1           = 15,   // ���Դ�-Mazda3����-2004,2002
        VSB_MAZDA_3_2           = 16,   // ���Դ�-Mazda3����-2009,2007
        VSB_MAZDA_3_3           = 17,   // ���Դ�-Mazda3����-2012,2010
        VSB_MAZDA_3_4           = 18,   // ���Դ�-Mazda3�ǳ�����-2013,2012
        VSB_MAZDA_5_1           = 19,   // ���Դ�-Mazda5-2010,2008,2007
        VSB_MAZDA_5_2           = 20,   // ���Դ�-Mazda5-2013,2012,2011
        VSB_MAZDA_6_2           = 21,   // ���Դ�-Mazda6-2006
        VSB_MAZDA_6_3           = 22,   // ���Դ�-Mazda6-2007
        VSB_MAZDA_8_1           = 23,   // ���Դ�-Mazda8-2013,2011,2010
        VSB_MAZDA_PREMACY_1     = 24,   // ���Դ�-������-2003
        VSB_MAZDA_PREMACY_2     = 25,   // ���Դ�-������-2006,2005,2004
        VSB_MAZDA_COREWING_1    = 26,   // ���Դ�-���-2012,2011,2010,2009
        VSB_MAZDA_COREWING_2    = 27,   // ���Դ�-������-2011,2010
        VSB_MAZDA_COREWING_3    = 28,   // ���Դ�-������-2012
        VSB_MAZDA_2_2           = 29,   // ���Դ�-Mazda2����(����)-2011,2010,2008
        VSB_MAZDA_6_1           = 30,   // ���Դ�-Mazda6-2004
        VSB_MAZDA_6_4           = 31   // ���Դ�-Mazda6-2014,2013,2012,2011,2010
}VSB_MAZDA_CLASS;

//ѩ������Ʒ������
typedef enum _VSB_CHEVROLET_CLASS
{
    VSB_CHEVROLET_OTHER          = 0,   // ��������
        VSB_CHEVROLET_NEWAVEO        = 1,   // ��Ψŷ
        VSB_CHEVROLET_EPICA          = 2,   // ����
        VSB_CHEVROLET_CRUZE          = 3,   // ��³��
        VSB_CHEVROLET_CAPTIVA        = 4,   // ������
        VSB_CHEVROLET_MALIBU         = 5,   // ����
        VSB_CHEVROLET_SAIL           = 6,   // ��ŷ
        VSB_CHEVROLET_CAMARO         = 7,   // ������
        VSB_CHEVROLET_LECHENG        = 8,   // �ֳ�
        VSB_CHEVROLET_LOVA           = 9,   // �ַ�
        VSB_CHEVROLET_OLDAVEO        = 10,  // �ֳ�-�ϿΨŷ
        VSB_CHEVROLET_SPARK          = 11,  // �ֳ�
        VSB_CHEVROLET_SAILSRV        = 12,   // ��ŷSRV
        VSB_CHEVROLET_LOVA_1         = 13,   // ѩ����-�ַ�-2009,2008,2007,2006
        VSB_CHEVROLET_LOVA_2         = 14,   // ѩ����-�ַ�-2010
        VSB_CHEVROLET_SPARK_1        = 15,   // ѩ����-�ֳ�-2010,2009,2006,2005,2004
        VSB_CHEVROLET_SPARK_2        = 16,   // ѩ����-�ֳ�-2010�˶���
        VSB_CHEVROLET_OLDAVEO_1      = 17,   // ѩ����-�ֳ�-2005
        VSB_CHEVROLET_OLDAVEO_2      = 18,   // ѩ����-�ֳ�-2010,2009,2008
        VSB_CHEVROLET_EPICA_1        = 19,   // ѩ����-����-2005
        VSB_CHEVROLET_EPICA_3        = 20,   // ѩ����-����-2012,2011,2010
        VSB_CHEVROLET_EPICA_4        = 21,   // ѩ����-����-2012,2011,2010�����
        VSB_CHEVROLET_EPICA_5        = 22,   // ѩ����-����-2013
        VSB_CHEVROLET_NEWAVEO_1      = 23,   // ѩ����-��Ψŷ����-2013,2012,2011
        VSB_CHEVROLET_CAPTIVA_1      = 24,   // ѩ����-������-2010,2008
        VSB_CHEVROLET_CAPTIVA_2      = 25,   // ѩ����-������-2014,2013,2012,2011
        VSB_CHEVROLET_KEMAILUO_1     = 26,   // ѩ����-������-2012,2011
        VSB_CHEVROLET_CRUZE_1        = 27,   // ѩ����-��³��-2014,2013,2012,2011,2010,2009
        VSB_CHEVROLET_SAIL_1         = 28,   // ѩ����-��ŷ����-2005
        VSB_CHEVROLET_SAIL_2         = 29,   // ѩ����-��ŷ����-2013,2011,2010
        VSB_CHEVROLET_MALIBU_1       = 30,   // ѩ����-����-2014,2013,2012
        VSB_CHEVROLET_EPICA_2        = 31   // ѩ����-����-2009,2008,2007
}VSB_CHEVROLET_CLASS;

//ѩ������Ʒ������
typedef enum _VSB_CITROEN_CLASS
{
    VSB_CITROEN_OTHER                 = 0,   // ��������
        VSB_CITROEN_C2                    = 1,   // ѩ����C2
        VSB_CITROEN_C4L                   = 2,   // ѩ����C4L
        VSB_CITROEN_C5                    = 3,   // ѩ����C5
        VSB_CITROEN_ELYSEE                = 4,   // ����������
        VSB_CITROEN_CQUATRELIANGXIANG     = 5,   // ��������
        VSB_CITROEN_CQUATRESANXIANG       = 6,   // ��������
        VSB_CITROEN_SAEAPICASSO           = 7,   // ����-�ϼ���
        VSB_CITROEN_PICASSO               = 8,   // �ϼ���
        VSB_CITROEN_CTRIOMPHE             = 9,   // ����
        VSB_CITROEN_XSARA                 = 10,  // ����
        VSB_CITROEN_SHENLONGFUKANG        = 11,  // ����
        VSB_CITROEN_CHANGANDS             = 12,   // ����DS
        VSB_CITROEN_C2_1                  = 13,   // ѩ����-C2-2012,2010,2008,2007,2006
        VSB_CITROEN_C4L_1                 = 14,   // ѩ����-C4L-2014,2013
        VSB_CITROEN_C4PICASSO_1           = 15,   // ѩ����-C4�ϼ���-2009���ʰ�
        VSB_CITROEN_C5_1                  = 16,   // ѩ����-C5-2012,2011,2010
        VSB_CITROEN_CQUATRESANXIANG_1     = 17,   // ѩ����-��������-2013,2012
        VSB_CITROEN_CQUATRELIANGXIANG_1   = 18,   // ѩ����-��������-2011,2010,2009,2008
        VSB_CITROEN_CTRIOMPHE_1           = 19,   // ѩ����-����-2010,2009,2008,2006
        VSB_CITROEN_FUKANG_1              = 20,   // ѩ����-����-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_1              = 21,   // ѩ����-����������-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_2              = 22,   // ѩ����-����������-2013,2012,2011,2010,2009,2008,2007
        VSB_CITROEN_SAEAPICASSO_1         = 23    // ѩ����-����-�ϼ���-2014
}VSB_CITROEN_CLASS;

//�ִ���Ʒ������
typedef enum _VSB_HYUNDAI_CLASS
{
    VSB_HYUNDAI_OTHER            = 0,   // ��������
        VSB_HYUNDAI_IX35             = 1,   // �ִ�IX35
        VSB_HYUNDAI_LANGDONG         = 2,   // �ʶ�
        VSB_HYUNDAI_MOINCA           = 3,   // ��Ԧ
        VSB_HYUNDAI_SHENGDA          = 4,   // ʤ��
        VSB_HYUNDAI_VERNA            = 5,   // ����
        VSB_HYUNDAI_RUIYI            = 6,   // ����
        VSB_HYUNDAI_SONATAEIGHT      = 7,   // ��������
        VSB_HYUNDAI_TUCSON           = 8,   // ;ʤ
        VSB_HYUNDAI_YUEDONG          = 9,   // �ö�
        VSB_HYUNDAI_ELANTRA          = 10,  // ������
        VSB_HYUNDAI_GRANDSANTAFE     = 11,  // ����
        VSB_HYUNDAI_COUPE            = 12,  // ����
        VSB_HYUNDAI_MATRIX           = 13,  // ����
        VSB_HYUNDAI_ACCENT           = 14,  // ������
        VSB_HYUNDAI_IX30             = 15,  // �ִ�IX30
        VSB_HYUNDAI_SONATA           = 16,  // ������
        VSB_HYUNDAI_REFINE           = 17,  // �ִ��������
        VSB_HYUNDAI_MISTRA           = 18,  // ��ͼ
        VSB_HYUNDAI_SONATAYUFENG     = 19,  // ������-����
        VSB_HYUNDAI_SANTAFE          = 20,  // �ִ�ʥ���
        VSB_HYUNDAI_HUIYI            = 21,   // ��ڻ���
        VSB_HYUNDAI_I30_1            = 22,   // �ִ�-i30-2010,2009
        VSB_HYUNDAI_IX35_1           = 23,   // �ִ�-ix35-2012,2011,2010
        VSB_HYUNDAI_YILANTE_1        = 24,   // �ִ�-������-2006,2005,2004
        VSB_HYUNDAI_YILANTE_2        = 25,   // �ִ�-������-2007����
        VSB_HYUNDAI_YILANTE_3        = 26,   // �ִ�-������-2011
        VSB_HYUNDAI_SHENGDA_1        = 27,   // �ִ�-ȫ��ʤ��-2013,2012
        VSB_HYUNDAI_MINGTU_1         = 28,   // �ִ�-��ͼ-2014,2013
        VSB_HYUNDAI_MINGYU_1         = 29,   // �ִ�-��Ԧ-2013,2011,2009
        VSB_HYUNDAI_SHENGDAFEI_1     = 30,   // �ִ�-ʥ���-δ֪
        VSB_HYUNDAI_YUXIANG_1        = 31,   // �ִ�-����-2005���ʰ�
        VSB_HYUNDAI_YUXIANG_2        = 32,   // �ִ�-����-2006,2005
        VSB_HYUNDAI_YUEDONG_1        = 33,   // �ִ�-�ö�-2010,2009,2008
        VSB_HYUNDAI_YUEDONG_2        = 34,   // �ִ�-�ö�-2012,2011
        VSB_HYUNDAI_SHENGDA_2        = 35,   // �ִ�-��ʤ��-2009,2006
        VSB_HYUNDAI_SHENGDA_3        = 36,   // �ִ�-��ʤ��-2012,2011,2010
        VSB_HYUNDAI_LANGDONG_1       = 37,   // �ִ�-�ʶ�-2013,2012
        VSB_HYUNDAI_GERUI_1          = 38,   // �ִ�-����-δ֪
        VSB_HYUNDAI_RUIYI_1          = 39,   // �ִ�-����-2014
        VSB_HYUNDAI_RUINA_1          = 40,   // �ִ�-��������-2013,2010
        VSB_HYUNDAI_RUINA_2          = 41,   // �ִ�-��������-2014,2013,2011
        VSB_HYUNDAI_RUIFENG_1        = 42,   // �ִ�-���-δ֪
        VSB_HYUNDAI_SUONATA_1        = 43,   // �ִ�-������-2008,2007,2006,2004,2003��׼��
        VSB_HYUNDAI_SUONATA_2        = 44,   // �ִ�-������-2010,2009,2008,2006,2004
        VSB_HYUNDAI_SOUNATA_3        = 45,   // �ִ�-��������-2011,2010
        VSB_HYUNDAI_WEILAKESI_1      = 46,   // �ִ�-ά����˹-2012,2010,2008,2007
        VSB_HYUNDAI_MEIJIA_1         = 47,   // �ִ�-����-δ֪
        VSB_HYUNDAI_JINKOUHUIYI_1    = 48,   // �ִ�-��ڻ���-δ֪
        VSB_HYUNDAI_TUSHENG_1        = 49,   // �ִ�-;ʤ-2005
        VSB_HYUNDAI_TUSHENG_2        = 50,   // �ִ�-;ʤ-2011,2009,2008,2006
        VSB_HYUNDAI_TUSHENG_3        = 51,   // �ִ�-;ʤ-2013
        VSB_HYUNDAI_KUPAI_1          = 52,   // �ִ�-����-δ֪
        VSB_HYUNDAI_YASHENTE_1       = 53,   // �ִ�-������-2008,2006
        VSB_HYUNDAI_YASHENTE_2       = 54,   // �ִ�-������-2011
        VSB_HYUNDAI_LINGXIANG_1      = 55,   // �ִ�-����-2009,2008
        VSB_HYUNDAI_FEISI_1          = 56    // �ִ�-��˼-2011
}VSB_HYUNDAI_CLASS;

//������Ʒ������
typedef enum _VSB_CHERY_CLASS
{
    VSB_CHERY_OTHER        = 0,   // ��������
        VSB_CHERY_A1           = 1,   // ����A1
        VSB_CHERY_A3           = 2,   // ����A3
        VSB_CHERY_EASTAR       = 3,   // ����֮��
        VSB_CHERY_FULWIN       = 4,   // ����
        VSB_CHERY_QQ           = 5,   // ����QQ
        VSB_CHERY_E5           = 6,   // ����E5
        VSB_CHERY_COWIN        = 7,   // ����
        VSB_CHERY_TIGGO        = 8,   // ��
        VSB_CHERY_A5           = 9,   // ����A5
        VSB_CHERY_S16          = 10,  // ����S16
        VSB_CHERY_YOUYA        = 11,  // ����
        VSB_CHERY_V5           = 12,  // ����V5
        VSB_CHERY_E3           = 13,   // ����E3
        VSB_CHERY_A1_1                = 14,     // ����-A1-2011,2008,2007
        VSB_CHERY_A3LIANGXIANG_1      = 15,     // ����-A3����-2012,2010,2009
        VSB_CHERY_A5_1                = 16,     // ����-A5-2009,2007,2006
        VSB_CHERY_QQ_1                = 17,     // ����-QQ-2006,2005,2004
        VSB_CHERY_QQ_2                = 18,     // ����-QQ-2010,2007,2006
        VSB_CHERY_QQ_3                = 19,     // ����-QQ-2012,2011,2010,2009,2007
        VSB_CHERY_QQ_4                = 20,     // ����-QQ-2012�˶���
        VSB_CHERY_QQ_5                = 21,     // ����-QQ-2013
        VSB_CHERY_DONGFANGZHIZI_1     = 22,     // ����-����֮��-2005,2004,2003
        VSB_CHERY_DONGFANGZHIZI_2     = 23,     // ����-����֮��-2007,2006
        VSB_CHERY_DONGFANGZHIZI_3     = 24,     // ����-����֮��CROSS-2009,2008,2007
        VSB_CHERY_YOUYA_1             = 25,     // ����-����-δ֪
        VSB_CHERY_E3_1                = 26,     // ����-����E3-2013
        VSB_CHERY_E5_1                = 27,     // ����-����E5-2014,2012,2011
        VSB_CHERY_QIYUN1_1            = 28,     // ����-����1-2010
        VSB_CHERY_QIYUN1_2            = 29,     // ����-����1-2012
        VSB_CHERY_QIYUN_1             = 30,     // ����-����-2004
        VSB_CHERY_QIYUN_2             = 31,     // ����-����-2009,2008,2007,2006
        VSB_CHERY_QIYUN2_1            = 32,     // ����-����2-2012
        VSB_CHERY_QIYUN2_2            = 33,     // ����-����2-2012������,2010
        VSB_CHERY_QIYUN3_1            = 34,     // ����-����3-2010
        VSB_CHERY_RUIHU_1             = 35,     // ����-��-2007,2006,2005
        VSB_CHERY_RUIHU_2             = 36,     // ����-��-2009,2007
        VSB_CHERY_RUIHU_3             = 37,     // ����-��-2012,2011
        VSB_CHERY_RUIHU_4             = 38,     // ����-��-2013,2012�Զ�DVVT������
        VSB_CHERY_RUIHU_5             = 39,     // ����-��-2013��Ӣ�������,2012��Ӣ��������
        VSB_CHERY_FENGYUN2SANXIANG_1  = 40,     // ����-����2����-2010
        VSB_CHERY_AIRUIZE7_1          = 41     // ����-������7-2014,2013
}VSB_CHERY_CLASS;

//������Ʒ������
typedef enum _VSB_KIA_CLASS
{
    VSB_KIA_OTHER        = 0,   // ��������
        VSB_KIA_K2           = 1,   // ����K2
        VSB_KIA_K3           = 2,   // ����K3
        VSB_KIA_K5           = 3,   // ����K5
        VSB_KIA_RIO          = 4,   // ��ŷ
        VSB_KIA_CERATO       = 5,   // ����ͼ
        VSB_KIA_SPORTAGER    = 6,   // ʨ��
        VSB_KIA_SOUL         = 7,   // ���
        VSB_KIA_ZHIPAO       = 8,   // ����
        VSB_KIA_CARENS       = 9,   // ����
        VSB_KIA_CARNIVAL     = 10,  // �λ�
        VSB_KIA_OPTIMA       = 11,  // Զ��
        VSB_KIA_OPIRUS       = 12,  // ŷ����˹
        VSB_KIA_MAXIMA       = 13,  // ǧ����
        VSB_KIA_FORTE        = 14,  // �����
        VSB_KIA_SORENTO      = 15,  // ������
        VSB_KIA_K2_1         = 16,   // ����-K2-2013,2012,2011
        VSB_KIA_K3_1         = 17,   // ����-K3-2012
        VSB_KIA_K5_1         = 18,   // ����-K5-2012,2011
        VSB_KIA_RUIOU_1      = 19,   // ����-RIO��ŷ-2009,2007
        VSB_KIA_QIANLIMA_1   = 20,   // ����-ǧ����-2004
        VSB_KIA_QIANLIMA_2   = 21,   // ����-ǧ����-2006,2005
        VSB_KIA_JIAHUA_1     = 22,   // ����-�λ�-δ֪
        VSB_KIA_XINJIALE_1   = 23,   // ����-�¼���-2011
        VSB_KIA_ZHIPAO_1     = 24,   // ����-����-2014,2012,2011,2010
        VSB_KIA_SHIPAO_1     = 25,  // ����-ʨ��-2008,2007,2005
        VSB_KIA_SHIPAO_2     = 26,  // ����-ʨ��-2011,2009
        VSB_KIA_SHIPAO_3     = 27,  // ����-ʨ��-2012
        VSB_KIA_SHIPAO_4     = 28,  // ����-ʨ��-2013
        VSB_KIA_FURUIDI_1    = 29,  // ����-�����-2012,2011,2009
        VSB_KIA_FURUIDI_2    = 30,  // ����-�����-2014
        VSB_KIA_XIUER_1      = 31,  // ����-���-2012,2010
        VSB_KIA_SUOLANTUO_1  = 32,  // ����-������-2006
        VSB_KIA_SUOLANTUO_2  = 33,  // ����-������-2012,2010,2009
        VSB_KIA_SAILATU_1    = 34,  // ����-����ͼ-2006,2005
        VSB_KIA_SAILATU_2    = 35,  // ����-����ͼ-2007
        VSB_KIA_SAILATU_3    = 36,  // ����-����ͼ-2012,2010GLS
        VSB_KIA_YUANJIAN_1   = 37   // ����-Զ��-δ֪
}VSB_KIA_CLASS;

//������Ʒ������
typedef enum _VSB_BENZ_CLASS
{
    VSB_BENZ_OTHER         = 0,   // ��������
        VSB_BENZ_C             = 1,   // ����C��
        VSB_BENZ_E             = 2,   // ����E��
        VSB_BENZ_GLK           = 3,   // ����GLK��
        VSB_BENZ_WEITING       = 4,   // ����-PINYIN
        VSB_BENZ_SPRINTER      = 5,   // ����
        VSB_BENZ_VIANO         = 6,   // Ψ��ŵ
        VSB_BENZ_M             = 7,   // ����Mϵ
        VSB_BENZ_CLK           = 8,   // ����CLKϵ
        VSB_BENZ_G             = 9,   // ����Gϵ
        VSB_BENZ_GL            = 10,  // ����GLϵ
        VSB_BENZ_R             = 11,  // ����Rϵ
        VSB_BENZ_S             = 12,  // ����Sϵ
        VSB_BENZ_A             = 13,  // ����Aϵ
        VSB_BENZ_SMART         = 14,  // ˹����(����)
        VSB_BENZ_B             = 15,  // ����Bϵ
        VSB_BENZ_SLK           = 16,  // ����SLKϵ
        VSB_BENZ_MB100         = 17,  // ����MB100
        VSB_BENZ_VITO          = 18,  // ����
        VSB_BENZ_CLS           = 19,  // ����CLSϵ
        VSB_BENZ_SL            = 20,   // ����SLϵ
        VSB_BENZ_AJI_1         = 21,   // ����-A��-2011,2009
        VSB_BENZ_AJI_2         = 22,   // ����-A��-2013
        VSB_BENZ_BJI_1         = 23,   // ����-B��-2010,2009
        VSB_BENZ_CJI_1         = 24,   // ����-C��-2010,2008,2007ʱ����
        VSB_BENZ_CJI_2         = 25,   // ����-C��-2013,2011,CGI
        VSB_BENZ_CJI_3         = 26,   // ����-C��-2013,2011ʱ����
        VSB_BENZ_EJI_1         = 27,   // ����-E��-2002
        VSB_BENZ_EJI_2         = 28,   // ����-E��-2007,2006
        VSB_BENZ_EJI_3         = 29,   // ����-E��-2013,2012,2011,2010,2009
        VSB_BENZ_EJI_4         = 30,   // ����-E��-2013,2012,2011,2010,2009ʱ����
        VSB_BENZ_GLKJI_1       = 31,   // ����-GLK��-2012,2011
        VSB_BENZ_GLKJI_2       = 32,   // ����-GLK��-2012,2011������,2008
        VSB_BENZ_GLKJI_3       = 33,   // ����-GLK��-2014,2013
        VSB_BENZ_GLJI_1        = 34,   // ����-GL��-2011
        VSB_BENZ_GLJI_2        = 35,   // ����-GL��-2011�����,2010
        VSB_BENZ_GLJI_3        = 36,   // ����-GL��-2012,2010������
        VSB_BENZ_GJI_1         = 37,   // ����-G��-2013,2010,2009
        VSB_BENZ_MB100_1       = 38,   // ����-MB100-2000
        VSB_BENZ_MLJI_1        = 39,   // ����-ML��-2006,2005
        VSB_BENZ_MLJI_2        = 40,   // ����-ML��-2010,2008
        VSB_BENZ_MLJI_3        = 41,   // ����-ML��-2014,2012
        VSB_BENZ_RJI_1         = 42,   // ����-R��-2006
        VSB_BENZ_RJI_2         = 43,   // ����-R��-2007
        VSB_BENZ_RJI_3         = 44,   // ����-R��-2014,2011,2010,2009
        VSB_BENZ_SLKJI_2       = 45,   // ����-SLK��-2006,2004
        VSB_BENZ_SLKJI_3       = 46,   // ����-SLK��-2010,2009
        VSB_BENZ_SLKJI_1       = 47,   // ����-SLK��-2011
        VSB_BENZ_SJI_1         = 48,   // ����-S��-2004
        VSB_BENZ_SJI_2         = 49,   // ����-S��-2009_Hybrid,2008,2006
        VSB_BENZ_SJI_3         = 50,   // ����-S��-2009,2008������
        VSB_BENZ_SJI_4         = 51,   // ����-S��-2012,2011,2010
        VSB_BENZ_LINGTE_1      = 52,   // ����-����-2013,2012,2011
        VSB_BENZ_WEIYANUO_1    = 53,   // ����-Ψ��ŵ-2010,2006,2004
        VSB_BENZ_WEIYANUO_2    = 54,   // ����-Ψ��ŵ-2014,2013,2012,2011
        VSB_BENZ_WEITING_1     = 55,   // ����-����-2013,2011,2010
        VSB_BENZ_KECHE_1       = 56    // ����-�ͳ�����1-A��
}VSB_BENZ_CLASS;

//˹�´���Ʒ������
typedef enum _VSB_SKODA_CLASS
{
    VSB_SKODA_OTHER            = 0,   // ��������
        VSB_SKODA_HAORUI           = 1,   // ���
        VSB_SKODA_FABIA            = 2,   // ����
        VSB_SKODA_OCTAVIA          = 3,   // ����
        VSB_SKODA_SUPERB           = 4,   // ����
        VSB_SKODA_SPACEBACK        = 5,   // 꿶�
        VSB_SKODA_RAPID            = 6,   // ���
        VSB_SKODA_YETI             = 7,    // Ұ��
        VSB_SKODA_HAORUI_1         = 8,      // ˹�´�-���-2013,2012,2010,2009
        VSB_SKODA_MINGRUI_1        = 9,      // ˹�´�-����-2009,2008,2007
        VSB_SKODA_MINGRUI_2        = 10,      // ˹�´�-����-2014,2013,2012,2011,2010
        VSB_SKODA_MINGRUI_3        = 11,      // ˹�´�-����RS-2010
        VSB_SKODA_XINRUI_1         = 12,      // ˹�´�-���-2013��ѡ��
        VSB_SKODA_JINGRUI_1        = 13,      // ˹�´�-����-2011,2009,2008
        VSB_SKODA_JINGRUI_2        = 14,      // ˹�´�-����-2014,2013,2012
        VSB_SKODA_JINGRUI_3        = 15,      // ˹�´�-����-2014,2013,2012Sport��
        VSB_SKODA_SUPAI_1          = 16,      // ˹�´�-����-2013
        VSB_SKODA_YEDI_1           = 17      // ˹�´�-Ұ��-2014,2013
}VSB_SKODA_CLASS;

//������Ʒ������
typedef enum _VSB_DONGFENG_CLASS
{
    VSB_DONGFENG_OTHER                 = 0,   // ��������
        VSB_DONGFENG_JOYEARX5              = 1,   // ����X5
        VSB_DONGFENG_LINGZHI               = 2,   // ����
        VSB_DONGFENG_JOYEARX3              = 3,   // ����X3
        VSB_DONGFENG_JOYEAR                = 4,   // ����
        VSB_DONGFENG_FENGXINGCM7           = 5,   // ����CM7
        VSB_DONGFENG_YUFENG                = 6,   // ���
        VSB_DONGFENG_FENGSHENA60           = 7,   // ����A60
        VSB_DONGFENG_FENGSHENS30           = 8,   // ����S30
        VSB_DONGFENG_FENGSHENH30CROSS      = 9,   // ����H30-CROSS
        VSB_DONGFENG_PICKUP                = 10,  // ����Ƥ��
        VSB_DONGFENG_ZHONGXINGMIANBAOCHE   = 11,  // �����������
        VSB_DONGFENG_XIAOXINGMIANBAOCHE    = 12,  // ����С�����
        VSB_DONGFENG_ZHONGXINGVAN          = 13,  // �������ͻ���
        VSB_DONGFENG_QINGXINGXIANGSHIVAN   = 14,  // ����������ʽ����
        VSB_DONGFENG_QINGZHONGXINGVAN      = 15,  // ������������ͨ����
        VSB_DONGFENG_FENGSHENMERCURY       = 16,  // ����ˮ��
        VSB_DONGFENG_SUCCE                 = 17,  // ˧��
        VSB_DONGFENG_ODIN                  = 18,  // �¶�
        VSB_DONGFENG_YUMSUN                = 19,  // ����
        VSB_DONGFENG_RUIQI                 = 20,  // ����
        VSB_DONGFENG_FENGGUANG             = 21,  // ���
        VBR_DONGFENG_C35_1                 = 22,   // ����-C35-2013
        VBR_DONGFENG_K07_1                 = 23,   // ����-K07-2008
        VBR_DONGFENG_K07_2                 = 24,   // ����-K07-2010,2006
        VBR_DONGFENG_V21_1                 = 25,   // ����-V21-2011
        VBR_DONGFENG_JIALONG_1             = 26,   // ����-�������-�ػ���
        VBR_DONGFENG_XKFG_1                = 27,   // ����-����С�����-2013
        VBR_DONGFENG_CV03_1                = 28,   // ����-����CV03-2012
        VBR_DONGFENG_KAIPUTE_1             = 29,   // ����-������-C390
        VBR_DONGFENG_DUOLIKA_1             = 30,   // ����-����-S2800
        VBR_DONGFENG_DUOLIKA_2             = 31,   // ����-����-XL�п�
        VBR_DONGFENG_DUOLIKA_3             = 32,   // ����-����-�п�
        VBR_DONGFENG_TIANJIN_1             = 33,   // ����-���-4X2�ػ���
        VBR_DONGFENG_TIANJIN_2             = 34,   // ����-���-A��
        VBR_DONGFENG_XBW_1                 = 35,   // ����-С����-�Ῠ1
        VBR_DONGFENG_XBW_2                 = 36,   // ����-С����-�Ῠ2
        VBR_DONGFENG_MENGKA_1              = 37,   // ����-�ο�-�Ῠ
        VBR_DONGFENG_FURUIKA_1             = 38,   // ����-����-�Ῠ1
        VBR_DONGFENG_RUIQI_1               = 39,   // ����-����Ƥ��-2013,2010,2009
        VBR_DONGFENG_A60_1                 = 40,   // �������-A60-2014,2012
        VBR_DONGFENG_H30_1                 = 41,   // �������-H30-Cross-2012,2011
        VBR_DONGFENG_H30_2                 = 42,   // �������-H30-Cross-2014,2013
        VBR_DONGFENG_H30_3                 = 43,   // �������-H30-2012
        VBR_DONGFENG_JINGYI_1              = 44,   // �������-����-2014_2012LV,2011������
        VBR_DONGFENG_JINGYI_2              = 45,   // �������-����-2014_2012XL,2011,2010,2009,2008,2007
        VBR_DONGFENG_JINGYI_3              = 46,   // �������-����X5-2014,2013
        VBR_DONGFENG_LINGZHI_1             = 47,   // �������-����-2004
        VBR_DONGFENG_LINGZHI_2             = 48,   // �������-����-2011,2008,2007
        VBR_DONGFENG_LINGZHI_3             = 49,   // �������-����-2011Q3��׼��,2010Q7
        VBR_DONGFENG_LINGZHI_4             = 50,   // �������-����-2014_2013M3
        VBR_DONGFENG_LINGZHI_5             = 51   // �������-����-2014_2013V3,2011M3_���ð�_������
}VSB_DONGFENG_CLASS;

//���ǵ���Ʒ������
typedef enum _VSB_BYD_CLASS
{
    VSB_BYD_OTHER         = 0,   // ��������
        VSB_BYD_F0            = 1,   // ���ǵ�F0
        VSB_BYD_F3            = 2,   // ���ǵ�F3
        VSB_BYD_F3R           = 3,   // ���ǵ�F3R
        VSB_BYD_F6            = 4,   // ���ǵ�F6
        VSB_BYD_G3            = 5,   // ���ǵ�G3
        VSB_BYD_G3R           = 6,   // ���ǵ�G3R
        VSB_BYD_G6            = 7,   // ���ǵ�G6
        VSB_BYD_L3            = 8,   // ���ǵ�L3
        VSB_BYD_M6            = 9,   // ���ǵ�M6
        VSB_BYD_S6            = 10,  // ���ǵ�S6
        VSB_BYD_SURUI         = 11,  // ����
        VSB_BYD_FOLEL         = 12,  // �ش�������
        VSB_BYD_SIRUI         = 13,  // ˼��
        VSB_BYD_MT5           = 14,  // ���ǵ�MT5(����)
        VSB_BYD_F0_1          = 15,        // ���ǵ�-F0-2013,2012,2011,2010,2009,2008
        VSB_BYD_F3R_1         = 16,        // ���ǵ�-F3R-2011,2009,2008,2007
        VSB_BYD_F6_1          = 17,        // ���ǵ�-F6-2011,2009,2008
        VSB_BYD_G3R_1         = 18,        // ���ǵ�-G3R-2011
        VSB_BYD_G6_1          = 19,        // ���ǵ�-G6-2013,2012,2011
        VSB_BYD_L3_1          = 20,        // ���ǵ�-L3-2013,2012,2011,2010
        VSB_BYD_M6_1          = 21,        // ���ǵ�-M6-2013,2011,2010
        VSB_BYD_S6_1          = 22,        // ���ǵ�-S6-2014,2013,2012,2011
        VSB_BYD_FULAIER_1     = 23,        // ���ǵ�-������-2005������
        VSB_BYD_SURUI_1       = 24        // ���ǵ�-����-2014,2013,2012
}VSB_BYD_CLASS;

//��ľ��Ʒ������
typedef enum _VSB_SUZUKI_CLASS
{
    VSB_SUZUKI_OTHER           = 0,   // ��������
        VSB_SUZUKI_ALTO            = 1,   // ��������
        VSB_SUZUKI_SCROSS          = 2,   // ��Ԧ
        VSB_SUZUKI_SWIFT           = 3,   // ����
        VSB_SUZUKI_SX4             = 4,   // ����
        VSB_SUZUKI_LINGYANG        = 5,   // ����
        VSB_SUZUKI_BEIDOUXING      = 6,   // ������
        VSB_SUZUKI_LIANAA6         = 7,   // ������-A6
        VSB_SUZUKI_LANDY           = 8,   // �˵�
        VSB_SUZUKI_SPLASH          = 9,   // ��ϲ
        VSB_SUZUKI_GRANDVITARA     = 10,  // ����ά����
        VSB_SUZUKI_JIMNY           = 11,  // ��ķ��
        VSB_SUZUKI_KAZASHI         = 12,  // ������
        VSB_SUZUKI_LIANA           = 13,   // ������
        VSB_SUZUKI_LIANA_1           = 14,     // ��ľ-����������-2012,2011,2010,2008,2007,2005
        VSB_SUZUKI_LIANA_2           = 15,     // ��ľ-����������-2013,2012,2011
        VSB_SUZUKI_BEIDOUXING_1      = 16,     // ��ľ-������-2012,2011,2010,2009,2008,2007,2005,2004��׼��
        VSB_SUZUKI_BEIDOUXING_2      = 17,     // ��ľ-������-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003
        VSB_SUZUKI_BEIDOUXING_3      = 18,     // ��ľ-������-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003������
        VSB_SUZUKI_BEIDOUXING_4      = 19,     // ��ľ-������-2013X5
        VSB_SUZUKI_JIMUNI_1          = 20,     // ��ľ-��ķ��-2011,2010,2009,2007
        VSB_SUZUKI_JIMUNI_2          = 21,     // ��ľ-��ķ��-2012
        VSB_SUZUKI_SX4_1             = 22,     // ��ľ-����SX4����-2008,2006
        VSB_SUZUKI_SX4_2             = 23,     // ��ľ-����SX4����-2010,2009
        VSB_SUZUKI_SX4_3             = 24,     // ��ľ-����SX4����-2011A,2009,2008,2007
        VSB_SUZUKI_SX4_4             = 25,     // ��ľ-����SX4����-2011B
        VSB_SUZUKI_SX4_5             = 26,     // ��ľ-����SX4����-2013,2012,2011
        VSB_SUZUKI_ALTO_1            = 27,     // ��ľ-����-2006,2001,2000,1999,1993��׼��
        VSB_SUZUKI_ALTO_2            = 28,     // ��ľ-����-2006,2004,2001,2000,1999,1993
        VSB_SUZUKI_ALTO_3            = 29,     // ��ľ-����-2013
        VSB_SUZUKI_ALTO_4            = 30,     // ��ľ-����-2014,2012,2011,2010,2009
        VSB_SUZUKI_SPLASH_1          = 31,     // ��ľ-��ϲ-2013,2012,2011
        VSB_SUZUKI_LANDY_1           = 32,     // ��ľ-�˵�-2011,2010,2007
        VSB_SUZUKI_LINGYANG_2        = 33,     // ��ľ-����-2006,2004,2003
        VSB_SUZUKI_LINGYANG_3        = 34,     // ��ľ-����-2009,2008,2007
        VSB_SUZUKI_LINGYANG_4        = 35,     // ��ľ-����-2011
        VSB_SUZUKI_LINGYANG_5        = 36,     // ��ľ-����-2012
        VSB_SUZUKI_GRANDVITARA_1     = 37,     // ��ľ-����ά����-2011,2008,2007,2006
        VSB_SUZUKI_FENGYU_1          = 38,     // ��ľ-��Ԧ-2014
        VSB_SUZUKI_SWIFT_1           = 39,     // ��ľ-����-2011_1.3L,2009,2008,2007,2005
        VSB_SUZUKI_SWIFT_2           = 40,     // ��ľ-����-2012,2011
        VSB_SUZUKI_KINGCHANG_1       = 41,     // ��ľ-������-2004
        VSB_SUZUKI_LINGYANG_1        = 42     // ��ľ-����-2002
}VSB_SUZUKI_CLASS;

//������Ʒ������
typedef enum _VSB_SGMW_CLASS
{
    VSB_SGMW_OTHER               = 0,   // ��������
        VSB_SGMW_HONGGUANG           = 1,   // ������
        VSB_SGMW_HONGGUANGS          = 2,   // ������S
        VSB_SGMW_ZHIGUANG            = 3,   // ����֮��
        VSB_SGMW_RONGGUANGS          = 4,   // �����ٹ�S
        VSB_SGMW_RONGGUANG           = 5,   // �����ٹ�
        VSB_SGMW_HONGTU              = 6,   // �����;
        VSB_SGMW_XINGWANG            = 7,   // ��������
        VSB_SGMW_YANGGUANG           = 8,   // �������
        VSB_SGMW_XIAOXUANFENG        = 9,   // ����С���
        VSB_SGMW_WULINGZHIGUANG_1    = 10,       // ����-����֮��-2010,2009��ҵ
        VSB_SGMW_WULINGZHIGUANG_2    = 11,       // ����-����֮��-2010�̳���,����
        VSB_SGMW_WULINGZHIGUANG_3    = 12,       // ����-����֮��-2010������,2008��ʽ,2007
        VSB_SGMW_XINGWANG_1          = 13,       // ����-�������-2003
        VSB_SGMW_XINGWANG_2          = 14,       // ����-�������-2009��׼
        VSB_SGMW_XINGWANG_3          = 15,       // ����-�������-2010,2009,2007,2006,2005,2004
        VSB_SGMW_HONNGUANG_1         = 16,       // ����-���-2013,2010
        VSB_SGMW_HONNGUANG_2         = 17,       // ����-���-2014,2013S
        VSB_SGMW_XIAOXUANFENG_1      = 18,       // ����-С���-2006
        VSB_SGMW_YANGGUANG_1         = 19,       // ����-���-2006,2005,2004
        VSB_SGMW_YANGGUANG_2         = 20,       // ����-���-2008,2007
        VSB_SGMW_YANGGUANG_3         = 21,       // ����-���-2009,2006,2005�ֶ���׼��
        VSB_SGMW_RONGGUANG_1         = 22,       // ����-�ٹ����-2012,2011,2008��
        VSB_SGMW_RONGGUANG_2         = 23,       // ����-�ٹ����-2012,2011,2008��׼
        VSB_SGMW_HONGTU_1            = 24        // ����-��;-2010,2009,2008,2007
}VSB_SGMW_CLASS;

//������Ʒ������
typedef enum _VSB_CHANA_CLASS
{
    VSB_CHANA_OTHER                = 0,   // ��������
        VSB_CHANA_HONOR                = 1,   // ŷŵ
        VSB_CHANA_XINGKA               = 2,   // �����ǿ�
        VSB_CHANA_ZHIXING              = 3,   // ����֮��
        VSB_CHANA_PICKUP               = 4,   // ��������С��(����Ƥ��)
        VSB_CHANA_ZHIXING2             = 5,   // ����֮��2��
        VSB_CHANA_TAURUS               = 6,   // ��ţ��
        VSB_CHANA_XINGGUANG            = 7,   // �����ǹ�
        VSB_CHANA_BENNI                = 8,   // ����
        VSB_CHANA_ALSVIN               = 9,   // ����
        VSB_CHANA_CX20                 = 10,  // ����CX20
        VSB_CHANA_CX30                 = 11,  // ����CX30
        VSB_CHANA_EADO                 = 12,  // �ݶ�
        VSB_CHANA_ZHIXINGS460          = 13,  // ����֮��S460
        VSB_CHANA_CM8                  = 14,  // ����CM8
        VSB_CHANA_XINBAO               = 15,  // �±�
        VSB_CHANA_XUNLONG              = 16,  // ѫ��
        VSB_CHANA_YUNTONG              = 17,  // ��ͨ
        VSB_CHANA_LEIMENG              = 18,  // ����
        VSB_CHANA_XINGYUN              = 19,  // ��������
        VSB_CHANA_OULIWEI              = 20,  // ŷ����
        VSB_CHANA_EADOXT               = 21,   // ����XT
        VSB_CHANA_XINGYUN_1            = 22,      // ��������-����-2004,2003,2000
        VSB_CHANA_OULIWEI_1            = 23,      // ��������-ŷ����-2013
        VSB_CHANA_YUNTONG_1            = 24,      // ��������-��ͨ-2004
        VSB_CHANA_TAURUS_1             = 25,      // ��������-��ţ��-2013,2012,2011,2010
        VSB_CHANA_LEIMENG_1            = 26,      // ��������-����-2005,2003
        VSB_CHANA_ZHIXING_1            = 27,      // ��������-����֮��-2010,2009
        VSB_CHANA_ZHIXING_2            = 28,      // ��������-����֮��-2013
        VSB_CHANA_ZHIXING_3            = 29,      // ��������-����֮��2-2009,2008
        VSB_CHANA_ZHIXING_4            = 30,      // ��������-����֮��2-2012
        VSB_CHANA_ZHIXING_5            = 31,      // ��������-����֮��S460-2010,2009
        VSB_CHANA_ZHIXING_6            = 32,      // ��������-����֮��SC6350-2003
        VSB_CHANA_PICKUP_1             = 33,      // ��������-����΢������-2013,2012
        VSB_CHANA_XINGGUANG_1          = 34,      // ��������-�����ǹ�4500-2009,2007
        VSB_CHANA_XINGGUANG_2          = 35,      // ��������-�����ǹ�4500-2012
        VSB_CHANA_HONOR_1              = 36      // ��������-����ŷŵ-2014,2012
}VSB_CHANA_CLASS;

//�����γ���Ʒ������
typedef enum _VSB_EADO_CLASS
{
    VSB_EADO_OTHER                = 0,       // ��������
        VSB_EADO_CS_1                 = 1,       // �����γ�-CS35-2014,2013,2012
        VSB_EADO_CX_1                 = 2,       // �����γ�-CX20-2011
        VSB_EADO_CX_2                 = 3,       // �����γ�-CX30����-2010
        VSB_EADO_BENBEN_1             = 4,       // �����γ�-����-2008,2007,2006
        VSB_EADO_BENBEN_2             = 5,       // �����γ�-����-2008������,2007�˶���
        VSB_EADO_BENBEN_3             = 6,       // �����γ�-����-2010
        VSB_EADO_BENBEN_4             = 7,       // �����γ�-����MINI-2011,2010
        VSB_EADO_BENBEN_5             = 8,       // �����γ�-����MINI-2012
        VSB_EADO_YUEXIANG_1           = 9,       // �����γ�-����-2011,2010,2009
        VSB_EADO_YUEXIANG_2           = 10,       // �����γ�-����-2012
        VSB_EADO_YUEXIANG_3           = 11,       // �����γ�-����V3-2013,2012
        VSB_EADO_YUEXIANG_4           = 12,       // �����γ�-����V5-2012
        VSB_EADO_YIDONG_1             = 13        // �����γ�-�ݶ�-2014,2013,2012
}VSB_EADO_CLASS;

//����Ʒ������
typedef enum _VSB_JINBEI_CLASS
{
    VSB_JINBEI_OTHER           = 0,   // ��������
        VSB_JINBEI_GRACE           = 1,   // �𱭸���˹
        VSB_JINBEI_HIACE           = 2,   // �𱭺�ʨ
        VSB_JINBEI_HAIXING         = 3,   // ����
        VSB_JINBEI_BADAO           = 4,   // �𱭰Ե�
        VSB_JINBEI_LINGQI          = 5,   // ����
        VSB_JINBEI_JINQI           = 6,   // ����
        VSB_JINBEI_LINGCHI         = 7,   // ���
        VSB_JINBEI_QIYUN           = 8,   // ����
        VSB_JINBEI_ZHISHANG_1      = 9,       // ��-����S30-2014,2013,2012
        VSB_JINBEI_HAIXING_1       = 10,       // ��-����-2012
        VSB_JINBEI_HAIXING_2       = 11,       // ��-����-2012A7�ػ���,2011
        VSB_JINBEI_HIACE_1         = 12,       // ��-��ʨ-2008
        VSB_JINBEI_HIACE_2         = 13,       // ��-��ʨ-2013,2011,2010
        VSB_JINBEI_HIACE_3         = 14,       // ��-��ʨ-2013������,2011����,2008��׼��
        VSB_JINBEI_JINDIAN_1       = 15,       // ��-���-2009
        VSB_JINBEI_GRACE_1         = 16,       // ��-����˹MPV-2011,2008,2007
        VSB_JINBEI_GRACE_2         = 17,       // ��-����˹MPV-2011���������,2010,2009,2007��׼9��
        VSB_JINBEI_BADAO_1         = 18       // ��-�Ե�SUV-2011,2008

}VSB_JINBEI_CLASS;

//������Ʒ������
typedef enum _VSB_GEELY_CLASS
{
    VSB_GEELY_OTHER              = 0,   // ��������
        VSB_GEELY_EC7                = 1,   // ����ۺ�EC7
        VSB_GEELY_EC8                = 2,   // ����ۺ�EC8
        VSB_GEELY_SC3                = 3,   // ����SC3
        VSB_GEELY_SC5RV              = 4,   // ����SC5-RV
        VSB_GEELY_SC6                = 5,   // ����SC6
        VSB_GEELY_JINGYING           = 6,   // ��ӥ
        VSB_GEELY_JINGGANG           = 7,   // ���
        VSB_GEELY_SX7                = 8,   // ����SX7
        VSB_GEELY_HAOQING            = 9,   // ����
        VSB_GEELY_MEIRI              = 10,  // ����
        VSB_GEELY_YINGLUNSC7         = 11,  // Ӣ��SC7
        VSB_GEELY_PANDA              = 12,  // ��è
        VSB_GEELY_YUANJING           = 13,  // Զ��
        VSB_GEELY_ZIYOUJIAN          = 14   // ���ɽ�
}VSB_GEELY_CLASS;

//������Ʒ������
typedef enum _VSB_MITSUBISHI_CLASS
{
    VSB_MITSUBISHI_OTHER                 = 0,   // ��������
        VSB_MITSUBISHI_GALANT                = 1,   // ����
        VSB_MITSUBISHI_ZINGER                = 2,   // ���
        VSB_MITSUBISHI_LANCER                = 3,   // ��ɪ
        VSB_MITSUBISHI_LANCEREX              = 4,   // ����
        VSB_MITSUBISHI_PAJERO                = 5,   // ������
        VSB_MITSUBISHI_PAJEROSPORT           = 6,   // ������-����
        VSB_MITSUBISHI_JINGXUANASX           = 7,   // ����ASX
        VSB_MITSUBISHI_GRANDIS               = 8,   // ���������
        VSB_MITSUBISHI_OUTLANDER             = 9,   // ŷ����
        VSB_MITSUBISHI_QINXINGYUEYE          = 10,  // ��������ԽҰ
        VSB_MITSUBISHI_GTO                   = 11,  // ����GTO
        VSB_MITSUBISHI_SOVERAN               = 12,  // ��������
        VSB_MITSUBISHI_LIONVEL               = 13,  // ��������
        VSB_MITSUBISHI_HAFEISIMBO            = 14,   // ��������
        VSB_MITSUBISHI_LANCEREX_1            = 15,   // ����-��������-2012,2011,2010
        VSB_MITSUBISHI_JINGXUAN_1            = 16,   // ����-����-2012,2011
        VSB_MITSUBISHI_ZINGER_1              = 17,   // ����-���-2011,2009
        VSB_MITSUBISHI_PAJERO_1              = 18,   // ����-������-2004���
        VSB_MITSUBISHI_PAJERO_2              = 19,   // ����-������-2004���
        VSB_MITSUBISHI_PAJERO_3              = 20,   // ����-������-2010���
        VSB_MITSUBISHI_PAJEROSPORT_1         = 21,   // ����-�����޾���-2011
        VSB_MITSUBISHI_GALANT_1              = 22,   // ����-����-2009
        VSB_MITSUBISHI_GALANDI_1             = 23,   // ����-������-2007
        VSB_MITSUBISHI_GALANDI_2             = 24,   // ����-������-2010
        VSB_MITSUBISHI_OUTLANDER_1           = 25,   // ����-ŷ����-2012,2011,2010
        VSB_MITSUBISHI_OUTLANDER_2           = 26,   // ����-ŷ����-2013
        VSB_MITSUBISHI_LINGYUE_1             = 27,   // ����-����-δ֪
        VSB_MITSUBISHI_LANCER_1              = 28   // ����-��ɪ-2010
}VSB_MITSUBISHI_CLASS;

//�׿���˹��Ʒ������
typedef enum _VSB_LEXUS_CLASS
{
    VSB_LEXUS_OTHER             = 0,   // ��������
        VSB_LEXUS_ES                = 1,   // �׿���˹ES
        VSB_LEXUS_CT                = 2,   // �׿���˹CT
        VSB_LEXUS_RX                = 3,   // �׿���˹RX
        VSB_LEXUS_IS                = 4,   // �׿���˹IS
        VSB_LEXUS_LX                = 5,   // �׿���˹LX
        VSB_LEXUS_GS                = 6,   // �׿���˹GS
        VSB_LEXUS_GX                = 7,   // �׿���˹GX
        VSB_LEXUS_LS                = 8,    // �׿���˹LS
        VSB_LEXUS_CT_1              = 9,   // �׿���˹-CT-2013,2012,2011
        VSB_LEXUS_ES_1              = 10,   // �׿���˹-ES-1994
        VSB_LEXUS_ES_2              = 11,   // �׿���˹-ES-2010,2009,2006
        VSB_LEXUS_ES_3              = 12,   // �׿���˹-ES-2013,2012
        VSB_LEXUS_GS_1              = 13,   // �׿���˹-GS-2011,2010,2009,2008,2005
        VSB_LEXUS_GX_1              = 14,   // �׿���˹-GX-2012,2010
        VSB_LEXUS_IS_1              = 15,   // �׿���˹-IS-2011
        VSB_LEXUS_LS_1              = 16,   // �׿���˹-LS-1994
        VSB_LEXUS_LS_2              = 17,   // �׿���˹-LS-2005,2004
        VSB_LEXUS_LS_3              = 18,   // �׿���˹-LS-2009,2007,2006
        VSB_LEXUS_LX_1              = 19,   // �׿���˹-LX-2013,2012
        VSB_LEXUS_RX_1              = 20,   // �׿���˹-RX-2011,2010,2009
        VSB_LEXUS_RX_2              = 21,   // �׿���˹-RX-2013,2012
        VSB_LEXUS_RX_3              = 22   // �׿���˹-RX-2007
}VSB_LEXUS_CLASS;

//������Ʒ������
typedef enum _VSB_ROEWE_CLASS
{
    VSB_ROEWE_OTHER              = 0,   // ��������
        VSB_ROEWE_350                = 1,   // ����350
        VSB_ROEWE_550                = 2,   // ����550
        VSB_ROEWE_W5                 = 3,   // ����W5
        VSB_ROEWE_950                = 4,   // ����950
        VSB_ROEWE_750                = 5,   // ����750
        VSB_ROEWE_350_1              = 6,   // ����-350-2011Ѹ�ǰ�,2010
        VSB_ROEWE_350_2              = 7,   // ����-350-2014,2013,2012,2011
        VSB_ROEWE_550_1              = 8,   // ����-550-2012,2010,2009,2008
        VSB_ROEWE_750_1              = 9,   // ����-750-2009,2008,2007,2006
        VSB_ROEWE_750_2              = 10,  // ����-750-2012,2011
        VSB_ROEWE_950_1              = 11   // ����-950-2012
}VSB_ROEWE_CLASS;


//������Ʒ������
typedef enum _VSB_HAIMA_CLASS
{
    VSB_HAIMA_OTHER               = 0,   // ��������
        VSB_HAIMA_PREMARIN            = 1,   // ������
        VSB_HAIMA_S7                  = 2,   // ����S7
        VSB_HAIMA_PRINCE              = 3,   // ��������
        VSB_HAIMA_CUPID               = 4,   // ����2-�����
        VSB_HAIMA_HATCHBACK           = 5,   // ����3-����
        VSB_HAIMA_KNIGHT              = 6,   // ��ʿ
        VSB_HAIMA_HAPPIN              = 7,   // ������
        VSB_HAIMA_FAMILY              = 8,   // ������
        VSB_HAIMA_M3                  = 9,    // ����M3
        VSB_HAIMA_CUPID_1             = 10,   // ����-�����-2012,2011,2010
        VSB_HAIMA_PREMARIN_1          = 11,   // ����-������-2007
        VSB_HAIMA_PREMARIN_2          = 12,   // ����-������-2012,2010
        VSB_HAIMA_HATCHBACK_1         = 13,   // ����-����-2010,2009
        VSB_HAIMA_HAPPIN_1            = 14,   // ����-������-2010,2009,2008,2007,2004
        VSB_HAIMA_HAPPIN_2            = 15,   // ����-������-2012,2011
        VSB_HAIMA_M3_1                = 16,   // ����-����3-2010,2008,2007
        VSB_HAIMA_FAMILY_1            = 17,   // ����-������-2007,2006
        VSB_HAIMA_FAMILY_2            = 18,   // ����-������-2010,2009,2008
        VSB_HAIMA_FAMILY_3            = 19,   // ����-������-2011
        VSB_HAIMA_FAMILY_4            = 20,   // ����-������-2014,2013,2012
        VSB_HAIMA_KNIGHT_1            = 21,   // ����-��ʿ-2013_2012A,2011,2010
        VSB_HAIMA_KNIGHT_2            = 22,   // ����-��ʿ-2013_2012B
        VSB_HAIMA_NEWHONGDA_1         = 23,   // �������ó�-�º��-2009
        VSB_HAIMA_NEWHONDGA_2         = 24,   // �������ó�-�º��-2012
        VSB_HAIMA_PRINCE_1            = 25,   // �������ó�-��������-2010
        VSB_HAIMA_RONGDA_1            = 26   // �������ó�-�ٴ�-2012

}VSB_HAIMA_CLASS;

//������Ʒ������
typedef enum _VSB_GREATWALL_CLASS
{
    VSB_GREATWALL_OTHER               = 0,   // ��������
        VSB_GREATWALL_SING                = 1,   // ��Ӱ
        VSB_GREATWALL_SAIJUN              = 2,   // ��
        VSB_GREATWALL_HAVAL               = 3,   // ����
        VSB_GREATWALL_SAFE                = 4,   // ��
        VSB_GREATWALL_SAIKU               = 5,   // ���
        VSB_GREATWALL_SAILING             = 6,   // ����
        VSB_GREATWALL_KINGDEER            = 7,   // ��϶�
        VSB_GREATWALL_DEER                = 8,   // �϶�
        VSB_GREATWALL_WINGLE              = 9,   // �翥
        VSB_GREATWALL_COOLBEAR            = 10,  // ����
        VSB_GREATWALL_LINGAO              = 11,  // ���
        VSB_GREATWALL_CROSS               = 12,  // ����
        VSB_GREATWALL_GWPERI              = 13,  // ����
        VSB_GREATWALL_COWRY               = 14,  // ����
        VSB_GREATWALL_M4                  = 15,   // ����M4
        VSB_GREATWALL_LINGAO_1            = 16,   // ����-���-2010
        VSB_GREATWALL_HAVAL_1             = 17,   // ����-����H3-2010,2009
        VSB_GREATWALL_HAVAL_2             = 18,   // ����-����H3-2012,2010,2009�����
        VSB_GREATWALL_HAVAL_3             = 19,   // ����-����H5-2012,2011,2010
        VSB_GREATWALL_HAVAL_4             = 20,   // ����-����H5-2012,2011,2010�̾�������
        VSB_GREATWALL_HAVAL_5             = 21,   // ����-����H5-2012������
        VSB_GREATWALL_HAVAL_6             = 22,   // ����-����H5-2014,2013
        VSB_GREATWALL_HAVAL_8             = 23,   // ����-����H6-2014,2013���
        VSB_GREATWALL_HAVAL_9             = 24,   // ����-����M2-2010
        VSB_GREATWALL_HAVAL_10            = 25,   // ����-����M2-2013,2012
        VSB_GREATWALL_HAVAL_11            = 26,   // ����-����M4-2012
        VSB_GREATWALL_HAVAL_12            = 27,   // ����-������-2011
        VSB_GREATWALL_CROSS_1             = 28,   // ����-����-2009,2008
        VSB_GREATWALL_CROSS_2             = 29,   // ����-����CROSS-2011,2009
        VSB_GREATWALL_JINGLING_1          = 30,   // ����-����-δ֪
        VSB_GREATWALL_SING_1              = 31,   // ����-��Ӱ-2003
        VSB_GREATWALL_SAIKU_1             = 32,   // ����-���-2004
        VSB_GREATWALL_SAILING_1           = 33,   // ����-����-δ֪
        VSB_GREATWALL_DIER_1              = 34,   // ����-�϶�-δ֪
        VSB_GREATWALL_COOLBEAR_1          = 35,   // ����-����-2010,2009
        VSB_GREATWALL_KINGDEER_1          = 36,   // ����-��϶�-2008,2007,2004,2003
        VSB_GREATWALL_GREATWALL_1         = 37,   // ����-����C20R-2013,2011
        VSB_GREATWALL_GREATWALL_2         = 38,   // ����-����C30-2010
        VSB_GREATWALL_GREATWALL_3         = 39,   // ����-����C30-2012
        VSB_GREATWALL_GREATWALL_4         = 40,   // ����-����C30-2013
        VSB_GREATWALL_GREATWALL_5         = 41,   // ����-����C50-2013,2012
        VSB_GREATWALL_GREATWALL_6         = 42,   // ����-����V80-2013,2012,2010,2009,2008
        VSB_GREATWALL_WINGLE_1            = 43,   // ����-�翥3-2011,2010,2007,2006
        VSB_GREATWALL_WINGLE_2            = 44,   // ����-�翥5-2014,2012,2011,2009
        VSB_GREATWALL_HAVAL_7             = 45   // ����-����H6-2013,2012,2011
}VSB_GREATWALL_CLASS;

//������Ʒ������
typedef enum _VSB_DS_CLASS
{
    VSB_DS_OTHER                      = 0,          // ��������
        VSB_DS_KUBO_1                     = 1,          // ����-�Ძ-2011,2010,2009,2008
        VSB_DS_KUWEI_1                    = 2,          // ����-����-2011,2010,2009
        VSB_DS_KUWEI_2                    = 3           // ����-����-2013
}VSB_DS_CLASS;

//·����Ʒ������
typedef enum _VSB_LANDROVER_CLASS
{
    VSB_LANDROVER_OTHER              = 0,   // ��������
        VSB_LANDROVER_FAXIAN_1           = 1,   // ·��-����-2005,2004
        VSB_LANDROVER_FAXIAN_2           = 2,   // ·��-����-2013,2011,2010
        VSB_LANDROVER_LANSHENG_1         = 3,   // ·��-��ʤ-2012,2011,2010
        VSB_LANDROVER_LANSHENG_2         = 4,   // ·��-��ʤ����-2014,2013,2012,2011
        VSB_LANDROVER_LANSHENG_3         = 5,   // ·��-��ʤ�˶���-2013,2012,2011,2010
        VSB_LANDROVER_LANSHENG_4         = 6,   // ·��-��ʤ�˶���-2013Ԧ��������
        VSB_LANDROVER_SXZ_1              = 7   // ·��-������2��-2014,2013,2011
}VSB_LANDROVER_CLASS;

//�����Ʒ������
typedef enum _VSB_MG_CLASS
{
    VSB_MG_OTHER             = 0,  // ��������
        VSB_MG_3SW_1             = 1,  // MG-MG-3SW-2009,2008
        VSB_MG_MG3_1             = 2,  // MG-MG3-2013,2012,2011
        VSB_MG_MG5_1             = 3,  // MG-MG5-2014,2013,2012
        VSB_MG_MG6_1             = 4,  // MG-MG6����-2012,2011
        VSB_MG_MG7_1             = 5,  // MG-MG7-2010,2009,2008,2007
}VSB_MG_CLASS;

//һ����Ʒ������
typedef enum _VSB_FAW_CLASS
{
    VSB_FAW_OTHER                                       = 0,    // ��������
        VSB_FAW_501_1						                = 1,	//һ��-501-�Ῠ
        VSB_FAW_N3_1						                = 2,	//һ��-N3+����-2006
        VSB_FAW_N3_2						                = 3,	//һ��-N3+����-2008
        VSB_FAW_JIABAO_1					                = 4,	//һ��-�ѱ�����-2011T50,T57
        VSB_FAW_JIABAO_2									= 5,	//һ��-�ѱ����-2000
        VSB_FAW_JIABAO_3									= 6,	//һ��-�ѱ����-2006
        VSB_FAW_JIABAO_4									= 7,	//һ��-�ѱ����-2012,2011V50���ʰ�
        VSB_FAW_JIABAO_5									= 8,	//һ��-�ѱ����-2012,2011V70
        VSB_FAW_JIABAO_6									= 9,	//һ��-�ѱ����-2013,2012,2011V52ʵ����
        VSB_FAW_JIABAO_7									= 10,	//һ��-�ѱ����-2014,2013V80
        VSB_FAW_XIALI_1										= 11,	//һ��-����-1999,1997
        VSB_FAW_XIALI_2										= 12,	//һ��-����2000-2003,2002
        VSB_FAW_XIALI_3										= 13,	//һ��-����A+-2011,2010,2006,2005
        VSB_FAW_XIALI_4										= 14,	//һ��-����N3-2012
        VSB_FAW_XIALI_5										= 15,	//һ��-����N5-2014,2013,2011,2010,2009
        VSB_FAW_XIALI_6										= 16,	//һ��-����N7-2013
        VSB_FAW_AOWEI_1										= 17,	//һ��-����J5P-2005,2004,2003
        VSB_FAW_AOWEI_2										= 18,	//һ��-����J5P-4X2������ǣ��,��ж��
        VSB_FAW_AOWEI_3										= 19,	//һ��-����J5P-4X2ǣ��,ж����
        VSB_FAW_AOWEI_4										= 20,	//һ��-����J5P-6X6ԽҰ��ж��
        VSB_FAW_AOXING_1									= 21,	//һ��-����-2004
        VSB_FAW_WEILE_1										= 22,	//һ��-����-2004
        VSB_FAW_WEILE_2										= 23,	//һ��-����-2008,2007
        VSB_FAW_WEIZI_1										= 24,	//һ��-����-2004
        VSB_FAW_WEIZHI_1									= 25,	//һ��-��־V2-2012�ֶ�CROSS
        VSB_FAW_WEIZHI_2									= 26,	//һ��-��־V2-2012�Զ�CROSS,2010
        VSB_FAW_WEIZHI_3									= 27,	//һ��-��־V5-2013,2012
        VSB_FAW_WEIZHI_4									= 28,	//һ��-��־����-2009,2008,2007
        VSB_FAW_WEIZHI_5									= 29,	//һ��-��־����-2011
        VSB_FAW_XIAOJIEFANG_1							    = 30,	//һ��-С���-90,109�����Ῠ
        VSB_FAW_HANWEI_1									= 31,	//һ��-����J5M-4X4�ػ���
        VSB_FAW_HANWEI_2									= 32,	//һ��-����J5M-6X6ǣ��,6X4��ж��
        VSB_FAW_HANWEI_3									= 33,	//һ��-����J5M-8X8��ж��
        VSB_FAW_XINDAWEI_1								    = 34,	//һ��-�´���-2010
        VSB_FAW_XINHANWEI_1								    = 35,	//һ��-�º���-2011
        VSB_FAW_SENYA_1										= 36,	//һ��-ɭ��M80-2012,2011,2009
        VSB_FAW_TENGWEI_1								    = 37,	//һ��-����L5M-�ؿ�
        VSB_FAW_JIEFANG_1									= 38,	//һ��-���J4R-A��
        VSB_FAW_JIEFANG_2									= 39,	//һ��-���J4R-��ж��,ǣ��
        VSB_FAW_JIEFANG_3									= 40,	//һ��-���J6-2004
        VSB_FAW_JIEFANG_4									= 41,	//һ��-���J6-�ؿ�
        VSB_FAW_JIEFANG_5									= 42,	//һ��-���J6L-�п�
        VSB_FAW_JIEFANG_6									= 43,	//һ��-���L5-A��
        VSB_FAW_SAILONG_1									= 44,	//һ��-����-�п�
        VSB_FAW_JUNWEI_1									= 45,	//һ��-����J5K-�п�
        VSB_FAW_B50_1									    = 46,	//һ��-����B50-2012,2011,2009
        VSB_FAW_B50_2									    = 47	//һ��-����B50-2013
}VSB_FAW_CLASS;


//������Ʒ������
typedef enum _VSB_SAICMOTOR_CLASS
{
    VSB_SAICMOTOR_OTHER               = 0,    // ��������
        VSB_HONGYAN_JIESHI_1              = 1,    // ������ά�º���-��ʨ-2012
        VSB_DATONG_V80_1                  = 2     // �����ͨ-V80-2014,2013,2012,2011
}VSB_SAICMOTOR_CLASS;

//��������Ʒ������
typedef enum _VSB_SOUEAST_CLASS
{
    VSB_SOUEAST_OTHER                 = 0,    // ��������
        VSB_SOUEAST_V3_1                  = 1,    // ����-V3����-2011��ֵ�Ҹ���,2010,2009,2008
        VSB_SOUEAST_V3_2                  = 2,    // ����-V3����-2012
        VSB_SOUEAST_V3_3                  = 3,    // ����-V3����-2012�콢��,2011,2010�·�ɰ�
        VSB_SOUEAST_V3_4                  = 4,    // ����-V3����-2012��ɰ�
        VSB_SOUEAST_V5_1                  = 5,    // ����-V5����-2014,2013,2012
        VSB_SOUEAST_XIWANG_1              = 6,    // ����-ϣ��-2011,2010
        VSB_SOUEAST_DELIKA_1              = 7,    // ����-����-2003,2002
        VSB_SOUEAST_DELIKA_2              = 8,    // ����-����-2005
        VSB_SOUEAST_DELIKA_3              = 9,    // ����-����-2008
        VSB_SOUEAST_DELIKA_4              = 10,    // ����-����-2009
        VSB_SOUEAST_LINGSHUAI_1           = 11,    // ����-��˧-2005,2004GLXi
        VSB_SOUEAST_FULIKA_1              = 12,    // ����-����-2005
        VSB_SOUEAST_FULIKA_2              = 13    // ����-����-2007
}VSB_SOUEAST_CLASS;


//��������Ʒ������
typedef enum _VSB_ZTE_CLASS
{
    VSB_ZTE_OTHER                     = 0,        // ��������
        VSB_ZTE_WEIHU_1                   = 1,        // ����-����-2012,2010
        VSB_ZTE_WEIHU_2                   = 2,        // ����-����TUV-2010,2006
        VSB_ZTE_WUXIAN_1                  = 3,        // ����-����-2008
        VSB_ZTE_WUXIAN_2                  = 4         // ����-����-2012,2011,2010,2009
}VSB_ZTE_CLASS;


//�л�����Ʒ������
typedef enum _VSB_ZHONGHUA_CLASS
{
    VSB_ZHONGHUA_OTHER                = 0,    // ��������
        VSB_ZHONGHUA_H230_1               = 1,   // �л�-H230-2012
        VSB_ZHONGHUA_H320_1               = 2,   // �л�-H320-2012
        VSB_ZHONGHUA_H330_1               = 3,   // �л�-H330-2013
        VSB_ZHONGHUA_H530_1               = 4,   // �л�-H530-2012,2011
        VSB_ZHONGHUA_V5_1                 = 5,   // �л�-V5-2012,2011
        VSB_ZHONGHUA_ZUNCHI_1             = 6,   // �л�-���-2004
        VSB_ZHONGHUA_ZUNCHI_2             = 7,   // �л�-���-2005,2003
        VSB_ZHONGHUA_KUBAO_1              = 8,   // �л�-�ᱦ-2007
        VSB_ZHONGHUA_JUNJIE_1             = 9,   // �л�-����-2010,2009,2008,2007,2006
        VSB_ZHONGHUA_JUNJIE_2             = 10,   // �л�-����-2012,2011
        VSB_ZHONGHUA_JUNJIECROSS_1        = 11,   // �л�-����cross-2010,2009
        VSB_ZHONGHUA_JUNJIEFRV_1          = 12,   // �л�-����FRV-2009,2008
        VSB_ZHONGHUA_JUNJIEFRV_2          = 13,   // �л�-����FRV-2010
        VSB_ZHONGHUA_JUNJIEFSV_1          = 14,   // �л�-����FSV-2009
        VSB_ZHONGHUA_JUNJIEFSV_2          = 15,   // �л�-����FSV-2010
        VSB_ZHONGHUA_JUNJIEFSV_3          = 16   // �л�-����FSV-2011
}VSB_ZHONGHUA_CLASS;


//�й�������Ʒ������
typedef enum _VSB_CNHTC_CLASS
{
    VSB_CNHTC_OTHER                   = 0,    // ��������
        VSB_CNHTC_HOKA_2                  = 1,      // �й�����-HOKA-ǣ��,��ж��
        VSB_CNHTC_HOWO_1                  = 2,      // �й�����-HOWO-A7
        VSB_CNHTC_HOWO_2                  = 3,      // �й�����-HOWO-T7H
        VSB_CNHTC_HOWO_3                  = 4,      // �й�����-HOWO-�Ῠ
        VSB_CNHTC_HOWO_4                  = 5,      // �й�����-HOWO�ؿ�-ǣ��
        VSB_CNHTC_HOWO_5                  = 6,      // �й�����-HOWO�ؿ�-��ж��A
        VSB_CNHTC_HOWO_6                  = 7,      // �й�����-HOWO�ؿ�-��ж��B
        VSB_CNHTC_HOWO_7                  = 8,      // �й�����-HOWO�ؿ�-�ػ���A
        VSB_CNHTC_HOWO_8                  = 9,      // �й�����-HOWO�ؿ�-�ػ���C
        VSB_CNHTC_SITAIERWANG_1           = 10,      // �й�����-˹̫����-ǣ��A,�ػ���,���賵
        VSB_CNHTC_HAOHAN_1                = 11,      // �й�����-���-A��
        VSB_CNHTC_HAOYUN_1                = 12,      // �й�����-����-ǣ��B,�ػ���,��ж��
        VSB_CNHTC_JINWANGZI_1             = 13,      // �й�����-�������ؿ�-ǣ��B
        VSB_CNHTC_HOKA_1                  = 14      // �й�����-HOKA-H7
}VSB_CNHTC_CLASS;

//��ͨ��Ʒ������
typedef enum _VSB_ZHONGTONG_CLASS
{
    VSB_ZHONGTONG_OTHER               = 0,  // ��������
        VSB_ZHONGTONG_KAICHI_1            = 1,  // ��ͨ�ͳ�-����A-A��
        VSB_ZHONGTONG_LINGYU_1            = 2,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGXIU_1           = 3,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGHANG_1          = 4,  // ��ͨ�ͳ�-�캽-A��
        VSB_ZHONGTONG_SHIJI_1             = 5,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_KAIXUAN_1           = 6,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGYUN_1           = 7,  // ��ͨ�ͳ�-����A-A��
        VSB_ZHONGTONG_YANGGUANG_1         = 8  // ��ͨ�ͳ�-����-A��
}VSB_ZHONGTONG_CLASS;


//������Ʒ������
typedef enum _VSB_JIULONG_CLASS
{
    VSB_JIULONG_OTHER                 = 0,    // ��������
        VSB_JIULONG_JIULONGA5_1           = 1,    // ����-����A5-2011
}VSB_JIULONG_CLASS;

//��̩��Ʒ������
typedef enum _VSB_ZOTYE_CLASS
{
    VSB_ZOTYE_OTHER                  = 0,       // ��������
        VSB_ZOTYE_2008_2                  = 1,      // ��̩-2008-2011,2010,2008
        VSB_ZOTYE_5008_1                  = 2,      // ��̩-5008-2013,2011,2010,2008
        VSB_ZOTYE_Z300_1                  = 3,      // ��̩-Z300-2013,2012
        VSB_ZOTYE_2008_1                  = 4      // ��̩-2008-2007
}VSB_ZOTYE_CLASS;

//��ά����Ʒ������
typedef enum _VSB_NAVECO_CLASS
{
    VSB_NAVECO_OTHER                  = 0,       // ��������
        VSB_NAVECO_Daily_1                = 1,     // ��ά��-Daily-2006,2004,2003
        VSB_NAVECO_Power_1                = 2,     // ��ά��-Power-Daily
        VSB_NAVECO_Turbo_1                = 3,     // ��ά��-Turbo-Daily-2014,2012,2011
        VSB_NAVECO_Venice_1               = 4,     // ��ά��-Venice-2011,2008
        VSB_NAVECO_BAODI_1                = 5,     // ��ά��-����-2012,2009
        VSB_NAVECO_DEYIHUOCHE_1           = 6,     // ��ά��-�������-2011
        VSB_NAVECO_DULING_1               = 7     // ��ά��-����-2010,2009,2007
}VSB_NAVECO_CLASS;

//��ʱ����Ʒ������
typedef enum _VSB_PORSCHE_CLASS
{
    VSB_PORSCHE_OTHER                 = 0,    // ��������
        VBR_PORSCHE_PANAMERA_1            = 1,    // ��ʱ��-panamera-2013,2012,2010
        VBR_PORSCHE_CAYENNE_1             = 2,    // ��ʱ��-����Cayenne-2014,2013,2011,2010
}VSB_PORSCHE_CLASS;


//����˹����Ʒ������
typedef enum _VSB_CHRYSLER_CLASS
{
    VSB_CHRYSLER_OTHER                = 0,    // ��������
        VSB_CHRYSLER_300C_1               = 1,   // ����˹��-300C-2007,2006,2004
        VSB_CHRYSLER_PTMANBUZHE_1         = 2,   // ����˹��-PT������-2007
}VSB_CHRYSLER_CLASS;

//����������Ʒ������
typedef enum _VSB_CADILLAC_CLASS
{
    VSB_CADILLAC_OTHER                = 0,    // ��������
        VSB_CADILLAC_ATS_1                = 1,   // ��������-ATS-2014
        VSB_CADILLAC_CTS_1                = 2,   // ��������-CTS-2012
        VSB_CADILLAC_CTS_3                = 3,   // ��������-CTS-2012��Ӣ�˶���,2011,2010,2009,2008
        VSB_CADILLAC_SLS_1                = 4,   // ��������-SLS����-2007,2006
        VSB_CADILLAC_SLS_2                = 5,   // ��������-SLS����-2012,2011,2010
        VSB_CADILLAC_SRX_1                = 6,   // ��������-SRX-2012,2011,2010,2009
        VSB_CADILLAC_CTS_2                = 7,   // ��������-CTS-2012,2009CTS
        VSB_CADILLAC_KAILEIDE_1           = 8   // ��������-���׵�-2011,2010,2008,2007,2006
}VSB_CADILLAC_CLASS;


//����KAMA��Ʒ������
typedef enum _VSB_KAMA_CLASS
{
    VSB_KAMA_OTHER                    = 0,       // ��������
        VSB_KAMA_QINGKA_2                 = 1,       // ����KAMA-����-�ῨD
        VSB_KAMA_FULAIKA_1                = 2,       // ����KAMA-������-�ῨA
        VSB_KAMA_JINYUNKA_1               = 3,       // ����KAMA-���˿�-�Ῠ
        VSB_KAMA_JUNWEIKA_1               = 4,       // ����KAMA-��������-2014,2011
        VSB_KAMA_QINGKA_1                 = 5       // ����KAMA-����-�ῨC
}VSB_KAMA_CLASS;

//������Ʒ������
typedef enum _VSB_LIFAN_CLASS
{
    VSB_LIFAN_OTHER                   = 0,      // ��������
        VSB_LIFAN_320_1                   = 1,      // ����-320-2012,2011,2009
        VSB_LIFAN_520_1                   = 2,      // ����-520-2007,2006
        VSB_LIFAN_520_2                   = 3,      // ����-520-2013,2011,2010,2008
        VSB_LIFAN_620_1                   = 4,      // ����-620-2012,2010,2009,2008
        VSB_LIFAN_X60_1                   = 5,      // ����-X60-2013,2012,2011
        VSB_LIFAN_FENGSHUN_1              = 6      // ����-��˳-2011
}VSB_LIFAN_CLASS;


//������Ʒ������
typedef enum _VSB_BEIJING_CLASS
{
    VSB_BEIJING_OTHER                 = 0,      // ��������
        VSB_BEIJING_E_1                   = 1,    // ������-Eϵ������-2014,2013,2012
}VSB_BEIJING_CLASS;

//����������Ʒ������
typedef enum _VSB_BEIBEN_CLASS
{
    VSB_BEIBEN_OTHER                  = 0,      // ��������
        VSB_BEIBEN_NG80_1                 = 1,     // ��������-NG80-�ؿ�A
        VSB_BEIBEN_NG80_2                 = 2,     // ��������-NG80-�ؿ�B
        VSB_BEIBEN_NG80_3                 = 3,     // ��������-NG80-�ؿ�C
        VSB_BEIBEN_V3_1                   = 4,     // ��������-����V3-V3H1
        VSB_BEIBEN_V3_2                   = 5     // ��������-����V3-�ؿ�A
}VSB_BEIBEN_CLASS;

//�����ͳ���Ʒ������
typedef enum _VSB_BEIFANG_CLASS
{
    VSB_BEIFANG_OTHER                 = 0,      // ��������
        VSB_BEIFANG_A_1                   = 1       // �����ͳ�-�ͳ�����1-A��
}VSB_BEIFANG_CLASS;


//����������Ʒ������
typedef enum _VSB_BAW_CLASS
{
    VSB_BAW_OTHER                     = 0,        // ��������
        VSB_BAW_YUSHENG007_1              = 1,        // ��������-��ʤ007-2013,2011
        VSB_BAW_QILING_1                  = 2,        // ��������-����-A��
        VSB_BAW_LUBA_1                    = 3,        // ��������-½��-2004
        VSB_BAW_QISHI_1                   = 4         // ��������-��ʿ-2009,2007
}VSB_BAW_CLASS;

//����������Ʒ������
typedef enum _VSB_BQWEIWANG_CLASS
{
    VSB_BQWEIWANG_OTHER               = 0,  // ��������
        VSB_BQWEIWANG_205_1               = 1,  // ��������-205-2013
        VSB_BQWEIWANG_306_1               = 2   // ��������-306-2014,2013,2011
}VSB_BQWEIWANG_CLASS;


//������Ʒ������
typedef enum _VSB_SMA_CLASS
{
    VSB_SMA_OTHER                     = 0,        // ��������
        VSB_SMA_HAIYU_1                   = 1,        // ����-����-2007,2005,2004
        VSB_SMA_HAIYU_2                   = 2,        // ����-����-2007����MB
        VSB_SMA_HAISHANG_1                = 3,        // ����-����-2008,2005
        VSB_SMA_HAIJING_1                 = 5,        // ����-����-2010,2009
        VSB_SMA_HAIXUN_1                  = 4,        // ����-��Ѹ-2005,2004쭷�
        VSB_SMA_HAIXUN_2                  = 6,        // ����-��Ѹ-2007,2006
}VSB_SMA_CLASS;

//����������Ʒ������
typedef enum _VSB_XINGMA_CLASS
{
    VSB_XINGMA_OTHER                  = 0,        // ��������
        VSB_XINGMA_XINGKAIMA_1            = 1         // ��������-�ǿ���-ǣ����1,�ػ�����1
}VSB_XINGMA_CLASS;

//˫����Ʒ������
typedef enum _VSB_SHUANGHUAN_CLASS
{
    VSB_SHUANGHUAN_OTHER              = 0,        // ��������
        VSB_SHUANGHUAN_SCEO_1             = 1,        // ˫��-SCEO-2011,2009,2006,2005
}VSB_SHUANGHUAN_CLASS;

//������Ʒ������
typedef enum _VSB_JEEP_CLASS
{
    VSB_JEEP_OTHER                    = 0,       // ��������
        VSB_JEEP_DAQIENUOJI_1             = 1,       // ����-����ŵ��(���)-2014,2013,2012,2011
        VSB_JEEP_DAQIENUOJI_2             = 2,       // ����-����ŵ��(���)-2014���?����
        VSB_JEEP_ZHINANZHE_1              = 3,       // ����-ָ����-2010,2007
        VSB_JEEP_ZHINANZHE_2              = 4,       // ����-ָ����-2014,2013,2012,2011
        VSB_JEEP_MUMAREN_1                = 5,       // ����-������-2012ʹ���ٻ�������,2011
        VSB_JEEP_MUMAREN_2                = 6,       // ����-������-2014,2013,2012,2011,2010,2009,2008
        VSB_JEEP_ZIYOUKE                  = 7,       // ����-���ɿ�-2014,2013,2012,2011
}VSB_JEEP_CLASS;

//������Ʒ������
typedef enum _VSB_VENUCIA_CLASS
{
    VSB_VENUCIA_OTHER                 = 0,       // ��������
        VSB_VENUCIA_D50_1                 = 1        // ����-D50-2014,2013,2012
}VSB_VENUCIA_CLASS;

//������Ʒ������
typedef enum _VSB_HAFEI_CLASS
{
    VSB_HAFEI_OTHER                   = 0,      // ��������
        VSB_HAFEI_XINMINYI_1              = 1,      // ����-���������-2010
        VSB_HAFEI_XINMINYI_2              = 2,      // ����-���������-2012
        VSB_HAFEI_MINYI_1                 = 3,      // ����-�������-2006
        VSB_HAFEI_MINYI_2                 = 4,      // ����-�������-2008
        VSB_HAFEI_SAIBAO_1                = 5,      // ����-���-2012
        VSB_HAFEI_SAIMA_1                 = 6,      // ����-����-2002
        VSB_HAFEI_SAIMA_2                 = 7,      // ����-����-2004,2003
        VSB_HAFEI_SAIMA_3                 = 8,      // ����-����-2009
        VSB_HAFEI_LUBAO_1                 = 9,      // ����-·��-2004
        VSB_HAFEI_LUBAO_2                 = 10,      // ����-·��-2008,2007
        VSB_HAFEI_LUBAO_3                 = 11,      // ����-·��-2012
        VSB_HAFEI_LUZUNXIAOBAWANG_1       = 12,      // ����-·��С����-2011,2010
        VSB_HAFEI_RUIYI_1                 = 13,      // ����-����-2009
        VSB_HAFEI_JUNYI_1                 = 14       // ����-����-2012,2010
}VSB_HAFEI_CLASS;

//�ƿ�ŷ����Ʒ������
typedef enum _VSB_TKING_CLASS
{
    VSB_TKING_OTHER                   = 0,      // ��������
        VSB_TKING_OUGUAN_1                = 1,      // �ƿ�ŷ��-ŷ��-2011
        VSB_TKING_OUGUAN_2                = 2,      // �ƿ�ŷ��-ŷ��-�ῨB
        VSB_TKING_OUTENG_1                = 3,      // �ƿ�ŷ��-ŷ��-�ῨA
        VSB_TKING_FUXING_1                = 4,      // �ƿ�ŷ��-����-2006
        VSB_TKING_QINGKAWANG_1            = 5,      // �ƿ�ŷ��-�Ῠ��-�Ῠ
        VSB_TKING_AFANDA_1                = 6,      // �ƿ�ŷ��-������-���ؿ�
        VSB_TKING_JUNQI_1                 = 7       // �ƿ�ŷ��-����-���ؿ�A
}VSB_TKING_CLASS;

//������Ʒ������
typedef enum _VSB_DAEWOO_CLASS
{
    VSB_DAEWOO_OTHER                  = 0,    // ��������
        VBR_DAEWOO_6960H3_1               = 1     // ����-6960H3-A��
}VSB_DAEWOO_CLASS;

//��������Ʒ������
typedef enum _VSB_DAYUN_CLASS
{
    VSB_DAYUN_OTHER                   = 0,     // ��������
        VBR_DAYUN_ZHONGKA_1               = 1      // ������-�ؿ�-A��
}VSB_DAYUN_CLASS;

//������Ʒ������
typedef enum _VSB_BESTURN_CLASS
{
    VSB_BESTURN_OTHER                 = 0,   // ��������
        VSB_BESTURN_B70_1                 = 1,    // ����-B70-2009,2007,2006
        VSB_BESTURN_B70_2                 = 2,    // ����-B70-2011
        VSB_BESTURN_B70_3                 = 3,    // ����-B70-2011��Ӣ��,2010
        VSB_BESTURN_B70_4                 = 4,    // ����-B70-2012
        VSB_BESTURN_B90_1                 = 5,    // ����-B90-2012
        VSB_BESTURN_AOXING_1		      = 6	   // һ��-����-2004
}VSB_BESTURN_CLASS;

//������Ʒ������
typedef enum _VSB_WEILIN_CLASS
{
    VSB_WEILIN_OTHER                 = 0,      // ��������
        VSB_WEILIN_H3_1                   = 1,     // ����-H3-2011
        VSB_WEILIN_V5_1                   = 2,     // ����-V5-2012,2009
        VSB_WEILIN_X5_1                   = 3      // ����-X5-2012,2011,2010
}VSB_WEILIN_CLASS;

//��ͨ��Ʒ������
typedef enum _VSB_YUTONG_CLASS
{
    VSB_YUTONG_OTHER                  = 0,     // ��������
        VSB_YUTONG_8XI_1                  = 1,     // ��ͨ-8ϵ-2012,2005
        VSB_YUTONG_KECHE_1                = 2,     // ��ͨ-�ͳ�����10-2013,2010
        VSB_YUTONG_KECHE_3                = 3,     // ��ͨ-�ͳ�����2-A��
        VSB_YUTONG_KECHE_4                = 4,     // ��ͨ-�ͳ�����8-2004
        VSB_YUTONG_KECHE_5                = 5,     // ��ͨ-�ͳ�����9-2014
        VSB_YUTONG_KECHE_2                = 6      // ��ͨ-�ͳ�����12-A��
}VSB_YUTONG_CLASS;

//������Ʒ������
typedef enum _VSB_ANKAI_CLASS
{
    VSB_ANKAI_OTHER                   = 0,      // ��������
        VSB_ANKAI_KECHE_1                 = 1,      // ����-�ͳ�����1-A��
        VSB_ANKAI_KECHE_2                 = 2       // ����-�ͳ�����3-A��
}VSB_ANKAI_CLASS;

//������Ʒ������
typedef enum _VSB_BAOJUN_CLASS
{
    VSB_BAOJUN_OTHER            = 0,   // ��������
        VSB_BAOJUN_630_1                  = 1      // ����-����630-2014,2013,2012,2011
}VSB_BAOJUN_CLASS;

//������Ʒ������
typedef enum _VSB_BINLI_CLASS
{
    VSB_BINLI_OTHER                   = 0,     // ��������
        VSB_BINLI_OULU_1                  = 1      // ����-ŷ½-2009,2008
}VSB_BINLI_CLASS;

//��������Ʒ������
typedef enum _VSB_TRUMPCHE_CLASS
{
    VSB_TRUMPCHE_OTHER                = 0,   // ��������
        VSB_TRUMPCHE_GA5_1                = 1,   // ������-GA5-2012,2011
        VSB_TRUMPCHE_GA5_2                = 3,   // ������-GA5-2013,2012�Զ���Ӣ��
        VSB_TRUMPCHE_GS5_1                = 2    // ������-GS5-2014,2013,2012
}VSB_TRUMPCHE_CLASS;

//����� ��Ʒ������
typedef enum _VSB_GONOW_CLASS
{
    VSB_GONOW_OTHER                   = 0,   // ��������
        VSB_GONOW_G3_1                    = 1,      // �����-G3-2011
        VSB_GONOW_G5_1                    = 2,      // �����-G5-2012,2011
        VSB_GONOW_SHUAIJIAN_1             = 4,      // �����-˧��-2012,2009
        VSB_GONOW_XINGWANGM1_1            = 3,      // �����-����M1-2012
        VSB_GONOW_CAIYUN500_1             = 5      // �����-����500-2010
}VSB_GONOW_CLASS;

//������Ʒ������
typedef enum _VSB_ISUZU_CLASS
{
    VSB_ISUZU_OTHER                   = 0,   // ��������
        VSB_ISUZU_ZHONGXINGSHANGYONG_1    = 1,      // ����-�������ó�-2011
        VSB_ISUZU_WUSHILINGPIKA_1         = 2,      // ����-��ʮ��Ƥ��-2009
        VSB_ISUZU_WUSHILINGPIKA_2         = 3,      // ����-��ʮ��Ƥ��-2014,2009
        VSB_ISUZU_JINGJIZHE_1             = 4      // ����-������-2004,2002
}VSB_ISUZU_CLASS;


//������Ʒ������
typedef enum _VSB_KARRY_CLASS
{
    VSB_KARRY_OTHER                   = 0,   // ��������
        VSB_KARRY_YOU_2                   = 1,      // ����-����-2013,2012
        VSB_KARRY_YOUJIN_1                = 2,      // ����-�ž�-2012,2011����,2010
        VSB_KARRY_YOUSHENG_1              = 3,      // ����-��ʤ-2010
        VSB_KARRY_YOUSHENG_2              = 4,      // ����-��ʤ-2012,2011
        VSB_KARRY_YOUYA                   = 5,      // ����-����-2012,2011,2007
        VSB_KARRY_YOU_1                   = 6      // ����-����-2011,2010,2009
}VSB_KARRY_CLASS;

//�ݱ���Ʒ������
typedef enum _VSB_GAGUAR_CLASS
{
    VSB_GAGUAR_OTHER                  = 0,   // ��������
        VSB_GAGUAR_XF_1                   = 1,     // �ݱ�-XF-2014,2013
        VSB_GAGUAR_XJ_1                   = 2     // �ݱ�-XJ-2014,2013,2012,2011,2010
}VSB_GAGUAR_CLASS;

//˹��³��Ʒ������
typedef enum _VSB_SUBARU_CLASS
{
    VSB_SUBARU_OTHER                  = 0,   // ��������
        VSB_SUBARU_AOHU_1                 = 1,     // ˹��³-����-2012,2011,2010
        VSB_SUBARU_LISHI_1                = 2,     // ˹��³-��ʨ�γ�-2008,2006
        VSB_SUBARU_LISHI_2                = 3,     // ˹��³-��ʨ�γ�-2011,2010
        VSB_SUBARU_XV_1                   = 4,     // ˹��³-˹��³XV-2014,2012
        VSB_SUBARU_SENLINREN_1            = 5,     // ˹��³-ɭ����-2007,2006
        VSB_SUBARU_SENLINREN_2            = 6     // ˹��³-ɭ����-2012,2011,2010,2009,2008
}VSB_SUBARU_CLASS;

//ʱ������Ʒ������
typedef enum _VSB_ERA_CLASS
{
    VSB_ERA_OTHER                     = 0,   // ��������
        VSB_ERA_XIAOKA_1                  = 1,        // ʱ����-С��֮��-С��֮��1,2,Q2
        VSB_ERA_XIAOKA_3                  = 2,        // ʱ����-С��֮��-С��֮��5
        VSB_ERA_XIAOKA_4                  = 3,        // ʱ����-С��֮��-����
        VSB_ERA_KANGRUI_1                 = 4,        // ʱ����-����-����H1
        VSB_ERA_KANGRUI_2                 = 5,        // ʱ����-����-����H3
        VSB_ERA_KANGRUI_3                 = 6,        // ʱ����-����-����K1,KQ1
        VSB_ERA_RUIWO_1                   = 7,        // ʱ����-����-RC1
        VSB_ERA_RUIWO_2                   = 8,        // ʱ����-����-RC2
        VSB_ERA_RUIWO_3                   = 9,        // ʱ����-����-����II�ῨA
        VSB_ERA_JINGANG                   = 10,        // ʱ����-���-���568
        VSB_ERA_LINGHANG_1                = 11,        // ʱ����-�캽-�캽2
        VSB_ERA_LINGHANG_2                = 12,        // ʱ����-�캽-�캽3
        VSB_ERA_YULING_1                  = 13,        // ʱ����-Ԧ��-Ԧ��V1
        VSB_ERA_YULING_2                  = 14,        // ʱ����-Ԧ��-Ԧ��V5,VQ5
        VSB_ERA_YULING_3                  = 15,        // ʱ����-Ԧ��-Ԧ��VQ1,VQ2
        VSB_ERA_YULING_4                  = 17,        // ʱ����-Ԧ��-����
        VSB_ERA_XIAOKA_2                  = 17,        // ʱ����-С��֮��-С��֮��3
}VSB_ERA_CLASS;

//�����Ʒ������
typedef enum _VSB_CHANGHE_CLASS
{
    VSB_CHANGHE_OTHER           = 0,  // ��������
        VSB_CHANGHE_CH6321_1        = 1,  // ���-CH6321-2000
        VSB_CHANGHE_DANSHUANGPAI_1  = 2,  // ���-����µ�˫��-1999
        VSB_CHANGHE_AIDIER_1        = 3,  // ���-���϶�-2004
        VSB_CHANGHE_AIDIER_2        = 4,  // ���-���϶��-2007,2006
        VSB_CHANGHE_FURUIDA_1       = 5   // ���-��������-2014,2013,2011,2009
}VSB_CHANGHE_CLASS;

//ŷ����Ʒ������
typedef enum _VSB_OPEL_CLASS
{
    VSB_OPEL_OTHER              = 0,    // ��������
        VSB_OPEL_YATE_1             = 1     // ŷ��-����-2010GTCȫ���絲��,2007,2006
}VSB_OPEL_CLASS;

//��Դ��Ʒ������
typedef enum _VSB_JONWAY_CLASS
{
    VSB_JONWAY_OTHER            = 0,   // ��������
        VSB_JONWAY_A380_1           = 1    // ��Դ-A380-2010,2009,2008
}VSB_JONWAY_CLASS;

//������Ʒ������
typedef enum _VSB_JIANGNAN_CLASS
{
    VSB_JIANGNAN_OTHER          = 0,   // ��������
        VSB_JIANGNAN_TT_1           = 1    // ����-����TT-2011,2010,2004
}VSB_JIANGNAN_CLASS;

//����ȫ��ӥ��Ʒ������
typedef enum _VSB_GLEAGLE_CLASS
{
    VSB_GLEAGLE_OTHER                      = 0,   // ��������
        VSB_GLEAGLE_EAGLE_GC7_1                = 1,   // ����ȫ��ӥ-GC7-2013,2012
        VSB_GLEAGLE_EAGLE_GX2_1                = 2,   // ����ȫ��ӥ-GX2-2012,2011
        VSB_GLEAGLE_EAGLE_GX7_1                = 3,   // ����ȫ��ӥ-GX7-2013,2012
        VSB_GLEAGLE_EAGLE_PANDA_1              = 4,   // ����ȫ��ӥ-��è-2013,2011,2010,2009
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1          = 5,   // ����ȫ��ӥ-���ɽ�-2009���±�׼��,2007
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2          = 6,   // ����ȫ��ӥ-���ɽ�-2010,2009,2008,2006,2005
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3          = 7,   // ����ȫ��ӥ-���ɽ�-2012,2011
        VSB_GLEAGLE_EAGLE_YUANJING_1           = 8,   // ����ȫ��ӥ-Զ��-2011,2010,2009,2008,2006
        VSB_GLEAGLE_EAGLE_YUANJING_2           = 9,   // ����ȫ��ӥ-Զ��-2013,2012
}VSB_GLEAGLE_CLASS;

//����ۺ���Ʒ������
typedef enum _VSB_EMGRAND_CLASS
{
    VSB_EMGRAND_OTHER                      = 0,   // ��������
        VSB_EMGRAND_EC7_2                      = 1,   // ����ۺ�-EC7-2013
        VSB_EMGRAND_EC7_3                      = 2,   // ����ۺ�-EC7-RV
        VSB_EMGRAND_EC8_1                      = 3,   // ����ۺ�-EC8-2013,2011,2010
        VSB_EMGRAND_EC7_1                      = 4    // ����ۺ�-EC7-2012,2010,2009
}VSB_EMGRAND_CLASS;


//����Ӣ����Ʒ������
typedef enum _VSB_ENGLON_CLASS
{
    VSB_ENGLON_OTHER                       = 0,    // ��������
        VSB_ENGLON_SC3_1                       = 1,    // ����Ӣ��-SC3-2012
        VSB_ENGLON_SC5_1                       = 2,    // ����Ӣ��-SC5-RV-2012
        VSB_ENGLON_SC6_1                       = 3,    // ����Ӣ��-SC6-2012
        VSB_ENGLON_SC7_1                       = 4,    // ����Ӣ��-SC7-2013,2012,2011,2010
        VSB_ENGLON_SX7_1                       = 5,    // ����Ӣ��-SX7-2014,2013
        VSB_ENGLON_JINGANG_1                   = 6,    // ����Ӣ��-���-2010,2007,2006
        VSB_ENGLON_JINYING_1                   = 7     // ����Ӣ��-��ӥ-2011,2010,2008
}VSB_ENGLON_CLASS;


//����-��Ʒ������
typedef enum _VSB_JAC_CLASS
{
    VSB_JAC_OTHER               = 0,      // ��������
        VSB_JAC_TONGYUE_1           = 1,      // ����-ͬ��-2012,2010,2008
        VSB_JAC_HEYUE_1             = 2,      // ����-����-2012,2011,2010
        VSB_JAC_HEYUEA30_2          = 3,      // ����-����A30-2013
        VSB_JAC_HEYUERS_3           = 4,      // ����-����RS-2012,2011
        VSB_JAC_HAOYUN_1            = 5,      // ����-����-�Ῠ1
        VSB_JAC_WEILING_2           = 6,      // ����-����-�Ű��Ῠ
        VSB_JAC_WEILING_3           = 7,      // ����-����-�����ػ���
        VSB_JAC_WEILING_4           = 8,      // ����-����-�Ῠ
        VSB_JAC_KECHE_1             = 9,      // ����-�ͳ�-A��
        VSB_JAC_BINYUE_1            = 10,      // ����-����-2010,2008
        VSB_JAC_SHUAILING_2         = 11,      // ����-˧��-�Ῠ
        VSB_JAC_KANGLING_1          = 12,      // ����-����-�Ῠ1
        VSB_JAC_KANGLING_2          = 13,      // ����-����-�Ῠ2
        VSB_JAC_YUEYUE_1            = 14,      // ����-����-2013,2012,2011,2010
        VSB_JAC_XINGRUI_1           = 15,      // ����-����-2012,2011
        VSB_JAC_GEERFA_H_1          = 16,      // ����-���H-�����ػ���
        VSB_JAC_GEERFA_K_2          = 17,      // ����-���K-�ؿ�1
        VSB_JAC_GEERFA_K_3          = 18,      // ����-���K-�ؿ�2
        VSB_JAC_GEERFA_M_4          = 19,      // ����-���M-�����ػ���
        VSB_JAC_RUIFENG_1           = 20,      // ����-���-2011,2009,2007�ֶ�
        VSB_JAC_RUIFENG_2           = 21,      // ����-���-2013,2012,2011,2010,2007,2005
        VSB_JAC_RUIFENG_3           = 22,      // ����-���M5-2012,2011
        VSB_JAC_RUIFENG_4           = 23,      // ����-���S5-2013
        VSB_JAC_RUIYING_1           = 24,      // ����-��ӥ-2009,2007
        VSB_JAC_RUIYING_2           = 25,      // ����-��ӥ-2013,2012,2011
        VSB_JAC_JUNLING_2           = 26,      // ����-����-խ���,�����
        VSB_JAC_WEILING_1           = 27,      // ����-����-��ʽ�Ῠ
        VSB_JAC_SHUAILING_1         = 28,      // ����-˧��-��ʮ��
        VSB_JAC_RUILING_1           = 29,      // ����-����-2012
        VSB_JAC_JUNLING_1           = 30      // ����-����-�콢��
}VSB_JAC_CLASS;


//������Ʒ������
typedef enum _VSB_JMC_CLASS
{
    VSB_JMC_OTHER               = 0,      // ��������
        VSB_JMC_KAIYUN_1            = 1,      // ����-����-102,109�����Ῠ
        VSB_JMC_KAIYUN_2            = 2,      // ����-����-95�����Ῠ
        VSB_JMC_YUHU_1              = 3,      // ����-��-2012
        VSB_JMC_BAODIAN_1           = 4,      // ����-����-2007
        VSB_JMC_BAODIAN_2           = 5,      // ����-����-2009��׼��,2008
        VSB_JMC_BAODIAN_3           = 6,      // ����-����-2014,2012,2009������
        VSB_JMC_BAOWEI_1            = 7,      // ����-����-2005
        VSB_JMC_BAOWEI_2            = 8,      // ����-����-2009
        VSB_JMC_QUANSHUN_1          = 9,      // ����-����������ȫ˳-2010,2008
        VSB_JMC_QUANSHUN_2          = 10,      // ����-����ȫ˳-2006
        VSB_JMC_QUANSHUN_3          = 11,      // ����-����ȫ˳-2013,2011,2010
        VSB_JMC_SHUNDA_1            = 12,      // ����-˳��-2004,2003
        VSB_JMC_SHUNDA_2            = 13,      // ����-˳��-2011,2010,2008
        VSB_JMC_YUSHENG_1           = 14,      // ����-Ԧʤ-2013
        VSB_JMC_YUSHENG_2           = 15       // ����-Ԧʤ-2013�ֶ���װ��,2012,2011
}VSB_JMC_CLASS;

// �ֶ�����Ʒ������
typedef enum _VSB_VOLVO_CLASS
{
    VSB_VOLVO_OTHER             = 0,   // ��������
        VSB_VOLVO_C30_1             = 1,    // �ֶ���-C30-2013,2012,2011,2010
        VSB_VOLVO_S40_1             = 2,    // �ֶ���-S40-2012,2011,2010,2009,2008,2007
        VSB_VOLVO_S60_1             = 3,    // �ֶ���-S60-2003
        VSB_VOLVO_S60_2             = 4,    // �ֶ���-S60-2013,2012,2011
        VSB_VOLVO_S80L_1            = 5,    // �ֶ���-S80L-2012,2011,2010,2009
        VSB_VOLVO_XC60_1            = 6,    // �ֶ���-XC60-2013,2012,2011,2010,2009
        VSB_VOLVO_XC90_1            = 7     // �ֶ���-XC90-2013,2012,2011,2008
}VSB_VOLVO_CLASS;

// ������Ʒ������
typedef enum _VSB_HIGER_CLASS
{
    VSB_HIGER_OTHER             = 0,   // ��������
        VSB_HIGER_H8_1              = 1,    // ����-H8-A��
        VSB_HIGER_H92_1             = 2,    // ����-H92-A��
        VSB_HIGER_V7_1              = 3,    // ����-V7,V8-2006
        VSB_HIGER_KECHE_1           = 4,    // ����-�ͳ�����5-A��
        VSB_HIGER_LONGWEI_1         = 5,    // ����-����-2012,2011
        VSB_HIGER_H7V_1             = 6     // ����-����H7V-2010
}VSB_HIGER_CLASS;

// ������Ʒ������
typedef enum _VSB_RUILIN_CLASS
{
    VSB_RUILIN_OTHER            = 0,   // ��������
        VSB_RUILIN_G3_1             = 1,   // ����-G3-2012,2010
        VSB_RUILIN_G5_1             = 2,   // ����-G5-2012,2011,2010
        VSB_RUILIN_M1_1             = 3,   // ����-M1-2013,2011,2010,2009
        VSB_RUILIN_X1_1             = 4,   // ����-X1-2012A,2011,2010
        VSB_RUILIN_X1_2             = 5    // ����-X1-2012B
}VSB_RUILIN_CLASS;

// ������Ʒ������
typedef enum _VSB_SHENLONG_CLASS
{
    VSB_SHENLON_OTHER                  = 0,         // ��������
        VSB_SHENLONG_KECHE_1               = 1          //����ͳ�-�ͳ�����4-A��
}VSB_SHENLONG_CLASS;

// ������Ʒ������
typedef enum _VSB_FOTON_CLASS
{
    VSB_FOTON_OTHER                    = 0,            // ��������
        VSB_FOTON_AOLING_1                 = 1,            // ����-����-�п�
        VSB_FOTON_AOLING_2                 = 2,            // ����-����-��ʽ����
        VSB_FOTON_AOLING_3                 = 3,            // ����-����-����TX,CTX
        VSB_FOTON_OUMAN_1                  = 4,            // ����-ŷ��-GTL6ϵB
        VSB_FOTON_OUMAN_2                  = 5,            // ����-ŷ��-TX6ϵ,9ϵ
        VSB_FOTON_OUMAN_3                  = 6,            // ����-ŷ��-ŷ���ؿ�1
        VSB_FOTON_OUMAN_4                  = 7,            // ����-ŷ��-��ʨ6ϵ,9ϵ
        VSB_FOTON_OUHUI_1                  = 8,            // ����-ŷ�Կͳ�-D��
        VSB_FOTON_OUMAKE_1                 = 9,            // ����-ŷ���-3ϵ
        VSB_FOTON_OUMAKE_2                 = 10,            // ����-ŷ���-5ϵ
        VSB_FOTON_SAPU_1                   = 11,            // ����-����-2011
        VSB_FOTON_SAPU_3                   = 12,            // ����-����-2011���͹���
        VSB_FOTON_MENGPAIKE_1              = 13,            // ����-���ɿ�-2013
        VSB_FOTON_MIDI_1                   = 14,            // ����-�Ե�-2011,2009
        VSB_FOTON_FENGJING_1               = 15,            // ����-�羰ϵ��-2012,2011,2009
        VSB_FOTON_SAPU_2                  = 16            // ����-����-2011����������Z7
}VSB_FOTON_CLASS;

//������Ʒ������
typedef enum _VSB_FODAY_CLASS
{
    VSB_FODAY_OTHER                    = 0,            // ��������
        VSB_FODAY_CHAOREN_1                = 1,            // ����-С����Ƥ��-2009,2006
        VSB_FODAY_CHAOREN_2                = 2,            // ����-С����Ƥ��-2011
        VSB_FODAY_TANSUOZHE_1              = 3,            // ����-̽����6-2013,2011,2010
        VSB_FODAY_TANSUOZHE_2              = 4,            // ����-̽���ߢ�-2011,2010,2009
        VSB_FODAY_TANSUOZHE_3              = 5,            // ����-̽���ߢ�-2011,2004
        VSB_FODAY_XIONGSHI_1               = 6             // ����-��ʨF16Ƥ��-2012
}VSB_FODAY_CLASS;

// ������Ʒ������
typedef enum _VSB_HONGQI_CLASS
{
    VSB_HONGQI_OTHER                   = 0,         // ��������
        VSB_HONGQI_MINGSHI_1               = 1           // ����-����-2007,2003,2001,2000,1999
}VSB_HONGQI_CLASS;


// ���ǽ� ��Ʒ������
typedef enum _VSB_LUXGEN_CLASS
{
    VSB_LUXGEN_OTHER                   = 0,         // ��������
        VSB_LUXGEN_DASEVEN_1               = 1          // ���ǽ�-��7-SUV
}VSB_LUXGEN_CLASS;

// ������Ʒ������
typedef enum _VSB_XIALI_CLASS
{
    VSB_XIALI_OTHER                    = 0,         // ��������
        VSB_XIALI_QIBING_1                 = 1,         // ����(����)-���-2010
}VSB_XIALI_CLASS;

// ��ۿͳ���Ʒ������
typedef enum _VSB_SHUCHI_CLASS
{
    VSB_SHUCHI_OTHER                   = 0,         // ��������
        VSB_SHUCHI_A_1                     = 1          // ��ۿͳ�-�ͳ�-A��
}VSB_SHUCHI_CLASS;

//Ӣ�������Ʒ������
typedef enum _VSB_INFINITI_CLASS
{
    VSB_INFINITI_OTHER                 = 0,         // ��������
        VSB_INFINITI_EX_1                  = 1,         // Ӣ�����-EX-2013,2011,2010,2009,2008
        VSB_INFINITI_FX_1                  = 2,         // Ӣ�����-FX-2007
        VSB_INFINITI_FX_2                  = 3,         // Ӣ�����-FX-2011,2010,2009
        VSB_INFINITI_FX_3                  = 4,         // Ӣ�����-FX-2013,2012FX35
        VSB_INFINITI_G_1                   = 5,         // Ӣ�����-G-2013,2010
        VSB_INFINITI_JX_1                  = 6          // Ӣ�����-JX-2013,2011
}VSB_INFINITI_CLASS;


// ������Ʒ������
typedef enum _VSB_LOTUS_CLASS
{
    VSB_LOTUS_OTHER                    = 0,            // ��������
        VSB_LOTUS_L3_1                     = 1,            // ����-L3����-2010������,2009
        VSB_LOTUS_L3_2                     = 2             // ����-L5����-2012,2011
}VSB_LOTUS_CLASS;

//��������Ʒ������
typedef enum _VSB_FIAT_CLASS
{
    VSB_FIAT_OTHER                     = 0,            // ��������
        VSB_FIAT_FEIYUE_1                  = 1             // ������-��Ծ-2014,2013,2012
}VSB_FIAT_CLASS;

//ک����Ʒ������
typedef enum _VSB_OGA_CLASS
{
    VSB_OGA_OTHER                      = 0,              // ��������
        VSB_OGA_MDX_1                      = 1,              // ک��-MDX-2010
        VSB_OGA_MDX_2                      = 2               // ک��-MDX-2011
}VSB_OGA_CLASS;



// Ծ����Ʒ������
typedef enum _VSB_YUEJIN_CLASS
{
    VSB_YUEJIN_OTHER                   = 0,           // ��������
        VSB_YUEJIN_SHUAIHU_1               = 1,           // Ծ��-˧��-H100,H300
        VSB_YUEJIN_CAISHEN_1               = 2,           // Ծ��-����-S100
        VSB_YUEJIN_CAISHEN_2               = 3,           // Ծ��-����-S300
        VSB_YUEJIN_CAISHEN_3               = 4            // Ծ��-����-S500
}VSB_YUEJIN_CLASS;

//Ұ����Ʒ������
typedef enum _VSB_YEMA_CLASS
{
    VSB_YEMA_OTHER                     = 0,        // ��������
        VSB_YEMA_F99_1                     = 1            // Ұ��-F99-2012,2011,2010,2009
}VSB_YEMA_CLASS;

//������Ʒ������
typedef enum _VSB_SZKINGLONG_CLASS
{
    VSB_SZKINGLONG_OTHER               = 0,        // ��������
        VSB_SZKINGLONG_BUS11_1             = 1,       // ����-�ͳ�����11-A��
        VSB_SZKINGLONG_BUS12_1             = 2,       // ����-�ͳ�����12-A��
        VSB_SZKINGLONG_BUS13_1             = 3,       // ����-�ͳ�����13-A��
        VSB_SZKINGLONG_BUS14_1             = 4,       // ����-�ͳ�����14-A��
        VSB_SZKINGLONG_BUS16_1             = 5,       // ����-�ͳ�����16-A��
        VSB_SZKINGLONG_BUS18_1             = 6,       // ����-�ͳ�����18-A��
        VSB_SZKINGLONG_BUS1_1              = 7,       // ����-�ͳ�����1-A��
        VSB_SZKINGLONG_BUS20_1             = 8,       // ����-�ͳ�����20-A��
        VSB_SZKINGLONG_BUS2_1              = 9,       // ����-�ͳ�����2-A��
        VSB_SZKINGLONG_BUS5_1              = 10,       // ����-�ͳ�����5-A��
        VSB_SZKINGLONG_BUS6_1              = 11,       // ����-�ͳ�����6-A��
        VSB_SZKINGLONG_BUS9_1              = 12,       // ����-�ͳ�����9-A��
        VSB_SZKINGLONG_BUS10_1             = 13,       // ����-�ͳ�����10-A��
        VSB_SZKINGLONG_BUS15_1             = 14        // ����-�ͳ�����15-A��
}VSB_SZKINGLONG_CLASS;

//�����Ա���Ʒ������
typedef enum _VSB_CHANGFENG_CLASS
{
    VSB_CHANGFENG_OTHER                = 0,        // ��������
        VSB_CHANGFENG_CS7_1                = 1,        // �����Ա�-CS7-2009
        VSB_CHANGFENG_QIBING_1             = 2,        // �����Ա�-���-2010,2009
        VSB_CHANGFENG_LIEBAO_1             = 3,        // �����Ա�-�Ա�CS6-2010,2008
        VSB_CHANGFENG_FULING_1             = 4,        // �����Ա�-����Ƥ��-A��
        VSB_CHANGFENG_FEIYANG_1            = 5,        // �����Ա�-����Ƥ��-2010,2009,2005
        VSB_CHANGFENG_FEITENG_1            = 6,        // �����Ա�-����-2010,2009,2006
        VSB_CHANGFENG_BLACKJINGANG_1       = 7,        // �����Ա�-�ڽ��-2013,2010,2009,2008,2006
}VSB_CHANGFENG_CLASS;

//½����Ʒ������
typedef enum _VSB_LUFENG_CLASS
{
    VSB_LUFENG_OTHER                   = 0,           // ��������
        VSB_LUFENG_X6_1                    = 1,           // ½��-X6-2005
        VSB_LUFENG_X6_2                    = 2,           // ½��-X6-2006
        VSB_LUFENG_X6_3                    = 3,           // ½��-X6-2011,2010,2008,2007
        VSB_LUFENG_LUFENGX5_1              = 4,           // ½��-½��X5-2013
        VSB_LUFENG_LUFENGX8_1              = 5,           // ½��-½��X8-2013,2012,2011,2009
        VSB_LUFENG_LUFENGX8_2              = 6,           // ½��-½��X8-2014,2012̽����
        VSB_LUFENG_FENGHUA_1               = 7,           // ½��-�绪-2008,2007
        VSB_LUFENG_X6_4                    = 8,           // ½��-X6-2011����
        VSB_LUFENG_FENGSHANG_1             = 9            // ½��-����-2011,2006
}VSB_LUFENG_CLASS;

//�����ؿ���Ʒ������
typedef enum _VSB_SHANQI_CLASS
{
    VSB_SHANQI_OTHER                   = 0,           // ��������
        VSB_SHANQI_AOLONG_1                = 1,           // �����ؿ�-����-�ؿ�A
        VSB_SHANQI_AOLONG_2                = 2,           // �����ؿ�-����-�ؿ�B
        VSB_SHANQI_DELONG_1                = 3,           // �����ؿ�-����F2000-4X2ǣ��
        VSB_SHANQI_DELONG_2                = 4,           // �����ؿ�-����F3000-B��
        VSB_SHANQI_DELONG_3                = 5,           // �����ؿ�-����M3000-�ؿ�
}VSB_SHANQI_CLASS;


//Ұ����Ʒ������
typedef enum _VSB_RENAULT_CLASS
{
    VSB_RENAULT_OTHER                  = 0,          // ��������
        VSB_RENAULT_MEIGANNA_1             = 1,          // ��ŵ-÷����-2006
        VSB_RENAULT_KELEIAO_1              = 2,          // ��ŵ-���װ�-2010,2009
        VSB_RENAULT_KELEIAO_2              = 3,          // ��ŵ-���װ�-2013,2012
        VSB_RENAULT_SCENE_1                = 4,          // ��ŵ-�羰-2007
        VSB_RENAULT_FENGLANG_1             = 5,          // ��ŵ-����-2011
        VSB_RENAULT_TAFEIKE_1              = 6           // ��ŵ-���ƿ�-2004
}VSB_RENAULT_CLASS;

//�ƺ���Ʒ������
typedef enum _VSB_HUANGHAI_CLASS
{
    VSB_HUANGHAI_OTHER                 = 0,         // ��������
        VSB_HUANGHAI_DACAISHEN_1           = 1,         // �ƺ�-�����-2013,2012
        VSB_HUANGHAI_DACAISHEN_2           = 2,         // �ƺ�-�����-2013,2012,2011,2010,2009���Ͱ�
        VSB_HUANGHAI_BUS4_1                = 3,         // �ƺ�-�ͳ�����4-2012,2011
        VSB_HUANGHAI_CHALLENGER_1          = 4,         // �ƺ�-��ս��-2011,2010,2009,2008
        VSB_HUANGHAI_AOLONGCUV_1           = 5,         // �ƺ�-����CUV-2010,2009
        VSB_HUANGHAI_AOJUN_1               = 6,         // �ƺ�-����-2009
        VSB_HUANGHAI_AOJUN_2               = 7,         // �ƺ�-����-2010,2009
        VSB_HUANGHAI_QISHENGV3_1           = 8,         // �ƺ�-��ʤV3-2011
        VSB_HUANGHAI_LINGHANGZHE_1         = 9,         // �ƺ�-�캽��-2007,2005
        VSB_HUANGHAI_FENGCHI_1             = 10         // �ƺ�-���-A��
}VSB_HUANGHAI_CLASS;

/********************����Ʒ��������End*************************/

//������Ϣ
typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;          //�������
    BYTE  byVehicleType;    //�������� 0 ��ʾ�����ͣ�1 ��ʾС�ͳ���2 ��ʾ���ͳ� ,3��ʾ���˴��� ,4��ʾ���ֳ����� 5��ʾ���ֳ�����(3.5Ver)
    BYTE  byColorDepth;		//������ɫ��ǳ
    BYTE  byColor;          //������ɫ,�ο�VCR_CLR_CLASS
    /*�״��쳣״̬��
    0~�״���
    1~�״����
    2~�״�һֱ����ĳһ����ͬ�ٶ�ֵ
    3~�״��ͳ����Ϊ0
    4~�״��ͳ���ݹ����߹�С
    */
    BYTE  byRadarState;
    WORD  wSpeed;           //��λkm/h
    WORD  wLength;          //ǰһ�����ĳ��?��
                            /*Υ�����ͣ�0-��1-���٣�2-���٣�3-���У�4-�����,5-ѹ������,6-��������7-·��������
                            8-��ռ�ǣ�9-Υ�������10-�������� 11-Υ�����12-·��ͣ����13-�̵�ͣ��, 14-δ��������(Υ������1357),
    15-Υ��ͣ����16-Υ�µ�ͷ,17-ռ��Ӧ������,18-����,19-����,20-ѹ����,21-δϵ��ȫ��,22-���˴����,23-����*/
    BYTE  byIllegalType;
    BYTE  byVehicleLogoRecog; //�ο�ö������ VLR_VEHICLE_CLASS
    BYTE  byVehicleSubLogoRecog; //����Ʒ��������ʶ�𣻲ο�VSB_VOLKSWAGEN_CLASS��������ö�١�
    BYTE  byVehicleModel; //������Ʒ����0-δ֪���ο�"������Ʒ�����.xlsx"
    BYTE  byCustomInfo[16];  //�Զ�����Ϣ
    WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" (���ֶμ���byVehicleLogoRecog);
    BYTE  byRes3[14];
}NET_DVR_VEHICLE_INFO, *LPNET_DVR_VEHICLE_INFO;

//���Ƽ����
typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;	        //�ṹ����
    BYTE	byResultType;	//0-��Ƶʶ����1ͼ��ʶ���� 2 ����10Mʱ������·��
    BYTE    byChanIndex;	//ͨ����
    WORD    wAlarmRecordID;	//����¼��ID(���ڲ�ѯ¼�񣬽���byResultTypeΪ2ʱ��Ч)
    DWORD   dwRelativeTime;	//���ʱ���
    BYTE    byAbsTime[32];	//���ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999�����룩
    DWORD   dwPicLen;	    //ͼƬ����(��ͼ)
    DWORD	dwPicPlateLen;  //����СͼƬ����
    DWORD   dwVideoLen;	    //¼�����ݳ���
    BYTE	byTrafficLight;	//0-�Ǻ��̵�ץ�ģ�1-�̵�ʱץ�ģ�2-���ʱץ��
    BYTE    byPicNum;       //���ĵ�ͼƬ���
    BYTE	byDriveChan;    //����������
    BYTE	 byVehicleType; //�������ͣ��ο�VTR_RESULT
    DWORD   dwBinPicLen;    //���ƶ�ֵͼ����
    DWORD   dwCarPicLen;    //����ԭͼ����
    DWORD   dwFarCarPicLen; //Զ��ͼ����
    BYTE    *pBuffer3;      //���ƶ�ֵͼ
    BYTE    *pBuffer4;      //����ԭͼ
    BYTE    *pBuffer5;      //Զ��ͼ
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //����������ʻ�ķ���0��ʾ�������£�1��ʾ�������ϣ����ʵ�ʳ�������ʻ����������֣�
    BYTE    byRes3[6];
    NET_DVR_PLATE_INFO  struPlateInfo;    //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE	*pBuffer1;   		        // ���ϴ�����ͼƬ(��ͼ)��ָ��ָ��ͼƬ��Ϣ�����ϴ�������Ƶ��ָ��ָ����Ƶ��Ϣ���������ͼƬ����Ƶ��Ϣ����NULL(DVS������ͼ)
    BYTE    *pBuffer2;                  // ���ϴ�����ͼƬ(����ͼ)ʱ��ָ����ͼƬ��ָ�루DVS���Ʋ�ͼ��
}NET_DVR_PLATE_RESULT, *LPNET_DVR_PLATE_RESULT;
//�������ͼƬ��ݺ�¼����ݣ�ֻ��һ�֣�ͼƬ���Ϊ����ͼƬ+����СͼƬ

//ͼ�������Ϣ����
typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD		dwSize;
    BYTE		byOverlayInfo;//����ʹ�ܿ��أ�0-�����ӣ�1-����
    BYTE		byOverlayMonitorInfo;//�Ƿ���Ӽ�����Ϣ��0-�����ӣ�1-����
    BYTE		byOverlayTime;//�Ƿ����ʱ�䣬0-�����ӣ�1-����
    BYTE		byOverlaySpeed;//�Ƿ�����ٶȣ�0-�����ӣ�1-����
    BYTE		byOverlaySpeeding;//�Ƿ���ӳ��ٱ���0-�����ӣ�1-����
    BYTE		byOverlayLimitFlag;//�Ƿ�������ٱ�־��0-�����ӣ�1-����
    BYTE		byOverlayPlate;//�Ƿ���ӳ��ƺţ�0-�����ӣ�1-����
    BYTE		byOverlayColor;//�Ƿ���ӳ�����ɫ��0-�����ӣ�1-����
    BYTE		byOverlayLength;//�Ƿ���ӳ�����0-�����ӣ�1-����
    BYTE		byOverlayType;//�Ƿ���ӳ��ͣ�0-�����ӣ�1-����
    BYTE		byOverlayColorDepth;//�Ƿ���ӳ�����ɫ��ǳ��0-�����ӣ�1-����
    BYTE		byOverlayDriveChan;//�Ƿ���ӳ�����0-�����ӣ�1-����
    BYTE		byOverlayMilliSec; //���Ӻ�����Ϣ 0-�����ӣ�1-����
    BYTE		byOverlayIllegalInfo; //����Υ����Ϣ 0-�����ӣ�1-����
    BYTE        byOverlayRedOnTime;  //���Ӻ������ʱ�� 0-�����ӣ�1-����
    BYTE        byFarAddPlateJpeg;      //Զ��ͼ�Ƿ���ӳ��ƽ�ͼ,0-������,1-����
    BYTE        byNearAddPlateJpeg;      //��ͼ�Ƿ���ӳ��ƽ�ͼ,0-������,1-����
    BYTE		byRes1[3];    //����
    BYTE		byMonitorInfo1[32];    //������Ϣ1
    BYTE		byMonitorInfo2[44]; //������Ϣ2
    BYTE		byRes2[52];    //����
}NET_DVR_IMAGEOVERLAYCFG, *LPNET_DVR_IMAGEOVERLAYCFG;

//��IO����ץ�Ĺ�������
typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE	byRelatedDriveWay;//����IO�����ĳ�����
    BYTE 	bySnapTimes; //��Ȧץ�Ĵ���0-��ץ�ģ���0-���Ĵ���Ŀǰ���5��
    WORD	wSnapWaitTime;  //ץ�ĵȴ�ʱ�䣬��λms��ȡֵ��Χ[0,60000]
    WORD	wIntervalTime[MAX_INTERVAL_NUM];//���ļ��ʱ�䣬ms
	DWORD   dwSnapVehicleNum; //ץ�ĳ�����š�
    BYTE	byRes2[20];//�����ֽ�
}NET_DVR_SNAPCFG, *LPNET_DVR_SNAPCFG;

typedef enum _ITC_MAINMODE_ABILITY_
{
    ITC_MODE_UNKNOW    = 0x0,   //��
        ITC_POST_MODE  = 0x1,  //����ģʽ
        ITC_EPOLICE_MODE      = 0x2,  //�羯ģʽ
        ITC_POSTEPOLICE_MODE  = 0x4  //��ʽ�羯ģʽ
}ITC_MAINMODE_ABILITY;

typedef enum _ITC_RECOG_REGION_TYPE_
{
    ITC_REGION_RECT    = 0x0,   //����
        ITC_REGION_POLYGON  = 0x1,  //�����
}ITC_RECOG_REGION_TYPE;

typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum;//IO�������
    BYTE  byIoOutNum;//IO�������
    BYTE  bySingleSnapNum;//��IO��������
    BYTE  byLightModeArrayNum;//���̵�ģʽ����
    BYTE  byMeasureModeArrayNum;//����ģʽ����
    BYTE  byPlateEnable; //����ʶ������
    BYTE  byLensMode;//��ͷģʽ0-CCD,1-CMOS
    BYTE  byPreTriggerSupport; //�Ƿ�֧��ԭ����ģʽ��0-֧�֣�1-��֧��
    DWORD dwAbilityType; //֧�ֵĴ���ģʽ��������λ��ʾ�������ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //֧�ֵ�IO��������
    BYTE  byIoLightGroup; //֧�ֵ�IO���̵�����
    BYTE  byRecogRegionType; //��ʶ����֧�ֵ����ͣ������ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport&0x1����ʾ�Ƿ�֧����չ���ַ��������
    // bySupport&0x2����ʾ�Ƿ�֧����չ��Уʱ���ýṹ
    // bySupport&0x4, ��ʾ�Ƿ�֧�ֶ���(�������)
    // bySupport&0x8, ��ʾ�Ƿ�֧�����bonding����(�����ݴ�)
    // bySupport&0x10, ��ʾ�Ƿ�֧�������Խ�
    //2013-07-09 ����������
    WORD wSupportMultiRadar;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // wSupportMultiRadar&0x1����ʾ ����RS485�״� ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x2����ʾ ����������Ȧ ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x4����ʾ ���п��� ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x8����ʾ ��Ƶ��� ֧�ֳ��������״ﴦ��
    BYTE  byICRPresetNum;
    // ��ʾ֧�ֵ�ICRԤ�õ㣨�˹�Ƭƫ�Ƶ㣩��
    BYTE  byICRTimeSlot;//��ʾ֧�ֵ�ICR��ʱ�����1��8��
    BYTE  bySupportRS485Num;//��ʾ֧�ֵ�RS485�ڵ�����
    BYTE  byExpandRs485SupportSensor;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // byExpandRs485SupportSensor &0x1����ʾ�羯������֧�ֳ�����
    // byExpandRs485SupportSensor &0x2����ʾ��ʽ�羯������֧�ֳ�����
    BYTE  byExpandRs485SupportSignalLampDet;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // byExpandRs485SupportSignalLampDet &0x1����ʾ�羯������֧������źŵƼ����
    // byExpandRs485SupportSignalLampDet &0x2����ʾ��ʽ�羯������֧������źŵƼ����
    BYTE  byRelayNum;// ��ʾ֧�̵ּ����ĸ��� 2013-11-04
    BYTE  bySupport1; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport1&0x1����ʾ�Ƿ�֧���Զ���Уʱ��Ϣ����
    // bySupport1&0x2,  ��ʾ�Ƿ�֧����Ƶ�����Ż�����
    // bySupport1&0x4,  ��ʾ�Ƿ�֧��DDNS���÷���
    // bySupport1&0x8,  ��ʾ�Ƿ�֧�ֻ�ȡ�豸��ǰ����ģʽ�ӿ�����
    // bySupport1&0x10, ��ʾ�Ƿ�֧�ֳ�������� 2014-03-03
    // bySupport1&0x20,  ��ʾ�Ƿ�֧��GPSģ���������
    // bySupport1&0x40,  ��ʾ�Ƿ�֧��NTPУʱ���֧�ַ�������
    // bySupport1&0x80,  ��ʾ�Ƿ�֧��tps��������ϴ�
    BYTE  bySupport2; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport2&0x01,  ��ʾ�Ƿ�֧������������Ϣ����
    // bySupport2&0x02,  ��ʾͨ��ͼ�����INTER_PICCFG_V30�����Ƿ�֧����Ƶ����ʱ��������ò���byOSDMilliSecondEnable��
    BYTE  bySupportWhiteBalance; //��ƽ��������Ĭ�϶���֧���ֶ���ƽ�⡢�Զ���ƽ�⡢�Զ���ƽ��2��3��ģʽ��
    // bySupportWhiteBalance &0x01,  ��ʾ�Ƿ�֧���չ��ģʽ
    // bySupportWhiteBalance &0x02,  ��ʾ�Ƿ�֧����Ȼ��ģʽ
    // bySupportWhiteBalance &0x04,  ��ʾ�Ƿ�֧��ů���ģʽ
    // bySupportWhiteBalance &0x08,  ��ʾ�Ƿ�֧�ְ׳��ģʽ
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY, *LPNET_DVR_SNAP_ABILITY;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//Ԥ�õ��1��8 , 0�����
    BYTE   bySubSwitchMode;//1~���죬2~���� (��Ԥ�õ����0 ��ʱ����Ч)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM  //156
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//�Զ��л�ʱ��� (�Զ��л��� ʱ������Ч ����֧��4�飬Ԥ��4��)
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч�����������̬��ʾ [0~100] �����±��ʾԤ�õ��1��8 ��0��7 ���Ӧ��
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч�����������̬��ʾ [0~100]
    BYTE  bySubSwitchMode;//1~���죬2~����
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч�����������̬��ʾ [0~100] �����±��ʾԤ�õ��1��8 ��0��7 ���Ӧ��
    BYTE  byRes[148];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

//�㷨�Զ�
typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//�����ֵ,��Χ[0,100],Ĭ�� 58
    BYTE  byAbBrightnessThreshold; //�쳣������ֵ����Χ[0,100]��Ĭ��12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;

typedef union tagNET_ITC_ICR_PARAM_UNION
{
    BYTE uLen[156];
    NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
    NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
    NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
    NET_ITC_ICR_ALGAOTOSWITCH_PARAM strICRAlgorithmAutoSwitch;
}NET_ITC_ICR_PARAM_UNION,*LPNET_ITC_ICR_PARAM_UNION;

typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~�Զ��л���2~�ֶ��л� ,3~��ʱ�л�,4~�㷨�Զ�
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;

//2013-07-09 �쳣����
typedef struct
{
    DWORD   dwHandleType; //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: ��������������̵��������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    BYTE 	byEnable; //0�������ã�1������
    BYTE	byRes;
    WORD	wDuration;//����ʱ��(��λ/s)
    BYTE	byAlarmOutTriggered[MAX_ITC_EXCEPTIONOUT];//�������ͨ��
    BYTE    byRes1[8];
} NET_ITC_HANDLEEXCEPTION, *LPNET_ITC_HANDLEEXCEPTION;

typedef struct
{
    DWORD dwSize;
    NET_ITC_HANDLEEXCEPTION struSnapExceptionType[MAX_EXCEPTIONNUM_V30]; //�����ÿ��Ԫ�ض���ʾһ���쳣������0- Ӳ�̳���,1-���߶�,2-IP ��ַ��ͻ, 3-�������쳣, 4-�źŵƼ�����쳣
}NET_ITC_EXCEPTION,*LPNET_ITC_EXCEPTION;

typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX; /*��Ȧ���ϽǺ���꣨2���ֽڣ�*/
    WORD wTopLeftY; /*��Ȧ���Ͻ�����꣨2���ֽڣ�*/
    WORD wWdith; /*��Ȧ��ȣ�2���ֽڣ�*/
    WORD wHeight; /*��Ȧ�߶ȣ�2���ֽڣ�*/
} NET_DVR_TRIGCOORDINATE, *LPNET_DVR_TRIGCOORDINATE;

typedef enum _PROVINCE_CITY_IDX_
{
    ANHUI_PROVINCE             = 0,              //����
        AOMEN_PROVINCE             = 1,              //����
        BEIJING_PROVINCE           = 2,              //����
        CHONGQING_PROVINCE         = 3,              //����
        FUJIAN_PROVINCE            = 4,              //����
        GANSU_PROVINCE             = 5,              //����
        GUANGDONG_PROVINCE         = 6,              //�㶫
        GUANGXI_PROVINCE           = 7,              //����
        GUIZHOU_PROVINCE           = 8,              //����
        HAINAN_PROVINCE            = 9,              //����
        HEBEI_PROVINCE             = 10,             //�ӱ�
        HENAN_PROVINCE             = 11,             //����
        HEILONGJIANG_PROVINCE      = 12,             //����
        HUBEI_PROVINCE             = 13,             //����
        HUNAN_PROVINCE             = 14,             //����
        JILIN_PROVINCE             = 15,             //����
        JIANGSU_PROVINCE           = 16,             //����
        JIANGXI_PROVINCE           = 17,             //����
        LIAONING_PROVINCE          = 18,             //����
        NEIMENGGU_PROVINCE         = 19,             //���ɹ�
        NINGXIA_PROVINCE           = 20,             //����
        QINGHAI_PROVINCE           = 21,             //�ຣ
        SHANDONG_PROVINCE          = 22,             //ɽ��
        SHANXI_JIN_PROVINCE        = 23,             //ɽ��
        SHANXI_SHAN_PROVINCE       = 24,             //����
        SHANGHAI_PROVINCE          = 25,             //�Ϻ�
        SICHUAN_PROVINCE           = 26,             //�Ĵ�
        TAIWAN_PROVINCE            = 27,             //̨��
        TIANJIN_PROVINCE           = 28,             //���
        XIZANG_PROVINCE            = 29,             //����
        XIANGGANG_PROVINCE         = 30,             //���
        XINJIANG_PROVINCE          = 31,             //�½�
        YUNNAN_PROVINCE            = 32,             //����
        ZHEJIANG_PROVINCE          = 33              //�㽭
}PROVINCE_CITY_IDX;

typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2]; /*����*/
    DWORD dwCity; /*���У����PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;

//����ģʽ
typedef enum _SCENE_MODE_
{
    UNKOWN_SCENE_MODE   = 0,            //δ֪����ģʽ
        HIGHWAY_SCENE_MODE  = 1,            //���ٳ���ģʽ
        SUBURBAN_SCENE_MODE = 2,            //����ģʽ(����)
        URBAN_SCENE_MODE    = 3,            //����ģʽ
        TUNNEL_SCENE_MODE   = 4             //�������ģʽ(����)
}SCENE_MODE;

typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;  /* �Ƿ�ʹ��������Ȧ��0-��ʹ�ã�1-ʹ��*/
    BYTE    byIsDisplay; /* �Ƿ���ʾ������Ȧ��0-����ʾ��1-��ʾ*/
    BYTE    byLoopPos; //��䴥����Ȧ��ƫ��0-���ϣ�1-����
    BYTE    bySnapGain; /*ץ������*/
    DWORD   dwSnapShutter; /*ץ�Ŀ����ٶ�*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate; //����
    NET_DVR_TRIGCOORDINATE struRes[MAX_VL_NUM];
    BYTE    byTotalLaneNum;/*��Ƶ�����ĳ�����1*/
    BYTE    byPolarLenType; /*ƫ�����ͣ�0������ƫ�񾵣�1����ʩ�͵�ƫ�񾵡�*/
    BYTE	byDayAuxLightMode; /*���츨������ģʽ��0���޸���������1��LED��������2�����������*/
    BYTE	byLoopToCalRoadBright; /*���Լ���·�����ȵĳ���(������Ȧ)*/
    BYTE	byRoadGrayLowTh; /*·�����ȵ���ֵ��ʼ��ֵ1*/
    BYTE	byRoadGrayHighTh; /*·�����ȸ���ֵ��ʼ��ֵ140*/
    WORD	wLoopPosBias; /*��䴥����Ȧλ��30*/
    DWORD   dwHfrShtterInitValue; /*����ͼ���ع�ʱ��ĳ�ʼֵ2000*/
    DWORD   dwSnapShtterInitValue; /*ץ��ͼ���ع�ʱ��ĳ�ʼֵ500*/
    DWORD   dwHfrShtterMaxValue; /*����ͼ���ع�ʱ������ֵ20000*/
    DWORD   dwSnapShtterMaxValue; /*ץ��ͼ���ع�ʱ������ֵ1500*/
    DWORD   dwHfrShtterNightValue; /*�������ͼ���ع�ʱ�������ֵ3000*/
    DWORD   dwSnapShtterNightMinValue; /*���ץ��ͼ���ع�ʱ�����Сֵ3000*/
    DWORD   dwSnapShtterNightMaxValue; /*���ץ��ͼ���ع�ʱ������ֵ5000*/
    DWORD   dwInitAfe; /*����ĳ�ʼֵ200*/
    DWORD   dwMaxAfe; /*��������ֵ400*/
    WORD    wResolutionX;/* �豸��ǰ�ֱ��ʿ�*/
    WORD    wResolutionY;/* �豸��ǰ�ֱ��ʸ�*/
    DWORD   dwGainNightValue; /*������棬Ĭ��ֵ70*/
    DWORD   dwSceneMode; /*����ģʽ�� ���SCENE_MODE */
    DWORD   dwRecordMode; /*¼���־��0-��¼��1-¼��*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*��ַλ��*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*������־��0-��ͷ������1-��β������2-��ͷ/��β������*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*���������ȣ�1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM, *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD dwSize;
    BYTE  byPlateEnable;//�Ƿ�֧�ֳ���ʶ��0-��֧�֣�1-֧��
    BYTE  byRes1[2];   //����
    BYTE  byFrameFlip;   //ͼ���Ƿ�ת 0-����ת��1-��ת
    WORD  wFlipAngle;    //ͼ��ת�Ƕ� 0,90,180,270
    WORD  wLightPhase;   //��λ��ȡֵ��Χ[0, 360]
    BYTE  byLightSyncPower;  //�Ƿ��źŵƵ�Դͬ����0-��ͬ����1-ͬ��
    BYTE  byFrequency;		//�ź�Ƶ��
    BYTE  byUploadSDEnable;  //�Ƿ��Զ��ϴ�SDͼƬ��0-��1-��
    BYTE  byPlateMode; //ʶ��ģʽ����:0-��Ƶ����,1-�ⲿ����
    BYTE  byUploadInfoFTP; //�Ƿ��ϴ�ץ�ĸ�����Ϣ��FTP��0-��1-��
    BYTE  byAutoFormatSD; //�Ƿ��Զ���ʽ��SD����0-��1-��
    WORD  wJpegPicSize; //JpegͼƬ��С[64-8196]
    BYTE  bySnapPicResolution;  //ץ��ͼƬ�ֱ���(��NET_DVR_COMPRESSION_INFO_V30�зֱ��ʱ���һ��)
    BYTE  byRes[55]; //����
}NET_DVR_SNAPENABLECFG, *LPNET_DVR_SNAPENABLECFG;

/*ftp�ϴ�����*/
typedef struct
{
    DWORD	dwSize;
    DWORD	dwEnableFTP;			/*�Ƿ�����ftp�ϴ�����*/
    char	sFTPIP[16];				/*ftp ������*/
    DWORD	dwFTPPort;				/*ftp�˿�*/
    BYTE	sUserName[NAME_LEN];	/*�û���*/
    BYTE	sPassword[PASSWD_LEN];	/*����*/
    DWORD	dwDirLevel;	/*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    WORD 	wTopDirMode;	/* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x=6�Զ���,0x7=Υ������,0x8=����,0x9=�ص�*/
    WORD 	wSubDirMode;	/* ����Ŀ¼��0x1 = ʹ��ͨ����,0x2 = ʹ��ͨ���ţ�,0x3=ʹ��ʱ��(������),0x4=ʹ�ó�����,0x=5�Զ���,0x6=Υ������,0x7=����,0x8=�ص�*/
    BYTE    byEnableAnony; //��������0-��1-��
    BYTE    byPicArchivingInterval;//ͼƬ�鵵���[1~30],0��ʾ�ر�
    BYTE    byRes[22];
}NET_DVR_FTPCFG, *LPNET_DVR_FTPCFG;

/*����������ͼƬ�����Ԫ�� */
#define PICNAME_ITEM_DEV_NAME 	    1		/*�豸��*/
#define PICNAME_ITEM_DEV_NO 	    2		/*�豸��*/
#define PICNAME_ITEM_DEV_IP 	    3		/*�豸IP*/
#define PICNAME_ITEM_CHAN_NAME 	    4		/*ͨ����*/
#define PICNAME_ITEM_CHAN_NO 	    5		/*ͨ����*/
#define PICNAME_ITEM_TIME 		    6		/*ʱ��*/
#define PICNAME_ITEM_CARDNO		    7		/*����*/
#define PICNAME_ITEM_PLATE_NO       8   /*���ƺ���*/
#define PICNAME_ITEM_PLATE_COLOR    9   /*������ɫ*/
#define PICNAME_ITEM_CAR_CHAN       10  /*������*/
#define PICNAME_ITEM_CAR_SPEED      11  /*�����ٶ�*/
#define PICNAME_ITEM_CARCHAN        12  /*����*/
#define PICNAME_ITEM_PIC_NUMBER     13  //ͼƬ���
#define PICNAME_ITEM_CAR_NUMBER     14  //�������
#define PICNAME_MAXITEM 		    15

#define PICNAME_ITEM_SPEED_LIMIT_VALUES    15 //����ֵ
#define PICNAME_ITEM_ILLEGAL_CODE          16 //���Υ������
#define PICNAME_ITEM_CROSS_NUMBER          17 //·�ڱ��
#define PICNAME_ITEM_DIRECTION_NUMBER      18 //������

//(3.7Ver)
#define PICNAME_ITEM_CAR_COLOR             19 //������ɫ
#define PICNAME_ITEM_PLATE_COORDINATE      20 //�������
#define PICNAME_ITEM_CAR_TYPE              21 //��������
#define PICNAME_ITEM_VIOLATION_TYPE        22 //Υ������
#define PICNAME_ITEM_CUSTOM                255//�Զ���



//ͼƬ����
typedef struct
{
    BYTE 	byItemOrder[PICNAME_MAXITEM];	/*	�����鶨���ļ�����Ĺ��� */
    BYTE 	byDelimiter;		/*�ָ���һ��Ϊ'_'*/
}NET_DVR_PICTURE_NAME, *LPNET_DVR_PICTURE_NAME;

//�������2013-09-27
#define PICNAME_ITEM_PARK_DEV_IP 	        1		/*�豸IP*/
#define PICNAME_ITEM_PARK_PLATE_NO          2       /*���ƺ���*/
#define PICNAME_ITEM_PARK_TIME 		        3		/*ʱ��*/
#define PICNAME_ITEM_PARK_INDEX             4       /*��λ���*/
#define PICNAME_ITEM_PARK_STATUS            5       /*��λ״̬*/
#define PICNAME_ITEM_BUILDING_NUMBER        6       /*���ŵ�Ԫ��*/
#define PICNAME_ITEM_OUTDOOR_UNIT_ID        7       /*�ſڻ���*/
#define PICNAME_ITEM_UNLOCK_TYPE            8       /*����ʽ*/
#define PICNAME_ITEM_DEVICE_NAME            9       //�豸���
#define PICNAME_ITEM_PERIOD_NO              10      /*�ں�*/
#define PICNAME_ITEM_DEV_INDEX              11      /*�豸���*/
#define PICNAME_PREFIX                      32      /*ͼƬ���Զ���ǰ׺����*/
//ͼƬ������չ 2013-09-27
typedef struct
{
    BYTE 	byItemOrder[PICNAME_MAXITEM];	/*	�����鶨���ļ�����Ĺ��� */
    BYTE 	byDelimiter;	            	/*�ָ���һ��Ϊ'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //ͼƬ���Զ���ǰ׺
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

/* ����ץͼ����*/
typedef struct
{
    BYTE	byStrFlag;	/*������ݿ�ʼ��*/
    BYTE 	byEndFlag;	/*�����*/
    WORD	wCardIdx;	/*���������ʼλ*/
    DWORD 	dwCardLen;	/*���ų���*/
    DWORD   dwTriggerPicChans;	/*����ͨ���ţ���λ���ӵ�1λ��ʼ�ƣ���0x2��ʾ��һͨ��*/
}NET_DVR_SERIAL_CATCHPIC_PARA, *LPNET_DVR_SERIAL_CATCHPIC_PARA;

//DVRץͼ�������ã����ߣ�
typedef struct
{
    DWORD	dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];	/*ÿ��ͨ����ͼ�����*/
    WORD	wBurstMode;							/*ץͼ��ʽ,��λ����.0x1=�������봥����0x2=�ƶ���ⴥ�� 0x4=232������0x8=485������0x10=���紥��*/
    WORD	wUploadInterval;					/*ͼƬ�ϴ����(��)[0,65535]*/
    NET_DVR_PICTURE_NAME 	struPicNameRule;	/* ͼƬ������� */
    BYTE	bySaveToHD;		/*�Ƿ񱣴浽Ӳ��*/
    BYTE	byRes1;
    WORD	wCatchInterval;		/*ץͼ���(����)[0,65535]*/
    BYTE	byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];	/* ÿ��ͨ��һ�δ������մ��� */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30]; /*��������ץ��ͨ��,��λ���ã��ӵ�1λ��ʼ*/
}NET_DVR_JPEGCFG_V30, *LPNET_DVR_JPEGCFG_V30;

//ץ�Ĵ�������ṹ(����)
typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-���ر�(Ĭ��)��1-�ر�
    BYTE   byRes[23]; //����
}NET_DVR_MANUALSNAP, *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG
{
    DWORD dwSize;
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д*/
    BYTE byPlateOSD;    /*0:�����ͳ��Ʋ�ɫͼ,1:���ͳ��Ʋ�ɫͼ*/
    BYTE bySendJPEG1;   /*0-�����ͽ�JPEGͼ,1-���ͽ�JPEGͼ*/
    BYTE bySendJPEG2;   /*0-������Զ��JPEGͼ,1-����Զ��JPEGͼ*/
    WORD wDesignedPlateWidth;   /*������ƿ��*/
    BYTE byTotalLaneNum;  /*ʶ��ĳ�����*/
    BYTE byRes1;      /*����*/
    WORD wRecognizedLane;  /*ʶ��ĳ����ţ���λ��ʾ��bit0��ʾ����1�Ƿ�ʶ��0-��ʶ��1-ʶ��*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];  /*����ʶ������*/
                                                  DWORD dwRecogMode;  /*ʶ������ͣ�
                                                                      bit0-����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) ��
                                                                      bit1-����ʶ���С����ʶ��0-С����ʶ��1-����ʶ�� ��
                                                                      bit2-������ɫʶ��0-�����ó�����ɫʶ���ڱ���ʶ���С����ʶ��ʱ��ֹ���ã�1-������ɫʶ��
                                                                      bit3-ũ�ó�ʶ��0-������ũ�ó�ʶ��1-ũ�ó�ʶ��
                                                                      bit4-ģ��ʶ��0-������ģ��ʶ��1-ģ��ʶ��
                                                                      bit5-֡��λ�򳡶�λ��0-֡��λ��1-����λ��
                                                                      bit6-֡ʶ���ʶ��0-֡ʶ��1-��ʶ��
                                                  bit7-���ϻ���죺0-���죬1-���� */
                                                  BYTE  bySendPRRaw;       	//�Ƿ���ԭͼ��0-�����ͣ�1-����
                                                  BYTE  bySendBinImage;  	//�Ƿ��ͳ��ƶ�ֵͼ��0-�����ͣ�1-����
                                                  BYTE  byDelayCapture;  //��ʱץ�Ŀ���,��λ��֡
                                                  BYTE  byUseLED;    //ʹ��LED���ƣ�0-��1-��
                                                  BYTE  byRes2[68];    //����
}NET_DVR_SPRCFG, *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;	//�Ƿ����ó������Ȳ�����Ĭ�����ã���0-�رգ�1-����
    BYTE byPlateExpectedBright;	//���Ƶ�Ԥ�����ȣ�Ĭ��ֵ50��, ��Χ[0, 100]
    BYTE byRes1[2];	//����
    BYTE byTradeoffFlash;     //�Ƿ�������Ƶ�Ӱ��: 0 - ��;  1 - ��(Ĭ��);
    //ʹ������Ʋ���ʱ, ����Ǽ�������Ƶ�������ǿЧӦ, ����Ҫ��Ϊ1;����Ϊ0
    BYTE byCorrectFactor;     //����ϵ��, ��Χ[0, 100], Ĭ��ֵ50 (��tradeoff_flash�л�ʱ,�ָ�Ĭ��ֵ��
    WORD wLoopStatsEn;  //�Ƿ����Ȧ�����ȣ���λ��ʾ��0-��ͳ�ƣ�1-ͳ��
    BYTE byPlcBrightOffset;// �������Ȳ���������(������Ȧģʽ��Ч)��ȡֵ��Χ1~100
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //Ԥ�����Ӹ���
    WORD wFortifyLinkNum; //�������Ӹ���
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //Ԥ�����û�IP��ַ
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //�������ӵ��û�IP��ַ
    DWORD dwVideoFrameRate;	//֡�ʣ�0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;  	//�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;  	//ץ�ķֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //�������ͣ�0-��������1-������
    BYTE byTriggerType; //����ģʽ��0-��Ƶ������1-��ͨ����
    DWORD dwSDVolume;  //SD������
    DWORD dwSDFreeSpace; //SD��ʣ��ռ�
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //������״̬��0-δʹ�ã�1-��2-�쳣
    BYTE byDetectorLinkState; //����������״̬��0-δ���ӣ�1-����
    BYTE bySDStatus;    //SD��״̬ 0�����1�����ߣ�2���쳣��3-��sd��
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //�����ȼ���0-�ޣ�1-һ�ȼ����ߣ���2-���ȼ����У���3-��ȼ����ͣ�
    BYTE byRes2[116]; //����
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//��Ȧ����,��λcm��ȡֵ��Χ[0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];	//�źŵ�ͨ����
    BYTE  byCapSpeed;//��־���٣���λkm/h��ȡֵ��Χ[0,255]
    BYTE  bySpeedLimit;//����ֵ����λkm/h��ȡֵ��Χ[0,255]
    BYTE  byTrafficDirection;//��������0-�ɶ�������1-�����򶫣�2-�����򱱣�3-�ɱ�����
    BYTE  byRes1; //����
    WORD  wLoopPreDist;        /*�����ӳپ��� ����λ������*/
    WORD  wTrigDelay;             /*����Ӳ��ʱʱ�� ����λ������*/
    BYTE  byRes[124];//�����ֽ�
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;


//�źŵ��쳣���
typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;		//�ṹ����
    //���ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999  �����λΪ������
    BYTE    byAbsTime[32];
    NET_DVR_IPADDR    struAlarmCamIP;//���������IP
    DWORD   dwPic1Len;     //�쳣ͼƬ1����
    DWORD   dwPic2Len;     //�쳣ͼƬ2����
    char	*pPic1Buffer;	//���ָ��  ���ӳ�����ͼƬ
    char	*pPic2Buffer;	//���ָ��  �����źŵ�״̬ͼƬ
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize; // �ṹ���С
    DWORD         dwChannel;				//ͨ����
    BYTE          byExternalDevType;// 0-��Чֵ��������1-�źŵ�,2-�����
    BYTE          byRes[63];             // �����ֽ�
}NET_DVR_EXDEVDET_COND,*LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize; // �ṹ���С
    BYTE          byExternalDevStatus;// 0-��1-�쳣
    BYTE          byRes[63];// �����ֽ�
} NET_DVR_EXDEVDET_CFG,*LPNET_DVR_EXDEVDET_CFG;

/***************************** end *********************************************/

#define IPC_PROTOCOL_NUM      50   //ipc Э��������

//Э������
typedef struct tagNET_DVR_PROTO_TYPE
{
    DWORD dwType;               /*ipcЭ��ֵ*/
    BYTE  byDescribe[DESC_LEN]; /*Э�������ֶ�*/
}NET_DVR_PROTO_TYPE, *LPNET_DVR_PROTO_TYPE;

//Э���б�
typedef struct tagNET_DVR_IPC_PROTO_LIST
{
    DWORD   dwSize;
    DWORD   dwProtoNum;           /*��Ч��ipcЭ����Ŀ*/
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM];   /*��Ч��ipcЭ��*/
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST, *LPNET_DVR_IPC_PROTO_LIST;

//Э���б�V41
typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;
    DWORD   dwProtoNum;  //��Ч��ipcЭ����Ŀ
    BYTE    *pBuffer;    //Э���б?����, dwProtoNum ��NET_DVR_PROTO_TYPE�ṹ
    DWORD   dwBufferLen; //�������
    BYTE    byRes[32];
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P����ˮƽ����
    DWORD    dwTiltPos;    // T����ֱ����
    DWORD    dwZoomPos;  // Z����䱶����
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;

//��������ʶ����ṹ��
typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;    //�����,�μ� HUMAN_AGE_GROUP_ENUM
    BYTE bySex;         //�Ա�, 1 - �� , 2 - Ů
    BYTE byEyeGlass;    //�Ƿ���۾� 1 - ����, 2 - ��
    BYTE byRes [13];    //����
}NET_VCA_HUMAN_FEATURE ,*LPNET_VCA_HUMAN_FEATURE;

//������ɫ����
typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;        	//��ɫ���ƶ������е�ռ����ֵ
    BYTE  byRed; 		   		    // RGB��ɫ������еĺ�ɫ
    BYTE  byGreen; 		   		// RGB��ɫ������е���ɫ
    BYTE  byBlue;           	    // RGB��ɫ������е���ɫ
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE ,*LPNET_DVR_OBJECT_FEATURE;

//�����������
typedef union tagNET_DVR_ADVANCE_COND_UNION
{
    BYTE                  byLen[36];  //�����峤��
    NET_VCA_HUMAN_FEATURE      struHumanFeature; //��������
    NET_DVR_OBJECT_FEATURE     struObjectFeature; //��������
}NET_DVR_ADVANCE_COND_UNION,*LPNET_DVR_ADVANCE_COND_UNION;


#define MAX_ALERTLINE_NUM	8 //��󾯽�������


typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];  //��Խ���������
    DWORD dwPreTime;   /*���ܱ�����ǰʱ�� ��λ:��*/
    DWORD dwDelayTime; /*���ܱ����ӳ�ʱ�� ��λ:��*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ�����Ϣ
    BYTE  byAdvanceType;   //��Ϸ�ʽ��0-��ʹ����ţ�1-������������ϣ�2-��������ɫռ�����
    BYTE  byRes1[3];  //����
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //�������
    BYTE  byRes[5604]; //����
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND; //Խ������ѯ����

#define MAX_INTRUSIONREGION_NUM	8 //�����������
typedef struct tagNET_DVR_INTRUSION_SEARCHCOND
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/]; //��������
    DWORD dwPreTime;   /*���ܱ�����ǰʱ�� ��λ:��*/
    DWORD dwDelayTime; /*���ܱ����ӳ�ʱ�� ��λ:��*/
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ�����Ϣ
    BYTE  byAdvanceType;//��Ϸ�ʽ��0-��ʹ����ţ�1-������������ϣ�2-��������ɫռ�����
    BYTE  byRes1[3];  //����
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //�������
    BYTE byRes[5348]; //����
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND; //��������


typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //ʶ������
    DWORD           dwPreTime;   /*����¼����ǰʱ�� ��λ:��*/
    DWORD           dwDelayTime; /*����¼���ӳ�ʱ�� ��λ:��*/
    BYTE byRes[5972]; //����
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND; //�������


typedef union tagNET_DVR_AREA_SMARTSEARCH_COND_UNION
{
    BYTE    byLen[6144];  //�ṹ�峤��
    BYTE    byMotionScope[64][96]; //������� 0-96λ��ʾ64�У�����96*64��С��飬1-���ƶ��������0-���ƶ��������
    NET_DVR_TRAVERSE_PLANE_SEARCHCOND struTraversPlaneCond; //Խ�����
    NET_DVR_INTRUSION_SEARCHCOND struIntrusionCond; //��������
    NET_DVR_FACEDETECTION_SEARCHCOND struFaceSnapCond; //�����������
}NET_DVR_AREA_SMARTSEARCH_COND_UNION,
*LPNET_DVR_AREA_SMARTSEARCH_COND_UNION;


//������������
typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE	  byChan;					//ͨ����
    BYTE      bySearchCondType; //���ܲ���������NET_DVR_AREA_SMARTSEARCH_COND_UNION������
    /*0-�ƶ�������� ��1-Խ����⣬ 2-��������*/
    WORD      wChan;                //ͨ���ţ� ���ֶ��Ƕ�byChan����չ��ʹ�ø��ֶκ�byChan���Բ���ʹ��
    NET_DVR_TIME struStartTime;		//¼��ʼ��ʱ��
    NET_DVR_TIME struEndTime;		//¼��ֹͣ��ʱ��
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //���ܲ�������
    BYTE  bySensitivity;   			//�ƶ��������������,1	>80%  2 40%~80%  3 1%~40%
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM, *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{
    DWORD 	              dwSize; 				//�ṹ���С
    NET_DVR_STREAM_INFO   struIDInfo;           //ͨ����Ϣ
    BYTE     	          bySearchCondType;     //���ܲ������������� 0-�������, 1-Խ�����, 2-��������,3-�������, 4-���Ƽ��
    BYTE                  bySensitivity; //�������̬����������,1-100
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //���ܲ�������
    BYTE                  byRes2[256];
}NET_DVR_SMART_SEARCH_PARAM_V40,*LPNET_DVR_SMART_SEARCH_PARAM_V40;



typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;	//�ƶ���ⱨ����ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ��
    BYTE byRes[64];
}NET_DVR_SMART_SEARCH_RET, *LPNET_DVR_SMART_SEARCH_RET;

// IPSAN �ļ�Ŀ¼����
typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IP��ַ
    WORD            wPort;      // IPSAN  �˿�
    BYTE            byRes[10];  // �����ֽ�
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // ���ص��ļ�Ŀ¼
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;

//DVR�豸����
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR���
    DWORD dwDVRID;				//DVR ID,����ң���� //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;		//�Ƿ�ѭ��¼��,0:����; 1:��
    //���²��ɸ��
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    DWORD dwSoftwareVersion;			//����汾��,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwSoftwareBuildDate;			//����������,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;		    //DSP����汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwDSPSoftwareBuildDate;		// DSP����������,0xYYYYMMDD
    DWORD dwPanelVersion;				// ǰ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwHardwareVersion;	// Ӳ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    BYTE byAlarmInPortNum;		//DVR�����������
    BYTE byAlarmOutPortNum;		//DVR�����������
    BYTE byRS232Num;			//DVR 232���ڸ���
    BYTE byRS485Num;			//DVR 485���ڸ���
    BYTE byNetworkPortNum;		//����ڸ���
    BYTE byDiskCtrlNum;			//DVR Ӳ�̿���������
    BYTE byDiskNum;				//DVR Ӳ�̸���
    BYTE byDVRType;				//DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;				//DVR ͨ������
    BYTE byStartChan;			//��ʼͨ����,����DVS-1,DVR - 1
    BYTE byDecordChans;			//DVR ����·��
    BYTE byVGANum;				//VGA�ڵĸ���
    BYTE byUSBNum;				//USB�ڵĸ���
    BYTE byAuxoutNum;			//���ڵĸ���
    BYTE byAudioNum;			//�����ڵĸ���
    BYTE byIPChanNum;			//�������ͨ���� ��8λ����8λ��byHighIPChanNum
    BYTE byZeroChanNum;			//��ͨ���������
    BYTE bySupport;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧�֣�
    //bySupport & 0x1, ��ʾ�Ƿ�֧����������
    //bySupport & 0x2, ��ʾ�Ƿ�֧�ֱ���
    //bySupport & 0x4, ��ʾ�Ƿ�֧��ѹ������������ȡ
    //bySupport & 0x8, ��ʾ�Ƿ�֧�ֶ���
    //bySupport & 0x10, ��ʾ֧��Զ��SADP
    //bySupport & 0x20, ��ʾ֧��Raid������
    //bySupport & 0x40, ��ʾ֧��IPSAN����
    //bySupport & 0x80, ��ʾ֧��rtp over rtsp
    BYTE byEsataUseage;		//Esata��Ĭ����;��0-Ĭ�ϱ��ݣ�1-Ĭ��¼��
    BYTE byIPCPlug;			//0-�رռ��弴�ã�1-�򿪼��弴��
    BYTE byStorageMode;		//0-����ģʽ,1-�������, 2��֡ģʽ
    BYTE bySupport1;		//������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport1 & 0x1, ��ʾ�Ƿ�֧��snmp v30
    //bySupport1 & 0x2, ֧����ֻطź�����
    //bySupport1 & 0x4, �Ƿ�֧�ֲ������ȼ�
    //bySupport1 & 0x8, �����豸�Ƿ�֧�ֲ���ʱ�����չ
    //bySupport1 & 0x10, ��ʾ�Ƿ�֧�ֶ�������33����
    //bySupport1 & 0x20, ��ʾ�Ƿ�֧��rtsp over http
    WORD wDevType;//�豸�ͺ�
    BYTE  byDevTypeName[DEV_TYPE_NAME_LEN];//�豸�ͺ����
    BYTE bySupport2; //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport2 & 0x1, ��ʾ�Ƿ�֧����չ��OSD�ַ����(�ն˺�ץ�Ļ���չ���)
    BYTE byAnalogAlarmInPortNum; //ģ�ⱨ���������
    BYTE byStartAlarmInNo;    //ģ�ⱨ��������ʼ��
    BYTE byStartAlarmOutNo;  //ģ�ⱨ�������ʼ��
    BYTE  byStartIPAlarmInNo;  //IP����������ʼ��
    BYTE  byStartIPAlarmOutNo; //IP���������ʼ��
    BYTE byHighIPChanNum;      //����ͨ�������8λ
    BYTE byEnableRemotePowerOn;//�Ƿ��������豸���ߵ�״̬��Զ�̿����ܣ�0-�����ã�1-����
    BYTE byRes2[8];			//����
}NET_DVR_DEVICECFG_V40, *LPNET_DVR_DEVICECFG_V40;

#define MAX_ZEROCHAN_NUM    16
//��ͨ��ѹ�����ò���
typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;			//�ṹ����
    BYTE  byEnable;			//0-ֹͣ��ͨ�����룬1-��ʾ������ͨ������
    BYTE  byRes1[3];			//����
    DWORD dwVideoBitrate; 	//��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;	//֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0����14-15, 15-18, 16-22;
    BYTE  byRes2[32];        //����
}NET_DVR_ZEROCHANCFG, *LPNET_DVR_ZEROCHANCFG;

//��ͨ�����Ų���
typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;			    //�ṹ����
    NET_VCA_POINT  struPoint;	//�����е�����
    BYTE byState;			    //���ڵ�״̬��0-��С��1-�Ŵ�
    BYTE byPreviewNumber;       //Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16���� �ò���ֻ��
    BYTE byPreviewSeq[MAX_WINDOW_V30];//����ͨ����Ϣ �ò���ֻ��
    BYTE byRes[30];				//����
}NET_DVR_ZERO_ZOOMCFG, *LPNET_DVR_ZERO_ZOOMCFG;

#define DESC_LEN_64 64
typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;			//�ṹ����
    BYTE    byEnable;			//0-����SNMP��1-��ʾ����SNMP
    BYTE    byRes1[3];			//����
    WORD    wVersion;		//snmp �汾  v1 = 1, v2 =2, v3 =3���豸Ŀǰ��֧�� v3
    WORD    wServerPort; //snmp��Ϣ���ն˿ڣ�Ĭ�� 161
    BYTE    byReadCommunity[NAME_LEN]; //����ͬ�壬���31,Ĭ��"public"
    BYTE    byWriteCommunity[NAME_LEN];//д��ͬ��,���31 �ֽ�,Ĭ�� "private"
    BYTE 	byTrapHostIP [DESC_LEN_64];	//��������ip��ַ������֧��IPV4 IPV6����������
    WORD    wTrapHostPort;   // trap����˿�
    BYTE    byTrapName[NAME_LEN];
    BYTE    byRes2[70];    //����
}NET_DVR_SNMPCFG, *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE	byUserName[NAME_LEN];			// �û���
    BYTE	bySecLevel;						// ��ȫ���� 1-��У�� 2-����ȨУ�� 3-��ȨУ��
    BYTE	byAuthtype;						// ��֤���� 0-MD5��֤ 1-SHA��֤ 2: none
    BYTE	byPrivtype;						// 0: DES; 1: AES; 2: none;
    BYTE	byRes[5];
    BYTE	byAuthpass[PASSWD_LEN];			// ��֤����
    BYTE	byPrivpass[PASSWD_LEN];			// ��������
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

// snmpv30
typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD				dwSize;			//�ṹ����
    BYTE				byEnableV1;		//0-����SNMP V1��1-��ʾ����SNMP V1
    BYTE				byEnableV2;		//0-����SNMP V2��1-��ʾ����SNMP V2
    BYTE				byEnableV3;		//0-����SNMP V3��1-��ʾ����SNMP V3
    BYTE				byRes1[3];
    WORD				wServerPort;					//snmp��Ϣ���ն˿ڣ�Ĭ�� 161
    BYTE				byReadCommunity[NAME_LEN];		//����ͬ�壬���31,Ĭ��"public"
    BYTE				byWriteCommunity[NAME_LEN];		//д��ͬ��,���31 �ֽ�,Ĭ�� "private"
    BYTE 				byTrapHostIP [DESC_LEN_64];		//��������ip��ַ������֧��IPV4 IPV6����������
    WORD				wTrapHostPort;					// trap����˿�
    BYTE				byRes2[2];
    NET_DVR_SNMPv3_USER	struRWUser;    // ��д�û�
    NET_DVR_SNMPv3_USER	struROUser;    // ֻ���û�
    BYTE				byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

#define  PROCESSING          0     //���ڴ���
#define  PROCESS_SUCCESS     100   //������
#define  PROCESS_EXCEPTION   400   //����쳣
#define  PROCESS_FAILED      500   //���ʧ��
#define  PROCESS_QUICK_SETUP_PD_COUNT 501 //һ����������3��Ӳ��

#define  SOFTWARE_VERSION_LEN 48
typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;     // �豸IP��ַ
    WORD            wPort;      // �豸�˿ں�
    WORD            wFactoryType;   // �豸��������
    char            chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char            chSerialNo[16]; // ���к�
    WORD            wEncCnt;       // ����ͨ������
    BYTE	        byMACAddr[MACADDR_LEN];		// MAC ��ַ
    NET_DVR_IPADDR  struSubDVRIPMask;   // DVR IP��ַ����
    NET_DVR_IPADDR  struGatewayIpAddr;  // ���
    NET_DVR_IPADDR	struDnsServer1IpAddr;			/* ���������1��IP��ַ */
    NET_DVR_IPADDR	struDnsServer2IpAddr;			/* ���������2��IP��ַ */
    BYTE            byDns;
    BYTE            byDhcp;
    BYTE            szGB28181DevID[DEV_ID_LEN];  //GB28181Э�����ʱ���豸ID������IPC��GB28181Э�����
    BYTE            byActivated;//0-��Ч��1-�Ѽ��2-δ����
    BYTE            byRes[125];     // �����ֽ�
}NET_DVR_SADPINFO, *LPNET_DVR_SADPINFO;

#define  MAX_SADP_NUM   256   // �������豸�����Ŀ
typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD            dwSize;   //  �ṹ��С
    WORD             wSadpNum;   // �������豸��Ŀ
    BYTE             byRes[6];   // �����ֽ�
    NET_DVR_SADPINFO struSadpInfo[MAX_SADP_NUM]; // ����
}NET_DVR_SADPINFO_LIST, *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY, *LPNET_DVR_SADP_VERIFY;

/*******************************���ݽӿ� begin********************************/
//��ȡ�����豸��Ϣ�ӿڶ���
#define DESC_LEN_32          32   //�����ֳ���
#define MAX_NODE_NUM         256  //�ڵ����

typedef struct tagNET_DVR_DESC_NODE
{
    int   iValue;
    BYTE  byDescribe[DESC_LEN_32]; //�����ֶ�
    DWORD dwFreeSpace;           //��ȡ�����б�ר��,��λΪM
    BYTE  byRes[12];			  //����
}NET_DVR_DESC_NODE, *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{
    DWORD     dwSize;            //�ṹ����
    DWORD     dwNodeNum;		 //����������
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //��������
}NET_DVR_DISKABILITY_LIST, *LPNET_DVR_DISKABILITY_LIST;

//���ݽ���б�
#define BACKUP_SUCCESS                100  //�������
#define BACKUP_CHANGE_DEVICE          101  //�����豸������豸�����

#define BACKUP_SEARCH_DEVICE          300  //�������������豸
#define BACKUP_SEARCH_FILE            301  //��������¼���ļ�
#define BACKUP_SEARCH_LOG_FILE        302  //����������־�ļ�

#define BACKUP_EXCEPTION			  400  //�����쳣
#define BACKUP_FAIL					  500  //����ʧ��

#define BACKUP_TIME_SEG_NO_FILE       501  //ʱ�������¼���ļ�
#define BACKUP_NO_RESOURCE            502  //���벻����Դ
#define BACKUP_DEVICE_LOW_SPACE       503  //�����豸��������
#define BACKUP_DISK_FINALIZED         504  //��¼���̷���
#define BACKUP_DISK_EXCEPTION         505  //��¼�����쳣
#define BACKUP_DEVICE_NOT_EXIST       506  //�����豸������
#define BACKUP_OTHER_BACKUP_WORK      507  //������ݲ����ڽ���
#define BACKUP_USER_NO_RIGHT          508  //�û�û�в���Ȩ��
#define BACKUP_OPERATE_FAIL           509  //����ʧ��
#define BACKUP_NO_LOG_FILE            510  //Ӳ��������־

//���ݹ�̽ӿڶ���
typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;   //�ļ�����
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM]; //�ļ��б�
    BYTE byDiskDes[DESC_LEN_32];   //���ݴ�������
    BYTE byWithPlayer;      //�Ƿ񱸷ݲ�����
    BYTE byContinue;    /*�Ƿ����� 0������ 1����*/
    BYTE byRes[34];         //����
}NET_DVR_BACKUP_NAME_PARAM, *LPNET_DVR_BACKUP_NAME_PARAM;

typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;        //��ʱ�䱸�ݵ�ͨ��
    NET_DVR_TIME    struStartTime;   //���ݵ���ʼʱ��
    NET_DVR_TIME    struStopTime;    //���ݵ���ֹʱ��
    BYTE            byDiskDes[DESC_LEN_32];     //���ݴ�������
    BYTE            byWithPlayer;               //�Ƿ񱸷ݲ�����
    BYTE            byContinue;                 //�Ƿ����� 0������ 1����
    BYTE            byDrawFrame;			     //0 ����֡  1 ��֡
    BYTE            byUseBackCfgParam;          //ʹ�ñ��������еĲ���0-��Ч��1-����(���ú�ͨ������Ч)��2-������
    DWORD           dwStreamType;                //�����������ͣ���λ��ʾ
    //&0x1-��ʾ������
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    BYTE            byRes[28];					 // �����ֽ�
}NET_DVR_BACKUP_TIME_PARAM, *LPNET_DVR_BACKUP_TIME_PARAM;
/********************************* end *******************************************/

typedef enum _COMPRESSION_ABILITY_TYPE_
{
    COMPRESSION_STREAM_ABILITY = 0, //����ѹ������
        MAIN_RESOLUTION_ABILITY = 1,	//������ѹ���ֱ���
        SUB_RESOLUTION_ABILITY  = 2,	//������ѹ���ֱ���
        EVENT_RESOLUTION_ABILITY =  3,  //�¼�ѹ������ֱ���
        FRAME_ABILITY = 4,				//֡������
        BITRATE_TYPE_ABILITY = 5,		//λ����������
        BITRATE_ABILITY = 6,			//λ������
        THIRD_RESOLUTION_ABILITY = 7,   //������ѹ���ֱ���
        STREAM_TYPE_ABILITY = 8,        //��������
        PIC_QUALITY_ABILITY = 9,         //ͼ������
        INTERVAL_BPFRAME_ABILITY = 10,  //BP֡���
        VIDEO_ENC_ABILITY = 11,           //��Ƶ��������
        AUDIO_ENC_ABILITY = 12,           //��Ƶ��������
        VIDEO_ENC_COMPLEXITY_ABILITY = 13, //��Ƶ���븴�Ӷ�����
        FORMAT_ABILITY = 14, //��װ��ʽ����
}COMPRESSION_ABILITY_TYPE;

//�����б�
typedef struct tagNET_DVR_ABILITY_LIST
{
    DWORD     dwAbilityType;	//�������� COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];        //�����ֽ�
    DWORD     dwNodeNum;		//����������
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //��������
}NET_DVR_ABILITY_LIST, *LPNET_DVR_ABILITY_LIST;

#define MAX_ABILITYTYPE_NUM  12   //���������
// ѹ�����������б�
typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{
    DWORD     dwSize;            //�ṹ����
    DWORD     dwAbilityNum;		//�������͸���
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM]; //��������
}NET_DVR_COMPRESSIONCFG_ABILITY, *LPNET_DVR_COMPRESSIONCFG_ABILITY;
/********************************9000RH begin****************************************/
#define SUPPORT_PD_NUM			16
#define SUPPORT_ARRAY_NUM		8
#define SUPPORT_VD_NUM			128
#define SUPPORT_PD_NUM_			16
#define SUPPORT_PD_NUM_PARTTWO	8

typedef enum tagRAID_MODE
{
    RAID0 = 1,
        RAID1,
        RAID10,
        RAID1E,
        RAID5,
        RAID6,
        RAID50,
        JBOD,
        RAID60
}RAID_MODE;

typedef enum tagHD_SUPPORT_TYPE
{
    HD_TYPE_SATA    = 0x01,
        HD_TYPE_PATA    = 0x02,
        HD_TYPE_SAS     = 0x04,
        HD_TYPE_ATAPI   = 0x08,
        HD_TYPE_TAPE    = 0x10,
        HD_TYPE_SES     = 0x20
}HD_SUPPORT_TYPE;

// ��λ��ʾ λΪ0��ʾ��֧��  1��ʾ֧��
typedef enum tagSUPPORT_RAID_TYPE
{
    RAID0_ABILITY   = 0x0001,
        RAID1_ABILITY   = 0x0002,
        RAID10_ABILITY  = 0x0004,
        RAID1E_ABILITY  = 0x0008,
        RAID5_ABILITY   = 0x0010,
        RAID6_ABILITY   = 0x0020,
        RAID50_ABILITY  = 0x0040,
        JBOD_ABILITY    = 0x0080,
        RAID60_ABILITY  = 0x0100
}SUPPORT_RAID_TYPE;

// �������
typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;         // Ӳ�̲�λ
    BYTE    byType;         // Ӳ����Ϣ��0 ��ͨ��1ȫ���ȱ���2-�����ȱ� 3-������
    BYTE    byStatus;       // Ӳ��״̬��  0-�� 1-���� 2-��ɾ�� 3-���̶�ʧ 4-���� 5-���� 6-���� 7-�쳣 8-SMART״̬�쳣 9-����0xff-������
    BYTE    byMode[40];   // Ӳ������ �ַ�
    DWORD   dwHCapacity;    //  ����������32λ ��λkb
    DWORD   dwLCapacity;    //  ����������32λ
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;          // ��������ID
    BYTE    byRes[102];         // �����ֽ�
}NET_DVR_PHY_DISK_INFO, *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST, *LPNET_DVR_PHY_DISK_LIST;

typedef enum tagBGA_TYPE
{
    BGA_REBUILD = 0x01,            // �ؽ�
        BGA_CONSISTENCY_FIX = 0x02,    // һ���Լ�鲢�޸�
        BGA_CONSISTENCY_CHECK = 0x04,  // һ���Լ��
        BGA_INIT_QUICK = 0x08,         // ��ʼ��(��)
        BGA_INIT_BACK = 0x10,          // ��ʼ��(��ȫ)
        BGA_MIGRATION = 0x20,       // Ǩ��
        BGA_INIT_FORE = 0x40,           // ��ʼ��
        BGA_COPYBACK = 0x80             // ��Ǩ
}BGA_TYPE;

typedef enum tagBGA_STATE
{
    BGA_STATE_NONE = 0,     //  �޺�̨����
        BGA_STATE_RUNNING,       //  ��̨������������
        BGA_STATE_ABORTED,       //  ��̨����ȡ��
        BGA_STATE_PAUSED         //  ��̨������ͣ
}BGA_STATE;
typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;  // ��̨��������
    BYTE	byBgaState;		   /*�����ֵ--��̨����״̬*/
    WORD    wBgaPercentage;     /*�����ֵ--��̨����ִ�аٷֱ�*/
    BYTE    byRes[4];  // �����ֽ�
}NET_DVR_BGA_INFO, *LPNET_DVR_BGA_INFO;

// ������Ϣ
typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID; // ����ID
    BYTE    byRaidMode; // raidģʽ  ����RAID_MODE
    BYTE    byStatus;  // 0-���� 1-���̶�ʧ 2-���� 3-���� 4-�쳣 5-���� 6-������  7-��ɾ�� 8-SMART״̬�쳣 0xff-������
    DWORD   dwHCapacity; // ����������32λ
    DWORD   dwLCapacity; // ����������32λ
    DWORD   dwHFreeSpace;   // ����ʣ��ռ��32λ
    DWORD   dwLFreeSpace;   // ����ʣ��ռ��32λ
    BYTE    byArrayName[MAX_NAMELEN]; // �������
    BYTE    byPDCount;  // ���������Ŀ
    BYTE    bySpareCount;   // �ȱ���Ŀ
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];	// �����������
    WORD    wSparePDSlots[SUPPORT_PD_NUM];	// �ȱ���������
    NET_DVR_BGA_INFO	struBgaInfo;	// ��̨��������״̬
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //�������������չ��0��ʾ��Ч
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];	// �ȱ�����������չ��0��ʾ��Ч
    BYTE    byRes2[48]; // �����ֽ�
}NET_DVR_ARRAY_INFO, *LPNET_DVR_ARRAY_INFO;


typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;     // �ṹ���С
    DWORD   dwCount;    // ���и���
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST, *LPNET_DVR_ARRAY_LIST;

//���������Ϣ
typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;    //������̲�λ
    BYTE    byStatus; // ״̬0-�� 1-���� 2-��ɾ�� 3-���̶�ʧ 4-���� 5-���� 6-���� 7-�쳣 8-SMART״̬�쳣 0xff-������
    BYTE    byRaidMode; // Raid ģʽ ���� RAID_MODE
    WORD    wArrayID;      // ��������ID
    BYTE    byRepair;   // �Ƿ���Ҫ�޸� 0 ����Ҫ 1��Ҫ
    BYTE	byUsage;	  	//LUN���ʹ�÷�ʽ  0-IPSAN 1-FCSAN 2-DVR���� 3-NAS 4-¼���
    BYTE	byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];    // ������������
    DWORD   dwHCapacity;    // �������������32λ
    DWORD   dwLCapacity;    // �������������32λ
    DWORD   dwHFreeSpace;   // �������ʣ��ռ��32λ
    DWORD   dwLFreeSpace;   // �������ʣ��ռ��32λ
    NET_DVR_BGA_INFO	struBgaInfo;	// ��̨����״̬
    DWORD				dwBlockSize;	//��С�洢��Ԫ���С
    NET_DVR_IPADDR		struWarrantIP;	// ��Ȩ��DVR����IP
    char				szArrayGroup[NAME_LEN]; 	//ʹ�õ���������飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
    BYTE				byRes[20];
}NET_DVR_VD_INFO, *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;     // �ṹ���С
    DWORD   dwCount;    // ������̸���
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];  //�����������
}NET_DVR_VD_LIST, *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION, *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD  wVDSlot;
    BYTE  byAlloc;  // �Ƿ��Ѿ�����
    BYTE  byRes[5];
    DWORD dwHVDSlotSize;	// ������̿ռ��С��32λ
    DWORD dwLVDSlotSize;	// ������̿ռ��С��32λ
}NET_DVR_VD_SLOT, *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;						/*current number of slots in DG*/
    BYTE    byRes1[3];              // �����ֽ�
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO, *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;    // �ṹ���С
    NET_DVR_ADAPTER_VERSION struVersion;	// �������汾��
    BYTE    bySlotCount;    //��������λ��
    BYTE    bySupportMigrate;  // Ǩ��(1-֧��  0-��֧��)
    BYTE    bySupportExpand;   // ����  (1-֧��  0-��֧��)
    BYTE    bySupportRebuild;  // �Ƿ�֧���ؽ����� (1��֧�� 0-��֧��)
    WORD    wSlotSupportType; //  ��λ��ʾ HD_SUPPORT_TYPE
    WORD    wSupportRaidType;      // ֧��Raid ���� ��λ��ʾ
    BYTE    byAutoRebuild;      // 0 ���Զ��ؽ� 1�Զ��ؽ� ����
    BYTE    byRes[27];      // �����ֽ�
}NET_DVR_RAID_ADAPTER_INFO, *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    //�Ƿ�һ��  ���Ϊһ����򴴽�ʱʱ���֮��Ҫarray��ƣ�����Ҫ�������
    // ����������豸���д���
    BYTE    byRaidMode;     // ����/Ǩ��ʱRaid������
    BYTE    byPDCount;  // ���������Ŀ
    WORD    wArrayID;   // Ǩ�ƻ����ؽ�ʱ��Ҫָ������ID
    WORD    wPDSlots[SUPPORT_PD_NUM];// �������
    BYTE    byName[MAX_NAMELEN];  // array ���
    BYTE    byInitMode;              //��ʼ����ʽ
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];       //���������Ϣ
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM, *LPNET_DVR_OPERATE_ARRAY_PARAM;


#define INIT_QUICK                                      0    /*���ٳ�ʼ��*/
#define INIT_FULLFOREGROUND                             1    /*��ȫ��ʼ��(ǰ̨)*/
#define INIT_FULLBACKGROUND                             2    /*��ȫ��ʼ��(��̨)*/

typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;		// ����ID
    BYTE    bySlot;			// �����������ָ����λ
    BYTE    byInitType;     // �����������ʱ��ʼ������ 0 - ���ٳ�ʼ�� 1 - ǰ̨��ȫ��ʼ�� 2 - ��̨��ȫ��ʼ��
    DWORD	dwHCapacity;	// ������̴�С��32λ
    DWORD	dwLCapacity;	// ������̴�С��32λ
    BYTE    byName[MAX_NAMELEN]; // ����������
    BYTE    byRes2[16];          // �����ֽ�
}NET_DVR_OPERATE_VD_PARAM, *LPNET_DVR_OPERATE_VD_PARAM;


typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;        // ������̲�λ
    WORD    wArrayID;       // ����������
    BYTE    bySpareType;    // �ȱ����� 1-ȫ���ȱ�  2 ָ������  ��Ϊָ�����е�ʱ����Ҫָ���������е�ID
    BYTE    byRes[7];       // �����ֽ�
}NET_DVR_SPARE_DISK_PARAM, *LPNET_DVR_SPARE_DISK_PARAM;

/********************************9000RH End****************************************/


#define MATRIX_MAXDECSUBSYSTEMCHAN	4//��Ƶ�ۺ�ƽ̨������ϵͳͨ����

//��ȡ������ϵͳ������Ϣ
typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE	byJoinStatus;//����״̬��0-û�й�����1-�Ѿ�����
    BYTE	byJoinSubSystem;//�������ϵͳ��λ��
    BYTE	byJoinDispNum;//�������ʾͨ����
    BYTE	byJoinSubWindowNum;//������Ӵ��ں�
    BYTE	byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS,LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE	bySubSystemType;//��ϵͳ���ͣ�0-�ޣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ,5-�����ϵͳ��6-������ϵͳ
    BYTE	byConnectStatus;//����ϵͳ����״̬��1-������2-���ӶϿ�
    BYTE    byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE	bySubSystemNum;//������ϵͳ��λ�ţ�0~79����ϵͳ������3��4ʱ����
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE	byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE    byRes[7];
}NET_DVR_SINGLESUBSYSTEMJOININFO,LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM];//80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

//2010-04-13 ����NAT�����������
typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD		  		dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2];//NAT IP��ַ
    BYTE				byNATEnable;//�Ƿ�����NAT���ܣ�0-�����ã���0-����
    BYTE		  		byRes[63];
}NET_DVR_NATASSOCIATECFG, *LPNET_DVR_NATASSOCIATECFG;

//2010-06-01 ��Ƶ�ۺ�ƽ̨��������
typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE	 byEnableTemperatureAlarm;//ʹ���¶ȳ��ޱ�����0-������1-������
    BYTE	 byRes1[3];
    int 	 iTemperatureUpLimited;	//��ȷ��С������λ����1234��ʾ�¶�12.34��
    int 	 iTemperatureDownLimited;
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE	 byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG, *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm;//�Ȳ�α���ʹ�ܣ�1-������0-������
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;	/* ���?ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG, *LPNET_DVR_BOARDALARMCFG;


typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD 						 dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;
    NET_DVR_BOARDALARMCFG 		 struBoardAlarmCfg;
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM];//0-�����쳣��1-��ϵͳ�쳣��2-IP��ַ��ͻ��3-���߶ϣ�4-�Ƿ����ʣ�5-�����쳣��6-ǰ����쳣
    BYTE						 byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG,*LPNET_DVR_VIDEOPLATFORMALARMCFG;
//2010-05-17
typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD		dwSize;
    NET_DVR_IPADDR   struIP;  /*������IP��ַ*/
    WORD		wPort;        //�������˿ں�
    BYTE		byRes1[6];
    BYTE		sUserName[NAME_LEN];	/* �û���32�� */
    BYTE		sPassword[PASSWD_LEN];	/*���� ��16��*/
    BYTE        byChan;//������ͨ����
    BYTE		byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE, *LPNET_DVR_CODESPLITTERASSOCIATE;

//2010-06-01 ��Ƶ�ۺ�ƽ̨�����ϴ��ṹ
typedef struct tagNET_DVR_MATRIXSUBSYSTEMINFO
{
    BYTE   byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE	bySubSystemNum;//��ϵͳ��λ��
    BYTE   byRes [14];
} NET_DVR_MATRIXSUBSYSTEMINFO, *LPNET_DVR_MATRIXSUBSYSTEMINFO;

typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;      //�ṹ���С
    BYTE   byAlarmType;	// 0-�γ��Ӱ壬1-�����Ӱ�,2-�¶ȳ����ޱ�����3-�¶ȳ����ޱ�����4-����״̬�쳣��5-��ϵͳ�쳣,6-�Ƿ����ʣ�7-�����쳣����,8-ǰ����쳣����
    BYTE   byBoardNum;     //�Ӱ�ţ���1��B10��֧�ָ��ֶΣ���Ч����Ϊ0xff
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8]; //�Ӱ��λ��,һ���Ӱ�����8����ϵͳ����ֱ��Ӧ�Ĳ�λ�ţ���ϵͳ�쳣ʱ��bySubSystemChan[0]��ʾ��Ӧ��ϵͳ���
    int    iTemperature;  //�¶ȳ��ޱ���ʱ���ã��¶�ֵ
    BYTE   byMainboardSeq;//�¶ȳ��ޱ���ʱ���ã�0-�����壬1-����
    BYTE   byRes2[3];
    BYTE   byFanSequence[32];//�쳣���ȣ�byFanSequence[i] = 1��ʾ����i+1�쳣��byFanSequence[i] = 0��ʾ����i+1��
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;// �����쳣����ʱʹ�ã�������
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;//�����쳣����ʱʹ�ã�������
    BYTE   byRes3[68];
}NET_DVR_VIDEOPLATFORM_ALRAMINFO,*LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

/***************************��ѶDVR begin *****************************/
#define MAX_INQUEST_PIP_NUM		3     //��ͨ����ʾ�Ļ��л���Ŀ
#define MAX_INQUEST_CDRW_NUM	4     //����¼����Ŀ
#define MAX_INQUEST_PIP_NUM_EX	16		//��Ѷ���л�������

typedef struct
{
    DWORD      dwSize;
    DWORD      dwNum;                       //��¼�������
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30];// �Ƿ�ѡ�иù���
    DWORD      dwModeSelect;                //0��ʾѭ����¼ģʽ  1��ʾ���п�¼ģʽ(Ĭ��ģʽ)
    BYTE	   byRes[24];                   //����
    DWORD	   dwStartCDRW;                 //DVR �����Ѿ���ʼ��¼
    DWORD      dwHdExcp;                    //Ӳ������ ��
    DWORD	   dwInterval;                  //ʱ������10����(0)��20����(1)��30����(2)
    char 	   sLable[64];                  //�������
}NET_DVR_INQUEST_CDRW_CFG, *LPNET_DVR_INQUEST_CDRW_CFG;

typedef struct
{
    char      sFileName[36];			 //�ļ���
    DWORD     dwFileLen;				 //�ļ�����
}NET_DVR_INQUEST_FILEINFO, *LPNET_DVR_INQUEST_FILEINFO;

typedef struct
{
    DWORD     dwFileNum;			         // ��Ҫ��¼����ɾ����ļ������һ��20��
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //�������������ڱ�ʾ��¼���ļ�ʱʹ��
    DWORD     dwCDIndex;				    //��¼�������1:ѡ��1�ſ�¼��2:ѡ��2�ſ�¼�� 3:3�ſ�¼��,4:4�ſ�¼��,5:���п�¼��
    DWORD      bFinalizeDisc;		     	// 0=��¼��֮�󲻷��̣�1=��¼��֮�����
}NET_DVR_INQUEST_FILES, *LPNET_DVR_INQUEST_FILES;

typedef struct
{
    DWORD     dwEnable;			//��¼��״̬�Ƿ���Ч,0-��Ч,1-��Ч
                                DWORD     dwStatus;			/* ��dwType=0ʱ��
                                                            0-������1-�޹��̻�����쳣,
                                                            ��dwType=1��2ʱ��
                                                            0-��¼��1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻�㣬
                                                            4-�쳣������Ѷ��ֹ(81��֧��)
                                                            ��dwType=3ʱ��
                                                            0-��¼��1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻��
                                                            ��dwType=4ʱ��
                                                            0-��¼��1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻��
                                                            ��dwType=5ʱ,
                                                            0-������ 1-�޹��̻�����쳣,
                                                            2-�����ѷ���(81��֧��)
                                                            ��dwType=6��7ʱ,
                                                            0-��¼��, 1-�޹��̻�����쳣,
                                2-�����ѷ���(81��֧��), 3-���̿ռ䲻��*/
                                DWORD    dwVolumn;      //��������,��λM
                                DWORD    dwFreeSpace;   //����ʣ������,��λM
                                DWORD    dwTimeLeft; 	// ����ʣ��ʱ�䣬��λ��
                                BYTE  	    byCDType;     	// ��������
                                BYTE       byRes[3];      //�����ֽ�
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct
{
/*����״̬��0-��Ѷ��ʼ��
1-��Ѷ����п�¼��2-��Ѷֹͣ��
3-��¼��Ѷ�ļ�,
4-����(�º󱸷ݺͱ��ر���)
5-����
6-��ʼ��Ӳ��
    7-�ָ���Ѷ*/
    DWORD    dwType;
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];   //����0��ʾ��¼��1
    NET_DVR_TIME_EX			struInquestStartTime;		//��Ѷ��ʼ��ʱ���
    BYTE					byRes[16];             //����
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;

typedef struct
{
    BYTE     byPipChan;			  //���л���ʾ��ͨ�� 0xFF�ر�
    BYTE     byRes[3];			  //�����ֽ�
    WORD     wTopLeftX;			  //���л���x���
    WORD     wTopLeftY;			  //���л���Y���
}NET_DVR_INQUEST_PIP_PARAM, *LPNET_DVR_INQUEST_PIP_PARAM;

typedef struct
{
    BYTE     byBaseChan;          //��ʾ���л����ڵ�ͨ��
    BYTE     byBackChan;          //��ʾ���л�����ͨ��
                                  BYTE     byPIPMode;           /*�Ƿ���,
                                                                0 ��ǰ������С����
                                                                1 ��ǰ������1��С����
                                                                2 ��ǰ������2��С����
                                                                3 ��ǰ������3��С����
                                  */
                                  BYTE     byRes;               //�����ֽ�
                                  NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];  //����λ�õĲ���
}NET_DVR_INQUEST_PIP_STATUS, *LPNET_DVR_INQUEST_PIP_STATUS;

//V40��չ�������л�������չΪ32��
typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*���л���ʾ��ͨ�� 0xFF�ر�*/
    BYTE     byRes1[3];
    WORD     wTopLeftX;     	/*���л���x���*/
    WORD     wTopLeftY;     	/*���л���Y���*/
    WORD     wHeight;    		/*���л��ĸ� */
    WORD     wWidth;    		/*���л��Ŀ� */
    BYTE	 byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD	struStructHead;
    BYTE     		byBaseChan;     /*��ʾ���л����ڵ�ͨ��*/
    BYTE     		byBackChan;     /*��ʾ���л�����ͨ��*/
                                    BYTE     		byPIPMode;      /*�Ƿ���, 0 ��ǰ������С����
                                                                    1 ��ǰ������1��С����
                                                                    2 ��ǰ������2��С����
                                                                    3 ��ǰ������3��С����
                                                                    4 ��ǰ������4��С����
                                                                    5 ��ǰ������5��С����
                                                                    6 ��ǰ������6��С����
                                                                    7 ��ǰ������7��С����
                                                                    8 ��ǰ������8��С����
                                                                    9 ��ǰ������9��С����
                                    255  ��ǰ���ڹر�Ԥ������*/
                                    BYTE     					byPipCount;          /*С����ĸ���*/
                                    BYTE    					byPicShowMode; /*������ʾģʽ��0-���л���1-������2-����ƴ��*/
                                    BYTE						byRes[31];		/*����*/
                                    NET_DVR_INQUEST_PIP_PARAM_V40 	strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*����λ�õĲ���*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct
{
    BYTE	sSecretKey[16];        /*����������Կ*/
    BYTE	byRes[64];             /*�����ֽ�*/
}NET_DVR_INQUEST_SECRET_INFO, *LPNET_DVR_INQUEST_SECRET_INFO;


/***************************��ѶDVR end *****************************/


/********************************�ӿڲ���ṹ(end)*********************************/
#define		MAX_BIGSCREENNUM	100//������ƴ����

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE	byScreenSeq;//��Ļ��ţ�0xff��ʾ���ô���,64-T��������һ����ʾ����
    BYTE	bySubSystemNum;//������ϵͳ��λ��,��������ֵû����
    BYTE	byDispNum;//������ϵͳ�϶�Ӧ��ʾͨ���ţ�64-T�������и�ֵ��ʾ����������ʾͨ����
    BYTE	byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE	byEnable;//����ƴ��ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE	byModeX;/*����ƴ��ģʽ*/
    BYTE	byModeY;
    BYTE	byMainDecodeSystem;//�ۺ�ƽ̨�Ľ�����и�ֵ��ʾ������λ�ţ�64-T�������и�ֵ��ʾ����ͨ����
    BYTE	byMainDecoderDispChan;//����������ʾͨ���ţ�1.1netra�汾������netra��������������ʾͨ�������ܹ���Ϊ������64-T�и�ֵ��Ч
    BYTE	byVideoStandard;      //����ÿ��������ʽ��ͬ 1:NTSC,2:PAL
    BYTE	byRes1[2];
    DWORD  dwResolution;         //����ÿ�������ֱ�����ͬ
    //����ƴ�Ӵ���Ļ��Ϣ
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM];
    //��ʼ������Ϊ��׼��������
    WORD    wBigScreenX; //�����ڵ���ǽ����ʼX���
    WORD    wBigScreenY; //�����ڵ���ǽ����ʼY���
    BYTE	byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;


#define	DECODEPIC_LEFTADJUST			1		/*ͼ������*/
#define	DECODEPIC_RIGHTADJUST			2		/*ͼ������*/
#define	DECODEPIC_UPADJUST				3		/*ͼ������*/
#define	DECODEPIC_DOWNADJUST			4		/*ͼ������*/
#define	DECODEPIC_REDUCEADJUST			5		/*ͼ����С*/
#define	DECODEPIC_FULL_SCREEN_ADJUST	6		/*ͼ��ȫ��*/
#define	DECODEPIC_CANCEL_FULL_SCREEN_ADJUST	7		/*ͼ��ȡ��ȫ����ʾ*/
#define DECODEPIC_AUTOADJUST           8        /*  ͼ���Զ����� */
#define DECODEPIC_HEIGHTADJUST         9       /* ͼ��߶ȵ��� */
#define DECODEPIC_WIDTHADJUST         	10       /* ͼ���ȵ��� */

#define 	MAX_UNITEDMATRIX_NUM		8//�����������Ƶ�ۺ�ƽ̨����
#define 	MAX_SUBDOMAIN_NUM		    4//�����������������
typedef struct tagNET_DVR_SUBSERVERINFO
{
    BYTE		bySequence;//��ţ���������������ţ�������Ƶ�ۺ�ƽ̨����ƽ̨�ţ�0��ʾ�޴�ƽ̨\����
    BYTE		byBelongSubDomain;//����ƽ̨��Ч����ʾ�����ĸ�����
    BYTE		byRes1[6];
    DWORD       dwMaxIpcNums;//���ӵ����IPC����
    NET_DVR_IPADDR struSubMatrixIP;		/*IP��ַ*/
    WORD		wSubMatrixPort;        /*��ϵͳ�˿ں�*/
    BYTE		byRes2[6];
}NET_DVR_SUBSERVERINFO, *LPNET_DVR_SUBSERVERINFO;

typedef struct tagNET_DVR_UNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBSERVERINFO struDomainInfo;
    NET_DVR_SUBSERVERINFO struSubDomainInfo[MAX_SUBDOMAIN_NUM];//������Ϣ
    NET_DVR_SUBSERVERINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];//��Ƶ�ۺ�ƽ̨��Ϣ
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXINFO, *LPNET_DVR_UNITEDMATRIXINFO;

typedef struct tagNET_DVR_REGCALLBACKPARAM
{
    char sDeviceID[NAME_LEN];//�豸ID��
    char sPassword[PASSWD_LEN];
    BYTE sSerialNumber[SERIALNO_LEN]; /* �豸���к� */
    DWORD dwDeviceType;//�豸����
    BYTE nStatus;// ������״̬��0���ߣ�1���ߣ�
    /* net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks */
    BYTE byNetType;
    BYTE byRes[14];
}NET_DVR_REGCALLBACKPARAM, *LPNET_DVR_REGCALLBACKPARAM;

typedef struct tagNET_DVR_LOGONREPONSEPARAM
{
    //����ʱ��������λ����, 5�ı���180�����ڡ�Ĭ����15�롣
    WORD wHeartbeatTime;
    BYTE byOvertimes;// �豸����ʱ����Ĭ����3��
    BYTE byRes[13];
}NET_DVR_LOGONREPONSEPARAM, *LPNET_DVR_LOGONREPONSEPARAM;


typedef struct tagNET_DVR_PREVIEWPARAM
{
    BYTE byTransProtol;		//����Э�飬0-TCP, 1-UDP
    BYTE byTransMode;		///* ��������ģʽ 0�������� 1��������*/
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD wPort;/*CU�˿�*/
    WORD wUdpPort;
    BYTE bySupportQos;//�Ƿ�����QOS,1-���ã�0-������
    //�Ƿ���NATԤ������0-��1-��(ֻ��byTransMode�ֶ�)
    BYTE  byNatRequest;
    BYTE  byPreviewType;// 0-��ͨԤ�� 1-��ʱԤ��
    BYTE  byRes[7];
}NET_DVR_PREVIEWPARAM, *LPNET_DVR_PREVIEWPARAM;
typedef struct tagNET_DVR_DEVICENATINFO
{
    NET_DVR_IPADDR struPuIp; //PU������IP��ַ
    WORD	wOuterPort;/*PU����˿�*/
    WORD	wInterPort;//PU������Ƶ�ı��ض˿�
    DWORD   nSessionID;//CMS�����sessionID
    BYTE	byRes[4];
}NET_DVR_DEVICENATINFO, *LPNET_DVR_DEVICENATINFO;


typedef struct tagNET_DVR_PREVIEWCALLBACKPARAM
{
    LONG lChannel;
    BYTE nLinkProtocol;
    BYTE nTransMode;
    BYTE byPreviewType; //0-��ͨԤ�� 1-��ʱԤ��
    BYTE byRes[5];
    DWORD nSessionID;//CMS�����sessionID
}NET_DVR_PREVIEWCALLBACKPARAM, *LPNET_DVR_PREVIEWCALLBACKPARAM;

//�ط�
typedef struct tagNET_DVR_PLAYBACKREQUESTPARAM
{
    BYTE byPlayBackMode;		/* �ط�����ģʽ 1�������� 2����ʱ�� */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];		/* �طŵ��ļ��� */
        struct
        {
            LONG	lChannel;				/*�طŵ�ͨ����*/
            NET_DVR_TIME struStartTime;			/* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;			/* ��ʱ��طŵĽ���ʱ�� */
            BYTE    byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD	wPort;/*CU�˿�*/
    BYTE	byRes2[2];
    DWORD   dwSessionID;//CMS�����sessionID,�������
    BYTE    byRes3[16];
}NET_DVR_PLAYBACKREQUESTPARAM, *LPNET_DVR_PLAYBACKREQUESTPARAM;

//2010-10-06
typedef struct tagNET_DVR_PLAYBACKCALLBACKPARAM
{
    BYTE byPlayBackMode;		/* �ط�����ģʽ 1�������� 2����ʱ�� */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];		/* �طŵ��ļ��� */
        struct
        {
            LONG    	lChannel;				/*�طŵ�ͨ����*/
            NET_DVR_TIME struStartTime;			/* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;			/* ��ʱ��طŵĽ���ʱ�� */
            BYTE       byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    DWORD nSessionID;//CMS�����sessionID
    BYTE byRes2[44];
}NET_DVR_PLAYBACKCALLBACKPARAM, *LPNET_DVR_PLAYBACKCALLBACKPARAM;

typedef struct tagNET_DVR_VOICEREQUESETPARAM
{
    BYTE	nVoiceChannel;		//�Խ�ͨ����
    BYTE	byRes1[3];
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD	 wPort;/*CU�˿�*/
    BYTE	byRes2[10];
}NET_DVR_VOICEREQUESTPARAM, *LPNET_DVR_VOICEREQUESTPARAM;

typedef struct tagNET_DVR_ALARMSETUPREQUESETPARAM
{
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD	 wPort;/*CU�˿�*/
    BYTE	byRes[2];
}NET_DVR_ALARMSETUPREQUESTPARAM, *LPNET_DVR_ALARMSETUPREQUESTPARAM;

typedef struct tagNET_DVR_GPSALARMINFO
{
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    NET_DVR_TIME_EX struGpsTime;    /*GPS�ϴ���ʱ��*/
    DWORD	dwLongitude;	/* ����*/
    DWORD	dwLatitude;  /* γ��*/
    int 	iTimeZone; /*ʱ���÷������ʾ��+60��?1��+480��?8��-60�������-480�����8����ֶκ�GPSTime����һ�������ʱ������*/
    DWORD dwDirection; /*��������=ʵ�ʷ����Զ�Ϊ��λ������Ϊ��˳ʱ�뷽����㣩*100*/
    WORD  wSatellites; /*��������*/
    WORD  wPrecision; /*����*/
    DWORD dwHeight; /*�߶�:���ף�Ԥ��*/
    DWORD dwGPSSeq; /*GPS��ţ�GPS����ʱҪ�õ�*/
    WORD  wSpeed;//�ٶȣ���λ��km/h
    /* direction[0]:'E'or'W'(����/����), direction[1]:'N'or'S'(��γ/��γ)*/
    char sDirection[2];
    BYTE byLocateMode;/*��λģʽ(��ֵ0)��1,������λ,2,���3,����,4,�����Ч*/
    BYTE byRes[3];
}NET_DVR_GPSALARMINFO, *LPNET_DVR_GPSALARMINFO;

//ͼƬ��Ϣ�ϴ�
typedef struct tagNET_DVR_PICINFO
{
    DWORD   dwSize;				//�ṹ����
    BYTE    byChanIndex;			//ͨ����
    BYTE    byRes1[3];				//����
    BYTE 	byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE    byAbsTime[32];		//���ʱ���, yyyymmddhhmmssxxx,
    DWORD   dwPicLen;					//ͼƬ����
    BYTE	byRes2[32];
    BYTE	*pPicBuffer;
}NET_DVR_PICTUREINFO, *LPNET_DVR_PICTUREINFO;

//ƽ̨����
typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;//CMS����UDP�����ѯ�Ķ˿�
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;

///���Ź���
#define DIALPASSWD_LEN  32 //�������볤��

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;	/* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;	/* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;	/* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;


typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];		/* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];	/* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];	/* password, eg. "card" */
    BYTE byApn[NAME_LEN];		/* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;		/* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;	/* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

#define MAX_PHONE_NUM		        32//����볤��

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;		/* 0: disable; 1: enable 3g */
    BYTE byDialMethod;		/* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;	/* switch methold: 0: auto switch;1��3G���ȣ�2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* ʹ�ܱ������봥������; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;		/* auto off line when no connection exist,��λ�����ӣ���Χ��5~65535���� */
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;		/*�����*/
    BYTE byNetType;		/* ָ�����ĳ�������Ĭ�ϲ��Ų�������ʱ�˲���û�á�0���Զ���1��CDMA��2��EVDO��3��WCDMA��4��TD-SCDMA */
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;


/* UIM card information */
typedef enum
{
    UIM_UNKNOWN = 0,
        UIM_VALID = 1,
        UIM_NOVALID = 4,
        UIM_ROAM = 11,
        UIM_NOEXIST = 255
}UIM_INFO;

/* real 3g mode */
typedef enum
{
    /* evdo */
    RMODE_CDMA1X = 12,
        RMODE_EVDO = 14,
        RMODE_CDMAHYBRID = 18,
        /* wcdma */
        RMODE_GSM = 21,
        RMODE_GPRS = 22,
        RMODE_EDGE = 23,
        RMODE_WCDMA = 24,
        RMODE_HSDPA = 25,
        RMODE_HSUPA = 26,
        RMODE_HSPA = 27,
        /* tdscdma */
        RMODE_TGSM = 31,
        RMODE_TGPRS = 32,
        RMODE_TEDGE = 33,
        RMODE_TDSCDMA = 34,
        RMODE_TDHSDPA = 35,
        RMODE_TDHSUPA = 36,
        RMODE_TDHSPA = 37
}REAL_MODE;

typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;		/* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;		/* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;			/* signal RSSI */
    DWORD dwDialStatus;		/* dial status */
    NET_DVR_IPADDR struLocalIp;	/* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;	/* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;	/* wireless networks netmask */
    NET_DVR_IPADDR struDns;		/* wireless networks DNS */
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

//���Ź���
#define MAX_WHITELIST_NUM	        8 //��������

#define HARDDISKFULL_EXCEPTION      0x0     /*Ӳ����*/
#define HARDDISKERROR_EXCEPTION     0x1     /*Ӳ�̴�*/
#define ETHERNETBROKEN_EXCEPTION    0x2     /*���߶�*/
#define IPADDRCONFLICT_EXCEPTION    0x3     /*IP��ַ��ͻ*/
#define ILLEGALACCESS_EXCEPTION     0x4     /*�Ƿ�����*/
#define VI_EXCEPTION                0x5     /*��Ƶ�ź��쳣*/
#define VS_MISMATCH_EXCEPTION       0x6     /*����/�����Ƶ��ʽ��ƥ�� */
#define VIDEOCABLELOSE_EXCEPTION    0x7     /*��Ƶ���ź�*/
#define AUDIOCABLELOSE_EXCEPTION    0x8     /*��Ƶ���ź�*/
#define ALARMIN_EXCEPTION           0x9     /*��������*/
#define MASKALARM_EXCEPTION         0xa     /*�ڵ�����*/
#define MOTDET_EXCEPTION            0xb     /*�ƶ����*/
#define RECORDING_EXCEPTION         0xc     /*¼���쳣*/
#define WIRELESS_EXCEPTION          0xd     /*PIR����*/
#define PIR_EXCEPTION				0xe     /*���߱���*/
#define CALLHELP_EXCEPTION          0xf     /*���ȱ���*/

#define AUDIO_DETECTION_EXCEPTION              0x10    /*��Ƶ�쳣��ⱨ��*/
#define SCENECHANGE_DETECTION_EXCEPTION        0x11    /*������ⱨ��*/
#define DEFOCUS_DETECTION_EXCEPTION            0x12    /*�齹��ⱨ��*/
#define FACE_DETECTION_ENTRANCE_EXCEPTION      0x13    /*������ⱨ��*/
#define LINE_DETECTION_ENTRANCE_EXCEPTION      0x14    /*Խ����ⱨ��*/
#define FIELD_DETECTION_ENTRANCE_EXCEPTION     0x15    /*����������ⱨ��*/
#define REGION_EXITING_EXCEPTION               0x16    /*�뿪������ⱨ��*/
#define REGION_ENTRANCE_EXCEPTION              0x17    /*�������򱨾�*/
#define LOITERING_EXCEPTION                    0x18    /*��Ա�ǻ���ⱨ��*/
#define GROUP_EXCEPTION                        0x19    /*��Ա�ۼ���ⱨ��*/
#define RAPIDMOVE_EXCEPTION                    0x1a    /*�����ƶ���ⱨ��*/
#define PARKING_EXCEPTION                      0x1b    /*ͣ����ⱨ��*/
#define UNATTENDEDBAGGAGE_EXCEPTION            0x1c    /*��Ʒ������ⱨ��*/
#define ATTENDEDBAGGAGE_EXCEPTION              0x1d    /*��Ʒ��ȡ��ⱨ��*/


#define PHONECFG_RECEIVE_SMS        0x0    /* ֧�ֽ��ձ������� */
#define PHONECFG_SMS_CONTROL        0x1    /* ֧�ֶ��ſ��������� */
#define PHONECFG_CALL_CONTROL       0x2    /* ֧�ֺ��п������� */
#define PHONECFG_SMS_REBOOT         0x3    /*֧�ֶ�������*/
#define PHONECFG_DOOR_CONTROL       0x4    /* ֧���Ų�������*/

typedef struct tagNET_DVR_PHONECFG
{
    BYTE byWhiteList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*���ֽڱ�ʾ�Ƿ�ʹ�ܸú����ĳ���ܣ�����λ���ĺ���
    ��PHONECFG_RECEIVE_SMS�ȶ��� */
    BYTE byAlarmHandler[32];   /*���ֽڱ�ʾ�Ƿ�ʹ�ܶ�ĳ���������͵Ķ��ŷ���*/
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;	/* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struWhiteList[MAX_WHITELIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;


typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;//��������
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;//�����ָ�볤�ȣ��������
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;			/* the index of sms */
    BYTE byStatus;			/* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;		/* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

#define	MAX_SMSCONTENT_LEN		140//�������ݳ���
typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;

//pin������
typedef enum
{
    CPIN_READY = 1,
        CPIN_PIN = 2,
        CPIN_PUK = 3,
        CPIN_PIN2 = 4,
        CPIN_PUK2 = 5
}PIN_READY;

typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;		/* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;	/* remain input PIN times */
    BYTE byPukTimes;	/* remain input PUK times */
    BYTE bEnableLock;	/* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;

typedef enum
{
    PIN_ENABLE = 1,
        PIN_DISABLE = 2,
        PIN_VERIFY = 3,
        PUK_VERIFY = 4,
        PIN_CHANGE = 5
}PIN_CMD;
#define MAX_PIN_LEN		12  //PIN����󳤶�
typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;		/* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];		/* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];	/* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;


//ͼƬ����
typedef struct
{
    /* 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA*/
    WORD	wPicSize;
    WORD	wPicQuality; /* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
    //ץͼͼƬ���?ʽ��1-�ϴ����ģ�2-�豸���ر��棬3-�ϴ�����ͬʱ�豸���ر���
    BYTE	byPicTackleMode;
    BYTE   byRes[11];
}NET_DVR_PUSHJPEGPARA, *LPNET_DVR_PUSHJPEGPARA;


#define	COM_PUSHALARM		0x1200	//�豸������Ϣ�ϴ�����ģʽ�豸ʹ��
#define	COM_PUSHALARM_V30	0x1201	//�豸������Ϣ�ϴ�v30����ģʽ�豸ʹ��
typedef struct tagNET_DVR_PUSHALARMINFO
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*����������˿ڣ���һλΪ1��ʾ��Ӧ��һ�����*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*������¼��ͨ������һλΪ1��ʾ��Ӧ��һ·¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmTypeΪ2��3,6ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]λ��Ӧ��1��Ӳ��*/
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[4];
}NET_DVR_PUSHALARMINFO, *LPNET_DVR_PUSHALARMINFO;

typedef struct
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯  12-�����쳣 */
    DWORD dwAlarmInputNumber;/*��������˿�*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*����������˿ڣ�Ϊ1��ʾ��Ӧ���*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*������¼��ͨ����Ϊ1��ʾ��Ӧ¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmTypeΪ2��3,6��9��10ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]��Ӧ��1��Ӳ��*/
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[7];
}NET_DVR_PUSHALARMINFO_V30, *LPNET_DVR_PUSHALARMINFO_V30;

//2011-04-20
//��������
typedef struct tagNET_DVR_MB_AUTOWORKPARA
{
    /*��ǰ�������Ʒ�ʽ 0:  Ԥ��,  1:  ��ʱ�ػ�,  2:  �Զ����ػ�*/
    BYTE	byCurPowerCtrlType;
    BYTE	byRes[3];
    NET_DVR_SCHEDTIME	struWorkTime[MAX_DAYS][2];
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD	 dwHaltDelay; /* �ػ��ӳ�ʱ��,��λmin */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*����������ز�������*/
    BYTE       byEnableUnderVoltProtect;   /*�Ƿ���Ƿѹ����*/
    BYTE       byUnderVoltPercent;   /*Ƿѹ�����ٷֱȣ���85��90��95�����Чֵ*/
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;
/*ע��1�����ػ��ӳ�ʱ��, ��ѡʱ��Ϊ 0��5���ӣ�10���� ��20���� 25���� 30���� 35���� 40���� ��45 ���� 50���� ��60���� ��60*2���� ��60*3  60 *4   60*5  60*6 */

//�Զ�����
typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* �Ƿ����Զ����� 0 �ر� ��1 ���� */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30]; 	/*��Ҫ���ݵ�ͨ��*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*��������*/
                                        /* �����ļ�����
                                        {0,ALL_RECORD_TYPE,ȫ��},
                                        {1,TIMING_REC,��ʱ},
                                        {2,MOTION_DETECT_REC,�ƶ���� },
                                        {3,ALARM_REC,���� },
    {4,MANUAL_REC,�ֶ�¼��}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];	/* �Զ�����ʱ���*/
    BYTE  byRes2[36];						/* �����ֽ�*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;


typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;	/*�Ƿ�����GPS */
    BYTE  byGpsInterface;/*gps���սӿ�0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*�ٶȵ�λ��0������/Сʱ��1 ��Ӣ��/Сʱ*/
    BYTE  byEnableRetrieve; /* ä��(1���ã�0������) */
    int	  iAdjustTime;/*ʱ��*/
    BYTE  byEnableAdjustTime;/*�Ƿ�����GPSУʱ�� 1-����, 0-������*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;	/* GPS�ϴ����, ��*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD ��ʾ��ÿ�ֽڴ��һ· */
    DWORD dwSpeedLimit;	/* ���ٱ���*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm;
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;
/*ע��1��������λΪ����/Сʱ ʱ��ΧΪ��0 ,965����������Ӣ��/Сʱ����λ��ʱ�� ������ٶȷ�ΧΪ��0-600*/

#define 		SENSOR_IN_NUMBER  		8
typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*�г�״̬��ش�����������ֻ�ú�4�����ֱ���ɲ������ת����ת��������0-�ߵ�ƽ��1-�͵�ƽ*/
    BYTE  byTriggerChannel [SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay [MAX_CHANNUM_V30];/*OSD��ʾ,ÿλ���һ·*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;


typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD	dwMaxXAcc;	/* X����ٶȱ���ֵ ����ȡֵΪʵ����ֵ����10,��СΪ0*/
    DWORD	dwMaxYAcc;	/* Y����ٶȱ���ֵ ����ȡֵΪʵ����ֵ����10.��СΪ0*/
    DWORD	dwMaxZAcc;	/* Z����ٶȱ���ֵ�� ��ȡֵΪʵ����ֵ����10,��СΪ0*/
    BYTE	byRes[4];
}NET_DVR_ACCELERATIONCFG,*LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*ģ��ѡ��0����/1����*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];	/*������չ�ֽ�*/
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR	struDownloadSvrIp;		/* �Զ����ط�������ַ */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA,*LPNET_DVR_MB_DOWNLOADSVRPARA;

/* ����ʶ�����ز���*/
typedef struct tagNET_DVR_PLATERECOG_PARA
{
    DWORD dwSize;
    BYTE byPrMode; /* ����ʶ���ģʽ, ��̬ͼ��0/��̬��Ƶ1 */
    BYTE byPrScene; /* ����ʶ��ĳ���, ���ٳ���0/���ٳ���1 */
    BYTE byPrDetRect; /* 0:ȫ��Ļ;1:�������� */
    BYTE byPrPicQuality; /* ����ʶ�𷵻ص�ͼƬ����, 0:���/3:��� */
    BYTE byPrPicMode;/*����ʶ�𷵻ص�ͼƬ�ֱ���: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF */
    BYTE byPlateOsdDisplay; /* ����OSD�Ƿ���ʾ 0:����ʾ/1:��ʾ */
    BYTE byPrProvCharIndex;	/* ����ʶ��ʡ���׺��ֶ�Ӧ������ */
    BYTE byPrProvCharIndex1;	/* ����ʶ�𳣼��׺���1��Ӧ������ */
    BYTE byPrProvCharIndex2;	/* ����ʶ�𳣼��׺���2��Ӧ������ */
    BYTE byRes[7];
}NET_DVR_PLATERECOG_PARA, *LPNET_DVR_PLATERECOG_PARA;


/* ��̬ȡ֤ϵͳ,�������ò���Ľṹ*/
typedef struct tagNET_DVR_SPEEDLMT_PARA
{
    BYTE	bStartMaxSpeedLimit;		/* ������������ */
    BYTE	bStartMinSpeedLimit;		/* ������������ */
    BYTE	byRes[6];
    DWORD	dwMaxSpeedLimit;				/* ������� */
    DWORD	dwMinSpeedLimit;				/* ������� */
}NET_DVR_SPEEDLMT_PARA, *LPNET_DVR_SPEEDLMT_PARA;

/* ��̬ȡ֤ϵͳ,���ƱȶԲ���Ľṹ*/
typedef struct tagNET_DVR_PLATECHECK_PARA
{
    BYTE	bAlarmWhenChecked;			/* ���ɹ��Ƿ񱨾� */
    BYTE	bInformWhenChecked;			/* ���ɹ��Ƿ�Ի�����ʾ */
    BYTE	byRes[6];
    NET_DVR_IPADDR struBlackFtpServer;			/* ����FTP��������ַ */
}NET_DVR_PLATECHECK_PARA, *LPNET_DVR_PLATECHECK_PARA;

typedef struct tagNET_DVR_ENFORCESYS_PARA
{
    DWORD dwSize;
    NET_DVR_SPEEDLMT_PARA	struSpeedLmtPara;	/*��������*/
    NET_DVR_PLATECHECK_PARA struPlateCheckPara;	/*���Ʊȶ�*/
    BYTE	bySelPeccType;	/*�Ƿ�ѡ��Υ������*/
    BYTE	byEnfOptHabit; /*ȡ֤����ϰ��, 0:����ȡ֤;1:�̰�����ȡ֤*/
                           /*Ԥ��֡�ʵ���ģʽ�����֣�
                           A �ر� adjPrevFpsMode=0
                           �Թ̶���֡��(25FPS)Ԥ��
                           B ��׼ adjPrevFpsMode=1
                           �Թ̶���֡��(6FPS)Ԥ��
                           C ����Ӧ adjPrevFpsMode=2
                           ���GPS�ٶ���Ϣ��̬����Ԥ��֡�ʣ�
    3������ЧGPS������£��Թ̶���֡��Ԥ��*/
    BYTE	byAdjPrevFpsMode;
    BYTE	byRes1;
    NET_DVR_IPADDR  struUploadServerIp; //�ϴ���������ַ
    WORD	wUploadServerPort;
    BYTE	byRes2[18];
}NET_DVR_ENFORCESYS_PARA, *LPNET_DVR_ENFORCESYS_PARA;

typedef struct tagNET_DVR_PUSHMODEPARAM
{
    //ֱ��ģʽ��UDPԤ��ģʽ��1-ͬ�˿ڶ�·����2-һ�˿�һ·��
    BYTE byUdpPreviewMode;
    //�����Խ�����ģʽ��0-�����Խ���1-����ת����SDK�����������Ĳɼ��Ͳ��ţ�
    BYTE byVoiceWorkMode;
    BYTE byRes[18];
}NET_DVR_PUSHMODEPARAM, *LPNET_DVR_PUSHMODEPARAM;

#define MAX_ALARMHOST_ALARMIN_NUM	        512//���籨��������󱨾��������
#define MAX_ALARMHOST_ALARMOUT_NUM	        512//���籨��������󱨾��������

#define ALARMHOST_MAX_AUDIOOUT_NUM		    32//���籨������������������
#define ALARMHOST_MAX_ELECTROLOCK_NUM		32//���籨��������������
#define ALARMHOST_MAX_MOBILEGATE_NUM		32//���籨����������ƶ�����
#define ALARMHOST_MAX_SIREN_NUM             8 // ��󾯺���Ŀ
#define MAX_ALARMHOST_SUBSYSTEM             32//�������������ϵͳ��

//����������
typedef enum tagSENSOR_TYPE
{
    SENSOR_TYPE_NONE = 0,                   // ��
        SENSOR_TYPE_TEMPERATURE = 1,            // �¶�
        SENSOR_TYPE_HUMIDITY ,                  // ʪ��
        SENSOR_TYPE_WINDSPEED,                  // ����
        SENSOR_TYPE_GAS,                        // ����
        SENSOR_AC_VOLTAGE,                      // ������ѹ
        SENSOR_AC_CURRENT,                      // ��������
        SENSOR_DC_VOLTAGE,                      // ֱ����ѹ
        SENSOR_DC_CURRENT,                      // ֱ������
        SENSOR_WATER_PRESSURE,                  // ˮѹ
        SENSOR_PRESSURE_TRANSMITTER,            // ѹ��������
        SENSOR_FLOW_TRANSMITTER,                // ����������
        SENSOR_WATER_LEAKAGE,                   // ©ˮ������
        SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,//һ�廯�±�
        SENSOR_ISOLATION_TEMPERATURE_DETECTOR,  //����ʽ�±�
        SENSOR_RESIDUAL_CHLORINE,               //����������
        SENSOR_TYPE_AC_TERMINAL = 16,           //AC����
        SENSOR_TYPE_AC_SOCKET = 17,             //AC����
        SENSOR_TYPE_UNKNOW = 255                // δ����
}SENSOR_TYPE;

typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD  dwSize;                 // �ṹ���С
    BYTE    byName[NAME_LEN];    // ���������
    BYTE    byEnable;               // �Ƿ�����
    BYTE    byValid;                // �Ƿ���Ч ����������(�ò���ֻ�ܻ�ȡ���ܸ�����)
    BYTE    byType;                 // ģ�������� ����SENSOR_TYPE
    BYTE	byAlarmMode;//����ģʽ�����֣�15-HHHH��14-HHHL��12-HHLL��8HLLL��0-LLLL������1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������)
    float   fMeasureHigh;           // ��������
    float   fMeasureLow;            // ��������
    float	fAlarm1;           //������1,������1-4 ��������
    float	fAlarm2;           //������2
    float	fAlarm3;           //������3
    float	fAlarm4;           //������4
    DWORD   dwOsdCfg;          //ģ�����ַ���ӣ���λ��ʾ0-15��Ӧ��Ƶͨ��1-16
    float	fSensitive;			// �����ȱ�ʾ��ʵʱֵ�ı仯���������ȵķ�Χʱ�����ʾʵʱֵ�����˱仯��������Ϊû�з���仯���磺������Ϊ0.1�����ʾǰ���������ֵ֮�����0.1ʱ������Ϊ��ݷ���仯����0.1����Ҫ�ϴ������Ϊ1�����ʾ�仯����1ʱ�ϱ���
    BYTE	bySensorStandard;	//���������0- 0~20mA��1, 0~5V
    BYTE	byChan;			//ģ����ͨ����
    BYTE    byRes3[114];            // �����ֽ�
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;					// �ṹ��С
    BYTE    byName[NAME_LEN];		// ���
    WORD    wDelay;					// ����ӳ� ��λΪ��, ��Χ 0~5599s 0��ʾһֱ�����
    BYTE	byRes1[2];
    DWORD   dwOverallEventJointSirenOn;		//ȫ���¼�������������������¼����Ͱ�λ��ʾ��bit0-�������, bit1-ȫ�ּ��̽�������,bit2-������ϵ磬bit3-��ص�ѹ��,bit4-�绰�ߵ���,bit5-���������쳣,bit6-���������쳣,  bit7-����485����
    DWORD	dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//��ϵͳ�¼�����������������������±��ʾ��ϵͳ�ţ�ÿһ��Ԫ�ذ�λ��ʾ�¼����ͣ�bit0-��������
    BYTE    byRes2[448];  // �����ֽڡ���
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD	dwSize;		// �ṹ���С
    BYTE	byEnable;	// 0--�ػ� 1--����
    BYTE	byMode;		// �յ�ģʽ
    BYTE	byTemperature;	// �¶ȣ�����ֵ��ʾ ͨ��Ϊ16-30��
    BYTE	byRes[9];		// �����ֽ�
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;

typedef enum tagDETECTOR_TYPE
{
    PANIC_BUTTON = 0,               // ��������
        MAGNETIC_CONTACT,               // �Ŵſ���
        SMOKE_DETECTOR,                 // �̸�̽����
        ACTIVE_INFRARED_DETECTOR,       // ��������̽����
        PASSIVE_INFRARED_DETECTOR,      // ��������̽����
        GLASS_BREAK_DETECTOR,           // ��������̽����
        VIBRATION_DETECTOR,             // ��̽����
        DUAL_TECHNOLOGY_PIR_DETECTOR,   // ˫���ƶ�̽����
        TRIPLE_TECHNOLOGY_PIR_DETECTOR, // ����̽����
        HUMIDITY_DETECTOR,              // ʪ��̽����
        TEMPERATURE_DETECTOR,           // �¸�̽����
        COMBUSTIBLE_GAS_DETECTOR,        // ��ȼ����̽����
        DYNAMIC_SWITCH,					//�涯����
        CONTROL_SWITCH,					//���ƿ���
        OTHER_DETECTOR = 0xffff          // ����̽����
}DETECTOR_TYPE;

typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�����4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ�������  8-24Сʱ�������9-24Сʱ�𶯷��� 0xff-��
    BYTE    byUploadAlarmRecoveryReport;    //�Ƿ��ϴ������ָ����棬0-���ϴ���1-�ϴ�
    DWORD	dwParam;    // �������  ��ʱ������ʱ�೤ʱ��, ������������������б����������ʱʱ��ͨ��������������� , �������������÷�ʽͨ���������е�bySupportAlarmInDelay�ֶ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*����ʱ��ʱ���*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // ������������������
    BYTE	byAssociateSirenOut[8];		//  ������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE	bySensitivityParam;//���������Ȳ���, 0-10ms��1-250ms��2-500ms��3-750ms
    BYTE	byArrayBypass;//�Ƿ������·��,0-��֧������·,1-֧������·
    BYTE	byJointSubSystem; //������������ϵͳ�ţ��ò���ֻ�ܻ�ȡ
    BYTE    byModuleStatus;	//ģ��״̬ 1-���� 2-����
    WORD	wModuleAddress;	//ģ���ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE	byModuleChan;	//ģ��ͨ���ţ���1��ʼ�����ֵ���ģ��������������0xFF��ʾ��Ч
    BYTE	byModuleType;	//ģ�����ͣ�1-���ط���2-������3-˫����4-8����5-8·ģ��������, 6-��������
    WORD	wZoneIndex;		//����ţ��ò���ֻ�ܻ�ȡ
    WORD    wInDelay;    //������ʱ��0-255��
    WORD    wOutDelay;    //�˳���ʱ��0-255��
    BYTE    byAlarmType;     //���������� 0-��Ч��1-������2-����
    BYTE	byZoneResistor;	//������裬��λǧŷ  0-��Ч 1--2.2 ��2--3.3��3--4.7��4--5.6 �� 5--8.2 ��0xff-�Զ���
    float	fZoneResistorManual;/*�����ֶ����裬1.0-10.0����ȷ��С����һλ����λǧŷ��byZoneResistorΪ0xffʱ��Ч*/
    BYTE    byRes2[32];      // �����ֽ�
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             // �ṹ���С
    BYTE    byName[NAME_LEN];   // ���
    WORD    wDelay;             // ����ӳ� ��λs, ��Χ��0~3599s 0 ��ʾһֱ�����
    WORD	wTriggerIndex;		//�������ţ��ò���ֻ�ܻ�ȡ
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //��ʾ���Ÿ���ı�������ͨ�� �������������ͬʱ����һ����������������±�0��ʾ��������1���������� 0-������ 1-����
    BYTE	byModuleType;	//��Ӵ��������ͣ�1-���ش������� 2-4·��������3-8·������ 4-����������5-32·������
    BYTE	byModuleStatus;	//��Ӵ�����״̬ 1-���� 2-����
    WORD	wModuleAddress;	//��Ӵ�������ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE	byModuleChan;	//��Ӵ�����ͨ���ţ���1��ʼ�����ֵ���ģ��������������0xFF��ʾ��Ч
    BYTE	byWorkMode;		//����ģʽ��1-������2-�涯
    BYTE	byAlarmOutMode;	//���ģʽ��1-������ģʽ��2-����ģʽ
    BYTE	byTimeOn;		//��ʱ�� 1~60s
    BYTE	byTimeOff;		//��ʱ�� 1~60s
    BYTE   	byRes2[51]; 			//�����ֽ�
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//��������ͨ�� �����±�0��Ӧ���������1����������
    BYTE byRes[100];//�����ֽ�
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڲ���״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ��������ڴ��ڳ���״̬��1-��Ӧ��������ڴ��ڲ���״̬
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڱ���״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ��������ڵ�ǰ�ޱ�����1-��Ӧ��������ڵ�ǰ�б���
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//���������״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ����������ޱ�����1-��Ӧ����������б���
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // ��·״̬ �����±��ʾ0��Ӧ���������1 0-��ʾ���������û����· 1-��ʾ�����������·
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //��ϵͳ����״̬,0-��Ӧ��ϵͳ���ڳ���״̬��1-��Ӧ��ϵͳ���ڲ���״̬
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڹ���״̬��0-��Ӧ��������ڴ�����״̬��1-��Ӧ��������ڴ��ڹ���״̬
    BYTE   byRes[56];      //  �����ֽ�
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//�����״̬��(���֧��512�������ѯ)��0-��Ӧ�����ڳ���״̬��1-��Ӧ�����ڲ���״̬
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//����״̬��(���֧��512�������ѯ)��0-��Ӧ����ǰ�ޱ�����1-��Ӧ����ǰ�б���
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//������״̬��(���֧��512����������ѯ)��0-��Ӧ�������ޱ�����1-��Ӧ�������б���
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // ��·״̬ �����±��ʾ0��Ӧ����1 0-��ʾ����û����· 1-��ʾ������·
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬,0-��Ӧ��ϵͳ���ڳ���״̬��1-��Ӧ��ϵͳ���ڲ���״̬
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//�������״̬��0-��Ӧ��������״̬��1-��Ӧ�����ڹ���״̬
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������״̬�� 0-��Ӧ����ǰ�ޱ�����1-��Ӧ����ǰ�б�����0xffffff
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; // �������״̬��0-��Ӧ�����ޱ�����1-��Ӧ�����б���
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬��0-��Ч��1-��Ӧ��ϵͳδ���ã�2-��Ӧ��ϵͳ����
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM];/* 0-��Ч��1-���������2-��ʱ������3-���ز���*/
    BYTE   byRes[448];      //  �����ֽ�
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    // �������״̬ 0-���Ŵ����ޱ���״̬��1-���Ŵ����б���״̬
    BYTE   byRes[92];             // �����ֽ�
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

//ʹ��״̬����
typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//�������ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//����ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//�ƶ���ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//����ʹ�ܣ� 0-���ܣ�1-ʹ��
    BYTE  bySerialPurpose;//������;��0-���ڼ�����������1-����PTZ����
    BYTE  byRes[63];
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;					  // �ṹ���С
    WORD    wTotalAlarmInNum;         // �������������(����),��������
    WORD    wLocalAlarmInNum;         // ���ر��������
    WORD    wExpandAlarmInNum;        // ����չ�ı��������
    WORD    wTotalAlarmOutNum;        // ������������� ���豸֧�ֵ�����
    WORD    wLocalAlarmOutNum;        // ���ر�������ڸ���
    WORD    wExpandAlarmOutNum;       // ����չ�ı��������
    WORD    wTotalRs485Num;           // ������������� ���豸֧�ֵ�����
    WORD    wLocalRs485Num;           // ����485����
    WORD    wExpandRs485Num;          // ����չ��485����
    WORD	wFullDuplexRs485Num;    // ȫ˫����485����
    WORD    wTotalSensorNum;          // ģ���������� (�豸֧�ֵ�����)
    WORD	wLocalSensorNum;		// ����ģ��������
    WORD    wExpandSensorNum;         // ����չ��ģ��������
    WORD    wAudioOutNum;			    //�����������
    WORD    wGatewayNum;			//�Ž����
    WORD    wElectroLockNum;		    //�������
    WORD    wSirenNum;     			// �������Ŀ
    WORD    wSubSystemNum;			// �ɻ�����ϵͳ��Ŀ
    WORD    wNetUserNum;            // �����û���
    WORD    wKeyboardNum;           // ������
    WORD    wOperatorUserNum;           // �����û���
    BYTE    bySupportDetector;//�Ƿ�֧�ֳ���������̽������1-֧�֣�0-��֧��
    BYTE    bySupportSensitivity;//�Ƿ�֧�ַ��������ȣ�1-֧�֣�0-��֧��
    BYTE    bySupportArrayBypass;//�Ƿ�֧������·��1-֧�֣�0-��֧��
    BYTE    bySupportAlarmInDelay;//�Ƿ�֧�ַ����ӳ�,1-֧�֣�0-��֧��
    //���bySupportAlarmInDelayΪ1ʱ����ʾ�ͻ���Ӧ��ʹ��NET_DVR_ALARMIN_PARAM �е�dwParam��������ʱʱ�䣬������������������б�������ʹ������������ʱ��ʽ;
    //���bySupportAlarmInDelayΪ0ʱ����ʾͨ��NET_DVR_ALARMSUBSYSTEMPARAM �е�wEnterDelay ��wExitDelay ������
    BYTE    bySupportAlarmInType[16];//֧�ֵķ�������,����0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�����4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ������� 15-��
    BYTE	byTelNum;		//֧�ֵ绰����
    BYTE	byCenterGroupNum;	//���������
    BYTE	byGPRSNum;		//GPRS���������4��
    BYTE	byNetNum;		//�������������4��
    BYTE	byAudioNum;		//��Ƶ����
    BYTE	by3GNum;		//3Gģ�����
    BYTE	byAnalogVideoChanNum;		//ģ����Ƶͨ������
    BYTE	byDigitalVideoChanNum;		//������Ƶͨ������
    BYTE	bySubSystemArmType;		//��ϵͳ�������ͣ�0-��ʾ��֧�֣�1-��ʾ֧�֡�bit0-��ͨ������ע������С����ֻ֧����ͨ���������������м�����ֶε�ʱ������С�����Ѿ���������������С�����и��ֶ�Ϊ0��������0��ʾ֧�֣�1��ʾ��֧�֡�����ӿ���SDK�ڲ��������ݣ���bit1-��ʱ������bit2-���ز�����
    BYTE	byPublicSubSystemNum;	//������ϵͳ����
    DWORD	dwSupport1;	//��λ��ʾ������0��ʾ֧�֣�0��ʾ��֧��
    // bit0: 	�Ƿ�֧����ϵͳ�����þ������ʱ�䣬���֧���򾯺����ʱ����ÿ����ϵͳ�����ã����֧�֣�����ʱ���ھ��Ų���������������
    // bit1:	�Ƿ�֧���¼����������������
    // bit2:	�Ƿ�֧���¼�������������ر�
    // bit3:	�Ƿ�֧����ϵͳʹ��
    // bit4;	�Ƿ�֧�ַ����
    // bit5;	�Ƿ�֧����ϵͳ�Զ�������
    // bit6:	�Ƿ�֧�־�����Ϲ����������
    // bit7:	�Ƿ�֧�ֹ���״̬��ѯ
    // bit8:	�Ƿ�֧����ϵͳ��չ����
    // bit9:    �Ƿ�֧��Կ�׷��������ϵͳ
    // bit10:   �Ƿ�֧��"������ʾ�ɹ����ͱ���"����
    // bit11:   �Ƿ�֧�ֵ��뵼����������
    // bit12:   �Ƿ�֧��LED��Ļ��������
    // bit13: �Ƿ�֧�ֹ��Ϲ������ع��ϵ����
    DWORD	dwSubSystemEvent;		//��ϵͳ�¼�����λ��ʾ��0��ʾ��֧�֣���0��ʾ֧��,bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������
    DWORD	dwOverallEvent;			//ȫ���¼�����λ��ʾ��0��ʾ��֧�֣���0��ʾ֧�֣�bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣
    DWORD	dwFaultType;			//�豸֧�ֵĹ������ͣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-�����̵��ߣ�bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣
    BYTE	byPublicSubsystemAssociateSubsystemNum;	//������ϵͳ�ɹ�������ϵͳ����
    BYTE	byOverallKeyboard;	//ȫ�ּ��̸���
    WORD    wSafetyCabinSupport; //�����տ�������������λ��ʾ������0��ʾ֧�֣�0��ʾ��֧��
    //bit0: �Ƿ�֧�ַ����տ���������ģʽ����
    //bit1: �Ƿ�֧�����źŴ�������������
    //bit2: �Ƿ�֧��Ļ���������������ã�̽���ӳ�ʱ�䡢��״̬�仯��Ӧʱ�䣩
    //bit3: �Ƿ�֧�ֺ�����䴫�����������ã��˲���
    //bit4: �Ƿ�֧�ַ�����ʹ�ó�ʱʱ������
    BYTE	by485SlotNum;		//485�����λ��
    BYTE	byRes2;			//  �����ֽ�
    WORD	wKeyboardAddrNum;      // ���̵�ַ��
    BYTE	byRes[118];			//  �����ֽ�
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

#define MAX_485CHAN				256	//485ͨ����
#define MAX_485SLOT				256	//485��λ��
typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD		dwSize;
    BYTE		byAll;	//0-����ȫ����ȡ��1-ȫ����ȡ
    BYTE		byres[3];
    BYTE		byIndex[MAX_485SLOT];			//485��λ��
    BYTE   		byRes[64];      //����
}NET_DVR_485_SLOT_LIST_INFO,* LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD		dwSize;
    BYTE		byAll;	//0-����ȫ����ȡ��1-ȫ����ȡ
    BYTE		byres[3];
    BYTE		byIndex[MAX_485CHAN];			//485ͨ���� �±��ʾͨ���ţ�ֵ0-��ʾ��ʹ�ã�1��ʾʹ��
    BYTE   	byRes[64];      //����
}NET_DVR_485LIST_INFO,*LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    sDeviceName[NAME_LEN];  // ǰ���豸���
    WORD    wDeviceType;            // ǰ���豸����,ͨ��NET_DVR_GetDeviceTypeList��ȡ
    WORD    wDeviceProtocol;        // ǰ���豸Э�� ͨ���ȡЭ���б��ȡ
    DWORD   dwBaudRate;             //������(bps)��0-50��1-75��2-110��3-150��4-300��5-600��6-1200��7-2400��8-4800��9-9600��10-19200��11-38400��12-57600��13-76800��14-115.2k
    BYTE    byDataBit;              // ����м�λ��0-5λ��1-6λ��2-7λ��3-8λ
    BYTE    byStopBit;              // ֹͣλ��0-1λ��1-2λ
    BYTE    byParity;               //�Ƿ�У�飺0-��У�飬1-��У�飬2-żУ��
    BYTE    byFlowcontrol;           // �Ƿ����أ�0-�ޣ�1-������,2-Ӳ����
    BYTE	byDuplex;				// 0 - ��˫��1- ȫ˫��  ֻ��ͨ��1������ȫ˫������ֻ���ǰ�˫��
    BYTE    byWorkMode;                // ����ģʽ 0-����̨ 1-͸��ͨ��,2-�ݿأ�3-������,0xfe-�Զ��壬0xff-����
    BYTE	byChannel;				//485ͨ����
    BYTE    byRes[37];              // �����ֽ�
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

#define MAX_DEVICE_PROTO_NUM       256
#define MAX_DEVICE_TYPE_NUM			256

// 485ǰ���豸֧��Э���б�
typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             // �ṹ���С
    DWORD   dwProtoNum;         // Э�����
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  // Э������
    BYTE    byRes[12];          // �����ֽ�
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD	dwType;
    BYTE	byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD	dwSize;				// �ṹ���С
    DWORD	dwTypeNum;			// ���͸���
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE	byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

#define	MAX_ALARMHOST_VIDEO_CHAN	64
typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                 // �ṹ���С
    BYTE   sUserName[NAME_LEN];    // �û���
    BYTE   sPassword[PASSWD_LEN];	// ����
    NET_DVR_IPADDR	struUserIP;					/* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE   byMACAddr[MACADDR_LEN];			/* �����ַ */
    BYTE   byUserType; // 0-��ͨ�û� 1-����Ա�û�
    BYTE   byAlarmOnRight;         // ����Ȩ��
    BYTE   byAlarmOffRight;        // ����Ȩ��
    BYTE   byBypassRight;          // ��·Ȩ��
    BYTE   byOtherRight[MAX_RIGHT];  // ����Ȩ��
    // 0 -- ��־Ȩ��
    // 1 -- �����ػ�
    // 2 -- ��������Ȩ��
    // 3 --	�����ȡȨ��
    // 4 -- �ָ�Ĭ�ϲ���Ȩ��
    // 5 -- �������Ȩ��
    // 6 -- PTZ ����Ȩ��
    // 7 -- Զ����Ȩ��
    // 8 -- Զ��Ԥ��
    // 9 -- Զ���ֶ�¼��
    // 10 -- Զ�̻ط�
    BYTE	byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN/8];	// Զ�̿���Ԥ����ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE	byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN/8];	// Զ�̿���¼���ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE	byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN/8]; // Զ�̿��Իطŵ�ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE	byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN/8];		// Զ�̿���PTZ��ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    //BYTE	byPriority;										// ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--��
    //�ޣ���ʾ��֧�����ȼ������ã�
    //�ͣ�Ĭ��Ȩ�ޣ�����Զ�̻طţ�Զ�̲鿴��־��״̬��Զ�̹ػ�/������
    //�У�����Զ�̿�����̨��Զ���ֶ�¼��Զ�̻طţ������Խ���Զ��Ԥ�������ر��ݣ�����/Զ�̹ػ�/������
    //�ߣ�����Ա��
    BYTE	byRes2[168];              // �����ֽ�
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;

typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD 	dwSize; 	// �ṹ���С
    DWORD	dwID;		// �����û�ID
    BYTE	byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //����Ȩ��  �������±��ʾ ���֧��512������ 0 - ��Ȩ�� 1- ��Ȩ��
    BYTE	byRes[560];		// �����ֽ�
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;

typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD	 dwSize;		// �ṹ���С
    BYTE    sUserName[NAME_LEN];    // �û���
    BYTE    sPassword[PASSWD_LEN];  // ����
                                    BYTE   bySubSystemPermission;/*0-��װԱȨ�� ����ԱȨ�ޣ�������ϵͳ�����£� 1-���������޲������棬������· 2-���������޳������棬������· 3-���������޲��������棬������·
                                                                 4-���������в�//�����棬������· 5-���������г������棬������· 6-���������в��������棬������·  7-���������޲��������棬������·
                                                                 8-���������޲��������棬������· 9-���������޲��������棬������· 10-���������в������棬������· 11-���������г������棬������· 1
                                    2-���������в��������棬������·*/
                                    BYTE    byRes[63];             //  �����ֽ�
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD	dwSize;		// �ṹ���С
    BYTE	byName[NAME_LEN];	//  �Ž����
    BYTE	byEnable;	// �Ƿ�����
    BYTE    byLocalEnable;  //  �����Ƿ�����
    WORD    wDelayTime;	// ������ʱʱ��	��λΪ��0-65535 0Ϊһֱ����
    BYTE	byLockWorkMode;//������ģʽ��0-ͨ��������1-�ϵ�����
    BYTE	byRes[31];	// �����ֽ�
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD   dwSize;		        // �ṹ���С
    DWORD   dwAbsTime;	        // ���ʱ����Ϣ  OSD��ʾ��Ϣ
    BYTE    byName[NAME_LEN]; 	// sensor ���
    BYTE    bySensorChannel;    // ģ����ͨ��
    BYTE    byType;             // ģ��������
    BYTE	byAlarmType;	    // 1-��4��2-��3��3-��2��4-��1��5-��1��6-��2��7-��3��8-��4 �͵�ǰģʽ�й�
    // ���統Ϊ1000ʱ,����1��1��2��3�������ֱ���
    BYTE	byAlarmMode;        //����ģʽ�����֣�-HHHH��-HHHL��-HHLL��HLLL��-LLLL�� ��Ϊƽ̨�����̶��жϹ���,����1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������)
    float	fValue;		        // ��ǰģ������ֵ
    BYTE	byRes2[32];		    // �����ֽ�
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;

typedef struct
{
    /*Ԥ����Ŀǰ��������ı���û������(���������򣬼���������)*/
    DWORD  dwAlarmType;
    /*����0��Ӧ��1������˿�*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE	byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO,*LPNET_DVR_ALARMHOST_ALARMINFO;
// �����������ϴ�
typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN]; 	// switch ���
    WORD  wSwitchChannel;     // ������ͨ��, 0-255
    BYTE	byAlarmType;		// �������� 0--��1--��·��2--��·,3-�쳣
    BYTE 	byRes[41];			// �����ֽ�
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;

typedef union tagNET_DVR_ALARMHOST_EXCEPTION_PARAM
{
    DWORD   dwUnionSize[20];        // �������С
}NET_DVR_ALARMHOST_EXCEPTION_PARAM, *LPNET_DVR_ALARMHOST_EXCEPTION_PARAM;

typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // �ṹ���С
    // �쳣����  1-�豸���𱨾� 2-�豸������ָ��� 3-����Դ���籨�� 4-����Դ�����ָ��� 5-�ڲ�ͨ�Ź��ϱ���
    // 6-�ڲ�ͨ�Ź��Ϻ�ָ���  7-�绰�߶��� 8-�绰�߶��߻ָ� 9-�Լ�ʧ�ܱ���  10-�Լ�ʧ�ܺ�ָ���
    // 11����Ƿѹ  12���ص�ѹ�ָ���13-���ع��ϣ�14-MBUSģ����ߣ�15-MBUSģ����߻ָ���16-���̵��ߣ�
    //17-���̵��߻ָ���18-�豸���ƶ���19-�豸���ƶ���λ  20-485������·�ϱ���  21-485������·�Ϻ�ָ���
    //25-�Ӱ�1����,26-�Ӱ�1�γ�, 27-�Ӱ�2����,28-�Ӱ�2�γ�
    DWORD   dwExceptionType;
    BYTE   byRes[36];          // ����
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

//�����в��Ų������ü����÷�ʽ����
#define MAX_CENTERNUM			4		//G1,G2 G3 G4����N1��N2��N3��N4����T1��T2��T3��T4
typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //���ĺ���
    BYTE byRepeatCall;          //�ظ����Ŵ���1~15��
    BYTE byPstnProtocol;        //ͨ��Э�飬0-CID��
    BYTE byDialDelay;           //������ʱ�����150s, 0-150
    BYTE byPstnTransMode;       //���䷽ʽ��0-DTMF 5/S��1-DTMF 10/S��
    BYTE byRes1[6];
    BYTE byReceiverId[6];     	//���ջ�ʶ���˺ţ�
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//�����Ĳ���
    WORD wReportPeriod;      //���Ա����ϴ����ڣ�Сʱ�������ֵ֧��7�죬��168Сʱ), ��Χ��1-168
    WORD wFirstReportTime;	 //���豸��������һ�����Ա����ϴ���1~3600����
    BYTE  byReportValid;	//0-�����ò��Ա����ϴ� 1-���ò��Ա����ϴ�
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//���÷�ʽ��0�������ã�1��һֱ���ã�2:���߶����ã���ʱ�رգ�
    BYTE byCallType; //�ϴ����ķ�ʽ��1-�����ģ�2-˫���ģ�3��һ��һ��
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

#define  MAX_PU_CHAN_NUM    512

typedef struct tagNET_DVR_PU_CHAN_INFO
{
    NET_DVR_IPADDR  struIpAddr;     // ip��ַ
    WORD            wPort;          // �˿�
    WORD            wChannel;       // ͨ��
    BYTE            byRes[24];      //
}NET_DVR_PU_CHAN_INFO, *LPNET_DVR_PU_CHAN_INFO;

typedef struct tagNET_DVR_PU_CHAN_LIST
{
    DWORD   dwSize;     // �ṹ��
    DWORD   dwNum;      // ǰ��ͨ������
    NET_DVR_PU_CHAN_INFO struPuChanInfo[MAX_PU_CHAN_NUM];
}NET_DVR_PU_CHAN_LIST, *LPNET_DVR_PU_CHAN_LIST;

#define  MAX_ALARM_CAM_NUM	32		// ��������CAM������

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   // �Ƿ�����PTZ����
    BYTE    byType;     // PTZ ���Ƶ����� 1- Ԥ�õ� 2 -Ѳ��  3-�켣
    BYTE    byPtzNo;    //  ptz ���Ƶ�Ԥ�õ� Ѳ�� �켣��
    BYTE    byRes[5];    // �����ֽ�
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD			dwCamID;      // ������CAMͨ������
    DWORD           dwRecordTime;   // ����¼��ʱ�� ��λΪs  -1��ʾһֱ¼�� 0 ��ʾ��¼��
    DWORD           dwMonID;      // ����Cam��Mon����ʾ
    DWORD           dwResidentTime; // ��Ѳͣ��ʱ�䵥λΪs  -1��ʾһֱͣ�� 0 ��ʾ��ͣ��
    NET_DVR_PTZ_CTRL struPtzCtrl;    // PTZ������Ϣ
    BYTE			byAlarmOffMode;		// �����л���ǽȡ��ģʽ   0-����ȡ��1-�Զ�ȡ��2-�ֶ�ȡ�� ����ȡ����ȡ��ʱ����ȡ�������ǽ   �Զ�ȡ����ȡ��ʱ�ȴ�һ��ʱ���ȡ�������ǽ������Լ����20��  �ֶ�ȡ���û�ͨ���ֶ��ķ�ʽȡ��
    BYTE            byDevType;		// ���豸Ϊ�����豸ʱ����Ч��ʾ���ܱ����豸ȡ��Դ 1-���뿨	 2-���뿨
    BYTE            byDecChan;		// ��Ϊ����ͨ��Ϊ����ͨ����
    BYTE            byRes[17];      // �����ֽ�
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD		dwSize;			// �ṹ���С
    BYTE        byEnable;       // �Ƿ����ñ�������CAM���� �豸Ĭ�ϲ�����
    BYTE        byRes[7];       // �����ֽ�
    DWORD		dwNum;			// ����CAM�����ĸ��� ��ȡ�����ǰ������Ч����
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

#define MAX_GATEWAY_NUM 		8  // ����Ž����
typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD 		dwSize;
    BYTE		byEnterDoor[8];	// �±��ʾ�Ž�ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE		byExitDoor[8]; 	// �±��ʾ�Ž�ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE 		byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  //�����������룬�±��ʾ��������ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE 		byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

//����ϴ����أ������ϴ����ص���չ��
typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD 		dwSize;
    BYTE		byUploadType;	/*�ϴ���ʽ��1-����ļ����Ե�ַ��ȡ����ļ��ϴ��� 2-�ӻ������ȡ����ϴ�*/
    BYTE		byDataType;		//������ͣ�1-��Ƶ���
    BYTE		byDataNum;		//��ݱ�ţ��磺�ϴ���������ò����ʾ�����ţ�����һ�������ţ���ʱ��ʾ����
    BYTE		byAudioType;		//������ʽ��0-wave
    char		sFileName[260];		//����ļ���ȫ·��
    char		*lpBuffer;			//��ݻ�����
    DWORD		dwBufferSize;		//�������С
    BYTE		byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_ALARMHOST_PARAM
{
    DWORD 		dwSize;
    BYTE		byDownType;		/*���ص���ݱ��淽ʽ��1-����ļ����Ե�ַ������ݣ� 2-ͨ��ص������ȡ���*/
    BYTE		byDataType;		//������ͣ�1-��Ƶ���
    BYTE		byDataNum;		//��ݱ�ţ��磺������������ò����ʾ�����ţ�����һ�������ţ���ʱ��ʾ����
    BYTE		byRes1;
    char		sFileName[260];		//����ļ���ȫ·��
    DATADOWNLOAD lpDataCallBack; //����ʱ�Ļص�������
    void*		pUserData;	//�û���ݣ����ڻص������д���
    BYTE		byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;


typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD 		dwSize;
    BYTE		byDownType;		/*���ص���ݱ��淽ʽ��1-����ļ����Ե�ַ������ݣ� 2-ͨ��ص������ȡ���*/
    BYTE		byDataType;		//������ͣ�1-��Ƶ���
    BYTE		byDataNum;		//��ݱ�ţ��磺������������ò����ʾ�����ţ�����һ�������ţ���ʱ��ʾ����
    BYTE		byRes1;
    char		sFileName[260];		//����ļ���ȫ·��
    DATADOWNLOAD lpDataCallBack; //����ʱ�Ļص�������
    void*		pUserData;	//�û���ݣ����ڻص������д���
    BYTE		byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;

//LED��Ļ����
typedef  struct tagNET_DVR_LED_SCREEN_CFG
{
    DWORD 		dwSize;
    BYTE		sLEDName[NAME_LEN/*32*/];	// LED��Ļ���
    BYTE		byTransMode; 				// ��ֻ֧�ִ���ͨѶ 1-����ͨ��
    BYTE		byProtocolType;				// Э�����ͣ���ӦLED���ĳ���
    BYTE		byLEDColor; 				// 1-��ɫ�� 2-˫ɫ�� 3-256���Ҷ�˫��ɫ�� 4- ȫ��ɫ��Ŀǰֻ�õ�ɫ��
    BYTE		byDataPolarity;				// ��ݼ��� .0-������1-��
    BYTE		byOEPolarity;				// 0-����Ч 1-����Ч
    BYTE		byScanMode; 				// 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-��̬
    BYTE		byRes1[2];
    //��Ļ��Ⱥ͸߶���С��16*16�㣬�����8����
    WORD		wLEDWidth;	 				// 16~2048
    WORD 		wLEDHeight;					// 16~2048
    BYTE		byRes2[64];
}NET_DVR_LED_SCREEN_CFG, *LPNET_DVR_LED_SCREEN_CFG;

//LED��������
#define  MAX_CONTENT_LEN  512
typedef  struct tagNET_DVR_LED_CONTENT_CFG
{
    DWORD 		dwSize;
    BYTE		sLEDContent[MAX_CONTENT_LEN];	// LED��Ļ��ʾ����
    BYTE		byContentAct;					// 1-��̬��2-���ٴ����3-�����ƶ���4-�����ƶ��� 5-�����ƶ��� 6-�����ƶ�
    BYTE		byContentSpeed;					// 1-24��1��죬24����
    BYTE		byContentStayTime; 				// 0-127.5s(����0.5s�� SDK����ʱ��*2����������ֵ0-255���豸����ʹ�õ�ʱ�������2)
    BYTE		byRes[33];
}NET_DVR_LED_CONTENT_CFG, *LPNET_DVR_LED_CONTENT_CFG;

//LED��ʱ���ػ�
#define 	LED_TIMER_NUM 			3			// LED����ػ�ʱ������
#define		TIME_SEGMENT_A_DAY		48			// ʱ��θ���һ��24Сʱ����Сʱһ����

typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE	byValid;				// ���鶨ʱʱ���Ƿ���Ч��ʱ���ǳɶ����õ�
    BYTE	byRes[3];
    NET_DVR_TIME_EX struTimeOn; 	// ����ʱ��
    NET_DVR_TIME_EX struTimeOff; 	// �ػ�ʱ��
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;


typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD		dwSize;
    NET_DVR_SWITCH_TIME struTimer[LED_TIMER_NUM /*3*/]; 		//��ʱ���ػ�ʱ�䣬�ṹ����ֻ��Сʱ�ͷ�������������Ч��ÿ�鿪��ʱ��Ҫ���ڸ���Ĺػ�ʱ�䣬����ǰһ��Ĺػ�ʱ��Ҫ�?���磺struTimer[0]�Ĺػ�ʱ����10��00��ô��struTimer[0]�Ŀ���ʱ��������Ϊ10:00֮ǰ�� struTimer[1]�Ŀ���ʱ��������Ϊ10��:00�Ժ�
    BYTE		byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

//��ʱ���ȵ���
typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD 		dwSize;
    BYTE		byValid;		//��ʱ���ȵ����Ƿ���Ч
    BYTE		byRes1[3];
    BYTE 		byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/]; 	//��ȫ��24��Сʱ��Ϊ48��ʱ�Σ�ÿ30����һ��ʱ�Σ���48���ֽڱ�ʾÿ��ʱ�ε����ȼ������ȹ�16������0~15��ʾ��
    BYTE		byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD	dwSize;
    BYTE	bySwitchState;		//1-����״̬ 2-�ػ�״̬
    BYTE	byBrightness;		//����ֵ����Χ0-15
    BYTE	byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;

//2010-12-28 ������뿨������ begin
//�µĽ��뿨������������
#define		MAX_DECODE_CARD_NUM			6   //��������뿨��
/********************������뿨���ģʽ�궨��********************/
typedef enum _HD_DISPLAY_FORMAT
{
    HD_DISPLAY_FORMAT_INVALID = 0x00000000,
        HD_DISPLAY_FORMAT_CVBS = 0x00000001,
        HD_DISPLAY_FORMAT_DVI = 0x00000002,
        HD_DISPLAY_FORMAT_VGA = 0x00000004,
        HD_DISPLAY_FORMAT_HDMI = 0x00000008,
        HD_DISPLAY_FORMAT_YPbPr = 0x00000010
}HD_DISPLAY_FORMAT,*LPHD_DISPLAY_FORMAT;

/********************������뿨���ģʽ�궨��********************/
typedef struct tagNET_DVR_DECCARD_ABILITY      /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //����ͨ����
    BYTE byDispNums;      //��ʾͨ����
    BYTE byDecStartIdx;     //�׸�����ͨ�������н���ͨ���е�����
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byDispResolution[80]; //���ģʽ֧�ֵķֱ���
    BYTE byDispFormat[8];     //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT)
    BYTE byWindowMode[4][8]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes[35];
} NET_DVR_DECCARD_ABILITY,*LPNET_DVR_DECCARD_ABILITY;

typedef struct tagNET_DVR_DECODESVR_ABILITY
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY, *LPNET_DVR_DECODESVR_ABILITY;

typedef struct tagNET_MATRIX_DEV_CHAN_INFO
{
    NET_DVR_IPADDR 	struIP;		    //DVR IP��ַ
    WORD 	wDVRPort;			 	//�˿ں�
    BYTE 	byChannel;				//ͨ����
    BYTE	byTransProtocol;		//����Э������0-TCP��1-UDP
    BYTE	byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE	byFactoryType;			/*ǰ���豸��������,ͨ��ӿڻ�ȡ*/
    BYTE	byUsedSlotNum;			//�Ƿ�ʹ�ò�λ�ţ�0-��ʹ�ã�1-ʹ��
    BYTE	bySlotNum;//��λ��
    BYTE	byRes[68];
    BYTE	sUserName[NAME_LEN];	//��������½�ʺ�
    BYTE	sPassword[PASSWD_LEN];	//�����������
}NET_MATRIX_DEV_CHAN_INFO,*LPNET_MATRIX_DEV_CHAN_INFO;

typedef struct tagNET_MATRIX_PU_STREAM_CFG
{
    DWORD							dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG	struStreamMediaSvrCfg;
    NET_MATRIX_DEV_CHAN_INFO		struDevChanInfo;
} NET_MATRIX_PU_STREAM_CFG,LPNET_MATRIX_PU_STREAM_CFG;

/*camera���õ�Ԫ�ṹ*/
typedef struct tagNET_DVR_MATRIX_CAMERACFG
{
    DWORD					dwGlobalIndex;//ȫ�ֱ��
    DWORD					dwInterIndex;//�ֲ����
    BYTE					sCamName[NAME_LEN];
    NET_MATRIX_PU_STREAM_CFG struPuStreamCfg;
} NET_DVR_MATRIX_CAMERACFG,*LPNET_DVR_MATRIX_CAMERACFG;

typedef struct tagNET_DVR_MATRIX_CAMERALIST
{
    DWORD			dwSize;
    BYTE			byRes[12];
    DWORD			dwCamNum;//CAM����
    BYTE  			*pBuffer;
    DWORD 			dwBufLen;//�����ָ�볤�ȣ��������
} NET_DVR_MATRIX_CAMERALIST,*LPNET_DVR_MATRIX_CAMERALIST;

typedef struct tagNET_DVR_DISP_CHAN_INFO
{
    NET_DVR_IPADDR	struIP;				/* ������ IP��ַ */
    WORD 	wDVRPort;			 	/* �˿ں� */
    BYTE 	byDispChannel;			/* ��ʾͨ���� */
    BYTE	byUsedSlotNum;			//�Ƿ�ʹ�ò�λ�ţ�0-ʹ�ã�1-��ʹ��
    BYTE	bySlotNum;//��λ��
    BYTE	byRes[7];
    BYTE	sUserName[NAME_LEN];	/*��½�ʺ� */
    BYTE	sPassword[PASSWD_LEN];	/*���� */
}NET_DVR_DISP_CHAN_INFO,*LPNET_DVR_DISP_CHAN_INFO;

/*monitor���õ�Ԫ�ṹ*/
typedef struct tagNET_DVR_MATRIX_MONITORCFG
{
    DWORD						dwGlobalIndex;//ȫ�ֱ��
    DWORD						dwInterIndex;
    BYTE						sMonName[NAME_LEN];
    NET_DVR_DISP_CHAN_INFO		struDispChanCfg;
} NET_DVR_MATRIX_MONITORCFG,*LPNET_DVR_MATRIX_MONITORCFG;
typedef struct tagNET_DVR_MATRIX_MONITORLIST
{
    DWORD		dwSize;
    BYTE		byRes[12];
    DWORD		dwMonNum;//MON����
    BYTE  		*pBuffer;
    DWORD 		dwBufLen;//�����ָ�볤�ȣ��������
} NET_DVR_MATRIX_MONITORLIST,*LPNET_DVR_MATRIX_MONITORLIST;

#define 	MAX_SUBMATRIX_NUM		8//������������ϵͳ����
typedef struct tagNET_DVR_SUBMATRIXINFO
{
    BYTE		byMainMatrix;//�Ƿ�����ϵͳ��1-�ǣ�0-��
    BYTE		bySubMatrixSequence;//��������Ƶ�ۺ�ƽ̨ϵͳ���
    BYTE		byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-�����
    BYTE		byRes1[9];
    NET_DVR_IPADDR  struSubMatrixIP;		/*IP��ַ�����޸ģ�*/
    WORD		wSubMatrixPort;        /*��ϵͳ�˿ںţ����޸ģ�*/
    BYTE		byRes2[6];
    NET_DVR_IPADDR  struSubMatrixIPMask;    /*IP��ַ����*/
    NET_DVR_IPADDR	struGatewayIpAddr;		 /* ��ص�ַ */
    BYTE		sUserName[NAME_LEN];	/* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE		sPassword[PASSWD_LEN];	/*���� ���˲���ֻ�ܻ�ȡ��*/
    char		sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char 		sDnsAddress[MAX_DOMAIN_NAME];/*DNS�����IP��ַ*/
    BYTE		sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
    BYTE		byRes3[16];
}NET_DVR_SUBMATRIXINFO, *LPNET_DVR_SUBMATRIXINFO;

typedef struct tagNET_DVR_ALLUNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBMATRIXINFO struSubMatrixInfo[MAX_SUBMATRIX_NUM];
    BYTE  byRes2[32];
}NET_DVR_ALLUNITEDMATRIXINFO, *LPNET_DVR_ALLUNITEDMATRIXINFO;

#define	MAX_GATEWAYTRUNKNUM		1024 //������Ƶ�ۺ�ƽ̨�����·�ɸ�����

typedef struct tagNET_DVR_MATRIXGATEWAYNOTE
{
    WORD	wTrunkInToOutAbility;//���ߴ�?��D1�ı�׼��������4��ʾ֧��4��D1
    WORD	wTrunkOutToInAbility;//���ߴ�?��D1�ı�׼��������4��ʾ֧��4��D1��˫�����ʱ�õ���ֵ
    BYTE    byRes[4];
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;
}NET_DVR_MATRIXGATEWAYNOTE, *LPNET_DVR_MATRIXGATEWAYNOTE;

typedef struct tagNET_DVR_MATRIXGATEWAYINFO
{
    DWORD dwSize;
    NET_DVR_MATRIXGATEWAYNOTE struGatewayNote[MAX_GATEWAYTRUNKNUM];
    BYTE  byRes [32];
}NET_DVR_MATRIXGATEWAYINFO, *LPNET_DVR_MATRIXGATEWAYINFO;

typedef struct tagNET_DVR_MATRIXCODESYSTEMINFO
{
    BYTE   byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE	bySubSystemNum;//��ϵͳ��λ��
    BYTE	byChan;//����ͨ��
    BYTE   byRes [13];
}NET_DVR_MATRIXCODESYSTEMINFO,*LPNET_DVR_MATRIXCODESYSTEMINFO;
typedef struct tagNET_DVR_MATRIXDECODESYSTEMINFO
{
    BYTE    byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE	bySubSystemNum;//��ϵͳ��λ��
    BYTE	byDispChan;//��ʾͨ��
    BYTE	bySubDispChan;//��ʾͨ����ͨ����
    BYTE    byRes [12];
}NET_DVR_MATRIXDECODESYSTEMINFO,*LPNET_DVR_MATRIXDECODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXSWITCH
{
    NET_DVR_MATRIXCODESYSTEMINFO struInputNote;
    NET_DVR_MATRIXDECODESYSTEMINFO struOutputNote;
    BYTE	byRes[32];
}NET_DVR_MATRIXSWITCH, *LPNET_DVR_MATRIXSWITCH;

typedef enum {
    ENC_CARD = 0,
        DEC_CARD,
        SD_DEC_CARD,
        FPGA_CARD,
        CS_CARD,
        ALERTOR_CARD,
        NAT_0,
        NAT_1,
        VCA_CARD,
        VGA_DEC_CARD,
        VGA_ENC_CARD,
        ERR_CARD,
} DEV_TYPE;

typedef struct tagNET_DVR_MATRIXSWITCHCTRL
{
    DWORD dwCamId;//�����ȫ�ֱ��
    DWORD dwMonId;//������ȫ�ֱ��
    BYTE  bySubWindowNum;//��������Ӧ�Ӵ��ں�
    BYTE   bySwitchType;/*�л����ͣ�0:���л���1:���������л���2:����ȡ��0xff:��ʾ��MON�����б���ȫ��ȡ��*/
    WORD   wAlarmType;//�����豸���ͣ�1:��������2�������豸
    DWORD  dwResidentTime;/* ��ʾפ��ʱ�䣬0xFFFFFFFF ʱ Ϊ��פ�����������ʾ*/
    BYTE   byVcaDevType;//�������豸������"�����豸"ʱ����DEV_TYPE����
    BYTE   byRes[19];
}NET_DVR_MATRIXSWITCHCTRL, *LPNET_DVR_MATRIXSWITCHCTRL;

typedef struct tagNET_DVR_MATRIXDATABASE
{
    //�����ļ����ͣ�1-����ݿ������ļ���2-������ݿ������ļ���3-ƽ̨��ݿ������ļ���4-���������ļ���0xff���һ��ʧ�ܵ���ݿ����
    DWORD dwDevType;
    DWORD dwParam; //��������š�����š�ƽ̨�ţ����������ļ�ʱ��ֵ����
    BYTE  byFileType;//�ļ����ͣ�1-sql��䣬2-db��䣬3-���������ļ�
    BYTE  byRes [3];
} NET_DVR_MATRIXDATABASE, *LPNET_DVR_MATRIXDATABASE;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
/*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��
    9-V6��ϵͳ��10-ת����ϵͳ��11-X86��������ϵͳ��12-������������ϵͳ��13-X86���ķ���壬14- X86ҵ�����壬15-�����ƴ����ϵͳ�� 16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE		bySubSystemType;
    //��ϵͳͨ������������ϵͳ�����485�����������˲���ֻ�ܻ�ȡ��
    BYTE		byChan;
    BYTE		byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-�����
    BYTE		bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    BYTE		byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;		/*IP��ַ�����޸ģ�*/
    NET_DVR_IPADDR   struSubSystemIPMask;//��������
    NET_DVR_IPADDR	 struGatewayIpAddr;	/* ��ص�ַ */
    WORD		wSubSystemPort;        //��ϵͳ�˿ںţ����޸ģ�
    BYTE		byRes2[6];
    BYTE		sUserName[NAME_LEN];	/* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE		sPassword[PASSWD_LEN];	/*����(���޸�)*/
    char		sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char 		sDnsAddress[MAX_DOMAIN_NAME];/*DNS�����IP��ַ*/
    BYTE		sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
    BYTE		byBelongBoard;//�����Ӱ�ţ���1��ʼ��0xff��ʾ��Ч
    BYTE		byInterfaceType;//�ӿ����ͣ�1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��10-3GSDI, 11-VGA/DVI����Ӧ��12-HDTVI��0xff-��Ч
    BYTE		byInterfaceNums;//�ӿڸ���0xff��ʾ��Ч
    BYTE		byInterfaceStartNum;//�ӿ���ʼ�ţ�0xff��ʾ��Ч
    BYTE        byDeviceName[20];//��ϵͳ���
    BYTE        byAudioChanNums; //��Ƶͨ������
    BYTE        byAudioChanStartNum; //��Ƶͨ����ʼ��
    BYTE        byAudioChanType;//��Ƶͨ�����ͣ�0-��Ч��1-��Ƶ���룬2-��Ƶ���
    BYTE		byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

#define  MAX_SUBSYSTEM_NUM_V40  120
typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V40
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE   bySubSystemType;
    BYTE   byConnectStatus;//����ϵͳ����״̬��1-������2-���ӶϿ�
    BYTE   byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE   bySubSystemNum;//������ϵͳ��λ�ţ�0~79����ϵͳ������3��4ʱ����
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE   byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE   bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    //��ϵͳ����Ϊ1��ʱ���ã�0-δ������1-D1��2-720��3-1080
    BYTE   byDecodeAbility;
    BYTE   byUsedTrunk;
    BYTE   byRes[64];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V40,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V40
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V40 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V40, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

#define  MAX_OPTICALFIBER_NUM  16
typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
/*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��
	10-ת����ϵͳ��11-X86��������ϵͳ���壬 14- X86ҵ�����壬15-�����ƴ����ϵͳ�� 16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��0-NULL���˲���0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE  bySubSystemType;
    BYTE  byChanNum;//��ϵͳͨ����
    BYTE  byStartChan;//��ϵͳ��ʼͨ����
    BYTE  bySlotNum ;//��λ��
    BYTE  byRes1[4];
    union
    {
        BYTE byRes[200];
        struct
        {
            BYTE byDecode;        //�Ƿ��Ǵ���빦�ܵ����ܰ�,1-�ǣ�0-��
            BYTE byNeedPreAllocDec; //�Ƿ���ҪԤ���������Դ��1-�ǣ�0-��
            BYTE byVACType;  //������ϵͳ���ͣ�0-��ͨ�ͣ�1-��ǿ��
            BYTE byRes[197];
        }struVACSystemAbility;
        struct
        {
            BYTE  byVGANums;//VGA��ʾͨ�������1��ʼ��
            BYTE  byBNCNums;//BNC��ʾͨ�������9��ʼ��
            BYTE  byHDMINums;//HDMI��ʾͨ�������25��ʼ��
            BYTE  byDVINums;//DVI��ʾͨ�������29��ʼ��
            BYTE  byLayerNums ;//����ƴ���У�������ʱ��֧��ͼ����
            BYTE  bySpartan;//���Թ��ܣ�0-��֧�֣�1-֧��
            BYTE  byDecType; //������ϵͳ���ͣ�0-��ͨ��,1-��ǿ��(��ͨ�ͷ���ʱǰ4������ʹ��������Դ����ǿ���޴����ƣ���ǿ�����ɱ�������ϵͳ��16·D1������Դ
            //��ǿ�ͱ���������Ϊ��������Դ�ɱ����ã���ͨ�����ܱ�����)
            //2-���ܹ���������ϵͳ��3-ת�����������ϵͳ�����ܺ�ת�������ϵͳ�������ڽ�����ǽ��
            BYTE  byOutputSwitch;//�Ƿ�֧��HDMI/DVI�����л���0-��֧�֣�1-֧��
            BYTE  bySDINums;//SDI��ʾͨ�������33��ʼ��
            BYTE  byRes1[38];
            BYTE  byDecoderType ; //������Ƿ�֧�ֶ೧���������룬0-��֧�֣�1-֧��
            BYTE  byRes2[152];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byCoderType;//���������ͣ�0-���壬1-����, 2-ģ�����
            BYTE  byOptical;//��˻���룬0-��1-��
            BYTE  byOpticalSubChan; //ÿ������ŵ���
            BYTE  bySupportAVSeparate;//�Ƿ�֧������Ƶ���룬0-��֧�֣�1-֧��
            BYTE  byRes[196];
        }struCoderSystemAbility;
        struct
        {
            WORD	wTrunkAbility;//���ߴ�?��D1�ı�׼��������4��ʾ֧��4��D1
            BYTE    byOpticalFiberNum;//��������
            BYTE    byRes[197];
        }struInputSystemAbility;
        struct
        {
            WORD	wTrunkAbility;//���ߴ�?��D1�ı�׼��������4��ʾ֧��4��D1
            BYTE    byOpticalFiberNum;//��������
            BYTE    byRes[197];
        }struOutputSystemAbility;
        struct
        {
            BYTE	by485Num;//�����ϵͳ��485����
            BYTE	bySlotNum;//ÿ��485��λ��
            BYTE    byRes[198];
        }struCodeSpitterSystemAbility;
        struct
        {
            WORD	wAlarmInNums;
            WORD	wAlarmOutNums;
            /* ��ʶ�������Ƿ����ӣ� 1��ʾ�����ӣ� Ϊ0 ��ʾδ���� */
            BYTE  byAlarmBoxEnable[4][8];
            BYTE  bySupportContact; /* ��Ƶ�ۺ�ƽ̨�ڲ�����������0-��֧��,1-֧�� */
            BYTE  byRes[163];
        }struAlarmHostSystemAbility;
        struct
        {
            BYTE  byOpticalFiberNum;//��������
            BYTE  byRes1[3];
            //���˴�?��D1�ı�׼��������4��ʾ֧��4��D1
            WORD	wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
            BYTE  byRes2[164];
        }struInOutputSystemAbility;
        struct
        {
            BYTE  bySupportRingProtocol;   //�Ƿ�֧�ֻ���Э��
            BYTE  bySupportRingNums; //֧�ֻ�������
            BYTE  bySupportPortNums;  //֧�ֵĶ˿�����
            BYTE  byRes[1];
            DWORD dwPortSupportRingProto; //ÿ���˿��Ƿ�֧�ֻ���Э�飬��λ�㣬1��32λ�ֱ��ʾ1��32�˿ڣ�0-��֧�֣�1-��ʾ֧��
            BYTE  byRes2[192];
        } struFiberSwitchSystemAbility;
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;//������ϵͳ����
    BYTE    byDecodeSubSystemNums;//������ϵͳ����
    BYTE    bySupportNat;//�Ƿ�֧��NAT��0-��֧�֣�1-֧��
    BYTE    byInputSubSystemNums;//����������ϵͳ����
    BYTE	byOutputSubSystemNums;//���������ϵͳ����
    BYTE	byCodeSpitterSubSystemNums;//�����ϵͳ����
    BYTE	byAlarmHostSubSystemNums;//������ϵͳ����
    BYTE	bySupportBigScreenNum;//��֧�������ɴ����ĸ���
    BYTE	byVCASubSystemNums;//������ϵͳ����
    BYTE	byV6SubSystemNums;//V6��ϵͳ����
    BYTE	byV6DecoderSubSystemNums;//V6������ϵͳ����
    BYTE	bySupportBigScreenX;/*����ƴ�ӵ�ģʽ��m��n*/
    BYTE	bySupportBigScreenY;
    BYTE	bySupportSceneNums;//֧�ֳ���ģʽ�ĸ���
    BYTE    byVcaSupportChanMode;//����֧�ֵ�ͨ��ʹ��ģʽ��0-ʹ�ý���ͨ����1-ʹ����ʾͨ������ͨ����
    BYTE    bySupportScreenNums;//��֧�ֵĴ�������Ļ������
    BYTE    bySupportLayerNums;//��֧�ֵ�ͼ����0xff-��Ч
    BYTE    byNotSupportPreview;//�Ƿ�֧��Ԥ��,1-��֧�֣�0-֧��
    BYTE    byNotSupportStorage;//�Ƿ�֧�ִ洢,1-��֧�֣�0-֧��
    BYTE    byUploadLogoMode;//�ϴ�logoģʽ��0-�ϴ������ͨ����1-�ϴ�����ʾͨ��
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE	by485Nums;//485���ڸ���
    BYTE	by232Nums;//232���ڸ���
    BYTE	bySerieStartChan;//��ʼͨ��
    BYTE	byScreenMode;//����ģʽ��0-�����ɿͻ��˷��䣬1-�������豸�˷���
    BYTE	byDevVersion;//�豸�汾��0-B10/B11/B12��1-B20
    BYTE	bySupportBaseMapNums;//��֧�ֵĵ�ͼ���ͼ�Ŵ�1��ʼ
    WORD    wBaseLengthX;//ÿ������С�Ļ�׼ֵ��B20ʹ��
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;  //�Ƿ�֧��ͼƬ���ԣ�0-��֧�֣�1-֧��
    BYTE    bySupportPreAllocDec;   //�Ƿ�֧�����ܽ�����ԴԤ���䣬0-��֧�֣�1-֧��
    BYTE    bySupportDecAutoManage; //�Ƿ�֧�ֽ�����Դ����
    BYTE    byTranDevSubSystemNums; //ת����ϵͳ����
    BYTE    byFiberSwitchNums;  //���������ϵͳ����
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums;//������ϵͳ����
    BYTE  byDecodeSubSystemNums;//������ϵͳ����
    BYTE  bySupportNat;//�Ƿ�֧��NAT��0-��֧�֣�1-֧��
    BYTE  byInputSubSystemNums;//����������ϵͳ����
    BYTE  byOutputSubSystemNums;//���������ϵͳ����
    BYTE  byCodeSpitterSubSystemNums;//�����ϵͳ����
    BYTE  byAlarmHostSubSystemNums;//������ϵͳ����
    BYTE  bySupportBigScreenNum;//��֧��������ƴ������
    BYTE  byVCASubSystemNums;//������ϵͳ����
    BYTE  byRes1[11];
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  by485Nums;//485���ڸ���
    BYTE  by232Nums;//485���ڸ���
    BYTE  bySerieStartChan;//��ʼͨ��
    BYTE  byRes2[637];
}NET_DVR_VIDEOPLATFORM_ABILITY, *LPNET_DVR_VIDEOPLATFORM_ABILITY;
//��ȡ�������ӿ�

//ģʽA
typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;	// ��ʼ�� ��1��ʼ
    BYTE	byStartDay;		// ��ʼ�� ��1��ʼ
    BYTE	byEndMonth;		// ������
    BYTE	byEndDay;		// ������
    BYTE	byRes[4];		// �����ֽ�
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE	byStartMonth;	// ��1��ʼ
    BYTE	byStartWeekNum;	// �ڼ������� ��1��ʼ
    BYTE	byStartWeekday;	// ���ڼ�
    BYTE	byEndMonth;		// ��1��ʼ
    BYTE	byEndWeekNum;	// �ڼ������� ��1��ʼ
    BYTE	byEndWeekday;	// ���ڼ�
    BYTE	byRes[2];		// �����ֽ�
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD	wStartYear;		// ��
    BYTE	byStartMon;		// ��
    BYTE	byStartDay;		// ��
    WORD	wEndYear;		// ��
    BYTE	byEndMon;		// ��
    BYTE	byEndDay;		// ��
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;

typedef union tagNET_DVR_HOLIDATE_UNION
{
    // �������С 12�ֽ�
    DWORD				    dwSize[3];
    NET_DVR_HOLIDATE_MODEA	struModeA;	// ģʽA
    NET_DVR_HOLIDATE_MODEB	struModeB;	// ģʽB
    NET_DVR_HOLIDATE_MODEC	struModeC;	// ģʽC
}NET_DVR_HOLIDATE_UNION, *LPNET_DVR_HOLIDATE_UNION;

typedef enum tagHOLI_DATE_MODE
{
    HOLIDATE_MODEA = 0,
        HOLIDATE_MODEB,
        HOLIDATE_MODEC
}HOLI_DATE_MODE;

typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE	byEnable;			// �Ƿ�����
    BYTE	byDateMode;			// ����ģʽ 0-ģʽA 1-ģʽB 2-ģʽC
    BYTE	byRes1[2];			// �����ֽ�
    NET_DVR_HOLIDATE_UNION uHolidate;	// ��������
    BYTE	byName[NAME_LEN];	// �������
    BYTE	byRes2[20];			// �����ֽ�
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

#define  MAX_HOLIDAY_NUM	32

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD	dwSize;			// �ṹ���С
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];	// ���ղ���
    DWORD	byRes[40];		// ��������
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

// ���ձ������?ʽ
typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD	dwSize;				// �ṹ���С
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];	// ����ʱ���
    BYTE	byRes2[240];		// �����ֽ�
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;                // �ṹ���С
    DWORD    dwChannel;            //ͨ����
    DWORD    dwSMDHandleType;    //�������ܼ��ղ������� 0-��Ƶ�쳣��⣬1-�齹��⣬2-����������
    BYTE	 byRes2[32];		// �����ֽ�
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD           dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // ¼�����
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // ¼��ʱ���
    BYTE      byRes[20];      //  �����ֽ�
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

#define  MAX_LINK_V30  128

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // �ͻ���IP
    LONG            lChannel;   // ͨ����
    BYTE            byRes[32];  // �����ֽ�
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      // �ṹ���С
    WORD    wLinkNum;    // ���ӵ���Ŀ
    BYTE    byRes1[2];  // �����ֽ�
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   // ���ӵĿͻ�����Ϣ
    BYTE    byRes[32];  // �����ֽ�
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

#define MAX_BOND_NUM  2

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;				// ����ģʽ0 - �����ݴ� 1 - ���ؾ��
    BYTE	byUseDhcp;			// �Ƿ�ʹ��dhcp
    BYTE	byMasterCard;	    //  ָ��������Ϊ����
    BYTE    byStatus;           // BONDING��״̬  0 - �쳣 1-�� ֻ�ܻ�ȡ��������
    BYTE	byBond[MAX_NETWORK_CARD];// byBond[0]== 1 ��ʾʹ��eh0  0��ʾ��ʹ��eh0
    NET_DVR_ETHERNET_V30	struEtherNet;		// �����
    NET_DVR_IPADDR	struGatewayIpAddr;  // ��ص�ַ
    BYTE	byRes[20];			// �����ֽ�
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         // �ṹ���С
    BYTE    byEnable;       // �Ƿ�����bonding����
    BYTE    byNum;          // Bonding��ĸ���
    BYTE    byRes1[2];         //  �����ֽ�
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE	byRes2[40];		// �����ֽ�
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;


// �������
typedef struct tagNET_DVR_DISK_QUOTA
{
    BYTE	byQuotaType;	 // �����������,1 - ������ 2-������3-��ʱ��
    BYTE    byRes1[5];       // �����ֽ�
    WORD    wStoragePeriod;  //¼��洢���ڣ���λ�죬�������Ϊ��ʱ��ʱ��Ч
    DWORD   dwHCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwLCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwHUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    DWORD   dwLUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    BYTE    byQuotaRatio;    //	����Ĵ��̱���,��λ:%
    BYTE    byRes2[21];      // �����ֽ�
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         // �ṹ���С
    NET_DVR_DISK_QUOTA    struPicQuota;       //  ͼƬ���
    NET_DVR_DISK_QUOTA    struRecordQuota;    //  ¼�����
    NET_DVR_DISK_QUOTA    struAddInfoQuota;   //  ������Ϣ��� (�����ƴ洢��������Ŀǰ֧�ֵĸ�����Ϣ�У��ȶ�ͼ��������)
    BYTE    byRes[12];      //�����ֽ�
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;


typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // ��ʱץͼͼƬ����
    DWORD      dwPicInterval;  // ��ʱץͼʱ����,��λs   1-1s 2-2s 3-3s 4-4s 5-5s
    //	6-10m 7-30m 8-1h 9-12h 10-24h
    BYTE       byRes[12];      // �����ֽ�
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    // ��λ��ʾ
    BYTE    byRes[20];          // �����ֽ�
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

#define MAX_PIC_EVENT_NUM      32
#define MAX_ALARMIN_CAPTURE   16

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //���ɴ����Ĺ���ͨ����-ֻ������
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //�����Ĺ���ץͼͨ���ţ���ֵ��ʾ�����ý���������,0xffffffff��ʾ������Ч
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   // �¼�ץͼͼƬ����
    DWORD   dwPicInterval;   // �¼�ץͼʱ����  ��λΪ��
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   // �����±� 0 �ƶ���ⴥ��ץͼ 1 ��Ƶ�ڵ�����ץͼ 2 ��Ƶ��ʧ����ץͼ,����3��ʾPIR����ץͼ������4��ʾ���߱���ץͼ������5��ʾ���ȱ���ץͼ,����6��ʾ����ץͼ
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // �������봥��ץͼ���±�0 ��?������1 ��������
    DWORD   dwMaxGroupNum;  //�豸֧�ֵ���󱨾���������ÿ��16����������
    BYTE      byCapTimes; //ץͼ����
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;


typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // �¼�ץͼͼƬ����
    DWORD       dwPicInterval;  // �¼�ץͼʱ����  ��λΪ��  1-1s 2-2s 3-3s 4-4s 5-5s
    //	6-10m 7-30m 8-1h 9-12h 10-24h
    /*
    �����±� 0 �ƶ���ⴥ��ץͼ 1 ��Ƶ�ڵ�����ץͼ��2 ��Ƶ��ʧ����ץͼ,����3��ʾPIR����ץͼ��
    ����4��ʾ���߱���ץͼ������5��ʾ���ȱ���ץͼ,����6��ʾ����ץͼ,����7 ��ʾ�������ץͼ��
    ����8 ��ʾ-Խ��������ץͼ������9 ��ʾ�����������ץͼ,����10��ʾ����������ץͼ,
    ����11-�����������,����12-�뿪�������,����13-�ǻ����,����14-��Ա�ۼ����,����15-�����˶����,
    ����16-ͣ�����,����17-��Ʒ�������,����18-��Ʒ��ȡ��⡣
    */
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM];
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // �������봥��ץͼ���±�0 ��?������1 ��������
    BYTE       byCapTimes; //ץͼ����
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD     				        dwSize;               //�ṹ�峤��
    NET_DVR_TIMING_CAPTURE        struTimingCapture;
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;//ץͼ�������� 0-��������1-������
    BYTE       byRes3[19];     // �����ֽ�
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         // �ṹ���С
    NET_DVR_TIMING_CAPTURE struTimingCapture;
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;//ץͼ�������� 0-��������1-������
    BYTE       byRes3[19];     // �����ֽ�
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE	byAllDayCapture;	// �Ƿ�ȫ��ץͼ
    BYTE	byCaptureType;		// ץͼ���ͣ�0-��ʱץͼ��1-�ƶ����ץͼ��2-����ץͼ��3-�ƶ����򱨾�ץͼ��4-�ƶ����ͱ���ץͼ��6-���ܱ���ץͼ
    BYTE	byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;        // ץͼʱ���
    BYTE        byCaptureType;       // ץͼ���ͣ�0-��ʱץͼ��1-�ƶ����ץͼ��2-����ץͼ��3-�ƶ����򱨾�ץͼ��4-�ƶ����ͱ���ץͼ��6-���ܱ���ץͼ
    BYTE        byRes[3];           // �����ֽ�
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

// ͨ��ץͼ�ƻ�
typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     // �ṹ��
    BYTE	byEnable;	// �Ƿ�ץͼ
    BYTE	byRes1[3];	// �����ֽ�
    NET_DVR_CAPTURE_DAY	struCaptureDay[MAX_DAYS];	// ȫ��ץͼ�ƻ�
    NET_DVR_CAPTURE_SCHED	struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];	// ʱ���ץͼ�����ƻ�
    NET_DVR_CAPTURE_DAY	struCaptureHoliday;			// ����ץͼ�ƻ�
    NET_DVR_CAPTURE_SCHED	struHolidaySched[MAX_TIMESEGMENT_V30];	// ʱ��μ���ץͼ�����ƻ�
    DWORD	dwRecorderDuration;	// ץͼ�����ʱ�� 0xffffffff��ʾ��ֵ��Ч
    BYTE	byRes[40];			// �����ֽ�
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;


typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;              //�ṹ��С
    LONG   lCardIndex;         //������
    DWORD  dwInterval;         //�豸�ϴ�����ʱ����, ��λ:100ms
    BYTE   byRes[8];           //�����ֽ�
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //�ṹ��С
    DWORD  dwSendFlowSize;     //����������С,��λkbps
    DWORD  dwRecvFlowSize;     //����������С,��λkbps
    BYTE   byRes[20];          //����
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

//  ¼���ǩ
#define LABEL_NAME_LEN 40
typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;					// �ṹ���С
    NET_DVR_TIME  struTimeLabel;			// ��ǩ��ʱ��
    BYTE	byQuickAdd;				// �Ƿ������� �������ʱ��ǩ�����Ч
    BYTE	byRes1[3];				// �����ֽ�
    BYTE	sLabelName[LABEL_NAME_LEN];	// ��ǩ����� ����Ϊ40�ֽ�
    BYTE	byRes2[40];				// �����ֽ�
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

#define  LABEL_IDENTIFY_LEN     64
typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64�ֽڱ�ʶ
    BYTE    byRes[8];               // �����ֽ�
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

#define MAX_DEL_LABEL_IDENTIFY  20// ɾ�������ǩ��ʶ����

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       // �ṹ���С
    BYTE    byMode;   // ��λ��ʾ,0x01��ʾ����ʶɾ��
    BYTE    byRes1;
    WORD    wLabelNum;      // ��ǩ��Ŀ
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; // ��ǩ��ʶ
    BYTE    byRes2[160];   //�����ֽ�
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //Ҫ�޸ĵı�ǩ��ʶ
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];	//�޸ĺ�ı�ǩ���
    BYTE byRes2[40];
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

// ��ǩ�����ṹ��
typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;          // �ṹ���С
    LONG	    lChannel;		// ���ҵ�ͨ��
    NET_DVR_TIME	struStartTime;	// ��ʼʱ��
    NET_DVR_TIME	struStopTime;	// ����ʱ��
    BYTE	    sLabelName[LABEL_NAME_LEN];	//  ¼���ǩ��� ����ǩ���Ϊ�գ���������ֹʱ�����б�ǩ
    BYTE		byDrawFrame;		//0:����֡��1����֡
    BYTE	    byRes[39];		// �����ֽ�
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

// ��ǩ��Ϣ�ṹ��
typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE	sLabelName[LABEL_NAME_LEN];	// ��ǩ���
    NET_DVR_TIME struTimeLabel;		// ��ǩʱ��
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; // ��ǩ��ʶ
    BYTE	byRes1[32];			// �����ֽ�
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;

#define CARDNUM_LEN_V30 40
//���ö��
typedef enum _COUNTRY_INDEX_
{
    COUNTRY_NONSUPPORT = 0,   //0-�㷨�ⲻ֧����ʶ���
        COUNTRY_CZE = 1, //Czech Republic �ݿ˹��͹�
        COUNTRY_FRA = 2, //France ����
        COUNTRY_DEU = 3, //Germany �¹�
        COUNTRY_ESP = 4, //Spain  ������
        COUNTRY_ITA = 5, //Italy  �����
        COUNTRY_NLD = 6, //Netherlands ����
        COUNTRY_POL = 7, //Poland  ����
        COUNTRY_SVK = 8, //Slovakia  ˹�工��
        COUNTRY_BLR = 9, // Belorussia  �׶���˹
        COUNTRY_MDA = 10, //Moldova  Ħ�����
        COUNTRY_RUS = 11, //Russia  ����˹
        COUNTRY_UKR = 12, //Ukraine  �ڿ���
        COUNTRY_BEL = 13, //Belgium  ����ʱ
        COUNTRY_BGR = 14, //Bulgaria  ��������
        COUNTRY_DNK = 15, //Denmark  ����
        COUNTRY_FIN = 16, //Finland  ����
        COUNTRY_GBR = 17, //Great Britain  Ӣ��
        COUNTRY_GRC = 18, //Greece  ϣ��
        COUNTRY_HRV = 19, //Croatia  ���޵���
        COUNTRY_HUN = 20, //Hungary  ������
        COUNTRY_ISR = 21, //Israel  ��ɫ��
        COUNTRY_LUX = 22, //Luxembourg  ¬ɭ��
        COUNTRY_MKD = 23, //Macedonia  ����ٹ��͹�
        COUNTRY_NOR = 24, //Norway  Ų��
        COUNTRY_PRT = 25, //Portugal  ������
        COUNTRY_ROU = 26, //Romania  ��������
        COUNTRY_SRB = 27, //Serbia  ���ά��
        COUNTRY_AZE = 28, //Azerbaijan �������͹�
        COUNTRY_GEO = 29, //Georgia  ����³����
        COUNTRY_KAZ = 30, //Kazakhstan �����˹̹
        COUNTRY_LTU = 31, //Lithuania  �����𹲺͹�
        COUNTRY_TKM = 32, //Turkmenistan ������˹̹
        COUNTRY_UZB = 33, //Uzbekistan   ���ȱ��˹̹
        COUNTRY_LVA = 34, //Latvia       ����ά��
        COUNTRY_EST = 35, //Estonia ��ɳ����
        COUNTRY_ALB = 36, //Albania ���������
        COUNTRY_AUT = 37, //Austria �µ���
        COUNTRY_BIH = 38, //Bosnia and Herzegovina ��˹���Ǻͺ����ά��
        COUNTRY_IRL = 39, //Ireland ������
        COUNTRY_ISL = 40, //Iceland ��
        COUNTRY_VAT = 41, //Vatican ��ٸ�
        COUNTRY_MLT = 42, //Malta �����
        COUNTRY_SWE = 43, //Sweden ���
        COUNTRY_CHE = 44, //Switzerland ��ʿ
        COUNTRY_CYP = 45, //Cyprus ����·˹
        COUNTRY_TUR = 46, //Turkey ������
        COUNTRY_SVN = 47, //Slovenia ˹��������
        COUNTRY_UNRECOGNIZED = 0xfe, //Unrecognized �޷�ʶ��
        COUNTRY_ALL = 0xff, //ALL  ȫ��
}COUNTRY_INDEX;

typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         // �ṹ���С
    LONG   lChannel;       // ͨ����
    /* ���ҵ�ͼƬ����:0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ��
    3 ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ 6 �ֶ�ץͼ ,
    9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���,
    0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬
    0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������,
    0x13-�����������,0x14-�뿪�������,0x15-�ǻ����,
    0x16-��Ա�ۼ����,0x17-�����˶����,0x18-ͣ�����,
    0x19-��Ʒ�������,0x1a-��Ʒ��ȡ���, 0x1b-�������,
    0x1c-���м��,0x1d-ȡ֤�¼�,0x1e-�����,0x1f-���ƻ����,
    0x20-��ֻ��⣬0x21-����Ԥ����0x22-���±���,0xff- ȫ������*/
    BYTE   byFileType;
    BYTE   byNeedCard;     // �Ƿ���Ҫ����
                           /*
                           0-������1-�ģ�2-����3-�壬4-����5-�ʣ�6-����7-��
                           8-��9-�?10-����11-ԥ��12-�ڣ�13-����14-�棬
                           15-����16-�գ�17-�ӣ�18-�ɣ�19-�ɣ�20-����21-�࣬
                           22-³��23-��24-�£�25-����26-����27-̨��28-��
                           29-�أ�30-�ۣ�31-�£�32-�ƣ�33-�㣬34-�0xff-ȫ��
    */
    BYTE   byProvince;     //ʡ������ֵ
    BYTE   byRes;  //���ҽ�����Ƿ�Ҫ�󷵻����������Ϣ��0-�����أ�1-����
    BYTE   sCardNum[CARDNUM_LEN_V30];     // ����
    NET_DVR_TIME  struStartTime;//����ͼƬ�Ŀ�ʼʱ��
    NET_DVR_TIME  struStopTime;// ����ͼƬ�Ľ���ʱ��
    //ITC3.7 ����
    DWORD    dwTrafficType; //ͼƬ������Ч�� �ο� VCA_OPERATE _TYPE
    DWORD    dwVehicleType; //�������� �ο� VCA_VEHICLE_TYPE
    //Υ�������Ͳο� VCA_ILLEGAL_TYPE ��ǰ��֧�ָ�ѡ
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //������(1~99)
    BYTE     bySubHvtType ;//0-����,1-��(����������֧�ֳ��Ƽ�����ʡ�ݼ���),2-�ǻ�,3-����
    BYTE     byRes2[2];
    char	 sLicense[MAX_LICENSE_LEN/*16*/];	//���ƺ���
    BYTE     byRegion;     // ��������ֵ 0-������1-ŷ��(Europe Region)��2-��������(Russian Region)��3-ŷ��&����˹(EU&CIS) ,0xff-����
    BYTE     byCountry;     // �������ֵ�����գ�COUNTRY_INDEX
    BYTE     byRes3[6];     // �����ֽ�
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

#define PICTURE_NAME_LEN 64

typedef struct
{
    char    sFileName[PICTURE_NAME_LEN];//ͼƬ��
    NET_DVR_TIME struTime;//ͼƬ��ʱ��
    DWORD dwFileSize;//ͼƬ�Ĵ�С
    char    sCardNum[CARDNUM_LEN_V30];	//����
    BYTE   byPlateColor ;//�ο��ṹ VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//�ο��ṹ VLR_VEHICLE_CLASS
    BYTE   byEventSearchStatus; //����ͼƬ��ʾͬһ���ҽ���ʱ��0-��ʾ����û��ͼƬ��Ϣ��1-��ʾ���滹��ͼƬ��Ϣ���ܹ�ͼƬ��Ϣ�������һ��״̬Ϊ0��ͼƬ��
    BYTE   byRecogResult ;//ʶ����ο��ṹVTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];	//���ƺ���
    BYTE   byRes[12];
}NET_DVR_FIND_PICTURE,*LPNET_DVR_FIND_PICTURE;

#define MAX_RECORD_PICTURE_NUM  50      //  ��󱸷�ͼƬ����

typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         // �ṹ���С
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*�Ƿ����� 0������ 1����*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct
{
    DWORD dwSize;           //�ṹ���С
    DWORD dwChannel;        //ͨ����
    BYTE  byCompressType;   //���ȡ��ѹ����������1,������2,������3,�¼�
    BYTE  byRes[15];        //����
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //��ǰѹ����������
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

#define   STEP_READY       0    //׼����
#define   STEP_RECV_DATA   1    //����������
#define   STEP_UPGRADE     2    //��ϵͳ
#define   STEP_BACKUP      3    //����ϵͳ
#define   STEP_SEARCH      255  //�������ļ�

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //����[0,255]
    DWORD dwContrastValue;    //�Աȶ�[0,255]
    DWORD dwSaturationValue;  //���Ͷ�[0,255]
    DWORD dwHueValue;         //ɫ��[0,255]
    DWORD dwSharpness;		  //���[0,255]
    DWORD dwDenoising;		  //ȥ��[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{
    DWORD					dwSize;				//�ṹ���С
    WORD					wEffectMode;        //ģʽ 0-��׼ 1-���� 2-���� 3-����  255-�Զ���
    BYTE					byRes1[146];        //����
    NET_DVR_VIDEO_EFFECT	struVideoEffect;	//��ƵЧ�����
    BYTE					byRes2[60];			//����
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;


typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD	dwChannel;			// ͨ����
    DWORD	dwVideoParamType;  	// ��Ƶ�������� 0-���� 1-�Աȶ� 2-���Ͷ� 3-ɫ�� 4-��� 5-ȥ��
    DWORD	dwVideoParamValue;  //��Ӧ����Ƶ����ֵ����Χ����������
    BYTE 	byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD	dwSize;			// �ṹ���С
    DWORD	dwChannel;		// ͨ����
    DWORD	dwVideoMode;	// ģʽ
    BYTE	byRes[32];      // ����
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD	dwSize;			// �ṹ���С
    BYTE	byJointed;		//  0 û�й��� 1 �Ѿ�����
    BYTE	byDevType;		// ���������豸����  1 ��������豸
    BYTE	byRes1[2];		// �����ֽ�
    NET_DVR_IPADDR	struIP;			// �����ı�ȡ���豸IP��ַ
    WORD	wPort;			// �����ı�ȡ���豸�˿ں�
    WORD	wChannel;		// �����ı�ȡ���豸ͨ����
    BYTE	byRes2[20];			// �����ֽ�
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE	byJointed;				// 0-û�й���  1-�Ѿ�����
    BYTE	byRes1[3];
    NET_DVR_IPADDR	struIP;					// ������ȡ���豸IP��ַ
    WORD	wPort;					// ������ȡ���豸�˿ں�
    WORD	wChannel;				// ������ȡ���豸ͨ����
    BYTE	byVcaChanStatus;		// 0 - δ���� 1 - ����
    BYTE	byRes2[19];				// �����ֽ�
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD	dwSize;			// �ṹ���С
    BYTE	byDeviceStatus;	// �豸��״̬0 - ���� 1- ������
    BYTE	byCpuLoad;		// CPUʹ����0-100 �ֱ���ʹ�ðٷ���
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD	dwRes[40];		// �����ֽ�
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{
    DWORD	dwSize;
    BYTE   byAudio;			/*��Ƶ�Ƿ���*/
    BYTE   byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE 	byVgaResolution;      /*�ֱ��ʣ�����������ȡ*/
    BYTE	byVedioFormat;         /*1:NTSC,2:PAL��0-NULL*/
    DWORD	dwWindowMode;		/*����ģʽ����������ȡ*/
    BYTE  	byJoinDecChan[MAX_WINDOWS];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE	byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    BYTE	byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
    /*��ֹ����壬0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-�����������ʾͨ������*/
    BYTE	byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*�����Ӵ��ڶ�Ӧ����ͨ�����Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
            BYTE	byJoinDecoderId[MAX_WINDOWS];
            //��ʾ���������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ��ݴ�//�ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ
            //���������˽���ͨ��
            BYTE	byDecResolution;
            BYTE	byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE	byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE	byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40,*LPNET_DVR_VGA_DISP_CHAN_CFG_V40;

typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE		bySerialTrans;//�Ƿ�͸����0-��1-��
    BYTE		byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;

#define		NET_DVR_V6PSUBSYSTEMARAM_GET	1501//��ȡV6��ϵͳ����
#define		NET_DVR_V6PSUBSYSTEMARAM_SET	1502//����V6��ϵͳ����


typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //���0-���뻵��ģʽ��1-��ӻ��㣬2-���滵�㣬3-�˳�����
    DWORD dwDeadPixelX; //����X���
    DWORD dwDeadPixelY; //����Y���
    BYTE byRes[12]; //����
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

#define MAX_REDAREA_NUM   6   //�����̵��������

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;//�ƵƵļ��ʱ�䣬��λ���루s��
    BYTE byDigTrafficLight;//�Ƿ��ǽ�ͨ���ֻƵƣ�0-���ǣ�1-��
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS,*LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable; //�Ƿ���У���ܣ�0-�رգ�1-����
    DWORD dwCorrectLevel; //У���1(У������)-10(У������),Ĭ��Ϊ5
    DWORD dwAreaNum; //У���������
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM]; //У������
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/]; //У���������Ժ�У�������Ӧ
    BYTE   byRes2[8]; //����
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //��ʷ��ݸ���
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;


#define INQUEST_MESSAGE_LEN     44    //��Ѷ�ص�����Ϣ����
#define INQUEST_MAX_ROOM_NUM    2     //�����Ѷ�Ҹ���
#define MAX_RESUME_SEGMENT      2     //֧��ͬʱ�ָ���Ƭ����Ŀ

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE		byRoomIndex;     //��Ѷ�ұ��
    BYTE		byFileType;		//0-��Ѷ�ļ���1-��ͥ�ϴ��ļ�
    BYTE		byRes[22];       //����
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char 		sMessage[INQUEST_MESSAGE_LEN]; //�ص�����Ϣ
    BYTE	byRes[46];                     //����
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD	wDeviceType;	//��ݲɼ��豸�ͺ�:0-�� 1-���� 2-�ز� 3-���� 4-���� 5-���ء�6-���ϡ�7-ά��˹��
    WORD	wDeviceAddr;	//��ݲɼ��豸��ַ
    BYTE 	byRes[28];	    //����
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //֧��Э������,��λ��ʾ, �°汾����������������չ���ֶ�
    //0x1:���� 0x2:�ز� 0x4:����
    BYTE    byRes[120];        //����
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char		szCDName[NAME_LEN];	//������ƣ�����˫�̹��������һ���
    union
    {
        BYTE 	byBitRate;	// byCalcTypeΪ0ʱ��Ч��(0-32��1-48��2-64��3-80��4-96��5-128��
								//6-160��7-192��8-224��9-256��10-320��11-384��12-448��
								//13-512��14-640��15-768��16-896ǰ16��ֵ����)17-1024��18-1280��19-1536��
								//20-1792��21-2048��22-3072��23-4096��24-8192
        BYTE	byInquestTime;  // byCalcTypeΪ1ʱ��Ч��0-1Сʱ, 1-2Сʱ,2-3Сʱ,3-4Сʱ, 4-6Сʱ,5-8Сʱ,6-10Сʱ,7-12Сʱ
        //8-16Сʱ, 9-20Сʱ,10-22Сʱ,11-24Сʱ
    }uCalcMode;
    BYTE		byCalcType;			//��¼��������0-������ 1-��ʱ��
    BYTE		byAutoDelRecord;	// �Ƿ��Զ�ɾ��¼��0-��ɾ�����ʱ����¼�� 1-ɾ��
    BYTE		byAlarmThreshold;		// ����������ֵ
    BYTE		byInquestChannelResolution;     //��Ѷͨ���ֱ��ʣ�0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE		byRes[11];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD	dwRecordMode;         //��¼ģʽ:1 ����˫��ģʽ 2 �����ֿ�ģʽ 3 ˫��˫��ģʽ���޸���Ҫ�����豸��
    DWORD	dwWorkMode;           //����ģʽ:0 ��׼ģʽ 1 ͨ��ģʽ(������Ŀǰֻ�б�׼ģʽ)
    DWORD	dwResolutionMode;     //�豸�ֱ��ʣ�0:���� 1:D1 2:720P 3:1080P��������Ѷ���ô��ֶΣ�
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //��ʪ�ȴ���������
    NET_DVR_INQUEST_ROOM_INFO 	struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE	byEnableHashCheck;		//�Ƿ����öԹ������HASHֵУ�� 0-�����壬1-�����ã�2-����
    BYTE	byEnableInitCD;		//�Ƿ����ó�ʼ������ 0-�����壬1-�����ã�2-����
    BYTE    byRes[22];
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //�¼���ʼʱ��
    NET_DVR_TIME  struStopTime;  //�¼���ֹʱ��
    BYTE	byRoomIndex;         //��Ѷ�ұ��,��1��ʼ
    BYTE    byDriveIndex;        //��¼����,��1��ʼ
    WORD    wSegmetSize;         //��Ƭ�ϵĴ�С, ��λM
    DWORD   dwSegmentNo;         //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
    BYTE    byRes[24];           //����
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //��ָ����¼�����
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE	byResumeMode;		//�ָ�ģʽ��0-�����ָ̻���1-˫���ָ̻�
    BYTE    byRes[199];        //����
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
BYTE  byMainVersion;         /*�������汾.
                             0 : δ֪
                             1 : 8000��ѶDVR
                             �ΰ汾: 1 : 8000HD-S
                             2 : 8100��ѶDVR
                             �ΰ汾: 1 : ��Ѷ81SNL
                             2 : ��Ѷ81SH
                             3 : ��Ѷ81SFH
                             3 : 8608������Ѷ��NVR
                             �ΰ汾: 1 : DS-8608SN-SP
                             2 : DS-8608SN-ST
*/
BYTE  bySubVersion;          //���ߴΰ汾
BYTE  byUpgradeVersion;      //��汾,δ��Ϊ0
BYTE  byCustomizeVersion;     //���ư汾,�Ƕ���Ϊ0
BYTE  byRes[60];             //����
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

typedef struct tagNET_DVR_DISK_RAID_INFO
{
    DWORD dwSize;   //�ṹ���С
    BYTE byEnable;  //����Raid�Ƿ����
    BYTE bySleepStatus;    //0-��Ч�� 1-���ߣ�2-������
    BYTE byRes[34];  //�����ֽ�
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;


typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //�ṹ���С
    BYTE  byEnable;  //�Ƿ����ã�Ϊǰ��IPCͬ���豸����
    BYTE  byRes[7];  //����
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //�ṹ���С
    char sOldPasswd[PASSWD_LEN];  //IPC�ľ����룬����DVR��DVR��֤
    char sNewPasswd[PASSWD_LEN];  //IPC��������
    BYTE byRes[32];
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

//ͨ���ȡDVR������״̬����λbps
typedef struct tagNET_DEVICE_NET_USING_INFO
{
    DWORD dwSize;    //�ṹ���С
    DWORD dwPreview;   //Ԥ��
    DWORD dwPlayback;  //�ط�
    DWORD dwIPCModule; //IPC����
    DWORD dwNetDiskRW; //���̶�д
    BYTE res[32];
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

//ͨ��DVR����ǰ��IPC��IP��ַ
typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_IPADDR struIP;       //IPC��IP��ַ
    WORD wPort;       //IPC�Ķ˿�
    char res[126];
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

//��ʱ����
typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //ͨ����, 0xff��ʾ����ͨ��
    DWORD   dwRecordType;     //¼������:  0xffffffff��ȫ����0����ʱ¼��1-�ƶ���⣬2������������3-�����������ƶ���⣬4-�����������ƶ���⣬5-�������6-�ֶ�¼��7-����¼��(ͬ�ļ�����)
    DWORD   dwLockDuration;   //�����ʱ��,��λ��,0xffffffff��ʾ������
    NET_DVR_TIME_EX strUnlockTimePoint;	//����ʱ��Ч����dwLockDuration��Ϊ������ʱ��������ʱ�䵽��ʱ�����Զ�����
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    BYTE    byRes[20];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;

//67DVS
//֤����������
typedef enum
{
    UPGRADE_CERT_FILE = 0,
    UPLOAD_CERT_FILE = 1,
    TRIAL_CERT_FILE = 2,
    CONFIGURATION_FILE = 3,
    UPLOAD_RECORD_FILE = 4 , //�ϴ�¼���ļ�
    SCENE_CONFIGURATION_FILE = 5, //���������ļ��ϴ�
    UPLOAD_PICTURE_FILE = 6,  //�ϴ�ͼƬ�ļ�
    UPLOAD_VIOLATION_FILE = 7,  //�ϴ�Υ���ֵ��ļ�
    UPLOAD_TG_FILE = 8,  //�ϴ�TG��Timing Generator���ļ�������T1���ԣ�
	UPLOAD_DATA_TO_DB = 9,		//�ϴ��ļ�����ͼ��
	UPLOAD_BACKGROUND_PIC = 10, //�ϴ�����ͼƬ
    UPLOAD_CALIBRATION_FILE = 11, //�ϴ��궨�ļ�
	UPLOAD_TME_FILE = 12, //�ϴ�����ڹ����ļ�
    UPLOAD_VEHICLE_BLACKWHITELST_FILE = 13,
    UPLOAD_PICTURE_TO_CLOUD = 15,    //�ϴ�ͼƬ���ƴ洢
    UPLOAD_VIDEO_FILE = 16  //�ϴ���Ƶ�ļ�
}NET_SDK_UPLOAD_TYPE;

typedef enum
{
	NET_SDK_DOWNLOAD_CERT = 0,		//����֤��
	NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,//����IPC�����ļ�
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2, //���ػ�׼����ͼƬ
	NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3,       //����VQD����ͼƬ
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE=4,   //���������ļ�
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5, //���س��������ļ�
	NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,				//����ͼ��������
    NET_SDK_DOWNLOAD_TME_FILE = 7,  //���س���ڹ����ļ�
    NET_SDK_DOWNLOAD_VEHICLE_BLACKWHITELST_FILE = 8, //���غڰ��������ļ�
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,    //���ƴ洢����ͼƬ
    NET_SDK_DOWNLOAD_PICTURE = 11, //����ͼƬ
	NET_SDK_DOWNLOAD_VIDEO = 12 //������Ƶ
}NET_SDK_DOWNLOAD_TYPE;

//����״̬
typedef enum
{
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,	//���سɹ�
        NET_SDK_DOWNLOAD_STATUS_PROCESSING,		//��������
        NET_SDK_DOWNLOAD_STATUS_FAILED,			//����ʧ��
        NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR	//δ֪����
}NET_SDK_DOWNLOAD_STATUS;

//���ؿ�����������
typedef enum tagNET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM
{
    ENUM_DOWNLOAD_CONTROL_ERR = -1,
	ENUM_DOWNLOAD_CONTROL_QOS = 1		//����
}NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM;

typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD	dwSize;				// �ṹ���С
    BYTE	byEnableBonjour;		// Bonjourʹ�� 0 ������ 1���ر�
    BYTE 	byRes1[3];
    BYTE 	byFriendlyName[MAX_DOMAIN_NAME]; 	// ������
    BYTE 	byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD			dwSize;				// �ṹ���С
    BYTE			byEnableSocks;  		// ʹ�� 0���ر� 1������
    BYTE 			byVersion;  			// SOCKS�汾 4��SOCKS4   5��SOCKS5
    WORD			wProxyPort;				// ����˿ڣ�Ĭ��1080
    BYTE			byProxyaddr[MAX_DOMAIN_NAME];  	// ����IP��ַ������������
    BYTE 			byUserName[MAX_DOMAIN_NAME]; 	// �û��� SOCKS����
    BYTE 			byPassword[NAME_LEN];			// ����SOCKS5����
    BYTE 			byLocalAddr[MAX_LOCAL_ADDR_LEN];  //��ʹ��socks�������Σ���ʽΪ"ip/netmask;ip/netmask;��"
    BYTE 			byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;



typedef struct tagNET_DVR_QOS_CFG
{
    DWORD		dwSize;
    BYTE		byManageDscp;   // ������ݵ�DSCPֵ [0-63]
    BYTE		byAlarmDscp;    // ������ݵ�DSCPֵ [0-63]
    BYTE		byVideoDscp;    // ��Ƶ��ݵ�DSCPֵ [0-63]��byFlagΪ0ʱ����ʾ����Ƶ
    BYTE		byAudioDscp;    // ��Ƶ��ݵ�DSCPֵ [0-63]��byFlagΪ1ʱ��Ч
    BYTE		byFlag;			// 0������Ƶ��һ��1������Ƶ�ֿ�
    BYTE		byEnable;
    BYTE 		byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD		dwSize;
    WORD		wHttpsPort;		// HTTPS�˿�
    BYTE		byEnable;		// ʹ�� 0���ر� 1������
    BYTE		byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

//֤�����
typedef struct tagNET_DVR_CERT_NAME
{
    BYTE	byCountry[MAX_COUNTRY_NAME_LEN];  			//��Ҵ�� CN��
    BYTE 	byState[MAX_DOMAIN_NAME];				//�޻�ʡ
    BYTE 	byLocality[MAX_DOMAIN_NAME];			//����
    BYTE 	byOrganization[MAX_DOMAIN_NAME];		//��֯
    BYTE 	byUnit[MAX_DOMAIN_NAME];				//��λ
    BYTE 	byCommonName[MAX_DOMAIN_NAME];
    BYTE 	byEmail[MAX_DOMAIN_NAME];
    BYTE 	byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME ;

typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //֤�����࣬0-802.1x,1-HTTPS
    WORD wCertType; //֤�����ͣ�0-CA��1-Certificate,2-˽Կ�ļ�
    BYTE byFileType; //֤���ļ����ͣ�0-PEM,1-PFX
    BYTE byRes[35];
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

#define UPLOAD_CERTIFICATE  1 //�ϴ�֤��


typedef struct tagNET_DVR_CERT_INFO
{
    DWORD 				dwSize;
    NET_DVR_CERT_PARAM 	struCertParam;	//֤�����
    DWORD				dwValidDays;   //��Ч��������Ϊ��ǩ��ʱ��Ч
    BYTE     			byPasswd[NAME_LEN];   //˽Կ����
    NET_DVR_CERT_NAME 	struCertName;    // ֤�����
    NET_DVR_CERT_NAME 	struIssuerName;    // ֤�鷢������ƣ���ǩ��֤����Ϣ��ȡʱ��Ч��
    NET_DVR_TIME_EX     	struBeginTime;   //֤�鴴��ʱ�䣨��ǩ��֤����Ϣ��ȡʱ��Ч��
    NET_DVR_TIME_EX     	struEndTime;   //֤���ֹʱ�䣨��ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE     			serialNumber[NAME_LEN];   //֤���ʶ�루��ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE 				byVersion;
    BYTE     			byKeyAlgorithm;			//�������� 0-RSA  1-DSA
    BYTE      			byKeyLen;				//���ܳ��� 0-512  1-1024�� 2-2048
    BYTE     			bySignatureAlgorithm; //ǩ���㷨���ͣ���ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE 				byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;


//channel record status
//***ͨ��¼��״̬*****//
typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE    byValid;       //�Ƿ���Ч
                           /*(ֻ��)¼������:0: ����¼��1����¼�� 2-����
                           3-������ 4-��������Ƶ 5-δ���� 6-�浵�� 7-�ش���
    8-�û��������� 9-δ��֤,10-�浵�к�¼���� 11-¼��ش��к�¼����*/
    BYTE    byRecord;
    WORD    wChannelNO;   //ͨ����
    DWORD   dwRelatedHD;  //��������
    BYTE	byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE	byRes[7];      //�����ֽ�
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;


typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize;
    DWORD dwIPAlarmInGroup;      //IPͨ��������������
    DWORD dwIPAlarmInNum;       //IPͨ�������������
    DWORD dwIPAlarmOutGroup;     //IPͨ�������������
    DWORD dwIPAlarmOutNum;      //IPͨ�������������
    BYTE byRes[64];
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //һ��64��
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;


typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; /*�������Ͻ���ʼ��X���*/
    WORD wYCoordinate; /*�������Ͻ�Y���*/
    WORD wWidth;       /*���ο��*/
    WORD wHeight;      /*���θ߶�*/
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;
/*������Ϣ*/
typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;          /*����Դ����*/
    BYTE  byLayerIdx;          /*ͼ�㣬0Ϊ��ײ�*/
    BYTE  byTransparency; //͸���ȣ�0��100
    NET_DVR_RECTCFG  struWin;//Ŀ�Ĵ���(�����ʾǽ)
    WORD wScreenHeight;//������
    WORD wScreenWidth;//������
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

#define  MAX_LAYERNUMS	32

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;//������
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;//ͼ���
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

//2011-04-18
/*�������Ϣ,���9999������1��ʼ */
typedef struct tagNET_MATRIX_CAMERAINFO
{
    DWORD dwGlobalCamId;      /* cam��ȫ�ֱ��*/
    BYTE  sCamName[NAME_LEN]; /*cam�����*/
    DWORD dwMatrixId;          /*cam��Ӧ����ı��*/
    DWORD dwLocCamId;         /*cam��Ӧ������ڲ����*/
    BYTE  byValid;    /*�Ƿ���Ч��0-��1-��*/
    BYTE  byPtzCtrl; /* �Ƿ�ɿأ�0-��1-��*/
    BYTE  byUseType; //*ʹ�����ͣ�0-����Ϊ����ʹ�ã�1-BNC��2-SP3,3-V6���ˣ�4-�������*/
    BYTE  byUsedByTrunk;//��ǰʹ��״̬��0-û�б�ʹ�ã�1-������ʹ��
    BYTE  byTrunkReq; /*�����ֱ���,��D1Ϊ��λ��1 - 1��D1��2- 2��D1����Ϊ����ʹ��ʱ��ָ���Ǹ��ߵĴ��*/
    BYTE  byRes1[3];
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE  sPurpose[NAME_LEN];/*��;����*/
    BYTE  byRes2[20];
}NET_MATRIX_CAMERAINFO, *LPNET_MATRIX_CAMERAINFO;

/*��������Ϣ�����2048��*/
typedef struct tagNET_MATRIX_MONITORINFO
{
    DWORD	dwGloalMonId; /*mon ��ͳһ���*/
    BYTE	sMonName[NAME_LEN];
    DWORD	dwMatrixId;  /*mon���ھ���ı��*/
    DWORD	dwLocalMonId; /*mon���ڲ����*/
    BYTE	byValid;    /*�Ƿ���Ч��0-��1-��*/
    BYTE	byTrunkType; /*ʹ�����ͣ�0-����Ϊ����ʹ�ã�1-BNC��2-SP3,3-V6���ˣ�4-�������*/
    BYTE	byUsedByTrunk;//��ǰʹ��״̬��0-û�б�ʹ�ã�1-������ʹ��
    BYTE	byTrunkReq; /*�ֱ���, ��D1Ϊ��λ��1- 1��D1��2- 2��D1����Ϊ����ʹ��ʱ��ָ���Ǹ��ߵĴ��*/
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE	sPurpose[NAME_LEN];/*��;����*/
    BYTE	byRes[20];
}NET_MATRIX_MONITORINFO, *LPNET_MATRIX_MONITORINFO;

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress; /*�豸Ϊ�����豸ʱ��IP��Ϣ*/
    WORD	wPort;
    BYTE	byNicNum; /*0 - eth0, 1 - eth1, ����˫������ͨ�ż���󶨵����*/
    BYTE	byRes[69];
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;
typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE	bySerPortNum;   /*���ӵĴ��ں�  0xff-��ͨ����*/
    BYTE    byMatrixSerPortType;/* ���������صĴ�����ģ�����ļ��̿�(����Э��)���ӻ��������ͨ�ſڣ�����Э�飩���� ��0 --- ����Э��ͨѶ�� 1 --- ����ͨѶ��*/
    BYTE	byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;	//232���ڲ���  ��ͨ����ʱ�˲�����Ч
    BYTE	byRes2[200];
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;

typedef union tagNET_MATRIX_UNION
{
    NET_MATRIX_DIGITALMATRIX struDigitalMatrix;
    NET_MATRIX_ANALOGMATRIX struAnalogMatrix;
}NET_MATRIX_UNION, *LPNET_MATRIX_UNION;
/*����������Ϣ�����20��*/
typedef struct tagNET_MATRIX_MATRIXINFO
{
    DWORD   dwSize;
    DWORD	dwMatrixId;  /*������*/
    BYTE	sDevName[NAME_LEN];
    BYTE	byCtrlType; /*ָͨѶ��ʽ�Ǵ���ͨ��, ��������ͨ��*/
    BYTE	byProtocolType;/*����ͨ�ſ���Э��*/
    BYTE	byRes1[6];   /*Ԥ��*/
    NET_MATRIX_UNION struMatrixUnion;
    DWORD	dwMaxPortsIn; /*����������*/
    DWORD	dwMaxPortsOut;/*���������*/
    BYTE	sUserName[NAME_LEN];   /*��¼�û���*/
    BYTE	sPassword[PASSWD_LEN];  /*��¼����*/
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE	sPurpose[NAME_LEN];/*��;����*/
    BYTE	byRes2[20];   /*Ԥ��*/
}NET_MATRIX_MATRIXINFO, *LPNET_MATRIX_MATRIXINFO;


typedef struct tagNET_DVR_MATRIXLIST
{
    DWORD	dwSize;
    BYTE	byRes[12];
    DWORD	dwMatrixNum;//�豸���صľ�������
    BYTE    *pBuffer;//������Ϣ������
    DWORD   dwBufLen;//�����ָ�볤�ȣ��������
}NET_DVR_MATRIXLIST,*LPNET_DVR_MATRIXLIST;

/*����������Ϣ*/
typedef struct tagNET_MATRIX_UARTPARAM
{
    DWORD dwSize;
    BYTE  byPortName[NAME_LEN];
    WORD  wUserId; /*�û���ţ��������豸Ϊ����ʱ����һ���û�������Ȩ�޹���*/
    BYTE  byPortType;    /*�������ͣ�����0-RS232/1-RS485/2-RS422*/
    BYTE  byFuncType; /*�������ӵ��豸������0-���У�1-���̣�2-����͸��ͨ��(485���ڲ������ó�͸��ͨ��),3-ģ�����*/
    BYTE  byProtocolType;  /*����֧�ֵ�Э������, �����Ӽ����豸ʱ��Ҫ����Ϣ,��ȡ����֧��Э��ı�ż�������*/
    BYTE  byBaudRate;
    BYTE  byDataBits;
    BYTE  byStopBits;   /*ֹͣλ*/
    BYTE  byParity;      /*У��*/
    BYTE  byFlowCtrl;   /*���أ�������أ�������*/
    BYTE  byRes[22];     /*Ԥ��*/
}NET_MATRIX_UARTPARAM, *LPNET_MATRIX_UARTPARAM;

//���256���û���1��256
typedef struct tagNET_MATRIX_USERPARAM
{
    DWORD dwSize;
    BYTE	sUserName[NAME_LEN];
    BYTE	sPassword[PASSWD_LEN/*16*/];
    BYTE	byRole;/*�û���ɫ:0-����Ա,1-����Ա��ֻ��һ��ϵͳ����Ա��255������Ա*/
    BYTE	byLevel;  /*ͳһ�������ڲ����������,1- 255*/
    BYTE	byRes[18];
}NET_MATRIX_USERPARAM, *LPNET_MATRIX_USERPARAM;

//���255����Դ��
typedef struct tagNET_MATRIX_RESOURSEGROUPPARAM
{
    DWORD dwSize;
    BYTE  byGroupName[NAME_LEN];
    BYTE  byGroupType;/*0-�����CAM�飬1-������MON��*/
    BYTE  byRes1;
    WORD  wMemNum;
    DWORD dwGlobalId[512];
    BYTE  byRes2[20];
}NET_MATRIX_RESOURCEGROUPPARAM,*LPNET_MATRIX_RESOURSEGROUPPARAM;

//���255���û���
typedef struct tagNET_MATRIX_USERGROUPPARAM
{
    DWORD dwSize;
    BYTE  sGroupName[NAME_LEN];
    WORD  wUserMember[255];  /*����û���Ա*/
    WORD  wResorceGroupMember[255]; /*�����Դ���Ա*/
    BYTE  byPermission[32];//Ȩ�ޣ�����0-ptzȨ�ޡ��л�Ȩ�ޡ���ѯȨ��
    BYTE  byRes[20];
} NET_MATRIX_USERGROUPPARAM, *LPNET_MATRIX_USERGROUPPARAM;

typedef struct tagNET_MATRIX_TRUNKPARAM
{
    DWORD	dwSize;
    DWORD	dwTrunkId;
    BYTE	sTrunkName[NAME_LEN];
    DWORD	dwSrcMonId;
    DWORD	dwDstCamId;
    BYTE	byTrunkType;  /*ʹ������  1-BNC��2-SP3���˸��壬3-SP3����D1�� 4-V6���ˣ�5-�������*/
    BYTE	byAbility;     /*��ʾ���˵Ĵ�?���Դ��伸·*/
    BYTE	bySubChan;   /*��Թ��˸��߶��ԣ���ʾ��ͨ����*/
    BYTE    byLevel;		/* ���߼��� 1-255*/
    WORD	wReserveUserID;	//Ԥ�����û�ID�� 1~256 ��0��ʾ�ͷ�Ԥ��
    BYTE   byRes[18];
} NET_MATRIX_TRUNKPARAM, *LPNET_MATRIX_TRUNKPARAM;

typedef struct tagNET_DVR_MATRIX_TRUNKLIST
{
    DWORD	dwSize;
    BYTE	byRes[12];
    DWORD	dwTrunkNum;//�豸���صĸ�������
    BYTE    *pBuffer;//������Ϣ������
    DWORD   dwBufLen;//�����ָ�볤�ȣ��������
}NET_DVR_MATRIX_TRUNKLIST,*LPNET_DVR_MATRIX_TRUNKLIST;

#define MATRIX_PROTOCOL_NUM    20    //֧�ֵ�������Э����
#define KEYBOARD_PROTOCOL_NUM  20    //֧�ֵ�������Э����
typedef struct tagNET_DVR_PROTO_TYPE_EX
{
    WORD wType;               /*ipcЭ��ֵ*/
    WORD wCommunitionType;		/*0��ģ�� 1������ 2������ģ�⡢����*/
    BYTE  byDescribe[DESC_LEN]; /*Э�������ֶ�*/
}NET_DVR_PROTO_TYPE_EX, LPNET_DVR_PROTO_TYPE_EX;

typedef struct tagNET_DVR_MATRIXMANAGE_ABIILITY
{
    DWORD	dwSize;
    DWORD	dwMaxCameraNum;//���Camera����
    DWORD	dwMaxMonitorNum;//������������
    WORD	wMaxMatrixNum;//����������
    WORD	wMaxSerialNum;//��������
    WORD	wMaxUser;//����û���
    WORD	wMaxResourceArrayNum;//�����Դ����
    WORD	wMaxUserArrayNum;//����û�����
    WORD	wMaxTrunkNum;//��������
    BYTE	nStartUserNum;//��ʼ�û���
    BYTE	nStartUserGroupNum;//��ʼ�û����
    BYTE	nStartResourceGroupNum;//��ʼ��Դ���
    BYTE	nStartSerialNum;//��ʼ���ں�
    DWORD   dwMatrixProtoNum;     /*��Ч�ľ���Э����Ŀ����0��ʼ*/
    NET_DVR_PROTO_TYPE_EX struMatrixProto[MATRIX_PROTOCOL_NUM];/*���Э���б?��*/
    DWORD   dwKeyBoardProtoNum;     /*��Ч�ļ���Э����Ŀ����0��ʼ*/
    NET_DVR_PROTO_TYPE_EX struKeyBoardProto[KEYBOARD_PROTOCOL_NUM];/*���Э���б?��*/
    BYTE    byRes[32];
} NET_DVR_MATRIXMANAGE_ABILITY, *LPNET_DVR_MATRIXMANAGE_ABILITY;

//����ץ�Ĺ���(����)
typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;				//�Ƿ񼤻����0-��1-��
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    //�����Զ�ROI����ʹ��
    BYTE byAutoROIEnable;//0-�ر�,1-����
    BYTE byRes[2]; //����
    /********* IPC5.1.7 �������� End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //�ߴ������
    NET_VCA_POLYGON     struVcaPolygon;		//����ʶ������
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

//����ץ�Ĺ������
typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;					//����Ŀ��������ץ�Ĵ���0-10
    BYTE bySnapInterval;                 //ץ�ļ������λ��֡
    BYTE bySnapThreshold;               //ץ����ֵ��0-100
    BYTE byGenerateRate; 		//Ŀ������ٶ�,��Χ[1, 5]
    BYTE bySensitive;			//Ŀ���������ȣ���Χ[1, 5]
    BYTE byReferenceBright; //2012-3-27�ο�����[0,100]
    BYTE byMatchType;         //2012-5-3�ȶԱ���ģʽ��0-Ŀ����ʧ�󱨾���1-ʵʱ����
    BYTE byMatchThreshold;  //2012-5-3ʵʱ�ȶ���ֵ��0~100
    NET_DVR_JPEGPARA  struPictureParam; //ͼƬ���ṹ
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //����ץ�Ĺ���
    //�����ع���̳���ʱ�䣨�����ֽڣ�
    WORD wFaceExposureMinDuration;//��Χ(1~3600�룬Ĭ��60)��Ч���Զ�ģʽ��
    //�����ع�ģʽ
    BYTE byFaceExposureMode;//1-�رգ�2-������0-�Զ�����������жϣ�
    BYTE byBackgroundPic;//����ͼ�ϴ�ʹ�� 0-Ĭ��ֵ����������1-��ֹ
    BYTE byRes2[96];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

//�����
typedef enum tagHUMAN_AGE_GROUP_ENUM
{
    ENUM_AGE_GROUP_INFANT      = 1,   //Ӥ�׶�
        ENUM_AGE_GROUP_CHILD       = 2,   //��ͯ
        ENUM_AGE_GROUP_YOUNGSTER   = 3,   //����
        ENUM_AGE_GROUP_ADOLESCENT  = 4,   //������
        ENUM_AGE_GROUP_YOUTH       = 5,   //����
        ENUM_AGE_GROUP_PRIME       = 6,   //׳��
        ENUM_AGE_GROUP_MIDLIFE     = 7,   //����
        ENUM_AGE_GROUP_MIDAGE      = 8,   //������
        ENUM_AGE_GROUP_OLD         = 9    //����
}HUMAN_AGE_GROUP_ENUM;

//����ץ�Ľ��
typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;     		// �ṹ��С
    DWORD 	dwRelativeTime;     // ���ʱ��
    DWORD	dwAbsTime;			// ���ʱ��
    DWORD   dwFacePicID;       //����ͼID
    DWORD   dwFaceScore;		//��������,0-100
    NET_VCA_TARGET_INFO  struTargetInfo;//����Ŀ����Ϣ
    NET_VCA_RECT         struRect;      //������ͼ����
    NET_VCA_DEV_INFO  	 struDevInfo;	//ǰ���豸��Ϣ
    DWORD   dwFacePicLen;		//������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    DWORD   dwBackgroundPicLen; //����ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ(����)
    BYTE    bySmart;            //IDS�豸����0(Ĭ��ֵ)��Smart Functiom Return 1
    BYTE    byAlarmEndMark;//����������0-������1-�����ǣ����ֶν������ID�ֶ�ʹ�ã���ʾ��ID��Ӧ���±���������Ҫ�ṩ��NVRʹ�ã������жϱ���������ȡʶ��ͼƬ����У��������ߵ�ͼƬ��
    BYTE    byRepeatTimes;   //�ظ���������0-������
	BYTE    byRes;
    NET_VCA_HUMAN_FEATURE   struFeature;  //��������
    float   fStayDuration;  //ͣ��������ʱ��(��λ: ��)
    char    sStorageIP[16];		//�洢����IP��ַ
	WORD    wStoragePort;			//�洢����˿ں�
	BYTE    byRes1[18];              // �����ֽ�
    BYTE*   pBuffer1;  //������ͼ��ͼƬ���
    BYTE*   pBuffer2;  //����ͼ��ͼƬ��ݣ�������ͨ����ұ���ͼ�ӿڿ��Ի�ȡ����ͼ��
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
	DWORD dwImageLen;  //ͼƬ��ݳ���
	DWORD dwFaceScore;		//��������,0-100
	NET_VCA_RECT struVcaRect; //������ͼ����
	NET_VCA_POINT struLeftEyePoint;  //����λ��
	NET_VCA_POINT struRightEyePoint; //����λ��
    BYTE       byDistance;		   //���ۼ��
    BYTE       bySex;
    BYTE       byAgeGroup;
    BYTE       byEyeGlass;
	NET_VCA_RECT struPosRect;  //����λ������
	BYTE	   byRes[20];  //����
	BYTE	   *pImage;  //ͼƬ���
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD     dwSize; //�ṹ��С
    DWORD 	   dwRelativeTime; //���ʱ��
    DWORD	   dwAbsTime; //���ʱ��
    DWORD      dwBackgroundPicLen; //����ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//������ͼ����
    BYTE   byFacePicNum;//��ͼ����
    BYTE   byRes[255];
    BYTE*  pBackgroundPicpBuffer; //����ͼ��ͼƬ���
}NET_DVR_FACE_DETECTION,*LPNET_DVR_FACE_DETECTION;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
	DWORD dwSize;   //�ṹ��С
	DWORD dwImageId; //��ͼID
	BYTE byRes[20]; //����
	DWORD dwSubImageNum;  //������ͼ����
	NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];  //������ͼ��Ϣ
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

//�齹�����
typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     /*�ṹ����*/
    NET_VCA_DEV_INFO  	 struDevInfo;/*�豸��Ϣ*/
    BYTE	byRes[64];		// �����ֽ�
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     /*�ṹ����*/
    BYTE  byAlarmType;//�������ͣ�1-��Ƶ�����쳣��2-��Ƶ����ͻ�䣨��ǿ����3-��ǿ������4-��Ƶ��ʧ
    BYTE  byRes1;
    WORD wAudioDecibel;//����ǿ�ȣ���Ƶ����ͻ��ʱ�õ���
    NET_VCA_DEV_INFO  	 struDevInfo;/*�豸��Ϣ*/
    BYTE	byRes[64];		// �����ֽ�
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct  tagNET_BUTTON_DOWN_EXCEPTION_ALARM
{
    DWORD      dwSize;     /*�ṹ����*/
    NET_VCA_DEV_INFO  	 struDevInfo;/*�豸��Ϣ*/
    BYTE	byRes[64];		// �����ֽ�
}NET_BUTTON_DOWN_EXCEPTION_ALARM, *LPNET_BUTTON_DOWN_EXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //�Ҷ�ͼ����ݿ��
    DWORD   dwHeight;                 //�Ҷ�ͼ��߶�
    DWORD   dwImageLen;  //�Ҷ�ͼ����ݳ���
    BYTE     byRes[20];  //����
    BYTE     *pImage;    //�Ҷ�ͼ�����
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //�ṹ��С
    BYTE     byEnable;         //�Ƿ񼤻����;
    BYTE     bySensitivity;      //��������ȣ�[0,5]
    BYTE     byRes1[22];       //�����ֽ�
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_VCA_POLYGON   struPolygon;    //�����
    NET_VCA_FD_IMAGE_CFG struFDImage;  //ͼƬ��Ϣ
    BYTE     byRes2[20];    //����
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;  //ͼƬ��ݳ���
    DWORD dwFaceScore;		//��������,0-100
    NET_VCA_RECT struVcaRect; //������ͼ����
    BYTE  byRes[20];  //����
    BYTE  *pImage;  //ͼƬ���
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;   //�ṹ��С
    DWORD dwImageId; //��ͼID
    BYTE byRes[20]; //����
    DWORD dwSubImageNum;  //������ͼ����
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //������ͼ��Ϣ
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //ͼƬ��ݳ���
    DWORD dwModelLen;  //ģ����ݳ���
    BYTE  byRes[20]; //����
    BYTE  *pImage;  //����ͼƬ���ָ��
    BYTE  *pModel;  //ģ�����ָ��
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //��ͼID
    DWORD dwFaceScore;		//��������,0-100
    NET_VCA_RECT struVcaRect;  //������ͼ����
    BYTE  byRes[20];  //����
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

#define MAX_HUMAN_PICTURE_NUM  10   //�����Ƭ��
#define MAX_HUMAN_BIRTHDATE_LEN 10   //���������³���

typedef struct tagNET_DVR_AREAINFOCFG
{
    WORD wNationalityID; //��
    WORD wProvinceID; //ʡ
    WORD wCityID; //��
    WORD wCountyID; //��
    BYTE byRes[4]; //����
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //�Ա�0-�У�1-Ů
    BYTE   byCertificateType; //֤�����ͣ�0-���֤��1-����֤
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //�������£��磺201106
    BYTE   byName[NAME_LEN]; //����
    NET_DVR_AREAINFOCFG struNativePlace; //�������
    BYTE   byCertificateNumber[NAME_LEN];  //֤����
    BYTE   byRes2[20];
}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE   byCertificateType; //֤�����ͣ�0-�����ã�1-���֤��2-����֤
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE   byName[NAME_LEN]; //����
    NET_DVR_AREAINFOCFG struNativePlace; //�������
    BYTE   byCertificateNumber[NAME_LEN];  //֤����
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;


typedef struct tagNET_VCA_BLACKLIST_INFO
{
    DWORD  dwSize;   //�ṹ��С
    DWORD  dwRegisterID;  //��ע��ID�ţ�ֻ����
    DWORD  dwGroupNo; //�����
    BYTE   byType; //�ڰ����־��0-ȫ����1-����2-����
    BYTE   byLevel; //����ȼ���0-ȫ����1-�ͣ�2-�У�3-��
    BYTE   byRes1[2];  //����
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE   byRemark[NAME_LEN]; //��ע��Ϣ
    BYTE   byRes2[20];
}NET_VCA_BLACKLIST_INFO, *LPNET_VCA_BLACKLIST_INFO;

typedef struct tagNET_VCA_BLACKLIST_PARA
{
    DWORD dwSize;   //�ṹ��С
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //��������
    DWORD dwRegisterPicNum;  //����ͼ����
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //����ͼƬ��Ϣ
    BYTE  byRes[40]; //����
}NET_VCA_BLACKLIST_PARA, *LPNET_VCA_BLACKLIST_PARA;

typedef struct tagNET_VCA_BLACKLIST_COND
{
    LONG  lChannel; //ͨ����
    DWORD dwGroupNo; //�����
    BYTE  byType; //�ڰ����־��0-ȫ����1-����2-����
    BYTE  byLevel; //����ȼ���0-ȫ����1-�ͣ�2-�У�3-��
    BYTE  byRes1[2];  //����
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //��Ա��Ϣ
    BYTE  byRes[20];
}NET_VCA_BLACKLIST_COND, *LPNET_VCA_BLACKLIST_COND;

typedef struct tagNET_VCA_BLACKLIST_PIC
{
    DWORD dwSize;   //�ṹ��С
    DWORD dwFacePicNum;  //����ͼ����
    BYTE  byRes[20]; //����
    NET_VCA_PICMODEL_RESULT  struBlackListPic[MAX_HUMAN_PICTURE_NUM];  //������Ƭ��Ϣ
}NET_VCA_BLACKLIST_PIC, *LPNET_VCA_BLACKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE byRes[12]; //����
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

#define MAX_FACE_PIC_LEN   6144   //�������ͼƬ��ݳ���
typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ��ݳ���
    NET_DVR_TIME struSnapTime;  //ץ��ʱ��
    DWORD dwSimilarity; //���ƶ�
    BYTE  byRes[16];  //����
    char  sPicBuf[MAX_FACE_PIC_LEN];  //ͼƬ���
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //����ͼƬID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //��ͼID
    DWORD dwFaceScore;  //��������
    NET_VCA_RECT struVcaRect; //������ͼ����
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;

typedef union tagNET_VCA_FIND_SNAPPIC_UNION
{
    NET_VCA_NORMAL_FIND  struNormalFind; //��ͨ����
    NET_VCA_ADVANCE_FIND struAdvanceFind; //�߼�����
}NET_VCA_FIND_SNAPPIC_UNION, *LPNET_VCA_FIND_SNAPPIC_UNION;

typedef enum _VCA_FIND_SNAPPIC_TYPE_
{
    VCA_NORMAL_FIND  = 0x00000000,   //��ͨ����
        VCA_ADVANCE_FIND  = 0x00000001  //�߼�����
}VCA_FIND_SNAPPIC_TYPE;

typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE byThreshold;  //��ֵ��0-100
    BYTE byRes[23]; //����
    VCA_FIND_SNAPPIC_TYPE dwFindType;//�������ͣ����VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //��������
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;     // ���ʱ��
    DWORD dwAbsTime;			// ���ʱ��
    DWORD dwSnapFacePicID;       //ץ������ͼID
    DWORD dwSnapFacePicLen;		//ץ��������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    NET_VCA_DEV_INFO struDevInfo;		//ǰ���豸��Ϣ
   	BYTE  byRes[20];              // �����ֽ�
    BYTE  *pBuffer1;  //ץ��������ͼ��ͼƬ���
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //�������Ϣ
    DWORD dwBlackListPicLen;       //����������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
   	BYTE  byRes[20];              // �����ֽ�
    BYTE  *pBuffer1;  //����������ͼ��ͼƬ���
}NET_VCA_BLACKLIST_INFO_ALARM, *LPNET_VCA_BLACKLIST_INFO_ALARM;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;     		// �ṹ��С
    float fSimilarity; //���ƶȣ�[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //ץ����Ϣ
    NET_VCA_BLACKLIST_INFO_ALARM struBlackListInfo; //������Ϣ
    char		 sStorageIP[16];		//�洢����IP��ַ
	WORD			wStoragePort;			//�洢����˿ں�
    BYTE			 byRes[42];              // �����ֽ�
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;


typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //�������Ϣ
    DWORD dwBlackListPicID;       //����������ͼID�����ڲ���ͼƬ
   	BYTE  byRes[20];              // �����ֽ�
}NET_VCA_BLACKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLACKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;     // ���ʱ��
    DWORD dwAbsTime;			// ���ʱ��
    DWORD dwSnapFacePicID;       //ץ������ͼID
    NET_VCA_DEV_INFO  	 struDevInfo;		//ǰ���豸��Ϣ
   	BYTE  byRes[20];              // �����ֽ�
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;     		// �ṹ��С
    float fSimilarity; //���ƶȣ�[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //ץ����Ϣ
    NET_VCA_BLACKLIST_INFO_ALARM_LOG struBlackListInfoLog; //������Ϣ
    BYTE  byRes[60];              // �����ֽ�
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;

typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;     		// �ṹ��С
   	DWORD dwSnapFaceID; //ץ��������ͼID
    DWORD dwBlackListID; //ƥ��ĺ���ID
    DWORD dwBlackListFaceID; //�ȶԵĺ���������ͼID
    BYTE  byRes[20];              // �����ֽ�
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;     		// �ṹ��С
   	DWORD dwSnapFaceLen; //ץ��������ͼ����
    DWORD dwBlackListFaceLen; //�ȶԵĺ���������ͼ����
    BYTE  byRes[20];              //�����ֽ�
    BYTE *pSnapFace;  //ץ��������ͼ��ͼƬ���
    BYTE *pBlackListFace;  //�ȶԵĺ���������ͼ���
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLACKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //�ṹ��С
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //��������
    DWORD dwImageLen;  //ͼ����ݳ���
    BYTE  byRes[124];  //����
    BYTE  *pImage;    //ͼ�����
}NET_VCA_BLACKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLACKLIST_FASTREGISTER_PARA;

//������������
typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  // �Ƿ����,0-��,1-��
    BYTE  byType;   //0-�洢ץ�ģ�1-�洢����ȶԱ�����2-�洢ץ�ĺͺ���ȶԱ�����0xff-��Ч
    BYTE  bySaveAlarmPic; //�Ƿ����ڱ������ı���ͼƬ��0-��1-��
    BYTE  byRes1[5]; //����
    DWORD dwDiskDriver;   //�̷�ţ���0��ʼ
    DWORD dwLeftSpace;   //Ԥ����������λΪG��
    BYTE  byRes2[8]; //����
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

//�洢·������
typedef struct tagNET_VCA_SAVE_PATH_CFG
{
    DWORD dwSize;   //�ṹ��С
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //��������
    BYTE  byRes[40]; //����
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR 	struIP;		//�����豸��IP��ַ
    WORD 	wDevicePort;			 	//�˿ں�
    BYTE	byEnable;		         //�Ƿ����ã�0-��1-��
    BYTE 	byRes1;				//����
    BYTE	sUserName[NAME_LEN];	//�����豸�ĵ�¼�ʺ�
    BYTE	sPassword[PASSWD_LEN];	//�����豸�ĵ�¼����
    BYTE	byRes2[60];
}NET_DVR_DEV_ACCESS_CFG,*LPNET_DVR_DEV_ACCESS_CFG;

/********************************��������ʶ�� end****************************/
//�ֱ���
#define MAKE_RESOLUTION(_interlace_, _width_, _height_, _fps_) \
    (((_interlace_)<<28) \
    |((((_width_)>>3)&0x1ff)<<19)| \
    ((((_height_)>>1)&0x7ff)<<8)| \
((_fps_)&0xff))
#define GET_RES_INTERLACE(_res_) \
(((_res_)>>28)&0x1)
#define GET_RES_WIDTH(_res_) \
((((_res_)>>19)&0x1ff)<<3)
#define GET_RES_HEIGHT(_res_) \
((((_res_)>>8)&0x7ff)<<1)
#define GET_RES_FPS(_res_) \
((_res_)&0xff)

#define NOT_AVALIABLE	MAKE_RESOLUTION (0,0,0,0)
#define SVGA_60HZ 		MAKE_RESOLUTION(0, 800, 600, 60)
#define SVGA_75HZ 		MAKE_RESOLUTION(0, 800, 600, 75)
#define XGA_60HZ 		MAKE_RESOLUTION(0, 1024, 768, 60)
#define XGA_75HZ 		MAKE_RESOLUTION(0, 1024, 768, 75)
#define SXGA_60HZ  		MAKE_RESOLUTION(0, 1280, 1024, 60)
#define SXGA2_60HZ  	MAKE_RESOLUTION(0, 1280, 960, 60)
#define _720P_24HZ      MAKE_RESOLUTION(0, 1280, 720, 24)
#define _720P_25HZ      MAKE_RESOLUTION(0, 1280, 720, 25)
#define _720P_30HZ      MAKE_RESOLUTION(0, 1280, 720, 30)
#define _720P_60HZ  	MAKE_RESOLUTION(0, 1280, 720, 60)
#define _720P_50HZ  	MAKE_RESOLUTION(0, 1280, 720, 50)
#define _1080I_60HZ 	MAKE_RESOLUTION(1, 1920, 1080, 60)
#define _1080I_50HZ  	MAKE_RESOLUTION(1, 1920, 1080, 50)
#define _1080P_60HZ 	MAKE_RESOLUTION(0, 1920, 1080, 60)
#define _1080P_50HZ 	MAKE_RESOLUTION(0, 1920, 1080, 50)
#define _1080P_30HZ 	MAKE_RESOLUTION(0, 1920, 1080, 30)
#define _1080P_25HZ 	MAKE_RESOLUTION(0, 1920, 1080, 25)
#define _1080P_24HZ 	MAKE_RESOLUTION(0, 1920, 1080, 24)
#define UXGA_60HZ  		MAKE_RESOLUTION(0, 1600, 1200, 60)
#define UXGA_30HZ  		MAKE_RESOLUTION(0, 1600, 1200, 30)
#define WSXGA_60HZ 		MAKE_RESOLUTION(0, 1680, 1050, 60)
#define WUXGA_60HZ  	MAKE_RESOLUTION(0, 1920, 1200, 60)
#define WUXGA_30HZ 		MAKE_RESOLUTION(0, 1920, 1200, 30)
#define WXGA_60HZ  		MAKE_RESOLUTION(0, 1360, 768, 60)
#define SXGA_PLUS_60HZ	MAKE_RESOLUTION(0, 1400, 1050, 60)
#define VGA_MODE_3840x2160_30HZ MAKE_RESOLUTION(0, 3840, 2160, 30)
#define VGA_MODE_3840x2160_60HZ MAKE_RESOLUTION(0, 3840, 2160, 60)



//��ʾͨ������ָ�ģʽ
#define  MAX_WINDOWS_NUM 12		//����ָ�ģʽ������
#define  MAX_SUPPORT_RES 32
#define  MAX_DISPNUM_V41 32
#define  MAX_SDI_RES	 16     //SDI��ʾͨ�����֧�ֱַ�����

typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//��ʾͨ�����ͣ�0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
    BYTE byDispChanSeq;//��ʾͨ�����,��1��ʼ�����������VGA�����ʾ�ڼ���VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;

typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//ͨ������
    BYTE  byStartChan;//��ʼͨ��
    BYTE  byRes[2];
    DWORD	dwSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֱַ���
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

//����ƴ����Ϣ
typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//������ƴ������
    BYTE  byStartBigScreenNum;//����ƴ����ʼ��
    BYTE  byMaxScreenX;//����ƴ��ģʽ
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//ͨ������
    BYTE  byStartChan;//��ʼͨ��
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//֧�ֱַ���
}NET_DVR_SDI_INFO,*LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP����
    BYTE  byDecChanNums;//����ͨ����
    BYTE  byStartChan;//��ʼ����ͨ��
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//VGA��ʾͨ����Ϣ
    NET_DVR_DISPINFO struBncInfo;//BNC��ʾͨ����Ϣ
    NET_DVR_DISPINFO struHdmiInfo;//HDMI��ʾͨ����Ϣ
    NET_DVR_DISPINFO struDviInfo;//DVI��ʾͨ����Ϣ
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //�Ƿ�֧���Զ�������0-��֧�֣�1-֧��
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI��ʾͨ����Ϣ
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;

//��ʾͨ������
#define  MAX_WINDOWS			    16
#define  MAX_WINDOWS_V41			36

#define  STARTDISPCHAN_VGA		1
#define  STARTDISPCHAN_BNC		9
#define  STARTDISPCHAN_HDMI		25
#define  STARTDISPCHAN_DVI		29

typedef union tagNET_DVR_VIDEO_PLATFORM
{
    BYTE byRes[160];
    struct
    {
        /*�����Ӵ��ڶ�Ӧ����ͨ�����Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
        //����ۺ�ƽ̨֧���Զ����������Դ���˲�����Ҫ���
        BYTE	byJoinDecoderId[MAX_WINDOWS_V41];
        //��ʾ���������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ��ݴ˷ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ���������˽���ͨ��
        BYTE	byDecResolution[MAX_WINDOWS_V41];
        NET_DVR_RECTCFG struPosition; //��ʾͨ���ڵ���ǽ��λ��
        BYTE	byRes[80];
    }struVideoPlatform;
    struct
    {
        BYTE	byRes[160];
    }struNotVideoPlatform;
}NET_DVR_VIDEO_PLATFORM, LPNET_DVR_VIDEO_PLATFORM;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{
    DWORD	dwSize;
    BYTE	byAudio;			/*��Ƶ�Ƿ���*/
    BYTE	byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE	byDispChanType;      /*��ʾͨ�����ͣ�0-BNC��1-VGA��2-HDMI��3-DVI��4-YPbPr(���뿨������DECODER_SERVERר��)*/
    BYTE	byVedioFormat;         /*1:NTSC,2:PAL��0-NULL*/
    DWORD	dwResolution;//�ֱ���
    DWORD	dwWindowMode;		/*����ģʽ����������ȡ*/
    BYTE	byJoinDecChan[MAX_WINDOWS_V41];/*�����Ӵ��ڹ����Ľ���ͨ��,�豸֧�ֽ�����Դ�Զ�����ʱ�˲��������*/
    BYTE	byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE	byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    BYTE	byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
    BYTE	byUnionType;/*��ֹ�����,0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-�����������ʾͨ������*/
    NET_DVR_VIDEO_PLATFORM		struDiff;
    DWORD   dwDispChanNum; //��ʾ����ţ��˲�����ȫ����ȡʱ��Ч
    WORD     wLEDWidth;     //LED�ֱ��ʿ?0Ϊ��Ч
    WORD     wLEDHeight;    //LED�ֱ��ʸߣ�0Ϊ��Ч
    BYTE      byEnableVideoEffect;  //��ʾЧ��ʹ�ܣ� 0-��ʹ�ܣ� !0-ʹ��
    BYTE      byRes[3];  //�����ֶ�
    NET_DVR_VIDEOEFFECT struVideoEffect;   //��ʾЧ��
    BYTE	byRes2[60];
}NET_DVR_MATRIX_VOUTCFG,*LPNET_DVR_MATRIX_VOUTCFG;

/*�������豸״̬*/
typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*��ʾ״̬��0��δ��ʾ��1��������ʾ*/
    BYTE  byBVGA;              /*0-BNC��1-VGA�� 2-HDMI��3-DVI��4-SDI 0xff-��Ч*/
    BYTE  byVideoFormat;     /*��Ƶ��ʽ��1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;       /*����ģʽ*/
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*�����ӻ�������Ľ���ͨ��*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*ÿ���ӻ������ʾ֡��*/
    BYTE  byScreenMode;		/*��Ļģʽ0-��ͨ 1-����*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*��ȡȫ����ʾͨ��״̬ʱ��Ч������ʱ����0*/
    BYTE  byRes2[24];
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

/*�������豸״̬*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*����ͨ��״̬*/
    /*��ʾͨ��״̬*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];
    BYTE byAlarmInStatus[32];         /*��������״̬*/
    BYTE byAlarmOutStatus[32];       /*�������״̬*/
    BYTE byAudioInChanStatus;          /*�����Խ�״̬*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41,*LPNET_DVR_DECODER_WORK_STATUS_V41;
/*******************************�ļ��ط�-Զ�̻ط�����*******************************/
typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD	dwSize;
    NET_DVR_IPADDR	struIP;		/* DVR IP��ַ */
    WORD	wDVRPort;			/* �˿ں� */
    BYTE	byChannel;			/* ͨ���� */
    BYTE 	byReserve;
    BYTE	sUserName[NAME_LEN];		/* �û��� */
    BYTE	sPassword[PASSWD_LEN];		/* ���� */
    DWORD	dwPlayMode;   	/* 0�����ļ� 1����ʱ��*/
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE	byRes[64];		/*����*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;


#define  MAX_BIGSCREENNUM_SCENE 100
#define  MAX_LAYERNUMS	32

//��ʾͨ�����ýṹ
typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; /*�������Ͻ���ʼ��X���*/
    WORD wYCoordinate; /*�������Ͻ�Y���*/
    WORD wWidth;       /*���ο��*/
    WORD wHeight;      /*���θ߶�*/
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{
    BYTE	byEnable;//�Ƿ����ã�0-�����ã�1-����
    BYTE	bySoltNum;//��λ��
    BYTE	byRes1[2];
    BYTE	byDispChanNum;
    BYTE	byAudio;				/*��Ƶ�Ƿ���,0-��1-��*/
    BYTE	byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE	byVedioFormat;          /*1:NTSC,2:PAL��0-NULL*/
    BYTE	byWindowMode;			/*����ģʽ������������ȡ*/
    BYTE	byEnlargeStatus;         /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    BYTE	byScale; /*��ʾģʽ��0-��ʵ��ʾ��1-������ʾ( ���BNC )*/
    DWORD   dwResolution;//�ֱ���
    BYTE	byJoinDecChan[MAX_WINDOWS_V41];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE	byJoinDecoderId[MAX_WINDOWS_V41];/*��λ��*/
    //��ʾ���������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ��ݴ�//�ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ���������˽���ͨ��
    BYTE	byDecResolution[MAX_WINDOWS_V41];
    BYTE	byRow;//�������ڵ��е����
    BYTE	byColumn;//�������ڵ��е����
    BYTE	byRes2[5];
    NET_DVR_RECTCFG struDisp; //����ǽ��ʾλ��
} NET_DVR_SCENEDISPCFG,*LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;				/* DVR IP��ַ */
    WORD 	wDVRPort;			 	/* �˿ں� */
    BYTE 	byChannel;		/* ͨ���ţ�����9000���豸��IPC���룬ͨ���Ŵ�33��ʼ */
    BYTE	byTransProtocol;		/* ����Э������0-TCP��1-UDP ��2-MCAST��3-RTP*/
    BYTE	byTransMode;			/* ��������ģʽ 0�������� 1��������*/
    BYTE	byFactoryType;				/*ǰ���豸��������*/
    BYTE	byDeviceType;			//�豸���ͣ�1-IPC��2- ENCODER
    BYTE	byRes[5];
    BYTE	sUserName[NAME_LEN];	/* ��������½�ʺ� */
    BYTE	sPassword[PASSWD_LEN];	/* ����������� */
} NET_DVR_DEV_CHAN_INFO_SCENE,*LPNET_DVR_DEV_CHAN_INFO_SCENE;

/*��ý�������������*/
typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE	byValid;			/*�Ƿ�������ý�������ȡ��,0��ʾ��Ч*/
    BYTE	byRes1[3];
    NET_DVR_IPADDR struDevIP;	/*��ý���������ַ*/
    WORD	wDevPort;			/*��ý��������˿�*/
    BYTE	byTransmitType;		/*����Э������0-TCP��1-UDP */
    BYTE	byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE	streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE				struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE,*LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE							byEnable;	/* �Ƿ����� 0���� 1������*/
    BYTE							byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE	struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE			struDecChanInfo;	/*��Ѳ����ͨ����Ϣ*/
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE,*LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//��Ѳ����ṹ
typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD	wPoolTime;		/*��ѯ���*/
    BYTE	byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE	struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE,*LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//��������ͨ�����ýṹ��
typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE	byDecodeEnable;//������ͣ��־��0-ֹͣ��1-���ö�̬���룬2-������Ѳ����
    BYTE	bySlotNum;//��λ��
    BYTE	byDecChan;
    BYTE	byJointAllDecodeChan;		//�Ƿ�������ܽ���ͨ�� 0-��������1-����
    BYTE	byJointSlotNum;			//�����Ĳ�λ�ţ����ܽ����Ĳ�λ�ţ�
    BYTE	byJointChanNum;		//������ͨ���ţ����ܽ����ͨ���ţ�
    BYTE    byRes[2];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg;
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE,*LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid; /*����ʹ�ܱ�־ */
    BYTE byAssociateBaseMap;//�����ĵ�ͼ��ţ�0��?����
    BYTE byEnableSpartan;//��������ʹ�ܣ�1-����0-��
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;//�����ĸ������ֵͨ����������ȡ
    BYTE  byRes1[3];
    WORD  wDecChanNums;//�����н���ͨ���ĸ���
    WORD  wDispChanNums;//��������ʾͨ���ĸ���
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//�������û�����, byBigScreenNums��sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;//����ͨ�����û�����, wDecChanNums��sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;//��ʾͨ�����û�����, wDispChanNums��sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;

#define	NET_DVR_GET_ALLWINCFG		            1503 //���ڲ����ȡ

typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;//ʹ�ܵ�ͼ��ʾ
    BYTE  byAssociateBaseMap;//�����ĵ�ͼ��ţ�0��?����
    BYTE  byEnableSpartan;//��������ʹ�ܣ�1-����0-��
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;
/*******************************��������*******************************/
#define MAX_WIN_COUNT  224 //֧�ֵ���󿪴���

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD	dwSize;
    BYTE	byVaild;
    BYTE	byInputType;		//��CAM_MDOE
    WORD	wInputIdx;			/*����Դ����*/
    DWORD	dwLayerIdx;			/*ͼ�㣬0Ϊ��ײ�*/
    NET_DVR_RECTCFG  struWin;	//Ŀ�Ĵ���(�����ʾǽ)
    BYTE	byWndIndex;			//���ں�
    BYTE	byCBD;				//0-�ޣ�1-����2-����
    BYTE	bySubWnd;			//0���ǣ�1��
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//�豸���
    BYTE	byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD	dwSize;
    WORD	wScreenSeq;	//�豸���
    BYTE	byRes[10];
    DWORD	dwWinNum;	//�豸���صĴ�������
    BYTE    *pBuffer;	//������Ϣ���������Ϊ224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;	//�����ָ�볤��
}NET_DVR_WINLIST,*LPNET_DVR_WINLIST;

#define MAX_LAYOUT_COUNT 16		//��󲼾���
typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;								//�����Ƿ���Ч
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];			//�������
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];	//�����ڴ��ڲ���
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];   //���в���
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;

#define MAX_CAM_COUNT  224

typedef enum tagNET_DVR_CAM_MODE
{
    NET_DVR_UNKNOW  = 0,//��Ч
        NET_DVR_CAM_BNC,
        NET_DVR_CAM_VGA,
        NET_DVR_CAM_DVI,
        NET_DVR_CAM_HDMI,
        NET_DVR_CAM_IP,
        NET_DVR_CAM_RGB,
        NET_DVR_CAM_DECODER,
        NET_DVR_CAM_MATRIX,
        NET_DVR_CAM_YPBPR,
        NET_DVR_CAM_USB,
        NET_DVR_CAM_SDI,
        NET_DVR_CAM_HDI,
		NET_DVR_CAM_DP,
		NET_DVR_CAM_HDTVI,
		NET_DVR_CAM_JOINT,   //ƴ���ź�Դ
		NET_DVR_CAM_HDBASET,
}NET_DVR_CAM_MODE;

typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD	dwSize ;
    BYTE	byValid;
    BYTE	byCamMode;						//�ź�����Դ���ͣ���NET_DVR_CAM_MODE
    WORD	wInputNo;						//�ź�Դ���0-224
    BYTE	sCamName[NAME_LEN] ;			//�ź�����Դ���
    NET_DVR_VIDEOEFFECT struVideoEffect;	//��Ƶ����
    NET_DVR_PU_STREAM_CFG	struPuStream;	//ip����ʱʹ��
    WORD	wBoardNum ;						//�ź�Դ���ڵİ忨��
    WORD	wInputIdxOnBoard;				//�ź�Դ�ڰ忨�ϵ�λ��
    DWORD   dwResolution;//�ֱ���
    BYTE	byVideoFormat;//��Ƶ��ʽ����VIDEO_STANDARD
    BYTE	byStatus;    //�ź�Դ״̬��0-�ֶ���Ч 1-���ź� 2-���ź� 3-�쳣
    BYTE	sGroupName[NAME_LEN/*32*/];	//�����ź�Դ���� ����
    BYTE	byJointMatrix;			//  �������� ��0-������  1-����
    BYTE	byRes;
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT]; //�����ź�Դ
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

/*******************************�����������*******************************/
/*���ͨ������*/
typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;		/*�������ģʽ,1-BNC,2-VGA,3-DVI,4-HDMI*/
    BYTE   byRes1[3];
    DWORD  dwResolution;	/*�ֱ��ʣ������������ȡ��֧�ֵĽ�������*/
    NET_DVR_VIDEOEFFECT  struVideoEffect;	/*���ͨ����Ƶ��������*/
    BYTE	byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD	dwSize;
    BYTE	byScreenLayX;						//��������-�����
    BYTE	byScreenLayY;						//��������-�����
    WORD	wOutputChanNum;					//���ͨ������0��ʾ�豸֧�ֵ�������ͨ���������������������ȡ������ֵ��ʾʵ�����ͨ������
    BYTE	byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;	/*���ͨ����Ƶ��������*/
    BYTE	sWallName[16];					//����ǽ���
    BYTE	byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

/*******************************������*******************************/
#define SCREEN_PROTOCOL_NUM  	20    //֧�ֵ�������������Э����
//����������������
typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;   			/*�ṹ����*/
    BYTE byIsSupportScreenNum; /*��֧�ִ�������������Ŀ*/
    BYTE bySerialNums;			//���ڸ���
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//��������-������������
    BYTE byMaxScreenLayY;//��������-�������������
    WORD wMatrixProtoNum; /*��Ч�Ĵ���Э����Ŀ*/
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];/*���Э���б�*/
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

//����������������
typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;   		/*�ṹ����*/
    BYTE byLayoutNum; 		/* ���ָ���*/
    BYTE byWinNum; 			/*��Ļ���ڸ���*/
    BYTE byOsdNum;  		/*OSD����*/
    BYTE byLogoNum; 		/*Logo����*/
    BYTE byInputStreamNum;  //����Դ���� ---�豸֧���������ͨ�����������������Դ����������Դ��
    BYTE byOutputChanNum;	//���ͨ������---�豸֧��������ͨ������
    BYTE byCamGroupNum;		/*�������*/
    BYTE byPlanNum;    		/*Ԥ������*/
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  /*�Ƿ�֧�ֻط�*/
    BYTE byMatrixInputNum;  //֧���������������
    BYTE byMatrixOutputNum; //֧���������������
    NET_DVR_DISPINFO struVgaInfo;//VGA�����Ϣ
    NET_DVR_DISPINFO struBncInfo;//BNC�����Ϣ
    NET_DVR_DISPINFO struHdmiInfo;//HDMI�����Ϣ
    NET_DVR_DISPINFO struDviInfo;//DVI�����Ϣ
    BYTE byMaxUserNums;//֧���û���
    BYTE byPicSpan;		//��ͼ��ȣ�һ�ŵ�ͼ���ɸ��ǵ���Ļ��
    WORD wDVCSDevNum;	//�ֲ�ʽ��������������豸��
    WORD wNetSignalNum;	//�����������Դ����
    WORD wBaseCoordinateX;//��׼���
    WORD wBaseCoordinateY;
    BYTE byExternalMatrixNum;	//�����Ӿ������
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

/*******************************�����ź�״̬*******************************/
typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD	dwLostFrame;		/*��Ƶ���붪֡��*/
    BYTE	byHaveSignal;		/*�Ƿ�����Ƶ�ź�����*/
    BYTE	byVideoFormat;		/*��Ƶ��ʽ��1��NTSC,2��PAL,0����*/
    BYTE	byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;

typedef union tagNET_DVR_INPUTSTATUS_UNION
{
    NET_DVR_MATRIX_CHAN_STATUS struIpInputStatus;
    NET_DVR_ANALOGINPUTSTATUS struAnalogInputStatus;
} NET_DVR_INPUTSTATUS_UNION, *LPNET_DVR_INPUTSTATUS_UNION;

typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD	wInputNo;		/*�ź�Դ���*/
    BYTE	byInputType;	//��NET_DVR_CAM_MODE
    BYTE	byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE	byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD	dwSize;
    BYTE	byRes[12];
    DWORD	dwNums;		//�豸���ص�����Դ״̬������
    BYTE    *pBuffer;	//������
    DWORD   dwBufLen;	//�����ָ�볤�ȣ��������
}NET_DVR_SCREENINPUTSTATUS,*LPNET_DVR_SCREENINPUTSTATUS;

typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD	dwSize;
    BYTE	byAlarmType;	//�������ͣ�1-�Ӱ�γ���2-�Ӱ���룬3-��ϵͳ״̬�쳣��4-��ϵͳ�ָ��ָ� 5-����Դ�쳣   6-�¶ȱ��� 7-FPGA�汾��ƥ�� 8-Ԥ����ʼ 9-Ԥ������ 10-�������� 11-�����IP��ַ��ͻ��12-�����쳣
    BYTE	byBoardType;	// 1-����� 2-����� ��3-���壬4-���壬��������Ϊ1��2��3��6��ʱ��ʹ��
    BYTE	bySubException;	//�����쳣ʱ�������쳣 1- �ֱ�����ı� 2-����˿����͸ı�3-�ֱ��ʴ���4-�ֱ��ʸı䵼�½�����Դ���㣬�رո�����Դ��Ӧ���ڡ�5-�ֱ��ʸı䣬�����ѿ��������ű�����1/8��8����Χ��6-�ֱ��ʻָ���,7-�ֱ��ʸı䵼����������������,�豸�رմ���
    BYTE	byRes1;
    WORD	wStartInputNum; // �쳣����Դ���쳣��㣩
    WORD	wEndInputNum;	// �쳣����Դ���쳣�յ㣩
    BYTE	byRes2[16];
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;				//�ж��Ƿ���ģ������Ƿ���Ч��
    BYTE  byCommandProtocol;	//ģ������ָ�4�֣�
    BYTE  byScreenType;			//����
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];	//ģ�������������Ļ�Ķ�Ӧ��ϵ
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;/*�豸Ϊ�����豸ʱ��IP��Ϣ*/
    WORD			wPort;		//ͨ����
    BYTE			byRes[26];  //����
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;
typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE	byDevSerPortNum;   /*�����豸�Ĵ��ں�*/
    BYTE    byScreenSerPort;  /*���Ӵ����Ĵ��ں�*/
    BYTE	byRes[130];
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;

typedef union tagNET_DVR_SCREEN_UNION
{
    NET_DVR_DIGITALSCREEN struDigitalScreen;
    NET_DVR_ANALOGSCREEN struAnalogScreen;
}NET_DVR_SCREEN_UNION, *LPNET_DVR_SCREEN_UNION;
typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;				//�Ƿ���Ч
    BYTE nLinkMode;				//���ӷ�ʽ��0-���ڣ�1-���
    BYTE byDeviceType;			//�豸�ͺţ���������ȡ
    BYTE byScreenLayX;			//��������-�����
    BYTE byScreenLayY;			//��������-�����
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];	/*��¼�û���*/
    BYTE sPassword[PASSWD_LEN]; /*��¼����*/
    BYTE sDevName[NAME_LEN];	/*�豸���*/
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;			// ����Դ����
    BYTE byOutputNum;			// ���Դ����
    BYTE byCBDNum;				//CBD����
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

/*******************************��ͼ�ϴ�*******************************/
typedef struct tagNET_DVR_BASEMAP_CFG
{
    BYTE byScreenIndex;         //��Ļ�����
    BYTE byMapNum;				/*���ָ���˶��ٿ� */
    BYTE res[2];
    WORD wSourWidth;			/* ԭͼƬ�Ŀ�� */
    WORD wSourHeight;			/* ԭͼƬ�ĸ߶� */
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;


typedef struct tagNET_DVR_PICCFG
{
    DWORD	dwSize;		//��С
    BYTE	byUseType;	//1-��ͼ��2-GIFͼƬ��3-CADͼƬ 4-�����ͼƬ
    BYTE    bySequence;//���
    BYTE	byRes[2];
    NET_DVR_BASEMAP_CFG	struBasemapCfg;
    BYTE	sPicName[NAME_LEN];//ͼƬ���
    DWORD   dwVideoWall;       //ǽ�� 1�ֽ�ǽ��+3�ֽڱ���
    BYTE	byRes2[28];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;

/*******************************OSD*******************************/
#define MAX_OSDCHAR_NUM 256
typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*�Ƿ���Ч 0��Ч 1��Ч*/
    BYTE    byDispMode;  //��ʾģʽ��1-͸����2-��͸����3-��������ģʽ
    BYTE    byFontColorY; /*������ɫY,0-255*/
    BYTE    byFontColorU; /*������ɫU,0-255*/
    BYTE    byFontColorV; /*������ɫV,0-255*/
    BYTE    byBackColorY; /*������ɫY,0-255*/
    BYTE    byBackColorU; /*������ɫU,0-255*/
    BYTE    byBackColorV; /*������ɫV,0-255*/
    WORD    wXCoordinate;   /*OSD����Ļ���Ͻ�λ��x*/
    WORD    wYCoordinate;   /*OSD����Ļ���Ͻ�λ��y*/
    WORD    wWidth;       /*OSD���*/
    WORD    wHeight;      /*OSD�߶�*/
    DWORD   dwCharCnt;     /*�ַ�ĸ���*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM];       /*OSD�ַ�����*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;


/*******************************��ȡ������Ϣ*******************************/
typedef struct tagNET_DVR_SERIAL_CONTROL
{
    DWORD	dwSize ;
    BYTE    bySerialNum;        // ���ڸ���
    BYTE	byRes1[3];
    BYTE    bySerial[32];
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;

/*******************************��Ļ����*******************************/
//��Ļ����Դ����
typedef enum tagINPUT_INTERFACE_TYPE
{
    INTERFACE_VGA = 0,
        INTERFACE_SVIDEO, // 2046NL��֧�֣�2046NH֧��
        INTERFACE_YPBPR,
        INTERFACE_DVI ,
        INTERFACE_BNC ,
        INTERFACE_DVI_LOOP,//(��ͨ) 2046NH��֧�֣�2046NL֧��
        INTERFACE_BNC_LOOP, //(��ͨ) 2046NH��֧�֣�2046NL.֧��
        INTERFACE_HDMI,
        INTERFACE_IP,
        INTERFACE_USB,
        INTERFACE_SDI,
        INTERFACE_DP,
        INTERFACE_HDBASET
}INPUT_INTERFACE_TYPE;
typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE	byInputSourceType;	//��INPUT_INTERFACE_TYPE
    BYTE	byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;
//��ʾ��Ԫ��ɫ����
typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE	byColorType;		//1-���� 2-�Աȶ� 3-���Ͷ� 4-�����
    char	byScale;			//-1 ��0��+1���ֵ
    BYTE	byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;
//��ʾ��Ԫλ�ÿ���
typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE	byPositionType;	//1-ˮƽλ�� 2-��ֱλ�ã�
    char	byScale;			//-1 ��0��+1���ֵ
    BYTE	byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;


/*******************************��Ļ����V41*******************************/
typedef struct tagNET_DVR_RECTCFG_EX
{
    DWORD dwXCoordinate; /*�������Ͻ���ʼ��X���*/
    DWORD dwYCoordinate; /*�������Ͻ�Y���*/
    DWORD dwWidth;       /*���ο��*/
    DWORD dwHeight;      /*���θ߶�*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;

/*******************************Ԥ������*******************************/
#define		MAX_PLAN_ACTION_NUM 	32 	//Ԥ����������
#define		DAYS_A_WEEK				7	//һ��7��
#define		MAX_PLAN_COUNT			16	//Ԥ������


typedef enum
{
    NET_DVR_SWITCH_LAYOUT = 1, 		// �����л� Ĭ��
        NET_DVR_SCREEN_POWER_OFF,  		// �رմ���Ļ��ʾ
        NET_DVR_SCREEN_POWER_ON,   		// �򿪴���Ļ��ʾ
}NET_DVR_PLAN_OPERATE_TYPE;

/*Ԥ������Ϣ*/
typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE  	byValid;      	// �����Ƿ���Ч
    BYTE  	byType;       	// ����NET_DVR_PLAN_OPERATE_TYPE
    WORD  	wLayoutNo;  	// ���ֺ�
    BYTE	byScreenStyle;    //��Ļ�ͺţ����ػ����ã�1�ǵ�����2�Ǹ���
    BYTE	byRes1[3];
    DWORD  	dwDelayTime;  	// һ���������ʱ��, ��λ��
    DWORD   dwSerialNo;		//���ںţ���Ļ����ʱʹ��
	BYTE    byRes2[28];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;
typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE	byValid;
    BYTE	byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;
/*Ԥ������*/
typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD 	dwSize;
    BYTE  	byValid;      	// ��Ԥ���Ƿ���Ч
    BYTE  	byWorkMode;  	// Ԥ������ģʽ 1��ʾ�ֶ���2�Զ���3Ԥ��ѭ��
    BYTE	byWallNo;		//����ǽ�ţ���1��ʼ
    BYTE    byPlanNo;	//Ԥ���ţ���ȡԤ���б�ʱ��Ч��0-��Ч��֧��
    BYTE  	byPlanName[NAME_LEN/*32*/]; //Ԥ�����
    NET_DVR_TIME_EX struTime; // ����ģʽΪ�Զ�ʱʹ��
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*ѭ��ʱ�䣬����Ϊһ�����ڣ��ꡢ�¡����������ʹ�á��磺struTimeCycle[0]�е�byValid��ֵ��1����ʾ������ִ�и�Ԥ��������ȡֵ���Ϊ[0,6]������0��������죬1�������һ���Դ�����*/
    DWORD 	dwWorkCount;  	// Ԥ������ִ�д���0Ϊһֱѭ�����ţ�����ֵ��ʾ����
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // Ԥ��ִ�е�����
    BYTE	byRes2[64];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;


/*******************************��ȡ�豸״̬*******************************/
/*Ԥ���б�*/
typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD		dwSize;
    DWORD		dwPlanNums;			//�豸�����ź�Դ����
    BYTE  		*pBuffer;			//ָ��dwInputSignalNums��NET_DVR_PLAN_CFG�ṹ��С�Ļ�����
    BYTE		byWallNo;			//ǽ�ţ���1��ʼ
    BYTE		byRes1[2];
    DWORD 		dwBufLen;			//����仺����ȣ����������ڵ���dwInputSignalNums��NET_DVR_PLAN_CFG�ṹ��С��
    BYTE		byRes2[64];
} NET_DVR_PLAN_LIST,*LPNET_DVR_PLAN_LIST;


/*******************************Ԥ������*******************************/
//�ýṹ�����Ϊͨ�ÿ��ƽṹ��
typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD	dwSize;
    BYTE	sDeviceID[NAME_LEN]; //�����豸���豸ID
    WORD	wChan;				 //����ͨ��
    BYTE	byIndex;			 //��������������ȷ�������ʾʲô����
    BYTE	byRes1;
    DWORD	dwControlParam;
    BYTE	byRes2[32];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

/*******************************��ȡ�豸״̬*******************************/
typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD 	dwSize;
    DWORD	dwMemoryTotal;		//�ڴ�����	��λKbyte
    DWORD	dwMemoryUsage;		//�ڴ�ʹ���� ��λKbyte
    BYTE	byCPUUsage;			//CPUʹ���� 0-100
    BYTE    byMainFrameTemp;   //�����¶ȣ���λ�����϶�
    BYTE    byBackPanelTemp;    //�����¶ȣ���λ�����϶�
    BYTE    byRes1[1];
    BYTE    byLeftDecResource[32];   //�������ʣ�������Դ���Խ�D1�ֱ�����ԴΪ��λ��byLeftDecResource[i],��ʾ��λ��i�����ʣ����Դ,0xff��ʾ��Ч���ǽ�����û����ӣ�
    BYTE    byRes[92];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

// 91ϵ��HD-SDI����DVR �����Ϣ
typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;
   	char  sCameraInfo[32];		// ǰ�������Ϣ
    BYTE  byInterfaceType;		// ǰ�˽���ӿ����ͣ�1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
   	BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //��Ƶ�������ͣ�0-mic in��1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter; //�Ƿ�����������-�أ�-��
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-�����ã�1-�Զ�ģʽ��2-��
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6];
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD		dwSize;
    DWORD		dwInputSignalNums;	//�豸�����ź�Դ����
    BYTE  		*pBuffer;			//ָ��dwInputSignalNums��NET_DVR_INPUTSTREAMCFG�ṹ��С�Ļ�����
    BYTE		byRes1[3];
    DWORD 		dwBufLen;			//����仺����ȣ����������ڵ���dwInputSignalNums��NET_DVR_INPUTSTREAMCFG�ṹ��С��
    BYTE		byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST,*LPNET_DVR_INPUT_SIGNAL_LIST;

// ��ȫ����״̬
#define PULL_DISK_SUCCESS    	1   // ��ȫ���̳ɹ�
#define PULL_DISK_FAIL    		2   // ��ȫ����ʧ��
#define PULL_DISK_PROCESSING    3   // ����ֹͣ����
#define PULL_DISK_NO_ARRAY 		4	// ���в�����
#define PULL_DISK_NOT_SUPPORT	5 	// ��֧�ְ�ȫ����

// ɨ������״̬
#define SCAN_RAID_SUC			1 	// ɨ�����гɹ�
#define SCAN_RAID_FAIL			2 	// ɨ������ʧ��
#define SCAN_RAID_PROCESSING	3	// ����ɨ������
#define SCAN_RAID_NOT_SUPPORT	4 	// ��֧������ɨ��

// ����ǰ���������״̬
#define SET_CAMERA_TYPE_SUCCESS    		1   // �ɹ�
#define SET_CAMERA_TYPE_FAIL    		2   // ʧ��
#define SET_CAMERA_TYPE_PROCESSING		3   // ���ڴ���

//9000 2.2
typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD	dwSize;    //�ṹ���С
    BYTE    byType;    //0 ������Ƶ¼��, 1ͼƬͨ��¼��, 2ANRͨ��¼��, 3��֡ͨ��¼��
    BYTE 	byRes[63]; //����
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD		  dwSize;        //�ṹ���С
    NET_DVR_TIME  strBeginTime;  //��ʼʱ��
    NET_DVR_TIME  strEndTime;    //����ʱ��
    BYTE		  byType;        //0 ������Ƶ¼��, 1ͼƬͨ��¼��, 2ANRͨ��¼��, 3��֡ͨ��¼��
    BYTE 		  byRes[35];     //����
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;					//�ṹ���С
    BYTE     byPicQuota;				//ͼƬ�ٷֱ�	 [0%,  30%]
    BYTE     byRecordQuota;				//��ͨ¼��ٷֱ� [20%, 40%]
    BYTE     byDrawFrameRecordQuota;	//��֡¼��ٷֱ� [30%, 80%]
    BYTE     byRes[61];					//�����ֽ�
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //�ö˿��Ƿ�ʹ��ӳ��
    WORD wExtPort;		//ӳ����ⲿ�˿ں�
    BYTE byRes[12];       //����
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //�ṹ���С
    WORD wEnableUpnp;     //UPNP�����Ƿ�����
    WORD wEnableNat;		//UPNP�˿�ӳ�䣨NAT�������Ƿ�����(��������wEnableUpnp����һ��)
    NET_DVR_IPADDR  struIpAddr;      //NAT·����LAN IP��ַ
    NET_DVR_NAT_PORT    struHttpPort;   //web server http�˿�ӳ������
    NET_DVR_NAT_PORT    struCmdPort; //����˿�ӳ������(8000)
    NET_DVR_NAT_PORT    struRtspPort;  //rtsp�˿�ӳ������
    BYTE byFriendName[64]; //������
    BYTE byNatType; //UPNP�˿�ӳ�����ͣ�0-�ֶ���1-�Զ�
    BYTE            byRes1[3];    //����
    NET_DVR_NAT_PORT    struHttpsPort;     //https�˿�ӳ������
    BYTE            byres[76];    //����
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;

typedef struct
{
    DWORD  dwEnabled;               //�ö˿��Ƿ�ʹ��ӳ��
    WORD   wInternalPort;           //ӳ��ǰ�Ķ˿�
    WORD   wExternalPort;           //ӳ���Ķ˿�
                                    DWORD  dwStatus;				 /*�˿�ӳ��״̬
                                                                     0 δ��Ч
                                                                     1 δ��Ч��ӳ��Դ�˿���Ŀ�Ķ˿���һ��
                                                                     2 δ��Ч:  ӳ��˿ں��ѱ�ʹ��
                                                                     3 ��Ч
                                    */
                                    NET_DVR_IPADDR	struNatExternalIp;       //ӳ�����ⲿ��ַ
                                    NET_DVR_IPADDR	struNatInternalIp;       //NAT·����LAN IP��ַ
                                    BYTE   byRes[16];               //����
}NET_DVR_UPNP_PORT_STATE, *LPNET_DVR_UPNP_PORT_STATE;


typedef struct
{
    NET_DVR_UPNP_PORT_STATE strUpnpPort[UPNP_PORT_NUM];     //�˿�ӳ��״̬,����0 web server�˿� ����1 ����˿� ����2 rtsp�˿�
    BYTE   byRes[200];              //����
}NET_DVR_UPNP_NAT_STATE, *LPNET_DVR_UPNP_NAT_STATE;

typedef struct tagNET_DVR_PLAYCOND
{
    DWORD			 dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE			 byDrawFrame;  //0:����֡��1����֡
    BYTE			 byStreamType ; //�������ͣ�0-������ 1-������ 2-������
    BYTE             byStreamID[STREAM_ID_LEN];
    BYTE			 byRes[30];    //����
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //�������� 0-ȫ����1-��ѯ�� 2-ȡ� 3-�� 4-�޸����룬5-ת�ˣ� 6-�޿���ѯ 7-�޿��� 8-�̳� 9-�̿� 10-�Զ���
    BYTE    byRes[3] ;    //����
    DWORD  dwTransationAmount ;     //���׽�� ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO ;

typedef union  tagNET_DVR_SPECIAL_FINDINFO_UNION
{
    BYTE  byLenth[8] ;
    NET_DVR_ATMFINDINFO      struATMFindInfo;	       //ATM��ѯ
}NET_DVR_SPECIAL_FINDINFO_UNION, *LPNET_DVR_SPECIAL_FINDINFO_UNION;


typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;/*�����¼���ļ�����0xff-ȫ����0-��ʱ¼��1-�ƶ���⣬2-����������3-�����������ƶ���⣬4-�����������ƶ���⣬5-�������6-�ֶ�¼��
    7-����¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼���15-Խ����⣬16-�������֣�17-�����쳣��18-���������⣬19-������⣨Խ�����|��������|�������|�����쳣|���������⣩��
    20-������⣬ 21-�ź�����22-�ش���23-��Ǩ¼��24-�ڵ���25-pos¼��26-�����������, 27-�뿪�������,28-�ǻ����,29-��Ա�ۼ����,30-�����˶����,31-ͣ�����,32-��Ʒ�������,33-��Ʒ��ȡ���,
    34-�����⣬35-���ƻ���⣬36-��ֻ��⣬37-����Ԥ����38-���±���,39-��ܶ�Ź������40-�����⣬41-�˯���*/
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;//�Ƿ��ATM��Ϣ���в�ѯ��0-����ATM��Ϣ��1-�����׿��Ų�ѯ��2-���������Ͳ�ѯ��3-�����׽���ѯ��4-�����š��������ͼ����׽�����ϲ�ѯ 5-���γ���Ʋ��ң���ʱ���ű�ʾ�γ����
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0:����֡��1����֡
    BYTE		byFindType; //0:��ѯ��ͨ�?1����ѯ�浵��
    BYTE		byQuickSearch; //0:��ͨ��ѯ��1�����٣������ѯ
    BYTE        bySpecialFindInfoType ;    //ר�в�ѯ�������� 0-��Ч�� 1-��ATM��ѯ����
    DWORD       dwVolumeNum;  //�浵���
    BYTE		byWorkingDeviceGUID[GUID_LEN];    //������GUID��ͨ���ȡN+1�õ�
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo ;   //ר�в�ѯ����
    BYTE		byStreamType;	//0-��������1-��������2-��������0xff-ȫ��
    BYTE		byAudioFile;				//��Ƶ�ļ� 0-����Ƶ�ļ���1-��Ƶ�ļ�
    BYTE        byRes2[30];    //����
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

typedef struct
{
    BYTE	sAESKey[16];        /*����������Կ*/
    BYTE	byRes[64];          /*�����ֽ�*/
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;

typedef struct
{
    NET_DVR_IPADDR struIP;     //IP��ַ
    BYTE  byRes[128]; //����
}NET_DVR_POE_CFG, *LPNET_DVR_POE_CFG;

#define MAX_PRO_PATH         256    //���Э��·������

typedef struct
{
    DWORD dwSize;              //�ṹ���С
    DWORD dwEnabled;           //�Ƿ����ø�Э��0 ������ 1 ����
    char  sProtocalName[DESC_LEN];   //�Զ���Э�����, 16λ
    BYTE  byRes1[64];          //����,����Э�������չ
    DWORD dwEnableSubStream;   //�������Ƿ�����0 ������ 1 ����

    BYTE  byMainProType;        //������Э������ 1 RTSP
    BYTE  byMainTransType;		//�������������� 0��Auto 1��udp 2��rtp over rtsp
    WORD  wMainPort;           //�������˿�
    char  sMainPath[MAX_PRO_PATH];  //������·��

    BYTE  bySubProType;         //������Э������ 1 RTSP
    BYTE  bySubTransType;		//�������������� 0��Auto 1��udp 2��rtp over rtsp
    WORD  wSubPort;            //�������˿�
    char  sSubPath[MAX_PRO_PATH];   //������·��

    BYTE  byRes2[200];          //����
}NET_DVR_CUSTOM_PROTOCAL, *LPNET_DVR_CUSTOM_PROTOCAL;


//B10��֧��PSIA�豸
//ѭ����ǽ�ṹ�壨ʵʱ��
typedef struct
{
    DWORD	dwEnable; /* �Ƿ����� 0���� 1������*/
    BYTE	byType; //�豸���� 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME	3:DEV_OTHERES
    BYTE	byRes[3];  //����
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; /* ��ѭ����ͨ����Ϣ */
    BYTE	sRtspUrl[128];//����ַ
}NET_DVR_MATRIX_CHAN_INFO_EX,*LPNET_DVR_MATRIX_CHAN_INFO_EX;

typedef struct
{
    DWORD	dwSize;
    DWORD	dwPoolTime;	/*��ѯ���*/
    NET_DVR_MATRIX_CHAN_INFO_EX		struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE    byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_EX,*LPNET_DVR_MATRIX_LOOP_DECINFO_EX;

//ʵʱԤ����ǽ�ṹ��
typedef struct
{
    DWORD dwSize;
    BYTE byType; //�豸���� 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    BYTE byRes[3]; //����
    NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO struDevChanInfo;
    BYTE sRtspUrl[128];//����ַ
}NET_DVR_PU_STREAM_CFG_EX,*LPNET_DVR_PU_STREAM_CFG_EX;

typedef struct tagNET_DVR_MATRIX_TRUNKCFG
{
    DWORD     dwGlobalIndex;  //����
    DWORD     dwInterIndex;   //����ȫ�ֱ��
    BYTE      sTrunkName[NAME_LEN];
    BYTE      byType;   //�豸����1-bnc, 2-SP3, 3-V6
    BYTE      byDir;   //���߷��� 1-����2-���
    BYTE      byAbility;   //����������D1����
    BYTE      bySubsys;   //��ϵͳID
    BYTE      byChan;     //ͨ��ID
    BYTE      byRes[255];     //Ԥ��
} NET_DVR_MATRIX_TRUNKCFG,*LPNET_DVR_MATRIX_TRUNKCFG;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//����״̬��0-û�й�����1-�Ѿ�������ͨ�������ֶ��жϱ��Լ�������������ϵͳ������2-��ռ�ã�byDecodeAbility����1ʱ��Ч��3-����������������4-��������������
    BYTE		byJoinSubSystem;// �������ռ�õ���ϵͳ��λ��
    BYTE		byJoinDispNum;// �������ռ�õ���ʾͨ����
    BYTE		byJoinSubWindowNum;// �������ռ�õ��Ӵ��ں�
    BYTE		byDecodeAbility;   //����ͨ���ĵ�ǰ����������0-δ������1-D1��2-720��3-1080
    BYTE		byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE	bySubSystemType;
    BYTE	byConnectStatus;//����ϵͳ����״̬��1-������2-���ӶϿ�
    BYTE    byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE	bySubSystemNum;//������ϵͳ��λ�ţ���ϵͳ������3��4ʱ����
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE	byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE	bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    BYTE    byUsedTrunk;//�Ƿ񱻸���ʹ�ã�0-δ��ʹ�ã�1-��ʹ��
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;

//////////��ϵͳ����/////////////
#define MAX_ALARMHOSTKEYBOARD 64 //���籨��������������
typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //������ϵͳ�ţ���λ��ʾ��bit0��ʾ�ù�����ϵͳ������ϵͳ1.
    DWORD	dwJointSubSystem;
    BYTE	byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //��ʾ����Щ������ϵͳ��������λ��ʾ��bit0 ��ʾ������ϵͳ.��������������ϵͳ1
    DWORD	dwBeJoinedSubSystem;
    BYTE	byRes[16];
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;

typedef union tagNET_DVR_JOINT_SUB_SYSTEM
{
    // byPublicAttributeEnableΪ0ʱʹ�øñ���
    NET_DVR_NOAMAL_SUB_SYSTEM 	struNormalSubSystem;
    //byPublicAttributeEnableΪ1ʱʹ�øñ���
    NET_DVR_PUBLIC_SUB_SYSTEM		struPublicSubSystem;
    BYTE	byRes[20];
}NET_DVR_JOINT_SUB_SYSTEM,*LPNET_DVR_JOINT_SUB_SYSTEM;
typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD		dwSize;
    WORD		wEnterDelay;					//������ʱ,��λ:��, ��Χ��10-150 ������������������б����������ʱʱ���� NET_DVR_ALARMIN_PARAM �е�dwParam��������ʱʱ��
    //�������������÷�ʽͨ���������е�bySupportAlarmInDelay�ֶ������
    WORD		wExitDelay;//�˳���ʱ,��λ:�룬 ��Χ10-300
    BYTE		byHostageReport;				//Ю�ֱ��棬0���� 1ʹ��
    BYTE		bySubsystemEnable;				//��ϵͳʹ��
    BYTE		byKeyToneOfArmOrDisarm;			// �ɹ����Ͳ����������Ƿ������ʾ��0-���̲���ʾ 1-���������ʾ��
    BYTE		byKeyToneOfManualTestReport;	//�ɹ����Ͳ��Ա����Ƿ������ʾ��0-���̲���ʾ 1-���������ʾ��
    WORD		wDelayTime;						//���������ʱ������������dwSupport1�е�bit0λΪ1ʱ��ʹ�øò������þ������ʱ�䡣bit0Ϊ0ʱ��ʹ��NET_DVR_SIREN_PARAM�е�wDelay�������þ������ʱ��
    BYTE        byEnableAlarmInDelay;//0--������(ʹ����ϵͳ��ʱ),1--����(ʹ�÷�����ʱ)��Ĭ�ϲ�����
    BYTE 		byPublicAttributeEnable;		//�Ƿ�Ϊ������ϵͳ
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;
    BYTE		byKeyZoneArm;					//�Ƿ�֧��Կ�׷������ϵͳ���в�������
    BYTE		byKeyZoneArmReport;				//�Ƿ�֧��Կ�׷������ϵͳ����ʱ���Ͳ�������
    BYTE		byKeyZoneDisarm;				//�Ƿ�֧��Կ�׷������ϵͳ���г�������
    BYTE		byKeyZoneDisarmReport;			//�Ƿ�֧��Կ�׷������ϵͳ���г�������ʱ���ͳ�������
    BYTE		byRes2[624];					// �����ֽ�
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;//�Ƿ����ñ������� 0-�����ã�1-����
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME,*LPNET_DVR_REMIND_TIME;

//��ϵͳ����������չ
#define	MAX_KEYBOARD_USER_NUM	256
typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD 	dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //������ʱ��
    BYTE	byAlarmInAdvance;			// ��������ǰ��ʾʱ��0~45��
    BYTE	byRes1[3];
    BYTE 	byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//��λ����ʾ��ϵͳ�����ı�������ͨ���ţ�0-�����룬1-����
    BYTE 	byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//��λ����ʾ֧�ֵļ��̺ţ�0-�����룬1-����
    BYTE	byJointOpetaterUser[MAX_KEYBOARD_USER_NUM/8];//��λ��ʾ��bit0��ʾ���̲����û�1 ��0-������ 1-����
    NET_DVR_REMIND_TIME	struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];//MAX_TIMESEGMENT_V30��ʾÿ�����֧��8������
    BYTE 			byRes2[288];			// �����ֽ�
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;


typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD 	dwSize;
    BYTE 	byPrinterEnable;		//�Ƿ����ô�ӡ��
    BYTE	byPrintTime;			//�Ƿ��ӡʱ��
    BYTE 	byFaultDetect;			//�Ƿ����ӡ�����
    BYTE	byRes1;
    DWORD	dwAlarmInfo;			//������Ϣ����λ��ʾ��bit0-������bit1-�����ָ���bit2-����������bit-3Ю�ֱ���
    DWORD	dwDeviceInfo;			//�豸��Ϣ����λ��ʾ��bit0-������ϵ硢bit1-������ϵ�ָ���bit2-����Ƿѹ��bit3-����Ƿѹ�ָ���bit4-�绰�߶��ߡ�bit5-�绰�߶��߻ָ���bit6-���Ա��桢bit7-����bit8-����ָ���bit9-485�豸���ߡ�bit10-485�豸���߻ָ���bit11-���������쳣��bit12-��������ָ���bit13-���������쳣��bit14-��������ָ���bit15-��չ�����쳣��bit17-��չ���߻ָ���bit17-Ӳ�̹��ϡ�bit18-Ӳ�̹��ϻָ�
    DWORD	dwOperateInfo;			//������Ϣ����λ��ʾ��bit0-������bit1-������bit2-��bit3-��·��bit4-��·�ָ���bit5-�����̡�bit6-�˳���̡�bit7-����λ
    BYTE 	byRes2[256];			// �����ֽ�
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

//////////GPRS��������/////////////
#define	ACCOUNTNUM_LEN 			6
#define ACCOUNTNUM_LEN_32             32
#define ACCOUNTNUM_LEN_V40      9
#define	APN_NAME_LEN			32
#define	APN_USERNAME_LEN		24
#define	APN_USERPASSWORD_LEN	16

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD	wPort;
    BYTE	byAddressType;	//0 - ������, 1 - ipv4/ipv6��ַ��2 - ����
    BYTE	byRes1[1];
    BYTE	byDomainName[MAX_DOMAIN_NAME/*64*/]; //����GPRS�������á������������ʱ���ֶξ���Ч
    BYTE	byReportProtocol;		//1-private 2-NAL2300
    BYTE	byDevID[ACCOUNTNUM_LEN_32/*32*/]; //Э��ΪNAL2300ʱ��Ч
    BYTE	byRes2[7]; //GPRS������������ڹ̶��ķ������Ͻ��еģ����Բ���Ҫ���������������ϢԤ��һЩ�ֶ�
}NET_DVR_ALARMHOST_NETPARAM,  *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD	dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //���� GPRS������ز��������
    BYTE 	byAPNName[APN_NAME_LEN/*32*/];
    BYTE	byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE	byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE	byReconnTime;	//����ʱ�䣬����ʧЧ������������ʱ�䣬10��Ϊ��λ,ȡֵ��Χ1-30
    BYTE	byOverTime;		//��ʱʱ�䣬����OverTimeʱ��û���յ���Ч�������������Χ1-254����λ30��
    BYTE	byDetectLinkTime;	//	//̽����·�Ƿ񻹱��֣���Χ1-30����λ10s
    BYTE	byRes1;
    BYTE	bySIMNum[NAME_LEN/*32*/]; //SIM���ţ��ֻ�ţ�
    NET_DVR_IPADDR	struSIMIP;	  //��½��������������IP��ַ��ֻ�ܻ�ȡ
    BYTE	byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////�����������/////////////
typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM 	struNetCenter[MAX_CENTERNUM];
    BYTE	byRes1[32];
}NET_DVR_ALARMHOST_NETCFG,  *LPNET_DVR_ALARMHOST_NETCFG;

//////////��ľ�ϴ���ʽ/////////////
#define	MAX_REPORTCHAN_NUM		4
#define	MAX_CENTERGROUP_NUM		16
typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD	dwSize;
    BYTE	byValid;				//�Ƿ�����
    BYTE	byRes[3]; //����1
    BYTE	byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];	//�����鱨��ͨ���� 1-T1��2-T2�� 3-N1�� 4-N2��5-G1�� 6-G2
    BYTE	byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //��ָ�������鷢��ʧ�ܱ��棬�������±��ʾ���ĸ������飬0-��ѡ��1-ѡ��
    BYTE	byDataType;	//1-������� 2-�Ǳ������ 3-�������
    BYTE	byRes2[15];	//����2
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

#define MAX_EVENT_NUM 32//���籨����������¼���
typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD		dwSize;
    BYTE		byValid;			//�Ƿ�����
    BYTE		byDataType;			//1-���б������ 2-���зǱ������ 3-������ݣ�4-�������棬5-�Ƿ�������
    BYTE		byRes[2]; 			//����1
    BYTE		byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];	//�����鱨��ͨ���� 1-T1��2-T2�� 3-N1�� 4-N2��5-G1�� 6-G2(����豸֧��3G��G1��G2��ʾ3Gģ�飬���֧�֣���ʾGPRSģ�飬һ���豸��3Gģ���GPRSģ��ֻ�����һ��)
    BYTE		byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //��ָ�������鷢��ʧ�ܱ��棬�������±��ʾ���ĸ������飬0-��ѡ��1-ѡ��
    BYTE	 	byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];	//��������ͣ�0-���ϴ���1-�ϴ�
    BYTE		byNonZoneReport[MAX_EVENT_NUM]; //�Ƿ�������, ÿһ��Ԫ�ر�ʾһ���¼����ͣ�0-���ϴ���1-�ϴ���byNonZoneReport[0]-������ byNonZoneReport[1]-ϵͳ״̬���� byNonZoneReport[2]-ȡ��� byNonZoneReport[3]-���Ա��� byNonZoneReport[4]-�������� byNonZoneReport[5]-�������� byNonZoneReport[6]-Ю�ֱ��� byNonZoneReport[7]-�����ָ����� byNonZoneReport[8]-��·���� byNonZoneReport[9]-��·�ָ����档
    BYTE		byRes2[256];			//����2
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;


//////////������״̬�ϴ�/////////////
typedef  struct tagNET_DVR_ALARMHOST_SAFETYCABINSTATE
{
    DWORD	dwSize;
    BYTE	byEnterButton;	//���Ű�ť״̬ 0-������ 1-��ť����
    BYTE	byExitButton;	//���Ű�ť״̬ 0-������ 1-��ť����
    BYTE	byDoorState;	//��״̬	0-�Źر� 1-�Ŵ�
    BYTE	byLockState;	//��״̬ 0-���	1-��
    BYTE	byUrgencyButton;	//������ť״̬	0-������ 1-��ť����
    BYTE	byManState;		//��״̬	 0-û�� 1-����
    BYTE    byAbnormal; //�쳣״̬  0-�� 1-�쳣(������ʹ�ó�ʱ�ϴ��쳣)
    BYTE    byLightState;   //�ƹ�״̬ 0-�� ��1-��
    BYTE    byFanState;     //����״̬ 0-�أ�1-��
    BYTE	byRes[63];
}NET_DVR_ALARMHOST_SAFETYCABINSTATE,*LPNET_DVR_ALARMHOST_SAFETYCABINSTATE;

/////////��������ڣ�����״̬�ϴ�/////////////
typedef  struct tagNET_DVR_ALARMHOST_ALARMOUTSTATUS
{
    DWORD	dwSize;
    BYTE	byName[32];		//�����������ƻ򾯺����
    BYTE	byAlarmType;	//1-���������״̬�� 2-����״̬
    WORD	wChan;			//����Ǳ��������״̬����ֵ�ķ�ΧΪ0-511������Ǿ���״̬����Χ1-8��������ֻ��1�����������
    BYTE	byAlarmStatus; //����״̬ 0-�ޱ��� 1-�б���
    BYTE	byRes[32];
}NET_DVR_ALARMHOST_ALARMOUTSTATUS,*LPNET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////�����ϴ�����/////////////
typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD		dwSize;
    BYTE		byAudioFormat;      //��Ƶ��ʽ��1-G711��2-G722
    BYTE		byRes1;
    WORD		wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD		dwSamplesPerSec;	//������
    BYTE		byRes2[20];			//����
    DWORD		dwAudioSize;		//��Ƶ���ȴ�С��ѹ����Ĵ�С
}NET_DVR_AUDIO_PARAM,*LPNET_DVR_AUDIO_PARAM;

//Ԥ��V40�ӿ�
typedef struct tagNET_DVR_PREVIEWINFO
{
    LONG lChannel;//ͨ����
    DWORD dwStreamType;	// �������ͣ�0-��������1-��������2-����3��3-����4 ���Դ�����
    DWORD dwLinkMode;// 0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-RTP/RTSP,5-RSTP/HTTP
    HWND hPlayWnd;//���Ŵ��ڵľ��,ΪNULL��ʾ������ͼ��
    DWORD bBlocked;  //0-������ȡ��, 1-����ȡ��, �������SDK�ڲ�connectʧ�ܽ�����5s�ĳ�ʱ���ܹ�����,���ʺ�����ѯȡ������.
    DWORD bPassbackRecord; //0-������¼��ش�,1����¼��ش�
    BYTE byPreviewMode;//Ԥ��ģʽ��0-��Ԥ����1-�ӳ�Ԥ��
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//��ID��lChannelΪ0xffffffffʱ���ô˲���
    BYTE byProtoType; //Ӧ�ò�ȡ��Э�飬0-˽��Э�飬1-RTSPЭ��
    BYTE byRes1[2];
    DWORD dwDisplayBufNum; //���ſⲥ�Ż�������󻺳�֡��Χ1-50����0ʱĬ��Ϊ1
    BYTE byRes[216];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;


//�¼������������

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD	dwSize;
    DWORD	dwOverallEventTriggerAlarmoutOn;	//ȫ���¼��������������������λ��bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣 ,bit5-Ӳ�̹���
    DWORD	dwOverallEventTriggerAlarmoutOff;	//ȫ���¼��������������������λ��bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣 ,bit5-Ӳ�̹���
    DWORD	dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ�¼����������������,dwSubSystemEvent[0]��ʾ��ϵͳ1��dwSubSystemEvent[2]��ʾ��ϵͳ2���������ϵͳ�������������ȡ��wSubSystem����ÿ����ϵͳ���¼���λ��ʾ��bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������,bit6-�����ָ�,bit7-�������,bit8-�������ָ�
    DWORD	dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ�¼�������������ر�,wSubSystemEvent[0]��ʾ��ϵͳ1��dwSubSystemEvent[2]��ʾ��ϵͳ2���������ϵͳ�������������ȡ��wSubSystem����ÿ����ϵͳ���¼���λ��ʾ��bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������,bit6-�����ָ�,bit7-�������,bit8-�������ָ�
    BYTE	byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

//���ϴ�������
typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD 	dwSize;
    DWORD	dwCheckFault;	//�Ƿ�����ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣��, bit11-������չ���쳣������֧�ֵĹ������ʹ���������ȡ
    DWORD	dwOverallFaultJointLED;		//���Ϲ���ȫ�ּ���ָʾ����� bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣������֧�ֵĹ������ʹ���������ȡ
    DWORD	dwOverallFaultJointSound;	//���Ϲ���ȫ�ּ���������� bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣������֧�ֵĹ������ʹ���������ȡ
    DWORD	dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*���Ϲ�����ϵͳ����ָʾ�������dwSubSystemFaultJointLED[0]��ʾ��ϵͳ1�Ĺ�����Ϣ��dwSubSystemFaultJointLED[0]��ÿһλ��ʾһ�й��ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣; dwSubSystemFaultJointLED[1]��ʾ��ϵͳ2���Դ�����*/
    DWORD	dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*���Ϲ�����ϵͳ������������������ڼ����������dwSubSystemFaultJointLED[0]��ʾ��ϵͳ1�Ĺ�����Ϣ��dwSubSystemFaultJointSound [0]��ÿһλ��ʾһ�й��ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣; dwSubSystemFaultJointSound [1]��ʾ��ϵͳ2���Դ�����*/
    DWORD	dwFaultJointFaultLight;//���Ϲ������ϵ����
    BYTE	byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD	dwSize;
    BYTE	byIndex;			//��ϵͳ�ţ�0xff��ʾ������ϵͳ
    BYTE   	byRes[63];      //����
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;

#define CID_CODE_LEN 4
typedef enum tagNET_DVR_ALARMHOST_REPORT_TYPE
{
    NET_DVR_DEFENCE_ALARM = 1,		//����
        NET_DVR_VIDEO_ALARM,			//��Ƶ����
        NET_DVR_VIRTUAL_DEFENCE_ALARM,	//�����
        NET_DVR_HOSTAGE_ALARM,			//Ю�ֱ���
        NET_DVR_KNOCK_DOWN_ALARM,		//���𱨾�
        NET_DVR_OPERATE_ALARM,			//��������
        NET_DVR_OHTER_ABNORMAL_ALARM	//�쳣����
}NET_DVR_ALARMHOST_REPORT_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MAIN_TYPE
{
	CID_ENTER = 1000,	/*��������Ļ���*/
	CID_EXIT = 3000		/*�ָ�����Ļ���*/
}NET_DVR_ALARMHOST_CID_MAIN_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MINOR_TYPE
{
	CID_ALARM = 103,            /*����*/
	CID_FIRE_ALARM = 110,       /*��*/
	CID_ABDUCT_REPORT = 121,    /*Ю�ֱ���*/
	CID_SILENT_24 = 122,        /*24Сʱ����*/
	CID_AUDIO_24 = 123,         /*24Сʱ����*/
	CID_AUXILIARY_24 = 124,     /*24Сʱ����*/
	CID_SHOCK_24 = 125,         /*24Сʱ��*/
	CID_PERIMETER_ALARM = 131,  /*�ܽ�*/
	CID_INNET_ALARM = 132,      /*�ڲ�����*/
	CID_ENTER_EXIT = 134,       /*����*/
	CID_DEVICE_OPEN = 137,      /*�豸����*/
	CID_ZONE_BUS_BREAK = 141,   // ���߿�·
    CID_ZONE_BUS_SHORT = 142,   // ���߶�·

	CID_AC_LOSS = 301,          /*��������*/
	CID_LOW_BATT_VOL = 302,     /*���ص�ѹ��*/
	CID_DEV_RESET = 305,        /*����λ*/
	CID_MBUS_MODEL_FAULT = 333, // ��չģ�����
	CID_PRINTER_FAIL = 336,     /*��ӡ�����*/
	CID_LINE_LOSS = 354,          // �绰��ͨѶʧ��
	CID_BUS_LOSS = 382, 	    /*��չ����ģ�����*/
	CID_DETECTOR_OPEN = 383, 	/*�����Ӧ������*/

	CID_GUARD = 401,            /*��������*/
	CID_GUARD_AUTO = 403,       /*�Զ�������*/
	CID_CANCEL_ARM = 406,       /*��*/
	CID_GUARD_IMME = 408,       /*��ʱ������*/
	CID_KEY_ZONE_GUARD = 409,   /*Կ�׷�����*/
	CID_GUARD_STAY = 441,       /*���ز�����*/
	CID_FORCED_ARM = 442,       /*ǿ�Ʋ���*/
	CID_AUTOCTRL_TRIG = 443,    /*��ʱ��/�ش�����*/
	CID_AUTOGUARD_FAIL = 455,   /*�Զ�����ʧ��*/
	CID_AOPEN_TRIG_FAIL = 460,  /*��ʱ����������ʧ��*/
	CID_ACLOSE_TRIG_FAIL = 461, /*��ʱ�رմ�����ʧ��*/
	CID_AUTOUNGUARD_FAIL = 462, /*�Զ�����ʧ��*/

	CID_BYPASS = 570,           /*��·�¼�*/
	CID_GROUP_BYPASS = 574,     /*����·*/

	CID_MANUAL_TEST_RPT = 601,  /*�ֶ����Ա���*/
	CID_AUTO_TEST_RPT = 602,    /*��ʱ���Ա���*/
	CID_ENTER_PROG = 627,       /*������*/
	CID_EXIT_PROG = 628,        /*�˳����*/

	CID_SOFT_INSTAND = 810,     /*������������*/
	CID_SOFT_FIRE = 811,        /*������*/
	CID_SOFT_MOBS = 812,        /*�����˾�mobster*/

	CID_KEY_FAIL = 910,         /*���̵���*/
	CID_TRIGGER_FAIL = 911,     /*���������ϴ���������*/
	CID_GPK_FAIL = 912,         /*����������GP/K����*/
	CID_MODULE_FAIL = 913,      /*����������MN/K����*/
	CID_WRIE_LESS_NET = 920,    /*�����������*/
	CID_SIM_FAULT = 921,        /*SIM������*/
	CID_IPADDR_CONFLICT = 930,  /*IP��ͻ*/
	CID_ETHERNET_BROKEN = 931,  /*���߶�*/
	CID_GROUP_OUT_RP = 932,       // ���ͨѶʧ��
    CID_GROUP_IN_RP = 933,        // ͨ��ͨѶʧ��
	CID_MOTION_DECTECT = 940,   /*�ƶ���ⱨ����ʼ/����*/
	CID_MASK_ALARM = 941,       /*�ڵ�������ʼ/����*/
	CID_VI_LOST = 942,          /*��Ƶ��ʧ��ʼ/����*/
	CID_VS_MISMATCH = 943,      /*����/�����Ƶ��ʽ��ƥ��*/
	CID_VI_EXCEPTION = 944,     /*��Ƶ�����쳣/�ָ���*/
	CID_HD_FULL = 945,          /*Ӳ����/�ָ���*/
	CID_HD_ERROR = 946,         /*Ӳ�̴�/�ָ���*/
	CID_PIC_SEND_FAILED = 947,  /*ͼƬ�ϴ�ʧ��*/
	CID_ZONE_BUS_SEARCH = 970,    // ��������
    CID_ZONE_BUS_REGIST = 971,    // ����ע��
    CID_GUARD_DELAY_OP = 972,     // �Զ���������ʱ����
	CID_GUARD_SINGLE = 973     /*��������*/
}NET_DVR_ALARMHOST_CID_MINOR_TYPE;


typedef struct tagNET_DVR_CID_ALARM
{
    DWORD	dwSize;
    BYTE	sCIDCode[CID_CODE_LEN/*4*/];	//CID�¼���
    BYTE	sCIDDescribe[NAME_LEN/*32*/];	//CID�¼���
    NET_DVR_TIME_EX struTriggerTime;			//����������ʱ���
    NET_DVR_TIME_EX struUploadTime;				//�ϴ�������ʱ���
    BYTE	sCenterAccount[ACCOUNTNUM_LEN/*6*/];	//�����ʺ�
    BYTE	byReportType;					//����NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE	byUserType;						//�û����ͣ�0-�����û� 1-�����û�,2-�ֻ��û�,3-ϵͳ�û�
    BYTE	sUserName[NAME_LEN/*32*/];		//�����û��û���
    WORD	wKeyUserNo;						//�����û���	0xFFFF��ʾ��Ч
    BYTE	byKeypadNo;						//���̺�		0xFF��ʾ��Ч
    BYTE	bySubSysNo;						//��ϵͳ��		0xFF��ʾ��Ч
    WORD	wDefenceNo;						//�����		0xFFFF��ʾ��Ч
    BYTE	byVideoChanNo;					//��Ƶͨ����	0xFF��ʾ��Ч
    BYTE	byDiskNo;						//Ӳ�̺�		0xFF��ʾ��Ч
    WORD	wModuleAddr;					//ģ���ַ		0xFFFF��ʾ��Ч
    BYTE	byCenterType;					//0-��Ч, 1-�����˺�(����6),2-��չ�������˺�(����9)
    BYTE	byRes1;
    BYTE	sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];	//�����˺�V40,ʹ�ô��ֶ�ʱsCenterAccount��Ч
    BYTE	byRes2[28];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;

#define MODULE_INFO_LEN			32	//ģ����Ϣ����
#define VERSION_INFO_LEN		32	//�汾��Ϣ����

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD dwSize;
    BYTE	byModuleType;	//1-����2-������ 3-������
    BYTE	byZoneType;		//�������ͣ�1-���ط���2-������3-˫����4-8����5-8·ģ��������6-����������0xff��ʾ�ò�����Ч
    BYTE	byTriggerType;	//���������ͣ�1-���ش������� 2-4·��������3-8·��������4-����������0xff��ʾ�ò�����Ч
    BYTE	byRes1[1];
    char	sModelInfo[MODULE_INFO_LEN];				//ģ����Ϣ
    char	sDeviceVersionInfo[VERSION_INFO_LEN];			    /* �汾��Ϣ*/
    BYTE	byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;


#define MAX_DECODE_CARD_SUPPORTDISPNUMS 8//ÿ�����뿨���֧�ֵ���ʾͨ����
#define MAX_SUPPORT_RES 32
typedef struct tagNET_DVR_DECCARD_ABILITY_V41 /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //����ͨ����
    BYTE byDispNums;      //��ʾͨ����
    BYTE byDecStartIdx;     //�׸�����ͨ�������н���ͨ���е�����
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byRes1[3];
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    BYTE byDispFormat[MAX_DECODE_CARD_SUPPORTDISPNUMS];   //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT�е�ö��)
    BYTE byWindowMode[MAX_DECODE_CARD_SUPPORTDISPNUMS][12]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes2[36];
} NET_DVR_DECCARD_ABILITY_V41,*LPNET_DVR_DECCARD_ABILITY_V41;

#define		MAX_DECODE_CARD_NUM			6   //��������뿨��
typedef struct tagNET_DVR_DECODESVR_ABILITY_V41
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY_V41 struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY_V41, *LPNET_DVR_DECODESVR_ABILITY_V41;

// ��¼��״̬
typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD           dwSize;
    BYTE			byRecord;         //(ֻ��)¼������, 0������¼��1����¼�� 2-����
    //3-������ 4-��������Ƶ 5-δ���� 6-�浵��
    //7-�ش��� 8-�û��������� 9-δ��֤
    //10-�浵�к�¼���� 11-¼��ش��к�¼����
    BYTE			byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE			byRes1[2];        //�����ֽ�
    DWORD			dwRelatedHD;      //��������
    BYTE			byRes2[8];        //�����ֽ�
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

#define  CHAN_NO_LEN   24

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE		byEnable;					//�Ƿ�����
    BYTE		byProType;					//Э�����ͣ�0-˽��Э��(default), (��Ҫ���豸��ȡ����)
    BYTE  		byZeroChan;					//�Ƿ�����ͨ��,0-���ǣ�1-��
    BYTE		byPriority;				//���ȼ�
    BYTE		sUserName[NAME_LEN];		//�û���
    BYTE		sPassword[PASSWD_LEN];	    //����
    BYTE		byDomain[MAX_DOMAIN_NAME];	//�豸����
    NET_DVR_IPADDR  struIP;				        //IP��ַ
    WORD		wDVRPort;			 	    //�˿ں�
    BYTE		byStreamType;               //������:0; ��������1
    BYTE		byOnline;					//ֻ����0-������ 1-����
    DWORD		dwChannel;                  //ͨ����
    BYTE		byTransProtocol;			//Э�����ͣ�0-TCP��1-UDP��2-�ಥ
    BYTE	    byLocalBackUp;		    	//���ر���: 0-������CVR���ر��ݣ�1-����CVR���ر���--���ط�ʱ����һ����¼��?һ���ڴ浵�?���ر��ݣ�
    WORD		wDirectLastTime;			//��������ʱ��
    BYTE    	byChanNo[CHAN_NO_LEN];	 //ͨ�����--����VAGȡ��
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE	byEnable;					//�Ƿ�����
    BYTE	byProType;					//Э�����ͣ�0-˽��Э��(default), 1-����Э�飬2-����, 3-�� (��Ҫ���豸��ȡ����)
    BYTE	byZeroChan;					//�Ƿ�����ͨ��,0-���ǣ�1-��
    BYTE	byRes1;						//�����ֶΣ���0
    BYTE	sUserName[NAME_LEN];		//�û���
    BYTE	sPassword[PASSWD_LEN];	    //����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //ǰ��IP��������,��Ҫ�豸 ������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD	wDVRPort;			 	    //�˿ں�
    BYTE	byStreamType;               //������:0; ��������1
    BYTE	byOnline;					//ֻ����0-������ 1-����
    DWORD   dwChannel;				//ͨ����
    BYTE	byTransProtocol;			//����Э�����ͣ�0-TCP��1-UDP 2-�ಥ
    BYTE	byLocalBackUp;			         //���ر��ݣ�0-������CVR���ر��ݣ�1-����CVR���ر���--��¼��ʱ����һ����¼��?һ���ڴ浵�?���ر��ݣ�
    BYTE	byRes2[2];				//�����ֶΣ���0
    BYTE	byVAGChanNo[MAX_VAG_CHANNO_LEN];	 //Э������ΪVAGʱ����Ӧ��VAGͨ�����
    BYTE    byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];//��ý��IP
    WORD    wStreamMediaPort; //��ý��˿�
    BYTE    byTransmitType; //��ý�崫��Э�� 0- TCP  1- UDP
    BYTE    byRes1[33];
    BYTE    byDevIP[64]; //�豸IP
    WORD    wDevPort; //�豸�˿�
    BYTE    byChannel; //ͨ����
    BYTE    byTransMode; //����ģʽ 0-������ 1- ������
    BYTE    byProType;
    //�������� 0-˽�� 1-�� 2-���� 3-�ɳ� 4-��ɫ�Ǽ� NET_DVR_GetIPCProtoList�ӿڻ�ȡ
    //VQD��ý����ֻ֧�� 0��1��ʽ��ֱ��֧�� 0��1��2��3��4
    BYTE    byTransProtocol; //����Э������0-TCP,  1-UDP,  2-�ಥ��ʽ,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byRes2[28];  //Ԥ��
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{
    BYTE    byEnable;
    BYTE    byRes[3];
    BYTE    byStreamMediaIP[64];//��ý��IP
    WORD   wStreamMediaPort; //��ý��˿�
    BYTE    byTransmitType; //��ý�崫��Э�� 0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64]; //�豸IP
    WORD   wDevPort; //�豸�˿�
    BYTE    byChannel; //ͨ����
    BYTE    byTransMode; //����ģʽ 0-������ 1- ������
    BYTE    byProType;
    //�������� 0-���� 1-�� 2-���� 3-�ɳ� 4-��ɫ�Ǽ� NET_DVR_GetIPCProtoList�ӿڻ�ȡ
    //VQD��ý����ֻ֧�� 0��1��ʽ��ֱ��֧�� 0��1��2��3��4
    BYTE    byTransProtocol; //����Э������0-TCP,  1-UDP  2-�ಥ��ʽ
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byRes2[308];  //Ԥ��
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable;
    BYTE    byStreamType; //��������
    BYTE    byLocalBackUp; //�Ƿ񱾵ر���
    BYTE 	byRes;
    BYTE    strURL[URL_LEN_V40]; //��ý��URL�����Լ���
    DWORD   dwProtocalType;   //IPCЭ������ֵ������ͨ���ȡIPCЭ���б�õ�
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //����ԴIP��������,��Ҫ���� ������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD    wIPPort;  //����Դ��Ӧ�Ķ˿ں�
    WORD    wChanNo; //����Դ�豸IPͨ����
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];	 //����Դͨ�����,����VAG����
    BYTE 	byRes1[88];
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;

typedef union tagNET_DVR_STREAM_TYPE_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO	struChanInfo;	      //IPͨ����Ϣ  ����ֵΪ0
    NET_DVR_PU_STREAM_URL				struStreamUrl;        //ͨ����ý�嵽urlȡ��������ֵΪ4
    NET_DVR_PU_STREAM_URL_CFG           struStreamUrlCfg; //ͨ����ý�嵽ָ������豸��ȡ��������ֵΪ6
}NET_DVR_STREAM_TYPE_UNION, *LPNET_DVR_STREAM_TYPE_UNION;

typedef union tagNET_DVR_STREAM_TYPE_V40_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40	struChanInfo;	 //IPͨ����Ϣ������ֵΪ0
    NET_DVR_PU_STREAM_URL struPuStreamUrl;		//ͨ����ý�嵽urlȡ��������ֵΪ4
    NET_DVR_PU_STREAM_URL_CFG_V40   struStreamUrlCfg; //ͨ����ý�嵽���urlȡ��������ֵΪ6
    NET_DVR_RTSP_PROTOCAL_CFG struRtspCfg;		//�ɱ�׼RTSP����ȡ�� ����ֵ7
    NET_DVR_STREAM_URL_V40  struStreamUrlV40;  //ͨ����ý�壨֧�ּ�����ʽ��������Դȡ��������ֵΪ8
}NET_DVR_STREAM_TYPE_V40_UNION, *LPNET_DVR_STREAM_TYPE_V40_UNION;


typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE					byGetStreamType;	//ȡ����ʽ��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��, 3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸���� 4-ͨ����ý����URLȥȡ��
    BYTE					byRes[3];			// �����ֽ�
    NET_DVR_STREAM_TYPE_UNION	uGetStream;			// ��ͬȡ����ʽ�ṹ��
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

// ����Դ��Ϣ
typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD					    dwSize;
    NET_DVR_STREAM_MODE_TYPE	struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO,*LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD					dwSize;
    BYTE					byGetStreamType;	//ȡ����ʽ��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��, 3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸���� 4-ͨ����ý����URLȥȡ�� 6-ͨ����ý�嵽ָ������豸��ȡ��
    BYTE					byRes1[3];			// �����ֽ�
    NET_DVR_STREAM_TYPE_V40_UNION	uGetStream;			// ��ͬȡ����ʽ�ṹ��
    BYTE					byRes[512];			// �����ֽ�
}NET_DVR_STREAM_SRC_INFO_V40,*LPNET_DVR_STREAM_SRC_INFO_V40;


// ��¼����Ϣ
typedef struct
{
    DWORD			dwSize;
    NET_DVR_RECORD_V30	struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

// ����ID��ʱ��μ���
typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD			dwSize;				// �ṹ���С
    NET_DVR_TIME	strBeginTime;		// ��ʼʱ��
    NET_DVR_TIME	strEndTime;			// ����ʱ��
    NET_DVR_STREAM_INFO struStreamInfo;		// ����Ϣ
    DWORD			dwRecordType;		// ¼������:  0xffffffff��ȫ��������ʱ¼��-�ƶ���⣬������������-�����������ƶ���⣬-�����������ƶ���⣬-�������-�ֶ�¼��-����¼��(ͬ�ļ�����)
    DWORD			dwLockDuration;		// �����ʱ��,��λ�룬0xffffffff��ʾ������
    NET_DVR_TIME_EX		strUnlockTimePoint;	// ����ʱ��Ч����dwLockDuration��Ϊ������ʱ��������ʱ�䵽��ʱ�����Զ�����
    BYTE				byRes[4];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;

// ��ID+ʱ��طŽṹ��
typedef struct tagNET_DVR_VOD_PARA
{
    DWORD				dwSize;
    NET_DVR_STREAM_INFO struIDInfo;
    NET_DVR_TIME		struBeginTime;
    NET_DVR_TIME		struEndTime;
    HWND				hWnd;
    BYTE				byDrawFrame; //0:����֡��1����֡
    BYTE				byVolumeType;  //0-��ͨ¼���  1-�浵��
    BYTE				byVolumeNum;  //��ţ�Ŀǰָ�浵���
    BYTE				byStreamType;   //�������� 0-�������� 1-��������2-������
    DWORD			   	dwFileIndex;  	//�浵���ϵ�¼���ļ����������浵��¼��ʱ���ص�ֵ
    BYTE				byAudioFile;	//��Ƶ�ļ�0-��1-��
    BYTE				byRes2[23];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

// �ֶ�¼��
typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD			lRecordType;
    BYTE			byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;


// CABAC����ѹ������ѡ����������20%��ֻ��ģ��ͨ��������
typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD		dwSize;              	//�ṹ���С
    BYTE 		byCabacEnable;       	//����ѹ������ѡ��ֵ0 ������ 1 ����
    BYTE  		byRes1[31];          		//����
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

#define  MAX_IOSPEED_GROUP_NUM      4 //IO���������
#define  MAX_IOOUT_NUM              4  //���IO����ڸ���
#define  MAX_IOIN_NUM               8  //���IO����ڸ���
#define  MAX_RELAY_NUM              12 //�̵��������豸����� 2013-11-04
#define  MAX_VEHICLE_TYPE_NUM		8  //������Ϣ�ܿ������2013-11-04
#define  MAX_IOIN_NUMEX             10 //���IO����ڸ���(��չ)
#define  MAX_ITC_LANE_NUM           6  //��󳵵�����
#define  MAX_LANEAREA_NUM           2  //����������������
#define  ITC_MAX_POLYGON_POINT_NUM	20	//����������֧��20����Ķ����
#define  MAX_ITC_SERIALCHECK_NUM    8 //����У�����͸���
#define  MAX_LIGHT_NUM              6 //���ͨ����
#define  MAX_VIDEO_INTERVAL_NUM     2  //���ץ�ļ����
#define  MAX_VIDEO_DETECT_LIGHT_NUM  12  //��Ƶ�������������
#define  MAX_RS485_NUM  12 //485�����֧����

#define  MAX_IOOUT_K_NUM            8  //Kϵ�����IO����ڸ���

//IO����ڲ���3.1�汾������֮��
typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IOĬ��״̬��0-�͵�ƽ��1-�ߵ�ƽ
    BYTE     byIOOutStatus;//IO��Чʱ״̬��0-�͵�ƽ��1-�ߵ�ƽ��2-����
    BYTE     byMode; //����ƹ�����ʽ,��λ��ʾ��0-��ʾ������1-��ʾ��������bit0-��Ƶ��bit1-���ڣ�bit2-Υ��
    BYTE     byIOWorkMode;//IO����ڹ���ģʽ��0-����ƣ�1-ƫ��,  2-������
    DWORD    dwTimeDelay;//IO��Ч����ʱ�䣬��λus
    WORD     wAheadTime;//���IO��ǰʱ�䣬��λus
    BYTE     byFreqMulti;		//��Ƶ����ֵ��Χ[1,15]
    BYTE     byDutyRate;		//ռ�ձȣ�[0,40%]
    BYTE     byDetectBrightness;/*�Զ��������ʹ�������0-����⣻1-���*/
    BYTE     byBrightnessThreld;/*ʹ�������������ֵ����Χ[0,100],������ֵ��*/
    BYTE     byFlashLightEnable;	//���������ʱ��ʹ��:0-��;1-��
    BYTE     byStartHour;		//��ʼʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE     byStartMinute;		//��ʼʱ��-��,ȡֵ��Χ0-59
    BYTE     byEndHour;		//����ʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE     byEndMinute;		//����ʱ��-��,ȡֵ��Χ0-59
    BYTE     byAutoPlateBrightness;// ���������Զ�ʹ������� 0-������ 1-����
    BYTE     byRes[8];
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;

typedef enum _ITC_TRIGGERMODE_TYPE_
{
    ITC_POST_IOSPEED_TYPE              = 0x1,  //IO���٣����ڣ�
        ITC_POST_SINGLEIO_TYPE             = 0x2,  //��IO���������ڣ�
        ITC_POST_RS485_TYPE                = 0x4,  //RS485���������������ڣ�
        ITC_POST_RS485_RADAR_TYPE          = 0x8,  //RS485�״ﴥ�������ڣ�
        ITC_POST_VIRTUALCOIL_TYPE          = 0x10,   //������Ȧ���������ڣ�
        ITC_POST_HVT_TYPE_V50			   = 0x20,	//���п�����Ƶ����V50
        ITC_POST_MPR_TYPE                  = 0x40,   //��֡ʶ��(����)(Ver3.7)
        ITC_POST_PRS_TYPE                  = 0x80,   //��Ƶ��ⴥ������
        ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE  = 0x100,  //IO���̵ƣ��羯��
        ITC_EPOLICE_RS485_TYPE             = 0x200,  //RS485�������羯�������羯��
        ITC_POST_HVT_TYPE				   = 0x400,	//���п�����Ƶ���������ڣ�
        ITC_PE_RS485_TYPE                  = 0x10000,  //RS485��������ʽ�羯��������ʽ�羯��
        ITC_VIDEO_EPOLICE_TYPE             = 0x20000, //��Ƶ�羯��������ʽ�羯��
        ITC_VIA_VIRTUALCOIL_TYPE           = 0x40000,  //VIA��������
        ITC_POST_IMT_TYPE				   = 0x80000,   //�ǻۼ������
        IPC_POST_HVT_TYPE			       = 0x100000,	//IPC֧�ֵ�HVT
		ITC_POST_MOBILE_TYPE               = 0x200000 //�ƶ���ͨ����ģʽ
}ITC_TRIGGERMODE_TYPE;

//�������ӿڵ���������ӦpOutBuf����
typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //�������ͣ���λ��ʾ������ITC_TRIGGERMODE_ABILITY���壬���������������Ͳ�ͬ���˴����صĴ�������Ҳ��ͬ
    BYTE byRes[16];
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM
{
    BYTE byIntervalType;	//������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

//��ʶ����
typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д*/
    BYTE byEnable; //�Ƿ����ø�������ʶ��0-��1-��
    DWORD dwRecogMode;
    /*ʶ������ͣ�
       bit0-����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) ��
       bit1-����ʶ���С����ʶ��0-С����ʶ��1-����ʶ�� ��
       bit2-������ɫʶ��0-�����ó�����ɫʶ���ڱ���ʶ���С����ʶ��ʱ��ֹ���ã�1-������ɫʶ��
       bit3-ũ�ó�ʶ��0-������ũ�ó�ʶ��1-ũ�ó�ʶ��
       bit4-ģ��ʶ��0-������ģ��ʶ��1-ģ��ʶ��
       bit5-֡��λ�򳡶�λ��0-֡��λ��1-����λ��
       bit6-֡ʶ���ʶ��0-֡ʶ��1-��ʶ��
       bit7-���ϻ���죺0-���죬1-����
       bit8-Ħ�г�ʶ��0-������Ħ�г�ʶ��1-Ħ�г�ʶ��;
       bit9-����ģʽ��0-�羯/��֡��1-���ڣ�
       bit10-΢С���ƣ�0-�����ã�1-����΢С����ʶ��(����60��80)
       bit11-��ȫ���⣺0-�����ã�1-���ð�ȫ����
       bit12-�񺽳���ʶ��: 0-�����ã�1-�����񺽳���ʶ��
       bit13-���ƹ����б����: 0-�����ã�1-���������б���?PRS��
       bit14-������ʶ��: 0-�����ã�1-����������ʶ��PRS��
       bit15-�������⣺0-�����ã�1-������������
       bit16-�Ʊ공��⣺0-�����ã�1-���ûƱ공���
       bit17-Σ��Ʒ������⣺0-�����ã�1-����Σ��Ʒ�������

    */
    BYTE byVehicleLogoRecog;//����ʶ�� 0-�����ã�1-����
   /*
       0-������1-�ģ�2-����3-�壬4-����5-�ʣ�6-����7-��8-��9-�?10-����11-ԥ��
       12-�ڣ�13-����14-�棬15-����16-�գ�17-�ӣ�18-�ɣ�19-�ɣ�20-����21-�࣬22-³��
       23-��24-�£�25-����26-����27-̨��28-��29-�أ�30-�ۣ�31-�£�32-�ƣ�33-�㣬
       34-�0xff-ȫ��
    */
    BYTE byProvince;//ʡ������ֵ
    BYTE byRegion;// ��������ֵ 0-������1-ŷ�ޣ�2-��������, 3-ŷ��&����˹(EU&CIS)
    BYTE byRes1;
    WORD wPlatePixelWidthMin;//��������ʶ������Сֵ����λ�����أ���ǰ�Ƽ���Χ[130,500]
    WORD wPlatePixelWidthMax;//��������ʶ�������ֵ����λ�����أ���ǰ�Ƽ���Χ[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

//����ͽṹ��
typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //��Ч�� ���ڵ���3������3����һ��������Ϊ����Ч�����߽�����Ϊ����Ч����
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //����α߽��,���20��
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM
{
    BYTE byMode; //�������ͣ�0-���Σ�1-�����
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //��������
        NET_ITC_POLYGON struPolygon; //���������
    }uRegion;
    BYTE  byRes[16];    //����
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

//����IO���ٲ���
typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE byTrigCoil1; //��һ��Ȧ����IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil1IOStatus;//��һ��ȦIO�����״̬��0-�½��أ�Ĭ�ϣ���1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byTrigCoil2; //�ڶ���Ȧ����IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil2IOStatus;//�ڶ���ȦIO�����״̬��0-�½��أ�Ĭ�ϣ���1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE byTimeOut;//��ʱʱ�䣨Ĭ��10������λs
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    DWORD dwDistance;//��Ȧ���루Ĭ��1000��,��λ������
    BYTE byCapSpeed;//�����ٶȣ�Ĭ��30������λkm/h
    BYTE bySpeedLimit;//����ֵ��Ĭ��60������λkm/h
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySnapTimes1; //��Ȧ1ץ�Ĵ���Ĭ�ϲ�ץ�ģ���0-��ץ�ģ���0-���Ĵ������5��
    BYTE bySnapTimes2; //��Ȧ2ץ�Ĵ���Ĭ��1����0-��ץ�ģ���0-���Ĵ������5��
    BYTE byBigCarSpeedLimit; //�󳵳�������ֵ
    BYTE byBigCarSignSpeed;//��־����(��)����λkm/h(3.7Ver)
    BYTE byIntervalType;	//������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wInterval1[MAX_INTERVAL_NUM];//��Ȧ1���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    WORD wInterval2[MAX_INTERVAL_NUM];//��Ȧ2���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO�����(����ͬʱ�������)������0��ʾIO�����1������1��ʾIO�����2���Դ����ƣ�0-��������1-����
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-�����·
    BYTE byCarSignSpeed;//��־���٣���λkm/h(3.7Ver)
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ����(������ʶ����1��������һ��)
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;					    //С���޵���ֵ����λkm/h
    BYTE byBigCarLowSpeedLimit;			    //���޵���ֵ����λkm/h
    BYTE byLowSpeedCapEn;                 //�Ƿ����õ���ץ�ģ�0-��1-��
    BYTE byRes[28];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

//����IO���ٲ���
typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //����IO���������
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

//��IO����
typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO����Ĭ��״̬��0-�͵�ƽ��1-�ߵ�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE bySnapTimes; //ץ�Ĵ���Ĭ��1����0-��ץ�ģ���0-���Ĵ������5
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byEnable;//��IOʹ�ܱ�־0-�����ã�1-���� (Remark:����������֧�� bySupport&0x20����ʾ�Ƿ�֧�ֵ�IO��������IOʹ������ ʱ��Ч)
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    BYTE byRes2;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ����
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

//��IO��������
typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //����IO��������
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //�Ƿ����øó�����0-�����ã�1-����
    BYTE byRelatedDriveWay;//�����ĳ�����
    WORD wDistance; //��Ȧ���룬�����ٶ�
    WORD wTrigDelayTime; //�����ӳ�ʱ�䣨Ĭ��200������λ������
    BYTE byTrigDelayDistance; //�����ӳپ��루Ĭ��0������λ������
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySignSpeed;//��־���٣���λkm/h
    BYTE bySpeedLimit;//����ֵ����λkm/h
    BYTE bySnapTimes; //ץ�Ĵ���Ĭ��1����0-��ץ�ģ���0-���Ĵ������5
    BYTE byOverlayDriveWay; //OSD���ӵĳ�����
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byCartSignSpeed;//��־����(��)����λkm/h
    BYTE byCartSpeedLimit;//����ֵ���󳵣�����λkm/h
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-�����·
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;					//С���޵���ֵ����λkm/h
    BYTE byBigCarLowSpeedLimit;			    //���޵���ֵ����λkm/h
    BYTE byLowSpeedCapEn;                   //�Ƿ����õ���ץ�ģ�0-��1-��
    BYTE byRes[10];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

//����RS485��������������
typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byTriggerSpareMode; //��������ģʽ��0-Ĭ�ϣ�1-����������Ȧģʽ,2-���ڻ�ϳ���ģʽ
    BYTE byFaultToleranceTime;//�ݴ�ʱ��(��λ:����)�����ڼ�⳵�����Ƿ�������ʱ��
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;	//�״����ͣ�0-���״�,1-�������״2-����ά�ǣ�3-����΢��4,�״��IO��չ��(�˲����ڿ���������Ȧ�����п��ڽ�����ʹ�ã�����RS485�״ﲻʹ��),0xff-��������
    BYTE    byLevelAngle;   //��ˮƽ����ɽǶ�,Ĭ��Ϊ25��(0��90��)
    WORD    wRadarSensitivity; //�״�������
    WORD    wRadarSpeedValidTime;//�״��ٶ���Чʱ��(0~2000] ,0��ʾ��֧��
    BYTE    byRes1[2];
    float  	fLineCorrectParam;//���Խ������[0.0~2.0]
    int  	iConstCorrectParam;//�����������[-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND  //�����ṹ
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;//������RS485�� 1��5 (Ψһֵ)
    //	BYTE  byModeType; //0��Ԥ����1���״2����������3���źŵƼ����
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND,*LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;//24
    BYTE  byAssociateLaneNo;//�����ĳ�����1��99 (���ֵ�����ڲ�ͬRS485���ظ�)
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;

typedef union tagNET_ITC_ACCESS_DEVINFO_PARAM_UNION
{
    BYTE uLen[128];
    NET_ITC_RADAR_INFO_PARAM struRadarInfoParam;//�״��������
}NET_ITC_ACCESS_DEVINFO_PARAM_UNION, *LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION;

typedef struct tagNET_ITC_RS485_ACCESS_CFG //144  ���ýṹ
{
    DWORD dwSize;
    BYTE  byModeType;//0��Ԥ����bit1���״bit2����������bit3���źŵƼ����
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam; //64
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG,*LPNET_ITC_RS485_ACCESS_CFG;

//2013-07-09 �״����������չ
typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];//�೵���״���Ϣ
    //���������������ʾ����֧�ֵ�Ĭ��Ϊ0������ʾ  ���м�������֧�ּ�����
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;


//����RS485�״ﴥ������
typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    NET_ITC_RADAR_PARAM struRadar;  //�״����
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySignSpeed;//��־���٣���λkm/h
    BYTE bySpeedLimit;//����ֵ����λkm/h
    BYTE bySnapTimes; //ץ�Ĵ���Ĭ��1����0-��ץ�ģ���0-���Ĵ������5
    BYTE byBigCarSignSpeed;///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLowSpeedLimit;/*�޵��٣���λkm/h*/
    BYTE byBigCarLowSpeedLimit; /*���޵��٣���λkm/h*/
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    NET_VCA_LINE struLine; //������
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  /*������Ȧ����*/
    BYTE byTrigFlag; //������־��0-��ͷ������1-��β������2-��ͷ/��β������
    BYTE byTrigSensitive;  //���������ȣ�1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO�����(����ͬʱ�������)������0��ʾIO�����1������1��ʾIO�����2���Դ����ƣ�0-��������1-����
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-�����·
    BYTE byEnableRadar; //�Ƿ������״���٣�0-��1-��
    NET_ITC_VTLANE_PARAM struLane; //�����ĳ�������
    //������;���ͣ����ITC_LANE_USEAGE_TYPE��ʹ��1��8��������(3.7Ver)
    BYTE byUseageType;
    //������ʻ�������ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

//����������Ȧ��������
typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE    byRelatedLaneNum;//�����ĳ�������
    BYTE    byIsDisplay; //��Ƶ���Ƿ���ʾ������Ȧ��0-����ʾ��1-��ʾ
    BYTE    byLoopPos; //��䴥����Ȧ��ƫ��Ĭ��10��
    BYTE    byPolarLenType; /*ƫ�����ͣ�0������ƫ�񾵣�1����ʩ�͵�ƫ�񾵡�*/
    BYTE    byDayAuxLightMode; /*���츨������ģʽ��0���޸���������1��LED��������2�����������*/
    BYTE    byVideoLaneNO; //��Ƶ�ο����ȵĲο�������
    BYTE    byVideoLowTh; /*��Ƶ�ο����ȵ���ֵ��ʼ��ֵ��Ĭ��40��*/
    BYTE    byVideoHighTh; /*��Ƶ�ο����ȸ���ֵ��ʼ��ֵ��Ĭ��55��*/
    BYTE    byRecordMode; //¼���־��0-��¼��1-¼��
    BYTE 	bySnapMode;//ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    /*���ٷ�ʽ��0-�����٣�0x1-�״���٣�0x2-��Ƶ����*/
    BYTE    bySpeedDetector;
    BYTE    byRes2;
    WORD    wResolutionX;/* �豸��ǰ�ֱ��ʿ�*/
    WORD    wResolutionY;/* �豸��ǰ�ֱ��ʸ�*/
    DWORD   dwDayInitExp; /*��Ƶ�����ع�ʱ��ĳ�ʼֵ2000*/
    DWORD   dwDayMaxExp; /*��Ƶ�����ع�ʱ������ֵ20000*/
    DWORD   dwNightExp; /*�����Ƶ�ع�ʱ�������ֵ3000*/
    DWORD   dwSnapExp; /*ץ���ع�ʱ��*/
    BYTE    byDayInitGain; /*��Ƶ��������ĳ�ʼֵ200*/
    BYTE    byDayMaxGain; /*��Ƶ������������ֵ400*/
    BYTE    byNightGain; /*�����Ƶ����*/
    BYTE    bySnapGain; /*ץ������*/
    DWORD   dwSceneMode; //����ģʽ�� ���SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //��ַλ��(Ĭ���㽭)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //������Ȧ����
    NET_ITC_RADAR_PARAM struRadar;  //�״����
    NET_VCA_LINE struLine; //�ҳ�����
    //Υ�������ͣ���λ��ʾ�����ITC_VIOLATION_DETECT_TYPE��0-�����ã�1-����(3.7Ver)
    DWORD dwVioDetectType;
    BYTE  byDebugMode; /*����ģʽ��0-�����ã�1-����*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

//����IO���̵Ʋ���
typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE byLightIO; //���̵�IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrafficLight; //���̵���Ч״̬0-�ߵ�ƽ��ƣ��͵�ƽ�̵ƣ�1-�ߵ�ƽ�̵ƣ��͵�ƽ���
    BYTE byTrigIO;//������IO�ţ�0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrigIOStatus;//����IO�ڵ�״̬��Ĭ��0����0-�½��أ�1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE byRedSnapTimes; //���ץ�Ĵ���0-��ץ�ģ���0-���Ĵ������5��
    BYTE byGreenSnapTimes; //�̵�ץ�Ĵ���0-��ץ�ģ���0-���Ĵ������5��
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    BYTE byRes1;
    BYTE byIntervalType;	//������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wRedInterval[MAX_INTERVAL_NUM];//������ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    WORD wGreenInterval[MAX_INTERVAL_NUM];//�̵����ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ�������
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

//�羯IO���̵Ʋ���
typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //����IO���̵Ʋ���
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;

typedef enum _ITC_SERIAL_PROTOCOL_
{
    ITC_PROTOCOL_UNKNOW = 0, /*δ֪*/
        ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1, /*����Ȧ������Э��ģʽ1����ʾΪ����_��1_��1_��1_1��������뿪���뿪��ʱץ�ģ��뿪��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2, /*˫��Ȧ������Э��ģʽ1����ʾΪ��˫_��1_��1_��2_1��������1���뿪1���뿪2ץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��Ĭ�ϣ�*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3, /*˫��Ȧ������Э��ģʽ2����ʾΪ��˫_��1_��2_��2_1�����뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4, /*˫��Ȧ������Э��ģʽ3����ʾΪ��˫_��2_��1_��2_1��������2���뿪1���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5, /*˫��Ȧ������Э��ģʽ4����ʾΪ��˫/��_��2_��2_��2_1��������2���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6, /*˫��Ȧ������Э��ģʽ5����ʾΪ��˫/��_��2_��2_��2_2��������2���뿪2���뿪2��ʱץ�ģ�����2���뿪1����ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ��Ĭ�ϣ�*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7, /*˫��Ȧ������Э��ģʽ6����ʾΪ��˫/��_��1_��2_��2_2��������1���뿪2���뿪2��ʱץ�ģ�����1���뿪1����ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8, /*˫��Ȧ������Э��ģʽ7����ʾΪ��˫_��1_��1_��2_1��������1���뿪1���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1������Ƶ���1���뿪1���뿪2��ʱ���ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9, /*˫��Ȧ������Э��ģʽ8����ʾΪ��˫_��1_��1_��2_2��������1���뿪1���뿪2��ʱץ�ģ�����1���뿪1����ʶ���ϴ�����ͼƬ�������뿪1������Ƶ���1���뿪1���뿪2��ʱ�������Ŷȸߵĳ��ƽ��Ĭ�ϣ�*/
        ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10, /*����Ȧ������Э��ģʽ2����ʾΪ����_��1_��1_��1_2��������뿪���뿪��ʱץ�ģ�����뿪����ʶ���ϴ�����ͼƬ�������뿪������Ƶ���뿪���뿪��ʱ�������Ŷȸߵĳ��ƽ��Ĭ�ϣ�*/
        ITC_OTHER_PROTOCOL = 0xff /*�������Э��(������demo�������ã�3.3֮��汾������demo�Ϳؼ���֧�ִ�ֵ)*/
}ITC_SERIAL_PROTOCOL;

//����߼�ץ������
typedef enum _ITC_NORMAL_PASS_SERIAL_PROTOCOL_
{
    ITC_NORMAL_PASS_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_NORMAL_PASS_PROTOCOL_MODE1  = 1,  //����Ȧ���뿪ץ�ģ���ʶ�ϴ���Ĭ�ϣ�
        ITC_NORMAL_PASS_PROTOCOL_MODE2 =2,  //����Ȧ������뿪ץ�ģ�����ʶ�����ϴ��뿪����ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_NORMAL_PASS_PROTOCOL_MODE3 =3,  //˫��Ȧ���뿪1ץ�ģ���ʶ�ϴ���Ĭ�ϣ�
        ITC_NORMAL_PASS_PROTOCOL_MODE4 =4, //˫��Ȧ������1���뿪1ץ�ģ�����ʶ�����ϴ��뿪1����ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_NORMAL_PASS_PROTOCOL_MODE5 =5, //˫��Ȧ������2���뿪1ץ�ģ�����ʶ�����ϴ��뿪1����ͼƬ�����Ŷȸߵĳ��ƽ��
}ITC_NORMAL_PASS_SERIAL_PROTOCOL;

//����Υ���߼�ץ������
typedef enum _ITC_INVERSE_SERIAL_PROTOCOL_
{
    ITC_INVERSE_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_INVERSE_PROTOCOL_MODE1  = 1,  //��ץ��
        ITC_INVERSE_PROTOCOL_MODE2 =2,  //����1��ץ2�š��뿪2ץ�ģ�����1���ž���ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_INVERSE_PROTOCOL_MODE3 =3,  //����1���뿪2ץ�ģ�����1��ʶ���ϴ�2�ų���ͼƬ�ͳ��ƽ��
}ITC_INVERSE_SERIAL_PROTOCOL;

//����Υ���߼�ץ������
typedef enum _ITC_SPEED_SERIAL_PROTOCOL_
{
    ITC_SPEED_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_SPEED_PROTOCOL_MODE1  = 1,  //��ץ��
        ITC_SPEED_PROTOCOL_MODE2 =2,  //˫/����Ȧ���뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1�������뿪1���뿪2���뿪2��ʱ���ͳ��ƽ��
        ITC_SPEED_PROTOCOL_MODE3 =3,  //˫/����Ȧ���뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1�������뿪1���뿪2���ͳ��ƽ��
}ITC_SPEED_SERIAL_PROTOCOL;

//����������
typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //������Э�����ͣ����ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;	//������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wInterval;//���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byNormalPassProtocol; //���ץ��Э�����ͣ����ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //����ץ��Э�����ͣ����ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //����ץ��Э�����ͣ����ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //�Ƿ����øó�����0-�����ã�1-����
    BYTE byRelatedDriveWay;//�����ĳ�����
    WORD wDistance; //��Ȧ���룬��λ����
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE bySignSpeed;//��־����(��ʽ�羯ģʽ��Ч)����λkm/h
    BYTE bySpeedLimit;//����ֵ(��ʽ�羯ģʽ��Ч)����λkm/h
    BYTE byOverlayDriveWay; //OSD���ӵĳ�����
    NET_ITC_SERIAL_INFO struSerialInfo; //����������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE bySerialType; //���������ͣ�0-˽�г�������1-˽��OEM��������2-�������
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    BYTE bySnapPicPreRecord; //ץ��ͼƬԤ¼ʱ��㣻0-Ĭ��ֵ���ڶ���ͼƬ����1-��һ��ͼƬ��2-�ڶ���ͼƬ��3-������ͼƬ
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    BYTE byBigCarSignSpeed;	///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/
    BYTE byRedTrafficLightChan;//���ͨ���ţ�1��16�����̵Ƽ������
    BYTE byYellowTrafficLightChan;//�Ƶ�ͨ���ţ�1��16�����̵Ƽ������
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

//�羯/��ʽ�羯RS485��������������
typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byTrafficLightSignalSrc;//��ͨ���ź���Դ 0�������� 1�����̵Ƽ����
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

//�������Բ���ṹ
typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType;     //������;���ͣ����ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType;  //�����������ͣ����ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //������ʻ�������ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[33];        //����
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

//��Ƶ�羯�߽ṹ
typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //�߲���
    BYTE byLineType; //�����ͣ����ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE 	byVehicleCapMode;//��ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE 	byNoVehicleCapMode;//�ǻ�ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE 	byPasserCapMode;//����ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE 	byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

//size = 128
typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD 		dwCapShutter;			//ץ�Ŀ���0~65535
    WORD 		wCapGain;			//ץ������0��100
    BYTE  		byRes[2];
    DWORD 		dwDayTimeVideoShutter;	//�����ع�ʱ�����ֵ
    WORD 		wDayTimeVideoGain;		//�����������ֵ
    WORD 		wNightVideoGain;			//�����������ֵ
    DWORD 		wNightVideoShutter;		//�����ع�ʱ�����ֵ
    BYTE  		byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //�����ĳ����� 1~255�����ڵ��Ӻ��ϴ���
    BYTE bySignSpeed;	//��־���٣���λkm/h 0��255  70
    BYTE bySpeedLimit;	//����ֵ����λkm/h 0��255    80 ʵ����Ч
    BYTE byBigCarSignSpeed;///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE byCaptureCount;//ץ������1��5(��)
    BYTE byRelatedIOOut;	/*������IO�����(����ͬʱ�������)����λ��ʾIO����ڣ���0λ��ʾIO�����1���Դ����ƣ�0-��������1-����*/
    BYTE byFlashMode;		/*�������˸ģʽ��0-ͬʱ����1-������*/
    BYTE byEnableRadar; //�Ƿ������״���٣�0-��1-��
    BYTE byRes2[2];
    DWORD dwCapTarget;	//ץ������ bit0 ��ʾ�� bit1 ��ʾ�ǻ� bit2 ��ʾ���� 0����ʾ��ѡ�� 1����ʾѡ��
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //�������ԣ���byUseageType��byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;		  //�󳵵��ߣ�������Ϊ���ߡ�ʵ�ߡ������ߺ�˫����
    NET_ITC_LINE struRightLaneLine;		  //�ҳ����ߣ�������Ϊ���ߡ�ʵ�ߡ������ߺ�˫����
    NET_ITC_POLYGON struPlateRecog;         //��ʶ�������
    NET_ITC_POLYGON struTraceArea;		  //��Ƶ������������
    NET_VCA_LINE  struForwardTrigLine;	  //���򴥷��ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧��ˮƽ���ã��ӿڰ��߶ε������˵㱣�档��һ������Ϊ����������Ѵ���λ�ã�
    NET_VCA_LINE  struBackwardTrigLine;     //���򴥷��ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧��ˮƽ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ����������Ѵ���λ�ã�
    NET_VCA_LINE  struLeftTrigLine;		  //��ߴ����ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧�ִ�ֱ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ����߽��복������Ѵ���λ�ã�
    NET_VCA_LINE  struRightTrigLine;		  //�ұߴ����ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧�ִ�ֱ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ���ұ߽��복������Ѵ���λ�ã�
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//ʶ��ĳ�������1-6
    BYTE bySceneMode;//0-δ֪1-�����·��2-С������
    BYTE byRoadExpBright;//·���������ȣ���Ƶ�ع������������֮һ�����޻�ʱ�����ݴ���������ֵ��������Ƶ�ع����
    BYTE byPlateExpBright;//�����������ȣ���Ƶ�ع������������֮һ�����л�ͨ��ʶ�𵽳���ʱ�����ݴ���������ֵ������Ƶ�ع�������
    NET_ITC_POLYGON struDetectArea;					//��Ƶ�������
    NET_ITC_SNAPMODE_PARAM  struCapMode;//ץ��ģʽ
    NET_ITC_HVT_EC_PARAM struEcParam;	//�ع���Ʋ���
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //����������
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;	//��ʶ����
    NET_DVR_GEOGLOCATION struGeogLocation;	//��ַλ�ã�Ĭ���㽭��
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

/*************************MPR����ģʽ begin 2013-12-07****************/
typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO��[1, byIoInNum+1] ��С��1��ʼ�����ֵ��ݽӿ���������NET_DVR_SNAP_ABILITY���ֶ�byIoInNum
            BYTE  byTriggerType;//0-�½��أ�1-������
            BYTE  byRes1[2];
        }struIO;//IOģʽ����Ч
        struct
        {
            BYTE  byRelateChan;//����������ͨ����[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; //������ʻ���� ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_MPR_PARAM,*LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR��������Ƶ������,1-����IO�������ظ���Ȧ��,2-����RS485�Ĵ����ź�
    BYTE byPicUploadType;//ͼƬ�ϴ����ͣ�0~ȫ���ϴ���1-�����ϴ���2-�����ϴ�
    BYTE byRes[60];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char szSceneName[NAME_LEN/*32*/]; //�������
    BYTE byRes1[408];
}NET_ITC_POST_MPR_PARAM,*LPNET_ITC_POST_MPR_PARAM;
/*************************MPR����ģʽ end 2013-12-07****************/

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //����������
    BYTE byRes[63]; //����
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //�������Բ���
    NET_ITC_LINE  struLaneLine;//������
    NET_ITC_POLYGON  struPlateRecog;//��ʶ����
    BYTE byRes1[300]; //����
} NET_DVR_VIA_LANE_PARAM,*LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;	//ʹ�� 0-������ 1-����
    BYTE byLaneNum; //������
    BYTE byRes[62]; //����
    NET_ITC_LINE  struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//��ʶ����
    BYTE byRes1[624];//����
}NET_DVR_VIA_VTCOIL_PARAM,*LPNET_DVR_VIA_VTCOIL_PARAM;

//���������ӿ�
typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //�ṹ���С
    DWORD  dwChannel;    //ͨ����
    DWORD  dwTriggerMode;//������ʽ���ο� ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    BYTE   byRes[63];    //������
}NET_DVR_TRIGGER_COND,*LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;//���ӳ�����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;//������
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM,*LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySnapMode; //ץ�����ͣ�0~����1~�����
	BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//��ʶ����
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ����ұ߳����ı߽��ߣ�
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM,*LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO��[1,4]
            BYTE  byTriggerType;//0-�½��أ�1-������
            BYTE  byRes1[2];
        }struIO;//IOģʽ����Ч
        struct
        {
            BYTE  byRelateChan;//����������ͨ����[1,16]
            BYTE  byRes2[3];
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_PRS_PARAM,*LPNET_ITC_LANE_PRS_PARAM;


typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;
    BYTE byLaneNum;
    BYTE bySourceType;//0-��Ƶ���,1-����IO�������ظ���Ȧ��,2-����RS485�Ĵ����ź�
    BYTE bySnapMode;//0-ȫ��ͼ��1-ȫ��ͼ+��д
    BYTE byCapMode;//bySourceTypeΪ0��Ƶ���ʱʹ�ã�0-Ƶ��ģʽ��1-����ģʽ
    BYTE byRes[59];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM,*LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //������ʻ���� ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM,*LPNET_IPC_LANE_HVT_PARAM;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;
    BYTE  byLaneNum;
    BYTE  byRes[62];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    char    szSceneName[NAME_LEN/*32*/]; //�������
    BYTE  byRes1[408];
} NET_IPC_POST_HVT_PARAM,*LPNET_IPC_POST_HVT_PARAM;

//ץ�Ļ�4.0����
typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE  byLaneNO;		//�����ĳ�����1��255(���ڵ��Ӻ��ϴ�)
    BYTE  byFlashMode;	//�������˸ģʽ��0-ͬʱ����1-������
    BYTE  bySignSpeed;	//С����־�޸��٣���λkm/h
    BYTE  bySpeedLimit;	//С���޸���ֵ����λkm/h
    BYTE  bySignLowSpeed;	//С����־�޵��٣���λkm/h
    BYTE  byLowSpeedLimit;	//С���޵���ֵ����λkm/h
    BYTE  byBigCarSignSpeed;	//�󳵱�־�޸��٣���λkm/h���½��棩
    BYTE  byBigCarSpeedLimit;	//���޸���ֵ����λkm/h���½��棩
    BYTE  byBigCarSignLowSpeed;	//�󳵱�־�޵��٣���λkm/h
    BYTE  byBigCarLowSpeedLimit;	//���޵���ֵ����λkm/h
    BYTE  bySnapTimes;	//����ץ������1~3
    BYTE  byDriveLineSnapTime;// ѹ��ץ������ 1~3
    BYTE  byHighSpeedSnapTime;// ������ץ������1~3
    BYTE  byLowSpeedSnapTime;// ������ץ������1~3
    BYTE  byBanSnapTime;// Υ������ץ������  1~3
    BYTE  byReverseSnapTime;//����ץ������  1~3
    BYTE  byRelatedDriveWay;                //���������ţ�����ƥ�䳵����
    BYTE  byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-�����·
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ����������������������byRelatedDriveWay��Ӧ��ȷ������Ψһ�ԡ�
    BYTE  byRelaLaneDirectionType;
    BYTE  byRes1[29];
    //Ŀǰ��ʹ�õ�һ�������ģ��Ժ���ܻ���չΪ�೵���ֱ�����
    //����, ��λ��ʾ,0-������,1-���òο� ITC_VIOLATION_DETECT_TYPE
    DWORD  dwVioDetectType;
    DWORD  dwRelatedIOOut;  //������IO�����(����ͬʱ�������)����λ��ʾIO����ڣ���0λ��ʾIO�����1���Դ����ƣ�0-��������1-����
    NET_ITC_LINE struTrigLine; //�����ߣ�Ŀǰ��ʹ�õ�һ�������ģ��Ժ���ܻ���չΪ�೵���ֱ�����
    NET_ITC_LINE struLineLeft;				//�󳵵���
    NET_ITC_POLYGON struPlateRecog;       //��ʶ����
    NET_ITC_LANE_LOGIC_PARAM struLane;   //�������ԣ���byUseageType��byCarDriveDirect
    NET_ITC_INTERVAL_PARAM struInterval;//ץ�ļ������20byte��
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;


typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;	//ʶ��ĳ�������1-6
    BYTE byCapType;		//ץ�����ͣ�0-��ǡ��ˣ�Ĭ�ϣ���1-��
    BYTE byCapMode;	//ץ�ķ�ʽ��0-��Ƶ��֡��1-���ץ�ģ�2-���ģʽ��
    BYTE bySecneMode;	//����ģʽ��0-�����·��Ĭ�ϣ���1-С�����ڣ�2-���ٹ�·
    BYTE bySpeedMode;  //����ģʽ��0-�޲��٣�1-�״���٣�2-��Ƶ����
    BYTE byLineRuleEffect; //������������Ч��,ÿһλ���һ��������,0-��Ч;1-��Ч��bit0-�󴥷���;bit1-�Ҵ�����;bit2-��Ƶ�������
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;	//�󴥷���(һ����ֱ��)
    NET_ITC_LINE struRigtTrigLine;	//�Ҵ�����(һ����ֱ��)
    NET_ITC_LINE struLaneBoundaryLine;		//�����߽��ߣ����ұ߳������ҳ����ߣ�
    NET_ITC_POLYGON struDetectArea;	//��Ƶ�������
    NET_DVR_GEOGLOCATION struGeogLocation; //����λ�ã�Ĭ���㽭ʡ������ʱ��
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //����������
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;	//��ʶ����
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;


typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;
    BYTE  bySceneMode;//����ģʽ 0-���ٹ�· 1-���е�·
	/*ץ������
	bit0-����,bit1-��ռ��,bit2-ѹӲ·��
	*/
    WORD  wExpressWayCapType;//���ٹ�·
	/*ץ������
	bit0-����,bit1-��ռ��,bit2-ռ��ר�ó���
	*/
    WORD  wUrbanRoadCapType;//���е�·
    BYTE  byCapNum;//ץ������ [2,3]
    BYTE  byRecordEnable;//Υ��¼��ʹ�� 0-�رգ�1-����
    DWORD dwPreRecordTime;//¼��Ԥ¼ʱ��(s)
    DWORD dwOverRecordTime;//¼��ʱʱ��(s)
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM,*LPNET_ITC_POST_MOBILE_PARAM;


typedef union tagNET_ITC_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1070];			//����
    NET_ITC_POST_IOSPEED_PARAM      struIOSpeed;    //�����ڣ�IO���ٲ���
    NET_ITC_POST_SINGLEIO_PARAM     struSingleIO;   //�����ڣ���IO����
    NET_ITC_POST_RS485_PARAM        struPostRs485;  //�����ڣ�RS485����������
    NET_ITC_POST_RS485_RADAR_PARAM  struPostRadar;  //�����ڣ�RS485�״����
    NET_ITC_POST_VTCOIL_PARAM       struVtCoil;     //�����ڣ�������Ȧ����
    NET_ITC_POST_HVT_PARAM          struHvt;	    //�����ڣ����п��ڲ���
    NET_ITC_EPOLICE_IOTL_PARAM      struIOTL;		//���羯��IO���̵Ʋ���
    NET_ITC_EPOLICE_RS485_PARAM     struEpoliceRs485; //���羯��RS485��������������
    NET_ITC_EPOLICE_RS485_PARAM     struPERs485;	//����ʽ�羯��RS485��������������
    NET_ITC_POST_MPR_PARAM          struPostMpr;    //��֡��ⴥ����MPR��
    NET_DVR_VIA_VTCOIL_PARAM        struViaVtCoil;  //(VIA)��Ƶ������
    NET_ITC_POST_IMT_PARAM          struPostImt;//�ǻۼ�ش���
    NET_ITC_POST_PRS_PARAM          struPostPrs;//��Ƶ��ⴥ��
    NET_IPC_POST_HVT_PARAM          struIpcHvt;//(IPC) ���п��ڲ���
    NET_ITC_POST_HVT_PARAM_V50      struHvtV50;  /*�����ڣ����п��ڲ���V50*/
	NET_ITC_POST_MOBILE_PARAM       struPostMobile;// �ƶ���ͨ����ģʽ
}NET_ITC_TRIGGER_PARAM_UNION, *LPNET_ITC_TRIGGER_PARAM_UNION;

//������������ṹ
typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;	//�Ƿ����øô���ģʽ��0-��1-��
    BYTE  byRes1[3];
    DWORD dwTriggerType; //�������ͣ����ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //��������
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

//��������ṹ
typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;			//�ṹ����
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //������������
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;

//����IO�����źŵƲ���
typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //��ͨ�Ƶ�������,0-��ת��,1-ֱ�е�,2-��ת��
    BYTE byRelatedIO; //������IO�ں�
    BYTE byRedLightState; //��Ƶ�ƽ״̬��0-�ߵ�ƽ��ƣ�1-�͵�ƽ���
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO�����źŵƲ���
typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //����IO�����źŵƲ���
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

//����485�����źŵƲ���
typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //��ͨ�Ƶ������ͣ�0-��ת�ƣ�1-ֱ�еƣ�2-��ת��
    BYTE byRelatedLightChan; //�����ĺ��̵Ƽ����ͨ����
    BYTE byInputLight;	//������źŵ����ͣ�0-�Ӻ�ƣ�1-���̵�
    BYTE byRelatedYLightChan; //�����ĻƵƼ����ͨ����
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

//485�����źŵƲ���
typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //����485�����źŵƲ���
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

//������Ƶ��⽻ͨ�źŵƲ���ṹ
typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //��ͨ�Ƹ���
    BYTE byStraightLight; //�Ƿ���ֱ�б�־�ƣ�0-�� ��1-��
    BYTE byLeftLight; //�Ƿ�����ת��־�ƣ�0-��1-��
    BYTE byRightLight; //�Ƿ�����ת��־�ƣ�0-��1-��
    BYTE byRedLight;//�Ƿ��к�ƣ�0-��1-��
    BYTE byGreenLight; //�Ƿ����̵ƣ�0-��1-��
    BYTE byYellowLight; //�Ƿ��лƵƣ�0-��1-��
    BYTE byYellowLightTime;//ȡֵ��Χ��0��10s����ITC3.7Ver��
    NET_POS_PARAM struLightRect; //��ͨ������
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//��Ƶ��⽻ͨ�źŵƲ���ṹ(������12�������⣬488�ֽ�)
typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //������Ƶ����źŵƲ���
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//��ͨ�źŵƽ������
typedef union tagNET_ITC_LIGHT_ACCESSPARAM_UNION
{
    DWORD uLen[122];
    NET_ITC_IO_LIGHT_PARAM struIOLight; //IO�����źŵƲ���
    NET_ITC_RS485_LIGHT_PARAM struRS485Light; //485�����źŵƲ���
    NET_ITC_VIDEO_DETECT_LIGHT_PARAM struVideoDelectLight; //��Ƶ����źŵƲ���
}NET_ITC_LIGHT_ACCESSPARAM_UNION, *LPNET_ITC_LIGHT_ACCESSPARAM_UNION;

//��ͨ�źŵƲ���ṹ
typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //��ͨ�źŵƽ���Դ��0-IO���룬1-RS485����
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//�źŵƽ������
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

//Υ�������ͺ궨��
typedef enum _ITC_VIOLATION_DETECT_TYPE_
{
    ITC_VIOLATION_POST = 0x01, //����ץ��
        ITC_VIOLATION_DRIVELINE = 0x02,//ѹ������ץ��
        ITC_VIOLATION_REVERSE = 0x04,//����ץ��
        ITC_VIOLATION_REDLIGHT = 0x08,//�����ץ��
        ITC_VIOLATION_DIRECTION = 0x10,//����������ʻץ��
        ITC_VIOLATION_INTERSECTION_CONGEST = 0x20,//·������ץ��
        ITC_VIOLATION_NONDRIVEWAY = 0x40,  //��ռ��ץ��
        ITC_VIOLATION_CHANGELANE = 0x80, //Υ�����
        ITC_VIOLATION_BAN = 0x100, //Υ������
        ITC_VIOLATION_INTERSECTION_PARK=0x200,//���Խ��
        ITC_VIOLATION_GREEN_PARK=0x400,//�̵�ͣ��
        ITC_VIOLATION_HIGH_SPEED = 0x800, /*����*/
        ITC_VIOLATION_LOW_SPEED = 0x1000, /*����*/
        ITC_VIOLATION_EMERGENCY = 0x2000, /*ռ��Ӧ������*/
        ITC_VIOLATION_TURN_AROUND = 0x8000,/*Υ����ͷ*/
        ITC_VIOLATION_CONGESTION = 0x10000 /*ӵ��*/
}ITC_VIOLATION_DETECT_TYPE;


//Υ�������ṹ
typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //Υ��������, ��λ��ʾ, ���ITC_VIOLATION_DETECT_TYPE ,0-������,1-����
    BYTE byDriveLineSnapTimes; //ѹ������ץ������,2-3
    BYTE byReverseSnapTimes; //����ץ��,2-3
    WORD wStayTime; //��ռ��ͣ��ʱ�䣨��ʱ���ץ�ģ�����λs
    BYTE byNonDriveSnapTimes;//��ռ��ץ������2-3
    BYTE byChangeLaneTimes;//Υ�����ץ������ 2-3
    BYTE bybanTimes;//Υ������ץ������2-3
    BYTE byDriveLineSnapSen;// ѹ��������(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //��2,3��ץ��λ����Сƫ��(Υ���źŵ�ʱ��Ч)����λ�����أ� ������Ľ�
    BYTE bySpeedTimes;//Υ������ץ������2-3(3.8Ver)
    BYTE byTurnAroundEnable;//Υ�µ�ͷʹ�� 0~�ر� 1~����
    BYTE byThirdPlateRecogTime;//��������ʶʱ�� 0~180s
    BYTE byRes1[19];
    WORD wStopLineDis;  //�羯��2��Υ��ͼƬ��ֹͣ�ߵ���̾��룬[0,300]��λ(����)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;

//���������������Ͷ���
typedef enum _ITC_RELA_LANE_DIRECTION_TYPE_
{
    ITC_RELA_LANE_DIRECTION_UNKNOW      = 0,   //����
        ITC_RELA_LANE_EAST_WEST               = 1,    //�Ӷ�����
        ITC_RELA_LANE_WEST_EAST               = 2,    //������
        ITC_RELA_LANE_SOUTH_NORTH            = 3,    //������
        ITC_RELA_LANE_NORTH_SOUTH            = 4,    //�ӱ�����
        ITC_RELA_LANE_EASTSOUTH_WESTNORTH  = 5,    //�Ӷ���������
        ITC_RELA_LANE_WESTNORTH_EASTSOUTH  = 6,    //����������
        ITC_RELA_LANE_EASTNORTH_WESTSOUTH  = 7,    //�Ӷ���������
        ITC_RELA_LANE_WESTSOUTH_EASTNORTH  = 8     //�������򶫱�
} ITC_RELA_LANE_DIRECTION_TYPE;


//������;���Ͷ���
typedef enum _ITC_LANE_USEAGE_TYPE_
{
    ITC_LANE_USEAGE_UNKNOW     =  0,   //δ֪
        ITC_LANE_CARRIAGEWAY  = 1,  //���
        ITC_LANE_BUS      = 2,  //������ר�õ�
        ITC_LANE_FAST  = 3,  //�쳵��
        ITC_LANE_SLOW  = 4,  //���
        ITC_LANE_MOTOR     = 5,   //Ħ�г���
        ITC_LANE_NONMOTOR  = 6,  //�ǻ���
        ITC_LANE_REVERSE_LANE = 7, //���򳵵�
        ITC_LANE_BAN_TRUCKS  = 8, // ��ֹ��������
        ITC_LANE_MIX = 9, //��ϳ���
        ITC_LANE_EMERGENCY = 10, //Ӧ������
        ITC_LANE_BAN_LEFT  = 11, // ���󳵵�
        ITC_LANE_BAN_RIGHT  = 12 // ���ҳ���
}ITC_LANE_USEAGE_TYPE;

//�����������Ͷ���
typedef enum _ITC_LANE_DIRECTION_TYPE_
{
    ITC_LANE_DIRECTION_UNKNOW     =  0,   //δ֪
        ITC_LANE_LEFT      = 1,  //��ת
        ITC_LANE_STRAIGHT  = 2,  //ֱ��
        ITC_LANE_LEFT_STRAIGHT = 3, //��ת+ֱ��
        ITC_LANE_RIGHT  = 4,  //��ת
        ITC_LANE_LEFT_RIGHT = 5, //��ת+��ת
        ITC_LANE_RIGHT_STRAIGHT = 6, //��ת+ֱ��
        ITC_LANE_LEFT_RIGHT_STRAIGHT = 7, //��ת+��ת+ֱ��
        ITC_LANE_LEFT_WAIT  =  9,  //��ת����
        ITC_LANE_STRAIGHT_WAIT = 10, //ֱ�д���
        ITC_LANE_FORWARD = 11, //������ʻ
        ITC_LANE_BACKWARD = 12, //������ʻ
        ITC_LANE_BOTHWAY = 13, //˫����ʻ
        ITC_LANE_STRAIGHT_WAIT_RIGHT = 14 //ֱ�д��� + ��ת
}ITC_LANE_DIRECTION_TYPE;

//������ʻ�������Ͷ���
typedef enum _ITC_LANE_CAR_DRIVE_DIRECT_
{
    ITC_LANE_DRIVE_UNKNOW		= 0, //δ֪
        ITC_LANE_DRIVE_UP_TO_DOWN	= 1, //����������ʻ(����)
        ITC_LANE_DRIVE_DOWN_TO_UP	= 2  //����������ʻ(����)
}ITC_LANE_CAR_DRIVE_DIRECT;

//�����Ͷ���
typedef enum _ITC_LINE_TYPE_
{
    ITC_LINT_UNKNOW     =  0,   //δ֪
        ITC_LINE_WHITE      = 1,  //������İ�ʵ��
        ITC_LINE_STOP       = 2, //����ֹͣ��
        ITC_LINE_SINGLE_YELLOW = 3, //������
        ITC_LINE_DOUBLE_YELLOW = 4, //˫����
        ITC_LINE_GUARD_RAIL = 5, //���������л���
        ITC_LINE_NO_CROSS = 6, //�����޷���Խ�ĳ�����
        ITC_LINE_DOTTED = 7 //����
}ITC_LINE_TYPE;

//Υ�����߲���ṹ
typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //�����߲���
    NET_ITC_LINE  struStopLine; //ֹͣ�߲���
    NET_ITC_LINE  struRedLightLine; //����ƴ����߲���
    NET_ITC_LINE  struCancelLine; //ֱ�д���λ��ȡ����
    NET_ITC_LINE struWaitLine; //������ֹͣ�߲���
    NET_ITC_LINE struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

//����������Ƶ�羯��������ṹ
typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //�����ĳ�����
    BYTE bySensitivity; //��Ȧ�����ȣ�[1,100]
    BYTE byEnableRadar;//�����״����0-�����ã�1-����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //��������
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //Υ�������
    NET_ITC_VIOLATION_DETECT_LINE struLine; //Υ������
    NET_ITC_POLYGON struPlateRecog; //��ʶ�������
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE byCarSpeedLimit; //��������ֵ����λkm/h
    BYTE byCarSignSpeed;//��־���٣���λkm/h
    BYTE bySnapPicPreRecord; //ץ��ͼƬԤ¼ʱ��㣻0-Ĭ��ֵ���ڶ���ͼƬ����1-��һ��ͼƬ��2-�ڶ���ͼƬ��3-������ͼƬ
    BYTE byRes[56];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//��Ƶ�羯��������ṹ
typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;	//�Ƿ����ã�0-�����ã�1-����
    BYTE byLaneNum; //ʶ��ĳ�������
    BYTE byLogicJudge;//�����Υ���ж��߼�������ֵΪ��0-������1-������
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //��ͨ�źŵƲ���
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //����������
    NET_ITC_LINE  struLaneBoundaryLine; //�����߽��ߣ����ұ߳����ı߽��ߣ�
    NET_ITC_LINE  struLeftLine; //��ת��ֽ���
    NET_ITC_LINE  struRightLine; //��ת��ֽ���
    NET_ITC_LINE  struTopZebraLine; //�ϲ�������
    NET_ITC_LINE  struBotZebraLine; //�²�������
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;

typedef union tagNET_ITC_VIDEO_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1150];
    NET_ITC_VIDEO_EPOLICE_PARAM struVideoEP; //��Ƶ�羯����
}NET_ITC_VIDEO_TRIGGER_PARAM_UNION, *LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION;

typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //����ģʽ�����ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //����ģʽ����
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;			//�ṹ����
    BYTE   byEnableTrigIODetect; //��������IO״̬��⣬1-�ǣ�0-��
    BYTE   byEnableFlashOutDetect; //����ͬ�����״̬��⣬1-�ǣ�0-��
    BYTE   byEnableRS485Detect; //����RS485����״̬��⣬1-�ǣ�0-��
    BYTE   byEnableTrafficLightDetect;//������ͨ��״̬��⣬1-�ǣ�0-��
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;

typedef enum _ITC_STATUS_DETECT_TYPE_
{
    ITC_STATUS_DETECT_NULL = 0,		//δ֪
        ITC_STATUS_DETECT_TRIGGERIO,	//����IO
        ITC_STATUS_DETECT_FLASHOUT,     //ͬ�����
        ITC_STATUS_DETECT_RS485, //RS485
        ITC_STATUS_DETECT_TRIGGERTYPE, //�������ͣ�������
        ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //��ͨ�ƣ������ɫ��
        ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //��ͨ�ƣ����ת��
}ITC_STATUS_DETECT_TYPE;

typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //����IO��
    BYTE byRes[40];
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //ͬ�������
    BYTE byRes[40];
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //485����У����0-��Ч,1-��Ч, bySerialIndex[0]��ʾ��ȷ��ͷ, bySerialIndex[1]��ʾ��ȷ��β
    BYTE byRes[40];
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //��������ֵ
    BYTE byRes[47];
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

//��Ƶ�羯
typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//��ת�ƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byRightLight; //��ת�ƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byStraightLight; //ֱ�еƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

//����Ƶ�羯
typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;

typedef union tagNET_ITC_STATUS_UNION
{
    BYTE   uLen[48];			//����
    NET_ITC_TRIGGERIO_INFO struTrigIO; //����IO�ں�
    NET_ITC_FLASHOUT_INFO struFlashOut; //ͬ�����
    NET_ITC_SERIAL_CHECKINFO struSerial;  //����
    NET_ITC_TRIGGERTYPE_INFO struTrigType; //�������ͣ�������
    NET_ITC_TRAFFIC_LIGHT_COLOR struTrafficLightColor; //��ͨ�ƣ������ɫ����Ӧ����ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    NET_ITC_TRAFFIC_LIGHT_TURN struTrafficLightTurn;//��ͨ�ƣ����ת�򣩶�Ӧ����ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
}NET_ITC_STATUS_UNION, *LPNET_ITC_STATUS_UNION;

typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//״̬������ͣ����ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //״̬�����
    DWORD dwHoldTime; //��������ʱ�䣨����������λ��ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //�������ȼ���0-һ�ȼ����ߣ���1-���ȼ����У���2-��ȼ����ͣ�
    BYTE  byAlarmInfoType; //�ϴ�������Ϣ���ͣ�ץ�Ļ�֧�֣���0-�ϱ�����Ϣ��NET_DVR_PLATE_RESULT����1-�±�����Ϣ(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--����NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO, 1--�豸֧��NET_DVR_ALARMINFO_V40�򷵻�NET_DVR_ALARMINFO_V40����֧���򷵻�NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR�ϴ�������Ϣ�ص��ṹ��汾�� 0-COMM_ALARM_DEVICE�� 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD�����ϴ����ͣ�0-�ϴ�������NET_DVR_VQD_DIAGNOSE_INFO��1-�ϴ�����NET_DVR_VQD_ALARM
    //1-��ʾ������ⱨ����չ(INTER_FACE_DETECTION),0-��ʾԭ��֧�ֽṹ(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    BYTE  bySupport; //Bit0- ��ʾ���������Ƿ��ϴ�ͼƬ: 0-�ϴ���1-���ϴ�
    //����������
    //bit0-���Ƽ�⣨IPC�� ��0-����1-��
    //bit1-����ͳ�ƣ�IPC��  ��0-����1-��
    //bit2-�ȶ�ͼͳ�ƣ�IPC�� ��0-����1-��
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;	//������� �� (�ϴ����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�dwTaskNo��Ӧ ͬʱ �·�����ṹ NET_DVR_VEHICLE_RECOG_COND�е��ֶ�dwTaskNo��Ӧ)
    BYTE  byRes1[5];
    BYTE  byCustomCtrl;//Bit0- ��ʾ֧�ָ���ʻ������ͼ�ϴ�: 0-���ϴ�,1-�ϴ�,(ע��ֻ�ڹ�˾�ڲ�8600/8200��ƽ̨����)
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //��Ƶ����ģʽ���ͣ����ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

//�����ṹ
typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;//ͨ����
    BYTE	byWorkMode;  // 0-FTP1(��FTP)��1-FTP2(��FTP)
    BYTE	byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;

//���ýṹ
typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE			    byEnable;			/*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE 				byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    WORD				wFTPPort;			/*�˿�*/
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME];//��������ַ������
            BYTE			byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;/*IP��ַ*/		//IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64
    BYTE				szUserName[NAME_LEN];		/*�û���*/
    BYTE				szPassWORD[PASSWD_LEN];		/*����*/
    BYTE	            byRes4;  // 0-FTP1(��FTP)��1-FTP2(��FTP)
                                 BYTE				byDirLevel;	/*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,
                                                                1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼,
                                 3 = ʹ��3��Ŀ¼,4=ʹ��4��Ŀ¼*/
                                 BYTE 				byIsFilterCarPic;/*����Сͼ�Ƿ��ϴ���0-�ϴ�,1-���ϴ�*/
                                 BYTE   		     	byUploadDataType;//0-ȫ����1-���ڣ�2-Υ�� (��FTPʱĬ��ѡ��ȫ����˫FTPʱ֧�ֿ��ڣ�Υ�µ�ѡ��)
                                 NET_DVR_PICTURE_NAME 	struPicNameRule;/* ͼƬ������� */
                                                                        BYTE				byTopDirMode; /*һ��Ŀ¼, 0x1 = ʹ���豸��,
                                                                                                          0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                          0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),
                                                                                                          0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE				bySubDirMode; /*����Ŀ¼, 0x1 =ʹ���豸��,
                                                                                                          0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                          0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),
                                                                                                          0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE				byThreeDirMode; /*��Ŀ¼, 0x1 = ʹ���豸��,
                                                                                                            0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                            0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),
                                                                                                            0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE				byFourDirMode; /*�ļ�Ŀ¼, 0x1 =ʹ���豸��,
                                                                                                           0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                           0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),
                                                                                                           0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        /*ͼƬ�����Զ��� ��PICNAME_ITEM_CUSTOM ʱ ��Ч*/
                                                                        BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver ��Ч)
                                                                        BYTE			    szTopCustomDir[MAX_CUSTOMDIR_LEN]; /*�Զ���һ��Ŀ¼*/
                                                                        BYTE				szSubCustomDir[MAX_CUSTOMDIR_LEN];/*�Զ������Ŀ¼*/
                                                                        BYTE				szThreeCustomDir[MAX_CUSTOMDIR_LEN];	/*�Զ�����Ŀ¼*/
                                                                        BYTE				szFourCustomDir[MAX_CUSTOMDIR_LEN];	/*�Զ����ļ�Ŀ¼*/
                                                                        BYTE 				byRes3[900]; //����12����չԤ�� ֧��͸��
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//��[0,179]
    BYTE byMinute;//��[0,59]
    BYTE bySec;//��[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//��[0,179]
    BYTE byMinute;//��[0,59]
    BYTE bySec;//��[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD 	dwSize;
    BYTE byGpsDataMode;//GPS��ݻ�ȡ 0-�Զ���1-�ֶ�
    BYTE byLongitudeType;//���� 0-������1-����
    BYTE byLatitudeType;//γ�� 0-��γ��1-��γ
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM	struLatitude;	 /*γ��*/
    NET_DVR_LONGITUDE_PARAM	struLongitude; /*����*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG,*LPNET_DVR_GPS_DATACFG;

typedef enum _VCA_DATABASE_TYPE_
{
    DATABASE_NULL = 0, //δ֪
        DATABASE_SNAP,    //ץ����ݿ�
        DATABASE_FACE    //������ݿ�
}VCA_DATABASE_TYPE;

typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //��ݿ�ID���豸��ɣ����ʱ��Ч���޸ĺ�ɾ��ʱ��Ч��
    DWORD dwDataBaseType; //��ݿ����ͣ���VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //��ݿ����
    BYTE byAttribute[64]; //��ݿ�����
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //��ݿ����ͣ����VCA_DATABASE_TYPE
    BYTE byRes[12]; //����
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //��ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //��ݿ�ID
    BYTE byRes[64]; //����
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    BYTE byRes[12]; //����
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_DVR_TIME struSnapTime;  //ץ��ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ��ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ���
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;

typedef union tagNET_VCA_DELETE_SNAPRECORD_COND_UNION
{
    NET_VCA_INQUIRE_SNAPDB_COND struAttribute;  //��Ա��Ϣ������ɾ��
    DWORD dwRecordID; //��¼ID������ɾ��
}NET_VCA_DELETE_SNAPRECORD_COND_UNION, *LPNET_VCA_DELETE_SNAPRECORD_COND_UNION;

typedef enum _VCA_DELETE_RECORD_TYPE_
{
    DELETE_RECORD_SINGLE = 0, //����ɾ��
        DELETE_RECORD_BATCH    //����ɾ��
}VCA_DELETE_RECORD_TYPE;

typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //ɾ���¼����
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //ɾ�����
    BYTE  byRes[40]; //����
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;

typedef enum _VCA_SEARCH_DATABASE_TYPE_
{
    VCA_NORMAL_SEARCH_DATABASE  = 0x00000000,   //��ͨ����
        VCA_ADVANCE_SEARCH_DATABASE  = 0x00000001  //�߼�����
}VCA_SEARCH_DATABASE_TYPE;

typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //��ݿ����ͣ����VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //��ݿ�ID
    DWORD dwFacePicID; //����ͼƬID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;

typedef union tagNET_VCA_SEARCH_DATABASE_COND_UNION
{
    DWORD uLen[25];
    NET_VCA_REGISTER_PIC struNormalFind; //��ͨ����
    NET_VCA_ADVANCE_SEARCH_DATABASE_COND struAdvanceFind; //�߼�����
}NET_VCA_SEARCH_DATABASE_COND_UNION, *LPNET_VCA_SEARCH_DATABASE_COND_UNION;

typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //�������ͣ����VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //��������
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{
    DWORD dwChannel; //ͨ��
    DWORD dwDataBaseID; //��ݿ�ID
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //��������
    DWORD dwMaxSearchNum; //����������
    WORD wThreshold;  //��ֵ��0-100
    BYTE  byRes[78]; //����
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_DVR_TIME struSnapTime;//ץ��ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    float fSimilarity; //���ƶȣ�[0.001,1]
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ��ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ���
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{
    DWORD dwSize; //�ṹ���С
    DWORD dwRecordID; //��¼ID�����ʱ��Ч���޸�ʱ��Ч
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    NET_VCA_REGISTER_PIC struRegisterPic;  //��ԱͼƬ��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    BYTE  byRes[32]; //����
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{
    DWORD dwSize; //�ṹ���С
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    DWORD dwImageLen;  //ͼ����ݳ���
    BYTE  byRes[80];  //����
    BYTE *pImage;    //ͼ�����
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ��ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ���
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    float fSimilarity; //���ƶȣ�[0.001,1]
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ��ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ���
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{
    DWORD dwDataBaseID; //��ݿ�ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ
    BYTE byRes[80];  //����
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;

typedef union tagNET_VCA_DELETE_RECORD_COND_UNION
{
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ������ɾ��
    DWORD dwRecordID; //��¼ID������ɾ��
}NET_VCA_DELETE_RECORD_COND_UNION, *LPNET_VCA_DELETE_RECORD_COND_UNION;

typedef struct tagNET_VCA_DELETE_RECORD_COND
{
    VCA_DELETE_RECORD_TYPE dwDeleteType; //ɾ���¼����
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //ɾ�����
    BYTE  byRes[40]; //����
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{
    DWORD dwDataBaseID; //��ݿ�ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //��������
    DWORD dwMaxSearchNum; //����������
    WORD wThreshold;  //��ֵ��0-100
    BYTE  byRes[78]; //����
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //��ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    BYTE byRes[64]; //����
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //��ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //��ݿ�ID
    DWORD dwRecordID; //��¼ID
    DWORD dwPicLen; //ͼƬ����
    BYTE byRes[64]; //����
    BYTE *pPicBuffer; //ͼƬ���ָ��
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    WORD wDealyTime; //�ӳ�ʱ�䣬��λs
    BYTE  byRes[30];
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byRes[16];
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byIndex;  //���߱�����ţ�1-8
    BYTE  byRes[15];
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;

#define MAX_AUX_ALARM_NUM 8 //���������
#define MAX_WIRELESS_ALARM_NUM 8 //������߱�������
typedef enum _IPC_AUX_ALARM_TYPE_
{
    IPC_AUXALARM_UNKNOW = 0, //δ֪
        IPC_AUXALARM_PIR = 1, //PIR����
        IPC_AUXALARM_WIRELESS = 2,   //���߱���
        IPC_AUXALARM_CALLHELP = 3  //���ȱ���
}IPC_AUX_ALARM_TYPE;

typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;//ʹ��
    BYTE	byRes1[3];
    DWORD	dwDecibelLimit; //�ֱ��澯��ֵ
    NET_DVR_HANDLEEXCEPTION_V30	struHandleException;  //�쳣���?ʽ
    BYTE	byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG,*LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;//ʹ��
    BYTE	byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30	struHandleException;  //�쳣���?ʽ
    BYTE	byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG,*LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];	/* ������� */
    BYTE byAlarmHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];	/* ������� */
    BYTE byAlarmHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

//���ȱ���
typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];	/* ������� */
    BYTE byAlarmHandle;	        /* �Ƿ��� 0-������ 1-����*/
    BYTE byID; //���߱���ID��1-8
    BYTE byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;	/* ���?ʽ */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //�������߱�������
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;

typedef union tagNET_IPC_AUX_ALARMCFG_UNION
{
    DWORD uLen[472];
    NET_IPC_PIR_ALARMCFG_EX struPIRAlarm; //PIR��������
    NET_IPC_WIRELESS_ALARMCFG struWirelessAlarm; //���߱�������
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //���ȱ�������
}NET_IPC_AUX_ALARMCFG_UNION, *LPNET_IPC_AUX_ALARMCFG_UNION;

typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;	   //���������ͣ����IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //��������
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //��������
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;

typedef union tagNET_IPC_AUXALARM_UPLOAD_UNION
{
    DWORD uLen[66];
    NET_IPC_PIR_ALARMCFG struPIRAlarm; //PIR��������
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm; //���߱�������
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //���ȱ�������
}NET_IPC_AUXALARM_UPLOAD_UNION, *LPNET_IPC_AUXALARM_UPLOAD_UNION;

typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE byAlarmType;	   //���������ͣ����IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //����������
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;         // �ṹ���С
    BYTE   byCorrectMode;   //У��ģʽ��0-���У��1-оƬУ��
    BYTE   byMountType;     //��װ���ͣ�0-��1-���棬2-ǽ��
    /*
    0-ģʽ1������+ȫ��+3PTZ (��ԭ�з�ʵʱģʽһ��)��
    1-ģʽ2������+4PTZ(��ԭ��ʵʱģʽһ��)��
    2-ģʽ3������(��)+����(��)+3PTZ��
    3-ģʽ4��ȫ��չ��(������+������)��
    4-ģʽ5��4PTZ��
    5-ģʽ6�����ۣ�
    */
    BYTE   byRealTimeOutput;  //ʵʱ�����0 -�����ã�1- ����
    BYTE   byRes[61];
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZCommand; //PTZ��������
    NET_VCA_POINT struVcaPoint; //Ԥ����������
    DWORD dwSpeed; //���Ƶ��ٶȣ�ȡֵ��Χ[0,7]
    DWORD dwStop; //ֹͣ������ʼ������0-��ʼ��1-ֹͣ
    BYTE  byRes[32];
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZPresetCmd; //Ԥ�õ��������
    NET_VCA_POINT struVcaPoint; //Ԥ����������
    DWORD dwPresetIndex; //Ԥ�õ����ţ���1��ʼ�������֧��255��Ԥ�õ�
    WORD  wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZCruiseCmd; //Ѳ����������
    NET_VCA_POINT struVcaPoint; //Ԥ����������
    WORD wCruiseRoute; //Ѳ��·�������֧��32��·������Ŵ�1��ʼ��
    WORD wCruisePoint; //Ѳ���㣬���֧��32���㣨��Ŵ�1��ʼ��
    WORD wInput; //��ͬѲ������ʱ��ֵ��ͬ��Ԥ�õ�(���255)��ʱ��(���255)���ٶ�(���40)
    WORD wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //����WPS��0-��1-��
    BYTE byRes[31];
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN��
    BYTE byRes[32];
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS���ӷ�ʽ��0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN��(WPS���ӷ�ʽΪAP PINʱ��Ч)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS���ӷ�ʽΪAP PINʱ��Ч)
    BYTE byRes[32];
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD	dwSize;		// �ṹ���С
    BYTE	byJointed;		//  0 û�й��� 1 �Ѿ�����
    BYTE	byRes1[3];		// �����ֽ�
    NET_DVR_IPADDR	struIP;	// ��������������IP��ַ
    WORD	wPort;			// �������������Ķ˿ں�
    WORD	wChannel;		// �������������Ľ���ͨ����
    BYTE	sDeviceName[NAME_LEN];	//���������������豸���
    BYTE	sChanName[NAME_LEN];	//�������������Ľ���ͨ�����
    BYTE	byRes2[32];		// �����ֽ�
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD	dwSize;
    NET_DVR_IPADDR	struCuIp; //CU��IP��ַ
    WORD	wPort;/*CU�˿�*/
    BYTE	bySourceIndex;	//�ź�Դͨ����
    BYTE	byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

#define DVCS_DEVICEID_LEN   16
//2012-03-13ͼƬ����ע����Ϣ�ص�
typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD	dwUserID;
    BYTE    sDeviceID[DVCS_DEVICEID_LEN];
    LONG	nPicViewHandle; //���Ծ��
    WORD	wSignalIndex;	//�ź�Դ����
    WORD	wHeadLen;		//�ļ�ͷ���� ˽�е������ļ�ͷ����40
    BYTE	byHeadBuf[100]; //�ļ�ͷ
    BYTE	byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

#define DEVICEID_LEN	  32

typedef struct tagNET_DVR_DEVICEID_INFO
{
    DWORD		dwSize;
    DWORD		dwDeviceIndex;	//�豸���
    BYTE		byWallNo;	 //ǽ�ţ���1��ʼ
    BYTE	    byRes1[27];
    DWORD		dwChan;		//ͨ����
    DWORD		dwInputSignalIndex; //�ź�Դ������ʽ����������ʹ��
    BYTE		byRes2[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;


typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;				 //�Ƿ�����DHCP 0xff-��Ч 0-������ 1-����
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // �豸IP��ַ
    NET_DVR_IPADDR  struSubnetMask;  // �豸��������
    NET_DVR_IPADDR  struGateway;     // �豸���
    WORD	wDevPort;				 // �豸�˿ں�
    BYTE	byMACAddr[MACADDR_LEN];   // MAC ��ַ(ֻ�ܻ�ȡ)
    BYTE	byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD	dwSize;
    BYTE	byValid;				//0-��Ч 1-��Ч
    BYTE	byRes1[3];
    BYTE	sChanName[NAME_LEN];    //ͨ�����
    NET_DVR_COLOR struVideoColor;   //�ź�Դ��ɫ
    WORD	wResolutionX;		//��ǰ�ֱ���---��
    WORD	wResolutionY;		//��ǰ�ֱ���---��
    BYTE   byRes2[40];
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

//�������豸��Ϣ
typedef struct tagNET_DVR_CODEDEV_INFO
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];/*�豸ͨ����Ϣ*/
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

//�������豸��Ϣ
typedef struct tagNET_DVR_DECODEDEV_INFO
{
    BYTE	byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

//�����ź�Դ��Ϣ
typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD	dwSize;
    BYTE	byDevName[NAME_LEN/*32*/];//�����ź�Դ���
    NET_DVR_PU_STREAM_CFG struPuStream;
    BYTE    byValid;			//�Ƿ���Ч��0-��Ч��ɾ��ʱ��Ϊ0  1-��Ч����Ӻ��޸�ʱ��Ϊ1/
    BYTE 	byRes1[3];	//����
    BYTE	sGroupName[NAME_LEN/*32*/];//�����ź�Դ����������������ź�Դ����������������
    WORD	wResolutionX;		//��ǰ�ֱ���---��
    WORD	wResolutionY;		//��ǰ�ֱ���---��
    BYTE	byRes2[24];
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE	byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;

typedef union tagNET_DVR_DIFFDEV_INFO
{
    NET_DVR_CODEDEV_INFO struCodeDevInfo;		//�����豸��Ϣ
    NET_DVR_DECODEDEV_INFO struDecodeDevInfo;	//�����豸��Ϣ
    NET_DVR_NETSIGNALDEV_INFO struNetSignalInfo;	//�����ź�Դ��Ϣ
} NET_DVR_DIFFDEV_INFO, *LPNET_DVR_DIFFDEV_INFO;

/*ע���豸��Ϣ*/
typedef enum tagNET_DVCS_DEVICE_TYPE
{
    NET_DVR_BNC_PROC = 1,                       /* BNC������ */
        NET_DVR_RGB_PROC,                       /* RGB������ */
        NET_DVR_STP_PROC,                       /* ת�봦���� */
        NET_DVR_DISP_PROC,                      /* ��ʾ������ */
        NET_DVR_NETSIGNAL,						//�����ź�Դ
        NET_DVR_SDI_PROC,                       //SDI������
        NET_DVR_BIW_PROC,                       //8·BNC������
        NET_DVR_DON_PROC,                        //��ʾ������
        NET_DVR_TVI_PROC,                       //TVI������
        NET_DVR_DI2_PROC                        //2·DVI������
}NET_DVCS_DEVICE_TYPE;

typedef struct  tagNET_DVR_SINGLE_DEV_INFO
{
    DWORD	dwSize;
    DWORD	dwSoftVersion;			/*�豸����汾��(ֻ�ܻ�ȡ) ���8λΪ���汾�ţ��θ�8λΪ�ΰ汾�ţ���16λΪ�޸��汾��*/
    DWORD	dwSoftwareBuildDate; 		//�汾��������Build, 0xYYYYMMDD
    BYTE	byUseInSys;				/*�Ƿ���ϵͳ��ʹ��*/
    BYTE	byDevStatus;			/*�豸��ǰ״̬��0-���ߣ�1-����(ֻ�ܻ�ȡ)*/
    BYTE	byDeviceType;			/*�豸����(ֻ�ܻ�ȡ)  ��DEVICE_TYPE*/
    BYTE	byRes1[17];
    BYTE	sDevName[NAME_LEN];     /*�豸���*/
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; /*�豸�������*/
    BYTE	sSerialNumber[SERIALNO_LEN];	/*�豸���к�*/
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;		/*�豸��Ϣ*/
    DWORD	dwDeviceIndex;//�豸��ţ�ÿ���豸Ψһȷ��
    BYTE	byRes2[48];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD		dwSize;
    DWORD		dwDevNums;//�豸���صķֲ�ʽ���豸����
    BYTE  		*pBuffer;
    BYTE		byRes1[3];
    DWORD 		dwBufLen;//�����ָ�볤�ȣ��������
    BYTE		byRes2[64];
} NET_DVR_DEVLIST,*LPNET_DVR_DEVLIST;

typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;          /*�Ƿ���ϵͳ��ʹ��*/
    BYTE   byDeviceType;      /*�豸����(ֻ�ܻ�ȡ)*/
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN]; /*�豸���*/
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO,*LPNET_DVR_DEV_BASE_INFO;

/*����������Ϣ*/
typedef  struct tagNET_DVR_NETPARAM
{
    DWORD dwSize;
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET];//��̫���
    BYTE   byRes[64];
} NET_DVR_NETPARAM, *LPNET_DVR_NETPARAM;

// ����Ļ���豸��ϵ(16���ֽ�)
typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD	dwSize;
    WORD	wScreenID;		// ��ĻID��, ID�Ŵ�1��ʼ
    BYTE	byWallNo;		// ����ǽ��
    BYTE	byRes1;			// ����1
    DWORD	dwDeviceIndex;	// ����豸���
    BYTE	byRes2[16];		// ����2
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

// ��Ļ����
typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//�Ƿ���ʾ���֣�1-��ʾ���֣�0-����ʾ����
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD		dwSize;
    BYTE		byWallNo;	//����ǽ�ţ���1��ʼ
    BYTE		byRes[11];
    DWORD		dwScreenNums;//�豸���ص�ӳ����ʾ������
    BYTE  		*pBuffer;
    DWORD 		dwBufLen;//�����ָ�볤�ȣ��������
} NET_DVR_SCREENLIST,*LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD	dwSize;
    DWORD	dwSubCommand;	//�����豸�����1-�豸��ʼ��2-ֹͣ��
    DWORD	dwDeviceIndex;//�豸���
    BYTE	byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

//�豸��
typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD	dwProgress; // 0-100
    BYTE 	byState;  //���ȣ�1-����� 2-������ 3-��ʧ��
    BYTE	byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;
typedef void (CALLBACK *DVCS_UPGRADESTATE_CB)(LONG nUpgradeHandle, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

typedef enum
{
    NET_DVR_DATA_BMP = 0,
        NET_DVR_START_CALLBACK,
        NET_DVR_STREAM_SYSHEAD,
        NET_DVR_STREAM_DATA
}PIC_PREVIEW_DATATYPE;

typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD	dwSize;
    DWORD	dwSignalIndex;	//�ź�Դ��ţ��ò������ڴ����������������豸��ֵ��Ϊ0
    DWORD	dwDeviceIndex;//�豸���
    BYTE	byRes1[12];
    BYTE	byChanIndex;	//ͨ����
    BYTE    byRes2[3];
    //��Ƶ�ۺ�ƽ̨���Բ���
    DWORD   dwScreenNum; //������ţ����㿪ʼ
    DWORD   dwLayer;     //ͼ��ţ����㿪ʼ
    DWORD   dwResolution;//���Էֱ���,1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//֡�ʣ���λ��֡/��
    BYTE    byRes3[15];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD	dwSize;
    BYTE	byAlarmType;		// ��������,1-�豸���ߣ�2-�豸���� 3-���������� 4-���������� 5-����Ա��½ 6-Ԥ����ʼ,7-Ԥ������8-�ֱ��ʱ仯��9-ͼ���и�ʧ�ܣ�10-�豸��Դ���㣬11-�¶��쳣  12-���ڴ�С���ź�Դ�ֱ��ʲ����*/
    BYTE	byDeviceType;		// �豸���� ����NET_DVCS_DEVICE_TYPE */
    BYTE	byWallNo;			// ǽ�ţ���1��ʼ�� 0��ʾ��Ч
    BYTE	byDeviceChanIndex; 	// �豸ͨ���ţ�0��ʾ��Ч������ֵ��ʾͨ����
    DWORD	dwDeviceIndex;		// �豸��ţ� 0��ʾ��Ч
    WORD	wResolutionX;		// �ֱ���-��  0��ʾ��Ч
    WORD	wResolutionY;		// �ֱ���-��  0��ʾ��Ч
    WORD	wTemperature;       // �豸�¶� ��λ�����϶�, 0��ʾ��Ч
    BYTE	byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD		dwSize;
    BYTE		bySubCommand;		//��궨��DECODEPIC_LEFTADJUST��
    BYTE		byScale;			//�������ֵ
    BYTE		byPictureProportion;	//ͼ�����ű��� 0-��Ч 1-4:3, 2-16:9
    BYTE		byRes[29];
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD	dwSize;
    BYTE	byControlCommand;	//�л����1-��ʾ��2-���أ�3-ȫ��ɾ�����GIFͼƬ	��
    BYTE	byUseType;			//ͼƬ���ͣ�1-OSD 2-��ͼ��3-GIF
    BYTE	byWallNo;			//����ǽǽ�ţ���1��ʼ
    BYTE	byPictureNo;		//ͼƬ���
    BYTE	byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;

// 76SP�豸POEͨ����ӷ�ʽ����
typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD		dwSize;              	//�ṹ���С
    BYTE 		byAddMode;     			//��ӷ�ʽ 0: ���弴�� 1: �ֶ����
    BYTE  		byRes1[127];          	//����
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

#define MAX_ESATA_NUM 16
#define MAX_MINISAS_NUM 96

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD		dwSize;
    BYTE	    byESATAUsage[MAX_ESATA_NUM];		// ���������ʾ�ڼ���eSATA��0��Ĭ�ϱ��� 1��Ĭ��¼��
    BYTE	    byMiniSASUsage[MAX_MINISAS_NUM];	// ���������ʾ�ڼ���miniSAS��0��Ĭ�ϱ��� 1��Ĭ��¼��
    BYTE 		byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

#define MAX_DISK_NUM 128

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD		dwSize;
    BYTE	    byDiskDesc[DESC_LEN_32];		//���ݴ�������
    BYTE		byHardDisk[MAX_DISK_NUM];		//�豸�ݵ�Ӳ�̺ţ����ݼ���ȡǰ����
    BYTE		byBackupHardDiskNum;  			//�豸�ݵ�Ӳ�̸���
    BYTE	    byContinue;						//�Ƿ����ݣ�0-������1-����
    BYTE        byAllLogBackUp ;        /*�Ƿ�ȫ�����ݣ�0-�����̺ű��ݣ�1-����������־����Ϊ1ʱ���豸�ݵĴ��̺ź�Ӳ�̸�����Ч*/
    BYTE 		byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD	dwSize;
    BYTE	byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //��ʾ��������ͨ���ĶԽ�״̬ 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE	byDigitalChanState[MAX_CHANNUM_V30];  /*����ͨ��������״̬ byDigitalChanErrState[0]
                                               ��ʾ��һ������ͨ��������ֵ��ʾ״̬�룬���NET_SDK_DIGITAL_CHANNEL_STATUS���Դ����ƣ�0xff��ʾ��Чͨ����δ���IPC*/
    BYTE	byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30*3];  //��ʾ��������ͨ���ĶԽ�״̬���ӵ�MAX_CHANNUM_V30+1 ����MAX_CHANNUM_V30*4���� 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE	byDigitalChanStateEx[MAX_CHANNUM_V30*3];  /*����ͨ��������״̬ byDigitalChanErrStateEx[0]��ʾ�ڴӵ�MAX_CHANNUM_V30+1��������ͨ��������ֵ��ʾ״̬�룬���NET_SDK_DIGITAL_CHANNEL_STATUS���Դ����ƣ�0��ʾ��Ч*/
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];//��ʾģ��ͨ���Ƿ�����,0-����,1-����
    BYTE	byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;

//����ͨ��״̬
typedef enum
{
    NET_SDK_DC_STATUS_CONNECTED = 1,                //������
        NET_SDK_DC_STATUS_CONNECTING,                    //��������
        NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,        //����ϵͳ���
        NET_SDK_DC_STATUS_DOMAIN_ERROR,                //�������
        NET_SDK_DC_STATUS_CHANNEL_ERROR,                //ͨ���Ŵ���
        NET_SDK_DC_STATUS_ACCOUNT_ERROR,                //�û�����������
        NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,    //�����Ͳ�֧��
        NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,            //���豸IP��ַ��ͻ
        NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,            //��IPC IP��ַ��ͻ
        NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,    //���粻�ɴ�
        NET_SDK_DC_STATUS_IPC_NOT_EXIST,                //IPͨ��δ����
        NET_SDK_DC_STATUS_IPC_EXCEPTION,                //IPͨ���쳣
        NET_SDK_DC_STATUS_OTHER_ERROR,                //�������
        NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,    //IPC�ֱ��ʲ�֧��
        NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,         //IPC������NVR���Բ�ƥ��
        NET_SDK_DC_STATUS_USER_LOCKED = 16,         //�û�����
        NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,		//�豸δ����
        NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,      //�û�������
        NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,     //IPͨ����Ӧ�豸δע��(GB28181Э�����)
        NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20   //POEͨ�������
}NET_SDK_DIGITAL_CHANNEL_STATUS;

/*************************************ITS****************************/
#define VERSION_LEN                 32 //�汾����
#define	MAX_OVERLAP_ITEM_NUM		50 //����ַ��������
#define	ITS_MAX_DEVICE_NUM		    32 //����豸����

//�ն˻���Ϣ
typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;
    BYTE    byMainVer[VERSION_LEN];	// �㷨�����̰汾
    BYTE    byMprVer[VERSION_LEN];	// ��֡ʶ���汾
    BYTE    byBvtVer[VERSION_LEN];	// ������Ƶ��汾
    BYTE    byLptVer[VERSION_LEN];	// ��Ƶ���ٿ�汾
    BYTE    byTvdVer[VERSION_LEN];	// Υ�¼���汾
    BYTE    byTldVer[VERSION_LEN];	// �źŵƼ���汾
    BYTE    byRes[252];		// Ԥ���ֶ�
}NET_ITS_BASEINFO,*LPNET_ITS_BASEINFO;

//ͼƬ�ϳɲ���
typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE   byIsMerge;		//�Ƿ���Ҫ�ϳɣ�0�����ϳɣ�1���ϳɣ�
    BYTE   byCloseupProportion;//��дͼ���� 1-ԭʼ�ֱ��ʴ�С��2-���Ϊԭʼ�ֱ����������Դ�����(1��8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;	//ץ�ĵ���ͼ�ϳɷ�ʽ�����ܻ��ȡ��дͼ��
    /************************************************************************/
    /* 201 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ2��         */
    /* 202 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ1��         */
    /* 203 ���ºϳɣ���д�����ϱ�.			                              */
    /* 204 ���ºϳɣ���д�����±�.                                        */
    /* 205 ���Һϳɣ���д�����ұߡ�                                       */
    /* 206 ���Һϳɣ���д�������                                         */
    /* 207 Ʒ�ֺϳɣ���дͼ���ϱ�                                         */
    /* 208 ��Ʒ�ֺϳɣ���дͼ���±�                                       */
    /* 209 �����Σ����1��Ϊ��д                                          */
    /* 210 �������Σ��ұ�1��Ϊ��д                                        */
    /* 301 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ3��         */
    /* 302 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��3��,��Ϊ1��		  */
    /* 303 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��					  */
    /* 304 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��					  */
    /* 305 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��					  */
    /* 306 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;ѹ��ͼƬ�ֱ���,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��	  */
    /* 307 ����ͼƬ"Ʒ"�������кϳ�										  */
    /* 308 ����ͼƬ��"Ʒ"�������кϳ�									  */
    /* 309 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��					      */
    /* 310 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��					      */
    /* 311 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��					      */
    /* 312 ������ͼƬ��ȡһ������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;ѹ��ͼƬ�ֱ���,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��	  */

    /* 313 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ����дͼ������ͼ������ͼ������ͼ                         */
    /* 314 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ����дͼ������ͼ������ͼ                         */
    /* 315 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ����дͼ������ͼ                         */
    /* 316 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ������ͼ����дͼ                         */
    /* 317 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ����дͼ������ͼ������ͼ������ͼ                         */
    /* 318 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ����дͼ������ͼ������ͼ                         */
    /* 319 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ����дͼ������ͼ                         */
    /* 320 ������ͼƬ��ȡһ������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ������ͼ����дͼ                         */
    /************************************************************************/
    DWORD  dwTwoMergeType;	//ץ������ͼ�ϳɷ�ʽ
    DWORD  dwThreeMergeType;	//ץ������ͼ�ϳɷ�ʽ
    DWORD  dwJpegQuality;      //ѹ��������0~100��
    DWORD  dwCloseupIndex;     //��дͼץ�ĵڼ���
    DWORD  dwMerageMaxSize;   //�ϳ�ͼƬ��С������,300-10240(��λKB)
    WORD   wCloseupDeviation; // ��дͼƫ����(50~ͼƬ�߶�)����λ:����
    BYTE   byRes[30];
}NET_ITS_IMGMERGE_CFG,*LPNET_ITS_IMGMERGE_CFG;

//��ͨ�������
typedef	struct	tagNET_ITS_TRAFFIC_DATA_HOST
{
    NET_DVR_IPADDR	struHostAddr;	// Զ������IP
    WORD			wHostPort;	// Զ������Port
    BYTE			byRes1[2];
    DWORD			dwDataType;	// �ϴ�Զ�������������ͣ�������£�����λ��ʾ
    BYTE			bySuspendUpload;	// �Ƿ���ͣ����ϴ���0-���ϴ���1-��ͣ�ϴ�
    BYTE			byUploadStrategy;	// �ϴ����ԣ�0-������������ϴ���1-����ͨ��ʱ���ϴ�
    WORD			wUploadInterval;	// �ϴ����ʱ�䣨ms��1~2000�����ò���ֻ����ʷ�����Ч
    DWORD			dwUploadTimeOut; //�ϴ���ʱʱ��
    BYTE			byRes[24];
}NET_ITS_TRAFFIC_DATA_HOST,*LPNET_ITS_TRAFFIC_DATA_HOST;

//����ϴ�����
typedef  struct	tagNET_ITS_UPLOAD_CFG
{
    DWORD              	dwSize;
    NET_ITS_TRAFFIC_DATA_HOST	struRemoteDataHost1;   	//���ս�ͨ�������1
    NET_ITS_TRAFFIC_DATA_HOST	struRemoteDataHost2;	    //���ս�ͨ�������2
}NET_ITS_UPLOAD_CFG,*LPNET_ITS_UPLOAD_CFG;

typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;   	    //��
    WORD  wMonth;  		//��
    WORD  wDay;    		//��
    WORD  wHour;   		//ʱ
    WORD  wMinute;  	//��
    WORD  wSecond;  	//��
    WORD  wMilliSec;	//����
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;

//��ͨ�������״̬��Ϣ
typedef	struct tagNET_ITS_TRAFFIC_DATA_INFO
{
    DWORD    dwDataQuantity;      //�������
    DWORD    dwDataRsendQuantity;     //δ������������Ҫ�ϴ���ͨ�������ģ�
    NET_DVR_SYSTEM_TIME      struStartTime;        //δ������ݵ�����ʱ��
    NET_DVR_SYSTEM_TIME      struEndTime;        //δ������ݵ�����ʱ��
    NET_DVR_IPADDR   struDataHost;    //���ս�ͨ�������
}NET_ITS_TRAFFIC_DATA_INFO, *LPNET_ITS_TRAFFIC_DATA_INFO;

//�ն˹���״̬
typedef  struct tagNET_ITS_WORKSTATE
{
    DWORD  dwSize ;
    BYTE   byDevName[NAME_LEN];	// �豸���
    DWORD  dwRunTime;		// ϵͳ����ʱ�䣬��λs
    NET_ITS_TRAFFIC_DATA_INFO	struTrafficDataInfo[2]; //֧����̨��������ϴ����õ�����
    DWORD  dwMemoryUsage;	// �ڴ�ռ���ʣ�����ڴ�ռ����Ϊ30%���˴���30��
    DWORD  dwCpuUsage;		// cpuռ���ʣ����cpuռ����Ϊ30%���˴���30��
    DWORD  dwDevTemperature;	// �����¶�
    DWORD  dwDeviceStatic; 	// �豸��״̬,0-��,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //��������ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD dwLocalDisplay;			//������ʾ״̬,0-��,1-����
    BYTE  byAudioInChanStatus[8];  	//��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ���У�����0��ʾ��1������ͨ��
    BYTE  byRes[36]; 			//����
}NET_ITS_WORKSTATE, *LPNET_ITS_WORKSTATE;

//����ڽ�ͨ���û�ȡ����
typedef  struct tagNET_ITS_ECT_WORKSTATE_COMMAND
{
    DWORD	dwSize;
    DWORD   dwChannel;
    BYTE    byRes[256]; 			//����
}NET_ITS_ECT_WORKSTATE_COMMAND, *LPNET_ITS_ECT_WORKSTATE_COMMAND;

typedef struct tagNET_ITS_ECTWORKSTATE
{
    DWORD	 dwSize ;
    BYTE	 byDevName[NAME_LEN];	// �豸���
    DWORD    dwRunTime;		// ϵͳ����ʱ�䣬��λs
    NET_ITS_TRAFFIC_DATA_INFO	struTrafficDataInfo[2]; //֧����̨��������ϴ����õ�����
    DWORD    dwMemoryUsage;	// �ڴ�ռ���ʣ�����ڴ�ռ����Ϊ30%���˴���30��
    DWORD    dwCpuUsage;		// cpuռ���ʣ����cpuռ����Ϊ30%���˴���30��
    DWORD    dwDevTemperature;	// �����¶�
    DWORD    dwDeviceStatic; 	// �豸��״̬,0-��,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //��������ڵ�״̬,0-û�б���,1-�б���
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD    dwLocalDisplay;			//������ʾ״̬,0-��,1-����
    BYTE     byRes[256]; 			//����
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

// ͼƬ��Ϣ����������������
typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;		    //ý����ݳ���
    BYTE    byType;			// 0:����ͼ;1:����ͼ;2:�ϳ�ͼ; 3:��дͼ;4:��ֱͼ;5:����;6:������ͼ(����ʻ);7:������ͼ(����ʻ)��ͼ;8-�ǻ�;9-����;10-����ԭʼ�����
    // 0-���ֱ���ϴ�; 1-�ƴ洢������URL(3.7Ver)ԭ�ȵ�ͼƬ��ݱ��URL��ݣ�ͼƬ���ȱ��URL����
    BYTE    byDataType;
    BYTE    byCloseUpType;//��дͼ���ͣ�0-����,1-�ǻ�,2-����
    BYTE    byPicRecogMode;  //ͼƬ����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) ��
    DWORD   dwRedLightTime;		//����ĺ��ʱ��  ��s��
    BYTE    byAbsTime[32];		//���ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999  �����λΪ������
    NET_VCA_RECT   struPlateRect;	//����λ��
    NET_VCA_RECT  struPlateRecgRect;   //��ʶ�������
    BYTE	*pBuffer;	//���ָ��
    BYTE    byRes2[12];   		//����
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;

// �����
typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;		//�ṹ����
    DWORD   dwMatchNo;		//ƥ�����,��(�������,�������,������)���ƥ����
    BYTE    byGroupNum;	//ͼƬ��������һ���������ץ�ĵ����������һ��ͼƬ������������ʱƥ����ݣ�
    BYTE    byPicNo;		//���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������;���ճ�ʱ����ͼƬ������ʱ�������Ҫ������ɾ��
    BYTE    bySecondCam;	//�Ƿ�ڶ����ץ�ģ���Զ��ץ�ĵ�Զ������ǰ��ץ�ĵĺ����������Ŀ�л��õ���
    BYTE    byFeaturePicNo; //����Ƶ羯��ȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE	byDriveChan;		//����������
    BYTE	byVehicleType;     //�������ͣ��ο�VTR_RESULT
    BYTE    byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    BYTE    byVehicleAttribute;//�������ԣ���λ��ʾ��0- �޸�������(��ͨ��)��bit1- �Ʊ공(�������ı�־)��bit2- Σ��Ʒ������ֵ��0- ��1- ��
    WORD    wIllegalType;       //Υ�����Ͳ��ù�궨��
    BYTE    byIllegalSubType[8];   //Υ��������
    BYTE    byPostPicNo;    //Υ��ʱȡ�ڼ���ͼƬ��Ϊ����ͼ,0xff-��ʾ��ȡ
    //ͨ����(��Ч������ͨ���ź������豸�ϴ�����ͨ����һ�£��ں�˺������� ͨ����һ��)
    BYTE    byChanIndex;
    WORD	wSpeedLimit;		//�������ޣ�����ʱ��Ч��
    BYTE	byRes2[2];
    NET_DVR_PLATE_INFO  struPlateInfo; 	//������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo;	//������Ϣ
    BYTE    byMonitoringSiteID[48];		//������
    BYTE    byDeviceID[48];				//�豸���
    BYTE    byDir;    		//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE    byDetectType;	//��ⷽʽ,1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //����������ʻ�ķ���0��ʾ�������£�1��ʾ�������ϣ����ʵ�ʳ�������ʻ����������֣�
    //��wIllegalType����Ϊ��ʱ��ʹ�øò�����wIllegalType����Ϊ��ֵʱ����wIllegalType����Ϊ׼���ò�����Ч��
    DWORD   dwCustomIllegalType; //Υ�����Ͷ���(�û��Զ���)
    BYTE    byRes4[9]; //����
    BYTE    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    //0-��բ��1-δ��բ (ר������ʷ���������ݺڰ���ƥ����Ƿ�բ�ɹ��ı�־)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-ʵʱ��ݣ�1-��ʷ���
    NET_DVR_TIME_V30  struSnapFirstPicTime;//�˵�ʱ��(ms)��ץ�ĵ�һ��ͼƬ��ʱ�䣩
    DWORD   dwIllegalTime;//Υ������ʱ�䣨ms�� = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    DWORD   dwPicNum;		//ͼƬ��������picGroupNum��ͬ����?����Ϣ�����ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����
    NET_ITS_PICTURE_INFO struPicInfo[6]; 		//ͼƬ��Ϣ,���Żص������6��ͼ����������
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

//����ڳ���ץ������ϴ�
typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;		//�ṹ����
    DWORD   dwMatchNo;		//ƥ�����,��(�������,�������,������)���ƥ���� Ĭ��0
    BYTE    byGroupNum;	//ͼƬ��������һ���������ץ�ĵ����������һ��ͼƬ������������ʱƥ����ݣ�Ĭ�� 1 ץ��������ͼƬ��� ���ƺ��������ʱ����
    BYTE    byPicNo;		//���ĵ�ͼƬ���ϴ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ������ɡ�
    //���ճ�ʱ����ͼƬ������ʱ�������Ҫ������ɾ��
    BYTE    bySecondCam;	//�Ƿ�ڶ����ץ�ģ���Զ��ץ�ĵ�Զ������ǰ��ץ�ĵĺ����������Ŀ�л��õ�����ʾǰ�����ץ��ͼƬ
    BYTE    byRes; //���ΪԤ��
    WORD    wLaneid;            //������1��32��������ţ�������Ծ��
    BYTE    byCamLaneId;	//��Ӧ������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byRes1;			//����
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //�Զ��屨������ Ĭ��Ϊ����
    WORD    wBackList;    //���Ϊ�Ƿ񱨾���� 0 ��ʾΪ������ 1 ��ʾ����
    WORD	wSpeedLimit;		//�������ޣ�����ʱ��Ч��km/h
    DWORD   dwChanIndex;		//ͨ����
    NET_DVR_PLATE_INFO    struPlateInfo; 	//������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO  struVehicleInfo;	//������Ϣ  ���ٶ�
    BYTE    byMonitoringSiteID[MAX_ID_LEN];		//������
    BYTE    byDeviceID[MAX_ID_LEN];				//�豸���
    BYTE    byDir;    		//��ⷽ��0-���� 1 �볡��2 ����
    BYTE    byDetectType;	//��ⷽʽ, 0-���� 1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN]; // ����
    DWORD   dwPicNum;		//ͼƬ��������picGroupNum��ͬ����?����Ϣ�����ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����
    NET_ITS_PICTURE_INFO struPicInfo[4]; 		//ͼƬ��Ϣ,���Żص������4��ͼ����������
    //2013-11-19 ����ڳ���ץ������ϴ�������ʽ����������
    BYTE    bySwipeTime[MAX_TIME_LEN];//����ˢ��ʱ��  ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;

//���������ʶ��
typedef  struct  tagNET_ITS_GATE_FACE
{
    DWORD   dwSize;            //�ṹ�峤��
    BYTE    byGroupNum;	//ͼƬ��������һ�����������ץ�ĵ����������һ��ͼƬ������������ʱƥ����ݣ�
    BYTE    byPicNo;		//���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ������ɡ�
    //���ճ�ʱ����ͼƬ������ʱ�������Ҫ������ɾ��
    BYTE    byFeaturePicNo; //��ץʱȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE    byRes;   //����
    WORD    wLaneid;            //������1��32��������ţ�������Ծ��
    BYTE    byCamLaneId;	//��Ӧ������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byDir;    	//��ⷽ��0-���� 1 �볡�� 2 ����
    DWORD   dwChanIndex;		//ͨ����
    BYTE    byMonitoringSiteID[MAX_ID_LEN];		//������
    BYTE    byDeviceID[MAX_ID_LEN];				//�豸���
    NET_VCA_FACESNAP_RESULT     struFaceInfo;   //����ץ�����
    BYTE    byRes2[256];   //Ԥ��
}NET_ITS_GATE_FACE, *LPNET_ITS_GATE_FACE;

//ͣ��������ϴ�
typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize; //�ṹ����
    BYTE    byGroupNum; //ͼƬ��������������ѯץ�ĵ�ͼƬ������
    BYTE    byPicNo; //���ĵ�ͼƬ���ϴ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������
    //���ճ�ʱ����ͼƬ������ʱ�������Ҫ������ɾ��
    BYTE    byLocationNum; //����ͼƬ�����ĳ�λ��
    BYTE    byParkError; //ͣ���쳣��0-�� 1 �쳣
    BYTE    byParkingNo[MAX_PARKNO_LEN];//��λ���
    BYTE    byLocationStatus; //��λ����״̬��0-�޳���1�г�
    BYTE    bylogicalLaneNum;//�߼���λ�ţ�0-3��һ���������ܹ�4����λ ��0�������ߣ�3������ұߣ�
    WORD    wUpLoadType;//����λ��ʾ��0~��ѵ�ϴ���1~�仯�ϴ�
    BYTE    byRes1[4]; //�����ֽ�
    DWORD   dwChanIndex; //ͨ��������ͨ��
    NET_DVR_PLATE_INFO   struPlateInfo;  //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE    byMonitoringSiteID[MAX_ID_LEN]; //������
    BYTE    byDeviceID[MAX_ID_LEN]; //�豸���
    DWORD   dwPicNum; //ͼƬ��������picGroupNum��ͬ����?����Ϣ�����ͼƬ����
    //��ͼƬ��Ϣ��struVehicleInfoEx����
    NET_ITS_PICTURE_INFO struPicInfo[2];  //ͼƬ��Ϣ,���Żص������2��ͼ����������
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

//��ͨȡ֤����
typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //�ṹ���С
    DWORD                   dwRelativeTime;        //���ʱ��
    DWORD                   dwAbsTime;	           //���ʱ��
    DWORD                   dwIllegalType;         //Υ�����ͣ����ù�궨��
    DWORD                   dwIllegalDuration;     //Υ������ʱ�䣨��λ���룩 = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //�豸���
    NET_VCA_DEV_INFO        struDevInfo;	       //ǰ���豸��Ϣ
    NET_DVR_SCENE_INFO      struSceneInfo;         //������Ϣ
    NET_DVR_TIME_EX         struBeginRecTime;      //¼��ʼʱ��
    NET_DVR_TIME_EX         struEndRecTime;        //¼�����ʱ��
    NET_DVR_AID_INFO        struAIDInfo;           //��ͨ�¼���Ϣ
    NET_DVR_PLATE_INFO      struPlateInfo;         //������Ϣ
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //������Ϣ
    DWORD                   dwPicNum;              //ͼƬ����
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //ͼƬ��Ϣ�����8��
    BYTE                    bySpecificVehicleType;     //���峵������  �ο�ʶ��������VTR_RESULT
    BYTE                    byLaneNo;  //����������
    BYTE                    byRes1[2]; //����
    NET_DVR_TIME_V30        struTime;//�ֶ����ٶ�λ����ǰʱ�䡣
    DWORD                   dwSerialNo;//��ţ�
    BYTE                    byVehicleAttribute;//�������ԣ���λ��ʾ��0- �޸�������(��ͨ��)��bit1- �Ʊ공(�������ı�־)��bit2- Σ��Ʒ������ֵ��0- ��1- ��
    BYTE                    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE                    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE                    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE                    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE                    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    BYTE                    byRes[102]; //����
}NET_DVR_TFS_ALARM,*LPNET_DVR_TFS_ALARM;

typedef struct _tagNET_ITS_ECT_BLACKLIST_
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  bylogicalLaneNo;//�߼�������
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];//������� 32
    NET_DVR_PLATE_INFO  struPlateInfo;  //������Ϣ�ṹ
    BYTE  byRes2[256];       // �����ֽ�
}NET_ITS_ECT_BLACKLIST, *LPNET_ITS_ECT_BLACKLIST;

//IPCͨ����������
typedef	struct 	tagNET_ITS_IPC_CHAN_CFG
{
    DWORD		dwSize;
    BYTE		byCameraType;		//������࣬0-��������1-��Ȧ�������2-��Ƶ���������,3-һ���
    BYTE		byRes1[3];		   //����
    BYTE		byMonitoringSiteID[48];		//������
    BYTE		byDeviceID[48];				//�豸���
    BYTE		byDirectionNo;	     //��ⷽ����,0-��,1-����,2-����,3-˫��,4-�ɶ�����,5-������,6-������,7-�ɱ�����,8-����
    BYTE		byMonitorInfo[48];  	//������Ϣ����
    BYTE		byRes2[15];		//����
}NET_ITS_IPC_CHAN_CFG, *LPNET_ITS_IPC_CHAN_CFG;

//�����豸��Ϣ
typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;  //�豸���ͣ�0-�նˣ�1-���2-����ƣ�3-��������4-��Ȧ1��5-��Ȧ2��6-��Ȧ3��7-���̵Ƽ������8-���
    //9-�״10-��բ��11-����ڿ��ƻ�(Ʊ��)��12-LED��ʾ����13-Զ�����������14-������������15-����ɨ��ǹ��
    //16-Ʊ�ݴ�ӡ��17-�ڵ������(�յ����������) , 18-�������
    DWORD  dwDirID;               //������
    DWORD  dwLaneID;             //�������
    DWORD  dwDeviceState;         //�豸״̬  0�� ��0 �쳣���ο��豸�쳣����?
    BYTE   byDeviceName[32];     //�豸���
    BYTE   byDeviceID[48];		   //�豸��ţ�һ�������кţ��������õ�ַ
    NET_DVR_TIME_V30  struTriggerTime;//����ʱ��
    BYTE   byRelateChan; //����ͨ���ţ���������1~8  AC����1~4  AC����1~2��
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO,*LPNET_ITS_SINGLE_DEVICE_INFO;

//·����Ϣ
typedef struct tagNET_ITS_ROADINFO
{
    DWORD	 dwSize;
    DWORD	 dwChannel;		  //ͨ����,0xffffffff��ʾ�նˣ������ʾ��Ӧ�����
    BYTE     byTriggerMode;    //  0:��Ȧ����;  1:��Ƶ����
    BYTE	 byRes1[3];
    DWORD    dwDeviceNum;       //ʵ���豸����
    BYTE     byMonitoringSiteID[48];	//������
    BYTE  	 byRoadInfo[48];       //������Ϣ
    NET_ITS_SINGLE_DEVICE_INFO		struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE     byRes[16];
}NET_ITS_ROADINFO,*LPNET_ITS_ROADINFO;

//��������·����Ϣ
typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;		//������
    BYTE   byRes1[3];    		// Ԥ��
    WORD   wCarFlux;			//��������
    WORD   wPasserbyFlux;		//����������
    WORD   wShayFlux;		//���ֳ�������
    float  fAverOccpancy;   	//ƽ���ռ���ʰٷֱ�
    WORD   wAverSpeed;		 //ƽ����(km/h)
    WORD   wAverCarDis;    	//ƽ���(��λ��)
    BYTE   byRes2[16];   		 // Ԥ��
}NET_ITS_TRAFFIC_DRIVE_CHAN,*LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;		//�ṹ��С
    BYTE   byMonitoringSiteID[48];		//������
    BYTE   byDeviceID[48];				//�豸���
    BYTE   byLaneNum;	//��������
    BYTE   byDir;    	//��ⷽ��
    BYTE   byDetectType;    //��ⷽʽ1-�ظ���Ȧ��2-��Ƶ������3����֡ʶ��4�״ﴥ��
    BYTE   byRes1;   		//Ԥ��
    DWORD  dwChannel; //ͨ����
    NET_DVR_SYSTEM_TIME 	struStartTime;		//ͳ�ƿ�ʼʱ��
    DWORD  dwSamplePeriod;	//ͳ��ʱ��,��λ��
    NET_ITS_TRAFFIC_DRIVE_CHAN	struDriveChan[6]; 		//��ͨ�������,ÿ�����֧��6������
    BYTE   byRes2[24]; 	//Ԥ��
}NET_ITS_TRAFFIC_COLLECT,*LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //����ģʽ��0-�նˣ�1-ǰ��(ֱ��ǰ�˻��ն˽�ǰ��)
    BYTE  byPicModeType;//0-��ʾСͼ(����ͼ)��1-��ʾ��ͼ(�ϳ�ͼ)
                        /*
                        0��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
                        1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE  byRelateType;
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;

typedef enum ITS_OVERLAP_ITEM_TYPE
{
    OVERLAP_ITEM_NULL = 0,	      //0-δ֪
        OVERLAP_ITEM_SITE,                //1-�ص�
        OVERLAP_ITEM_ROADNUM,             //2-·�ڱ��
        OVERLAP_ITEM_INSTRUMENTNUM,       //3-�豸���
        OVERLAP_ITEM_DIRECTION,           //4-������
        OVERLAP_ITEM_DIRECTIONDESC,       //5-����
        OVERLAP_ITEM_LANENUM,             //6-������
        OVERLAP_ITEM_LANEDES,             //7-����
        OVERLAP_ITEM_CAPTIME,             //8-ץ��ʱ��(�������)
        OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-ץ��ʱ��(�����)
        OVERLAP_ITEM_PLATENUM,            //10-���ƺ�
        OVERLAP_ITEM_CARCOLOR,            //11-������ɫ
        OVERLAP_ITEM_CARTYPE,             //12-��������
        OVERLAP_ITEM_CARBRAND,            //13-����Ʒ��
        OVERLAP_ITEM_CARSPEED,            //14-�����ٶ�
        OVERLAP_ITEM_SPEEDLIMIT,          //15-���ٱ�־
        OVERLAP_ITEM_CARLENGTH,           //16-��������1~99m
        OVERLAP_ITEM_ILLEGALNUM,          //17-Υ������(Υ���������Ӧ��û�õģ�Ӧ��ֱ�ӵ���Υ����Ϣ����������١����١����С�����ơ�ռ����ѹ���ߵ�)
        OVERLAP_ITEM_MONITOR_INFO,      //18-������Ϣ
        OVERLAP_ITEM_ILLEGALDES,          //19-Υ����Ϊ
        OVERLAP_ITEM_OVERSPEED_PERCENT,	//20-���ٱ�
        OVERLAP_ITEM_RED_STARTTIME,           //21-��ƿ�ʼʱ��
        OVERLAP_ITEM_RED_STOPTIME,		//22-��ƽ���ʱ��
        OVERLAP_ITEM_RED_DURATION,        //23-�������ʱ��
        OVERLAP_ITEM_SECUNITY_CODE,		//24-��α��
        OVERLAP_ITEM_CAP_CODE,		//25-ץ�ı��
        OVERLAP_ITEM_SEATBELT,      //26-��ȫ��
        OVERLAP_ITEM_MONITOR_ID,    //27-������
        OVERLAP_ITEM_SUN_VISOR,     //28-������
        OVERLAP_ITEM_LANE_DIRECTION,  //29-������ʻ����
        OVERLAP_ITEM_LICENSE_PLATE_COLOR,  // 30-������ɫ
        OVERLAP_ITEM_SCENE_NUMBER,  //31-�������
        OVERLAP_ITEM_SCENE_NAME,   //32-�������
        OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-�Ʊ공
        OVERLAP_ITEM_DANGEROUS_CAR    //34-Σ��Ʒ��
}ITS_OVERLAP_ITEM_TYPE;

//�ַ����ÿһ����Ϣ�ṹ��
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                   // ����
    BYTE byItemType;   //���ͣ����OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;		   //�������Ļ�����[0-10](Ĭ��0)
    BYTE bySpaceNum;				   //�������Ŀո���[0-255](Ĭ��0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //�Ƿ����������ʾ
    WORD wStartPosTop;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD wStartPosLeft;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //�����ַ����
    DWORD dwLinePercent;  //�����аٷֱ�(0-100),(Ĭ��100)
    DWORD dwItemsStlye;   //���ӷ�ʽ��0-����,1-����(Ĭ�Ϻ���)
    WORD  wStartPosTop;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartPosLeft;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wCharStyle;    //��������,0-����1-κ��(Ĭ��)
    WORD  wCharSize;    //�ַ��С,0--16x16,1--32x32,2-48x48,3--64x64 (Ĭ��),8x128(Ver3.7)
    WORD  wCharInterval;    //�ַ��࣬[0��16]�����赥λ������(Ĭ��)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //ǰ��ɫ��RGBֵbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00FFFFFF-��)
    DWORD dwBackClorRGB; //����ɫ��RGBֵ,ֻ��ͼƬ�������Чbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00000000-��)
    BYTE  byColorAdapt;	//��ɫ�Ƿ�����Ӧ0-��1-��
    //(Ver3.7 ����)
    // ������ʹ�� 0-����, 1-�����㣨��ϸע�ͣ��ٶ�,����ֵ ����3λ��0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// ����Сͼ�������Ͻ�ʹ�� 0-������, 1-����
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartSPicPosLeft; //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    //OSD����λ��  0-ͼƬ��,1-ͼƬ�ϱ�Ե,2-ͼƬ�±�Ե���ϳ�ͼר�õ����ϱ�Ե�⣩��V3.7��
    BYTE       byOsdLocate;
    BYTE 		byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

//�����������Ϣ
typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //�ص�����
    BYTE byRoadNum[32];  //·�ڱ��
    BYTE byInstrumentNum[32];				//�豸���
    BYTE byDirection[32];        //������
    BYTE byDirectionDesc[32];    //��������
    BYTE byLaneDes[32];        //��������
    BYTE byRes1[32];     //����
    BYTE byMonitoringSite1[44];		//����1��Ϣ
    BYTE byMonitoringSite2[32];		//����2��Ϣ
    BYTE byRes[64];		//����
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM		struOverLapItem; //�ַ����
    NET_ITS_OVERLAP_INFO_PARAM 	struOverLapInfo;  //�ַ�������Ϣ
    BYTE  byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

//�ַ����ÿһ����Ϣ�ṹ��
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                   // ����
    BYTE byItemType;   //���ͣ����OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;		   //�������Ļ�����[0-10](Ĭ��0)
    BYTE bySpaceNum;				   //�������Ŀո���[0-255](Ĭ��0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //�Ƿ����������ʾ
    WORD wStartPosTop;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD wStartPosLeft;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    //�Զ������ͣ���byItemType�����Ӧ���ɽ�byItemType���������Զ�����ơ����Զ�������Ϊ�գ���Ĭ����byItemType�����е���������
    BYTE byItemTypeCustom[32];
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //�����ַ����
    DWORD dwLinePercent;  //�����аٷֱ�(0-100),(Ĭ��100)
    DWORD dwItemsStlye;   //���ӷ�ʽ��0-����,1-����(Ĭ�Ϻ���)
    WORD  wStartPosTop;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartPosLeft;    //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wCharStyle;    //��������,0-����1-κ��(Ĭ��)
    WORD  wCharSize;    //�ַ��С,0--16x16,1--32x32,2-48x48,3--64x64 (Ĭ��),8x128(Ver3.7)
    WORD  wCharInterval;    //�ַ��࣬[0��16]�����赥λ������(Ĭ��)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //ǰ��ɫ��RGBֵbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00FFFFFF-��)
    DWORD dwBackClorRGB; //����ɫ��RGBֵ,ֻ��ͼƬ�������Чbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00000000-��)
    BYTE  byColorAdapt;	//��ɫ�Ƿ�����Ӧ0-��1-��
    //(Ver3.7 ����)
    // ������ʹ�� 0-����, 1-�����㣨��ϸע�ͣ��ٶ�,����ֵ ����3λ��0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// ����Сͼ�������Ͻ�ʹ�� 0-������, 1-����
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartSPicPosLeft; //��ʼ�����,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    //OSD����λ��  0-ͼƬ��,1-ͼƬ�ϱ�Ե,2-ͼƬ�±�Ե���ϳ�ͼר�õ����ϱ�Ե�⣩��V3.7��
    BYTE  byOsdLocate;
    BYTE  byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byRes1[3];
    NET_ITS_OVERLAP_ITEM_PARAM_V50		struOverLapItemV50; //�ַ����
    NET_ITS_OVERLAP_INFO_PARAM 	        struOverLapInfo;  //�ַ�������Ϣ
    BYTE  byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;

#define  MAX_PTZCRUISE_POINT_NUM   32   //���֧��32��Ѳ����


//Ԥ�õ���Ϣ
typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum; //Ԥ�õ����
    DWORD dwGroupNum;  //����
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;

//�������
typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //���
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;

//�������
typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //Ԥ�õ����
    NET_VCA_POINT struVcaPoint; //Ԥ�õ����
    WORD wZoomCoordinate; ///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[30];
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

//��ȡѲ��·������Ŀ
typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum; //·������
    DWORD dwGroupNum; //����
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

//�������
typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //���
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;

//�������
typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //Ԥ�õ����
    NET_VCA_POINT struVcaPoint; //Ԥ�õ����
    BYTE	byDwell;		//ͣ��ʱ��
    BYTE	bySpeed;		//�ٶ�
    WORD  wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE   byRes[28];
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute; //Ѳ��·�����
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM]; //���֧��32��Ѳ����
    BYTE  byRes[32];
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;

//����ģʽ�ṹ
typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize;
    BYTE byEnableTrack;   //���ø��٣�0-��1-��
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;

//һ��Ķ�ʱ�ƻ�
typedef struct tagNET_DVR_DAY_SCHEDULE
{
    BYTE byWorkMode ;			//0-ȫ�쿪��1-ȫ��أ�2-��ʱ
    BYTE byRes1[3] ;
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];  //ʱ���
    BYTE byRes2[8];              	//����
}NET_DVR_DAY_SCHEDULE ,*LPNET_DVR_DAY_SCHEDULE;

//��ʱ���ܸ��ٲ���ṹ
typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD	dwSize;	//�ṹ����
    BYTE 	byEnableTrack;			//���ø��٣�0- ��1- ��
    BYTE	byRes1[3] ;
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];	//��ʱ���ܸ���ʱ��Σ�������8��ʱ����ڵ�ʱ�䣬Ĭ�϶�ʱ���ܸ��ٹر�
    BYTE	byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG,*LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD	dwSize;					//�ṹ����
    BYTE	sStreamID[STREAM_ID_LEN/*32*/] ; //��ID
    DWORD	dwChan;				 	//����ͨ����
    BYTE	byStreamType;		 	//0-��������1-��������2-����3��3-����4��4-����5
    BYTE	byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //���ڼ���1-7�������һ��������
    BYTE byHour;   //ʱ
    BYTE byMinute; //��
    BYTE byRes1;
    BYTE byRebootMode; //0-����������1-�����������˲���ֻ�ܻ�ȡ���������ã�
    BYTE byRes[11]; //����
}NET_DVR_REBOOT_TIME,*LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG,*LPNET_DVR_AUTO_REBOOT_CFG;

#define NET_DVR_GPS_FINDING       0   //���ڲ���
#define NET_DVR_GPS_RECV          1   //�������
#define NET_DVR_GPS_OVER          2   //���ҽ���
#define NET_DVR_GPS_EXCEPTION     3   //�����쳣
typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD		dwSize;
    BYTE		byMenuOutputMode; //��ͬԴ�豸��0-Auto 1-��CVBS 2-HDMI 3-VGA ͬԴ�豸��0-Auto 1-��CVBS 2-HDMI/VGA
    BYTE		byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP��ַ
    WORD        wPort;   //�˿ں�
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR,*LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //�豸id
    BYTE byPassword[PASSWD_LEN];  //����
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //�豸id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{
    DWORD dwSize;
    BYTE byNetEnvironment;/*���绷��,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*< ��ǰƽ̨0 - WVS, 1 - E��, 2 - ��ģʽ */
    BYTE byRes1[2];
    NET_DVR_MB_WVSPARA  struWVSPara; /*����ƽ̨(ƽ̨����)*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E��ƽ̨����ƽ̨�������豸�������� */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE		byGPSModule;      /*gpsģ��, 0: ������, 1: ��*/
    BYTE		byPositionStatus;	  /*gps��λ״̬, 0: ��λʧ��, 1: ��λ�ɹ�*/
    BYTE		bySignalStrength;    /*�ź�ǿ��, 0: ��, 1: ��, 2: ǿ*/
    BYTE		byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE		byGsensorModule;	/*g-sensorģ��, 0: not exist, 1: ����, 2: ����*/
    BYTE		byCurAccX[10]; 	/*��ǰX����ٶ�*/
    BYTE		byCurAccY[10];	/*��ǰY����ٶ�*/
    BYTE		byCurAccZ[10];	/*��ǰZ����ٶ�*/
    BYTE		byRefAccX[10];	/* X����ٶȱ궨ֵ*/
    BYTE		byRefAccY[10];	/* Y����ٶȱ궨ֵ*/
    BYTE		byRefAccZ[10];	/* Z����ٶȱ궨ֵ*/
    BYTE		byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

#define IP_ADDR_LEN 		16
#define IW_ESSID_MAX_SIZE	32

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE		byEnableWiFi; /* ����, 0 ��, 1 �� */
    BYTE 		byWiFiConnectStatus;  /* WIFI״̬, 0: ����ʧ��, 1: ���ӳɹ� 2: ��ģ��*/
    BYTE		bySignalStrength;             /* �ź�ǿ��, 0 ��, 1 ��, 2 ǿ */
    BYTE		byIPaddress[IP_ADDR_LEN];   /*WIFI �豸 ip*/
    BYTE		byEssid[IW_ESSID_MAX_SIZE];  /*���߽����essid*/
    BYTE		byres[5];
}NET_DVR_MB_WIFI_STATUS,*LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE		byCurPlat;	  /*��ǰƽ̨, 0: wvs, 1: ivms, 2: ��ģʽ(net_3g_sdk)*/
    BYTE		byLoginStatus; 	/*login ״̬, 0: login failed, 1: login success*/
    BYTE		byExceptionInfo;  	/*�쳣��Ϣ*/
    /*
    WVS :exception info:
    0: ���ӷ�����ʧ��
    1: ע����
    2: �û����������
    3: ע�ᳬʱ
    4: ����ʱ
    5: ע��ɹ�
    iVMS :exception info:
    0δע��
    1ע����
    2ע�����ӳ���
    3ע�ᳬʱ
    4��ʱ��û�����������ж�
    5����ע��
    6 CMS��ע���豸�����Ѿ������޶���̨��
    7 CMS��ע��ͨ�������Ѿ������޶�ͨ����
    8�豸��WEB����������û������
    9CMS��WEB��������ͨ��ʧ��
    10��¼δ֪����
    11ע��ɹ�
    ��ģʽ :exception info:
    0δע��
    1: ע����
    2: �ظ�ע��
    3: ע������ʧ��
    4: ������IP�仯
    5: ע��ɹ�
    6: �û�ע��
    7: ����ʱ
    */
    BYTE		byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;


typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD		dwSize;      /*�ṹ��С*/
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

#define NET_DVR_GPS_STATUS       0
#define NET_DVR_GSENSOR_STATUS   1
#define NET_DVR_WIFI_STATUS      2
#define NET_DVR_PLATFORM_STATUS  3

//GPS����Ϣ�ṹ
typedef struct tagNET_DVR_GPS_INFO
{
    /* ��γ��ΪS*100 */
    BYTE    byDirection[2];		/*direction[0]0or1(����/����), direction[1]:0or1(��γ/��γ)  */
    BYTE    bySvs;         /* satellite vehicles(��ֵ0)����Ч��λ���� */
    BYTE    byLocateMode;  /* ��λģʽ(��ֵ0)����NMEA0183 3.00�汾�����0=������λ��1=��֣�2=���㣬3=�����Ч */
    WORD    wHDOP;  /* ˮƽ�������ӣ�����GPS��ȷ�ȣ�0.5-99.9��6���ڶ�λ���ȸߣ�20�����趪������洢���ǳ���10�Ժ������ */
    WORD    wHeight;         	/* �߶� */
    DWORD   dwLatitude;	 /*γ��latitude = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD   dwLongitude; /*����longitude =ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD   dwVehicleSpeed;		/* mobile speed =ʵ���ٶ�*100000 ʵ�ʵ�λkph*/
    DWORD	dwVehicleDirection;	/* mobile direction= ʵ�ʷ���*100��ʵ����ֵ�Ƿ���ǣ���Ϊ0�ȣ�˳ʱ�� */
    BYTE	byRes[8];            // ����
}NET_DVR_GPS_INFO,*LPNET_DVR_GPS_INFO; //32�ֽ�

//GPS����ʱ��
typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS����
    NET_DVR_TIME      struTime;    		//GPS����Ӧ��ʱ��㣬UTCʱ��
    BYTE	    byRes[12];             // ����
}NET_DVR_GPS_DATA,*LPNET_DVR_GPS_DATA;

//GPS���������ṹ
typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{
    DWORD dwCmdType;              //0-��ʱ��β���GPS���,1-��ʱ������GPS���
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //GPS��ݲ�����ʼʱ��
            NET_DVR_TIME struEndTime;                 //GPS��ݲ��ҽ���ʱ��
            DWORD dwInterval;                  //GPS��ʱ��������λ��
            BYTE  byRes[76];                    // ����
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //GPS��ݲ�����ʼʱ�䵥λ��
            BYTE  byRes[104];              // ����
        }TimePoint;
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM,*LPNET_DVR_GET_GPS_DATA_PARAM;

typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE	byEnableAbilityParse;	//ʹ��������������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE    byVoiceComMode;          //�Խ�ģʽ��0-ʹ�öԽ��⣨Ĭ�ϣ���1-ʹ��windows apiģʽ
    BYTE    byLoginWithSimXml;  //��¼ʱʹ��ģ������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE	byProtectKey[128];	//Ĭ������Ϊ0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;

typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE	byEnableAbilityParse;	//ʹ��������������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE	byRes[127];
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE	byTalkMode;				//�Խ�ģʽ��0-ʹ�öԽ��⣨Ĭ�ϣ���1-ʹ��windows apiģʽ
    BYTE	byRes[127];
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;


typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE	byProtectKey[128];		//Ĭ������Ϊ0
    BYTE	byRes[128];
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //��¼ʱʹ��ģ������У��ṹ�������ֶ�,0-��ʹ��,1-ʹ��
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;

typedef enum tagNET_SDK_LOCAL_CFG_TYPE
{
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,		//����TCP�˿ڰ����ã���Ӧ�ṹ��NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,			//����UDP�˿ڰ����ã���Ӧ�ṹ��NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,				//�ڴ�ر������ã���Ӧ�ṹ��NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,		//��ģ�����ó�ʱʱ�䣬��Ӧ�ṹ��NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,			//�Ƿ�ʹ�������������⣬��Ӧ�ṹ��NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,				//�Խ�ģʽ����Ӧ�ṹ��NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,				//��Կ���ã���Ӧ�ṹ��NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,             //���ڲ��԰汾ͷ���豸�˼������, ֻ�������ò���ʱ�������á�
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,				//rtsp�������ã����ڽṹ��NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            //�ڵ�¼ʱʹ��ģ����������support�ֶ�, ��Ӧ�ṹNET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                //�������ʱ��
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  //SDK���ΰ�ȫ���ã�
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            //����өʯ��ͨ�ſ��ַ��
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               //13.�����ַ������ش���ص�
    NET_SDK_LOCAL_CFG_TYPE_PROXYS                     //���û�ȡ��
}NET_SDK_LOCAL_CFG_TYPE;

typedef int(CALLBACK * CHAR_ENCODE_CONVERT)(char * pInput, DWORD dwInputLen, DWORD dwInEncodeType, char *pOutput, DWORD dwOutputLen, DWORD dwOutEncodeType);

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;//˽��Э��ͨ��ģʽ�� //0-����ģʽ��Ĭ�ϣ����������е�SDK��¼Э��ͨ��1-��ȫģʽ��MD5��, ����RSA��MD5��¼������У��2-��ȫģʽ��RSA��RSA��¼������У��
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //Ѳ��ʱ��������λms  ��СֵΪ30s�����ֵ120s��Ϊ0ʱ����ʾ��Ĭ��ֵ(120s)
    DWORD   dwCheckOnlineNetFailMax;  //��������ԭ��ʧ�ܵ�����ۼӴ�����ֵSDK�Żص��û��쳣��Ϊ0ʱ����ʾʹ��Ĭ��ֵ1
    BYTE    byRes[256];
}NET_DVR_LOCAL_CHECK_DEV,*LPNET_DVR_LOCAL_CHECK_DEV;


typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE	byVersion;			            //�汾��Ϣ
    BYTE	byRes[63];						//����
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD	wLocalBindTcpMinPort;			//���ذ�Tcp��С�˿�
    WORD	wLocalBindTcpMaxPort;			//���ذ�Tcp���˿�
    BYTE	byRes[60];						//����
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD	wLocalBindUdpMinPort;			//���ذ�Udp��С�˿�
    WORD	wLocalBindUdpMaxPort;			//���ذ�Udp���˿�
    BYTE	byRes[60];						//����
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD	dwAlarmMaxBlockNum;		//����ģ���ڴ�������ϵͳ������ڴ�飨block������ÿ��blockΪ64MB, ���������������ϵͳ���룬0��ʾ������
    DWORD	dwAlarmReleaseInterval;				//����ģ������ڴ��ͷŵļ������λ�룬Ϊ0��ʾ���ͷ�
    BYTE	byRes[512];							//����
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD		dwPreviewTime;		//Ԥ��ģ�鳬ʱʱ��
    DWORD		dwAlarmTime;		//����ģ�鳬ʱʱ��
    DWORD		dwVodTime;			//�ط�ģ�鳬ʱʱ��
    DWORD		dwElse;				//����ģ��
    BYTE		byRes[512];							//����
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD	dwMaxBuffRoomNum;	//rtp over udp���򿪱ٵ���󻺳������0Ϊ��Ч��ʹ��Ĭ��ֵ20
    //һ����������ڴ�Ϊ10K��һ�㣬���������Խ�࣬���������������Խǿ��������Խ�ã���ʱҲԽ��
    BYTE	byUseSort;	//�Ƿ���rtp over udp���� 0-������  1-����
    BYTE	byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;

typedef  struct  tagNET_DVR_OPTICAL_CHANNEL_BIND
{
    WORD wChannelIndex;    //��ں�(0-7)
    WORD wSubChannel;      //�����ͨ���ţ�ȡֵ��Χ����������ȡ
    BYTE  byBind;      //0-���󶨻����󶨣�1-��
    BYTE  byRes[3];
}NET_DVR_OPTICAL_CHANNEL_BIND,*LPNET_DVR_OPTICAL_CHANNEL_BIND;

typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//��Ƶ��
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//��Ƶ��
    BYTE  byRes[16];           //����
}NET_DVR_OPTICAL_CHANNEL_CFG,*LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//������ϵͳ��λ��
    BYTE  byChannel; //����ͨ����
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO,*LPNET_DVR_OPTICAL_INFO;

//��Ƶ�л�
typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //��Ƶ�Ƿ�����1-����0-��
    BYTE  byRes1[3];
    //���²���byStatus == 1ʱ��Ч
    DWORD dwSubWinNum; //�������Ӵ��ں�
    DWORD dwSurChanNum;             /*���ͨ����  */
    NET_DVR_IPADDR struIpaddr;            /*���ͨ����ַ */
    WORD   wPort;                      	/*���ͨ���˿� */
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

//�˿ھۺ�
#define MAX_ETHERNET_PORT_NUM       8//ÿ����·���˿���
typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j��ʾ����i���˿ڼ��뵽��j����·��j��ȡֵΪ1-8,j=0��ʾ�Ƴ�
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO,*LPNET_DVR_ETHERNET_CHANNEL_INFO;

//����
typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-���Թأ�1-���Կ�
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO,*LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //����IP��ַ���ˣ�0-��1-��
    BYTE byFilterType; //�������ͣ�0-���ã�1-����
    BYTE byRes[18];
    BYTE byIPAddr[1024];	//IP��ַ��Ϣ����ʽ192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-��1-��
    BYTE  byRes1[3];
    DWORD dwCoordinateX;	//ͼƬ��ʾ����X���
    DWORD dwCoordinateY;	//ͼƬ��ʾ����Y���
    WORD  wPicWidth; //ͼƬ��
    WORD  wPicHeight; //ͼƬ��
    BYTE  byRes[16];		//����
}NET_DVR_LOGO_OVERLAYCFG,*LPNET_DVR_LOGO_OVERLAYCFG;


typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD	struStructHead;
    DWORD				dwDiskNo;			// ���̺�
    BYTE				byDelAll;			// 0-ɾ��dwDiskNo  1-ɾ��ȫ����Ч����
    BYTE 				byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;


typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD	struStructHead;
    DWORD				dwDiskNo;			// ���̺�
    BYTE 				byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;

// �����ӻص�����
typedef enum
{
    NET_SDK_CALLBACK_TYPE_STATUS = 0,		// �ص�״ֵ̬
        NET_SDK_CALLBACK_TYPE_PROGRESS,			// �ص����ֵ
        NET_SDK_CALLBACK_TYPE_DATA				// �ص��������
}NET_SDK_CALLBACK_TYPE;


// �ص�����ΪNET_SDK_CALLBACK_TYPE_STATUSʱ��״ֵ̬
typedef enum
{
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,		// �ɹ�
        NET_SDK_CALLBACK_STATUS_PROCESSING,			// ������
        NET_SDK_CALLBACK_STATUS_FAILED,				// ʧ��
        NET_SDK_CALLBACK_STATUS_EXCEPTION,			// �쳣
        NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,	//��IPC�����ļ����룩���Բ�ƥ��
        NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,	//��IPC�����ļ����룩�豸���Ͳ�ƥ��
        NET_DVR_CALLBACK_STATUS_SEND_WAIT           // ���͵ȴ�
}NET_SDK_CALLBACK_STATUS_NORMAL;


//һ������ͨ��״̬
#define NET_SDK_OKC_STATUS_SUCCESS				1000  //һ�����óɹ�
#define NET_SDK_OKC_STATUS_FAILED				1002  //һ������ʧ��

//һ������CVR״̬
#define NET_SDK_OKC_STATUS_START_CONFIG			1003  //��ʼ����
#define NET_SDK_OKC_CHECK_HD					1004  //������
#define NET_SDK_OKC_INIT_HD						1005  //��ʼ������
#define NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK	1006  //�������л��ߵ���ģʽ
#define NET_SDK_OKC_INIT_CVR_SERVICE			1007  //��ʼ��CVR����
#define NET_SDK_OKC_CREATE_RECORD_VOLUME		1008  //����¼���

//����Ϊһ������ʧ�ܵ�״̬��
#define NET_SDK_OKC_ERR_LOAD_CONF_FAILED              1009 //���������ļ�ʧ��
#define NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE        1010 //��֧�ִ������͵�raid
#define NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT		  1011 //ϵͳ�Ѿ�����raid��洢��
#define NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED          1012 //��ȡ������Ϣʧ��
#define NET_SDK_OKC_ERR_CHECK_DISK_FAILED             1013 //������ʧ��
#define NET_SDK_OKC_ERR_INIT_DISK_FAILED              1014 //��ʼ������ʧ��
#define NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL           1015 //��������������
#define NET_SDK_OKC_ERR_BOTH_SV_NS                    1016 //ͬʱ����SV�̺�NS��
#define NET_SDK_OKC_ERR_CREATE_RAID_FAILED            1017 //����raidʧ��
#define NET_SDK_OKC_ERR_GET_RAID_FAILED               1018 //��ȡraidʧ��
#define NET_SDK_OKC_ERR_CREATE_SPARE_FAILED           1019 //�����ȱ���ʧ��
#define NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED    1020 //�����洢��ʧ��
#define NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED          1021 //��ȡ�洢����Ϣʧ��
#define NET_SDK_OKC_ERR_CREATE_LUN_FAILED   	      1022 //����lun��ʧ��
#define NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED           1023 //��ȡlun��Ϣʧ��
#define NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED    	  1024 //����Ԥ����ʧ��
#define NET_SDK_OKC_ERR_GET_BACKUP_FAILED          	  1025 //��ȡԤ����ʧ��
#define NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED  	  1026 //����˽�о�ʧ��
#define NET_SDK_OKC_ERR_CREATE_RV_FAILED              1027 //����¼���ʧ��
#define NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED         1028 //�����浵��ʧ��
#define NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED	  1029 //����CVR����ʧ��

//һ������SAN״̬
#define NET_SDK_OKC_CREATING_ARRAY					1030  //�������н׶�
#define NET_SDK_OKC_CREATING_STORAGE_POOL			1031  //�����洢�ؽ׶�
#define NET_SDK_OKC_CREATING_LUN_VOL				1032  //�����߼���׶�
#define NET_SDK_OKC_CREATING_ISCSI					1033  //����ISCSI�׶�
#define NET_SDK_OKC_ERR_HOT_SPARE_CONFICT			1034  //�Ѵ����ȱ���
#define NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT		1035  //�Ѵ��ڴ洢��

typedef enum
{
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,	// �ɹ���ȡ����ݣ��ͻ��˴����걾����ݺ���Ҫ�ٴε���NET_DVR_RemoteConfigGetNext��ȡ��һ�����
        NET_SDK_GET_NETX_STATUS_NEED_WAIT,		// ��ȴ��豸������ݣ��������NET_DVR_RemoteConfigGetNext����
        NET_SDK_GET_NEXT_STATUS_FINISH,			// ���ȫ��ȡ�꣬��ʱ�ͻ��˿ɵ���NET_DVR_StopRemoteConfig��������
        NET_SDK_GET_NEXT_STATUS_FAILED,			// �����쳣���ͻ��˿ɵ���NET_DVR_StopRemoteConfig��������
}NET_SDK_GET_NEXT_STATUS;

//���������ļ�������
typedef enum tagNET_SDK_IPC_CFG_FILE_ERR_CODE
{
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,								/* û���� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,       /* ͨ��ID�Ƿ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,         /* ͨ��ID�ظ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,              /* ͨ��IP������Ƿ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,           /* ͨ��IP�������ظ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL, /* ͨ��IP�뱾��IP��ͻ */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,         /* Э����� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,             /* ����˿ڴ��� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,   /* �豸ͨ���Ŵ��� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,       /* �û���Ƿ��ַ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,             /* ���뺬�Ƿ��ַ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID /*����Э�����*/
}NET_SDK_IPC_CFG_FILE_ERR_CODE;

//IPC�������
typedef enum
{
    NET_SDK_UPGRADE_IPC_INVALID = 0,				//��Чͨ����δѡ���ͨ����
        NET_SDK_UPGRADE_IPC_SUCCESS,					//��ɹ�
        NET_SDK_UPGRADE_IPC_OFFLINE,					//IPC������
        NET_SDK_UPGRADE_IPC_NOT_SUPPORT,				//IPC��֧��������
        NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,			//���Բ�ƥ��
        NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,			//дflshʧ��
        NET_SDK_UPGRADE_IPC_OTHER_ERROR					//�������
}NET_SDK_UPGRADE_IPC_ERR_CODE;

typedef enum
{
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,//¼������һ��ɹ�
        NET_SDK_REMOTE_CONFIG_STATUS_FAILED,	//¼������һ��ʧ��
        NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING	//¼������һ�����ڻ�ȡ
}NET_SDK_REMOTE_CONFIG_STATUS;

#define MAX_CODE_CARD_SUPPORTDISPNUMS 8//ÿ�����뿨���֧�ֵ���ʾͨ����
#define MAX_SUPPORT_RES 32

typedef enum _BOARD_TYPE
{
    DS4004HC_BOARD		=2,  //4004HC
        DS4008HC_BOARD		=3,  //4008HC
        DS4016HC_BOARD		=4,  //4016HC
        DS4001HF_BOARD		=5,  //4001HF
        DS4004HF_BOARD		=6,  //4004HF
        DS4002MD_BOARD		=7,  //4002MD
        DS4004MD_BOARD		=8,  //4004MD
        DS4016HCS_BOARD		=9,  //4016HCS
        DS4004HC_PLUS_BOARD	=13, //4004HC+
        DS4008HC_PLUS_BOARD	=14, //4008HC+
        DS4016HC_PLUS_BOARD	=15, //4016HC+
        DS4008HF_BOARD		=16, //4008HF
        DS4008MD_BOARD		=17, //4008MD
        DS4008HS_BOARD		=18, //4008HS
        DS4016HS_BOARD		=19, //4016HS

        DS4108HCV_BOARD		=20, //4108HCV
        DS4116HCV_BOARD		=21, //4116HCV
        DS5016HC_BOARD		=22, //5016HC

        DS4208HFV_BOARD		=23, //4208HFV
        DS4216HC_BOARD		=24, //4216HC
        DS4216HFV_BOARD		=25, //4216HFV

        DS5008HF_BOARD		=26, //5008HF
        DS5116HF_BOARD		=27, //5116HF

        DS5216HC_BOARD		=28, //5216HC
        DS5208HF_BOARD		=29, //5208HF
        DS5216HF_BOARD		=30, //5216HF

        DS4101HD_BOARD		=31, //4101HD
        DS4102HD_BOARD		=32, //4102HD
        DS4104HD_BOARD		=33, //4104HD

        DS4002MD_PLUS_BOARD =34, //4002MD+
        DS4004MD_PLUS_BOARD =35, //4004MD+

        DS4204HFV_BOARD		=36, //4204HFV
        DS4308HCV_BOARD		=37, //4308HCV
        DS4308HFV_BOARD		=38, //4308HFV
        DS4316HCV_BOARD		=39, //4316HCV
        DS4316HFV_BOARD		=40, //4316HFV
        DS4304HD_BOARD		=41, //4304HD
        DS4304HFH_BOARD     =42, //4304HFH
        DS4304HFV_BOARD     =43, //4304HFV
        DS4302HFH_BOARD     =44, //4302HFH
        DS5316HF_BOARD      =45, //5316HF
        DS4308HW_BOARD      =46, //4308HW
        DS4316HW_BOARD      =47, //4316HW
        DS4308MD_BOARD      =48, //4308MD
        UNKNOWN_BOARD_TYPE  =0xffffffff,
}BOARD_TYPE;

typedef struct tagNET_DVR_CODECARD_ABILITY /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(��BOARD_TYPE�е�ö��)
    BYTE byCodeNums;      //����ͨ����
    BYTE byDispNums;      //��ʾͨ����
    BYTE byCodeStartIdx;     //�׸�����ͨ�������б���ͨ���е�����
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byRes1[3];
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT�е�ö��)
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY,*LPNET_DVR_CODECARD_ABILITY;

#define		MAX_CODE_CARD_NUM			8   //��������뿨��
typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;		/*��ʾͨ�����ͣ�0-BNC��1-VGA��2-HDMI��3-DVI*/ //�˲���ֻ�ܻ�ȡ
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL��0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //�ֱ���
    DWORD  dwWindowMode;		/*����ģʽ��֧��ģʽ����������ȡ*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG,*LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //��ʾͨ����
    DWORD  dwCodeChan; //����ͨ����
    DWORD  dwWinNum;   //���ںţ���1��
    BYTE   byEnableAudio; //������Ƶ��0-�أ�1-��
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO,*LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//��ʾͨ����
    DWORD dwWinNum;     //���ںţ���1��ʼ
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO,*LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;         //�ṹ��С
    DWORD  dwCodeChan;      /*����ͨ����*/
    BYTE   byDisplay;              /*�Ƿ������0-��1-��*/
    BYTE   byAudio;			/*��Ƶ�Ƿ���,0-��1-��*/
    BYTE   byRes[30];
}NET_DVR_WINDOW_STATUS,*LPNET_DVR_WINDOW_STATUS;

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD 	dwSize;      		//�ṹ���С
    BYTE 	byPercentage;    	//�ٷֱȣ�ȡֵ��Χ[0,100]
    BYTE  	byRes[31];          //����
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD 			dwSize; 			//�ṹ���С
    NET_DVR_STREAM_INFO struStreasmInfo; 	//��ID
    DWORD  			dwBeginTime;    //¼���ܵĿ�ʼʱ��
    DWORD 			dwEndTime;		//¼���ܵĽ���ʱ��
    BYTE  			byRes[32];       //����
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO		struStreamInfo;
    DWORD					dwCmdType; 						//�ⲿ��������
    DWORD					dwRecordTimeLen;				//¼�����ʱ�䣬��λ����
    BYTE					byEventID[MAX_EVENTID_LEN];		//�¼�ID����Ϊ������Ϣ
    BYTE					byRes[128];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE				byFileName[NAME_LEN]; 	// ¼���ļ�����Э��ֻ��32���ļ���
    DWORD				dwLockDuration;			// �����ʱ��,��λ�룬0xffffffff��ʾ������
    BYTE				byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD					dwSize;
    NET_DVR_STREAM_INFO		struStreamInfo;
    DWORD					dwStreamType; //�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    BYTE					byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD							dwSize;
    DWORD							dwStreamType;		//�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    NET_DVR_COMPRESSION_INFO_V30	struStreamPara;		//����ѹ������
    BYTE							byRes[80];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯  12-�����쳣 */
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;    /*��λ,��0λ��Ӧ��0������˿�,dwAlarmTypeΪ0ʱ��Ҫ����*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*��λ,��0λ��Ӧ��0������˿�, */
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*��λ,��0λ��Ӧ��0��ͨ��*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; // ID��Ϣ
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*��λ,0x2��ʾ��1ͨ������1λ��Ӧ��1��ͨ��(��ͨ��1��ʼ)��dwAlarmTypeΪ2��3, 6��9��10ʱ��Ҫ����, */
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*��λ,��0λ��Ӧ��0��Ӳ��,dwAlarmTypeΪ1,4,5ʱ��Ҫ����*/
            BYTE byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;

typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD 	struStruceHead;
    DWORD 			dwPackageInterval;    // ���ʱ���� ��ʱ�䵥λ������
    BYTE  			byRes[32];       		// ����
}NET_DVR_RECORD_PACK,*LPNET_DVR_RECORD_PACK;

#define NET_DVR_FIND_NAS_DIRECTORY     6161        //����NASĿ¼
#define NET_DVR_NAS_FINDING       0   //���ڲ���
#define NET_DVR_NAS_RECV          1   //�������
#define NET_DVR_NAS_OVER          2   //���ҽ���
#define NET_DVR_NAS_EXCEPTION     3   //�����쳣
typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR    		  struIP;     	// IP��ַ
    WORD  			wPort;      // IP�˿�
    BYTE    			byRes[10];  // �����ֽ�
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;


typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // ���ص��ļ�Ŀ¼
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD 	struStruceHead;
    BYTE  			byWD1Enable;     	//WD1ʹ�ܿ��� 0 �ر� 1 ����
    BYTE 				byRes[31];      //����
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;

typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD 	struStruceHead;
    BYTE				byEnableFTP;		    /*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE				byProtocolType;	 	    /*Э������ 0-FTP��1-SFTP*/
    WORD				wFTPPort;			    /*�˿�*/
    union
    {
        struct
        {
            BYTE			szDomain[64];	    //��������ַ������ʹIPv4 IPv6��������
            BYTE			byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;             /*IP��ַ:IPv4 IPv6��ַ, 144�ֽ�*/
        }struAddrIP;
    }unionServer;  //ʹ��������ṹ����ֹ����IP��ַ������������
    BYTE				szUserName[32];		    /*�û���*/
    BYTE				szPassWORD[16];		    /*����*/
    BYTE				szTopCustomDir[64];	    /*�Զ���һ��Ŀ¼*/
    BYTE				szSubCustomDir[64];	    /*�Զ������Ŀ¼*/
    BYTE				byDirLevel;	            /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,	1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    BYTE 				byTopDirMode;	        /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��
                                                0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x6-ʹ���Զ��� ,0x7=Υ������,0x8=����,0x9=�ص�*/
    BYTE 				bySubDirMode;           /*����Ŀ¼��0x1=ʹ��ͨ����,0x2=ʹ��ͨ���� 0x3=ʹ��ʱ��(������),
                                                0x4=ʹ�ó�����,0x5-ʹ���Զ���, 0x6=Υ������,0x7=����,0x8=�ص�,0x9 = ��λ���*/
    BYTE				byType;			        /* 0-����������1-��������*/
    BYTE                byEnableAnony;          /*�������� 0-�� 1��*/
    BYTE                byAddresType;           /*0 ʹ��IPV4��IPV6  1- ʹ������*/
    BYTE				byFTPPicType;           //0-������1-ͣ����ץ��ͼƬ�������
    BYTE 	            byPicArchivingInterval; //ͼƬ�鵵���[1~30],0��ʾ�ر�
    NET_DVR_PICTURE_NAME_EX	 struPicNameRule;   /* ͼƬ�������:
    byFTPPicType ==1��ʱ��,�������ڵ����������ͣ����ץ��ͼƬ�������*/
    BYTE                byPicNameRuleType;      //ͼƬ����������ͣ�0~Ĭ�����ͣ�1~ͼƬǰ׺����(����struPicNameRule�е�byPicNamePrefix�ֶ�)
    BYTE 				byRes[203];             /*����*/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE	byType;  // 0-����������1-��������
    BYTE	byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

//FTP���������Բ���ṹ��
typedef struct
{
    DWORD 	dwSize;
    BYTE	byEnableFTP;		    /*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE	byProtocolType;	 	    /*Э������ 0-FTP��1-SFTP*/
    WORD	wFTPPort;			    /*�˿�*/
    union
    {
        BYTE	byRes[144];
        struct
        {
            BYTE	szDomain[MAX_DOMAIN_NAME];	    //��������ַ������ʹIPv4 IPv6��������
            BYTE	byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;             /*IP��ַ:IPv4 IPv6��ַ, 144�ֽ�*/
        }struAddrIP;
    }unionServer;  //ʹ��������ṹ����ֹ����IP��ַ������������

    BYTE	szUserName[NAME_LEN];		    /*�û���*/
    BYTE	szPassWORD[PASSWD_LEN];		    /*����*/
    BYTE	szTopCustomDir[MAX_CUSTOM_DIR];	    /*�Զ���һ��Ŀ¼*/
    BYTE	szSubCustomDir[MAX_CUSTOM_DIR];	    /*�Զ������Ŀ¼*/
    BYTE	byDirLevel;	            /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,	1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
                                    BYTE	byTopDirMode;	        /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��
                                                                    0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x6-ʹ���Զ��� ,0x7=Υ������,
                                    0x8=����,0x9=�ص�*/
                                    BYTE	bySubDirMode;           /*����Ŀ¼��0x1=ʹ��ͨ����,0x2=ʹ��ͨ���� 0x3=ʹ��ʱ��(������),
                                                                    0x4=ʹ�ó�����,0x5-ʹ���Զ���, 0x6=Υ������,0x7=����,0x8=�ص�,
                                    0x9 = ��λ���*/
                                    BYTE	byType;			        /* 0-����������1-��������*/
                                    BYTE	byEnableAnony;          /*�������� 0-�� 1��*/
                                    BYTE	byAddresType;           /*0 ʹ��IPV4��IPV6  1- ʹ������*/

                                    BYTE	byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

//���������Խṹ��
typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD	dwSize;
    union
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA	struNtpPara;					/*NTP���������Բ���80�ֽ�*/
            BYTE	byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40	struNasPara;   /*NAS���������Բ���480�ֽ�*/
            BYTE	byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA	struFtpPara;   /*FTP���������Բ���528�ֽ�*/
            BYTE	byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30	struEmailPara;			/*Email���������Բ���660�ֽ�*/
            BYTE	byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR	struIp;							/*IP��ͻ���Բ���24�ֽ�*/
            BYTE	byRes1[716];
        }struIpPara;
        struct
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //�˿ں�
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //�û���
            char  szPassword[CLOUD_PASSWD_LEN/*48*/]; 	// ����
            NET_DVR_POOLPARAM  struPoolInfo[16];// ����0��ʾ����ͼƬ��ݳأ�����1��ʾΥ��ͼƬ��ݳأ�����2��ʾ���������ݳأ�IPC/D��
            BYTE byRes1[486];
        }struCloudStoragePara;
        struct
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];
            BYTE byRes1[708];
        }struPhoneNumPara;//���Ų���
    }unionServerPara;
    BYTE byRes2[800];
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO  //��ȡGOP������Ϣ�ṹ��,��������ʱʹ��
{
    DWORD	  dwSize;  		//�ṹ���С
    LONG      lChannel;       //ͨ����
    NET_DVR_TIME_EX   struStartTime;    //��ʼʱ��
    NET_DVR_TIME_EX   struEndTime;     //����ʱ��
    BYTE                 byRes[256];      // �����ֽ�
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;    //Gop��Ϣʱ���
    DWORD         dwDuration;    //��Ϣ����ʱ��
    DWORD         dwDataSize;     //ָ��pBuf��С
    BYTE          byRes[128];
    char* pBuf;//Gop��Ϣ��
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK   //���������Ϣ����
{
    DWORD       dwSize;                 //�ṹ���С
    NET_DVR_TIME_V30  struTime;         //��ʼʱ��,���������Ϊ����Ԫ���ʱ����ʾ�Ŀ�ʼʱ�䣬��Ϊ����ͼʱ����ʾ����ͼƬʱ��
    DWORD       dwDuration;             //��Ϣ����ʱ�䣬�����������Ϊ����Ԫ���ʱ��Ч
    DWORD       dwMetaDataSize;         //���Դ�Ĵ�С
    DWORD       dwPicDataSize;          //ͼƬ��ݴ�С
    char*		pMetaDataBuffer;        //����Ԫ��ݻ�����
    char*       pPicDataBuf;            //ͼƬ������
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;
    BYTE   byRes1[3];
    DWORD  dwWallNum;//����ǽ�����
    //�����Ϊ��׼��������128��128������Ⱥ͸߶�ֵ�������ã���Ϊ��׼ֵ
    NET_DVR_RECTCFG struRectCfg;
    BYTE	byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

/*������Ϣ*/
typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//���ں�
    DWORD dwLayerIndex;//�������Ӧ��ͼ���
    NET_DVR_RECTCFG struWinPosition;//Ŀ�Ĵ���(�����ʾǽ)
    DWORD dwDeviceIndex;//�ֲ�ʽ�����������豸���
    WORD wInputIndex;//�����ź�Դ
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD	dwSize;
    BYTE	byWallNo;	//����ǽ��ţ���1��ʼ
    BYTE	bySceneNo;	//�������
    BYTE	byRes1[2];
    DWORD	dwDeviceID;	//�ֲ�ʽ���豸ID
    DWORD	dwWindowNo;	//�������/�ź�Դ���
    BYTE	byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //ʹ��͸���ȣ�0-�أ���0-��
    BYTE  byWinMode;//���ڷ���ģʽ����������ȡ
    BYTE  byEnableSpartan;//����ʹ�ܣ�0-�أ�1-��
    BYTE  byDecResource;  //Ϊ���ڷ���Ľ�����Դ��1-D1,2-720P,3-1080P
    BYTE  byRes[32];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD	dwSize;
    BYTE	sSceneName[NAME_LEN];	//�������
    BYTE	byEnable;				//�����Ƿ���Ч��0-��Ч��1-��Ч
    BYTE	bySceneIndex;			//�����ţ�ֻ�ܻ�ȡ����ȡ���г���ʱʹ�øò���
    BYTE	byRes [78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //���ں�
    DWORD dwSubWinNum;//�Ӵ��ں�
    DWORD dwWallNo; //ǽ��
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO,*LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize ;
    BYTE  byDecodeStatus; /*��ǰ����״̬:0:δ����,1 :������*/
    BYTE  byStreamType;    /*��������*/
    BYTE  byPacketType;    /*���ʽ*/
    BYTE  byFpsDecV; /*��Ƶ����֡��*/
    BYTE  byFpsDecA; /*��Ƶ����֡��*/
    BYTE  byRes1[7];
    DWORD dwDecodedV; /*�������Ƶ֡*/
    DWORD dwDecodedA; /*�������Ƶ֡*/
    WORD  wImgW; /*��ǰ����Դ��ͼ���С*/
    WORD  wImgH;
    BYTE  byStreamMode ; //����Դ(�˲������Ƶ�ۺ�ƽ̨��Ч)��1-���磬2-�ۺ�ƽ̨�ڲ�������ϵͳ,0xff-��Ч
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //���ں�
    DWORD dwSubWinIndex;//�Ӵ��ں�
    BYTE  byType ;//��Դ���ͣ�1-���룬2-����
    BYTE  byWallNo ; //ǽ��
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize ;
    BYTE   sAddress[MAX_DOMAIN_NAME];//ip��ַ����������
    WORD   wDVRPort;			 	/* �˿ں� */
    WORD   wChannel;				/* ͨ���� */
    BYTE   sUserName[NAME_LEN];	/* ��������½�ʺ� */
    BYTE   sPassword[PASSWD_LEN];	/* ����������� */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO,*LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //�ֱ���
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat; //��Ƶ��ʽ����VIDEO_STANDARD
    BYTE  byDisplayMode;/*�������ģʽ,1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��0xff-��Ч*/
    BYTE  byBackgroundColor; //����ɫ��0-��Ч����֧�ֱ���ɫ��1-�죬2-�̣�3-����4-�ƣ�5-�ϣ�6-�࣬7-�ڣ�8-��
    BYTE  byRes1[1];     //����
    WORD  wLEDWidth;     //LED������ֱ��ʿ�
    WORD  wLEDHeight;    //LED������ֱ��ʸ�
    BYTE  byRes2[56];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

#define 	MAX_UNITEDMATRIX_NUM		8  //�����������Ƶ�ۺ�ƽ̨����

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    //ƽ̨�ţ�0��ʾ�޴�ƽ̨
    DWORD		dwSequence;
    BYTE		sAddress[MAX_DOMAIN_NAME];//ip��ַ����������
    WORD		wSubMatrixPort;        /*��ϵͳ�˿ں�*/
    BYTE		byRes1[6];
    BYTE		sUserName[NAME_LEN];	/*�û���*/
    BYTE		sPassword[PASSWD_LEN];	/*���� */
    BYTE		byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO,*LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //��Ƶ�ۺ�ƽ̨��Ϣ
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO,*LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD dwSize;
    BYTE  byTransparency;//͸����,0-100,0Ϊ��͸��
    BYTE  byWinStaticMode; //���ڽ���ֹͣ��ʾģʽ��1-������2-��ʾ���һ֡ͼ��
    BYTE  byRes[62];
}NET_DVR_WALL_CFG,*LPNET_DVR_WALL_CFG;

typedef	struct tagNET_DVR_LEDDISPLAYINFO
{
    DWORD            dwSize;
    BYTE 		     byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    BYTE		byRes1[3];
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME/*64*/];//��������ַ������
            BYTE			byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR 	struIp;/*IP��ַ*/		//IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64
    char		szDisplayInfo[MAX_LEDDISPLAYINFO_LEN/*1024*/];
    BYTE		byRes[128];
}NET_DVR_LEDDISPLAYINFO,*LPNET_DVR_LEDDISPLAYINFO;


typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD dwSize;
    BYTE  byLowLightLimt; /* ���նȵ��ӿ���: 0-�أ�1-�� */
    BYTE  byLowLightLimtLevel;
    /*���0-�أ�1-�����*2��2-�����*3��3-�����*4��4-�����*6��5-�����*8��6-�����*12��7-�����*16��
    8-�����*24��9-�����*32��10-�����*48��11-�����*64��12-�����*96��13-�����*128��14-�����*256��
    15-�����*512, 16-�����*1.25, 17-�����*1.5 */
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD dwSize;
    BYTE  byFocusMode;  /* �۽�ģʽ��0-�Զ���1-�ֶ���2-���Զ� */
    BYTE  byAutoFocusMode; /* �Զ��۽�ģʽ��0-�أ�1-ģʽA��2-ģʽB��3-ģʽAB��4-ģʽC �Զ��۽�ģʽ����Ҫ�ھ۽�ģʽΪ�Զ�ʱ����ʾ*/
    WORD  wMinFocusDistance; /* ��С�۽����룬��λCM,  0-�Զ���0xffff-����Զ */
    BYTE  byZoomSpeedLevel;  /* �䱶�ٶȣ�Ϊʵ��ȡֵ��1-3 */
    BYTE  byFocusSpeedLevel; /* �۽��ٶȣ�Ϊʵ��ȡֵ��1-3 */
    BYTE  byOpticalZoom;		/* ��ѧ�䱶��0-255 */
    BYTE  byDigtitalZoom;		/* ���ֱ䱶��0-255 */
    float fOpticalZoomLevel; /* ��ѧ�䱶(����ֵ) [1,32], ��С���0.5 ���ڲ��豸������ʱ��*1000 */
    DWORD dwFocusPos;/* dwFocusPos ��focusֵ���۽�ֵ������ΧΪ[0x1000,0xC000]�����ֵ��sony���ֵ��ʹ�����ֵ��Ϊ�˶���ͳһ����֤��ͬ�ľ�ͷ����focusֵ��ת���������Χ�� (�ֶ��۽�ģʽ����Ӧ��)*/
    BYTE  byRes[56];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;  /* �����������-����ģʽ��0-�Զ���1-�ֶ� */
    BYTE  byIrBrightness;	/* �����������-�������ȣ�0-100 */
    BYTE  byIrSensitivity;	/* �����������-����������ȣ�0-100 */
    BYTE  byIrTrigMode; /* ����ģʽ 0-��о������1-�������� �Զ�ģʽ����Ч*/
    BYTE  byIrBrightnessLimit;/* �������� ����ֵΪ80����ʾ�������ǵ�ǰ����Ƶ�����Ϊԭ�ȸ���Զ����Լ����������ֵ��80% �Զ�ģʽ����Ч*/
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int   iIrisSet;	/* ��Ȧ��Ϊʵ��ȡֵ*100��ֵ��0-�� */
    int   iGainSet;	/* �������棬�عⲹ����Ϊʵ��ȡֵ*100��ֵ���п����Ǹ�ֵ */
    int   iGainLimit;/* �������ƣ��عⲹ����Ϊʵ��ȡֵ*100��ֵ���п����Ǹ�ֵ */
    int   iExposureCompensate; /* �عⲹ����Ϊʵ��ȡֵ*100��ֵ������1050���10.5dB, -750���-7.5dB */
    BYTE  byExposureModeSet;	/* �����ع�ģʽ,0-�ֶ�ģʽ��1-�Զ��ع⣬2-��Ȧ���ȣ�3-�������ȣ�4-�������� */
    BYTE  byShutterSet;         /* ���ţ�0-�أ�1-�Զ�x1��2-�Զ�x2��3-�Զ�x4��4-�Զ�x8��5-�Զ�x16��6-�Զ�x32��7-�Զ�x64��8-�Զ�x128��9-1/1��10-1/2��
    11-1/3��12-1/4��13-1/6��14-1/8��15-1/12��16-1/15��17-1/25��18-1/30��19-1/50��20-1/60��21-1/75��
    22-1/90��23-1/100��24-1/120��25-1/125��26-1/150��27-1/180��28-1/200��29-1/215��30-1/250��31-1/300��
    32-1/350��33-1/425��34-1/500��35-1/600��36-1/725��37-1/1000��38-1/1250��39-1500,40-1/1750��41-1/2000��
    42-1/2500��43-3000,44-1/3500��45-1/4000��46-1/6000��47-1/10000��48-1/30000��49-1/100000,50-1/175��
    51-1/195��52-1/225��53-1/230 */
    BYTE  byImageStabilizeLevel;  /* �������ȼ�: 0-3 */
    BYTE  byCameraIrCorrect; /* ����У��: 0-�Զ���1-����2,�� */
    BYTE  byHighSensitivity; /* ������������: 0-�أ�1-�� */
    BYTE  byInitializeLens;  /* ��ʼ����ͷ: 0-�أ�1-�� */
    BYTE  byChromaSuppress; /* ɫ������ :0-255*/
    BYTE  byMaxShutterSet;	 //������ֵ;����ֵ��byShutterSet��ͬ(���Զ��ع⡢��Ȧ����ģʽ����Ч)
    BYTE  byMinShutterSet;	 //��С����ֵ;����ֵ��byShutterSet��ͬ(���Զ��ع⡢��Ȧ����ģʽ����Ч)
    BYTE  byMaxIrisSet; //����Ȧ����ֵ(�Զ��ع⡢��������ģʽ) [0,100] ;
    BYTE  byMinIrisSet;	//��С��Ȧ����ֵ(�Զ��ع⡢��������ģʽ) [0,100] ;
    BYTE  byRes[61];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD		dwSize;
    BYTE		byValid;			// ��ЧʱΪ���ã���ЧʱΪɾ��
    BYTE		byRes1[3];
    BYTE	    sMatrixName[NAME_LEN/*32*/];       // ��������
    DWORD  	    dwMatrixID;		// �����ID�ţ�ֻ�ܻ�ȡ
    WORD		wMatrixInputChanNum;				// ���������ͨ����Ŀ
    WORD		wMatrixOutputChanNum;			// ��������ͨ����Ŀ
    WORD   	    wMatrixOutputChanRef[MAX_CAM_COUNT];   //// �豸����;�������İ󶨹�ϵ�������±��ʾ�������豸����ͨ���ţ�Ԫ�ص�ֵ��ʾ��������ͨ���ţ�
    //Ԫ��ֵ����0 ��ʾ�󶨾������ͨ����Ԫ��ֵΪ0ʱ��ʾ���󶨣���Ļ������Ϊ��Ļ����ź;�������İ󶨹�ϵ
    BYTE		byMatrixChanType;// �����ͨ������1-BNC��2-VGA��3-RGB��4-DVI
    BYTE		byMatrixProtocol;	// ��������Э��1��ZT1.0��2.ZT2.0��3.Extron��4.Creator
    BYTE		byMatrixType;		//1-ģ�����2-���־���
    BYTE		byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE		byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;


#define MAX_INPUTNUMS 1024
#define MAX_OUTPUTNUMS 256
typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE byEnable;
    BYTE byRes1[3];
    DWORD dwDeviceIndex;//�ֲ�ʽ�����������豸���
    WORD wInputIndex;//�����ź�Դ
    BYTE  byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE	byEnable;
    BYTE	byWallNo;		//ǽ�ţ���1��ʼ
    BYTE	byRes1[2];
    DWORD	dwOutputIndex;	//�����ʾ�������
    BYTE	byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM,*LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD   dwSize;
    BYTE	sUserName[NAME_LEN];			// �û������16�ֽ�
    BYTE	sPassWord[PASSWD_LEN];		// ����
    NET_DVR_IPADDR	struUserIP;	// �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ)
    BYTE	byMacAddr[MACADDR_LEN];			// �����ַ
    BYTE	byPriority;		// ���ȼ���1-����Ա��2-����Ա ������Ա�����κ�Ȩ�ޣ�����Աû��"�����û�"��Ȩ��
    BYTE	byRes1;
    DWORD	dwRight;/*Զ�̲���Ȩ�ޣ���λ��ʾ��0-��֧�֣�1-֧�֣���32λ����Ȩ������*/
    //bit0-��ȡ���û����
    //bit1-��ʾ������
    //bit2-���ڹ���
    //bit3-�ź�Դ����
    //bit4-���ֹ���
    //bit5-Ԥ������
    //bit6-��ͼ����
    //bit7-OSD����
    //bit8-����Ȩ��
    //bit9-��������
    //bit10-Զ����
    //bit11-�ָ�Ĭ������
    //bit12-���뵼�����������ļ�
    //bit13-��־��ѯ
    //bit14-Զ������
    //bit15-��Ļ�������
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //��Ļ��������
	BYTE   byWallNo;	//������Ļ���������ǽ�ţ���ֻ֧�ֵ�ǽ���豸�����ֶ���Ч
	BYTE   byRes[107];				/* ���� */
} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{
    BYTE    byValid; //�Ƿ����ã�0-��1-��
    BYTE	byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP��������
    WORD	wDevPort;			/*��ý��������˿�*/
    BYTE	byTransmitType;		/*����Э������ 0-TCP��1-UDP*/
    BYTE	byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

//�豸ͨ����Ϣ
typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];	//�豸����
    WORD 	wDVRPort;			 	//�˿ں�
    BYTE 	byChannel;				//ͨ����
    BYTE	byTransProtocol;		//����Э������0-TCP��1-UDP
    BYTE	byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE	byFactoryType;			/*ǰ���豸��������,ͨ��ӿڻ�ȡ*/
    BYTE	byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ�����Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE	bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE	byResolution;	//; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã��������������ݸò�����������Դ
    BYTE    byUseZeroChan; //�Ƿ�ʹ����ͨ����0-��1-��
    BYTE	byRes;
    BYTE	sUserName[NAME_LEN];	//��������½�ʺ�
    BYTE	sPassword[PASSWD_LEN];	//�����������
}NET_DVR_DEV_CHAN_INFO_V41,*LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE    byChanType;              //ͨ�����ͣ�0-��ͨͨ��,1-��ͨ��,2-��ID,3-��������Դ��4-������������ͨ����5-ƴ��ͨ��
    BYTE    byStreamId[STREAM_ID_LEN];//��ID
    BYTE    byRes1[3];
    DWORD   dwChannel;  //ͨ���ţ�ͨ������Ϊ��ͨͨ������ͨ������������Դ��������������ͨ��ʱ����ֶ�
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];	//�豸����
    WORD 	wDVRPort;			 	//�˿ں�
    BYTE 	byChannel;				//ͨ����,dwChannel��Ϊ0ʱ���ֶ���Ч
    BYTE	byTransProtocol;		//����Э������0-TCP��1-UDP
    BYTE	byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE	byFactoryType;			/*ǰ���豸��������,ͨ��ӿڻ�ȡ*/
    BYTE	byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ�����Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE	bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE	byResolution;	//; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã��������������ݸò�����������Դ
    BYTE	byRes[2];
    BYTE	sUserName[NAME_LEN];	//��������½�ʺ�
    BYTE	sPassword[PASSWD_LEN];	//�����������
}NET_DVR_DEV_CHAN_INFO_EX,*LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{
    BYTE   byValid; //�Ƿ����ã�0-��1-��
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP��������
    WORD   wDevPort;			/*��ý��������˿�*/
    BYTE   byTransmitType;		/*����Э������ 0-TCP��1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER,*LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];	//����(IPServer��hiDDNSʱ�������кŻ��߱���)
    BYTE   byTransProtocol;		//����Э������0-TCP��1-UDP, 2-MCAST
    BYTE   byTransMode;			//��������ģʽ 0�������� 1��������
    BYTE   byDdnsType;         //������������ͣ�0-IPServer 1��Dyndns 2��PeanutHull(�����)��3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS��������ַ
    WORD   wDdnsPort;			 	//DDNS�������˿ں�
    BYTE   byChanType;              //0-��ͨͨ��,1-��ͨ��,2-��ID
    BYTE   byFactoryType;			//ǰ���豸��������,ͨ��ӿڻ�ȡ
    DWORD  dwChannel; //ͨ����
    BYTE   byStreamId[STREAM_ID_LEN]; //��ID
    BYTE   sUserName[NAME_LEN];	//��������½�ʺ�
    BYTE   sPassword[PASSWD_LEN];	//�����������
    WORD   wDevPort;				//ǰ���豸ͨ�Ŷ˿�
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO,*LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER	struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX			    struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX,*LPNET_DVR_DEC_STREAM_DEV_EX;


//DDNS��ʽȡ��
typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV,*LPNET_DVR_DEC_DDNS_DEV;

typedef union tagNET_DVR_DEC_STREAM_MODE
{
    NET_DVR_DEC_STREAM_DEV_EX struDecStreamDev;
    NET_DVR_PU_STREAM_URL struUrlInfo;
    NET_DVR_DEC_DDNS_DEV struDdnsDecInfo;
    BYTE byRes[300];
}NET_DVR_DEC_STREAM_MODE,*LPNET_DVR_DEC_STREAM_MODE;

typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD dwSize;
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ��̬����������豸ȡ��*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
    BYTE  byRes2[64];
}NET_DVR_PU_STREAM_CFG_V41,*LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE byEnable; //�Ƿ����ã�0-��1-��
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ��̬����������豸ȡ��*/
    BYTE byRes[2];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
}NET_DVR_MATRIX_CHAN_INFO_V41,*LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD							dwSize;
    DWORD							dwPoolTime;		/*��Ѳ���*/
    NET_DVR_MATRIX_CHAN_INFO_V41	struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE               			byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_V41,*LPNET_DVR_MATRIX_LOOP_DECINFO_V41;

typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD	dwSize;
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ��̬����������豸ȡ��*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
    DWORD	dwPlayMode;		/* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;		/* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;		/* ��ʱ��ط�ֹͣʱ�� */
    BYTE    sFileName[128];		/* ���ļ��ط��ļ��� */
    DWORD   dwGetStreamMode;	/*ȡ��ģʽ:1-������2-����*/
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE	byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE	byDevAddress[MAX_DOMAIN_NAME];	/*�豸IP��ַ*/
    WORD	wDevPort;       //�豸�˿�
    BYTE 	byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];	/*DDNS����*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];	/*�豸��ַ*/
    BYTE byDdnsType; //������������ͣ�0-IPServer 1��Dyndns 2��PeanutHull(�����)��//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //�豸�˿�
    WORD wDdnsPort; //����������˿�
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;

typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD	dwSize;
    DWORD	dwDecChannel;  //����ͨ����
    BYTE	byAddressType;  //�豸��ַ���ͣ�0-IP��1-DDNS
    BYTE	byChannelType;  //ͨ�����ͣ�0-��ͨͨ����1-��ͨ����2-��ID
    BYTE	byres[2];
    BYTE	sUserName[NAME_LEN];		/* �û��� */
    BYTE	sPassword[PASSWD_LEN];		/* ���� */
    DWORD	dwChannel;			/* �豸ͨ���� */
    BYTE	byStreamId[STREAM_ID_LEN];  //��ID,�˲�����ͨ������Ϊ��IDʱ��Ч
    DWORD	dwPlayMode;   	/* 0�����ļ� 1����ʱ��*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;

    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //��ʱ��ط�ʱ�ļ���Ϣ
        char sFileName[128];	//���ļ���ط�ʱ�ļ���Ϣ
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

typedef struct tagNET_DVR_DISPLAY_EFFECT_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR  struColor;      //��ʾ��ز���/
    BYTE byRes[32];
}NET_DVR_DISPLAY_EFFECT_CFG,*LPNET_DVR_DISPLAY_EFFECT_CFG;

//��ȡ����״̬
typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD		dwSize;
    DWORD		dwTrunkID;	//����ID
    WORD		wReserveUserID;	//Ԥ�����û�ID�� 1~256 ��0��ʾ�ͷ�Ԥ��
    BYTE		byStatus;  //1-���У�2-ռ�ã�3-���� */
    BYTE		byRes1;
    BYTE  		byUserId[256];  //�����±��ʾ�û�ID�ţ�����Ԫ�ص�ֵ��ʾ�Ƿ�ʹ�ø��ߡ��磺byUserID[0] ��ֵΪ1����ʾ�û�IDΪ0���û�����ʹ�ã�byUserID[0] ��ֵΪ0��ʾ�û�IDΪ0���û�û��ʹ����������
    BYTE	   	byRes2[64];
}NET_DVR_TRUNK_USE_STATE,  *LPNET_DVR_TRUNK_USE_STATE;


//PTZ���Ʋ���
typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD	dwSize;
    DWORD	dwCtrlDelayTime;		//PTZ���Ƴ���ʱ�䣬ָPTZ���ƺ���dwCtrlDelayTimeʱ���ڣ�����ͬ�����ͼ����û����������Ч����λ����
    BYTE	byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

//��ʾ·��
#define		MAX_MATRIX_CASCADE		32
typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD		dwSize;
    DWORD	   	dwCamNo;
    DWORD   	dwMonNo;
    DWORD		dwSubWin;
    DWORD		dwUserId;
    DWORD   	dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId��Ա��Ӧ���������1��32����CAM�˿�ʼ��trunkId[0]��ʾ��һ��������trunkId[1]��ʾ�ڶ�������, trunkId[i] = 0 ��ʾ�޸���
    BYTE		byRes[64];      /* Ԥ�� */
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;


//��ȡPTZ״̬
typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD		dwSize;
    DWORD		dwUserID;	//1~256��0 ��ʾ���û�
    DWORD   	dwStatus;  	// PTZ����״̬0-ֹͣ��1-����
    DWORD		dwRestTime;  //ʣ��ʱ��
    BYTE		byRes[64];
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;

typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //����ģʽ��0-�����ų�����1-�����ų���
    BYTE  byRes[15];
}NET_DVR_SAFETYCABIN_WORK_MODE,*LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //���������ͣ�0-��������ͣ�1-Ļ��������
    BYTE  bySensitivity; //���������жȣ���Χ��0-100%
    BYTE  byDevUseTimeout; //������ʹ�ó�ʱʱ�䣬��λ����,��Χ��5-30��Ĭ�ϳ�ʱ15min,��ʱ��ͨ���ͨ���ϴ�����
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //Ļ��������̽����ʱʱ�䣬��λ���룬��Χ��0-10
    WORD  wCurtainResponseTime; //Ļ����״̬�仯��������Ӧʱ�䣬��λ���룬��Χ��0-300
    BYTE  byRes2[32];
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG,*LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD		dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //��������ַ
    BYTE  byRes[64];      //����
}NET_DVR_ETHERNET_IPV6_COND,*LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD		dwSize;
    BYTE  byState; //IPv6״̬��0-·�ɷ��䣬1-�Զ�����
    BYTE  byRes1[3];
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6��ַ
    BYTE  byRes[64];      //����
}NET_DVR_ETHERNET_IPV6_CFG,*LPNET_DVR_ETHERNET_IPV6_CFG;

typedef struct
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME,*LPNET_DVR_DAYTIME;

typedef struct
{
    NET_DVR_DAYTIME  struStartTime; //��ʼʱ��
    NET_DVR_DAYTIME  struStopTime; //����ʱ��
}NET_DVR_SCHEDULE_DAYTIME, *LPNET_DVR_SCHEDULE_DAYTIME;

typedef struct
{
    BYTE byObjectSize;//ռ�Ȳ���(0~100)
    BYTE byMotionSensitive; /*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byRes[6];
}NET_DVR_DNMODE, *LPNET_DVR_DNMODE;

typedef struct
{
    BYTE byAreaNo;//������(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;//��������������Ϣ(����) size = 16;
    NET_DVR_DNMODE  struDayNightDisable;//�ر�ģʽ
    NET_DVR_DNMODE  struDayModeParam;//����ģʽ
    NET_DVR_DNMODE  struNightModeParam;//ҹ��ģʽ
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;

typedef struct
{
    BYTE byDayNightCtrl;//��ҹ���� 0~�ر�,1~�Զ��л�,2~��ʱ�л�(Ĭ�Ϲر�)
    BYTE byRes[3];
    NET_DVR_SCHEDULE_DAYTIME struScheduleTime;//�л�ʱ��  16
    NET_DVR_MOTION_MULTI_AREAPARAM struMotionMultiAreaParam[MAX_MULTI_AREA_NUM];//���֧��24������
    BYTE byRes1[60];
}NET_DVR_MOTION_MULTI_AREA,*LPNET_DVR_MOTION_MULTI_AREA; //1328

typedef struct
{
    BYTE byMotionScope[64][96];		/*�������,0-96λ,��ʾ64��,����96*64��С���,Ŀǰ��Ч����22*18,Ϊ1��ʾ���ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;			/*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byRes[3];
}NET_DVR_MOTION_SINGLE_AREA, *LPNET_DVR_MOTION_SINGLE_AREA;

typedef struct
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //��ͨģʽ�µĵ�������
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //ר��ģʽ�µĶ���������
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct
{
    NET_DVR_MOTION_MODE_PARAM  struMotionMode; //(5.1.0����)
    BYTE byEnableHandleMotion;		/* �Ƿ����ƶ���� 0���� 1����*/
    BYTE byEnableDisplay;	/*�����ƶ���������ʾ��0-��1-��*/
    BYTE byConfigurationMode; //0~��ͨ,1~ר��(5.1.0����)
    BYTE byRes1; //�����ֽ�
    /* �쳣���?ʽ */
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //ʵ�ʴ����ı�������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    /*������¼��ͨ��*/
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];	 /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - dwRelRecordChan -1��Ч������м�����0xffffffff,�������Ч*/
    BYTE  byRes[128]; //�����ֽ�
}NET_DVR_MOTION_V40,*LPNET_DVR_MOTION_V40;

typedef struct
{
    DWORD dwEnableHideAlarm;				/* �Ƿ������ڵ�������0-��1-�������ȣ�2-�������ȣ�3-��������*/
    WORD wHideAlarmAreaTopLeftX;			/* �ڵ������x��� */
    WORD wHideAlarmAreaTopLeftY;			/* �ڵ������y��� */
    WORD wHideAlarmAreaWidth;				/* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;				/*�ڵ�����ĸ�*/
    /* �źŶ�ʧ����������� */
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*������������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE  byRes[64]; //����
}NET_DVR_HIDEALARM_V40,*LPNET_DVR_HIDEALARM_V40; //�ڵ�����

typedef struct
{
    DWORD dwEnableVILostAlarm;				/* �Ƿ������źŶ�ʧ���� ,0-��,1-��*/
    /* �źŶ�ʧ����������� */
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*������������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE	byVILostAlarmThreshold;	/*�źŶ�ʧ������ֵ����ֵ������ֵ����Ϊ�źŶ�ʧ��ȡֵ0-99*/
    BYTE	byRes[63]; //����
}NET_DVR_VILOST_V40,*LPNET_DVR_VILOST_V40;	//�źŶ�ʧ����

typedef struct
{
    NET_DVR_COLOR	  struColor[MAX_TIMESEGMENT_V30];/*ͼ�����(��һ����Ч�������������)*/
    NET_DVR_SCHEDTIME  struHandleTime[MAX_TIMESEGMENT_V30];/*����ʱ���(����)*/
}NET_DVR_VICOLOR, *LPNET_DVR_VICOLOR;

typedef struct
{
    DWORD  dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD  dwVideoFormat;	/* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL  */
    NET_DVR_VICOLOR struViColor;//	ͼ�����ʱ�������
    //��ʾͨ����
    DWORD  dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ�����,0-����ʾ,1-��ʾ
    WORD    wShowNameTopLeftX;				/* ͨ�������ʾλ�õ�x��� */
    WORD    wShowNameTopLeftY;				/* ͨ�������ʾλ�õ�y��� */
    //��˽�ڵ�
    DWORD  dwEnableHide;		/* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD  dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ
    WORD   wOSDTopLeftX;				/* OSD��x��� */
    WORD   wOSDTopLeftY;				/* OSD��y��� */
    BYTE    byOSDType;					/* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE    byDispWeek;				/* �Ƿ���ʾ���� */
    BYTE    byOSDAttrib;				/* OSD����:͸������˸ */
    /* 0: ����ʾOSD */
    /* 1: ͸������˸ */
    /* 2: ͸��������˸ */
    /* 3: ��͸������˸ */
    /* 4: ��͸��������˸ */
    BYTE    byHourOSDType;				/* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
    BYTE    byFontSize;      //16*16(��)/8*16(Ӣ)��1-32*32(��)/16*32(Ӣ)��2-64*64(��)/32*64(Ӣ) FOR 91ϵ��HD-SDI����DVR
    BYTE	byOSDColorType;	 //0-Ĭ�ϣ��ڰף���1-�Զ���
    BYTE    byAlignment;//���뷽ʽ 0-����Ӧ��1-�Ҷ���, 2-�����
    BYTE    byOSDMilliSecondEnable;//��Ƶ����ʱ��֧�ֺ��룻0~������, 1-����
    NET_DVR_VILOST_V40 struVILost;  //��Ƶ�źŶ�ʧ������֧���飩
    NET_DVR_VILOST_V40 struAULost;  /*��Ƶ�źŶ�ʧ������֧���飩*/
    NET_DVR_MOTION_V40 struMotion;  //�ƶ���ⱨ����֧���飩
    NET_DVR_HIDEALARM_V40 struHideAlarm;  //�ڵ�������֧���飩
    NET_DVR_RGB_COLOR	struOsdColor;//OSD��ɫ
    BYTE    byRes[124];
}NET_DVR_PICCFG_V40,*LPNET_DVR_PICCFG_V40;

typedef struct  //
{
    DWORD				   dwSize;
    BYTE   byWorkType;// 0-����Ӧ, 1-��ʱģʽ
    BYTE   byRes[3];
    //��ʱģʽ����
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;//��ҹ��ʱ�л�ģʽ(����ʱ��)
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam; //����Ӧ����
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;//�������
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;//ҹ�����
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG,*LPNET_DVR_ISP_CAMERAPARAMCFG;

typedef struct
{
    DWORD       dwSize;
    BYTE        byIrLampServer;//��������� 0�����ã�1������
    BYTE        bytelnetServer;//telnet���� 0�����ã�1������
    BYTE        byABFServer;//ABF���� 0�����ã�1������
    BYTE        byEnableLEDStatus;//״ָ̬ʾ�ƿ��� 0�����ã�1������
    BYTE        byEnableAutoDefog;//�Զ�������� 0�����ã�1������
    BYTE        byEnableSupplementLight;//����ƿ���0-���ã�1-����
    BYTE		byEnableDeicing;//����� 0-�رգ�1-����
    BYTE        byRes[249];
}NET_DVR_DEVSERVER_CFG,*LPNET_DVR_DEVSERVER_CFG;

typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD	   dwSize;
    BYTE	   byEnable;//28181Э��ʹ�� 0-�ر� 1-����
    BYTE       byTransProtocol;//����Э��:0-UDP��1-TCP��Ĭ��0-UDP
    WORD       wLocalSipPort;//1024-65535(IPC�豸��)
    char       szServerID[MAX_SERVERID_LEN];//������ID��64�ֽ��ַ���������
    char       szServerDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// ��������
    char       szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN] ;// SIP��������ַ֧�������IP��ַ
    WORD       wServerSipPort;//������SIP�˿ڣ�1024-65535
    BYTE       byProtocolVersion;//Э��汾 0-GB/T28181-2011(��֧��UDP),1-GB/T28181-2015(֧��TCP,UDP)
    BYTE       byRes3;
    char       szSipUserName[MAX_SERVERNAME_LEN];//SIP�û���ƣ�64�ֽ��ַ�(����SIP�ն�����IPC����ʱʹ��)
    char       szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];//SIP�û���֤ID��64�ֽ��ַ�
    char       szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];//SIP�û���֤���룺32�ֽ��ַ�(IPC�豸ע�ᵽSIP������ʱʹ��)
    DWORD      dwRegisterValid;//ע����Ч�ڣ���λ�룬Ĭ��3600��
    BYTE       byHeartbeatInterval;//����������λ�룬Ĭ��10�룻
    BYTE       byMaxHeartbeatTimeOut;//�������ʱ����Ĭ��3�Σ�
    BYTE       byStreamType;// ȡ������0����������1����������2��3����
    BYTE   	   byDeviceStatus; //�豸�Ƿ�����״̬��0-������1-���ߣ�2-����
    DWORD      dwRegisterInterval;//ע����:ע��ʧ�ܺ��ٴ�ע���ʱ����,��Χ60-600s��Ĭ��60s
    DWORD      dwAutoAllocChannelID ; //�Ƿ��Զ�����ͨ��ID,��λ��ʾ��0Ϊ�ֶ����ã�1Ϊ�Զ����䣬bit1-�Զ��������ͨ��ID,bit2-�Զ����䱨������ͨ��,bit3-�Զ��������ͨ��ID
    char       szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// �豸��
    BYTE       byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG,*LPNET_DVR_GBT28181_ACCESS_CFG;

//GBT28181Э����豸����ͨ������
typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD				   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];//�豸��Ƶͨ������ID��64�ֽ��ַ���������
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG,*LPNET_DVR_GBT28181_CHANINFO_CFG;

//GBT28181Э��ı�������ͨ������ �����ṹ
typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;//��������ͨ����
    BYTE  byRes[32]; //����
}NET_DVR_ALARMIN_INFO,*LPNET_DVR_ALARMIN_INFO;

//GBT28181Э��ı�������ͨ������ ���ýṹ
typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD				   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//�豸�����������ID��ÿһ·�������벻ͬ����20�ֽ��ַ���������
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG,*LPNET_DVR_GBT28181_ALARMINCFG;

typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD  wSetupHeight; //����߶�[0,20]����λ����
    BYTE  byLensType; //��ͷ�������ͣ�0-δ֪,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE  bySetupHeightUnit;// ����߶ȵ�λ0��M,1~CM
    DWORD dwSceneDis; //ͼ���±�Եλ�������֮���ˮƽ���룬��λ������
    float fPitchAngle;//������Ƕ�[-180��, 180��],
    float fInclineAngle;//�����б�Ƕ�[-180��,180��]
    float fRotateAngle;//�����ת�Ƕ�[-180��,180��]
    WORD  wVideoDetCoefficient; //��Ƶ����ϵ��[0,300](3.6����)
    BYTE  byErectMethod; //���跽ʽ0-��װ��1-��װ(3.6����)
    BYTE  byCameraViewAngle;//�����װ��Ұ�Ƕ�(0-��ֱ��1-��б��Ĭ��0-��ֱ)
    DWORD dwHorizontalDistance;//�����������ˮƽ���룺��Χ1-1000��Ĭ��30����λcm��ע�������Ƕ�Ϊ��бʱ������Ч
    BYTE  byDetailLensType;//��Χ1-100��Ĭ��28����λ0.1mm
    BYTE  byRes[3];
    float fHorFieldAngle; //���ˮƽ�ӳ��ǽǶ�[0��, 360��]��ץ�Ļ�
    float fVerFieldAngle; //���ֱ�ӳ��ǽǶ�[0��, 360��]��ץ�Ļ�
    BYTE  byRes1[24];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

//��ֹ���ڶβ���ṹ��
typedef struct tagNET_DVR_SCHEDDATE
{
    BYTE   byStartMonth;   //��ʼ���£�
    BYTE   byStartDay;     //��ʼ���գ�
    BYTE   byStopMonth;    //�����£�
    BYTE   byStopDay;      //�����գ�
}NET_DVR_SCHEDDATE,*LPNET_DVR_SCHEDDATE;

//ʱ���������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{
    NET_DVR_SCHEDTIME struTime;  //ʱ���
    BYTE byState;                //0�C�ر�, 1�C����
    BYTE byRes[11];              //����
} NET_DVR_OUTPUT_SCHEDULE ,*LPNET_DVR_OUTPUT_SCHEDULE;

//����ʱ������������
typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{
    BYTE                     byEnable;    //�Ƿ����ù���,0-��,1-��
    BYTE                     byRes1[3];   //����
    NET_DVR_SCHEDDATE        struDate;    //�������
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //���֧��8��ʱ��ε�ʱ�����
    BYTE                     byRes2[16];  //����
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

//ʱ������������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{
    DWORD  dwSize; //�ṹ���С
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //���֧��8��������εĹ�������
    BYTE   byRes[64];  //����
}NET_DVR_OUTPUT_SCHEDULE_RULECFG,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

//��ͨͳ�Ʊ�������
typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ý�ͨͳ�Ʊ����ϴ�
    BYTE byRes1[3];	//
    DWORD dwInterval;//ͳ�Ƽ��ʱ�䣨��λ�����ӣ�
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;	//����¼��ID(���ڲ�ѯ¼�񣬽���byResultTypeΪ2ʱ��Ч)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;

typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//1-4��0xff�� ����1-4��ʾ�����IOͨ���ţ�0xff��ʾ������
    BYTE  byCabinetState;//0~�͵�ƽ,1~�ߵ�ƽ
    BYTE  byAlarmIntervalTime;//ȡֵ��Χ1-60����λ����
    BYTE  byRes1[25];
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0~�����ã�1������
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;

typedef  struct  tagNET_ITS_GATE_LANE_CFG
{
    BYTE      byGateSiteID[MAX_ID_LEN];    //����ڱ��
    BYTE	  byGateInfo[MAX_ID_LEN];  	//�������Ϣ����
    BYTE      byLaneName[NAME_LEN];     //�������
    BYTE      byValid;              //�Ƿ����� 0 ��ʾδ���ã�1��ʾ����
    BYTE	  byCamLaneId; 	//��Ӧ������1��16��������õĳ����ţ�������Ծ��������ͬ��
    WORD      wLaneid;            //������1��32��������ţ�������Ծ �߼�������
    BYTE	  byRelativeIoNum;         //�߼������Ź���������ڱ��
    BYTE      byDirection;          //������;  0 -���� 1 �볡  2 ���� 3 ˫��
    BYTE	  byLprMode; //��ʶ��������0 ȫ����1 ������2 �����
    BYTE 	  byCardMode; //��Ƭ��������0 ȫ����1 ������2 �����
    BYTE 	  byGateLaneMode;//����ڷ�������ģʽ 0-ȫ���� 1-ֻ����ʶƥ�����2 ֻ��ˢ��ƥ���//�� 3-��ʶ��Ƭ��һ��ƥ������� 4-��ʶ�ҿ�Ƭͬʱƥ������� 5-ȫ����
    //2013-11-19 ��������
    BYTE      byCharge;//�Ƿ��շ� 0-���շѣ�1-�շ�
    BYTE      byChargeMode;//�շ����� 0-�����շѣ�1-�����շ�
    BYTE      byRes1;
    BYTE      byLedRelativeIndex[MAX_INDEX_LED];//LED ���� (1~255) �������У�0��ʾ��Ч����������������
    BYTE      byGateRelativeIndex;//����ڿ��ƻ��������
    BYTE      byFarRrRelativeIndex;// Զ����������������
    BYTE      byRes[82]; //Ԥ��
}NET_ITS_GATE_LANE_CFG, *LPNET_ITS_GATE_LANE_CFG;

typedef	struct  tagNET_ITS_IPC_CHAN_LANE_CFG
{
    DWORD     dwSize;
    BYTE	  byIpcType;  //0-�ޣ�1-����ץ�ģ�2-����ץ�ģ�3-������
    BYTE	  byRes[135];
    NET_ITS_GATE_LANE_CFG  struGateLane[4]; //�������ýṹ��
}NET_ITS_IPC_CHAN_LANE_CFG, *LPNET_ITS_IPC_CHAN_LANE_CFG;

//�豸Զ�̿���
typedef	struct	tagNET_ITS_REMOTE_COMMAND
{
    WORD            wLaneid; //������1��32��������ţ�������Ծ��
    BYTE	 		byCamLaneId;	//��Ӧ������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE            byRes;     //Ԥ��
    DWORD           dwCode;       //������ 0x0 ��բ 0x1 ��բ���������չ
    BYTE			byRes1[128];
}NET_ITS_REMOTE_COMMAND,*LPNET_ITS_REMOTE_COMMAND;

typedef  struct	tagNET_ITS_REMOTE_CONTROL_
{
    DWORD          dwSize;
    NET_ITS_REMOTE_COMMAND	struRemoteCommand;   //Զ������ṹ
}NET_ITS_REMOTE_CONTROL,*LPNET_ITS_REMOTE_CONTROL;

//�����ӻ�ȡͨ��״̬
typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE  bySignalStatic; //���ӵ��ź�״̬,0-��,1-�źŶ�ʧ
    BYTE  byHardwareStatic;//ͨ��Ӳ��״̬,0-��,1-�쳣,����DSP����
    BYTE  byChannelArmState; //����IPC�Ĳ���״̬
    DWORD dwChannel; //ͨ����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    NET_DVR_IPADDR struClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
    DWORD dwIPLinkNum;//����ͨ��ΪIP���룬��ô��ʾIP���뵱ǰ��������
    BYTE  byExceedMaxLink;	// �Ƿ񳬳���128·������ 0 - δ����, 1-����
    BYTE  byRes[139];       // �����ֽ�
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

//��ӵ�
typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 �� ������ 1 �� ����
    BYTE   byFlicker;//0 �� ����˸ 1 �� ��˸
    BYTE   byIOState;//0 �� �͵�ƽ 1 �� �ߵ�ƽ (���õ���Ч)
    BYTE   byLampColor;// 0- �� 1-��   2-��  3-��  4-�� 5-Ʒ��  6-��  7-��ɫ (���õ���Ч)
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0������˸ 1 ����˸
    BYTE   byLampColor;//0-�� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (���õ���Ч)
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//�г�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//�޳�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//���⳵λ�г�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//���⳵λ�޳�io��ƽ״̬
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*��ӵƵ�����³�λ��Ϣ��һ��ͨ�����4����λ (�����ҳ�λ ����0��3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0~����˸ 1 ����˸(��λָʾ����˸)
    BYTE   byLampColor;//0- �� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (��λָʾ����ɫ)
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

//�������õ�ģʽ
typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //��λ״̬ 0����޳���1����г���2���ѹ��(���ȼ����), 3���⳵λ
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //������λ�ƣ�0-���õ�, 1-���õ�1, 2-���õ�2, 3-���õ�3��
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE;

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0~����˸ 1 ����˸
    BYTE   byLampColor;//0- �� 1-��   2-��  3-��  4-�� 5-Ʒ��  6-��  7-��ɫ
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

//�������õ�ģʽ
typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    //��λ״̬ 0����޳���1����г���2���ѹ��(���ȼ����), 3���⳵λ
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    //������λ�ƣ�0-���õ�, 1-���õ�1, 2-���õ�2, 3-���õ�3��
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP;

/*���õƼ����õ�ģʽ�� ���õƿ��ƽṹ����Ϣ */
typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;     //0�������� 1 ������
    BYTE   byFlicker;    //0~����˸ 1 ����˸
    BYTE   byLampColor;  //0- �� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (���õ���Ч)
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

/* ��Ͽ���ģʽ�ṹ */
typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];//���õ� ���ճ�λ�Ž�����֣�һ��ͨ�����4����λ (�����ҳ�λ ����0��3)
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];//���õ� ���ճ�λ״̬��֣���λ״̬ 0����޳���1����г���2���ѹ��(���ȼ����), 3���⳵λ
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

/* ������ӵƿ���ģʽ�ṹ */
typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE //�����õ�ģʽ�ǲ���ֳ�λ��Ϣ����ʾ��ǰ��λ״̬�У��ȼ���õ�״̬��ѹ��>���⳵λ>���޳�״̬��
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];//���õ� ���ճ�λ�Ž�����֣�һ��ͨ�����4����λ (�����ҳ�λ ����0��3)
    BYTE byLampType; /* 1-���õ�1��2-���õ�2��3-���õ�3*/
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;

typedef union tagNET_DVR_LAMP_CTRL_MODE_UNION
{
    BYTE uLen[288];
    NET_DVR_INLAY_LAMP_CTRL_MODE struInlayLampCtrlMode;/*���õƿ���ģʽ�ṹ*/
    NET_DVR_EXTERNAL_LAMP_CTRL_MODE struExternalLampCtrlMode;/*��ӵƿ���ģʽ�ṹ*/
    NET_DVR_PARKLAMP_CTRL_MODE struParkLampCtrlMode[MAX_PARKING_NUM/*4*/];/*�������õ�ģʽ��һ��ͨ�����4����λ (�����ҳ�λ ����0��3)  ��ģʽΪ�����õƵ�ʱ����Ч*/
    //��λ�����������õƣ���Ͽ���ģʽ����������������õ�ģʽ����ģʽ�����õƲ���Ϊ���õ�ʹ�ã��������õ�ģʽ�£����õ���Ϊ���õ�ʹ�ã�����
    //��Ͽ���ģʽ�£����õ���ʾ��ǰ��⳵λ״̬�У����ȼ���ߵĳ�λ״̬(ѹ��>���⳵λ>���޳�״̬)�����Ƶ�״̬
    NET_DVR_MIXLAMP_CTRL_MODE  struMixLampCtrlMode;
    //�����õ�ģʽ�ǲ���ֳ�λ��Ϣ����ʾ��ǰ��λ״̬�У��ȼ���õ�״̬��ѹ��>���⳵λ>���޳�״̬��
    NET_DVR_SINGLELAMP_CTRL_MODE struSingleExternalLampCtrlMode;
}NET_DVR_LAMP_CTRL_MODE_UNION, *LPNET_DVR_LAMP_CTRL_MODE_UNION;/*�ƿ���ģʽ������*/

typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*�ص�ģʽ��1������õ�,2�����ӵ�,3��������õ�,4����ϵ�ģʽ�����õ�ֻ�������ȼ�ָʾ��),5-��?���õ�ģʽ*/
    BYTE      byCtrlChannelIndex;/*�������ͨ����(33~48)*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;/*�ƿ���ģʽ������*/
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

//��λ�������ã�Ĭ�϶���normal��
typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~��ͨ��λ 1�����⳵λ
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//һ��ͨ�����4����λ (�����ҳ�λ ����0��3)
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

//ָʾ�����
typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0~����˸ 1 ����˸
    BYTE      byParkingIndex;//��λ��1��3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //���ʹ�� 0�������� 1������
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;//ָʾ�����
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

//��λǿ��ץͼ һ��ͨ������ĳ�λ
typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE	   byParkIndex;/*��λ��Ŵ����� ��0-��ʾ��ǰ�м�����λ�����ϴ�����ͼƬ��1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

//��ر����ṹ
typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD	  dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;//ָʾ�����״̬
    NET_DVR_TIME      struExternalBeginTime;/*��ؿ�ʼʱ��*/
    BYTE	  byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;

/* �豸���� */
typedef enum tagEXTERNAL_DEVICES_TYPE
{
    DEVICES_TYPE_RES1 = 0,				//����1
	DEVICES_TYPE_FAR_SCR = 1,			//Զ���������
	DEVICES_TYPE_ENTRANCE_CONTROL = 2,	//����ڿ��ƻ�
	DEVICES_TYPE_WJ_LED_DEV = 3,		//���LED
	DEVICES_TYPE_NJ_LED_DEV = 4,		//�ڽ�LED
	DEVICES_TYPE_VEH_DETECT_DEV = 5,	//�������豸
	DEVICES_TYPE_DZ_DEV = 6,			//��բ
	DEVICES_TYPE_PX_SCR_DEV = 7, 		//Ʊ�������
	DEVICES_TYPE_KJ_SCR_DEV = 8, 		//���������
	DEVICES_TYPE_FKJ_DEV = 9,			//������
	DEVICES_TYPE_SKJ_DEV = 10,			//�տ���
	DEVICES_TYPE_HDD_DEV = 11,			//Ӳ��(���� 1G)
	DEVICES_TYPE_DZ_LOCK = 12,			//��բ��բ״̬��0��ʾδ��բ��1��ʾ��բ
	DEVICES_TYPE_PAPER_PRINTER = 13     //ֽƱ��ӡ��
}EXTERNAL_DEVICES_TYPE;

/* �豸״̬ */
typedef enum tagEXTERNAL_DEVICES_STATUS
{
    /* ͨ���豸״̬�� 0~19*/
    DEVICES_STATUS_NORMAL = 0,			//״̬��
	DEVICES_STATUS_ABNORMAL = 1,		//״̬�쳣

	/* �������豸״̬�� 20~39*/
	DEVICES_STATUS_TOO_LESS_CARD = 20, 		//�������ٿ�
	DEVICES_STATUS_NO_CARD = 21, 			//�������޿�

	/* ��բ�豸״̬�� 40~60*/
	DEVICES_STATUS_OPENING = 40, 			//��բ���ڿ�
	DEVICES_STATUS_CLOSING = 41, 			//��բ���ڹ�
	DEVICES_STATUS_OPENED  = 42, 			//��բ����λ
	DEVICES_STATUS_CLOSED  = 43, 			//��բ�ص�λ
	DEVICES_STATUS_NOSIGNAL = 44, 		    //��բ���ź�

	/* ֽƱ��ӡ��״̬ 61~90*/
	PP_STATUS_OFFLINE = 61,                   //�ѻ�
	PP_STATUS_PRINT_HEADER_UP,           // ��ӡͷ̧��
	PP_STATUS_FEED_BUTTON_FEEDING,       //�����ý�ֽ���ֽ
	PP_STATUS_ONLINE_WAITING,            //����ȴ�
	PP_STATUS_FEED_BUTTON_ENABLE,        //�����ֽʹ��Ϊ��
	PP_STATUS_JAMR_PAPER_ERROR,          //��ֽ����
	PP_STATUS_CUT_PAPER_ERROR,           //�е�����
	PP_STATUS_AUTO_FEED_ERROR,           //�Զ���ֽ����
	PP_STATUS_EXIT_RECOVERY_ERROR,       //�пɻָ�����
	PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,  //�п��Զ��ָ�����
	PP_STATUS_PULL_PAPER_ERROR,          //��ֽ����
	PP_STATUS_LESS_PAPER ,               //ֽ����
	PP_STATUS_NO_PAPER,                  //��ֽ
	PP_STATUS_PRINT_FAIL,                //��ӡʧ��
	PP_STATUS_PRINTING,                  //���ڴ�ӡ
}EXTERNAL_DEVICES_STATUS;

typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1�����Ƿ����뱨��
    //0x2��բ��ʱδ�ر���
    //0x3����ѹ��Ȧ��ʱ����
    //0x4�����������޿���
    //0x5�����������ٿ���
    //0x6���������������쳣��
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//����豸����(EXTERNAL_DEVICES_TYPE)
    BYTE  byExternalDevStatus;//����豸����(EXTERNAL_DEVICES_STATUS)
	BYTE  byRes;
    NET_DVR_TIME_V30  struAlarmTime;//����ʱ��
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
            /*��������0-���� 1-�̶�����2-��ʱ����3-Ԥ������4-���쳵��5-��Ȩ��*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//��struAlarmTypeΪ(0x1�����Ƿ����뱨��)
    }uAlarmInfo;
    BYTE  byRes2[64]; //Ԥ��
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;			//A���ѹ
    int iPhaseBVol;			//B���ѹ
    int iPhaseCVol;			//C���ѹ
    int iAveragePhaseVol;	//���ѹƽ��ֵ
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;			//AB�ߵ�ѹ
    int iLineVolBC;			//BC�ߵ�ѹ
    int iLineVolCA;			//CA�ߵ�ѹ
    int iAverageLineVol;	//�ߵ�ѹƽ��ֵ
} NET_DVR_LINE_VOLTAGE,*LPNET_DVR_LINE_VOLTAGE;


//����
typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;			//A�����
    int iPhaseBCurrent;			//B�����
    int iPhaseCCurrent;			//C�����
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

//����
typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;			//A�๦��
    int iPhaseBPower;			//B�๦��
    int iPhaseCPower;			//C�๦��
    int iSysTotalPower;			//ϵͳ�ܹ���
}NET_DVR_POWER, *LPNET_DVR_POWER;

//��������
typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;	//A�๦������
    int iPhaseBPowerFactor;		//B�๦������
    int iPhaseCPowerFactor;		//C�๦������
    int iTotalPowerFactor;		//�ܹ�������
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

//Ƶ��
typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;		//A��Ƶ��
    int iPhaseBFrequency;		//B��Ƶ��
    int iPhaseCFrequency;		//C��Ƶ��
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

//������
typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;		//A�ฺ����
    int iPhaseBLoadFactor;		//B�ฺ����
    int iPhaseCLoadFactor;		//C�ฺ����
    BYTE	byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

//UPS״̬
typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE		struInputVoltage;	//�����ѹ
    NET_DVR_VOLTAGE		struBypassVoltage;	//��·��ѹ
    NET_DVR_VOLTAGE		struOutputVoltage;	//�����ѹ
    int iRectifierVol;			//��������ѹ
    int iInverterVol;			//�������ѹ

    NET_DVR_CURRENT	struInputCurrent;	//�������
    NET_DVR_CURRENT	struBypassCurrent;	//��·����
    NET_DVR_CURRENT	struOutputCurrent;	//�������
    int iInverterCurrent;		//���������

    NET_DVR_FREQUENCY	struInputFrequency;	//����Ƶ��
    NET_DVR_FREQUENCY	struBypassFrequency;	//��·Ƶ��
    NET_DVR_FREQUENCY	struOutputFrequency;	//���Ƶ��
    int iInverterFre;			//�����Ƶ��

    NET_DVR_POWER 		struInputPower;	//���빦��
    NET_DVR_POWER		struBypassPower;	//��·����
    NET_DVR_POWER		struOutputPower;	//�������
    NET_DVR_POWER		struComplexPower;	//������

    int iNormalPower;			//��ƹ���
    int iPowerFacter;			//��������

    NET_DVR_LOAD_FACTOR	struBatteryLoadFactor;	//��ظ�����
    int iBatteryEstimated;		//��ر���ʱ��(min)
    int iBatteryTemperature;		//����¶�
    int iBatteryVoltage;			//��ص�ѹ


    BYTE	byRectifierState;		//����������״̬/*1�� 2�쳣*/
    BYTE	byInverterState;		//���������״̬/*1�� 2�쳣*/
    BYTE	byChargeState;		//���������״̬/*1�� 2�쳣*/
    BYTE	byBatteryState;		//�������״̬/*1�� 2�쳣*/
    BYTE	byAutoBypassState;	//�Զ���·״̬/*1�� 2�쳣*/
    BYTE	byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE;

//���ص�Դ״̬
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE		struACVoltage;	//������ѹ
    int 	iDCConvertVoltage;	//DCת������ѹ
    NET_DVR_CURRENT		struACCurrent;	//��������
    int 	iTotalCurrent;			//�����ܵ���
    int 	iBattery1Temperature;	//���1�¶�
    int 	iBattery2Temperature;	//���2�¶�
    int 	iBattery1Current;		//���1����
    int 	iBattery2Current;		//���2����
    int 	iBattery3Current;		//���3����
    int 	iBattery4Current;		//���4����
    int 	iBatteryTestVoltage;	//��ز��Ե�ѹ
    int 	iRectifierOutputVoltage;	//����ģ�������ѹ
    int 	iRectifierOutputCurrent;	//����ģ���������
    int 	iDCOutputVoltage;		//ֱ�������ѹ
    BYTE	byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE,
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

//����̽����״̬
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int		iSF6;			//SF6����λppm
    int  	iFlow;           //������ml/min
    int		iTemperature;		//�¶ȣ���λ���϶�
    int		iO2;		    //����λ%
    int		iHumidity;		//ʪ�ȣ���λ%
    BYTE	byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,
*LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

//��ʪ�ȴ�����״̬
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int		iTemperature;	//�¶ȣ���λ���϶�
    int		iHumidity;		//ʪ�ȣ���λ%
    BYTE	byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

//�յ�״̬
typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int		iTemperature;	//�¶ȣ���λ���϶�
    int		iHumidity;		//ʪ�ȣ���λ%
    BYTE   byRunState;		//����״̬ 1-��2-ͣ��
    BYTE	byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;


//������״̬
typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int		iDCVoltage;		//ֱ����ѹ
    int		iDCCurrent;		//ֱ������
    NET_DVR_VOLTAGE		struPhaseVoltage;	//���ѹ
    NET_DVR_LINE_VOLTAGE struLineVoltage;	//�ߵ�ѹ
    NET_DVR_CURRENT	struCurrent[4];		//������struCurrent[0]��ʾ��1·, �Դ�����
    int iAverageCurrent;	//ƽ�����
    int iNeutralCurrent;		//���ߵ���
    NET_DVR_POWER	struActivePower[4];	//�й����� struActivePower[0]��ʾ��һ·�й����ʣ��Դ�����
    NET_DVR_POWER	struReactivePower[4];	//�޹����� struReactivePower[0]��ʾ��һ·�޹����ʣ��Դ�����
    NET_DVR_POWER	struApparentPower[4];	//���ڹ��� struApprentPower[0]��ʾ��һ·���ڹ��ʣ��Դ�����
    NET_DVR_POWER_FACTOR	struPowerFactor[4];	//�������أ�struPowerFactor[0]��ʾ��һ·�������أ��Դ�����
    NET_DVR_FREQUENCY		struFrequency;			//Ƶ��
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

//��������Ա�״̬
typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int		iPhaseATemperature;		//A���¶�
    int		iPhaseBTemperature;		//B���¶�
    int		iPhaseCTemperature;		//C���¶�
    int		iPhaseDTemperature;		//D���¶�
    BYTE 	byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;

//ˮλ������
typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG        iWaterLevel;        //ˮλ
    BYTE        byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//�ﳾ�������
typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG        iDust;        //�ﳾ
    LONG        iNoise;        //����
    BYTE        byRes[504];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//�����ɼ���
typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG        iAmmoniaNitrogen;	//����
    LONG        iCOD;				//COD
    LONG        iPH;				//PH
    LONG        iOxygen;			//����
    LONG        iSulfurDioxide;	//��������
    LONG        iSoot;			//�̳�
    LONG        iFluoride;        //����
    LONG        iPollutedWater;	//��ˮ
    LONG        iTotalPhosphorus;	//����
    LONG        iExhaust;			//����
    LONG        iNitrogenOxides;	//��������
    LONG        iFlueGasTemperature;//�����¶�
    LONG        iFlueGasPressure;	//����ѹ��
    BYTE        byRes[460];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

typedef union tagNET_DVR_EXTERNAL_DEVICE_STATE_UNION
{
    NET_DVR_ALARMHOST_UPS_STATE struUpsState;		//UPS״̬
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE struSwitchPowerState;//���ص�Դ״̬
    NET_DVR_ALARMHOST_GAS_DETECTOR_STATE struGasDetectorState;//������ϵͳ״̬
    NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE struTempHumiSensorState;//��ʪ�ȴ�����״̬
    NET_DVR_ALARMHOST_AIRCONDITION_STATE struAirConditionState;//�յ�״̬
    NET_DVR_ALARMHOST_ELECTRICITY_STATE struElectricityState;//������״̬
    NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE struTransformerTempState;	//�����״̬
    NET_DVR_ALARMHOST_WATERLEVEL_SENSOR struWaterLevelSensor;//ˮλ������
    NET_DVR_ALARMHOST_DUSTNOISE_SENSOR struDustNoiseSensor;//�ﳾ�������
    NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER struEnvironmentLogger;//�����ɼ���
    BYTE	byRes[512];
} NET_DVR_EXTERNAL_DEVICE_STATE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE	byDevType;	//1-UPS��2-���ص�Դ��3-������ϵͳ��4-��ʪ�ȴ�������5-�յ���6-�����?7-�����״̬, 8-ˮλ��������9-�ﳾ���������10-�����ɼ���
    BYTE	byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE	byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;


//UPS������ֵ
typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;		//Խ�������ѹֵ(��ֵ)
    int iInputVolLow;		//Խ�������ѹֵ(��ֵ)
    int iInputFreHigh;		//Խ������Ƶ��ֵ(��ֵ)
    int iInputFreLow;		//Խ������Ƶ��ֵ(��ֵ)
    int iOutputVolHigh;	//Խ�������ѹֵ(��ֵ)
    int iOutputVolLow;		//Խ�������ѹֵ(��ֵ)
    int iBatteryVoltageLow;	//��ص͵�ѹ��ֵ
    int iBatterySurplus;		//��غ�ʱ��� ��ֵ
    int iBatteryTemperatureHigh;//����¶ȸ���ֵ
    BYTE	byRes[64];			//����
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

//��ʪ�ȴ�������ֵ
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;	//�¶ȸ���ֵ����λ���϶�
    int iTemperatureLowLimit;	//�¶ȵ���ֵ����λ���϶�
    int iHumidityHighLimit;		//ʪ�ȸ���ֵ����λ%
    int iHumidityLowLimit;		//ʪ�ȵ���ֵ����λ%
    BYTE	byRes[84];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

typedef union tagNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION
{
    NET_DVR_ALARMHOST_UPS_LIMIT_VALUE struUpsLimitValue;
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE struTempHumidityLimitValue;
}NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION,*LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE	byDevType;	//1-UPS��2-��ʪ�ȴ�����
    BYTE	byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE	byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

#define	ALARMHOST_ALARMOUT_NUM	64  //����������
typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD 		dwSize;
    BYTE		bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];//ģ����������������0-��������1-����
    BYTE		bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];//ģ������������
    BYTE		bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//ģ�������������������������ֶ���bySensorJointAlarmOut����չ�������±��ʾ�������ţ�����Ԫ�ص�ֵ��λ��ʾ�������ͣ��������ͼ���"��"�Ĺ�ϵ������ֵ���壺1bit0-��1��bit1-��2��bit2-��3��bit3-��4��bit4-����
    BYTE		bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //ģ�����������������ţ����ֶ���bySensorJointSiren����չ�������±��ʾ������ţ�����Ԫ�ص�ֵ��λ��ʾ�������ͣ��������ͼ���"��"�Ĺ�ϵ������ֵ���壺bit0-��1��bit1-��2��bit2-��3��bit3-��4��bit4-����
    BYTE		byChan;		//ͨ����
    BYTE		byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

//UPS������Ϣ�ϴ�
typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE	byAlarmType;/*�������ͣ�1.A�������ѹԽ�� 2.B�������ѹԽ�� 3.C�������ѹԽ�� 4.A�������ѹԽ��5.B�������ѹԽ�� 6.C�������ѹԽ��7.A������Ƶ��Խ�� 8.B������Ƶ��Խ��9.C������Ƶ��Խ��10.��������ѹԽ�ޱ��� 11.���ر��� 12.��ص�ѹ�ͱ��� 13.��غ�ʱ�䳬�ͱ��� 14.����¶ȳ��߱��� 15.������رձ��� 16.�Զ���·������ 17.���������ϱ��� 18.��������ϱ��� 19.��������ϱ���	20.��ع��ϱ���	 21.�Զ���·���ϱ��� */
    BYTE	byChanNo;	//485ͨ���ţ���1��ʼ
    BYTE    bySlotNo;	//485�����λ��
    BYTE	byRes1;		//����
    int		iAlarmValue;//����ֵ
    BYTE	byRes2[64];		//����
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

//���ص�Դ�����ϴ�
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE	byAlarmType;	/*�������ͣ�1-��ز���ʧ�� 2-AC-DCת�������ϣ�3-������/���ѹAB/AԽ�ޣ�4-������/���ѹBC/BԽ�ޣ�5-������/���ѹCA/CԽ�ޣ�6-�������AԽ�ޣ�7-�������BԽ�ޣ�8-�������CԽ�ޣ�9����ģ����ϣ�10-���ȹ��ϣ�11-ֱ����ѹԽ��*/
    BYTE	byChanNo;		//485ͨ���ţ���1��ʼ
    BYTE	bySlotNo;		//485�����λ��
    BYTE	byRes1;
    int 	iAlarmValue;		//����ֵ
    BYTE	byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO,
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

//������ϵͳ����
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE	byAlarmType;	/*�������ͣ�1- SF6���庬���쳣��2-�������쳣��3-�¶�ֵ�쳣��4-ʪ��ֵ�쳣��5-����*/
    BYTE	byChanNo;	//485ͨ���ţ���1��ʼ
    BYTE	bySlotNo;	//485�����λ��
    BYTE	byRes1;
    int 	iAlarmValue;		//����ֵ
    BYTE	byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO,
*LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;


//��ʪ�ȴ���������
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE	byAlarmType;	//1-�¶��쳣��2-ʪ���쳣
    BYTE	byChanNo;		//485ͨ����
    BYTE	bySlotNo;		//485��λ��
    BYTE	byRes1;
    int 		iAlarmValue;	//����ֵ
    BYTE	byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

typedef union  tagNET_DVR_485_DEVICE_ALARM_UNION
{
    NET_DVR_ALARMHOST_UPS_ALARMINFO struUPSAlarm; //UPS����
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO struSwitchPowerAlarm; //���ص�Դ����
    NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO struGasDetectSystemAlarm; //������ϵͳ����
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO struTempHumiditySensorAlarm; //��ʪ�ȴ���������
    BYTE	byRes[72];
} NET_DVR_485_DEVICE_ALARM_UNION, *LPNET_DVR_485_DEVICE_ALARM_UNION;

//485����豸������Ϣ
typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE	byAlarmType;	//1-UPS������2-���ص�Դ������3-������ϵͳ������4-��ʪ�ȴ���������
    BYTE	byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE	byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD   	dwSize;              // �ṹ���С
    BYTE    	sDeviceName[NAME_LEN];  	// ǰ���豸���
    WORD    	wDeviceType;        	// ǰ���豸����ALARM_FRONT_DEVICE _TYPE
    WORD		wDeviceProtocol;     // ǰ���豸Э�� ͨ���ȡЭ���б��ȡ
    WORD        wAddress;			//�豸��ַ
    BYTE		byChannel;          //485ͨ����
    BYTE		bySlotChan;         //��λ��
    BYTE    	byRes[60];          // �����ֽ�
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

//����ģʽ
typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD		dwSize;
    BYTE        byEnableCorridorMode; //�Ƿ���������ģʽ 0�������ã� 1������
    BYTE        byMirrorMode;            //����ʽ��0 �ر�;1 ����;2 ����;3 �м�
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

//�������
typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD	 dwSize;
    BYTE	 byEnableDetectFace; //�Ƿ����� 0�������ã� 1������
    BYTE	 byDetectSensitive; //������ 10���ȼ� 1��10
    BYTE     byEnableDisplay;	/*�����ƶ���������ʾ��0-��1-��*/
    BYTE     byEnableFaceRecog;  //�Ƿ���������ʶ��0-�����ã�1-����
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*���?ʽ*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ�� */
    DWORD    dwMaxRelRecordChanNum;     //����������¼��ͨ�� ��ֻ�������֧������
    DWORD    dwRelRecordChanNum;     //����������¼��ͨ���� ʵ��֧����
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];	/* ����������¼��ͨ��*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    WORD	 wDuration;  //��������ʱ�� 5s ������
    BYTE	 byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD	    dwSize;				 // �ṹ���С
    DWORD       dwGroup ;             //���
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //����������
    BYTE         byRes[64] ;
}NET_DVR_MUL_STREAM_CHANNEL_GROUP,*LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD	    dwSize;	   // �ṹ���С
    DWORD       dwChannel; //ͨ����
    DWORD       dwGroup;   //���
    BYTE        byID;      //�豸��������ID
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //����λ�������,IPC��0��IPD�Ǵ�1��ʼ
    BYTE        byRes[56];
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;


typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //ʱ��
    BYTE   byDetSceneID;//��ⳡ����[1,4],IPCĬ����0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION,*LPNET_DVR_TIME_DETECTION;

//ץ�Ĵ���ģʽ֧�ֹ�������ʱ��κ��ϴ���������
typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    /*
    0��ʾ��Ч��
    1��ʾ���� ץ��VIAģʽ����Ƶ����ץ�� IPCʹ�ã�;
    2 ��ʾ���� ץ�� HVT ģʽ ���쿨IPCʹ�ã�
    */
    BYTE   byRelateType;
    BYTE   byGroupNo;  //���
    BYTE   byRes[62];
}NET_DVR_GUARD_COND,*LPNET_DVR_GUARD_COND;

//ץ�Ĵ���ģʽ֧�ֹ�������ʱ��κ��ϴ�����
typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //����ʱ��
    NET_DVR_TIME_DETECTION	struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //������ʵ�ʴ�����¼��ͨ����
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];    //����������¼��ͨ��(0xffff ffff��ʾ������Ч��
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    BYTE   byRes[88];
}NET_DVR_GUARD_CFG,*LPNET_DVR_GUARD_CFG;

//ץ��ͼƬ����������չ�����ṹ
typedef	struct  tagNET_DVR_SNAPINFO_COND_
{
    DWORD    dwSize;
    DWORD    dwChan;
    /*
    0 ��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
    1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE     byRelateType;
    BYTE     byRes[63];		//����
}NET_DVR_SNAPINFO_COND, *LPNET_DVR_SNAPINFO_COND;


//ץ��ͼƬ��������
typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0-��ʾ��ͼƬ������1-��ʾͼƬ��С
    BYTE  byPicQuality;//ͼƬ����[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//ͼƬ��С[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG,*LPNET_DVR_SNAPINFOCFG;

//ptz���ٷ�ʽ
typedef enum _PTZ_TRACK_MODE_
{
    PTZ_TRACK_MODE_ALWAYS  = 1,   //һֱ����
        PTZ_TRACK_MODE_BYTIME  = 2,   //����ָ��ʱ��
        PTZ_TRACK_MODE_NEXT    = 3,   //������һĿ��
}PTZ_TRACK_MODE;

//ptz���ٲ���
typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //�ṹ���С
    BYTE  byTrackMode; //���ٷ�ʽ,�ο�PTZ_TRACK_MODE
    BYTE  byLinkageTarget; //����Ŀ��0-Ĭ��,1-���1,2-���2��..��������
    BYTE  byAutoTrackEnable;//����ʹ�� 0-�Զ����ٿ�����1-�Զ����ٹرգ�ǹ���豸��֧���Զ����ٹرչ��ܣ����ڴ�������չ��
    BYTE  byRes1; //����
    DWORD dwTrackTime; //����ʱ�䣬
    //������ģʽΪPTZ_TRACK_MODE_ALWAYS�����ֶ���Ч
    //������ģʽΪPTZ_TRACK MODE_BYTIMEʱ����Χ[1,60]��Ĭ��10��
    //������ģʽΪPTZ_TRACK MODE_NEXTʱ����Χ[1,10]��Ĭ��2��
    BYTE  byRes2[256]; //����
}NET_DVR_PTZ_TRACK_PARAM,*LPNET_DVR_PTZ_TRACK_PARAM;

typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD dwSize;
    BYTE	byEnable;//ʹ��
    BYTE	byEnableDualVca;// ����֧�����ܺ���� 0-�����ã�1-����
    BYTE   byRes1[2];
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];  //�����߲���
    NET_DVR_SCHEDTIME	struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//����¼���ͨ����
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;


typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable; //ʹ�ܣ��Ƿ���
    BYTE byEnableDualVca;// ����֧�����ܺ���� 0-�����ã�1-����
    BYTE byRes1[2];
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];//ÿ������Ĳ�������
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //���ղ���ʱ��
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;	//�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    DWORD   dwRoiFixNum; //�̶���������ȷ�������ٴλ�ȡ�����
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC����֧��4�����������֧��24��
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//�̶�ROI�������
    DWORD   dwRoiTrackNum; //�Զ�������������ȷ�������ٴλ�ȡ�����
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC����֧��4�����������֧��24��
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;

typedef  enum  _DETECT_ROI_TYPE_
{
    DETECT_FIX_ROI  =  0, //���ROI�̶�����
        DETECT_TRACK_ROI = 1 //���ROI �Զ���������
}DETECT_ROI_TYPE;
//��������
typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //������� һ��PTZ֧��4��
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //����������
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE ��ֵ
    BYTE    byRoiDetectTrackType;//�̶�����ʱ�����ֶ���Ч����������ʱ��1��������⣨IPC��,2���ƶ��������,3-���Ƹ���
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND,*LPNET_DVR_ROI_DETECT_COND;

//���ò���
//ROI�̶�����ģʽ ������빦��
typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI�̶�����ģʽ �Ƿ����� 0�������ã� 1������
    BYTE  byImageQualityLevel; //ͼ����������ȼ� 1��6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;  //ROI����
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;

//ROI�Զ�����ģʽ ������빦��
typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI�Զ�����ģʽ �Ƿ����� 0�������ã� 1������
    BYTE  byImageQualityLevel; //ͼ����������ȼ� 1��6
    BYTE  byModeType;// 0 ~ ��, 1������ģʽ(�ƶ��;�ֹ������), 2~�ƶ��������(�ƶ�������), 3-���Ƹ���
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;

typedef union tagNET_DVR_ROI_DETECT_UNION
{
    DWORD						uLen[128];
    NET_DVR_ROI_FIX_RECT_CFG    strRoiFixRectCfg;//�̶�����ģʽ
    NET_DVR_ROI_TRACK_RECT_CFG  strRoiTrackRectCfg;//�Զ�����ģʽ
}NET_DVR_ROI_DETECT_UNION,*LPNET_DVR_ROI_DETECT_UNION;

typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;  //560
    DWORD	   dwStreamType;	//�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE ��ֵ
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo; //ROI�������
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

//�齹���
typedef struct tagNET_VCA_DEFOCUSPARAM
{
    DWORD dwSize;
    BYTE byEnable;//ʹ��
    BYTE  bySensitiveLevel;// 1-100��Ĭ��50��������Խ�ߣ�Խ���ױ���
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM,*LPNET_VCA_DEFOCUSPARAM;

//IPC5.1.0
typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD wPresetNum; //Ԥ�õ���
    BYTE byRes1[2]; //�ֽڶ���
    char byName[NAME_LEN];
    BYTE byRes[64];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;

typedef struct
{
    NET_DVR_SCHEDTIME struSchedTime; //ʱ��
    WORD  wAction;  ///< ��ʱ�������嶯��
    WORD  wActionNum; ///< ���⶯���ӱ�ţ���Ԥ�õ㣬Ѳ�����������������ҹ�л���
    BYTE byres[12];
}NET_DVR_SCHEDTASK,* LPNET_DVR_SCHEDTASK;

//��ʱ����
typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///< ʹ�� 1-����0-��
    BYTE byRes[3];    ///< �ֽڶ���
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];	///< 7�죬ÿ��10ʱ���
    DWORD dwParkTime;   ///< ����ʱ�� 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK,*LPNET_DVR_TIME_TASK;

//�����ṹ��
typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;				 // �ṹ���С
    DWORD dwChannel ;           //ͨ����
    DWORD dwIndex ;             //�����
    BYTE  byRes[64] ;
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;				 // �ṹ���С
    char  cName[NAME_LEN] ;          //���
    BYTE  byRes[64];
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

//��¼�豸����
typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   byMobileDev;  //�豸����, 0- ���ƶ��豸, 1 - �ƶ��豸
    BYTE   byRes[63];    //����
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;

typedef enum RECV_DATA_TYPE
{
    ENUM_RECV_ERRCODE = 0x0, //���ش�����
} RECV_DATA_TYPE;

//�������ģʽ
typedef enum tagFISHEYE_STREAM_OUTPUT_MODE_
{
    FISHEYE_STREAM_MODE_FISHEYE    = 1,   //����ģʽ
        FISHEYE_STREAM_MODE_PTZ        = 2,   //PTZģʽ
        FISHEYE_STREAM_MODE_PANORAMA   = 3    //ȫ��ģʽ
}FISHEYE_STREAM_OUTPUT_MODE;

//�ص��������ö��
typedef enum _CALLBACK_TYPE_DATA_ENUM_
{
    ENUM_FISHEYE_STREAM_STATUS   = 1,  //�����������״̬
        ENUM_FISHEYE_PTZPOS          = 2,  //ptzͨ����ǰ������ģʽ�µ����
        ENUM_FISHEYE_REALTIME_OUTPUT = 3   //ʵʱ���ģʽ
}CALLBACK_TYPE_DATA_ENUM;

//��������״̬
typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{
    DWORD  dwSize;        //�ṹ���С
    BYTE   byStreamMode;  //�������ģʽ���μ�FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //����
}NET_DVR_FISHEYE_STREAM_STATUS,*LPNET_DVR_FISHEYE_STREAM_STATUS;

//�����ӻص���ݽṹ��
typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{
    DWORD  dwChannel;      //ͨ����
    DWORD  dwDataType;     //�μ�CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //��ݳ���
    BYTE*  pData;          //��ݣ���dwTypeDataΪ ENUM_FISHEYE_STREAM_STATUS�����ӦΪNET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //����
}NET_DVR_CALLBACK_TYPE_DATA,*LPNET_DVR_CALLBACK_TYPE_DATA;

//����ptz�϶�����
typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD          dwChannel;      //ͨ����
    DWORD          dwPtzChannel;   //��dwChannel��ָͨ��ģʽΪFISHEYE_STREAM_MODE_FISHEYE������ģʽʱ������ֵΪ���϶���������ptzͨ������dwChannelͨ��ģʽΪ������ʱ����Ϊ0����
    NET_VCA_POINT  struToPoint;    //�϶�����Ҫ��ת����Ŀ��㣬Ŀ���λ�������Ԥ����������Ͻ�
    NET_VCA_POINT  struOriPoint;   //�϶�������ʼ��,�˵�Ϊ�����϶�������ʼʱ�����ָ�������Ԥ���������Ͻǵ�λ��
    BYTE           byRes[56];      //����
}NET_DVR_DRAG_POS_PARAM,*LPNET_DVR_DRAG_POS_PARAM;

//ƽ̨��ѯ��Ϸ�������״̬
typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad; 	  //CPU��Դռ�����, ȡֵ��Χ��0-100
    BYTE       byMemLoad;	  //Memory��Դռ�������ȡֵ��Χ��0-100
    WORD       wAbility;      //��Ϸ�����������������0
    WORD       wRemainAbility;//��Ϸ�����ʣ��������ȡֵ��Χ������ 0  ʣ���ص�ĸ���
    WORD       wTotalPlanNum; //���64���ƻ�>
    WORD       wCurPlanNum;   //��ǰ�ƻ���  ���64���ƻ�>
    BYTE       byRes[62];     //����
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;	        //�Ƿ�����
    BYTE   byDevType;     	    //�豸���ͣ�0-����̨�豸��1-����̨�豸
    BYTE   bySignalPoint;       //�źŶ�ʧ��ֵ��0-100
    BYTE   byBlurPoint;         //ͼ��ģ��ֵ��0-100
    BYTE   byLumaPoint;         //ͼ�������ֵ��0-100
    BYTE   byChromaPoint;       //ͼ��ƫɫ��ֵ��0-100
    BYTE   bySnowPoint;         //������ŷ�ֵ��0-100
    BYTE   byStreakPoint;       //���Ƹ��ŷ�ֵ��0-100
    BYTE   byFreezePoint;       //���涳�ֵᷧ��0-100
    BYTE   byPTZPoint;          //��̨ʧ�ط�ֵ��0-100
    BYTE   byMonitorDel;        //��ص�ɾ�� 0-��ɾ�� 1-ɾ��
    BYTE   byContrastThreshold; //�Աȶ��쳣��ֵ��0-100
    BYTE   byMonoThreshold;     //�ڰ�ͼ����ֵ��0-100
    BYTE   byShakeThreshold;    //��Ƶ������ֵ��0-100
    BYTE   byFlashThreshold;    //��Ƶ�����ֵ��0-100
    BYTE   byCoverThreshold;    //��Ƶ�ڵ���ֵ��0-100
    BYTE   bySceneThreshold;    //���������ֵ��0-100
    BYTE   byDarkThreshold;     //ͼ�����ֵ��0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

//��Ͻ��
typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];	///< ��ID������С��32���ֽ�
   	char  sMonitorIP[64];  ///< ��ص�ip
   	DWORD  dwChanIndex;  ///< ��ص�ͨ����
    DWORD  dwWidth;  ///< ͼ����
    DWORD  dwHeight;  ///< ͼ��߶�
    NET_DVR_TIME  struCheckTime;  ///< ���ʱ��(�ϲ����ں�ʱ���ֶ�)����ʽ��2012-08-06 13:00:00
    BYTE  byResult;  ///0-δ��� 1-�� 2-�쳣 3-��¼ʧ�� 4-ȡ���쳣
    BYTE  bySignalResult; ///< ��Ƶ��ʧ����� 0-δ��� 1-�� 2-�쳣
   	BYTE  byBlurResult;  ///< ͼ��ģ������0-δ��� 1-�� 2-�쳣
   	BYTE  byLumaResult;  ///< ͼ����������0-δ��� 1-�� 2-�쳣
   	BYTE  byChromaResult;  ///< ƫɫ�����0-δ��� 1-�� 2-�쳣
   	BYTE  bySnowResult;  ///< ������ż����0-δ��� 1-�� 2-�쳣
    BYTE  byStreakResult;  ///< ���Ƹ��ż����0-δ��� 1-�� 2-�쳣
   	BYTE  byFreezeResult;  ///< ���涳������0-δ��� 1-�� 2-�쳣
   	BYTE  byPTZResult;  ///< ��̨�����0-δ��� 1-�� 2-�쳣
    BYTE  byContrastResult;     //�Աȶ��쳣�����0-δ��⣬1-��2-�쳣
    BYTE  byMonoResult;         //�ڰ�ͼ������0-δ��⣬1-��2-�쳣
    BYTE  byShakeResult;        //��Ƶ���������0-δ��⣬1-��2-�쳣
    char  sSNapShotURL[256];	///<ͼƬURL��ַ
    BYTE  byFlashResult;        //��Ƶ�������0-δ��⣬1-��2-�쳣
    BYTE  byCoverResult;        //��Ƶ�ڵ������0-δ��⣬1-��2-�쳣
    BYTE  bySceneResult;        //�����������0-δ��⣬1-��2-�쳣
    BYTE  byDarkResult;         //ͼ�������0-δ��⣬1-��2-�쳣
	BYTE  byStreamType;		//�������ͣ�0-��Ч��1-δ֪��2-������ͣ�3-�ǹ������
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST   ///< �����ݽṹ��ƽ̨���͵���Ϸ�������
{
    NET_DVR_STREAM_INFO  struStreamInfo;
   	char   sSnapShotURL[256];  ///< ���ץͼURL������С��256���ֽ�
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO  ///< �����ݽṹ����Ϸ��������ظ�ƽ̨��
{
    DWORD  dwSize;
    char   sStreamID[32];	 ///<��ID(��ص�ID)������С��32���ֽ�
    DWORD  dwPicLength;  ///ͼƬ����
    BYTE   byStatus;     ///< ���ý��:0-�ɹ�,1-�������2-ͼƬ�����ڣ�3-��ȡͼƬʧ��
    BYTE   byRes[31];
   	char   *pSnapShot;      ///< ���ץͼ����һ��ͼƬ�������(700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];	///< �ƻ�id������С��32���ֽ�
   	NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];	///< ���ʱ��
    BYTE	byPlanMode;  ///0:��ʱ�ƻ���1:���ڼƻ�
    BYTE    byRes1;//
    BYTE    byCheckFlag;  ///< �Ƿ��⣬0-����⣬1-���
    BYTE    bySignal;  ///<��Ƶ��ʧ �Ƿ��⣬0-����⣬1-���
   	BYTE    byBlur;  ///< ͼ��ģ�� �Ƿ��⣬0-����⣬1-���
   	BYTE    byLuma;  ///< ͼ������Ƿ��⣬0-����⣬1-���
   	BYTE    byChroma;  ///< ƫɫ��� �Ƿ��⣬0-����⣬1-���
   	BYTE    bySnow;  ///<������� �Ƿ��⣬0-����⣬1-���
    BYTE    byStreak;  ///<���Ƹ��� �Ƿ��⣬0-����⣬1-���
   	BYTE    byFreeze;  ///<���涳���Ƿ��⣬0-����⣬1-���
   	BYTE    byPTZ;  ///<��̨�Ƿ��⣬0-����⣬1-���
    BYTE    byEnablePlanRound;  ///�ƻ�ѭ���Ƿ���
    BYTE    byContrast;  //�Աȶ��쳣�Ƿ��⣬0-����⣬1-���
    BYTE    byMono;      //�ڰ�ͼ���Ƿ��⣬0-����⣬1-���
    BYTE    byShake;     //��Ƶ�����Ƿ��⣬0-����⣬1-���
    BYTE    byFlash;     //��Ƶ����Ƿ��⣬0-����⣬1-���
    BYTE    byCover;     //��Ƶ�ڵ��Ƿ��⣬0-����⣬1-���
    BYTE    byScene;     //��������Ƿ��⣬0-����⣬1-���
    BYTE    byDark;      //ͼ����Ƿ��⣬0-����⣬1-���
    BYTE    byRes[13];
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;


typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;                //�ܲ���
    BYTE  byStepIndex;                //��ǰ�ڼ���
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;

//����IPC�б�
typedef enum tagNET_DVR_IPC_ENUM
{
    ENUM_BUSINESS_INVALID = -1,

        ENUM_BUSINESS_HIKVISION = 0,
        ENUM_BUSINESS_PANASONIC,
        ENUM_BUSINESS_SONY,
        ENUM_BUSINESS_AXIS,
        ENUM_BUSINESS_SANYO,
        ENUM_BUSINESS_BOSCH,
        ENUM_BUSINESS_ZAVIO,
        ENUM_BUSINESS_GRANDEYE,
        ENUM_BUSINESS_PROVIDEO,
        ENUM_BUSINESS_ARECONT, // 9
        ENUM_BUSINESS_ACTI,
        ENUM_BUSINESS_PELCO,
        ENUM_BUSINESS_VIVOTEK,
        ENUM_BUSINESS_INFINOVA,
        ENUM_BUSINESS_DAHUA,	//14

        ENUM_BUSINESS_HIK_STD_H264 = 0x20,
        ENUM_BUSINESS_HIK_STD_MPEG4,
        ENUM_BUSINESS_SUNELL ,	//����
        ENUM_BUSINESS_ATEME ,
        ENUM_BUSINESS_LAUNCH,	//�ʳ�
        ENUM_BUSINESS_YAAN,    //�Ű�
        ENUM_BUSINESS_BLUESKY,	//��ɫ�Ǽ�
        ENUM_BUSINESS_BLUESKYLIMIT,//��ɫ�Ǽ�LIMIT
        ENUM_BUSINESS_TDWY,			//���ΰҵ
        ENUM_BUSINESS_HBGK,			//����߿�
        ENUM_BUSINESS_SANTACHI,		//������
        ENUM_BUSINESS_HIGHEASY,		//����
        ENUM_BUSINESS_SAMSUNG,

        ENUM_BUSINESS_URL_RTSP = 0x40,    /* url����ȡ�� */
        ENUM_BUSINESS_ONVIF,

        ENUM_MAX_BUSINESS_TYPE,    //���������
} NET_DVR_IPC_ENUM, *LPNET_DVR_IPC_ENUM;

//��˴���ͳһ�����IPC�б�
typedef enum tagNET_DVR_IPC_ENUM_UNIFY
{
    ENUM_IPC_PROTOCOL_INVALID = -1,
        ENUM_IPC_PROTOCOL_HIKVISION = 0,  //��������
        ENUM_IPC_PROTOCOL_PANASONIC ,     //����
        ENUM_IPC_PROTOCOL_SONY ,          //����

        ENUM_IPC_PROTOCOL_AXIS = 4,       //��Ѷʿ
        ENUM_IPC_PROTOCOL_SANYO ,         //����
        ENUM_IPC_PROTOCOL_BOSCH ,         //����
        ENUM_IPC_PROTOCOL_ZAVIO ,         //ZAVIO
        ENUM_IPC_PROTOCOL_GRANDEYE ,      //GRANDEYE
        ENUM_IPC_PROTOCOL_PROVIDEO ,      //����
        ENUM_IPC_PROTOCOL_ARECONT ,       //������
        ENUM_IPC_PROTOCOL_ACTI ,          //����ͨ
        ENUM_IPC_PROTOCOL_PELCO ,         //�����
        ENUM_IPC_PROTOCOL_VIVOTEK ,       //���ͨѶ
        ENUM_IPC_PROTOCOL_DAHUA ,         //��
        ENUM_IPC_PROTOCOL_SAMSUNG ,       //����

        ENUM_IPC_PROTOCOL_PSIA = 17,      //PSIA
        ENUM_IPC_PROTOCOL_ONVIF ,         //ONVIF
        ENUM_IPC_PROTOCOL_BRICKCOM ,      //��שͨ��
        ENUM_IPC_PROTOCOL_GB28181 ,       //GB28181

        ENUM_IPC_PROTOCOL_CANON = 23 ,    //����

        ENUM_IPC_PROTOCOL_HUINT = 32,      //HUINT
        ENUM_IPC_PROTOCOL_INFINOVA ,       //Ӣ����
        ENUM_IPC_PROTOCOL_HIK_STD_H264,    //������׼264
        ENUM_IPC_PROTOCOL_HIK_STD_MPEG4 ,  //������׼MPEG4
        ENUM_IPC_PROTOCOL_SUNELL ,         //����
        ENUM_IPC_PROTOCOL_ATEME ,          //����ķ
        ENUM_IPC_PROTOCOL_LAUNCH ,         //�ɳ�
        ENUM_IPC_PROTOCOL_YAAN,				//�ǰ�
        ENUM_IPC_PROTOCOL_BLUESKY ,			//��ɫ�Ǽ�
        ENUM_IPC_PROTOCOL_BLUESKYLIMIT ,    //��ɫ�Ǽ�LIMIT
        ENUM_IPC_PROTOCOL_TDWY ,           //���ΰҵ
        ENUM_IPC_PROTOCOL_HBGK ,			//����߿�
        ENUM_IPC_PROTOCOL_SANTACHI,			//������
        ENUM_IPC_PROTOCOL_HIGHEASY,			//����
        ENUM_IPC_PROTOCOL_HANBANG ,         //����߿�
        ENUM_IPC_PROTOCOL_SAMSUNG_3120 ,    //����3120
        ENUM_IPC_PROTOCOL_SAMSUNG_3080 ,    //����3080
        ENUM_IPC_PROTOCOL_SAMSUNG_2000,     //����2000
        ENUM_IPC_PROTOCOL_SAMSUNG_5200 ,    //����5200
        ENUM_IPC_PROTOCOL_JINGYUAN ,        //��Ժ
        ENUM_IPC_PROTOCOL_VIDEOTREC ,       //����ӯ��
        ENUM_IPC_PROTOCOL_CHENOVA ,			//�Ϻ��Ϸ�
        ENUM_IPC_PROTOCOL_FENGHUO ,         //���
        ENUM_IPC_PROTOCOL_ZB_5301 ,         //�㽭����5301
        ENUM_IPC_PROTOCOL_ZB_5401 ,         //�㽭����5401
        ENUM_IPC_PROTOCOL_HAIXIN,			//����
        ENUM_IPC_PROTOCOL_ZHONGYINGXIN ,    //�����
        ENUM_IPC_PROTOCOL_AVUN ,			//��ŵ����
        ENUM_IPC_PROTOCOL_GOVTY ,           //���ݼ���
        ENUM_IPC_PROTOCOL_SAE ,				//�����
        ENUM_IPC_PROTOCOL_DONGFANGWANGLI,   //��������
        ENUM_IPC_PROTOCOL_CHANGHONG,		//����
        ENUM_IPC_PROTOCOL_H3C ,				//����
        ENUM_IPC_PROTOCOL_BAIAN ,           //�ٰ�
        ENUM_IPC_PROTOCOL_HAT ,				//����̩
        ENUM_IPC_PROTOCOL_YUANYE,			//Զҵ
        ENUM_IPC_PROTOCOL_HIKCARD ,			//�����忨
        ENUM_IPC_PROTOCOL_HAIXINCAP ,       //����ץ�Ļ�
        ENUM_IPC_PROTOCOL_WENANCAP ,        //�İ�ץ�Ļ�
        ENUM_IPC_PROTOCOL_XUNMEI ,			//Ѷ��
        ENUM_IPC_PROTOCOL_BAIWO ,			//����
        ENUM_IPC_PROTOCOL_APD ,				//���մ�
        ENUM_IPC_PROTOCOL_REACHDEV ,        //��ȡ
        ENUM_IPC_PROTOCOL_XUNMEI_DAHUA ,    //Ѷ����OEM
        ENUM_IPC_PROTOCOL_HUANGHE,			//�ƺ��豸
        ENUM_IPC_PROTOCOL_LIANCHEN ,		//���
        ENUM_IPC_PROTOCOL_CHENGYE,			//��ҵ
        ENUM_IPC_PROTOCOL_VISIONDIGI ,      //��Ǭ
        ENUM_IPC_PROTOCOL_HENGHE ,          //���
        ENUM_IPC_PROTOCOL_KODAK ,           //�ƴ�
        ENUM_IPC_PROTOCOL_AIRONIX,          //�����˹
        ENUM_IPC_PROTOCOL_LG,               //�ֽ�
        ENUM_IPC_PROTOCOL_HASEE ,          //����
        ENUM_IPC_PROTOCOL_8000ME ,          //8000ME
        ENUM_IPC_PROTOCOL_POVITEL ,         //���첩��
        ENUM_IPC_PROTOCOL_YIVIEW,           //��ά
        ENUM_IPC_PROTOCOL_TIANYUE ,         //��Ծ
        ENUM_IPC_PROTOCOL_HOWELL ,          //��ά
        ENUM_IPC_PROTOCOL_WAPA,             //����
        ENUM_IPC_PROTOCOL_SANLE ,           //����
        ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION,      //���ܺ����忨
        ENUM_IPC_PROTOCOL_JUNSDA ,          //���Ӵ�
        ENUM_IPC_PROTOCOL_LIYUAN ,          //��Ԫ
        ENUM_IPC_PROTOCOL_XINCHAN ,         //�Ų�
        ENUM_IPC_PROTOCOL_BITE ,            //����
        ENUM_IPC_PROTOCOL_MEIAN,            //����
        ENUM_IPC_PROTOCOL_ROSEEK,           //����
        ENUM_IPC_PROTOCOL_AEBELL ,          //���籴��
        ENUM_IPC_PROTOCOL_JSL_ST ,          //������ST
        ENUM_IPC_PROTOCOL_VIMICRO,          //����΢����

        ENUM_IPC_PROTOCOL_TYPE,    //���������
}NET_DVR_IPC_ENUM_UNIFY, *LPNET_DVR_IPC_ENUM_UNIFY;



typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD			    dwSize;			// �ṹ���С
    NET_DVR_STREAM_INFO	struStreamInfo;	// ��ص�
    WORD 			    wYear;      		// ��
    BYTE 			    byMonth;    		// ��
    BYTE			    byDrawFrame;	// 0-����֡ 1-��֡
    BYTE                byStreamType;   //0-������ 1-������
    BYTE                byRes[31];
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{
    DWORD			dwSize;			// �ṹ���С
    BYTE			byRecordDistribution[LEN_32];   // ¼��ֲ���byRecordDistribution[0]=1��ʾ1�մ���¼��byRecordDistribution[0]=0��ʾû��¼��
    //byRecordDistribution[1]��ʾ2�գ��Դ�����
    BYTE			byHasEventRecode[LEN_31];            //�¼�¼�� 0-���¼�¼��1-���¼�¼��
    BYTE			byRes;        				//����
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;


typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD	dwSize;	                    // �ṹ���С
    BYTE 	byGroup;			        // ��ţ�ÿ��ɻ�ȡ 64��ͨ������0��ʼ, 0��ʾ��1�飬�Դ�����
    BYTE	byProType;					//Э�����ͣ�0-˽��Э�飬1-����Э�飬2-����
    BYTE	byAccessMode;		        //����ģʽ��0-IP��ַ��1-����
    BYTE	byRes1;					    //�����ֶΣ���0
    char	szUserName[NAME_LEN];		//�û���
    char	szPassword[PASSWD_LEN];	    //����
    char	szDomain[MAX_DOMAIN_NAME];	//�豸����
    NET_DVR_IPADDR struIP;			    //IP��ַ
    WORD	wPort;			 	        // �˿ں�
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181Э�����ʱ���豸������ID
    BYTE	byRes2[2];				    //�����ֶΣ���0
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD	dwSize;	// �ṹ���С
    DWORD	dwTotalChannelNum;      //�豸��ͨ�������豸������ʱ����0��byChannel��Ч
    BYTE 	byChannel[MAX_CHANNUM_V30];    /*byChannel[i]Ϊ0��ʾ�ڣ�byGroup+1��*��i-1��ͨ��δ���뵽NVR��
                                    Ϊ1��ʾ��ͨ���ѽ��뵽NVR byGroup��NET_DVR_ACCESS_DEVICE_INFO��*/
    BYTE  byRes[32];           //����
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD	dwSize; //���
    BYTE	byGroup; //��ţ�ÿ�������64������
    BYTE	byVideoOutType; /*��Ƶ����ӿ�����,0-��CVBS,1-HDMI 2-VGA 3-�������һ
                     4-��������� 5-��������� 6-���������, 7-����HDMI, 8-��չHDMI1,
                     9-��չHDMI2, 10-��չHDMI3, 11-��չHDMI4, 12-��ͬԴVGA1��
                     13-��ͬԴVGA2��14-��ͬԴVGA3��15-��ͬԴVGA4��16-ͬԴVGA, 17-��LCD,18-����VGA,19-����LCD*/
    BYTE	byRes[2];
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD	dwSize;	// �汾���?�ṹ���С
                    WORD	wSwitchSeq[MAX_WINDOW_V40];/*bySwitchSeq [i]=6����ʾ�ڣ����*64+i+1��������
                    ��ʾ����ͨ����Ϊ0xff��ʾ�ô��ڲ���ʾ*/
                    BYTE	byPreviewNumber;/*Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16����, 4-6����, 5-8���棬6-25����,7-32����, 8-36����, 9-64����
                    0xff:�����*/
                    BYTE	byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
                    BYTE	bySwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
                    BYTE    bySameSource ; //�Ƿ�ͬԴ������Ƶ���������Ϊ��ͬԴVGA1-��ͬԴVGA4ʱ��Ч
                    BYTE	byRes[32];		//����
}NET_DVR_PREVIEW_SWITCH_CFG,* LPNET_DVR_PREVIEW_SWITCH_CFG;

typedef struct tagNET_DVR_USER_COND
{
    char		szUserName[NAME_LEN];
    BYTE		byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{
    DWORD			dwSize;
    BYTE			byAddMonitoringPointRight; // ��Ӽ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE			byModMonitoringPointRight; // �޸ļ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE			byDelMonitoringPointRight; // ��Ӽ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE			bySetRecordPlanRight; // �ƶ�¼�����Ȩ��0-�� 1-��
    BYTE			byDelRecordPlanRight; // ɾ��¼�����Ȩ��0-�� 1-��
    BYTE			byEnableOrDisableRecordPlanRight; // ���úͽ���¼��ƻ�Ȩ��0-�� 1-��
    BYTE			byManualRecordRight; // ������ֹͣ�ֶ�¼��Ȩ��0-�� 1-��
    BYTE			bySetAlarmRecordRight; // ����¼���趨Ȩ��0-�� 1-��
    BYTE			byRecordBackupRight; // ¼��浵Ȩ��0-�� 1-��
    BYTE			byRecordDownloadRight; // ¼������Ȩ��0-�� 1-��
    BYTE			byRecordDeleteRight; // ¼��ɾ��Ȩ��0-�� 1-�У�������
    BYTE			byDelBackupRecordRight; // ɾ��浵¼��Ȩ��0-�� 1-�У�������
    BYTE			bySetBackupVolumeRight; // ���ô浵��Ȩ��0-�� 1-��
    BYTE			byRecordPlayBackRight; // ¼��ط�Ȩ��0-�� 1-��
    BYTE			byLogDeleteRight; // ��־���Ȩ��0-�� 1-�У�������
    BYTE			byLogDownloadRight; // ��־����Ȩ��0-�� 1-�У�������
    BYTE			byAddUserRight; // ����û�Ȩ��0-�� 1-��
    BYTE			byDelUserRight; // ɾ���û�Ȩ��0-�� 1-��
    BYTE			byModUserRight; // �޸��û�Ȩ��0-�� 1-��
    BYTE			byAllocUserRight; // �û�Ȩ�޷���Ȩ��0-�� 1-��
    BYTE			byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD				dwSize;
    DWORD   			dwMaxNum; 		// ��󱸻���Ŀ
    BYTE 	  			byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;

//����N+1�豸������ģʽ��NVR��Ҫ�ⲽ��CVR����Ҫ
typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD	dwSize ;
    BYTE	byWorkMode;		//0-������ 1-����
    BYTE	byRes[127];       //����
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR	struIP;		// �豸IP
    char			szPassword[PASSWD_LEN];	//�������룬����׼���
    BYTE 			byAddType; 		// 0-���������ϣ���ӱ���1-�������ϣ���ӹ�����
    BYTE 			byDisableBackup; //���ݹ���ʹ�ܿ��� 0-����1-�ر� CVRĬ�Ͽ���
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR	struIP;		// �豸IP
    BYTE 			byDelType; 	// 0-ɾ��ָ���Ļ��������������1-ȫɾ
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;

typedef union tagNET_DVR_NPO_PARAM_UNION
{
    NET_DVR_ADD_PARAM	struAddParam;		//�����Ϣ
    NET_DVR_DEL_PARAM 	struDelParam;		//ɾ����Ϣ
}NET_DVR_NPO_PARAM_UNION, *LPNET_DVR_NPO_PARAM_UNION;

// N+1ģʽ�豸����
typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD					dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam;
    BYTE 					byType; 	/* 0-��ӣ���ӦunionParam�е�struAddParam 1-ɾ���ӦunionParam�е�struDelParam */
    BYTE  					byRes2[255];          // ����
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

// ��ݻ�Ǩ
typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD				dwSize;
    BYTE   				byEnable; 	// 0-��������ݻ�Ǩ 1-������ݻ�Ǩ
    BYTE   				byDelData; 	// ��byEnableΪ1����Ч 0-��ɾ���¼����� 1-ɾ���¼�����
    BYTE 	  			byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD 	dwSize;
    BYTE 	bySleepStatus;/*����״̬0-������ 1-����*/
    BYTE  	byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD 	dwSize;
    BYTE 	bySpeed;	/*0-���� 1-���� 2-����*/
    BYTE  	byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD				dwSize;
    DWORD				dwSrcLunID;		// ԴLUN ID
    DWORD   			dwDstLunID; 	// Ŀ��LUN ID
    BYTE 	  			byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD				dwSize;
    DWORD				dwLunID;					// LUN ID
    DWORD				dwHSize;					// ��չ�Ĵ�С��32λ
    DWORD				dwLSize;					// ��չ�Ĵ�С��32λ
    char				szArrayIDGroup[NAME_LEN];	// ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ΪĬ��
    char   				szNewLunName[MAX_NAMELEN]; 	// ��LUN��
    BYTE 	  			byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;


typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD				dwSize;
    char				szOldDvrNetDiskName[MAX_NAMELEN];		// ԭDVR���̹�����
    char   				szNewDvrNetDiskName[MAX_NAMELEN]; 	// ��DVR���̹�����
    NET_DVR_IPADDR		struWarrantIP;						// ����Ȩ��DVR����IP
    BYTE 	  			byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;


typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD				dwSize;
    DWORD				dwLunID;		// LUN ID
    BYTE 	  			byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD				dwSize;
    DWORD				dwTargetID;		// iSCSI�����Target ID
    DWORD				dwLunID;		// LUN ID
    DWORD				dwAccessMode;	//��д��ʽ 0-��д 1-ͬ����д 2-ֻ�� 3-����ֻ��;
    NET_DVR_IPADDR		struClientIP;		// �ͻ���IP��0.0.0.0Ϊ����IP
    BYTE 	  			byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD				dwSize;
    DWORD				dwStoreLunID;					// �洢LUN ID
    DWORD				dwLogicLunID;					// �߼�LUN ID��-1��ʾ�Զ����
    DWORD				dwHbaID;						// ����ͨ����
    DWORD				dwAccessMode;					//��д��ʽ 0-��д 1-ͬ����д 2-ֻ�� 3-����ֻ��;
    char				szClientWWWPN[NAME_LEN]; 		// �ͻ����˿�
    BYTE 	  			byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;


// �߼��� 60�ֽ�
typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD		dwHCapacity;	// �߼����С��32λ
    DWORD		dwLCapacity;	// �߼����С��32λ
    char    	szName[MAX_NAMELEN]; 	// �߼������
    DWORD		dwBlockSize;		// �߼������С�洢��Ԫ���С
    char		szArrayIDGroup[NAME_LEN]; 	//ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;

typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD			dwHCapacity;	// DVR���̴�С��32λ
    DWORD			dwLCapacity;	// DVR���̴�С��32λ
    char 	   		szName[MAX_NAMELEN]; 	// DVR�������
    DWORD			dwBlockSize;		// �߼������С�洢��Ԫ���С
    NET_DVR_IPADDR	struWarrantIP;		// ��Ȩ��DVR����IP
    char			szArrayIDGroup[NAME_LEN]; 	//ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;

typedef union tagNET_DVR_VD_UNION
{
    BYTE						byUnionLen[256];  	// �������С
    NET_DVR_OPERATE_VD_PARAM	struHikVDParam;		// �������
    NET_DVR_LUN_PARAM			struLunParam;			// �߼���
    NET_DVR_DVR_PARAM			struDvrParam;			// DVR����
}NET_DVR_VD_UNION, *LPNET_DVR_VD_UNION;

typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE				byVDType;	//����������ͣ�0-˽��������� 1-�߼��� 2-DVR����
    BYTE				byRes1[3];
    NET_DVR_VD_UNION 	uVDParam;
    BYTE				byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;

typedef struct tagNET_DVR_CVR_ALARM
{
    char    		szFirstType[NAME_LEN];  //�����ͣ�����Ϊ��
    char			szFirstIndex[NAME_LEN];	//�����ͱ��
    char			szSecondType[NAME_LEN];	//�����ͣ�����Ϊ��
    NET_DVR_TIME	struTime;		//����ʱ��
    BYTE 			byStatus;   	//״̬ 0-�� ��0-�����ͬ����ֵ��ʾ���岻ͬ�����±�
    BYTE		    byAlarmLevel;         //��������
    BYTE			byRes1[2];
    char           	szSecondIndex[NAME_LEN];  //�����ͱ�ţ�����Ϊ��
    char    		szThirdType[NAME_LEN];  //�������ͣ�����Ϊ��
    char			szThirdIndex[NAME_LEN];	//�������ͱ��
    char    		szFourthType[NAME_LEN];  //�������ͣ�����Ϊ��
    char			szFourthIndex[NAME_LEN];	//�������ͱ��
    BYTE      		byRes2[92];  //����
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR	struIP;			//�豸IP
    BYTE 			byLinkStatus; //����״̬ 0-����ʧ��1-���ӳɹ�
    BYTE 			byWorkStatus; //����״̬ 0-��1-�쳣
    BYTE 			byBacupStatus; //����״̬0-���ڱ���1-���ڱ���
    BYTE 			bySyncProgress; //¼��ͬ����ȣ�0��ʾδ��ʼ��100��ʾͬ�����
    NET_DVR_TIME_EX	struSyncBeginTime;	//ͬ����ʼʱ��
    NET_DVR_TIME_EX	struSyncEndTime;		//ͬ������ʱ
    char			szSerialNumber[SERIALNO_LEN] ; //�豸���к�
    DWORD			dwSoftwareVersion ;		//�豸����汾
    BYTE  			byWorkingDeviceGUID[GUID_LEN]; //������GUID�����ַ����ڱ���������������¼��
    char			szDevTypeName[DEV_TYPE_NAME_LEN];		//�豸�������
    WORD			wDevType;		//�豸����ֵ
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR	struIP;			//�豸IP
    BYTE 			byWorkStatus; 	//����״̬ 0-��1-�쳣
    BYTE 			byBackupStatus; //����״̬0-���ڼ�� 1-���ڼ��2-���ڱ�����2-����ͬ��
    WORD			wBackupPort;	//���ݶ˿�
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef union tagNET_DVR_NPO_DEV_INFO_UNION
{
    BYTE 							byUnionLen[512];			//�����峤��
    NET_DVR_WORKING_DEVICE_INFO		struWorkingDeviceInfo;		//��������Ϣ
    NET_DVR_REDUNDANT_DEVICE_INFO	struRedundantDeviceInfo; 	//������Ϣ
}NET_DVR_NPO_DEV_INFO_UNION, *LPNET_DVR_NPO_DEV_INFO_UNION;


typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD						dwSize;
    NET_DVR_NPO_DEV_INFO_UNION	unionDevInfo;
    BYTE						byType;	/*���� 0-�������ӦunionDevInfo�е�struWorkingDeviceInfo 	1-�����ӦunionDevInfo�е�struRedundantDeviceInfo*/
    BYTE 	  					byRes[127];
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;

//ipc�����
typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO	struStreamInfo[MAX_CHANNUM_V30];	// 64����ص�
    char  				szFileName[260];					// ���ļ���
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;


typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO	struStreamInfo; 	//��ص�
    WORD				wErrCode;    		//��Ӧ������
    BYTE				byRes[30];          //����
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

//IPC�����ļ�����
typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char  		szFileName[260];					// �����ļ���
    BYTE		byRes[32];
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD 	wRow;   	//������У�0��ʾû���?1��ʾ��1�г��?�Դ�����
    WORD	wErrCode;	//������
    BYTE	byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE 	struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPatternCmd; //��̨�켣����������,������涨��
    DWORD dwPatternID; //��̨�켣ID��ɾ�����й켣ʱ��Ч��
    BYTE  byRes[64];
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byOneTouchSwitch;//һ���, 0-�����ã�1-���� (��wActionType���ʹ��)
    BYTE  byRes1[2];
    DWORD dwParkTime; //����ȴ�ʱ�䣬��λs
    WORD  wActionType; //���������ͣ�0-�Զ�ɨ�裬1-֡ɨ�裬2-���ɨ�裬3-Ѳ��ɨ�裬4-����ɨ�裬5-Ԥ�õ㣬6-ȫ��ɨ�裬7-��ֱɨ��
    WORD  wID; //ID�ţ�Ѳ��ɨ�衢Ԥ�õ㡢����ɨ���ID��
    BYTE  byRes[128];
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    NET_VCA_POINT struPoint; //��λ���
    BYTE byTrackType; //��������0�����Զ�ȡ֤(��ͨȡ֤) 1�����ٵ�·���� 2�����е�·���٣��ֶ�����ȡ֤��3����̬ȡ֤
    BYTE byLinkageType;//��������:  0-����������  1-���������и���
    BYTE byRes[2];
    NET_VCA_POINT struPointEnd;/*��λ����յ�*/
    NET_DVR_TIME_V30 struTime;//�ֶ����ٶ�λ����ǰʱ�䡣
    DWORD  dwSerialNo;//��ţ�
    BYTE   byRes1[36];
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;

typedef enum tagVQD_TYPE
{
    VQD_BLUR_FLAG     = 0x00000001,    //ͼ��ģ��
        VQD_LUMA_FLAG     = 0x00000002,//�����쳣
        VQD_CHROMA_FLAG   = 0x00000004,//ͼ��ƫɫ
        VQD_SNOW_FLAG     = 0x00000008,//ѩ������
        VQD_STREAK_FLAG   = 0x00000010,//���Ƹ���
        VQD_FREEZE_FLAG   = 0x00000020,//���涳��
        VQD_SIGLOSE_FLAG  = 0x00000040,//�źŶ�ʧ
        VQD_PTZ_FLAG      = 0x00000080//��̨ʧ��
}VQD_TYPE;

typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD  dwSize ;        //�ṹ���С
    BYTE	byEnable;	    // ���ʹ�� 0 :�رգ����� 1:����
    BYTE 	byRes1[3] ;     //����
    BYTE	byVQDTypeEnable[32];     //VQD���ģʽ��0 --������ 1--����  ÿ��������Ͷ�Ӧ�������ȣ������ȵ��±���������͵��±�һ��
    /*����0 ͼ��ģ��     ����1 �����쳣 ����2 ͼ��ƫɫ*/
    /*����3 ѩ������     ����4 ���Ƹ��� ����5 ���涳��*/
    /*����6 �źŶ�ʧ     ����7 ��̨ʧ��*/
    BYTE byThresholdValue[32] ;       //��ֵ0~100����ͬ���ģʽ�и��Զ�Ӧ����ֵ
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //�������?ʽ
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //���ղ���ʱ���
    BYTE    byRes[324];      //����
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;


typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;   //ͨ����
    DWORD  dwVQDType;     // VQD�������
    NET_DVR_TIME struDiagnoseTime;    //���ʱ��
    BYTE     byScoreValue;       //����ֵ ���ٷ���
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO,*LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize ;        //�ṹ���С
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo ; //����쳣��Ϣ�ṹ��
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/];
    //������Դ״̬�б?byDecStatus[i]��ʾ��λ��i����ϵͳ״̬��0-��Ч��1-���У�2-��ͨ����(������ͨ������ǽ�ʹ���������)��3-���ܽ���
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST,*LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource; /*����Ľ�����Դ���Էֱ��ʺ�����0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,
                         6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,
                         19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536,
                         31-2448*2048,32-2448*1200,33-2448*800,34-XGA��1024*768����35-SXGA��1280*1024��,36-WD1(960*576/960*480),
    37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)*/
    DWORD  dwChannel; //����ͨ����
    NET_DVR_IPADDR  struIP;   //������IP
    WORD  wPort;         //�����߶˿ں�(���ܷ�����ͨѶ�˿�)
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO,*LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;  //��λ�ţ��˲������ͷŽ�����Դ�͵�½������ϵͳУ����
    NET_DVR_IPADDR struIP; //������ϵͳIP��ַ
    WORD  wPort;      //�˿ں�
    BYTE  byRes1[2];
    DWORD dwDecChan;  //����ͨ����
    BYTE  sUserName[NAME_LEN];	/* ������ϵͳ��½�ʺ� */
    BYTE  sPassword[PASSWD_LEN];	/* ������ϵͳ��½���� */
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO,*LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum; //��λ��,�����������Դʱ���صĲ�λ��
    DWORD dwDecChan; //����ͨ����
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND,*LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;     //����ʹ�ܣ�0-�޹�����1-����
    BYTE  byRes1[3];
    //byEnable = 1ʱ���²�����Ч
    DWORD dwYUVAddress[3]; //YUV�����ַ
    WORD  wWidth;       //YUV�����
    WORD  wHeight;      //YUV�����
    BYTE  byEnableAudio;  //ʹ����Ƶ��0-�����ã�1-����
    BYTE  byRes2[3];
    DWORD dwAudioAddr;  //��Ƶ�����ַ
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG,*LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD		dwSize;
    BYTE		byChanType;		//�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE		byRes1[3];
    DWORD		dwChanNo;		//ͨ����
    DWORD		dwSubChanNo;	//��λ��
    DWORD		dwVariableNo;	//�������
    BYTE		byRes2[60];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD		dwSize;
    WORD		wVariableIndex;		//������ţ�ֻ�ܻ�ȡ
    WORD		wVariableType;		//�������� 1-ģ���� 2-��������ֻ�ܻ�ȡ
    BYTE		sDescribe[NAME_LEN];//��������
    BYTE		byLimitLineType;	//������ֵ�������ͣ�0-��֧�ֱ�����ֵ���ã�1-����ֵ���ã������ޡ����ޣ���2-����ֵ����
    BYTE		byRes[31];			//����
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;


//ģ���������ز���
typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int   		nMeasureHigh;			// �������� �ⲿֵ*1000���� ����Ϊ����
    int   		nMeasureLow;			// �������� �ⲿֵ*1000����
    BYTE		byAlarmMode;			// ����ģʽ�����֣�-HHHH��-HHHL��-HHLL��HLLL��-LLLL��
    // ����1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������)
    BYTE 		byRes1[3];
    int			nAlarmValue[4];			// ������
    DWORD  		dwOsdCfg;				// ģ�����ַ���ӣ���λ��ʾ0-15��Ӧ��Ƶͨ��1-16
    DWORD		dwSensitive;			// �����ȷ�Χ10~1000���ⲿ float*1000�� �����ȱ�ʾ��ʵʱֵ�ı仯���������ȵķ�Χʱ�����ʾʵʱֵ�����˱仯��������Ϊû�з���仯���磺������Ϊ0.1�����ʾǰ���������ֵ֮�����0.1ʱ������Ϊ��ݷ���仯����Ҫ�ϴ������Ϊ1�����ʾ�仯����1ʱ�ϱ���
    DWORD		dwIPChanOsd;			// ����ͨ������ģ�����ַ�λ��ʾ��0~31��Ӧ����ͨ��1-32
    BYTE		byRes[24];
}NET_DVR_ALARM_SENSOR_POINT_CFG,*LPNET_DVR_ALARM_SENSOR_POINT_CFG;

typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
    BYTE		byRes[64];
}NET_DVR_ALARM_SWITCH_POINT_CFG,*LPNET_DVR_ALARM_SWITCH_POINT_CFG;

typedef union tagNET_DVR_ALARM_POINT_PARAM_UNION
{
    BYTE	byLength[64]; //�����峤��Ϊ64
    NET_DVR_ALARM_SENSOR_POINT_CFG struSensor;	//ģ������ز���
    NET_DVR_ALARM_SWITCH_POINT_CFG struSwitch;	//��������ز���
}NET_DVR_ALARM_POINT_PARAM_UNION,*LPNET_DVR_ALARM_POINT_PARAM_UNION;

//�����Ϣ
typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD		dwSize;
    DWORD		dwPointNo;			//���
    BYTE		sPointDescribe[NAME_LEN];		//�������
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam; //����������Ϊģ����ʱ��ʹ�ýṹ��struSensor������������Ϊ������ʱ��ʹ�ýṹ��struSwitch
    BYTE		byPointType;		//������ͣ�1-ģ������2-������
    BYTE		byChanType;		//�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE		byRes1[2];
    DWORD		dwChanNo;		//ͨ����
    DWORD		dwSubChanNo;	//��λ��
    DWORD		dwVariableNo;	//�������
    BYTE		byRes[16];			//����
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

//��ʷ��ݲ�ѯ
typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD		dwSize;
    BYTE		byMajorType;	//��ѯ��ʽ��1-ȫ����2-��ʱ�䣬 3-�����ͣ�4-ʱ��+����
    BYTE		byMinorType;	//1-��ţ�2-ͨ��+��λ+������
    BYTE		byRes1[2];
    NET_DVR_TIME struStartTime;	//��ʼʱ��
    NET_DVR_TIME struStopTime;	//����ʱ��
    BYTE		byChanType;		//ͨ�����ͣ�1-ģ������2-��������3-485ͨ����0xff��ʾ��Ч
    BYTE		byRes2[3];
    DWORD		dwChanNo;		//ͨ���ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwSubChanNo;	//��λ�ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwVariableNo;	//�����ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwPointNo;	//��ţ�0xffffffff��ʾ��Ч
    BYTE      	byRes3[32];		//����
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD		dwSize;
    NET_DVR_TIME struTime;	//ʱ���
    BYTE		byChanType;		//ͨ�����ͣ�1-ģ������2-��������3-485ͨ����0xff��ʾ��Ч
    BYTE		byRes1[3];
    DWORD		dwChanNo;		//ͨ���ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwSubChanNo;	//��λ�ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwVariableNo;	//�����ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD		dwPointNo;		//��ţ�0xffffffff��ʾ��Ч
    int			iData;			//��ʷ���
    BYTE		byDataType;		//0-����ݣ�1-Խ������ݣ�2-Խ�������
    BYTE		byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD	dwSize;
    BYTE	byDataUploadMode;	//1-��ͨ���ϴ���2-�������ϴ�
    BYTE	byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG,*LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;


typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE	byChanType;		//�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE	byPointType;	//�����ͣ�1-ң�⣨ģ��������2-ң�ţ���������
    BYTE	byRes1[2];		//����
    DWORD 	dwChanNo;		//485ͨ���ţ�0xffffffff��ʾ��Ч��ͨ������Ϊ1ʱ����ʾ����ģ����ͨ���ţ�ͨ������Ϊ2ʱ��ʾ���ؿ�����ͨ���ţ�ͨ������Ϊ3ʱ��ʾ485ͨ���š�
    DWORD	dwSubChanNo;	//��λ�ţ� 0xffffffff��ʾ��Ч��ͨ������Ϊ3ʱʹ��
    DWORD	dwVariableNo;	//������ţ�0xffffffff��ʾ��Ч
    DWORD 	dwPointNo;		//104��ţ�0xffffffff��ʾ��Ч
    int		iValue;			//�����ֵ
    BYTE	byRes[16];
}NET_DVR_ALARMHOST_POINT_VALUE,*LPNET_DVR_ALARMHOST_POINT_VALUE;

typedef union tagNET_DVR_ALARMHOST_DATA_UNION
{
    BYTE	byLength[40];
    NET_DVR_ALARMHOST_POINT_VALUE struPointValue;	//����ʵʱ���
}NET_DVR_ALARMHOST_DATA_UNION,*LPNET_DVR_ALARMHOST_DATA_UNION;

typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD		dwSize;
    BYTE		byDataType;		//������ͣ�1-����ʵʱ����ϴ�
    BYTE		byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE		byRes2[32];
}NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;     /*�ṹ����*/
    BYTE   byAudioInputChan;//��Ƶ����ͨ����
    BYTE   byRes[63];		// �����ֽ�
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE byAudioOutVolume;// ��������ȼ�����һ��Ϊ0-100��
    BYTE byRes[63];
}NET_DVR_AUDIOOUT_VOLUME,*LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE,*LPNET_DVR_FUZZY_UPGRADE;

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //����ģʽ��0-����̨��1-˽��͸��ͨ����2-͸��ͨ��
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //ʹ��͸��ͨ����0-��ʹ�ܣ�1-ʹ��
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //Զ���豸IP��ַ
    WORD wPort; //Զ���豸�˿�
    BYTE byRes2[18];
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //ʹ��͸��ͨ����0-��ʹ�ܣ�1-ʹ��
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //��������Զ���豸IP
    BYTE byRes2[16];
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //���ؼ���Ķ˿ںţ���RS485��һһ��Ӧ
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;

typedef union tagNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION
{
    BYTE byRes[512];
    NET_DVR_TRANSPARENT_CLIENT_MODE struClientMode;  //�ͻ���ģʽ����
    NET_DVR_TRANSPARENT_SERVER_MODE struServerMode; //������ģʽ����
}NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION, *LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;
    BYTE  byWorkMode; //����ģʽ��1-�ͻ���ģʽ��2-������ģʽ
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;

typedef enum tagNAKED_DATA_TYPE
{
    NAKED_DATA_TYPE_NOT_DEFINED = 0, //δ����
        NAKED_DATA_TYPE_POS_INFO    //���յ���Pos��Ϣ
}NAKED_DATA_TYPE;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP�˿ںţ�����Pos��Ϣ���գ���ֵΪ0����ʹ��Ĭ�϶˿�7050
    BYTE  byRes[130];      //�����ֽ�
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

#define UPLOAD_POS_INFO     1001  //�ϴ�Pos��Ϣ

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD 	struVerHead;  //�汾ͷ
    DWORD dwChannelNum;          //ͨ����
    BYTE  byRes[60];
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;


#define MAX_IGNORE_STRING_NUM		4
#define FILTERRULE_NUM              4
#define MAX_POS_FILTER_DATA_LEN     128

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //������
    NET_VCA_POINT   struEnd;    //�յ����
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;


typedef struct
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*���׿�ʼ��־��Ŀǰ���Ϊ32��ֻ��anyCharacterΪ��ʱ����Ч*/
    BYTE byRes[4];					/*����*/
}NET_DVR_GENERIC_START, *LPNET_DVR_GENERIC_START;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*���׽����־��Ŀǰ���Ϊ32*/
    BYTE  byRes[8];
} NET_DVR_GENERIC_END, *LPNET_DVR_GENERIC_END;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*��ݱ�־��Ŀǰ���Ϊ32*/
    BYTE  byRes[4];
}NET_DVR_GENERIC_DATA_CFG, *LPNET_DVR_GENERIC_DATA_CFG;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*���Ե��ַ�Ŀǰ���Ϊ32*/
}NET_DVR_IGNORE_STRING, *LPNET_DVR_IGNORE_STRING;

typedef struct
{
    BYTE  byCaseSensitive;/*�Ƿ���ִ�Сд��0->����֣�1->���*/
    BYTE  byRes1[7];
    NET_DVR_GENERIC_START struTransactionStart;/*���׿�ʼ*/
    NET_DVR_GENERIC_END struTransactionEnd;/*���׽���*/
    NET_DVR_GENERIC_DATA_CFG struLineDeli;/*�м����*/
    NET_DVR_IGNORE_STRING struIgnoreString[MAX_IGNORE_STRING_NUM];/*�����ַ�ĿǰΪ4��*/
    BYTE byRes[40];    //����
}NET_DVR_POS_GENERIC, *LPNET_DVR_GENERIC;

typedef struct
{
    DWORD	dwPosAddr;		//pos��ַ���
    BYTE    byRes[948];
}NET_DVR_POS_AVE, *LPNET_DVR_AVE;

typedef  union _NET_DVR_POS_PROTOCOL_UNION
{
    BYTE byLenth[952];   //���ڱ�ʾ�����峤�ȣ���ʵ������
    NET_DVR_POS_GENERIC struGeneric;
    NET_DVR_POS_AVE struAve;
}NET_DVR_POS_PROTOCOL_UNION,*LPNET_DVR_POS_PROTOCOL_UNION;

typedef enum tagNET_DVR_CHARSET_ENUM  //���뷽ʽ
{
    ENUM_UTF8 =0,
        ENUM_GB2312,
        ENUM_LATIN1,
        ENUM_LATIN2,
        ENUM_LATIN3,
        ENUM_LATIN4,
        ENUM_CYRILLIC,
        ENUM_ARABIC,
        ENUM_GREEK,
        ENUM_HEBREW,
        ENUM_TURKISH,
        ENUM_NORDIC,
        ENUM_THAI,
        ENUM_LATIN7,
        ENUM_LATIN8,
        ENUM_LATIN9,
        ENUM_LATIN10,
        ENUM_CENTRAL_EUROPEAN,
        ENUM_CYRILLIC_SCRIPT
}NET_DVR_CHARSET_ENUM, *LPNET_DVR_CHARSET_ENUM;


typedef struct
{
    DWORD   dwSize;
    BYTE 	byEnable;    		//����ʹ��
    BYTE 	byCharSetType;      //���뷽ʽ0-UTF-8,1-GB2312
    BYTE    byRes1;   //����
    BYTE	byProtocolType;//Э�����ͣ�1->generic textЭ��, 2->AVE VSI-ADD	 3->AVE Vnet,4-EPSON(���������账��posЭ�����)
    NET_DVR_POS_PROTOCOL_UNION uPosProtocol;   //POSЭ��
    BYTE    byRes[32];    //����
}NET_DVR_POS_FILTER_CFG, *LPNET_DVR_POS_FILTER_CFG;

typedef struct  tagNET_DVR_NET_SNIFF /*��������ṹ�� 312byte*/
{
    BYTE       byEnableSourcePort;       //�Ƿ����ö����Դ�˿ڹ���  0-�����ã�1-����
    BYTE       byEnableDestAddr;        //�Ƿ����ö�Ŀ��IP��ַ���й��� 0-�����ã�1-����
    BYTE       byEnableDestPort;         //�Ƿ����ö�Ŀ���ַ�Ķ˿ںŽ��й���
    BYTE       byRes1;                 //����
    BYTE	   bySourceIpAddr[MAX_DOMAIN_NAME];			    //���Դ��ַ
    BYTE	   byDestinationIpAddr[MAX_DOMAIN_NAME];		//��ݷ���Ŀ���ַ
    WORD   	   wSourcePort;   			//���Դ�˿ں�
    WORD   	   wDestinationPort;   		//��ݷ���Ŀ��˿ں�
    BYTE       byRes[16];                 //����
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;

typedef struct
{
    WORD  wNetPort;  /*device net port*/
    BYTE  byRes[2];
}NET_DVR_NET_RECEIVE, *LPNET_DVR_NET_RECEIVE;

typedef struct tagNET_DVR_MONITOR_INFO  /*����*/
{
    WORD  wPort;       //����˿ں�
    BYTE  byRes[310];     //����
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;

typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP; //IP��ַ
    WORD wPort;	//�˿ں�
    BYTE byRes[2];
}NET_DVR_ADDRESS,*LPNET_DVR_ADDRESS;

typedef union tagNET_DVR_POS_CONNECTMODE_UNION
{
    BYTE   					byLen[312];      //�����峤�ȣ���ʵ������
    NET_DVR_NET_RECEIVE 	struNetRecv;     //�������ģʽ
    NET_DVR_MONITOR_INFO 	struTcpMonitor;	//�������ģʽ
    NET_DVR_SINGLE_RS232 	struRS232;		//���ڷ�ʽ
    NET_DVR_MONITOR_INFO 	struUdpMonitor; 	//�������-UDPģʽ
    NET_DVR_NET_SNIFF      	struSniff;  		//��������ģʽ
    NET_DVR_ADDRESS    		struMcast;  		//�ಥģʽ
    NET_DVR_USB_RS232 		struUSBRS232;	//USBת���ڷ�ʽ
}NET_DVR_POS_CONNECTMODE_UNION, *LPNET_DVR_POS_CONNECTMODE_UNION;


//DVR��POS���ӷ�ʽ���ýṹ��
typedef struct tagNET_DVR_CONNECT_POS_CFG
{
    DWORD   dwSize;       		//�ṹ���С
    BYTE     byConnectMode;	//����ģʽ:0->�������(TCP),1->�������,2->���ڽ���3-�������UDP��,4-��������,5-�ಥ
    BYTE     byRes1[3];         //����
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;	//����ģʽ����
    BYTE  byRes[64];
}NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD  				dwSize;  			//�ṹ���С
    BYTE	  			byFilterID;       	//POS���˹���ID
    BYTE 				byFontSize;         //�ֺŴ�С��0-- 8*16  1--16*32  2--32*64
    BYTE  				byShowPosInfo;		//�������Ƿ����pos��Ϣ
    BYTE                byOverlayMode;      //���ӷ�ʽ��0-������1-��ҳ
    DWORD 				dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR	    struOsdColor;   		//OSD��ɫ
    NET_DVR_SCHEDTIME	    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    //�쳣���?ʽ�б������������Ű󶨣������Ϊ0ʱ����ʾ�����ı�������ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ�����ı�������ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں���ı���������Ч
    DWORD  		        dwMaxRelRecordChanNum ;  //����������¼��ͨ����ֻ�������֧������
    DWORD  		        dwRelRecordChanNum ;     //�����ڹ�����¼��ͨ����
    DWORD  		        dwRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    //������¼��ͨ��������Ű󶨣������Ϊ0ʱ����ʾ������ͨ���ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ������ͨ���ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ�����ں���Ĺ���ͨ������Ч
    BYTE  			byRes[64];    //����
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG;

#define		MAX_LAN_ENCODE_LEN		32	//���Ա����ʽ��󳤶�
typedef struct	tagNET_DVR_DEVICE_LAN_ENCODE
{
    DWORD		dwSize;
    BYTE		byLanEncode[MAX_LAN_ENCODE_LEN];	//�豸���Ա����ʽ
    BYTE		byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD	dwSize;
    BYTE	byEnable; //ʹ�ܣ��Ƿ��� 0~������,1~����
    BYTE	bySensitiveLevel;// 1-100��Ĭ��50��������Խ�ߣ�Խ���ױ���
    BYTE	byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    DWORD	dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD	dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD	dwRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    //����������¼��ͨ�������ֽڵ�ͨ���ţ���ʼֵ�� 0xffffffff��
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION,*LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD            dwSize;     	 // �ṹ��С
    NET_VCA_DEV_INFO struDevInfo;    //ǰ���豸��Ϣ
    BYTE             byRes[128];      // �����ֽ�
}NET_DVR_SCENECHANGE_DETECTION_RESULT,*LPNET_DVR_SCENECHANGE_DETECTION_RESULT;
typedef enum
{
    PREVIEW_MOD = 0,
        ALARM_MOD,
        PLAYBACK_MOD,
        MAX_TYPE
}MODULE_TYPE;

//��λ��Ϣ
typedef struct tagNET_DVR_PARK_INFO
{
    char          sPlateNo[MAX_PlATE_NO_LEN];             //���ƺ���
    char          sParkIndex[MAX_PlATE_NO_LEN];        //��λ���
    BYTE		  byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;


typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD				 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*����ʱ��*/
    NET_DVR_PARK_INFO    struParkInfo; //��λ��Ϣ
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //����Ϣ
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //��Դ��Ϣ
}NET_DVR_STREAM_SRC_CFG,*LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP, 9-RTP+PS����꣺GB28181����0xff-��Ч
    BYTE  byVideoEncType;//��Ƶ�������ͣ�0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��0xff-��Ч
    WORD  wWidth; //ͼ����
    WORD  wHeight; //ͼ��߶�
    BYTE  byRes1[2];
    DWORD dwVideoBitrate; 	//��Ƶ����,��λKbps
    DWORD dwVideoFrameRate;	//֡�ʣ�200���ʾС��1֡/���״̬������ֵ��ʾʵ��֡��ֵ,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//��Ƶ�������ͣ�0-G722��1-G711_U��2-G711_A��5-MPEG2,6-G726��7-AAC,0xff-��Ч
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;


typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//��ID��ת��ͨ����Ϣ
    BYTE  byMode;//ת��ģʽ��1-����ת�룬2-����ת��
    BYTE  byLinkNums;//������
    BYTE  byPassiveTransMode; //����ת��ģʽ��0-��Ч��1-ʵʱ����2-�ļ���
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//Ŀ��ת��ip��ַ
    BYTE  byTransResource;//��ʹ�õ�ת����Դ��D1����
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//Դ������Ϣ
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//Ŀ�������Ϣ
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//ȫ��ת����Դ����D1Ϊ��λ����
    DWORD dwIdleResource;//ʣ��ת����Դ����D1Ϊ��λ����
    BYTE  byCpuLoad;//CPU������
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-ͨ��ģʽ��2-��IDģʽ
    BYTE  byDisplayMode; //0-��ͨ��1-����
    BYTE  byEnableVcaDec; //�Ƿ��������ܽ��룬0-�����ã���0-����
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE,*LPNET_DVR_DEV_WORK_MODE;


typedef struct tagNET_DVR_PASSIVETRANSINFO
{
    DWORD dwSize;
    BYTE byStreamType;// �������ͣ�0-��������1-������
    BYTE byLinkMode;// 0��TCP��ʽ,1��UDP��ʽ��������
    BYTE byPassiveTransMode; //����ת��ģʽ��1-ʵʱ����2-�ļ���
    BYTE byRes1[5];
    BYTE byDataType;//���������ͣ�1-SDP��2-����ͷ
    BYTE byRes2;
    WORD wDataLength;//��ݳ���
    char *pBuffer;//������
    BYTE byRes3[32]; // ����
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;        //�Ƿ���ʾ��1-��ʾ��0-����
    BYTE  byBaseMapType;    //��ͼ���ͣ�1-ͼƬ��ͼ��2-�����������ͼ
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     //��ͼ�ţ���ͼ����Ϊ1ʱ���˲���ΪͼƬ��ţ���ͼ����Ϊ2ʱ�˲���Ϊ������������ϵͳ����ںţ�1�ֽھ����+1�ֽ��Ӱ��+1�ֽ�����ں�+1�ֽڱ�����
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG,*LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //�ֱ��ʣ�MAKE_RESOLUTION�궨���ֵ���ӵ���ǽ������ȡ֧�ֵķֱ���ֵ
    BYTE  byRes2[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    NET_DVR_RECTCFG_EX struWinPosition;//Ŀ�Ĵ���(�����ʾǽ),��ͼ���ڵ���ʼ���ʹ�С�����ǻ�׼��������
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//ͼƬ���
    BYTE   byUsed; //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-����
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO,*LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO��С������BMP���ļ�ͷ��ͼƬ��С���ޣ���100K���ߺͿ�����32�ı���
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO,*LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo�Ƿ���ڣ�0-�����ڣ�1-���ڣ��˲���ֻ�ܻ�ȡ��
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO��С������BMP���ļ�ͷ(�˲���ֻ�ܻ�ȡ)
    BYTE   byLogoName[NAME_LEN];  //logo���
    DWORD  dwLogoNo;	//logo��ţ���ȡ����logo��Ϣʱ��Ч��
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG,*LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo��
    BYTE   byEnable; //logo�Ƿ���ʾ��1-��ʾ��0-����
    BYTE   byRes1[3];
    DWORD  dwCoordinateX;	//ͼƬ��ʾ����X���
    DWORD  dwCoordinateY;	//ͼƬ��ʾ����Y���
    BYTE   byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE   byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE   byRes2[34];				//����
}NET_DVR_WIN_LOGO_CFG,*LPNET_DVR_WIN_LOGO_CFG;


typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //���ںţ���1��ʼ��0��ʾ��ͼ
    BYTE  byEnable; //�Ƿ����Ƶ��1-����Ƶ��0-�ر���Ƶ
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //0-��״̬��1-�Ŵ�״̬
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //�Ŵ����򣬵�byZoomStatusΪ1ʱ��Ч
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS,NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;     	 // �ṹ��С
    DWORD           dwChannel;;     // ͨ����
    BYTE            byRes[16];      // �����ֽ�
}NET_DVR_RESUME_INITRACKPOS_CFG,*LPNET_DVR_RESUME_INITRACKPOS_CFG;

typedef  struct tagNet_DVR_TEST_SELFCHECK_RESULT
{
    DWORD   dwSize;
    DWORD   dwChannel;      //ͨ����
    BYTE    bySelfCheckStatus;   //�Լ�״ֵ̬ 0-δ��ʼ��1-�ɹ���2-ʧ�ܣ�3-�Լ���
    BYTE    byRes[23];   //�����ֽ�
}NET_DVR_TEST_SELFCHECK_RESULT, *LPNET_DVR_TEST_SELECHECK_RESULT;

#define  MAX_TEST_COMMAND_NUM 32
typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;
    DWORD   dwChannel;       //ͨ����
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM];
    //0-��ʾ���������ԣ� 1-��ʾ��������
    //�����±�0 �����ϻ����Գ���
    //�����±�1 ����ƽ������ģʽ
    //�����±�2 ICR�ϻ����ԣ�0��ʾ�رգ�1��ʾ������������bit0 ��ϣ���0000_0001(ֻ����Ѳ���ϻ�)��0000_0101��ͬʱ����Ѳ����ICR�ϻ�����0000_0100��ֻ����ICR�ϻ���
    WORD    wICRIntervalTime;//icr���ʱ�䣨byTestCommand �����±�2�ڵ�ֵΪ1ʱ��ICR���ؼ��ʱ�䣬��λ�룩
    BYTE    byRes[18];      //�����ֽ�
}NET_DVR_TEST_COMMAND,*LPNET_DVR_TEST_COMMAND;

#define MAX_DEVMODULE_NUM 8
typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //ͨ����
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //���Ե��豸����
    // 0-����������,1-��������
    // bit0-���Է���1
    // bit1-���Է���2
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //���Ե��豸����
    // 0-����������,1-��������
    // bit0-���Լ�����1
    // bit1-���Լ�����2
    BYTE    byRes[22];      //�����ֽ�
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;

//���������
typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE  byLaneNo;//�����ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-����1��
    BYTE  byRes[3];
}NET_DVR_BARRIERGATE_COND,*LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-�޲���,1-����բ
    BYTE   byRes1 ;
    WORD   wAlarmOperateType;//0-�޲���,bit0-�̵���������� bit1-�����ϴ����� bit3-�澯�����ϴ����ɸ�ѡ��(0-��ʾ�أ�1-��ʾ��)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL,*LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-�������豸��1-����բ��2-�ص�բ��3-ͣ��բ��4-�����źš�5-������
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM,*LPNET_DVR_RELAY_PARAM;

//���������
typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable ;// ʹ��0-��ʾ�رգ�1-��ʾ��
    BYTE    byBarrierGateCtrlMode;//0-����Զ����ƣ�1-ƽ̨�ⲿ����
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//��������ģʽ �ο�ITC_TRIGGERMODE_TYPE
    /*0x00: ����ƥ��*/
    /*0x01: ����ƥ�䣨������ɫ��*/
    /*0x02: ����ƥ�䣨��������ɫ��*/
    /*0x04: ����ƥ��*/
    DWORD  dwMatchContent;  //�쳣����,�쳣���?ʽ��"��"���
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//�̵�������������Ϣ(һ���̵���ֻ�ܿ���һ�������豸) ����0��ʾ�̵���1 ����1��ʾ�̵���2 �������� 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //����IO���������IO������������0��ʾIO1������1��ʾIO2���������� ; ��������ֵ�ĺ��壨0-�ޣ�1-��բ����λ��2-��բ�ص�λ��3-���������
    //������Ϣ�ܿ�
    //����0��ʾ��ʱ�������õ�ģʽ
    //����1-��������ģʽ,
    //����2-��������ģʽ
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//������Ϣ�ܿ�
    BYTE    byRes2[64];
}NET_DVR_ENTRANCE_CFG,*LPNET_DVR_ENTRANCE_CFG;
////////////////////////////����ڲ������� end///////////////////////////////

// ��բ����
typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byLaneNo;  //��բ�ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-��բ1��
    BYTE  byBarrierGateCtrl;//0-�رյ�բ,1-������բ,2-ֹͣ��բ 3-���բ
    BYTE  byEntranceNo;//����ڱ�� [1,8]
    BYTE  byRes[13];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;

//����ںڰ�������ͬ��
typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//ͨ����0xff - ȫ��ͨ����ITC Ĭ����1��
    DWORD  dwDataIndex;//�����ˮ�ţ�ƽ̨ά�������Ψһֵ���ͻ��˲�����ʱ�򣬸�ֵ������Ч����ֵ��Ҫ�����������ͬ����
    char   sLicense[MAX_LICENSE_LEN]; //���ƺ���
    BYTE   byListType;//�����ԣ��ڰ���0-����1-����
    BYTE   byPlateType;	//��������
    BYTE   byPlateColor;	//������ɫ
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // ����
    NET_DVR_TIME_V30  struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30  struStopTime;//��Ч����ʱ��
    //������ƽ̨ͬ������ˮ�Ų����ظ��������������£����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0��2014-03-03
    char        sOperateIndex[MAX_OPERATE_INDEX_LEN];
    BYTE  byRes1[224]; // �����ֽ�
} NET_DVR_VEHICLE_CONTROL_LIST_INFO,*LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;

//���ȫ����ȡ�ӿ� �������ӻ�ȡ��
typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//ͨ����0xffffffff - ȫ��ͨ����ITC Ĭ����1��
    DWORD  dwOperateType;//�������ͣ�����VCA_OPERATE _TYPE�����ɸ�ѡ��
    char   sLicense[MAX_LICENSE_LEN];//���ƺ���
    char   sCardNo[MAX_CARDNO_LEN]; // ����
    BYTE   byListType;//�����ԣ��ڰ���0-����1-����0xff-ȫ��
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//�����ˮ��
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND,*LPNET_DVR_VEHICLE_CONTROL_COND;

//�ڰ��������Ҫͬ������
typedef struct
{
    DWORD    dwSize;
    DWORD    dwDataIndex;//�����ˮ�ţ����ֵ�����豸��ǰ���յ�����ݵ����һ�������ˮ��,ƽ̨ͬ����ʱ�����һ����ˮ�ſ�ʼͬ����
    char     sOperateIndex[MAX_OPERATE_INDEX_LEN];  //������ƽ̨ͬ������ˮ�Ų����ظ��������������£����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0�� 2014-03-03
    BYTE     byRes[32];
}NET_DVR_VEHICLE_CONTROL_LIST_DSALARM, *LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM;

//�����������ڰ���
typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //�����ԣ��ڰ���0-����1-����2-��ʱ��
    BYTE  byPlateType;  //��������
    BYTE  byPlateColor;	//������ɫ
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//���ƺ���
    char  sCardNo[MAX_CARDNO_LEN];  // ����
    NET_DVR_TIME_V30 struAlarmTime; //����ʱ��
    BYTE  byRes2[64];
}NET_DVR_VEHICLE_CONTROL_ALARM,*LPNET_DVR_VEHICLE_CONTROL_ALARM;

//�������
typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//����ʱ��
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM,*LPNET_DVR_FIRE_ALARM;

//����豸���ƺ�����ݿ���Ϣ
typedef struct
{
    DWORD dwSize;
    DWORD dwDelType;//ɾ���������ͣ�ɾ���������ͣ�����VCA_OPERATE _TYPE�����ɸ�ѡ��
    char  sLicense[16]; //���ƺ���
    char  sCardNo[48]; // ����
    BYTE  byPlateType;	//��������
    BYTE  byPlateColor;	//������ɫ
    BYTE  byOperateType;	//ɾ���������(0-����ɾ��,0xff-ɾ��ȫ��)
    //2014-02-25
    BYTE  byListType;//�����ԣ��ڰ���0-����1-���� 2014-03-03
    DWORD dwDataIndex;//�����ˮ��
    //������ƽ̨ͬ������ˮ�Ų����ظ��������������£����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0��2014-03-03
    char  sOperateIndex[MAX_OPERATE_INDEX_LEN];
    BYTE  byRes[24];
} NET_DVR_VEHICLE_CONTROL_DELINFO, *LPNET_DVR_VEHICLE_CONTROL_DELINFO;

//�����ƹ���
typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byLaneNo; //��բ�ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-��բ1��
    BYTE  byBrightlampCtrl;//0-�رճ����ƣ�1-����������
    BYTE  byRes[14];
}NET_DVR_GATELAMP_INFO,*LPNET_DVR_GATELAMP_INFO;


//SDI����1.0
#define  MATRIX_MAX_OUTPUT_NUM      256              //����������ͨ������
typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize;
    DWORD dwValidInputNum;     //��Ч������ͨ����
    DWORD dwValidOutputNum;    //��Ч�����ͨ����
    BYTE  byRes[64];
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize;
    DWORD   dwInputChan;        //����ͨ���ţ�Ϊ0��ʾȡ���ָ������Ĺ�����ϵ
    DWORD   dwOutputChan;       //Ҫ�л��������ͨ����, (��Ļ������Ϊ��Ļ�����(1�ֽ��豸��+1�ֽڱ���+2�ֽ���Ļ�����)), 0xffffffff��ʾ�л����������
    DWORD   dwMatrixID; //����ID��
    BYTE    byRes[28];
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize;
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //���ͨ������������ͨ��, dwIORelation[i] = j��ʾ���ͨ��(i + 1)������ͨ��j����,
    //dwIORelation[i] = 0��ʾ���ͨ��i + 1δ��������ͨ��
    BYTE    byRes[256];
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;


//�����ӿ�����
typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-����(����)��1-Զ�����ͷ�豸��2-����ڿ��ƻ�3-led��  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byRelativeIndex;//0-����(����)������(����ڽ�������) ��Χ 1~8 Led���������Χ�ǣ�1��255��   0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    //	BYTE   byLaneID;// �߼�������
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND,*LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//0-����1-Զ�����ͷ�豸��2-����ڿ��ƻ�3-led��
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE	byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//DEV IP��ַ 144
            WORD     wDevPort;//�豸�˿�
            BYTE     byRes[510];
        }struRrReader;//Զ�����ͷ�豸
        struct
        {
            BYTE byRs485No; //RS485���(����豸����һ��ñ�ſ����ظ������Ͳ�һ��ñ�Ż���)
            BYTE byDevCtrlCode;//�����ַ����������豸(1-255)
            BYTE byAutoIssuedData;//�Ƿ��Զ��·���Ƭ��� 0-���Զ��·���1-�Զ��·�
            BYTE byOfflineDetEnable;//���߼�� 0-�رգ�1-����
            BYTE byDetCycle;//������ڣ�0��60 ��λ s��
            BYTE byRes[651];
        }struGateway;//����ڿ��ƻ�
        struct
        {
            BYTE byExternalMode;//0-RS485,1-����
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP��ַ 144 (��byExternalMode == 1 ʱ��Ч)
            WORD wDevPort;//�豸�˿�(��byExternalMode == 1 ʱ��Ч)
            BYTE byRs485No; //RS485���(����豸����һ��ñ�ſ����ظ������Ͳ�һ��ñ�Ż���)
            BYTE byDevCtrlCode;//�����ַ����������豸(1-255)
            //led��ͨ����ƿ�������ʾ�ģ���ͬ�Ŀ��ƿ�����֧�ֵ���ʾ��ʽ��ͬ
            BYTE byCtrlCardType;//���ƿ����� 0-����(��Чֵ) 1- EQ2013
            BYTE byLedScreenType;//������ 0-��ɫ�� 1-˫ɫ��
            BYTE byLedScreenUse;//����;0-���� 1-��λ�� 2-��ʾ�� 3-�շ���
            BYTE byLedDisplayMode;//��Ļ������ʾ��ʽ: 1 "������ʾ",	2 "����" ,3 "����" ,4 "����", 	5 "����"
            char sLedCustomInfo[MAX_LED_INFO];//��Ļ������ʾ��Ϣ
            //led�����ɿ��ƿ����Ƶģ�led�����Ը����Ŀʵ��ʹ�ø��С����ʱ��Ҫ�ն�֪ͨ���ƿ�Ŀǰʹ�õ����������
            DWORD dwLedScreenH;//��ʾ����ɸ߶�����Ҫ��LED����
            DWORD dwLedScreenW;//��ʾ����ɿ������Ҫ��LED����
            BYTE byRes1[236];
        }struLed;//led��
    }uExternalDevInfo; //��byExternalMode ֵ�������ĸ���Ч
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;

//�����ӻ�ȡ����
typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS//Զ�����ͷ�豸
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//�豸���
    BYTE   byExternalDevTpye;//0-����(����)��1-Զ�����ͷ�豸��2-����ڿ��ƻ�3-led��  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byRelativeIndex;//0-����(����)���������(����ڽ���������) ��Χ 1~8  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byOnline;//0-�����ߣ�1-����
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS,*LPNET_DVR_EXTERNAL_DEVSTATUS;

//�ն˳���ڼ������
typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;		//�ṹ����
    //���߼�⿪��ʱ������⵽�豸���ߣ������ն�ƥ�俨Ƭ��Ϣ�������͵�բ����ָ������ڿ��ƻ�����ɳ���ڿ��ƻ�����ƥ����Ƶ�բ
    BYTE   byOfflineDetEnable;//���߼�� 0-�رգ�1-����
    BYTE   byDetCycle;//������ڣ�0��60 ��λ s��
    BYTE   byDevCtrlCode;//����ڿ��ƻ����ַ����������豸(1-255)
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG,*LPNET_DVR_ENTRANCEDET_CFG;

//�ն˳���ڿ���(���ƽӿ� �·���Ƭ��Ϣ)
typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD  dwSize; //�ṹ����
    BYTE   byDevCtrlCode;//����ڿ��ƻ����ַ����������豸(1-255)
    BYTE   byManualIssuedData;//�ֶ�����·� 0-�رգ�1-����
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND,*LPNET_DVR_ENTRANCEDEV_COMMAND;

//�ն˳���ڿ���(���ƽӿ� ����·���Ƭ��Ϣ)
typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize; //�ṹ����
    BYTE   byDevCtrlCode;//����ڿ��ƻ����ַ����������豸(1-255)
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL,*LPNET_DVR_ENISSUED_DATADEL;

//����ڹ��շ���ϸ������ʽ��
typedef  struct  _tagNET_ITS_PASSVEHICLE_COST_ITEM
{
    DWORD   dwSize;		//�ṹ����
    DWORD   dwPassVehicleID; //�������������ݵĹ���������
    BYTE    byIntime[MAX_TIME_LEN]; //�볡ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byOuttime[MAX_TIME_LEN]; //����ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byCardNo[MAX_CARD_LEN];   //����
    BYTE    byPlateInfo[MAX_LICENSE_LEN]; //���ƺ���
    float   fPayCost;       //�շѽ��(��λԪ)
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //������Ա���
    BYTE    byVehicleType; //��������  0-С�ͳ� 2 ���ͳ�
    BYTE    byRes1[3]; //Ԥ���ֶ�1
    DWORD   dwPayRuleID; // �շѹ�����ˮ��
    DWORD   dwFreeRuleID; // ���������ˮ��
    BYTE    byRes2[256]; // Ԥ���ֶ�2
}NET_ITS_PASSVEHICLE_COST_ITEM, *LPNET_ITS_PASSVEHICLE_COST_ITEM;

//����ڽ��Ӱ���ݣ�����ʽ��
typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;		//�ṹ����
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //������Ա���
    BYTE    byOperatorCard[MAX_CARD_LEN]; //������Ա����
    BYTE    byStartTime[MAX_TIME_LEN];//�ϰ�ʱ���ʽ����yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //�°�ʱ���ʽ����yyyymmddhh24miss
    float   fTotal_Pay;    //�����ϰ��ڼ��ܵ��շѽ��(��λԪ)
    DWORD   dwTotal_Records;   //�����ϰ��ڼ��ܵĹ��շѵļ�¼����
    BYTE    byRes[64]; //Ԥ��
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;


typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //�������ͣ����ITC_TRIGGERMODE_TYPE
    BYTE   byRes[24];
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;



typedef struct tagNET_DVR_TEMP_HUMI
{
    DWORD    dwSize;            // ���ݳ��� && �汾�����ں�����չ��
    DWORD  	 dwChannel;         // ͨ���ţ�Ĭ��1
    int      iHumidity;         // ʪ�ȣ�����֣�val/1000��С��֣�val%1000
    int      iTemp;             // �¶ȣ�����֣�val/1000��С��֣�val%100
    BYTE     byRes[8];          // �����ֽ�
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;


typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;      // ���ݳ��� && �汾�����ں�����չ��
    DWORD    dwChannel;     // ͨ���ţ�Ĭ��1
    DWORD    dwSoundMode;   // ����ģʽ: 0����ģʽ��1����ģʽ��2����ģʽ
    BYTE     byRes[12];     // �����ֽ�
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{
   	DWORD    dwSize;// ���ݳ��� && �汾�����ں�����չ��
    DWORD    dwChannel; 		// ͨ���ţ�Ĭ��1
    DWORD    dwMode;		// ��ȫģʽ: 1���ã��������ܣ�2�����ã�����������
    char     szRandCode[6];   //�豸������"�����֤��"
    BYTE     byRes[6];         // �����ֽ�
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD dwSize;
    BYTE  byPreviewFpsAdjMode;   /* Ԥ��֡�ʵ���ģʽ:0-�����ڣ���׼֡��Ԥ��,1-��׼��֡��Ԥ��,2-���GPS�ٶȽ���֡�ʵ��� */
    BYTE  bySelPeccType;           /* �Ƿ�ѡ��Υ������ */
    BYTE  byOptHabit;             /* ȡ֤����ϰ��, 0:����ȡ֤;1:�̰�����ȡ֤ */
    BYTE  byEnablePeccRec;      /* 1: ʹ��Υ��¼��ץȡ, 0: ��ֹΥ��¼��ץȡ */
    BYTE  byPicSize;				/*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA��7-XVGA��8-HD900p��9-HD1080��10-2560*1920��11-1600*304��12-2048*1536��13-2448*2048,14-2448*1200��15-2448*800��16-XGA(1024*768)��17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;			/* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG,*LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD		 dwSize;
    NET_DVR_IPADDR	struAddr;		            // ƽ̨������IP
    WORD   	     wServerPort;   	            // ƽ̨����������˿ڣ�
    BYTE	     bySeverProtocolType;	        //ƽ̨Э������ 1-˽�У�2-Ehome
    BYTE   	     byStatus;         	            //�豸ע�ᵽ��ƽ̨��״̬��1-δע�ᣬ2-��ע��
    BYTE         sDeviceId[NAME_LEN/*32*/];     //�豸ID
    char	     sPassWord[PASSWD_LEN];
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE         sPlatformEhomeVersion[NAME_LEN];//ƽ̨EHOMEЭ��汾
    /********* IPC5.1.7 �������� end 2014-03-21***********/
    BYTE		 byNetWork;				//0- �����壬1-�Զ���2-�����������ȣ�3-�������磬4-3G����
    BYTE		 byAddressType;			//0 - ������, 1 - ipv4/ipv6��ַ��2 - ����
    BYTE   		 byRes1[2];
    BYTE		 sDomainName[MAX_DOMAIN_NAME/*64*/]; //����
    BYTE   		 byRes[140];      	// �����ֽ�
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;

//�����ṹ
typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //ͨ����
    BYTE    byDetSceneID;//��ⳡ����[1],���ǰ֧��1������, IPCĬ����0
    BYTE    byRes[63];
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//Ŀ����٣�0-�رգ�1-������Ĭ��0-�ر�
    BYTE bySensitivity;  //�����Ȳ���Χ1-100��Ĭ��50
    BYTE byBackgroundUpdateRate;//���������ٶȣ���Χ1-100��Ĭ��50
    BYTE bySceneChangeLevel;//�����仯�ȼ�����Χ1-100��Ĭ��50
    BYTE byMinTargetSize;//��СĿ��ߴ磺��Χ1-100��Ĭ��50
    BYTE byRes[15];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

#define MAX_HEATMAPREGION_NUM 8

//�ȶ�ͼ������ýṹ
typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //ʹ�ܣ��Ƿ���
    BYTE  byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//����Χ
    NET_DVR_HEATMAP_PARAM  struHeatMap ;
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    //����ʱ��
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

//�ȶ�ͼ�����ϴ�
typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*�豸��Ϣ*/
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    DWORD  dwMaxHeatMapValue;//����ȶ�ֵ
    DWORD  dwMinHeatMapValue;//��С�ȶ�ֵ
    DWORD  dwTimeHeatMapValue;// (ʱ���ȶ�ֵ)ƽ���ȶ�ֵ
    WORD   wArrayLine;//ͼƬ���ص���ֵ
    WORD   wArrayColumn;//ͼƬ���ص���ֵ ��������ֵΪ0��ʱ�����ص�ֵ�ڴ���Ϣ�����ڣ�
    BYTE*  pBuffer;  //�ȶ�ͼƬ���ص������Ϣ
    BYTE   byDetSceneID;//��ⳡ����[1],���ǰ֧��1������, IPCĬ����0
    BYTE   byRes[127];
}NET_DVR_HEATMAP_RESULT,*LPNET_DVR_HEATMAP_RESULT;

//�ȶ�ͼ�������� �����ṹ��
typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//ͨ����
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    BYTE    byReportType;//0-��Чֵ��1-�ձ��?2-�ܱ��?3-�±��?4-�걨��
    BYTE	byDetSceneID;//��ⳡ����[1],���ǰ֧��1������, IPCĬ����0
    BYTE    byRes[126];
}NET_DVR_HEATMAP_QUERY_COND,*LPNET_DVR_HEATMAP_QUERY_COND;

//�ȶ�ͼ��������
typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*�����ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;  /*�������ʱ��*/
    DWORD  dwHeatMapPicLen;         /*�ռ��ȶ�ͼƬ����(������ͼƬ��ʱ�򣬸��ֶ�Ϊ��0��û��ͼƬ��ʱ�򣬸��ֶ�Ϊ0)*/
    BYTE*  pBuffer;                 //�ȶ�ͼƬ�����Ϣ
    DWORD  dwTimeHeatMapValue ;     //ʱ���ȶ�ֵ(���п��ȶ�ͼ��ʱ��,���ֶβ���Ҫ��ֵ)
    DWORD  dwHeatMapMaxValue;//�����������ȶȵ���Ա�ʱ��(s)(�ռ��ȶ�ͼʱ��Ч)
    DWORD  dwHeatMapMinValue;//�����������ȶȵ���Ա�ʱ��(s) (�ռ��ȶ�ͼʱ��Ч)
    BYTE    byRes[116];
}NET_DVR_HEATMAP_INFO,*LPNET_DVR_HEATMAP_INFO;

typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    BYTE   byReportType;//0-��Чֵ��1-�ձ��?2-�ܱ��?3-�±��?4-�걨��
    BYTE   byRes[127];
}NET_DVR_PDC_QUERY_COND,*LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    DWORD   dwEnterNum;   //��������
    DWORD   dwLeaveNum;  //�뿪����
    BYTE    byRes[256];    //�����ֽ�
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;


typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д  3 */
    BYTE  byTimeOsd;// ʱ����Ϣ���� 0 - �����ӣ� 1- ����
    BYTE  byRecogResultOsd;//ʶ�������  0 - �����ӣ� 1- ����
    BYTE  byRecogHint;//ʶ��ɹ���ʾ 0 - ����ʾ�� 1- ��ʾ
    BYTE  byRecogDir;//ʶ���� 0: ����, 1: ����
    BYTE  byRecogEnv;//ʶ�𻷾� 0: ����, 1: ����
    BYTE  byRecogPlateType;//0-С����ʶ��1-����ʶ��
    BYTE  byUploadPlate;//�Ƿ��ϴ����� 0 -���ϴ��� 1-�ϴ�
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG,*LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:�������״�  1:�����״� */
    BYTE   byEnableAlarm;   /* 0:����������  1:�������� */
    WORD   wOverSpeed;    /* ��ΧΪ20~250 */
    BYTE   bySpeedUnits;  /* 0:����/Сʱ   1:Ӣ��/Сʱ */
    BYTE   bydirection;     /* 0:�����״��복���� 1:�����״��복���� */
    BYTE   byMeasureMode;   /* 0:��̬ (�״�״̬)       1:��̬ (�״�״̬)*/
    BYTE   byTargetType;    /* 0:���(�״���ٳ������)  1:���(�״���ٳ������)*/
    BYTE   bySensitivity;  /* ������[0,100] */
    BYTE   byCaptureNum;   /* ץ������[0,255] */
    BYTE   byUploadPlate;  /*�Ƿ��ϴ�����ץ��ͼƬ 0-���ϴ���1-�ϴ�*/
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG,*LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* ��������Ƿ���к����� 0-��飬1-�����*/
    BYTE  byCheckAlarm;/* ���ɹ����� 0-��������1-����*/
    BYTE  byCheckHint; /* ���ɹ���ʾ (�����ʾ) 0-����ʾ��1-��ʾ*/
    BYTE  byUploadBlackCar; /*�Ƿ��ϴ��ڳ���Ϣ 0-���ϴ���1-�ϴ�*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG,*LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//ͨ����0xff - ȫ��ͨ����Ĭ����1,���һ��ͨ����
    NET_DVR_PLATE_INFO  struPlateInfo; //������Ϣ
    WORD  wIllegalType; //Υ�����Ͳ��ù�궨�� ���ο�������
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// Υ��������Ϣ��128��
    NET_DVR_TIME_V30  struIllegalTime;//Υ��ʱ��
    BYTE  byIllegalVehicleNum;//����Υ������
    BYTE  byRes1[3];
    char sCustomInfo[64];//�Զ�����Ϣ
    BYTE  byRes2[128]; // �����ֽ�
}NET_DVR_VEHICLE_CHECK,*LPNET_DVR_VEHICLE_CHECK;

typedef enum _LONG_CFG_SEND_DATA_TYPE_ENUM_
{
    ENUM_DVR_VEHICLE_CHECK = 1, //��������ݻ������
    ENUM_MSC_SEND_DATA = 2, //��Ļ�������������
    ENUM_ACS_SEND_DATA = 3, //�Ž������������
    ENUM_TME_CARD_SEND_DATA = 4, //ͣ����(����ڿ��ƻ�)��Ƭ�������
    ENUM_TME_VEHICLE_SEND_DATA = 5, //ͣ����(����ڿ��ƻ�)�����������
	ENUM_DVR_DEBUG_CMD = 6 //����������Ϣ
}LONG_CFG_SEND_DATA_TYPE_ENUM;

typedef enum _LONG_CFG_RECV_DATA_TYPE_ENUM_
{
    ENUM_DVR_ERROR_CODE = 1, //������
    ENUM_MSC_RECV_DATA=2, //��Ļ�������������
    ENUM_ACS_RECV_DATA=3 //�Ž������������
}LONG_CFG_RECV_DATA_TYPE_ENUM;

typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//����ʱ��������λ���룩[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//������ʱ�䣨��λ���룩[2min~24h]������ʾ�����ӵ�λ
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM,*LPNET_DVR_WIPER_CONTINUEWORK_PARAM;

typedef union tagNET_DVR_WIPERMODE_PARAM_UNION
{
    BYTE uLen[16];
    //��byWiperWorkMode = 1ʱ��Ч
    NET_DVR_WIPER_CONTINUEWORK_PARAM struWiperContinueWorkParam;
}NET_DVR_WIPERMODE_PARAM_UNION,*LPNET_DVR_WIPERMODE_PARAM_UNION;

typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //��ˢ����ģʽ
    //0-����ģʽ��1-����ģʽ��������ýṹNET_DVR_ROTATE_OPERATE_PARAM��
    BYTE  byWiperWorkMode;
    BYTE  byRes[23];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG,*LPNET_DVR_WIPERINFO_CFG;

//�����Զ��Խ�����
typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{
   	DWORD     dwSize;
    DWORD     dwChannel;			//ͨ����
    BYTE      byRes[24];            // �����ֽ�
}NET_DVR_AUTOFOCUS_TESTCFG,*LPNET_DVR_AUTOFOCUS_TESTCFG;


typedef struct tagNET_DVR_VIDEO_OUT_CFG
{
    BYTE	byDisplayMode;		//��ʾģʽ��1-��׼��2-��ɫ��3-ůɫ��0xff-�Զ���
    BYTE 	byBrightnessLevel; 	// ����ֵ0-100
    BYTE	byContrastLevel; 	// �Աȶ�0-100
    BYTE 	bySharpnessLevel; 	// ���0-100
    BYTE 	bySaturationLevel; 	// ���Ͷ�0-100
    BYTE 	byHueLevel; 		// ɫ��0-100
    BYTE    byImageMode;        // ͼ��ģʽ��0-��ģʽ��1-ҹģʽ1��2-ҹģʽ2��3-ҹģʽ3��4-����ģʽ1��5-����ģʽ2��6-����ģʽ3
    BYTE	byRes[5];			// ����
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;
//ɫ��
typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{
    BYTE	byRed;				//��ɫ�� 0-100
    BYTE	byGreen;			//��ɫ�� 0-100
    BYTE	byBlue;				//��ɫ��0-100
    BYTE	byRedOffset;		//��ɫƫ�ƣ�0-100
    BYTE	byGreenOffset;		//��ɫƫ�ƣ�0-100
    BYTE	byBlueOffset;		//��ɫƫ�ƣ�0-100
    BYTE	byRes[6];
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{
    BYTE	byGainR;			//����R�� 0-100
    BYTE	byGainG;			//����G��0-100
    BYTE	byGainB;			//����B��0-100
    BYTE	byOffsetR;			//ƫ����R��0-100
    BYTE	byOffsetG;			//ƫ����G��0-100
    BYTE	byOffsetB;			//ƫ����B��0-100
    BYTE	byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{
    BYTE	byEnable;	        //�Ƿ�������Ļ��Ե 0-������ 1-����
    BYTE	byLeftEdge;	        //���Ե��0-100
    BYTE	byRightEdge;	    //�ұ�Ե��0-100
    BYTE	byTopEdge;	        //�ϱ�Ե��0-100
    BYTE	byLowerEdge;	    //�±�Ե��0-100
    BYTE	byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;
    BYTE    byCfgType;       /*���õĲ������ͣ���ȡʱ�˲�����Ч��0-��Ч��1-�������2-��Ƶ����3-ɫ�²���4-ADC����5-��Ļ��Ե����*/
    BYTE	byBackLight;	//���� 0~100
    BYTE	byRes1[2];
    NET_DVR_VIDEO_OUT_CFG 		  struVideoOutCfg;	 //��Ƶ������ģʽ��
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //ɫ�²���
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC����
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //��Ļ��Ե����
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;
//ģ��ң������
typedef enum tagNET_DVR_SCREEN_REMOTE_CTRL_TYPE
{
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,//1-��Դ��
        REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,//2-��Դ��
        REMOTE_CTRL_SIGNALSOURCE,//3-�ź�Դ
        REMOTE_CTRL_MENU,//4-�˵�
        REMOTE_CTRL_DETERMINATION,//5-ȷ��
        REMOTE_CTRL_ON,//6-��
        REMOTE_CTRL_UNDER,//7-��
        REMOTE_CTRL_LEFT,//8-��
        REMOTE_CTRL_RIGHT,//9-��
        REMOTE_CTRL_INFO,//10-INFO
        REMOTE_CTRL_RETURN,// 11-������һ��
        REMOTE_CTRL_NUM, //12-���ּ���
}SCREEN_REMOTE_CTRL_TYPE;

//ģ��ң�ذ���
typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;
    BYTE		byControlType;	//1-��Դ����2-��Դ�أ�3-�ź�Դ��4-�˵���5-ȷ����6-�ϣ�7-�£�8-��9-��,  10-INFO, 11-������һ��,12-���ְ���,13-����һ�尴��
	BYTE       byControlParam; //���������������Ϊ12ʱ����ʾ����ֵ��0-9�����������ʱ�˲�����Ч
    BYTE		byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL,*LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//��Ļ�ź�Դ����
typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;
    BYTE     bySignalSourceType;	//����Դ�����ö�� NET_DVR_CAM_MODE
    BYTE	 byNoSignalPic;		    //���źŻ���ģʽ��1-������2-������3-LOGO����
    BYTE	 byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

//��Ļƴ������
typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;
    BYTE	bySpliceIndex;			//��ƴ�����ţ�0����û��ƴ�ӣ�����ֵ��ʾ��ƴ���������š�����ƴ��0101~0202��4����������4������bySpliceIndex������ͬ���ҷ�0.
    BYTE	bySpliceX;				//��Ļ����ƴ�����е���λ��
    BYTE	bySpliceY;				//��Ļ����ƴ�����е���λ��
    BYTE    byWidth;                //ƴ�ӹ�ģ�?����ĻΪ��λ
    BYTE    byHeight;               //ƴ�ӹ�ģ�ߣ�����ĻΪ��λ
    BYTE	byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

//���ȹ�����ʽ����
typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;
    BYTE		byWorkMode;		         //1-������2-�Զ�
    BYTE		byTemperatureLimitValue; //���ȿ������¶ȷ�ֵ������ģʽΪ�Զ�ʱ�ò�����Ч��
    BYTE		byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA�ź�����
typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;
    BYTE        byEnableAutoAdjust;      //�Ƿ��Զ�����0-��1-�ǣ����Զ���������ʱ���²�����Ч
    BYTE		byHorizontalPosition;   //ˮƽλ�� 0-100
    BYTE		byVerticalPosition;  	//��ֱλ�� 0-100
    BYTE		byClock;	            //ʱ�� ��0-100
    BYTE		byPhase;                //��λ��0-100
    BYTE		byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

//��Ļ�˵�����
typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;
    BYTE		byMenuLanguage; //���ԣ�1-���ģ�2-Ӣ��
    BYTE		byTransparency; //͸���� 0-��͸����1-�ͣ�2-�У�3-��
    BYTE		byDuration;	    //����ʱ�䣬0-������1-5�룬2-15�룬3-30��
    BYTE		byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

//���л�
typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;
    BYTE	byEnable;	//�Ƿ����û��л� 0-������ 1-����
    BYTE	bySubWindowSource;	//�ӻ����ź�Դ���ο�ö��NET_DVR_CAM_MODE
    BYTE	bySubWindowBorderColor;	//�ӻ���߿���ɫ�� 1-��ɫ��2-��ɫ
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;    //�ӻ���λ�ã���Ļ�ܴ�СΪ100*100
    BYTE	byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

//͸������
typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;
    BYTE	byDefogEnable;    //����͸�?�أ�0~�رգ�1~����
    BYTE	byDefogModel;     //͸��ģʽ��0~�Զ�ȥ�?1~�ֶ�ȥ��
    BYTE    byDefogLevel;     //͸��ǿ�ȵȼ���1-7���ȼ���Ĭ�ϵȼ�Ϊ4���ȼ�1Ϊ0.5���ȼ�2Ϊ0.55���ȼ�3Ϊ0.60���ȼ�4Ϊ0.65���ȼ�5Ϊ0.70���ȼ�6Ϊ0.75���ȼ�7Ϊ0.80����ȥ��ģʽΪ�ֶ�ȥ��ʱ��������ȥ��ǿ�ȵȼ���
    BYTE	byRes[33];
}NET_DVR_DEFOG_LCD,*LPNET_DVR_DEFOG_LCD;

//��Ļάǽ
typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD	dwSize;
    BYTE    byEnable; //״̬���ء�0-Ϊ�رգ�1-Ϊ����
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

//��Ļλ��
typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD	 dwSize;
    BYTE     byScreenRowNum;//��Ļ�кš�
    BYTE     byScreenColNum;//��Ļ�кš�
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;

typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize;     //�ṹ��ĳ���
    DWORD     dwChanNo;   //����Ƶͨ���ţ� �������ú󣬱��󶨵������Խ�ͨ������Ϊ��ͨ������ƵԴ
    BYTE	  byEnable;   //�Ƿ����������Խ���Ϊ��Ƶ����Դ 0-������ 1-����
    BYTE	  byRes[31];          //����
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{
    DWORD   dwSize;
    BYTE	byEnable;//ʹ��
    BYTE	byRes1[3];
    NET_DVR_SCHEDTIME	struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣���?ʽ
    DWORD	dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ��ֻ�������֧������
    DWORD	dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD	dwRelRecordChan[MAX_CHANNUM_V30/*64*/];//����¼��ͨ����
    BYTE	byEnablePreset[MAX_CHANNUM_V30];
    BYTE	byPresetNo[MAX_CHANNUM_V30];
    BYTE	byEnableCruise[MAX_CHANNUM_V30];
    BYTE	byCruiseNo[MAX_CHANNUM_V30];
    BYTE	byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE	byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //���ղ���ʱ��
    BYTE  byRes[224];;
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{
    DWORD dwSize;  //�ṹ���С
    BYTE	byEnable;//ʹ��
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME	struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;        //�쳣����,�쳣���?ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: ������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ����ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/]; //* ʵ�ʴ����ı�������ţ���ֵ��ʾ,���ý��������У����±�0��ʼ˳���ȡ���������0xffffffff�������Ч*/
    /*������¼��ͨ��*/
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];	 /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0��ʼ˳���ȡ���������0xffffffff,�������Ч*/
    DWORD dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/]; //���õ�Ԥ�õ���Ϣ����dwEnablePresetChanNum��Ϊ0ʱ�������±�0-(dwEnablePresetChanNum -1)��Ч����Ϊ0ʱ����ʾδ����Ԥ�õ�
    BYTE byRes2[516];					/*����*/
    DWORD dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/]; //����Ѳ������ͨ������Ϣ����dwEnableCruiseChanNum��Ϊ0ʱ�������±�0-( dwEnableCruiseChanNum -1)��Ч����Ϊ0ʱ����ʾδ����Ѳ��
    DWORD dwEnablePtzTrackChanNum;  //��ǰ������̨�켣ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/]; //������̨�켣��ͨ����Ϣ����dwEnablePtzTrackChanNum��Ϊ0ʱ�������±�0-(dwEnablePresetChanNum -1)��Ч����Ϊ0ʱ����ʾδ������̨�켣
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;  //�ṹ���С;
    BYTE     byEnableCS;  //�����ƴ洢����  0-�ر� 1-����
    BYTE     byRes[511];     //����
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;


typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize ; //�ṹ���С
    BYTE    byValid;       //�Ƿ���Ч
                           /*(ֻ��)¼�����ͣ�0: ����¼��1����¼�� 2-����
                           3-������ 4-��������Ƶ 5-δ���� 6-�浵�� 7-�ش���
    8-�û��������� 9-δ��֤,10-�浵�к�¼���� 11-¼��ش��к�¼����*/
    BYTE    byRecord;
    DWORD   dwRelatedHD;  //��������
    BYTE	byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE 	byRes[63];        //�����ֽ�
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

#define  MAX_CAMERAID_LEN    64
typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;
    DWORD             dwRecordType; //¼������  0- ��ʱ¼��1- �ƶ����¼��2- ����¼��3- �������ƶ����¼��4- �������ƶ����¼�� 5- �������6- �ֶ�¼��7- �𶯱�����8- ��������������9- ���ܱ�����10- �ش�¼��
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //¼��ʼʱ��
    NET_DVR_TIME_EX   struStopTime;  //¼�����ʱ��
    DWORD             dwStoragePoolID; //�洢��ID
    BYTE              byFormatType ;     //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP��9-RTP+PS����꣺GB28181����0xff-��Ч
    BYTE              byVideoEncType ;       //��Ƶ�������ͣ�0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��8-MPEG2��0xfe- �Զ�����Դһ�£���0xff-��Ч
    BYTE              byAudioEncType;  //��Ƶ�������ͣ�0-G722��1-G711_U��2-G711_A��5-MP2L2��6-G726��7-AAC��0xfe- �Զ�����Դһ�£���0xff-��Ч
    BYTE 		      byRes[125];
}NET_DVR_UPLOAD_RECORD_INFO,*LPNET_DVR_UPLOAD_RECORD_INFO;

//����Ʋ�������  �����ṹ��
typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//ͬ�������(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND,*LPNET_DVR_IOOUT_COND;

//����Ʋ�������
typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD  dwSize;
    BYTE   byWorkMode;// 0-�������,1-Ƶ����(Ĭ��)
    BYTE   byRes1[3];
    union
    {
        BYTE	byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//Ĭ��״̬ 0-�͵�ƽ(Ĭ��)��1-�ߵ�ƽ
            BYTE   byWorkState;//��Ч״̬ 0-�͵�ƽ(Ĭ��),1-�ߵ�ƽ,2-����
            BYTE   byFreqMulti;//��Ƶ����ֵ��Χ[1,15]
            BYTE   byDutyRatio;//ռ�ձȣ�[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;	//���������ʱ��ʹ��:0-��;1-��
            NET_DVR_SCHEDTIME  struFlashLightTime;//���������ʱ��
            BYTE   byRes1[116];
        }struStrobeLamp;	// Ƶ���� ʱ��Ч
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG,*LPNET_DVR_IOOUT_CFG;

//�źŵ�ͬ������
typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//��λ(0~360)
    BYTE   byLineLock;//��Դͬ�� 0-��1-��
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG,*LPNET_DVR_SIGNAL_SYNCCFG;

// өʯEZVIZ�������ṹ��
typedef struct
{
    DWORD	dwSize;
    BYTE	byEnable;// ����EZVIZ���� 0�����ã�1������
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE    byDeviceStatus; //�豸�Ƿ�����״̬��0-������1-���ߣ�2-����
    BYTE	byAllowRedirect;	//�Ƿ������ض���,0-����,1-��,2-��,0��ʾ���ֲ���,������SDK�����豸�����
    BYTE	byDomainName[MAX_DOMAIN_NAME];	//�����������ַ
    BYTE    byRes [445];
}NET_DVR_EZVIZ_ACCESS_CFG,*LPNET_DVR_EZVIZ_ACCESS_CFG;

typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0��ʾ�ƶ���⣬
    1��ʾ��Ƶ�ڵ���
    2��ʾ��Ƶ��ʧ��
    3��ʾPIR������
    4��ʾ���߱�����
    5��ʾ���ȱ�����
    6��ʾ����ץͼ��
    7��ʾ������⣬
    8��ʾԽ�������⣬
    9��ʾ����������⣬
    10��ʾ���������⣬
    11 ��ʾ�쳣��⣬
    0xff ��ʾ��������
    */
    BYTE  byAlarmType;
    //�������� 0-��Ч,1-ץͼ�ϴ�FTP,2-Jpegץͼ�ϴ�Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    //��������Ż���ͨ���Ż������߱��
    //(��byAlarmType ==0xffʱ,dwChannel��ʾ���Ǳ��������)
    //(��byAlarmType ==4ʱ,dwChannel��ʾ�������߱��)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND,*LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum ; //�����ı�������ͨ����ֻ�������֧������
    //dwRelateChan�ĳ�ʼֵ��0xffffffff;��������д��ʵ�ʵ�ͨ����;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG,*LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //���ñ���䱶���� 0-��1-��
    BYTE   byPresetFreezing; //����Ԥ�õ���Ƶ���� 0-��1-��
    BYTE   byPresetSpeed;//Ԥ�õ��ٶȵȼ� 1--8��Ĭ��4
    BYTE   byKeyboardCtrlSpeed;//�ֿ��ٶȵȼ�0-��,1-��,2-��
    BYTE   byAutoScanSpeed;//ɨ���ٶȵȼ���1--40��Ĭ��28
    BYTE   byZoomingSpeed;//�䱶�ٶȣ�1--3��Ĭ��3
    BYTE   byManualControlSpeed;//�ֿ��ٶ�ģʽ��0-���ݣ�1-���ˣ�2-�ǻ���3-����4-����Ӧ
    BYTE   byPTZMotionTrack;//�����˶����٣�����̨������ 0-Ĭ�ϣ���������1-�ر�
    BYTE   byRes[124];
}NET_DVR_PTZ_BASICPARAMCFG,*LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //��ͷ������ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPtStatus;    //��λ����ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPresetStatus;//Ԥ�õ������ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPositionDisplayFormat;//��λ����ʾ��ʽ 0-����PT��ʾ(�� P179|T-02)��1-���շ�λ��ʾ(SE123|T-02)
    BYTE   byRes[124];
}NET_DVR_PTZ_OSDCFG,*LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //�������ģʽ��Oxff-���á�1-30�롢2-60�롢3-300�롢4-600�룬Ĭ��30��
    BYTE   byRes[127];
}NET_DVR_PTZ_POWEROFFMEMCFG,*LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan; //ͨ����
    BYTE   byLimitMode; //��λģʽ 0-������1-�����λ��2-ɨ����λ
    BYTE   byRes[63];
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//����ʹ�ܣ�0-��1-��
    BYTE   byLimitStatus; //��λ״̬ 0-δ��λ��1-����λ�����ɱ༭��
    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCFG,*LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byLimitMode; //��λģʽ 0-������1-�����λ��2-ɨ����λ
    BYTE   byWorkMode ;//0-���ã�1-���
    BYTE   byRes[122];
}NET_DVR_PTZ_LIMITCTRL,*LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode ;//��̨����� 0-����1-��
    BYTE   byRes[123];
}NET_DVR_PTZ_LOCKCFG,*LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//ͨ����
    BYTE    byRes[64];
}NET_DVR_PTZLOCKINFO_COND,*LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec ;//ʣ������
    BYTE    byRes[128];    //�����ֽ�
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    WORD   wRouteNo;//Ѳ��·����
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND,*LPNET_DVR_CRUISEPOINT_COND;

typedef struct
{
    WORD	wPresetNo;	//Ԥ�õ�
    WORD	wDwell;	//ͣ��ʱ��
    BYTE    bySpeed;	//�ٶ�
    BYTE	bySupport256PresetNo;//����֮ǰ�� ��256��Ԥ�õ��Ƿ���Ч
    BYTE    byRes[6];
}NET_DVR_CRUISEPOINT_PARAM,*LPNET_DVR_CRUISEPOINT_PARAM;

typedef struct
{
    DWORD  dwSize;
    // ���֧��128��Ѳ����
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISE_POINT_NUM];
    BYTE	 Res[64]; //����
}NET_DVR_CRUISEPOINT_V40, *LPNET_DVR_CRUISEPOINT_V40;

typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;

#define MAX_DISPLAY_NUM         512  //�����ʾ�������
#define MAX_LEDCONTENT_NUM      512  //����LED�ַ���󳤶�
#define MAX_PPT_CHAN			128	 //PPT����

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//ʹ��
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//��귶Χ�����ݻ�׼�������֧�ֵ�ƴ��ģʽ
    BYTE  sName[NAME_LEN]; //����ǽ���
    BYTE  byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//��ʾ�����
    BYTE  byDispChanType;/*�������ģʽ,1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��10-3GSDI,11-VGA/DVI����Ӧ��12-HDBaseT, 0xff-��Ч*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM,*LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/] ;
    BYTE  byRes[128];
}NET_DVR_DISPLAYCFG,*LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD   dwSize;
    BYTE	byEnable;
    BYTE	byRes1[3];
    //ǽ��,1�ֽ�ǽ��+3�ֽڱ���
    DWORD	dwVideoWallNo;
    DWORD   dwDisplayNo;//��ʾ�����
    //�����Ϊ��׼��������1920*1920������Ⱥ͸߶�ֵ�������ã���Ϊ��׼ֵ
    NET_DVR_RECTCFG_EX struRectCfg;
    BYTE	byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION,*LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

/*������Ϣ*/
typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //����ʹ��,0-��ʹ�ܣ�1-ʹ��
    BYTE  byRes1[7];
    DWORD dwWindowNo;//���ں�
    DWORD dwLayerIndex;//�������Ӧ��ͼ��ţ�ͼ��ŵ�����ö����ö�����
    NET_DVR_RECTCFG_EX struRect;//Ŀ�Ĵ���(�����ʾǽ)

    BYTE  byRes2[64];
}NET_DVR_VIDEOWALLWINDOWPOSITION,*LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    //���ںţ�1�ֽ�ǽ��+1�ֽڱ���+2�ֽڴ��ں�
    DWORD	dwWindowNo;
    DWORD   dwSceneNo;//������
    BYTE	byRes[20];
}NET_DVR_VIDEO_WALL_INFO,*LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM
{
    DWORD   dwSize;
    BYTE    byEnable; //ʹ��
    BYTE    byDispMode;//��ʾģʽ��1-͸����2-��͸����3-����
    BYTE    byRes1[6];
    NET_DVR_RGB_COLOR struContentColor;//������ɫ
    NET_DVR_RGB_COLOR struBackColor;//������ɫ
    NET_DVR_RECTCFG_EX struRect;
    DWORD   dwContentNum;/*�ַ�ĸ���*/
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; /*����LED�ַ�����*/
    BYTE    byMoveMode; //�ַ��ƶ�ģʽ��1-��ͨ��2-ƽ����3-��ֹ
    BYTE    byFontSize; //�����С��1-1����2-2����3-4��
    BYTE    byMoveDirection; //�ƶ�����0-Ĭ�ϣ������ң���1-�����ң�2-���ҵ���3-���ϵ��£�4-���µ���
    BYTE    byMoveSpeed; //�ƶ��ٶȣ�1-�ٶ�1,2-�ٶ�2
    BYTE    byRes2[124];
}NET_DVR_VIRTUALLED_PARAM,*LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //ͼ���и�ģʽ��1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE,*LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{
    DWORD  dwSize ;
    DWORD  dwSerialPort; //��ǰʹ�ô��ں�
    BYTE byProtocolType; //����Э�����ͣ�1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 �� 4-LCD-DLP�� 5-LCD-S3 , 6-LCD-D20��7-LCD-L2,8-LCD-Z1��9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT,*LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//�������
    BYTE  byEnable;//�����Ƿ���Ч 1-��Ч��0-��Ч
    BYTE  bySceneIndex;	 //�����ţ�ֻ�ܻ�ȡ����ȡ���г���ʱʹ�øò���
    BYTE  byRes [78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //����ǽ��Ϣ
    DWORD dwCmd; //�����������1-����ģʽ�л������Ҫ�л����ǵ�ǰ�������򲻽����л�����2-��ʼ�����������˳�����������գ�����ǵ�ǰ��������ͬʱ�Ե�ǰ��������������������3-ǿ���л��������Ƿ��ǵ�ǰ������ǿ���л�����4-���浱ǰģʽ��ĳ���� 5-ɾ��
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{
    DWORD dwSize;
    DWORD dwDisplayNo;  //��ʾ����ںţ�0xffffffff��ʾ����������ڽ��в���
    BYTE  byEnable;     //ʹ����ʾ��0-����ʾ��1-��ʾ
    BYTE  byChanType;   //��ʾ��ͨ�����ͣ�1-��ʾͨ���ţ�2-��������
    BYTE  byRes1[2];
    DWORD dwWallNo; //ǽ�ţ�1�ֽ�ǽ�ţ���λ��+3�ֽڱ�������ʾ��Ļ���ʱ��Ч
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO,*LPNET_DVR_SHOW_CONTROL_INFO;

typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;	//������ָ��
    DWORD   nLen;	//�������
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //����������
    NET_DVR_BUF_INFO struInParamBuf;         //�������
    DWORD  dwRecvTimeout;      //������ݳ�ʱʱ�䣬��λ��ms,��0���ýӿ�Ĭ�ϳ�ʱ
    BYTE   byRes[32];
}NET_DVR_IN_PARAM,LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf;            //����������
    void*  lpStatusList;       //״̬������
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM,LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;
    DWORD dwChannel;   //��Ƶͨ������ϣ�1�ֽ��豸��+1�ֽ��Ӱ��+2�ֽ���Ƶͨ���ţ�
    BYTE  byRes[48];
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO;

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //��Ƶͨ�����
    BYTE          byEnable; //��Ƶ�Ƿ����� 0-�أ� 1-��
    BYTE          byAudioSwitchType; //��Ƶ�л���ʽ��1-��ǰ��Դ��ʽ��2-�����ڽ���Դ��ʽ
    BYTE          byRes[2];
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //��ƵԴ��Ϣ byAudioSwitchTypeΪ1ʱ��Ч
    DWORD         dwWindowNo; //�Ӵ��ںţ�1�ֽ�ǽ��+1�ֽ��Ӵ��ں�+2�ֽڴ��ںţ���byAudioSwitchTypeΪ2ʱ��Ч
    BYTE          byRes2[28];
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

#define MAX_SUBBOARD_NUM        42        //����ʽ�����豸����Ŀ
#define MAX_SINGLE_BOARD_EXCEPTION_NUM 16 //������󲢷��쳣��
typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //���ڹ���ģʽ��1-RS484,2-RS232
    BYTE byFunType; //���ڹ��ܣ�1-���̿��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PTZ����  5-������� 6-����̨
    BYTE byDataBit;// ����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    DWORD dwBaudRate;//������0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    WORD wProtocol;//����Э�飬��ͬ���ڹ��ܶ�Ӧ����Э�鲻һ��
    BYTE byVariable ;  //�����Ƿ�ɱ䣬1-���ɱ�  2-�ɱ� ��ֻ��ȡ��
    BYTE byRes[31];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;
    BYTE	   byBoardType;    //���� 0-����  1-DVI-I���룬2-YPbPr���룬3-BNC���룬4-SDI���룬 5-DVI˫��·���룬 6-��ͨ��������룬 7-DVI-I����� 8-SDI���, 9-��ǿ�ͽ�������� 0xff-δ֪����
    BYTE       byInterfaceNum;  //�ӿ���
    BYTE	   byStatus;        //״̬��0-�쳣�� 1-��
    BYTE       byRes[1];
    DWORD      dwSlotNo;       //���ڲ�λ��
    BYTE       byRes2[32];
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //�������ͣ� 1-4U�� 2-8U�� 3-13U, 0xff-δ֪����
    BYTE	  bySoltNum;        //��λ��Ŀ
    BYTE	  byBoardNum;   //��Ч��Ŀ
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //ǰbyBoardNum����Ч
    BYTE       byRes2[32];
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO;

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE 		byExceptNum;         //�쳣����
    BYTE        byRes1[3];
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //������
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //������
    BYTE        byRes2[32];
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;


typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //ͨ����
    BYTE    byLinearScanType; //��λ���ͣ�0-����,1-��߽�����,2-�ұ߽�����
    BYTE    byRes[63];
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

//����������Ϣ
typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //�ṹ���С
    BYTE  byStreamWithVca; //�����е���������Ϣ���ɹ����к������0-������,1-����
    BYTE  byRes[127];      //����
}NET_DVR_STREAM_ATTACHINFO_CFG,*LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;  //Ĭ��·�ɣ�0��ʾstruEtherNet[0]��1��ʾstruEtherNet[1]
    BYTE   byNetworkCardNum;      //�豸ʵ�ʿ����õ�����Ŀ
    BYTE   byRes1[2]; //����
    NET_DVR_ETHERNET_MULTI struEtherNet [MAX_NETWORK_CARD]; //��̫���
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

//�������
typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byAllPreset; //������е�Ԥ�õ㣺0-��,1-��
    BYTE   byAllPatrols; //������е�Ѳ��·����0-��,1-��
    BYTE   byAllPatterms; //������еĻ���ɨ�裺0-��,1-��
    BYTE   byAllPrivacyMasks; //������е���˽�飺0-��,1-��
    BYTE   byAllPTZLimited; //������е���λ���ã�0-��,1-��
    BYTE   byAllScheduledTasks; //������еĶ�ʱ����0-��,1-��
    BYTE   byAllParkAction; //������е�����0-��,1-��
    BYTE   byRes[125];
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

//��̨����������Ϣ
typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //��̨���ȣ�0-Rs485��1-���磬Ĭ������
    BYTE   byRes[3];
    DWORD   dwDelay; //��ʱ��2---200��
    BYTE   byRes1[124];
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

//�㷽λ�ǿ���
typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byWorkMode ;//0-���ã�1-���
    BYTE   byRes[127];
}NET_DVR_INITIALPOSITIONCTRL,*LPNET_DVR_INITIALPOSITIONCTRL;

//��˽�ڱβ���
typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan; //ͨ����
    BYTE   byRegionalID; //����ID�� 1��24
    //ɾ��ǰID��Ӧ����˽�ڱ���Ϣ 0-������1-ɾ�� ��WriteOnly��
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62];
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//�Ƿ����� 0-��1-��
    //��˽�ڱ��������ò����Ƿ���ʾ  0-��1-�� ��ReadOnly��
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0-����,1-�ҡ�2-�졢3-�̡�4-����5-�ȡ�6-�ơ�0xff-�����
    BYTE   byActiveZoomRatio;//���α��ʣ�1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];//�ڵ�������ƣ�ֻʹ��16���ֽ�
    NET_VCA_POLYGON  struRegion;//����Χ
    //��ǰ��������Ƿ���Ч 0-��1-�� ����Ե��������������������Ϣ���͵������µĶ������������������Ϣ��
    BYTE   byCurrentRegionEnable;
    //��ǰ����ʹ���ֶ� 0- byActiveZoomRatio ;1- fActiveZoomRatio(֧�������ڵ�curActiveZoomRatioType)
    BYTE   byCurZoomRatio ;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //���α���(��ȷ��С���1λ)��[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

//ȫ��ʹ��
typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//����ʹ�ܣ�0-��1-��
    BYTE   byRes[127];
}NET_DVR_PRIVACY_MASKS_ENABLECFG,*LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

//�����˶�����������Ϣ
typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//����ʹ�� 0-��1-��
    BYTE  byRes[3];
    DWORD dwDuration;//����ʱ�䣺0--300�룬Ĭ��300��
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG,*LPNET_DVR_SMARTTRACKCFG;

//���ٱ���
typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byRes[128];
}NET_DVR_ZOOMRATIOCTRL,*LPNET_DVR_ZOOMRATIOCTRL;


//���뿪����Ϣ
typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//���ſ���״̬
    BYTE   byRes[28];
}NET_DVR_DIAL_SWITCH_CFG,*LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS //¼��ʧ�����ӽṹ
{
    NET_DVR_TIME_EX struInspectStart; //Ѳ�쿪ʼʱ��
    NET_DVR_TIME_EX struInspectEnd;   //Ѳ�����ʱ��
    NET_DVR_IPADDR  struIP;           //¼��ʧ��Ӧͨ����IP��ַ
    DWORD  dwChanNo;                //ͨ����
    DWORD  dwIDIndex;                //������ID
    BYTE   sName[STREAM_ID_LEN];       //���������
    NET_DVR_TIME_EX struLossStartTime; //¼��ʧ��ʼʱ��
    NET_DVR_TIME_EX struLossEndTime;   //¼��ʧ����ʱ��
    DWORD  dwLostNum;                 //¼��ʧ���� 0xffffffff��ʾȫ����ʧ
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION //ȡ���쳣����  �ӽṹ
{
    NET_DVR_IPADDR  struIP;           //������Ƶ�쳣ͨ����IP��ַ
    DWORD  dwChanNo;                //ͨ����
    DWORD  dwIDIndex;                //������ID
    BYTE   sName[STREAM_ID_LEN];       //���������
    BYTE   byExceptionCase;           //�쳣ԭ��0-���д���쳣 1-��������쳣
    BYTE   byRes[307];                //����
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;


typedef struct tagNET_ALARM_RESOURCE_USAGE  //��Դʹ�ñ��� �ӽṹ
{
    BYTE   byLevel;    //ʹ����������س̶ȵ����� 0-��1-һ���澯���� 2-�����澯���� 3-��澯����
    BYTE   byRes[491]; //����
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION //¼���쳣���� �ӽṹ
{
    BYTE    byReason;    //�쳣ԭ�� 0-¼����� 1-¼����쳣 2-�޿���lun��
    BYTE    byRes1[3];   //����
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //¼���ID��Ӳ�̺ţ�
    BYTE    byRes[452];  //����
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;

typedef union tagNET_ALARM_CVR_SUBINFO_UNION  //CVR�����ӽṹ
{
    BYTE byLen[492];   //�����峤��
    NET_ALARM_RECORDFILE_LOSS 	struRecordLost; //¼��ʧ
    NET_ALARM_STREAM_EXCEPTION     struStreamException; //ȡ���쳣
    NET_ALARM_RESOURCE_USAGE     struResourceUsage;  //��Դʹ��
    NET_ALARM_RECORD_EXCEPTION   struRecordException; //¼���쳣
}NET_ALARM_CVR_SUBINFO_UNION, *LPNET_ALARM_CVR_SUBINFO_UNION;

#define  MAX_VARIABLE_DATA_NUM    65535  //���ɱ���ݸ���

typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //���������� 0-������(ͨ��)�ź���������1-˽�о���𻵣�2- NVR�����˳���3-������״̬�쳣��4-ϵͳʱ���쳣��5-¼���ʣ��������ͣ�6-������(ͨ��)�ƶ���ⱨ����
    //7-������(ͨ��)�ڵ�����; 8-¼��ʧ����; 9-��Ƶʵʱ��ⱨ��; 10-��Դʹ���ʸ澯; 11- CVR�Զ��޸��쳣�� 12-¼���쳣
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //������Ϣ�ӽṹ ��������Ϊ8,9,10,11,12ʱ����������Ч
    BYTE             byRes[256];
    DWORD            dwNumber; //�ɱ���ݸ���
    WORD             *pNO; //������Ϊ0��3��6��7ʱ�����ܻ���ͨ���ţ�������Ϊ5ʱ�����ܻ��д��̺š��ɱ�ʾ��ֵ��ΧΪ0~65535
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

typedef struct tagNET_DVR_CONTROL_START_CFG //һ��ʼ������Ϣ
{
    BYTE	byUseDefine; //ʹ���Զ��壬 0-ʹ��Ĭ�ϣ�1-ʹ���Զ���
    BYTE	byRes1;
    WORD	wCourseIndex; //�γ�����
    BYTE	byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//һ���ӳ�¼�������Ϣ
{
    BYTE	byUseDefine; //ʹ���Զ��壬 0-ʹ��Ĭ�ϣ�1-ʹ���Զ���
    BYTE	byRes1;
    WORD	wDelayTime; //¼���ӳ�ʱ��<����¼��ʱ���Դ�Ϊ׼>����λs
    BYTE	byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;

typedef union tagNET_DVR_CONTROL_INFO_UNION  //������Ϣ������
{
    BYTE    byLen[132]; //�����峤��
    NET_DVR_CONTROL_START_CFG  struStartCfg;   //һ��ʼ
    NET_DVR_CONTROL_DELAY_CFG  struDelayCfg;  //һ���ӳ�
}NET_DVR_CONTROL_INFO_UNION, *LPNET_DVR_CONTROL_INFO_UNION;

typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD	dwSize;        //�ṹ���С
    WORD	wCmdType;    //�����������ͣ�0-һ��ʼ��1-һ�����2-һ����ͣ��3-һ��ָ���4-һ���ӳ�,5-һ��ʼ���� 6-һ��ֹͣ����
    BYTE	byRes1 [2]; //����
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //������Ϣ������ʹ�ý�Ͽ�����������
    BYTE	byRes[256]; //����
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD	 dwSize;  //�ṹ���С
    DWORD    dwOneKeyDelayTime; //һ����ӳ�ʱ��  ¼�����¼��ʱ�� ��λ S
    BYTE     byDirectedMode; //����ģʽ��0-�Զ�������1�ֶ�����
    BYTE     byRes[127];     //����
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;   //�ṹ���С
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30] ;
    //SDIͨ�����豸��ʵ�ʵ���������ʽ��ģ��ͨ���������ǰ��ʹ��IPͨ����
    BYTE   byCameraType[MAX_CHANNUM_V30];     //ͨ�������������ͣ�ֵΪ 0-�����壬1-��ʦ���٣�2-ѧ����٣�3-��ʦȫ����4-ѧ��ȫ����5-��ý�壬0xff-δ����
    BYTE   byRes[64];     //����
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE				byProtocolType;	//Э������ 0-FTP��1-SFTP
    BYTE				byRes1;     //����
    WORD				wFTPPort;  //�˿�
    BYTE   				byAddress[MAX_DOMAIN_NAME];  //IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    BYTE				szUserName[NAME_LEN/*32*/];		//�û���<����>
    BYTE				szPassWord[PASSWD_LEN/*16*/];		//����<����>
    BYTE				szCustomDir[128];	//����Ŀ¼,֧��Ŀ¼�ṹ
    BYTE				byRes[12]; //����
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //������URL��ַ��Ϣ
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE				byProtocolType;	//Э������ 0-FTP��1-SFTP
    BYTE				byRes1;     //����
    WORD				wFTPPort;  //�˿�
    BYTE   			byAddress[MAX_DOMAIN_NAME];  //IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    BYTE				szUserName[NAME_LEN/*32*/];		//�û���<����>
    BYTE				szPassWord[PASSWD_LEN/*16*/];		//����<����>
    BYTE      			byDirLevel;                     /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    BYTE    			byTopDirMode;         /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ                     0xff=ʹ���Զ���*/
    BYTE    			bySubDirMode;         /*����Ŀ¼��0x1=ʹ��ͨ�����,0x2=ʹ��ͨ���ţ�0x3=ʹ�ÿγ���ƣ�0x4-ʹ���ڿ����ڣ�0xff-ʹ���Զ���*/
    BYTE  			byRes2;
    BYTE   			byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*�Զ���һ��Ŀ¼*/
    BYTE   			bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*�Զ������Ŀ¼*/
    BYTE				byRes[72]; //����
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;


typedef  union tagNET_DVR_PUBLISH_ADD_UNION
{
    BYTE    byLen[256]; //�����峤��
    NET_DVR_PUBLISH_HTTP_CFG struHttpCfg; //http��ַ��Ϣ
    NET_DVR_PUBLISH_FTP_CFG  struFtpCfg;  //ftp��ַ��Ϣ
    NET_DVR_PUBLISH_FTP_CFG_DIR struDirFtpCfg;  //��Ŀ¼��ʽ��FTP
}NET_DVR_PUBLISH_ADD_UNION, *LPNET_DVR_PUBLISH_ADD_UNION;

typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO //ͨ��¼�񷢲���Ϣ
{
    BYTE	byPublish; //�Ƿ񷢲���0-�������� 1-����
    BYTE	byRes1[3];
    DWORD  dwStreamType;   //һ���������ͣ���λ��ʾ
    //&0x1-��ʾ������
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    BYTE	byRes[12];     //����
}NET_DVR_RECORD_PUBLISH_INFO,*LPNET_DVR_RECORD_PUBLISH_INFO;


typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byPublishType;    //������ʽ��0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3]; //����
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //һ���ַ��Ϣ
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30]; //ͨ��¼�񷢲���Ϣ struChanPublis[0]��ʾͨ��1��Ӧ¼�񷢲���Ϣ
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //����ͨ��¼�񷢲���Ϣ
    BYTE      			byUploadTime;      //�Ƿ�������ʱftp�ϴ����� 0-�����壬1-��������2-����
    BYTE                byTimerMode;      //0-�����壬1-���α?ʱ�ϴ����һ�ڿε�¼��2-��ʱ��㷽ʽ�ϴ�ǰ24Сʱ¼��
    BYTE      			byUploadStartHour;	//��ʱ�䶨ʱ�ϴ���ʼʱ��  ʱ
    BYTE                byUoploadStartMin;    //��ʱ�䶨ʱ�ϴ� ��ʼʱ�� ��
    BYTE                byRes[1020]; //����
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;  //�ṹ���С
    BYTE  byUseDefine;  //ʹ���Զ���  0-ʹ��Ĭ�Ϸ���������Ϣ��1-ʹ���Զ��巢��������Ϣ
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //ͨ��¼�񷢲���Ϣ struChanPublis[0]��ʾͨ��1��Ӧ¼�񷢲���Ϣ
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //����ͨ��¼�񷢲���Ϣ
    NET_DVR_TIME_EX  struStartTime;  //�γ̿�ʼʱ��
    NET_DVR_TIME_EX  struEndTime;   //�γ̽���ʱ��
    BYTE    bySchedulePublish;  //�Ƿ񰴿α?����0�����α?��1���α?��
    BYTE    sFileName[COURSE_NAME_LEN/*32*/];  //�����ļ����
    BYTE    byRes[31];
}NET_DVR_ONEKEY_PUBLISH_CFG,*LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD	dwSize;
    char	sCourseName[COURSE_NAME_LEN/*32*/];
    char	sInstructorName[INSTRUCTOR_NAME_LEN/*16*/];
    char	sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE	byIndex;		//�γ�����
    BYTE	byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime ;   //�γ���ֹʱ��
    WORD  wCourseIndex ;        //�γ�����
    WORD  wSessionIndex ;        //�ڴ�
    BYTE   byRes[4] ;            //����
}NET_DVR_EACH_LESSON_INFO,*LPNET_DVR_EACH_LESSON_INFO ;
// ��¼��״̬
typedef struct tagNET_DVR_CURRICULUM_CFG  //�α�ƻ� ������������
{
    DWORD  dwSize ;         //�ṹ���С
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/] ; //ÿ�ڿ���Ϣ
    BYTE   byRes[256] ; //����
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;

typedef  struct  tagNET_DVR_DATE_
{
    WORD 		wYear;		//��
    BYTE		byMonth;		//��
    BYTE 		byDay;		//��
}NET_DVR_DATE,*LPNET_DVR_DATE;

typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD	dwSize ;
    BYTE	byEnablePPTDetect; //�Ƿ�����PPT���
    BYTE	byPptDetLevel; //������
    BYTE	byEnablePartScreen; //�Ƿ����ò�������
    BYTE	byRes1[2];
    WORD	wX; //�������
    WORD	wY;
    WORD	wWidth;
    WORD	wHeight;
    BYTE	byRes[32];
}NET_DVR_PPT_DETECT_CFG,*LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD	dwSize ;
    BYTE	byChan[MAX_PPT_CHAN];
    BYTE	byRes[32];
}NET_DVR_PPT_CHANNEL_CFG,*LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;   //�Ƿ�����
    BYTE   byRes[11];
	//�����������ͣ���λ��ʾ
	//&0x1-��ʾ������
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    DWORD  dwStreamType;
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD 	dwSize ;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];  //��Ҫ���ݵ�ͨ��,�����±��Ӧ��Ӧ��ͨ����
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //����ͨ��������Ϣ
    BYTE    byRes[256];      // �����ֽ�
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

//���ڻ���
typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //���
    WORD  wRoomNumber;    //�����
    WORD  wDevIndex;      //���ڻ��ţ�0-10
    BYTE  byRes[122];     //����
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

//�ſڻ���
typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //�ں�, ��Χ[0,9]
    WORD wBuildingNumber; //¥��
    WORD wUnitNumber;  //��Ԫ��
    SHORT wFloorNumber;  //���
    WORD wDevIndex;  //�ſڻ���ţ�ÿһ�����ſڻ�����Ψһ����0��ʼ
    BYTE byRes[118]; //����
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

//Χǽ����
typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //�ں�, ��Χ[0,9]
    WORD wDevIndex;  //Χǽ����ţ�ÿһ�����ſڻ�����Ψһ����0��ʼ
    BYTE byRes[124]; //����
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

//�������
typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //�ںţ���Χ[0,9]
    WORD wDevIndex;  //�������ţ�ÿһ���й��������Ψһ,��0��ʼ
    BYTE byRes[124]; //����
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;

//���ӶԽ��豸���������
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION
{
    BYTE byLen[128] ; //�������С
    NET_DVR_INDOOR_UNIT_DEVICEID struIndoorUnit;   //���ڻ�
    NET_DVR_OUTDOOR_UNIT_DEVICEID struOutdoorUnit; //�ſڻ�
    NET_DVR_MANAGE_UNIT_DEVICEID struManageUnit; //�����
    NET_DVR_OUTDOOR_FENCE_DEVICEID struFenceUnit; //Χǽ��
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struVillaOutdoorUnit;  //�����ſڻ�
}NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;

//�豸��Ų���ṹ��
typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType;   //�豸���ͣ�1-�ſڻ�2-����� 4-Χǽ��,5-�����ſڻ�6-����ȷ�ϻ�
    BYTE byIsAutoReg;  //�Ƿ��Զ�ע�ᣬ0-��1-��
    BYTE byRes1[2];  //����
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;

//Ȩ����������
typedef enum tagPRIVILEGE_PASSWORD_TYPE_ENUM
{
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1, //��������
        ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2, //��/��������
        ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK  = 3, //������������
        ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING  = 4, //���ٳ�����
}PRIVILEGE_PASSWORD_TYPE_ENUM;

//Ȩ��������Ϣ
typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{
    DWORD  dwSize; //�ṹ���С
    BYTE   byPwdType; //�������ͣ��ο�PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];  //����
    BYTE   byOldPassword[PASSWD_LEN];  //������
    BYTE   byNewPassword[PASSWD_LEN]; //������
    BYTE   byRes2[128]; //����
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;


//���ڻ����ʱ������
typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime; //������ʱ�䣬��Χ[10,60]��
    DWORD dwMaxRingTime; //�������ʱ�䣬��Χ[15,60]��
    DWORD dwCallForwardingTime; //����ת�Ƴ�ʱʱ�䣬��Χ[0,20]��
    BYTE  byRes[116];//����
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

//��������ʱ������
typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime; //�������ʱ�䣬��Χ[30,60]��
    DWORD dwMaxTalkTime; //���ͨ��ʱ�䣬��Χ[90,120]��
    BYTE   byRes[120]; //����
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;

//��������ʱ������
typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //������ʱ�䣬��Χ[10,60]��
    DWORD dwMaxRingTime;        //�������ʱ�䣬��Χ[15,60]��
    DWORD dwMaxTalkTime;		//���ͨ��ʱ�䣬��λs
    BYTE  byRes[116];           //����
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;

//���ӶԽ�����ʱ��������
typedef union tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION
{
    BYTE byLen[128]; //�������С
    NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG struIndoorUnit; //���ڻ�
    NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG struOutdoorUnit; //�ſڻ�/Χǽ��/�����ſڻ�/����ȷ�ϻ�
    NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG struManageUnit; //�����
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;

//���ӶԽ�����ʱ������
typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType; //�豸���ͣ�1-�ſڻ�2-�����3-���ڻ�4-Χǽ��5-�����ſڻ�6-����ȷ�ϻ�
    BYTE byRes1[3];  //����
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;

//���ڻ�����������豸
typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit; //���ſڻ�IP
    NET_DVR_IPADDR struManageUnit;  //�����IP
    NET_DVR_IPADDR struSIPServer;    //SIP������IP
    NET_DVR_IPADDR struAgainUnit;   //����ȷ�ϻ�IP
    BYTE  		   byOutDoorType;  //���ſڻ����ͣ�0������1-����Ԫ�ſڻ�2-�������ſڻ�
    BYTE  		   byOutInConnectMode;  //�ſڻ������ڷֻ�����ģʽ��1-�ſڻ������ڷֻ�ͬһ������,2-�ſڻ������ڷֻ�ͬ������
    BYTE  		   byIndoorConnectMode;  //�������������ڷֻ�����ģʽ��1-ͨ��������2-ͨ��������
    BYTE           byRes1;
    NET_DVR_IPADDR struIndoorUnit; //��������IP
    BYTE           byRes[300];       //����
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;

//�ſڻ�������������豸
typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struMainOutdoorUnit; //���ſڻ�IP�����ſڻ�ʱ��Ч
    NET_DVR_IPADDR struManageUnit;   //�����IP
    NET_DVR_IPADDR struSIPServer;     //SIP������IP�����ſڻ�ʱ��Ч
    BYTE           byRes[592];       //����
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;

//����ȷ�ϻ�������������豸
typedef struct tagNET_DVR_AGAIN_RELATEDEV
{
    NET_DVR_IPADDR   struSIPServer;       //SIP������IP
    NET_DVR_IPADDR   struCenterAddr;      //����ƽ̨IP
    WORD             wCenterPort;         //����ƽ̨�˿�
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //��������IP
    BYTE             byRes[588];//����
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;


//�����������������豸
typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP������IP
    BYTE   byRes[880];       //����
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;


//���ӶԽ����������豸����ṹ��
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION
{
    DWORD dwRes[256] ; //�������С
    NET_DVR_INDOOR_UNIT_RELATEDEV struIndoorUnit;   //���ڻ�
    NET_DVR_OUTDOOR_UNIT_RELATEDEV struMainOutdoorUnit; //�ſڻ�/Χǽ��
    NET_DVR_MANAGE_UNIT_RELATEDEV struManageUnit; //�����
    NET_DVR_OUTDOOR_UNIT_RELATEDEV  struVillaUnit;      //�����ſڻ�
    NET_DVR_AGAIN_RELATEDEV           struAgainUnit;      //����ȷ�ϻ�
}NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;

//���������豸����ṹ��
typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType; //�豸���ͣ�1-�ſڻ�2-�����3-���ڻ�4-Χǽ��5-�����ſڻ�6-����ȷ�ϻ�
    BYTE byRes1[3];  //����
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize; //�ṹ���С
    DWORD dwGatewayIndex; //�Ž���ţ���1��ʼ
    BYTE  byCommand; //�������0-�رգ�1-��
    BYTE  byRes1[3]; //����
    BYTE  byControlSrc[NAME_LEN]; //��������Դ��Ϣ
    BYTE  byControlType; //�������ͣ�1-���ӣ�2-ͨ��
    BYTE  byRes2[127]; //����
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;


//����ͼƬ��Ϣ�ṹ��
typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData; //ͼƬָ��
    DWORD dwPicDataLen; //ͼƬ��ݳ���
    BYTE   byRes[32]; //����
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;

//�������
typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_TIME_EX struTime; //����ʱ��
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //������
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];//��������
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN]; //��������
    BYTE   byLevel; //����ȼ���1-�������Ϣ��2-��ҵ��Ϣ��3-��������Ϣ;4-֪ͨ����Ϣ
    BYTE   byPicNum; //����ͼƬ����
    BYTE   byRes1[2]; //����
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM]; //����ͼƬ
    BYTE   byRes2[128]; //����
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;

//����Ȩ����֤����
typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize; //�ṹ���С
    BYTE   byPassword[PASSWD_LEN]; //��֤����
    BYTE   byRes[128]; //����
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;

//��������
typedef enum tagUNLOCK_TYPE_ENUM
{
    ENUM_UNLOCK_PASSWORD = 1, //���뿪��
        ENUM_UNLOCK_HIJACKING  = 2, //�ٳֿ���
        ENUM_UNLOCK_CARD = 3, //ˢ������
        ENUM_UNLOCK_HOUSEHOLDER  = 4, //��������
        ENUM_UNLOCK_CENTER_PLATFORM = 5 //����ƽ̨����
}UNLOCK_TYPE_ENUM;


//�������ͣ��Ͳ�Ʒ��ȷ�ϣ��˶���û��ʹ�ã�ʹ�õ���DETECTOR_TYPE
// typedef enum tagALARM_ZONE_TYPE_ENUM
// {
//     ENUM_ALARM_ZONE_SMOKE = 1, //�̸�
//         ENUM_ALARM_ZONE_GAS  = 2,  //ú��
//         ENUM_ALARM_ZONE_INFRARED = 3, //����
//         ENUM_ALARM_ZONE_MAGNETIC  = 4, //�Ŵ�
//         ENUM_ALARM_ZONE_MANUAL = 5 //�ֶ�
// }ALARM_ZONE_TYPE_ENUM;

//�����¼
typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType; //����ʽ���ο�UNLOCK_TYPE_ENUM
    BYTE   byRes1[3]; //����
    BYTE   byControlSrc[NAME_LEN]; //��������Դ��Ϣ��ˢ������ʱΪ���ţ����������Ϊ�豸���
    DWORD  dwPicDataLen; //ͼƬ��ݳ���
    BYTE*  pImage; //ͼƬָ��
    BYTE   byRes[212];  //����
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;

//������Ϣ�Ķ���ִ
typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //������
    BYTE   byRes[224];  //����
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;


//���ӶԽ��¼���¼��Ϣ������
typedef union tagNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
{
    BYTE byLen[256]; //�������С
    NET_DVR_UNLOCK_RECORD_INFO struUnlockRecord; //�����¼
    NET_DVR_NOTICEDATA_RECEIPT_INFO struNoticedataReceipt; //������Ϣ�Ķ���ִ
}NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON,*LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;


//���ӶԽ��¼���¼
typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_TIME_EX struTime; //ʱ��
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //�豸���
    BYTE   byEventType; //�¼���Ϣ���ͣ�1-�����¼��2-������Ϣ�Ķ���ִ
    BYTE   byRes1[3]; //����
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo; //�¼���Ϣ���������ݲο�byEventTypeȡֵ
    BYTE  byRes2[256]; //����
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;


//������Ϣ
typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN]; //�������
    DWORD  dwZonendex; //�����
    BYTE   byZoneType; //�������ͣ��ο�DETECTOR_TYPE
    BYTE   byRes[219];  //����
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

typedef union tagNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION
{
    BYTE byLen[256]; //�������С
    NET_DVR_ZONE_ALARM_INFO struZoneAlarm; //����
}NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION,*LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;


//���ӶԽ�������Ϣ������
typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;  //�ṹ���С
    NET_DVR_TIME_EX struTime; //����ʱ��
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN]; //�豸���
    BYTE  byAlarmType; //�������ͣ�1-������2-���𱨾���3-�ٳֱ�����4-������뿪��ʧ�ܱ���,5-��û����6-��û�� 7-SOS ��8-ͨ���Խ�
    BYTE  byRes1[3]; //����
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo; //������Ϣ���������ݲο��ֶ�byAlarmTypeȡֵ
    BYTE  byRes2[256]; //����
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;

typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;//����ID
    BYTE byNumber;//�����е���Ա���� 0-��ʾ������û����Ա
    BYTE byDressType;//��װ���� 0-δ֪��1-���ۡ�2-���¡�3-�Ʒ�
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;//���ͼƬ���� (0��ʾû�г���)
    char*  pPicBuffer;//�����ͼƬ���
    BYTE byRes1[24];//����(Ԥ��������չ��������)
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD 	dwSize;
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO  struDevInfo;//ǰ���豸��Ϣ
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    /*��Ա��ⱨ������
    ��0-	δ֪��
    ��1-	��Ѷ���ڴ�ܶ�Ź����
    ��2-	��Ѷ��Ա�˯��ⱨ��
    ��3-	����Ѷ��Ա�����ⱨ��
    ��4-	������Ա��⣩
    */
    BYTE  byPeopleAlarmType;
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;

typedef	struct tagNET_DVR_SUPPLEMENTLIGHT
{
    BYTE        byEnable;//ʹ�� 0-�أ�1-��
    BYTE  		byMode;//�����ģʽ 0-�Զ���1-��ʱ
    BYTE        byHighBeamBrightness;//Զ�������[0,10]
    BYTE        byLowBeamBrightness;//��������[0,10]
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���
    WORD        wFilteringTime;//����ʱ��(s)[0,120]
    BYTE        byRes[62];
}NET_DVR_SUPPLEMENTLIGHT,*LPNET_DVR_SUPPLEMENTLIGHT;

typedef	struct tagNET_DVR_EXTERNALDEVICE
{
    DWORD		dwSize;//�ṹ���С
    NET_DVR_SUPPLEMENTLIGHT struSupplementLight;//����ƽṹ��Ϣ
    BYTE        byRes[512];
}NET_DVR_EXTERNALDEVICE,*LPNET_DVR_EXTERNALDEVICE;

//(���֧�֣����ʵ�֣��������������豸�ڲ���)
typedef	struct tagNET_DVR_BUILTIN_SUPPLEMENTLIGHT
{
    DWORD		dwSize;//�ṹ���С
    BYTE  		byMode;//�����ģʽ 0-��ʱ��1-������2-�رգ�3-�Զ����ǹ������㷨����ʶ��
    BYTE        byBrightnessLimit;//��������[0,100]
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���
    BYTE        byRes1[256];
}NET_DVR_BUILTIN_SUPPLEMENTLIGHT,*LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT;

typedef	struct tagNET_DVR_OSD_BATTERY_POWER_CFG
{
    DWORD dwSize;
    NET_VCA_POINT  struOSDBatteryPower;//����ͳ����ʾOSD��ʾ���Ͻ����
    BYTE   byOSDBatteryPower;//��ص���OSD������ʾʹ��,  0-��1-��
    BYTE	byRes[63];
}NET_DVR_OSD_BATTERY_POWER_CFG, *LPNET_DVR_OSD_BATTERY_POWER_CFG;

#define CARD_PARAM_CARD_VALID       0x00000001  //���Ƿ���Ч����
#define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
#define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
#define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
#define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ���������
#define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
#define CARD_PARAM_PASSWORD         0x00000080  //���������
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
#define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������

typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //ʹ����Ч�ڣ�0-��ʹ�ܣ�1ʹ��
    BYTE byRes1[3];
    NET_DVR_TIME_EX struBeginTime; //��Ч����ʼʱ��
    NET_DVR_TIME_EX struEndTime; //��Ч�ڽ���ʱ��
    BYTE byRes2[32];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // ��Ҫ�޸ĵĿ��������ÿ�����ʱ��Ч����λ��ʾ��ÿλ���һ�ֲ���1Ϊ��Ҫ�޸ģ�0Ϊ���޸�
    // #define CARD_PARAM_CARD_VALID       0x00000001 //���Ƿ���Ч����
    // #define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ���������
    // #define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
    // #define CARD_PARAM_PASSWORD         0x00000080  //���������
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byCardValid; //���Ƿ���Ч��0-��Ч��1-��Ч������ɾ������ʱ��Ϊ0����ɾ���ȡʱ���ֶ�ʼ��Ϊ1��
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-������4-Ѳ��5-в�ȿ���6-��������7-��������8-���Ĭ����ͨ��
    BYTE byLeaderCard; //�Ƿ�Ϊ�׿���1-�ǣ�0-��
    BYTE byRes1;
    DWORD dwDoorRight; //��Ȩ�ޣ���λ��ʾ��1Ϊ��Ȩ�ޣ�0Ϊ��Ȩ�ޣ��ӵ�λ����λ��ʾ����1-N�Ƿ���Ȩ��
    NET_DVR_VALID_PERIOD_CFG struValid; //��Ч�ڲ���
    DWORD dwBelongGroup; //����Ⱥ�飬��λ��ʾ��1-���ڣ�0-�����ڣ��ӵ�λ����λ��ʾ�Ƿ����Ⱥ��1-N
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //������
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //��Ȩ�޼ƻ���ȡֵΪ�ƻ�ģ���ţ�ͬ���Ų�ͬ�ƻ�ģ�����Ȩ�޻�ķ�ʽ����
    DWORD dwMaxSwipeTime; //���ˢ������0Ϊ�޴�������
    DWORD dwSwipeTime; //��ˢ������
    WORD wRoomNumber;  //�����
    SHORT wFloorNumber;   //���
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //���û��ȡ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ���п���Ϣ
    BYTE  byCheckCardNo; //�豸�Ƿ���п���У�飬0-��У�飬1-У��
    BYTE  byRes[31];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byRes[16];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;

typedef struct tagNET_DVR_CARD_USER_INFO_CFG  /*��Ӧ���ýṹ��*/
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN];                /* �û���*/
    BYTE byRes2[256];
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //��״̬�ܼƻ�����
#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //�������ܼƻ�����
#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //��Ȩ���ܼƻ�����
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //��״̬���ռƻ�����
#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //���������ռƻ�����
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //��Ȩ�޼��ռƻ�����
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //��״̬���������
#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //��������֤��ʽ���������
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //��Ȩ�޼��������
#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //��״̬�ƻ�ģ�����
#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //��������֤��ʽ�ƻ�ģ�����
#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //��Ȩ�޼ƻ�ģ�����
#define ACS_PARAM_CARD                         0x00001000 //������
#define ACS_PARAM_GROUP                        0x00002000 //Ⱥ�����
#define ACS_PARAM_ANTI_SNEAK_CFG			   0x00004000 //��Ǳ�ز���
#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //�¼���������������
#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //���뿪��ʹ�ܲ���

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //�������ͣ���λ��ʾ
    //#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //��״̬�ܼƻ�����
    //#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //�������ܼƻ�����
    //#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //��Ȩ���ܼƻ�����
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //��״̬���ռƻ�����
    //#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //���������ռƻ�����
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //��Ȩ�޼��ռƻ�����
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //��״̬���������
    //#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //��������֤��ʽ���������
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //��Ȩ�޼��������
    //#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //��״̬�ƻ�ģ�����
    //#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //��������֤��ʽ�ƻ�ģ�����
    //#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //��Ȩ�޼ƻ�ģ�����
    //#define ACS_PARAM_CARD                         0x00001000 //������
    //#define ACS_PARAM_GROUP                        0x00002000 //Ⱥ�����
    //#define ACS_PARAM_ANTI_SNEAK_CFG			     0x00004000 //��Ǳ�ز���
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //�¼���������������
    //#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //���뿪��ʹ�ܲ���
    BYTE byRes[32];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byIOUseType;     //��;��0-���ã�1-���Ű�ť��2-��״̬��0xff-�Զ���
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byIOUseType;     //��;��0-���ã�1-����0xff-�Զ���
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byEnable;   //�Ƿ������ݿأ�0-��1-��
    BYTE    byRes1;     //����
    BYTE    byInterfaceType; //�ӿ����ͣ�0-�ޣ�1-RS485,2-���
    BYTE    byRS485Protocol; //RS485Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ1ʱ��Ч
    BYTE    byNetworkType;  //���Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ2ʱ��Ч
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byEnable;               //�Ƿ������ݿأ�0-��1-��
    BYTE    byRes1;                 //����
    BYTE    byInterfaceType;        //�ӿ����ͣ�0-�ޣ�1-RS485,2-���
    BYTE    byRS485Protocol;        //RS485Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ1ʱ��Ч
    BYTE    byNetworkType;          //���Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ2ʱ��Ч
    BYTE    byRes2;                 //����
    WORD    wServerPort;            //�ݿط������˿ںţ�����Э������Ϊ1-˽�� ʱ��Ч
    NET_DVR_IPADDR    struServerIP; //�ݿط�����IP������Э������Ϊ1-˽�� ʱ��Ч
    BYTE    byRes[256];              // �����ֽ�
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN]; // ���ӶԽ��豸��ţ������ţ��豸����ΪIPCʱȫ��Ϊ0
    BYTE  byDeviceName[NAME_LEN];  //�豸���
    BYTE  bySourceType;            //��ƵԴ���ͣ�0�����壬1-IPC��2-DVR/DVS/NVR��3-�ſڻ�4-Χǽ��5-����ȷ�ϻ�
    BYTE  byRes[255];              //����
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;

#define UNLOCK_PASSWORD_LEN                        8 //������볤��
typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //�����
    BYTE byMagneticType; //�Ŵ����ͣ�0-���գ�1-����
    BYTE byOpenButtonType; //���Ű�ť���ͣ�0-���գ�1-����
    BYTE byOpenDuration; //���ų���ʱ�䣬1-255s
    BYTE byDisabledOpenDuration; //�м��˿����ų���ʱ�䣬1-255s
    BYTE byMagneticAlarmTimeout; //�Ŵż�ⳬʱ����ʱ�䣬0-255s��0��ʾ������
    BYTE byEnableDoorLock; //�Ƿ����ñ��Ż���0-��1-��
    BYTE byEnableLeaderCard; //�Ƿ������׿��������ܣ�0-��1-��
    BYTE byRes1;
    DWORD dwLeaderCardOpenDuration; //�׿���������ʱ�䣬1-1440min
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //в������
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //��������
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN];         //�����
    BYTE byRes2[56];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];    //�豸���
    BYTE    byRes[64];                      	//����
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;          						//ID
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //�豸���
    BYTE        byMACAddr[MACADDR_LEN];             //mac��ַ
    BYTE        byRes1[2];                           //����
    BYTE        sSerialNumber[SERIALNO_LEN];        //�豸���к�
    NET_DVR_IPADDR   struDevIP;                     //�豸IP��ַ
    NET_DVR_TIME_EX struRegisterTime;                 //ע��ʱ��
    BYTE        byRegisterType;                     //ע�����ͣ�0-������1-�ſڻ�2-�����3-���ڻ�4-Χǽ��5-�����ſڻ�6-����ȷ�ϻ�7-8700�ͻ��ˡ�8-4200�ͻ���
    BYTE        byRes[127];                         //����
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;

typedef struct tagNET_DVR_CALLER_INFO
{
    DWORD dwSize;          //�ṹ���С
    WORD   wBuildingNo;	//¥��
    SHORT   wFloorNo;	//���
    BYTE   byZoneNo;		//�ں�
    BYTE   byUnitNo;	//��Ԫ��
    BYTE   byDevNo;	//�豸���
    BYTE    byDevType;   //�豸���ͣ�1-�ſڻ�2-�����3-���ڻ�4-Χǽ��5-�����ſڻ�6-����ȷ�ϻ�7-8700�ͻ��ˣ�8-4200�ͻ��ˣ�9-APP
    BYTE    byRes[100]; 	   //����
}NET_DVR_CALLER_INFO,*LPNET_DVR_CALLER_INFO;

typedef struct tagNET_DVR_CALL_STATUS
{
    DWORD dwSize;          //�ṹ���С
    BYTE   byCallStatus; //��ȡͨ��״̬��1-�޺��С�2-���塢3-����ͨ��
    BYTE   byRes[127];
}NET_DVR_CALL_STATUS, *LPNET_DVR_CALL_STATUS;

#define MAX_SERVER_DEVICE_NUMBER                  16  //����豸����

typedef struct tagNET_DVR_SERVER_DEVICE_CFG
{
    BYTE    byDeviceName[NAME_LEN];   //�豸���
    BYTE	   byDeviceType; ////�豸���ͣ�1-�ſڻ�2-�����3-���ڻ�
    BYTE	   byDeviceID; //�ſڻ���
    BYTE    byRes[6]; 	   //����
}NET_DVR_SERVER_DEVICE_CFG,*LPNET_DVR_SERVER_DEVICE_CFG;

typedef struct tagNET_DVR_SERVER_DEVICE_INFO
{
    DWORD   dwSize;  //�ṹ���С
    DWORD 	dwDeviceNum; //�豸��
    NET_DVR_SERVER_DEVICE_CFG    struDeviceCfg[MAX_SERVER_DEVICE_NUMBER];   //�豸��Ϣ
    BYTE    byRes[200]; 	   //����
}NET_DVR_SERVER_DEVICE_INFO,*LPNET_DVR_SERVER_DEVICE_INFO;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD	dwSize;
    DWORD   dwCmdType;      //��������  0-������У�1-ȡ��κ��У�2-����κ��� 3-�ܾ��������� 4-�������峬ʱ 5-�����ͨ����6-�豸����ͨ���У�7-�豸����ͨ����
    BYTE    byRes[128];     //����
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;

#define MAX_SCREEN_ADDRESS_LEN 16 //��������󳤶�
#define MAX_DAY_TIME_POINT 8   //ÿ�����ʱ������
#define MAX_TIME_POINT     16  //ÿ�����ʱ������

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //�û���
    BYTE byPassWord[PASSWD_LEN]; //����
    NET_DVR_IPADDR struIPAddr; //IP��ַ
    WORD wPort; //�˿ں�
    BYTE byRes[24];
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;

typedef union tagNET_DVR_SCREEN_BASE_INFO
{
    BYTE byScreenAddress[MAX_SCREEN_ADDRESS_LEN]; //��Ļ�����룬�豸��ӷ�ʽΪ0ʱ��Ч
    NET_DVR_DEV_IP_INFO struIPInfo; //��Ļip��ַ��Ϣ
    BYTE byRes[100];
}NET_DVR_SCREEN_BASE_INFO,*LPNET_DVR_SCREEN_BASE_INFO;

typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE byDevAddType; //�豸��ӷ�ʽ��0-��������(����������Ļʹ�ô���ͨ��)��1-��IP��ַ(����������Ļʹ������ͨ��)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //��Ļ�豸����Ϣ
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG,*LPNET_DVR_SCREEN_INDEX_CFG;

//ģ��ң��������
typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE		byControlType;	//1-��Դ����2-��Դ�أ�3-�ź�Դ��4-�˵���5-ȷ����6-�ϣ�7-�£�8-��9-��,  10-INFO, 11-������һ��,12-���ְ���
    BYTE        byControlParam; //���������������Ϊ12ʱ����ʾ����ֵ(0-9)���������ʱ�˲�����Ч
    BYTE		byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

//��Ļάǽ����
typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //״̬���ء�0-Ϊ�رգ�1-Ϊ����
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

//����Ŵ�ԭ����
typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;	//����Ŵ�ԭָ�1-�Ŵ�2-��ԭ
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //��Ҫ�Ŵ��������1920*1920��Ϊ��Ļ�ܴ�С����ԭʱ�˲�����Ч
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;

typedef  union tagNET_DVR_SCREEN_CONTROL_PARAM
{
    NET_DVR_INPUT_INTERFACE_CTRL	struInputCtrl;
    NET_DVR_DISPLAY_COLOR_CTRL 		struDisplayCtrl;
    NET_DVR_DISPLAY_POSITION_CTRL 	struPositionCtrl;
    NET_DVR_SIMULATE_REMOTE_CTRL struSimulateRemoteCrtl; //ģ��ң�ذ���
    NET_DVR_SCREEN_WALL_CTRL struScreenWallCtrl; //��Ļάǽ����
    NET_DVR_AREA_ZOOM_CFG struZoomArea;  //����Ŵ�ԭ����
    BYTE		byRes[16];
}NET_DVR_SCREEN_CONTROL_PARAM, *LPNET_DVR_SCREEN_CONTROL_PARAM;

typedef struct tagNET_DVR_SCREEN_CONTROL
{
    DWORD 	dwSize;
    DWORD  	dwCommand ;      /* ���Ʒ��� 1-�� 2-�� 3-��Ļ����Դѡ�� 4-��ʾ��Ԫ��ɫ���� 5-��ʾ��Ԫλ�ÿ���*/
    BYTE   	byProtocol;      //����Э������,1:LCD-S1,2:LCD-S2
    BYTE	byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM	struControlParam;
    BYTE   	byRes2[52];
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{
    DWORD   dwSize;
    BYTE	bySerialNo;		//���ں�
    BYTE    byRes[2];
    BYTE   	byProtocol;    // ����Э������ 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20��7-LCD-L2,8-LCD-Z1��
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-��Ч��ʹ��Ԥ�Ȱ󶨵�Э������
    DWORD  	dwCommand ;      /* ���Ʒ��� 1-�� 2-�� 3-��Ļ����Դѡ�� 4-��ʾ��Ԫ��ɫ���� 5-��ʾ��Ԫλ�ÿ��ƣ�6-ģ��ң�ذ���,7-��ʾ��Ļ״̬,
    8-��ʾ��Ļ�����루���������������ʼ�����Ϊ��0,0������߾���Ϊ0xffffffff��, 9-��Ļάǽ,10-�ָ���ĻĬ�ϲ���11-��ʾIP�����������������ʼ�����Ϊ��0,0������߾���Ϊ0xffffffff��,12-��ĻUSB�� 13-����Ŵ�ԭ*/
    NET_DVR_SCREEN_CONTROL_PARAM	struControlParam;
    BYTE	byWallNo;		// ����ǽ��
    BYTE   byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//��������м��㣬��׼���
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo; //ƴ������
    BYTE byWallNo; //����ǽ��
    BYTE byEnable; //�Ƿ�ʹ�ܣ�0-��1-��
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ҫ����ƴ�ӵ����򣬻�ȡ��ʱ��˲�����0
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG,*LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;	//����Դ�����ö�� INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;		//���źŻ���ģʽ��1-������2-������3-LOGO����
    BYTE  byRes[30];
}NET_DVR_MSC_SCREEN_INTERFACE_CFG,*LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

//�������
typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //���⣬0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG,*LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//���л�����
typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE	byEnable;	//�Ƿ����û��л� 0-������ 1-����
    BYTE	bySubWindowSource;	//�ӻ����ź�Դ���ο�ö��INPUT_INTERFACE_TYPE
    BYTE	bySubWindowBorderColor;	//�ӻ���߿���ɫ�� 1-��ɫ��2-��ɫ
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //�ӻ���λ�ã���Ļ�ܴ�СΪ1920*1920
    BYTE	byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG,*LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//����״̬��0-�أ�1-��
    BYTE		   byFanExceptionStatus;	//�����쳣״̬��0-��֧�֣�1-��2-�쳣
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //�ۻ���ʱ������λ��Сʱ
    BYTE           byVersion[VERSION_LEN];//����汾��
    int            iTemperature; //�忨�¶ȣ���ȷ����λ����λ�����϶�
    BYTE 			byTempState; 	//�忨�¶�״̬��0-��֧�֣�1-��2-�쳣
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE,*LPNET_DVR_SCREEN_WORK_STATE;

//����logo����
typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�����Ƿ���ʾlogo,0-����ʾ��1-��ʾ
    BYTE byRes[31];
}NET_DVR_BOOT_LOGO_CFG,*LPNET_DVR_BOOT_LOGO_CFG;
//��Ƶ����
typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //�Ƿ�����0-��1-��
    BYTE    byVolume; //������С��0-100
    char    byBalance; //���ƽ�⣬-50-+50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;

//��Ļ����������
typedef union tagNET_DVR_MSC_SCREEN_PARAM
{
    NET_DVR_MSC_SCREEN_INTERFACE_CFG struInterfaceCfg; //����Դ����
    NET_DVR_SCREEN_FAN_WORK_MODE_CFG struFanWorkMode; //���ȹ���ģʽ����
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA�źŲ���
    NET_DVR_SCREEN_MENU_CFG struMenuCfg; //��Ļ�˵�����
    NET_DVR_VIDEO_OUT_CFG struOutEffectCfg; //��ʾЧ�����
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemperatureCfg; //ɫ�²���
    NET_DVR_ADC_CFG struAdcCfg; //ADC����
    NET_DVR_SCREEN_EDGE_CFG struScreenEdgeCfg; //��Ļ��Ե����
    NET_DVR_MSC_SCREEN_BACKLIGHT_CFG struBacklight; //�������
    NET_DVR_MSC_SCREEN_PIP_CFG struPicInPicCfg; //���л�����
    NET_DVR_DEFOG_LCD struDefog; //ȥ�����
    NET_DVR_SCREEN_WORK_STATE struWorkState; //��Ļ����״̬
    NET_DVR_BOOT_LOGO_CFG struBootLogoCfg; //��ʼ��ʾlogo����
    NET_DVR_LCD_AUDIO_CFG struAudioCfg; //��Ƶ����
    BYTE byRes[256];
}NET_DVR_MSC_SCREEN_PARAM,*LPNET_DVR_MSC_SCREEN_PARAM;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //�������ͣ�1-����Դ����2-���ȹ���ģʽ����3-VGA�źŲ���4-��Ļ�˵�����5-��ʾЧ�����6-ɫ�²���7-ADC����8-��Ļ��Ե����9-�������10-���л�����11-͸�����12-��Ļ����״̬��ֻ�ܻ�ȡ����13-����LOGO�Ƿ���ʾ����  14-��Ƶ����
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //��Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG,*LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ļ����
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //���õ���Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG,*LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byParamType; //�������ͣ�1-����Դ����2-���ȹ���ģʽ����3-VGA�źŲ���4-��Ļ�˵�����5-��ʾЧ�����6-ɫ�²���7-ADC����8-��Ļ��Ե����9-�������10-���л�����11-͸�����12-��Ļ����״̬��ֻ�ܻ�ȡ����13-����LOGO�Ƿ���ʾ���� 14-��Ƶ����
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND,*LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //�Ƿ����ø�ʱ���,0-�����ã�1-����
    BYTE bySwitchType; //���ػ����ͣ�0-�ػ�1-����
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //���ػ�ʱ���
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME,*LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //�Ƿ����ø�ʱ���,0-�����ã�1-����
    BYTE bySwitchType; //���ػ����ͣ�0-�ػ�1-����
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //���ػ�ʱ���
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT,*LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //�ܿ��ػ�ƻ�
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //��ʱ��㿪�ػ����
    BYTE byRes[64];
}NET_DVR_TIME_SWITCH_CFG,*LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //��Ļ��Χ
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //��ʱʱ�䣬0-3000����λ��ms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME,*LPNET_DVR_DELAY_TIME;

//˫Ŀ�궨����
typedef enum _BV_CALIBRATION_TYPE_ENUM_
{
    ENUM_BV_CALIBRATION_NONE    = 0, //δ�궨
        ENUM_BV_CALIBRATION_DIRECT  = 1, //˫Ŀֱ�ӱ궨
        ENUM_BV_CALIBRATION_SAMPLE = 2, //˫Ŀ��궨
} BV_CALIBRATION_TYPE_ENUM;


//��궨��
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{
    BYTE  byCalibPtID;   //�궨��ID����Χ[1,5]����ʾ�˵���˫Ŀ�궨����е����
    BYTE  byRes1[3];     //����
    NET_VCA_POINT struPoint;  //�궨�����
    BYTE  byRes2[16];    //����
}NET_DVR_BV_SAMPLE_CALIB_POINT,*LPET_DVR_BV_SAMPLE_CALIB_POINT;

//��ʼ��궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //�����߶ȣ���λcm
    DWORD  dwHumanHeight;  //������ߣ���λcm
    BYTE    byRes[248];      //����
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//������궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //�궨�㡣������Ա����ֱ�����ߣ������������ض�����������ʱ���˵��ʾ�����������ߵ��е㡣
    BYTE byRes[228]; //����
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//������궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256]; //����
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//��궨�������������
typedef union tagNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION
{
    BYTE byRes[256]; //����
    NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM struCalibBegin; //��ʼ�궨�������
    NET_DVR_BV_SAMPLE_CALIB_SET_PARAM struCalibSet; //���ñ궨�������
    NET_DVR_BV_SAMPLE_CALIB_END_PARAM struCalibEnd; //����궨�������
}NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION,*LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//��궨����ö��
typedef enum _BV_SAMPLE_CALIB_CMD_ENUM
{
    ENUM_BV_SAMPLE_CALIB_BEGIN    = 1,   //��ʼ�궨
        ENUM_BV_SAMPLE_CALIB_SETTING  = 2,   //���ò���
        ENUM_BV_SAMPLE_CALIB_END      = 3    //����궨
}BV_SAMPLE_CALIB_CMD_ENUM;

//��궨�ṹ��
typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{
    DWORD   dwSize;     //�ṹ���С
    DWORD   dwChannel;  //ͨ����
    BYTE    byCommand; //�궨����μ�BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];    //����
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //�궨�������ȡֵ�������ֶ�byCommand
    BYTE    byRes2[256] ;  //����
}NET_DVR_BV_SAMPLE_CALIBRATION,*LPNET_DVR_BV_SAMPLE_CALIBRATION;


//˫Ŀ��궨��Ϣ
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;             //�ṹ���С
    DWORD  dwCameraHeight;    //�����߶ȣ���λcm
    float  fPitchAngle;   //������ӽǶ�[0��, 60��],
    float  fInclineAngle; //�������б�Ƕ�[-20��,20��]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //�궨����
    BYTE  byRes[256]; //����
}NET_DVR_BV_SAMPLE_CALIB_CFG,*LPNET_DVR_BV_SAMPLE_CALIB_CFG;

//˫Ŀͼ��У�����ṹ��
typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{
    float   fCamInternalMatrix[3][3];  //����ڲξ��󣬰������༰�������
    float   fDistCoeffs[8];            //��ͷ���ϵ��
    float   fRotateMatrix[3][3];       //У������ת����
    float   fProjectMatrix[3][4];      //У����ͶӰ����
    BYTE    byRes[64];              //����
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

//�������У�����
typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;                       //�ṹ��С
    float      fReprojectMatrix[4][4];   //��ͶӰ����
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //�����У�����
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //�����У�����
    BYTE    byLensType;             //��ͷ�������ͣ�0-δ֪,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE    byRes[255];             //����
} NET_DVR_BV_CORRECT_PARAM,*LPNET_DVR_BV_CORRECT_PARAM;

//�����Ƶ����
typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;     //�ṹ��С
    BYTE   byType;     //�����Ƶ���ͣ�1-ƴ��ͼ��2-���ͼ
    BYTE   byRes[63];  //����
}NET_DVR_OUTPUT_VIDEO_TYPE,*LPNET_DVR_OUTPUT_VIDEO_TYPE;

#define MAX_CHECK_485CHAN		64	//485�Լ��豸ͨ���Ÿ���

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD		dwSize;
    DWORD		dwRS485Chan[MAX_CHECK_485CHAN];//RS485ͨ������������ͨ���ţ�ֵ��ʾͨ���ţ�λ��ʾ��λ��
    DWORD		dwSensorChan[4];//ģ������Ч��ͨ���ţ���λ��ʾ
   	BYTE     	byRes[32];      // �����ֽ�
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

//������ȫ��ȡ����ֵ
typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize ; //�ṹ�峤��
    DWORD   dwChannel; //ͨ����
    BYTE    byRes[64];
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;
    DWORD	    dwChannel;   //ͼƬ��Ӧ��ͨ����
    BYTE	    byPictureType;//ͼƬ��ʽ,0-bmp��1-jpeg��2-PNG 3-SWF 4-GIF
    BYTE 		byRes1[3];  //����
    NET_DVR_TIME_V30 struTime;  //ͼƬ���ʱ��
    char*		sPictureBuffer;//ͼƬ������
    DWORD	    dwPictureLength;//ͼƬ����
	DWORD		dwPicMangeNo;  //ͼƬ�����
	BYTE        sPicName[NAME_LEN];  //ͼƬ���
    BYTE        byRes[92];
}NET_DVR_UPLOAD_PICTURE_INFO,*LPNET_DVR_UPLOAD_PICTURE_INFO;

#define  MAX_UPLOADFILE_URL_LEN      240

typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN] ;   //url
    BYTE byRes[260];
} NET_DVR_UPLOAD_FILE_RET,*LPNET_DVR_UPLOAD_FILE_RET;

typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];  //������ͼ�����Ϣ
    BYTE     byRes[64];
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;
typedef union tagNET_DVR_PIC_EXTRA_INFO_UNION
{
    BYTE   byUnionLen[544];   //�����峤�ȣ���ʵ������
    NET_DVR_FACE_EXTRA_INFO struFaceExtraInfo;   //���������Ϣ
}NET_DVR_PIC_EXTRA_INFO_UNION, *LPNET_DVR_PIC_EXTRA_INFO_UNION;

typedef struct	tagNET_DVR_FIND_PICTURE_V40   //���ҽ��ṹ��
{
    char    sFileName[PICTURE_NAME_LEN];//ͼƬ��
    NET_DVR_TIME struTime;//ͼƬ��ʱ��
    DWORD dwFileSize;//ͼƬ�Ĵ�С
    char    sCardNum[CARDNUM_LEN_V30];	//����
    BYTE   byPlateColor ;//�ο��ṹ VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//�ο��ṹ VLR_VEHICLE_CLASS
    BYTE   byFileType ;  //�ļ����ͣ� :0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ3  ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ 	6 �ֶ�ץͼ ,9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���,	0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������
    BYTE   byRecogResult ;//ʶ����ο��ṹVTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];	//���ƺ���
    BYTE   byEventSearchStatus; //����ͼƬ��ʾͬһ���ҽ���ʱ��0-��ʾ����û��ͼƬ��Ϣ��1-��ʾ���滹��ͼƬ��Ϣ���ܹ�ͼƬ��Ϣ�������һ��״̬Ϊ0��ͼƬ��
    BYTE   byRes[75];		//  �����ֽ�
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //ͼƬ������Ϣ
}NET_DVR_FIND_PICTURE_V40,*LPNET_DVR_FIND_PICTURE_V40;

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byDetectionTarget;//���Ŀ��:0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes[62];             //����
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;

typedef	struct tagNET_DVR_REGION_ENTRANCE_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_REGIONENTRANCE_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_REGION_ENTRANCE_DETECTION,*LPNET_DVR_REGION_ENTRANCE_DETECTION;

typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //ͨ����
    DWORD dwRegion;         //����ID��
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byRes[63];             //����
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef	struct tagNET_DVR_EVENT_TRIGGER
{
    DWORD		dwSize;//�ṹ���С
    NET_DVR_HANDLEEXCEPTION_V41 struHandleException;     //�쳣���?ʽ
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40]; //ʵ�ʴ���¼��ͨ������ֵ��ʾ�����ý��������У����±�0��ʼ˳���ȡ���м�����0xffffffff�������Ч��
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ
    BYTE		byRes2[256];
}NET_DVR_EVENT_TRIGGER,*LPNET_DVR_EVENT_TRIGGER;

typedef	struct tagNET_DVR_EVENT_SCHEDULE
{
    DWORD		dwSize;//�ṹ���С
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    NET_DVR_SCHEDTIME struHolidayAlarmTime[MAX_TIMESEGMENT_V30]; /*���ղ���ʱ��*/
    BYTE		byRes[128];
}NET_DVR_EVENT_SCHEDULE,*LPNET_DVR_EVENT_SCHEDULE;

typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byDetectionTarget;//���Ŀ��:0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes[62];             //����
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;

typedef	struct tagNET_DVR_REGION_EXITING_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_REGIONEXITING_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_REGION_EXITING_DETECTION,*LPNET_DVR_REGION_EXITING_DETECTION;

typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    BYTE byRes[62];             //����
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;

typedef	struct tagNET_DVR_LOITERING_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_LOITERING_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_LOITERING_DETECTION,*LPNET_DVR_LOITERING_DETECTION;

typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE byObjectOccup; //ռ�ȣ���Χ[1-100]
    BYTE byRes[63];             //����
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;

typedef	struct tagNET_DVR_GROUP_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_GROUPDETECTION_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_GROUP_DETECTION,*LPNET_DVR_GROUP_DETECTION;

typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byDetectionTarget;//���Ŀ��:0-����Ŀ�꣬1-�ˣ�2-��
    BYTE byRes[62];             //����
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;

typedef	struct tagNET_DVR_RAPIDMOVE_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_RAPIDMOVE_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_RAPIDMOVE_DETECTION,*LPNET_DVR_RAPIDMOVE_DETECTION;

typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    BYTE byRes[62];             //����
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;

typedef	struct tagNET_DVR_PARKING_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_PARKING_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_PARKING_DETECTION,*LPNET_DVR_PARKING_DETECTION;

typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    WORD wTimeThreshold;//ʱ����ֵ����Χ[5-3600], ��λ��s
    BYTE byTimeThresholdMode;//(ֻд�ֶΣ����ڼ�������)0-�ֶ�byTimeThreshold��Ч��1-�ֶ�wTimeThreshold��Ч
    BYTE byRes[59];             //������
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;

typedef	struct tagNET_DVR_UNATTENDED_BAGGAGE_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_UNATTENDED_BAGGAGE_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_UNATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ���Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    WORD wTimeThreshold;//ʱ����ֵ����Χ[5-3600], ��λ��s
    BYTE byTimeThresholdMode;//(ֻд�ֶΣ����ڼ�������)0-�ֶ�byTimeThreshold��Ч��1-�ֶ�wTimeThreshold��Ч
    BYTE byRes[59];             //����
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;

typedef	struct tagNET_DVR_ATTENDED_BAGGAGE_DETECTION
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    NET_DVR_ATTENDED_BAGGAGE_REGION	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[128];
}NET_DVR_ATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_ATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize;
    DWORD dwChannel;        //ͨ����
    DWORD dwStreamType;     //�������ͣ�0- ��������1- ��������2- ��������
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE		byRes1[3];
    WORD      wResolutionWidth; //�ֱ��ʵĳ�
    WORD      wResolutionHeight; //�ֱ��ʵĿ�
    NET_VCA_POLYGON	struRegion[MAX_REGION_NUM];
    BYTE		byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

#define MAX_DIALNUM_LENGTH  32
typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ��������߲��ţ�0-��1- ��
    BYTE       byDialMode; // 0-�Զ���Auto����1-�ֶ���Manual����Ĭ���Զ����ֶ�ģʽ�¿����ò��żƻ�������ʱ�䡢�ֶ�����
    BYTE       byNetworkMode; //0-�Զ���1-4G���ȣ�2-3G���ȣ�3-�ֶ��л�2G��4-�ֶ��л�3G��5-�ֶ��л�4G��6-��������
    BYTE		byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //���ź���
    BYTE       byUserName[NAME_LEN]; //�û���
    BYTE       byPassword[NAME_LEN]; //����
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //�ֻ����
    BYTE       byVerifProtocol;  // 0-�Զ���Auto����1-CHAP��2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //����ʱ�䣬30-65535����λ�룬�ֶ�ģʽ����Ч
    BYTE		byRes3[64];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;

typedef	struct tagNET_DVR_WIRELESSDIAL_SCHEDULE
{
    DWORD		dwSize;//�ṹ���С
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE		byRes[160];
}NET_DVR_WIRELESSDIAL_SCHEDULE,*LPNET_DVR_WIRELESSDIAL_SCHEDULE;

#define MAX_LENGTH_32   32
typedef	struct tagNET_DVR_WIRELESSDIAL_STATUS
{
    DWORD		dwSize;//�ṹ���С
    BYTE        byRealtimeMode[MAX_LENGTH_32]; //ʵʱģʽ(CDMA 1x��EVDO��HYBRID��GSM��GPRS��EDGE��WCDMA��HSDPA��HSUPA��HSPA��TDSCDMA��TD-LTE��FDD-LTE)
    BYTE        byUIMStatus[MAX_LENGTH_32]; //UIM״̬(UNKNOWN,VALID,NOVALID,ROAM,NOEXIST)
    DWORD       dwSignalQuality; //�ź�������1-100
    BYTE        byDialStatus[MAX_LENGTH_32]; //����״̬��
    NET_DVR_IPADDR    struIpAddr;  //IP��ַ
    NET_DVR_IPADDR    struIPMask;  //�����ַ
    NET_DVR_IPADDR    struGatewayIPMask;  //��ص�ַ
    NET_DVR_IPADDR    struDnsServerIpAddr; //DNS��ַ
    BYTE		byRes[256];
}NET_DVR_WIRELESSDIAL_STATUS,*LPNET_DVR_WIRELESSDIAL_STATUS;

typedef	struct tagNET_DVR_WIRELESSDIAL_CONNECT
{
    DWORD		dwSize;//�ṹ���С
    DWORD       dwInterface; //���ţ�1,2����
    BYTE        byEnableConnect; //�Ƿ�����0-����1-����
    BYTE		byRes[255];
}NET_DVR_WIRELESSDIAL_CONNECT_PARAM,*LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM;


typedef	struct tagNET_DVR_LITESTORAGE
{
    DWORD		dwSize;//�ṹ���С
    BYTE       byEnable; /*ʹ�� 0-������,1-����*/
    BYTE       byStorageTime;/*�洢ʱ�� 1-30 Ĭ��7��*/
    BYTE       byLevel; //�ȼ�����0-��Чֵ����������1-�ͣ�2-��(Ĭ��)��3-�ߣ�
    BYTE		byRes;
    float           fCapacity;//����SD��¼��ռ䣬ֻ��
    BYTE		byDefLowStorageTime;// ��ģʽ���Ƽ����� ֻ��
    BYTE		byDefMediumStorageTime; // ��ģʽ���Ƽ����� ֻ��
    BYTE		byDefHighStorageTime; // ��ģʽ���Ƽ����� ֻ��
    BYTE       byRes1[61];
}NET_DVR_LITESTORAGE,*LPNET_DVR_LITESTORAGE;

typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;//�ṹ���С
    NET_VCA_POLYGON  struRegion;//�궨����
    BYTE        byRes[64];
}NET_DVR_CALIBRATION,*LPNET_DVR_CALIBRATION;

typedef	struct	tagNET_DVR_STD_CONFIG
{
    void*		lpCondBuffer;		//[in]��������(�ṹ���ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD		dwCondSize;		    //[in] lpCondBufferָ����ڴ��С
    void*		lpInBuffer;		    //[in]�������(�ṹ���ʽ),����ʱ��ΪNULL����ȡʱΪNULL
    DWORD		dwInSize;		    //[in] lpInBufferָ����ڴ��С
    void*		lpOutBuffer;		//[out]�������(�ṹ���ʽ),��ȡʱ��ΪNULL,����ʱΪNULL
    DWORD		dwOutSize;		    //[in] lpOutBufferָ����ڴ��С
    void*		lpStatusBuffer;	    //[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�����Ҫ,������NULL
    DWORD		dwStatusSize;		//[in] lpStatusBufferָ����ڴ��С
    void*       lpXmlBuffer;    //[in/out]byDataType = 1ʱ��Ч,xml��ʽ���
    DWORD       dwXmlSize;      //[in/out]lpXmlBufferָ����ڴ��С,��ȡʱͬʱ��Ϊ�������������ȡ�ɹ�����޸Ļ�ʵ�ʳ��ȣ�����ʱ��ʾʵ�ʳ��ȣ���������ڴ��С
    BYTE        byDataType;     //[in]����/�����������,0-ʹ�ýṹ������lpInBuffer/lpOutBuffer��Ч,1-ʹ��XML����lpXmlBuffer��Ч
    BYTE        byRes[23];
}NET_DVR_STD_CONFIG,*LPNET_DVR_STD_CONFIG;

typedef	struct	DWORDtagNET_DVR_STD_ABILITY
{
    void*		lpCondBuffer;	//[in]��������(���ָ�ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD		dwCondSize;		//[in] dwCondSizeָ����ڴ��С
    void*		lpOutBuffer;	//[out]�������(XML��ʽ),��ΪNULL
	DWORD		dwOutSize;		//[in] lpOutBufferָ����ڴ��С
    void*		lpStatusBuffer;	//[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�����Ҫ,������NULL
    DWORD		dwStatusSize;	//[in] lpStatusBufferָ����ڴ��С
    DWORD		dwRetSize;		//[out]��ȡ������ݳ���(lpOutBuffer����lpStatusBufferָ���ʵ����ݳ���)
    BYTE		byRes[32];		//�����ֽ�
}NET_DVR_STD_ABILITY,*LPNET_DVR_STD_ABILITY;

typedef struct tagNET_DVR_STD_CONTROL
{
    void*		lpCondBuffer;	//[in]��������(���ָ�ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD		dwCondSize;		//[in] dwCondSizeָ����ڴ��С
    void*		lpStatusBuffer;	//[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�����Ҫ,������NULL
    DWORD		dwStatusSize;	//[in] lpStatusBufferָ����ڴ��С
    void*       lpXmlBuffer;    //[in/out]byDataType = 1ʱ��Ч,xml��ʽ���
    DWORD       dwXmlSize;      //[in/out]lpXmlBufferָ����ڴ��С,��ȡʱͬʱ��Ϊ�������������ȡ�ɹ�����޸Ļ�ʵ�ʳ��ȣ�����ʱ��ʾʵ�ʳ��ȣ���������ڴ��С
    BYTE        byDataType;     //[in]����/�����������,0-ʹ�ýṹ������lpCondBuffer��Ч,1-ʹ��XML����lpXmlBuffer��Ч
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;

typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
	DWORD   dwSize;						//�ṹ���С
	void*	lpRequestUrl;				//��������ַ��ʽ
	DWORD	dwRequestUrlLen;			//��������ȣ��ַ���
	void*	lpInBuffer;					//����������XML��ʽ
	DWORD	dwInBufferSize;				//�����������С
	DWORD   dwRecvTimeOut;				//���ճ�ʱʱ�䣬��λ��ms����0��ʹ��Ĭ�ϳ�ʱ5s
	BYTE	byRes[32];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
	DWORD   dwSize;						//�ṹ���С
	void*	lpOutBuffer;				//����������XML��ʽ
	DWORD	dwOutBufferSize;			//�����������С(�ڴ��С)
	DWORD   dwReturnedXMLSize;			//ʵ�������XML���ݴ�С
	void*	lpStatusBuffer;				//���ص�״̬����(XML��ʽ),��ȡ����ɹ�ʱ���ḳֵ,�����Ҫ,������NULL
	DWORD	dwStatusSize;				//״̬�������С(�ڴ��С)
	BYTE	byRes[32];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;

typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //ʱ
    BYTE byMinute; //��
    BYTE bySecond; //��
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //��ʼʱ���
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //����ʱ���
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byDoorStatus; //��״̬ģʽ��0-��Ч��1-����״̬��2-����״̬��3-��ͨ״̬����״̬�ƻ�ʹ�ã�
    BYTE byVerifyMode; //��֤��ʽ��0-��Ч��1-ˢ����2-ˢ��+����(��������֤��ʽ�ƻ�ʹ��)��3-ˢ��,4-ˢ��������(��������֤��ʽ�ƻ�ʹ��), 5-ָ�ƣ�6-ָ��+���룬7-ָ�ƻ�ˢ����8-ָ��+ˢ����9-ָ��+ˢ��+���루���Ⱥ�˳��
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //ʱ��β���
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //�ܼƻ�����
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];
    NET_DVR_DATE struBeginDate; //���տ�ʼ����
    NET_DVR_DATE struEndDate; //���ս�������
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //ʱ��β���
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�1-���ã�0-������
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //���������
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //���ռƻ���ţ���ǰ��䣬��0��Ч
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�1-���ã�0-������
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //ģ�����
    DWORD dwWeekPlanNo; //�ܼƻ���ţ�0Ϊ��Ч
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //�������ţ���ǰ��䣬��0��Ч
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;


typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //�ƻ�ģ���ţ�Ϊ0��ʾȡ��������ָ�Ĭ��״̬����ͨ״̬��
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //�ƻ�ģ���ţ�Ϊ0��ʾȡ��������ָ�Ĭ��״̬��ˢ�����ţ�
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //Ⱥ����Ч�ڲ���
    BYTE byGroupName[GROUP_NAME_LEN]; //Ⱥ�����
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //�Ƿ����ø�Ⱥ�����
    BYTE byMemberNum; //ˢ����Ա����
    BYTE bySequenceNo; //Ⱥ��ˢ�������
    BYTE byRes;
    DWORD dwGroupNo;  //Ⱥ����,0xffffffff��ʾԶ�̿��ţ�0xfffffffe��ʾ��������
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //�Ƿ����øö��ؿ������0-�����ã�1-����
    BYTE byEnableOfflineVerifyMode; //�Ƿ�������������ʱ��֤��ʽ�������������Զ�̿��ţ�
    BYTE byRes1[2];
    DWORD dwTemplateNo; //���ö��ؿ����ܵļƻ�ģ����
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //Ⱥ����ϲ���
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ö��ؿ����ܣ�0-�����ã�1-����
    BYTE bySwipeIntervalTimeout; //ˢ�������ʱʱ�䣬1-255s��Ĭ��10s
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //Ⱥ��ˢ������
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

//2014-12-03  T1����״̬�ṹ��
typedef struct
{
    DWORD  dwSize;//�ṹ���С
    WORD   wPort;  //�˿ں�
    //(�豸ͨ��˿ڿ��ƣ��˿ں��豸�˹̶����ϲ㲻�����ã�����ʼ����socket���ӣ���������T1�������ݣ���XML��ʽ)
    //0- �ر�(�ر��豸�������̣߳��ͷŶ˿�)��1- ����(�豸�ڲ������������߳�)
    BYTE   byPortState;
    BYTE   byRes[61];	 //����
}NET_DVR_T1TEST_PARAMCFG,*LPNET_DVR_T1TEST_PARAMCFG;

#define CARD_PARAM_CARD_VALID       0x00000001 //���Ƿ���Ч����
#define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
#define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
#define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
#define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ���������
#define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
#define CARD_PARAM_PASSWORD         0x00000080  //���������
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
#define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //ʹ�ܷ�Ǳ�ع��ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //��Ǳ����ʼ���������
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //�����������ţ�Ϊ0��ʾ����ע��ʼ���������
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //�������ʾ,�Ƿ��п���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //�������ʾ,�Ƿ��й���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM]; //�������ʾ,�Ƿ��в���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];  //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byRes[256];                              //����
}NET_DVR_PHONE_DOOR_RIGHT_CFG,*LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ö��Ż����ܣ�1-���ã�0-������
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //���Ż��������ȡֵΪ�ű��
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byCardReaderType; //���������ͣ�1-DS-K110XM/MK/C/CK��2-DS-K192AM/AMP��3-DS-K192BM/BMP��4-DS-K182AM/AMP��5-DS-K182BM/BMP��6-DS-K182AMF/ACF��7-Τ���485������,8- DS-K1101M/MK��9- DS-K1101C/CK��10- DS-K1102M/MK/M-A
                            //11- DS-K1102C/CK��12- DS-K1103M/MK��13- DS-K1103C/CK��14- DS-K1104M/MK��15- DS-K1104C/CK��16- DS-K1102S/SK/S-A��17- DS-K1102G/GK��18- DS-K1100S-B��19- DS-K1102EM/EMK��20- DS-K1102E/EK��
                            //21- DS-K1200EF��22- DS-K1200MF��23- DS-K1200CF��24- DS-K1300EF��25- DS-K1300MF��26- DS-K1300CF��27- DS-K1105E��28- DS-K1105M��29- DS-K1105C��30- DS-K182AMF��31- DS-K196AMF��32-DS-K194AMP
                            //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C��35-DS-K1T105E/E-C/M/M-C/C/C-C
    BYTE byOkLedPolarity; //OK LED���ԣ�0-������1-����
    BYTE byErrorLedPolarity; //Error LED���ԣ�0-������1-����
    BYTE byBuzzerPolarity; //���������ԣ�0-������1-����
    BYTE bySwipeInterval; //�ظ�ˢ�����ʱ�䣬��λ����
    BYTE byPressTimeout;  //����ʱʱ�䣬��λ����
    BYTE byEnableFailAlarm; //�Ƿ����ö���ʧ�ܳ��α�����0-�����ã�1-����
    BYTE byMaxReadCardFailNum; //������ʧ�ܴ���
    BYTE byEnableTamperCheck;  //�Ƿ�֧�ַ����⣬0-disable ��1-enable
    BYTE byOfflineCheckTime;  //���߼��ʱ�� ��λ��
    BYTE byFingerPrintCheckLevel;   //ָ��ʶ��ȼ���1-1/10�����ʣ�2-1/100�����ʣ�3-1/1000�����ʣ�4-1/10000�����ʣ�5-1/100000�����ʣ�6-1/1000000�����ʣ�7-1/10000000�����ʣ�8-1/100000000�����ʣ�9-3/100�����ʣ�10-3/1000�����ʣ�11-3/10000�����ʣ�12-3/100000�����ʣ�13-3/1000000�����ʣ�14-3/10000000�����ʣ�15-3/100000000�����ʣ�16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byRes[24];
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //����״̬��0-�أ�1-��
    BYTE byDoorStatus[MAX_DOOR_NUM]; //��״̬��1-����״̬��2-����״̬��3-��ͨ״̬
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //�Ŵ�״̬��0-�պϣ�1-����
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; ////�¼�������״̬��0-�����룬1-������
    WORD wBatteryVoltage; //���ص�ѹֵ��ʵ��ֵ��10����λ������
    BYTE byBatteryLowVoltage; //�����Ƿ��ڵ�ѹ״̬��0-��1-��
    BYTE byPowerSupplyStatus; //�豸����״̬��1-�����繩�磬2-���ع���
    BYTE byMultiDoorInterlockStatus; //���Ż���״̬��0-�رգ�1-����
    BYTE byAntiSneakStatus; //��Ǳ��״̬��0-�رգ�1-����
    BYTE byHostAntiDismantleStatus; //�������״̬��0-�رգ�1-����
    BYTE byIndicatorLightStatus; //ָʾ��״̬��0-���ߣ�1-����
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //����������״̬��0-�����ߣ�1-����
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //����������״̬��0-�رգ�1-����
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //��������ǰ��֤��ʽ��1-ˢ����2-ˢ��+���룬3-ˢ����4-ˢ��������
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڲ���״̬��0-��Ӧ��������ڴ��ڳ���״̬��1-��Ӧ��������ڴ��ڲ���״̬
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������ڱ���״̬��0-��Ӧ��������ڵ�ǰ�ޱ�����1-��Ӧ��������ڵ�ǰ�б���
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //���������״̬��0-��Ӧ����������ޱ�����1-��Ӧ����������б���
    DWORD dwCardNum; //����ӵĿ�����
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //���������������0-��������1-����
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //������������������1-������0-������
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //���������ı��������1-������0-������
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //����1-N�����Ŵ򿪣�0-��������1-���������򿪣�
    BYTE  byDoorClose[MAX_DOOR_NUM]; //����1-N�����Źرգ�0-��������1-���������رգ�
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;

typedef enum _ENUM_UPGRADE_TYPE
{
    ENUM_UPGRADE_DVR = 0, //��ͨ�豸��
        ENUM_UPGRADE_ADAPTER = 1, //DVR��������
        ENUM_UPGRADE_VCALIB = 2,  //���ܿ���
        ENUM_UPGRADE_OPTICAL = 3, //��˻���
        ENUM_UPGRADE_ACS = 4, //�Ž�ϵͳ��
        ENUM_UPGRADE_AUXILIARY_DEV = 5,//�����豸��
		ENUM_UPGRADE_LED = 6 //LED���Ϳ��ͽ��տ���
}ENUM_UPGRADE_TYPE;

typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //���ţ�Ϊ0��Ч
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-������4-Ѳ��5-в�ȿ���6-��������7-��������Ϊ0��Ч
    BYTE byWhiteListNo; //������,1-8��Ϊ0��Ч
    BYTE byReportChannel; //�����ϴ�ͨ����1-�����ϴ���2-������1�ϴ���3-������2�ϴ���Ϊ0��Ч
    BYTE byCardReaderKind; //������������һ�࣬0-��Ч��1-IT��������2-���֤��������3-��ά�������
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    DWORD dwDoorNo; //�ű�ţ�Ϊ0��Ч
    DWORD dwVerifyNo; //���ؿ���֤��ţ�Ϊ0��Ч
    DWORD dwAlarmInNo;  //��������ţ�Ϊ0��Ч
    DWORD dwAlarmOutNo; //��������ţ�Ϊ0��Ч
    DWORD dwCaseSensorNo; //�¼����������
    DWORD dwRs485No;    //RS485ͨ���ţ�Ϊ0��Ч
    DWORD dwMultiCardGroupNo; //Ⱥ����
    BYTE  byRes[32];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME struTime; //ʱ��
    BYTE	sNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR	struRemoteHostAddr ;//Զ�������ַ
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo; //��ϸ����
    DWORD dwPicDataLen;   //ͼƬ��ݴ�С����Ϊ0�Ǳ�ʾ��������
    char    *pPicData;
    BYTE byRes[24];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;

#define JUDGE_MAX_VIDEOOUT_NUM 9

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;    //�Ƿ�����
    BYTE    byRes1[3];
    DWORD   dwChanNo;    //�����������Ƶͨ����
    BYTE    bySensitivity; //������ 1-100��������Խ�ߣ���ʾ�ϵ͵���������ʹ�ܸ���Ƶ���뼤���ܣ�������Խ�ͣ���ʾ��Ҫ�ϸߵ���������ʹ�ܸ���Ƶ����ļ�����
    BYTE    byPriority;     //���ȼ�  0-���ȼ�0��1-���ȼ�1�� ֵԽ�󼶱�Խ��
    WORD    wDelayTime;  //��������������л��ӳ�ʱ�䣬��λs, ��ʱ���Զ��ص�Ԥ�õ�1��Ӧ�Ļ���
    BYTE    byRes2;      //����
    BYTE    byEnablePreset; //�Ƿ�����Ԥ�õ�
    WORD    wPreset;    //Ԥ�õ�
    WORD	wBase;           /*��׼����*/
    BYTE	byRes3[2];
   	BYTE	byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];          //���������Ƿ��������Ƶ����ڡ�ֵ0��ʾ�������1-��ʾ������±��ʾͨ��˳�����£�0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
    BYTE    byRes[255]; //����
}NET_DVR_AUDIO_ACTIVATION_CFG,*LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   byIROutPort;   //�����������1-���������1��2-���������2
    BYTE   byIRCmdIndex; //����ѧ�������Ӧ������
    BYTE   byRes[254]; //����
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

#define  MAX_IR_CMD_NAME_LEN    32   //�������������Ƴ���
#define  MAX_IR_CMD_NUM         32   //�����������

typedef struct tagNET_DVR_INFRARED_CMD_INFO   //�������������Ϣ
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];  //�����������
    BYTE   byRes[8];         //����
} NET_DVR_INFRARED_CMD_INFO,*LPNET_DVR_INFRARED_CMD_INFO;


typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;  //�ṹ���С
    BYTE	  sIROutName[MAX_IR_CMD_NAME_LEN];  //������������
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];  //������������Ϣ
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG,*LPNET_DVR_INFRARED_CMD_NAME_CFG;

typedef enum tagIR_LEARN_SEND_DATA_TYPE_ENUM
{
    ENUM_SENDDATA = 0x0, //�������
        ENUM_SEND_LEARN_IR_CMD_START,  //���ͺ���ѧ��
        ENUM_SEND_LEARN_IR_CMD_END   = 0x2  //����ѧ�����
}IR_LEARN_SEND_DATA_TYPE_ENUM;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;       //�ṹ���С
    BYTE  byIROutPort;  //�����������1-���������1��2-���������2
    BYTE  byIRCmdIndex; //����ѧ�������Ӧ������
    BYTE  byRes[30];    //����
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   bySaveLearnInfo;      //����ѧ����Ϣ��0-���棬1-������
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END,*LPNET_DVR_INFRARED_LEARN_END;

#define MAX_VIDEOIN_TYPE_NUM  10    //���֧�ֵ���Ƶ����Դ����

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;   //����Դ����  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
    WORD  wInNum;  //֧�ֵ��������
    WORD  wStartNo;  //�����Ӧ����ʼ��
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;

typedef  struct tagNET_DVR_TRIAL_SYSTEM_INFO
{
    DWORD dwSize ;    //�ṹ���С
    BYTE   byVideoInTypeNum ;   //��Ƶ����Դ���͸���
    BYTE   byRes1[3];
    NET_DVR_VIDEOIN_TYPE_INFO struVideoIn[MAX_VIDEOIN_TYPE_NUM] ;  //��Ƶ����Դ
    BYTE   byRes[512 ] ;  //����
} NET_DVR_TRIAL_SYSTEM_INFO, *LPNET_DVR_TRIAL_SYSTEM_INFO;

typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;       //�ṹ���С
    BYTE	byCaseNo[CASE_NO_LEN];  //�������
    BYTE	byCaseName[CASE_NAME_LEN]; //������ƣ�
    BYTE	byLitigant1[LITIGANT_LEN]; //������1��
    BYTE	byLitigant2[LITIGANT_LEN]; //������2��
    BYTE	byChiefJudge[CHIEF_JUDGE_LEN];//���г�
    BYTE	byCaseType; //�������ͣ�1-���°�����2-���°���
    BYTE	byShowCaseInfoTime; /* ������Ϣ��ʾʱ��,��λ��, ȡֵ��Χ1~30*/
    BYTE    byRes[254]; //����
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;

#define	 MICROPHONE_NUM			16
#define	 FAN_NUM				8
#define	 FPGA_NUM				8
#define	 MAIN_BOARD				8
#define  LOCAL_INPUT_NUM		24
#define  LAMP_STATE_NAME		32
#define  LAMP_NAME				32
#define FILE_NAME_LEN			32
typedef  struct _NET_DVR_REMOTE_PLAY_
{
    DWORD	dwSize;
    BYTE	byFileName[FILE_NAME_LEN];   //��Ҫ���ŵ��ļ����
    BYTE	byVideoOut[7];	//���������
    BYTE	byRes1[5];
    BYTE	byType;  // 0-�����壬1-��ʼ���ţ�2-ֹͣ����
    BYTE  	byRes[31];  //����
}NET_DVR_REMOTE_PLAY, *LPNET_DVR_REMOTE_PLAY;

typedef  struct _NET_DVR_TRIAL_MICROPHONE_STATUS
{
    DWORD 	dwSize ;
    BYTE	byMicrophoneStatus [MICROPHONE_NUM];//��˷�״̬�±��ʾ��˷��0-���磬1-������
    BYTE	byRes[32] ;  //����
}NET_DVR_TRIAL_MICROPHONE_STATUS, *LPNET_DVR_TRIAL_MICROPHONE_STATUS;

typedef  struct _NET_DVR_TRIAL_HOST_STATUS
{
    DWORD  dwSize ;
    DWORD  dwFanSpeed [FAN_NUM];//����ת��
    WORD   wMainBoardTemp[MAIN_BOARD]; //�����¶�
    BYTE   byFpgaTempWarn [FPGA_NUM];     //����0-�����¶����ޱ���״̬������1-FPGA�¶ȱ���״̬λ��1-���ڱ���״̬   0-�����ޱ���״̬
    BYTE   byRes[32] ;  //����
}NET_DVR_TRIAL_HOST_STATUS, *LPNET_DVR_TRIAL_HOST_STATUS;

typedef  struct _NET_DVR_LOCAL_INPUT_INFO_
{
    DWORD	  dwSize;
    BYTE	  byChannelName[NAME_LEN] ;		//ͨ�����
    BYTE	  byRes[32] ;  //����
}NET_DVR_LOCAL_INPUT_INFO, *LPNET_DVR_LOCAL_INPUT_INFO;

typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE 	byEnable;  //�Ƿ�����
    BYTE 	byRes1[3];
    BYTE 	byLampName[LAMP_NAME];   //Lamp ��ƣ��������3��4��ΪLamp1������5��6�����Ϊlamp2��
    BYTE 	byLampState1[LAMP_STATE_NAME];   //״̬1��Ӧ��ƣ�
    BYTE 	byLampState2[LAMP_STATE_NAME];   //״̬2��Ӧ���
    BYTE 	byLampState3[LAMP_STATE_NAME];   //״̬3��Ӧ���
    BYTE 	byRes[32];
}NET_DVR_LAMP_STATUS,*LPNET_DVR_LAMP_STATUS;

typedef  struct _NET_DVR_LAMP_OUT
{
    DWORD		dwSize;
    NET_DVR_LAMP_STATUS  struLampInfo[2]; //����0-��ʾlamp1,����1����lamp2
    BYTE  byRes[256];  //����
}NET_DVR_LAMP_OUT, *LPNET_DVR_LAMP_OUT;

typedef  struct _NET_DVR_LAMP_CONTROL
{
    DWORD	 dwSize ;
    BYTE  byLampNo ; //Lamp��ţ���Ӧ����Lamp�����±�
    BYTE  byLampStateNo ; //Lamp״̬��� 0-�����壬1-״̬1, 2-״̬2�� 3-״̬3  ��ӦLAMP���������״̬
    BYTE  byRes[14] ;  //����
}NET_DVR_LAMP_CONTROL, *LPNET_DVR_LAMP_CONTROL;


//ʵʱ��Ϣ
typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE				byStart;          // ��ʼ��
    BYTE				byCMD;         // ����ţ�01-����ָ�02-�뿪ָ�03-ӵ��״ָ̬��(Ϊ03ʱ��ֻ��byLaneState��byQueueLen��Ч)
    BYTE				byRes[2];        // Ԥ���ֽ�
    WORD				wDeviceID;      // �豸ID
    WORD				wDataLen;       // ��ݳ���
    BYTE				byLane;         // ��Ӧ������
    BYTE				bySpeed;        // ��Ӧ���٣�KM/H��
    BYTE              	byLaneState;     // ����״̬��0-��״̬��1-��ͨ��2-ӵ����3-����
    BYTE              	byQueueLen;	   // ����״̬���Ŷӳ��ȣ�����50�ף�
    BYTE                byRes1[24];        //����
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

//TPSʵʱ������ϴ�
typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwChan ;//ͨ����
    NET_DVR_TIME_V30	  struTime;	//���ʱ��
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// ��ͨ����ͳ����Ϣ
    BYTE                  byRes[24];      // ����
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

//ͳ����Ϣ
typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE              	byLane;			 // ��Ӧ������
    BYTE              	bySpeed;			 // ������ƽ���ٶ�
    BYTE              	byRes[2];			 // ����
    DWORD               dwLightVehicle;      // С�ͳ�����
    DWORD               dwMidVehicle;        // ���ͳ�����
    DWORD               dwHeavyVehicle;      // ���ͳ�����
    DWORD               dwTimeHeadway;      // ��ͷʱ�࣬�������
    DWORD               dwSpaceHeadway;     // ��ͷ��࣬����������
    float               fSpaceOccupyRation; // �ռ�ռ���ʣ��ٷֱȼ���,������*1000
    float               fTimeOccupyRation;  // ʱ��ռ���ʣ��ٷֱȼ���,������*1000
    BYTE                byRes1[16];           	// ����
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

// ��ͨ����ͳ����Ϣ
typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE				byStart;          // ��ʼ��
    BYTE				byCMD;         // ����ţ� 08-��ʱ�������ָ��
    BYTE				byRes[2];        // Ԥ���ֽ�
    WORD				wDeviceID;      // �豸ID
    WORD				wDataLen;       // ��ݳ���
    BYTE				byTotalLaneNum;  // ��Ч��������
    BYTE                byRes1[15];
    NET_DVR_TIME_V30	struStartTime;	//ͳ�ƿ�ʼʱ��
    DWORD				dwSamplePeriod;	//ͳ��ʱ��,��λ��
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

//TPSͳ�ƹ�����ϴ�
typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwChan ;//ͨ����
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// ��ͨ����ͳ����Ϣ
    BYTE                  byRes[128];      // ����
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;

#define     DPC_CORRECT                1    //У��
#define     DPC_CORRECT_CANCEL         2    //ȡ��У��
#define     DPC_CROSS_DISPALY_OPEN     3    //������ʮ�ֲ���ʾ����
#define     DPC_CROSS_DISPALY_CLOSE    4    //������ʮ�ֲ���ʾ�ر�
#define     DPC_POINT                  5    //����У�����
#define     DPC_UP                     6    //����У����������ƫ��
#define     DPC_DOWN                   7    //����У����������ƫ��
#define     DPC_RIGHT                  8    //����У����������ƫ��
#define     DPC_LEFT                   9    //����У����������ƫ��

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //ͨ����
    WORD    wCtrlType ;//�ο��궨��
    BYTE    byRes[2];
    NET_VCA_POINT struPoint; /*�����ͼ��ƽ����꣬��һ����0-1*/
    BYTE    byRes1[64];
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

//�Ǿ�����У��(FFC)�ֶ�ģʽ
typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE   byRes[64];
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

//�Ǿ�����У��(FFC)��������
typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE   byRes[64];
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

//�洢����������״̬
typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    /*�洢ͼƬ���أ���λ��ʾ��0-�رգ�1-����
    ����0-�ƶ����ץͼ(�ݲ�֧��)
    ����1-����ץͼ(�ݲ�֧��)
    ����
    */
    BYTE  byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER];
    /*�洢������Ϣ���أ���λ��ʾ��0-�رգ�1-����
    ����0-�ȶ�ͼ(�ݲ�֧��)
    ����1-������(�ݲ�֧��)
    ����
    */
    BYTE  byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER];
    BYTE  byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,
*LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;

//ǿ��ֹͣȡ֤
typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE    byRes[64];
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //�������ܱ�������ʾͨ����
    BYTE  bySubWinNo;  //�������ܱ������Ӵ��ں�
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //����ʱ��
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //����Դ��Ϣ
    BYTE  *byAlarmPic; //����ͼƬ������
    DWORD dwAlarmPicSize; //����ͼƬ��С����λ���ֽ�
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //�Ƿ�������ܱ���logo��0-�����ӣ���0-����
    BYTE byFlash;   //�Ƿ���˸��0-����˸����0-��˸
    WORD wFlashTime; //��˸ʱ�䣬��λ���룬ȡֵ��Χ�ӽ�������������ȡ
    DWORD dwLogoX;  //logo X��꣬���봰���ܴ�С��1920*1920
    DWORD dwLogoY;  //logo Y���
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //���ܱ���ʱ�Ƿ��ϴ�����ͼƬ��0-���ϴ�����0-�ϴ�
    BYTE byOverlayTargetInfo; //����ͼƬ�Ƿ����Ŀ����Ϣ��0-�����ӣ���0-����
    BYTE byOverlayRuleInfo; //����ͼƬ�Ƿ�������ܹ�����Ϣ��0-�����ӣ���0-����
    BYTE byPicQuality;			//ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ��
    /*ͼƬ��С ����ͨ����������ȡ
    0-CIF��           1-QCIF��           2-D1��         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)��
    6-VGA��           7-XVGA��           8-HD900p��     9-HD1080��     10-2560*1920��
    11-1600*304��     12-2048*1536��     13-2448*2048,  14-2448*1200�� 15-2448*800��
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576��
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(ʹ�õ�ǰ�����ֱ���)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //���ܱ���logo���Ӳ���
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //���ܱ���ͼƬ����
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

#define MAX_OSD_LEN                 64   //�����OSD����
typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//ͼƬ���
    BYTE   byUsed; //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-����
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO,*LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD dwSize;
    DWORD  dwOutputPicNo;  //ͼƬ���
    BYTE   byEnable; //logo�Ƿ���ʾ��1-��ʾ��0-����
    BYTE   byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//logoλ�ã�����ڷ�Χ�ܴ�СΪ1920*1920
    BYTE   byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE   byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE   byRes2[2];				//����
    DWORD  dwOutputPicWinNo; //�����ͼƬ���ںţ�1�ֽ��豸��+1�ֽ�����ں�+2�ֽ������ͼƬ���ںţ�,��ȡȫ��ʱ��Ч
    BYTE   byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG,*LPNET_DVR_OUTPUT_PIC_CFG;

typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //OSD�Ƿ���ʾ��0-����ʾ��1-��ʾ
    BYTE     byFontSize; //�����С��1-��2-�У�3-С
    BYTE     byOSDColor; //OSD��ɫ���ã�0-Ĭ�ϣ� 1-�ڣ�2-�ף�3-�죬4-�̣�5-��
    BYTE     byRes1[1];
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD����
    NET_DVR_RECTCFG_EX struRect;//OSDλ�ã�����ڷ�Χ�ܴ�СΪ1920*1920
    DWORD dwOsdWinNo; //�����OSD���ںţ�1�ֽ��豸��+1�ֽ�����ں�+2�ֽ�OSD���ںţ�����ȡ����ʱ��Ч
    BYTE	 byRes2[32];				//����
}NET_DVR_OUTPUT_OSD_CFG,*LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //��ʾͨ���ţ�1�ֽ��豸��+1�ֽڱ���+2�ֽ���ʾͨ���ţ�
    BYTE  byRelateAudio; //�Ƿ�����Ӵ�����Ƶ
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //������Ƶ���Ӵ��ںţ�1�ֽڵ���ǽ��+1�ֽ��Ӵ��ں�+2�ֽڴ��ںţ�
    DWORD dwChannel; //����ͨ���ţ���ȡȫ��ʱ��Ч
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD	dwSize;
    BYTE	bySensorChan[64];//ģ����ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE	byAlarmInChan[64];//��������ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE	byAlarmOutChan[64];//�������ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE	by485Chan[64];//485ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE	byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;

typedef struct
{
    DWORD	dwSize;
    BYTE	byOutScale[8];//�±��ʾ�����ںţ�0-��ʾ��֧�֣�1-��ʾ12V��2-��ʾ24V
    BYTE	byRes[16];
}NET_DVR_OUT_SCALE_CFG, *LPNET_DVR_OUT_SCALE_CFG;

typedef	struct 	tagNET_DVR_MONITOR_LOCATION_COND
{
    DWORD   dwSize;
    DWORD   dwChan;
    /*
    0 ��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
    1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE    byRelateType;
    BYTE	byRes[63];		//����
}NET_DVR_MONITOR_LOCATION_COND, *LPNET_DVR_MONITOR_LOCATION_COND;

typedef	struct 	tagNET_DVR_MONITOR_LOCATION_CFG
{
    DWORD   dwSize;
    BYTE    byMonitoringSiteID[MAX_ID_LEN/*48*/];		//������
    BYTE    byDeviceID[MAX_ID_LEN/*48*/];				//�豸���
    BYTE	byDirectionNo;		//��ⷽ����,0-��,1-����,2-����,3-˫��,4-�ɶ�����,5-������,6-������,7-�ɱ�����,8-����
    BYTE	byRes1[3];		//����
    BYTE	byMonitorInfo[MONITORSITE_ID_LEN/*48*/];  	//������Ϣ����
    BYTE	byRes[128];		//����
}NET_DVR_MONITOR_LOCATION_CFG, *LPNET_DVR_MONITOR_LOCATION_CFG;

typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;    //�ṹ��С
    DWORD   dwChannel; //ͨ����
    BYTE    byRes[64];
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;               //�ṹ��С
    BYTE    byAlarmStatus;//����״̬��0-����,1-����,2-����
    BYTE    byRes[3];
    WORD    wAlarmDealyTime;//�����ӳ�ʱ�䣬��λs
    WORD    wDisAlarmDealyTime;//�����ӳ�ʱ�䣬��λs
    BYTE    byRes1[64];
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{
    DWORD	dwSize;
    BYTE	byCommuMode;//˽��Э��ͨ��ģʽ��0-����ģʽ��1-��ȫģʽ
    BYTE	byRes1[2];
    BYTE	byWebAuthentication;    //web��֤���� 0-digest��1-basic;Ĭ��basic��֤
    BYTE	byRtspAuthentication;   //rtsp��֤���� 0-disable��1-basic;Ĭ��basic��֤
    BYTE    byTelnetServer;         //telnet���� 0�����ã�1������
    BYTE    bySSHServer;            //SSH���� 0������(Ĭ��)��1������
    BYTE    byIllegalLoginLock;     //������½��, 0-���ã�Ĭ�ϣ���1-����
    BYTE    byStreamEncryption;     //�������� 0-�����ܣ�1-����
    BYTE	byRes[27];
}NET_DVR_SECURITY_CFG,*LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD	dwSize;
    BYTE 	byRes[3];
    BYTE 	byLockCount;  	//��Ӧ�û����IP����������Ĵ��������¼�󣬶Ը��û�������0-��������ֵΪ��Ĵ��� Ĭ��Ϊ0������1��ʾ�����¼1���Ժ������û���
    DWORD  dwLockTime;   	//��ʱ�䣬��ʾ��������ʱ�䣬��λ���롣����Ϊ0��byLockCount��Ϊ0ʱ��dwLockTime����Ч
    BYTE 	byRes1[128];		//4�ֽڶ���
} NET_DVR_PASSWORD_MANAGE_CFG,*LPNET_DVR_PASSWORD_MANAGE_CFG;


typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD	dwSize;
    BYTE	byUnlockType;	//0-��Ч�� 1-��IP����2-��������IP
    BYTE	byIPVersion;	//1-IPV4��2-IPV6����byUnlockTypeΪ1ʱ���ò�����Ч
    BYTE	byRes1[2];
    NET_DVR_IPADDR struIPAddr;		//IP��ַ
    BYTE 	byRes[64];
} NET_DVR_UNLOCK_INFO,*LPNET_DVR_UNLOCK_INFO;

typedef  struct  tagNET_DVR_LOCKED_INFO
{
    DWORD	dwSize;
    BYTE	byIPType;	//IP���� 0-��Ч��1-IPV4��2-IPV6
    BYTE	byRes1[3];
    NET_DVR_IPADDR struIPAddress;
    BYTE	byRes[20];
} NET_DVR_LOCKED_INFO,*LPNET_DVR_LOCKED_INFO;


typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];
                            /*�������ֵ
                            0-�㷨�ⲻ֧����ʶ��ң�1-�ݿ˹��͹�(CZ - Czech Republic)��2-����(FRA - France)��
                            3-�¹�(DE - Germany),4-������(E - Spain), 5-�����(IT - Italy)��6-����(NL - Netherlands)��7-����(PL - Poland)��8-˹�工��(SVK - Slovakia), 9-�׶���˹(BY - Belorussia), 10-Ħ�����(MDA - Moldova)��11-����˹(RU - Russia)��12-�ڿ���(UA - Ukraine), 0xfe-�޷�ʶ��
    */
    BYTE  byCountry;                   // �������ֵ

    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;   //ͼƬ��С
    NET_VCA_RECT       struVcaRect;  //��ͼ�ڴ�ͼ�е����λ�ã���һ�����
    DWORD              dwFaceScore;  //���ƶȣ�ȡֵ��Χ0-100
    BYTE                byRes[228];
    BYTE               *pImage;  //����ͼƬҪ��Ϊjpg��ʽ
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD dwSearchType;   //��������
    //&0x1 - ��Խ������
    //&0x2 - ��������
    //&0x4 - ��Ʒ����
    //&0x8 - ��Ʒ��ȡ
    //&0x10 - ��������
    //&0x20 - �뿪����
    //&0x40 - �Ƿ�ͣ��
    //&0x80 - �ǻ�
    //&0x100 -��Ա�ۼ�
    //&0x200 - �����ƶ�
    BYTE byRes[252];  //����
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef union tagNET_DVR_SMARTSEARCH_PIC_UNION
{
    BYTE                byLen[256];  //�����峤��
    NET_DVR_VEHICLE_PARA     struVehiclePara; //���������Ϣ
    NET_VCA_HUMAN_FEATURE    struHumaFeature; //��������
    NET_DVR_FACE_PIC_DATA_INFO   struHumaPic;     //���������ͼ��Ϣ��ѯ������Զ��ͼƬ����ͼ��ͼ���ܣ�
    NET_DVR_BEHAVIOUR_COND   struBehaviourCond;  //��Ϊ������������
}NET_DVR_SMARTSEARCH_PIC_UNION,*LPNET_DVR_SMARTSEARCH_PIC_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA  //����ͼƬ�����ṹ�� size 344
{
    DWORD                dwChanNo;               //ͨ����
    DWORD                byStreamID[STREAM_ID_LEN] ;   //��ID��Ϣ����dwChanNo��ȣ����ȼ��ϸߣ�����byStreamID��Ϊ��ʱ����ʹ����ID��Ϊ�յ������ʹ��dwChanNo�ֶ�
    NET_DVR_TIME_EX         struStartTime;	           //¼��ʼ��ʱ��
    NET_DVR_TIME_EX         struEndTime;            //¼��ֹͣ��ʱ��
    WORD                wSearchType;            //���ܲ�������  0-�������� ��1-�������ԣ� 2-��ͼ��ͼ ��3-��Ϊ����
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;  //���ܲ�������
    BYTE               byRes[64];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

//��������ʶ����
typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;   //���ƶ� 0-100
    NET_VCA_RECT   struVcaRect;    //�������򣬹�һ�����
    BYTE           byRes2[236];   //����
}NET_DVR_FACE_SUB_PIC_INFO ,*LPNET_DVR_FACE_SUB_PIC_INFO;


typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT struVcaRect;
    BYTE         byRes2[240];   //����
}NET_DVR_BEHAVIOR_INFO ,*LPNET_DVR_BEHAVIOR_INFO;

typedef union tagNET_DVR_PIC_FEATURE_UNION
{
    BYTE                         byLen[256];         //�����峤��
    NET_DVR_PLATE_INFO              struPlateInfo;      //����������Ϣ
    NET_DVR_FACE_SUB_PIC_INFO       struFaceSubInfo;    //������ͼ��Ϣ
    NET_DVR_BEHAVIOR_INFO           struBehavior;       //��Ϊ������Ӧ����ͼ��Ϣ
}NET_DVR_PIC_FEATURE_UNION,*LPNET_DVR_PIC_FEATURE_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];//�ļ���
    NET_DVR_TIME_EX     struTime;                      //ͼƬ��ץͼʱ��
    DWORD   dwFileSize;                 //�ļ��Ĵ�С
    WORD    wPicType;                  //ͼƬ����  0-�������� ��1-�������ԣ� 2-��ͼ��ͼ ��3-��Խ�����ߣ�4-�������֣� 5-��Ʒ������ 6-��Ʒ��ȡ�� 7-�������� 8-�뿪���� 9-�Ƿ�ͣ����10-�ǻ���11-��Ա�ۼ���12-�����ƶ�
    BYTE    byRes1[2];                  //����
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;  //ͼƬ����
    BYTE    byRes[32];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET;

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;   //�Ƿ������� 0-δ��1-��
    BYTE  byRes[31];     //����
}NET_DVR_T1TEST_SEND_DATA_BUZZER,*LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef union NET_DVR_T1TEST_DATA_UNION
{
    BYTE  byUnionLen[32];
    NET_DVR_T1TEST_SEND_DATA_BUZZER struBuzzer;  //������
    NET_DVR_TIME_V30  struCurTime;   //��ǰPC��ʱ��
}NET_DVR_T1TEST_DATA_UNION,*LPNET_DVR_T1TEST_DATA_UNION;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;     //�ṹ���С
    BYTE  byDataType;  //������� 0-��������1-pc����ʱ��
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;  //���͵��������
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA,*LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG  //ͼ��ģ��������
{
    DWORD       dwSize;    //�ṹ���С
    BYTE         byEnable;     //�Ƿ�����
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM  //�����Ϣ����
{
    DWORD           dwSize;   //�ṹ���С
    BYTE            byMouseEvent;  //����¼����ͣ� 0-���������1-������˫����2-����Ҽ�3-�����Ϲ���4-�����¹�
    BYTE            byRes1[3];    //����
    NET_VCA_POINT   struPoint;    //����λ����꣬��һ������
    BYTE            byRes[64];    //����
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC���� 0-��������1-����
    BYTE  byMode;              //ģʽ, 0-����, 1-��ͨ,2-����
    BYTE  byFilterQValue;      //����Ӧ�˲���Qֵ����λOct, 0-1/40,1-1/10, Ĭ��ֵΪ1/40 Oct
    BYTE  byStaticFilterNum;   //��̬�˲���������ȡֵ��Χ0-12
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG,*LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;  //�ṹ���С
    DWORD  dwHighPassFilter;         //��ͨ�˲��� ȡֵ��Χ 0-127, ���������?����������Ϊ׼
    DWORD  dwNoiseMargin;            //�������ޣ�ȡֵ��Χ 0-127, ���������?����������Ϊ׼
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //�Զ��޲����Ʋ�����Ƶ����ԴΪmacInʱ��Ч
    BYTE   byRes[64];
}NET_DVR_MIX_AUDIOIN_CFG,*LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;  //�ṹ���С
    BYTE    byModulatorEnbale;  //�Ƿ�������λ������
    BYTE    byPostFilter;       //Post Filter���أ�0-�رգ�1-������Ĭ�Ͽ���
    BYTE    byLimitPressure;    //���ѹ�޿��� 0-�رգ�1-������Ĭ�Ͽ���
    BYTE    byRes1;             //����
    WORD    wModulatorValue;    //��λ������ ȡֵ��Χ 0-127, ���������?����������Ϊ׼��Ĭ��10
    WORD    wTriggerTime;       //ѹ�޴���ʱ�䣬ȡֵ��Χ 0-127, ���������?����������Ϊ׼
    WORD    wFreeTime;          //ѹ���ͷ�ʱ�䣬ȡֵ��Χ 0-127, ���������?����������Ϊ׼
    BYTE    byCompressThreshold; //ѹ������ 0-1X,1-2X,2-4X,3-8X  X��ʾ��������2X��ʾ2��
    BYTE    byCompressMode;     //ѹ����ʽ��0-Ӳѹ����1-��ѹ����Ĭ��ΪӲѹ��
    BYTE    byCompressRate;    //ѹ����
    BYTE    byRecoveryGain;    //�ظ����� 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //������� 0 ~100����ֵ��
    BYTE    byRes[61];
}NET_DVR_MIX_AUDIOOUT_CFG,*LPNET_DVR_MIX_AUDIOOUT_CFG;

#define MAX_AUDIOOUT_PRO_TYPE				8	//��Ƶ������?ʽ
typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD	dwSize;  //�ṹ���С
    WORD	wVolume[MAX_AUDIOOUT_PRO_TYPE];      //������С ȡֵ��Χ 0-127, ���������?����������Ϊ׼
	BYTE	byPhantomPowerSupply;	//�Ƿ�ʹ�û����Դ����(��Ƶ����ͨ��ΪMICʱ��Ч)��0-�����壬1-�����磬2-����
	BYTE	byEnableAEC;	//�Ƿ�����ȫ�ֵĻ������,0-�����ã�1-����
	BYTE	byRes1[2];
	BYTE	byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];	//�Ƿ�����FBC(Х������),0-�����ã�1-����
    BYTE	byRes[20];     //����
}NET_DVR_VOLUME_CFG,*LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG  //��Ƶ����ڷֱ�������
{
    DWORD       dwSize;    //�ṹ���С
    BYTE         byResolution;     //�ֱ��� 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];  /* ����IP��ַ��������,��Ҫ�豸����,������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ  */
    WORD   wPort;
	BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO,*LPNET_DVR_ADDR_DOMAIN_INFO;

#define MAX_CENTERNUM_V40     6    //�������ĵ�ַ����

//����������������
typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD	dwSize;
    BYTE	byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];  /* ����������IP��ַ��������,��Ҫ�豸����,������ʽΪ����ĸ�������С�.������Ϊ������,����ΪIP��ַ */
    WORD	wAuxiliaryAlarmPort;     /* ����������˿ں� */
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40]; //�������ĵ�ַ��Ϣ
	BYTE	byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

//�״���Ա����ϴ� ץ�Ļ�4.0����
typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD             dwSize;
    DWORD             dwRadarTriggerTimeSecond;//�״ﴥ��ʱ�䣬��
    DWORD             dwRadarTriggerTimeMSecond;//�״ﴥ��ʱ�䣬����
    DWORD             dwVedioTriggerTimeSecond;//��Ƶ����ʱ�䣬��
    DWORD             dwVedioTriggerTimeMSecond;//��Ƶ����ʱ�䣬����
    DWORD             dwVedioRadarDiffTimeMSecond;//�״���Ƶ����ʱ������
    DWORD             dwRadarSpeed;//�״��ٶ�
    BYTE              byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

#define MAX_FINGER_PRINT_LEN            768  //���ָ�Ƴ���
typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    DWORD dwFingerPrintLen; 	//ָ����ݳ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //��Ҫ�·�ָ�ƵĶ��������������ʾ��0-���·��ö�������1-�·����ö�����
    BYTE  byFingerPrintID;     //ָ�Ʊ�ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //ָ���������
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG,*LPNET_DVR_FINGER_PRINT_CFG;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //ָ�ƶ�����״̬���������ʾ
    BYTE  byFingerPrintID;     //ָ�Ʊ�ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;        //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byTotalStatus;  //�·��ܵ�״̬��0-��ǰָ��δ�������ж�������1-���������ж�����(���������ָ�����Ž����������еĶ������·��ˣ����ܳɹ����)
    BYTE  byRes[61];
}NET_DVR_FINGER_PRINT_STATUS,*LPNET_DVR_FINGER_PRINT_STATUS;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ�������Ϣ���������ʾ
    DWORD dwFingerPrintNum; //���û��ȡ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ���п���Ϣ
    BYTE  byFingerPrintID;     //ָ�Ʊ�ţ���Чֵ��ΧΪ-10   0xff��ʾ�ÿ�����ָ��
    BYTE  byCallbackMode;     //�豸�ص���ʽ��0-�豸���ж����������˷�Χ��1-��ʱ��������˲���Ҳ����
    BYTE  byRes1[26];          //����
}NET_DVR_FINGER_PRINT_INFO_COND,*LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ�������Ϣ���������ʾ
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];	    //��Ҫ��ȡ��ָ����Ϣ���������±ֵ꣬��ʾ0-��ɾ��1-ɾ���ָ��
    BYTE  byRes1[34];          //����
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;  //��ֵ��ʾ��ָ�ƶ��������
    BYTE  byClearAllCard;  //�Ƿ�ɾ�����п���ָ����Ϣ��0-������ɾ��ָ����Ϣ��1-ɾ�����п���ָ����Ϣ
    BYTE  byRes1[3];       //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byRes[100];          //����
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE
{
    BYTE   uLen[140];   //�����峤��
    NET_DVR_FINGER_PRINT_BYCARD       struByCard;     //�����ŵķ�ʽɾ��
    NET_DVR_FINGER_PRINT_BYREADER     struByReader;   //���������ķ�ʽɾ��
}NET_DVR_DEL_FINGER_PRINT_MODE,*LPNET_DVR_DEL_FINGER_PRINT_MODE;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //ɾ��ʽ��0-�����ŷ�ʽɾ��1-��������ɾ��
    BYTE  byRes1[3];       //����
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //���?ʽ
    BYTE  byRes[64];          //����
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef enum _ACS_DEV_SUBEVENT_ENUM_
{
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,      //������𱨾�
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,    //�����¼���90%����
    EVENT_ACS_NET_BROKEN,                   //����Ͽ�
    EVENT_ACS_NET_RESUME ,                  //����ָ�
    EVENT_ACS_LOW_BATTERY,                  //���ص�ѹ��
    EVENT_ACS_BATTERY_RESUME,               //���ص�ѹ�ָ���
    EVENT_ACS_AC_OFF,                       //������ϵ�
    EVENT_ACS_AC_RESUME,                    //������ָ�
    EVENT_ACS_SD_CARD_FULL,                 //SD���洢��
    EVENT_ACS_LINKAGE_CAPTURE_PIC           //����ץ���¼�����
}ACS_DEV_SUBEVENT_ENUM;

typedef enum _ACS_ALARM_SUBEVENT_ENUM_
{
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,    //�����·����
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,       //�����·����
    EVENT_ACS_ALARMIN_EXCEPTION,            //�����쳣����
    EVENT_ACS_ALARMIN_RESUME,               //�����ָ�
    EVENT_ACS_CASE_SENSOR_ALARM,            //�¼����뱨��
    EVENT_ACS_CASE_SENSOR_RESUME            //�¼�����ָ�
}ACS_ALARM_SUBEVENT_ENUM;

typedef enum _ACS_DOOR_SUBEVENT_ENUM_
{
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN  = 0,	    //�׿����ſ�ʼ
    EVENT_ACS_LEADER_CARD_OPEN_END,             //�׿����Ž���
    EVENT_ACS_ALWAYS_OPEN_BEGIN ,               //����״̬��ʼ
    EVENT_ACS_ALWAYS_OPEN_END,                  //����״̬����
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,               //����״̬��ʼ
    EVENT_ACS_ALWAYS_CLOSE_END,                 //����״̬����
    EVENT_ACS_LOCK_OPEN,                        //�����
    EVENT_ACS_LOCK_CLOSE,                       //����ر�
    EVENT_ACS_DOOR_BUTTON_PRESS,                //���Ű�ť����
    EVENT_ACS_DOOR_BUTTON_RELEASE,              //���Ű�ť�ſ�
    EVENT_ACS_DOOR_OPEN_NORMAL,                 //���ţ��Ŵţ�
    EVENT_ACS_DOOR_CLOSE_NORMAL ,               //����ţ��Ŵţ�
    EVENT_ACS_DOOR_OPEN_ABNORMAL,               //���쳣�򿪣��Ŵţ�
    EVENT_ACS_DOOR_OPEN_TIMEOUT,                //�Ŵ򿪳�ʱ���Ŵţ�
    EVENT_ACS_REMOTE_OPEN_DOOR,                 //Զ�̿���
    EVENT_ACS_REMOTE_CLOSE_DOOR,                //Զ�̹���
    EVENT_ACS_REMOTE_ALWAYS_OPEN,               //Զ�̳���
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,              //Զ�̳���
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,                   //�������ڶ�����֤Ⱥ��
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,              //�����ڶ�����֤ʱ�����
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,            //������֤ģʽ����������֤ʧ��
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,           //������֤ģʽԶ����֤ʧ��
    EVENT_ACS_MULTI_VERIFY_SUCCESS,                     //������֤�ɹ�
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,            //���ض�����֤��ҪԶ�̿���
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,  //������֤����������֤�ɹ��¼�
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,          //������֤�ظ���֤ʧ��
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,                     //������֤��ʱʧ��
    EVENT_ACS_REMOTE_CAPTURE_PIC,                       //Զ��ץ��
    EVENT_ACS_DOORBELL_RINGING                          //������
}ACS_DOOR_SUBEVENT_ENUM;

typedef enum _ACS_CARD_READER_SUBEVENT_ENUM_
{
    EVENT_ACS_STRESS_ALARM = 0,	                        //в�ȱ���
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,              //���������𱨾�
    EVENT_ACS_LEGAL_CARD_PASS,                          //�Ϸ�����֤ͨ��
    EVENT_ACS_CARD_AND_PSW_PASS,                        //ˢ����������֤ͨ��
    EVENT_ACS_CARD_AND_PSW_FAIL,                        //ˢ����������֤ʧ��
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,                     //ˢ����������֤��ʱ
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,               //��������֤ʧ�ܳ���
    EVENT_ACS_CARD_NO_RIGHT,                            //��δ����Ȩ��
    EVENT_ACS_CARD_INVALID_PERIOD,                      //����ǰʱ����Ч
    EVENT_ACS_CARD_OUT_OF_DATE,                         //���Ź���
    EVENT_ACS_INVALID_CARD,                             //�޴˿���
    EVENT_ACS_ANTI_SNEAK_FAIL,                          //��Ǳ����֤ʧ��
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,                 //������δ�ر�
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,                 //ָ�Ʊȶ�ͨ��
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,                 //ָ�Ʊȶ�ʧ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,             //ˢ����ָ����֤ͨ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,             //ˢ����ָ����֤ʧ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,          //ˢ����ָ����֤��ʱ
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,      //ˢ����ָ�Ƽ�������֤ͨ��
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,      //ˢ����ָ�Ƽ�������֤ʧ��
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,   //ˢ����ָ�Ƽ�������֤��ʱ
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,           //ָ�Ƽ�������֤ͨ��
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,           //ָ�Ƽ�������֤ʧ��
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,        //ָ�Ƽ�������֤��ʱ
    EVENT_ACS_FINGERPRINT_INEXISTENCE                   //ָ�Ʋ�����
}ACS_CARD_READER_SUBEVENT_ENUM;

typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //�¼������ͣ�0-�豸�¼���1-���������¼���2-���¼���3-�������¼�
    WORD          wSubEventType;                      //�¼�������
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;

typedef  union tagNET_DVR_EVETN_CARD_LINKAGE_UNION
{
    BYTE                   		byCardNo[ACS_CARD_NO_LEN];          //����
    NET_DVR_EVENT_LINKAGE_INFO  struEventLinkage;                   //�¼�����ʱ����
}NET_DVR_EVETN_CARD_LINKAGE_UNION,*LPNET_DVR_EVETN_CARD_LINKAGE_UNION;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD			dwSize;    //�ṹ���С
    BYTE          	byProMode;                          //������ʽ��0-�¼���1-����
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //�¼�ԴID����������Ϊ�豸�¼�ʱ��Ч�� �������������¼�ʱΪ�ű��;��������Ϊ�������¼�ʱ��Ϊ������ID;��Ϊ���������¼�ʱΪ��������ID���¼���������ID
    NET_DVR_EVETN_CARD_LINKAGE_UNION 	uLinkageInfo;  //������ʽ����
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //�����ı�������ţ��������ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byRes2[32];                         //����
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //�������ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //�������ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //�������ʾ,�Ƿ�����������0-��������1-����
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //�������ʾ,�Ƿ��������أ�0-��������1-����
    BYTE           byMainDevBuzzer;                    //���������   0-��������1-�������
    BYTE           byCapturePic;                           //�Ƿ�����ץ�ģ�0-������ץ�ģ�1-����ץ��
    BYTE           byRes3[30];                         //����
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //�������������������������ʾ��0-��������1-����
    BYTE           byRes[128];            			   //����
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;     //����IP��ַ
    BYTE   byIsStartAddr; //�Ƿ�Ϊ��ʼ��ַ��0-��1-��
    BYTE   byHostNo;      //�����ţ�1-8����Ҫ���ڶ�����˳������
    BYTE   byRes[34];     //����
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;   //��Ǳ��������
    BYTE  byRes[5];           //����
    WORD wFollowUpCardReader; //�÷�Ǳ�������µĶ��������
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //���������ַ��Ϣ
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //��ʼ��������� ��������ȫΪ0ʱ����ʾ����ע���ĸ���������ʼ
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE 		byEnable; 			//�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE  		byAntiSnealHostNo;   //��Ǳ��������
    WORD 		wReaderID;      	    //������ID
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //����������������
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD       	dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];  //��������Ϣ
    BYTE			byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD       	dwSize;    		//�ṹ���С
    BYTE            byRS485Backup;  //�Ƿ���������RS485ͨ�ű��ݹ��ܣ�0-�����ã�1-����
    BYTE            byShowCapPic;    //�Ƿ���ʾץ��ͼƬ�� 0-����ʾ��1-��ʾ
    BYTE            byShowCardNo;    //�Ƿ���ʾ���ţ�0-����ʾ��1-��ʾ
    BYTE            byShowUserInfo;  //�Ƿ���ʾ�û���Ϣ��0-����ʾ��1-��ʾ
	BYTE            byOverlayUserInfo;//�Ƿ�����û���Ϣ��0-�����ӣ�1-����
    BYTE            byVoicePrompt;  //�Ƿ�����������ʾ��0-�����ã�1-����
    BYTE 			byUploadCapPic;     //����ץ���Ƿ��ϴ�ͼƬ��0-���ϴ���1-�ϴ�
    BYTE 			bySaveCapPic;    //�Ƿ񱣴�ץ��ͼƬ��0-�����棬1-����
    BYTE            byInputCardNo;  //�Ƿ��Ƿ����?�����뿨�ţ�0-�����?1-����
    BYTE byRes[503];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //������
    DWORD dwErrorCode; //��ȡ�����뿪��ʹ�����÷��صĴ����룬�ɹ�Ϊ0��ʧ�ܷ��ش�����
    BYTE byCardValid; //���Ƿ���Ч��0-��Ч��1-��Ч������ɾ������ʱ��Ϊ0����ɾ���ȡʱ���ֶ�ʼ��Ϊ1��
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    DWORD dwErrorCode; //���Ϳ����뿪��ʹ�����÷��صĴ����룬�ɹ�Ϊ0��ʧ�ܷ��ش�����
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

//����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    //�����ˮ�� �ͣ��ϴ����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�sDataIndex��Ӧ��
    char   sDataIndex[DATA_INDEX_LEN];
    //������� �� (�ϴ����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�dwTaskNo��Ӧ)
    WORD  wTaskNo;
    BYTE  byRes1[2];
    NET_VCA_RECT  struPlateRect;//����λ��
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    /*
    ����ͼƬ����ʶ�����
    bit0-����ʶ��0-������ʶ��1-����ʶ��
    bit1-��������ʶ��0-������ʶ��1-����ʶ��
    bit2-������ɫʶ��0-������ʶ��1-����ʶ��
    bit3-����Ʒ��ʶ��0-������ʶ��1-����ʶ��
    bit4-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit5-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit6-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit7-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit8-����ͼƬ����ʹ�ܣ�0-������ʶ��1-����ʶ��
    bit9-�ϴ�����ͼƬʹ��(ͨ��SDK)��0-������ʶ��1-����ʶ��
    bit10-�ϴ�����ͼƬʹ��(ͨ��URL)��0-������ʶ��1-����ʶ��
    bit11-�Ʊ공��0-������ʶ��1-����ʶ��
    bit12-���ֻ�0-������ʶ��1-����ʶ��
    */
    DWORD  dwRecogOperate;
    /*
    ����ͼƬ����ϴ�
    bit0-����ͼƬ��0-���ϴ���1-�ϴ���
    bit1-����ͼƬ��0-���ϴ���1-�ϴ���
    bit2-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit3-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit4-��ȫ����ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit5-��ȫ����ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    */
    DWORD  dwDataUploadType;
    BYTE   byRes[131];
    BYTE   byPicDataType;//ͼƬ������ͣ�0-ͼƬ��ݣ�1-URL
    //ͼƬ���
    //��byPicDataType == 0��ʱ�򣬸��ֶ��ڵ������Ч��ͼƬ����ڽṹ�����
    //��byPicDataType == 1��ʱ����ָ����ͼƬ��URL��Ϣ
    char  sPicDataPath[256];
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    char   sDataIndex[DATA_INDEX_LEN];//�����ˮ��    ȫ0��ʱ���ʾ��ȡȫ��
    WORD  wTaskNo;//�������         ֵΪ0��ʱ���ʾȫ������
                  /*
                  ����״̬
                  bit0-���״̬������0-����ѯ��1-��ѯ��
                  bit1-ִ���е�����0-����ѯ��1-��ѯ��
                  bit2-�ȴ��е�����0-����ѯ��1-��ѯ��
    */
    BYTE   byTask;
    BYTE   byRes[125];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

//����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    char   sDataIndex[DATA_INDEX_LEN];//�����ˮ��
    WORD  wTaskNo;//�������
    WORD  wTaskProgress;//����ִ�н�ȣ�ʵ�ʽ��*1000��
    BYTE   byTaskState;//����״̬��0-�ȴ��У�1-ִ���У�2-���
    BYTE   byRes1[3];
    /*
    ����ͼƬ����ʶ�����
    bit0-����ʶ��0-������ʶ��1-����ʶ��
    bit1-��������ʶ��0-������ʶ��1-����ʶ��
    bit2-������ɫʶ��0-������ʶ��1-����ʶ��
    bit3-����Ʒ��ʶ��0-������ʶ��1-����ʶ��
    bit4-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit5-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit6-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit7-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit8-����ͼƬ����ʹ�ܣ�0-������ʶ��1-����ʶ��
    bit9-�ϴ�����ͼƬʹ��(ͨ��SDK)��0-������ʶ��1-����ʶ��
    bit10-�ϴ�����ͼƬʹ��(ͨ��URL)��0-������ʶ��1-����ʶ��
    bit11-�Ʊ공��0-������ʶ��1-����ʶ��
    bit12-���ֻ�0-������ʶ��1-����ʶ��

    */
    DWORD  dwRecogOperate;
    BYTE   byRes[128];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;

typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //�ṹ
    //�����ˮ�� �ͣ��ϴ����INTER_VEHICLE_RECOG_COND�е��ֶ�sDataIndex��Ӧ��
    char   sDataIndex[DATA_INDEX_LEN];
    //������� �� (�ϴ����INTER_DVR_SETUPALARM_PARAM�е��ֶ�dwTaskNo��Ӧ ͬʱ �·�����ṹ INTER_VEHICLE_RECOG_COND�е��ֶ�dwTaskNo��Ӧ)
    WORD  wTaskNo;
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;//����λ��
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    BYTE  byVehicleType;    //�������ͣ��ο�VTR_RESULT
    BYTE  byColorDepth;	 //������ɫ��ǳ���ο� 0-��ɫ��1-ǳɫ
    BYTE  byColor;	     //������ɫ,  �ο�VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //������Ʒ��
    BYTE  byVehicleSubLogoRecog; //������Ʒ��
    BYTE  byPilotSafebelt;//0-��ʾδ֪,1-��ϵ��ȫ��,2-ϵ��ȫ��
    BYTE  byCopilotSafebelt;//0-��ʾδ֪,1-��ϵ��ȫ��,2-ϵ��ȫ��
    BYTE  byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE  byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE  byVehicleModel;// �ο��ĵ�  ������Ʒ�����
    WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx"
    BYTE  byRes1[251];
    // 0-���ֱ���ϴ�; 1-�ƴ洢������URLԭ�ȵ�ͼƬ��ݱ��URL��ݣ�ͼƬ���ȱ��URL����
    BYTE  byDataType;
    /*
    �ϴ�ͼƬ������Ϣ:
    bit0-����ͼ��0-���ϴ���1-�ϴ���
    bit1-����ͼ��0-���ϴ���1-�ϴ���
    bit2-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit3-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit4-��ȫ��ʶ��(����ʻ)��0-���ϴ���1-�ϴ���
    bit5-��ȫ��ʶ��(����ʻ)��0-���ϴ���1-�ϴ���
    */
    DWORD  dwPicType; //0:��ͼƬ��Ϣ;: ����ͼ;:����ͼ;
    BYTE	*pVehicleBuffer;	//����ͼƬ���ָ��
    DWORD  dwVehicleBufferLen ;// ����ͼƬ��ݳ���
    BYTE	*pPlateBuffer;	//����ͼƬ���ָ��
    DWORD  dwPlateBufferLen ;// ����ͼƬ��ݳ���
    BYTE	*pPilotFaceBuffer;	//������ͼ(����ʻ)ͼƬ���ָ��
    DWORD  dwPilotFaceBufferLen ;// ������ͼ(����ʻ)ͼƬ��ݳ���
    BYTE	*pCopilotFaceBuffer;	//������ͼ(����ʻ)ͼƬ���ָ��
    DWORD  dwCopilotFaceBufferLen ;// ������ͼ(����ʻ)ͼƬ��ݳ���
    BYTE	*pPilotSafebeltBuffer;	//��ȫ��ʶ��(����ʻ)ͼƬ���ָ��
    DWORD  dwPilotSafebeltBufferLen ;// ��ȫ��ʶ��(����ʻ)ͼƬ��ݳ���
    BYTE	*pCopilotSafebeltBuffer;// ��ȫ��ʶ��(����ʻ)ͼƬ���ָ��
    DWORD  dwCopilotSafebeltBufferLen ;// ��ȫ��ʶ��(����ʻ)ͼƬ��ݳ���
    NET_VCA_RECT  struVehicleRect ;//����������
    NET_VCA_RECT  struPilotRect ;//����ʻ�������
    NET_VCA_RECT  struCopilotRect ;//����ʻ�������
    BYTE   Res2[80] ;
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

#define MAX_ZONE_LINKAGE_CHAN_NUM	4	/* ����������ͨ����*/

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD					dwSize;
    BYTE	byAddressType;	//0 - ipv4/ipv6��ַ��1 - ����
    BYTE	byRes1;
    WORD	wServerPort;				//�������˿�
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME];
            BYTE			byRes2[80];
        }struDomain;					//����������
        struct
        {
            NET_DVR_IPADDR	struIp;
        }struAddrIP;					//IP��ַ
    }unionServer;//ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ��������
    WORD					wInterval;	//�������ʱ��,0-30s
    BYTE					byRes3[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE	byDDNSType;		//������������ͣ�0 - ��Ч��1 - IPServer(˽��DNS)��2 - hiDDNS
    BYTE	byRes1;
    WORD	wDDNSPort;						//����������˿ں�
    BYTE	byServerAddr[MAX_DOMAIN_NAME];	//�����������ַ
    BYTE	byDevName[MAX_DOMAIN_NAME];			//�豸���
    BYTE	byDevSerialNum[SERIALNO_LEN];	//�豸���к�
    BYTE	byAddressType;	//0 - ipv4/ipv6��ַ��1 - ����
    BYTE	byRes2;
    WORD	wDevPort;		//�豸�˿ں�
    union
    {
        struct
        {
            BYTE			szDomain[MAX_DOMAIN_NAME];
            BYTE			byRes2[80];
        }struDomain;									//����
        struct
        {
            NET_DVR_IPADDR	struIp;
        }struAddrIP;									//IP��ַ
    }unionDevAddr;//ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ��������
    BYTE	sUserName[NAME_LEN/*32*/];	//�û���
    BYTE	sPassword[PASSWD_LEN/*16*/];//����
    DWORD	dwChannel;					//����ͨ����
    BYTE	byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD	dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];	// ÿ��������Թ����ĸ���Ƶͨ��
    BYTE	byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;	//��Ļ�����
    BYTE byOnOffLine;	//��Ļ�Ƿ����ߣ�0-���ߣ�1-���ߣ�����Ļ����ʱ�����ṹ���������Ч
    BYTE byTempState;	//�忨�¶�״̬��0-��1-�쳣
    BYTE byFanState;		//����״̬��0-�أ�1-��
    BYTE byFanException;	//�����쳣״̬��0-��֧�� 1-��2-�쳣
    BYTE byTemperature;	//��Ļ�忨�¶ȣ���λ�����϶�
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

//�������ϴ���Ϣ
typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD   dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //���������
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //������ͨ��
    BYTE	byReboot; //֮ǰ�Ƿ�������һ���������ĺ�ĵ�һ����ݴ��������־��0-��ʾû��������1-�й�����
    BYTE	byPowerSupply;//�Ƿ���� 0-���ڹ��磬1-���ڹ���
    BYTE	byStatusType;//�豸״̬:0:��1���쳣��2������
    BYTE	bySensorType;//�ο�������ö������SENSOR_TYPE
    float  	fVoltageValue;//��ѹֵ�� ��ȷ��0.001
    float	fCurrentValue;//����ֵ����ȷ��0.001
    float   fActualValue;//ģ���ź�ת�������ֵ����ȷ��0.001
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //������Ϣ;���豸״̬��byStatusType��Ϊ��0ʱ��Ч��
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

//ץ��ͼƬ�ϴ�
typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize;
    NET_DVR_TIME_V30  struTime;
    DWORD	dwChannel;//ͨ����
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//ͼƬ����
    BYTE	*pBuffer;	//ͼƬ���ָ��
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;

#define MAX_MASK_AREA_NUM                   8   //������������

typedef struct tagNET_DVR_AREA_MASK_CFG  //���������
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byEnable;//�Ƿ����������   0-��1-��
    BYTE   byMaskThick;  //����˺�� 0-���룬1-���룬2-���룬���������СΪ8*8������16*16������32*32��Ĭ��Ϊ����
    BYTE   byRes1[2];
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM];//���������Χ
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG  //��Ƶ����
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byEnable;  //�Ƿ����ñ��� 0-�����ã�1-����
    char    byBassValue;   //�ߵ���ֵ����ΧΪ-12-12 ֵԽ������Խϸ����֮ԽС��0-��ʾ������
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //wifiģʽ��DHCP��Χ����
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;   //��ʼIP��ַ
    NET_DVR_IPADDR   struEndAddr;     //����IP��ַ
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;


typedef struct tagNET_DVR_WIFI_CLIENT_INFO  //��Ƶ����
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;  //IP��ַ
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //�����ٶ� ��λKB
    BYTE        byRSSIValue;         //���յ����ź�ǿ�ȣ�ȡֵΪ��ֵ������ʱ����ֵ����ΧΪ0~-110dbm,ֵԽ�󣬴���ź�Խǿ
    BYTE        byRes1;         //����
    WORD        wBandwidth;     //������  ��λKB
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG  //����������ͨ��
{
    DWORD       dwSize;              //�ṹ���С
    DWORD       dwChannel;           //�����ı���ͨ����
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;

typedef struct
{
    BYTE byPort;   //�˿�
    BYTE byMasterSlaveProperty;   //�˿���������  1-��  2-��
    BYTE byPortEthernetType;  //�˿����ͣ�1-���׶˿ڣ�2-ǧ�׶˿�
    BYTE byRes[9];
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;
typedef struct
{
    DWORD   dwSize;
    BYTE 	byEnable;     //�Ƿ����ã� 0-�����ã� !0-����
    BYTE 	byProtoType;  //Э�����ͣ� 1-��˻�����Э��(˽��)��2-�ۺ�ƽ̨����Э�飨˽�У���3-G8032Э�飨���У�
    BYTE   byBandWidth;   //���������ͣ�1-���ף�2-ǧ��
    BYTE 	byRes1;        //�����ֶ�
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //����˿�
    BYTE  	byRes2[60];    //�����ֶ�
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;
typedef struct  //
{
    DWORD   dwSize;   //�ṹ���С
    BYTE 	byStatus;     		 //����״̬��1-�� 2-�Ͽ�
    BYTE 	byMasterSlaveProperty ; //���˰��������� 1-��  2-��
    BYTE 	byRes[62];    		//�����ֶ�
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

//����ⱨ��
typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize; //�ṹ��С
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byRes1[2] ;
    DWORD   dwPicDataLen;//����ץ��ͼƬ����
    BYTE	*pBuffer;	//���ָ��
    NET_VCA_RECT struRect;//����
    NET_VCA_POINT struPoint ;//����������¶ȵ����
    WORD    wFireMaxTemperature ;//�������¶�[300��~4000��]
    WORD    wTargetDistance ;//Ŀ�����[100m ~ 10000m]
    BYTE    byRes[96];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

//���������
typedef	struct tagNET_DVR_FIREDETECTION_CFG
{
    DWORD	dwSize;//�ṹ���С
    BYTE	byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE    bySensitivity; //���������: 1~100Ĭ��5s
    BYTE    byFireComfirmTime;//���ֻ��ȴ�ʱ��: 0-120�� Ĭ��5s
    BYTE    byFireRegionOverlay;//�������ӻ���: 0- ��1- ��
    BYTE    byFocusZoom; //���ֻ���ɼ�⾵ͷ�۽��䱶��1~100, Ĭ��50
    BYTE	byRes[127];
}NET_DVR_FIREDETECTION_CFG,*LPNET_DVR_FIREDETECTION_CFG;

#define MAX_PLAYLIST_NUM        50          //��󲥷��б���Ŀ
#define MAX_PLAYPLAN_NUM        50          //��󲥷żƻ���Ŀ

#define MAX_LEN_256                     256
#define MAX_GROUP_RECORD_NUM            10      //����¼����
typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize;
    DWORD  dwAreaID;   //����ID
    DWORD  dwMonitorID;  //��ǰ��ʼ��ȡ�ļ�ص��ţ���1��ʼ
    BYTE   byIsNeedGroup;  //�Ƿ��ѯ����������Ϣ
    BYTE   byRes [127];
}NET_DVR_AREA_MONITOR_COND,*LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;
    BYTE  byDelType;     //ɾ�����ͣ�0-ɾ��ָ����������м�ص㣬1-ɾ��ָ�������ָ����ص�
    DWORD  dwAreaID;   //����ID
    DWORD  dwMonitorID;   //��ص�ID����byDelTypeΪ0ʱ��Ч����byDelTypeΪ1ʱ��Ч������1��ʼ
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND,*LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_COND
{
    DWORD       dwSize;         //�ṹ���С
    BYTE		byType;         //�ڰ����־��- ȫ����- ����- ����
    BYTE		byRes1[3];      //����
    DWORD       dwFaceID;       //������ID
    DWORD       dwMaxSnapNum;   //���ץ������0-��ʾ������
    BYTE        byRes[256];
}NET_DVR_BLACKLIST_ALARM_COND, *LPNET_DVR_BLACKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;         //�ṹ���С
    DWORD	    dwStorageID;	//�ӵ�ǰ��ſ�ʼ��ȡʣ����Դ����1��ʼ
    BYTE		byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_RECORD
{
    DWORD          dwSize;   //�ṹ���С
    DWORD			dwSnapFacePicID;	//ץ������ID
    DWORD			dwRegisterID;		//��ע��ID�ţ�ֻ����
    DWORD			dwGroupNo;			//�����
    BYTE		    byRes[128];
}NET_DVR_BLACKLIST_ALARM_RECORD, *LPNET_DVR_BLACKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_INFO  //�������Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD          dwGroupID; //�����ţ���ȡʱ��Ч�����ʱ��Ч������1��ʼ
    DWORD			dwGroupNo;			//������
    BYTE			byGroupType;		//�������ͣ�0-������飬1-�������
    BYTE			byRes1;
    WORD			wThreshold;			//������ֵ��ȡֵ��ΧΪ0-1000
    DWORD			dwListNum;			//��������
    BYTE			szGroupName[NAME_LEN];  //�������
    BYTE			szRemark[MAX_LEN_256];
    BYTE			byStorageAddr[MAX_DOMAIN_NAME];  //�洢IP��ַ��Ϣ
    WORD			wStoragePort;			//�洢IP��Ӧ�Ķ˿ں�
    BYTE			byRes[126];
}NET_DVR_BLACKLIST_GROUP_INFO, *LPNET_DVR_BLACKLIST_GROUP_INFO;


typedef struct tagNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD
{
    DWORD          dwSize;   //�ṹ���С
    DWORD			dwGroupRecordID;			//�����¼ID���޸ĺͲ�ѯʱ��Ч������ʱ��Ч����1��ʼ
    DWORD			dwGroupNo;			//������
    DWORD			dwFaceDBID;			//������ID
    DWORD			dwFaceRecordID;		//������¼ID
    BYTE			byAlarmLevel;		//�����ȼ���0-high,1-medium,2-low
    BYTE			byRes1[3];			//����
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;   //�洢IP��ַ��Ϣ
    BYTE			byRes[256];
}NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD,*LPNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;   //�ṹ���С
    DWORD			dwRecordID;				//�ӵ�ǰ��ſ�ʼ��ȡ����1��ʼ
    BYTE			byRes[64];
}NET_DVR_BLACKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLACKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_CFG  //������¼��Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD			dwRecordNum;			//��¼�ܸ���
    NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM]; //��¼����
    BYTE			byRes[256];
}NET_DVR_BLACKLIST_GROUP_RECORD_CFG,*LPNET_DVR_BLACKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_CFG  //������¼��Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD			dwGroupNum;			//�����ܸ���
    NET_DVR_BLACKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM]; //��¼����
    BYTE			byRes[256];
}NET_DVR_BLACKLIST_GROUP_CFG,*LPNET_DVR_BLACKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_COND
{
    DWORD        dwSize;   //�ṹ���С
    DWORD			dwGroupID;				//�ӵ�ǰ��ſ�ʼ��ȡ����1��ʼ
    BYTE			byRes[64];
}NET_DVR_BLACKLIST_GROUP_COND, *LPNET_DVR_BLACKLIST_GROUP_COND;



typedef  struct  tagNET_DVR_SENSOR_VALUE
{
    float   fMinValue; //��Сֵ����ȷ��0.001����Ϊ0xfffffffff��ʾ��ѯ����
    float   fMaxValue; //���ֵ����ȷ��0.001����Ϊ0xfffffffff��ʾ��ѯ����
    BYTE    byRes[8];
}NET_DVR_SENSOR_VALUE, *LPNET_DVR_SENSOR_VALUE;

typedef  struct  tagNET_DVR_HISTORICAL_QUERY_PARAM //��ʷ��ݲ�ѯ�����ӽṹ
{
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    NET_DVR_SENSOR_VALUE struVoltageValue; //��ѹ����; ��λ����
    NET_DVR_SENSOR_VALUE struCurrentValue; //��������; ��λ����
    NET_DVR_SENSOR_VALUE struTemperatureValue;//�¶Ȳ���λ���϶�
    NET_DVR_SENSOR_VALUE struHumidityValue;//ʪ�Ȳ���
    BYTE   bySwitchStatus;//ͨ��״̬�� 0~δͨ�磬1~ͨ�磬0xff��ѯ����
    BYTE   bySensorStatus; //������״̬�� 0-��1-�쳣��2-������0xff��ѯ����
    BYTE   byRes[66];
}NET_DVR_HISTORICAL_QUERY_PARAM, *LPNET_DVR_HISTORICAL_QUERY_PARAM;

typedef  struct  tagNET_DVR_SENSOR_COND //�����ṹ
{
    DWORD  dwSize;
    BYTE   byQueryType; //��ѯ��ʽ��0~ʵʱ��ݲ�ѯ��1~��ʷ��ݲ�ѯ
    BYTE   byDeviceType; //�豸����;0~δ֪,1~ģ����������, 2~�ϵ����,3~�ϵ����0xff��ʾ��ѯ����
    BYTE   byDeviceID; //�豸ID��Analog(ģ����������)��Χ��1-8��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2��0xff��ʾ��ѯ����
    BYTE   byRes1;
    // INTER_HISTORICAL_QUERY_PARAM�ӽṹ����byQueryTypeΪ1ʱ��Ч
    NET_DVR_HISTORICAL_QUERY_PARAM struHistoricalQueryParam; //��ʷ��ݲ�ѯ����
    BYTE   byRes[64];
}NET_DVR_SENSOR_COND,*LPNET_DVR_SENSOR_COND;

typedef  struct  tagNET_DVR_SENSOR_CFG//���ýṹ
{
    DWORD  dwSize;
    BYTE   byEnable; //��ǰ��ѯ�Ĵ������Ƿ�ʹ�ܣ�0-��ʹ�ܣ�1-ʹ�ܣ�
    BYTE   byDeviceType; //�豸����;0~δ֪,1~ģ����������, 2~�ϵ����,3~�ϵ����
    BYTE   byDeviceID; //�豸ID��Analog(ģ����������)��Χ��1-8��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2
    BYTE   byRes1;
    NET_DVR_TIME_V30 struTime;//ʱ��
    BYTE   byIsFirst; //�Ƿ����������һ�����(����Ƿ�������)��0-��, 1-�ǣ�
    BYTE   byIsSwitchOn; //�Ƿ�ͨ�磬0-��, 1-�ǣ�
    BYTE   bySensorStatus; //������״̬�� 0-��1-�쳣��2-������
    BYTE   bySensorType; //���������ͣ� 0-δ֪��1-�¶ȡ�2-ʪ�ȣ�
    float  fVoltage; //��ѹ����λ���أ���ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fCurrent; //��������λ��������ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fTemperatureValue;//�¶�ֵ����λ���϶ȣ���ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fHumidityValue;//ʪ��ֵ����ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    BYTE   bySensorName[SENSORNAME_LEN/*32*/]; //���������
    BYTE   byDescription[MAX_SENSORDESCR_LEN/*64*/]; //��������ݵ�������Ϣ��statusTypeΪ��ʱ��description����Ϊ��
    BYTE   byRes[256];
}NET_DVR_SENSOR_CFG,*LPNET_DVR_SENSOR_CFG;

typedef	struct tagNET_DVR_SENSOR_SWITCH_COND
{
    DWORD	 dwSize;//�ṹ���С
    BYTE     byDeviceType; //�豸����;0~δ֪, 1~�ϵ����Terminal,2~�ϵ����Socket
    BYTE     byDeviceID; //�豸ID��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2
    BYTE     bySwitch; //���أ�0-�ϵ�, 1-�ϵ磬2-����
    BYTE	 byRes[125];
}NET_DVR_SENSOR_SWITCH_COND,*LPNET_DVR_SENSOR_SWITCH_COND;

typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;     //�ṹ���С
    BYTE   byServerID[DEV_ID_LEN];  //SIP������ID��
    WORD   wPort;      //SIP�������˿ں�
    BYTE   byRes1[2];  //����
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;   		//��������ڣ���λ���룬Ĭ�ϣ�3600
    BYTE   byMaxHeartbeatTimeOut;	//�������ʱ����Ĭ�ϣ�3��
    BYTE   byAutoAddIpc;            //�Ƿ������Զ����ipc,0-�����ã�1-����
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];   //������չΪ64λ������ʱ��byAuthPasswdExΪ�ǿգ��˲�����Ч��byAuthPasswd��Ч����ȡʱ��byAuthPasswdEx��byAuthPasswd������
    BYTE   byRes[190];				//����
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;
typedef	struct	tagNET_DVR_ACTIVATECFG
{
    DWORD   dwSize;	//�ṹ���С
    BYTE    sPassword[PASSWD_LEN];	//��ʼ����
    BYTE    byRes[108];
}NET_DVR_ACTIVATECFG,*LPNET_DVR_ACTIVATECFG;

typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;	//�ṹ���С
    BYTE        byMode;	//0-��ͨ�����1-����ַ����
    BYTE        bySelfDefinePassword;//�Ƿ��Զ�������,0-��,1-��
    BYTE        sPassword[PASSWD_LEN];//�Զ�������
    BYTE        sUserName[NAME_LEN];//�û���
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union��С
        struct
        {
            DWORD       dwChannelNo;//ͨ����
            BYTE        byRes[508];
        }struChannelInfo;//ͨ����Ϣ
        struct
        {
            NET_DVR_IPADDR   struIp;//IP��ַ
            WORD    wPort;//�˿ں�
            BYTE    sProtocolDesc[DESC_LEN];//Э������
            BYTE    byMacAddr[MACADDR_LEN];//mac��ַ
            BYTE    byRes[344];
        }struAddrInfo;//IP��ַ������NET_DVR_SADPINFO
    }unActivateDeviceInfo;//ʹ��������ṹ��ͨ��byMode�ֶα�ʾ�ǰ�ͨ�����ǰ���ַ
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-����,1-IPCδ���2-�������룬3-����ǿ������4-����ǿ���У�5-����ǿ��ǿ;byDigitalChanPasswordStatus[0]��ʾ��һ������ͨ��
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_CAMERACHAN_SERIALCFG
{
    DWORD	dwSize;
    DWORD   dwBaudRate;  //������(bps)��0-50��1-75��2-110��3-150��4-300��5-600��6-1200��7-2400��8-4800��9-9600��10-19200��11-38400��12-57600��13-76800��14-115.2k
    BYTE    byDataBit; //����м�λ��0-5λ��1-6λ��2-7λ��3-8λ
    BYTE    byStopBit;  //ֹͣλ��0-1λ��1-2λ
    BYTE    byParity;  //�Ƿ�У�飺0-��У�飬1-��У�飬2-żУ��
    BYTE    byFlowcontrol;// �Ƿ����أ�0-�ޣ�1-������,2-Ӳ����
    WORD	wPTZProtocol;  //����Э�����ͣ�����ֵ
    BYTE	byRes1[6];
    DWORD   dwSerialPort; //���ں�,���λΪ0����ʾǰ��崮�ڣ����λΪ1����ʾ����崮��
    BYTE	bySerialAddress; //���ڵ�ַ0~255
    BYTE    byRes[15];
}NET_DVR_CAMERACHAN_SERIALCFG, *LPNET_DVR_CAMERACHAN_SERIALCFG;

#define MAX_MATRIX_SUBBOARD_NUM      16   //�ۺ�ƽ̨����Ӱ���
#define MAX_BOARD_SUBSYSTEM_NUM      12   //ÿ���Ӱ����ϵͳ��
typedef  struct  tagNET_DVR_SUBSYSTEM_STATUS
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-Fpga������ϵͳ��9-Fpga��ϵͳ��10-ת����ϵͳ��
	11-X86��������ϵͳ��12-������������ϵͳ��13-X86���ķ���壬 14- X86ҵ������ ��15-�����ƴ����ϵͳ��16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ0-NULL*/
    BYTE	bySubSystemType;
    BYTE	bySubSystemNo;   //��ϵͳ�ţ��������Ӱ��ϵı��
    BYTE	byOnlineStatus;  //��������״̬�� 1-���� 2-������
    BYTE	byRes[49];
}NET_DVR_SUBSYSTEM_STATUS, *LPNET_DVR_SUBSYSTEM_STATUS;
typedef  struct  tagNET_DVR_MATRIX_SUBBOARD
{
    BYTE  byBoardNo;                //�Ӱ��
    BYTE  byPcieConnectStatus;        //pcie����״̬�� 1-���� 2-�Ͽ�
    BYTE  byRes[2];
    DWORD dwHardwareVersion;       //�Ӱ�Ӳ���汾
    DWORD dwPcieBandwidth ;        //pcie Link ���
    DWORD dwTemperature ;          //�Ӱ��¶�  ��λ�����϶�
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //��ϵͳ״̬
    BYTE  byRes2[16];
}NET_DVR_MATRIX_SUBBOARD, *LPNET_DVR_MATRIX_SUBBOARD;
typedef struct  tagNET_DVR_MATRIX_STATUS
{
    DWORD dwSize;
    BYTE  byMainFrameType;   //��������  1-18U����(V1.0) 2-18U���� 3-14U���� 4-11U���� 5-8U���� 6-7U����  7-5U����
    BYTE  bySoltNum;   //��λ��
    BYTE  byBoardNum;   //�Ӱ���
    BYTE  byRes;
    NET_DVR_MATRIX_SUBBOARD struMatrixSubboard [MAX_MATRIX_SUBBOARD_NUM];
    BYTE  byRes2[48];
}NET_DVR_MATRIX_STATUS,*LPNET_DVR_MATRIX_STATUS;
typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;  //ͼ���ںϿ�(����ͼ����Ŀ)
    WORD wHeight; //ͼ���ںϸ�(����ͼ����Ŀ)
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;  //�Ƿ��ںϣ�0-δ�ںϻ�ȡ���ںϣ���0-�ں�
    BYTE byUseHistoryMap; //�Ƿ�ʹ����ʷ�ں�ӳ��?0-��ʹ�ã���0-ʹ��
    BYTE byRes[30];
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_MULTIFUNCTION_SERIALCFG
{
    DWORD dwSize ;
    BYTE  byVariable ;  //�����Ƿ�ɱ䣬1-���ɱ�  2-�ɱ� ��ֻ��ȡ��
    BYTE  bySerialWorkMode;   //����ģʽ��1-RS485, 2-RS232��ֻ�ڿɱ�����£��޸Ĺ���ģʽ��
    BYTE  byFunType;   //���ڹ��ܣ� 1-���̿��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PTZ����  5-������� 6-����̨
    BYTE byDataBit;// ���λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    BYTE byRes1 ;
    DWORD dwBaudRate;//������0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    WORD wProtocol;   //����Э��  ��ͬ���ڹ��ܶ�Ӧ����Э�鲻һ��
    BYTE byRes[34];
}NET_DVR_MULTIFUNCTION_SERIALCFG, *LPNET_DVR_MULTIFUNCTION_SERIALCFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //ͨ����
    BYTE    byPSpeed;  // X������ٶ�  ��ȡֵ1��64��
    BYTE    byTSpeed;  // Y������ٶ�   ��ȡֵ1��64��
    BYTE    byZSpeed;  // Z�ٶ�
    BYTE    byPDirect; // P���� 1-�� 2-��
    BYTE    byTDirect; // T���� 1-�ϣ� 2-��
    BYTE    byZDirect;  //Z����  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];  //�����ֽ�
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL;

//Sensor��Ϣ
typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE		bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//ˮƽ��� ��ȷ��С������λ *10000
    float       fVerWidth;//��ֱ��� ��ȷ��С������λ *10000
    float       fFold;//zoom=1û��ʱ�Ľ��� ��ȷ��С������λ *100
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//��[0.000000,60.000000]
    BYTE byDegree;//��:γ��[0,90] ����[0,180]
    BYTE byMinute;//��[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

//���λ����Ϣ
typedef struct
{
    float   fPanPos;//ˮƽ����ȷ��С����1λ
    float   fTiltPos;//��ֱ����ȷ��С����1λ
    float   fZoomPos;//�䱶����ȷ��С����1λ
    BYTE    byRes[16] ;
}NET_DVR_PTZPOS_PARAM, *LPNET_DVR_PTZPOS_PARAM;

//GIS��Ϣ�ϴ�
typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;//�ṹ���С
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO    struDevInfo;//ǰ���豸
    float   fAzimuth;//�������̵ķ�λ��Ϣ����λ��[0.00��,360.00��)
    BYTE    byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE    byLongitudeType ;// �������ͣ�0-���ȣ�1-����
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM	struLatitude;	 /*γ��*/
    NET_DVR_LLI_PARAM	struLongitude;   /*����*/
    float   fHorizontalValue;//ˮƽ�ӳ��ǣ���ȷ��С��������λ
    float   fVerticalValue;//��ֱ�ӳ��ǣ���ȷ��С��������λ
    float   fVisibleRadius;//��ǰ���Ӱ뾶����ȷ��С��������λ
    float   fMaxViewRadius;//�����Ӱ뾶����ȷ��С������0λ��Ԥ�����?
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor��Ϣ
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz���
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

//���ƻ�������Ϣ�ϴ�
typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD		dwSize;//�ṹ���С
    DWORD 	    dwRelativeTime; //���ʱ��
    DWORD	    dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO    struDevInfo;//ǰ���豸
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;

//���в��ز�������
typedef	struct tagNET_DVR_CENTRALIZEDCTRL_CFG
{
    DWORD		dwSize;//�ṹ���С
    BYTE        byEnable;//0-����1-��ʼ
    BYTE        byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE        byLongitudeType ;// �������ͣ�0-������1-����
    BYTE        byRes1;
    NET_DVR_LLI_PARAM	struLatitude;	 /*γ��*/
    NET_DVR_LLI_PARAM	struLongitude; /*����*/
    DWORD       dwTimeOut;//��ʱʱ�� [60s, 6*60*60s]
    BYTE		byControlType;//���в��ط�ʽ 0-ǿ�Ʋ��أ�1-��ǿ�Ʋ���
    BYTE		byRes[127];
}NET_DVR_CENTRALIZEDCTRL_CFG,*LPNET_DVR_CENTRALIZEDCTRL_CFG;

//����GIS��Ϣ���
typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;//�ṹ���С
    float  fAzimuth;//�������̵ķ�λ��Ϣ����λ��[0.00��,360.00��)
    float  fHorizontalValue;//ˮƽ�ӳ��ǣ���ȷ��С��������λ
    float  fVerticalValue;//��ֱ�ӳ��ǣ���ȷ��С��������λ
    float  fVisibleRadius;//��ǰ���Ӱ뾶����ȷ��С��������λ
    float  fMaxViewRadius;//�����Ӱ뾶����ȷ��С������0λ��Ԥ�����?
    BYTE   byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE   byLongitudeType ;// �������ͣ�0-������1-����
    BYTE   byRes1[2] ;
    NET_DVR_LLI_PARAM	 struLatitude;	 /*γ��*/
    NET_DVR_LLI_PARAM    struLongitude; /*����*/
    NET_DVR_PTZPOS_PARAM struPtzPos; //ptz���
    NET_DVR_SENSOR_PARAM struSensorParam;//Sensor��Ϣ
    BYTE  byRes[256];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;

//�����̹������ƻ�����
typedef	struct tagNET_DVR_VANDALPROOFALARM_CFG
{
    DWORD	dwSize;//�ṹ���С
    BYTE    bySensitivity;//������[1,100] (֧�����������ã�������ֵ��Խ���״�����ֵԽС��Խ�Ѵ���)
    BYTE    byUploadEnabled;//���÷��ƻ������ϴ�ʹ�� 0-�����ã�1-����
    BYTE    byVoiceWarningEnabled;//���÷��ƻ�����������ʾʹ�� 0-�����ã�1-����
    BYTE    byEnable;// ���ü����ƻ����� 0-�رգ�1-��ʼ
    BYTE    byRes[124];
}NET_DVR_VANDALPROOFALARM_CFG,*LPNET_DVR_VANDALPROOFALARM_CFG;

typedef	struct tagNET_DVR_AZIMUTHINFO
{
    DWORD		dwSize;//�ṹ���С
    float       fDegree;//��λ�Ƕ���(��ȷ��С������λ)
    BYTE        byAzimuth; //��λ����Ϣ 0-����,1-����,2-����,3-����,4-��,5-��,6-��,7-��
    BYTE		byRes[127];
}NET_DVR_AZIMUTHINFO,*LPNET_DVR_AZIMUTHINFO;

//�������̽���ָ������������ṹ
typedef	struct tagNET_DVR_COMPASS_COND
{
    DWORD		dwSize;//�ṹ���С
    DWORD	    dwChannel;//ͨ����
    BYTE		byRes[128];
}NET_DVR_COMPASS_COND,*LPNET_DVR_COMPASS_COND;

typedef	struct tagNET_DVR_POSITION_CFG
{
    DWORD	 dwSize;//�ṹ���С
    BYTE     bySoftWorkMode;//����ģʽ 0-�Զ���1-�ֶ�
    BYTE     byRes[127];
}NET_DVR_POSITION_CFG,*LPNET_DVR_POSITION_CFG;

typedef	struct tagNET_DVR_STREAMING_COND
{
    DWORD		dwSize;//�ṹ���С
    DWORD	    dwChannel;//ͨ����
    BYTE        byStreamType;//��������0-��������1-��������2-����3
    BYTE		byRes[127];
}NET_DVR_STREAMING_COND,*LPNET_DVR_STREAMING_COND;

//���Ƕ�λ��������
typedef	struct tagNET_DVR_SATELLITETIME_CFG
{
    DWORD		dwSize;//�ṹ���С
    BYTE        byEnable;//���Ƕ�λУʱʹ�� 0-��������1-����
    BYTE        byRes;
    WORD        wTimeInterval;//Уʱʱ����(s)
    BYTE		byRes1[124];
}NET_DVR_SATELLITETIME_CFG,*LPNET_DVR_SATELLITETIME_CFG;

#define MAX_SIGNAL_JOINT_NUM       64  //����ƴ�ӹ�ģ
typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
	DWORD	dwSize;
	BYTE  sCamName[NAME_LEN] ;  //ƴ�Ӻ��ź�Դ���
	BYTE  byEnable;               //ʹ�ܣ�0-��ʹ��  !0-ʹ��
	BYTE  byCamMode ;            //ƴ�Ӻ��ź�Դ���ͣ�NET_DVR_CAM_JOINT
	BYTE  byRows ;               //ƴ������
	BYTE  byColumns ;            //ƴ������
	DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //�ź�Դ��,ǰbyRows* byColumns����Ч
	DWORD dwJointNo;           //ƴ�ӱ�ţ���ȡ��Ч��
	DWORD dwSignalNoJoint;      //ƴ�Ӻ���ź�Դ�ţ���ȡ��Ч��
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
	DWORD    dwSize;
	DWORD    dwSignalNo;     //�ź�Դ��
	DWORD	 dwCutTop;      //�Ϸ��ü�����ֵ,0��?ԭ
	DWORD 	 dwCutBottom;   //�·��ü�����ֵ,0��?ԭ
	DWORD 	 dwCutLeft;     //��߲ü�����ֵ,0��?ԭ
	DWORD 	 dwCutRight;    //�ұ߲ü�����ֵ,0��?ԭ
    BYTE     byRes2[32];
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM;

typedef struct tagNET_DVR_WALL_RELATION_CFG
{
	DWORD dwSize;
	BYTE  byEnable;           //������ 0-������ !0-����
	BYTE  byRealWallNo ;  	//����ǽ��
	BYTE  byRes[14] ;
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;


typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
	DWORD		dwSize ;
	BYTE    	byValid ;     //
	BYTE		byCamMode ;//��NET_DVR_CAM_MODE
	WORD		wInputNo ; //�ź�Դ���
	BYTE		sCamName[NAME_LEN] ;
	NET_DVR_VIDEOEFFECT 	struVideoEffect ;//��Ƶ����
	NET_DVR_PU_STREAM_CFG	struPuStream ;	//ip����ʱʹ��
	WORD		wBoardNum ; 	 //�ź�Դ���ڵİ忨�ţ�ֻ�ܻ�ȡ
	WORD		wInputIdxOnBoard ; //�ź�Դ�ڰ忨�ϵ�λ�ã�ֻ�ܻ�ȡ
	DWORD	dwResolution ;//�ֱ���
	BYTE	byVideoFormat ;//��Ƶ��ʽ����VIDEO_STANDARD
	BYTE	byStatus;    //�ź�Դ״̬��0-�ֶ���Ч 1-���ź� 2-���ź� 3-�쳣
	BYTE	sGroupName[NAME_LEN/*32*/];	//�����ź�Դ���� ����
	BYTE	byJointMatrix ;			//��������0-������  1-�������������ź�ԴΪNET_DVR_CAM_BNC��NET_DVR_CAM_VGA��NET_DVR_CAM_DVI��NET_DVR_CAM_HDMI,�е�һ��ʱ���ò�����Ч��
	BYTE	byJointNo ;         //ƴ���ź�Դ��ƴ�ӱ��(ֻ�ܻ�ȡ)
	BYTE	byColorMode;      //ɫ��ģʽ�� 0-�Զ��� 1-���� 2-��ͨ 3-��ͣ���Ϊ�Զ���ʱ��ʹ��struVideoEffect����
    BYTE	byRes[127];  //����
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM
{
	DWORD    dwSize;
	WORD     wPTZProtocol;  //����Э�����ͣ�����ֵ
	BYTE     byRes[34];
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM;

//��������
typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //�Ƿ���
    BYTE      byAxleNum;            //����
    BYTE      byRes[2];               //Ԥ��
    float     fOverWeight;          //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С������λ��
    float     fWeight;              //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С������λ��
    float     fLimitWeight;         //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С������λ��
    float     fAxleLen;             //���(��)��ʵ��ֵ����100�����䣨ʵ��ֵ��ȷ��С������λ��
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/]; //�豸������Ϣ
    BYTE      byRes2[64];            //Ԥ��
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

// ���Ƽ����
typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;		//�ṹ����
    DWORD   dwMatchNo;		//ƥ�����,��(�������,�������,������)���ƥ����
    BYTE    byGroupNum;	//ͼƬ��������һ���������ץ�ĵ����������һ��ͼƬ������������ʱƥ����ݣ�
    BYTE    byPicNo;		//���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������;���ճ�ʱ����ͼƬ������ʱ�������Ҫ������ɾ��
    BYTE    bySecondCam;	//�Ƿ�ڶ����ץ�ģ���Զ��ץ�ĵ�Զ������ǰ��ץ�ĵĺ����������Ŀ�л��õ���
    BYTE    byFeaturePicNo; //����Ƶ羯��ȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE	byDriveChan;		//����������
    BYTE	byVehicleType;     //�������ͣ��ο�VTR_RESULT
    BYTE    byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    BYTE    byVehicleAttribute;// 0-�޸�������,1-�Ʊ공(���),2-Σ��Ʒ����
    WORD    wIllegalType;       //Υ�����Ͳ��ù�궨��
    BYTE    byIllegalSubType[8];   //Υ��������
    BYTE    byPostPicNo;    //Υ��ʱȡ�ڼ���ͼƬ��Ϊ����ͼ,0xff-��ʾ��ȡ
    BYTE    byChanIndex;		//ͨ���ţ�������
    WORD	wSpeedLimit;		//�������ޣ�����ʱ��Ч��
    BYTE	byRes2[2];
    NET_DVR_PLATE_INFO  struPlateInfo; 	//������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo;	//������Ϣ
    BYTE    byMonitoringSiteID[48];		//������
    BYTE    byDeviceID[48];				//�豸���
    BYTE    byDir;    		//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE    byDetectType;	//��ⷽʽ,1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ���������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byRes3; //����
    //��wIllegalType����Ϊ��ʱ��ʹ�øò�����wIllegalType����Ϊ��ֵʱ����wIllegalType����Ϊ׼���ò�����Ч��
    DWORD   dwCustomIllegalType; //Υ�����Ͷ���(�û��Զ���)
    BYTE    byRes4[9]; //����
    BYTE    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    //0-��բ��1-δ��բ (ר������ʷ���������ݺڰ���ƥ����Ƿ�բ�ɹ��ı�־)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-ʵʱ��ݣ�1-��ʷ���
    NET_DVR_TIME_V30  struSnapFirstPicTime;//�˵�ʱ��(ms)��ץ�ĵ�һ��ͼƬ��ʱ�䣩
    DWORD   dwIllegalTime;//Υ������ʱ�䣨ms�� = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    DWORD   dwPicNum;		//ͼƬ��������picGroupNum��ͬ����?����Ϣ�����ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����
    NET_ITS_PICTURE_INFO struPicInfo[6]; 		//ͼƬ��Ϣ,���Żص������6��ͼ����������
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //��������
    BYTE     byRes[256]; //Ԥ��
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;

typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-���������1-���ز�����2-��ʱ����
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;

typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    //�ճ��ƻ�����ʱ���
    BYTE byNormalSchedTimeOn; //�ճ��ƻ��Ƿ�����
    BYTE byMandatoryAlarm;//0-��ǿ�Ʋ�����1-ǿ�Ʋ��� ָ���������������Ƿ�Ϊ��·����
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;


#define MAX_WHITELIST_PHONE_NUM      16

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD	dwSize;
    BYTE	byEnable;//�Ƿ����� 0-�����ã�1-����
    BYTE	byRes1[3];
    BYTE	byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD	dwArmRight; //����Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1�в���Ȩ�ޣ���������
    DWORD	dwDisArmRight; //����Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1�г���Ȩ�ޣ���������
    DWORD	dwClearAlarmRight; //��Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1����Ȩ�ޣ���������
    BYTE	byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/]; //��������ͣ�0-���ϴ���1-�ϴ�
    DWORD	dwNonZoneReport; //�Ƿ������� bit0-������ bit1-ϵͳ״̬���� bit2-ȡ��� bit3-���Ա��� 		bit4-�������� bit5-�������� bit6-Ю�ֱ��� bit7-�����ָ����� bit8-��·���� bit9-��·�ָ����档
    BYTE	byIntervalTime; //0-0s,1-10s,2-30s,3-1min,4-5min,5-10min,6-�Զ��壨1~5999s��
    BYTE	byRes2;
    WORD	wDefineIntervalTime; //��byIntervalTimeΪ6ʱ��Ч���Զ���ʱ�䣨1~5999s��
    BYTE	byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD	dwSize;
    BYTE	byModuleType;			//��Ӵ��������ͣ�1-���̣�2-��������3-����
    BYTE	byKeyBoardType;			//1-LCD,2-LED
    BYTE	byTriggerType;			// 1-���ش������� 2-4·��������3-8·��������4-����������5-32·������
	BYTE	byZoneType;				//�������ͣ�1-���ط���2-������3-˫����4-8����5-8·ģ��������, 6-��������
    WORD	wModuleAddress;			//��Ӵ�������ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE	byRes2[2];				//����
    char	sModelInfo[32];			//ģ����Ϣ
    char	sDeviceVersionInfo[32];	//�汾��Ϣ
    BYTE	byRes[128];				//����
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;// 0- ��1- ��
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE					   byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];//�±��ʾ�������ţ�ֵ0-�����ã�1-����
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;
//ʱ������������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{
    DWORD  dwSize; //�ṹ���С
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/]; //���֧��8��������εĹ������ã����ڶ�ʱ��/�ش�����ֻ��Ҫʹ��һ��������ξͿ�����
    BYTE   byRes[64];  //����
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

//����ʱ�������������
typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD		dwSize;
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE		byRes[256];  //����
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD		dwSize;
    BYTE		byBeforeAlarmPic;	//��Ӧ�ֱ����¿����ñ���ǰͼƬ�����4CIF��10�ţ�2CIF��20�ţ�CIF��40�ţ�QCIF��80�ţ�WD1:10��,XVGA:10��,720P:10��,1080P:10��
    BYTE		byAfterAlarmPic;	//��Ӧ�ֱ����¿����ñ�����ͼƬ����� 4CIF��10�ţ�2CIF��20�ţ�CIF��40�ţ�QCIF��80�ţ�WD1:10��,XVGA:10��,720P:10��,1080P:10��
    WORD	  	wInterval; //���ʱ�� ��λs
    BYTE		byResolution;	//ͼƬ�ֱ���1-CIF��2-2CIF��3-4CIF��4-QCIF��5-WD1��6-VGA,7-XVGA��8-720P��9-1080P
    BYTE   		byRes[63];      	// �����ֽ�
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

#define PRIOR_SCHEDTIME			30

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE	byEnable; //�Ƿ����� 0-�����ã�1-����
    BYTE byRes1[3];
    BYTE bySubSystem[32];//��ϵͳ���±��ʾ��ϵͳ�� 0-��֧�֣�1-֧��
    BYTE byMandatoryAlarm;//0-��ǿ�Ʋ�����1-ǿ�Ʋ��� ָ���������������Ƿ�Ϊ��·����
    BYTE byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType; 	// 0-��,1-������2-����
    BYTE    byUploadAlarmRecoveryReport;    //�Ƿ��ϴ������ָ����棬0-���ϴ���1-�ϴ�
    BYTE	byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //�������������	BYTE			byAssociateSirenOut[8];		//������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE	byAssociateSirenOut[8];		//������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE	byTamperResistor;	//������裬��λǧŷ �� 0-��Ч 1-2.2 ��2--3.3, 3-4.7 ��4-5.6 �� 5-8.2 ��0xff-�Զ���
    BYTE	byRes2[3];
    float	fTamperResistorManual;/*�����ֶ����裬1.0-10.0����ȷ��С����һλ����λǧŷ��byTamperResistorΪ0xffʱ��Ч*/
    BYTE	byRes3[36];    		// �����ֽ�
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;


typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;
    BYTE	byRes1;
    WORD	wRemoteCtrllerID;//ң������ ��1��ʼ
    BYTE	sDevSn[16];/*��Ʒ���к�*/
    BYTE	byArmRight;			/*0-�޲���Ȩ�ޣ�1-�в���Ȩ��*/
    BYTE	byDisArmRight;		/*0-�޳���Ȩ�ޣ�1-�г���Ȩ��*/
    BYTE	byArmReportRight;	/*0-�޴���������Ȩ�ޣ�1-�д���������Ȩ��*/
    BYTE	byDisArmReportRight;/*0-���ϴ���������Ȩ�ޣ�1-���ϴ���������Ȩ��*/
    BYTE	byClearAlarmRight;	/*0-����Ȩ�ޣ�1-����Ȩ��*/
    BYTE	bySubSystemID;       /* �豸(ң����)��ϵͳ��,1~8 */
    BYTE	byKeyboardAddr;      /* ���ռ��̵ĵ�ַ,�����ʱ���� */
    BYTE	byRes2[65];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


typedef struct tagNET_DVR_KEYBOARD_ALARM_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;//�Ƿ������̱������� 0-�رգ�1-����
    BYTE	byRes[131];
}NET_DVR_KEYBOARD_ALARM_CFG, *LPNET_DVR_KEYBOARD_ALARM_CFG;


typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD	dwSize;
    BYTE	byCommOperatorNum[NAME_LEN/*32*/];//ͨ����Ӫ�̺���
    BYTE	byQueryCode[16];//ҵ���ѯ����
    BYTE	byBusinessType;//ҵ������ 0-���ѣ�1-����
    BYTE	byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD	dwSize;
    BYTE	by3GBusiness[1024];//3Gҵ��ͨ����Ų�ѯ
    BYTE	byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD	dwSize;
    WORD	wdelayTime;//�ӳ�Ԥ��ʱ�䣬��λ����
    BYTE	byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD	dwSize;
	DWORD	dwDevNo;	//�豸��
	BYTE	byDevType;	//���豸���� 0-����,1-��о
    BYTE	byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD	dwSize;
    SHORT   nFloorNumber;	//���
    WORD	wRoomNumber;	//�����
    BYTE	byRes[128];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD	dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

//��Ѷ������Ϣ
typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD	dwSize;
    BYTE	sCaseNo[INQUEST_CASE_NO_LEN];		//�������
    BYTE	sCaseName[INQUEST_CASE_NAME_LEN];	//������ƣ�
    BYTE	sCustomInfo1[CUSTOM_INFO_LEN];		//�Զ�����Ϣ1��
    BYTE	sCustomInfo2[CUSTOM_INFO_LEN];		//�Զ�����Ϣ2��
    BYTE	sCustomInfo3[CUSTOM_INFO_LEN];		//�Զ�����Ϣ3
    BYTE	byShowCaseInfoTime; /* ������Ϣ��ʾʱ��,��λ��, ȡֵ��Χ1~60��*/
    BYTE	byShowCaseInfo;	//������ʼ�Ƿ���ʾ������Ϣ��0-����ʾ��1-��ʾ
    BYTE	byPosition;		//������ʾλ�ã�0-���ϣ�1-����
    BYTE	byRes[257]; //����
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD	dwSize;
	DWORD	dwChannel;//��Ѷͨ����
	BYTE	byShowCaseInfoTime;	//��ʾ����ʱ��
	BYTE	byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD	dwSize;
    /*����0: ��Ѷ��¼ɾ��Ȩ��*/
	BYTE	byLocalRight[MAX_RIGHT];    /* ����Ȩ�� */
	/*����0: Զ����ƵԤ��Ȩ��*/
	BYTE	byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */
    BYTE	byNetAudioRight[MAX_CHANNUM_V40];    /* Զ����ƵԤ��Ȩ�ޣ������±��ʾͨ����ֵ��ʾ����Ȩ�ޣ�0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE	byRes[512*9];         //����9��Ȩ�޿���չ
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;	//�Ƿ����û�����0-�����ã�1-����
	BYTE	byRes1[3];	//����
	DWORD	dwMixCnt;  /*������ͨ����*/
    BYTE	bySrcChan[MAX_MIX_CHAN_NUM];    /*�����±��ʾ����ͨ���ţ�ģ��ͨ����IPͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
    BYTE	byLineIn[MAX_LINE_IN_CHAN_NUM];	/*�����±��ʾ����Line Inͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
    BYTE	byMic[MAX_MIC_CHAN_NUM];		/*�����±��ʾ����Micͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
	BYTE	byMixAudioDelay;	//�����ӳ٣���λ��֡����Χ0-63
    BYTE	byRes2[127];	//����
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD dwSize;
    DWORD   dwChannel;//ͨ����
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    BYTE   byReportType;//ͳ�Ʊ������ͣ�1-�ձ��?2-�ܱ��?3-�±��?4-�걨��
    BYTE   byStatType;//�������ͳ�ƣ�Bit0-����Σ�Bit1-�Ա�Bit2-����
    BYTE   byRes[126];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;//���꣨����
    DWORD	dwYouth;//���꣨����
    DWORD	dwMidLife;//���꣨����
    DWORD	dwElderly;//���꣨����
    BYTE   byRes[64];
}NET_DVR_AGEGROUP_PARAM,*LPNET_DVR_AGEGROUP_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;//�У�����
    DWORD	dwFemale;//Ů������
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;/*�����ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*�������ʱ��*/
    BYTE   byStatType;//�������ͳ�ƣ�Bit0-�������Ч��Bit1-�Ա���Ч��Bit2-������Ч
    BYTE   byRes[7];
    DWORD  dwPeopleNum;//����ͳ��
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;//���������ͳ��
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;//�Ա�����ͳ��
    BYTE   byRes1[128];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

//��ȡ��ͨ��������ṹ
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
	DWORD  dwSize;
    /*
	Bit0-ͨ����Ч
	Bit1-ʱ����Ч
	Bit2-���ƺ���Ч
	Bit3-����������Ч
	Bit4-������ɫ��Ч
	Bit5-������ɫ��Ч
	Bit6-����������Ч
	Bit7-����Ʒ����Ч
	Bit8-��������Ч
	Bit9-��ⷽ����Ч
	Bit10-����ٶ���Ч
	Bit11-����ٶ���Ч
	Bit12-���������Ч
	Bit13-���ط�ʽ������Ч
    Bit14-Υ��ȡ֤��Ч
    Bit15-�¼�������Ч
    Bit16-ȡ֤������Ч
    */
    DWORD  dwQueryCond;//��ѯ���� 0��ʾ��Ч��1��ʾ��Ч
	DWORD  dwChannel;//Ĭ����1��[1~32]��bit0��ʾͨ��1����������bit31��ʾͨ��32��
	NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
	NET_DVR_TIME_V30 struEndTime;//����ʱ��
	char  sLicense[MAX_LICENSE_LEN/*16*/];//(�豸֧��ģ���ѯ, GB2312����)
	/*
	Bit0-δ֪������
	Bit1-��׼���ó����
	Bit2-02ʽ���ó���
	Bit3-�侯��
	Bit4-����
	Bit5-���ó�˫��β��
	Bit6-ʹ�ݳ���
	Bit7-ũ�ó�
	Bit8-Ħ�г�
	*/
	DWORD  dwPlateType;//�������ͣ�֧�ְ�λ��ʾ�����Ը�ѡ��
	/*
	Bit0-δ֪������
	Bit1-��ɫ
	Bit2-��ɫ
	Bit3-��ɫ
	Bit4-��ɫ
	Bit5-��ɫ
	*/
	DWORD  dwPlateColor;//������ɫ��֧�ְ�λ��ʾ�����Ը�ѡ��
	/*
	Bit0-δ֪������
	Bit1-��ɫ
	Bit2-��ɫ
	Bit3-��ɫ
	Bit4-��ɫ
	Bit5-��ɫ
	Bit6-����ɫ
	Bit7-��ɫ
	Bit8-��ɫ
	Bit9-��ɫ
	Bit10-��ɫ
	Bit11-��ɫ
	Bit12-��ɫ
	Bit13-���ɫ
	*/
	DWORD  dwVehicleColor;//������ɫ��֧�ְ�λ��ʾ�����Ը�ѡ��
	/*
	Bit0-δ֪������
	Bit1-�ͳ�
	Bit2-�����
	Bit3-�γ�
	Bit4-���
	Bit5-С����
	Bit6-����
	Bit7-���ֳ�
	Bit8-���ֳ�
    Bit9-SUV/MPV
    Bit10-���Ϳͳ�
	*/
	DWORD  dwVehicleType;//�������ͣ�֧�ְ�λ��ʾ�����Ը�ѡ��
 	/**
	Bit0-��������
	Bit1-����
	Bit2-����
	Bit3-����
	Bit4-�����
	Bit5-ѹ������
	Bit6-��������
	Bit7-·������
	Bit8-��ռ��
	Bit9-Υ�����
	Bit10-��������
	Bit11-Υ������
	Bit12-·��ͣ��
	Bit13-�̵�ͣ��
	Bit14-δ��������
	Bit15-Υ��ͣ��
	Bit16-Υ�µ�ͷ
	Bit17-ռ��Ӧ������
	Bit18-δϵ��ȫ��
	*/
	DWORD dwIllegalType;
	/**
	Bit0-��������
	Bit1-ӵ��
	Bit2-ͣ��
	Bit3-����
	Bit4-����
	Bit5-������
	Bit6-����
	Bit7-ѹ��
	Bit8-����
	Bit9-����
	Bit10-���
	Bit11-��ͷ
	Bit12-��ռ��
	Bit13-����
	*/
	DWORD dwEventType;
	/**
	Bit0-��������
	Bit1-���й�·Υ��ͣ��
	Bit2-���ٹ�·Υ��ͣ��
	Bit3-ѹ��
	Bit4-����
	Bit5-Υ�����
	Bit6-��ռ��
	*/
	DWORD  dwForensiceType;
	WORD   wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" ������ѡ��
	BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
	BYTE   byDirection;//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ�����
	WORD   wMinSpeed;//����ٶȣ�0~999����λkm/h
	WORD   wMaxSpeed;//����ٶȣ�0~999����λkm/h
	BYTE   byDataType;//������� 0-������ݣ�1-Υ����ݣ�2-��ͨ�¼���3-ȡ֤��� ������ѡ��
	BYTE   byExecuteCtrl;//���� 0-����1-����0xff-����
	BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

//��ͨͼƬ�����ӽṹ
typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30 	struRelativeTime; //ץ�����ʱ��
    NET_DVR_TIME_V30	struAbsTime;  //ץ�ľ��ʱ��
    char szPicName[PICTURE_NAME_LEN/*64*/];
    BYTE  byPicType;//ͼƬ���� 0-����ͼ��1-ץ��ԭͼ��2-�ϳ�ͼ��3-��дͼ
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

//��ͨ��ݽṹ��
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
	DWORD  dwSize;
    DWORD  dwChannel;//Ĭ����1��[1~32]��
	char  sLicense[MAX_LICENSE_LEN/*16*/];
	/*
	Bit0-δ֪������
	Bit1-��׼���ó����
	Bit2-02ʽ���ó���
	Bit3-�侯��
	Bit4-����
	Bit5-���ó�˫��β��
	Bit6-ʹ�ݳ���
	Bit7-ũ�ó�
	Bit8-Ħ�г�
	*/
	DWORD  dwPlateType;//��������
	/*
	Bit0-δ֪������
	Bit1-��ɫ
	Bit2-��ɫ
	Bit3-��ɫ
	Bit4-��ɫ
	Bit5-��ɫ
	*/
	DWORD  dwPlateColor;//������ɫ
	/*
	Bit0-δ֪������
	Bit1-��ɫ
	Bit2-��ɫ
	Bit3-��ɫ
	Bit4-��ɫ
	Bit5-��ɫ
	Bit6-����ɫ
	Bit7-��ɫ
	Bit8-��ɫ
	Bit9-��ɫ
	Bit10-��ɫ
	Bit11-��ɫ
	Bit12-��ɫ
	Bit13-���ɫ
	*/
	DWORD  dwVehicleColor;//������ɫ
	/*
	Bit0-δ֪������
	Bit1-�ͳ�
	Bit2-�����
	Bit3-�γ�
	Bit4-���
	Bit5-С����
	Bit6-����
	Bit7-���ֳ�
	Bit8-���ֳ�
	*/
	DWORD  dwVehicleType;//��������
	/**
	Bit0-��������
	Bit1-����
	Bit2-����
	Bit3-����
	Bit4-�����
	Bit5-ѹ������
	Bit6-��������
	Bit7-·������
	Bit8-��ռ��
	Bit9-Υ�����
	Bit10-��������
	Bit11-Υ������
	Bit12-·��ͣ��
	Bit13-�̵�ͣ��
	Bit14-δ��������
	Bit15-Υ��ͣ��
	Bit16-Υ�µ�ͷ
	Bit17-ռ��Ӧ������
	Bit18-δϵ��ȫ��
	*/
	DWORD dwIllegalType;
	/**
	Bit0-��������
	Bit1-ӵ��
	Bit2-ͣ��
	Bit3-����
	Bit4-����
	Bit5-������
	Bit6-����
	Bit7-ѹ��
	Bit8-����
	Bit9-����
	Bit10-���
	Bit11-��ͷ
	Bit12-��ռ��
	Bit13-����
	*/
	DWORD dwEventType;
	/**
	Bit0-��������
	Bit1-���й�·Υ��ͣ��
	Bit2-���ٹ�·Υ��ͣ��
	Bit3-ѹ��
	Bit4-����
	Bit5-Υ�����
	Bit6-��ռ��
	*/
	DWORD dwForensiceType;
	WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx"
	BYTE  byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
	BYTE  byDirection;//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ�����
	WORD  wSpeed;//�ٶȣ�0~999����λkm/h
    BYTE  byDataType;//�������: 0-���� 1-Υ�� 2-�¼� 3-ȡ֤
    BYTE  byRes[253];
	NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//�����ӻ�ȡ��ͨ���������ṹ
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
	DWORD  dwSize;
	/**
	Bit0-ͨ����Ч
	Bit1-ʱ����Ч
	Bit2-��������Ч
    */
    DWORD  dwQueryCond;//��ѯ���� 0-������
	DWORD  dwChannel;//Ĭ����1��[1~32]��bit0��ʾͨ��1����������bit31��ʾͨ��32��
	DWORD  dwResChan[10];//Ԥ������չ��ͨ����
	NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
	NET_DVR_TIME_V30 struEndTime;//����ʱ��
	BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
	BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

//�����ӻ�ȡ��ͨ�����ṹ
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
	DWORD  dwSize;
	NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
	NET_DVR_TIME_V30 struEndTime;//����ʱ��
	DWORD  dwChannel;//Ĭ����1��[1~32]��
	DWORD  dwFlow;//������
    BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
	BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

//ͼƬ����
typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //ͼƬ���ͣ�0-jpg
    BYTE   byRes1[3];        //����
    DWORD  dwPicWidth;       //ͼƬ���
    DWORD  dwPicHeight;      //ͼƬ�߶�
    DWORD  dwPicDataLen;     //ͼƬ��ݴ�С
    char*  byPicDataBuff;    //ͼƬ��ݻ�����
    BYTE   byRes2[32];       //����
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD	   dwSize;//�ṹ���С
    BYTE       byEnable;       //�����Ƿ����ã� 0-�����ã�1-����
    BYTE       byRuleID;       //�����Ĺ���ID
    BYTE       byColorBlockNo;  //��ɫ����ţ���1��ʼ
    BYTE       byRes1;      //����
    NET_DVR_PIC_INFO  struPicInfo;  //ͼƬ��ɫ��Ϣ
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD	    dwSize;//�ṹ���С
    DWORD     dwChannel;     //ͨ����
    BYTE        byRuleID;       //�����Ĺ���ID  0��ʾ������
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

//LLDP����
typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //����
    BYTE byPortNo;      //�˿ں�
    BYTE byEnabledTx;   //ʹ�ܷ���lldp��0-��ʹ�ܣ�1-ʹ��
    BYTE byEnabledRx;   //ʹ�ܽ���lldp��0-��ʹ�ܣ�1-ʹ��
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //ʹ��LLDP���ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //����ʱ�䣬��λ����
    DWORD dwReiniTime;  //���³�ʼ��ʱ�䣬��λ����
    DWORD dwPacketTime; //���ʱ�䣬��λ����
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //���˿�LLDP����
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

//�����շ�������Ϣ
typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //�˿ںţ�0-��Ч
    BYTE  byPortName[NAME_LEN];  //�˿���
    BYTE  byWorkMode;            //����ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byBandWidth;           //��?1-100M��2-1G��3-10G
    BYTE  byPortType;            //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];      //�ͺ����
    BYTE  bySerialNo[SERIALNO_LEN];  //���к�
    BYTE  bySoftwareVersion[VERSION_LEN]; //����汾
    NET_DVR_IPADDR struIPAddr;           //IP��ַ
	DWORD dwSlotNo;	//��ܿ���λ�ţ�����λ��
    BYTE  byStructureType;           //�ṹ���ͣ�1-2U��2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //�������Ϣ
    BYTE  byRes2[32];
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                 //���ţ���1��ʼ
	BYTE  byTypeName[NAME_LEN];     //�ͺ����
    BYTE  bySerialNo[SERIALNO_LEN]; //���к�
    BYTE  bySoftwareVersion[VERSION_LEN]; //����汾
	DWORD dwMainSlot;               //����λ����1��ʼ
    BYTE  byStructureType;          //�ṹ���ͣ�1-2U��2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //���˿ڲ���
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType;                                       //��Դ���ͣ�1-����Դ��2-˫��Դ
    BYTE  byRes1[3];
	DWORD dwSlotNum;											 //��ܿ���λ�ţ�����λ��
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //��ܿ���Ϣ
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //���ܿ���Ϣ
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

//�����շ�������״̬��Ϣ
typedef struct tagNET_DVR_CARD_PORT_STATE
{
	BYTE  byValid;				 //�Ƿ���Ч��0-��Ч��1-��Ч
    BYTE  byPortType;            //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byLinkState;           //����״̬��0-δ���ӣ�1-������
    BYTE  byRes1;
    DWORD dwSendBytes;           //���͵��ֽ���
    DWORD dwRecvBytes;           //������ݰ���
    DWORD dwRecvLostPackets;     //���ն�����
    DWORD dwRecvCrcErrPackets;   //����CRCУ��������
    DWORD dwRecvFragmentPackets; //������Ƭ����ͻ������ֽڰ����Ⱦ�С��64�ֽڣ�
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
	NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];	//���˿�״̬
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
	BYTE  byEnabled;	//�˽ṹ�Ƿ���Ч��0-��Ч��1-��Ч
	BYTE  byRes1[3];
    DWORD dwCardNo; //����
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //��ܿ�״̬
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //���ܿ�״̬
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

//�����շ���������Ϣ
typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //�˿ںţ�0-��Ч����0Ϊ���ܿ��˿ں�
    BYTE  byPortType;               //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byLocalWorkMode;          //���ع���ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byLocalBandWidth;         //���ش�?1-100M��2-1G��3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //�Զ��豸�������
    BYTE  byPeerMac[MACADDR_LEN];   //�Զ�MAC��ַ
    DWORD dwPeerPortNo;             //�Զ˶˿ں�
    BYTE  byPeerWorkMode;           //�Զ˹���ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byPeerBandWidth;          //�Զ˴�?1-100M��2-1G��3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;	                //�˽ṹ���Ƿ���Ч��0-��Ч����0-��Ч
	BYTE  byRes1[3];
    DWORD dwCardNo;                 //���ţ�0-��ܿ�������0-���ܿ�
	DWORD dwSlotNum;	            //��ռ�õĲ�λ��
	BYTE  byTypeName[NAME_LEN];	    //���������
	BYTE  byLocalMac[MACADDR_LEN];  //����MAC��ַ
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //���˿�������Ϣ
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM]; //����������Ϣ
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

//�����շ����˿�ע����Ϣ
typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //��λ��
    DWORD dwPortNo; //�˿ں�
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
	DWORD dwSize;
	BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //���ض˿�ע����Ϣ
    BYTE  byPeerRemarks[MAX_REMARKS_LEN]; //�Զ˶˿�ע����Ϣ
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;

typedef enum _EN_FIBER_CONVERT_ALARM
{
    FC_OPTICAL_PORT_LOST = 1,
    FC_ELECTRICAL_PORT_LOST,
    FC_FUNC_CARD_LOST,
}EN_FIBER_CONVERT_ALARM;

typedef enum _EN_FIBER_CONVERT_NOTIFICATION
{
    FC_OPTICAL_PORT_CONNECTED = 1,
    FC_ELECTRICAL_PORT_CONNECTED,
    FC_FUNC_CARD_INSERT,
}EN_FIBER_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;  //�¼����ͣ�1-�澯��2-֪ͨ
    DWORD dwEvent;      //�����¼�,�澯ʱ�ο�ö��EN_FIBER_CONVERT_ALARM,֪ͨʱ�ο�ö��EN_FIBER_CONVERT_NOTIFICATION
    BYTE bySlotNum;     //��λ��
    BYTE byCardType;    //�����ͣ�1-���翨��2-���ܿ�
    BYTE byPortNo;      //�ӿ������1��ʼ
    BYTE byRes1[33];
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD	    dwSize;//�ṹ���С
    BYTE       byEnable;       //�����Ƿ����ã� 0-�����ã�1-����
    BYTE       byTriggerMode; // 1-������2-���δ���
    BYTE       byUploadPic;   //0-���ϴ�ͼƬ��1-�ϴ�ͼƬ
    BYTE       byRes1;        //����
    DWORD      dwTimeInterval; //��������ʱ��������Χ[0,3600]����λ����
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;//���?ʽ
    BYTE       byRelRecordChan[MAX_IVMS_IP_CHANNEL];	//����������¼��ͨ����1��ʾ������ͨ����0��ʾ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//���ʱ��
    BYTE       byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD	    dwSize;//�ṹ���С
    NET_VCA_DEV_INFO    struDevInfo;        //�豸��Ϣ
    NET_DVR_TIME_EX     struTime;           //����ʱ��
    BYTE                byLampStatus;       //���ص�״̬��0-�ѹر�  1-�Ѵ�
    BYTE                byRes1[3];          //����
    DWORD               dwPicDataLen;       //ͼƬ��ݳ��ȣ���0��ʾ��ͼƬ�ϴ�
    char*               pPicData;           //ͼƬ���
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

//�����ռ�������
typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
	DWORD	dwSize;
	BYTE	byDevAddr;	//�豸��ַ��0-����1-15Ϊ�ӻ�
	BYTE	byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

//˽�йؼ���Ϣ�ϴ�����
typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD 		 dwSize;
    NET_DVR_IPADDR	 struIP; //��Ϣ�ϴ���IP��ַ
    WORD 		 wPort;//��Ϣ�ϴ��Ķ˿ں�
    BYTE		 byRes[2];
    DWORD        dwInterval;//��Ϣ�ϴ����(0-��ʱ�������ƣ����豸Ϊ׼; >=0,����Ϊ��λ��ʱ����)
    BYTE		 byServerType;//�������� 0-�ޣ�1-����
    BYTE         byEcryptedSMSEnable;//0-�����ܣ�1-����
    BYTE         byAlgorithm;//�����㷨��0-�ޣ�1-RSA
    BYTE         byRes1[221];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//��Կ����
    char		 szSecretKey[MAX_SECRETKEY_LEN/*512*/];//��Կ
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

//��������
typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD 	dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

//������Ϣ
typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD 	dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;



#define MAX_SSID_LEN    32   //SSID�ų���
#define MAX_WS_PASSWD_LEN    64   //���볤��
typedef	struct tagNET_DVR_WIRELESSSERVER
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byWLanShare;//WLan�ȵ�ʹ�� 0-�رգ�1-ʹ��
    BYTE        byBroadcastSSID;//SSID�㲥ʹ�� 0-�رգ�1-ʹ��
    BYTE        bySecurityMode;//��ȫģʽ 0- not-encrypted��1-WPA��2-WPA2(��ʱֻ֧��2)
    BYTE		byAlgorithmType; //����ģʽ 1-TKIP��2-AES
    char        szSSID[MAX_SSID_LEN/*32*/];//SSID����Ϣ
    char        szPassWord[MAX_WS_PASSWD_LEN/*64*/];
    BYTE        byDefaultPassword;//�Ƿ���Ĭ������ 0-��1-��
    BYTE        byRes[255];
}NET_DVR_WIRELESSSERVER,*LPNET_DVR_WIRELESSSERVER;

typedef	struct tagNET_DVR_CONNECTDEV_COND
{
    DWORD       dwSize;
    DWORD		dwChannel;
    BYTE        byRes[128];
}NET_DVR_CONNECTDEV_COND,*LPNET_DVR_CONNECTDEV_COND;

typedef	struct tagNET_DVR_CONNECTDEV_CFG
{
    DWORD       dwSize;
    BYTE		byID;//���к�
    BYTE        byRes[1];
    BYTE		byMACAddr[MACADDR_LEN/*6*/];	// �����ַ
    NET_DVR_IPADDR	struDVRIP;//�豸IP
    NET_DVR_TIME  struConnectTime;//����ʱ��
    BYTE        byRes1[256];
}NET_DVR_CONNECTDEV_CFG,*LPNET_DVR_CONNECTDEV_CFG;

typedef struct tagNET_DVR_GIS_SERVER_INFO
{
	BYTE  byUserName[NAME_LEN];
	BYTE  byPassword[PASSWD_LEN];
	NET_DVR_IPADDR struServerIP;     //GIS������IP��ַ
	WORD  wPort;    //GIS�������˿�
	BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
	DWORD dwSize;
	BYTE  byEnable;        //�Ƿ���ʾ��1-��ʾ��0-����
	BYTE  byBaseMapType;    //��ͼ���ͣ�1-ͼƬ��ͼ��2-�����������ͼ��3-GIS��ͼ
	BYTE  byRes1[2];
	DWORD dwBaseMapNo;     //��ͼ�ţ���ͼ����Ϊ1ʱ���˲���ΪͼƬ��ţ���ͼ����Ϊ2ʱ�˲���Ϊ������������ϵͳ����ںţ�1�ֽھ����+1�ֽ��Ӱ��+1�ֽ�����ں�+1�ֽڱ�����
	NET_DVR_GIS_SERVER_INFO struGisServer;	//GIS��������Ϣ,����ͼ����ΪGIS��ͼʱ��Ч
	BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{
    DWORD		dwSize;       			//NET_DVR_VIDEO_IMG_DB_CFG�ṹ���С
	INT64   	i64Capacity; 			//��ͼ������������λ����λ��MB
	INT64		i64UsedSpace;			//ֻ�������ÿռ䣬��λ����λ��MB
	INT64		i64AvailableSpace;		//ֻ�������ÿռ䣬��λ����λ��MB
    BYTE      	byRes[256];				//����
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{
    DWORD		dwSize;       			//NET_DVR_FILE_QUERY_INFO�ṹ���С
	INT64   	i64FileLen; 			//�ļ���С
    BYTE      	byRes[256];				//����
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char		szFileID[MAX_FILE_ID_LEN];		//�ϴ�֮���豸������ļ�ID
    BYTE		byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD 	dwType;			//����, 0-�����Ϣ,1-����ͼƬ��Ϣ(�ƴ洢��������),2-ͼƬ������Ϣ(�ƴ洢��������)
    BYTE    *pData;			//���ָ��
    DWORD   dwDataLen;		//��ݳ���
    void*   pFileInfo;		//�ļ���Ϣ�ṹ��(�ƴ洢��������ʱ��Ч)
    DWORD   dwFileInfoLen;	//�ļ���Ϣ�ṹ�峤��(�ƴ洢��������ʱ��Ч)
    BYTE    byRes[120];		//����
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef BOOL (*DOWNLOAD_DATA_CB)( LONG lHandle, NET_DOWNLOAD_CB_INFO *pCBInfo, void *pUserData);

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
	DOWNLOAD_DATA_CB 	fnDownloadDataCB;	//������ݻص�����
	void 				*pUserData;			//�û�����, ��fnPreviewDataCB�ص�����
	INT64				i64Offset;		//�����ļ���ƫ���������ڶϵ���
    BYTE       			byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64	i64FileLen;			 //�ϴ����ļ�����Ҫ����ļ����ȣ��ļ�����Բ���
	BYTE	byContinueUpload;	 //0-���ļ��ϴ���1-���ļ����ļ��������
    BYTE   	byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;


typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char	szFileID[MAX_FILE_ID_LEN];		//�ϴ�֮���豸������ļ�ID
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;

typedef struct tagNET_DVR_SEND_PARAM_IN
{
	BYTE	*pSendData;		//���͵Ļ�����
	DWORD	dwSendDataLen;	//������ݳ���
    NET_DVR_TIME_V30	struTime;	//ͼƬʱ��
    BYTE	byPicType;	//ͼƬ��ʽ,1-jpg,2-bmp,3-png
    BYTE   byRes[243];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;


typedef struct tagNET_DVR_DOWNLOAD_QOS
{
	DWORD	dwMaxSpeed;			//��������ٶȣ���λkbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;



//��Ӱģʽ����
typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD    dwSize;  		//�ṹ���С
    BYTE     byScreenType; 	//�������ͣ�0-�����棬1-�����棬2-���л�
    BYTE     byRes[255];    //����
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

//������������
typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;  //�ṹ���С
    BYTE     byDirectedStrategyType; //�����������ͣ�0-��̬�������ԣ�1-��Ʒ��������
    BYTE     byRes[255];     //����
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

//�߿��ӽṹ
typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; /*�߿��ȺϷ�ȡֵ��ΧΪ[0,14]������ֻ��ȡż��ֵ*/
    BYTE	 byRed;  /*�߿���ɫΪRGB ģʽ��R��G��B���ֱ��Ӧλ������*/
    BYTE     byGreen;
    BYTE     byBlue;
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

//���û���߿�
typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;  		//�ṹ���С
    NET_DVR_FRAME	struTopFrame;	//�ϱ߿�
    NET_DVR_FRAME	struBottomFrame;//�±߿�
    NET_DVR_FRAME	struLeftFrame;	//��߿�
    NET_DVR_FRAME	struRightFrame;	//�ұ߿�
    BYTE            byFrameEnable;  //���ӱ߿�0-������1-���ӱ߿�
    BYTE            byRes[256];     //����
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

//���û���߿�����
typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//������
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

//��Ƶ�Ż�����
typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;  		//�ṹ���С
    DWORD       dwCheckDelay;	//���ʱ�ӣ���λs��0��ʾ���Զ��Ż�
    BYTE        byThreshold; 	//��ֵ[0,100]
    BYTE        byVolumePercent;//���� [0,100]
    BYTE        byPriority; 	//�ȼ���[0��100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

//¼����Ƶ����
typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;  			//�ṹ���С
    BYTE        byExportType; 		//��ֵ0-MP4 1-AVI
    BYTE        byRes[255];      	//�����ֽ�
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE    		 byStreamType;  //�������ͣ�1-��������2-��������3-������
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

//RTMP Cfg
typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD   	dwSize;  						//�ṹ���С
    BYTE		byEnable;						//�Ƿ�����RTMP��0-�����ã�1-����
    BYTE     	byRes1[3];
    DWORD   	dwPacketLen; 					//RTMP��
    char		szURL[RTMP_URL_LEN];        	//RTMP URL
    BYTE     	byRes[256];      				//�����ֽ�
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;

//�ļ�����
typedef  struct  tagNET_DVR_RECORDING_PUBLISH_FILE_CFG
{
    DWORD   dwSize;                         //�ṹ���С
    BYTE    byFileID[MAX_ID_LEN_128/*128*/];  //�����ļ�ID
    NET_DVR_TIME_EX  struStartTime;  //�γ̿�ʼʱ��
    NET_DVR_TIME_EX  struEndTime;   //�γ̽���ʱ��
    BYTE    byCmdType;  //������������  1--��ʼ���� 2--ȡ��
    BYTE   byRes[255];
}NET_DVR_RECORDING_PUBLISH_FILE_CFG, *LPNET_DVR_RECORDING_PUBLISH_FILE_CFG;

//�ļ������������
typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE    		 byFileID[MAX_ID_LEN_128/*128*/];  //�����ļ�ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

//�ļ�������Ȳ���
typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;  		//�ṹ���С
    BYTE     byPublishPercent; 	//�����ٷֱ� 0-100
    BYTE     byPublishStatus; 	//����״̬  0-�����ɹ� 1--���ڷ��� 2--�ȴ� 3-������FTP  4--û���ҵ����ļ� 5--����ʧ�ܣ��������
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;

//ɾ����ͼ���е��ļ�
typedef  struct  tagNET_DVR_BACKGROUND_PIC_COND
{
	DWORD    dwSize;
    char     szFileID[MAX_ID_LEN_128/*128*/];		//�ϴ�֮���豸������ļ�ID, ָ����ͼƬ��
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_COND, *LPNET_DVR_BACKGROUND_PIC_COND;

//��ѯ����ͼƬ�ļ�
typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
	DWORD    dwSize;                         //�ṹ���С
    DWORD	 dwPicSize;  //����ͼƬ��С
    DWORD	 dwPicType;   //ͼƬ���ͣ�YUV:0 JPEG:1
    WORD     wPicWidth;   //ͼƬ��
    WORD     wPicHeight;    //ͼƬ��
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;                              //�ṹ���С
	BYTE    byEnable;             //�Ƿ����ñ���ͼƬ���ӣ�0-��1-��
	BYTE    byRes1[3];
	BYTE    byPicID[MAX_ID_LEN_128/*128*/];
	BYTE    byRes[300];         //����
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;


//�ϴ�����ͼƬ�ļ�
typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
	DWORD       dwSize;
	DWORD		dwChannel; //����ͨ��
	DWORD		dwPicSize;  //����ͼƬ��С
	WORD    	wPicWidth;   //ͼƬ��
	WORD   	    wPicHeight;    //ͼƬ��
	char      	szPicName[MAX_PIC_NAME_LEN/*128*/];   //ͼƬ���
    BYTE		byPicType;   //ͼƬ���ͣ�YUV:0 JPEG:1
    BYTE		byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;

//�͹�������
typedef	struct tagNET_DVR_LOWPOWER
{
	DWORD		dwSize;//�ṹ���С
	BYTE  		byMode;//�����ģʽ 0-�ֶ���1-��ʱ
	BYTE        byEnabled;//�ֶ�ģʽ�µ�ʹ�ܿ��� 0-�رգ�1-����
	BYTE        byRes[6];
	NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���
	BYTE        byRes1[256];
}NET_DVR_LOWPOWER,*LPNET_DVR_LOWPOWER;

typedef struct tagNET_DVR_POINT
{
	DWORD dwX;	//X�����
	DWORD dwY;	//Y���
}NET_DVR_POINT, *LPNET_DVR_POINT;

//�䱶��������
typedef	struct tagNET_DVR_ZOOMLINKAGE
{
	DWORD		dwSize;//�ṹ���С
	BYTE  		byEnable;//ʹ�� 0-�أ�1-��
	BYTE       byRes[255];
}NET_DVR_ZOOMLINKAGE,*LPNET_DVR_ZOOMLINKAGE;

typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-δ��ʼ��,1-������,2-��ɹ�,3-�����Բ�ƥ��,4-дfalshʧ��,5-�����Ͳ�ƥ��,6-��汾��ƥ��,7-���粻�ɴ�,8-�����������,
							//9-��ȡ����ļ�����,10-û���ҵ����ļ�,11-���ļ��д�,12-�豸�ڴ治��,0xff-δ֪����
    BYTE    byProgress; //����,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;

typedef	struct tagNET_DVR_FIRMWARECODE_COND
{
    DWORD  dwSize;
    DWORD  dwStartIndex;	//��ʼ�����
    DWORD  dwMaxNum;	//����������32
    BYTE   byRes[52];
}NET_DVR_FIRMWARECODE_COND,*LPNET_DVR_FIRMWARECODE_COND;

typedef	struct	tagNET_DVR_FIRMWARECODE
{
    WORD  wIndex;
    WORD  wCodeLen;	//ʶ���볤�ȣ��ϲ�Ӧ�ÿ�����ʱ����һ���жϣ�����ֶδ���128���뱨�?��ʾ�û����¹���/�ͻ��˰汾
    BYTE  byCode[MAX_IDCODE_LEN];//ʶ����
    BYTE  byVersion[MAX_VERSIIN_LEN];//�汾
    BYTE  byRes[12];
}NET_DVR_FIRMWARECODE,*LPNET_DVR_FIRMWARECODE;

typedef	struct	tagNET_DVR_FIRMWARECODE_LIST
{
    DWORD  dwSize;
    DWORD  dwValidCodeNum;	//��Ч����
    NET_DVR_FIRMWARECODE  struCode[MAX_IDCODE_NUM];
    BYTE   byRes[64];
}NET_DVR_FIRMWARECODE_LIST,*LPNET_DVR_FIRMWARECODE_LIST;

typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-δ����,1-������
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //�Ƿ���Ҫ�ӷ�������⣬0-����Ҫ���������豸�����Լ��Ľ��;1-��Ҫ���豸�ἴʱ���ӷ���������Ƿ����°汾
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //�Ƿ����°汾,0-��,1-��
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //�°汾�İ汾��
    BYTE   byChangeLog[SDK_LEN_2048];  //�°汾���µ�����
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN];
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //�Ƽ���,0-��,1-��
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;

//��ʪ������
typedef	struct tagNET_DVR_THSCREEN
{
	DWORD  dwSize;//�ṹ���С
    BYTE   byEnable;//���ö�ʱʹ��
	BYTE   byTHOSDDisplay;//��ʪ����ʾOSD��ʾ�Ƿ�����,  0-��1-��
	BYTE   byRes[2]; // �����ֽ�
	NET_VCA_POINT   struTHOSDPoint;//��ʪ����ʾOSD��ʾ���Ͻ����
	BYTE   byTimingMode;//Уʱģʽ 0-�ֶ���1-�Զ�
	BYTE   byRes1;
	WORD   wInterval;//Уʱ��ʱģʽ�£����ʱ������[1,10080]m
	BYTE   byRes2[254];
}NET_DVR_THSCREEN,*LPNET_DVR_THSCREEN;

typedef	struct tagNET_DVR_SENSOR_ADJUSTMENT
{
    DWORD		dwSize;//�ṹ���С
    BYTE     byType;//����ģʽ��0-���£�1-����
    BYTE     bySensorNo;//Sensor ��[1,8]
    BYTE     byRes[2];
    int     iAdjustMentRange;//������ [-100,100]
    BYTE     byRes1[128];
}NET_DVR_SENSOR_ADJUSTMENT,*LPNET_DVR_SENSOR_ADJUSTMENT;

typedef	struct tagNET_DVR_PANORAMAIMAGE
{
    DWORD		dwSize;//�ṹ���С
    BYTE     byFusionMode;//ģʽ��0-ԭʼͼ��1-ȫ��ͼ��
    BYTE     byRes[127];
}NET_DVR_PANORAMAIMAGE,*LPNET_DVR_PANORAMAIMAGE;

typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD	    dwSize;//�ṹ���С
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];	 //�ӹ��豸�ĵ�ַ
    WORD        wPort ;                 //�豸�˿ں�
    BYTE        byRes[254] ;            //����
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
	DWORD dwSize;
	BYTE byEnabled;		//�Ƿ����û�������0-��1-��
	BYTE byRes1[3];
	NET_DVR_POINT struRegion[RECT_POINT_NUM];	//�������򣬾��Σ���ʼ��Ϊ���½ǣ�˳ʱ�뷽��
	DWORD dwOutputWidth;	//������ڻ�׼�?ֻ�ܻ�ȡ
	DWORD dwOutputHeight;	//������ڻ�׼�ߣ�ֻ�ܻ�ȡ
	BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
	DWORD dwSize;
	BYTE  byAnswerType; //���������Ӧ��ʽ��1-�Զ�����2-�Զ��ܽӣ�3-�ֶ�����
	BYTE  byProtocolType;	//ʹ�õ�Э�����ͣ�1-SIP��2-H232
	BYTE  byRes[30];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    BYTE byRes[128];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;     //�Ƿ�����0-��1-��
    BYTE byVolume;   //�������Ǿ���ʱ��Ч��1-100
    BYTE byAudioInputDisabled;  //��ֹ��Ƶ���룬0-������Ƶ���룬1-��ֹ��Ƶ����
    BYTE byAudioInputVolume;    //��Ƶ����������������Ƶ����ʱ��Ч��1-100
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef union tagNET_DVR_TERMINAL_DETAIL_CTRL_PARAM
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struCallInfo;
    NET_DVR_TERMINAL_AUDIO_CTRL struAudioCtrl;
}NET_DVR_TERMINAL_DETAIL_CTRL_PARAM, *LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;	//�������ͣ�1-����2-�ܽӣ�3-���У�4-��Ƶ����
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;   //������Ʋ���
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //������ʶ��
    NET_DVR_TIME struStartTime; //������ʼʱ��
    NET_DVR_TIME struEndTime;   //��������ʱ��
    BYTE byCallType;    //�������ͣ�1-�ѽӣ�2-δ�ӣ�3-�Ѳ���4-��������
    BYTE byRes1[3];
    DWORD dwMaxResults; //���β�����෵�ظ���
    DWORD dwSearchPos;  //������ʼ����
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;    //�������ͣ�1-�ѽӣ�2-δ�ӣ�3-�Ѳ�
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN]; //�ն���
    BYTE byAddressURL[MAX_URL_LEN]; //�Զ�URL��ַ
    NET_DVR_TIME struStartTime; //���п�ʼʱ��
    NET_DVR_TIME struEndTime;   //���н���ʱ��
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef enum tagCALL_QUERY_RESULT_STATUS
{
	CALL_QUERY_RESULT_OK = 0,     //�ɹ���ѯ����
	CALL_QUERY_RESULT_FAIL,       //��ѯʧ�ܣ�δ֪����
	CALL_QUERY_RESULT_MORE,     //�ɹ���ѯ ���и��û�з���
	CALL_QUERY_RESULT_NOMATCH,  //û�в�ѯ��ƥ���
	CALL_QUERY_RESULT_PARAMERROR,  //��ѯ�����������
	CALL_QUERY_RESULT_INVALIDTIME,   //��ѯ����ʱ����Ч
	CALL_QUERY_RESULT_TIMEOUT,   //��ѯ��ʱ
}CALL_QUERY_RESULT_STATUS;

typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //������ʶ��
	BYTE   byStatus;  //��ѯ״̬  �ο�CALL_QUERY_RESULT_STATUS�ṹ��
	BYTE   byRes[3];  //����
    DWORD dwCount; //ʵ�ʲ�ѯ���Ľ�����
    BYTE *pResults; //������ݣ�dwCount��NET_DVR_CALL_QUERY_SINGLE,��Ҫ������Ԥ�ȷ������ڴ�
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN]; //����ID
    BYTE byConferenceName[NAME_LEN];	//�������
    NET_DVR_TIME struStartTime;		//���鿪ʼʱ��
    NET_DVR_TIME struEndTime;		//�������ʱ��
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;

typedef union tagNET_DVR_CALL_INFO
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struTerminalCallInfo;  //�ն˵�Ե������Ϣ
    NET_DVR_CONFERENCE_CALL_INFO struConferenceCallInfo;  //���������Ϣ
}NET_DVR_CALL_INFO, *LPNET_DVR_CALL_INFO;

typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
	DWORD dwSize;
	BYTE  byAlarmType;              //�������ͣ�1-������У� 2-����״̬�л�
	BYTE  byCallType;               //�������ͣ���������Ϊ1ʱ��Ч��1-�ն˵�Ե���У�2-�������
	BYTE  byAutoAnswer;	            //�Ƿ����Զ�����0-��1-��
	BYTE  byCallStatusSwitch;       //����״̬�л����ͣ�����������Ϊ2ʱ��Ч��1-��ʼ���У�2-���гɹ���3-���н���4-�Զ˹Ҷ�
	NET_DVR_CALL_INFO struCallInfo; //������Ϣ
    BYTE  byRes2[32];
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;    //��Ϊ��Ƶ�������������ڱ��
    BYTE  byRes[32];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;    //�Ƿ�����0-��1-��
    BYTE byVolume;  //����������1-100���Ǿ���ʱ��Ч
    BYTE byAudioInputDisabled;  //������Ƶ���룬0-��1-��
    BYTE byAudioInputVolume; //��Ƶ����������1-100��������Ƶ����ʱ��Ч
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState; //����״̬��0-���У�1-æµ�������У���2-�����У�3-��������
    BYTE byConferenceType;  //�������ͣ�1-��Ե㣬2-MCU�������
    BYTE byRes1[2];
    DWORD dwInputNo;   //ʹ�õ���Ƶ����ں�
    NET_DVR_CALL_INFO struCallInfo; //������Ϣ
    NET_DVR_AUDIO_STATUS struAudioStatus;   //��Ƶ���״̬
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

//���������ο��ز���
typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
	DWORD dwSize;
	BYTE  byEnableRoam;	//�Ƿ����?�����Σ�0-�񣬷�0-��
	BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE byEnableZoom;  //�Ƿ����ţ�0-��1-��
    BYTE byAutoCutBlackEdge;  //�Ƿ��Զ��ü��ڱߣ�0-��1-��
    BYTE byRes1[2];
    WORD wLEDWidth;     //�ֱ��ʿ�
    WORD wLEDHeight;    //�ֱ��ʸ�
    DWORD dwRefreshRate;	//ˢ��Ƶ��
    DWORD dwInputNO;    //����������ͨ����
    BYTE byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //�Ƿ�ʹ�ܣ�0-��1-��
    BYTE  byRes1[3];
    DWORD dwPortNum;    //��Ķ˿ڸ���
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM];     //��Ķ˿ں�
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //�к�
    WORD wColumn; //�к�
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo;  //��ʾ�������ʼλ��(���տ����к�)
    WORD    wWidth;     //������տ���
    WORD    wHeight;    //������տ���
    WORD 	wRecvCardWidth;   //���տ���ȴ�С��Ϊ0��ʹ�ö˿ڲ����н��տ���С����
    WORD    wRecvCardHeigt;   //���տ��߶ȴ�С��Ϊ0��ʹ�ö˿ڲ����н��տ���С����
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //���տ�λ��
    WORD wRecvCardWidth;   //���տ���ȴ�С
    WORD wRecvCardHeigt;   //���տ��߶ȴ�С
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;	//�Ƿ����ö˿ڱ��ݣ�0-��1-��
    BYTE byPortMode; //�˿�ģʽ��1-���ڣ�2-���ݿ�
    BYTE byRes1[2];
    DWORD dwPairPort; //��Զ˿ںţ����˿�Ϊ����ʱ���˲���Ϊ���ݿڶ˿ںţ����˿�Ϊ���ݿ�ʱ���˲���Ϊ���ڶ˿ں�
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //�Ƿ����øö˿ڣ�0-��1-��
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup;	//�˿ڱ��ݲ���
    DWORD dwRecvCardNum;   //���˿����ӵĽ��տ���
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM];   //�����տ�����Ϣ
    DWORD dwPortNo; //�˿ںţ���ȡ���ж˿ڲ���ʱ��Ч
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp;    //ɫ�²���
    NET_DVR_VIDEO_OUT_CFG struVoutCfg;        //��ʾЧ�����
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;		//�Ƿ����ò����źţ�0-�����ã�1-����
    BYTE bySignalType;	//�����ź����ͣ�1-������2-���ƣ�3-��״������4-����5-ˮƽ�ʹ�ֱ�ҽ������壬6-���̣�0xff-�Զ�����ɫ
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor;	//�����ź���ɫ�������ź�����Ϊ0xffʱ��Ч
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode;	//���ź���ʾģʽ��1-������2-��ʾ����LOGO��3-��ʾ�Զ���ͼƬ
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;	//����ֱ��ʿ?ֻ��
    DWORD dwResolutionHeight;	//����ֱ��ʸߣ�ֻ��
    DWORD dwRefreshRate;		//�����ź�ˢ��Ƶ�ʣ�ֻ��
    NET_DVR_SCREEN_VGA_CFG struVgaCfg;	//VGA�źŵ������VGA����ʱ�ɵ�
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;	//������
    NET_DVR_LINE_COLUMN_INFO struPosStart; //���տ���ʼλ��
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //���տ�����λ��
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];	//GAMMA��Yȡֵ��ÿ��Ԫ��ȡֵ0-65535
    BYTE byRes[128];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;	//����ʱ��dclkƵ�ʣ�ʵ��ֵ��10����λ��MHz��ʵ��ֵ��Χ1.0-31.3
    DWORD dwGclkRate;	//ˢ��ʱ��gclkƵ�ʣ�ʵ��ֵ��10����λ��MHz��ʵ��ֵ��Χ1.0-31.3
    DWORD dwGclkCountNum;	//300ns gclk����ֵ
    BYTE  byDclkDutyRatio;	//dclkʱ��ռ�ձȣ�ȡֵ��25��50��75
    BYTE  byDclkPhase;	//dclk��λ��ȡֵ��0,1,2,3
    BYTE  byGclkNum;	//ˢ��1����Ҫ����Чgclk����0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;	//ʱ����ز���
    BYTE byGrayLevel;	//�Ҷȵȼ���ȡֵ13��14
    BYTE byRefreshRate;	//ˢ�±��ʣ�ȡֵ1-6
    BYTE byLineScanNum;	//��ɨ��0-255
    BYTE byRefreshCompleteGrayNum; //ˢ������ҽ���0-255
    DWORD dwHBlank;		//������ʱ�䣬��λ��gclkʱ�Ӹ���ȡֵ1-65535
    DWORD dwAfterglowCtrl;	//���Ϳ��ƽ���ʱ�䣬��λ��gclkʱ�Ӹ���ȡֵ1-65535
    DWORD dwLineFeedTime;	//����ʱ�䣬��λ��gclkʱ�Ӹ���ȡֵ1-65535
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;		//оƬ1���ֽ�
	BYTE byChip1Low;		//оƬ1���ֽ�
	BYTE byChip2High;		//оƬ2���ֽ�
	BYTE byChip2Low;		//оƬ2���ֽ�
	BYTE byChip3High;		//оƬ3���ֽ�
	BYTE byChip3Low;		//оƬ3���ֽ�
	BYTE byRes[10];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;	//�¹�Ӱ���ȼ���0-5
    BYTE byEliminateShadowy;			//��һɨƫ�����ȼ���0-15
    BYTE byGrayEqualize1;				//�ͻ�ƫɫ����1��0-3
    BYTE byGrayEqualize2;				//�ͻ�ƫɫ����2��0-15
    BYTE byEnableGrayUniformity;		//�ͻҾ����������Ƿ�����0-�أ�1-��
    BYTE byDisableHGrayStripes;		    //�ͻҺ���������Ƿ�����0-�أ�1-��
    BYTE byGhostShadowEnhancedMode1;	//�¹�Ӱ�����ǿģʽ1�Ƿ�����0-�أ�1-��
    BYTE byGhostShadowEnhancedMode2;	//�¹�Ӱ�����ǿģʽ2�Ƿ�����0-�أ�1-��
    BYTE byClearBadPoint;				//ȥ���ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE byEnableSelfDefineRegistor;	//�Ƿ������Զ���Ĵ���ֵ��0-��1-��
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue;	//�Զ���Ĵ�������
    BYTE byRes[32];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
	DWORD dwSize;
	NET_DVR_LED_RECV_REGISTOR struFirstRegistor;	//��һ����տ��߼������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
	NET_DVR_LED_RECV_REGISTOR struSecondRegistor;	//�ڶ�����տ��߼������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
	NET_DVR_LED_RECV_REGISTOR struThirdRegistor;	//��������տ��߼������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
	BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

//��ѯ��ʽ
enum  ADDR_QUERY_TYPE
{
    QUERYSVR_BY_COUNTRYID = 0,	//����ұ�Ų�ѯ��������ַ
    QUERYDEV_BY_NICKNAME_DDNS = 2, //���ǳƴ�hiDDNS�ϲ�ѯ�豸��Ϣ
    QUERYDEV_BY_SERIAL_DDNS = 3,	//�����кŴ�hiDDNS�ϲ�ѯ�豸��Ϣ
    CHECKDEV_BY_NICKNAME_DDNS = 4,//���ǳƴ�hiDDNS����豸��Ϣ
    CHECKDEV_BY_SERIAL_DDNS = 5,	//�����кŴ�hiDDNS����豸��Ϣ
    QUERYDEV_BY_NICKNAME_IPSERVER = 6, //���ǳƴ�IPServer�ϲ�ѯ�豸��Ϣ
    QUERYDEV_BY_SERIAL_IPSERVER = 7	//���ǳƴ�IPServer�ϲ�ѯ�豸��Ϣ
};
#define	CLIENT_VERSION_LEN	64
//����ұ�Ų�ѯ�������ṹ��
typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD	wCountryID;	//��ұ��,ȡֵ����һ
    char	szSvrAddr[MAX_DOMAIN_NAME];//��������ַ,��ʾȥ�ĸ��������ϲ�ѯĿ�����������Ϣ
    char	szClientVersion[CLIENT_VERSION_LEN];//�ͻ��˰汾��Ϣ,����:iVMS4500 V4.0.0.0 build20150112
    BYTE	byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;

//����ұ�Ų�ѯ�ķ��ؽṹ��
typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char	szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ(���豸ע�������)
    char	szAlarmSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    BYTE	byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

//��hiDDNS�ϲ�ѯ����ϵ������ṹ��
typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char	szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    char	szDevNickName[MAX_DOMAIN_NAME];	//�豸�ڽ����������ϵı���
    char	szDevSerial[SERIALNO_LEN];	//�豸���к�
    char	szClientVersion[CLIENT_VERSION_LEN];//�ͻ��˰汾��Ϣ,����:iVMS4500 V4.0.0.0 build20150112
    BYTE	byRes[272];		//����
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;
#define SDK_MAX_IP_LEN 48
//��hiDDNS�ϲ�ѯ���صĽṹ��
typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char	szDevIP[SDK_MAX_IP_LEN];	//�豸IP��ַ
    WORD	wCmdPort;		//���ƶ˿ڣ�SDK���Ӷ˿ڣ�
    WORD	wHttpPort;		//http�˿�
    BYTE	byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;

//��hiDDNS����Ϸ��صĽṹ��
typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE	byDevStatus;		//�豸״̬,0-��,1-�Ҳ���,2-�豸������,3-�豸���ڵ�ǰ����
    BYTE	byRes1;
    NET_DVR_QUERY_DDNS_RET	struQueryRet;	//��ַ��Ϣ
    WORD	wRegionID;		//��ǰ�豸ע��������[1����,2����,3��̫,4�й�,5ŷ��,6����]
    BYTE	byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

//��IPServer�ϲ�ѯ�������ṹ��
typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char	szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    WORD	wResolveSvrPort;	//�����������˿�
    char	szDevNickName[MAX_DOMAIN_NAME];	//�豸�ڽ����������ϵı���
    char	szDevSerial[SERIALNO_LEN];	//�豸���к�
    BYTE	byRes[334];		//����
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

//��IPServer�ϲ�ѯ���صĽṹ��
typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char	szDevIP[SDK_MAX_IP_LEN];	//�豸IP��ַ
    WORD	wCmdPort;		//���ƶ˿ڣ�SDK���Ӷ˿ڣ�
    BYTE	byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //ͨ����
    BYTE   byres[32];                    //����
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;

//�������������ṹ
typedef	struct tagNET_DVR_STREAMENCRYPTION_COND
{
	DWORD	dwSize;  //�ṹ���С
    DWORD   dwChan;  //Ԥ��ͨ����
	BYTE	byRes[128];
}NET_DVR_STREAMENCRYPTION_COND, *LPNET_DVR_STREAMENCRYPTION_COND;

//����������Ϣ�ṹ
typedef	struct tagNET_DVR_STREAMENCRYPTION_CFG
{
	DWORD	dwSize;    //�ṹ���С
    BYTE    byEnable;  //�����������ܣ�0~�رգ�1~����
	BYTE	byRes[255];
}NET_DVR_STREAMENCRYPTION_CFG, *LPNET_DVR_STREAMENCRYPTION_CFG;

//У׼��GPS��γ�Ȳ���
typedef	struct tagNET_DVR_REVISE_GPS_CFG
{
     DWORD	dwSize;    //�ṹ���С
	 BYTE   byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
	 BYTE   byLongitudeType ;// �������ͣ�0-���ȣ�1-����
     BYTE   byMode ;//ģʽ 0-Ĭ�ϣ�1-�Զ���2-�ֶ�
	 BYTE	byRes;
     NET_DVR_LLI_PARAM	struLatitude;	 /*γ��*/
	 NET_DVR_LLI_PARAM	struLongitude; /*����*/
     BYTE	byRes1[300];
}NET_DVR_REVISE_GPS_CFG, *LPNET_DVR_REVISE_GPS_CFG;

typedef	struct tagNET_DVR_PDC_RECOMMEND
{
    DWORD 	    dwSize;
    WORD        wWidth;//�Ƽ����ֵ[0, 1000]
    BYTE	    byRes[126];
}NET_DVR_PDC_RECOMMEND,*LPNET_DVR_PDC_RECOMMEND;

typedef	struct tagNET_DVR_FLASHSTORAGE_REMOVE
{
    DWORD 	    dwSize;
    DWORD       dwChannel;
    BYTE        byPDCRemoveEnable;//���������ʹ�� 0-�����1-���
    BYTE	    byRes[127];
}NET_DVR_FLASHSTORAGE_REMOVE,*LPNET_DVR_FLASHSTORAGE_REMOVE;

/********************************DS-TME4XX���ƻ� Begin****************************/
typedef struct tagNET_DVR_PARKING_CARD
{
	DWORD  dwSize;
	DWORD  dwChannel;//Ĭ����1��������ݶ�ͨ���豸��
	char  szCardNo[MAX_CARDNO_LEN/*48*/];//����
	BYTE  byCardType;//��Ƭ���� 0-��ʱ����1-�̶���
	BYTE  byCardStatus;//��Ƭ״̬ 0-��1-��ʧ��2-ע��
	BYTE  byChargeRuleID;//�շѹ���ID
    BYTE  byDelete;//�Ƿ�ɾ�� 0-��ɾ��1-ɾ��
    NET_DVR_TIME_V30 struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//��Ч����ʱ��
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

//����ڿ�Ƭ��Ϣ�ϴ�
typedef struct tagNET_DVR_GATE_CARDINFO
{
	DWORD 	dwSize;
	NET_VCA_DEV_INFO struDevInfo;
	DWORD dwRelativeTime; //���ʱ��
	DWORD dwAbsTime; //���ʱ��
	char	szCardNo[MAX_CARDNO_LEN/*48*/];//����
	char	szPassVehicleID[MAX_VEHICLE_ID_LEN];//Ψһ��ʶ
	char	szInVehicleID[MAX_VEHICLE_ID_LEN];//����ʱ�����Ψһ��ʶ
	NET_DVR_TIME_V30  struSwipeTime;//ˢ��ʱ��
	NET_DVR_TIME_V30  struCardTime;//��Ƭ���ʱ�䣬���볡ʱд���ʱ�䣬ֻ�Գ���Ʊ�����ã�0��ʾ���볡ʱ��
    BYTE    byLetPass;//����ڷ��з�ʽ 0-������(��CardType == ֽƱ)��Ҫ�շѣ�1-���У�2-�����շѷ���
	BYTE 	byCardType;//������ 0-�̶�����1-��ʱ����2-ֽƱ
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

//����ڸ�����Ϣ�ϴ�(COMM_GATE_CHARGEINFO_UPLOAD)
typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //���ʱ��
    DWORD dwAbsTime; //���ʱ��
    char  sLicense[MAX_LICENSE_LEN];        //����
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //����Ψһ���ʾ
    char  szEntranceID[32];  //�볡Ψһ���ʾ
    DWORD dwTotalCost;   //ʵ���շѽ��*100
    char  szOperateName[32]; //�ѻ���Ϊ"offline"
    BYTE  byChargeRuleId; //�շѹ���centerId
    BYTE  byVehicleType;//�������ͣ�0-��������1-С�ͳ���2-���ͳ�
    BYTE  byRes[127];//Ԥ��
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

//ͣ����ͣ�������ƽṹ��
typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
	DWORD  dwSize;
	DWORD  dwChannel; //ͨ����
	BYTE  byCardType;//��Ƭ���� 0-��ʱ��
	BYTE  byDeleteALL;//�Ƿ�ȫ��ɾ�� 0-��ɾ��1-ɾ��
	BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;

//TME����ץͼ�ϴ�
typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //������1��32��������ţ�������Ծ��
    BYTE    byCamLaneId; //��Ӧ������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byRes1; //����
    DWORD   dwChanIndex; //ͨ����
    NET_DVR_PLATE_INFO  struPlateInfo; //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE    byMonitoringSiteID[48]; //������
    BYTE    byDeviceID[48]; //�豸���
    BYTE    byDir;     //��ⷽ��0-���� 1 �볡��2 ����
    BYTE    byRes2;
    WORD    wBackList; //���Ϊ�Ƿ񱨾���� 0 ��ʾΪ������  1 ��ʾ����
    DWORD   dwPicNum; //ͼƬ��������picGroupNum��ͬ����?����Ϣ�����ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����
    NET_ITS_PICTURE_INFO struPicInfo[4];  //ͼƬ��Ϣ,�ݶ����4��ͼ
    BYTE    byPassVehicleID[32];    //����ΨһID
    BYTE    byCardNo[48]; // ����
    BYTE    bySwipeTime[32];//����ˢ��ʱ��  ʱ���ʽΪyyyymmddhh24missfff
    DWORD   dwCharge;      //�շѽ�� ���֣�
    BYTE    byHistory;     //�Ƿ�����ʷ���  0-��  1-��
    BYTE    byLetPass;     //�Ƿ��ѷ��У�0-δ���У�1-����  2-δ֪
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

//������Ϣͬ��
typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//Ĭ����1��������ݶ�ͨ���豸��
    char    szLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//��������
    NET_DVR_TIME_V30 struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//��Ч����ʱ��
    BYTE    byVehicleType;//�������ͣ�0-��������1-С�ͳ���2-���ͳ�
    BYTE    byPlateColor;//������ɫ���ο� VCA_PLATE_COLOR
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;

//�ɷѽ����Ϣ
typedef	struct tagNET_DVR_CHARGEACCOUNT_CFG
{
    DWORD   dwSize;//�ṹ���С
    float   fAccount;//ʵ���շѽ��
    BYTE    byRes[128];
}NET_DVR_CHARGEACCOUNT_CFG,*LPNET_DVR_CHARGEACCOUNT_CFG;

//ͣ����Ʊ������豸��ǶȲ�������
typedef	struct tagNET_DVR_PXMULTICTRL_CFG
{
    DWORD		dwSize;//�ṹ���С
    DWORD		dwMultiChansWaitTime;//��Ƕ�ץ��ƥ��ʱ�䣨1~300s��
    BYTE 		byMultiChansCapEnabled;//�Ƿ����ö�Ƕ�ץ�� 0-��1-��
    BYTE		byRes[127];
}NET_DVR_PXMULTICTRL_CFG,*LPNET_DVR_PXMULTICTRL_CFG;

//ͣ����Ʊ���ѻ��²�������
typedef	struct tagNET_DVR_PXOFFLINE_CFG
{
	DWORD   dwSize;//�ṹ���С
	BYTE    byEnabled;//�Ƿ�����Ʊ���ѻ�ģʽ��0-������ 1-����
	BYTE    byChargeEnabled;//�Ƿ��ѻ��շ� 0-��1-��
	BYTE    byAlarmEnabled;//�Ƿ������ѻ� 0-��1-��
	BYTE    byRecordSource;//��¼�������� 0-��ʶ 1-����
	DWORD   dwTimeWait;//Ʊ������ѻ�ģʽǰ�ĵȴ�ʱ�䣨1-300�룩
	/**
	 realeaseMode&(0x1<<0) �̶�������
	 realeaseMode&(0x1<<1) �̶�������
	 realeaseMode&(0x1<<2) ��ʱ������
	 realeaseMode&(0x1<<3) ��ʱ������
	 realeaseMode&(0x1<<4) �޳��Ʒ���
	 realeaseMode&(0x1<<5) �̶�����������Զ�����
	 realeaseMode&(0x1<<6) ��ʱ����������Զ�����
	*/
	DWORD   dwRealeaseMode; //���з�ʽ����λ��ʾ
	BYTE    byVehCardmatch;//����һ��  0-��1-��
    BYTE    bySingleInSingleOut;//����� 0-��1-��
	BYTE    byRes[126];
}NET_DVR_PXOFFLINE_CFG,*LPNET_DVR_PXOFFLINE_CFG;

typedef	struct tagNET_DVR_PARKINGSAPCE_CFG
{
    DWORD	dwSize;//�ṹ���С
    DWORD 	dwTotalParkingLot;//��ͣ��λ��
    DWORD	dwCurrParkingLot;//��ǰʣ��ͣ��λ��
    BYTE	byRes[128];
}NET_DVR_PARKINGSAPCE_CFG,*LPNET_DVR_PARKINGSAPCE_CFG;

typedef	struct tagNET_DVR_PAPERCHARGEINFO_CFG
{
    DWORD   dwSize;//�ṹ���С
    char    szBarCode[LEN_16];//�����루16λ�ַ�
    char    szLicense[MAX_LICENSE_LEN]; //���ƺ���
    char    szVehicleInTime[LEN_32];//�볡ʱ�䣨32λ�ַ� YYYY-MM-DD HH:MM:SS��
    char    szPaymentTime[LEN_32];//�ɷ�ʱ�䣨32λ�ַ� YYYY-MM-DD HH:MM:SS��
    float   fPaymentAmount;//�ɷѽ��
    DWORD   dwPaymentOutFailureTime;//�ɷѳ���ʧЧʱ�䣨DWORD��
    BYTE    byVehicleOutEnabled; //�Ƿ����: 0- ��1- ��
    BYTE    byRes[128];
}NET_DVR_PAPERCHARGEINFO_CFG,*LPNET_DVR_PAPERCHARGEINFO_CFG;

//ͣ����Ʊ�����
typedef	struct tagNET_DVR_ILLEGALCARDFILTERING_CFG
{
	DWORD   dwSize;//�ṹ���С
    char    sLEDDefaultInfo[MAX_LED_INFO_LEN/*512*/]; // LEDĬ����ʾ����
	BYTE    byillegalCardFilteringEnabled;//���÷Ƿ�������,0~�����ã�1~����
    BYTE    bySendCardSensingCoilEnabled;//�������Ƿ�����ظ���Ȧ
    BYTE    byWiegendSensingCoilEnabled;//Զ���뿨�Ƿ�����ظ���Ȧ
    BYTE    byGateSwitchEnabled; //�Ƿ��е�բ������Ϣ
    BYTE    byVerifyKeyWriteCardEnabled;//�Ƿ���֤��Կ��д��
	BYTE    byRes[127];
}NET_DVR_ILLEGALCARDFILTERING_CFG,*LPNET_DVR_ILLEGALCARDFILTERING_CFG;


//ͣ��������ڳ����շѹ�����������ṹ
typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //ͨ����
    char    szCardNo[32];//����
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;

//LED��Ļ��ʾ����
typedef	struct tagNET_DVR_LEDDISPLAY_CFG
{
    DWORD   dwSize;//�ṹ���С
    char    sDisplayInfo[MAX_LED_INFO_LEN/*512*/]; // LED��ʾ����
    BYTE    byDisplayMode;//��ʾ��ʽ:0~����,1~����,2~������ʾ
    BYTE    bySpeedType;//�ٶ�����:0~��,1~��,2~��
    BYTE    byRes1[2];
    DWORD   dwShowTime;//��ʾʱ����1~60��
    BYTE    byRes[128];
}NET_DVR_LEDDISPLAY_CFG,*LPNET_DVR_LEDDISPLAY_CFG;

//�����������Ʋ���
typedef	struct tagNET_DVR_VOICEBROADCAST_CFG
{
    DWORD		dwSize;//�ṹ���С
    char        sInfo[MAX_VOICE_INFO_LEN/*128*/]; //������������
    BYTE		byRes[128];
}NET_DVR_VOICEBROADCAST_CFG,*LPNET_DVR_VOICEBROADCAST_CFG;

//ֽƱ��ӡ��ʽ����
typedef	struct tagNET_DVR_PAPERPRINTFORMAT_CFG
{
    DWORD		dwSize;//�ṹ���С
    char        sTitleInfo[MAX_LITLE_INFO_LEN/*64*/]; //ֽƱ��������
    char        sCustomInfo[MAX_CUSTOM_INFO_LEN/*64*/]; //ֽƱ�Զ�����Ϣ����
    char        sPhoneNum[MAX_PHONE_NUM_LEN/*16*/];//��ϵ�绰
    BYTE        byPrintInTimeEnabled; //�Ƿ��ӡ�볡ʱ��
    BYTE		byRes[127];
}NET_DVR_PAPERPRINTFORMAT_CFG,*LPNET_DVR_PAPERPRINTFORMAT_CFG;


//������բʱ���
typedef	struct tagNET_DVR_LOCKGATE_TIME_CFG
{
    char        sBeginTime[LEN_32];//��ʼʱ�䣨32λ�ַ� HH:MM:SS��
    char        sEndTime[LEN_32];//����ʱ�䣨32λ�ַ� HH:MM:SS��
    BYTE		byRes[64];
}NET_DVR_LOCKGATE_TIME_CFG,*LPNET_DVR_LOCKGATE_TIME_CFG;

//������բ����
typedef	struct tagNET_DVR_LOCKGATE_CFG
{
    DWORD		dwSize;//�ṹ���С
    NET_DVR_LOCKGATE_TIME_CFG struTime[LOCKGATE_TIME_NUM]; //������բʱ���
    BYTE		byRes[128];
}NET_DVR_LOCKGATE_CFG,*LPNET_DVR_LOCKGATE_CFG;

//���ͬ��״̬
typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//Ӧ�����к�, ��?ǰ�����ӵ�Ӧ��
    DWORD   dwParkingNum; //��ǰͣ������
    DWORD   dwUpdataSerialNum; //�������к�; ��������µ����кš�
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;

//����EPTZ����
typedef	struct tagNET_DVR_EPTZ_CFG
{
    DWORD dwSize;
    BYTE    byEnableEPTZ;        //�Ƿ�����EPTZ, 0-�����ã�1 -����
    BYTE	byRes[503];
}NET_DVR_EPTZ_CFG, *LPNET_DVR_EPTZ_CFG;

//���ĵ����
typedef	struct tagNET_DVR_CENTER_POINT_CFG
{
    DWORD dwSize;
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE	byRes[512];
}NET_DVR_CENTER_POINT_CFG, *LPNET_DVR_CENTER_POINT_CFG;

/********************************DS-TME4XX���ƻ� End****************************/

//WEP������Կ
typedef struct tagNET_DVR_WEP_KEY_CFG
{
	char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//������Կ��
    BYTE	byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;


//WEP����
typedef struct tagNET_DVR_WEP_CFG
{
	BYTE   byAuthenticationType;//�����֤���ͣ�0~������֤��1~������Կ��2~�Զ���֤
	BYTE   byDefaultTransmitKeyIndex;//Ĭ�ϴ�����Կ����1~4������Ӧ��struEncryptionKeyCfg������Կ�ĸ���
	/*
	��Ϊ64λ��Կʱ��ASCII����Կ�ַ��Ϊ5����
	��Ϊ128λ��Կʱ��ASCII����Կ�ַ��Ϊ13����
	*/
	BYTE   byWepKeyLenType;//��Կ���ͣ�0~   64λ��Կ��1~  128λ��Կ��
	BYTE   byKeyType;// ��Կ���ͣ�0~   ASCII�룬1~  16���ơ�
	NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP������Կ�����֧��4����
	BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

//WPA����
typedef struct tagNET_DVR_WPA_CFG
{
	BYTE   byAlgorithmType; //�㷨���ͣ�0~TKIP, 1~AES, 2~TKIP/AES
	BYTE   byWPAKeyLen;// WPA������Կ���ȣ����Ϊ8~63����Ӧ��csSharedKey������ַ��
	BYTE   byDefaultPassword;//�Ƿ�����Ĭ��WPA��Կ
	BYTE   byRes1;
	char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//WPA������Կ,Ϊ8-63��ASCII�ַ�
	BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;


typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
	BYTE   bySecurityMode; //��ȫģʽ��0~����,1~WEP,2~WPA-personal, 3~WPA2-personal
	NET_DVR_WEP_CFG  struWEPCfg; //����ȫģʽѡ��ΪWEPʱ��Ч��
	NET_DVR_WPA_CFG  struWPACfg; //����ȫģʽѡ��ΪWPA-personal��WPA2-personalʱ��Ч��
	BYTE	byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

//wifi�ȵ��������(�����)
typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD	dwSize;//�ṹ���С
    BYTE	byWifiAPEnabled;  //�Ƿ���������AP��0-��1- ��
    BYTE    byBroadcastEnabled; // �Ƿ����ù㲥��0-��1-��
    BYTE    byWlanShareEnabled; //�Ƿ����ù��?0-��1-��
    BYTE    byDHCPEnabled; //�Ƿ�����DHCP��0-��1-��
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType; //IP��ַ���ͣ�0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr;  //IP��ַ
    NET_DVR_IPADDR    struIPMask;  //�����ַ
    NET_DVR_IPADDR    struGatewayIPMask;  //��ص�ַ
    NET_DVR_IPADDR    struStartIPAddrPool;  //IP����ʼ��ַ
    NET_DVR_IPADDR    struEndIPAddrPool;  // IP�ν����ַ
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS��ַ
	NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg;//���߰�ȫ���ܲ���
    BYTE	byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;	//ͨ���ţ�0Ϊ��Ч
	BYTE byChannelName[NAME_LEN];
    BYTE bySignal;  //�Ƿ����źţ�0-�ޣ�1-�У�ֻ��
    BYTE bySignalType;  //�ź�Դ���ͣ�1-���壬2-���壬���ź�ʱ��Ч��ֻ��
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;	//�Ƿ���Ч��0-��Ч��1-��Ч
	BYTE  byRes1[3];
	DWORD dwDevNo;	//��˻��
    BYTE  byDevName[NAME_LEN];   //�ڵ��˻����
    BYTE  byDevID[MAX_ID_LEN];   //��˻�����ID���豸Ψһ��ʶ��ֻ��
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM];
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

#define MAX_OPTICAL_DEV_NODE 32     //���ڵ��˻���

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //�Ƿ����źŽ��룬0-�ޣ�1-�У�ֻ��
    BYTE  byLinkType;    //��·���ͣ�1-����2-����ֻ��
    BYTE  byPortWorkMode;    //�˿ڹ���ģʽ��0-��Ч��1-���ڣ�2-���ڣ�����·����Ϊ����ʱ��Ч��ֻ��
	BYTE  byRes1[1];
	DWORD dwPairPort;	//��Թ�ںţ���·����Ϊ����ʱ��Ч������ʱ�˲���Ϊ���ںţ�����ʱ���˲���Ϊ���ں�
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //�ڵ��˻��豸��Ϣ
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
	DWORD dwSize;
	BYTE  byEnable;	//�Ƿ������˻����룬0-�񣬷�0-��
	BYTE  byRes1[3];
	DWORD dwDevNo;	//��˻��
    DWORD dwOpticalPort;  //��ں�
	BYTE  byDevID[MAX_ID_LEN];   //��˻�����ID
    DWORD dwInputChanNo;  //��˻�����ͨ����
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;

typedef  struct tagNET_DVR_START_FILE_TO_CLOUD_COND
{
    DWORD	dwSize;
    BYTE	aCameraID[MAX_CAMERAID_LEN];	//������ID
    DWORD  	dwPoolID;	//�洢��ID
    DWORD  	dwRepPoolID;	//�����ID
    WORD  	wReplication;	//�������
    BYTE   	byRes [178];
}NET_DVR_START_FILE_TO_CLOUD_COND,*LPNET_DVR_START_FILE_TO_CLOUD_COND;

typedef  struct 	tagNET_DVR_START_PICTURE_FROM_CLOUD_COND
{
    DWORD       dwSize;
    BYTE        aCameraID[MAX_CAMERAID_LEN];	//������ID
    NET_DVR_TIME_V30    struBeginTime;	//��ʼʱ��
    NET_DVR_TIME_V30    struEndTime;		//����ʱ��
    DWORD   dwPicType;		//ͼƬ���ͣ���λ��ʾ
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    BYTE    byRes1[3];
    BYTE    byZoomType;	//0-������,1-������,2-����С,3-���ֱ���
    union
    {
        BYTE    uLen[32];
        struct
        {
            BYTE        byScale; 		//1~99
        }struScale;
        struct
        {
            BYTE        byQuality;	//1~99
        }struQuality;
        struct
        {
            DWORD       dwWidth;
            DWORD       dwHeight;
        }struResolution; //Ŀ��ֱ���
    }uZoomParam;
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;	//��ݻص�����
    void*   pUser;	//�û����ָ��
    BYTE    byRes [372];
}NET_DVR_START_PICTURE_FROM_CLOUD_COND,*LPNET_DVR_START_PICTURE_FROM_CLOUD_COND;

typedef 	struct	tagNET_DVR_START_PICTURE_FROM_CLOUD_RET
{
    DWORD       dwSize;
    DWORD       dwFileCount;	//�ļ�����
    BYTE        byRes[120];
}NET_DVR_START_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_START_PICTURE_FROM_CLOUD_RET;

typedef  struct
{
    DWORD       dwSize;
    NET_DVR_TIME_V30    struTime;	//ͼƬʱ��
    DWORD       dwPicLen;	//ͼƬ����
    BYTE        byPicType;	//ͼƬ��ʽ,1-jpg,2-bmp,3-png
    BYTE        byRes[107];
}NET_DVR_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_PICTURE_FROM_CLOUD_RET;

typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //���֤��Ϣ�ϱ���0���ϴ�18λ���֤�ţ�1���ϴ�ȫ����Ϣ
    BYTE byRes1;
    BYTE byCardVerifyMode; //ˢ����֤ģʽ��0��Զ��������֤��1���ͻ���ƽ̨��֤
    BYTE byACSDevType; //�豸�ͺţ�1�����֤��������2��IC��������3����ά���������4��ָ�ƶ�������5���ַ���+��ά���������6���տ�����7���ַ�����
    BYTE byDoorMode; //�ų������ͣ�0�����ţ�1�����ţ�
    BYTE byRes[303];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;			//����ģʽ��0�ܿأ�1��ֹ��2���ɣ�
    BYTE byOutMode; 		//����ģʽ��0�ܿأ�1��ֹ��2���ɣ�
    BYTE byWorkMode;		//����ģʽ��0������1ά����2���գ�3������
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

#define MAX_ID_NUM_LEN                  32  //������֤�ų���
#define MAX_ID_NAME_LEN                 128   //��������
#define MAX_ID_ADDR_LEN                 280   //���סַ����
#define MAX_ID_ISSUING_AUTHORITY_LEN    128 //���ǩ����س���

//���֤��Ϣ
typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;        //�ṹ����
    BYTE  byName[MAX_ID_NAME_LEN];   //����
    NET_DVR_DATE struBirth; //��������
    BYTE byAddr[MAX_ID_ADDR_LEN];  //סַ
    BYTE byIDNum[MAX_ID_NUM_LEN];   //���֤����
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];  //ǩ�����
    NET_DVR_DATE struStartDate;  //��Ч��ʼ����
    NET_DVR_DATE struEndDate;  //��Ч��ֹ����
    BYTE byTermOfValidity;  //�Ƿ�����Ч�� 0-��1-�ǣ���Ч��ֹ������Ч��
    BYTE   bySex;  //�Ա�1-�У�2-Ů
    BYTE  byNation;    //���壬1-"��"��2-"�ɹ�"��3-"��",4-"��",5-"ά���",6-"��",7-"��",8-"׳",9-"����",10-"����",
    //11-"��",12-"��",13-"��",14-"��",15-"����",16-"����",17-"�����",18-"��",19-"��",20-"����",
    //21-"��",22-"�",23-"��ɽ",24-"����",25-"ˮ",26-"����",27-"����",28-"����",29-"�¶����",30-"��",
    //31-"���Ӷ�",32-"����",33-"Ǽ",34-"����",35-"����",36-"ë��",37-"����",38-"��",39-"����",40-"����",
    //41-"������",42-"ŭ",43-"���α��",44-"����˹",45-"���¿�",46-"�°�",47-"����",48-"ԣ��",49-"��",50-"������",
    //51-"����",52-"���״�",53-"����",54-"�Ű�",55-"���",56-"��ŵ"
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

//���֤��Ϣ����
typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;        //�ṹ����
    NET_DVR_ID_CARD_INFO	struIDCardCfg ;//���֤��Ϣ
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME_V30  struSwipeTime; //ʱ��
    BYTE	byNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR	struRemoteHostAddr ;//Զ�������ַ
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    DWORD dwDoorNo; //�ű�ţ�Ϊ0��Ч
    BYTE byRes[216];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;        //�ṹ����
    DWORD  dwAccessChannel;	//��Աͨ����
    NET_DVR_TIME_V30  struSwipeTime; //ʱ��
    BYTE	byNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR	struRemoteHostAddr ;//Զ�������ַ
    DWORD	dwEntryTimes;	//��Ա�����
    DWORD	dwExitTimes;		//��Ա������
    DWORD	dwTotalTimes;		//��Ա�����ܴ���
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;
typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
	DWORD   dwSize;
	DWORD   dwVideoMangeNo;  //��Ƶ�����
	BYTE    byVideoType;  //��Ƶ��ʽ 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB
	BYTE    byRes1[3];  //����
	BYTE    sVideoName[NAME_LEN];  //��Ƶ���
    NET_DVR_TIME_V30 struTime;  //ͼƬ�ϴ�ʱ��
    BYTE 	byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
	DWORD   dwSize;
	BYTE	sFileName[NAME_LEN];  //�ļ����
	DWORD	dwManageNo;     //(ֻ�ܻ�ȡ)
	NET_DVR_TIME_EX  struTime;    //�ĵ��ϴ�ʱ��
	BYTE	byUsed;          //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-���� ��ֻ�ܻ�ȡ��
	BYTE	byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
	DWORD	dwSize;
	BYTE	byItemType;  //���������ͣ�1-ͼƬ 2-��Ƶ 3-�����б�
	BYTE	byRes[3];    //����
	DWORD	dwPlayManageNo;   //���Ź����
	DWORD	dwPlayPicTime; //����ͼƬʱ�䣬��λ��, (����ΪͼƬ��Ч)
    BYTE    byRes2[64];
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM;

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
	DWORD	dwSize;
	BYTE    byEnable;  //�Ƿ���Ч�� 0-��Ч  !0-��Ч
	BYTE    byPlayType;  //����ģʽ��1-ѭ������
	BYTE    byVaildItemNum;    //��Ч����������
	BYTE    byRes[1];
	NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM]; //�����ǰbyVaildItemNum��Ч
	BYTE     byPlaylistName[PLAYLIST_NAME_LEN];  //�����б����
	DWORD   dwPlaylistNo;    //�����б�ţ���ȡ��Ч��
	BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;
typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
	DWORD	dwSize;
	BYTE	byCtrlType;  //�������ͣ� 1-��Ӳ�����  2-ɾ�����  3-�ƶ�������λ��
	BYTE	byPlayIndex;  //������ţ� ��1��ʼ
	NET_DVR_PLAY_ITEM struPlayItem;	//������
	BYTE   byNewPlayIndex;   //�²�����ţ�0��Ч
    BYTE   byRes[63];
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL;
typedef struct tagNET_DVR_PLAN_ITEM
{
	NET_DVR_PLAY_ITEM struPlanPlayItem;       //������
	NET_DVR_TIME_SEGMENT struTimeSegment;     //ʱ��β���
	BYTE  byRes[16];
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD	dwSize;
    BYTE	byEnable;  //�Ƿ�ʹ��,  0-��ʹ�� !0-ʹ��
	BYTE    byPlanMode;   //�ƻ�ģʽ��1-�ܼƻ�  2-�ռƻ�
    BYTE	byRes[2];
	NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
	DWORD	dwPlayPlanNo;   //���żƻ��ţ���ȡʱ��Ч��
	BYTE	byPlayPlanName[NAME_LEN]; //���żƻ����
    BYTE	byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;
typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
	DWORD dwSize;
	BYTE byEnable;    //�Ƿ����ò��żƻ��� 0-������ !0-����
	BYTE byRes[3];
	DWORD dwPlayPlanNo;   //���żƻ���
	BYTE byRes2[32];
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG;
typedef struct tagNET_DVR_DEV_PLAYCTRL
{
	DWORD   dwSize;
	BYTE    byControlType;  //�������ͣ�1-��Ƶ����2-��Ƶ�أ�3-ֹͣ���ţ�4-��ͣ���ţ��ָ�����
	BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;

typedef union tagNET_DVR_PLAYITEM_INFO
{
	struct   //��������
	{
		DWORD  dwPlayItem;   //������
		BYTE    byPlayItemName[NAME_LEN]; //���������
		BYTE    byRes2[8];
    } struPlayItem;
	struct  //�����б�
	{
		DWORD  dwPlaylistNo;  //�����б��
		BYTE    byPlaylistName[NAME_LEN]; //�����б����
		WORD   wPlayIndex;    //����λ��
		BYTE    byPlayType;    //�����б������ڲ������� 1-ͼƬ 2-��Ƶ
		BYTE    byRes[3];
		DWORD  dwPlayItem;   //������
		BYTE    byPlayItemName[NAME_LEN]; //���������
		BYTE    byRes2[16];
	} struPlaylistItem;
	struct  //���żƻ���
	{
		DWORD  dwPlayPlanNo;  //���żƻ���
        NET_DVR_TIME_SEGMENT struTime;      //���ڲ���ʱ���
		BYTE    byPlayType;  //���żƻ����ڲ�������  1-ͼƬ 2-��Ƶ 3-�����б�
		BYTE    byRes[3];
		DWORD  dwPlaylistNo;  //�����б��
		BYTE    byPlaylistName[NAME_LEN]; //�����б����
		DWORD  dwPlayItem;   //������
		BYTE    byPlayItemName[NAME_LEN]; //���������
		WORD   wPlayIndex;    //����λ��
		BYTE    byRes2[18];
	} struPlayPlanItem;
}NET_DVR_PLAYITEM_INFO, *LPNET_DVR_PLAYITEM_INFO;
typedef struct tagNET_DVR_PLAYING_INFO
{
	DWORD	dwSize;
    BYTE    byPlayWay;   //���ŷ�ʽ�� 1-�����  2-�����б�  3-���żƻ� 4-��̬���� 5-�����岥
    BYTE    byCurPlayType; //���ڲ����ز����ͣ� 1-ͼƬ 2-��Ƶ����̬����ͽ����岥ʱ��Ч
    BYTE    byPlayState;	//����״̬��1-���ڲ��ţ�2-����ֹͣ��3-������ͣ
	BYTE    byAudioState;	//��Ƶ����״̬��0-�أ�1-��
	NET_DVR_PLAYITEM_INFO  struPlayItemInfo;  //��������Ϣ
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_ONLINEUSER_COND //�����ṹ
{
    DWORD   dwSize;
    DWORD  dwChannel;//ͨ���ţ�ǰ��Ĭ����1��
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG //���ýṹ
{
    DWORD   dwSize;
    BYTE   byID;//�û����к�
    BYTE   byUserType;//�û����� 0-��ͨ�û���1-����Ա��2-�����û�
    BYTE   byDataType;//���״̬����:0-����У�1-��ʼ��2-����
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;//IP��ַ
    NET_DVR_TIME_V30  struLoginTime;//��½ʱ��
    char   szUserName[NAME_LEN/*32*/];//�û���
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;

//�洢����״̬
typedef	struct tagNET_DVR_STORAGE_DETECTION
{
    DWORD	dwSize;//�ṹ���С
    BYTE    byHealthState;//����״̬0-���ã�1-�2-�𻵣�3-δ֪
    BYTE    bySDCardState;//SDcard״̬ 0-���ߣ�1-����,2-δ֪,3-����
    WORD    wAbnormalPowerLoss;//�쳣������
    WORD    wBadBlocks;//������
    BYTE    byRemainingLife; //SD��ʣ������; 0~100%
    BYTE	byRes[125];
}NET_DVR_STORAGE_DETECTION,*LPNET_DVR_STORAGE_DETECTION;

//�洢���ܼ�ⱨ���ϴ�
typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD 	dwRelativeTime; //���ʱ��
    DWORD	dwAbsTime; //���ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    DWORD   dwCardID;   //��ID
    WORD    wAbnormalPowerLoss;//�쳣������
    WORD    wBadBlocks;//������
    BYTE    byHealthState;//����״̬0-���ã�1-�2-�𻵣�3-δ֪
    BYTE    byRes[125];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;


//�洢���Ķ�д������
typedef	struct tagNET_DVR_STORAGE_RWLOCK
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byEnabled;//ʹ�� 0-�رգ�1-����
    BYTE    byRes[3];
    char    szPassWD[PASSWD_LEN/*16*/]; //��д��������
    char    szOriginalPassWD[PASSWD_LEN/*16*/]; //ԭʼ����
    BYTE	byRes1[128];
}NET_DVR_STORAGE_RWLOCK,*LPNET_DVR_STORAGE_RWLOCK;

//�洢���Ľ�������
typedef	struct tagNET_DVR_STORAGE_UNLOCK
{
    DWORD   dwSize;//�ṹ���С
    char    szPassWD[PASSWD_LEN/*16*/]; //����
    BYTE	byRes1[128];
}NET_DVR_STORAGE_UNLOCK,*LPNET_DVR_STORAGE_UNLOCK;


typedef	struct tagNET_DVR_PTZTRACKSTATUS
{
	DWORD		dwSize;//�ṹ���С
	BYTE  		byID;//�����豸��ID (�ֶ�byLinkageType��0��ʱ����Ч)
	BYTE      byLinkageType;//��������0-��������1-��������豸����
	BYTE      byRes[254];
}NET_DVR_PTZTRACKSTATUS,*LPNET_DVR_PTZTRACKSTATUS;

#define MAX_PROXY_COUNT 32

typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129];  //�����������ַ
    BYTE  byAuthType; //��֤��ʽ����ʱ�Ȳ�ʹ�ø��ֶ�
    WORD  wPort;      //����������˿�
    BYTE  byRes2[64]; //���Ҫʹ����֤��ʽ����Ȼ��ҪһЩ�����ֽڣ�����һЩ
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD 				    dwLength; 		//�ṹ����
    DWORD					dwChannel; 		//ͨ��
    NET_DVR_TIME_V30		struTimePoint;	//ʱ���
    BYTE  					byRes[64];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen; 	//ͼƬ����
    char 	*pPicBuf; 	//ͼƬ���
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;

//�ֶ�������
typedef	struct tagNET_DVR_MANUALRANGING_CFG
{
    DWORD		dwSize;//�ṹ���С
    BYTE		byEnabled;  //�Ƿ����ֶ���ࣺ0- ��1- ��
    BYTE		byRes[127];
}NET_DVR_MANUALRANGING_CFG,*LPNET_DVR_MANUALRANGING_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD       	dwSize;    		//�ṹ���С
    BYTE           byDoorNotCloseAlarm;   //�Ƿ��ϴ���δ�ر�����0-���ϴ���1-�ϴ�
    BYTE			byRes[603];     	//����
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp
    DWORD    dwYear;	        //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate,��֡��С��0ʱ��0x80000002:��ʾ1/2֡�ʣ�ͬ�����0x80000010Ϊ1/16֡��
    DWORD    dwFlag;         //flag E֡���
    DWORD    dwFilePos;      //file pos
    DWORD	 dwPacketType;    //Packet type:0 -file head��1 -video I frame��2- video B frame�� 3- video P frame�� 10- audio packet�� 11- private packet
    DWORD	 dwPacketSize;   //packet size
    unsigned char*	pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   //���ʽ:0-������1-FU_A���ʽ
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] ��ʾ˽���������
    //reserved[1] ��ʾ˽������ݵ�ַ��λ
    //reserved[2] ��ʾ˽������ݵ�ַ��λ
    //reserved[3] ��ʾ˽������ݳ���
    //reserved[4] ˽��֡/���ʱ����\ʱ���
    //reserved[5].һbitλ����Ƿ�Ϊ��P֡����P��1����Ϊ��P��0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef BOOL (* DEV_WORK_STATE_CB)(void* pUserdata, int iUserID, LPNET_DVR_WORKSTATE_V40 lpWorkState);

typedef struct tagNetDVRCheckDevState
{
    DWORD				dwTimeout;      //��ʱ����豸����״̬����λms��Ϊ0ʱ����ʾʹ��Ĭ��ֵ(30000)����СֵΪ1000
    DEV_WORK_STATE_CB	fnStateCB;
    void*				pUserData;
    BYTE				byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;


/********************************SDK�ӿں�������*********************************/
NET_DVR_API BOOL __stdcall NET_DVR_Init();
NET_DVR_API BOOL __stdcall NET_DVR_Cleanup();

//NET_DVR_SetDVRMessage����չ
#ifdef _WIN32
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessage(UINT nMessage,HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT nMessage, HWND hWnd, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
#elif defined(__linux__) || defined(__APPLE__)
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT reserved1, void* reserved2, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
/*Linuxר�� */
#if defined(__linux__)
NET_DVR_API BOOL NET_DVR_DrawAreaInit(INITINFO InitInfo, DWORD iUseSDL = 1);
NET_DVR_API BOOL NET_DVR_DrawAreaRelease();
#endif
#endif

NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack(BOOL (CALLBACK *fMessCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_EX(BOOL (CALLBACK *fMessCallBack_EX)(LONG lCommand,LONG lUserID,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_NEW(BOOL (CALLBACK *fMessCallBack_NEW)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, WORD dwLinkDVRPort));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack(BOOL (CALLBACK *fMessageCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, DWORD dwUser), DWORD dwUser);
typedef void (CALLBACK *MSGCallBack)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V30(MSGCallBack fMessageCallBack, void* pUser);
typedef BOOL (CALLBACK *MSGCallBack_V31)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V31(MSGCallBack_V31 fMessageCallBack, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetConnectTime(DWORD dwWaitTime = 3000, DWORD dwTryTimes = 3);
NET_DVR_API BOOL __stdcall NET_DVR_SetReconnect(DWORD dwInterval = 30000, BOOL bEnableRecon = TRUE);
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKVersion();
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKBuildVersion();
NET_DVR_API int __stdcall NET_DVR_IsSupport();
NET_DVR_API BOOL __stdcall NET_DVR_StartListen(char *sLocalIP,WORD wLocalPort);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen();

NET_DVR_API LONG __stdcall NET_DVR_StartListen_V30(char *sLocalIP, WORD wLocalPort, MSGCallBack DataCallback, void* pUserData = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen_V30(LONG lListenHandle);
NET_DVR_API LONG __stdcall NET_DVR_Login(char *sDVRIP,WORD wDVRPort,char *sUserName,char *sPassword,LPNET_DVR_DEVICEINFO lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V30(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);

NET_DVR_API LONG __stdcall NET_DVR_Login_V40(LPNET_DVR_USER_LOGIN_INFO pLoginInfo,LPNET_DVR_DEVICEINFO_V40 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Login_Check(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Logout(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Logout_V30(LONG lUserID);
NET_DVR_API DWORD __stdcall NET_DVR_GetLastError();
NET_DVR_API char* __stdcall NET_DVR_GetErrorMsg(LONG *pErrorNo = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_SetShowMode(DWORD dwShowType,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRIPByResolveSvr(char *sServerIP, WORD wServerPort, BYTE *sDVRName,WORD wDVRNameLen,BYTE *sDVRSerialNumber,WORD wDVRSerialLen,char* sGetIP);
NET_DVR_API BOOL  __stdcall NET_DVR_GetDVRIPByResolveSvr_EX(char *sServerIP, WORD wServerPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP, DWORD *dwPort);

//Ԥ����ؽӿ�
NET_DVR_API LONG __stdcall NET_DVR_PlayDirect(char *sDVRIP, char *sUserName, char *sPassword, \
											  LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay(LONG lUserID,LPNET_DVR_CLIENTINFO lpClientInfo);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V30(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API BOOL __stdcall NET_DVR_StopRealPlay(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayDirect(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RigisterDrawFun(LONG lRealHandle,void (CALLBACK* fDrawFun)(LONG lRealHandle,HDC hDc,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayerBufNumber(LONG lRealHandle,DWORD dwBufNum);
NET_DVR_API BOOL __stdcall NET_DVR_ThrowBFrame(LONG lRealHandle,DWORD dwNum);
NET_DVR_API BOOL __stdcall NET_DVR_SetAudioMode(DWORD dwMode);
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_Volume(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData(LONG lRealHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopSaveRealData(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBack(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBack(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture(LONG lRealHandle,char *sPicFileName);//bmp
NET_DVR_API BOOL __stdcall NET_DVR_SetCapturePictureMode(DWORD dwCaptureMode);

//��̬���I֡
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrame(LONG lUserID, LONG lChannel);//������
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrameSub(LONG lUserID, LONG lChannel);//������

//��̨������ؽӿ�
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_Other(LONG lUserID,LONG lChannel,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_Other(LONG lUserID,LONG lChannel,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_EX(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_EX(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_EX(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_EX(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_Other(LONG lUserID, LONG lChannel, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_EX(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_Other(LONG lUserID, LONG lChannel, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_EX(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCruise(LONG lUserID,LONG lChannel,LONG lCruiseRoute, LPNET_DVR_CRUISE_RET lpCruiseRet);


//�ļ�������ط�
NET_DVR_API LONG __stdcall NET_DVR_FindFile(LONG lUserID,LONG lChannel,DWORD dwFileType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile(LONG lFindHandle,LPNET_DVR_FIND_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V30(LONG lFindHandle, LPNET_DVR_FINDDATA_V30 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V40(LONG lFindHandle, LPNET_DVR_FINDDATA_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V30(LONG lUserID, LPNET_DVR_FILECOND pFindCond);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_V30(LONG lFindHandle);

NET_DVR_API BOOL __stdcall NET_DVR_LockFileByName(LONG lUserID, char *sLockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByName(LONG lUserID, char *sUnlockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByNameV40(LONG lUserID, BOOL bLock, const NET_DVR_LOCK_FILE_BY_NAME_PARA *lpLockFilePara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName(LONG lUserID,char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);

NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl(LONG lPlayHandle,DWORD dwControlCode,DWORD dwInValue,DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBack(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayBackESCallBack(LONG lPlayHandle, void (CALLBACK *fPlayESCallBack)(LONG lPlayHandle, NET_DVR_PACKET_INFO_EX *struPackInfo,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack_V40(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack_V40) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackSaveData(LONG lPlayHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBackSave(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlayBackOsdTime(LONG lPlayHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackCaptureFile(LONG lPlayHandle,char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName(LONG lUserID,char *sDVRFileName,char *sSavedFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetFile(LONG lFileHandle);
NET_DVR_API int __stdcall NET_DVR_GetDownloadPos(LONG lFileHandle);
NET_DVR_API int	__stdcall NET_DVR_GetPlayBackPos(LONG lPlayHandle);

//��
NET_DVR_API LONG __stdcall NET_DVR_AdapterUpgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_VcalibUpgrade(LONG lUserID, LONG lChannel, char const *sFileName);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeState(LONG lUpgradeHandle);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeProgress(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseUpgradeHandle(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetNetworkEnvironment(DWORD dwEnvironmentLevel);
//Զ�̸�ʽ��Ӳ��
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk(LONG lUserID,LONG lDiskNumber);
NET_DVR_API BOOL __stdcall NET_DVR_GetFormatProgress(LONG lFormatHandle, LONG *pCurrentFormatDisk,LONG *pCurrentDiskPos,LONG *pFormatStatic);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFormatHandle(LONG lFormatHandle);
//����
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan(LONG lAlarmHandle);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V30(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan_V30(LONG lAlarmHandle);
//�����Խ�
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_V30(LONG lUserID, DWORD dwVoiceChan, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceComClientVolume(LONG lVoiceComHandle, WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_StopVoiceCom(LONG lVoiceComHandle);
//����ת��
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR_V30(LONG lUserID, DWORD dwVoiceChan, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceComSendData(LONG lVoiceComHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress(LONG lUserID, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress_V50(LONG lUserID, LPNET_DVR_AUDIO_CHANNEL lpAudioChannel, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
//�����㲥
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart();
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart_V30(void(CALLBACK *fVoiceDataCallBack)(char *pRecvDataBuffer, DWORD dwBufSize, void * pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStop();
NET_DVR_API BOOL __stdcall NET_DVR_AddDVR(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_AddDVR_V30(LONG lUserID, DWORD dwVoiceChan);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR_V30(LONG lVoiceHandle);
//͸��ͨ������
NET_DVR_API LONG __stdcall NET_DVR_SerialStart(LONG lUserID,LONG lSerialPort,void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle,char *pRecvDataBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
//485��Ϊ͸��ͨ��ʱ����Ҫָ��ͨ���ţ���Ϊ��ͬͨ����485�����ÿ��Բ�ͬ(���粨����)
NET_DVR_API LONG __stdcall NET_DVR_SerialStart_V40(LONG lUserID,void* lpInBuffer, LONG dwInBufferSize, void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle, LONG lCHannel, char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SerialSend(LONG lSerialHandle, LONG lChannel, char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SerialStop(LONG lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SendTo232Port(LONG lUserID, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SendToSerialPort(LONG lUserID, DWORD dwSerialPort, DWORD dwSerialIndex, char *pSendBuf, DWORD dwBufSize);

//���� nBitrate = 16000
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder(int nBitrate = 16000);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *pDecHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
//����
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);

//����
NET_DVR_API void* __stdcall NET_DVR_InitG726Decoder(void** pDecMoudle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG726Frame(void *pDecMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
//����
NET_DVR_API void* __stdcall NET_DVR_InitG726Encoder(void** pEncMoudle);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG726Frame(void *pEncMoudle,BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Encoder(void *pEncHandle);
//Զ�̿��Ʊ�����ʾ
NET_DVR_API BOOL __stdcall NET_DVR_ClickKey(LONG lUserID, LONG lKeyIndex);
//Զ�̿����豸���ֶ�¼��
NET_DVR_API BOOL __stdcall NET_DVR_StartDVRRecord(LONG lUserID,LONG lChannel,LONG lRecordType);
NET_DVR_API BOOL __stdcall NET_DVR_StopDVRRecord(LONG lUserID,LONG lChannel);
//���뿨
NET_DVR_API BOOL __stdcall NET_DVR_InitDevice_Card(long *pDeviceTotalChan);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDevice_Card();
NET_DVR_API BOOL __stdcall NET_DVR_InitDDraw_Card(HWND hParent,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDraw_Card();
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card(LONG lUserID,LPNET_DVR_CARDINFO lpCardInfo,long lChannelNum);
NET_DVR_API BOOL __stdcall NET_DVR_ResetPara_Card(LONG lRealHandle,LPNET_DVR_DISPLAY_PARA lpDisplayPara);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_ClearSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_RestoreSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetVolume_Card(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_AudioPreview_Card(LONG lRealHandle,BOOL bEnable);
NET_DVR_API LONG __stdcall NET_DVR_GetCardLastError_Card();
NET_DVR_API HANDLE __stdcall NET_DVR_GetChanHandle_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_Card(LONG lRealHandle, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetSerialNum_Card(long lChannelNum,DWORD *pDeviceSerialNo);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog(LONG lLogHandle, LPNET_DVR_LOG lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V30(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, BOOL bOnlySmart = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V30(LONG lLogHandle, LPNET_DVR_LOG_V30 lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose_V30(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindAlarmHostLog(LONG lUserID, LONG lSelectMode, NET_DVR_ALARMHOST_SEARCH_LOG_PARAM *lpSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextAlarmHostLog(LONG lFindHandle, NET_DVR_ALARMHOST_LOG_RET *lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindAlarmHostLogClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByCard(LONG lUserID,LONG lChannel,DWORD dwFileType, int nFindType, BYTE *sCardNumber, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle,BYTE* pInBuffer, BYTE* pOutBuffer);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_NEW(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sJpegPicBuffer, DWORD dwPicSize,  LPDWORD lpSizeReturned);
NET_DVR_API int __stdcall NET_DVR_GetRealPlayerIndex(LONG lRealHandle);
NET_DVR_API int __stdcall NET_DVR_GetPlayBackPlayerIndex(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG(LONG lUserID, DWORD dwScale);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG(LONG lUserID, DWORD *lpOutScale);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_SetATMPortCFG(LONG lUserID, WORD wATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetATMPortCFG(LONG lUserID, WORD *LPOutATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_InitDDrawDevice();
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDrawDevice();
NET_DVR_API LONG __stdcall NET_DVR_GetDDrawDeviceTotalNums();
NET_DVR_API BOOL __stdcall NET_DVR_SetDDrawDevice(LONG lPlayPort, DWORD nDeviceNum);

NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn(LONG lRealHandle, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn_EX(LONG lUserID, LONG lChannel, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecode(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERINFO lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecode(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecoderState(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERSTATE lpDecoderState);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_DecPlayBackCtrl(LONG lUserID, LONG lChannel, DWORD dwControlCode, DWORD dwInValue,DWORD *LPOutValue, LPNET_DVR_PLAYREMOTEFILE lpRemoteFileInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlDec(LONG lUserID, LONG lChannel, DWORD dwControlCode);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlScreen(LONG lUserID, LONG lChannel, DWORD dwControl);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecCurLinkStatus(LONG lUserID, LONG lChannel, LPNET_DVR_DECSTATUS lpDecStatus);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DYNAMIC_DEC lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopDynamic(LONG lUserID, DWORD dwDecChanNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecEnable(LONG lUserID, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_STATUS lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetVideoStandard(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwVideoStandard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetVideoStandard(LONG lUserID, DWORD dwDecChanNum, DWORD dwVideoStandard);

//2007-12-22 ����֧�ֽӿ�
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlayControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwControlCode, DWORD dwInValue, DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetRemotePlayStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS lpOuter);
//2009-4-13 ����
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);

NET_DVR_API LONG __stdcall NET_DVR_MatrixStartPassiveDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_PASSIVEMODE lpPassiveMode /*, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser*/);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSendData(LONG lPassiveHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopPassiveDecode(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_DISP_LOGOCFG lpDispLogoCfg, char *sLogoBuffer);
#define	NET_DVR_SHOWLOGO			1		/*��ʾLOGO*/
#define	NET_DVR_HIDELOGO			2		/*����LOGO*/
NET_DVR_API BOOL __stdcall NET_DVR_LogoSwitch(LONG lUserID, DWORD dwDecChan, DWORD dwLogoSwitch);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus(LONG lUserID,  LPNET_DVR_DECODER_WORK_STATUS lpDecoderCfg);

#define	DISP_CMD_ENLARGE_WINDOW				1	/*��ʾͨ���Ŵ�ĳ������*/
#define	DISP_CMD_RENEW_WINDOW				2	/*��ʾͨ�����ڻ�ԭ*/
#define	DISP_CMD_OPENAUDIO			        3	/*��ʾͨ������Ƶ*/
#define	DISP_CMD_CLOSEAUDIO			        4	/*��ʾͨ���ر���Ƶ*/

NET_DVR_API BOOL __stdcall NET_DVR_MatrixDiaplayControl(LONG lUserID, DWORD dwDispChanNum, DWORD dwDispChanCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPassiveDecodeControl(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PASSIVEDECODE_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_MatrixGetPassiveDecodeStatus(LONG lPassiveHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshPlay(LONG lPlayHandle);
//�ָ�Ĭ��ֵ
NET_DVR_API BOOL __stdcall NET_DVR_RestoreConfig(LONG lUserID);
//�������
NET_DVR_API BOOL __stdcall NET_DVR_SaveConfig(LONG lUserID);
//����
NET_DVR_API BOOL __stdcall NET_DVR_RebootDVR(LONG lUserID);
//�ر�DVR
NET_DVR_API BOOL __stdcall NET_DVR_ShutDownDVR(LONG lUserID);

//�������� begin
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState_V30(LONG lUserID, LPNET_DVR_WORKSTATE_V30 lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState(LONG lUserID, LPNET_DVR_WORKSTATE lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_SetVideoEffect(LONG lUserID, LONG lChannel, DWORD dwBrightValue, DWORD dwContrastValue, DWORD dwSaturationValue, DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetVideoEffect(LONG lUserID, LONG lChannel, DWORD *pBrightValue, DWORD *pContrastValue, DWORD *pSaturationValue, DWORD *pHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_SetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmProtocol(LONG lUserID, LPNET_DVR_ATM_PROTOCOL lpAtmProtocol);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut_V30(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS_V30 lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmOut(LONG lUserID, LONG lAlarmOutPort,LONG lAlarmOutStatic);

//��Ƶ�������
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetVideoEffect(LONG lRealHandle,DWORD dwBrightValue,DWORD dwContrastValue, DWORD dwSaturationValue,DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetVideoEffect(LONG lRealHandle,DWORD *pBrightValue,DWORD *pContrastValue, DWORD *pSaturationValue,DWORD *pHueValue);

//�����ļ�
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_V30(LONG lUserID, char *sOutBuffer, DWORD dwOutSize, DWORD *pReturnSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_EX(LONG lUserID, char *sOutBuffer, DWORD dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile_EX(LONG lUserID, char *sInBuffer, DWORD dwInSize);

//������־�ļ�д��ӿ�
NET_DVR_API BOOL __stdcall NET_DVR_SetLogToFile(DWORD nLogLevel = 0, char * strLogDir = NULL, BOOL bAutoDel = TRUE);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKState(LPNET_DVR_SDKSTATE pSDKState);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKAbility(LPNET_DVR_SDKABL pSDKAbl);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol(LONG lUserID, NET_DVR_PTZCFG *pPtzcfg);
//ǰ�����
NET_DVR_API BOOL __stdcall NET_DVR_LockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_UnLockPanel(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_SetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpOutBuffer, DWORD dwOutBufferSize);

//��������ȡ
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceAbility(LONG lUserID, DWORD dwAbilityType, char* pInBuf, DWORD dwInLength, char* pOutBuf, DWORD dwOutLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);

//����
//����/��ȡ����ؼ���
NET_DVR_API BOOL __stdcall NET_DVR_SetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int nValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int *pValue);

//��ȡ/������Ϊ����Ŀ����ӽӿ�
NET_DVR_API BOOL __stdcall NET_DVR_GetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);
NET_DVR_API BOOL __stdcall NET_DVR_SetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);

//������ģʽ���ýӿ�
NET_DVR_API BOOL __stdcall NET_DVR_SetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);

//�������ܿ�
NET_DVR_API BOOL __stdcall NET_VCA_RestartLib(LONG lUserID, LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData_V30(LONG lRealHandle, DWORD dwTransType, char *sFileName);

NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V40(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V40  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V40(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET_V40 lpSearchEventRet);
//ֹͣ���� NET_DVR_FindClose

NET_DVR_API LONG __stdcall NET_DVR_FindPDCInfo(LONG lUserID, LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPDCInfo(LONG lFindHandle,LPNET_DVR_PDC_QUERY lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindPDCClose(LONG lFindHandle);

// �궨У��
#define NET_DVR_PDC_VERIFY_CALIBRATION          1    //��ֵΪ1��ΪPDC�궨У�� pdc����ֵΪNET_VCA_POINT   ����ֵΪ NET_VCA_RECT�ṹ
#define NET_DVR_VERIFY_BEHAVIOR_CALIBRATION     2    // ��Ϊ�����궨��У��
#define NET_DVR_VERIFY_ITS_CALIBRATION		    3    // ���ܽ�ͨ�궨У��
#define NET_DVR_VERIFY_BV_CALIBRATION	        5    //˫Ŀ�궨У��

NET_DVR_API BOOL __stdcall  NET_DVR_VerifyCalibration(LONG lUserID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOuterBuffer, DWORD dwOuterBufferSize);
NET_DVR_API BOOL __stdcall  NET_DVR_ResetCounter(LONG lUserID,LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_MATRIX(LONG lLogHandle, LPNET_DVR_LOG_MATRIX lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_Matrix(LONG lUserID, LONG lSelectMode, DWORD dwMajorType, DWORD dwMinorType, LPNET_DVR_VEDIOPLATLOG lpVedioPlatLog, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

NET_DVR_API BOOL __stdcall NET_DVR_ManualSnap(LONG lUserID, NET_DVR_MANUALSNAP const* lpInter, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol_Ex(LONG lUserID, LONG lChannel, NET_DVR_PTZCFG *pPtzcfg);

NET_DVR_API LONG __stdcall NET_DVR_StartEmailTest(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopEmailTest(LONG lEmailTestHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetEmailTestProgress(LONG lEmailTestHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST lpProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList_V41(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST_V41 lpProtoList);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch_V40(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM_V40 lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SearchNextInfo(LONG lSearchHandle, LPNET_DVR_SMART_SEARCH_RET lpSmartSearchRet);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearch(LONG lSearchHandle);

// IP San �ļ�Ŀ¼����
NET_DVR_API LONG __stdcall NET_DVR_FindIpSanDirectory(LONG lUserID, LPNET_DVR_IPSAN_SERACH_PARAM lpIpsanSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDirectory(LONG lFindHandle, LPNET_DVR_IPSAN_SERACH_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindDirectoryClose(LONG lFindHandle);

typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

NET_DVR_API LONG __stdcall NET_DVR_ZeroStartPlay(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL, BOOL bBlocked = TRUE);

NET_DVR_API BOOL __stdcall NET_DVR_ZeroStopPlay(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroMakeKeyFrame(LONG lUserID, LONG lZeroChan);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl_V40(LONG lPlayHandle,DWORD dwControlCode, LPVOID lpInBuffer = NULL, DWORD dwInLen = 0, LPVOID lpOutBuffer = NULL, DWORD *lpOutLen = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroTurnOver(LONG lUserID, LONG lChannel, BOOL bNextPreview);

NET_DVR_API BOOL __stdcall NET_DVR_GetDiskList(LONG lUserID, LPNET_DVR_DISKABILITY_LIST lpDiskList);
NET_DVR_API LONG __stdcall NET_DVR_Backup(LONG lUserID, DWORD dwBackupType, LPVOID lpBackupBuff, DWORD dwBackupBuffSize);
NET_DVR_API LONG __stdcall NET_DVR_BackupByName(LONG lUserID, LPNET_DVR_BACKUP_NAME_PARAM lpBackupByName);
NET_DVR_API LONG __stdcall NET_DVR_BackupByTime(LONG lUserID, LPNET_DVR_BACKUP_TIME_PARAM lpBackupBytime);
NET_DVR_API BOOL __stdcall NET_DVR_GetBackupProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopBackup(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_GetSadpInfoList(LONG lUserID, LPNET_DVR_SADPINFO_LIST lpSadpInfoList);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateSadpInfo(LONG lUserID, LPNET_DVR_SADP_VERIFY lpSadpVerify, LPNET_DVR_SADPINFO lpSadpInfo);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_SetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestDeleteFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCDWByFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpCdrwFile);
NET_DVR_API LONG __stdcall NET_DVR_InquestUploadFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_InquestUploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_InquestGetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStartCDW( LONG lUserID, BOOL bPause);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStopCDW(LONG lUserID, BOOL bCancelWrite);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDWState(LONG lUserID, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCheckSecretKey(LONG lUserID, BOOL *bSecretSet);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetSecretKey(LONG lUserID, LPNET_DVR_INQUEST_SECRET_INFO pSecretInfo);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStreamEncrypt(LONG lUserID, LONG lChannel, BOOL bEncrypt);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetEncryptState(LONG  lUserID, LONG lChannel, BOOL *bEncrypt);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindFile(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindNextFile(LONG lFindHandle, LPNET_DVR_INQUEST_FILEINFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_InquestFindClose(LONG lFindHandle);

// 9000RH
NET_DVR_API LONG __stdcall NET_DVR_RaidFastConfig(LONG lUserID, char *sName);
NET_DVR_API BOOL __stdcall NET_DVR_FastConfigProcess(LONG lHandle, DWORD *pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFastConfig(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetArraySpaceAlloc(LONG lUserID, DWORD dwSlot, LPNET_DVR_ARRAY_SPACE_ALLOC_INFO lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DelArray(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_CreateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CalcArraySize(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam, UINT64* lpArraySize);
NET_DVR_API BOOL __stdcall NET_DVR_MigrateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_RebuildArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVD(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM lpVDParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVDEx(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM_EX lpVDParamEx);
NET_DVR_API BOOL __stdcall NET_DVR_DelVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_RepairVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_SetSpareDisk(LONG lUserID, LPNET_DVR_SPARE_DISK_PARAM lpSpareDisk);
NET_DVR_API BOOL __stdcall NET_DVR_GetPDList(LONG lUserID, LPNET_DVR_PHY_DISK_LIST lpPDList);
NET_DVR_API BOOL __stdcall NET_DVR_GetArrayList(LONG lUserID, LPNET_DVR_ARRAY_LIST lpArrayList);
NET_DVR_API BOOL __stdcall NET_DVR_GetVDList(LONG lUserID, LPNET_DVR_VD_LIST lpVDList);
NET_DVR_API LONG __stdcall NET_DVR_ExpandDisk(LONG lUserID,DWORD dwVDSLot);
NET_DVR_API BOOL __stdcall NET_DVR_GetExpandProgress(LONG lExpandHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseExpandHandle(LONG lExpandHandle);
NET_DVR_API LONG __stdcall NET_DVR_AlgoDebugStart(LONG lUserID, LONG lCHannel, void(CALLBACK *fAlgoLibInfoCallBack)(LONG lHandle, LONG lChannel,char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugSend(LONG lHandle, LONG lChannel, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugStop(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrint(BOOL bLogPrint);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrintAction(DWORD nLogLevel, DWORD nToDevice, BOOL bEnable, int Reserve1, int Reserve2);

NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_SetSceneMode(LONG  lUserID, LONG lChannel, DWORD dwSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetSceneMode(LONG lUserID, LONG lChannel, DWORD  *pSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetVCAVersion(LONG lUserID, LONG lChannel, LPNET_DVR_VCA_VERSION lpVersion);

NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPicAdjust(LONG lUserID, DWORD dwDispChan, DWORD dwPicAdjust, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmJoinedRecord(LONG lUserID, DWORD dwChan, DWORD dwAlarmSeq, DWORD dwRecordTime, DWORD dwRes);
NET_DVR_API BOOL __stdcall NET_DVR_GetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_UNITEDMATRIXINFO lpInter);
typedef LONG(CALLBACK * REGCallBack)(LONG lUserID, LPNET_DVR_REGCALLBACKPARAM pRegCallbackParam, LPNET_DVR_LOGONREPONSEPARAM pInterParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRegisterCallBack(REGCallBack fRegCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewRequest(LONG lUserID, LONG lChannel, LPNET_DVR_PREVIEWPARAM lpPreviewParam, LPNET_DVR_DEVICENATINFO lpOuter);
typedef LONG(CALLBACK * PREVIEWRESPONSECallBack)(LONG lUserID, LONG lStreamHandle, LPNET_DVR_PREVIEWCALLBACKPARAM pPewviewCallbackParam,void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPreviewResponseCallBack(PREVIEWRESPONSECallBack fPreviewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlaybackRequest(LONG lUserID, LPNET_DVR_PLAYBACKREQUESTPARAM lpPlayBackRequestParam);
typedef LONG(CALLBACK * PLAYBACKRESPONSECallBack)(LONG lUserID, LONG lPlaybackHandle, LPNET_DVR_PLAYBACKCALLBACKPARAM lpPlaybackParam,void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlaybackResponseCallBack(PLAYBACKRESPONSECallBack fPlaybackResponseCallBack, void *pUser);
typedef LONG(CALLBACK * VOICERESPONSECallBack)(LONG lUserID, LONG lVoiceHandle, LONG lVoiceChannel, BYTE nAudioType, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceResponseCallBack(VOICERESPONSECallBack fVoiceResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceRequest(LONG lUserID, LPNET_DVR_VOICEREQUESTPARAM lpVoiceParam);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmSetupRequest(LONG lUserID, LPNET_DVR_ALARMSETUPREQUESTPARAM lpAlarmSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsListInfo(LONG lUserID, LPNET_DVR_TIME_EX lpStartTime, LPNET_DVR_TIME_EX lpStopTime, LPNET_DVR_SMSLISTINFO lpSmsListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsContent(LONG lUserID, DWORD dwSmsIndex, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API BOOL __stdcall NET_DVR_SendSms(LONG lUserID, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API LONG __stdcall NET_DVR_StartServer(char *sLocalIP, WORD wLocalPort, BYTE byMode);
NET_DVR_API BOOL __stdcall NET_DVR_StopServer(LONG lServerHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartRecvNakedDataListen(NAKED_DATA_TYPE type, LPNET_DVR_NAKED_DATA_PARAM pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopRecvNakedDataListen(LONG lNakedDataRecvHandle);
typedef void(CALLBACK * NAKEDDAtACALLBACK)(DWORD typeInfo, char *pInfo, DWORD dwInfoLen,DWORD dwIPLen, void* pUser);
NET_DVR_API BOOL __stdcall  NET_DVR_SetNakedDataRecvCallBack(LONG lNakedDataRecvHandle, void(CALLBACK *fNakedDataCallBack)(DWORD dwTypeInfo, NET_DVR_NAKED_DATA_INFO *pStruNakedDataInfo, char *pInfo, DWORD dwInfoLen, void* pUser), void* pUser);

typedef LONG(CALLBACK * ALARMSETUPRESPONSECallBack)(LONG lUserID, LONG lAlarmHandle, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSetupResponseCallBack(ALARMSETUPRESPONSECallBack fAlarmSetupResponseCallBack, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SpringJPEGPicture(LONG lUserID, LONG lChannel, NET_DVR_PUSHJPEGPARA const *lpJpegPara);
NET_DVR_API BOOL __stdcall NET_DVR_SetPushModeParam(LPNET_DVR_PUSHMODEPARAM pPushParam);

NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetupAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostCloseAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_BypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_UnBypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostAssistantControl(LONG lUserID, DWORD dwType, DWORD dwNumber, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceTypeList(LONG lUserID, NET_DVR_DEVICE_TYPE_LIST *lpDeviceTypeList);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceProtoList(LONG lUserID, LONG lDeviceType, NET_DVR_DEVICE_PROTO_LIST *lpDeviceProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetBatteryVoltage(LONG lUserID, float *pVoltage);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_ControlGateway(LONG lUserID, LONG lGatewayIndex, DWORD dwStaic);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmHostOut(LONG lUserID, LONG lAlarmOutPort, LONG lAlarmOutStatic);
typedef void(CALLBACK *fAlarmHostSerialDataCallBack)
(LONG lSerialHandle, LONG lPort, LONG lDateType, char *pRecvDataBuffer, DWORD  dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_AlarmHostSerialStart(LONG lUserID, LONG lSerialType, fAlarmHostSerialDataCallBack cbSerialDataCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialSend(LONG lSerialHandle,LONG lPort,char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialStop(LONG  lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetMatrixPuChan(LONG lUserID, LONG lChanType, NET_DVR_PU_CHAN_LIST* lpChanList);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmOffMonitor(LONG lUserID, DWORD dwMonID, DWORD dwCamID);
NET_DVR_API BOOL __stdcall NET_DVR_GetCameraListInfo(LONG lUserID, DWORD dwCamNum, DWORD dwStartCam, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetMonitorListInfo(LONG lUserID, DWORD dwMonNum, DWORD dwStartMon, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetGlobalNum(LONG lUserID, DWORD *dwCamNum, DWORD *dwMonNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSpanSwitch(LONG lUserID, BYTE nSwitchMode, LPNET_DVR_MATRIXSWITCH lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartSwitch(LONG lUserID, LPNET_DVR_MATRIXSWITCHCTRL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char *sInBuffer,  DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char  *sOutBuffer,  DWORD   dwOutSize,  DWORD   *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V40(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 lpInter);
typedef void (CALLBACK *FLOWTESTCALLBACK)(LONG lFlowHandle, LPNET_DVR_FLOW_INFO pFlowInfo, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartNetworkFlowTest(LONG lUserID, NET_DVR_FLOW_TEST_PARAM* pFlowTest,  FLOWTESTCALLBACK fFlowTestCallback, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_StopNetworkFlowTest(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindRecordLabel(LONG lUserID, LPNET_DVR_FIND_LABEL lpFindLabel);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLabel(LONG lFindHandle, LPNET_DVR_FINDLABEL_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_StopFindLabel(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_InsertRecordLabel(LONG lPlayHandle, NET_DVR_RECORD_LABEL* lpRecordLabel, NET_DVR_LABEL_IDENTIFY *lpLableIdentify);
NET_DVR_API BOOL __stdcall NET_DVR_DelRecordLabel(LONG lUserID, NET_DVR_DEL_LABEL_PARAM* lpDelLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_ModifyRecordLabel(LONG lUserID, NET_DVR_MOD_LABEL_PARAM * lpModLabelParam);
NET_DVR_API LONG __stdcall NET_DVR_FindPicture(LONG lUserID, NET_DVR_FIND_PICTURE_PARAM* pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture(LONG lFindHandle,LPNET_DVR_FIND_PICTURE lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V40(LONG lFindHandle,LPNET_DVR_FIND_PICTURE_V40 lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFindPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture(LONG lUserID,char *sDVRFileName,const char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V30(LONG lUserID, char *sDVRFileName, char *sSavedFileBuf, DWORD dwBufLen, DWORD *lpdwRetLen);
NET_DVR_API LONG __stdcall NET_DVR_BackupPicture(LONG lUserID, NET_DVR_BACKUP_PICTURE_PARAM *lpBackupPicture);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeStep(LONG lUpgradeHandle, LONG *pSubProgress);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetEncodeJoint(LONG lUserID, LONG lChannel, LPNET_DVR_ENCODE_JOINT_PARAM lpEncodeJoint);
NET_DVR_API BOOL  __stdcall NET_DVR_GetLocalIP(char strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL  __stdcall NET_DVR_SetValidIP(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetVcaDevWorkState(LONG lUserID, LPNET_DVR_VCA_DEV_WORKSTATUS lpWorkState);
NET_DVR_API BOOL  __stdcall NET_DVR_SetRecvTimeOut(DWORD nRecvTimeOut = 5000); //��С3000����
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_ShutterCompensation(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CorrectDeadPixel(LONG lUserID, LONG lChannel, LPNET_DVR_CORRECT_DEADPIXEL_PARAM lpInParam);
NET_DVR_API BOOL __stdcall NET_DVR_CustomConfig(LONG lUserID, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricDataInfo(LONG lUserID, LONG lChannel, LPNET_DVR_HISTORICDATACFG lpHisData);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricData(LONG lUserID, LONG lChannel, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ClearHistoricData(LONG lUserID, LONG lChannel);
NET_DVR_API LONG  __stdcall NET_DVR_InquestUploadFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom,  char *sFileName);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestDeleteFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSendMessage(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_MESSAGE lpInquestMessage);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStartCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bNotBurn);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bCancelWrite);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetCDWState_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API LONG  __stdcall NET_DVR_InquestResumeEvent(LONG lUserID, LPNET_DVR_INQUEST_RESUME_EVENT lpResumeEvent);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetResumeProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopResume(LONG lHandle);
NET_DVR_API LONG  __stdcall NET_DVR_InquestFindFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM pInquestRoom);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetDeviceVersion(LONG lUserID, LPNET_DVR_INQUEST_DEVICE_VERSION lpVersionInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_SetSDKSecretKey(LONG lUserID, char *sSecretKey);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenZoomIn(LONG lUserID, LPNET_DVR_SCREENZOOM pStruScreen);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllCameraInfo(LONG lUserID, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleCameraInfo(LONG lUserID, DWORD dwCameraId, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddCamera(LONG lUserID, DWORD dwCameraNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModCameraInfo(LONG lUserID, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelCamera(LONG lUserID, DWORD dwCameraId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMonitorInfo(LONG lUserID, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleMonitorInfo(LONG lUserID, DWORD dwMonitorId, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddMonitor(LONG lUserID, DWORD dwMonitorNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModMonitorInfo(LONG lUserID, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelMonitor(LONG lUserID, DWORD dwMonitorId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMatrixInfo(LONG lUserID, LPNET_DVR_MATRIXLIST lpMatrixListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSingleMatrixInfo(LONG lUserID, DWORD dwMatrixId, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AddMatrix(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_ModMatrixInfo(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelMatrix(LONG lUserID, DWORD dwMatrixId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUartParam(LONG lUserID, DWORD dwSerialChan , LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUser(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUser(LONG lUserID, DWORD dwUserNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUserGroup (LONG lUserID, DWORD dwUserGroupNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllTrunkInfo(LONG lUserID, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTrunkInfo(LONG lUserID, DWORD dwTrunkNum, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddTrunk(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModTrunkInfo(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkCtrl(LONG lUserID, DWORD dwTrunkNum, BYTE byCtrlMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkStatusQuery(LONG lUserID, DWORD dwTrunkNum, BYTE *byTrunkStatus);

NET_DVR_API BOOL __stdcall NET_DVR_FindBackgroundPic(LONG lUserID, DWORD dwPicID, BYTE *pPicBuffer, DWORD *lpPicLen);
NET_DVR_API BOOL __stdcall NET_DVR_DetectImage(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_GetPictureModel(LONG lUserID, LPNET_VCA_REGISTER_PIC lpInBuf, LPNET_VCA_PICMODEL_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_AddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API LONG __stdcall NET_DVR_FindBlackList(LONG lUserID, LPNET_VCA_BLACKLIST_COND lpBlackListCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextBlackList(LONG lFindHandle,LPNET_VCA_BLACKLIST_INFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindBlackListClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetBlackListPicture(LONG lUserID, DWORD dwRegisterID, LPNET_VCA_BLACKLIST_PIC lpOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateBlackList(LONG lUserID,LONG lChannel, LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelBlackList(LONG lUserID,LONG lChannel, DWORD dwRegisterID);
NET_DVR_API LONG __stdcall NET_DVR_FindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSnapPic(LONG lFindHandle,LPNET_VCA_SUB_SNAPPIC_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindSnapPicClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_AdvanceFindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND_ADVANCE lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFaceMatchAlarm(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFaceMatchAlarm(LONG lFindHandle, LPNET_VCA_FACESNAP_MATCH_ALARM_LOG lpFaceMatchAlarmLog);
NET_DVR_API BOOL __stdcall NET_DVR_FindFaceMatchAlarmClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetFaceMatchPic(LONG lUserID, LPNET_VCA_FACEMATCH_PICCOND lpMatchCond, LPNET_VCA_FACEMATCH_PICTURE lpMatchPic);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_FASTREGISTER_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpVoutCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus_V41(LONG lUserID, LPNET_DVR_DECODER_WORK_STATUS_V41 lpDecoderCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSceneControl(LONG lUserID, DWORD dwSceneNum, DWORD dwCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCurrentSceneMode(LONG lUserID, DWORD *dwSceneNum);
NET_DVR_API BOOL __stdcall NET_DVR_GetAllValidWinInfo(LONG lUserID, LPNET_DVR_WINLIST lpWinListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenWinCtrl(LONG lUserID, DWORD dwWinIndex, DWORD dwCommand, LPNET_DVR_SCREEN_WINCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenInputStatus(LONG lUserID, LPNET_DVR_SCREENINPUTSTATUS lpStatus);
NET_DVR_API LONG __stdcall NET_DVR_PicUpload(LONG lUserID, char const *sFileName, LPNET_DVR_PICTURECFG lpPictureCfg);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadProgress(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall  NET_DVR_CloseUploadHandle(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_PicControl(LONG lUserID, BYTE byUseType, BYTE byPicIndex, BYTE byCtrlCmd);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadState(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenCtrl(LONG lUserID, DWORD dwDeviceNum, LPNET_DVR_SCREEN_CONTROL lpStruScreenCtrl);
typedef void (CALLBACK *SCREENPICDATACB)(LONG nScreenPicHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartScreenPic(LONG nUserID, DWORD nInputNum, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopScreenPic(LONG nScreenPicHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FocusOnePush(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_ResetLens(LONG lUserID, LONG lChannel);

typedef void(CALLBACK *fRemoteConfigCallback)(DWORD dwType, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_StartRemoteConfig(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferLen, fRemoteConfigCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopRemoteConfig(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetNextRemoteConfig(LONG lHandle, void* lpOutBuff, DWORD dwOutBuffSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRemoteConfigState(LONG lHandle, void *pState);
NET_DVR_API BOOL __stdcall NET_DVR_SendRemoteConfig(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwBufSize);

typedef void(CALLBACK *fLongCfgStateCallback)(LONG lHandle,  DWORD dwState, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseLongCfgHandle(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_RaidPullDiskStart(LONG lUserID, LONG lRaidID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_ScanRaidStart(LONG lUserID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_SetAccessCameraInfo(LONG lUserID, DWORD dwChannel, LPNET_DVR_ACCESS_CAMERA_INFO lpCameraInfo, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);

NET_DVR_API BOOL __stdcall NET_DVR_InquiryRecordTimeSpan(LONG lUserID, DWORD dwChannel,  NET_DVR_RECORD_TIME_SPAN_INQUIRY const *lpInquiry, LPNET_DVR_RECORD_TIME_SPAN lpResult);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateRecordIndex(LONG lUserID, DWORD dwChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetUpnpNatState(LONG lUserID, LPNET_DVR_UPNP_NAT_STATE lpState);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_EX lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrunkListInfo(LONG lUserID, DWORD dwTrunkNum, DWORD dwStartTrunk, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo, DWORD *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemSetupAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemCloseAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostClearAlarm(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypass(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypassResume (LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetReportMode(LONG lUserID, LONG lCenterNum, LPVOID lpInputBuf, DWORD dwInputBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostGetReportMode(LONG lUserID, LPVOID lpOutputBuf, DWORD dwOutputBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadAudio(LONG lUserID, DWORD dwAudioNum, DWORD dwAudioType, char const *sAudioFileName);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadAudio(LONG lUserID, DWORD dwAudioNum, char const *sAudioFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopAudioOperate(LONG lAudioHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetAudioProgress(LONG lAudioHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AudioCtrl(LONG lUserID, DWORD dwAudioNum, DWORD dwCtrlParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpInParamBuffer, DWORD dwInParamBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_LockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_StartManualRecord(LONG lUserID, LPNET_DVR_MANUAL_RECORD_PARA lpManualRecPara);
NET_DVR_API BOOL __stdcall NET_DVR_StopManualRecord(LONG lUserID, LPNET_DVR_STREAM_INFO pIDInfo);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V40(LONG lUserID, NET_DVR_VOD_PARA const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByTime_V40(LONG lUserID, HWND hWnd, LPNET_DVR_PLAYCOND pPlayCond);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime_V40(LONG lUserID, char *sSavedFileName, LPNET_DVR_PLAYCOND  pDownloadCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V40(LONG lUserID, LPNET_DVR_FILECOND_V40 pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V41(LONG lUserID, LPNET_DVR_SETUPALARM_PARAM lpSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_AddDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindDataBase(LONG lUserID, LPNET_VCA_FIND_DATABASE_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDataBase(LONG lFindHandle, LPNET_VCA_DATABASE_PARAM lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FindDataBaseClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteDataBase(LONG lUserID, LPNET_VCA_DELETE_DATABASE_COND lpCond);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_InquireSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_INQUIRE_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireSnapDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_SNAPRECORD_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_SearchSnapDB(LONG lUserID, LPNET_VCA_SEARCH_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchSnapDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_AddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_FAST_DATARECORD_INFO lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_InquireFaceDBRecord(LONG lUserID, LPNET_VCA_DATARECORD_COND lpInBuf,fSearchDBCallBack cbInquireDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireFaceDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_RECORD_COND lpInBuf);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lSearchHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_SearchFaceDB(LONG lUserID, LPNET_VCA_SEARCH_FACEDB_COND lpInBuf,fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchFaceDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearchDB(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FindMatchPicture(LONG lUserID, LPNET_VCA_FIND_MATCHPIC_COND lpFindCond, LPNET_VCA_FIND_MATCHPIC_RESULT lpFindResult);
NET_DVR_API BOOL __stdcall NET_DVR_RemoteControl(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);

NET_DVR_API BOOL __stdcall NET_DVR_PicViewRequest(LONG lUserID, NET_DVR_PIC_VIEW_PARAM *lpPicViewParam);
typedef LONG (CALLBACK *PicViewCallBack)(LPNET_DVR_PICVIEW_CALLBACKPARAM pStruPicViewParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewResponseCallBack(PicViewCallBack fPicViewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewDataCallBack(LONG lPicViewHandle, SCREENPICDATACB fPicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDevList(LONG lUserID, LPNET_DVR_DEVLIST lpDevListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenList(LONG lUserID, LPNET_DVR_SCREENLIST lpScreenListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetScreenRelation(LONG lUserID, NET_DVR_DISP_SCREEN const* lpScreenInfo);
NET_DVR_API BOOL __stdcall NET_DVR_TextShowCtrl(LONG lUserID, DWORD dwDeviceIndex, LPNET_DVR_TEXTSHOW lpText);
NET_DVR_API LONG __stdcall NET_DVR_StartUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, DVCS_UPGRADESTATE_CB UpgradeStateCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AddNetSignal(LONG lUserID, LPNET_DVR_NETSIGNAL_INFO lpStruSignal, void* lpOutBuf , DWORD dwBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartPicPreview(LONG lUserID, NET_DVR_START_PIC_VIEW_INFO const* lpStruStartPicView, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceStatus(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlanList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_PLAN_LIST lpPlanList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList_V40(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);

NET_DVR_API LONG __stdcall NET_DVR_UploadFile(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char* sFileName);
NET_DVR_API LONG __stdcall NET_DVR_UploadFile_V40(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char const * sFileName, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_etUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_GetUploadResult(LONG lUploadHandle, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_UploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadFile(LONG lUserID, LPNET_DVR_UPLOAD_PARAM  lpStruUploadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopUploadFile (LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadFile(LONG lUserID, LPNET_DVR_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownloadFile (LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadControl(LONG lDownloadHandle, NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM enumDownloadType, void* lpInBuffer, DWORD dwInBufferLen, void* lpOutBuffer, DWORD dwOutBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_UploadSend(LONG lUploadHandle, const NET_DVR_SEND_PARAM_IN *pstruSendParamIN, void* lpOutBuffer);


NET_DVR_API BOOL __stdcall NET_DVR_GetMobileDevStatus(LONG lUserID, DWORD dwStatusType, LPNET_DVR_MB_MOBILEDEV_STATUS lpstruMobileDevStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceDataCallBack(LONG lVoiceComHandle, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize, char *sOutBuffer, DWORD dwOutSize);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, const void *lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, void* lpOutBuff);

NET_DVR_API LONG __stdcall NET_DVR_OpticalUpgrade(LONG lUserID, char const *sFileName, LPNET_DVR_OPTICAL_INFO lpOpticalInfo);
typedef void(CALLBACK *fGPSDataCallback)(LONG nHandle, DWORD dwState, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_GetVehicleGpsInfo(LONG nUserID, LPNET_DVR_GET_GPS_DATA_PARAM lpGPSDataParam, fGPSDataCallback cbGPSDataCallback, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_ClosePreview(LONG lUserID, DWORD nSessionID);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePlayBack(LONG lUserID, DWORD nSessionID);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V40(LONG lUserID, LPNET_DVR_PREVIEWINFO lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);

NET_DVR_API LONG __stdcall NET_DVR_StartDownload(LONG lUserID, DWORD dwDownloadType, LPVOID lpInBuffer, DWORD dwInBufferSize, const char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadState(LONG lDownloadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownload(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_V41 lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 lpOuter);

NET_DVR_API LONG __stdcall NET_DVR_StartT1Test(LONG lUserID, LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API BOOL __stdcall NET_DVR_StopTT1Test(BOOL lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetT1TestStatus(LONG lHandle, LONG *pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SendT1TestData(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwSendBufLen);

NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo_NEW(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadLogo(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer, DWORD dwLogoBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_StartPassiveTransCode(LONG lUserID, NET_DVR_STREAM_INFO const *pStreamInfo, NET_DVR_COMPRESSIONCFG_V30 const *pDstTransInfo, NET_DVR_PASSIVETRANSINFO const *pPassiveTransInfo, void(CALLBACK *fTransCodeDataCallBack) (LONG lPassiveHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_TransCodeInputData(LONG lPassiveHandle, BYTE *pBuffer, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_StopPassiveTransCode(LONG lPassiveHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPassiveTransChanNum(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfigEx(LONG lUserID, DWORD dwCommand, DWORD dwCount, NET_DVR_IN_PARAM *lpInParam, NET_DVR_OUT_PARAM *lpOutParam);

NET_DVR_API BOOL __stdcall NET_DVR_GetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSTDAbility(LONG lUserID, DWORD dwAbilityType, LPNET_DVR_STD_ABILITY  lpAbilityParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDControl(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONTROL lpControlParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V40(DWORD lUserID, DWORD dwUpgradeType, char const *sFileName, void *pInbuffer, DWORD dwBufferLen);

NET_DVR_API BOOL __stdcall NET_DVR_DetectImage_V50(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT_V50 lpOutBuf);

NET_DVR_API LONG __stdcall NET_DVR_SmartSearchPicture(LONG lUserID, NET_DVR_SMART_SEARCH_PIC_PARA * pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSmartPicture(LONG lFindHandle,LPNET_DVR_SMART_SEARCH_PIC_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSmartSearchPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetESCallBack(LONG iRealHandle, void (__stdcall *fnESCallback)(LONG lPreviewHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ActivateDevice(char* sDVRIP, WORD wDVRPort, LPNET_DVR_ACTIVATECFG	lpActivateCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetAddrInfoByServer(DWORD	 dwQueryType, void* pInBuf, DWORD dwInBufLen, void* pOutBuf, DWORD dwOutBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_StartGetDevState(LPNET_DVR_CHECK_DEV_STATE pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetDevState();
NET_DVR_API BOOL __stdcall NET_DVR_RigisterPlayBackDrawFun(LONG lPlayHandle, void (__stdcall *fDrawFun)(LONG lPlayHandle, HDC hDc, DWORD dwUser), DWORD dwUser);



#endif //

