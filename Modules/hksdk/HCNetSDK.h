#ifndef _HC_NET_SDK_H_
#define _HC_NET_SDK_H_

#ifndef _WINDOWS_
    #if (defined(_WIN32) || defined(_WIN64))
        #include <winsock2.h>
        #include <windows.h>    
    #endif
#endif

#if defined(_WIN64)
    #define OS_WINDOWS64    1
#endif

#if defined(__LP64__)
    #define OS_POSIX64    1 
#endif

#ifndef __PLAYRECT_defined
    #define __PLAYRECT_defined
    typedef struct __PLAYRECT
    {
        int x;                               
        int y;                                  
        int uWidth;                            
        int uHeight;                            
    }PLAYRECT;
#endif

#if (defined(_WIN32)) //windows
    #define NET_DVR_API  extern "C" __declspec(dllimport)
    typedef  unsigned __int64   UINT64;
    typedef  signed   __int64   INT64;
#elif defined(__linux__) || defined(__APPLE__) //linux
    #define  BOOL  int
    typedef  unsigned int       DWORD;
    typedef  unsigned short     WORD;
    typedef  unsigned short     USHORT;
    typedef  short              SHORT;
    typedef  int                LONG;
    typedef  unsigned char      BYTE;
    typedef  unsigned int       UINT;
    typedef  void*              LPVOID;
    typedef  void*              HANDLE;
    typedef  unsigned int*      LPDWORD; 
    typedef  unsigned long long UINT64;
    typedef  signed long long   INT64;

    #ifndef TRUE
        #define TRUE  1
    #endif
    #ifndef FALSE
        #define FALSE 0
    #endif
    #ifndef NULL
        #define NULL 0
    #endif

    #define __stdcall 
    #define CALLBACK  

    #define NET_DVR_API extern "C"
    typedef unsigned int   COLORKEY;
    typedef unsigned int   COLORREF;

    #ifndef __HWND_defined
        #define __HWND_defined
        #if defined(__linux__)
            typedef unsigned int HWND;
        #else
            typedef void* HWND;
        #endif
    #endif

    #ifndef __HDC_defined
        #define __HDC_defined
        #if defined(__linux__)
            typedef struct __DC
            {
                void*   surface;        //SDL Surface
                HWND    hWnd;           //HDC window handle
            }DC;
            typedef DC* HDC;
        #else
            typedef void* HDC;
        #endif
    #endif

    typedef struct tagInitInfo
    {
        int uWidth; 
        int uHeight; 
    }INITINFO; 
#endif

//�궨��
#define MAX_NAMELEN                16        //DVR���ص�½��
#define MAX_RIGHT                32        //�豸֧�ֵ�Ȩ�ޣ�1-12��ʾ����Ȩ�ޣ�13-32��ʾԶ��Ȩ�ޣ�
#define NAME_LEN                32      //�û�������
#define MIN_PASSWD_LEN          8          //��С���볤��
#define PASSWD_LEN                16      //���볤��
#define STREAM_PASSWD_LEN         12      //����������Կ��󳤶�
#define MAX_PASSWD_LEN_EX            64      //���볤��64λ
#define GUID_LEN                16      //GUID����
#define DEV_TYPE_NAME_LEN        24      //�豸�������Ƴ���
#define SERIALNO_LEN            48      //���кų���
#define MACADDR_LEN                6       //mac��ַ����
#define MAC_ADDRESS_NUM         48      //Mac��ַ����
#define MAX_SENCE_NUM           16      //������
#define RULE_REGION_MAX         128      //�������
#define MAX_ETHERNET            2       //�豸������̫����
#define MAX_NETWORK_CARD        4       //�豸�������������Ŀ
#define MAX_NETWORK_CARD_EX     12      //�豸�������������Ŀ��չ
#define PATHNAME_LEN            128     //·������
#define MAX_PRESET_V13          16      //Ԥ�õ�
#define MAX_TEST_COMMAND_NUM   32      //���߲��Ա����ֶγ���
#define MAX_NUMBER_LEN            32        //������󳤶�
#define MAX_NAME_LEN            128        //�豸������󳤶�
#define MAX_INDEX_LED           8       //LED�������ֵ 2013-11-19
#define    MAX_CUSTOM_DIR            64      //�Զ���Ŀ¼��󳤶�
#define URL_LEN_V40             256        //���URL����
#define CLOUD_NAME_LEN          48      //�ƴ洢�������û�������
#define CLOUD_PASSWD_LEN        48      //�ƴ洢���������볤��
#define MAX_SENSORNAME_LEN      64      //���������Ƴ���
#define MAX_SENSORCHAN_LEN      32      //������ͨ������
#define MAX_DESCRIPTION_LEN     32      //��������������
#define MAX_DEVNAME_LEN_EX      64      //�豸���Ƴ�����չ
#define NET_SDK_MAX_FILE_PATH   256     //�ļ�·������ 
#define MAX_TMEVOICE_LEN        64      //TME�����������ݳ���
#define ISO_8601_LEN            32      //ISO_8601ʱ�䳤��
#define MODULE_INFO_LEN            32    //ģ����Ϣ����
#define VERSION_INFO_LEN        32    //�汾��Ϣ����

#define MAX_NUM_INPUT_BOARD     512     //�����������
#define MAX_SHIPSDETE_REGION_NUM    8 // ��ֻ��������б������Ŀ

#define MAX_RES_NUM_ONE_VS_INPUT_CHAN  8  //һ������������ͨ��֧�ֵķֱ��ʵ��������
#define MAX_VS_INPUT_CHAN_NUM  16  //����������ͨ���������

#define NET_SDK_MAX_FDID_LEN 256//������ID��󳤶�
#define NET_SDK_MAX_PICID_LEN 256 //����ID��󳤶�
#define NET_SDK_FDPIC_CUSTOM_INFO_LEN 96 //������ͼƬ�Զ�����Ϣ����
#define NET_DVR_MAX_FACE_ANALYSIS_NUM      32   //���֧�ֵ���ͼƬʶ����������������
#define NET_DVR_MAX_FACE_SEARCH_NUM      5   //���֧�����������������
#define NET_SDK_SECRETKEY_LEN      128   //�����ļ���Կ����
#define NET_SDK_CUSTOM_LEN                  512 //�Զ�����Ϣ��󳤶�
#define NET_SDK_CHECK_CODE_LEN          128//У���볤��
#define RELATIVE_CHANNEL_LEN        2//����������ͨ���ŵ�����
#define NET_SDK_MAX_CALLEDTARGET_NAME 32 //�º���Ŀ����û���
//С���LED������
#define  MAX_LEN_TEXT_CONTENT    128  //�ַ����ݳ���
#define  MAX_NUM_INPUT_SOURCE_TEXT    32    //�ź�Դ�ɵ��ӵ��ı�����
#define  MAX_NUM_OUTPUT_CHANNEL  512  //LED�������������ڸ���

//�Ӵ��ڽ���OSD
#define MAX_LEN_OSD_CONTENT  256  //OSD��Ϣ��󳤶�
#define MAX_NUM_OSD_ONE_SUBWND  8  //�����Ӵ���֧�ֵ����OSD����
#define MAX_NUM_SPLIT_WND  64 //��������֧�ֵ��������������������Ӵ���������
#define MAX_NUM_OSD 8

//2013-11-19
#define MAX_DEVNAME_LEN         32      //�豸������󳤶�
#define MAX_LED_INFO            256     //��Ļ������ʾ��Ϣ��󳤶�
#define MAX_TIME_LEN            32      //ʱ����󳤶�
#define MAX_CARD_LEN            24      //������󳤶�
#define MAX_OPERATORNAME_LEN    32      //������Ա������󳤶�

#define THERMOMETRY_ALARMRULE_NUM 40     //�ȳ��񱨾�������
#define MAX_THERMOMETRY_REGION_NUM  40  //�ȶ�ͼ����������֧����
#define MAX_THERMOMETRY_DIFFCOMPARISON_NUM  40 //�ȳ����²��������
#define MAX_SHIPS_NUM           20      //��ֻ������ֻ��
#define KEY_WORD_NUM             3 //�ؼ��ָ���
#define KEY_WORD_LEN            128  //�ؼ��ֳ���
//�첽��¼�ص�״̬�궨��
#define ASYN_LOGIN_SUCC            1        //�첽��¼�ɹ�
#define ASYN_LOGIN_FAILED        0        //�첽��¼ʧ��

#define NET_SDK_MAX_VERIFICATION_CODE_LEN  32        //өʯ����֤�볤��
#define NET_SDK_MAX_OPERATE_CODE_LEN  64        //өʯ�Ʋ����볤��
#define MAX_TIMESEGMENT_V30        8       //9000�豸���ʱ�����
#define MAX_TIMESEGMENT            4       //8000�豸���ʱ�����
#define MAX_ICR_NUM             8       //ץ�Ļ������˹�ƬԤ�õ���2013-07-09
#define MAX_VEHICLEFLOW_INFO                       24       //��������Ϣ������
#define MAX_SHELTERNUM            4       //8000�豸����ڵ�������
#define MAX_DAYS                7       //ÿ������
#define PHONENUMBER_LEN            32      //pppoe���ź�����󳤶�
#define MAX_ACCESSORY_CARD      256      //�������Ϣ��󳤶�
#define MAX_DISKNUM_V30            33        //9000�豸���Ӳ����/* ���33��Ӳ��(����16������SATAӲ�̡�1��eSATAӲ�̺�16��NFS��) */

#define NET_SDK_DISK_LOCATION_LEN  16      //Ӳ��λ�ó���
#define NET_SDK_SUPPLIER_NAME_LEN  32      //��Ӧ�����Ƴ���
#define NET_SDK_DISK_MODEL_LEN     64      //Ӳ���ͺų���
#define NET_SDK_MAX_DISK_VOLUME    33      //���Ӳ�̾����
#define NET_SDK_DISK_VOLUME_LEN    36      //Ӳ�̾����Ƴ���

#define MAX_DISKNUM                16      //8000�豸���Ӳ����
#define MAX_DISKNUM_V10            8       //1.2�汾֮ǰ�汾
#define CARD_READER_DESCRIPTION    32            //����������
#define MAX_FACE_NUM               2             //���������

#define MAX_WINDOW_V30            32      //9000�豸������ʾ��󲥷Ŵ�����
#define MAX_WINDOW_V40            64      //Netra 2.3.1��չ
#define MAX_WINDOW                16      //8000�豸���Ӳ����
#define MAX_VGA_V30                4       //9000�豸���ɽ�VGA��
#define MAX_VGA                    1       //8000�豸���ɽ�VGA��

#define MAX_USERNUM_V30            32      //9000�豸����û���
#define MAX_USERNUM                16      //8000�豸����û���
#define MAX_EXCEPTIONNUM_V30    32      //9000�豸����쳣������
#define MAX_EXCEPTIONNUM        16      //8000�豸����쳣������
#define MAX_LINK                6       //8000�豸��ͨ�������Ƶ��������
#define MAX_ITC_EXCEPTIONOUT    32      //ץ�Ļ���󱨾����
#define MAX_SCREEN_DISPLAY_LEN            512    //��Ļ��ʾ�ַ�����

#define MAX_DECPOOLNUM            4       //��·������ÿ������ͨ������ѭ��������
#define MAX_DECNUM                4       //��·��������������ͨ������ʵ��ֻ��һ������������������
#define MAX_TRANSPARENTNUM        2       //��·���������������͸��ͨ����
#define MAX_CYCLE_CHAN            16      //��·�����������Ѳͨ����
#define MAX_CYCLE_CHAN_V30      64      //�����Ѳͨ��������չ��
#define MAX_DIRNAME_LENGTH        80      //���Ŀ¼����
#define MAX_WINDOWS                16      //��󴰿���


#define MAX_STRINGNUM_V30        8        //9000�豸���OSD�ַ�������
#define MAX_STRINGNUM            4       //8000�豸���OSD�ַ�������
#define MAX_STRINGNUM_EX        8       //8000������չ
#define MAX_AUXOUT_V30            16      //9000�豸����������
#define MAX_AUXOUT                4       //8000�豸����������
#define MAX_HD_GROUP            16      //9000�豸���Ӳ������
#define MAX_HD_GROUP_V40        32      //�豸���Ӳ������
#define MAX_NFS_DISK            8       //8000�豸���NFSӲ����
#define NET_SDK_VERSION_LIST_LEN 64 //�㷨��汾���ֵ
#define IW_ESSID_MAX_SIZE        32      //WIFI��SSID�ų���
#define IW_ENCODING_TOKEN_MAX    32      //WIFI��������ֽ���
#define MAX_SERIAL_NUM            64        //���֧�ֵ�͸��ͨ��·��
#define MAX_DDNS_NUMS            10      //9000�豸������ddns��
#define MAX_DOMAIN_NAME            64        /* ����������� */
#define MAX_EMAIL_ADDR_LEN        48      //���email��ַ����
#define MAX_EMAIL_PWD_LEN        32      //���email���볤��
#define MAX_SLAVECAMERA_NUM     8       //�����������
#define MAX_CALIB_NUM           6       //�궨��ĸ���
#define MAX_CALIB_NUM_EX        20      //��չ�궨��ĸ���   
#define MAX_LEDDISPLAYINFO_LEN  1024    //���LED����ʾ����
#define MAX_PEOPLE_DETECTION_NUM    8  //�����Ա���������
#define MAXPROGRESS                100     //�ط�ʱ�����ٷ���
#define MAX_SERIALNUM            2       //8000�豸֧�ֵĴ����� 1-232�� 2-485
#define CARDNUM_LEN                20      //���ų���
#define PATIENTID_LEN              64
#define CARDNUM_LEN_OUT            32      //�ⲿ�ṹ�忨�ų���
#define MAX_VIDEOOUT_V30        4       //9000�豸����Ƶ�����
#define MAX_VIDEOOUT            2       //8000�豸����Ƶ�����

#define MAX_PRESET_V30            256        /* 9000�豸֧�ֵ���̨Ԥ�õ��� */
#define MAX_TRACK_V30            256        /* 9000�豸֧�ֵ���̨�켣�� */
#define MAX_CRUISE_V30            256        /* 9000�豸֧�ֵ���̨Ѳ���� */
#define MAX_PRESET                128        /* 8000�豸֧�ֵ���̨Ԥ�õ��� */
#define MAX_TRACK                128        /* 8000�豸֧�ֵ���̨�켣�� */
#define MAX_CRUISE                128        /* 8000�豸֧�ֵ���̨Ѳ���� */

#define MAX_PRESET_V40            300        /* ��̨֧�ֵ����Ԥ�õ��� */
#define MAX_CRUISE_POINT_NUM    128     /* ���֧�ֵ�Ѳ����ĸ��� */
#define MAX_CRUISEPOINT_NUM_V50 256     //���֧�ֵ�Ѳ����ĸ�����չ

#define CRUISE_MAX_PRESET_NUMS    32         /* һ��Ѳ������Ѳ���� */
#define MAX_FACE_PIC_NUM        30      /*������ͼ����*/
#define LOCKGATE_TIME_NUM       4       //��բʱ��θ���

#define MAX_SERIAL_PORT         8       //9000�豸֧��232������
#define MAX_PREVIEW_MODE        8       /* �豸֧�����Ԥ��ģʽ��Ŀ 1����,4����,9����,16����.... */
#define MAX_MATRIXOUT           16      /* ���ģ������������ */
#define LOG_INFO_LEN            11840   /* ��־������Ϣ */
#define DESC_LEN                16      /* ��̨�����ַ������� */
#define PTZ_PROTOCOL_NUM        200     /* 9000���֧�ֵ���̨Э���� */
#define IPC_PROTOCOL_NUM        50   //ipc Э��������

#define MAX_AUDIO                1       //8000�����Խ�ͨ����
#define MAX_AUDIO_V30            2       //9000�����Խ�ͨ����
#define MAX_CHANNUM                16      //8000�豸���ͨ����
#define MAX_ALARMIN                16      //8000�豸��󱨾�������
#define MAX_ALARMOUT            4       //8000�豸��󱨾������
//9000 IPC����
#define MAX_ANALOG_CHANNUM      32      //���32��ģ��ͨ��
#define MAX_ANALOG_ALARMOUT     32      //���32·ģ�ⱨ����� 
#define MAX_ANALOG_ALARMIN      32      //���32·ģ�ⱨ������

#define MAX_IP_DEVICE           32      //�����������IP�豸��
#define MAX_IP_DEVICE_V40       64      // �����������IP�豸�� �������64�� IVMS 2000�����豸
#define MAX_IP_CHANNEL          32      //�����������IPͨ����
#define MAX_IP_ALARMIN          128     //����������౨��������
#define MAX_IP_ALARMOUT         64      //����������౨�������
#define MAX_IP_ALARMIN_V40      4096    //����������౨��������
#define MAX_IP_ALARMOUT_V40     4096    //����������౨�������

#define MAX_RECORD_FILE_NUM     20      // ÿ��ɾ�����߿�¼������ļ���
//SDK_V31 ATM
#define MAX_ACTION_TYPE            12        //�Զ���Э����ӽ�����Ϊ�����Ϊ���� 
#define MAX_ATM_PROTOCOL_NUM    256   //ÿ�����뷽ʽ��Ӧ��ATM���Э����
#define ATM_CUSTOM_PROTO        1025   //�Զ���Э�� ֵΪ1025
#define ATM_PROTOCOL_SORT       4       //ATMЭ����� 
#define ATM_DESC_LEN            32      //ATM�����ַ�������
// SDK_V31 ATM


#define MAX_IPV6_LEN              64   //IPv6��ַ��󳤶�
#define MAX_EVENTID_LEN         64   //�¼�ID����

#define INVALID_VALUE_UINT32    0xffffffff   //��Чֵ
#define MAX_CHANNUM_V40         512
#define MAX_MULTI_AREA_NUM      24

//SDK ¼������
#define COURSE_NAME_LEN                32    //�γ�����
#define INSTRUCTOR_NAME_LEN            16    //�ڿν�ʦ
#define COURSE_DESCRIPTION_LEN        256    //�γ���Ϣ

#define MAX_TIMESEGMENT_V40            16    //ÿ�ڿ���Ϣ


#define MAX_MIX_CHAN_NUM        16    /*Ŀǰ֧�ֵ�������ͨ����������ͨ�� + MIC + LINE IN + ���4��С����*/ 
#define MAX_LINE_IN_CHAN_NUM    16    //���line inͨ����
#define MAX_MIC_CHAN_NUM        16    //���MICͨ����
#define INQUEST_CASE_NO_LEN        64    //��Ѷ������ų���
#define INQUEST_CASE_NAME_LEN    64    //��Ѷ�������Ƴ���
#define CUSTOM_INFO_LEN            64    //�Զ�����Ϣ����
#define INQUEST_CASE_LEN        64    //��Ѷ��Ϣ����


#define MAX_FILE_ID_LEN         128    //��ͼ����Ŀ���ļ�ID����󳤶�
#define MAX_PIC_NAME_LEN        128 //ͼƬ���Ƴ���

/* ���֧�ֵ�ͨ���� ���ģ��������IP֧�� */
#define MAX_CHANNUM_V30               ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL )//64
#define MAX_ALARMOUT_V40             (MAX_IP_ALARMOUT_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ALARMOUT_V30              ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT )//96
#define MAX_ALARMIN_V30               ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN )//160
#define MAX_ALARMIN_V40             (MAX_IP_ALARMIN_V40 +MAX_ANALOG_ALARMOUT) //4128
#define MAX_ANALOG_ALARM_WITH_VOLT_LIMIT    16 //�ܵ�ѹ�޶���ģ�ⱨ�����������

#define MAX_ROIDETECT_NUM       8    //֧�ֵ�ROI������
#define MAX_LANERECT_NUM        5    //�����ʶ��������
#define MAX_FORTIFY_NUM         10   //��󲼷�����
#define MAX_INTERVAL_NUM        4    //���ʱ��������
#define MAX_CHJC_NUM            3    //�����ʡ�ݼ���ַ�����
#define MAX_VL_NUM              5    //���������Ȧ����
#define MAX_DRIVECHAN_NUM       16   //��󳵵���
#define MAX_COIL_NUM            3    //�����Ȧ����
#define MAX_SIGNALLIGHT_NUM     6   //����źŵƸ���
#define LEN_16                    16
#define LEN_32                    32
#define LEN_64                    64
#define LEN_31                    31 
#define	MAX_LINKAGE_CHAN_NUM      16  //����������ͨ�����������
#define MAX_CABINET_COUNT       8    //���֧�ֻ�������
#define MAX_ID_LEN              48
#define MAX_PARKNO_LEN          16
#define MAX_ALARMREASON_LEN     32
#define MAX_UPGRADE_INFO_LEN    48 //��ȡ�����ļ�ƥ����Ϣ(ģ������)
#define MAX_CUSTOMDIR_LEN       32 //�Զ���Ŀ¼����
#define MAX_LED_INFO_LEN        512//LED���ݳ���
#define MAX_VOICE_INFO_LEN      128//�����������ݳ���
#define MAX_LITLE_INFO_LEN      64 //ֽƱ�������ݳ���
#define MAX_CUSTOM_INFO_LEN     64 //ֽƱ�Զ�����Ϣ���ݳ���
#define MAX_PHONE_NUM_LEN       16 //��ϵ�绰���ݳ���
#define MAX_APP_SERIALNUM_LEN   32 //Ӧ�����кų���

#define AUDIOTALKTYPE_G722       0
#define AUDIOTALKTYPE_G711_MU    1
#define AUDIOTALKTYPE_G711_A     2
#define AUDIOTALKTYPE_MP2L2      5
#define AUDIOTALKTYPE_G726         6
#define AUDIOTALKTYPE_AAC         7
#define AUDIOTALKTYPE_PCM         8
#define AUDIOTALKTYPE_G722C       9
#define AUDIOTALKTYPE_MP3         15

//packet type
#define FILE_HEAD            0 //file head
#define VIDEO_I_FRAME        1 //video I frame
#define VIDEO_B_FRAME        2 //video B frame
#define VIDEO_P_FRAME        3 //video P frame
#define AUDIO_PACKET        10 //audio packet
#define PRIVT_PACKET        11 //private packet
//E frame
#define HIK_H264_E_FRAME    (1 << 6)   // ��ǰE֡������,��P֡Ҳû�õ�
#define MAX_TRANSPARENT_CHAN_NUM      4   //ÿ�����������������͸��ͨ����
#define MAX_TRANSPARENT_ACCESS_NUM    4   //ÿ�������˿������������������

//ITS
#define MAX_PARKING_STATUS       8    //��λ״̬ 0�����޳���1�����г���2����ѹ��(���ȼ����), 3���⳵λ 
#define MAX_PARKING_NUM             4    //һ��ͨ�����4����λ (�����ҳ�λ ����0��3)

#define MAX_ITS_SCENE_NUM        16   //��󳡾�����
#define MAX_SCENE_TIMESEG_NUM    16   //��󳡾�ʱ�������
#define MAX_IVMS_IP_CHANNEL      128  //���IPͨ����
#define DEVICE_ID_LEN            48   //�豸��ų���
#define MONITORSITE_ID_LEN       48   //�����ų���
#define MAX_AUXAREA_NUM          16   //�������������Ŀ
#define MAX_SLAVE_CHANNEL_NUM    16   //����ͨ������
#define MAX_DEVDESC_LEN          64   //�豸������Ϣ��󳤶�
#define ILLEGAL_LEN       32      //Υ�����볤��
#define MAX_TRUCK_AXLE_NUM      10      //�����������
#define MAX_CATEGORY_LEN        8       //���Ƹ�����Ϣ����ַ�
#define SERIAL_NO_LEN           16      //����λ���


#define MAX_SECRETKEY_LEN           512     //�����Կ����
#define MAX_INDEX_CODE_LEN          64      //�����ų���
#define MAX_ILLEGAL_LEN          64     //Υ����������ַ�����
#define CODE_LEN        64  //��Ȩ��
#define ALIAS_LEN       32  //������ֻ��
#define MAX_SCH_TASKS_NUM        10

#define MAX_SERVERID_LEN            64 //��������ID�ĳ���
#define MAX_SERVERDOMAIN_LEN        128 //������������󳤶�
#define MAX_AUTHENTICATEID_LEN      64 //��֤ID��󳤶�
#define MAX_AUTHENTICATEPASSWD_LEN  32 //��֤������󳤶�
#define MAX_SERVERNAME_LEN          64 //���������û��� 
#define MAX_COMPRESSIONID_LEN       64 //����ID����󳤶�
#define MAX_SIPSERVER_ADDRESS_LEN   128 //SIP��������ַ֧��������IP��ַ
//ѹ�߱���
#define MAX_PlATE_NO_LEN            32   //���ƺ�����󳤶� 2013-09-27
#define UPNP_PORT_NUM                12      //upnp�˿�ӳ��˿���Ŀ

#define MAX_PEOPLE_DETECTION_NUM    8  //�����Ա���������

#define MAX_NOTICE_NUMBER_LEN       32   //��������󳤶�
#define MAX_NOTICE_THEME_LEN        64   //����������󳤶�
#define MAX_NOTICE_DETAIL_LEN       1024 //����������󳤶�
#define MAX_NOTICE_PIC_NUM          6    //������Ϣ���ͼƬ����
#define MAX_DEV_NUMBER_LEN          32   //�豸�����󳤶�
#define LOCK_NAME_LEN                   32  //������


#define HOLIDAY_GROUP_NAME_LEN          32  //���������Ƴ���
#define MAX_HOLIDAY_PLAN_NUM            16  //�����������ռƻ���
#define TEMPLATE_NAME_LEN               32  //�ƻ�ģ�����Ƴ���
#define MAX_HOLIDAY_GROUP_NUM           16   //�ƻ�ģ������������
#define DOOR_NAME_LEN                   32  //������
#define STRESS_PASSWORD_LEN             8   //в�����볤��
#define SUPER_PASSWORD_LEN              8   //в�����볤��
#define GROUP_NAME_LEN                  32  //Ⱥ�����Ƴ���
#define GROUP_COMBINATION_NUM           8   //Ⱥ�������
#define MULTI_CARD_GROUP_NUM            4   //���������ؿ�����
#define ACS_CARD_NO_LEN                 32  //�Ž����ų���
#define NET_SDK_EMPLOYEE_NO_LEN         32  //���ų���
#define NET_SDK_UUID_LEN                36  //UUID����
#define NET_SDK_EHOME_KEY_LEN           32  //EHome Key����
#define CARD_PASSWORD_LEN               8   //�����볤��
#define MAX_DOOR_NUM                    32  //�������
#define MAX_CARD_RIGHT_PLAN_NUM         4   //��Ȩ�����ƻ�����
#define MAX_GROUP_NUM_128               128 //���Ⱥ����
#define MAX_CARD_READER_NUM             64  //����������
#define MAX_SNEAK_PATH_NODE             8   //��������������
#define MAX_MULTI_DOOR_INTERLOCK_GROUP  8   //�����Ż�������
#define MAX_INTER_LOCK_DOOR_NUM         8   //һ�����Ż����������������
#define MAX_CASE_SENSOR_NUM             8   //���case sensor��������
#define MAX_DOOR_NUM_256                256 //�������
#define MAX_READER_ROUTE_NUM            16  //���ˢ��ѭ��·�� 
#define MAX_FINGER_PRINT_NUM            10  //���ָ�Ƹ���
#define MAX_CARD_READER_NUM_512            512 //����������
#define NET_SDK_MULTI_CARD_GROUP_NUM_20     20   //���������ؿ�����

#define ERROR_MSG_LEN      32 //�·�������Ϣ
#define MAX_DOOR_CODE_LEN               8 //������볤��
#define MAX_LOCK_CODE_LEN               8 //�����볤��
#define PER_RING_PORT_NUM                2   //ÿ�����Ķ˿���
#define SENSORNAME_LEN                  32  //���������Ƴ���
#define MAX_SENSORDESCR_LEN             64  //��������������
#define MAX_DNS_SERVER_NUM              2 //���DNS����
#define SENSORUNIT_LEN                  32 //���λ����

#define WEP_KEY_MAX_SIZE                32 //���WEP������Կ����
#define WEP_KEY_MAX_NUM                 4  //���WEP������Կ����
#define WPA_KEY_MAX_SIZE                64 //���WPA������Կ����

#define MAX_SINGLE_FTPPICNAME_LEN       20 //��󵥸�FTPͨ������
#define MAX_CAMNAME_LEN                 32 //���ͨ������
#define MAX_FTPNAME_NUM                 12 //TFP������


#define MAX_IDCODE_LEN      128 //  ʶ������󳤶�
#define MAX_VERSIIN_LEN     64  //�汾��󳤶�
#define MAX_IDCODE_NUM      32  // ʶ�������
#define SDK_LEN_2048        2048
#define SDK_MAX_IP_LEN 48

#define RECT_POINT_NUM                    4    //���ν���

#define MAX_PUBLIC_KEY_LEN 512 // ���Կ����
#define CHIP_SERIALNO_LEN 32 //����оƬ���кų���
#define ENCRYPT_DEV_ID_LEN        20  //�豸ID����

//MCU��ص�
#define MAX_SEARCH_ID_LEN               36  //������ʶ����󳤶�
#define TERMINAL_NAME_LEN               64  //�ն����Ƴ���
#define MAX_URL_LEN                     512 //URL����
#define REGISTER_NAME_LEN               64 //�ն�ע��GK������󳤶�

//����
#define MAX_PORT_NUM            64  //���˿���
#define MAX_SINGLE_CARD_PORT_NO 4   //�����շ����������˿���
#define MAX_FUNC_CARD_NUM       32  //�����շ�������ܿ���
#define MAX_FC_CARD_NUM         33  //�����շ��������
#define MAX_REMARKS_LEN         128 //ע����󳤶�
#define MAX_OUTPUT_PORT_NUM                32    //��·����������������˿���
#define MAX_SINGLE_PORT_RECVCARD_NUM    64    //�����˿����ӵ������տ���
#define MAX_GAMMA_X_VALUE                256    //GAMMA��X��ȡֵ����
#define NET_DEV_NAME_LEN        64  //�豸���Ƴ���
#define NET_DEV_TYPE_NAME_LEN  64  //�豸�������Ƴ���
#define ABNORMAL_INFO_NUM               4        //�쳣ʱ��θ���

#define PLAYLIST_NAME_LEN                64            //���ű����Ƴ��� 
#define PLAYLIST_ITEM_NUM                64            //��������Ŀ  

//������
#define NET_SDK_MAX_LOGIN_PASSWORD_LEN           128 //�û���¼������󳤶�
#define NET_SDK_MAX_ANSWER_LEN                   256 //��ȫ�������󳤶�
#define NET_SDK_MAX_QUESTION_LIST_LEN            32//��ȫ�����б���󳤶�

#define  MAX_SCREEN_AREA_NUM  128  //��Ļ�����������
#define NET_SDK_MAX_THERMOMETRYALGNAME           128//�����㷨��汾��󳤶�
#define NET_SDK_MAX_SHIPSALGNAME                 128//��ֻ�㷨��汾��󳤶�
#define NET_SDK_MAX_FIRESALGNAME                 128//����㷨��汾��󳤶�

#define MAX_PASSPORT_NUM_LEN          16     //�����֤���ų���
#define MAX_PASSPORT_INFO_LEN         128    //�����ͨ����Ϣ����
#define MAX_PASSPORT_NAME_LEN         64     //�������������
#define MAX_PASSPORT_MONITOR_LEN      1024   //����ռ໤��Ϣ����
#define MAX_NATIONALITY_LEN           16     //����չ�������
#define MAX_PASSPORT_TYPE_LEN         4      //�����֤�����ͳ���

/*******************ȫ�ִ����� begin**********************/    
#define NET_DVR_NOERROR                     0    //û�д���
#define NET_DVR_PASSWORD_ERROR                 1    //�û����������
#define NET_DVR_NOENOUGHPRI                 2    //Ȩ�޲���
#define NET_DVR_NOINIT                         3    //û�г�ʼ��
#define NET_DVR_CHANNEL_ERROR                 4    //ͨ���Ŵ���
#define NET_DVR_OVER_MAXLINK                 5    //���ӵ�DVR�Ŀͻ��˸����������
#define NET_DVR_VERSIONNOMATCH                6    //�汾��ƥ��
#define NET_DVR_NETWORK_FAIL_CONNECT        7    //���ӷ�����ʧ��
#define NET_DVR_NETWORK_SEND_ERROR            8    //�����������ʧ��
#define NET_DVR_NETWORK_RECV_ERROR            9    //�ӷ�������������ʧ��
#define NET_DVR_NETWORK_RECV_TIMEOUT        10    //�ӷ������������ݳ�ʱ
#define NET_DVR_NETWORK_ERRORDATA            11    //���͵���������
#define NET_DVR_ORDER_ERROR                    12    //���ô������
#define NET_DVR_OPERNOPERMIT                13    //�޴�Ȩ��
#define NET_DVR_COMMANDTIMEOUT                14    //DVR����ִ�г�ʱ
#define NET_DVR_ERRORSERIALPORT                15    //���ںŴ���
#define NET_DVR_ERRORALARMPORT                16    //�����˿ڴ���
#define NET_DVR_PARAMETER_ERROR             17  //��������
#define NET_DVR_CHAN_EXCEPTION                18    //������ͨ�����ڴ���״̬
#define NET_DVR_NODISK                        19    //û��Ӳ��
#define NET_DVR_ERRORDISKNUM                20    //Ӳ�̺Ŵ���
#define NET_DVR_DISK_FULL                    21    //������Ӳ����
#define NET_DVR_DISK_ERROR                    22    //������Ӳ�̳���
#define NET_DVR_NOSUPPORT                    23    //��������֧��
#define NET_DVR_BUSY                        24    //������æ
#define NET_DVR_MODIFY_FAIL                    25    //�������޸Ĳ��ɹ�
#define NET_DVR_PASSWORD_FORMAT_ERROR        26    //���������ʽ����ȷ
#define NET_DVR_DISK_FORMATING                27    //Ӳ�����ڸ�ʽ����������������
#define NET_DVR_DVRNORESOURCE                28    //DVR��Դ����
#define    NET_DVR_DVROPRATEFAILED                29  //DVR����ʧ��
#define NET_DVR_OPENHOSTSOUND_FAIL             30  //��PC����ʧ��
#define NET_DVR_DVRVOICEOPENED                 31  //�����������Խ���ռ��
#define    NET_DVR_TIMEINPUTERROR                32  //ʱ�����벻��ȷ
#define    NET_DVR_NOSPECFILE                    33  //�ط�ʱ������û��ָ�����ļ�
#define NET_DVR_CREATEFILE_ERROR            34    //�����ļ�����
#define    NET_DVR_FILEOPENFAIL                35  //���ļ�����
#define    NET_DVR_OPERNOTFINISH                36  //�ϴεĲ�����û�����
#define    NET_DVR_GETPLAYTIMEFAIL                37  //��ȡ��ǰ���ŵ�ʱ�����
#define    NET_DVR_PLAYFAIL                    38  //���ų���
#define NET_DVR_FILEFORMAT_ERROR            39  //�ļ���ʽ����ȷ
#define NET_DVR_DIR_ERROR                    40    //·������
#define NET_DVR_ALLOC_RESOURCE_ERROR        41  //��Դ�������
#define NET_DVR_AUDIO_MODE_ERROR            42    //����ģʽ����
#define NET_DVR_NOENOUGH_BUF                43    //������̫С
#define NET_DVR_CREATESOCKET_ERROR             44    //����SOCKET����
#define NET_DVR_SETSOCKET_ERROR                45    //����SOCKET����
#define NET_DVR_MAX_NUM                        46    //�����ﵽ���
#define NET_DVR_USERNOTEXIST                47    //�û�������
#define NET_DVR_WRITEFLASHERROR                48  //дFLASH����
#define NET_DVR_UPGRADEFAIL                    49  //DVR����ʧ��
#define NET_DVR_CARDHAVEINIT                50  //���뿨�Ѿ���ʼ����
#define NET_DVR_PLAYERFAILED                51    //���ò��ſ���ĳ������ʧ��
#define NET_DVR_MAX_USERNUM                    52  //�豸���û����ﵽ���
#define NET_DVR_GETLOCALIPANDMACFAIL        53  //��ÿͻ��˵�IP��ַ�������ַʧ��
#define NET_DVR_NOENCODEING                    54    //��ͨ��û�б���
#define NET_DVR_IPMISMATCH                    55    //IP��ַ��ƥ��
#define NET_DVR_MACMISMATCH                    56    //MAC��ַ��ƥ��
#define NET_DVR_UPGRADELANGMISMATCH            57    //�����ļ����Բ�ƥ��
#define NET_DVR_MAX_PLAYERPORT                58    //������·���ﵽ���
#define NET_DVR_NOSPACEBACKUP                59    //�����豸��û���㹻�ռ���б���
#define NET_DVR_NODEVICEBACKUP                60    //û���ҵ�ָ���ı����豸
#define NET_DVR_PICTURE_BITS_ERROR            61    //ͼ����λ����������24ɫ
#define NET_DVR_PICTURE_DIMENSION_ERROR        62    //ͼƬ��*���ޣ� ��128*256
#define NET_DVR_PICTURE_SIZ_ERROR            63    //ͼƬ��С���ޣ���100K
#define NET_DVR_LOADPLAYERSDKFAILED            64    //���뵱ǰĿ¼��Player Sdk����
#define NET_DVR_LOADPLAYERSDKPROC_ERROR        65    //�Ҳ���Player Sdk��ĳ���������
#define NET_DVR_LOADDSSDKFAILED                66    //���뵱ǰĿ¼��DSsdk����
#define NET_DVR_LOADDSSDKPROC_ERROR            67    //�Ҳ���DsSdk��ĳ���������
#define NET_DVR_DSSDK_ERROR                    68    //����Ӳ�����DsSdk��ĳ������ʧ��
#define NET_DVR_VOICEMONOPOLIZE                69    //��������ռ
#define NET_DVR_JOINMULTICASTFAILED            70    //����ಥ��ʧ��
#define NET_DVR_CREATEDIR_ERROR                71    //������־�ļ�Ŀ¼ʧ��
#define NET_DVR_BINDSOCKET_ERROR            72    //���׽���ʧ��
#define NET_DVR_SOCKETCLOSE_ERROR            73    //socket�����жϣ��˴���ͨ�������������жϻ�Ŀ�ĵز��ɴ�
#define NET_DVR_USERID_ISUSING                74    //ע��ʱ�û�ID���ڽ���ĳ����
#define NET_DVR_SOCKETLISTEN_ERROR            75    //����ʧ��
#define NET_DVR_PROGRAM_EXCEPTION            76    //�����쳣
#define NET_DVR_WRITEFILE_FAILED            77    //д�ļ�ʧ��
#define NET_DVR_FORMAT_READONLY                78  //��ֹ��ʽ��ֻ��Ӳ��
#define NET_DVR_WITHSAMEUSERNAME            79  //�û����ýṹ�д�����ͬ���û���
#define NET_DVR_DEVICETYPE_ERROR            80  /*�������ʱ�豸�ͺŲ�ƥ��*/
#define NET_DVR_LANGUAGE_ERROR              81  /*�������ʱ���Բ�ƥ��*/
#define NET_DVR_PARAVERSION_ERROR           82  /*�������ʱ����汾��ƥ��*/
#define NET_DVR_IPCHAN_NOTALIVE             83  /*Ԥ��ʱ���IPͨ��������*/
#define NET_DVR_RTSP_SDK_ERROR                84    /*���ظ���IPCͨѶ��StreamTransClient.dllʧ��*/
#define NET_DVR_CONVERT_SDK_ERROR            85    /*����ת���ʧ��*/
#define NET_DVR_IPC_COUNT_OVERFLOW            86  /*��������ip����ͨ����*/
#define NET_DVR_MAX_ADD_NUM                 87  /*��ӱ�ǩ(һ���ļ�Ƭ��64)�ȸ����ﵽ���*/
#define NET_DVR_PARAMMODE_ERROR             88 //ͼ����ǿ�ǣ�����ģʽ��������Ӳ������ʱ���ͻ��˽����������ʱ����ֵ��
#define NET_DVR_CODESPITTER_OFFLINE            89 //��Ƶ�ۺ�ƽ̨�������������
#define NET_DVR_BACKUP_COPYING                90  //�豸���ڱ���
#define NET_DVR_CHAN_NOTSUPPORT             91  // ͨ����֧�ָò���
#define NET_DVR_CALLINEINVALID              92  // �߶���λ��̫���л򳤶��߲�����б 
#define NET_DVR_CALCANCELCONFLICT           93  // ȡ���궨��ͻ����������˹���ȫ�ֵ�ʵ�ʴ�С�ߴ����
#define NET_DVR_CALPOINTOUTRANGE            94     // �궨�㳬����Χ 
#define NET_DVR_FILTERRECTINVALID           95  // �ߴ������������Ҫ��
#define NET_DVR_DDNS_DEVOFFLINE             96  //�豸û��ע�ᵽddns��
#define NET_DVR_DDNS_INTER_ERROR            97  //DDNS �������ڲ�����
#define NET_DVR_FUNCTION_NOT_SUPPORT_OS     98  //�˹��ܲ�֧�ָò���ϵͳ
#define NET_DVR_DEC_CHAN_REBIND             99  //����ͨ������ʾ�����������
#define NET_DVR_INTERCOM_SDK_ERROR          100 //���ص�ǰĿ¼�µ������Խ���ʧ��
#define NET_DVR_NO_CURRENT_UPDATEFILE       101 //û����ȷ��������  
#define NET_DVR_USER_NOT_SUCC_LOGIN         102  //�û���û��½�ɹ�
#define NET_DVR_USE_LOG_SWITCH_FILE            103  //����ʹ����־�����ļ�
#define NET_DVR_POOL_PORT_EXHAUST            104  //�˿ڳ������ڰ󶨵Ķ˿��Ѻľ�
#define    NET_DVR_PACKET_TYPE_NOT_SUPPORT        105    //������װ��ʽ����
#define NET_DVR_IPPARA_IPID_ERROR           106  //IP��������ʱIPID����

#define NET_DVR_LOAD_HCPREVIEW_SDK_ERROR           107         //Ԥ���������ʧ��
#define NET_DVR_LOAD_HCVOICETALK_SDK_ERROR         108         //�����������ʧ��
#define NET_DVR_LOAD_HCALARM_SDK_ERROR             109         //�����������ʧ��
#define NET_DVR_LOAD_HCPLAYBACK_SDK_ERROR          110         //�ط��������ʧ��
#define NET_DVR_LOAD_HCDISPLAY_SDK_ERROR           111         //��ʾ�������ʧ��
#define NET_DVR_LOAD_HCINDUSTRY_SDK_ERROR          112         //��ҵӦ���������ʧ��
#define NET_DVR_LOAD_HCGENERALCFGMGR_SDK_ERROR     113         //ͨ�����ù����������ʧ��
#define NET_DVR_LOAD_HCCOREDEVCFG_SDK_ERROR        114         //�豸���ú����������ʧ��
#define NET_DVR_LOAD_HCNETUTILS_SDK_ERROR          115         //HCNetUtils����ʧ��

#define NET_DVR_CORE_VER_MISMATCH                  121    //�����������ʱ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCPREVIEW        122    //Ԥ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCVOICETALK      123    //���������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCALARM          124    //���������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCPLAYBACK       125    //�ط������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCDISPLAY        126    //��ʾ�����core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCINDUSTRY       127    //��ҵӦ�������core�汾��ƥ��
#define NET_DVR_CORE_VER_MISMATCH_HCGENERALCFGMGR  128    //ͨ�����ù��������core�汾��ƥ��

#define NET_DVR_COM_VER_MISMATCH_HCPREVIEW         136    //Ԥ�������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCVOICETALK       137    //���������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCALARM           138    //���������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCPLAYBACK        139    //�ط������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCDISPLAY         140    //��ʾ�����HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCINDUSTRY        141    //��ҵӦ�������HCNetSDK�汾��ƥ��
#define NET_DVR_COM_VER_MISMATCH_HCGENERALCFGMGR   142    //ͨ�����ù��������HCNetSDK�汾��ƥ��

#define NET_ERR_CONFIG_FILE_IMPORT_FAILED          145  //�����ļ�����ʧ��
#define NET_ERR_CONFIG_FILE_EXPORT_FAILED          146  //�����ļ�����ʧ��
#define NET_DVR_CERTIFICATE_FILE_ERROR      147  //֤�����
#define NET_DVR_LOAD_SSL_LIB_ERROR          148  //����SSL��ʧ�ܣ������ǰ汾��ƥ�䣬Ҳ�����ǲ����ڣ�
#define NET_DVR_SSL_VERSION_NOT_MATCH       149  //SSL��汾��ƥ��

#define NET_DVR_ALIAS_DUPLICATE                150    //�����ظ�  //2011-08-31 ͨ�������������к��������豸���°汾ddns������
#define    NET_DVR_INVALID_COMMUNICATION        151    //��Чͨ��
#define    NET_DVR_USERNAME_NOT_EXIST            152    //�û��������ڣ��û��������ڣ�IPC5.1.7�з�����ȥ�ˣ�����ɾ�����������Ĳ�Ʒ����������ò��ϣ�
#define    NET_DVR_USER_LOCKED                    153 //�û�������
#define NET_DVR_INVALID_USERID              154 //��Ч�û�ID
#define NET_DVR_LOW_LOGIN_VERSION           155 //��¼�汾��
#define NET_DVR_LOAD_LIBEAY32_DLL_ERROR     156 //����libeay32.dll��ʧ��
#define NET_DVR_LOAD_SSLEAY32_DLL_ERROR     157 //����ssleay32.dll��ʧ��
#define NET_ERR_LOAD_LIBICONV           158 //����libiconv��ʧ��
#define NET_ERR_SSL_CONNECT_FAILED      159 //SSL����ʧ��
#define NET_ERR_MCAST_ADDRESS_ERROR      160 //��ȡ�ಥ��ַ����
#define NET_ERR_LOAD_ZLIB                   161 //����zlib.dll��ʧ��
#define NET_ERR_OPENSSL_NO_INIT             162 //Openssl��δ��ʼ��

#define NET_DVR_SERVER_NOT_EXIST         164 //��Ӧ�ķ������Ҳ���,����ʱ����Ĺ��ұ�Ż��߷��������ʹ���
#define NET_DVR_TEST_SERVER_FAIL_CONNECT            165    //���Ӳ��Է�����ʧ��
#define NET_DVR_NAS_SERVER_INVALID_DIR                166    //NAS����������Ŀ¼ʧ�ܣ�Ŀ¼��Ч
#define NET_DVR_NAS_SERVER_NOENOUGH_PRI                167    //NAS����������Ŀ¼ʧ�ܣ�û��Ȩ��
#define NET_DVR_EMAIL_SERVER_NOT_CONFIG_DNS            168    //������ʹ������������û������DNS���������������Ч��
#define    NET_DVR_EMAIL_SERVER_NOT_CONFIG_GATEWAY        169    //û���������أ�������ɷ����ʼ�ʧ�ܡ�
#define    NET_DVR_TEST_SERVER_PASSWORD_ERROR            170    //�û������벻��ȷ�����Է��������û������������
#define    NET_DVR_EMAIL_SERVER_CONNECT_EXCEPTION_WITH_SMTP    171    //�豸��smtp�����������쳣
#define    NET_DVR_FTP_SERVER_FAIL_CREATE_DIR            172    //FTP����������Ŀ¼ʧ��
#define    NET_DVR_FTP_SERVER_NO_WRITE_PIR                173    //FTP������û��д��Ȩ��
#define    NET_DVR_IP_CONFLICT                            174    //IP��ͻ
#define NET_DVR_INSUFFICIENT_STORAGEPOOL_SPACE      175  //�洢�ؿռ�����
#define NET_DVR_STORAGEPOOL_INVALID      176  //�Ʒ������洢����Ч,û�����ô洢�ػ��ߴ洢��ID����
#define NET_DVR_EFFECTIVENESS_REBOOT     177  //��Ч��Ҫ����
#define NET_ERR_ANR_ARMING_EXIST         178  //�����������������Ѿ�����(�ô���������HIK˽�в������ӽ���������£��ظ������Ķ�����������ʱ�����ء�)
#define NET_ERR_UPLOADLINK_EXIST         179  //���������ϴ������Ѿ�����(EHOMEЭ���HIK SDKЭ���ǲ���ͬʱ֧�ֶ��������ģ���һ��Э����ڵ�ʱ������һ�����ӽ�������������������롣)
#define NET_ERR_INCORRECT_FILE_FORMAT    180  //�����ļ���ʽ����ȷ
#define NET_ERR_INCORRECT_FILE_CONTENT   181  //�����ļ����ݲ���ȷ
#define NET_ERR_MAX_HRUDP_LINK           182 //HRUDP ������ �����豸����
#define NET_SDK_ERR_ACCESSKEY_SECRETKEY    183   // ������Կ�������Կ����ȷ
#define NET_SDK_ERR_CREATE_PORT_MULTIPLEX    184 //�����˿ڸ���ʧ��
#define NET_DVR_NONBLOCKING_CAPTURE_NOTSUPPORT   185 //��֧��������ץͼ 
#define NET_SDK_ERR_FUNCTION_INVALID   186  //�ѿ����첽���ù�����Ч
#define NET_SDK_ERR_MAX_PORT_MULTIPLEX     187   //�Ѵﵽ�˿ڸ��������Ŀ
// 2010-5-28
// ���д�����
#define RAID_ERROR_INDEX                    200
#define NET_DVR_NAME_NOT_ONLY               (RAID_ERROR_INDEX + 0)  // �����Ѵ���
#define NET_DVR_OVER_MAX_ARRAY              (RAID_ERROR_INDEX + 1 ) // ���дﵽ����
#define NET_DVR_OVER_MAX_VD                 (RAID_ERROR_INDEX + 2 ) // ������̴ﵽ����
#define NET_DVR_VD_SLOT_EXCEED              (RAID_ERROR_INDEX + 3 ) // ������̲�λ����
#define NET_DVR_PD_STATUS_INVALID           (RAID_ERROR_INDEX + 4 ) // �ؽ����������������״̬����
#define NET_DVR_PD_BE_DEDICATE_SPARE        (RAID_ERROR_INDEX + 5 ) // �ؽ����������������Ϊָ���ȱ�
#define NET_DVR_PD_NOT_FREE                 (RAID_ERROR_INDEX + 6 ) // �ؽ���������������̷ǿ���
#define NET_DVR_CANNOT_MIG2NEWMODE          (RAID_ERROR_INDEX + 7 ) // ���ܴӵ�ǰ����������Ǩ�Ƶ��µ���������
#define NET_DVR_MIG_PAUSE                   (RAID_ERROR_INDEX + 8 ) // Ǩ�Ʋ�������ͣ
#define NET_DVR_MIG_CANCEL                  (RAID_ERROR_INDEX + 9 ) // ����ִ�е�Ǩ�Ʋ�����ȡ��
#define NET_DVR_EXIST_VD                    (RAID_ERROR_INDEX + 10) // �����������ϴ���������̣��޷�ɾ������
#define NET_DVR_TARGET_IN_LD_FUNCTIONAL     (RAID_ERROR_INDEX + 11) // �����������Ϊ���������ɲ����ҹ�������
#define NET_DVR_HD_IS_ASSIGNED_ALREADY      (RAID_ERROR_INDEX + 12) // ָ����������̱�����Ϊ�������
#define NET_DVR_INVALID_HD_COUNT            (RAID_ERROR_INDEX + 13) // �������������ָ����RAID�ȼ���ƥ��
#define NET_DVR_LD_IS_FUNCTIONAL            (RAID_ERROR_INDEX + 14) // �����������޷��ؽ�
#define NET_DVR_BGA_RUNNING                 (RAID_ERROR_INDEX + 15) // ��������ִ�еĺ�̨����
#define NET_DVR_LD_NO_ATAPI                 (RAID_ERROR_INDEX + 16) // �޷���ATAPI�̴����������
#define NET_DVR_MIGRATION_NOT_NEED          (RAID_ERROR_INDEX + 17) // ��������Ǩ��
#define NET_DVR_HD_TYPE_MISMATCH            (RAID_ERROR_INDEX + 18) // ������̲�����ͬ������
#define NET_DVR_NO_LD_IN_DG                 (RAID_ERROR_INDEX + 19) // ��������̣��޷����д������
#define NET_DVR_NO_ROOM_FOR_SPARE           (RAID_ERROR_INDEX + 20) // ���̿ռ��С���޷���ָ��Ϊ�ȱ���
#define NET_DVR_SPARE_IS_IN_MULTI_DG        (RAID_ERROR_INDEX + 21) // �����ѱ�����Ϊĳ�����ȱ���
#define NET_DVR_DG_HAS_MISSING_PD           (RAID_ERROR_INDEX + 22) // ����ȱ����

// x86 64bit nvr���� 2012-02-04
#define NET_DVR_NAME_EMPTY                    (RAID_ERROR_INDEX + 23) /*����Ϊ��*/
#define NET_DVR_INPUT_PARAM                    (RAID_ERROR_INDEX + 24) /*�����������*/
#define NET_DVR_PD_NOT_AVAILABLE            (RAID_ERROR_INDEX + 25) /*������̲�����*/
#define NET_DVR_ARRAY_NOT_AVAILABLE            (RAID_ERROR_INDEX + 26) /*���в�����*/
#define NET_DVR_PD_COUNT                    (RAID_ERROR_INDEX + 27) /*�������������ȷ*/
#define NET_DVR_VD_SMALL                    (RAID_ERROR_INDEX + 28) /*�������̫С*/
#define NET_DVR_NO_EXIST                    (RAID_ERROR_INDEX + 29) /*������*/
#define NET_DVR_NOT_SUPPORT                    (RAID_ERROR_INDEX + 30) /*��֧�ָò���*/
#define NET_DVR_NOT_FUNCTIONAL                 (RAID_ERROR_INDEX + 31) /*����״̬��������״̬*/
#define NET_DVR_DEV_NODE_NOT_FOUND            (RAID_ERROR_INDEX + 32) /*��������豸�ڵ㲻����*/
#define NET_DVR_SLOT_EXCEED                    (RAID_ERROR_INDEX + 33) /*��λ�ﵽ����*/ 
#define NET_DVR_NO_VD_IN_ARRAY                (RAID_ERROR_INDEX + 34) /*�����ϲ������������*/
#define NET_DVR_VD_SLOT_INVALID                (RAID_ERROR_INDEX + 35) /*������̲�λ��Ч*/
#define NET_DVR_PD_NO_ENOUGH_SPACE            (RAID_ERROR_INDEX + 36) /*����������̿ռ䲻��*/
#define NET_DVR_ARRAY_NONFUNCTION            (RAID_ERROR_INDEX + 37) /*ֻ�д�������״̬�����в��ܽ���Ǩ��*/
#define NET_DVR_ARRAY_NO_ENOUGH_SPACE        (RAID_ERROR_INDEX + 38) /*���пռ䲻��*/
#define NET_DVR_STOPPING_SCANNING_ARRAY        (RAID_ERROR_INDEX + 39) /*����ִ�а�ȫ���̻�����ɨ��*/
#define NET_DVR_NOT_SUPPORT_16T             (RAID_ERROR_INDEX + 40) /*��֧�ִ�������16T������*/
#define NET_DVR_ARRAY_FORMATING             (RAID_ERROR_INDEX + 41) /*����ִ�и�ʽ���������޷�ɾ��*/ 
#define NET_DVR_QUICK_SETUP_PD_COUNT        (RAID_ERROR_INDEX + 42) /*һ������������Ҫ���������*/ 

//�豸δ����ʱ����¼ʧ�ܣ����ش�����
#define    NET_DVR_ERROR_DEVICE_NOT_ACTIVATED    250//�豸δ����
//��SDK�����豸�������û�������߼����ʱ��Ϊ��������ʱ��������
#define  NET_DVR_ERROR_RISK_PASSWORD          251 //�з��յ�����
//�Ѽ�����豸���ٴμ���ʱ���ش�����
#define    NET_DVR_ERROR_DEVICE_HAS_ACTIVATED    252//�豸�Ѽ���


// ���ܴ����� 
#define VCA_ERROR_INDEX                     300 // ���ܴ���������
#define NET_DVR_ID_ERROR                    (VCA_ERROR_INDEX + 0)   // ����ID������
#define NET_DVR_POLYGON_ERROR               (VCA_ERROR_INDEX + 1)   // ����β�����Ҫ��
#define NET_DVR_RULE_PARAM_ERROR            (VCA_ERROR_INDEX + 2)   // �������������
#define NET_DVR_RULE_CFG_CONFLICT           (VCA_ERROR_INDEX + 3)   // ������Ϣ��ͻ
#define NET_DVR_CALIBRATE_NOT_READY         (VCA_ERROR_INDEX + 4)   // ��ǰû�б궨��Ϣ
#define NET_DVR_CAMERA_DATA_ERROR           (VCA_ERROR_INDEX + 5)   // ���������������
#define NET_DVR_CALIBRATE_DATA_UNFIT        (VCA_ERROR_INDEX + 6)    // ���Ȳ�����б�������ڱ궨
#define NET_DVR_CALIBRATE_DATA_CONFLICT     (VCA_ERROR_INDEX + 7)    // �궨������Ϊ���е㹲�߻���λ��̫����
#define NET_DVR_CALIBRATE_CALC_FAIL         (VCA_ERROR_INDEX + 8)    // ������궨����ֵ����ʧ��
#define    NET_DVR_CALIBRATE_LINE_OUT_RECT        (VCA_ERROR_INDEX + 9)    // ����������궨�߳�����������Ӿ��ο�
#define NET_DVR_ENTER_RULE_NOT_READY        (VCA_ERROR_INDEX + 10)    // û�����ý�������
#define NET_DVR_AID_RULE_NO_INCLUDE_LANE    (VCA_ERROR_INDEX + 11)    // ��ͨ�¼�������û�а�����������ֵӵ�º����У�
#define NET_DVR_LANE_NOT_READY                (VCA_ERROR_INDEX + 12)    // ��ǰû�����ó���
#define NET_DVR_RULE_INCLUDE_TWO_WAY        (VCA_ERROR_INDEX + 13)    // �¼������а���2�ֲ�ͬ����
#define NET_DVR_LANE_TPS_RULE_CONFLICT      (VCA_ERROR_INDEX + 14)  // ���������ݹ����ͻ
#define NET_DVR_NOT_SUPPORT_EVENT_TYPE      (VCA_ERROR_INDEX + 15)  // ��֧�ֵ��¼�����
#define NET_DVR_LANE_NO_WAY                 (VCA_ERROR_INDEX + 16)  // ����û�з���
#define NET_DVR_SIZE_FILTER_ERROR           (VCA_ERROR_INDEX + 17)  // �ߴ���˿򲻺���
#define NET_DVR_LIB_FFL_NO_FACE             (VCA_ERROR_INDEX + 18) // �����㶨λʱ�����ͼ��û������
#define NET_DVR_LIB_FFL_IMG_TOO_SMALL       (VCA_ERROR_INDEX + 19) // �����㶨λʱ�����ͼ��̫С
#define NET_DVR_LIB_FD_IMG_NO_FACE          (VCA_ERROR_INDEX + 20) // ����ͼ���������ʱ�����ͼ��û������
#define NET_DVR_LIB_FACE_TOO_SMALL          (VCA_ERROR_INDEX + 21) // ��ģʱ����̫С
#define NET_DVR_LIB_FACE_QUALITY_TOO_BAD    (VCA_ERROR_INDEX + 22) // ��ģʱ����ͼ������̫��
#define NET_DVR_KEY_PARAM_ERR               (VCA_ERROR_INDEX + 23) //�߼��������ô���
#define NET_DVR_CALIBRATE_DATA_ERR          (VCA_ERROR_INDEX + 24) //�궨������Ŀ���󣬻�����ֵ���󣬻������㳬����ƽ��
#define NET_DVR_CALIBRATE_DISABLE_FAIL      (VCA_ERROR_INDEX + 25) //�����ù�������ȡ���궨
#define NET_DVR_VCA_LIB_FD_SCALE_OUTRANGE   (VCA_ERROR_INDEX + 26) //�����˿�Ŀ����Сֵ������С���˿�Ŀ�����ֵ��������
#define NET_DVR_LIB_FD_REGION_TOO_LARGE     (VCA_ERROR_INDEX + 27) //��ǰ�������Χ���󡣼�������Ϊͼ���2/3
#define NET_DVR_TRIAL_OVERDUE               (VCA_ERROR_INDEX + 28) //���ð��������ѽ���
#define NET_DVR_CONFIG_FILE_CONFLICT        (VCA_ERROR_INDEX + 29) //�豸�����������ļ���ͻ�����ܹ����������з��������ò�����������ʾ��
//�㷨����ش�����
#define NET_DVR_FR_FPL_FAIL                 (VCA_ERROR_INDEX + 30)   // ���������㶨λʧ��
#define NET_DVR_FR_IQA_FAIL                 (VCA_ERROR_INDEX + 31)   // ��������ʧ��
#define NET_DVR_FR_FEM_FAIL                 (VCA_ERROR_INDEX + 32)   // ����������ȡʧ��
#define NET_DVR_FPL_DT_CONF_TOO_LOW         (VCA_ERROR_INDEX + 33)   // �����㶨λʱ����������Ŷȹ���
#define NET_DVR_FPL_CONF_TOO_LOW            (VCA_ERROR_INDEX + 34)   // �����㶨λ���Ŷȹ���
#define NET_DVR_E_DATA_SIZE                 (VCA_ERROR_INDEX + 35)  // ���ݳ��Ȳ�ƥ��
#define NET_DVR_FR_MODEL_VERSION_ERR        (VCA_ERROR_INDEX + 36)  // ����ģ�������е�ģ�Ͱ汾����
#define NET_DVR_FR_FD_FAIL                  (VCA_ERROR_INDEX + 37)  // ʶ������������ʧ��
#define NET_DVR_FA_NORMALIZE_ERR            (VCA_ERROR_INDEX + 38)  // ������һ������
//����������
#define NET_DVR_DOG_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 39)  // ���ܹ���ǰ��ȡ���豸���Ͳ�ƥ��
#define NET_DVR_DEV_PUSTREAM_NOT_MATCH      (VCA_ERROR_INDEX + 40)  // ǰ��ȡ���豸�汾��ƥ��
#define NET_DVR_PUSTREAM_ALREADY_EXISTS     (VCA_ERROR_INDEX + 41)  // �豸������ͨ���Ѿ���ӹ���ǰ���豸
#define NET_DVR_SEARCH_CONNECT_FAILED       (VCA_ERROR_INDEX + 42)  // ���Ӽ���������ʧ��
#define NET_DVR_INSUFFICIENT_DISK_SPACE     (VCA_ERROR_INDEX + 43)  // �ɴ洢��Ӳ�̿ռ䲻��
#define NET_DVR_DATABASE_CONNECTION_FAILED  (VCA_ERROR_INDEX + 44)  // ���ݿ�����ʧ��
#define NET_DVR_DATABASE_ADM_PW_ERROR       (VCA_ERROR_INDEX + 45)  // ���ݿ��û������������
#define NET_DVR_DECODE_YUV                  (VCA_ERROR_INDEX + 46)  // ����ʧ��
#define NET_DVR_IMAGE_RESOLUTION_ERROR      (VCA_ERROR_INDEX + 47)  //
#define NET_DVR_CHAN_WORKMODE_ERROR         (VCA_ERROR_INDEX + 48)  //

#define NET_DVR_RTSP_ERROR_NOENOUGHPRI          401  //��Ȩ�ޣ�����������401ʱ��ת�����������
#define NET_DVR_RTSP_ERROR_ALLOC_RESOURCE       402  //������Դʧ��
#define NET_DVR_RTSP_ERROR_PARAMETER            403  //��������
#define NET_DVR_RTSP_ERROR_NO_URL               404  //ָ����URL��ַ�����ڣ�����������404ʱ��ת�����������
#define NET_DVR_RTSP_ERROR_FORCE_STOP           406  //�û���;ǿ���˳�

#define NET_DVR_RTSP_GETPORTFAILED                407  //rtsp �õ��˿ڴ���
#define NET_DVR_RTSP_DESCRIBERROR                410  //rtsp decribe ��������
#define NET_DVR_RTSP_DESCRIBESENDTIMEOUT        411  //rtsp decribe ���ͳ�ʱ
#define NET_DVR_RTSP_DESCRIBESENDERROR            412  //rtsp decribe ����ʧ��
#define NET_DVR_RTSP_DESCRIBERECVTIMEOUT        413  //rtsp decribe ���ճ�ʱ
#define NET_DVR_RTSP_DESCRIBERECVDATALOST        414  //rtsp decribe �������ݴ���
#define NET_DVR_RTSP_DESCRIBERECVERROR            415  //rtsp decribe ����ʧ��
#define NET_DVR_RTSP_DESCRIBESERVERERR            416  //rtsp decribe ���������ش���״̬

#define NET_DVR_RTSP_SETUPERROR                    420  //rtsp setup ��������
#define NET_DVR_RTSP_SETUPSENDTIMEOUT            421  //rtsp setup ���ͳ�ʱ
#define NET_DVR_RTSP_SETUPSENDERROR                422  //rtsp setup ���ʹ���
#define NET_DVR_RTSP_SETUPRECVTIMEOUT            423  //rtsp setup ���ճ�ʱ
#define NET_DVR_RTSP_SETUPRECVDATALOST            424  //rtsp setup �������ݴ���
#define NET_DVR_RTSP_SETUPRECVERROR                425  //rtsp setup ����ʧ��
#define NET_DVR_RTSP_OVER_MAX_CHAN                426  //������������������������߷�������Դ���㣬����������453ʱ��ת����������롣
#define NET_DVR_RTSP_SETUPSERVERERR                427  //rtsp setup ���������ش���״̬

#define NET_DVR_RTSP_PLAYERROR                    430  //rtsp play ��������
#define NET_DVR_RTSP_PLAYSENDTIMEOUT            431  //rtsp play ���ͳ�ʱ
#define NET_DVR_RTSP_PLAYSENDERROR                432  //rtsp play ���ʹ���
#define NET_DVR_RTSP_PLAYRECVTIMEOUT            433  //rtsp play ���ճ�ʱ
#define NET_DVR_RTSP_PLAYRECVDATALOST            434  //rtsp play �������ݴ���
#define NET_DVR_RTSP_PLAYRECVERROR                435  //rtsp play ����ʧ��
#define NET_DVR_RTSP_PLAYSERVERERR                436  //rtsp play ���������ش���״̬

#define NET_DVR_RTSP_TEARDOWNERROR                440  //rtsp teardown ��������
#define NET_DVR_RTSP_TEARDOWNSENDTIMEOUT        441  //rtsp teardown ���ͳ�ʱ
#define NET_DVR_RTSP_TEARDOWNSENDERROR            442  //rtsp teardown ���ʹ���
#define NET_DVR_RTSP_TEARDOWNRECVTIMEOUT        443  //rtsp teardown ���ճ�ʱ
#define NET_DVR_RTSP_TEARDOWNRECVDATALOST        444  //rtsp teardown �������ݴ���
#define NET_DVR_RTSP_TEARDOWNRECVERROR            445  //rtsp teardown ����ʧ��
#define NET_DVR_RTSP_TEARDOWNSERVERERR            446  //rtsp teardown ���������ش���״̬

#define  NET_PLAYM4_NOERROR                        500    //no error
#define     NET_PLAYM4_PARA_OVER                    501    //input parameter is invalid;
#define  NET_PLAYM4_ORDER_ERROR                    502    //The order of the function to be called is error.
#define     NET_PLAYM4_TIMER_ERROR                    503    //Create multimedia clock failed;
#define  NET_PLAYM4_DEC_VIDEO_ERROR                504    //Decode video data failed.
#define  NET_PLAYM4_DEC_AUDIO_ERROR                505    //Decode audio data failed.
#define     NET_PLAYM4_ALLOC_MEMORY_ERROR            506    //Allocate memory failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR                507    //Open the file failed.
#define  NET_PLAYM4_CREATE_OBJ_ERROR            508    //Create thread or event failed
#define  NET_PLAYM4_CREATE_DDRAW_ERROR            509    //Create DirectDraw object failed.
#define  NET_PLAYM4_CREATE_OFFSCREEN_ERROR      510    //failed when creating off-screen surface.
#define  NET_PLAYM4_BUF_OVER                    511    //buffer is overflow
#define  NET_PLAYM4_CREATE_SOUND_ERROR            512    //failed when creating audio device.    
#define     NET_PLAYM4_SET_VOLUME_ERROR            513    //Set volume failed
#define  NET_PLAYM4_SUPPORT_FILE_ONLY            514    //The function only support play file.
#define  NET_PLAYM4_SUPPORT_STREAM_ONLY            515    //The function only support play stream.
#define  NET_PLAYM4_SYS_NOT_SUPPORT                516    //System not support.
#define  NET_PLAYM4_FILEHEADER_UNKNOWN          517    //No file header.
#define  NET_PLAYM4_VERSION_INCORRECT            518    //The version of decoder and encoder is not adapted.  
#define  NET_PALYM4_INIT_DECODER_ERROR          519    //Initialize decoder failed.
#define  NET_PLAYM4_CHECK_FILE_ERROR            520    //The file data is unknown.
#define  NET_PLAYM4_INIT_TIMER_ERROR            521    //Initialize multimedia clock failed.
#define     NET_PLAYM4_BLT_ERROR                    522    //Blt failed.
#define  NET_PLAYM4_UPDATE_ERROR                523    //Update failed.
#define  NET_PLAYM4_OPEN_FILE_ERROR_MULTI       524   //openfile error, streamtype is multi
#define  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO       525   //openfile error, streamtype is video
#define  NET_PLAYM4_JPEG_COMPRESS_ERROR         526   //JPEG compress error
#define  NET_PLAYM4_EXTRACT_NOT_SUPPORT         527    //Don't support the version of this file.
#define  NET_PLAYM4_EXTRACT_DATA_ERROR          528    //extract video data failed.

//ת��װ�������
#define  NET_CONVERT_ERROR_NOT_SUPPORT          581  //convert not support

//�����Խ��������
#define  NET_AUDIOINTERCOM_OK                   600  //�޴���
#define  NET_AUDIOINTECOM_ERR_NOTSUPORT         601 //��֧��
#define  NET_AUDIOINTECOM_ERR_ALLOC_MEMERY      602 //�ڴ��������
#define  NET_AUDIOINTECOM_ERR_PARAMETER            603 //��������
#define  NET_AUDIOINTECOM_ERR_CALL_ORDER        604 //���ô������
#define  NET_AUDIOINTECOM_ERR_FIND_DEVICE       605 //δ�����豸
#define  NET_AUDIOINTECOM_ERR_OPEN_DEVICE       606 //���ܴ��豸��
#define  NET_AUDIOINTECOM_ERR_NO_CONTEXT        607 //�豸�����ĳ���
#define  NET_AUDIOINTECOM_ERR_NO_WAVFILE        608 //WAV�ļ�����
#define  NET_AUDIOINTECOM_ERR_INVALID_TYPE      609 //��Ч��WAV��������
#define  NET_AUDIOINTECOM_ERR_ENCODE_FAIL       610 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_DECODE_FAIL       611 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_NO_PLAYBACK       612 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_DENOISE_FAIL      613 //����ʧ��
#define  NET_AUDIOINTECOM_ERR_UNKOWN            619 //δ֪����

#define NET_QOS_OK                                 700                    //no error
#define NET_QOS_ERROR                             (NET_QOS_OK - 1)        //qos error
#define NET_QOS_ERR_INVALID_ARGUMENTS             (NET_QOS_OK - 2)        //invalid arguments 
#define NET_QOS_ERR_SESSION_NOT_FOUND             (NET_QOS_OK - 3)        //session net found
#define NET_QOS_ERR_LIB_NOT_INITIALIZED          (NET_QOS_OK - 4)        //lib not initialized
#define NET_QOS_ERR_OUTOFMEM                     (NET_QOS_OK - 5)        //outtofmem
#define NET_QOS_ERR_PACKET_UNKNOW                (NET_QOS_OK - 10)        //packet unknow
#define NET_QOS_ERR_PACKET_VERSION               (NET_QOS_OK - 11)        //packet version error
#define NET_QOS_ERR_PACKET_LENGTH                (NET_QOS_OK - 12)        //packet length error
#define NET_QOS_ERR_PACKET_TOO_BIG               (NET_QOS_OK - 13)        //packet too big
#define NET_QOS_ERR_SCHEDPARAMS_INVALID_BANDWIDTH (NET_QOS_OK - 20)        //schedparams invalid bandwidth
#define NET_QOS_ERR_SCHEDPARAMS_BAD_FRACTION      (NET_QOS_OK - 21)        //schedparams bad fraction
#define NET_QOS_ERR_SCHEDPARAMS_BAD_MINIMUM_INTERVAL (NET_QOS_OK - 22)    //schedparams bad minimum interval

#define NET_ERROR_TRUNK_LINE                        711 //��ϵͳ�ѱ���ɸ���
#define NET_ERROR_MIXED_JOINT                        712 //���ܽ��л��ƴ��
#define NET_ERROR_DISPLAY_SWITCH                    713 //���ܽ�����ʾͨ���л�
#define NET_ERROR_USED_BY_BIG_SCREEN                714 //������Դ������ռ��
#define NET_ERROR_USE_OTHER_DEC_RESOURCE            715 //����ʹ������������ϵͳ��Դ
#define NET_ERROR_DISP_MODE_SWITCH                  716 //��ʾͨ����ʾ״̬�л���
#define NET_ERROR_SCENE_USING                        717    //��������ʹ��
#define NET_ERR_NO_ENOUGH_DEC_RESOURCE              718 //������Դ����
#define NET_ERR_NO_ENOUGH_FREE_SHOW_RESOURCE        719 //������Դ����
#define NET_ERR_NO_ENOUGH_VIDEO_MEMORY              720 //�Դ���Դ����
#define NET_ERR_MAX_VIDEO_NUM                       721 //һ�϶���Դ����
#define NET_ERR_WIN_COVER_FREE_SHOW_AND_NORMAL      722 //���ڿ�Խ�˳�������ںͷǳ��������
#define NET_ERR_FREE_SHOW_WIN_SPLIT                 723 //���Դ��ڲ�֧�ַ���
#define NET_ERR_INAPPROPRIATE_WIN_FREE_SHOW         724 //����������������Ĵ��ڲ�֧�ֿ�������
#define NET_DVR_TRANSPARENT_WIN_NOT_SUPPORT_SPLIT   725 //����͸���ȵĴ��ڲ�֧�ַ���
#define NET_DVR_SPLIT_WIN_NOT_SUPPORT_TRANSPARENT   726 //����������Ĵ��ڲ�֧��͸��������
#define NET_ERR_MAX_LOGO_NUM                        727 //logo���ﵽ����
#define NET_ERR_MAX_WIN_LOOP_NUM                    728 //��Ѳ�������ﵽ����
#define NET_ERR_VIRTUAL_LED_VERTICAL_CROSS          729 //����LED�����������
#define NET_ERR_MAX_VIRTUAL_LED_HEIGHT              730 //����LED�߶ȳ���
#define NET_ERR_VIRTUAL_LED_ILLEGAL_CHARACTER       731 //����LED���ݰ����Ƿ��ַ�
#define NET_ERR_BASEMAP_NOT_EXIST                   732 //��ͼͼƬ������
#define NET_ERR_LED_NOT_SUPPORT_VIRTUAL_LED         733 //LED��Ļ��֧������LED
#define NET_ERR_LED_RESOLUTION_NOT_SUPPORT          734 //LED�ֱ��ʲ�֧��
#define NET_ERR_PLAN_OVERDUE                        735 //Ԥ�����ڣ������ٵ���
#define NET_ERR_PROCESSER_MAX_SCREEN_BLK            736 //����������������źſ�Խ����Ļ��������
#define NET_ERR_WND_SIZE_TOO_SMALL                  737 //�������ڿ��̫С
#define NET_ERR_WND_SPLIT_NOT_SUPPORT_ROAM          738 //�������ڲ�֧������
#define NET_ERR_OUTPUT_ONE_BOARD_ONE_WALL           739 //ͬһ���Ӱ�������ֻ�ܰ󶨵�ͬһ��ǽ��
#define NET_ERR_WND_CANNOT_LCD_AND_LED_OUTPUT       740 //���ڲ���ͬʱ��LCD��LED�����
#define NET_ERR_MAX_OSD_NUM                         741 //OSD�����ﵽ���

#define NET_SDK_CANCEL_WND_TOPKEEP_ATTR_FIRST       751 //��ȡ���ö����ִ��ڵ��ö��������Բ��ܽ����õײ���
#define NET_SDK_ERR_LED_SCREEN_CHECKING             752 //����У��LED��Ļ
#define NET_SDK_ERR_NOT_SUPPORT_SINGLE_RESOLUTION   753 //LCD/LED����ڰ�֮��֧�ֵ�������ڵķֱ�������
#define NET_SDK_ERR_LED_RESOLUTION_MISMATCHED       754 //������ڵ�LED�ֱ��ʺ���������ڵ�LED�ֱ��ʲ�ƥ�䣬��Ҫ����ͬ�еȸߡ�ͬ�еȿ�


#define NET_SDK_ERR_MAX_VIRTUAL_LED_WIDTH           755 //����LED��ȳ��ޣ��������ֵ����Сֵ
#define NET_SDK_ERR_MAX_VIRTUAL_LED_IN_SCREEN       756 //��������LED��������
#define NET_SDK_ERR_MAX_VIRTUAL_LED_IN_WALL         757 //��ǽ����LED��������
#define NET_SDK_ERR_VIRTUAL_LED_OVERLAP             758 //����LED�ص�����
#define NET_SDK_ERR_VIRTUAL_LED_TYPE                759 //���ʹ���
#define NET_SDK_ERR_VIRTUAL_LED_COLOUR              760 //��ɫ����
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_DIRECTION      761 //�ƶ��������
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_MODE           762 //�ƶ�ģʽ����
#define NET_SDK_ERR_VIRTUAL_LED_MOVE_SPEED          763 //�ƶ��ٶȴ���
#define NET_SDK_ERR_VIRTUAL_LED_DISP_MODE           764 //��ʾģʽ����
#define NET_SDK_ERR_VIRTUAL_LED_NO                  765 //����LED��Ŵ���
#define NET_SDK_ERR_VIRTUAL_LED_PARA                766 //����LED�������ô��󣬰����ṹ������������
#define NET_SDK_ERR_BASEMAP_POSITION                767 //��ͼ���ڿ�߲�������
#define NET_SDK_ERR_BASEMAP_PICTURE_LEN             768 //��ͼͼƬ���ȳ���
#define NET_SDK_ERR_BASEMAP_PICTURE_RESOLUTION      769 //��ͼͼƬ�ֱ��ʴ���
#define NET_SDK_ERR_BASEMAP_PICTURE_FORMAT          770 //��ͼͼƬ��ʽ����
#define NET_SDK_ERR_MAX_VIRTUAL_LED_NUM             771 //�豸֧�ֵ�����LED��������
#define NET_SDK_ERR_MAX_TIME_VIRTUAL_LED_IN_WALL    772 //�������ǽ֧�ֵ�ʱ������LED����������

#define NET_ERR_TERMINAL_BUSY                        780    //�ն�æ���ն˴��ڻ�����

#define NET_ERR_DATA_RETURNED_ILLEGAL               790 //�豸���ص����ݲ��Ϸ�
#define NET_DVR_FUNCTION_RESOURCE_USAGE_ERROR       791 //�豸��������ռ����Դ�����¸ù����޷�����

#define    NET_DVR_ERR_IMPORT_EMPTY_FILE           792    //�����ļ�Ϊ��
#define    NET_DVR_ERR_IMPORT_TOO_LARGE_FILE       793    //�����ļ�����        
#define    NET_DVR_ERR_BAD_IPV4_ADDRESS            794    //IPV4��ַ��Ч
#define    NET_DVR_ERR_BAD_NET_MASK                795    //���������ַ��Ч
#define    NET_DVR_ERR_INVALID_NET_GATE_ADDRESS    796    //���ص�ַ��Ч          
#define    NET_DVR_ERR_BAD_DNS                     797    //DNS��ַ��Ч
#define    NET_DVR_ERR_ILLEGAL_PASSWORD            798    //���벻�ܰ����û���

#define NET_DVR_DEV_NET_OVERFLOW                    800    //�������������豸��������
#define NET_DVR_STATUS_RECORDFILE_WRITING_NOT_LOCK  801 //¼���ļ���¼���޷������� 
#define NET_DVR_STATUS_CANT_FORMAT_LITTLE_DISK      802 //����Ӳ��̫С�޷���ʽ��

//N+1������
#define NET_SDK_ERR_REMOTE_DISCONNECT                803 //Զ���޷�����
#define NET_SDK_ERR_RD_ADD_RD                        804 //����������ӱ���
#define NET_SDK_ERR_BACKUP_DISK_EXCEPT                805 //�������쳣
#define NET_SDK_ERR_RD_LIMIT                        806 //�������Ѵ�����
#define NET_SDK_ERR_ADDED_RD_IS_WD                    807 //��ӵı����ǹ�����
#define NET_SDK_ERR_ADD_ORDER_WRONG                    808 //���˳���������û�б����������Ϊ����������ӹ�����
#define NET_SDK_ERR_WD_ADD_WD                        809 //������������ӹ�����
#define NET_SDK_ERR_WD_SERVICE_EXCETP                810 //������CVR�����쳣
#define NET_SDK_ERR_RD_SERVICE_EXCETP                811 //����CVR�����쳣
#define NET_SDK_ERR_ADDED_WD_IS_RD                    812 //��ӵĹ������Ǳ���
#define NET_SDK_ERR_PERFORMANCE_LIMIT                813 //���ܴﵽ����
#define NET_SDK_ERR_ADDED_DEVICE_EXIST                814 //��ӵ��豸�Ѿ�����

//��Ѷ��������
#define NET_SDK_ERR_INQUEST_RESUMING                815 //��Ѷ�ָ���
#define NET_SDK_ERR_RECORD_BACKUPING                816 //��Ѷ������
#define NET_SDK_ERR_DISK_PLAYING                    817 //���̻ط���
#define NET_SDK_ERR_INQUEST_STARTED                    818 //��Ѷ�ѿ���
#define NET_SDK_ERR_LOCAL_OPERATING                    819 //���ز���������
#define NET_SDK_ERR_INQUEST_NOT_START                820 //��Ѷδ����
//Netra3.1.0������                
#define NET_SDK_ERR_CHAN_AUDIO_BIND                 821  //ͨ��δ�󶨻�������Խ�ʧ��
//�ƴ洢������
#define NET_DVR_N_PLUS_ONE_MODE                     822 //�豸��ǰ����N+1ģʽ
#define NET_DVR_CLOUD_STORAGE_OPENED                823 //�ƴ洢ģʽ�ѿ���

#define NET_DVR_ERR_OPER_NOT_ALLOWED                824   //�豸����N+0���ӹ�״̬��������ò���
#define NET_DVR_ERR_NEED_RELOCATE                    825   //�豸����N+0���ӹ�״̬����Ҫ��ȡ�ض�����Ϣ�������²���

//ͥ������������
#define NET_SDK_ERR_IR_PORT_ERROR                   830 //��������ڴ���
#define NET_SDK_ERR_IR_CMD_ERROR                    831 //��������ڵ�����Ŵ���
#define NET_SDK_ERR_NOT_INQUESTING                  832 //�豸���ڷ���Ѷ״̬
#define NET_SDK_ERR_INQUEST_NOT_PAUSED              833 //�豸���ڷ���ͣ״̬
#define NET_DVR_CHECK_PASSWORD_MISTAKE_ERROR        834 //У���������
#define NET_DVR_CHECK_PASSWORD_NULL_ERROR           835 //У�����벻��Ϊ��
#define NET_DVR_UNABLE_CALIB_ERROR                  836  // ��ǰ�޷��궨
#define NET_DVR_PLEASE_CALIB_ERROR                  837  //������ɱ궨
#define NET_DVR_ERR_PANORAMIC_CAL_EMPTY             838 //Flash��ȫ���궨Ϊ��
#define NET_DVR_ERR_CALIB_FAIL_PLEASEAGAIN          839 //�궨ʧ�ܣ������±궨(Calibration failed. Please calibrate again.)
#define NET_DVR_ERR_DETECTION_LINE                  840 //���������ô������������ù����ߣ�ȷ��������λ�ں�ɫ������(Please set detection line again. The detection line should be within the red count area.)
#define NET_DVR_ERR_TURN_OFF_IMAGE_PARA             841 //���ȹر�ͼ������л�����(Please turn off the image parameters switch first.)
#define NET_DVR_EXCEED_FACE_IMAGES_ERROR            843  //��������ͼƬ�������
#define NET_DVR_ANALYSIS_FACE_IMAGES_ERROR          844  //ͼƬ����ʶ��ʧ��
#define NET_ERR_ALARM_INPUT_OCCUPIED                845  //A<-1�����������ڴ�������ץ��Alarm Input No. A<-1 is used to trigger vehicle capture.
#define NET_DVR_FACELIB_DATABASE_ERROR              846  //�����������ݿ�汾��ƥ��
#define NET_DVR_FACELIB_DATA_ERROR                  847  //���������ݴ���
#define NET_DVR_FACE_DATA_ID_ERROR                  848  //��������PID��Ч
#define NET_DVR_FACELIB_ID_ERROR                    849  //������ID��Ч
#define NET_DVR_EXCEED_FACE_LIBARY_ERROR            850  //����������������
#define NET_DVR_PIC_ANALYSIS_NO_TARGET_ERROR           851  //ͼƬδʶ��Ŀ��
#define NET_DVR_SUBPIC_ANALYSIS_MODELING_ERROR         852  //��ͼ��ģʧ��
#define NET_DVR_PIC_ANALYSIS_NO_RESOURCE_ERROR         853  //�޶�Ӧ���ܷ�������֧��ͼƬ����ʶ��
#define NET_DVR_ANALYSIS_ENGINES_NO_RESOURCE_ERROR                 854//�޷���������Դ
#define NET_DVR_ANALYSIS_ENGINES_USAGE_EXCEED_ERROR                855//����ʹ���ʳ����ɣ��Ѵ�100%
#define NET_DVR_EXCEED_HUMANMISINFO_FILTER_ENABLED_ERROR           856  //������������ȥ�����ͨ������
#define NET_DVR_NAME_ERROR                                         857  //���ƴ���
#define NET_DVR_NAME_EXIST_ERROR                                   858  //�����Ѵ���
#define NET_DVR_FACELIB_PIC_IMPORTING_ERROR                        859  //�����⵼��ͼƬ��
#define NET_DVR_ERR_CALIB_POSITION                  860 //�궨λ�ó���������˶���Χ
#define NET_DVR_ERR_DELETE                          861 //�޷�ɾ��
#define NET_DVR_ERR_SCENE_ID                        862 //����ID��Ч
#define NET_DVR_ERR_CALIBING                        863 //�궨��
#define NET_DVR_PIC_FORMAT_ERROR                                   864  //ͼƬ��ʽ����
#define NET_DVR_PIC_RESOLUTION_INVALID_ERROR                       865  //ͼƬ�ֱ�����Ч����
#define NET_DVR_PIC_SIZE_EXCEED_ERROR                              866  //ͼƬ����
#define NET_DVR_PIC_ANALYSIS_TARGRT_NUM_EXCEED_ERROR               867  //ͼƬĿ�������������
#define NET_DVR_ANALYSIS_ENGINES_LOADING_ERROR                     868//���������ʼ����
#define NET_DVR_ANALYSIS_ENGINES_ABNORMA_ERROR                     869//���������쳣
#define NET_DVR_ANALYSIS_ENGINES_FACELIB_IMPORTING                 870//�����������ڵ���������
#define NET_DVR_NO_DATA_FOR_MODELING_ERROR         871  //�޴���ģ����
#define NET_DVR_FACE_DATA_MODELING_ERROR           872 //�豸���ڽ���ͼƬ��ģ��������֧�ֲ�������
#define NET_ERR_FACELIBDATA_OVERLIMIT              873  //�����豸��֧�ֵ������������������ƣ�����������������ݣ�
#define NET_DVR_ANALYSIS_ENGINES_ASSOCIATED_CHANNEL  874//���������ѹ���ͨ��
#define NET_DVR_ERR_CUSTOMID_LEN                     875 //�ϲ��Զ���ID�ĳ�����С32�ַ�����
#define NET_DVR_ERR_CUSTOMFACELIBID_REPEAT           876 //�ϲ��·��ظ����Զ���������ID
#define NET_DVR_ERR_CUSTOMHUMANID_REPEAT             877 //�ϲ��·��ظ����Զ�����ԱID
#define NET_DVR_ERR_URL_DOWNLOAD_FAIL                878 //url����ʧ��
#define NET_DVR_ERR_URL_DOWNLOAD_NOTSTART            879 //urlδ��ʼ����

#define NET_DVR_CFG_FILE_SECRETKEY_ERROR         880  //�����ļ���ȫУ����Կ����
#define NET_DVR_WDR_NOTDISABLE_ERROR             881  //���ȹر�����ͨ����ǰ��ҹ����ת��ģʽ�µĿ�̬
#define NET_DVR_HLC_NOTDISABLE_ERROR             882  //���ȹر�����ͨ����ǰ��ҹ����ת��ģʽ�µ�ǿ������

#define NET_DVR_THERMOMETRY_REGION_OVERSTEP_ERROR         883  //��������Խ��


#define NET_DVR_ERR_MODELING_DEVICEINTERNAL     884 //��ģʧ�ܣ��豸�ڲ�����
#define NET_DVR_ERR_MODELING_FACE               885 //��ģʧ�ܣ�������ģ����
#define NET_DVR_ERR_MODELING_FACEGRADING        886 //��ģʧ�ܣ������������ִ���
#define NET_DVR_ERR_MODELING_FACEGFEATURE       887 //��ģʧ�ܣ���������ȡ����
#define NET_DVR_ERR_MODELING_FACEGANALYZING     888 //��ģʧ�ܣ�������ȡ����

#define NET_DVR_ERR_STREAM_LIMIT                889 //�������ܳ������ޣ������ȡ��·��
#define NET_DVR_ERR_STREAM_DESCRIPTION          890 //��������������
#define NET_DVR_ERR_STREAM_DELETE               891 //��������ʹ���޷�ɾ��
#define NET_DVR_ERR_CUSTOMSTREAM_NAME           892 //�Զ�����������Ϊ�ջ򲻺Ϸ�
#define NET_DVR_ERR_CUSTOMSTREAM_NOTEXISTED     893 //���Զ�������������

#define NET_DVR_ERR_TOO_SHORT_CALIBRATING_TIME     894 //�궨ʱ��̫��
#define NET_DVR_ERR_AUTO_CALIBRATE_FAILED     895 //�Զ��궨ʧ��
#define NET_DVR_ERR_VERIFICATION_FAILED     896 //У��ʧ��

#define NET_DVR_NO_TEMP_SENSOR_ERROR         897  //���¶ȴ�����
#define NET_DVR_PUPIL_DISTANCE_OVERSIZE_ERROR         898  //ͫ�����
#define NET_DVR_ERR_UNOPENED_FACE_SNAP           899 //������Ч�����ȿ�������ץ��
//2011-10-25���������������루900-950��
#define  NET_ERR_CUT_INPUTSTREAM_OVERLIMIT           900 //�ź�Դ�ü���ֵ����
#define  NET_ERR_WINCHAN_IDX                        901    // ����ͨ���Ŵ���
#define  NET_ERR_WIN_LAYER                            902    // ���ڲ������󣬵�����Ļ����า�ǵĴ��ڲ���
#define  NET_ERR_WIN_BLK_NUM                        903    // ���ڵĿ������󣬵������ڿɸ��ǵ���Ļ����
#define  NET_ERR_OUTPUT_RESOLUTION                    904    // ����ֱ��ʴ���
#define  NET_ERR_LAYOUT                                905    // ���ֺŴ���
#define  NET_ERR_INPUT_RESOLUTION                    906 // ����ֱ��ʲ�֧��
#define  NET_ERR_SUBDEVICE_OFFLINE                  907 // ���豸������
#define  NET_ERR_NO_DECODE_CHAN                     908 // û�п��н���ͨ��
#define  NET_ERR_MAX_WINDOW_ABILITY                 909 // ������������, �ֲ�ʽ�����������н������豸�������޻�����ʾ�������������޵���
#define  NET_ERR_ORDER_ERROR                        910 // ����˳������
#define  NET_ERR_PLAYING_PLAN                        911 // ����ִ��Ԥ��
#define  NET_ERR_DECODER_USED                        912 // ���������ʹ��
#define     NET_ERR_OUTPUT_BOARD_DATA_OVERFLOW            913    // ���������������
#define     NET_ERR_SAME_USER_NAME                        914    // �û�����ͬ
#define     NET_ERR_INVALID_USER_NAME                    915    // ��Ч�û���
#define     NET_ERR_MATRIX_USING                        916    // �����������ʹ��
#define     NET_ERR_DIFFERENT_CHAN_TYPE                917    // ͨ�����Ͳ�ͬ���������ͨ���Ϳ�����������Ϊ��ͬ�����ͣ�
#define     NET_ERR_INPUT_CHAN_BINDED                    918    // ����ͨ���Ѿ������������
#define     NET_ERR_BINDED_OUTPUT_CHAN_OVERFLOW        919    // ����ʹ�õľ������ͨ����������������������󶨵�ͨ������
#define     NET_ERR_MAX_SIGNAL_NUM                        920    // �����ź�Դ�����ﵽ����
#define  NET_ERR_INPUT_CHAN_USING                    921    // ����ͨ������ʹ��
#define  NET_ERR_MANAGER_LOGON                         922    // ����Ա�Ѿ���½������ʧ��
#define  NET_ERR_USERALREADY_LOGON                     923    // ���û��Ѿ���½������ʧ��
#define  NET_ERR_LAYOUT_INIT                         924    // �������ڳ�ʼ��������ʧ��
#define     NET_ERR_BASEMAP_SIZE_NOT_MATCH                925    // ��ͼ��С���� 
#define  NET_ERR_WINDOW_OPERATING                    926    // ��������ִ���������������β���ʧ��
#define  NET_ERR_SIGNAL_UPLIMIT                        927 // �ź�Դ���������ﵽ����
#define  NET_ERR_SIGNAL_MAX_ENLARGE_TIMES           928 // �ź�Դ�Ŵ������� 
#define  NET_ERR_ONE_SIGNAL_MULTI_CROSS             929 // �����ź�Դ���ܶ�ο���
#define  NET_ERR_ULTRA_HD_SIGNAL_MULTI_WIN          930 // �������ź�Դ�����ظ����� 
#define  NET_ERR_MAX_VIRTUAL_LED_WIDTH              931 //����LED��ȴ�������ֵ
#define  NET_ERR_MAX_VIRTUAL_LED_WORD_LEN           932 //����LED�ַ�����������ֵ
#define     NET_ERR_SINGLE_OUTPUTPARAM_CONFIG            933//��֧�ֵ�����ʾ�����������
#define  NET_ERR_MULTI_WIN_BE_COVER                 934//��������ڱ�����
#define  NET_ERR_WIN_NOT_EXIST                        935 //���ڲ�����
#define  NET_ERR_WIN_MAX_SIGNALSOURCE                936//�����ź�Դ����������ֵ
#define  NET_ERR_MULTI_WIN_MOVE                        937//�Զ���������ƶ�
#define  NET_ERR_MULTI_WIN_YPBPR_SDI                938 // YPBPR ��SDI�ź�Դ��֧��9/16����      
#define  NET_ERR_DIFF_TYPE_OUTPUT_MIXUSE            939  //��ͬ�����������
#define  NET_ERR_SPLIT_WIN_CROSS                    940//�Կ������ڷ���
#define  NET_ERR_SPLIT_WIN_NOT_FULL_SCREEN            941  //��δ�������ڷ���
#define  NET_ERR_SPLIT_WIN_MANY_WIN                    942  //�Ե�����������ж�����ڵĴ��ڷ���
#define  NET_ERR_WINDOW_SIZE_OVERLIMIT              943   //���ڴ�С����
#define  NET_ERR_INPUTSTREAM_ALREADY_JOINT           944    //�ź�Դ�Ѽ���ƴ�� 
#define  NET_ERR_JOINT_INPUTSTREAM_OVERLIMIT          945    //ƴ���ź�Դ��������      

#define  NET_ERR_LED_RESOLUTION                        946  //LED �ֱ��ʴ�������ֱ���
#define  NET_ERR_JOINT_SCALE_OVERLIMIT              947  //ƴ���ź�Դ�Ĺ�ģ����
#define  NET_ERR_INPUTSTREAM_ALREADY_DECODE            948  //�ź�Դ����ǽ
#define  NET_ERR_INPUTSTREAM_NOTSUPPORT_CAPTURE     949  //�ź�Դ��֧��ץͼ
#define  NET_ERR_JOINT_NOTSUPPORT_SPLITWIN            950  //ƴ���ź�Դ��֧�ַ���

//�����������루951-999��
#define NET_ERR_MAX_WIN_OVERLAP                        951 //�ﵽ��󴰿��ص���
#define NET_ERR_STREAMID_CHAN_BOTH_VALID            952 //stream ID��ͨ����ͬʱ��Ч
#define NET_ERR_NO_ZERO_CHAN                        953 //�豸����ͨ��
#define NEED_RECONNECT                                955 //��Ҫ�ض���ת����ϵͳʹ�ã�
#define NET_ERR_NO_STREAM_ID                        956 //��ID������
#define NET_DVR_TRANS_NOT_START                        957 //ת��δ����
#define NET_ERR_MAXNUM_STREAM_ID                    958 //��ID���ﵽ����
#define NET_ERR_WORKMODE_MISMATCH                    959 //����ģʽ��ƥ��
#define NET_ERR_MODE_IS_USING                        960 //�ѹ����ڵ�ǰģʽ
#define NET_ERR_DEV_PROGRESSING                        961 //�豸���ڴ�����
#define NET_ERR_PASSIVE_TRANSCODING                    962 //���ڱ���ת��

#define NET_ERR_RING_NOT_CONFIGURE                 964 //����δ����

#define NET_ERR_CLOSE_WINDOW_FIRST                    971  //�л�ȫ֡�ʳ���ʱ�����ȹرն�Ӧ������ǽ�Ĵ���
#define NET_ERR_SPLIT_WINDOW_NUM_NOT_SUPPORT        972  //VGA/DVI/DP/HDMI/HDBase_T����Դ��ȫ֡�ʳ����²�֧��9/16����
#define NET_ERR_REACH_ONE_SIGNAL_PREVIEW_MAX_LINK   973  //���ź�Դ����������������
#define NET_ERR_ONLY_SPLITWND_SUPPORT_AMPLIFICATION  974  //ֻ�з�������֧���Ӵ��ڷŴ�
#define NET_DVR_ERR_WINDOW_SIZE_PLACE  975  //����λ�ô���
#define NET_DVR_ERR_RGIONAL_RESTRICTIONS  976  //��Ļ���볬��
#define NET_ERR_WNDZOOM_NOT_SUPPORT  977  //�����ڲ�֧���Ӵ���ȫ������
#define NET_ERR_LED_SCREEN_SIZE  978  //LED����߲���ȷ
#define NET_ERR_OPEN_WIN_IN_ERROR_AREA  979  //�ڷǷ����򿪴�(������LCD/LED��)
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_MOVE  980  //ƽ��ģʽ��֧������
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_COVER  981  //ƽ��ģʽ��֧��ͼ�㸲��
#define NET_ERR_TITLE_WIN_NOT_SUPPORT_SPLIT  982  //ƽ��ģʽ��֧�ַ���
#define NET_DVR_LED_WINDOWS_ALREADY_CLOSED  983  //LED����������ڵķֱ��ʷ����仯���豸�ѹرո������ڵ�����LED����
#define NET_DVR_ERR_CLOSE_WINDOWS  984  //����ʧ�ܣ����ȹرմ���
#define NET_DVR_ERR_MATRIX_LOOP_ABILITY            985 //������Ѳ������������
#define NET_DVR_ERR_MATRIX_LOOP_TIME           986 //��Ѳ����ʱ�䲻֧��
#define NET_DVR_ERR_LINKED_OUT_ABILITY           987 //����ͨ������������
#define NET_ERR_REACH_SCENE_MAX_NUM         988 //���������ﵽ����
#define NET_ERR_SCENE_MEM_NOT_ENOUGH        989 //�ڴ治�㣬�޷��½�����
#define NET_ERR_RESOLUTION_NOT_SUPPORT_ODD_VOUT     990     //��ڲ�֧�ָ÷ֱ���
#define NET_ERR_RESOLUTION_NOT_SUPPORT_EVEN_VOUT    991     //ż�ڲ�֧�ָ÷ֱ���

#define NET_DVR_CANCEL_WND_OPENKEEP_ATTR_FIRST    992     //����������Ҫ��ȡ���������Բ��ܱ��ر�
#define NET_SDK_LED_MODE_NOT_SUPPORT_SPLIT        993     //LEDģʽ�²�֧�ִ��ڷ���
#define NET_ERR_VOICETALK_ONLY_SUPPORT_ONE_TALK   994     //ͬʱֻ֧��һ·�����Խ�
#define NET_ERR_WND_POSITION_ADJUSTED             995     //����λ�ñ��豸�������ϲ���Ҫ���»�ȡ�´���λ��
#define NET_SDK_ERR_STARTTIME_CANNOT_LESSTHAN_CURTIME   996     //��ʼʱ�䲻��С�ڵ�ǰʱ��
#define NET_SDK_ERR_NEED_ADJUST_PLAN            997     //�����ѱ�Ԥ�����������Ƚ��ó�����Ԥ����ɾ��
#define NET_ERR_UnitConfig_Failed     998 //�������õ�λͳһ����ѡʱ�����������õĵ�λ��ϵͳ�����µĵ�λ��ͬ���ص�λ���ô���

//�����������������
#define XML_ABILITY_NOTSUPPORT                      1000  //��֧�������ڵ��ȡ
#define    XML_ANALYZE_NOENOUGH_BUF                    1001        //����ڴ治��
#define    XML_ANALYZE_FIND_LOCALXML_ERROR                1002        //�޷��ҵ���Ӧ�ı���xml
#define    XML_ANALYZE_LOAD_LOCALXML_ERROR                1003        //���ر���xml����
#define    XML_NANLYZE_DVR_DATA_FORMAT_ERROR            1004        //�豸�������ݸ�ʽ����
#define    XML_ANALYZE_TYPE_ERROR                        1005        //���������ʹ���
#define    XML_ANALYZE_XML_NODE_ERROR                    1006        //XML�����ڵ��ʽ����
#define XML_INPUT_PARAM_ERROR                       1007  //���������XML�ڵ�ֵ����

#define NET_DVR_ERR_RETURNED_XML_DATA  1008  //�豸���ص�XML��������

//���Դ�����
#define NET_ERR_LEDAREA_EXIST_WINDOW        1051 //LED�����д��ڴ���(���LED�������Ѿ��д��ڴ��ڣ��������޸�LED����
#define NET_ERR_AUDIO_EXIST                 1052 //������ϴ�����Ƶ���������������
#define NET_ERR_MATERIAL_NAME_EXIST                1053 //�ز������Ѵ���
#define NET_ERR_MATERIAL_APPROVE_STATE             1054 //�ز����״̬����
#define NET_ERR_DATAHD_SIGNAL_FORMAT               1055 //��ʹ�õ�Ӳ�̲���������ʽ��

#define NET_ERR_SCENE_SWITCHING             1056 //���������л�
#define NER_ERR_DATA_TRANSFER               1057 //�豸��������ת����
#define NET_ERR_DATA_RESTORE                1058 //�豸�������ݻ�ԭ��
#define NET_ERR_CHECK_NOT_ENABLE            1059  //У��ʹ��δ����
#define NET_ERR_AREA_OFFLINE                1060  //��������
#define NET_ERR_SCREEN_TYPE                 1061 //��Ļ���Ͳ�ƥ��
#define NET_ERR_MIN_OPERATE_UNIT            1062 //��С������Ԫ��ƥ��
#define NET_ERR_MAINHD_NOT_BACKUP           1063 //��һ��λ�ϵ���ͨ�̣����̣���ֹ���óɱ�����
#define NET_ERR_ONE_BACKUP_HD               1064 //���ñ�����ʱ���豸������һ����ͨ��
#define NET_ERR_CONNECT_SUB_SYSTEM_ABNORMAL     1065  //������ϵͳ�쳣
#define NET_ERR_SERIAL_PORT_VEST             1066     //����Ĵ��ڹ���
#define NET_ERR_WHITE_LIST_FULL        1067           //�������б���������
#define NET_ERR_NOT_MATCH_SOURCE    1068         //��ƥ����ź�Դ����
#define NET_ERR_CLOCK_VIRTUAL_LED_FULL    1069        //����ʱ�ӹ��ܵ�����LED������
#define NET_ERR_MAX_WIN_SIGNAL_LOOP_NUM   1070      //������Ѳ�ź�Դ�����Ѵ�����
#define NET_ERR_RESOLUTION_NO_MATCH_FRAME 1071   //�ֱ����뵱ǰ֡����ƥ��
#define NET_ERR_NOT_UPDATE_LOW_VERSION    1072   //��֧����Ͱ汾����
#define NET_ERR_NO_CUSTOM_TO_UPDATE       1073   //�Ƕ��Ƴ����޷�����
#define NET_ERR_CHAN_RESOLUTION_NOT_SUPPORT_SPLIT  1074   //������ڷֱ��ʲ�֧�ַ���
#define NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_SPLIT  1075    //�����岻֧��9/16����ָ�
#define NET_ERR_MIRROR_IMAGE_BY_VIDEO_WALL         1076    //����ǽ�������
#define NET_ERR_MAX_OSD_FONT_SIZE                  1077    //����OSD���֧���ַ���
#define NET_ERR_HIGH_DEFINITION_NOT_SUPPORT_VIDEO_SET  1078  //���岻֧����Ƶ��������
#define NET_ERR_TILE_MODE_NOT_SUPPORT_JOINT        1079  //ƽ��ģʽ��֧��ƴ�Ӵ���
#define NET_ERR_ADD_AUDIO_MATRIX_FAILED         1080  //������Ƶ����ʧ��
#define NET_ERR_ONE_VIRTUAL_LED_AREA_BIND_ONE_AUDIO_AREA   1081  //һ������LED����ֻ�ܰ�һ����Ƶ����
#define NET_ERR_NAT_NOT_MODIFY_SERVER_NETWORK_PARAM   1082  //NAT���޷��޸ķ������������
#define NET_ERR_ORIGINAL_CHECH_DATA_ERROR       1083     //ԭʼУ�����ݴ���
#define NET_ERR_INPUT_BOARD_SPLICED_IN_DIFFERENT_NETWORKAREAS        1084  //��ͬ�������������岻��ƴ��
#define NET_ERR_SPLICINGSOURCE_ONWALL_IN_DIFFERENT_NETWORKAREAS        1085  //��ͬ���������ƴ��Դ������ǽ
#define NET_ERR_ONWALL_OUTPUTBOARD_MODIFY_NETWORKAREAS   1086  //�Ѱ��ڵ���ǽ�ϵ�����岻���޸���������
#define NET_ERR_LAN_AND_WAN_CANNOT_SAME_NET_SEGMENT   1087     //LAN��IP��WAN��IP���ܴ���ͬһ����
#define NET_ERR_USERNAME_REPETITIVE        1088  //�û����ظ�
#define NET_ERR_ASSOCIATED_SAMEWALL_IN_DIFFERENT_NETWORKAREAS   1089  //��ͬ�����������������ڲ��ܹ�����ͬһ����ǽ
#define NET_ERR_BASEMAP_ROAM_IN_LED_AREA   1090     //LED���������ͼ����
#define NET_ERR_VIRTUAL_LED_NOT_SUPPORT_4K_OUTPUT     1091    //����LED��֧��4K�������ʾ
#define NET_ERR_BASEMAP_NOT_SUPPORT_4K_OUTPUT         1092    //��ͼ��֧��4K�������ʾ
#define NET_ERR_MIN_BLOCK_IN_VIRTUAL_LED_AND_OUTPUT   1093   //����LED��������ཻ������С��
#define NET_ERR_485FIlE_VERSION_INVALID               1094   //485�ļ��汾��Ч
#define NET_ERR_485FIlE_CHECK_ERROR                   1095   //485�ļ�У�����
#define NET_ERR_485FIlE_ABNORMAL_SIZE                 1096   //485�ļ���С�쳣Ч
#define NET_ERR_MODIFY_SUBBOARD_NETCFG_IN_NAT         1097   //NAT���޷��޸��Ӱ������
#define NET_ERR_OSD_CONTENT_WITH_ILLEGAL_CHARACTERS   1098   //OSD���ݰ����Ƿ��ַ�
#define NET_ERR_NON_SLAVE_DEVICE_INSERT_SYNC_LINE     1099   //�Ǵ��豸��ֹ����ͬ����
//���ô����루1100��1200��
#define NET_ERR_PLT_USERID                          1100 //��֤ƽ̨userid����
#define NET_ERR_TRANS_CHAN_START                    1101 //͸��ͨ���Ѵ򿪣���ǰ�����޷����
#define NET_ERR_DEV_UPGRADING                        1102 //�豸��������
#define NET_ERR_MISMATCH_UPGRADE_PACK_TYPE          1103 //���������Ͳ�ƥ��
#define NET_ERR_DEV_FORMATTING                      1104 //�豸���ڸ�ʽ��
#define NET_ERR_MISMATCH_UPGRADE_PACK_VERSION       1105 //�������汾��ƥ��
#define NET_ERR_PT_LOCKED                           1106 //PT��������

#define NET_DVR_LOGO_OVERLAY_WITHOUT_UPLOAD_PIC     1110 //logo����ʧ�ܣ�û���ϴ�logoͼƬ
#define NET_DVR_ERR_ILLEGAL_VERIFICATION_CODE        1111 //���Ϸ���֤��
#define NET_DVR_ERR_LACK_VERIFICATION_CODE            1112 //ȱ����֤��
#define NET_DVR_ERR_FORBIDDEN_IP                    1113 //��IP��ַ�ѱ���ֹ������������(�豸֧�ֵ�IP��ַ���˹���)
#define NET_DVR_ERR_UNLOCKPTZ                       1114 //������Ч������������̨
#define NET_DVR_ERR_COUNTAREA_LARGE                 1116 //����������ƴ���������������豸����ֵ
#define NET_DVR_ERR_LABEL_ID_EXCEED                 1117//��ǩID����
#define NET_DVR_ERR_LABEL_TYPE                      1118//��ǩ���ʹ���
#define NET_DVR_ERR_LABEL_FULL                      1119//��ǩ��
#define NET_DVR_ERR_LABEL_DISABLED                  1120//��ǩδʹ��
#define NET_DVR_ERR_DOME_PT_TRANS_TO_DOME_XY        1121//���PTת���XYʧ��
#define NET_DVR_ERR_DOME_PT_TRANS_TO_PANORAMA_XY    1122//���PTתȫ��XYʧ��
#define NET_DVR_ERR_PANORAMA_XY_TRANS_TO_DOME_PT    1123//ȫ��XY����ת���PT����
#define NET_DVR_ERR_SCENE_DUR_TIME_LESS_THAN_INTERV_TIME 1124//����ͣ��ʱ��Ҫ���ڼ������
#define NET_DVR_ERR_HTTP_BKN_EXCEED_ONE            1125//������������ֻ֧��һ·
#define NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_WEBSOCKETS_FIRST    1126//ɾ��ʧ�ܣ����ȹر�HTTPS����������е���ǿ��SDK����WebSockets����
#define NET_DVR_ERR_DELETING_FAILED_TURN_OFF_HTTPS_ESDK_FIRST    1127//ɾ��ʧ�ܣ����ȹر�HTTPS����������е���ǿ��SDK����
#define NET_DVR_ERR_PTZ_OCCUPIED_PRIORITY          1128// �и����ȼ���̨����Ȩ���û�����
#define NET_DVR_ERR_INCORRECT_VIDEOAUDIO_ID        1129// ��Ƶͨ������ID���������ͨ������ID����
#define NET_DVR_ERR_REPETITIONTIME_OVER_MAXIMUM          1130// ȥ��ʱ����󲻳������ֵ
#define NET_DVR_ERR_FORMATTING_FAILED                 1131// ��ʽ������������
#define NET_DVR_ERR_ENCRYPTED_FORMATTING_FAILED       1132// ���ܸ�ʽ��ʧ�ܣ�������
#define NET_DVR_ERR_WRONG_PASSWORD                    1133// �������,��������ȷ�����루SD�� ����У��ʧ�ܣ�
#define NET_DVR_ERR_EXPOSURE_SYNC                     1134// ��ͷ���ع�ͬ���ѿ����������������ֶ�RGB

//2012-10-16 �����豸�����루1200~1300��
#define NET_ERR_SEARCHING_MODULE                    1201 // �����������ģ��
#define NET_ERR_REGISTERING_MODULE                  1202 // ����ע�����ģ��
#define NET_ERR_GETTING_ZONES                        1203 // ���ڻ�ȡ��������
#define NET_ERR_GETTING_TRIGGERS                    1204 // ���ڻ�ȡ������
#define NET_ERR_ARMED_STATUS                        1205 // ϵͳ���ڲ���״̬
#define    NET_ERR_PROGRAM_MODE_STATUS                    1206 // ϵͳ���ڱ��ģʽ
#define    NET_ERR_WALK_TEST_MODE_STATUS                1207 // ϵͳ���ڲ���ģʽ
#define    NET_ERR_BYPASS_STATUS                        1208 // ��·״̬
#define NET_ERR_DISABLED_MODULE_STATUS                1209 // ����δʹ��
#define    NET_ERR_NOT_SUPPORT_OPERATE_ZONE            1210 // ������֧�ָò���
#define NET_ERR_NOT_SUPPORT_MOD_MODULE_ADDR            1211 // ģ���ַ���ܱ��޸�
#define NET_ERR_UNREGISTERED_MODULE                    1212 // ģ��δע��
#define NET_ERR_PUBLIC_SUBSYSTEM_ASSOCIATE_SELF        1213 // ������ϵͳ��������
#define NET_ERR_EXCEEDS_ASSOCIATE_SUBSYSTEM_NUM        1214 // ����������ϵͳ����������
#define NET_ERR_BE_ASSOCIATED_BY_PUBLIC_SUBSYSTEM    1215 // ��ϵͳ������������ϵͳ����
#define    NET_ERR_ZONE_FAULT_STATUS                    1216 // �������ڹ���״̬
#define NET_ERR_SAME_EVENT_TYPE                    1217 // �¼�������������������¼�������������ر�������ͬ�¼�����    
#define NET_ERR_ZONE_ALARM_STATUS                    1218 // �������ڱ���״̬
#define NET_ERR_EXPANSION_BUS_SHORT_CIRCUIT            1219 //��չ���߶�·
#define NET_ERR_PWD_CONFLICT                        1220  //�����ͻ
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_ZONE     1221    //̽�����ѱ���������ע��
#define NET_ERR_DETECTOR_GISTERED_BY_OTHER_PU       1222    //̽�����ѱ���������ע��
#define NET_ERR_DETECTOR_DISCONNECT                 1223    //̽����������
#define NET_ERR_CALL_BUSY                           1224    //�豸����ͨ����
#define NET_DVR_ERR_ZONE_TAMPER_STAUS                1225    //�������ڷ���״̬
#define NET_DVR_ERR_WIRELESS_DEV_REGISTER             1226    //���������ѱ���������ע��
#define NET_DVR_ERR_WIRELESS_DEV_ADDED                1227   //���������ѱ����
#define NET_DVR_ERR_WIRELESS_DEV_OFFLINE              1228  //�������費����
#define NET_DVR_ERR_WIRELESS_DEV_TAMPER_STATUS         1229  //�������账�ڷ���״̬
#define NET_DVR_ERR_GPRS_PHONE_CONFLICT    1230   //�绰���������߱������ĳ�ͻ
//��Ϣ��������
#define NET_ERR_GET_ALL_RETURN_OVER                    1300  //��ȡ���з�����Ŀ����
#define NET_ERR_RESOURCE_USING                      1301  //��Ϣ������Դ����ʹ�ã������޸�
#define NET_ERR_FILE_SIZE_OVERLIMIT                    1302  //�ļ���С����

//��Ϣ����������������
#define NET_ERR_MATERIAL_NAME                       1303  //�ز����ƷǷ�
#define NET_ERR_MATERIAL_NAME_LEN                   1304  //�ز����Ƴ��ȷǷ�
#define NET_ERR_MATERIAL_REMARK                     1305  //�ز������Ƿ�
#define NET_ERR_MATERIAL_REMARK_LEN                 1306  //�ز��������ȷǷ�
#define NET_ERR_MATERIAL_SHARE_PROPERTY             1307  //�زĹ������ԷǷ�
#define NET_ERR_UNSUPPORT_MATERIAL_TYPE             1308  //�ز����Ͳ�֧��
#define NET_ERR_MATERIAL_NOT_EXIST                  1309  //�زĲ�����
#define NET_ERR_READ_FROM_DISK                      1310  //��Ӳ�̶�ȡ�ز��ļ�ʧ��
#define NET_ERR_WRITE_TO_DISK                       1311  //��Ӳ��д�ز��ļ�ʧ��
#define NET_ERR_WRITE_DATA_BASE                     1312  //�ز�д���ݿ�ʧ��
#define NET_ERR_NO_APPROVED_NOT_EXPORT              1313  //δ������ݽ�ֹ����
#define NET_ERR_MATERIAL_EXCEPTION                  1314  //�ز��쳣
#define NET_ERR_NO_MISINFO                          1315  //������Ϣ
#define NET_ERR_LAN_NOT_SUP_DHCP_CLIENT_CONFIGURATION   1316     //������·��ģʽ�£�����DHCP�ͻ��˷��ش���
#define NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT       1317    //����ǽ�ϸ�����ڷֱ��ʲ�һ��(��Ҫ������������ֱ���Ϊ4K�����쳣ʱ����)
#define NET_ERR_VIDEOWALL_OPTPORT_RESOLUTION_INCONSISTENT_UNBIND_OPTPORT_FIRST   1318    //����ǽ�ϸ�����ڷֱ��ʲ�һ�£����Ƚ�������(��Ҫ���ڰ�����ڳ����쳣ʱ����)
#define NET_ERR_FOUR_K_OUTPUT_RESOLUTION_UNSUPPORT_NINE_TO_SIXTEEN_SPLIT_SCREEN    1319    //4K����ֱ��ʲ�֧��9/16����
#define NET_ERR_SIGNAL_SOURCE_UNSUPPORT_CUSTOM_RESOLUTION  1320  //�ź�Դ��֧�ָ��Զ���ֱ���
#define NET_ERR_DVI_UNSUPPORT_FOURK_OUTPUT_RESOLUTION      1321   //DVI��֧��4K����ֱ���
#define NET_ERR_BNC_UNSUPPORT_SOURCE_CROPPING              1322   //BNC��֧���ź�Դ�ü� 

//��������������
#define    NET_ERR_MAX_SCREEN_CTRL_NUM                    1351    //��Ļ�����������ﵽ����
#define    NET_ERR_FILE_NOT_EXIST                        1352    //�ļ�������
#define NET_ERR_THUMBNAIL_NOT_EXIST                    1353    //����ͼ������
#define NET_ERR_DEV_OPEN_FILE_FAIL                    1354    //�豸�˴��ļ�ʧ��
#define NET_ERR_SERVER_READ_FILE_FAIL                1355    //�豸�˶�ȡ�ļ�ʧ��
#define NET_ERR_FILE_SIZE                            1356    //�ļ���С����
#define    NET_ERR_FILE_NAME                            1357    //�ļ����ƴ���Ϊ�ջ򲻺Ϸ�

//�ֶδ����루1351-1400��
#define NET_ERR_BROADCAST_BUSY                     1358     //�豸���ڹ㲥��

//2012-12-20ץ�Ļ������루1400-1499��
#define NET_DVR_ERR_LANENUM_EXCEED                  1400  //��������������
#define NET_DVR_ERR_PRAREA_EXCEED                   1401  //��ʶ�������
#define NET_DVR_ERR_LIGHT_PARAM                     1402  //�źŵƽ����������
#define NET_DVR_ERR_LANE_LINE_INVALID               1403  //���������ô���
#define NET_DVR_ERR_STOP_LINE_INVALID               1404  //ֹͣ�����ô���
#define NET_DVR_ERR_LEFTORRIGHT_LINE_INVALID        1405  //��/��ת�ֽ������ô���
#define NET_DVR_ERR_LANE_NO_REPEAT                  1406  //���ӳ������ظ�
#define NET_DVR_ERR_PRAREA_INVALID                  1407  //��ʶ����β�����Ҫ��
#define NET_DVR_ERR_LIGHT_NUM_EXCEED                1408  //��Ƶ��⽻ͨ���źŵ���Ŀ�������ֵ
#define NET_DVR_ERR_SUBLIGHT_NUM_INVALID            1409  //��Ƶ��⽻ͨ���źŵ��ӵ���Ŀ���Ϸ�
#define NET_DVR_ERR_LIGHT_AREASIZE_INVALID          1410  //��Ƶ��⽻ͨ�������źŵƿ��С���Ϸ�
#define NET_DVR_ERR_LIGHT_COLOR_INVALID             1411  //��Ƶ��⽻ͨ�������źŵ���ɫ���Ϸ�
#define NET_DVR_ERR_LIGHT_DIRECTION_INVALID         1412  //��Ƶ��⽻ͨ������Ʒ������Բ��Ϸ�
#define NET_DVR_ERR_LACK_IOABLITY                    1413  //IO��ʵ��֧�ֵ���������

#define NET_DVR_ERR_FTP_PORT                        1414  //FTP�˿ںŷǷ����˿ں��ظ������쳣��
#define NET_DVR_ERR_FTP_CATALOGUE                   1415  //FTPĿ¼���Ƿ������ö༶Ŀ¼���༶Ŀ¼��ֵΪ�գ�
#define NET_DVR_ERR_FTP_UPLOAD_TYPE                 1416  //FTP�ϴ����ͷǷ�����ftpֻ֧��ȫ��/˫ftpֻ֧�ֿ��ں�Υ�£�
#define NET_DVR_ERR_FLASH_PARAM_WRITE               1417  //���ò���ʱдFLASHʧ��
#define NET_DVR_ERR_FLASH_PARAM_READ                1418  //���ò���ʱ��FLASHʧ��
#define NET_DVR_ERR_PICNAME_DELIMITER               1419  //FTPͼƬ�����ָ����Ƿ�
#define NET_DVR_ERR_PICNAME_ITEM                    1420  //FTPͼƬ������Ƿ������� �ָ�����
#define NET_DVR_ERR_PLATE_RECOGNIZE_TYPE            1421  //��ʶ�������ͷǷ� �����κͶ������Ч��У�飩
#define NET_DVR_ERR_CAPTURE_TIMES                   1422  //ץ�Ĵ����Ƿ� ����Чֵ��0��5��
#define NET_DVR_ERR_LOOP_DISTANCE                   1423  //��Ȧ����Ƿ� ����Чֵ��0��2000ms��
#define NET_DVR_ERR_LOOP_INPUT_STATUS               1424  //��Ȧ����״̬�Ƿ� ����Чֵ��
#define NET_DVR_ERR_RELATE_IO_CONFLICT              1425  //������IO������ͻ
#define NET_DVR_ERR_INTERVAL_TIME                   1426  //���ļ��ʱ��Ƿ� ��0��6000ms��
#define NET_DVR_ERR_SIGN_SPEED                      1427  //��־����ֵ�Ƿ����󳵱�־���ٲ��ܴ���С����־���� ��
#define NET_DVR_ERR_PIC_FLIP                        1428  //ͼ�����÷�ת �����ý���Ӱ�죩
#define NET_DVR_ERR_RELATE_LANE_NUMBER              1429  //�������������� (�ظ� ��ЧֵУ��1��99)
#define NET_DVR_ERR_TRIGGER_MODE                    1430  //����ץ�Ļ�����ģʽ�Ƿ�
#define NET_DVR_ERR_DELAY_TIME                      1431  //������ʱʱ�����(2000ms)
#define NET_DVR_ERR_EXCEED_RS485_COUNT              1432  //�������485��������
#define NET_DVR_ERR_RADAR_TYPE                      1433  //�״����ʹ���
#define NET_DVR_ERR_RADAR_ANGLE                     1434  //�״�Ƕȴ���
#define NET_DVR_ERR_RADAR_SPEED_VALID_TIME          1435  //�״���Чʱ�����
#define NET_DVR_ERR_RADAR_LINE_CORRECT              1436  //�״����Խ�����������
#define NET_DVR_ERR_RADAR_CONST_CORRECT             1437  //�״ﳣ��������������
#define NET_DVR_ERR_RECORD_PARAM                    1438  //¼�������Ч��Ԥ¼ʱ�䲻����10s��
#define NET_DVR_ERR_LIGHT_WITHOUT_COLOR_AND_DIRECTION 1439   //��Ƶ����źŵ������źŵƸ���������û�й�ѡ�źŵƷ������ɫ��
#define NET_DVR_ERR_LIGHT_WITHOUT_DETECTION_REGION   1440   //��Ƶ����źŵ������źŵƸ���������û�л��������
#define NET_DVR_ERR_RECOGNIZE_PROVINCE_PARAM         1441   //��ʶ����ʡ�ݲ����ĺϷ���

#define NET_DVR_ERR_SPEED_TIMEOUT                 1442    //IO���ٳ�ʱʱ��Ƿ�����Чֵ����0��
#define NET_DVR_ERR_NTP_TIMEZONE                  1443    //ntpʱ����������
#define NET_DVR_ERR_NTP_INTERVAL_TIME             1444    //ntpУʱ�������
#define NET_DVR_ERR_NETWORK_CARD_NUM              1445    //������������Ŀ����
#define NET_DVR_ERR_DEFAULT_ROUTE                 1446    //Ĭ��·�ɴ���
#define NET_DVR_ERR_BONDING_WORK_MODE             1447    //bonding��������ģʽ����
#define NET_DVR_ERR_SLAVE_CARD                    1448    //slave��������
#define NET_DVR_ERR_PRIMARY_CARD                  1449    //Primary��������
#define NET_DVR_ERR_DHCP_PPOE_WORK                1450    //dhcp��pppoE����ͬʱ����
#define NET_DVR_ERR_NET_INTERFACE                 1451    //����ӿڴ���
#define NET_DVR_ERR_MTU                           1452    //MTU����
#define NET_DVR_ERR_NETMASK                       1453    //�����������
#define NET_DVR_ERR_IP_INVALID                    1454    //IP��ַ���Ϸ�
#define NET_DVR_ERR_MULTICAST_IP_INVALID          1455    //�ಥ��ַ���Ϸ�
#define NET_DVR_ERR_GATEWAY_INVALID               1456    //���ز��Ϸ�
#define NET_DVR_ERR_DNS_INVALID                   1457    //DNS���Ϸ�
#define NET_DVR_ERR_ALARMHOST_IP_INVALID          1458    //�澯������ַ���Ϸ�
#define NET_DVR_ERR_IP_CONFLICT                   1459    //IP��ͻ
#define NET_DVR_ERR_NETWORK_SEGMENT               1460    //IP��֧��ͬ����
#define NET_DVR_ERR_NETPORT                       1461    //�˿ڴ���

#define NET_DVR_ERR_PPPOE_NOSUPPORT               1462  //PPPOE��֧��
#define NET_DVR_ERR_DOMAINNAME_NOSUPPORT          1463  //������֧��
#define NET_DVR_ERR_NO_SPEED                      1464  //δ���ò��ٹ��� 
#define NET_DVR_ERR_IOSTATUS_INVALID              1465  //IO״̬����
#define NET_DVR_ERR_BURST_INTERVAL_INVALID        1466  //���ļ���Ƿ�    
#define NET_DVR_ERR_RESERVE_MODE                  1467  //����ģʽ����

#define NET_DVR_ERR_LANE_NO                       1468  //���ӳ����Ŵ���
#define NET_DVR_ERR_COIL_AREA_TYPE                1469  //��Ȧ�������ʹ���
#define NET_DVR_ERR_TRIGGER_AREA_PARAM            1470  //���������������
#define NET_DVR_ERR_SPEED_LIMIT_PARAM             1471  //Υ�����ٲ�������
#define NET_DVR_ERR_LANE_PROTOCOL_TYPE            1472  //��������Э�����ʹ���

#define NET_DVR_ERR_INTERVAL_TYPE                 1473  //���ļ�����ͷǷ�
#define NET_DVR_ERR_INTERVAL_DISTANCE             1474  //���ļ������Ƿ�
#define NET_DVR_ERR_RS485_ASSOCIATE_DEVTYPE       1475  //RS485�������ͷǷ�
#define NET_DVR_ERR_RS485_ASSOCIATE_LANENO        1476  //RS485���������ŷǷ�
#define NET_DVR_ERR_LANENO_ASSOCIATE_MULTIRS485   1477  //�����Ź������RS485��
#define NET_DVR_ERR_LIGHT_DETECTION_REGION        1478  //��Ƶ����źŵ������źŵƸ��������Ǽ���������Ϊ0

#define NET_DVR_ERR_DN2D_NOSUPPORT            1479  //��֧��ץ��֡2D����
#define NET_DVR_ERR_IRISMODE_NOSUPPORT        1480  //��֧�ֵľ�ͷ����
#define NET_DVR_ERR_WB_NOSUPPORT              1481  //��֧�ֵİ�ƽ��ģʽ
#define NET_DVR_ERR_IO_EFFECTIVENESS          1482  //IO�ڵ���Ч��
#define NET_DVR_ERR_LIGHTNO_MAX               1483  //�źŵƼ���������/�ƵƳ���(16)
#define NET_DVR_ERR_LIGHTNO_CONFLICT          1484  //�źŵƼ���������/�ƵƳ�ͻ      

#define NET_DVR_ERR_CANCEL_LINE                1485  //ֱ�д�����
#define NET_DVR_ERR_STOP_LINE               1486  //������ֹͣ��
#define NET_DVR_ERR_RUSH_REDLIGHT_LINE      1487  //����ƴ����� 
#define NET_DVR_ERR_IOOUTNO_MAX             1488  //IO����ڱ��Խ��

#define NET_DVR_ERR_IOOUTNO_AHEADTIME_MAX    1489  //IO�������ǰʱ�䳬��
#define NET_DVR_ERR_IOOUTNO_IOWORKTIME      1490  //IO�������Ч����ʱ�䳬��
#define NET_DVR_ERR_IOOUTNO_FREQMULTI       1491  //IO���������ģʽ�±�Ƶ����
#define NET_DVR_ERR_IOOUTNO_DUTYRATE        1492  //IO���������ģʽ��ռ�ձȳ���
#define NET_DVR_ERR_VIDEO_WITH_EXPOSURE     1493  //��������Ч��������ʽ��֧����Ƶ
#define NET_DVR_ERR_PLATE_BRIGHTNESS_WITHOUT_FLASHDET   1494  //���������Զ�ʹ������ƽ��ڳ������Ȳ���ģʽ����Ч

#define NET_DVR_ERR_RECOGNIZE_TYPE_PARAM            1495 //ʶ�����ͷǷ� ����ʶ���������󳵡�С�����������򡢳���ʶ��ȣ�
#define NET_DVR_ERR_PALTE_RECOGNIZE_AREA_PARAM      1496 //��ʶ�����Ƿ� ��ʶ��������ʱ�жϳ���
#define NET_DVR_ERR_PORT_CONFLICT                   1497 //�˿��г�ͻ
#define NET_DVR_ERR_LOOP_IP                         1498 //IP��������Ϊ�ػ���ַ
#define NET_DVR_ERR_DRIVELINE_SENSITIVE             1499 //ѹ�������ȳ���(��Ƶ�羯ģʽ��)


//2013-3-6VQD�����루1500��1550��
#define NET_ERR_VQD_TIME_CONFLICT                    1500 //VQD���ʱ��γ�ͻ
#define NET_ERR_VQD_PLAN_NO_EXIST                    1501 //VQD��ϼƻ�������
#define NET_ERR_VQD_CHAN_NO_EXIST                    1502 //VQD��ص㲻����
#define NET_ERR_VQD_CHAN_MAX                        1503 //VQD�ƻ����Ѵ�����
#define NET_ERR_VQD_TASK_MAX                        1504 //VQD�������Ѵ�����

#define NET_SDK_GET_INPUTSTREAMCFG                  1551  //��ȡ�ź�Դ
#define NET_SDK_AUDIO_SWITCH_CONTROL                1552 //�Ӵ�����Ƶ���ؿ���
#define NET_SDK_GET_VIDEOWALLDISPLAYNO              1553  //��ȡ�豸��ʾ�����
#define NET_SDK_GET_ALLSUBSYSTEM_BASIC_INFO         1554//��ȡ������ϵͳ������Ϣ
#define NET_SDK_SET_ALLSUBSYSTEM_BASIC_INFO         1555 //����������ϵͳ������Ϣ
#define NET_SDK_GET_AUDIO_INFO                      1556//��ȡ������Ƶ��Ϣ
#define NET_SDK_GET_MATRIX_STATUS_V50               1557 // ��ȡ��Ƶ�ۺ�ƽ̨״̬_V50
#define NET_SDK_DELETE_MONITOR_INFO                 1558//ɾ��Monitor��Ϣ
#define NET_SDK_DELETE_CAMERA_INFO                  1559//ɾ��Camaera��Ϣ


//ץ�Ļ�������������չ(1600~1900)
#define NET_DVR_ERR_EXCEED_MAX_CAPTURE_TIMES        1600 //ץ��ģʽΪƵ��ʱ���ץ������Ϊ2��(IVTģʽ��)
#define NET_DVR_ERR_REDAR_TYPE_CONFLICT             1601 //��ͬ485�ڹ����״����ͳ�ͻ 
#define NET_DVR_ERR_LICENSE_PLATE_NULL              1602 //���ƺ�Ϊ��
#define NET_DVR_ERR_WRITE_DATABASE                  1603 //д�����ݿ�ʧ��
#define NET_DVR_ERR_LICENSE_EFFECTIVE_TIME          1604 //������Чʱ�����
//��Ƶ�羯
#define NET_DVR_ERR_PRERECORDED_STARTTIME_LONG      1605 //Ԥ¼��ʼʱ�����Υ��ץ������
//��Ͽ���
#define NET_DVR_ERR_TRIGGER_RULE_LINE               1606 //���������ߴ���
#define NET_DVR_ERR_LEFTRIGHT_TRIGGERLINE_NOTVERTICAL 1607 //��/�Ҵ����߲���ֱ
#define NET_DVR_ERR_FLASH_LAMP_MODE                 1608 //�������˸ģʽ����
#define NET_DVR_ERR_ILLEGAL_SNAPSHOT_NUM            1609 //Υ��ץ����������
#define NET_DVR_ERR_ILLEGAL_DETECTION_TYPE          1610 //Υ�¼�����ʹ���
#define NET_DVR_ERR_POSITIVEBACK_TRIGGERLINE_HIGH   1611 //�����򴥷��߸߶ȴ���
#define NET_DVR_ERR_MIXEDMODE_CAPTYPE_ALLTARGETS    1612 //���ģʽ��ֻ֧�ֻ�����ץ������

#define NET_DVR_ERR_CARSIGNSPEED_GREATERTHAN_LIMITSPEED  1613//С����־���ٴ�������ֵ
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_LIMITSPEED  1614//�󳵱�־���ٴ�������ֵ
#define NET_DVR_ERR_BIGCARSIGNSPEED_GREATERTHAN_CARSIGNSPEED  1615//�󳵱�־���ٴ���С����־����ֵ
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_CARLIMITSPEED  1616//������ֵ����С������ֵ
#define NET_DVR_ERR_BIGCARLOWSPEEDLIMIT_GREATERTHAN_CARLOWSPEEDLIMIT  1617//�󳵵�������ֵ����С����������ֵ
#define NET_DVR_ERR_CARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1618//С�����ٴ����쳣����ֵ
#define NET_DVR_ERR_BIGCARLIMITSPEED_GREATERTHAN_EXCEPHIGHSPEED  1619//�����ٴ����쳣����ֵ
#define NET_DVR_ERR_STOPLINE_MORETHAN_TRIGGERLINE  1620//ֹͣ�߳���ֱ�д�����
#define NET_DVR_ERR_YELLOWLIGHTTIME_INVALID        1621/*��Ƶ���ƵƳ���ʱ�䲻�Ϸ�����*/
#define NET_DVR_ERR_TRIGGERLINE1_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE2 1622//��һ�����������˴����ߵ�λ�ó����˵ڶ������������˴�����
#define NET_DVR_ERR_TRIGGERLINE2_FOR_NOT_YIELD_TO_PEDESTRIAN_CANNOT_EXCEED_TRIGGERLINE1 1623//�ڶ������������˴����ߵ�λ�ó����˵�һ�����������˴�����

//�Ž�����������
#define NET_ERR_TIME_OVERLAP                        1900 //ʱ����ص�
#define NET_ERR_HOLIDAY_PLAN_OVERLAP                1901 //���ռƻ��ص�
#define NET_ERR_CARDNO_NOT_SORT                     1902 //����δ����
#define NET_ERR_CARDNO_NOT_EXIST                    1903 //���Ų�����
#define NET_ERR_ILLEGAL_CARDNO                      1904 //���Ŵ���
#define NET_ERR_ZONE_ALARM                          1905 //�������ڲ���״̬(�����޸Ĳ�����)
#define NET_ERR_ZONE_OPERATION_NOT_SUPPORT          1906 //������֧�ָò���
#define NET_ERR_INTERLOCK_ANTI_CONFLICT             1907 //���Ż����ͷ�Ǳ��ͬʱ���ô���
#define NET_ERR_DEVICE_CARD_FULL                    1908 //�����������ﵽ10W�󷵻أ�
#define NET_ERR_HOLIDAY_GROUP_DOWNLOAD              1909 //����������ʧ��
#define NET_ERR_LOCAL_CONTROL_OFF                    1910 //�͵ؿ���������
#define NET_ERR_LOCAL_CONTROL_DISADD                1911 //�͵ؿ�����δ���
#define NET_ERR_LOCAL_CONTROL_HASADD                1912 //�͵ؿ����������
#define NET_ERR_LOCAL_CONTROL_DOORNO_CONFLICT        1913 //������ӵľ͵ؿ������ű�ų�ͻ
#define NET_ERR_LOCAL_CONTROL_COMMUNICATION_FAIL    1914 //�͵ؿ�����ͨ��ʧ��
#define NET_ERR_OPERAND_INEXISTENCE                  1915 //�������󲻴��ڣ����š��������������������ز�����������δ���ʱ���أ�
#define NET_ERR_LOCAL_CONTROL_OVER_LIMIT              1916 //�͵ؿ����������豸������������ضԾ͵����������ƣ�
#define NET_ERR_DOOR_OVER_LIMIT                         1917 //�ų����豸�������
#define NET_ERR_ALARM_OVER_LIMIT                         1918 //����������������豸�������
#define NET_ERR_LOCAL_CONTROL_ADDRESS_INCONFORMITY_TYPE      1919 //�͵ؿ�������ַ�����Ͳ���
#define NET_ERR_NOT_SUPPORT_ONE_MORE_CARD           1920 //��֧��һ�˶࿨
#define NET_ERR_DELETE_NO_EXISTENCE_FACE            1921 //ɾ��������������
#define NET_ERR_DOOR_SPECIAL_PASSWORD_REPEAT        1922 //���豸�����������ظ�
#define NET_ERR_AUTH_CODE_REPEAT                    1923 //���豸��֤���ظ�
#define NET_ERR_DEPLOY_EXCEED_MAX                   1924 //�����������������
#define NET_ERR_NOT_SUPPORT_DEL_FP_BY_ID            1925 //��������֧�ְ���ָIDɾ��ָ��
#define NET_ERR_TIME_RANGE                          1926 //��Ч�ڲ������÷�Χ����
#define NET_ERR_CAPTURE_TIMEOUT                     1927 //�ɼ���ʱ
#define NET_ERR_LOW_SCORE                           1928 //�ɼ�������
#define NET_ERR_OFFLINE_CAPTURING                   1929 //���߲ɼ��У��޷���Ӧ

//���ӶԽ�������
#define NET_DVR_ERR_OUTDOOR_COMMUNICATION            1950 //���ſڻ�ͨ���쳣
#define NET_DVR_ERR_ROOMNO_UNDEFINED                1951 //δ���÷����
#define NET_DVR_ERR_NO_CALLING                        1952 //�޺���
#define NET_DVR_ERR_RINGING                            1953 //����
#define NET_DVR_ERR_IS_CALLING_NOW                    1954 //����ͨ��
#define NET_DVR_ERR_LOCK_PASSWORD_WRONG             1955//�������������
#define NET_DVR_ERR_CONTROL_LOCK_FAILURE            1956//������ʧ��    
#define NET_DVR_ERR_CONTROL_LOCK_OVERTIME           1957//��������ʱ    
#define NET_DVR_ERR_LOCK_DEVICE_BUSY                1958//�������豸��æ
#define NET_DVR_ERR_UNOPEN_REMOTE_LOCK_FUNCTION     1959//Զ�̿�������δ��


//��˴����� ��2100 - 3000��
#define NET_DVR_ERR_FILE_NOT_COMPLETE               2100    //���ص��ļ�������
#define NET_DVR_ERR_IPC_EXIST                       2101    //��IPC�Ѿ�����
#define NET_DVR_ERR_ADD_IPC                         2102    //��ͨ�������IPC
#define NET_DVR_ERR_OUT_OF_RES                      2103    //���������������
#define NET_DVR_ERR_CONFLICT_TO_LOCALIP             2104    //IPC��ip��ַ��DVR��ip��ַ��ͻ
#define NET_DVR_ERR_IP_SET                          2105    //�Ƿ�ip��ַ
#define NET_DVR_ERR_PORT_SET                        2106    //�Ƿ��Ķ˿ں�

#define NET_ERR_WAN_NOTSUPPORT                      2107     //����ͬһ�����������޷����ð�ȫ����򵼳�GUID�ļ�
#define NET_ERR_MUTEX_FUNCTION                      2108     //���ܻ���
#define NET_ERR_QUESTION_CONFIGNUM                  2109     //��ȫ����������������
#define NET_ERR_FACECHAN_NORESOURCE                 2110     //��������ͨ����Դ������
#define NET_ERR_DATA_CALLBACK                       2111     //�������ݻ�Ǩ
#define NET_ERR_ATM_VCA_CHAN_IS_RELATED             2112     //ATM����ͨ���ѱ�����
#define NET_ERR_ATM_VCA_CHAN_IS_OVERLAPED           2113     //ATM����ͨ���ѱ�����
#define NET_ERR_FACE_CHAN_UNOVERLAP_EACH_OTHER      2114     //����ͨ�����ܻ������
#define NET_ERR_ACHIEVE_MAX_CHANNLE_LIMIT           2115     //�ﵽ���·������
#define NET_DVR_SMD_ENCODING_NORESOURSE             2116  //SMD������Դ����
#define NET_DVR_SMD_DECODING_NORESOURSE             2117  //SMD������Դ����
#define NET_DVR_FACELIB_DATA_PROCESSING             2118  //�������������ڴ���
#define NET_DVR_ERR_LARGE_TIME_DIFFRENCE            2119  //�豸�ͷ�����֮���ʱ�����̫��
#define NET_DVR_NO_SUPPORT_WITH_PLAYBACK            2120  //�ѿ����طţ���֧�ֱ�����
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_SMD         2121  //ͨ���ѿ���SMD����֧�ֱ�����
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_FD          2122  //ͨ���ѿ�������ץ�ģ���֧�ֱ�����
#define NET_DVR_ILLEGAL_PHONE_NUMBER                2123  //�Ƿ��ĵ绰����
#define NET_DVR_ILLEGAL_CERITIFICATE_NUMBER         2124  //�Ƿ���֤������
#define NET_DVR_ERR_CHANNEL_RESOLUTION_NO_SUPPORT   2125  //ͨ���ֱ��ʲ�֧��
#define NET_DVR_ERR_CHANNEL_COMPRESSION_NO_SUPPORT  2126  //ͨ�������ʽ��֧��

#define NET_DVR_ERR_CLUSTER_DEVICE_TOO_LESS                 2127  //�豸���٣�������ɾ��
#define NET_DVR_ERR_CLUSTER_DEL_DEVICE_CM_PLAYLOAD          2128  //���豸�Ǽ�Ⱥ������������ɾ��
#define NET_DVR_ERR_CLUSTER_DEVNUM_OVER_UPPER_LIMIT         2129  //�豸���ﵽ���ޣ�����������
#define NET_DVR_ERR_CLUSTER_DEVICE_TYPE_INCONFORMITY        2130  //�豸���Ͳ�һ��
#define NET_DVR_ERR_CLUSTER_DEVICE_VERSION_INCONFORMITY     2131  //�豸�汾��һ��
#define NET_DVR_ERR_CLUSTER_IP_CONFLICT                     2132  //��ȺϵͳIP��ַ��ͻ��ipv4��ַ��ͻ��ipv6��ַ��ͻ
#define NET_DVR_ERR_CLUSTER_IP_INVALID                      2133  //��ȺϵͳIP��ַ��Ч��ipv4�Ƿ���ipv6�Ƿ�
#define NET_DVR_ERR_CLUSTER_PORT_CONFLICT                   2134  //��Ⱥϵͳ�˿ڳ�ͻ
#define NET_DVR_ERR_CLUSTER_PORT_INVALID                    2135  //��Ⱥϵͳ�˿ڷǷ�
#define NET_DVR_ERR_CLUSTER_USERNAEM_OR_PASSWORD_INVALID    2136  //�����û���������Ƿ�
#define NET_DVR_ERR_CLUSTER_DEVICE_ALREADY_EXIST            2137  //������ͬ�豸
#define NET_DVR_ERR_CLUSTER_DEVICE_NOT_EXIST                2138  //�豸������(����ʱ�·���cs�б��е��豸��Ϣ���κ�һ̨cs�϶��Ҳ�����ɾ����ʱ���·���id����)
#define NET_DVR_ERR_CLUSTER_NON_CLUSTER_MODE                2139  //�豸���ڷǼ�Ⱥģʽ
#define NET_DVR_ERR_CLUSTER_IP_NOT_SAME_LAN                 2140  //IP��ַ����ͬһ����������ͬ����������������/����

#define NET_DVR_ERR_CAPTURE_PACKAGE_FAILED                  2141  //ץ��ʧ��
#define NET_DVR_ERR_CAPTURE_PACKAGE_PROCESSING              2142  //����ץ��
#define NET_DVR_ERR_SAFETY_HELMET_NO_RESOURCE               2143  //��ȫñ�����Դ����
#define NET_DVR_NO_SUPPORT_WITH_ABSTRACT                    2144  //�ѿ�����ƵժҪ����֧�ֱ�����
#define NET_DVR_ERR_TAPE_LIB_NEED_STOP_ARCHIVE              2145  //�Ŵ���鵵��Ҫֹͣ
#define NET_DVR_INSUFFICIENT_DEEP_LEARNING_RESOURCES        2146  //���ѧϰ��Դ����
#define NET_DVR_ERR_IDENTITY_KEY                            2147  //�����������
#define NET_DVR_MISSING_IDENTITY_KEY                        2148  //��������ȱʧ
#define NET_DVR_NO_SUPPORT_WITH_PERSON_DENSITY_DETECT       2149  //�ѿ�����Ա�ܶȼ�⣬��֧�ֱ�����
#define NET_DVR_IPC_RESOLUTION_OVERFLOW                     2150  //IPC�ֱ��ʳ���
#define NET_DVR_IPC_BITRATE_OVERFLOW                        2151  //IPC���ʳ���
#define NET_DVR_ERR_INVALID_TASKID                          2152  //��Ч��taskID
#define NET_DVR_PANEL_MODE_NOT_CONFIG                       2153  //û���������·����
#define NET_DVR_NO_HUMAN_ENGINES_RESOURCE                   2154  //����������Դ����
#define NET_DVR_ERR_TASK_NUMBER_OVERFLOW                    2155  //�������ݳ�������
#define NET_DVR_ERR_COLLISION_TIME_OVERFLOW                 2156  //��ײʱ�䳬������
#define NET_DVR_ERR_CAPTURE_PACKAGE_NO_USB                  2157  //δʶ��U�̣������U�̻����²���
#define NET_DVR_ERR_NO_SET_SECURITY_EMAIL                   2158  //δ���ð�ȫ����
#define NET_DVR_ERR_EVENT_NOTSUPPORT                        2159  //�����¼���֧��
#define NET_DVR_ERR_PASSWORD_FORMAT                         2160  //�����ʽ����
#define NET_DVR_ACCESS_FRONT_DEVICE_PARAM_FAILURE           2161  //��ȡǰ���豸����ʧ��
#define NET_DVR_ACCESS_FRONT_DEVICE_STREAM_FAILURE          2162  //��ǰ���豸ȡ��ʧ��
#define NET_DVR_ERR_USERNAME_FORMAT                         2163  //�û�����ʽ����
#define NET_DVR_ERR_UNOPENED_HIGH_RESOLUTION_MODE           2164  //���߷ֱ���ģʽδ����
#define NET_DVR_ERR_TOO_SMALL_QUATO                         2165  //�������̫С
#define NET_DVR_ERR_EMAIL_FORMAT                            2166  //�����ʽ����
#define NET_DVR_ERR_SECURITY_CODE_FORMAT                    2167  //��ȫ���ʽ����
#define NET_DVR_PD_SPACE_TOO_SMALL                          2168  //����Ӳ������̫С
#define NET_DVR_PD_NUM_TOO_BIG                              2169  //����Ӳ�����������������Ķ���֮һ
#define NET_DVR_ERR_USB_IS_FULL                             2170  //U������
#define NET_DVR_EXCEED_MAX_SMD_TYPE                         2171  //�ﵽ���SMD�¼���������
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_BEHAVIOR            2172  //ͨ���ѿ�����Ϊ��������֧�ֱ�����
#define NET_DVR_NO_BEHAVIOR_ENGINES_RESOURCE                2173  //��Ϊ������Դ����
#define NET_DVR_NO_RETENTION_ENGINES_RESOURCE               2174  //��Ա���������Դ����
#define NET_DVR_NO_LEAVE_POSITION_ENGINES_RESOURCE          2175  //��ڼ����Դ����
#define NET_DVR_NO_PEOPLE_NUM_CHANGE_ENGINES_RESOURCE       2176  //�����쳣��Դ����
#define NET_DVR_PANEL_MODE_NUM_OVER_LIMIT                   2177  //�������·���·��
#define NET_DVR_SURROUND_MODE_NUM_OVER_LIMIT                2178  //��������·���·��
#define NET_DVR_FACE_MODE_NUM_OVER_LIMIT                    2179  //��������·���·��
#define NET_DVR_SAFETYCABIN_MODE_NUM_OVER_LIMIT             2180  //����������·���·��
#define NET_DVR_DETECT_REGION_RANGE_INVALID                 2181  //�������Χ�Ƿ�
#define NET_DVR_CHANNEL_CAPTURE_PICTURE_FAILURE             2182  //ͨ��ץͼʧ��
#define NET_DVR_VCACHAN_IS_NORESOURCE                       2183  //����ͨ����Դ����
#define NET_DVR_IPC_NUM_REACHES_LIMIT                       2184  // Ipcͨ����Ŀ�ﵽ����
#define NET_DVR_IOT_NUM_REACHES_LIMIT                       2185  // IOTͨ����Ŀ�ﵽ����
#define NET_DVR_IOT_CHANNEL_DEVICE_EXIST                    2186  //��ǰIOTͨ���Ѿ�����豸
#define NET_DVR_IOT_CHANNEL_DEVICE_NOT_EXIST                2187  //��ǰIOTͨ���������豸
#define NET_DVR_INVALID_IOT_PROTOCOL_TYPE                   2188  //�Ƿ���IOTЭ������
#define NET_DVR_INVALID_EZVIZ_SECRET_KEY                    2189  //�Ƿ���өʯע����֤��
#define NET_DVR_DUPLICATE_IOT_DEVICE                        2190  //�ظ���IOT�豸
#define NET_DVR_SADP_MODIFY_FALIURE                         2191  // SADP�޸�ʧ��
#define NET_DVR_IPC_NETWORK_ABNORMAL                        2192  // IPC�����쳣 
#define NET_DVR_IPC_PASSWORD_ERROR                          2193  // IPC�û����������
#define NET_DVR_ERROR_IPC_TYPE                              2194  //IPC���Ͳ���
#define NET_DVR_ERROR_IPC_LIST_NOT_EMPTY                    2195  //�����IPC�б�Ϊ�գ���֧��һ������
#define NET_DVR_ERROR_IPC_LIST_NOT_MATCH_PAIRING            2196  //IPC�б���䵥��ƥ��
#define NET_DVR_ERROR_IPC_BAD_LANGUAGE                      2197  //IPC���Ժ��豸��ƥ��
#define NET_DVR_ERROR_IPC_IS_LOCKING                        2198  //IPC�ѱ���
#define NET_DVR_ERROR_IPC_NOT_ACTIVATED                     2199  //IPCδ����
#define NET_DVR_FIELD_CODING_NOT_SUPPORT                    2200  //�����벻֧��
#define NET_DVR_ERROR_H323_NOT_SUPPORT_H265                 2201  //H323��Ƶ����Ͳ�֧��H265����
#define NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_P       2202  //P��ʽ�£��ع�ʱ�����
#define NET_DVR_ERROR_EXPOSURE_TIME_TOO_BIG_IN_MODE_N       2203  //N��ʽ�£��ع�ʱ�����
#define NET_DVR_ERROR_PING_PROCESSING                       2204  //����PING
#define NET_DVR_ERROR_PING_NOT_START                        2205  //Ping����δ��ʼ
#define NET_DVR_ERROR_NEED_DOUBLE_VERIFICATION              2206  //��Ҫ������֤
#define NET_DVR_NO_DOUBLE_VERIFICATION_USER                 2207  //�޶�����֤�û�
#define NET_DVR_CHANNEL_OFFLINE                             2208  //ͨ������
#define NET_DVR_TIMESPAN_NUM_OVER_LIMIT                     2209  //ʱ��γ���֧�������Ŀ
#define NET_DVR_CHANNEL_NUM_OVER_LIMIT                      2210  //ͨ����Ŀ����֧�������Ŀ
#define NET_DVR_NO_SEARCH_ID_RESOURCE                       2211  //��ҳ��ѯ��searchID��Դ����
#define NET_DVR_ERROR_ONEKEY_EXPORT                         2212  //���ڽ��е������������Ժ�����
#define NET_DVR_NO_CITY_MANAGEMENT_ENGINES_RESOURCE         2213  //�ǹ��㷨������Դ����
#define NET_DVR_NO_SITUATION_ANALYSIS_ENGINES_RESOURCE      2214  //̬�Ʒ���������Դ����
#define NET_DVR_INTELLIGENT_ANALYSIS_IPC_CANNT_DELETE       2215  //���ڽ������ܷ�����IPC�޷�ɾ��
#define NET_DVR_NOSUPPORT_RESET_PASSWORD                    2216  //NVR��֧�ֶ�IPC��������
#define NET_DVR_ERROR_IPC_NEED_ON_LAN                       2217  // IPC��Ҫ�ھ�������
#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_SAFETY_HELMET       2218  //ͨ���ѿ�����ȫñ��⣬��֧�ֱ�����
#define NET_DVR_ERROR_GET_RESETPASSWORDTYPE_IS_ABNORMAL     2219  /*IPC��������ʱ����ȡIPC���������������쳣*/
#define NET_DVR_ERROR_IPC_NOSUPPORT_RESET_PASSWORD          2220  /* IPC��֧����������*/
#define NET_DVR_ERROR_IP_IS_NOT_ONLY_ONE                    2221  /*IPC��IP��Ψһ�����ظ�*/
#define NET_DVR_NO_SUPPORT_WITH_SMD_OR_SCD                  2222  //�ѿ���SMD/SCD����֧�ֱ����ܣ�SCDΪ���������
#define NET_DVR_NO_SUPPORT_WITH_FD                          2223  //�ѿ�������ץ�ģ���֧�ֱ�����
#define NET_DVR_NO_FD_ENGINES_RESOURCE                      2224  //����ץ����Դ����
#define NET_DVR_ERROR_ONEKEY_REMOVE                         2225  //���ڽ���ɾ�����������Ժ�����
#define NET_DVR_FACE_PIP_BACKGROUND_CHANNEL_OVERFLOW        2226  //�������л�����ͨ������ 
#define NET_DVR_MICIN_CHANNEL_OCCUPIED                      2227  //micinͨ����ռ��
#define NET_DVR_IPC_CHANNEL_IS_IN_PIP                       2228  //����ʧ�ܣ���ͨ���ѹ�������Ѷͨ��������ȡ�����л����ù���

#define NET_DVR_CHANNEL_NO_SUPPORT_WITH_FACE_CONTRAST       2229  //ͨ���ѿ��������ȶԣ���֧�ֱ�����

#define NET_DVR_INVALID_RECHARGE_CARD                       2230 //��Ч�ĳ�ֵ��
#define NET_DVR_CLOUD_PLATFORM_SERVER_EXCEPTION             2231 //��ƽ̨�������쳣
#define NET_DVR_OPERATION_FAILURE_WITHOUT_LOGIN             2232 //δ��¼����ʧ��
#define NET_DVR_INVALID_ASSOCIATED_SERIAL_NUMBER            2233 //�������кŷǷ�
#define NET_DVR_CLOUD_PLATFORM_ACCOUNT_NOT_EXIST            2234 //��ƽ̨�ʺŲ�����
#define NET_DVR_DEVICE_SERIAL_NUMBER_REGISTERED             2235 //�豸���к���ע��
#define NET_DVR_CONFERENCE_ROOM_NOT_EXIST                   2236 //�����Ҳ�����
#define NET_DVR_NEED_DISABLED_ANALOG_CHANNEL                2237//�����ģ��ͨ��
#define NET_DVR_STUDENT_ROLL_CALL_FAILURE                   2238//ѧ������ʧ��
#define NET_DVR_SUB_DEVICE_NOT_ENABLE_INDIVIDUAL_BEHAVIOR   2239//���豸δ���ø�����Ϊģʽ
#define NET_DVR_SUB_DEVICE_CHANNEL_CONTROL_FAILED           2240//���豸ͨ������ʧ��
#define NET_DVR_DEVICE_NOT_IN_CONFERENCE                    2241//�豸���ڻ�����
#define NET_DVR_ALREADY_EXIST_CONFERENCE                    2242//��ǰ�Ѿ����ڻ���
#define NET_DVR_NO_SUPPORT_WITH_VIDEO_CONFERENCE            2243//��ǰ������Ƶ�����У���֧�ֱ�����
#define NET_DVR_START_INTERACTION_FAILURE                   2244//������ʼʧ��
#define NET_DVR_ASK_QUESTION_STARTED                        2245//�ѿ�ʼ����
#define NET_DVR_ASK_QUESTION_CLOSED                         2246//�ѽ�������
#define NET_DVR_UNABLE_OPERATE_BY_HOST                      2247//�ѱ������˽��ã��޷�����
#define NET_DVR_REPEATED_ASK_QUESTION                       2248//�ظ�����
#define NET_DVR_SWITCH_TIMEDIFF_LESS_LIMIT                         2249/*���ػ�ʱ���С������ֵ(10����)*/
#define NET_DVR_CHANNEL_DEVICE_EXIST                        2250  //��ǰͨ���Ѿ�����豸
#define NET_DVR_CHANNEL_DEVICE_NOT_EXIST                    2251  //��ǰͨ���������豸
#define NET_DVR_ERROR_ADJUSTING_RESOLUTION                  2252  //�ȹر�������Ĳü����ٵ����ֱ���
#define NET_DVR_SSD_FILE_SYSTEM_IS_UPGRADING                2253  //SSD�ļ�ϵͳ��������
#define NET_DVR_SSD_FILE_SYSTEM_IS_FORMAT                   2254  //SSD���ڸ�ʽ��
#define NET_DVR_CHANNEL_IS_CONNECTING                       2255  //��ǰͨ����������

#define NET_DVR_CHANNEL_STREAM_TYPE_NOT_SUPPORT             2257  //��ǰͨ���������Ͳ�֧��
#define NET_DVR_CHANNEL_USERNAME_NOT_EXIST                  2258  //��ǰͨ���û���������
#define NET_DVR_CHANNEL_ACCESS_PARAM_FAILURE                2259  //��ǰͨ����ȡ����ʧ��
#define NET_DVR_CHANNEL_GET_STREAM_FAILURE                  2260  //��ǰͨ��ȡ��ʧ��
#define NET_DVR_CHANNEL_RISK_PASSWORD                       2261  //��ǰͨ������Ϊ��������

#define NET_DVR_NO_SUPPORT_DELETE_STRANGER_LIB              2262  //��֧��ɾ��İ���˿�
#define NET_DVR_NO_SUPPORT_CREATE_STRANGER_LIB              2263  //��֧�ִ���İ���˿�

#define NET_DVR_NETWORK_PORT_CONFLICT                       2264  //�������ö˿ڳ�ͻ
#define NET_DVR_TRANSCODE_NO_RESOURCES                      2265  //ת����Դ����
#define NET_DVR_SSD_FILE_SYSTEM_ERROR                       2266  //SSD�ļ�ϵͳ����
#define NET_DVR_INSUFFICIENT_SSD__FOR_FPD                   2267  //������ԱƵ��ҵ���SSD��������
#define NET_DVR_ASSOCIATED_FACELIB_OVER_LIMIT               2268  //�����������Ѵ�����
#define NET_DVR_NEED_DELETE_DIGITAL_CHANNEL                 2269  //��ɾ������ͨ��

//�ȳ��������ش����루3001 - 3500��
#define NET_DVR_ERR_NOTSUPPORT_DEICING    3001    //�豸��ǰ״̬��֧�ֳ������ܣ�ֻ��POE+��AC24V��DC12V������֧�ֳ������ܣ�
#define NET_DVR_ERR_THERMENABLE_CLOSE     3002    //���¹�����ʹ��δ������(��NET_DVR_THERMOMETRY_BASICPARAMʹ��δ����)
#define NET_DVR_ERR_NOTMEET_DEICING       3003    //��ǰ��ǻ�¶Ȳ������ֶ������������������ǻ�¶�С��30�Ȳſɿ�����
#define NET_DVR_ERR_PANORAMIC_LIMIT_OPERATED   3004    //ȫ����ͼ����λ����ͬʱ����
#define NET_DVR_ERR_SMARTH264_ROI_OPERATED   3005    //SmartH264��ROI����ͬʱ����
#define NET_DVR_ERR_RULENUM_LIMIT   3006    //����������
#define NET_DVR_ERR_LASER_DEICING_OPERATED   3007    //�����Լ��������ܲ���ͬʱ����
#define NET_DVR_ERR_OFFDIGITALZOOM_OR_MINZOOMLIMIT   3008    //���ȹر����ݱ䱶���ܻ�䱶��������Ϊ��Сֵ����ִ���̻��⡢��Ϊ��������ֻ��⡢������������¡��̻����ι���ʱ����û�йر����ݱ䱶���߱䱶����û������Ϊ��Сֵʱ��������ʾ�ô����롣
#define NET_DVR_ERR_FIREWAITING 3009 //�豸��̨���ڻ��ȴ���
#define NET_DVR_SYNCHRONIZEFOV_ERROR 3010 //ͬ���ӳ��Ǵ���
#define NET_DVR_CERTIFICATE_VALIDATION_ERROR 3011 //֤����֤��ͨ��
#define NET_DVR_CERTIFICATES_NUM_EXCEED_ERROR 3012 //֤�������������
#define NET_DVR_RULE_SHIELDMASK_CONFLICT_ERROR 3013  //�������������������ͻ

//ǰ�˲�Ʒ�ߴ����루3501-4000��
#define NET_DVR_ERR_NO_SAFETY_HELMET_REGION            3501  //δ���ð�ȫñ�������
#define NET_DVR_ERR_UNCLOSED_SAFETY_HELMET             3502  //δ�رհ�ȫñ���ʹ��

#define NET_ERR_NPQ_BASE_INDEX    8000    //NPQ�������
#define NET_ERR_NPQ_PARAM       (NET_ERR_NPQ_BASE_INDEX + 1)        //NPQ���������
#define NET_ERR_NPQ_SYSTEM      (NET_ERR_NPQ_BASE_INDEX + 2)        //NPQ�����ϵͳ���ô���(������Դ����ʧ�ܻ��ڲ�����ȣ�
#define NET_ERR_NPQ_GENRAL      (NET_ERR_NPQ_BASE_INDEX + 3)        //NPQ���ڲ�ͨ�ô���
#define NET_ERR_NPQ_PRECONDITION    (NET_ERR_NPQ_BASE_INDEX + 4)        //NPQ�����˳�����
#define NET_ERR_NPQ_NOTSUPPORT        (NET_ERR_NPQ_BASE_INDEX + 5)        //NPQ�⹦�ܲ�֧��

#define NET_ERR_NPQ_NOTCALLBACK    (NET_ERR_NPQ_BASE_INDEX + 100)   //����û�лص�����
#define NET_ERR_NPQ_LOADLIB (NET_ERR_NPQ_BASE_INDEX + 101)   //NPQ�����ʧ��
#define NET_ERR_NPQ_STEAM_CLOSE (NET_ERR_NPQ_BASE_INDEX + 104) //��·����NPQ����δ����
#define NET_ERR_NPQ_MAX_LINK (NET_ERR_NPQ_BASE_INDEX + 110) //NPQȡ��·���ﵽ����
#define NET_ERR_NPQ_STREAM_CFG (NET_ERR_NPQ_BASE_INDEX + 111) //����������ڳ�ͻ����


//���Դ����� 8501~9500
#define NET_ERR_UPGRADE_PROG_ERR                  8501                      //����ִ�г���
#define NET_ERR_UPGRADE_NO_DEVICE                 8502                      //û���豸(ָLED������û�нӽ��տ�)
#define NET_ERR_UPGRADE_NO_FILE                   8503                      //û���ҵ������ļ�
#define NET_ERR_UPGRADE_DATA_ERROR                8504                      //�����ļ����ݲ�����
#define NET_ERR_UPGRADE_LINK_SERVER_ERR        8505                      //�����������ʧ��
#define NET_ERR_UPGRADE_OEMCODE_NOMATCH           8506                      //oemCode��ƥ��
#define NET_ERR_UPGRADE_FLASH_NOENOUGH            8507                      //flash����
#define NET_ERR_UPGRADE_RAM_NOENOUGH              8508                      //RAM����
#define NET_ERR_UPGRADE_DSPRAM_NOENOUGH           8509                      //DSP RAM����
#define NET_ERR_NOT_SUPPORT_CHECK                 8510                      //����Ļ�ͺŲ�֧��У��
#define NET_ERR_LED_DEVICE_BUSY_CHECK             8511                      //LED�豸æ������У����
#define NET_ERR_DEVICE_MEM_NOT_ENOUGH             8512                      //�豸�ڴ治��
#define NET_ERR_CHECK_PARAM                       8513                      //У����������
#define NET_ERR_RESOLUTION_OVER_LIMIT             8514                      //����ֱ��ʳ�������
#define NET_ERR_NO_CUSTOM_BASE                    8515                      //���Զ����ͼ
#define NET_ERR_PRIORITY_LOWER                    8516                      //���ȼ����ڵ�ǰģʽ
#define NET_ERR_SEND_MESSAGE_EXCEPT               8517                      //��Ϣ�����쳣
#define NET_ERR_SENDCARD_UPGRADING                8518                      //���Ϳ�������
#define NET_ERR_NO_WIRELESS_NETCARD               8519                      //δ������������
#define NET_ERR_LOAD_FS_FAIL                      8520                      //����Ļ����ʧ��
#define NET_ERR_FLASH_UNSTORAGE_RECCARD           8521                      //Flash��δ�洢���տ�����

/*******************ȫ�ִ����� end**********************/

/*************************************************
NET_DVR_IsSupport()����ֵ
1��9λ�ֱ��ʾ������Ϣ��λ����TRUE)��ʾ֧�֣�
**************************************************/
#define NET_DVR_SUPPORT_DDRAW            0x01//֧��DIRECTDRAW�������֧�֣��򲥷������ܹ�����
#define NET_DVR_SUPPORT_BLT                0x02//�Կ�֧��BLT�����������֧�֣��򲥷������ܹ�����
#define NET_DVR_SUPPORT_BLTFOURCC        0x04//�Կ�BLT֧����ɫת���������֧�֣��������������������RGBת����
#define NET_DVR_SUPPORT_BLTSHRINKX        0x08//�Կ�BLT֧��X����С�������֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSHRINKY        0x10//�Կ�BLT֧��Y����С�������֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSTRETCHX        0x20//�Կ�BLT֧��X��Ŵ������֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_BLTSTRETCHY        0x40//�Կ�BLT֧��Y��Ŵ������֧�֣�ϵͳ�����������ת����
#define NET_DVR_SUPPORT_SSE                0x80//CPU֧��SSEָ�Intel Pentium3����֧��SSEָ�
#define NET_DVR_SUPPORT_MMX                0x100//CPU֧��MMXָ���Intel Pentium3����֧��SSEָ�

/**********************��̨�������� begin*************************/    
#define LIGHT_PWRON        2    /* ��ͨ�ƹ��Դ */
#define WIPER_PWRON        3    /* ��ͨ��ˢ���� */
#define FAN_PWRON        4    /* ��ͨ���ȿ��� */
#define HEATER_PWRON    5    /* ��ͨ���������� */
#define AUX_PWRON1        6    /* ��ͨ�����豸���� */
#define AUX_PWRON2        7    /* ��ͨ�����豸���� */
#define SET_PRESET        8    /* ����Ԥ�õ� */
#define CLE_PRESET        9    /* ���Ԥ�õ� */

#define ZOOM_IN            11    /* �������ٶ�SS���(���ʱ��) */
#define ZOOM_OUT        12    /* �������ٶ�SS��С(���ʱ�С) */
#define FOCUS_NEAR      13  /* �������ٶ�SSǰ�� */
#define FOCUS_FAR       14  /* �������ٶ�SS��� */
#define IRIS_OPEN       15  /* ��Ȧ���ٶ�SS���� */
#define IRIS_CLOSE      16  /* ��Ȧ���ٶ�SS��С */

#define TILT_UP            21    /* ��̨��SS���ٶ����� */
#define TILT_DOWN        22    /* ��̨��SS���ٶ��¸� */
#define PAN_LEFT        23    /* ��̨��SS���ٶ���ת */
#define PAN_RIGHT        24    /* ��̨��SS���ٶ���ת */
#define UP_LEFT            25    /* ��̨��SS���ٶ���������ת */
#define UP_RIGHT        26    /* ��̨��SS���ٶ���������ת */
#define DOWN_LEFT        27    /* ��̨��SS���ٶ��¸�����ת */
#define DOWN_RIGHT        28    /* ��̨��SS���ٶ��¸�����ת */
#define PAN_AUTO        29    /* ��̨��SS���ٶ������Զ�ɨ�� */

#define FILL_PRE_SEQ    30    /* ��Ԥ�õ����Ѳ������ */
#define SET_SEQ_DWELL    31    /* ����Ѳ����ͣ��ʱ�� */
#define SET_SEQ_SPEED    32    /* ����Ѳ���ٶ� */
#define CLE_PRE_SEQ        33    /* ��Ԥ�õ��Ѳ��������ɾ�� */
#define STA_MEM_CRUISE    34    /* ��ʼ��¼�켣 */
#define STO_MEM_CRUISE    35    /* ֹͣ��¼�켣 */
#define RUN_CRUISE        36    /* ��ʼ�켣 */
#define RUN_SEQ            37    /* ��ʼѲ�� */
#define STOP_SEQ        38    /* ֹͣѲ�� */
#define GOTO_PRESET        39    /* ����ת��Ԥ�õ� */

#define DEL_SEQ         43  /* ɾ��Ѳ��·�� */
#define STOP_CRUISE        44    /* ֹͣ�켣 */
#define DELETE_CRUISE    45    /* ɾ�������켣 */
#define DELETE_ALL_CRUISE 46/* ɾ�����й켣 */

#define PAN_CIRCLE      50   /* ��̨��SS���ٶ��Զ�Բ��ɨ�� */
#define DRAG_PTZ        51   /* �϶�PTZ */
#define LINEAR_SCAN     52   /* ����ɨ�� */ //2014-03-15 
#define CLE_ALL_PRESET  53   /* Ԥ�õ�ȫ����� */ 
#define CLE_ALL_SEQ     54   /* Ѳ��ȫ����� */ 
#define CLE_ALL_CRUISE  55   /* �켣ȫ����� */ 

#define POPUP_MENU      56   /* ��ʾ�����˵� */

#define TILT_DOWN_ZOOM_IN    58    /* ��̨��SS���ٶ��¸�&&�������ٶ�SS���(���ʱ��) */
#define TILT_DOWN_ZOOM_OUT  59  /* ��̨��SS���ٶ��¸�&&�������ٶ�SS��С(���ʱ�С) */
#define PAN_LEFT_ZOOM_IN    60  /* ��̨��SS���ٶ���ת&&�������ٶ�SS���(���ʱ��)*/
#define PAN_LEFT_ZOOM_OUT   61  /* ��̨��SS���ٶ���ת&&�������ٶ�SS��С(���ʱ�С)*/
#define PAN_RIGHT_ZOOM_IN    62  /* ��̨��SS���ٶ���ת&&�������ٶ�SS���(���ʱ��) */
#define PAN_RIGHT_ZOOM_OUT  63  /* ��̨��SS���ٶ���ת&&�������ٶ�SS��С(���ʱ�С) */
#define UP_LEFT_ZOOM_IN     64  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS���(���ʱ��)*/
#define UP_LEFT_ZOOM_OUT    65  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS��С(���ʱ�С)*/
#define UP_RIGHT_ZOOM_IN    66  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS���(���ʱ��)*/
#define UP_RIGHT_ZOOM_OUT   67  /* ��̨��SS���ٶ���������ת&&�������ٶ�SS��С(���ʱ�С)*/
#define DOWN_LEFT_ZOOM_IN   68  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS���(���ʱ��) */
#define DOWN_LEFT_ZOOM_OUT  69  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS��С(���ʱ�С) */
#define DOWN_RIGHT_ZOOM_IN    70  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS���(���ʱ��) */
#define DOWN_RIGHT_ZOOM_OUT    71  /* ��̨��SS���ٶ��¸�����ת&&�������ٶ�SS��С(���ʱ�С) */
#define TILT_UP_ZOOM_IN        72    /* ��̨��SS���ٶ�����&&�������ٶ�SS���(���ʱ��) */
#define TILT_UP_ZOOM_OUT    73    /* ��̨��SS���ٶ�����&&�������ٶ�SS��С(���ʱ�С) */
/**********************��̨�������� end*************************/

#define DVR_VEHICLE_CONTROL_LIST   0x1 //�����ڰ�������������(���͵���������)2013-11-04
    

/*************************************************
�ط�ʱ���ſ�������궨�� 
NET_DVR_PlayBackControl
NET_DVR_PlayControlLocDisplay
NET_DVR_DecPlayBackCtrl�ĺ궨��
����֧�ֲ鿴����˵���ʹ���
**************************************************/    
#define NET_DVR_PLAYSTART        1//��ʼ����
#define NET_DVR_PLAYSTOP        2//ֹͣ����
#define NET_DVR_PLAYPAUSE        3//��ͣ����
#define NET_DVR_PLAYRESTART        4//�ָ�����
#define NET_DVR_PLAYFAST        5//���
#define NET_DVR_PLAYSLOW        6//����
#define NET_DVR_PLAYNORMAL        7//�����ٶ�
#define NET_DVR_PLAYFRAME        8//��֡��
#define NET_DVR_PLAYSTARTAUDIO    9//������
#define NET_DVR_PLAYSTOPAUDIO    10//�ر�����
#define NET_DVR_PLAYAUDIOVOLUME    11//��������
#define NET_DVR_PLAYSETPOS        12//�ı��ļ��طŵĽ���
#define NET_DVR_PLAYGETPOS        13//��ȡ�ļ��طŵĽ���
#define NET_DVR_PLAYGETTIME        14//��ȡ��ǰ�Ѿ����ŵ�ʱ��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_PLAYGETFRAME    15//��ȡ��ǰ�Ѿ����ŵ�֡��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_GETTOTALFRAMES  16//��ȡ��ǰ�����ļ��ܵ�֡��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_GETTOTALTIME    17//��ȡ��ǰ�����ļ��ܵ�ʱ��(���ļ��طŵ�ʱ����Ч)
#define NET_DVR_THROWBFRAME        20//��B֡
#define NET_DVR_SETSPEED        24//���������ٶ�
#define NET_DVR_KEEPALIVE        25//�������豸������(����ص�����������2�뷢��һ��)
#define NET_DVR_PLAYSETTIME        26//������ʱ�䶨λ
#define NET_DVR_PLAYGETTOTALLEN    27//��ȡ��ʱ��طŶ�Ӧʱ����ڵ������ļ����ܳ���
#define NET_DVR_PLAYSETTIME_V50    28//������ʱ�䶨λ(֧��ʱ����չ)
#define NET_DVR_PLAY_FORWARD    29 //�����л�Ϊ����
#define NET_DVR_PLAY_REVERSE    30 //�����л�Ϊ����
#define NET_DVR_SET_DECODEFFRAMETYPE 31 
#define NET_DVR_SET_TRANS_TYPE    32 //����ת���ʽ
#define NET_DVR_PLAY_CONVERT    33 //�ط�ת��
#define NET_DVR_START_DRAWFRAME 34 //��ʼ��֡�ط�
#define NET_DVR_STOP_DRAWFRAME  35 //ֹͣ��֡�ط�
#define NET_DVR_CHANGEWNDRESOLUTION   36    //���ڴ�С�ı䣬֪ͨ���ſ�
#define NET_DVR_RESETBUFFER	    37  //��վ�����뻺������Զ�̻ط��ļ���
#define NET_DVR_VOD_DRAG_ING    38 //�ط��϶���
#define NET_DVR_VOD_DRAG_END    39 //�ط��϶�����
#define NET_DVR_VOD_RESET_PLAYTIME    40 //���貥��ʱ��


#define PLAYM4_DECODE_NORMAIL              0   //��������
#define PLAYM4_DECODE_KEY_FRAME            1   //ֻ��I֡
#define PLAYM4_DECODE_NONE                 2   //ȫ����
#define PLAYM4_DECODE_TEMPORAL_LAYER_0     3   //��1/2
#define PLAYM4_DECODE_TEMPORAL_LAYER_1     4   //��1/4


//Զ�̰����������£�
/* key value send to CONFIG program */
#define KEY_CODE_1      1
#define KEY_CODE_2      2
#define KEY_CODE_3      3
#define KEY_CODE_4      4
#define KEY_CODE_5      5
#define KEY_CODE_6      6
#define KEY_CODE_7      7
#define KEY_CODE_8      8
#define KEY_CODE_9      9
#define KEY_CODE_0      10
#define KEY_CODE_POWER  11
#define KEY_CODE_MENU   12
#define KEY_CODE_ENTER  13
#define KEY_CODE_CANCEL 14
#define KEY_CODE_UP     15
#define KEY_CODE_DOWN   16
#define KEY_CODE_LEFT   17
#define KEY_CODE_RIGHT  18
#define KEY_CODE_EDIT   19
#define KEY_CODE_ADD    20
#define KEY_CODE_MINUS  21
#define KEY_CODE_PLAY   22
#define KEY_CODE_REC    23
#define KEY_CODE_PAN    24
#define KEY_CODE_M      25
#define KEY_CODE_A      26
#define KEY_CODE_F1     27
#define KEY_CODE_F2     28

/* for PTZ control */
#define KEY_PTZ_UP_START        KEY_CODE_UP
#define KEY_PTZ_UP_STOP         32

#define KEY_PTZ_DOWN_START      KEY_CODE_DOWN
#define KEY_PTZ_DOWN_STOP       33

#define KEY_PTZ_LEFT_START      KEY_CODE_LEFT
#define KEY_PTZ_LEFT_STOP       34

#define KEY_PTZ_RIGHT_START     KEY_CODE_RIGHT
#define KEY_PTZ_RIGHT_STOP      35

#define KEY_PTZ_AP1_START       KEY_CODE_EDIT /*��Ȧ+*/
#define KEY_PTZ_AP1_STOP        36

#define KEY_PTZ_AP2_START       KEY_CODE_PAN /*��Ȧ-*/
#define KEY_PTZ_AP2_STOP        37

#define KEY_PTZ_FOCUS1_START    KEY_CODE_A /*�۽�+*/
#define KEY_PTZ_FOCUS1_STOP     38

#define KEY_PTZ_FOCUS2_START    KEY_CODE_M /*�۽�-*/
#define KEY_PTZ_FOCUS2_STOP     39

#define KEY_PTZ_B1_START        40 /*�䱶+*/
#define KEY_PTZ_B1_STOP         41

#define KEY_PTZ_B2_START        42 /*�䱶-*/
#define KEY_PTZ_B2_STOP         43

//9000����
#define KEY_CODE_11             44
#define KEY_CODE_12             45
#define KEY_CODE_13             46
#define KEY_CODE_14             47
#define KEY_CODE_15             48
#define KEY_CODE_16             49



/*************************������������ begin*******************************/
//����NET_DVR_SetDVRConfig��NET_DVR_GetDVRConfig,ע�����Ӧ�����ýṹ

#define NET_DVR_GET_DEVICECFG        100        //��ȡ�豸����
#define NET_DVR_SET_DEVICECFG        101        //�����豸����
#define NET_DVR_GET_NETCFG            102        //��ȡ�������
#define NET_DVR_SET_NETCFG            103        //�����������
#define NET_DVR_GET_PICCFG            104        //��ȡͼ�����
#define NET_DVR_SET_PICCFG            105        //����ͼ�����
#define NET_DVR_GET_COMPRESSCFG        106        //��ȡѹ������
#define NET_DVR_SET_COMPRESSCFG        107        //����ѹ������
#define NET_DVR_GET_RECORDCFG        108        //��ȡ¼��ʱ�����
#define NET_DVR_SET_RECORDCFG        109        //����¼��ʱ�����
#define NET_DVR_GET_DECODERCFG        110        //��ȡ����������
#define NET_DVR_SET_DECODERCFG        111        //���ý���������
#define NET_DVR_GET_RS232CFG         112        //��ȡ232���ڲ���
#define NET_DVR_SET_RS232CFG        113        //����232���ڲ���
#define NET_DVR_GET_ALARMINCFG         114        //��ȡ�����������
#define NET_DVR_SET_ALARMINCFG        115        //���ñ����������
#define NET_DVR_GET_ALARMOUTCFG     116        //��ȡ�����������
#define NET_DVR_SET_ALARMOUTCFG        117        //���ñ����������
#define NET_DVR_GET_TIMECFG         118        //��ȡDVRʱ��
#define NET_DVR_SET_TIMECFG            119        //����DVRʱ��
#define NET_DVR_GET_PREVIEWCFG         120        //��ȡԤ������
#define NET_DVR_SET_PREVIEWCFG        121        //����Ԥ������
#define NET_DVR_GET_VIDEOOUTCFG     122        //��ȡ��Ƶ�������
#define NET_DVR_SET_VIDEOOUTCFG        123        //������Ƶ�������
#define NET_DVR_GET_USERCFG         124        //��ȡ�û�����
#define NET_DVR_SET_USERCFG            125        //�����û�����
#define NET_DVR_GET_EXCEPTIONCFG     126        //��ȡ�쳣����
#define NET_DVR_SET_EXCEPTIONCFG    127        //�����쳣����
#define NET_DVR_GET_ZONEANDDST        128        //��ȡʱ������ʱ�Ʋ���
#define NET_DVR_SET_ZONEANDDST        129        //����ʱ������ʱ�Ʋ���

//ע��������ֻ֧��4��OSD�����ͣ�ͨ������V30���µ��豸�汾��
#define NET_DVR_GET_SHOWSTRING        130        //��ȡ�����ַ�����
#define NET_DVR_SET_SHOWSTRING        131        //���õ����ַ�����

#define NET_DVR_GET_EVENTCOMPCFG    132        //��ȡ�¼�����¼�����
#define NET_DVR_SET_EVENTCOMPCFG    133        //�����¼�����¼�����
#define NET_DVR_GET_FTPCFG            134        //��ȡץͼ��FTP����(����)
#define NET_DVR_SET_FTPCFG            135        //����ץͼ��FTP����(����)
#define NET_DVR_GET_AUXOUTCFG        140        //��ȡ�������������������(HS�豸�������2006-02-28)
#define NET_DVR_SET_AUXOUTCFG        141        //���ñ������������������(HS�豸�������2006-02-28)
#define NET_DVR_GET_PREVIEWCFG_AUX     142        //��ȡ-sϵ��˫���Ԥ������(-sϵ��˫���2006-04-13)
#define NET_DVR_SET_PREVIEWCFG_AUX    143        //����-sϵ��˫���Ԥ������(-sϵ��˫���2006-04-13)

#define NET_DVR_GET_PASSWORD_MANAGE_CFG 144        //��ȡ�����������
#define NET_DVR_SET_PASSWORD_MANAGE_CFG    145        //���������������
#define NET_DVR_UNLOCK_USER             146        //�û�����
#define NET_DVR_GET_SECURITY_CFG         147        //��ȡ��ȫ��֤����
#define NET_DVR_SET_SECURITY_CFG         148        //���ð�ȫ��֤����
#define    NET_DVR_GET_LOCKED_INFO_LIST    149        //��ȡ���б�������Ϣ


/*********************************���ܲ��ֽӿ� begin***************************************/
//��Ϊ��Ӧ��NET_VCA_RULECFG��
#define NET_DVR_SET_RULECFG            152    //������Ϊ��������
#define NET_DVR_GET_RULECFG            153    //��ȡ��Ϊ��������
//����궨������NET_DVR_TRACK_CFG ��
#define NET_DVR_SET_TRACK_CFG       160//������������ò��� 
#define NET_DVR_GET_TRACK_CFG       161//��ȡ��������ò���

//���ܷ�����ȡ�����ýṹ
#define NET_DVR_SET_IVMS_STREAMCFG    162        //�������ܷ�����ȡ������
#define NET_DVR_GET_IVMS_STREAMCFG    163        //��ȡ���ܷ�����ȡ������
//���ܿ��Ʋ����ṹ
#define NET_DVR_SET_VCA_CTRLCFG        164     //�������ܿ��Ʋ���
#define NET_DVR_GET_VCA_CTRLCFG        165     //��ȡ���ܿ��Ʋ���
//��������NET_VCA_MASK_REGION_LIST
#define NET_DVR_SET_VCA_MASK_REGION    166     //���������������
#define NET_DVR_GET_VCA_MASK_REGION    167     //��ȡ�����������

//ATM�������� NET_VCA_ENTER_REGION
#define NET_DVR_SET_VCA_ENTER_REGION 168     //���ý����������
#define NET_DVR_GET_VCA_ENTER_REGION 169     //��ȡ�����������

//�궨������NET_VCA_LINE_SEGMENT_LIST
#define NET_DVR_SET_VCA_LINE_SEGMENT 170     //���ñ궨��
#define NET_DVR_GET_VCA_LINE_SEGMENT 171     //��ȡ�궨��

// ivms��������NET_IVMS_MASK_REGION_LIST
#define NET_DVR_SET_IVMS_MASK_REGION 172     //����IVMS�����������
#define NET_DVR_GET_IVMS_MASK_REGION 173     //��ȡIVMS�����������
// ivms����������NET_IVMS_ENTER_REGION
#define NET_DVR_SET_IVMS_ENTER_REGION 174     //����IVMS�����������
#define NET_DVR_GET_IVMS_ENTER_REGION 175     //��ȡIVMS�����������

#define NET_DVR_SET_IVMS_BEHAVIORCFG  176    //�������ܷ�������Ϊ�������
#define NET_DVR_GET_IVMS_BEHAVIORCFG  177    //��ȡ���ܷ�������Ϊ�������

// IVMS �طż���
#define NET_DVR_IVMS_SET_SEARCHCFG        178    //����IVMS�طż�������
#define NET_DVR_IVMS_GET_SEARCHCFG        179    //��ȡIVMS�طż�������

#define NET_DVR_SET_POSITION_TRACK      180     // ���ó�������������Ϣ
#define NET_DVR_GET_POSITION_TRACK      181     // ��ȡ��������������Ϣ

#define NET_DVR_SET_CALIBRATION         182    // ���ñ궨��Ϣ
#define NET_DVR_GET_CALIBRATION         183    // ��ȡ�궨��Ϣ

#define NET_DVR_SET_PDC_RULECFG         184    // ����������ͳ�ƹ���
#define NET_DVR_GET_PDC_RULECFG         185    // ��ȡ������ͳ�ƹ���

#define NET_DVR_SET_PU_STREAMCFG        186     // ����ǰ��ȡ���豸��Ϣ
#define NET_DVR_GET_PU_STREAMCFG        187     // ��ȡǰ��ȡ���豸��Ϣ

#define NET_VCA_SET_IVMS_BEHAVIOR_CFG        192  // ����IVMS��Ϊ�������� ����ʱ���
#define NET_VCA_GET_IVMS_BEHAVIOR_CFG        193  // ��ȡIVMS��Ϊ�������� ����ʱ���

#define NET_VCA_SET_SIZE_FILTER         194     // ����ȫ�ֳߴ������
#define NET_VCA_GET_SIZE_FILTER         195     // ��ȡȫ�ֳߴ������

#define NET_DVR_SET_TRACK_PARAMCFG      196     // ����������ز˵�����
#define NET_DVR_GET_TRACK_PARAMCFG      197     // ��ȡ������ز˵�����

#define NET_DVR_SET_DOME_MOVEMENT_PARAM 198     // ���������о����
#define NET_DVR_GET_DOME_MOVEMENT_PARAM 199     // ��ȡ�����о����

#define NET_DVR_GET_PICCFG_EX        200        //��ȡͼ�����(SDK_V14��չ����)
#define NET_DVR_SET_PICCFG_EX        201        //����ͼ�����(SDK_V14��չ����)
#define NET_DVR_GET_USERCFG_EX         202        //��ȡ�û�����(SDK_V15��չ����)
#define NET_DVR_SET_USERCFG_EX        203        //�����û�����(SDK_V15��չ����)
#define NET_DVR_GET_COMPRESSCFG_EX    204        //��ȡѹ������(SDK_V15��չ����2006-05-15)
#define NET_DVR_SET_COMPRESSCFG_EX    205        //����ѹ������(SDK_V15��չ����2006-05-15)


#define NET_DVR_GET_NETAPPCFG        222        //��ȡ����Ӧ�ò��� NTP/DDNS/EMAIL
#define NET_DVR_SET_NETAPPCFG        223        //��������Ӧ�ò��� NTP/DDNS/EMAIL
#define NET_DVR_GET_NTPCFG            224        //��ȡ����Ӧ�ò��� NTP
#define NET_DVR_SET_NTPCFG            225        //��������Ӧ�ò��� NTP
#define NET_DVR_GET_DDNSCFG            226        //��ȡ����Ӧ�ò��� DDNS
#define NET_DVR_SET_DDNSCFG            227        //��������Ӧ�ò��� DDNS
//��ӦNET_DVR_EMAILPARA
#define NET_DVR_GET_EMAILCFG        228        //��ȡ����Ӧ�ò��� EMAIL
#define NET_DVR_SET_EMAILCFG        229        //��������Ӧ�ò��� EMAIL

#define NET_DVR_GET_NFSCFG            230        /* NFS disk config */
#define NET_DVR_SET_NFSCFG            231        /* NFS disk config */

/*ע��������Ϊ���ƣ�ֻ֧��8��OSD�����ͣ��������V30�豸�汾֮ǰ��
NET_DVR_GET_SHOWSTRING ��NET_DVR_SET_SHOWSTRING �����������ʹ�ã�*/
#define NET_DVR_GET_SHOWSTRING_EX    238        //��ȡ�����ַ�������չ(֧��8���ַ�)
#define NET_DVR_SET_SHOWSTRING_EX    239        //���õ����ַ�������չ(֧��8���ַ�)
#define NET_DVR_GET_NETCFG_OTHER    244        //��ȡ�������
#define NET_DVR_SET_NETCFG_OTHER    245        //�����������

//��ӦNET_DVR_EMAILCFG�ṹ
#define NET_DVR_GET_EMAILPARACFG    250        //Get EMAIL parameters
#define NET_DVR_SET_EMAILPARACFG    251        //Setup EMAIL parameters


#define NET_DVR_GET_DDNSCFG_EX        274    //��ȡ��չDDNS����
#define NET_DVR_SET_DDNSCFG_EX        275    //������չDDNS����

#define    NET_DVR_SET_PTZPOS            292        //��̨����PTZλ��
#define    NET_DVR_GET_PTZPOS            293        //��̨��ȡPTZλ��
#define    NET_DVR_GET_PTZSCOPE        294        //��̨��ȡPTZ��Χ

#define NET_DVR_GET_AP_INFO_LIST    305//��ȡ����������Դ����
#define NET_DVR_SET_WIFI_CFG        306    //����IP����豸���߲���
#define NET_DVR_GET_WIFI_CFG        307    //��ȡIP����豸���߲���
#define NET_DVR_SET_WIFI_WORKMODE    308    //����IP����豸���ڹ���ģʽ����
#define NET_DVR_GET_WIFI_WORKMODE    309    //��ȡIP����豸���ڹ���ģʽ����
#define    NET_DVR_GET_WIFI_STATUS        310    //��ȡ�豸��ǰwifi����״̬
/*********************************���ܽ�ͨ�¼�begin***************************************/
#define NET_DVR_GET_REFERENCE_REGION            400      //��ȡ�ο�����
#define NET_DVR_SET_REFERENCE_REGION            401      //���òο�����

#define NET_DVR_GET_TRAFFIC_MASK_REGION         402     //��ȡ��ͨ�¼���������
#define NET_DVR_SET_TRAFFIC_MASK_REGION         403     //���ý�ͨ�¼���������
#define NET_DVR_SET_AID_RULECFG                 404     //���ý�ͨ�¼��������
#define NET_DVR_GET_AID_RULECFG                 405     //��ȡ��ͨ�¼��������

#define NET_DVR_SET_TPS_RULECFG                 406     //���ý�ͨͳ�ƹ������
#define NET_DVR_GET_TPS_RULECFG                 407     //��ȡ��ͨͳ�ƹ������

#define NET_DVR_SET_LANECFG                        408        //���ó�������
#define    NET_DVR_GET_LANECFG                        409        //��ȡ��������
#define NET_DVR_GET_VCA_RULE_COLOR_CFG          410     //��ȡ���ܹ����������ɫ����
#define NET_DVR_SET_VCA_RULE_COLOR_CFG          411     //�������ܹ����������ɫ����
#define NET_DVR_GET_SWITCH_LAMP_CFG             412     //��ȡ���صƼ��������ò���
#define NET_DVR_SET_SWITCH_LAMP_CFG             413     //���ÿ��صƼ��������ò��� 


/*********************************���ܽ�ͨ�¼�end***************************************/
#define NET_DVR_SET_FACEDETECT_RULECFG          420         // ��������������
#define NET_DVR_GET_FACEDETECT_RULECFG          421         // ��ȡ����������

#define NET_DVR_SET_VEHICLE_RECOG_TASK          422      //��������ʶ�������ύ
#define NET_DVR_GET_VEHICLE_RECOG_TASK          423      //��������ʶ�������ȡ

#define NET_DVR_SET_TIMECORRECT                    432      //Уʱ���ã�ֻ��Уʱ����������¼Уʱ���� eg.NET_DVR_SET_TIMECFG ���޸��豸��Уʱ���ã�NTPУʱ���ᱻ�޸�Ϊ�ֶ�Уʱ����
#define    NET_DVR_GET_CONNECT_LIST                433         //��ȡ�����豸�б���Ϣ

/***************************DS9000��������(_V30) begin *****************************/
//����(NET_DVR_NETCFG_V30�ṹ)
#define NET_DVR_GET_NETCFG_V30                    1000        //��ȡ�������
#define NET_DVR_SET_NETCFG_V30                    1001        //�����������

//ͼ��(NET_DVR_PICCFG_V30�ṹ)
#define NET_DVR_GET_PICCFG_V30                    1002        //��ȡͼ�����
#define NET_DVR_SET_PICCFG_V30                    1003        //����ͼ�����

//¼��ʱ��(NET_DVR_RECORD_V30�ṹ)
#define NET_DVR_GET_RECORDCFG_V30                1004        //��ȡ¼�����
#define NET_DVR_SET_RECORDCFG_V30                1005        //����¼�����

//�û�(NET_DVR_USER_V30�ṹ)
#define NET_DVR_GET_USERCFG_V30                 1006        //��ȡ�û�����
#define NET_DVR_SET_USERCFG_V30                    1007        //�����û�����

//¼��ʱ��(NET_DVR_RECORD_V40�ṹ)
#define NET_DVR_GET_RECORDCFG_V40                1008        //��ȡ¼�����(��չ)
#define NET_DVR_SET_RECORDCFG_V40                1009        //����¼�����(��չ)

//9000DDNS��������(NET_DVR_DDNSPARA_V30�ṹ)
#define     NET_DVR_GET_DDNSCFG_V30                1010        //��ȡDDNS(9000��չ)
#define     NET_DVR_SET_DDNSCFG_V30                1011        //����DDNS(9000��չ)

//EMAIL����(NET_DVR_EMAILCFG_V30�ṹ)
#define NET_DVR_GET_EMAILCFG_V30                1012     //��ȡEMAIL���� 
#define NET_DVR_SET_EMAILCFG_V30                1013     //����EMAIL���� 

#define NET_DVR_GET_NETCFG_V50     1015    //��ȡ�����������(V50)
#define NET_DVR_SET_NETCFG_V50     1016    //���������������(V50)

#define NET_GET_CRUISEPOINT_V40                    1018     //��ȡѲ��·������

//Ѳ������ (NET_DVR_CRUISE_PARA�ṹ)
#define     NET_DVR_GET_CRUISE                    1020        
#define     NET_DVR_SET_CRUISE                    1021        


//��������ṹ���� (NET_DVR_ALARMINCFG_V30�ṹ)
#define     NET_DVR_GET_ALARMINCFG_V30            1024        
#define     NET_DVR_SET_ALARMINCFG_V30            1025

//��������ṹ���� (NET_DVR_ALARMOUTCFG_V30�ṹ)
#define     NET_DVR_GET_ALARMOUTCFG_V30            1026        
#define     NET_DVR_SET_ALARMOUTCFG_V30            1027

//��Ƶ����ṹ���� (NET_DVR_VIDEOOUT_V30�ṹ)
#define     NET_DVR_GET_VIDEOOUTCFG_V30            1028        
#define     NET_DVR_SET_VIDEOOUTCFG_V30            1029


/*������֧��8��OSD�����ͣ����豸�汾ΪV30����ʱ��������ͨ���豸�汾��ƥ�䣬
ͬʱ����֮ǰ��NET_DVR_GET_SHOWSTRING ��NET_DVR_SET_SHOWSTRING ���������ʹ�ã�*/
//�����ַ��ṹ���� (NET_DVR_SHOWSTRING_V30�ṹ)
#define     NET_DVR_GET_SHOWSTRING_V30            1030        
#define     NET_DVR_SET_SHOWSTRING_V30            1031

//�쳣�ṹ���� (NET_DVR_EXCEPTION_V30�ṹ)
#define     NET_DVR_GET_EXCEPTIONCFG_V30        1034        
#define     NET_DVR_SET_EXCEPTIONCFG_V30        1035

//����232�ṹ���� (NET_DVR_RS232CFG_V30�ṹ)
#define     NET_DVR_GET_RS232CFG_V30            1036        
#define     NET_DVR_SET_RS232CFG_V30            1037

//����Ӳ�̽���ṹ���� (NET_DVR_NET_DISKCFG�ṹ)
#define        NET_DVR_GET_NET_DISKCFG                1038        //����Ӳ�̽����ȡ
#define        NET_DVR_SET_NET_DISKCFG                1039        //����Ӳ�̽�������
//ѹ������ (NET_DVR_COMPRESSIONCFG_V30�ṹ)
#define     NET_DVR_GET_COMPRESSCFG_V30            1040        
#define     NET_DVR_SET_COMPRESSCFG_V30            1041        

//��ȡ485���������� (NET_DVR_DECODERCFG_V30�ṹ)
#define     NET_DVR_GET_DECODERCFG_V30            1042        //��ȡ����������
#define     NET_DVR_SET_DECODERCFG_V30            1043        //���ý���������

//��ȡԤ������ (NET_DVR_PREVIEWCFG_V30�ṹ)
#define     NET_DVR_GET_PREVIEWCFG_V30            1044        //��ȡԤ������
#define     NET_DVR_SET_PREVIEWCFG_V30            1045        //����Ԥ������

//����Ԥ������ (NET_DVR_PREVIEWCFG_AUX_V30�ṹ)
#define     NET_DVR_GET_PREVIEWCFG_AUX_V30        1046        //��ȡ����Ԥ������
#define     NET_DVR_SET_PREVIEWCFG_AUX_V30        1047        //���ø���Ԥ������

//IP�������ò��� ��NET_DVR_IPPARACFG�ṹ��
#define     NET_DVR_GET_IPPARACFG               1048        //��ȡIP����������Ϣ 
#define     NET_DVR_SET_IPPARACFG               1049        //����IP����������Ϣ

//IP��������������ò��� ��NET_DVR_IPALARMINCFG�ṹ��
#define     NET_DVR_GET_IPALARMINCFG            1050        //��ȡIP�����������������Ϣ 
#define     NET_DVR_SET_IPALARMINCFG            1051        //����IP�����������������Ϣ

//IP��������������ò��� ��NET_DVR_IPALARMOUTCFG�ṹ��
#define     NET_DVR_GET_IPALARMOUTCFG           1052        //��ȡIP�����������������Ϣ 
#define     NET_DVR_SET_IPALARMOUTCFG           1053        //����IP�����������������Ϣ

//Ӳ�̹���Ĳ�����ȡ (NET_DVR_HDCFG�ṹ)
#define     NET_DVR_GET_HDCFG                    1054        //��ȡӲ�̹������ò���
#define     NET_DVR_SET_HDCFG                    1055        //����Ӳ�̹������ò���
//�������Ĳ�����ȡ (NET_DVR_HDGROUP_CFG�ṹ)
#define     NET_DVR_GET_HDGROUP_CFG                1056        //��ȡ����������ò���
#define     NET_DVR_SET_HDGROUP_CFG                1057        //��������������ò���

//�豸������������(NET_DVR_COMPRESSION_AUDIO�ṹ)
#define     NET_DVR_GET_COMPRESSCFG_AUD         1058        //��ȡ�豸�����Խ��������
#define     NET_DVR_SET_COMPRESSCFG_AUD         1059        //�����豸�����Խ��������

//IP�������ò��� ��NET_DVR_IPPARACFG_V31�ṹ��
#define     NET_DVR_GET_IPPARACFG_V31           1060        //��ȡIP����������Ϣ 
#define     NET_DVR_SET_IPPARACFG_V31           1061        //����IP����������Ϣ

// ͨ����Դ���� (NET_DVR_IPPARACFG_V40�ṹ)
#define NET_DVR_GET_IPPARACFG_V40               1062        // ��ȡIP��������
#define NET_DVR_SET_IPPARACFG_V40               1063        // ����IP��������

#define NET_DVR_GET_CCDPARAMCFG                 1067       //IPC��ȡCCD��������
#define NET_DVR_SET_CCDPARAMCFG                 1068       //IPC����CCD��������

#define NET_DVR_GET_IOINCFG                        1070    //��ȡץ�Ļ�IO�������
#define NET_DVR_SET_IOINCFG                        1071     //����ץ�Ļ�IO�������

#define NET_DVR_GET_IOOUTCFG                    1072    //��ȡץ�Ļ�IO�������
#define NET_DVR_SET_IOOUTCFG                    1073     //����ץ�Ļ�IO�������

#define NET_DVR_GET_FLASHCFG                    1074    //��ȡIO������������
#define NET_DVR_SET_FLASHCFG                    1075     //����IO������������

#define NET_DVR_GET_LIGHTSNAPCFG                1076    //��ȡץ�Ļ����̵Ʋ���
#define NET_DVR_SET_LIGHTSNAPCFG                1077     //����ץ�Ļ����̵Ʋ���

#define NET_DVR_GET_MEASURESPEEDCFG                1078    //��ȡץ�Ļ����ٲ���
#define NET_DVR_SET_MEASURESPEEDCFG                1079     //����ץ�Ļ����ٲ���

#define NET_DVR_GET_IMAGEOVERLAYCFG                1080//��ȡץ�Ļ�ͼ�������Ϣ����
#define NET_DVR_SET_IMAGEOVERLAYCFG                1081//����ץ�Ļ�ͼ�������Ϣ����

#define NET_DVR_GET_SNAPCFG                        1082//��ȡ��IO����ץ�Ĺ�������
#define NET_DVR_SET_SNAPCFG                        1083//���õ�IO����ץ�Ĺ�������

#define NET_DVR_GET_VTPPARAM                    1084//��ȡ������Ȧ����
#define NET_DVR_SET_VTPPARAM                    1085//����������Ȧ����

#define NET_DVR_GET_SNAPENABLECFG                1086//��ȡץ�Ļ�ʹ�ܲ���
#define NET_DVR_SET_SNAPENABLECFG                1087//����ץ�Ļ�ʹ�ܲ���

#define NET_DVR_GET_POSTEPOLICECFG              1088//��ȡ���ڵ羯����
#define NET_DVR_SET_POSTEPOLICECFG              1089//���ÿ��ڵ羯����

#define NET_DVR_GET_JPEGCFG_V30                    1090//��ȡץͼ��JPEG����(����)
#define NET_DVR_SET_JPEGCFG_V30                    1091//����ץͼ��JPEG����(����)

#define NET_DVR_GET_SPRCFG                        1092//��ȡ����ʶ�����
#define NET_DVR_SET_SPRCFG                        1093//���ó���ʶ�����
#define NET_DVR_GET_PLCCFG                      1094//��ȡ�������Ȳ�������
#define NET_DVR_SET_PLCCFG                      1095//���ó������Ȳ�������

#define NET_DVR_GET_DEVICESTATECFG              1096//��ȡ�豸��ǰ״̬����
#define NET_DVR_SET_CALIBRATE_TIME              1097//������չʱ��Уʱ
#define NET_DVR_GET_CALIBRATE_TIME              1098//��ȡ��չʱ��Уʱ

#define NET_DVR_GET_DEVICECFG_V40                1100//��ȡ��չ�豸���� 
#define NET_DVR_SET_DEVICECFG_V40                1101//������չ�豸����

#define NET_DVR_GET_ZEROCHANCFG                   1102    //��ȡ��ͨ��ѹ������ 
#define NET_DVR_SET_ZEROCHANCFG                  1103    //������ͨ��ѹ������

#define NET_DVR_GET_ZERO_PREVIEWCFG_V30         1104    // ��ȡ��ͨ��Ԥ����������
#define NET_DVR_SET_ZERO_PREVIEWCFG_V30         1105    // ������ͨ��Ԥ����������

#define NET_DVR_SET_ZERO_ZOOM                    1106     //������ͨ������������ 
#define NET_DVR_GET_ZERO_ZOOM                    1107     //��ȡ��ͨ������������

#define    NET_DVR_NATASSOCIATECFG_GET                1110    //��ȡNAT���������Ϣ
#define    NET_DVR_NATASSOCIATECFG_SET                1111     //����NAT���������Ϣ

#define NET_DVR_GET_SNMPCFG                       1112    //��ȡSNMP���� 
#define NET_DVR_SET_SNMPCFG                      1113    //����SNMP����

#define NET_DVR_GET_SNMPCFG_V30                   1114        //��ȡSNMPv30���� 
#define NET_DVR_SET_SNMPCFG_V30                  1115        //����SNMPv30����

#define    NET_DVR_VIDEOPLATFORMALARMCFG_GET        1130  //��ȡ��Ƶ�ۺ�ƽ̨��������
#define    NET_DVR_VIDEOPLATFORMALARMCFG_SET        1131  //������Ƶ�ۺ�ƽ̨��������

#define NET_DVR_GET_RAID_ADAPTER_INFO           1134    // ��ȡ��������Ϣ
#define NET_DVR_SET_RAID_ADAPTER_INFO           1135    // ������������Ϣ   

#define    NET_DVR_MATRIX_BIGSCREENCFG_GET            1140//��ȡ����ƴ�Ӳ���
#define    NET_DVR_MATRIX_BIGSCREENCFG_SET            1141//���ô���ƴ�Ӳ���

#define NET_DVR_GET_MB_PLATFORMPARA                1145 //��ȡƽ̨��¼����
#define NET_DVR_SET_MB_PLATFORMPARA                1146 //����ƽ̨��¼����
#define NET_DVR_GET_MB_DEVSTATUS                1147 //��ȡ�ƶ��豸״̬

#define  NET_DVR_GET_DECODER_JOINT_CHAN            1151//��ȡ�������ͨ��
#define  NET_DVR_SET_DECODER_JOINT_CHAN            1152//���ý������ͨ��

//����������
#define NET_DVR_GET_NETCFG_MULTI                1161        //��ȡ����������
#define NET_DVR_SET_NETCFG_MULTI                1162        //���ö���������
#define NET_DVR_GET_NETCFG_MULTI_V50            1163        //��ȡ����������(����)
#define NET_DVR_SET_NETCFG_MULTI_V50            1164        //���ö���������(����)

#define NET_DVR_GET_CMSPARA                        1170//��ȡƽ̨����
#define NET_DVR_SET_CMSPARA                        1171//����ƽ̨����
#define NET_DVR_GET_DIALSTATUS                    1172//��ȡ����״̬����
#define NET_DVR_GET_SMSRELATIVEPARA                1173//��ȡ������ز���
#define NET_DVR_SET_SMSRELATIVEPARA                1174//���ö�����ز���
#define NET_DVR_GET_PINSTATUS                    1175//��ȡPin״̬
#define NET_DVR_SET_PINCMD                        1176//����PIN����
#define NET_DVR_SET_SENSOR_CFG                    1180//����ģ��������
#define NET_DVR_GET_SENSOR_CFG                    1181//��ȡģ��������
#define NET_DVR_SET_ALARMIN_PARAM                1182//���ñ����������
#define NET_DVR_GET_ALARMIN_PARAM                1183//��ȡ�����������
#define NET_DVR_SET_ALARMOUT_PARAM                1184//���ñ����������
#define NET_DVR_GET_ALARMOUT_PARAM                1185//��ȡ�����������
#define NET_DVR_SET_SIREN_PARAM                    1186//���þ��Ų���
#define NET_DVR_GET_SIREN_PARAM                    1187//��ȡ���Ų���
#define NET_DVR_SET_ALARM_RS485CFG                1188//���ñ�������485����
#define NET_DVR_GET_ALARM_RS485CFG                1189//��ȡ��������485����
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS        1190//��ȡ����������Ҫ״̬
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS        1191//��ȡ������������״̬
#define NET_DVR_SET_ALARMHOST_ENABLECFG            1192//��ȡ��������ʹ��״̬
#define NET_DVR_GET_ALARMHOST_ENABLECFG            1193//���ñ�������ʹ��״̬
#define NET_DVR_SET_ALARM_CAMCFG                1194//������Ƶ�ۺ�ƽ̨��������CAM��������
#define NET_DVR_GET_ALARM_CAMCFG                1195//������Ƶ�ۺ�ƽ̨��������CAM��������
#define NET_DVR_GET_GATEWAY_CFG                 1196//��ȡ�Ž���������
#define NET_DVR_SET_GATEWAY_CFG                 1197//�����Ž���������

#define NET_DVR_GET_ALARMDIALMODECFG            1198//��ȡ�����������Ų���
#define NET_DVR_SET_ALARMDIALMODECFG            1199//���ñ����������Ų���
#define NET_DVR_SET_ALARMIN_PARAM_V50            1200        // ���÷�������V50
#define NET_DVR_GET_ALARMIN_PARAM_V50            1201            // ��ȡ��������V50
#define    NET_DVR_SET_WINCFG                        1202//���ڲ�������
#define NET_DVR_GET_ALARMHOSTDIALSETUPMODE        1204//��ȡ���������������÷�ʽ
#define NET_DVR_SET_ALARMHOSTDIALSETUPMODE        1205//���ñ��������������÷�ʽ

//��Ƶ�����������������(��Ƶ�������� V1.3)
#define NET_DVR_SET_SUBSYSTEM_ALARM                1210    //������ϵͳ��/����
#define NET_DVR_GET_SUBSYSTEM_ALARM                1211    //��ȡ��ϵͳ��/����
#define NET_DVR_GET_WHITELIST_ALARM                1215    //��ȡ����������
#define NET_DVR_SET_WHITELIST_ALARM                1216    //���ð���������
#define    NET_DVR_GET_ALARMHOST_MODULE_LIST        1222    //��ȡ����ģ��
#define NET_DVR_SET_PRIOR_ALARM                    1223    //������ϵͳ��/����
#define NET_DVR_GET_PRIOR_ALARM                    1224    //��ȡ��ϵͳ��/����    
#define NET_DVR_SET_TAMPER_ALARMIN_PARAM        1225    // ���÷����������
#define NET_DVR_GET_TAMPER_ALARMIN_PARAM        1226    // ��ȡ�����������

#define NET_DVR_GET_HOLIDAY_PARAM_CFG           1240// ��ȡ�ڼ��ղ���
#define NET_DVR_SET_HOLIDAY_PARAM_CFG           1241// ���ýڼ��ղ���

#define NET_DVR_GET_MOTION_HOLIDAY_HANDLE       1242// ��ȡ�ƶ������ձ�������ʽ
#define NET_DVR_SET_MOTION_HOLIDAY_HANDLE       1243// ��ȡ�ƶ������ձ�������ʽ

#define NET_DVR_GET_VILOST_HOLIDAY_HANDLE       1244// ��ȡ��Ƶ�źŶ�ʧ���ձ�������ʽ
#define NET_DVR_SET_VILOST_HOLIDAY_HANDLE       1245// ��ȡ��Ƶ�źŶ�ʧ���ձ�������ʽ

#define NET_DVR_GET_HIDE_HOLIDAY_HANDLE         1246// ��ȡ�ڸǼ��ձ�������ʽ
#define NET_DVR_SET_HIDE_HOLIDAY_HANDLE         1247// �����ڸǼ��ձ�������ʽ

#define NET_DVR_GET_ALARMIN_HOLIDAY_HANDLE      1248// ��ȡ����������ձ�������ʽ
#define NET_DVR_SET_ALARMIN_HOLIDAY_HANDLE      1249// ���ñ���������ձ�������ʽ
#define NET_DVR_GET_ALARMOUT_HOLIDAY_HANDLE     1250// ��ȡ����������ձ�������ʽ
#define NET_DVR_SET_ALARMOUT_HOLIDAY_HANDLE     1251// ���ñ���������ձ�������ʽ
#define NET_DVR_GET_HOLIDAY_RECORD              1252// ��ȡ����¼�����
#define NET_DVR_SET_HOLIDAY_RECORD              1253// ���ü���¼�����
#define NET_DVR_GET_NETWORK_BONDING             1254// ��ȡBONDING�������
#define NET_DVR_SET_NETWORK_BONDING             1255// ����BONDING�������
#define NET_DVR_GET_LINK_STATUS                 1256// ��ȡͨ��IP����״̬
#define NET_DVR_GET_DISK_QUOTA_CFG              1278// ��ȡ���������Ϣ
#define NET_DVR_SET_DISK_QUOTA_CFG              1279// ���ô��������Ϣ
#define NET_DVR_GET_JPEG_CAPTURE_CFG            1280// ��ȡDVRץͼ����
#define NET_DVR_SET_JPEG_CAPTURE_CFG            1281// ����DVRץͼ����
#define NET_DVR_GET_SCHED_CAPTURECFG            1282// ��ȡץͼ�ƻ�
#define NET_DVR_SET_SCHED_CAPTURECFG            1283// ����ץͼ�ƻ�
#define NET_DVR_GET_VGA_PREVIEWCFG              1284// ��ȡVGAԤ������
#define NET_DVR_SET_VGA_PREVIEWCFG              1285// ����VGAԤ������ 
#define NET_DVR_GET_VIDEO_INPUT_EFFECT          1286// ��ȡͨ����Ƶ����ͼ�����
#define NET_DVR_SET_VIDEO_INPUT_EFFECT          1287// ����ͨ����Ƶ����ͼ�����

#define NET_DVR_GET_STORAGE_SERVER_SWITCH        1290//��ȡ�洢����������״̬
#define NET_DVR_SET_STORAGE_SERVER_SWITCH        1291//���ô洢����������״̬

#define NET_DVR_GET_DISK_QUOTA_CFG_V60          1292//��ȡ���������ϢV60
#define NET_DVR_SET_DISK_QUOTA_CFG_V60          1293//���ô��������ϢV60

#define NET_DVR_GET_OPTICAL_CHANNEL                1300//��ȡ�����ϵͳͨ��������Ϣ
#define NET_DVR_SET_OPTICAL_CHANNEL                1301//���ù����ϵͳͨ��������Ϣ
#define NET_DVR_GET_FIBER_CASCADE                1302//��ȡ���˼���ģʽ
#define NET_DVR_SET_FIBER_CASCADE                1303//���ù��˼���ģʽ
#define NET_DVR_GET_SPARTAN_STATUS                1304//��ȡ����״̬
#define NET_DVR_SET_SPARTAN_STATUS                1305//���ó���״̬
#define NET_DVR_GET_ETHERNET_CHANNEL            1306//��ȡ�˿ھۺϲ���
#define NET_DVR_SET_ETHERMET_CHANNEL            1307//���ö˿ھۺϲ���
#define NET_DVR_OPTICAL_REBOOT                    1320//��˻�����
#define NET_DVR_SET_AUDIOCHAN_CFG                1321//������Ƶ�л�����
#define NET_DVR_GET_AUDIOCHAN_CFG                1322//��ȡ��Ƶ�л�����
//SDI����1.0
#define NET_DVR_SET_MATRIX_BASE_CFG             1332 //���þ����������
#define NET_DVR_GET_MATRIX_BASE_CFG             1333 //��ȡ�����������
#define NET_DVR_SWITCH_MATRIX_IO                1334 //������������л� 
#define NET_DVR_GET_MATRIX_IO_RELATION          1335 //��ȡ�����������������ϵ

#define    NET_DVR_V6PSUBSYSTEMARAM_GET            1501//��ȡV6��ϵͳ����
#define    NET_DVR_V6PSUBSYSTEMARAM_SET            1502//����V6��ϵͳ����
#define    NET_DVR_GET_ALLWINCFG                    1503 //���ڲ�����ȡ

#define    NET_DVR_BIGSCREENASSOCIATECFG_GET        1511 //��ȡ������������
#define    NET_DVR_BIGSCREENASSOCIATECFG_SET        1512 //���ô�����������

//1200��
#define    NET_DVR_GETSCREENINFO                    1601 //��ȡ������Ϣ����
#define    NET_DVR_SETSCREENINFO                    1602 //���ô�����Ϣ����
#define    NET_DVR_GET_SCREEN_WINCFG                1603//�������ڲ�����ȡ
#define    NET_DVR_LAYOUTLIST_GET                     1605//��ȡ�����б�
#define    NET_DVR_SET_LAYOUTCFG                    1606 //��������
#define    NET_DVR_LAYOUTCTRL                        1607//���ֿ��ƣ�1-open��2-close
#define    NET_DVR_INPUTLIST_GET                    1608 //��ȡ�����ź�Դ�б�
#define    NET_DVR_SET_INPUTSTREAMCFG                1609 //�����ź�Դ���� 
#define    NET_DVR_OUTPUT_SET                        1610 //�����������
#define    NET_DVR_OUTPUT_GET                        1611 //���������ȡ
#define    NET_DVR_SET_OSDCFG                        1612 //OSD��������
#define    NET_DVR_GET_OSDCFG                        1613 //OSD������ȡ
#define    NET_DVR_BIGSCREEN_GETSERIAL             1614//��ȡ����������Ϣ
#define    NET_DVR_GET_PLANLIST                    1615//��ȡԤ���б�
#define    NET_DVR_SET_PLAN                        1616//����Ԥ��
#define    NET_DVR_CTRL_PLAN                        1617//����Ԥ��
#define    NET_DVR_GET_DEVICE_RUN_STATUS           1618//��ȡ�豸����״̬
#define NET_DVR_GET_EXTERNAL_MATRIX_CFG            1619//��ȡ������Ϣ
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG            1620//���þ�����Ϣ
#define    NET_DVR_GET_OUTPUT_SCREEN_RELATION        1621//��ȡ�������Ļ�İ󶨹�ϵ
#define    NET_DVR_SET_OUTPUT_SCREEN_RELATION        1622//�����������Ļ�İ󶨹�ϵ
#define NET_DVR_GET_VCS_USER_CFG                1623//��ȡ�û���Ϣ����
#define    NET_DVR_SET_VCS_USER_CFG                1624//�����û���Ϣ����
#define    NET_DVR_CONTROL_SCREEN                    1625//��Ļ����
#define    NET_DVR_GET_EXTERNAL_MATRIX_CFG_V50        1626    //��ȡ������Ϣ
#define    NET_DVR_SET_EXTERNAL_MATRIX_CFG_V50        1627    //���þ�����Ϣ

#define NET_DVR_GET_DEV_BASEINFO                1650//��ȡ�����豸��Ϣ
#define NET_DVR_SET_DEV_BASEINFO                1651//���õ����豸��Ϣ
#define NET_DVR_GET_DEV_NETINFO                    1652//��ȡ�豸��������Ϣ
#define NET_DVR_SET_DEV_NETINFO                    1653//�����豸��������Ϣ
#define NET_DVR_GET_SIGNAL_SOURCE_INFO            1654//��ȡ�ź�Դ��Ϣ
#define NET_DVR_SET_SIGNAL_SOURCE_INFO            1655//�����ź�Դ��Ϣ
#define NET_DVR_ADJUST_PIC_V40                    1656//ͼ��΢��
#define NET_DVR_RESTORE_V40                        1657//�ָ�Ĭ�ϲ���
#define    NET_DVR_SET_NET_SIGNAL                    1658//���������ź�Դ
#define NET_DVR_REBOOT_V40                        1659//����
#define NET_DVR_CONTROL_PICTURE_V41                1660//ͼƬ����V41

#define NET_DVR_GET_AUTO_REBOOT_CFG             1710//��ȡ�Զ���������
#define NET_DVR_SET_AUTO_REBOOT_CFG             1711//�����Զ���������
#define NET_DVR_GET_TRUNK_USE_STATE             1713//��ȡָ������ʹ��״̬
#define NET_DVR_SET_PTZ_CTRL_INFO                 1714//����PTZ���Ʋ���
#define NET_DVR_GET_PTZ_CTRL_INFO                 1715//��ȡPTZ���Ʋ���
#define NET_DVR_GET_PTZ_STATUS                     1716//��ȡPTZ״̬
#define    NET_DVR_GET_DISP_ROUTE_LIST                1717//��ȡ��ʾ·���б�

#define NET_DVR_GET_DEC_RESOURCE_LIST            1720//��ȡ���ý�����Դ�б�
#define NET_DVR_SET_DEC_RESOURCE_LIST            1721//Ԥ���������Դ 
#define NET_DVR_GET_DEC_YUV                        1722//��ȡ����ͨ������YUV�������
#define NET_DVR_SET_DEC_YUV                        1723//���ý���ͨ������YUV�������
#define NET_DVR_GET_DEC_RESOUCE                    1724//����Ƶ�ۺ�ƽ̨���������Դ
#define NET_DVR_FREE_DEC_RESOURCE                1725//�ͷŽ�����Դ

#define NET_DVR_SET_VIDEOWALLDISPLAYMODE        1730//���õ���ǽƴ��ģʽ
#define NET_DVR_GET_VIDEOWALLDISPLAYMODE        1731//��ȡ����ǽƴ��ģʽ
#define NET_DVR_GET_VIDEOWALLDISPLAYNO          1732//��ȡ�豸��ʾ�����
#define    NET_DVR_SET_VIDEOWALLDISPLAYPOSITION    1733//������ʾ���λ�ò���
#define    NET_DVR_GET_VIDEOWALLDISPLAYPOSITION    1734//��ȡ��ʾ���λ�ò���
#define NET_DVR_GET_VIDEOWALLWINDOWPOSITION     1735//��ȡ����ǽ���ڲ���
#define NET_DVR_SET_VIDEOWALLWINDOWPOSITION     1736//���õ���ǽ���ڲ���
#define    NET_DVR_VIDEOWALLWINDOW_CLOSEALL        1737//����ǽ�ر����д���
#define    NET_DVR_SET_VIRTUALLED                    1738//����LED����
#define    NET_DVR_GET_VIRTUALLED                    1739//����LED��ȡ
#define NET_DVR_GET_IMAGE_CUT_MODE              1740//��ȡͼ���и�ģʽ
#define NET_DVR_SET_IMAGE_CUT_MODE              1741//����ͼ���и�ģʽ
#define NET_DVR_GET_USING_SERIALPORT            1742//��ȡ��ǰʹ�ô���
#define NET_DVR_SET_USING_SERIALPORT            1743//���õ�ǰʹ�ô���
#define NET_DVR_SCENE_CONTROL                   1744//��������
#define NET_DVR_GET_CURRENT_SCENE               1745//��ȡ��ǰ������
#define NET_DVR_GET_VW_SCENE_PARAM              1746//��ȡ����ǽ����ģʽ����
#define NET_DVR_SET_VW_SCENE_PARAM              1747//���õ���ǽ����ģʽ����
#define NET_DVR_DISPLAY_CHANNO_CONTROL          1748//����ǽ��ʾ��ſ���
#define NET_DVR_GET_WIN_DEC_INFO                1749//��ȡ���ڽ�����Ϣ��������
#define NET_DVR_RESET_VIDEOWALLDISPLAYPOSITION  1750  //�������ǽ����ӿڰ� 
#define NET_DVR_SET_VW_AUDIO_CFG                1752    //������Ƶ�л�����
#define    NET_DVR_GET_VW_AUDIO_CFG                1753    //��ȡ��Ƶ�л�����
#define NET_DVR_GET_GBT28181_DECCHANINFO_CFG    1754    //��ȡGBT28181Э������豸�Ľ���ͨ����Ϣ
#define NET_DVR_SET_GBT28181_DECCHANINFO_CFG    1755    //����GBT28181Э������豸�Ľ���ͨ����Ϣ
#define    NET_DVR_SET_MAINBOARD_SERIAL            1756  //�������ذ崮�ڲ���
#define    NET_DVR_GET_MAINBOARD_SERIAL            1757  //��ȡ���ذ崮�ڲ���
#define NET_DVR_GET_SUBBOARD_INFO               1758  //��ȡ�Ӱ���Ϣ
#define NET_DVR_GET_SUBBOARD_EXCEPTION          1759  //��ȡ�쳣�Ӱ��쳣��Ϣ

#define NET_DVR_GET_CAMERACHAN_SERIALCFG    1760   //��ȡCameraͨ���󶨴�������
#define NET_DVR_SET_CAMERACHAN_SERIALCFG    1761   //����Cameraͨ���󶨴�������
#define NET_DVR_GET_MATRIX_STATUS            1762   //��ȡ��Ƶ�ۺ�ƽ̨״̬
#define    NET_SET_MULTIFUNCTION_SERIALCFG     1763  //���ö๦�ܴ�������
#define    NET_GET_MULTIFUNCTION_SERIALCFG        1764  //��ȡ�๦�ܴ�������
#define NET_DVR_PTZ_3D_SPEED                1765  // 3ά���ٶȵ���̨����

#define  NET_DVR_GET_SIGNAL_JOINT            1766   //��ȡ�ź�Դ������
#define  NET_DVR_SET_SIGNAL_JOINT            1767   //�����ź�Դ������
#define  NET_DVR_SIGNAL_CUT                    1768   //�ź�Դ�ü�
#define  NET_DVR_DYNAMIC_DECODE_BATCH        1769     //������̬����
#define  NET_DVR_DECSWITCH_SET_BATCH        1770    //�������ý���ͨ������
#define  NET_DVR_DECSWITCH_GET_BATCH        1771    //������ȡ����ͨ������
#define  NET_DVR_GET_ALL_SIGNAL_JOINT        1772   //��ȡ�����ź�Դ������
#define     NET_DVR_GET_PLAYING_PLAN            1773    //��ȡ����ִ��Ԥ��
#define  NET_DVR_WALL_RELATION_GET            1774   //��ȡ�豸ǽ������ǽ�Ĺ���
#define  NET_DVR_WALL_RELATION_SET            1775   //�����豸ǽ������ǽ�Ĺ���
#define     NET_DVR_SET_INPUTSTREAMCFG_V40        1776   //�����ź�Դ����
#define  NET_DVR_PTZCFG_INPUTSTREAM_GET        1777  //��ȡ����Դ������̨��������
#define  NET_DVR_PTZCFG_INPUTSTREAM_SET        1778  //��������Դ������̨��������
#define  NET_DVR_SIGNAL_CUTPARAM_GET        1779  //��ȡ�ź�Դ�ü�����

#define NET_DVR_GET_SUBSYSTEM_NETCFG            1780    //��ȡ��ϵͳ��������
#define NET_DVR_SET_SUBSYSTEM_NETCFG              1781    //������ϵͳ��������
#define    NET_DVR_DEL_SIGNAL_JOINT                1782    //ɾ��ƴ���ź�Դ

#define NET_DVR_GET_PICTURE_INFO                1783     //��ȡͼƬ��Ϣ
#define NET_DVR_SET_PICTURE_INFO                1784     //����ͼƬ��Ϣ
#define NET_DVR_GET_VIDEO_INFO                    1785     //��ȡ��Ƶ��Ϣ
#define NET_DVR_SET_VIDEO_INFO                    1786     //������Ƶ��Ϣ
#define NET_DVR_SET_PLAYLIST                    1787     //���ò����б�
#define NET_DVR_GET_PLAYLIST                    1788     //��ȡ�����б�
#define NET_DVR_GET_ALL_PLAYLIST                1789     //��ȡ���в����б�
#define NET_DVR_PLAYITEM_CONTROL                1790     //���������
#define NET_DVR_SET_PLAYPLAN_TEMPLATE            1791     //���ò��żƻ�ģ��
#define NET_DVR_GET_PLAYPLAN_TEMPLATE            1792     //��ȡ���żƻ�
#define NET_DVR_GET_ALL_PLAYPLAN_TEMPLATE        1793     //��ȡ���в��żƻ�
#define NET_DVR_SET_WINDOW_PLAYPLAN                1794     //���ô��ڲ��żƻ�
#define NET_DVR_GET_WINDOW_PLAYPLAN                1795     //��ȡ���ڲ��żƻ�
#define NET_DVR_TOPLAY_ITEM                        1796     //ָ������
#define NET_DVR_DEVICE_PLAY_CONTROL                1797     //�豸���ſ���
#define NET_DVR_GET_PLAY_INFO                    1798     //��ȡ��ǰ������Ϣ
#define NET_DVR_GET_ALL_PICTURE_INFO            1799     //��ȡͼƬ��Ϣ
#define NET_DVR_GET_ALL_VIDEO_INFO                1800     //��ȡ��Ƶ��Ϣ
#define NET_DVR_DELETE_VIDEO_FILE                1801     //ɾ����Ƶ


#define NET_DVR_GET_ALARMHOSTSUBSYSTEM_CFG        2001//����������ȡ��ϵͳ����
#define NET_DVR_SET_ALARMHOSTSUBSYSTEM_CFG        2002//��������������ϵͳ����
#define NET_DVR_GETEXTENDALARMININFO            2003//��ȡ���������Ϣ
#define NET_DVR_MODIFYALARMINNO                 2004//�޸ķ��������Ϣ
#define NET_DVR_GET_ALARMHOST_WIRELESS_NETWORK_CFG    2005//��ȡ���������������
#define    NET_DVR_SET_ALARMHOST_WIRELESS_NETWORK_CFG    2006//�������������������
#define    NET_DVR_GET_ALARMHOST_NETCFG            2007//��ȡ�����������
#define    NET_DVR_SET_ALARMHOST_NETCFG            2008//���������������
#define NET_DVR_GET_LED_SCREEN_CFG                2009// ��ȡLED��Ļ����
#define NET_DVR_SET_LED_SCREEN_CFG                2010// ����LED��Ļ����
#define NET_DVR_GET_LED_CONTENT_CFG                2011// ��ȡLED��������
#define    NET_DVR_SET_LED_CONTENT_CFG                2012// ����LED��������
#define NET_DVR_TURNON_LED                        2013// ��LED��
#define NET_DVR_TURNOFF_LED                        2014// �ر�LED��
#define NET_DVR_GET_LED_TIMER_SWITCH            2015// ��ȡLED����ʱ���ز���
#define NET_DVR_SET_LED_TIMER_SWITCH            2016// ����LED����ʱ���ز���
#define NET_DVR_SET_LED_BRIGHTNESS                2017// �ֶ�����LED������
#define NET_DVR_GET_LED_TIMER_BRIGHTNESS            2018//���÷�ʱLED������
#define NET_DVR_SET_LED_TIMER_BRIGHTNESS            2019//��ȡ��ʱLED������
#define NET_DVR_LED_CHECKTIME                        2020//LEDУʱ
#define NET_DVR_GET_ALARMHOST_AUDIO_ASSOCIATE_ALARM    2021//��ȡ��Ƶ���汨���¼�
#define NET_DVR_SET_ALARMHOST_AUDIO_ASSOCIATE_ALARM    2022//������Ƶ���汨���¼�
#define    NET_DVR_GET_LED_STATUS                        2023//��ȡLED��״̬
#define NET_DVR_CLOSE_SUBSYSTEM_FAULT_ALARM         2027//�ر���ϵͳ������ʾ��
#define NET_DVR_SET_SUBSYSTEM_BYPASS                2028//��ϵͳ��·
#define NET_DVR_CANCEL_SUBSYSTEM_BYPASS                2029//��ϵͳ��·�ָ�

#define NET_DVR_GET_ALARMHOST_SUBSYSTEM_CFG_EX        2030//��ȡ��ϵͳ��չ����
#define    NET_DVR_SET_ALARMHOST_SUBSYSTEM_CFG_EX        2031//������ϵͳ��չ����
#define NET_DVR_GET_ALARMHOST_PRINTER_CFG            2032//��ȡ��ӡ����ӡʹ��
#define    NET_DVR_SET_ALARMHOST_PRINTER_CFG            2033//���ô�ӡ����ӡʹ��
#define    NET_DVR_GET_ALARMHOST_ZONE_LIST_IN_SUBSYSTEM 2034//��ȡָ����ϵͳ�ڵ����з���
#define    NET_DVR_GET_ALARMHOST_TRIGGER_LIST            2035//��ȡ���д�����
#define    NET_DVR_ARM_ALARMHOST_SUBSYSTEM                2036//���������Ͷ���ϵͳ����
#define    NET_DVR_GET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2037// ��ȡ�¼����������������
#define NET_DVR_SET_ALARMHOST_EVENT_TRIG_ALARMOUT_CFG 2038// �����¼����������������
#define    NET_DVR_GET_ALARMHOST_FAULT_CFG                2039// ��ȡ���ϴ�������
#define NET_DVR_SET_ALARMHOST_FAULT_CFG                2040// ���ù��ϴ�������
#define NET_DVR_SEARCH_ARMHOST_EXTERNAL_MODULE         2041//�Զ�����
#define    NET_DVR_REGISTER_ALARMHOST_EXTERNAL_MODULE    2042//�Զ�ע��
#define NET_DVR_CLOSE_ALARMHOST_OVERALL_FAULT_ALARM 2043//�ر�ȫ�ֹ�����ʾ��

#define NET_DVR_GET_SAFETYCABIN_WORK_MODE            2044 //��ȡ�����չ���ģʽ����
#define NET_DVR_SET_SAFETYCABIN_WORK_MODE            2045 //���÷����չ���ģʽ����
#define NET_DVR_GET_SAFETYCABIN_PERSON_SIGNAL_CFG   2046 //��ȡ���������ź�̽�����
#define NET_DVR_SET_SAFETYCABIN_PERSON_SIGNAL_CFG   2047 //���÷��������ź�̽�����

#define  NET_DVR_GET_ALARMHOST_MODULE_CFG            2048//��ȡģ����Ϣ
//#define  NET_DVR_SET_ALARMHOST_MODULE_CFG            2049//����ģ����Ϣ(Ԥ��)

#define     NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_STATE        2050//��ȡ485����豸״̬
#define  NET_DVR_SET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2051//��������豸������ֵ
#define  NET_DVR_GET_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE  2052//��ȡ����豸������ֵ
#define  NET_DVR_GET_ALARMHOST_SENSOR_JOINT_CFG                2053// ��ȡģ������������
#define  NET_DVR_SET_ALARMHOST_SENSOR_JOINT_CFG                2054// ����ģ������������
#define     NET_DVR_SET_ALARMHOST_RS485_SLOT_CFG                2055// ���ñ�������485��λ����
#define  NET_DVR_GET_ALARMHOST_RS485_SLOT_CFG                2056// ��ȡ��������485��λ����

#define NET_DVR_GET_ALL_VARIABLE_INFO      2057   // ��ȡ���б���Ԫ����Ϣ
#define NET_DVR_GET_ALARM_POINT_CFG       2058   // ��ȡ�����Ϣ
#define NET_DVR_SET_ALARM_POINT_CFG       2059   // ���õ����Ϣ
#define NET_DVR_GET_HISTORY_VALUE          2060   // ��ȡ��ʷ����
#define NET_DVR_GET_ALARMHOST_ALARM_MODE  2061   // ��ȡ�����ϴ���ʽ
#define NET_DVR_SET_ALARMHOST_ALARM_MODE  2062   // ���������ϴ���ʽ
#define NET_DVR_GET_ALARMHOST_SENSOR_VALUE 2063   // ��ȡģ����ʵʱ����

#define NET_DVR_GET_ALARMHOST_REPORT_CENTER_V40    2064   // ��ȡ�����ϴ���ʽ
#define NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40    2065   // ���������ϴ���ʽ
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG        2068   // ��ȡʱ���������
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG     2069   // ����ʱ���������
#define NET_DVR_GET_CMS_CFG                     2070
#define    NET_DVR_SET_CMS_CFG                        2071

#define NET_DVR_GET_PASSTHROUGH_CAP  2073  //��ȡ�豸͸��������

#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V40    2072   // ��ȡ��Ҫ״̬V40
#define NET_DVR_GET_ALARMHOST_MAIN_STATUS_V51    2083   // ��ȡ��Ҫ״̬V51

/*************************************��Ƶ��������1.3 begin*************************************/
#define NET_DVR_GET_ALARM_CAPTRUE_CFG                 2074    //��ȡ����ץͼ��������
#define    NET_DVR_SET_ALARM_CAPTRUE_CFG                2075    //���ñ���ץͼ��������
#define NET_DVR_GET_ONE_OUTPUT_SCH_RULECFG_V40        2078   // ��ȡ����ʱ���������V40
#define NET_DVR_SET_ONE_OUTPUT_SCH_RULECFG_V40        2079   // ���õ���ʱ���������V40
#define NET_DVR_GET_OUTPUT_SCHEDULE_RULECFG_V40        2080   // ��ȡʱ���������V40
#define NET_DVR_SET_OUTPUT_SCHEDULE_RULECFG_V40     2081   // ����ʱ���������V40
#define  NET_DVR_ALARMHOST_CLOSE_SUBSYSTEM  2082  //����ϵͳ��������
/*************************************��Ƶ��������1.3 end**************************************/


#define NET_DVR_GET_WEEK_PLAN_CFG               2100    //��ȡ��״̬�ܼƻ�����
#define NET_DVR_SET_WEEK_PLAN_CFG               2101    //������״̬�ܼƻ�����
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN    2102    //��ȡ��״̬���ռƻ�����
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN    2103    //������״̬���ռƻ�����
#define NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP   2104    //��ȡ��״̬���������
#define NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP   2105    //������״̬���������
#define NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE   2106    //��ȡ��״̬�ƻ�ģ�����
#define NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE   2107    //������״̬�ƻ�ģ�����
#define NET_DVR_GET_DOOR_CFG                    2108    //��ȡ�Ų���
#define NET_DVR_SET_DOOR_CFG                    2109    //�����Ų���
#define NET_DVR_GET_DOOR_STATUS_PLAN            2110    //��ȡ��״̬�ƻ�����
#define NET_DVR_SET_DOOR_STATUS_PLAN            2111    //������״̬�ƻ�����
#define NET_DVR_GET_GROUP_CFG                   2112    //��ȡȺ�����
#define NET_DVR_SET_GROUP_CFG                   2113    //����Ⱥ�����
#define NET_DVR_GET_MULTI_CARD_CFG              2114    //��ȡ���ؿ�����
#define NET_DVR_SET_MULTI_CARD_CFG              2115    //���ö��ؿ�����
#define NET_DVR_GET_CARD_CFG                    2116    //��ȡ������
#define NET_DVR_SET_CARD_CFG                    2117    //���ÿ�����
#define NET_DVR_CLEAR_ACS_PARAM                    2118    //����Ž���������
#define NET_DVR_GET_SNEAK_CFG                    2119    //��ȡ��Ǳ�ز���
#define NET_DVR_SET_SNEAK_CFG                   2120    //���÷�Ǳ�ز���
#define NET_DVR_GET_MULTI_DOOR_INTERLOCK_CFG    2121    //��ȡ���Ż�������
#define NET_DVR_SET_MULTI_DOOR_INTERLOCK_CFG    2122    //���ö��Ż�������
#define NET_DVR_GET_ACS_WORK_STATUS                2123    //��ȡ�Ž���������״̬
#define NET_DVR_GET_VERIFY_WEEK_PLAN            2124    //��ȡ��������֤��ʽ�ܼƻ�����
#define NET_DVR_SET_VERIFY_WEEK_PLAN            2125    //���ö�������֤��ʽ�ܼƻ�����
#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN        2126    //��ȡ��Ȩ���ܼƻ�����
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN        2127    //���ÿ�Ȩ���ܼƻ�����
#define NET_DVR_GET_VERIFY_HOLIDAY_PLAN         2128    //��ȡ��������֤��ʽ���ռƻ�����
#define NET_DVR_SET_VERIFY_HOLIDAY_PLAN         2129    //���ö�������֤��ʽ���ռƻ�����
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN     2130    //��ȡ��Ȩ�޼��ռƻ�����
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN     2131    //���ÿ�Ȩ�޼��ռƻ�����
#define NET_DVR_GET_VERIFY_HOLIDAY_GROUP        2132    //��ȡ��������֤��ʽ���������
#define NET_DVR_SET_VERIFY_HOLIDAY_GROUP        2133    //���ö�������֤��ʽ���������
#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP    2134    //��ȡ��Ȩ�޼��������
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP    2135    //���ÿ�Ȩ�޼��������
#define NET_DVR_GET_VERIFY_PLAN_TEMPLATE        2136    //��ȡ��������֤��ʽ�ƻ�ģ�����
#define NET_DVR_SET_VERIFY_PLAN_TEMPLATE        2137    //���ö�������֤��ʽ�ƻ�ģ�����
#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE    2138    //��ȡ��Ȩ�޼ƻ�ģ�����
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE    2139    //���ÿ�Ȩ�޼ƻ�ģ�����
#define NET_DVR_GET_CARD_READER_CFG                2140    //��ȡ����������
#define NET_DVR_SET_CARD_READER_CFG             2141    //���ö���������
#define NET_DVR_GET_CARD_READER_PLAN            2142    //��ȡ��������֤�ƻ�����
#define NET_DVR_SET_CARD_READER_PLAN            2143    //���ö�������֤�ƻ�����
#define NET_DVR_GET_CASE_SENSOR_CFG                2144    //��ȡ�¼�����������
#define NET_DVR_SET_CASE_SENSOR_CFG             2145    //�����¼�����������
#define NET_DVR_GET_CARD_READER_ANTI_SNEAK_CFG  2146    //��ȡ��������Ǳ�ز���
#define NET_DVR_SET_CARD_READER_ANTI_SNEAK_CFG  2147    //���ö�������Ǳ�ز���
#define NET_DVR_GET_PHONE_DOOR_RIGHT_CFG        2148    //��ȡ�ֻ�������Ȩ�޲���
#define NET_DVR_SET_PHONE_DOOR_RIGHT_CFG        2149    //��ȡ�ֻ�������Ȩ�޲���
#define NET_DVR_GET_FINGERPRINT_CFG             2150    //��ȡָ�Ʋ���
#define NET_DVR_SET_FINGERPRINT_CFG             2151    //����ָ�Ʋ���
#define NET_DVR_DEL_FINGERPRINT_CFG             2152    //ɾ��ָ�Ʋ���
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG      2153    //��ȡ�¼������������ò���
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG      2154    //�����¼������������ò���
#define NET_DVR_GET_ANTI_SNEAK_HOST_CFG            2155    //��ȡ�����鷴Ǳ�ز���
#define NET_DVR_SET_ANTI_SNEAK_HOST_CFG         2156    //���������鷴Ǳ�ز���
#define NET_DVR_GET_READER_ANTI_SNEAK_HOST_CFG  2157    //��ȡ�������������Ǳ�ز���
#define NET_DVR_SET_READER_ANTI_SNEAK_HOST_CFG  2158    //�����������������Ǳ�ز���
#define NET_DVR_GET_ACS_CFG                     2159    //��ȡ�Ž���������
#define NET_DVR_SET_ACS_CFG                     2160    //�����Ž���������
#define NET_DVR_GET_CARD_PASSWD_CFG                2161    //��ȡ�����뿪��ʹ������
#define NET_DVR_SET_CARD_PASSWD_CFG             2162    //���ÿ����뿪��ʹ������
#define NET_DVR_GET_CARD_USERINFO_CFG           2163    //��ȡ���Ź����û���Ϣ����
#define NET_DVR_SET_CARD_USERINFO_CFG           2164    //���ÿ��Ź����û���Ϣ����

#define NET_DVR_GET_ACS_EXTERNAL_DEV_CFG        2165    //��ȡ�Ž����������������
#define NET_DVR_SET_ACS_EXTERNAL_DEV_CFG        2166    //�����Ž����������������
#define NET_DVR_GET_PERSONNEL_CHANNEL_CFG       2167    //��ȡ��Աͨ������
#define NET_DVR_SET_PERSONNEL_CHANNEL_CFG       2168    //������Աͨ������
#define NET_DVR_SET_PLATFORM_VERIFY_CFG         2169    //�·�ƽ̨��֤���
#define NET_DVR_GET_PERSON_STATISTICS_CFG        2170   //��ȡ����ͳ�Ʋ���
#define NET_DVR_SET_PERSON_STATISTICS_CFG        2171   //��������ͳ�Ʋ���
#define NET_DVR_GET_ACS_SCREEN_DISPLAY_CFG        2172   //��ȡ��Ļ�ַ�����ʾ����
#define NET_DVR_SET_ACS_SCREEN_DISPLAY_CFG        2173   //������Ļ�ַ�����ʾ����
#define NET_DVR_GET_GATE_TIME_CFG               2174  //��ȡ��Աͨ��բ��ʱ�����
#define NET_DVR_SET_GATE_TIME_CFG               2175  //������Աͨ��բ��ʱ�����
#define NET_DVR_GET_LOCAL_CONTROLLER_STATUS     2176    //��ȡ�͵ؿ�����״̬
#define NET_DVR_GET_ONLINE_LOCAL_CONTROLLER     2177    //�������߾͵ؿ�����
#define NET_DVR_GET_CARD_CFG_V50                2178    //��ȡ�¿�����(V50)
#define NET_DVR_SET_CARD_CFG_V50                2179    //�����¿�����(V50)
#define NET_DVR_GET_ACS_WORK_STATUS_V50         2180    //��ȡ�Ž���������״̬(V50)
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V50  2181    //��ȡ�¼������������ò���(V50)
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V50  2182    //�����¼������������ò���(V50)
#define NET_DVR_GET_FINGERPRINT_CFG_V50         2183    //��ȡָ�Ʋ���V50
#define NET_DVR_SET_FINGERPRINT_CFG_V50         2184    //����ָ�Ʋ���V50

#define NET_DVR_GET_SAFETYCABIN_STATE            2197    //��ȡ������״̬
#define NET_DVR_GET_RS485_CASCADE_CFG            2198   //��ȡRs485�����豸����
#define NET_DVR_SET_RS485_CASCADE_CFG            2199   //����Rs485�����豸����

/*************************************��Ƶ��������2.0 begin*************************************/
#define NET_DVR_GET_REMOTECONTROLLER_PERMISION_CFG        2200    //��ȡң����Ȩ�޲���
#define NET_DVR_SET_REMOTECONTROLLER_PERMISION_CFG        2201    //����ң����Ȩ�޲���
#define NET_DVR_GET_KEYBOARD_CFG                        2202    //��ȡ���̲�������
#define NET_DVR_SET_KEYBOARD_CFG                        2203    //���ü��̲�������
#define    NET_DVR_GET_ALARMHOST_WIRELESS_BUSINNESS_INFO    2204    //����ҵ���ѯ
#define    NET_DVR_GET_ALL_REMOTECONTROLLER_LIST            2205    //��ȡ����ң����
#define    NET_DVR_GET_PREVIEW_DELAY_CFG                    2206    //��ȡ�ӳ�Ԥ����������
#define    NET_DVR_SET_PREVIEW_DELAY_CFG                    2207    //�����ӳ�Ԥ����������
#define NET_DVR_GET_ZONE_CHANNEL_LINKAGE_CFG            2208    //��ȡ����������Ƶͨ������
#define NET_DVR_SET_ZONE_CHANNEL_LINKAGE_CFG            2209    //���÷���������Ƶͨ������
#define NET_DVR_GET_CENTER_SERVER_CFG                    2210    //��ȡ�������ķ�����
#define NET_DVR_SET_CENTER_SERVER_CFG                    2211    //���ñ������ķ�����
/*************************************��Ƶ��������2.0 end**************************************/

/********************************һ��ʽ����������ƷV1.0.0 begin********************************/
#define NET_DVR_GET_EMERGENCE_ALARM_PRODUCT_CAP            2212    //��ȡһ��ʽ����������Ʒ����
#define NET_DVR_GET_CALL_WAITTING_CFG_CAP                2213    //��ȡ���еȴ�������������
#define NET_DVR_GET_CALL_WAITTING_CFG                    2214    //��ȡ���еȴ���������
#define NET_DVR_SET_CALL_WAITTING_CFG                    2215    //���ú��еȴ���������
#define NET_DVR_GET_ALARM_LAMP_CFG_CAP                    2216    //��ȡ���Ʋ�����������
#define NET_DVR_GET_ALARM_LAMP_CFG                        2217    //��ȡ���Ʋ�������
#define NET_DVR_SET_ALARM_LAMP_CFG                        2218    //���þ��Ʋ�������
#define NET_DVR_GET_VOICE_PROMPTION_CFG_CAP                2219    //��ȡ������ʾ��������
#define NET_DVR_GET_VOICE_PROMPTION_CFG                    2220    //��ȡ������ʾ����
#define NET_DVR_SET_VOICE_PROMPTION_CFG                    2221    //����������ʾ����
#define NET_DVR_GET_EMERGENCE_ALARM_RESPONSE_CAP        2222    //��ȡ����������������
#define NET_DVR_EMERGENCE_ALARM_RESPONSE_CTRL            2223    //���������������
/********************************һ��ʽ����������ƷV1.0.0 end**********************************/

//���籨������ V2.2
#define NET_DVR_GET_ALARMHOST_NETCFG_V50                2224    //��ȡ�������������������V50
#define NET_DVR_SET_ALARMHOST_NETCFG_V50                2225    //���ñ������������������V50
#define    NET_DVR_REGISTER_ALARM_RS485                    2226    //RS485����ע��
/**********************************������������V3.0****************************************/

#define NET_DVR_GET_ALARMIN_PARAM_LIST                    2227    //��ȡ���������б�
//���߱�������1.0.0
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS_V50            2228    //��ȡ������������״̬v50
#define NET_DVR_GET_ALARMHOST_OTHER_STATUS_V51            2236    //��ȡ������������״̬V51
#define NET_DVR_GET_ALARMIN_ASSOCIATED_CHAN_LIST        2229    //��ȡ��������������Ƶͨ�������б�
#define NET_DVR_GET_ALARMIN_TRIGGER                     2230    //��ȡ��������������������
#define NET_DVR_SET_ALARMIN_TRIGGER                     2231    //���ñ�������������������
#define NET_DVR_GET_EMERGENCY_CALL_HELP_TRIGGER         2232    //��ȡ������������������������
#define NET_DVR_SET_EMERGENCY_CALL_HELP_TRIGGER         2233    //���ñ�����������������������
#define NET_DVR_GET_CONSULT_TRIGGER                     2234    //��ȡ��������ҵ����ѯ��������
#define NET_DVR_SET_CONSULT_TRIGGER                     2235    //���ñ�������ҵ����ѯ��������
#define NET_DVR_GET_ALARMIN_PARAM_LIST_V50              2237    //��ȡ���������б�V50

#define NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50    2304  //��ȡ��Ȩ���ܼƻ�����V50
#define NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50    2305  //���ÿ�Ȩ���ܼƻ�����V50

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50    2310  //��ȡ��Ȩ�޼��ռƻ�����V50
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50    2311  //���ÿ�Ȩ�޼��ռƻ�����V50

#define NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50      2316 //��Ȩ�޼��������V50
#define NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50      2317 //���ÿ�Ȩ�޼��������V50

#define NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50     2322 //��ȡ��Ȩ�޼ƻ�ģ�����V50
#define NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50     2323//���ÿ�Ȩ�޼ƻ�ģ�����V50

/**********************************������ָ���Ž���ƷV1.0 �豸����****************************************/
#define NET_DVR_GET_SCHEDULE_INFO                       2500    //��ȡ�Ű���Ϣ
#define NET_DVR_GET_ATTENDANCE_SUMMARY_INFO             2501    //��ȡ���ڻ�����Ϣ
#define NET_DVR_GET_ATTENDANCE_RECORD_INFO              2502    //��ȡ���ڼ�¼��Ϣ
#define NET_DVR_GET_ABNORMAL_INFO                       2503    //��ȡ�쳣ͳ����Ϣ
/**********************************������ָ���Ž���ƷV1.0****************************************/

/*************************************��Ƶ�Ž�һ���1.0 begin**************************************/
#define NET_DVR_CAPTURE_FINGERPRINT_INFO                2504    //�ɼ�ָ����Ϣ
/*************************************��Ƶ�Ž�һ���1.0 end**************************************/

/*************************************Ƕ��ʽ�����ն�1.0 begin**************************************/
#define NET_DVR_BULK_UPLOAD_BLACK_LIST_PICTURE          2520       //�����ϴ�������ͼƬ
#define NET_DVR_BULK_UPLOAD_ID_BLACK_LIST        2521        //�����ϴ����֤������
#define NET_DVR_GET_FAILED_FACE_INFO             2522        //��ȡ�豸������ģʧ�ܵ�������¼
#define NET_DVR_GET_FACE_AND_TEMPLATE            2523        //��ȡ������ģ������
#define NET_DVR_SET_FACE_AND_TEMPLATE            2524        //����������ģ������
/*************************************Ƕ��ʽ�����ն�1.0 end**************************************/

/*************************************����ʶ���Ž�һ���1.0 begin**************************************/
#define NET_DVR_GET_CARD_READER_CFG_V50                    2505    //��ȡ����������(V50)
#define NET_DVR_SET_CARD_READER_CFG_V50                 2506    //���ö���������(V50)
#define NET_DVR_GET_FACE_PARAM_CFG                      2507    //��ȡ��������
#define NET_DVR_SET_FACE_PARAM_CFG                      2508    //������������
#define NET_DVR_DEL_FACE_PARAM_CFG                      2509    //ɾ����������
#define    NET_DVR_CAPTURE_FACE_INFO                        2510    //�ɼ�������Ϣ
/*************************************����ʶ���Ž�һ���1.0 end**************************************/
#define NET_DVR_GET_REGISTER_INFO                       2511    //�Ǽ���Ϣ��ȡ

#define NET_DVR_GET_SMSRELATIVEPARA_V50                    2512    //��ȡ������ز���
#define NET_DVR_SET_SMSRELATIVEPARA_V50                    2513    //���ö�����ز���
#define NET_DVR_GET_ACS_EVENT                           2514    //�豸�¼���ȡ
#define NET_DVR_GET_MULTI_CARD_CFG_V50                  2515    //��ȡ���ؿ�����V50
#define NET_DVR_SET_MULTI_CARD_CFG_V50                  2516    //���ö��ؿ�����V50
#define NET_DVR_DEL_FINGERPRINT_CFG_V50                 2517    //ɾ��ָ�Ʋ���V50
#define NET_DVR_GET_EVENT_CARD_LINKAGE_CFG_V51          2518    //��ȡ�¼������������ò���(V51)
#define NET_DVR_SET_EVENT_CARD_LINKAGE_CFG_V51          2519    //�����¼������������ò���(V51)

#define NET_DVR_SET_EXAM_INFO                           2530    //������Ϣ�·�
#define NET_DVR_SET_EXAMINEE_INFO                       2531    //������Ϣ�·�
#define NET_DVR_SEARCH_EXAM_COMPARE_RESULT              2532    //���ԱȶԽ����ѯ
#define NET_DVR_BULK_CHECK_FACE_PICTURE                 2533    //����У������ͼƬ
#define NET_DVR_JSON_CONFIG                         2550    //JSON͸������
#define NET_DVR_FACE_DATA_RECORD                        2551    //����������ݵ�������
#define NET_DVR_FACE_DATA_SEARCH                        2552    //��ѯ�������е���������
#define NET_DVR_FACE_DATA_MODIFY                        2553    //�޸��������е���������
#define NET_DVR_CAPTURE_DATA_SEARCH                 2554    //��ѯ���߲ɼ����ݼ�������

#define NET_DVR_GET_CARD                 2560
#define NET_DVR_SET_CARD                 2561
#define NET_DVR_DEL_CARD                 2562
#define NET_DVR_GET_FINGERPRINT          2563
#define NET_DVR_SET_FINGERPRINT          2564
#define NET_DVR_DEL_FINGERPRINT          2565
#define NET_DVR_GET_FACE                 2566
#define NET_DVR_SET_FACE                 2567

#define NET_DVR_GET_ALL_ALARM_RS485CFG            2705    // ��ȡ485����
#define NET_DVR_GET_ALL_ALARMHOST_RS485_SLOT_CFG        2706        // ��ȡ���б�������485��λ����
#define NET_DVR_GET_DEVICE_SELF_CHECK_STATE        2707    //��ȡ�豸�Լ칦��
#define NET_DVR_GET_ALL_ALARM_POINT_CFG            2708    // ��ȡ���е�Ų���
#define NET_DVR_GET_ALL_ALARM_SENSOR_CFG        2709    // ��ȡ����ģ��������
#define NET_DVR_GET_ALL_ALARM_SENSOR_JOINT        2710    //��ȡ����ģ������������
#define NET_DVR_GET_AIR_CONDITION_PARAM            2711    //��ȡ�յ�����
#define NET_DVR_GET_OUT_SCALE_CFG                2712        //��ȡ�������������
#define NET_DVR_SET_OUT_SCALE_CFG                2713        //�����������������
#define NET_DVR_GET_ALARM_CHAN_ABLITITY            2714        //��ȡ�������ͨ����
/**********************************������������V3.0****************************************/

//������������D2000 V1.0
#define NET_DVR_GET_ALARMCENTER_NETCFG            2715        //��ȡ�������������������
#define NET_DVR_SET_ALARMCENTER_NETCFG            2716        //��ȡ�������������������


#define NET_ITC_GET_TRIGGERCFG                  3003  //��ȡ��������
#define NET_ITC_SET_TRIGGERCFG                  3004  //���ô�������
#define NET_ITC_GET_IOOUT_PARAM_CFG                3005  //��ȡIO���������3.1��֮��汾��
#define NET_ITC_SET_IOOUT_PARAM_CFG                3006  //����IO���������3.1��֮��汾��

#define NET_DVR_GET_CAMERA_SETUPCFG                3007  //��ȡ����������
#define NET_DVR_SET_CAMERA_SETUPCFG                3008  //��������������

#define NET_ITC_GET_TRIGGER_DEFAULTCFG          3013  //��ȡ����ģʽ�Ƽ�����
#define NET_DVR_GET_STATUS_DETECTCFG            3015  //��ȡ״̬���ʹ�ܲ���
#define NET_DVR_SET_STATUS_DETECTCFG            3016  //����״̬���ʹ�ܲ���
#define NET_ITC_GET_VIDEO_TRIGGERCFG            3017  //��ȡ��Ƶ�羯��������
#define NET_ITC_SET_VIDEO_TRIGGERCFG            3018  //������Ƶ�羯��������
#define NET_DVR_GET_TPS_ALARMCFG                3019  //��ȡ��ͨͳ�Ʊ�������
#define NET_DVR_SET_TPS_ALARMCFG                3020  //���ý�ͨͳ�Ʊ�������


#define NET_DVR_GET_REDAREACFG                  3100   //��ȡ���̵��������
#define NET_DVR_SET_REDAREACFG                  3101   //���ú��̵��������
#define    NET_DVR_GET_TEST_SPOT                    3102   //��ȡSPOT�ڲ����ܲ����͵�ǰ�ڼ���
#define    NET_DVR_SET_TEST_SPOT                    3103   //����SPOT�ڲ����ܲ����͵�ǰ�ڼ���
#define NET_DVR_GET_CABINETCFG                    3104   //����������û�ȡ
#define NET_DVR_SET_CABINETCFG                    3105   //���������������
#define NET_DVR_VEHICLE_CHECK_START                3106   //�������������ݻش�
#define NET_DVR_SET_CAPTUREPIC_CFG                3107   //����ץͼ������������
#define NET_DVR_GET_CAPTUREPIC_CFG                3108   //����ץͼ���û�ȡ����
#define NET_DVR_SET_MOBILEPLATE_RECOG_CFG        3109   //���س���ʶ��������������
#define NET_DVR_GET_MOBILEPLATE_RECOG_CFG        3110   //���س���ʶ�����û�ȡ����
#define NET_DVR_SET_MOBILE_RADAR_CFG            3111   //�����״�������������
#define NET_DVR_GET_MOBILE_RADAR_CFG            3112   //�����״����û�ȡ����
#define NET_DVR_SET_MOBILE_LOCALPLATECHK_CFG    3113   //���غ��������ضԱ�������������
#define NET_DVR_GET_MOBILE_LOCALPLATECHK_CFG    3114   //���غ��������ضԱ����û�ȡ����

#define  NET_ITC_GET_ICRCFG                        3115   //��ȡICR�����л�
#define  NET_ITC_SET_ICRCFG                        3116   //����ICR�����л�
#define  NET_ITC_GET_RS485_ACCESSINFO            3117   //��ȡRs485���������豸����Ϣ 
#define  NET_ITC_SET_RS485_ACCESSINFO            3118   //����Rs485���������豸����Ϣ
#define  NET_ITC_GET_EXCEPTIONCFG                 3119   //��ȡ�쳣����
#define  NET_ITC_SET_EXCEPTIONCFG                3120   //�����쳣����
#define  NET_ITC_GET_FTPCFG                        3121   //��ȡITC  FTP���ò���
#define  NET_ITC_SET_FTPCFG                        3122   //����ITC FTP���ò���

#define  NET_DVR_VEHICLE_CONTROL_LIST_START     3123   //���ó����ڰ�������Ϣ
#define  NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST   3124   //��ȡ���г����ڰ�������Ϣ
#define  NET_DVR_VEHICLE_DELINFO_CTRL           3125   //ɾ���豸�ں��������ݿ���Ϣ
#define  NET_DVR_GET_ENTRANCE_PARAMCFG            3126   //��ȡ����ڿ��Ʋ���
#define  NET_DVR_SET_ENTRANCE_PARAMCFG            3127   //���ó���ڿ��Ʋ���
#define  NET_DVR_BARRIERGATE_CTRL               3128   //Զ�̿��Ƶ�բ
#define  NET_DVR_GATELAMP_CTRL                  3129   //�����ƹ���
#define  NET_DVR_GET_CURTRIGGERMODE             3130   //��ȡ�豸��ǰ����ģʽ
#define  NET_DVR_GET_GPSDATACFG                    3131   //��ȡGPS����
#define  NET_DVR_SET_GPSDATACFG                    3132   //����GPS����
#define  NET_DVR_VEHICLELIST_CTRL_START            3133   //���ó����ڰ�������Ϣ

#define  NET_DVR_GET_GUARDCFG                   3134   //��ȡ����ʶ����ƻ� 
#define  NET_DVR_SET_GUARDCFG                   3135   //���ó���ʶ����ƻ�
#define  NET_DVR_GET_SNAPINFO_CFG               3136   //��ȡץ��ͼƬ���� 
#define  NET_DVR_SET_SNAPINFO_CFG               3137   //����ץ��ͼƬ����
#define  NET_DVR_GET_SNAPINFO_CFG_V40           3138   //��ȡץ��ͼƬ������չ 
#define  NET_DVR_SET_SNAPINFO_CFG_V40           3139   //����ץ��ͼƬ������չ
#define  NET_DVR_SET_CURTRIGGERMODE                3140   //�����豸��ǰ����ģʽ(��IPC/D֧��)
#define     NET_DVR_GET_TRAFFIC_DATA                3141   //�����ӻ�ȡ��ͨ����
#define     NET_DVR_GET_TRAFFIC_FLOW                3142   //�����ӻ�ȡ��ͨ����
#define  NET_DVR_PARKING_VEHICLE_SEND           3143   //ͣ��������Ϣ�·�
#define  NET_DVR_PARKING_CARD_SEND              3144   //ͣ�����·�
#define     NET_DVR_PARKING_CARD_CTRL                3145   //ͣ����ͣ�������ƽӿ�

#define    NET_DVR_GET_ALARMCTRL_CAPABILITIES        3146   //��ȡ������������
#define    NET_DVR_SET_ALARMCTRL_CFG                3147   //���ñ�������
#define    NET_DVR_GET_ALARMCTRL_CFG                3148   //��ȡ��������

#define NET_DVR_GET_AUDIO_INPUT                 3201   //��ȡ��Ƶ�������
#define NET_DVR_SET_AUDIO_INPUT                 3202  //������Ƶ�������
#define NET_DVR_GET_CAMERA_DEHAZE_CFG           3203   //��ȡ͸���������
#define NET_DVR_SET_CAMERA_DEHAZE_CFG           3204  //����͸���������
#define NET_DVR_REMOTECONTROL_ALARM             3205  //Զ�̿���ң��������
#define NET_DVR_REMOTECONTROL_DISALARM          3206  //Զ�̿���ң��������
#define NET_DVR_REMOTECONTROL_STUDY             3207  //Զ�̿���ң����ѧϰ
#define NET_DVR_WIRELESS_ALARM_STUDY            3208  //Զ�̿������߱���ѧϰ
#define NET_IPC_GET_AUX_ALARMCFG                3209   //��ȡ����������������
#define NET_IPC_SET_AUX_ALARMCFG                3210  //���ø���������������
#define NET_DVR_GET_PREVIEW_DISPLAYCFG            3211  //��ȡԤ����ʾ����
#define NET_DVR_SET_PREVIEW_DISPLAYCFG             3212  //����Ԥ����ʾ����
#define NET_DVR_REMOTECONTROL_PTZ                3213  //Զ�̿���PTZ
#define NET_DVR_REMOTECONTROL_PRESETPOINT       3214   //Զ�̿���Ԥ�õ�
#define NET_DVR_REMOTECONTROL_CRUISE             3215   //Զ�̿���Ѳ��

#define NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG  3216 //Զ�̻�ȡ������ѹ������
#define NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG  3217 //Զ�����ö�����ѹ������ 

#define NET_DVR_GET_WPSCFG                        3218  //��ȡWPS����
#define NET_DVR_SET_WPSCFG                        3219  //����WPS����
#define NET_DVR_WPS_CONNECT                     3220  //Զ������WPS����
#define NET_DVR_GET_DEVICE_PIN                  3221  //��ȡ�豸PIN��
#define NET_DVR_UPDATE_PIN                      3223  //�����豸PIN��
#define NET_DVR_GET_PRESETCFG                   3224  //��ȡԤ�õ����
#define NET_DVR_GET_PTZCRUISECFG                3225  //��ȡѲ��·������
#define NET_DVR_GET_PRESET_NUM                    3226  //��ȡԤ�õ����
#define NET_DVR_GET_PTZCRUISE_NUM                3227  //��ȡѲ��·������

#define NET_DVR_GET_MOTION_TRACK_CFG            3228  //��ȡ���ٲ���
#define NET_DVR_SET_MOTION_TRACK_CFG            3229  //���ø��ٲ���
#define NET_DVR_CLEAR_IPC_PARAM                    3230  //���ǰ�˲���
#define NET_DVR_GET_IPADDR_FILTERCFG            3232  //��ȡIP��ַ���˲���
#define NET_DVR_SET_IPADDR_FILTERCFG            3233  //����IP��ַ���˲���

#define NET_DVR_GET_LOGO_OVERLAYCFG                3234  //��ȡLOGOͼƬ���Ӳ��� 
#define NET_DVR_SET_LOGO_OVERLAYCFG                3235  //����LOGOͼƬ���Ӳ���

#define NET_DVR_GET_IPV6_LIST                   3236  //��ȡ������ȫ��IPV6��ַ��Ϣ
#define NET_DVR_GET_AUDIOOUT_VOLUME             3237  //��ȡ�����Ƶ��С
#define NET_DVR_SET_AUDIOOUT_VOLUME             3238  //���������Ƶ��С
#define NET_DVR_GET_FUZZY_UPGRADE               3239  //��ȡģ������ƥ����Ϣ

#define NET_DVR_GET_BV_CORRECT_PARAM            3240  //��ȡ���У������
#define NET_DVR_SET_BV_CORRECT_PARAM            3241  //�������У������
#define NET_DVR_GET_OUTPUT_VIDEO_TYPE           3242  //��ȡ�����Ƶ����
#define NET_DVR_SET_OUTPUT_VIDEO_TYPE           3243  //���������Ƶ����

#define NET_DVR_FISHEYE_CFG                     3244  //���۳���������
#define NET_DVR_GET_PTZ_POINT                   3245  //��ȡPTZ������
#define NET_DVR_SET_PTZ_POINT                   3246  //����PTZ������
#define NET_DVR_REMOTECONTROL_DEV_PARAM         3247  //�����豸��¼�ͻ��˲���
#define NET_DVR_GET_FISHEYE_STREAM_STATUS       3248  //��ȡ��������״̬

#define NET_DVR_GET_GBT28181_ACCESS_CFG            3249  //��ȡGBT28181Э���������        
#define NET_DVR_SET_GBT28181_ACCESS_CFG            3250  //����GBT28181Э���������
#define NET_DVR_GET_GBT28181_CHANINFO_CFG        3251  //��ȡGBT28181Э������豸��ͨ����Ϣ
#define NET_DVR_SET_GBT28181_CHANINFO_CFG        3252  //����GBT28181Э������豸��ͨ����Ϣ
#define NET_DVR_GET_GBT28181_ALARMINCFG            3253  //��ȡGBT28181Э������豸�ı�����Ϣ
#define NET_DVR_SET_GBT28181_ALARMINCFG            3254  //����GBT28181Э������豸�ı�����Ϣ
#define NET_DVR_GET_ISP_CAMERAPARAMCFG            3255  //��ȡISPǰ�˲�������
#define NET_DVR_SET_ISP_CAMERAPARAMCFG            3256  //����ISPǰ�˲�������
#define NET_DVR_GET_DEVSERVER_CFG                3257  //��ȡģ���������
#define NET_DVR_SET_DEVSERVER_CFG                3258  //����ģ���������

//2013-11-25
#define    NET_DVR_GET_WIPERINFO_CFG                3259     //��ˢ���û�ȡ
#define    NET_DVR_SET_WIPERINFO_CFG                3260     //��ˢ��������
#define NET_DVR_GET_TRACK_DEV_PARAM             3261   //��ȡ�����豸����
#define NET_DVR_SET_TRACK_DEV_PARAM             3262   //���ø����豸����
#define NET_DVR_GET_PTZ_TRACK_PARAM             3263   //��ȡPTZ���ٲ���
#define NET_DVR_SET_PTZ_TRACK_PARAM             3264   //����PTZ���ٲ���
#define NET_DVR_GET_CENTER_POINT_CFG            3265   //��ȡ���ĵ����
#define NET_DVR_SET_CENTER_POINT_CFG            3266   //�������ĵ����
#define NET_DVR_GET_CENTER_POINT_CFG_CAPABILITIES        3267    //��ȡ���ĵ��������
#define NET_DVR_GET_FISHEYE_CAPABILITIES        3268        //��ȡ��������

#define NET_DVR_GET_BASICPARAMCFG                3270 //��ȡPTZ���û���������Ϣ        
#define NET_DVR_SET_BASICPARAMCFG                3271 //����PTZ���û���������Ϣ
#define NET_DVR_GET_PTZOSDCFG                    3272 //��ȡPTZ OSD���ò�����Ϣ        
#define NET_DVR_SET_PTZOSDCFG                    3273 //����PTZ OSD���ò�����Ϣ
#define NET_DVR_GET_POWEROFFMEMCFG                3274 //��ȡ�������ģʽ������Ϣ    
#define NET_DVR_SET_POWEROFFMEMCFG                3275 //���õ������ģʽ������Ϣ
#define NET_DVR_GET_LIMITCFG                    3276 //��ȡ��λ����������Ϣ    
#define NET_DVR_SET_LIMITCFG                    3277 //������λ����������Ϣ
#define NET_DVR_PTZLIMIT_CTRL                    3278 //�����λ��������    

#define NET_DVR_PTZ_CLEARCTRL                    3279 //���������Ϣ���ƽӿ�    
#define NET_DVR_GET_PRIORITIZECFG                3281 //��ȡ��̨����������Ϣ    
#define NET_DVR_SET_PRIORITIZECFG                3282 //������̨����������Ϣ
#define NET_DVR_PTZ_INITIALPOSITIONCTRL            3283 //�㷽λ�ǿ���    
#define NET_DVR_GET_PRIVACY_MASKSCFG            3285 //��ȡ��˽�ڱβ���
#define NET_DVR_SET_PRIVACY_MASKSCFG            3286 //������˽�ڱβ���
#define NET_DVR_GET_PTZLOCKCFG                    3287 //��ȡ��̨������Ϣ    
#define NET_DVR_SET_PTZLOCKCFG                    3288 //������̨������Ϣ
#define NET_DVR_PTZ_ZOOMRATIOCTRL                3289 //���ø��ٱ���    
#define NET_DVR_GET_PTZLOCKINFO                    3290 //��ȡ��̨����ʣ������
#define NET_DVR_GET_PRIVACY_MASKS_ENABLECFG        3291 //��ȡȫ��ʹ��    
#define NET_DVR_SET_PRIVACY_MASKS_ENABLECFG        3292 //����ȫ��ʹ��
#define NET_DVR_GET_SMARTTRACKCFG                3293 //��ȡ�����˶�����������Ϣ    
#define NET_DVR_SET_SMARTTRACKCFG                3294 //���������˶�����������Ϣ
#define NET_DVR_GET_EPTZ_CFG                    3295 //��ȡEPTZ����
#define NET_DVR_SET_EPTZ_CFG                    3296 //����EPTZ����
#define NET_DVR_GET_EPTZ_CFG_CAPABILITIES        3297 //��ȡEPTZ��������

#define NET_DVR_GET_LOW_LIGHTCFG                3303//��ȡ������ն�������Ϣ
#define NET_DVR_SET_LOW_LIGHTCFG                3304//���ÿ�����ն�������Ϣ
#define NET_DVR_GET_FOCUSMODECFG                3305//��ȡ����۽�ģʽ��Ϣ
#define NET_DVR_SET_FOCUSMODECFG                3306//���ÿ���۽�ģʽ��Ϣ
#define NET_DVR_GET_INFRARECFG                  3307//��ȡ�������������Ϣ
#define NET_DVR_SET_INFRARECFG                  3308//���ÿ������������Ϣ
#define NET_DVR_GET_AEMODECFG                   3309//��ȡ��������������Ϣ
#define NET_DVR_SET_AEMODECFG                   3310//���ÿ�������������Ϣ
#define NET_DVR_CONTROL_RESTORE_SUPPORT         3311 //�ָ�ǰ��Ĭ�ϲ���(�����������е�ǰ�˲���������صĶ��ָ�)
#define NET_DVR_CONTROL_RESTART_SUPPORT         3312 //�����о����
#define NET_DVR_CONTROL_PTZ_PATTERN             3313//��̨����ɨ��
#define NET_DVR_GET_PTZ_PARKACTION_CFG          3314//��ȡ��̨��������
#define NET_DVR_SET_PTZ_PARKACTION_CFG          3315//������̨��������
#define NET_DVR_CONTROL_PTZ_MANUALTRACE         3316//�ֶ����ٶ�λ
#define NET_DVR_GET_ROI_DETECT_NUM                3349 //��ȡROI�����������Ŀ
#define NET_DVR_GET_ROI_DETECT                    3350 //��ȡROI�����������
#define NET_DVR_SET_ROI_DETECT                    3351 //����ROI�����������
#define NET_DVR_GET_FACE_DETECT                    3352 //��ȡ�����������
#define NET_DVR_SET_FACE_DETECT                    3353 //���������������
#define NET_DVR_GET_CORRIDOR_MODE                3354 //��ȡ����ģʽ��������
#define NET_DVR_SET_CORRIDOR_MODE                3355 //��������ģʽ��������
#define NET_DVR_GET_SCENECHANGE_DETECTIONCFG    3356 //��ȡ���������������
#define NET_DVR_SET_SCENECHANGE_DETECTIONCFG    3357 //���ó��������������
#define NET_DVR_GET_TRAVERSE_PLANE_DETECTION    3360 
#define NET_DVR_SET_TRAVERSE_PLANE_DETECTION    3361 
#define NET_DVR_GET_FIELD_DETECTION                3362 //��ȡ�����������
#define NET_DVR_SET_FIELD_DETECTION                3363 //���������������
#define NET_DVR_GET_DEFOCUSPARAM                3364 //��ȡ�齹����������
#define NET_DVR_SET_DEFOCUSPARAM                3365 //�����齹����������
#define NET_DVR_GET_AUDIOEXCEPTIONPARAM            3366 //��ȡ��Ƶ�쳣����
#define NET_DVR_SET_AUDIOEXCEPTIONPARAM            3367 //������Ƶ�쳣����
#define NET_DVR_GET_CCDPARAMCFG_EX              3368 //��ȡCCD��������
#define NET_DVR_SET_CCDPARAMCFG_EX              3369 //����CCD��������
#define NET_DVR_START_GET_INPUTVOLUME            3370//��ʼ��ȡ����
#define NET_DVR_SET_SCH_TASK                    3380 //���������ʱ����
#define NET_DVR_GET_SCH_TASK                    3381  //��ȡ�����ʱ����
#define NET_DVR_SET_PRESET_NAME                    3382 //����Ԥ�õ�����
#define NET_DVR_GET_PRESET_NAME                    3383 //��ȡԤ�õ�����
#define NET_DVR_SET_AUDIO_NAME                    3384 //������������
#define NET_DVR_GET_AUDIO_NAME                    3385  //��ȡ��������
#define NET_DVR_RESUME_INITRACKPOS              3386  //�ָ����ٳ�ʼλ
#define NET_DVR_NTP_SERVER_TEST                    3387    //NTP����������
#define    NET_DVR_NAS_SERVER_TEST                    3388    //NAS����������
#define    NET_DVR_EMAIL_SERVER_TEST                3389    //Email����������
#define    NET_DVR_FTP_SERVER_TEST                    3390    //FTP����������
#define    NET_DVR_IP_TEST                            3391    //IP����
#define NET_DVR_GET_NET_DISKCFG_V40             3392 //����Ӳ�̽����ȡv40
#define NET_DVR_SET_NET_DISKCFG_V40                3393 //����Ӳ�̽�������v40
#define    NET_DVR_GET_IOOUT_CFG                    3394//��ȡ����Ʋ���
#define    NET_DVR_SET_IOOUT_CFG                    3395//���ò���Ʋ���
#define    NET_DVR_GET_SIGNAL_SYNC                    3396//��ȡ�źŵ�ͬ�����ò���
#define    NET_DVR_SET_SIGNAL_SYNC                    3397//�����źŵ�ͬ�����ò���    

#define    NET_DVR_GET_EZVIZ_ACCESS_CFG            3398//��ȡEZVIZ�������
#define    NET_DVR_SET_EZVIZ_ACCESS_CFG            3399//����EZVIZ�������
#define    NET_DVR_GET_SCHEDULE_AUTO_TRACK_CFG        3400//��ȡ��ʱ���ܸ��ٲ���
#define    NET_DVR_SET_SCHEDULE_AUTO_TRACK_CFG        3401//���ö�ʱ���ܸ��ٲ���
#define    NET_DVR_MAKE_I_FRAME                    3402//ǿ��I֡
#define NET_DVR_GET_ALARM_RELATE                3403//��ȡ��������ͨ�����ܲ���
#define NET_DVR_SET_ALARM_RELATE                3404//���ñ�������ͨ�����ܲ���
#define NET_DVR_GET_PDC_RULECFG_V42             3405  //����������ͳ�ƹ���(��չ)
#define NET_DVR_SET_PDC_RULECFG_V42             3406  //��ȡ������ͳ�ƹ���(��չ)
#define NET_DVR_GET_HEATMAP_CFG                 3407  //�����ȶ�ͼ��������
#define NET_DVR_SET_HEATMAP_CFG                 3408  //��ȡ�ȶ�ͼ��������
#define NET_DVR_REMOTECONTROL_LINEARSCAN        3409   //�������ұ߽���� 2014-03-15
#define NET_DVR_DPC_CTRL                        3410//����У������
#define NET_DVR_FFC_MANUAL_CTRL                 3411//�Ǿ�����У��(FFC)�ֶ�ģʽ
#define NET_DVR_FFC_BACKCOMP_CTRL               3412//�Ǿ�����У��(FFC)��������
#define NET_DVR_GET_FOCUSING_POSITION_STATE     3413//��ȡ�۽���λ״̬����
#define NET_DVR_GET_PRIVATE_PROTOCOL_CFG        3414   //��ȡ ˽�йؼ���Ϣ�ϴ����ýӿ�����
#define NET_DVR_SET_PRIVATE_PROTOCOL_CFG        3415   //���� ˽�йؼ���Ϣ�ϴ����ýӿ�����
#define NET_DVR_COMPLETE_RESTORE_CTRL           3420    //������ȫ�ָ�����ֵ

#define NET_DVR_CLOUDSTORAGE_SERVER_TEST        3421  //�ƴ洢����������
#define NET_DVR_PHONE_NUM_TEST                  3422  //�绰�������
#define NET_DVR_GET_REMOTECONTROL_STATUS        3423  //��ȡ���߲���״̬
#define NET_DVR_GET_MONITOR_LOCATION_INFO        3424  //��ȡ������Ϣ
#define NET_DVR_SET_MONITOR_LOCATION_INFO        3425  //���ü�����Ϣ


#define    NET_DVR_GET_SMART_CAPABILITIES                3500    //��ȡSmart����
#define    NET_DVR_GET_EVENT_TRIGGERS_CAPABILITIES        3501    //��ȡ�¼���������
#define    NET_DVR_GET_REGION_ENTRANCE_CAPABILITIES    3502    //��ȡ���������������
#define    NET_DVR_GET_REGION_ENTR_DETECTION            3503    //��ȡ������������
#define    NET_DVR_SET_REGION_ENTR_DETECTION            3504    //���ý�����������
#define    NET_DVR_GET_REGION_ENTR_REGION                3505    //��ȡ��������ĵ�����������
#define    NET_DVR_SET_REGION_ENTR_REGION                3506    //���ý�������ĵ�����������
#define    NET_DVR_GET_REGION_ENTR_TRIGGER                3507    //��ȡ����������������
#define    NET_DVR_SET_REGION_ENTR_TRIGGER                3508    //���ý���������������
#define    NET_DVR_GET_REGION_ENTR_SCHEDULE            3509    //��ȡ�������򲼷�ʱ������
#define    NET_DVR_SET_REGION_ENTR_SCHEDULE            3510    //���ý������򲼷�ʱ������
#define    NET_DVR_GET_REGION_EXITINT_CAPABILITIES        3511    //��ȡ�뿪�����������
#define    NET_DVR_GET_REGION_EXITING_DETECTION        3512    //��ȡ�뿪��������
#define    NET_DVR_SET_REGION_EXITING_DETECTION        3513    //�����뿪��������
#define    NET_DVR_GET_REGION_EXITING_REGION            3514    //��ȡ�뿪����ĵ�����������
#define    NET_DVR_SET_REGION_EXITING_REGION            3515    //�����뿪����ĵ�����������
#define    NET_DVR_GET_REGION_EXIT_TRIGGER                3516    //��ȡ�뿪������������
#define    NET_DVR_SET_REGION_EXIT_TRIGGER                3517    //�����뿪������������
#define    NET_DVR_GET_REGION_EXIT_SCHEDULE            3518    //��ȡ�뿪���򲼷�ʱ������
#define    NET_DVR_SET_REGION_EXIT_SCHEDULE            3519    //�����뿪���򲼷�ʱ������
#define    NET_DVR_GET_LOITERING_CAPABILITIES            3520    //��ȡ�ǻ��������
#define    NET_DVR_GET_LOITERING_DETECTION                3521    //��ȡ�ǻ��������
#define    NET_DVR_SET_LOITERING_DETECTION                3522    //�����ǻ��������
#define    NET_DVR_GET_LOITERING_REGION                3523    //��ȡ�ǻ��ĵ�����������
#define    NET_DVR_SET_LOITERING_REGION                3524    //�����ǻ��ĵ�����������
#define    NET_DVR_GET_LOITERING_TRIGGER                3525    //��ȡ�ǻ���������
#define    NET_DVR_SET_LOITERING_TRIGGER                3526    //�����ǻ���������
#define    NET_DVR_GET_LOITERING_SCHEDULE                3527    //��ȡ�ǻ�����ʱ������
#define    NET_DVR_SET_LOITERING_SCHEDULE                3528    //�����ǻ�����ʱ������
#define    NET_DVR_GET_GROUPDETECTION_CAPABILITIES        3529    //��ȡ��Ա�ۼ��������
#define    NET_DVR_GET_GROUP_DETECTION                    3530    //��ȡ��Ա�ۼ��������
#define    NET_DVR_SET_GROUP_DETECTION                    3531    //������Ա�ۼ��������
#define    NET_DVR_GET_GROUPDETECTION_REGION            3532    //��ȡ��Ա�ۼ��ĵ�����������
#define    NET_DVR_SET_GROUPDETECTION_REGION            3533    //������Ա�ۼ��ĵ�����������
#define    NET_DVR_GET_GROUPDETECTION_TRIGGER            3534    //��ȡ��Ա�ۼ���������
#define    NET_DVR_SET_GROUPDETECTION_TRIGGER            3535    //������Ա�ۼ���������
#define    NET_DVR_GET_GROUPDETECTION_SCHEDULE            3536    //��ȡ��Ա�ۼ�����ʱ������
#define    NET_DVR_SET_GROUPDETECTION_SCHEDULE            3537    //������Ա�ۼ�����ʱ������
#define    NET_DVR_GET_RAPIDMOVE_CAPABILITIES            3538    //��ȡ�����˶��������
#define    NET_DVR_GET_RAPIDMOVE_DETECTION                3539    //��ȡ�����˶��������
#define    NET_DVR_SET_RAPIDMOVE_DETECTION                3540    //���ÿ����˶��������
#define    NET_DVR_GET_RAPIDMOVE_REGION                3541    //��ȡ�����˶��ĵ�����������
#define    NET_DVR_SET_RAPIDMOVE_REGION                3542    //���ÿ����˶��ĵ�����������
#define    NET_DVR_GET_RAPIDMOVE_TRIGGER                3543    //��ȡ�����˶���������
#define    NET_DVR_SET_RAPIDMOVE_TRIGGER                3544    //���ÿ����˶���������
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE                3545    //��ȡ�����˶��Ĳ���ʱ������
#define    NET_DVR_SET_RAPIDMOVE_SCHEDULE                3546    //���ÿ����˶��Ĳ���ʱ������
#define    NET_DVR_GET_PATKING_CAPABILITIES            3547    //��ȡͣ���������
#define    NET_DVR_GET_PARKING_DETECTION               3548    //��ȡͣ���������
#define    NET_DVR_SET_PARKING_DETECTION                3549    //����ͣ���������
#define    NET_DVR_GET_PARKING_REGION                    3550    //��ȡͣ�����ĵ�����������
#define    NET_DVR_SET_PARKING_REGION                    3551    //����ͣ�����ĵ�����������
#define    NET_DVR_GET_PARKING_TRIGGER                    3552    //��ȡͣ�������������
#define    NET_DVR_SET_PARKING_TRIGGER                    3553    //����ͣ�������������
#define    NET_DVR_GET_PARKING_SCHEDULE                3554    //��ȡͣ�����Ĳ���ʱ������
#define    NET_DVR_SET_PARKING_SCHEDULE                3555    //����ͣ�����Ĳ���ʱ������
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_CAPABILITIES    3556    //��ȡ��Ʒ�����������
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_DETECTION    3557    //��ȡ��Ʒ�����������
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_DETECTION    3558    //������Ʒ�����������
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_REGION        3559    //��ȡ��Ʒ�������ĵ�����������
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_REGION        3560    //������Ʒ�������ĵ�����������
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_TRIGGER        3561    //��ȡ��Ʒ���������������
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_TRIGGER        3562    //������Ʒ���������������
#define    NET_DVR_GET_UNATTENDED_BAGGAGE_SCHEDULE        3563    //��ȡ��Ʒ�������Ĳ���ʱ������
#define    NET_DVR_SET_UNATTENDED_BAGGAGE_SCHEDULE        3564    //������Ʒ�������Ĳ���ʱ������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_CAPABILITIES    3565    //��ȡ��Ʒ��ȡ�������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_DETECTION        3566    //��ȡ��Ʒ��ȡ�������
#define    NET_DVR_SET_ATTENDEDBAGGAGE_DETECTION        3567    //������Ʒ��ȡ�������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_REGION            3568    //��ȡ��Ʒ��ȡ���ĵ�����������
#define    NET_DVR_SET_ATTENDEDBAGGAGE_REGION            3569    //������Ʒ��ȡ���ĵ�����������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_TRIGGER            3570    //��ȡ��Ʒ��ȡ�����������
#define    NET_DVR_SET_ATTENDEDBAGGAGE_TRIGGER            3571    //������Ʒ��ȡ�����������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE        3572    //��ȡ��Ʒ�������Ĳ���ʱ������
#define    NET_DVR_SET_ATTENDEDBAGGAGE_SCHEDULE        3573    //������Ʒ��ȡ���Ĳ���ʱ������
#define    NET_DVR_GET_REGIONCLIP_CAPABILITIES            3574    //��ȡ����ü�����
#define    NET_DVR_GET_REGION_CLIP                     3575    //��ȡ����ü�����
#define    NET_DVR_SET_REGION_CLIP                     3576    //��������ü�����
#define    NET_DVR_GET_NETWORK_CAPABILITIES            3577    //��ȡ��������
#define    NET_DVR_GET_WIRELESS_DIAL                     3578    //��ȡ���߲�������
#define    NET_DVR_SET_WIRELESS_DIAL                     3579    //�������߲�������
#define    NET_DVR_GET_WIRELESSDIAL_CAPABILITIES        3580    //��ȡ���߲��Ų�������
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE            3581    //��ȡ���żƻ�����
#define    NET_DVR_SET_WIRELESSDIAL_SCHEDULE            3582    //���ò��żƻ�����
#define    NET_DVR_GET_WIRELESSDIAL_STATUS             3583    //��ȡ����״̬
#define    NET_DVR_GET_REGION_ENTRANCE_SCHEDULE_CAPABILITIES    3584    //��ȡ����������Ⲽ��ʱ������
#define    NET_DVR_GET_REGION_EXITING_SCHEDULE_CAPABILITIES    3585    //��ȡ�뿪������Ⲽ��ʱ������
#define    NET_DVR_GET_LOITERING_SCHEDULE_CAPABILITIES    3586    //��ȡ�ǻ���Ⲽ��ʱ������
#define    NET_DVR_GET_GROUP_SCHEDULE_CAPABILITIES    3587    //��ȡ��Ա�ۼ���Ⲽ��ʱ������
#define    NET_DVR_GET_RAPIDMOVE_SCHEDULE_CAPABILITIES    3588    //��ȡ�����˶���Ⲽ��ʱ������
#define    NET_DVR_GET_PARKING_SCHEDULE_CAPABILITIES    3589    //��ȡͣ����Ⲽ��ʱ������
#define    NET_DVR_GET_UNATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3590    //��ȡ��Ʒ������Ⲽ��ʱ������
#define    NET_DVR_GET_ATTENDEDBAGGAGE_SCHEDULE_CAPABILITIES    3591    //��ȡ��Ʒ��ȡ��Ⲽ��ʱ������
#define    NET_DVR_GET_WIRELESSDIAL_SCHEDULE_CAPABILITIES    3592    //��ȡ���żƻ�����
#define    NET_DVR_WIRELESSDIAL_CONNECT    3593    //��������������������

#define    NET_DVR_GET_LITESTORAGE                    3594    //��ȡ��洢����
#define    NET_DVR_SET_LITESTORAGE                    3595    //������洢����
#define    NET_DVR_GET_LITESTORAGE_CAPABILITIES    3596    //��ȡ��洢����

#define    NET_DVR_GET_VEHICLE_CAPABILITIES    3597    //��ȡ�������궨����
#define    NET_DVR_GET_VEHICLE_CALIBRATION     3598    //��ȡ�������궨

#define    NET_DVR_GET_SLAVECAMERA_CAPABILITIES    3599    //��ȡ�������IP��Ϣ��������    
#define    NET_DVR_GET_SLAVECAMERA                    3600    //��ȡ�������IP��Ϣ����
#define    NET_DVR_SET_SLAVECAMERA                    3601    //���ô������IP��Ϣ����
#define    NET_DVR_GET_SLAVECAMERA_STATUS            3602    //��ȡ�����������״̬
#define    NET_DVR_GET_SLAVECAMERA_CALIB_CAPABILITIES    3603  //��ȡ�����������&&�궨����    
#define    NET_DVR_GET_SLAVECAMERA_CALIB            3604    //��ȡ��������궨����
#define    NET_DVR_SET_SLAVECAMERA_CALIB            3605    //���ô�������궨����
#define NET_DVR_GET_PHY_RATIO                    3606    //��ȡ������������Ϣ    
#define NET_DVR_SET_PHY_RATIO                    3607    //����������������Ϣ
#define NET_DVR_GET_MASTERSLAVETRACKING_CAPABILITIES   3608  //��ȡ���Ӹ�������
#define    NET_DVR_SET_TRACKINGRATIO                3610    //���ô���������ٱ���
#define    NET_DVR_GET_TRACKING                    3611    //��ȡ���Ӹ��ٹ��������������
#define    NET_DVR_SET_TRACKING                    3612    //�������Ӹ��ٹ��������������
#define    NET_DVR_GET_TRACKING_CAPABILITIES        3613    //��ȡ���Ӹ��ٹ������������������

#define    NET_DVR_GET_SLAVECAMERA_CALIB_V50        3614    //��ȡ��������궨����V50
#define    NET_DVR_SET_SLAVECAMERA_CALIB_V50        3615    //���ô�������궨����V50
#define    NET_DVR_SET_TRACKINGRATIO_MANUAL        3616    //���ô�������ֶ����ٱ���
#define    NET_DVR_GET_TRACKINGRATIO_MANUAL        3617    //��ȡ��������ֶ����ٱ���
#define    NET_DVR_SET_TRACK_INITPOSTION            3618    //���ô��������ʼ����λ��
#define    NET_DVR_GET_PTZ_CAPABILITIES            3619    //��ȡptz�����������

#define    NET_DVR_GET_THERMOMETRY_BASICPARAM_CAPABILITIES    3620 //��ȡ������������
#define    NET_DVR_GET_THERMOMETRY_BASICPARAM      3621    //��ȡ�������ò���
#define    NET_DVR_SET_THERMOMETRY_BASICPARAM        3622    //���ò������ò���
#define    NET_DVR_GET_THERMOMETRY_SCENE_CAPABILITIES    3623 //��ȡ����Ԥ�õ������������
#define    NET_DVR_GET_THERMOMETRY_PRESETINFO      3624    //��ȡ����Ԥ�õ�������ò���
#define    NET_DVR_SET_THERMOMETRY_PRESETINFO        3625    //���ò���Ԥ�õ�������ò���
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE_CAPABILITIES    3626//��ȡ���±�����ʽ��������
#define    NET_DVR_GET_THERMOMETRY_ALARMRULE       3627    //��ȡ����Ԥ�õ㱨���������ò���
#define    NET_DVR_SET_THERMOMETRY_ALARMRULE        3628    //���ò���Ԥ�õ㱨���������ò���
#define    NET_DVR_GET_REALTIME_THERMOMETRY        3629    //ʵʱ�¶ȼ��
#define    NET_DVR_GET_THERMOMETRY_DIFFCOMPARISON  3630    //��ȡ����Ԥ�õ��²�������ò���
#define    NET_DVR_SET_THERMOMETRY_DIFFCOMPARISON    3631    //���ò���Ԥ�õ��²�������ò���
#define    NET_DVR_GET_THERMOMETRY_TRIGGER            3632    //��ȡ������������
#define    NET_DVR_SET_THERMOMETRY_TRIGGER            3633    //���ò�����������

#define    NET_DVR_GET_THERMAL_CAPABILITIES        3634    //��ȡ�ȳ���Thermal������
#define    NET_DVR_GET_FIREDETECTION_CAPABILITIES    3635    //��ȡ�������������
#define    NET_DVR_GET_FIREDETECTION               3636    //��ȡ��������
#define    NET_DVR_SET_FIREDETECTION               3637    //���û�������
#define    NET_DVR_GET_FIREDETECTION_TRIGGER       3638    //��ȡ�������������
#define    NET_DVR_SET_FIREDETECTION_TRIGGER        3639    //���û������������

#define NET_DVR_GET_OIS_CAPABILITIES            3640    //��ȡ��ѧ����������������
#define NET_DVR_GET_OIS_CFG                     3641    //��ȡ��ѧ��������
#define NET_DVR_SET_OIS_CFG                     3642    //���ù�ѧ��������
#define NET_DVR_GET_MACFILTER_CAPABILITIES      3643    //��ȡMAC��ַ������������
#define NET_DVR_GET_MACFILTER_CFG               3644    //��ȡMAC��ַ��������
#define NET_DVR_SET_MACFILTER_CFG               3645    //����MAC��ַ��������
#define NET_DVR_GET_EAGLEFOCUS_CALCFG_CAPABILITIES   3646    //ӥ�Ӿ۽��궨��������
#define NET_DVR_GET_EAGLEFOCUSING_CALCFG        3647    //��ȡӥ�Ӿ۽��궨����
#define NET_DVR_SET_EAGLEFOCUSING_CALCFG        3648    //����ӥ�Ӿ۽��궨����
#define NET_DVR_GET_EAGLEFOCUSING_CFG_CAPABILITIES   3649   //��ȡӥ�Ӿ۽���������
#define NET_DVR_GET_EAGLEFOCUSING_CTRL          3650    //��ȡӥ�Ӿ۽�����
#define NET_DVR_SET_EAGLEFOCUSING_CTRL          3651    //����ӥ�Ӿ۽�����

#define    NET_DVR_GET_PXOFFLINE_CAPABILITIES      3652    //��ȡͣ����Ʊ���ѻ��²������� ����
#define    NET_DVR_SET_PXOFFLINE_CFG                3653    //����ͣ����Ʊ���ѻ��²���������Ϣ
#define    NET_DVR_GET_PXOFFLINE_CFG                3654    //��ȡͣ����Ʊ���ѻ��²���������Ϣ
#define    NET_DVR_GET_PAPERCHARGEINFO_CAPABILITIES  3655  //��ȡͣ���������ֽƱ��Ϣ�·� ����
#define    NET_DVR_SET_PAPERCHARGEINFO                3656    //����ͣ���������ֽƱ��Ϣ�·�
#define    NET_DVR_GET_PARKINGSAPCE_CAPABILITIES    3657    //��ȡͣ���������ͣ��λ��Ϣ�·� ����
#define    NET_DVR_SET_PARKINGSAPCE_INFO            3658    //����ͣ���������ͣ��λ��Ϣ�·�
#define    NET_DVR_GET_PXMULTICTRL_CAPABILITIES    3659    //��ȡͣ����Ʊ������豸��ǶȲ������� ����
#define    NET_DVR_GET_CHARGEACCOUNT_CAPABILITIES    3661    //��ȡͣ����Ʊ�������������
#define    NET_DVR_SET_CHARGE_ACCOUNTINFO          3662    //���ýɷѽ����Ϣ
#define    NET_DVR_SET_PXMULTICTRL_CFG                3663    //����ͣ����Ʊ������豸��ǶȲ���������Ϣ
#define    NET_DVR_GET_PXMULTICTRL_CFG                3664    //��ȡͣ����Ʊ������豸��ǶȲ���������Ϣ
#define    NET_DVR_GET_TME_CHARGERULE              3665    //��ȡͣ��������ڳ����շѹ������
#define    NET_DVR_SET_TME_CHARGERULE                3666    //����ͣ��������ڳ����շѹ������
#define    NET_DVR_GET_TME_CHARGERULE_CAPABILITIES 3667    //��ȡͣ��������� �����շ���Ϣ��������
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CAPABILITIES  3668    //��ȡͣ����Ʊ�������������
#define    NET_DVR_GET_ILLEGALCARDFILTERING_CFG    3669    //��ȡͣ����Ʊ���������
#define    NET_DVR_SET_ILLEGALCARDFILTERING_CFG    3670    //����ͣ����Ʊ���������
#define    NET_DVR_GET_LEDDISPLAY_CAPABILITIES        3671    //��ȡLED��Ļ��ʾ�������ò�������
#define    NET_DVR_SET_LEDDISPLAY_CFG              3672    //����LED��Ļ��ʾ����
#define    NET_DVR_GET_LEDDISPLAY_CFG              3673    //��ȡLED��Ļ��ʾ����
#define    NET_DVR_GET_VOICEBROADCAST_CAPABILITIES    3674    //��ȡ�����������Ʋ������ò�������
#define    NET_DVR_SET_VOICEBROADCAST_CFG          3675    //���������������Ʋ���
#define    NET_DVR_GET_PAPERPRINTFORMAT_CAPABILITIES    3676//��ȡֽƱ��ӡ��ʽ��������
#define    NET_DVR_GET_PAPERPRINTFORMAT_CFG        3677    //��ȡֽƱ��ӡ��ʽ��������
#define    NET_DVR_SET_PAPERPRINTFORMAT_CFG        3678    //����ֽƱ��ӡ��ʽ��������
#define    NET_DVR_GET_LOCkGATE_CAPABILITIES       3679    //��ȡ������բ��������
#define    NET_DVR_GET_LOCKGATE_CFG                3680    //��ȡ������բ��������
#define    NET_DVR_SET_LOCKGATE_CFG                3681    //����������բ��������
#define NET_DVR_GET_PARKING_DATASTATE            3682    //��ȡ����ͬ��״̬
#define NET_DVR_SET_PARKING_DATASTATE           3683    //��������ͬ��״̬
#define    NET_DVR_GET_TME_CAPABILITIES            3684    //��ȡͣ����������豸 ����

#define    NET_DVR_GET_TMEVOICE_CAPABILITIES       3686    //��ȡ����������Ϣ����
#define    NET_DVR_SET_TMEVOICE_CFG                3687    //����������������
#define    NET_DVR_GET_TMEVOICE_CFG                3688    //��ȡ������������
#define    NET_DVR_DEL_TMEVOICE_CFG                3689    //ɾ��������������
#define    NET_DVR_GET_POSITION                    3698    // ��ȡ��λ�������ò���
#define    NET_DVR_SET_POSITION                    3699    // ���÷�λ�������ò���
#define    NET_DVR_GET_CENTRALIZEDCTRL_CAPABILITIES    3700//��ȡ���в�������
#define    NET_DVR_GET_CENTRALIZEDCTRL                3701//��ȡ���в��ز�������
#define    NET_DVR_SET_CENTRALIZEDCTRL              3702//���ü��в��ز�������
#define    NET_DVR_GET_COMPASS_CAPABILITIES        3703//��ȡ������������
#define    NET_DVR_GET_VANDALPROOFALARM              3704//��ȡ���ƻ�������������
#define    NET_DVR_SET_VANDALPROOFALARM            3705//���÷��ƻ�������������
#define    NET_DVR_COMPASS_CALIBRATE_CTRL            3706//�������̽������ƽӿ�
#define    NET_DVR_COMPASS_NORTH_CTRL                3707//��������ָ���������ƽӿ�
#define    NET_DVR_GET_AZIMUTHINFO                    3708//��ȡ��λ�ǶȲ�������


#define    NET_DVR_GET_SATELLITETIME                3709//��ȡ���Ƕ�λ��������
#define    NET_DVR_SET_SATELLITETIME                3710//�������Ƕ�λ��������
#define    NET_DVR_GET_GISINFO                     3711//��ȡ��ǰ�����GIS��Ϣ����
#define    NET_DVR_GET_STREAMING_CAPABILITIES        3712//��ȡ��Ƶ��������
#define    NET_DVR_GET_REFRESHFRAME_CAPABILITIES    3713//��ȡˢ��֡������
#define    NET_DVR_STREAMING_REFRESH_FRAME            3714//ȡ��Ԥ����ǿ��ˢ��֡
#define    NET_DVR_FACECAPTURE_STATISTICS            3715//��������Աͳ��
#define    NET_DVR_GET_WIRELESSSERVER_CAPABILITIES    3716    //��ȡ�ȵ㹦������Э�������
#define    NET_DVR_GET_WIRELESSSERVER                3717    //��ȡ�ȵ㹦������Э��
#define    NET_DVR_SET_WIRELESSSERVER                3718    //�����ȵ㹦������Э��
#define    NET_DVR_GET_CONNECT_LIST_CAPABILITIES    3719    //��ȡ�����豸�б���Ϣ������
#define    NET_DVR_GET_THSCREEN_CAPABILITIES        3720 //��ȡ��ʪ������Э�������
#define    NET_DVR_GET_THSCREEN                    3721 //��ȡ��ʪ������Э��
#define    NET_DVR_GET_EXTERNALDEVICE_CAPABILITIES    3722//��ȡ��������Э�������
#define    NET_DVR_GET_EXTERNALDEVICE              3723//��ȡ��������Э��
#define    NET_DVR_SET_EXTERNALDEVICE                3724//������������Э��
#define    NET_DVR_GET_LEDDISPLAYINFO_CAPABILITIES     3725   //��ȡLED��ʾ��Ϣ������
#define    NET_DVR_SET_LEDDISPLAYINFO                 3726   //����LED��ʾ��Ϣ
#define    NET_DVR_GET_SUPPLEMENTLIGHT_CAPABILITIES 3727   //��ȡ���ò��������Э������� (���֧�֣����ʵ�֣��������������豸�ڲ���)
#define    NET_DVR_GET_SUPPLEMENTLIGHT                 3728    //��ȡ���ò��������Э��
#define    NET_DVR_SET_SUPPLEMENTLIGHT                 3729    //�������ò��������Э��
#define    NET_DVR_SET_THSCREEN                     3730 //������ʪ������Э��
#define    NET_DVR_GET_LOWPOWER_CAPABILITIES        3731   //��ȡ�͹�������Э�������
#define    NET_DVR_GET_LOWPOWER                     3732    //��ȡ�͹�������Э��
#define    NET_DVR_SET_LOWPOWER                     3733    //���õ͹�������Э��
#define    NET_DVR_GET_ZOOMLINKAGE_CAPABILITIES     3734   //��ȡ�䱶��������Э�������
#define    NET_DVR_GET_ZOOMLINKAGE                     3735    //��ȡ�䱶��������Э��
#define    NET_DVR_SET_ZOOMLINKAGE                     3736    //���ñ䱶��������Э��
#define    NET_DVR_THSCREEN_TIMING                     3737    //��ʪ��
#define NET_DVR_GET_OSD_BATTERY_POWER_CFG        3741        //��ȡOSD��ص�����ʾ����
#define NET_DVR_SET_OSD_BATTERY_POWER_CFG        3742        //����OSD��ص�����ʾ����
#define    NET_DVR_GET_OSD_BATTERY_POWER_CFG_CAPABILITIES    3743//OSD��ص�����ʾ����������
#define    NET_DVR_GET_VANDALPROOFALARM_TRIGGER    3744    //��ȡ���ƻ�������������
#define    NET_DVR_SET_VANDALPROOFALARM_TRIGGER    3745    //���÷��ƻ�������������
#define    NET_DVR_GET_PANORAMAIMAGE_CAPABILITIES    3746    //��ȡȫ��ͼ�������
#define    NET_DVR_GET_PANORAMAIMAGE                3747    //��ȡȫ��ͼ�������Э��
#define    NET_DVR_SET_PANORAMAIMAGE                3748    //����ȫ��ͼ�������Э��
#define    NET_DVR_GET_STREAMENCRYPTION            3749    //��ȡ������������
#define    NET_DVR_SET_STREAMENCRYPTION            3750    //����������������
#define    NET_DVR_GET_STREAMENCRYPTION_CAPABILITIES 3751  //��ȡ������������
#define    NET_DVR_GET_REVISE_GPS_CAPABILITIES     3752    //��ȡУ׼GPS��γ������
#define    NET_DVR_GET_REVISE_GPS                  3753    //��ȡУ׼GPS��γ������
#define    NET_DVR_SET_REVISE_GPS                  3754    //����У׼GPS��γ������
#define NET_DVR_GET_PDC_RECOMMEND                3755    //��ȡ����ͳ�Ʊ�ʾ�Ƽ�ֵ
#define NET_DVR_REMOVE_FLASHSTORAGE                3756    //���������������
#define    NET_DVR_GET_COUNTING_CAPABILITIES        3757    //��ȡ������ͳ������
#define    NET_DVR_SET_SENSOR_ADJUSTMENT            3758    //����Sensor ���ڲ�����Э��
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_CAPABILITIES        3759    //��ȡSensor ���ڲ�����Э�������
#define    NET_DVR_GET_WIRELESSSERVER_FULLVERSION_CFG         3760    //��ȡwifi�ȵ��������(������)
#define    NET_DVR_SET_WIRELESSSERVER_FULLVERSION_CFG         3761    //����wifi�ȵ��������(������)
#define    NET_DVR_GET_ONLINEUSER_INFO                3762    //�����ӻ�ȡ�û�������Ϣ
#define    NET_DVR_GET_SENSOR_ADJUSTMENT_INFO        3763    //��ȡָ��sensor���ڲ���
#define NET_DVR_SENSOR_RESET_CTRL               3764    //Sensor ���ڸ�λ

#define    NET_DVR_GET_POSTRADAR_CAPABILITIES        3765    //��ȡ�״������������
#define    NET_DVR_GET_POSTRADARSPEED_CFG          3766    //��ȡ�״��������
#define    NET_DVR_SET_POSTRADARSPEED_CFG          3767    //�����״��������
#define    NET_DVR_GET_POSTRADARSPEED_RECOM_CFG    3768    //��ȡ�״�����Ƽ�ֵ
#define    NET_DVR_GET_POSTRADARPARAM_CFG          3769    //��ȡ�״��������
#define    NET_DVR_SET_POSTRADARPARAM_CFG          3770    //�����״��������
#define    NET_DVR_GET_POSTRADARPARAM_RECOM_CFG    3771    //��ȡ�״�����Ƽ�ֵ

#define NET_DVR_GET_ENCRYPT_DEVICE_INFO        3772   //��ȡ�����豸��Ϣ
#define NET_DVR_GET_ANR_ARMING_HOST            3773  //��ȡ����������������Ϣ
#define NET_DVR_GET_FIRMWARE_VERSION    3776    //GET firmware version
/********************************IPC����FF����****************************/
#define    NET_DVR_GET_FTP_CAPABILITIES            3782    //��ȡftp����
#define    NET_DVR_GET_FTPUPLOAD_CFG                3783    //��ȡftp�ϴ���Ϣ��������
#define    NET_DVR_SET_FTPUPLOAD_CFG                3784    //����ftp�ϴ���Ϣ��������
#define NET_DVR_GET_VEHICLE_INFORMATION             3785 //��ȡ������Ϣ    
#define    NET_DVR_GET_DDNS_COUNTRY_ABILITY        3800//��ȡ�豸֧�ֵ�DDNS���������б�
#define NET_DVR_GET_DEVICECFG_V50    3801    //��ȡ�豸����
#define NET_DVR_SET_DEVICECFG_V50    3802    //�����豸����
#define  NET_DVR_SET_VEHICLE_RECOG_TASK_V50    3851  //��������ʶ�������ύV50��չ
#define NET_DVR_GET_SMARTCALIBRATION_CAPABILITIES    3900// Smart��Ϊ�궨���˳ߴ繦������
#define NET_DVR_GET_TEMPERATURE_TRIGGER              3903    //��ȡ���²��������� 
#define NET_DVR_SET_TEMPERATURE_TRIGGER              3904    //���ò��²��������� 

#define    NET_DVR_GET_SMARTCALIBRATION_CFG             3910 //��ȡSmart��Ϊ�궨���˳ߴ繦��
#define    NET_DVR_SET_SMARTCALIBRATION_CFG             3911  //����Smart��Ϊ�궨���˳ߴ繦��
#define NET_DVR_POST_SETUP_CALIB                     3912  //����궨
#define NET_DVR_SET_POS_INFO_OVERLAY                 3913//����Pos��Ϣ�������ӿ���
#define NET_DVR_GET_POS_INFO_OVERLAY                 3914//��ȡPos��Ϣ�������ӿ���
#define NET_DVR_GET_CAMERA_WORK_MODE                 3915  //�����������ģʽ����
#define NET_DVR_SET_CAMERA_WORK_MODE                 3916  //��ȡ�������ģʽ����
#define NET_DVR_GET_RESOLUTION_SWITCH_CAPABILITIES   3917  //��ȡ�ֱ���ģʽ�л�����
#define NET_DVR_GET_RESOLUTION_SWITCH                3918    //��ȡ�ֱ���ģʽ�л�����
#define NET_DVR_SET_RESOLUTION_SWITCH                3919     //���÷ֱ���ģʽ�л�����
#define NET_DVR_GET_CONFIRM_MECHANISM_CAPABILITIES   3920    //�����ϴ�ȷ�ϻ��ƿ�������
#define NET_DVR_CONFIRM_MECHANISM_CTRL               3921    //�����ϴ�ȷ�ϻ��ƿ���
#define NET_DVR_GET_VEHICLLE_RESULT_CAPABILITIES     3951   //��ȡ��ȡ������Ϣ�������
#define NET_DVR_GET_CALIB_CAPABILITIES               3952//��ȡ����궨����
#define NET_DVR_GET_POSINFO_OVERLAY_CAPABILITIES     3953//��ȡ��ȡPos��������
#define NET_SDK_FINDMEDICALFILE      3954    //��Ӱ�Ƽ��ǻ�ҽ�Ʋ���¼���ļ�
#define NET_SDK_FINDMEDICALPICTURE   3955    //��Ӱ�Ƽ��ǻ�ҽ�Ʋ���ͼƬ�ļ�
#define NET_DVR_SET_POSINFO_OVERLAY                  3960//����Pos����
#define NET_DVR_GET_POSINFO_OVERLAY                  3961//��ȡPos����
#define NET_DVR_GET_FACELIB_TRIGGER                  3962   //��ȡ�����ȶԿ����������
#define NET_DVR_SET_FACELIB_TRIGGER                  3963   //���������ȶԿ����������
#define NET_DVR_GET_FACECONTRAST_TRIGGER             3965//��ȡ�����ȶ���������
#define NET_DVR_SET_FACECONTRAST_TRIGGER             3966//���������ȶ���������
#define NET_DVR_GET_FACECONTRAST_SCHEDULE_CAPABILITIES 3967 //��ȡ�����ȶԲ���ʱ������
#define NET_DVR_GET_FACECONTRAST_SCHEDULE            3968//��ȡ�����ȶԲ���ʱ������
#define NET_DVR_SET_FACECONTRAST_SCHEDULE            3969//���������ȶԲ���ʱ������
#define NET_DVR_GET_FACELIB_SCHEDULE_CAPABILITIES    3970 //��ȡ�����ȶԿ�Ĳ���ʱ������
#define NET_DVR_GET_VCA_VERSION_LIST                 3973//��ȡ�㷨��汾
#define NET_DVR_GET_SETUP_CALIB                      3974//��ȡ����궨
#define NET_DVR_GET_PANORAMA_LINKAGE                 3975//��ȡ����ץͼ�ϴ�ʹ������
#define NET_DVR_SET_PANORAMA_LINKAGE                 3976//��������ץͼ�ϴ�ʹ������
#define NET_DVR_GET_FACELIB_SCHEDULE                 3977 //��ȡ�����ȶԿ�Ĳ���ʱ������
#define NET_DVR_SET_FACELIB_SCHEDULE                 3978 //���������ȶԿ�Ĳ���ʱ������
#define NET_DVR_GET_SOFTWARE_SERVICE_CAPABILITIES    3980//��ȡ�����������
#define NET_DVR_GET_SOFTWARE_SERVICE                 3981//��ȡ�����������
#define NET_DVR_SET_SOFTWARE_SERVICE                 3982//���������������
#define NET_DVR_GET_PREVIEW_MODE_CAPABILITIES        3983//��ȡԤ��ģʽ��������
#define NET_DVR_SET_EAGLE_FOCUS_GOTOSCENE            3984//ӥʽ�۽����������ת��ָ���ĳ���ID
#define NET_DVR_EAGLE_FOCUS_SCENE_DEL                3985//ɾ��ӥʽ�۽��궨�ĳ���
#define NET_DVR_GET_SAFETY_HELMET_TRIGGER            3986   //��ȡ��ȫñ�����������
#define NET_DVR_SET_SAFETY_HELMET_TRIGGER            3987  //���ð�ȫñ�����������
#define NET_DVR_GET_SAFETY_HELMET_SCHEDULE_CAPABILITIES 3988 //��ȡ��ȫñ��Ⲽ��ʱ������
#define NET_DVR_GET_SAFETY_HELMET_SCHEDULE           3989//��ȡ��ȫñ��Ⲽ��ʱ������
#define NET_DVR_SET_SAFETY_HELMET_SCHEDULE           3990//���ð�ȫñ��Ⲽ��ʱ������

#define NET_DVR_GET_SIGN_ABNORMAL_TRIGGER            4150   //��ȡ�����쳣��������
#define NET_DVR_SET_SIGN_ABNORMAL_TRIGGER            4151   //���������쳣��������

#define NET_DVR_ONE_KEY_CONFIG_SAN_V50               4152  //һ������SAN(V50)
#define NET_DVR_GET_HDCFG_V50                        4153  //��ȡӲ����Ϣ����V50
#define NET_DVR_SET_HDCFG_V50                        4154  //����Ӳ����Ϣ����V50
#define NET_DVR_GET_HDVOLUME_CFG                     4155  //��ȡӲ�̾���Ϣ
#define NET_DVR_SET_HDVOLUME_CFG                     4156  //����Ӳ�̾���Ϣ
#define NET_DVR_GET_POWER_SUPPLY_CABINET_TRIGGER     4157  //��ȡ���񹩵������������
#define NET_DVR_SET_POWER_SUPPLY_CABINET_TRIGGER     4158  //���û��񹩵������������
#define NET_DVR_GET_SENSOR_TRIGGER                   4159  //��ȡ������������������
#define NET_DVR_SET_SENSOR_TRIGGER                   4160  //���ô�����������������
#define	NET_DVR_GET_FACESNAP_TRIGGER                 4161  //��ȡ����ץ����������
#define	NET_DVR_SET_FACESNAP_TRIGGER	             4162  //��������ץ����������
#define NET_DVR_GET_FACESNAP_SCHEDULE_CAPABILITIES   4163  //��ȡ����ץ�Ĳ���ʱ������
#define NET_DVR_GET_FACESNAP_SCHEDULE                4164  //��ȡ����ץ�Ĳ���ʱ������
#define NET_DVR_SET_FACESNAP_SCHEDULE                4165  //��������ץ�Ĳ���ʱ������

#define NET_DVR_SET_SCREEN_SWITCH                    4171  //�����л�����
#define NET_DVR_GET_BV_CALIB_PIC                     4172  //��ȡ�豸ץȡͼƬ�͸�����Ϣ
#define NET_DVR_GET_BV_CALIB_RESULT                  4173  //��ȡ˫Ŀ��α궨���
#define NET_DVR_GET_BV_HCORRECTION                   4174  //��ȡ˫Ŀ�߶Ƚ�������
#define NET_DVR_DEL_BV_CALIB_PIC                     4175  //ɾ������ͼƬ
#define NET_DVR_GET_TV_SCREEN_CFG                    4176  //��ȡ��������ͣ��ʱ������
#define NET_DVR_SET_TV_SCREEN_CFG                    4177  //���õ�������ͣ��ʱ������
#define NET_DVR_ADJUST_BV_CALIB                      4178 //˫Ŀ�궨΢��
#define NET_DVR_GET_HUMAN_CALIB                      4179 //��ȡ��������궨����
#define NET_DVR_SET_HUMAN_CALIB                      4180 //������������궨����
#define NET_DVR_GET_USERCFG_V51                      4181    //��ȡ�û�����
#define NET_DVR_SET_USERCFG_V51                      4182    //�����û�����
#define NET_DVR_GET_SOFTIO_TRIGGER                   4183   //��ȡSoftIO��������
#define NET_DVR_SET_SOFTIO_TRIGGER                   4184   //����SoftIO��������
#define NET_DVR_GET_SOFTIO_SCHEDULE_CAPABILITIES     4185 //��ȡSoftIO����ʱ������
#define NET_DVR_GET_SOFTIO_SCHEDULE                  4186 //��ȡSoftIO����ʱ������
#define NET_DVR_SET_SOFTIO_SCHEDULE                  4187 //����SoftIO����ʱ������
#define NET_DVR_GET_HFPD_TRIGGER                     4188 //��ȡ��Ƶ��Ա�����������
#define NET_DVR_SET_HFPD_TRIGGER                     4189 //���ø�Ƶ��Ա�����������
#define NET_DVR_GET_HFPD_SCHEDULE_CAPABILITIES       4190 //��ȡ��Ƶ��Ա��Ⲽ��ʱ������
#define NET_DVR_GET_HFPD_SCHEDULE                    4191 //��ȡ��Ƶ��Ա��Ⲽ��ʱ������
#define NET_DVR_SET_HFPD_SCHEDULE                    4192 //���ø�Ƶ��Ա��Ⲽ��ʱ������
#define	NET_DVR_GET_ALARM_INFO                       4193	//��ȡ�����¼���Ϣ
#define NET_DVR_GET_USERCFG_V52                      4194    //��ȡ�û�����
#define NET_DVR_SET_USERCFG_V52                      4195    //�����û�����

/********************************NVR_��˲�Ʒ��****************************/
#define NET_DVR_GET_MUTEX_FUNCTION              4353  //��ȡ���ܻ�����Ϣ

#define NET_DVR_GET_SINGLE_CHANNELINFO          4360  //��ȡ����ͨ����������
#define NET_DVR_GET_CHANNELINFO                 4361  //��ȡͨ����������
#define NET_DVR_CHECK_LOGIN_PASSWORDCFG                 4362  //�û���¼����У��
#define NET_DVR_GET_SINGLE_SECURITY_QUESTION_CFG        4363    //��ȡ�����豸��ȫ����
#define NET_DVR_SET_SINGLE_SECURITY_QUESTION_CFG        4364    //���õ����豸��ȫ����
#define NET_DVR_GET_SECURITY_QUESTION_CFG       4365    //��ȡ�豸��ȫ����
#define NET_DVR_SET_SECURITY_QUESTION_CFG       4366    //�����豸��ȫ����
#define NET_DVR_GET_ONLINEUSERLIST_SC           4367  //Զ�̻�ȡ��½�û���Ϣ�������ӣ�

#define NET_DVR_GET_BLACKLIST_FACECONTRAST_TRIGGER   4368   //��ȡ�����������ȶ���������
#define NET_DVR_SET_BLACKLIST_FACECONTRAST_TRIGGER   4369   //���ú����������ȶ���������
#define NET_DVR_GET_WHITELIST_FACECONTRAST_TRIGGER   4370   //��ȡ�����������ȶ���������
#define NET_DVR_SET_WHITELIST_FACECONTRAST_TRIGGER   4371   //���ð����������ȶ���������
#define NET_DVR_GET_BLACKLIST_FACECONTRAST_SCHEDULE_CAPABILITIES 4372 //��ȡ�����������ȶԲ���ʱ������
#define NET_DVR_GET_BLACKLIST_FACECONTRAST_SCHEDULE  4373   //��ȡ�����������ȶԲ���ʱ������
#define NET_DVR_SET_BLACKLIST_FACECONTRAST_SCHEDULE  4374   //���ú����������ȶԲ���ʱ������
#define NET_DVR_GET_WHITELIST_FACECONTRAST_SCHEDULE_CAPABILITIES 4375 //��ȡ�����������ȶԲ���ʱ������
#define NET_DVR_GET_WHITELIST_FACECONTRAST_SCHEDULE  4376 //��ȡ�����������ȶԲ���ʱ������
#define NET_DVR_SET_WHITELIST_FACECONTRAST_SCHEDULE  4377 //���ð����������ȶԲ���ʱ������

#define NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE_CAPABILITIES 4378 //��ȡ����ʶ�𲼷�ʱ������
#define NET_DVR_GET_HUMAN_RECOGNITION_SCHEDULE 4379 //��ȡ����ʶ�𲼷�ʱ������
#define NET_DVR_SET_HUMAN_RECOGNITION_SCHEDULE 4380 //��������ʶ�𲼷�ʱ������
#define NET_DVR_GET_HUMAN_RECOGNITION_TRIGGER               4381 //��ȡ����ʶ����������
#define NET_DVR_SET_HUMAN_RECOGNITION_TRIGGER               4382 //��������ʶ����������
#define NET_DVR_GET_GBT28181_AUDIO_OUTPUT_CFG               4383 //��ȡGBT28181Э������豸�������Խ���Ϣ
#define NET_DVR_SET_GBT28181_AUDIO_OUTPUT_CFG               4384 //����GBT28181Э������豸�������Խ���Ϣ

#define NET_DVR_GET_STUDENTS_STOODUP_TRIGGER         4386   //��ȡѧ�����������������
#define NET_DVR_SET_STUDENTS_STOODUP_TRIGGER         4387   //����ѧ�����������������
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE_CAPABILITIES    4388 //��ȡ��������ͳ�Ʋ���ʱ������
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_SCHEDULE  4389    //��ȡ��������ͳ�Ʋ���ʱ������
#define NET_DVR_SET_FRAMES_PEOPLE_COUNTING_SCHEDULE  4390    //������������ͳ�Ʋ���ʱ������
#define NET_DVR_GET_FRAMES_PEOPLE_COUNTING_TRIGGER   4391   //��ȡ��������ͳ����������
#define NET_DVR_SET_FRAMES_PEOPLE_COUNTING_TRIGGER   4392   //������������ͳ����������

#define NET_DVR_GET_PERSONDENSITY_TRIGGER   4393   //��ȡ��Ա�ܶȼ�����������
#define NET_DVR_SET_PERSONDENSITY_TRIGGER   4394   //������Ա�ܶȼ�����������
#define NET_DVR_GET_PERSONDENSITY_SCHEDULE_CAPABILITIES 4395 //��ȡ��Ա�ܶȼ��Ĳ���ʱ������
#define NET_DVR_GET_PERSONDENSITY_SCHEDULE 4396 //��ȡ��Ա�ܶȼ��Ĳ���ʱ������
#define NET_DVR_SET_PERSONDENSITY_SCHEDULE 4397 //������Ա�ܶȼ��Ĳ���ʱ������

#define NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE_CAPABILITIES  4398 //��ȡѧ��������Ⲽ��ʱ������
#define NET_DVR_GET_STUDENTS_STOODUP_SCHEDULE        4399    //��ȡѧ��������Ⲽ��ʱ������
#define NET_DVR_SET_STUDENTS_STOODUP_SCHEDULE        4400    //����ѧ��������Ⲽ��ʱ������

#define NET_DVR_SET_FACE_THERMOMETRY_TRIGGER         4401 //��������������������
#define NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE_CAPABILITIES 4402 //��ȡ�������²���ʱ������
#define NET_DVR_GET_FACE_THERMOMETRY_SCHEDULE        4403 //��ȡ�������²���ʱ������
#define NET_DVR_SET_FACE_THERMOMETRY_SCHEDULE        4404 //�����������²���ʱ������
#define NET_DVR_GET_FACE_THERMOMETRY_TRIGGER         4405 //��ȡ����������������
#define	NET_DVR_GET_PERSONQUEUE_TRIGGER   4406   //��ȡ��Ա�ŶӼ�����������
#define	NET_DVR_SET_PERSONQUEUE_TRIGGER	  4407   //������Ա�ŶӼ�����������
#define	NET_DVR_GET_PERSONQUEUE_SCHEDULE_CAPABILITIES	4408 //��ȡ��Ա�ŶӼ��Ĳ���ʱ������
#define	NET_DVR_GET_PERSONQUEUE_SCHEDULE	4409	//��ȡ��Ա�ŶӼ��Ĳ���ʱ������
#define	NET_DVR_SET_PERSONQUEUE_SCHEDULE	4410	//������Ա�ŶӼ��Ĳ���ʱ������


/********************************��������ʶ��****************************/
#define NET_DVR_GET_FACESNAPCFG                 5001  //��ȡ����ץ�Ĳ���
#define NET_DVR_SET_FACESNAPCFG                 5002  //��������ץ�Ĳ���
#define NET_DVR_GET_DEVACCESS_CFG               5005  //��ȡ�����豸����
#define NET_DVR_SET_DEVACCESS_CFG               5006  //���ý����豸����
#define NET_DVR_GET_SAVE_PATH_CFG               5007  //��ȡ�洢��Ϣ����
#define NET_DVR_SET_SAVE_PATH_CFG               5008  //���ô洢��Ϣ����
#define NET_VCA_GET_RULECFG_V41                    5011  //��ȡ��Ϊ��������(��չ)
#define NET_VCA_SET_RULECFG_V41                    5012  //������Ϊ��������(��չ)
#define NET_DVR_GET_AID_RULECFG_V41             5013  //��ȡ��ͨ�¼��������
#define NET_DVR_SET_AID_RULECFG_V41             5014  //���ý�ͨ�¼��������
#define NET_DVR_GET_TPS_RULECFG_V41             5015  //��ȡ��ͨͳ�ƹ������(��չ)
#define NET_DVR_SET_TPS_RULECFG_V41             5016  //���ý�ͨͳ�ƹ������(��չ)
#define NET_VCA_GET_FACEDETECT_RULECFG_V41      5017  //��ȡATM����������(��չ) 
#define NET_VCA_SET_FACEDETECT_RULECFG_V41      5018  //����ATM����������(��չ)
#define NET_DVR_GET_PDC_RULECFG_V41             5019  //����������ͳ�ƹ���(��չ)
#define NET_DVR_SET_PDC_RULECFG_V41             5020  //��ȡ������ͳ�ƹ���(��չ)
#define NET_DVR_GET_TRIAL_VERSION_CFG           5021  //��ȡ���ð���Ϣ
#define NET_DVR_GET_VCA_CTRLINFO_CFG            5022  //������ȡ���ܿ��Ʋ���
#define NET_DVR_SET_VCA_CTRLINFO_CFG            5023  //�����������ܿ��Ʋ���
#define NET_DVR_SYN_CHANNEL_NAME                5024  //ͬ��ͨ����
#define NET_DVR_GET_RESET_COUNTER               5025  //��ȡͳ�������������������������ͨͳ�ƣ�
#define NET_DVR_SET_RESET_COUNTER               5026  //����ͳ�������������������������ͨͳ�ƣ�
#define NET_DVR_GET_OBJECT_COLOR                5027  //��ȡ������ɫ����
#define NET_DVR_SET_OBJECT_COLOR                5028  //����������ɫ����
#define NET_DVR_GET_AUX_AREA                    5029  //��ȡ��������
#define NET_DVR_SET_AUX_AREA                    5030  //���ø�������
#define NET_DVR_GET_CHAN_WORKMODE               5031  //��ȡͨ������ģʽ
#define NET_DVR_SET_CHAN_WORKMODE               5032  //����ͨ������ģʽ
#define NET_DVR_GET_SLAVE_CHANNEL               5033  //��ȡ��ͨ������
#define NET_DVR_SET_SLAVE_CHANNEL               5034  //���ô�ͨ������
#define NET_DVR_GET_VQD_EVENT_RULE              5035  //��ȡ��Ƶ��������¼�����
#define NET_DVR_SET_VQD_EVENT_RULE              5036  //������Ƶ��������¼�����
#define NET_DVR_GET_BASELINE_SCENE              5037  //��ȡ��׼��������
#define NET_DVR_SET_BASELINE_SCENE              5038  //���û�׼��������
#define NET_DVR_CONTROL_BASELINE_SCENE          5039  //��׼��������
#define NET_DVR_SET_VCA_DETION_CFG                5040  //���������ƶ���������
#define NET_DVR_GET_VCA_DETION_CFG                5041  //��ȡ�����ƶ���������
#define NET_DVR_GET_STREAM_ATTACHINFO_CFG       5042  //��ȡ����������Ϣ����
#define NET_DVR_SET_STREAM_ATTACHINFO_CFG       5043  //��������������Ϣ����

#define NET_DVR_GET_BV_CALIB_TYPE               5044  //��ȡ˫Ŀ�궨����
#define NET_DVR_CONTROL_BV_SAMPLE_CALIB         5045  //˫Ŀ�����궨
#define NET_DVR_GET_BV_SAMPLE_CALIB_CFG         5046  //��ȡ˫Ŀ�궨����
#define NET_DVR_GET_RULECFG_V42                    5049  //��ȡ��Ϊ��������(֧��16��������չ)
#define NET_DVR_SET_RULECFG_V42                    5050  //������Ϊ��������(֧��16��������չ)
#define NET_DVR_SET_VCA_DETION_CFG_V40            5051  //���������ƶ���������
#define NET_DVR_GET_VCA_DETION_CFG_V40          5052  //��ȡ�����ƶ���������
#define NET_DVR_SET_FLASH_CFG                   5110  //д�����ݵ�Flash ����ʹ��
/********************************��������ʶ�� end****************************/

//2014-12-03  
#define    NET_DVR_GET_T1TEST_CFG   5053     //���߲������ýӿڣ���ȡ��
#define    NET_DVR_SET_T1TEST_CFG   5054     ////���߲������ýӿڣ����ã�

/********************************ITS****************************/
#define NET_ITS_GET_OVERLAP_CFG_V50                5055  //��ȡ�ַ����Ӳ���������չ
#define NET_ITS_SET_OVERLAP_CFG_V50                5056  //�����ַ����Ӳ���������չ

#define NET_DVR_GET_PARKLAMP_STATE                5057  //��ȡͣ�����źŵ�״̬��Ϣ
#define NET_DVR_GET_CLOUDSTORAGE_CFG            5058  //��ȡ�ƴ洢���ò���
#define NET_DVR_SET_CLOUDSTORAGE_CFG            5059  //�����ƴ洢���ò���

#define NET_ITS_GET_BASE_INFO                    5060  //��ȡ�ն˻�����Ϣ
#define NET_DVR_GET_SENSOR_INFO                 5061  //��������Ϣ��ѯ
#define    NET_DVR_SET_SENSOR_SWITCH                5062  //������Զ�̿���
#define NET_ITS_GET_IMGMERGE_CFG                5063  //��ȡͼƬ�ϳ����ò���
#define NET_ITS_SET_IMGMERGE_CFG                5064  //����ͼƬ�ϳ����ò���
#define NET_ITS_GET_UPLOAD_CFG                    5065  //��ȡ�����ϴ�����
#define NET_ITS_SET_UPLOAD_CFG                    5066  //���������ϴ�����
#define    NET_DVR_GET_SENSOR_PORT_CAPABILITIES    5067  //��ȡ����������
#define NET_ITS_GET_WORKSTATE                    5069  //��ȡ�ն˹���״̬
#define NET_ITS_GET_IPC_CHAN_CFG                5070  //��ȡͨ��IPC��Ϣ
#define NET_ITS_SET_IPC_CHAN_CFG                5071  //����ͨ��IPC��Ϣ
#define NET_ITS_GET_OVERLAP_CFG                    5072  //��ȡ�ַ����Ӳ�������
#define NET_ITS_SET_OVERLAP_CFG                    5073  //�����ַ����Ӳ�������
#define NET_DVR_GET_TRIGGEREX_CFG               5074  //��ȡITC��չ����
#define NET_DVR_SET_TRIGGEREX_CFG               5075  //����ITC��չ����
#define NET_ITS_GET_ROAD_INFO                    5076  //��ȡ·����Ϣ

#define NET_ITS_REMOTE_DEVICE_CONTROL            5077//����Զ���豸����
#define NET_ITS_GET_GATEIPC_CHAN_CFG            5078//��ȡ����ڲ���
#define NET_ITS_SET_GATEIPC_CHAN_CFG            5079//���ó���ڲ���
#define NET_ITS_TRANSCHAN_START                    5080//ͬ�����ݷ�������������
#define NET_ITS_GET_ECTWORKSTATE                5081//��ȡ������ն˹���״̬
#define NET_ITS_GET_ECT_CHAN_INFO                5082//��ȡ������ն�ͨ��״̬
#define NET_DVR_GET_HEATMAP_RESULT              5083//�ȶ�ͼ���ݲ���
#define NET_DVR_SET_ITS_EXDEVCFG                5084 //����ITS����豸��Ϣ
#define NET_DVR_GET_ITS_EXDEVCFG                5085 //��ȡITS����豸��Ϣ
#define NET_DVR_GET_ITS_EXDEVSTATUS                5086 //��ȡITS��������豸��Ϣ
#define NET_DVR_SET_ITS_ENDEVCMD                5087 //����ITS�ն˳���ڿ�������
#define NET_DVR_SET_ENISSUED_DATADEL            5088 //����ITS�ն˳���ڿ������
#define NET_DVR_GET_PDC_RESULT                  5089//���������ݲ�ѯ 2014-03-21
#define NET_ITS_GET_LAMP_CTRLCFG                5090  //��ȡ�����õƲ���
#define NET_ITS_SET_LAMP_CTRLCFG                5091  //���������õƲ���
#define NET_ITS_GET_PARKSPACE_ATTRIBUTE_CFG     5092  //��ȡ���⳵λ����
#define NET_ITS_SET_PARKSPACE_ATTRIBUTE_CFG     5093  //�������⳵λ����
#define NET_ITS_SET_LAMP_EXTERNAL_CFG            5095  //����������ò���
#define NET_ITS_SET_COMPEL_CAPTURE                5096  //���ó�λǿ��ץͼ
#define NET_DVR_SET_TIMESIGN_CFG                5097  //������չУʱ�Զ�����
#define NET_DVR_GET_TIMESIGN_CFG                5098  //��ȡ��չУʱ�Զ�����
#define NET_DVR_GET_SIGNALLAMP_STATUS           5099  //�źŵƼ��
/********************************ITS end****************************/

#define NET_DVR_GET_MONITOR_PLAN_VQD            5100  //�����ӻ�ȡ��Ϸ������ƻ�
#define NET_DVR_GET_MONITORID_VQD               5101  //�����ӻ�ȡ��Ӧ�ƻ��ڵļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_INFO                5102  //�������üƻ��ڵļ�ص���Ϣ 
#define NET_DVR_DEL_MONITOR_PLAN_VQD            5103  //ɾ���ƻ�
#define NET_DVR_GET_MONITOR_VQD_STATUS          5104  //ƽ̨��ѯ��Ϸ�������״̬
#define NET_DVR_GET_RECORD_INFO                 5105  //��ȡ��ԴͼƬ��ѯ
#define NET_DVR_GET_MONITOR_VQDCFG              5106  //��ȡ�������ļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_VQDCFG              5107  //���÷������ļ�ص���Ϣ
#define NET_DVR_SET_MONITOR_PLAN_VQDCFG         5108  //���ù���ƻ�(�����ļƻ�)

#define NET_DVR_SCENE_CHANGE_UPDATE                5109   //����������ݸ���

#define NET_DVR_GET_CALIBRATE_POINT             5153  //��һ������ת����ǹ�������豸 �ⲿ���������� ���ߴ��벻ʵ�֣���ֹ��ͻ���ύ���ߣ�/*************************���ܶೡ��********************************/
#define NET_DVR_GET_SCENE_CFG                   5201  //��ȡ������Ϣ
#define NET_DVR_SET_SCENE_CFG                   5202  //���ó�����Ϣ
#define NET_DVR_GET_SCENE_REFERENCE_REGION      5203  //��ȡ�ο�����
#define NET_DVR_SET_SCENE_REFERENCE_REGION      5204  //���òο�����
#define NET_DVR_GET_SCENE_CALIBRATION           5205  //��ȡ�궨��Ϣ
#define NET_DVR_SET_SCENE_CALIBRATION           5206  //���ñ궨��Ϣ
#define NET_DVR_GET_SCENE_MASK_REGION           5207  //��ȡ��������
#define NET_DVR_SET_SCENE_MASK_REGION           5208  //������������
#define    NET_DVR_GET_SCENE_LANECFG                5209  //��ȡ��������
#define NET_DVR_SET_SCENE_LANECFG                5210  //���ó�������
#define NET_DVR_GET_SCENE_AID_RULECFG           5211  //��ȡ��ͨ�¼��������
#define NET_DVR_SET_SCENE_AID_RULECFG           5212  //���ý�ͨ�¼��������
#define NET_DVR_GET_SCENE_TPS_RULECFG           5213  //��ȡ��ͨͳ�ƹ������
#define NET_DVR_SET_SCENE_TPS_RULECFG           5214  //���ý�ͨͳ�ƹ������
#define NET_DVR_GET_SCENE_TIME_CFG              5215  //��ȡͨ���ĳ���ʱ�������
#define NET_DVR_SET_SCENE_TIME_CFG              5216  //����ͨ���ĳ���ʱ�������
#define NET_DVR_GET_FORENSICS_MODE              5217  //��ȡȡ֤��ʽ����
#define NET_DVR_SET_FORENSICS_MODE              5218  //����ȡ֤��ʽ����
#define NET_DVR_FORCESTOP_FORENSICS_CTRL        5219  //ǿ��ֹͣȡ֤
#define NET_DVR_GET_ALARM_PROCESS_CFG           5220   //��ȡ�����������
#define NET_DVR_SET_ALARM_PROCESS_CFG           5221   //���ñ����������
#define NET_DVR_GET_BLACKLIST_ALARM_INFO        5222   //��ȡ�ڰ����������켣
#define NET_DVR_GET_STORAGE_RESOURCE_CFG        5225   //��ȡ�洢��Դ����
#define NET_DVR_SET_STORAGE_RESOURCE_CFG        5226   //���ô洢��Դ����
#define NET_DVR_DEL_BLACKLIST_ALARM_RECORD        5227   //Զ��ɾ������������¼
#define NET_DVR_SET_BLACKLIST_GROUP_INFO        5229   //Զ�̷����б��������
#define NET_DVR_DEL_BLACKLIST_GROUP_INFO        5230   //Զ��ɾ�������б�
#define NET_DVR_GET_BLACKLIST_GROUP_INFO        5231   //Զ�̻�ȡȫ�������б�
#define NET_DVR_SET_BLACKLIST_GROUP_RECORD_CFG    5232   //�����¼��������
#define NET_DVR_GET_BLACKLIST_GROUP_RECORD_CFG    5234   //Զ�̻�ȡ�����¼����
#define NET_DVR_DEL_BLACKLIST_GROUP_RECORD_CFG    5235   //Զ��ɾ�������¼����
#define    NET_DVR_GET_AREA_MONITOR_CFG            5236   //��ȡ�����ص����
#define    NET_DVR_SET_AREA_MONITOR_CFG            5237   //���������ص����
#define    NET_DVR_DEL_AREA_MONITOR_CFG            5238   //ɾ�������ص�
#define NET_DVR_RETRIEVAL_SNAP_RECORD            5240   //ץ�Ŀ����
#define NET_DVR_GET_ALARMLIST                    5241   //��ȡ���������б�
#define NET_DVR_DETECT_IMAGE                    5242   //����ͼƬ���
#define NET_DVR_GET_SNAP_RECORD                 5243   //��ȡץ�ļ�¼
#define NET_DVR_DEL_SNAP_RECORD                 5244   //ɾ��ץ�ļ�¼
#define NET_DVR_GET_FACE_RECORD                 5245   //Զ�̻�ȡ������¼�б�
#define NET_DVR_SET_FACE_RECORD                    5246   //���������¼
#define NET_DVR_DEL_FACE_RECORD                    5247   //ɾ��������¼
#define NET_DVR_GET_FACE_DATABASE                5248   //��ȡ���������ò���
#define NET_DVR_SET_FACE_DATABASE                5249   //�������������ò���
#define NET_DVR_DEL_FACE_DATABASE                5250   //ɾ��������
#define NET_DVR_RETRIEVAL_FACE_DATABASE            5251   //���������
#define NET_DVR_SET_BLACKLIST_REL_DEV_CFG        5252   //�豸���������������
#define NET_DVR_DEL_BLACKLIST_REL_DEV            5253   //ɾ�� �豸��������������Ϣ
/*************************���ܶೡ��end*****************************/

#define NET_DVR_GET_DISK_RAID_INFO              6001  //��ȡ����Raid��Ϣ
#define NET_DVR_SET_DISK_RAID_INFO              6002  //���ô���Raid��Ϣ

#define NET_DVR_GET_DVR_SYNCHRONOUS_IPC         6005  //��ȡ���Ƿ�Ϊǰ��IPCͬ���豸����
#define NET_DVR_SET_DVR_SYNCHRONOUS_IPC         6006  //���ã��Ƿ�Ϊǰ��IPCͬ���豸����

#define NET_DVR_SET_DVR_IPC_PASSWD              6008  //���ã�IPC�û�������
#define NET_DVR_GET_DEVICE_NET_USING_INFO       6009  //��ȡ����ǰ�豸������Դʹ�����

#define NET_DVR_SET_DVR_IPC_NET                 6012  //���ã�����ǰ��IPC�������ַ

#define NET_DVR_GET_RECORD_CHANNEL_INFO         6013  //��ȡ��¼��ͨ����Ϣ
#define NET_DVR_SET_RECORD_CHANNEL_INFO         6014  //���ã�¼��ͨ����Ϣ


#define NET_DVR_MOUNT_DISK                        6015     // ���ش���
#define NET_DVR_UNMOUNT_DISK                    6016     // ж�ش���

// CVR 
#define NET_DVR_GET_STREAM_SRC_INFO                6017  //��ȡ������Դ��Ϣ
#define NET_DVR_SET_STREAM_SRC_INFO                6018  //���ã�����Դ��Ϣ
#define NET_DVR_GET_STREAM_RECORD_INFO            6019  //��ȡ����¼����Ϣ
#define NET_DVR_SET_STREAM_RECORD_INFO            6020  //���ã���¼����Ϣ
#define NET_DVR_GET_STREAM_RECORD_STATUS        6021  //��ȡ����¼��״̬
#define NET_DVR_SET_STREAM_RECORD_STATUS        6022  //���ã���¼��״̬
#define NET_DVR_GET_STREAM_INFO                    6023  //��ȡ����ӵ���ID��Ϣ
#define NET_DVR_GET_STREAM_SRC_INFO_V40            6024  //��ȡ������Դ��Ϣ
#define NET_DVR_SET_STREAM_SRC_INFO_V40          6025  //���ã�����Դ��Ϣ
#define NET_DVR_GET_RELOCATE_INFO               6026  //��ȡN+0ģʽ���ض�����Ϣ
#define NET_DVR_START_GOP_INFO_PASSBACK         6032  //������Ϣ����
#define NET_DVR_GET_CHANS_RECORD_STATUS_CFG     6035    //��ȡͨ��¼��״̬��Ϣ
#define NET_DVR_SET_CHANS_RECORD_STATUS_CFG     6036    //����ͨ��¼��״̬��Ϣ
//NVR��96xx
#define NET_DVR_GET_IP_ALARM_GROUP_NUM          6100  //��ȡ��IPͨ�����������������
#define NET_DVR_GET_IP_ALARM_IN                 6101  //��ȡ��IPͨ������������Ϣ
#define NET_DVR_GET_IP_ALARM_OUT                6102  //��ȡ��IPͨ�����������Ϣ

//9000 v2.2
#define NET_DVR_GET_FTPCFG_SECOND                6103      //��ȡͼƬ�ϴ�FTP����
#define NET_DVR_SET_FTPCFG_SECOND                6104      //����ͼƬ�ϴ�FTP����

#define NET_DVR_GET_DEFAULT_VIDEO_EFFECT        6105       // ��ȡ��Ƶ����Ч������Ĭ��ֵ
#define NET_DVR_SET_VIDEO_EFFECT                6106       // ����ͨ����Ƶ����ͼ�����
#define NET_DVR_DEL_INVALID_DISK                6107       // ɾ����Ч����

#define NET_DVR_GET_DRAWFRAME_DISK_QUOTA_CFG    6109    //��ȡ��֡ͨ���������
#define NET_DVR_SET_DRAWFRAME_DISK_QUOTA_CFG    6110    //���ó�֡ͨ���������

#define NET_DVR_GET_NAT_CFG                     6111     //��ȡNATӳ�����
#define NET_DVR_SET_NAT_CFG                     6112     //����NATӳ�����  
#define NET_DVR_GET_AES_KEY                     6113     //��ȡ�豸AES������Կ
#define NET_DVR_GET_POE_CFG                     6114     //��ȡPOE����
#define NET_DVR_SET_POE_CFG                     6115     //����POE����
#define NET_DVR_GET_CUSTOM_PRO_CFG              6116     //��ȡ�Զ���Э�����
#define NET_DVR_SET_CUSTOM_PRO_CFG              6117     //�����Զ���Э�����
#define NET_DVR_GET_STREAM_CABAC                6118     //��ȡ����ѹ������ѡ��
#define NET_DVR_SET_STREAM_CABAC                6119     //��������ѹ������ѡ��   
#define NET_DVR_GET_ESATA_MINISAS_USAGE_CFG        6120  //��ȡeSATA��miniSAS��;
#define NET_DVR_SET_ESATA_MINISAS_USAGE_CFG        6121  //����eSATA��miniSAS��; 

#define NET_DVR_GET_HDCFG_V40                    6122  //��ȡӲ����Ϣ����
#define NET_DVR_SET_HDCFG_V40                    6123  //����Ӳ����Ϣ����
#define NET_DVR_GET_POE_CHANNEL_ADD_MODE        6124     //��ȡPOEͨ����ӷ�ʽ
#define NET_DVR_SET_POE_CHANNEL_ADD_MODE        6125     //����POEͨ����ӷ�ʽ
#define NET_DVR_GET_DIGITAL_CHANNEL_STATE       6126     //��ȡ�豸����ͨ��״̬
#define   NET_DVR_GET_BONJOUR_CFG               6127 // ��ȡBonjour��Ϣ
#define   NET_DVR_SET_BONJOUR_CFG               6128 // ����Bonjour��Ϣ


#define NET_DVR_GET_SOCKS_CFG                    6130//��ȡSOCKS��Ϣ 
#define NET_DVR_SET_SOCKS_CFG                      6131//����SOCKS��Ϣ

#define    NET_DVR_GET_QOS_CFG                        6132//��ȡQoS��Ϣ
#define NET_DVR_SET_QOS_CFG                        6133//����QoS��Ϣ

#define NET_DVR_GET_HTTPS_CFG                    6134//��ȡHTTPS��Ϣ
#define NET_DVR_SET_HTTPS_CFG                    6135//����HTTPS��Ϣ

#define NET_DVR_GET_WD1_CFG                     6136//Զ�̻�ȡWD1ʹ�ܿ���
#define NET_DVR_SET_WD1_CFG                     6137//Զ������WD1ʹ�ܿ���

#define NET_DVR_CREATE_CERT                     6138//����֤��
#define NET_DVR_DELETE_CERT                     6139//ɾ��֤��


#define NET_DVR_GET_RECORD_LOCK_PERCENTAGE        6140  //��ȡ¼�����������
#define NET_DVR_SET_RECORD_LOCK_PERCENTAGE      6141  //����¼�����������

#define NET_DVR_CMD_TRIGGER_PERIOD_RECORD        6144 //�ⲿ�����ָ��ʱ��¼��
#define NET_DVR_UPLOAD_CERT                     6145    //�ϴ�֤��
#define NET_DVR_DOWNLOAD_CERT                   6146     //����֤��
#define NET_DVR_GET_CERT                        6147     //��ȡ֤��

#define NET_DVR_GET_POS_FILTER_CFG                6148    //��ȡPOS���˹���
#define NET_DVR_SET_POS_FILTER_CFG                6149    //����POS���˹���
#define NET_DVR_GET_CONNECT_POS_CFG                6150    //��ȡDVR��POS���ӷ�ʽ
#define NET_DVR_SET_CONNECT_POS_CFG                6151    //����DVR��POS���ӷ�ʽ
#define NET_DVR_GET_CHAN_FILTER_CFG                6152    //��ȡ������ͨ��������Ϣ
#define NET_DVR_SET_CHAN_FILTER_CFG                6153    //���ù�����ͨ��������Ϣ


#define NET_DVR_GET_FTPCFG_V40                    6162    //��ȡFTP��Ϣ
#define NET_DVR_SET_FTPCFG_V40                    6163    //����FTP��Ϣ

#define NET_DVR_GET_MONTHLY_RECORD_DISTRIBUTION 6164   //��ȡ����¼��ֲ�
#define NET_DVR_GET_ACCESS_DEVICE_CHANNEL_INFO  6165   //��ȡ�������豸ͨ����Ϣ
#define NET_DVR_GET_PREVIEW_SWITCH_CFG            6166   //��ȡ�豸����Ԥ���л�����
#define NET_DVR_SET_PREVIEW_SWITCH_CFG            6167   //�����豸����Ԥ���л�����

//Netra3.0.0
#define NET_DVR_GET_N_PLUS_ONE_WORK_MODE            6168    //��ȡN+1����ģʽ
#define NET_DVR_SET_N_PLUS_ONE_WORK_MODE            6169    //����N+1����ģʽ

#define NET_DVR_GET_HD_STATUS                         6170    //��ȡӲ��״̬
#define NET_DVR_SET_HD_STATUS                         6171    //����Ӳ��״̬

#define NET_DVR_IMPORT_IPC_CFG_FILE                    6172    //����IPC�����ļ�
#define NET_DVR_EXPORT_IPC_CFG_FILE                    6173    //����IPC�����ļ�
#define NET_DVR_UPGRADE_IPC                            6174    //����IPͨ��

#define NET_DVR_GET_RAID_BACKGROUND_TASK_SPEED        6175    //��ȡRAID��̨�����ٶ�
#define NET_DVR_SET_RAID_BACKGROUND_TASK_SPEED        6176    //����RAID��̨�����ٶ�

//marvell 256·NVR
#define NET_DVR_GET_EXCEPTIONCFG_V40                6177    //��ȡ�쳣��������
#define NET_DVR_SET_EXCEPTIONCFG_V40                6178    //�����쳣��������
#define NET_DVR_GET_PICCFG_V40                      6179    //��ȡͼ����� ֧�ֱ䳤    NetSDK_
#define NET_DVR_SET_PICCFG_V40                      6180    //����ͼ������� ֧�ֱ䳤
#define NET_DVR_GET_ALARMINCFG_V40                  6181    //��ȡ�������������֧�ֱ䳤
#define NET_DVR_SET_ALARMINCFG_V40                  6182    //��ȡ�������������֧�ֱ䳤
#define NET_DVR_GET_IPALARMINCFG_V40                6183    //��ȡIP�����������������Ϣ 
#define NET_DVR_GET_IPALARMOUTCFG_V40               6185    //��ȡIP�����������������Ϣ 
#define NET_DVR_GET_USERCFG_V40                     6187    //��ȡ�û�����
#define NET_DVR_SET_USERCFG_V40                     6188    //�����û�����
#define NET_DVR_GET_WORK_STATUS                     6189    //��ȡ�豸����״̬
#define NET_DVR_GET_JPEG_CAPTURE_CFG_V40            6190    //��ȡDVRץͼ����
#define NET_DVR_SET_JPEG_CAPTURE_CFG_V40            6191    //����DVRץͼ����
#define NET_DVR_GET_HDGROUP_CFG_V40                 6192    //��ȡ����������ò���
#define NET_DVR_SET_HDGROUP_CFG_V40                 6193    //��������������ò���
#define NET_DVR_GET_SMD_HOLIDAY_HANDLE              6194    //��ȡ�������ܼ��ռƻ�
#define NET_DVR_SET_SMD_HOLIDAY_HANDLE              6195    //���ü������ܼ��ռƻ�
#define NET_DVR_GET_PIC_MODEL_CFG                   6196    //��ȡͼƬ��ģ���ò���
#define NET_DVR_SET_PIC_MODEL_CFG                   6197    //����ͼƬ��ģ���ò���
#define NET_DVR_START_LOCAL_MOUSE_EVENT             6198    //�����豸��������¼���¼
#define NET_DVR_START_SIMULARE_MOUSE_EVENT          6199    //Զ��ģ������¼�
#define  NET_DVR_GET_WORK_STATUS_V50                6200    //��ȡ�豸����״̬V50

//91ϵ��HD-SDI����DVR
#define NET_DVR_GET_ACCESS_CAMERA_INFO          6201 // ��ȡǰ�������Ϣ
#define NET_DVR_SET_ACCESS_CAMERA_INFO          6202 // ����ǰ�������Ϣ
#define NET_DVR_PULL_DISK                        6203 // ��ȫ����
#define NET_DVR_SCAN_RAID                        6204 // ɨ������
// CVR 2.0.X
#define NET_DVR_GET_USER_RIGHT_CFG                6210        // ��ȡ�û�Ȩ��
#define NET_DVR_SET_USER_RIGHT_CFG                6211        // �����û�Ȩ��

#define NET_DVR_ONE_KEY_CONFIG                    6212        // һ������CVR
#define NET_DVR_RESTART_SERVICE                    6213        // ����CVR����

#define NET_DVR_GET_MAX_MACHINE_NUM_CFG            6214        // ��ȡ����������
#define NET_DVR_SET_MAX_MACHINE_NUM_CFG            6215        // ���ñ���������

#define NET_DVR_ADD_DEVICE                        6216        //N+1ģʽ����豸
#define NET_DVR_DEL_DEVICE                        6217        //N+1ģʽɾ���豸

#define NET_DVR_GET_DATA_CALLBACK_CFG            6218        // ��ȡ���ݻ�Ǩ״̬
#define NET_DVR_SET_DATA_CALLBACK_CFG            6219        // �������ݻ�Ǩ״̬

#define NET_DVR_CLONE_LUN                        6220    //��¡LUN��
#define NET_DVR_EXPAND_LUN                        6221    //��չ��������LUN��

#define NET_DVR_GET_N_PLUS_ONE_DEVICE_INFO        6222    //��ȡN+1�豸��Ϣ
#define NET_DVR_MODIFY_DVR_NET_DISK                6223    //�޸�DVR����
//#define NET_DVR_DEL_DVR_NET_DISK                6224    //ɾ��DVR����

#define NET_DVR_CREATE_NAS                        6225    //����NAS
#define NET_DVR_DELETE_NAS                        6226    //ɾ��NAS 

#define NET_DVR_OPEN_ISCSI                         6227    //����iSCSI
#define NET_DVR_CLOSE_ISCSI                        6228    //�ر�iSCSI 

#define NET_DVR_GET_FC                            6229    //��ȡ������Ϣ
#define NET_DVR_OPEN_FC                             6230    //����FC
#define NET_DVR_CLOSE_FC                         6231    //�ر�FC
#define NET_DVR_ONE_KEY_CONFIG_SAN                6232   // һ������SAN, ��һ������CVR�߼�һ��

//CVR2.3.2
#define NET_DVR_RECORD_CHECK                        6233  //¼�������Լ��
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL        6234  //�ֶ����¼��ش�����
#define NET_DVR_GET_ALL_RECORD_PASSBACK_TASK_MANUAL    6235  //��ȡ�����ֶ����¼��ش�����
#define NET_DVR_RECORD_PASSBACK_TASK_MANUAL_CTRL    6236  //�����ֶ�¼��ش�����
#define NET_DVR_DEL_RECORD_PASSBACK_TASK_MANUAL        6237  //ɾ���ֶ�¼��ش�����
#define NET_DVR_GET_RECORD_PASSBACK_PLAN_CFG        6238  //��ȡ¼��ش��ƻ�����
#define NET_DVR_SET_RECORD_PASSBACK_PLAN_CFG        6239  //����¼��ش��ƻ�����
#define NET_DVR_GET_DEV_STORAGE_CFG                    6240  //��ȡ�豸�洢��Ϣ
#define NET_DVR_GET_ONLINE_USER_CFG                    6241  //��ȡ�����û�����
#define NET_DVR_GET_RECORD_SEGMENT_CFG                6242  //��ȡ¼�������

#define NET_DVR_GET_REC_PASSBACK_TASK_EXECUTABLE    6243    //��ѯ�ֶ�¼��ش������ִ����
#define NET_DVR_GET_STREAM_MEDIA_CFG                6244    //��ȡ��ý��ش�¼��������ã���ID��ʽ��
#define NET_DVR_SET_STREAM_MEDIA_CFG                6245    //������ý��ش�¼��������ã���ID��ʽ��
#define NET_DVR_GET_USERCFG_V50                     6246  //��ȡ�û�����V50
#define NET_DVR_SET_USERCFG_V50                     6247  //�����û�����V50

#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG_CAP    6248  //��ȡCVR�ش����ܻ�����������
#define NET_DVR_GET_RECORD_PASSBACK_BASIC_CFG        6249  //��ȡCVR�ش����ܻ�������
#define NET_DVR_SET_RECORD_PASSBACK_BASIC_CFG        6250  //����CVR�ش����ܻ�������
#define NET_DVR_ONE_KEY_CONFIG_V50                    6251  // һ������CVR(V50)
#define NET_DVR_GET_RACM_CAP                        6252  //��ȡ�洢��������RACM������
#define NET_DVR_GET_THUMBNAILS                        6253  //��ȡ����ͼ��Ĭ����¼�������ͼ��(֧����ID)
#define NET_DVR_ADD_RECORD_PASSBACK_TASK_MANUAL_V50        6254  //�ֶ����¼��ش�����V50����������ID��
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG_CAP    6255  //��ȡCVR�ش���ʷ¼��ƻ�����
#define NET_DVR_GET_RECORD_PASSBACK_HISTORY_PLAN_CFG        6256  //��ȡCVR�ش���ʷ¼��ƻ�����
#define NET_DVR_SET_RECORD_PASSBACK_HISTORY_PLAN_CFG        6257  //����CVR�ش���ʷ¼��ƻ�����
#define NET_DVR_ONE_KEY_CONFIG_V51                          6258  // һ������CVR(V51)


#define NET_DVR_GET_RECORD_PACK                    6301    //��ȡ¼��������
#define NET_DVR_SET_RECORD_PACK                    6302    //����¼��������

#define NET_DVR_GET_CLOUD_STORAGE_CFG           6303     //��ȡ�豸��ǰ����ģʽ
#define NET_DVR_SET_CLOUD_STORAGE_CFG           6304    //�����豸��ǰ����ģʽ
#define NET_DVR_GET_GOP_INFO                    6305    //��ȡGOP��Ϣ 
#define NET_DVR_GET_PHY_DISK_INFO               6306     //��ȡ���������Ϣ
//¼�������ⲿ����
#define NET_DVR_GET_RECORDING_AUTO_TRACK_CFG    6307    //��ȡSDI�Զ�����������Ϣ
#define NET_DVR_SET_RECORDING_AUTO_TRACK_CFG    6308    //����SDI�Զ�����������Ϣ

#define NET_DVR_GET_RECORDING_PUBLISH_CFG        6309  //��ȡһ��������Ϣ 
#define NET_DVR_SET_RECORDING_PUBLISH_CFG        6310  //����һ��������Ϣ


#define NET_DVR_RECORDING_ONEKEY_CONTROL        6311  //¼����������

#define NET_DVR_GET_RECORDING_END_TIME    6312  //��ȡ¼��ʣ��ʱ��

#define NET_DVR_RECORDING_PUBLISH                6313  //һ������¼��

#define NET_DVR_GET_CURRICULUM_CFG            6314    //��ȡ�α�������Ϣ
#define NET_DVR_SET_CURRICULUM_CFG            6315  //���ÿα�������Ϣ

#define NET_DVR_GET_COURSE_INDEX_CFG        6316    //��ȡ�γ���Ϣ����
#define NET_DVR_SET_COURSE_INDEX_CFG        6317  //���ÿγ���Ϣ����

#define    NET_DVR_GET_PPT_CHANNEL                6318    //��ȡPPT֧��ͨ����
#define    NET_DVR_GET_PPT_DETECT_CFG            6319    //��ȡPPT������
#define    NET_DVR_SET_PPT_DETECT_CFG            6320    //����PPT������

#define NET_DVR_GET_RECORDINGHOST_CFG            6321    //��ȡ¼������������Ϣ
#define NET_DVR_SET_RECORDINGHOST_CFG            6322    //����¼������������Ϣ
#define NET_DVR_GET_BACKUP_RECORD_CFG           6323    //��ȡһ������������Ϣ
#define NET_DVR_SET_BACKUP_RECORD_CFG           6324    //����һ������������Ϣ

//ͥ������
#define NET_DVR_GET_AUDIO_ACTIVATION_CFG        6326    //��ȡ�����������ò���
#define NET_DVR_SET_AUDIO_ACTIVATION_CFG        6327    //���������������ò���
#define NET_DVR_GET_DECODERCFG_V40              6328    //��ȡ������������Ϣ
#define NET_DVR_SET_DECODERCFG_V40                6329    //���ý�����������Ϣ

#define NET_DVR_INFRARED_OUTPUT_CONTROL         6330   //�����������
#define NET_DVR_GET_INFRARED_CMD_NAME_CFG       6331   //��ȡ�����������Ʋ�������
#define NET_DVR_SET_INFRARED_CMD_NAME_CFG       6332   //���ú����������Ʋ�������
#define NET_DVR_START_INFRARED_LEARN            6333   //Զ�̺���ѧ��

#define NET_DVR_GET_TRIAL_SYSTEM_CFG            6334   //��ȡͥ������ϵͳ��Ϣ
#define NET_DVR_SET_CASE_INFO                    6335    //������Ϣ¼��
#define NET_DVR_GET_TRIAL_MICROPHONE_STATUS        6336  //��ȡ��˷�״̬��Ϣ
#define NET_DVR_SET_TRIAL_MICROPHONE_STATUS        6337  //��ȡ��˷�״̬��Ϣ
#define NET_DVR_GET_TRIAL_HOST_STATUS            6338  //��ȡͥ������״̬��Ϣ
#define NET_DVR_GET_LAMP_OUT                    6339  //��ȡLAMP�������Ϣ
#define NET_DVR_SET_LAMP_OUT                    6340  //����LAMP�������Ϣ
#define NET_DVR_LAMP_REMOTE_CONTROL                6341  // LAMP����
#define NET_DVR_REMOTE_CONTROL_PLAY                6342  //Զ�̿��Ʊ��ػط�
#define NET_DVR_GET_LOCAL_INPUT_CFG                6343  //��ȡͥ������״̬��Ϣͥ����������������Ϣ
#define NET_DVR_SET_LOCAL_INPUT_CFG                6344  //����ͥ����������������Ϣ
#define NET_DVR_GET_CASE_INFO                    6345  //��ȡ��ǰ������Ϣ

//��Ѷ���ⲿ����
#define NET_DVR_INQUEST_GET_CDW_STATUS             6350  //��ȡ��Ѷ����¼״̬-������
#define NET_DVR_GET_MIX_AUDIOIN_CFG             6351  //��ȡ��������ڲ�������
#define NET_DVR_SET_MIX_AUDIOIN_CFG             6352  //���û�������ڲ�������
#define NET_DVR_GET_MIX_AUDIOOUT_CFG            6353  //��ȡ��������ڲ�������
#define NET_DVR_SET_MIX_AUDIOOUT_CFG            6354  //���û�������ڲ�������
#define NET_DVR_GET_AUDIOIN_VOLUME_CFG          6355  //��ȡ��Ƶ������������ڲ�������
#define NET_DVR_SET_AUDIOIN_VOLUME_CFG          6356  //������Ƶ������������ڲ�������
#define NET_DVR_GET_AREA_MASK_CFG               6357  //��ȡ��������������
#define NET_DVR_SET_AREA_MASK_CFG               6358  //������������������
#define NET_DVR_GET_AUDIO_DIACRITICAL_CFG       6359  //��ȡ��Ƶ��������
#define NET_DVR_SET_AUDIO_DIACRITICAL_CFG       6360  //������Ƶ��������
#define NET_DVR_GET_WIFI_DHCP_ADDR_CFG          6361  //��WIFI DHCP ��ַ��Χ��������
#define NET_DVR_SET_WIFI_DHCP_ADDR_CFG          6362  //��WIFI DHCP ��ַ��Χ��������
#define NET_DVR_GET_WIFI_CLIENT_LIST_INFO       6363  //��ȡwifi�ȵ������ӵ��豸��Ϣ
#define NET_DVR_REMOTECONTROL_POWER_ON            6364  //Զ�̿���
#define NET_DVR_GET_MULTISTREAM_RELATION_CHAN_CFG      6365  //��ȡ����������ͨ����������
#define NET_DVR_SET_MULTISTREAM_RELATION_CHAN_CFG     6366  //���ö���������ͨ����������
#define NET_DVR_GET_VIDEOOUT_RESOLUTION_CFG        6367  //��ȡ�豸������Ƶ����ڷֱ���
#define NET_DVR_SET_VIDEOOUT_RESOLUTION_CFG        6368  //�����豸������Ƶ����ڷֱ���
#define NET_DVR_GET_AUDIOOUT_VOLUME_CFG         6369  //��ȡ��Ƶ������������ڲ�������
#define NET_DVR_SET_AUDIOOUT_VOLUME_CFG         6370  //������Ƶ������������ڲ�������
#define NET_DVR_INQUEST_PAUSE_CDW               6371  //��ͣ��¼
#define NET_DVR_INQUEST_RESUME_CDW              6372  //�ָ���¼
#define NET_DVR_GET_INPUT_CHAN_CFG              6373  //��ȡ����ͨ������
#define NET_DVR_SET_INPUT_CHAN_CFG              6374  //��������ͨ������
#define  NET_DVR_GET_INQUEST_MIX_AUDIOIN_CFG    6375    //��ȡ��Ѷ����Ƶ�����������
#define  NET_DVR_SET_INQUEST_MIX_AUDIOIN_CFG    6376    //������Ѷ����Ƶ�����������
#define     NET_DVR_CASE_INFO_CTRL                    6377    //������Ϣ��ʾ����
#define  NET_DVR_GET_INQUEST_USER_RIGHT            6378    //��ȡ��Ѷ���û�Ȩ��
#define  NET_DVR_SET_INQUEST_USER_RIGHT            6379    //������Ѷ���û�Ȩ��
#define NET_DVR_GET_INQUEST_CASE_INFO            6380    //��ȡ��Ѷ������Ϣ����
#define NET_DVR_SET_INQUEST_CASE_INFO            6381    //������Ѷ������Ϣ����

#define    NET_DVR_GET_FILM_MODE_CFG               6387    //��ȡ��Ӱģʽ
#define    NET_DVR_SET_FILM_MODE_CFG               6388    //���õ�Ӱģʽ
#define    NET_DVR_GET_FILM_MODE_CFG_CAP            6389    //��ȡ��Ӱģʽ��������

#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG       6390    //��ȡ������������
#define    NET_DVR_SET_DIRECTED_STRATEGY_CFG        6391    //���õ�����������
#define    NET_DVR_GET_DIRECTED_STRATEGY_CFG_CAP    6392    //��ȡ��Ӱģʽ��������
#define    NET_DVR_GET_FRAME_CFG                    6393    //��ȡ����߿�
#define    NET_DVR_SET_FRAME_CFG                    6394    //���û���߿�
#define    NET_DVR_GET_FRAME_CFG_CAP                6395    //��ȡ����߿���������
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG            6396    //��ȡ��Ƶ�Ż�����
#define    NET_DVR_SET_AUDIO_EFFECTIVE_CFG            6397    //������ƵЧ������
#define    NET_DVR_GET_AUDIO_EFFECTIVE_CFG_CAP        6398    //��ȡ��ƵЧ���Ż���������
#define    NET_DVR_GET_RECORD_VIDEO_CFG              6399    //��ȡ¼����Ƶ����
#define    NET_DVR_SET_RECORD_VIDEO_CFG            6400    //����¼����Ƶ����


#define NET_DVR_GET_OUTPUT_CFG                  6401        //��ȡ��ʾ�������
#define NET_DVR_SET_OUTPUT_CFG                  6402        //������ʾ�������
#define NET_DVR_CODER_DISPLAY_START             6403        //��ʼ���
#define NET_DVR_CODER_DISPLAY_STOP              6404        //ֹͣ���
#define NET_DVR_GET_WINDOW_STATUS               6405        //��ȡ��ʾ����״̬

//VQD���ܽӿ�
#define NET_DVR_GET_VQD_LOOP_DIAGNOSE_CFG       6406        //��ȡVQDѭ��������ò���
#define NET_DVR_SET_VQD_LOOP_DIAGNOSE_CFG       6407        //����VQDѭ��������ò���
#define NET_DVR_GET_VQD_DIAGNOSE_INFO           6408        //�ֶ���ȡVQD�����Ϣ

#define    NET_DVR_RECORDING_PUBLISH_FILE            6421        //�ļ�����
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_CAP    6422        //��ȡ�ļ���������
#define    NET_DVR_GET_PUBLISH_PROGRESS            6423           //��ȡ��������
#define    NET_DVR_GET_RECORD_VIDEO_CFG_CAP        6424        //��ȡ¼����Ƶ��������
#define    NET_DVR_GET_RTMP_CFG                    6425        //��ȡRTMP����
#define    NET_DVR_SET_RTMP_CFG                    6426        //����RTMP����
#define    NET_DVR_GET_RTMP_CFG_CAP                  6427        //��ȡRTMP��������
#define    NET_DVR_DEL_BACKGROUND_PIC                6428        //ɾ������ͼƬ�ļ�
#define    NET_DVR_GET_BACKGROUND_PIC_CFG            6429        //��ѯ����ͼƬ�ļ�
#define    NET_DVR_GET_BACKGROUND_PIC_INFO            6430        //��ȡ����ͼƬ��Ϊ����ͼƬ
#define    NET_DVR_SET_BACKGROUND_PIC_INFO            6431        //��������ͼƬ��Ϊ����ͼƬ
#define    NET_DVR_GET_BACKGROUND_PIC_INFO_CAP      6432           //��ȡ����ͼƬ��Ϊ����ͼƬ��������
#define    NET_DVR_GET_RECORD_HOST_CAP                6433        //��ȡ¼������������
#define NET_DVR_GET_COURSE_LIST                 6434    //��ȡ�γ��б�
#define    NET_DVR_GET_RECORD_STATUS                6435 //��ѯ¼��������ǰ״̬
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL        6436    //�ֶ��α����
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG        6437    //��ȡͼ���ּ�����
#define    NET_DVR_SET_IMAGE_DIFF_DETECTION_CFG        6438    //����ͼ���ּ�����
#define    NET_DVR_GET_IMAGE_DIFF_DETECTION_CFG_CAP    6439    //��ȡͼ���ּ����������
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO    6440    //��ȡ�����ļ���Ϣ����
#define    NET_DVR_SET_RECORDING_PUBLISH_FILE_INFO    6441    //���÷����ļ���Ϣ����
#define    NET_DVR_GET_RECORDING_PUBLISH_FILE_INFO_CAP        6442    //��ȡ�����ļ���Ϣ��������
#define    NET_DVR_MANUAL_CURRICULUM_CONTROL_CAP        6443    //��ȡ�ֶ��γ�¼�������
#define NET_DVR_GET_STATISTIC_DATA_LIST             6444    //��ȡͳ�������б�

#define    NET_DVR_GET_DEVICE_LAN_ENCODE            6501        //��ȡ�豸�����Ա���
#define NET_DVR_GET_GBT28181_SERVICE_CFG        6503        //��ȡGB28181����������
#define NET_DVR_SET_GBT28181_SERVICE_CFG        6504        //����GB28181����������
#define NET_DVR_GET_GBT28181_SERVICE_CAPABILITIES 6505      //��ȡGB28181����������

#define NET_DVR_GET_CLOUD_URL               6506    //��ȡ�ƴ洢URL
#define NET_DVR_GET_CLOUD_URL_CAP           6507    //��ȡ�ƴ洢URL-������
#define NET_DVR_GET_CLOUD_CFG               6508    //��ȡ�ƴ洢���ò���
#define NET_DVR_SET_CLOUD_CFG               6509    //�����ƴ洢���ò���
#define NET_DVR_GET_CLOUD_CFG_CAP           6510    //��ȡ�ƴ洢����-������
#define NET_DVR_GET_CLOUD_UPLOADSTRATEGY    6511    //��ȡ�ƴ洢�ϴ�����
#define NET_DVR_SET_CLOUD_UPLOADSTRATEGY    6512    //�����ƴ洢�ϴ�����
#define NET_DVR_GET_CLOUDSTORAGE_UPLOADSTRATEGY_CAP     6513    //�ƴ洢�ϴ���������-������

#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG        6601        //��ȡ��ͼ����Ϣ
#define    NET_DVR_SET_VIDEO_IMAGE_DB_CFG        6602        //������ͼ����Ϣ
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CFG_CAP    6603        //��ȡ��ͼ���������
#define    NET_DVR_GET_FILE_INFO_BY_ID            6604        //�����ļ�ID��ȡ��ͼ�����ļ���Ϣ
#define    NET_DVR_QUERY_FILE_INFO_CAP            6605        //�����ļ�����ѯ�ļ���Ϣ����
#define    NET_DVR_DEL_FILE_FROM_DB            6606        //����ͼ����ɾ���ļ�
#define    NET_DVR_GET_VIDEO_IMAGE_DB_CAP        6607        //��ȡ��ͼ��������

#define NET_DVR_GET_FIGURE                    6610       //��ȡ����ͼ

#define    NET_DVR_SYNC_IPC_PASSWD                  6621        //ͬ��IPC������NVRһ��
#define    NET_DVR_GET_VEHICLE_BLACKLST_SCHEDULE 6622    //��ȡ����������ʱ������
#define    NET_DVR_SET_VEHICLE_BLACKLST_SCHEDULE 6623    //���ú���������ʱ������

#define    NET_DVR_GET_VEHICLE_WHITELST_SCHEDULE 6624    //��ȡ����������ʱ������
#define    NET_DVR_SET_VEHICLE_WHITELST_SCHEDULE 6625    //���ð���������ʱ������

#define    NET_DVR_GET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6626    //��ȡ������������������
#define    NET_DVR_SET_VEHICLE_BLACKLIST_EVENT_TRIGGER     6627    //���ú�����������������

#define    NET_DVR_GET_VEHICLE_WHITELIST_EVENT_TRIGGER     6628    //��ȡ������������������
#define    NET_DVR_SET_VEHICLE_WHITELIST_EVENT_TRIGGER     6629    //���ð�����������������

#define    NET_DVR_GET_TRAFFIC_CAP    6630    //��ȡץ�����������
#define    NET_DVR_GET_VEHICLE_ALLLIST_EVENT_TRIGGER     6631    //��ȡȫ��������Ⲽ����������
#define    NET_DVR_SET_VEHICLE_ALLLIST_EVENT_TRIGGER     6632    //����ȫ��������Ⲽ����������
#define    NET_DVR_GET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6633    //��ȡ������������������
#define    NET_DVR_SET_VEHICLE_OTHERLIST_EVENT_TRIGGER     6634    //����������������������

#define    NET_DVR_GET_STORAGEDETECTION_EVENT_TRIGGER     6635    //��ȡ�洢���������������
#define    NET_DVR_SET_STORAGEDETECTION_EVENT_TRIGGER     6636    //���ô洢���������������
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE_CAPABILITIES    6637    //��ȡ�洢������Ⲽ��ʱ������
#define    NET_DVR_GET_STORAGEDETECTION_SCHEDULE         6638    //��ȡ�洢��������ʱ������
#define    NET_DVR_SET_STORAGEDETECTION_SCHEDULE         6639    //���ô洢��������ʱ������
#define    NET_DVR_GET_STORAGEDETECTION_STATE             6640    //��ȡ�洢����״̬

#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK             6646    //��ȡ�洢���Ķ�д������
#define    NET_DVR_GET_STORAGEDETECTION_RWLOCK_CAPABILITIES    6647    //��ȡ�洢���Ķ�д����������
#define    NET_DVR_SET_STORAGEDETECTION_RWLOCK             6648    //���ô洢���Ķ�д������
#define    NET_DVR_GET_PTZTRACKSTATUS                     6649    //��ȡ�����������״̬

#define    NET_DVR_SET_STORAGEDETECTION_UNLOCK             6653    //���ô洢���Ľ�������
#define    NET_DVR_GET_STORAGEDETECTION_UNLOCK_CAPABILITIES    6654    //��ȡ�洢���Ľ�����������

#define    NET_DVR_SET_SHIPSDETECTION_CFG                 6655    //���ô�ֻ����������
#define    NET_DVR_GET_SHIPSDETECTION_CFG                 6656    //��ȡ��ֻ����������
#define    NET_DVR_GET_SHIPSDETECTION_CAPABILITIES         6657    //��ȡ��ֻ��������������
#define    NET_DVR_GET_SHIPSDETECTION_COUNT               6658    //��ȡ��ֻ������Ϣ
#define    NET_DVR_SHIPSCOUNT_DELETE_CTRL                  6659   //��մ�ֻ������Ϣ

#define    NET_DVR_GET_BAREDATAOVERLAY_CAPABILITIES     6660   //��ȡ�����ݵ�������
#define    NET_DVR_SET_BAREDATAOVERLAY_CFG                 6661    //���������ݵ���
#define    NET_DVR_GET_BAREDATAOVERLAY_CFG                 6662    //��ȡ�����ݵ���
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE             6663    //��ȡ��ֻ��Ⲽ��ʱ������
#define    NET_DVR_SET_SHIPSDETECTION_SCHEDULE             6664    //���ô�ֻ��Ⲽ��ʱ������
#define    NET_DVR_GET_SHIPSDETECTION_EVENT_TRIGGER     6665    //��ȡ��ֻ�����������
#define    NET_DVR_SET_SHIPSDETECTION_EVENT_TRIGGER     6666    //���ô�ֻ�����������
#define    NET_DVR_GET_SHIPSDETECTION_SCHEDULE_CAPABILITIES    6667    //��ȡ��ֻ��Ⲽ��ʱ������

#define    NET_DVR_FIRE_FOCUSZOOM_CTRL         6670        //���ɼ��⾵ͷ�۽��䱶

#define    NET_DVR_GET_FIREDETECTION_SCHEDULE_CAPABILITIES    6671 //��ȡ����Ⲽ��ʱ������
#define    NET_DVR_GET_FIREDETECTION_SCHEDULE    6672    //��ȡ����Ⲽ��ʱ������
#define    NET_DVR_SET_FIREDETECTION_SCHEDULE    6673    //���û���Ⲽ��ʱ������
#define    NET_DVR_GET_MANUALRANGING_CAPABILITIES    6675    //��ȡ�ֶ������������
#define    NET_DVR_SET_MANUALRANGING           6677        //�����ֶ�������
#define    NET_DVR_GET_MANUALDEICING_CAPABILITIES    6678//��ȡ�ֶ�������������
#define    NET_DVR_SET_MANUALDEICING           6679        //�����ֶ�����
#define    NET_DVR_GET_MANUALDEICING           6680        //��ȡ�ֶ�����

#define    NET_DVR_GET_THERMALPOWER_CAPABILITIES   6689    //��ȡ�����Դ��������
#define    NET_DVR_GET_THERMALPOWER                6690    //��ȡ�����Դ���ò���
#define    NET_DVR_SET_THERMALPOWER                6691    //���������Դ���ò���
#define    NET_DVR_GET_PTZABSOLUTEEX_CAPABILITIES  6695    //��ȡ�߾���PTZ����λ��������չ����
#define    NET_DVR_GET_PTZABSOLUTEEX               6696    //��ȡ�߾���PTZ����λ��������չ
#define    NET_DVR_SET_PTZABSOLUTEEX               6697    //���ø߾���PTZ����λ��������չ

#define    NET_DVR_GET_CRUISE_CAPABILITIES              6698    //��ȡ�豸Ѳ��ģʽ��������
#define    NET_DVR_GET_CRUISE_INFO                      6699    //��ȡ�豸Ѳ��ģʽ
#define    NET_DVR_GET_TEMP_HUMI_CAPABILITIES           6700    //��ʪ��ʵʱ������ȡ
#define NET_DVR_GET_TEMP_HUMI_INFO                   6701   //��ʪ��ʵʱ��ȡ

#define    NET_DVR_GET_MANUALTHERM_INFO                 6706   //�ֶ�����ʵʱ��ȡ
#define    NET_DVR_GET_MANUALTHERM_CAPABILITIES         6707   //��ȡ�ֶ�����ʵʱ��������
#define    NET_DVR_SET_MANUALTHERM                      6708     //�����ֶ�������������

//DVR96000
#define    NET_DVR_GET_ACCESSORY_CARD_INFO_CAPABILITIES    6709 //��ȡ�������Ϣ����
#define    NET_DVR_GET_ACCESSORY_CARD_INFO                    6710 //��ȡ�������Ϣ

#define    NET_DVR_GET_THERMINTELL_CAPABILITIES    6711         //��ȡ�ȳ������ܻ�������
#define    NET_DVR_GET_THERMINTELL                 6712         //��ȡ�ȳ������ܻ������ò���
#define    NET_DVR_SET_THERMINTELL                 6713         //�����ȳ������ܻ������ò���
#define NET_GET_CRUISEPOINT_V50                      6714 //��ȡѲ��·��������չ
#define    NET_DVR_GET_MANUALTHERM_BASIC_CAPABILITIES     6715   //��ȡ�ֶ����»���������������
#define    NET_DVR_SET_MANUALTHERM_BASICPARAM           6716     //�����ֶ����»�������
#define    NET_DVR_GET_MANUALTHERM_BASICPARAM           6717     //��ȡ�ֶ����»�������

#define    NET_DVR_GET_FIRESHIELDMASK_CAPABILITIES            6718   //��ȡ���������������

#define NET_DVR_GET_HIDDEN_INFORMATION_CAPABILITIES    6720 //������Ϣ��������
#define NET_DVR_GET_HIDDEN_INFORMATION                 6721 //��ȡ������Ϣ����
#define NET_DVR_SET_HIDDEN_INFORMATION                 6722 //����������Ϣ����

#define    NET_DVR_SET_FIRESHIELDMASK_CFG                  6723    //���û���������β���
#define    NET_DVR_GET_FIRESHIELDMASK_CFG                  6724     //��ȡ����������β���

#define    NET_DVR_GET_SMOKESHIELDMASK_CAPABILITIES            6725   //��ȡ����������������
#define    NET_DVR_SET_SMOKESHIELDMASK_CFG                     6726     //���������������β���
#define    NET_DVR_GET_SMOKESHIELDMASK_CFG                     6727        //��ȡ�����������β���

#define    NET_DVR_GET_AREASCAN_CAPABILITIES                  6728   //��ȡ����ɨ������
#define    NET_DVR_GET_AREASCAN_CFG                          6730        //��ȡ����ɨ�����

#define    NET_DVR_DEL_AREASCAN_CFG                          6731        //ɨ������ɾ��
#define    NET_DVR_AREASCAN_INIT_CTRL                        6732        //��������ɨ������
#define    NET_DVR_AREASCAN_CONFIRM_CTRL                     6733        //��������ɨ������
#define    NET_DVR_AREASCAN_STOP_CTRL                        6734        //ֹͣ����ɨ������
#define    NET_DVR_SAVE_SCANZOOM_CTRL                        6735        //����ɨ�豶�ʣ����浱ǰ��ѧ����Ϊɨ�豶��
#define    NET_DVR_GET_SCANZOOM_CTRL                         6736        //��ȡɨ�豶�ʣ���Ԥ�������еĹ�ѧ���ʷ��ص���ǰɨ�豶�ʡ�
#define    NET_DVR_DEL_FIRESHIELDMASK_CTRL                   6737        //ɾ�������������
#define    NET_DVR_DEL_SMOKESHIELDMASK_CTRL                  6738        //ɾ��������������

#define    NET_DVR_GET_DENSEFOG_EVENT_TRIGGER                6740     //��ȡ��������������
#define    NET_DVR_SET_DENSEFOG_EVENT_TRIGGER                6741     //���ô�������������
#define    NET_DVR_SET_DENSEFOGDETECTION_CFG                 6742     //���ô������������
#define    NET_DVR_GET_DENSEFOGDETECTION_CFG                 6743     //��ȡ�������������
#define    NET_DVR_GET_DENSEFOGDETECTION_CAPABILITIES        6744     //��ȡ�����������������

#define    NET_DVR_GET_THERMOMETRY_SCHEDULE_CAPABILITIES     6750     //��ȡ���¼�Ⲽ��ʱ������
#define    NET_DVR_GET_THERMOMETRY_SCHEDULE                  6751     //��ȡ���¼�Ⲽ��ʱ������
#define    NET_DVR_SET_THERMOMETRY_SCHEDULE                  6752     //���ò��¼�Ⲽ��ʱ������
#define    NET_DVR_GET_TEMPERTURE_SCHEDULE_CAPABILITIES      6753     //��ȡ�²��ʱ������
#define    NET_DVR_GET_TEMPERTURE_SCHEDULE                   6754     //��ȡ�²��ʱ������
#define    NET_DVR_SET_TEMPERTURE_SCHEDULE                   6755     //�����²��ʱ������
#define NET_DVR_GET_SEARCH_LOG_CAPABILITIES               6756     //��־����֧������
#define    NET_DVR_GET_VEHICLEFLOW                           6758     //��ȡ����������
#define NET_DVR_GET_IPADDR_FILTERCFG_V50                  6759     //��ȡIP��ַ���˲�����չ
#define NET_DVR_SET_IPADDR_FILTERCFG_V50                  6760     //����IP��ַ���˲�����չ
#define    NET_DVR_GET_TEMPHUMSENSOR_CAPABILITIES            6761     //��ȡ��ʪ�ȴ�����������
#define    NET_DVR_GET_TEMPHUMSENSOR                         6762     //��ȡ��ʪ�ȴ���������Э��
#define    NET_DVR_SET_TEMPHUMSENSOR                         6763     //������ʪ�ȴ���������Э��

#define    NET_DVR_GET_THERMOMETRY_MODE_CAPABILITIES  6764  //��ȡ����ģʽ����
#define    NET_DVR_GET_THERMOMETRY_MODE               6765  //��ȡ����ģʽ����
#define    NET_DVR_SET_THERMOMETRY_MODE               6766  //���ò���ģʽ����

#define    NET_DVR_GET_THERMAL_PIP_CAPABILITIES    6767    //��ȡ�ȳ����л���������
#define    NET_DVR_GET_THERMAL_PIP   6768    //��ȡ�ȳ����л����ò���
#define    NET_DVR_SET_THERMAL_PIP   6769    //�����ȳ����л����ò���
#define    NET_DVR_GET_THERMAL_INTELRULEDISPLAY_CAPABILITIES    6770    //��ȡ�ȳ������ܹ�����ʾ����
#define    NET_DVR_GET_THERMAL_INTELRULE_DISPLAY   6771    //��ȡ�ȳ������ܹ�����ʾ����
#define    NET_DVR_SET_THERMAL_INTELRULE_DISPLAY   6772    //�����ȳ������ܹ�����ʾ����
#define    NET_DVR_GET_THERMAL_ALGVERSION   6773   //��ȡ�ȳ�������㷨��汾
#define    NET_DVR_GET_CURRENT_LOCK_CAPABILITIES    6774    //��ȡ����������������
#define    NET_DVR_GET_CURRENT_LOCK   6775    //��ȡ�����������ò���
#define    NET_DVR_SET_CURRENT_LOCK   6776    //���õ����������ò���

#define    NET_DVR_DEL_MANUALTHERM_RULE                      6778     //ɾ���ֶ����¹���

#define NET_DVR_GET_UPGRADE_INFO    6779    //��ȡ������Ϣ

#define    NET_DVR_SWITCH_TRANSFER  7000  

#define NET_DVR_GET_MB_POWERCTRLPARA            8000//��ȡ�������Ʋ���
#define    NET_DVR_SET_MB_POWERCTRLPARA            8001 //�����������Ʋ���
#define NET_DVR_GET_AUTOBACKUPPARA                8002//��ȡ�Զ����ݲ���
#define NET_DVR_SET_AUTOBACKUPPARA                8003 //�����Զ����ݲ���
#define NET_DVR_GET_MB_GPSPARA                    8004//��ȡGPS����
#define NET_DVR_SET_MB_GPSPARA                    8005 //����GPS����
#define NET_DVR_GET_MB_SENSORINPARA                8006//��ȡSENSOR����
#define NET_DVR_SET_MB_SENSORINPARA                8007 //����SENSOR����
#define NET_DVR_GET_GSENSORPARA                    8008//��ȡGSENSOR����
#define NET_DVR_SET_GSENSORPARA                    8009 //����GSENSOR����
#define NET_DVR_GET_MB_DOWNLOADSVRPARA            8010//��ȡ���ط���������
#define NET_DVR_SET_MB_DOWNLOADSVRPARA            8011//�������ط���������
#define NET_DVR_GET_PLATERECOG_PARA                8012//��ȡ����ʶ�����
#define NET_DVR_SET_PLATERECOG_PARA                8013//���ó���ʶ�����
#define NET_DVR_GET_ENFORCESYS_PARA                8014//��ȡ�����������
#define NET_DVR_SET_ENFORCESYS_PARA                8015//���ó����������
#define NET_DVR_GET_GPS_DATA                    8016 //��ȡGPS����
#define NET_DVR_GET_ANALOG_ALARMINCFG            8017//��ȡģ�ⱨ���������
#define NET_DVR_SET_ANALOG_ALARMINCFG            8018//����ģ�ⱨ���������

#define NET_DVR_GET_SYSTEM_CAPABILITIES         8100 //��ȡ�豸��ϵͳ����
#define NET_DVR_GET_EAGLEEYE_CAPABILITIES       8101 //��ȡ�豸ӥ������
#define NET_DVR_GET_SLAVECAMERA_CALIB_V51       8102    //��ȡ��������궨����V51
#define NET_DVR_SET_SLAVECAMERA_CALIB_V51       8103    //���ô�������궨����V51
#define NET_DVR_SET_GOTOSCENE                   8105  //�����������ת��ָ���ĳ���ID

//I��K��Eϵ��NVR��Ʒ����
#define NET_DVR_GET_PTZ_NOTIFICATION        8201//��ȡ��ͨ���¼�����PTZ
#define NET_DVR_SET_PTZ_NOTIFICATION        8202//���ö�ͨ���¼�����PTZ
/*****************************����ǽ start****************************/
#define    NET_DVR_MATRIX_WALL_SET                    9001  //���õ���ǽ����Ļ����
#define    NET_DVR_MATRIX_WALL_GET                    9002  //��ȡ����ǽ����Ļ����
#define    NET_DVR_WALLWIN_GET                        9003  //����ǽ�л�ȡ���ڲ���
#define    NET_DVR_WALLWIN_SET                        9004  //����ǽ�����ô��ڲ���
#define    NET_DVR_WALLWINPARAM_SET                9005  //���õ���ǽ������ز���
#define    NET_DVR_WALLWINPARAM_GET                9006  //��ȡ����ǽ������ز���
#define NET_DVR_WALLSCENEPARAM_GET                9007  //���ó���ģʽ����
#define NET_DVR_WALLSCENEPARAM_SET                9008  //��ȡ����ģʽ����
#define NET_DVR_MATRIX_GETWINSTATUS             9009  //��ȡ���ڽ���״̬
#define    NET_DVR_GET_WINASSOCIATEDDEVINFO        9010  //����ǽ�л�ȡ��Ӧ��Դ��Ϣ
#define    NET_DVR_WALLOUTPUT_GET                    9011  //����ǽ�л�ȡ��ʾ�������
#define    NET_DVR_WALLOUTPUT_SET                    9012  //����ǽ��������ʾ�������
#define NET_DVR_GET_UNITEDMATRIXSYSTEM          9013  //����ǽ�л�ȡ��Ӧ��Դ
#define NET_DVR_GET_WALL_CFG                    9014  //��ȡ����ǽȫ�ֲ���
#define NET_DVR_SET_WALL_CFG                    9015  //���õ���ǽȫ�ֲ���
#define NET_DVR_CLOSE_ALL_WND                    9016  //�ر����д���
#define NET_DVR_SWITCH_WIN_TOP                  9017  //�����ö�
#define NET_DVR_SWITCH_WIN_BOTTOM               9018  //�����õ�

#define    NET_DVR_CLOSE_ALL_WND_V41                9019  //����ǽ�ر����д���v41���ж������ǽ��
#define    NET_DVR_GET_WALL_WINDOW_V41                9020  //��ȡ����ǽ�еĴ���v41
#define    NET_DVR_SET_WALL_WINDOW_V41                9021  //���õ���ǽ�еĴ���v41
#define    NET_DVR_GET_CURRENT_SCENE_V41            9022  //��ȡ��ǰ����ǽ������ʹ�õĳ���v41
#define    NET_DVR_GET_WALL_SCENE_PARAM_V41        9023  //��ȡ��ǰ����ǽ������ʹ�õĳ���v41
#define    NET_DVR_SET_WALL_SCENE_PARAM_V41        9024  //���õ�ǰ����ǽ������ʹ�õĳ���v41
#define NET_DVR_GET_MATRIX_LOGO_CFG             9025  //��ȡlogo����
#define NET_DVR_SET_MATRIX_LOGO_CFG             9026  //����logo����
#define NET_DVR_GET_WIN_LOGO_CFG                9027  //��ȡ����logo����
#define NET_DVR_SET_WIN_LOGO_CFG                9028  //���ô���logo����
#define NET_DVR_DELETE_LOGO                     9029  //ɾ��logo
#define NET_DVR_SET_DISPLAY_EFFECT_CFG            9030  //������ʾ���Ч������v41
#define NET_DVR_GET_DISPLAY_EFFECT_CFG            9031  //��ȡ��ʾ���Ч������v41
#define NET_DVR_DEC_PLAY_REMOTE_FILE            9032  //���벥��Զ���ļ�
#define NET_DVR_DEC_PLAY_REMOTE_FILE_V50        9314  //���벥��Զ���ļ�V50
#define NET_DVR_GET_WIN_ZOOM_STATUS             9033  //��ȡ���ڵ��ӷŴ�״̬
#define NET_DVR_GET_ALL_MATRIX_LOGOCFG          9034  //��ȡ����logo����

/*****************************����ǽ end******************************/

/*******************************LCDƴ���� begin******************************************/
#define NET_DVR_SIMULATE_REMOTE_CONTROL         9035    //ģ��ң�ذ��� 2013-09-05
#define NET_DVR_SET_SCREEN_SIGNAL_CFG            9036    //������Ļ�ź�Դ����
#define    NET_DVR_GET_SCREEN_SIGNAL_CFG            9037    //��ȡ��Ļ�ź�Դ����
#define NET_DVR_SET_SCREEN_SPLICE_CFG              9038    //������Ļƴ��
#define    NET_DVR_GET_SCREEN_SPLICE_CFG            9039    //��ȡ��Ļƴ��
#define NET_DVR_GET_SCREEN_FAN_WORK_MODE         9040    //��ȡ���ȹ�����ʽ
#define NET_DVR_SET_SCREEN_FAN_WORK_MODE         9041    //���÷��ȹ�����ʽ
#define NET_DVR_SHOW_SCREEN_WORK_STATUS          9044    //��ʾ��Ļ״̬
#define NET_DVR_GET_VGA_CFG                      9045    //��ȡVGA�ź�����
#define NET_DVR_SET_VGA_CFG                      9046    //����VGA�ź�����
#define NET_DVR_GET_SCREEN_MENU_CFG                9048   //��ȡ��Ļ�˵�����
#define NET_DVR_SET_SCREEN_MENU_CFG              9049    //������Ļ�˵�����
#define NET_DVR_SET_SCREEN_DISPLAY_CFG          9050    //������ʾ���� 2013-08-28
#define    NET_DVR_GET_SCREEN_DISPLAY_CFG            9051    //��ȡ��ʾ���� 2013-08-28

#define NET_DVR_SET_FUSION_CFG                    9052    //����ͼ���ںϲ���
#define NET_DVR_GET_FUSION_CFG                    9053    //��ȡͼ���ںϲ���

#define NET_DVR_SET_PIP_CFG                      9060    //���û��л�����
#define    NET_DVR_GET_PIP_CFG                        9061    //��ȡ���л�����
#define NET_DVR_SET_DEFOG_LCD                      9073    //����͸�����
#define    NET_DVR_GET_DEFOG_LCD                    9074    //��ȡ͸�����
#define NET_DVR_SHOW_IP                          9075    //��ʾIP
#define NET_DVR_SCREEN_MAINTENANCE_WALL            9076    //��Ļάǽ
#define NET_DVR_SET_SCREEN_POS                  9077    //������Ļλ�ò���
#define    NET_DVR_GET_SCREEN_POS                    9078    //��ȡ��Ļλ�ò���
/*******************************LCDƴ���� end******************************************/

/*******************************LCDƴ����V1.2 begin******************************************/
#define    NET_DVR_SCREEN_INDEX_SET                9079    //��Ļ������ز�������
#define    NET_DVR_SCREEN_INDEX_GET                9080    //��Ļ������ز�����ȡ
#define NET_DVR_SCREEN_SPLICE_SET               9081    //������Ļƴ�Ӳ���
#define NET_DVR_SCREEN_SPLICE_GET               9082    //��ȡ��Ļƴ�Ӳ���
#define NET_DVR_SET_SCREEN_PARAM                9083    //������Ļ��ز���
#define NET_DVR_GET_SCREEN_PARAM                9084    //��ȡ��Ļ��ز���
#define NET_DVR_SET_SWITCH_CFG                  9085    //���ö�ʱ���ػ�����
#define NET_DVR_GET_SWITCH_CFG                  9086    //��ȡ��ʱ���ػ�����
#define NET_DVR_SET_POWERON_DELAY_CFG           9087    //������ʱ��������
#define NET_DVR_GET_POWERON_DELAY_CFG           9088    //��ȡ��ʱ��������
#define    NET_DVR_SET_SCREEN_POSITION                9089    //������Ļλ�ò���
#define    NET_DVR_GET_SCREEN_POSITION                9090    //��ȡ��Ļλ�ò���
#define NET_DVR_SCREEN_SCENE_CONTROL            9091    //��Ļ��������
#define NET_DVR_GET_CURRENT_SCREEN_SCENE        9092    //��ȡ��ǰ��Ļ������
#define NET_DVR_GET_SCREEN_SCENE_PARAM          9093    //��ȡ��Ļ����ģʽ����
#define NET_DVR_SET_SCREEN_SCENE_PARAM          9094    //������Ļ����ģʽ����
#define NET_DVR_GET_EXTERNAL_MATRIX_RELATION    9095    //��ȡ��Ӿ����������������ϵ
#define NET_DVR_GET_LCD_AUDIO_CFG                9096     //��ȡLCD��Ļ��Ƶ����
#define NET_DVR_SET_LCD_AUDIO_CFG                9097     //����LCD��Ļ��Ƶ����
#define NET_DVR_GET_LCD_WORK_STATE                9098     //��ȡLCD��Ļ����״̬
#define NET_DVR_GET_BOOT_LOGO_CFG                9099    //��ȡLCD��Ļ����logo��ʾ����
#define NET_DVR_SET_BOOT_LOGO_CFG                9100    //����LCD��Ļ����logo��ʾ����

/*******************************LCDƴ����V1.2 end ******************************************/
#define NET_DVR_GET_STREAM_DST_COMPRESSIONINFO    9101  //��ȡĿ��ѹ������
#define NET_DVR_SET_STREAM_DST_COMPRESSIONINFO  9102  //����Ŀ��ѹ������
#define NET_DVR_GET_STREAM_TRANS_STATUS            9103  //��ȡ��״̬
#define NET_DVR_GET_DEVICE_TRANS_STATUS            9104  //��ȡ�豸ת��״̬
#define NET_DVR_GET_ALLSTREAM_SRC_INFO          9105  //��ȡ��������Ϣ
#define NET_DVR_GET_BIG_SCREEN_AUDIO            9106  //��ȡ������Ƶ��Ϣ
#define NET_DVR_SET_BIG_SCREEN_AUDIO            9107  //���ô�����Ƶ��Ϣ
#define NET_DVR_GET_DEV_WORK_MODE                9108  //��ȡת���豸����ģʽ
#define NET_DVR_SET_DEV_WORK_MODE                9109  //����ת���豸����ģʽ
#define NET_DVR_APPLY_TRANS_CHAN                9110  //����ID����ת��ͨ��
#define NET_DVR_GET_DISPCHAN_CFG                9111  //������ȡ��ʾͨ������
#define NET_DVR_SET_DISPCHAN_CFG                9112  //����������ʾͨ������

#define NET_DVR_GET_DEC_CHAN_STATUS                9113  //��ȡ����ͨ������״̬
#define NET_DVR_GET_DISP_CHAN_STATUS            9114  //��ȡ��ʾͨ��״̬        
#define NET_DVR_GET_ALARMIN_STATUS                9115  //��ȡ��������״̬
#define NET_DVR_GET_ALARMOUT_STATUS                9116  //��ȡ�������״̬
#define NET_DVR_GET_AUDIO_CHAN_STATUS            9117  //��ȡ�����Խ�״̬

#define    NET_DVR_GET_VIDEO_AUDIOIN_CFG            9118   //��ȡ��Ƶ����Ƶ�������
#define NET_DVR_SET_VIDEO_AUDIOIN_CFG            9119   //������Ƶ����Ƶ�������

#define    NET_DVR_SET_BASEMAP_CFG                    9120  //���õ�ͼ����
#define NET_DVR_GET_BASEMAP_CFG                    9121  //��ȡ��ͼ����
#define NET_DVR_GET_VIRTUAL_SCREEN_CFG          9122  //��ȡ������������ϵͳ����
#define NET_DVR_SET_VIRTUAL_SCREEN_CFG          9123  //���ó�����������ϵͳ����
#define NET_DVR_GET_BASEMAP_WIN_CFG                9124  //��ȡ��ͼ���ڲ���
#define NET_DVR_SET_BASEMAP_WIN_CFG                9125  //���õ�ͼ���ڲ���
#define NET_DVR_DELETE_PICTURE                    9126  //ɾ����ͼ
#define NET_DVR_GET_BASEMAP_PIC_INFO            9127  //��ȡ��ͼͼƬ��Ϣ
#define    NET_DVR_SET_BASEMAP_WIN_CFG_V40         9128  //���õ�ͼ���ڲ���V40
#define NET_DVR_GET_BASEMAP_WIN_CFG_V40         9129  //��ȡ��ͼ���ڲ���V40

#define NET_DVR_GET_DEC_VCA_CFG                    9130    //��ȡ���������ܱ�������
#define NET_DVR_SET_DEC_VCA_CFG                    9131    //���ý��������ܱ�������

#define NET_DVR_SET_VS_INPUT_CHAN_INIT_ALL  9132  //��ʼ���������Ӱ����������ͨ��
#define NET_DVR_GET_VS_INPUT_CHAN_INIT_ALL  9133  //��ȡ�������Ӱ����������ͨ���ĳ�ʼ������
#define NET_DVR_GET_VS_INPUT_CHAN_INIT 9134  //��ȡ����������ͨ���ĳ�ʼ������
#define NET_DVR_GET_VS_INPUT_CHAN_CFG  9135  //��ȡ����������ͨ�����ò���

#define NET_DVR_GET_TERMINAL_CONFERENCE_STATUS    9136    //��ȡ�ն˻���״̬
#define NET_DVR_GET_TERMINAL_INPUT_CFG_CAP        9137    //��ȡ�ն������������
#define NET_DVR_GET_TERMINAL_INPUT_CFG            9138    //��ȡ�ն���Ƶ�����������
#define NET_DVR_SET_TERMINAL_INPUT_CFG            9139    //�����ն���Ƶ�����������

#define NET_DVR_GET_CONFERENCE_REGION_CAP        9140    //��ȡ�ն˻�����������
#define NET_DVR_GET_CONFERENCE_REGION            9141    //��ȡ�ն˻����������
#define NET_DVR_SET_CONFERENCE_REGION            9142    //�����ն˻����������
#define NET_DVR_GET_TERMINAL_CALL_CFG_CAP        9143    //��ȡ�ն˺�����������
#define NET_DVR_GET_TERMINAL_CALL_CFG            9144    //��ȡ�ն˺��в���
#define NET_DVR_SET_TERMINAL_CALL_CFG            9145    //�����ն˺��в���
#define NET_DVR_GET_TERMINAL_CTRL_CAP            9146    //��ȡ�ն˺��п�������
#define NET_DVR_TERMINAL_CTRL                    9147    //�ն˺��п���
#define    NET_DVR_GET_CALL_QUERY_CAP                9148    //��ȡ�����������
#define NET_DVR_GET_CALLINFO_BY_COND            9149    //��������ѯ���м�¼

#define    NET_DVR_SET_FUSION_SCALE                9150    //����ͼ���ںϹ�ģ
#define NET_DVR_GET_FUSION_SCALE                9151    //��ȡͼ���ںϹ�ģ

#define NET_DVR_GET_VCS_CAP                        9152    //��ȡMCU������


#define NET_DVR_GET_TERMINAL_GK_CFG_CAP            9153    //��ȡ�ն�ע��GK����
#define NET_DVR_GET_TERMINAL_GK_CFG                9154    //��ȡ�ն�ע��GK����
#define NET_DVR_SET_TERMINAL_GK_CFG                9155    //�����ն�ע��GK����
#define NET_DVR_GET_MCU_CONFERENCESEARCH_CAP    9156    //��ȡMCU�豸������
#define NET_DVR_SET_VS_INPUT_CHAN_CFG  9157  //��������������ͨ�����ò���
#define NET_DVR_GET_VS_NETSRC_CFG      9158  //��������������Դ����
#define NET_DVR_SET_VS_NETSRC_CFG      9159  //��������������Դ����

#define    NET_DVR_GET_LLDP_CFG                    9160    //��ȡLLDP����
#define    NET_DVR_SET_LLDP_CFG                    9161    //����LLDP����
#define NET_DVR_GET_LLDP_CAP                    9162    //��ȡLLDP������
#define    NET_DVR_GET_FIBER_CONVERT_BASIC_INFO    9163    //��ȡ�����շ���������Ϣ
#define    NET_DVR_GET_FIBER_CONVERT_WORK_STATE    9164    //��ȡ�����շ�������״
#define    NET_DVR_GET_FIBER_CONVERT_TOPOLOGY      9165    //��ȡ�����շ���������Ϣ
#define    NET_DVR_GET_FC_PORT_REMARKS                9166    //��ȡ�����շ����˿�ע�Ͳ���
#define    NET_DVR_SET_FC_PORT_REMARKS                9167    //���ù����շ����˿�ע�Ͳ���
#define NET_DVR_GET_PORT_REMARKS_CAP            9168    //��ȡ�����շ����˿�ע��������

#define NET_DVR_GET_MCU_CONFERENCECONTROL_CAP   9169    //��ȡ�����������
#define NET_DVR_GET_MCU_TERMINALCONTROL_CAP     9170    //��ȡ�ն˿�������
#define NET_DVR_GET_MCU_TERIMINALGROUP_CAP      9171    //��ȡ�ն˷�������
#define NET_DVR_GET_MCU_TERMINAL_CAP            9174    //��ȡ�ն˹�������
#define NET_DVR_GET_MCU_CONFERENCE_CAP          9175    //��ȡ��������
#define NET_DVR_GET_MCU_GK_CFG_CAP              9176    //��ȡMCUGK��������
#define NET_DVR_GET_MCU_GK_SERVER_CAP           9177    //��ȡMCUGK��������

#define NET_DVR_GET_EDID_CFG_FILE_INFO  9178  //��ȡEDID�����ļ���Ϣ
#define NET_DVR_GET_EDID_CFG_FILE_INFO_LIST  9179  //��ȡ����EDID�����ļ���Ϣ
#define NET_DVR_SET_EDID_CFG_FILE_INFO  9180  //����EDID�����ļ���Ϣ
#define NET_DVR_DEL_EDID_CFG_FILE_INFO  9181  //ɾ��EDID�����ļ���Ϣ�������ļ���
#define NET_DVR_GET_EDID_CFG_FILE_INFO_CAP  9182  //EDID�����ļ���Ϣ������

#define NET_DVR_GET_SUBWND_DECODE_OSD  9183  //��ȡ�Ӵ��ڽ���OSD��Ϣ
#define NET_DVR_GET_SUBWND_DECODE_OSD_ALL  9184  //��ȡ�����Ӵ��ڽ���OSD��Ϣ
#define NET_DVR_SET_SUBWND_DECODE_OSD  9185  //�����Ӵ��ڽ���OSD��Ϣ
#define NET_DVR_GET_SUBWND_DECODE_OSD_CAP  9186  //��ȡ�Ӵ��ڽ���OSD��Ϣ������
#define NET_DVR_GET_DECODE_CHANNEL_OSD  9187  //��ȡ����ͨ��OSD��Ϣ
#define NET_DVR_SET_DECODE_CHANNEL_OSD  9188  //���ý���ͨ��OSD��Ϣ


#define NET_DVR_GET_OUTPUT_PIC_INFO             9200    //��ȡ�����ͼƬ����
#define NET_DVR_SET_OUTPUT_PIC_INFO             9201    //���������ͼƬ����
#define NET_DVR_GET_OUTPUT_PIC_WIN_CFG          9202    //��ȡ�����ͼƬ���ڲ���
#define NET_DVR_SET_OUTPUT_PIC_WIN_CFG          9203    //���������ͼƬ���ڲ���
#define NET_DVR_GET_OUTPUT_ALL_PIC_WIN_CFG      9204    //��ȡ���������ͼƬ���ڲ���
#define NET_DVR_DELETE_OUPUT_PIC                9205    //ɾ�������ͼƬ
#define NET_DVR_GET_OUTPUT_OSD_CFG              9206    //��ȡ�����OSD����
#define NET_DVR_SET_OUTPUT_OSD_CFG              9207    //���������OSD����
#define NET_DVR_GET_OUTPUT_ALL_OSD_CFG          9208    //��ȡ���������OSD����
#define NET_DVR_GET_CHAN_RELATION               9209    //��ȡ����ͨ��������Դ����
#define NET_DVR_SET_CHAN_RELATION               9210    //���ñ���ͨ��������Դ����
#define NET_DVR_GET_ALL_CHAN_RELATION           9211    //��ȡ���б���ͨ��������Դ����
#define NET_DVR_GET_NS_RING_CFG                    9212    //��ȡ���˰廷������
#define NET_DVR_SET_NS_RING_CFG                   9213    //���ù��˰廷������
#define NET_DVR_GET_NS_RING_STATUS              9214    //��ȡ���˰廷��״̬
#define NET_DVR_GET_OPTICAL_PORT_INFO            9220    //��ȡ�����Ϣ
#define NET_DVR_SET_OPTICAL_PORT_INFO            9221    //���ù����Ϣ
#define NET_DVR_GET_OPTICAL_CHAN_RELATE_CFG        9222    //��ȡ����ͨ�������������Դ����
#define NET_DVR_SET_OPTICAL_CHAN_RELATE_CFG        9223    //���ñ���ͨ�������������Դ����
#define  NET_DVR_GET_WIN_ROAM_SWITCH_CFG        9224    //��ȡ�������������ο��ز���
#define  NET_DVR_SET_WIN_ROAM_SWITCH_CFG        9225    //���ý������������ο��ز���
#define    NET_DVR_START_SCREEN_CRTL                9226    //��ʼ��Ļ����
#define    NET_DVR_GET_SCREEN_FLIE_LIST            9227    //��ȡ��Ļ�ļ��б�
#define    NET_DVR_GET_SCREEN_FILEINFO                9228    //��ȡ��Ļ�ļ���Ϣ����
#define    NET_DVR_SET_SCREEN_FILEINFO             9229    //������Ļ�ļ���Ϣ����

/*******************************С���LED��ʾ�� begin***************************************/
#define NET_DVR_GET_LED_OUTPUT_CFG                9230    //��ȡ���Ϳ��������
#define NET_DVR_SET_LED_OUTPUT_CFG                9231    //���÷��Ϳ��������
#define NET_DVR_GET_LED_OUTPUT_PORT_CFG            9232    //��ȡLED���Ϳ�����˿ڲ���
#define NET_DVR_SET_LED_OUTPUT_PORT_CFG            9233    //����LED���Ϳ�����˿ڲ���
#define NET_DVR_GET_LED_DISPLAY_AREA_CFG        9234    //��ȡLED���Ϳ���ʾ����
#define NET_DVR_SET_LED_DISPLAY_AREA_CFG        9235    //����LED���Ϳ���ʾ����
#define NET_DVR_GET_LED_PORT_CFG                9236    //��ȡLED���Ϳ��˿ڲ���
#define NET_DVR_SET_LED_PORT_CFG                9237    //����LED���Ϳ��˿ڲ���
#define NET_DVR_GET_LED_DISPLAY_CFG                9238    //��ȡLED���Ϳ���ʾ����
#define NET_DVR_SET_LED_DISPLAY_CFG                9239    //����LED���Ϳ���ʾ����
#define NET_DVR_GET_ALL_LED_PORT_CFG            9240    //��ȡLED���Ϳ�ĳ�������Ӧ
#define NET_DVR_SAVE_LED_CONFIGURATION            9241    //�����̻�
#define NET_DVR_GET_LED_TEST_SIGNAL_CFG            9242    //��ȡLED�������źŲ���
#define NET_DVR_SET_LED_TEST_SIGNAL_CFG            9243    //����LED�������źŲ���
#define NET_DVR_GET_LED_NOSIGNAL_CFG            9244    //��ȡLED�����ź���ʾģʽ����
#define NET_DVR_SET_LED_NOSIGNAL_CFG            9245    //����LED�����ź���ʾģʽ����
#define NET_DVR_GET_LED_INPUT_CFG                9246    //��ȡLED���Ϳ��������
#define NET_DVR_SET_LED_INPUT_CFG                9247    //����LED���Ϳ��������
#define NET_DVR_GET_LED_RECV_GAMMA_CFG            9248    //��ȡ���տ�GAMMA�����
#define NET_DVR_SET_LED_RECV_GAMMA_CFG            9249    //���ý��տ�GAMMA�����
#define NET_DVR_GET_LED_RECV_CFG                9250    //��ȡ���տ���������
#define NET_DVR_SET_LED_RECV_CFG                9251    //���ý��տ���������
#define NET_DVR_GET_LED_RECV_ADVANCED_CFG        9252    //��ȡ���տ��߼�����
#define NET_DVR_SET_LED_RECV_ADVANCED_CFG        9253    //���ý��տ��߼�����
#define NET_DVR_GET_LED_SCREEN_DISPLAY_CFG        9254    //��ȡLED����ʾ����
#define NET_DVR_SET_LED_SCREEN_DISPLAY_CFG        9255    //����LED����ʾ����
/*******************************С���LED��ʾ�� end*****************************************/

#define NET_DVR_GET_INSERTPLAY_PROGRESS            9273    //��ȡ�岥����

#define    NET_DVR_GET_SCREEN_CONFIG               9260    //��ȡ��Ļ����������
#define    NET_DVR_SET_SCREEN_CONFIG               9261    //������Ļ����������
#define NET_DVR_GET_SCREEN_CONFIG_CAP              9262    //��ȡ��Ļ����������������

#define    NET_DVR_GET_SCHEDULE_PUBLISH_PROGRESS    9271    //��ȡ�ճ̷�������
#define    NET_DVR_GET_PUBLISH_UPGRADE_PROGRESS    9272    //��ȡ��Ϣ�����ն���������

#define NET_DVR_GET_INPUT_BOARD_CFG                9281    //��ȡ�����������Ϣ
#define NET_DVR_GET_INPUT_BOARD_CFG_LIST        9282    //��ȡ�����������Ϣ�б�
#define NET_DVR_SET_INPUT_BOARD_CFG                9283    //���������������Ϣ

#define NET_DVR_GET_INPUT_SOURCE_TEXT_CAP    9284            //��ȡ����Դ�ַ���������
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG    9285            //��ȡ����Դ�ַ����Ӳ���
#define NET_DVR_GET_INPUT_SOURCE_TEXT_CFG_LSIT 9286        //��ȡ����Դ�ַ����Ӳ����б�
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG    9287            //��������Դ�ַ����Ӳ���
#define NET_DVR_SET_INPUT_SOURCE_TEXT_CFG_LIST 9288        //��������Դ�ַ����Ӳ����б�
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CAP    9289    //��ȡ����Դ�Զ���ֱ�������
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG    9290    //��ȡ����Դ�Զ���ֱ��ʲ���
#define NET_DVR_GET_INPUT_SOURCE_RESOLUTION_CFG_LIST    9291 //��ȡ����Դ�Զ���ֱ����б�
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG    9292    //��������Դ�Զ���ֱ��ʲ���
#define NET_DVR_SET_INPUT_SOURCE_RESOLUTION_CFG_LIST  9293  //��������Դ�Զ���ֱ��ʲ���
#define NET_DVR_GET_LED_AREA_INFO_LIST  9295  //��ȡLED�����б�

#define NET_DVR_GET_DISPINPUT_CFG  9296  //��ȡ��ʾ�������
#define NET_DVR_GET_DISPINPUT_CFG_LIST  9297  //��ȡ������ʾ�������
#define NET_DVR_SET_DISPINPUT_CFG  9298  //������ʾ�������
#define NET_DVR_GET_DISPINPUT_CFG_CAP  9299  //��ȡ��ʾ�������������
#define NET_DVR_GET_CURRENT_VALID_PORT          9300    //��ȡ��ǰ��Ч��,�������ӵĶ˿�

#define    NET_DVR_SET_ONLINE_UPGRADE                9301    //������������
#define NET_DVR_GET_ONLINEUPGRADE_PROGRESS      9302    //��ȡ������������
#define    NET_DVR_GET_FIRMWARECODE                9303    //��ȡʶ����
#define NET_DVR_GET_ONLINEUPGRADE_SERVER        9304    //��ȡ����������״̬
#define NET_DVR_GET_ONLINEUPGRADE_VERSION       9305    //��ȡ�°汾��Ϣ
#define NET_DVR_GET_RECOMMEN_VERSION            9306    //����Ƿ��Ƽ��������˰汾
#define NET_DVR_GET_ONLINEUPGRADE_ABILITY       9309    //��ȡ��������������

#define    NET_DVR_GET_FIBER_CONVERT_BASIC_INFO_V50     9310    //��ȡԶ�������շ���������ϢV50
#define    NET_DVR_GET_FIBER_CONVERT_WORK_STATE_V50     9311    //��ȡԶ�������շ�������״̬

#define NET_SDK_LED_SCREEN_CHECK            9312    //LED��ĻУ��
#define NET_SDK_GENERATE_OUTPUT_CONTROL	    9315    //ͨ����չ�����ģ�����
#define  NET_SDK_GET_MATRIX_STATUS_V51   9313    /*��ȡ��Ƶ�ۺ�ƽ̨״̬*/

//DS-19D2000-S V2.0���� �����������ò���������
#define  NET_DVR_GET_ALARM_LINKAGE_CFG    9316    //��ȡ���������������ò���
#define  NET_DVR_SET_ALARM_LINKAGE_CFG    9317    //���ö��������������ò���


#define NET_DVR_GET_RS485_WORK_MODE             10001 //��ȡRS485���ڹ���ģʽ
#define NET_DVR_SET_RS485_WORK_MODE             10002 //����RS485���ڹ���ģʽ
#define NET_DVR_GET_SPLITTER_TRANS_CHAN_CFG     10003 //��ȡ�����͸��ͨ������
#define NET_DVR_SET_SPLITTER_TRANS_CHAN_CFG     10004 //���������͸��ͨ������

#define NET_DVR_GET_RS485_PROTOCOL_VERSION              10301       //��ȡRS485Э���汾��Ϣ
#define	 NET_DVR_ALARMHOST_REGISTER_DETECTOR  10302			//�Զ�ע��̽����

#define  NET_DVR_GET_SIP_CFG                    11001   //IP���ӻ�����ȡSIP����
#define  NET_DVR_SET_SIP_CFG                    11002   //IP���ӻ�������SIP����
#define  NET_DVR_GET_IP_VIEW_DEVCFG                11003   //��ȡIP�Խ��ֻ�����
#define  NET_DVR_SET_IP_VIEW_DEVCFG                11004   //����IP�Խ��ֻ�����
#define  NET_DVR_GET_IP_VIEW_AUDIO_CFG            11005   //��ȡIP�Խ��ֻ���Ƶ����
#define  NET_DVR_SET_IP_VIEW_AUDIO_CFG            11006   //����IP�Խ��ֻ���Ƶ����
#define     NET_DVR_GET_IP_VIEW_CALL_CFG            11007   //��ȡIP�Խ��ֻ����в���
#define  NET_DVR_SET_IP_VIEW_CALL_CFG            11008   //����IP�Խ��ֻ����в���
#define     NET_DVR_GET_AUDIO_LIMIT_ALARM_CFG        11009    //��ȡ�����������ò���
#define     NET_DVR_SET_AUDIO_LIMIT_ALARM_CFG        11010    //���������������ò���
#define     NET_DVR_GET_BUTTON_DOWN_ALARM_CFG        11011    //��ȡ��ť���¸澯���ò���
#define     NET_DVR_SET_BUTTON_DOWN_ALARM_CFG        11012    //���ð�ť���¸澯���ò���

#define  NET_DVR_GET_ISCSI_CFG                  11070   // ��ȡISCSI�洢����Э�� 
#define  NET_DVR_SET_ISCSI_CFG                  11071   // ��ȡISCSI�洢����Э�� 

#define NET_DVR_GET_SECURITYMODE                12004   //��ȡ��ǰ��ȫģʽ
//2013-11-21 ��ȡ�豸��ǰ���¶Ⱥ�ʪ��
#define  NET_DVR_GET_TEMP_HUMI                  12005

//2014-02-15 ����IPC�Զ���������Ŀ
#define  NET_DVR_SET_ALARMSOUNDMODE             12006   //���ñ�������ģʽ
#define  NET_DVR_GET_ALARMSOUNDMODE             12007   //��ȡ��������ģʽ

#define    NET_DVR_SET_IPDEVICE_ACTIVATED       13000//ͨ��NVR����ǰ���豸
#define NET_DVR_GET_DIGITAL_CHAN_SECURITY_STATUS    13001   //��ȡ����ͨ����Ӧ�豸��ȫ״̬
#define    NET_DVR_GET_ACTIVATE_IPC_ABILITY     13003    //��ȡNVR����IPC������


/*******************************¥����ӶԽ��� start***********************************/
#define NET_DVR_GET_VIDEO_INTERCOM_DEVICEID_CFG  16001  //��ȡ���ӶԽ��豸���
#define NET_DVR_SET_VIDEO_INTERCOM_DEVICEID_CFG  16002  //���ÿ��ӶԽ��豸���
#define NET_DVR_SET_PRIVILEGE_PASSWORD           16003  //����Ȩ������������Ϣ
#define NET_DVR_GET_OPERATION_TIME_CFG           16004  //��ȡ����ʱ������
#define NET_DVR_SET_OPERATION_TIME_CFG           16005  //���ò���ʱ������
#define NET_DVR_GET_VIDEO_INTERCOM_RELATEDEV_CFG 16006  //��ȡ���������豸����
#define NET_DVR_SET_VIDEO_INTERCOM_RELATEDEV_CFG 16007  //���ù��������豸����
#define NET_DVR_REMOTECONTROL_NOTICE_DATA        16008  //������Ϣ�·�
#define NET_DVR_REMOTECONTROL_GATEWAY            16009  //Զ�̿���
#define NET_DVR_REMOTECONTROL_OPERATION_AUTH     16010  //����Ȩ����֤

#define NET_DVR_GET_VIDEO_INTERCOM_IOIN_CFG      16016  //��ȡIO�������
#define NET_DVR_SET_VIDEO_INTERCOM_IOIN_CFG      16017  //����IO�������
#define NET_DVR_GET_VIDEO_INTERCOM_IOOUT_CFG     16018  //��ȡIO�������
#define NET_DVR_SET_VIDEO_INTERCOM_IOOUT_CFG     16019  //����IO�������
#define NET_DVR_GET_ELEVATORCONTROL_CFG          16020  //��ȡ�ݿ�������
#define NET_DVR_SET_ELEVATORCONTROL_CFG          16021  //�����ݿ�������
#define NET_DVR_GET_VIDEOINTERCOM_STREAM         16022  //��ȡ���ӶԽ���ͨ������
#define NET_DVR_SET_VIDEOINTERCOM_STREAM         16023  //���ÿ��ӶԽ���ͨ������
#define NET_DVR_GET_WDR_CFG                      16024  //��ȡ��̬��������
#define NET_DVR_SET_WDR_CFG                      16025  //���ÿ�̬��������
#define NET_DVR_GET_VIS_DEVINFO                  16026  //��ȡ���豸�����Ϣ
#define NET_DVR_GET_VIS_REGISTER_INFO            16027  //��ȡ���豸ע����豸��Ϣ
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V40      16028  //��ȡ�ݿ�������-��չ
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V40      16029  //�����ݿ�������-��չ
#define NET_DVR_GET_CALL_ROOM_CFG                 16030  //��ȡ��������ס������
#define NET_DVR_SET_CALL_ROOM_CFG                 16031  //���ð�������ס������
#define NET_DVR_VIDEO_CALL_SIGNAL_PROCESS        16032  //���ӻ��Խ������
#define NET_DVR_GET_CALLER_INFO                  16033  //��ȡ���г�����Ϣ
#define NET_DVR_GET_CALL_STATUS                  16034  //��ȡͨ��״̬
#define NET_DVR_GET_SERVER_DEVICE_INFO           16035  //��ȡ�豸�б�
#define NET_DVR_SET_CALL_SIGNAL                  16036  //���ӶԽ��ֻ��˷�������
#define NET_DVR_GET_VIDEO_INTERCOM_ALARM_CFG       16037    //��ȡ���ӶԽ������¼�����
#define NET_DVR_SET_VIDEO_INTERCOM_ALARM_CFG       16038    //���ÿ��ӶԽ������¼�����
#define NET_DVR_GET_RING_LIST                    16039    //��ѯ���������б�

#define NET_DVR_GET_ROOM_CUSTOM_CFG             16040  //�����Զ����ȡ
#define NET_DVR_SET_ROOM_CUSTOM_CFG             16041  //�����Զ�������
#define NET_DVR_GET_ELEVATORCONTROL_CFG_V50     16042  //��ȡ�ݿ�������V50
#define NET_DVR_SET_ELEVATORCONTROL_CFG_V50     16043  //�����ݿ�������V50
#define NET_DVR_GET_SIP_CFG_V50                 16044   //��ȡSIP����V50
#define NET_DVR_SET_SIP_CFG_V50                 16045   //����SIP����V50
#define NET_DVR_GET_NOTICE_VIDEO_DATA           16050  //������Ƶ��ȡ

/*******************************¥����ӶԽ��� end***********************************/

#define    NET_DVR_DEBUGINFO_START                     18000    //�����豸������Ϣ��������
#define    NET_DVR_AUTO_TEST_START                     18001    //�Զ����Գ����ӻ�ȡ

#define NET_DVR_GET_SELFCHECK_RESULT        20000    //��ȡ�豸�Լ���
#define NET_DVR_SET_TEST_COMMAND            20001    //���ò��Կ�������
#define NET_DVR_SET_TEST_DEVMODULE          20002    //���ò���Ӳ��ģ���������
#define NET_DVR_GET_TEST_DEVMODULE          20003    //��ȡ����Ӳ��ģ���������

#define NET_DVR_SET_AUTOFOCUS_TEST          20004    //�����Զ��Խ����� 2013-10-26
#define NET_DVR_CHECK_USER_STATUS           20005    //����û��Ƿ�����
#define NET_DVR_GET_TEST_COMMAND            20010    //��ȡ���Կ�������
#define NET_DVR_GET_DIAL_SWITCH_CFG         20200    //��ȡ���뿪����Ϣ
#define NET_DVR_SET_AGING_TRICK_SCAN          20201  //�����ϻ�ǰ�󹤾߲���
#define NET_DVR_GET_ECCENTRIC_CORRECT_STATE   20202  //��ȡ��ȡƫ��У��״̬

#define	NET_DVR_GET_THERMOMETRYRULE_TEMPERATURE_INFO   23001	//�ֶ���ȡ���¹����¶���Ϣ

#define NET_DVR_T1_TEST_CMD                    131073 //�������������ã�ͨ������������ı��������־�����ʲô.���ݳ��Ȳ��ô���1024
//��������ʽΪ��<T1TestCmd type="0"/>//�ָ��豸Ĭ�ϲ������ػ���

// ���ֶ��Ʋ˵����ģʽ�ⲿ����
#define NET_DVR_GET_MEMU_OUTPUT_MODE            155649            // ��ȡ�˵����ģʽ
#define NET_DVR_SET_MEMU_OUTPUT_MODE            155650            // ���ò˵����ģʽ

/***************************DS9000��������(_V30) end *****************************/

#define NET_DVR_GET_DEV_LOGIN_RET_INFO      16777200  //�豸��½���ز���


#define NET_DVR_GET_TEST_VERSION_HEAD           268435441   //��ȡ���԰汾ͷ
#define NET_DVR_SET_TEST_VERSION_HEAD           268435442   //���ò��԰汾ͷ
#define NET_DVR_GET_TEST_VERSION_HEAD_V1        268435443   //��ȡ���԰汾ͷ-�ڶ���
#define NET_DVR_SET_TEST_VERSION_HEAD_V1        268435444   //���ò��԰汾ͷ-�ڶ���
#define NET_DVR_GET_TEST_VERSION_HEAD_V2        268435445   //��ȡ���԰汾ͷ-������
#define NET_DVR_SET_TEST_VERSION_HEAD_V2        268435446   //���ò��԰汾ͷ-������

#define NET_DVR_GET_TEST_VERSION_HEAD_ONLY_0    268435447   //��ȡ���԰汾ͷ,��ǰ����һ���汾
#define NET_DVR_SET_TEST_VERSION_HEAD_ONLY_0    268435448   //���ò��԰汾ͷ,��ǰ����һ���汾


#define MAX_LOCAL_ADDR_LEN             96        //SOCKS��󱾵����θ���
#define    MAX_COUNTRY_NAME_LEN          4        //���Ҽ�д���Ƴ���

/************************DVR��־ begin***************************/

/* ���� */
//������
#define MAJOR_ALARM                        0x1
//������
#define MINOR_ALARM_IN                    0x1        /* �������� */
#define MINOR_ALARM_OUT                    0x2        /* ������� */
#define MINOR_MOTDET_START                0x3        /* �ƶ���ⱨ����ʼ */
#define MINOR_MOTDET_STOP                0x4        /* �ƶ���ⱨ������ */
#define MINOR_HIDE_ALARM_START            0x5        /* �ڵ�������ʼ */
#define MINOR_HIDE_ALARM_STOP            0x6        /* �ڵ��������� */
#define MINOR_VCA_ALARM_START            0x7        /*���ܱ�����ʼ*/
#define MINOR_VCA_ALARM_STOP            0x8        /*���ܱ���ֹͣ*/
#define MINOR_ITS_ALARM_START           0x09    // ��ͨ�¼�������ʼ
#define MINOR_ITS_ALARM_STOP            0x0A    // ��ͨ�¼���������
//2010-11-10 ���籨����־
#define MINOR_NETALARM_START            0x0b    /*���籨����ʼ*/
#define MINOR_NETALARM_STOP             0x0c    /*���籨������*/
//2010-12-16 ��������־����"MINOR_ALARM_IN"���ʹ��
#define MINOR_NETALARM_RESUME            0x0d    /*���籨���ָ�*/
//2012-4-5 IPC PIR�����ߡ����ȱ���
#define MINOR_WIRELESS_ALARM_START      0x0e  /* ���߱�����ʼ */
#define MINOR_WIRELESS_ALARM_STOP          0x0f /* ���߱������� */
#define MINOR_PIR_ALARM_START           0x10  /* �����Ӧ������ʼ */
#define MINOR_PIR_ALARM_STOP               0x11  /* �����Ӧ�������� */
#define MINOR_CALLHELP_ALARM_START      0x12  /* ���ȱ�����ʼ */
#define MINOR_CALLHELP_ALARM_STOP          0x13  /* ���ȱ������� */
#define MINOR_IPCHANNEL_ALARMIN_START   0x14  //����ͨ���������뿪ʼ��PCNVR�ڽ��յ�����ͨ����MINOR_ALARM_IN����������ͨ���������뿪ʼ����10s�����ղ���MINOR_ALARM_IN������������ͨ���������������
#define MINOR_IPCHANNEL_ALARMIN_STOP    0x15  //����ͨ���������뿪ʼ��ͬ��
#define MINOR_DETECTFACE_ALARM_START    0x16  /* ������ⱨ����ʼ */
#define MINOR_DETECTFACE_ALARM_STOP      0x17  /* ������ⱨ������ */
#define MINOR_VQD_ALARM_START           0x18  //VQD����
#define MINOR_VQD_ALARM_STOP            0x19  //VQD�������� 
#define MINOR_VCA_SECNECHANGE_DETECTION 0x1a  //������ⱨ�� 2013-07-16

#define MINOR_SMART_REGION_EXITING_BEGIN            0x1b  //�뿪������⿪ʼ
#define MINOR_SMART_REGION_EXITING_END              0x1c  //�뿪����������
#define MINOR_SMART_LOITERING_BEGIN                 0x1d  //�ǻ���⿪ʼ
#define MINOR_SMART_LOITERING_END                   0x1e  //�ǻ�������

#define MINOR_VCA_ALARM_LINE_DETECTION_BEGIN        0x20  
#define MINOR_VCA_ALARM_LINE_DETECTION_END          0x21  
#define MINOR_VCA_ALARM_INTRUDE_BEGIN                0x22  //������⿪ʼ    
#define MINOR_VCA_ALARM_INTRUDE_END                       0x23  //����������    
#define MINOR_VCA_ALARM_AUDIOINPUT                    0x24   //��Ƶ�쳣����
#define MINOR_VCA_ALARM_AUDIOABNORMAL                 0x25   //��ǿͻ��
#define MINOR_VCA_DEFOCUS_DETECTION_BEGIN           0x26  //�齹��⿪ʼ
#define MINOR_VCA_DEFOCUS_DETECTION_END                0x27  //�齹������

//����NVR
#define MINOR_EXT_ALARM                             0x28/*IPC�ⲿ����*/
#define MINOR_VCA_FACE_ALARM_BEGIN                    0x29    /*������⿪ʼ*/
#define MINOR_SMART_REGION_ENTRANCE_BEGIN           0x2a  //����������⿪ʼ
#define MINOR_SMART_REGION_ENTRANCE_END             0x2b  //��������������
#define MINOR_SMART_PEOPLE_GATHERING_BEGIN          0x2c  //��Ա�ۼ���⿪ʼ
#define MINOR_SMART_PEOPLE_GATHERING_END            0x2d  //��Ա�ۼ�������
#define MINOR_SMART_FAST_MOVING_BEGIN               0x2e  //�����˶���⿪ʼ
#define MINOR_SMART_FAST_MOVING_END                 0x2f  //�����˶�������

#define MINOR_VCA_FACE_ALARM_END                    0x30    /*����������*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_BEGIN            0x31   /*���������⿪ʼ*/
#define MINOR_VCA_SCENE_CHANGE_ALARM_END            0x32   /*�������������*/
#define MINOR_VCA_ALARM_AUDIOINPUT_BEGIN            0x33   /*��Ƶ�쳣���뿪ʼ*/
#define MINOR_VCA_ALARM_AUDIOINPUT_END                0x34   /*��Ƶ�쳣�������*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_BEGIN            0x35  /*��ǿͻ����⿪ʼ*/
#define MINOR_VCA_ALARM_AUDIOABNORMAL_END            0x36  /*��ǿͻ��������*/

#define MINOR_VCA_LECTURE_DETECTION_BEGIN           0x37  //�ڿ���⿪ʼ����
#define MINOR_VCA_LECTURE_DETECTION_END             0x38  //�ڿ�����������
#define MINOR_VCA_ALARM_AUDIOSTEEPDROP              0x39  //��ǿ���� 2014-03-21
#define MINOR_VCA_ANSWER_DETECTION_BEGIN            0x3a  //�ش�������⿪ʼ����
#define MINOR_VCA_ANSWER_DETECTION_END              0x3b  //�ش���������������

#define MINOR_SMART_PARKING_BEGIN                   0x3c   //ͣ����⿪ʼ
#define MINOR_SMART_PARKING_END                     0x3d   //ͣ��������
#define MINOR_SMART_UNATTENDED_BAGGAGE_BEGIN        0x3e   //��Ʒ������⿪ʼ
#define MINOR_SMART_UNATTENDED_BAGGAGE_END          0x3f   //��Ʒ����������
#define MINOR_SMART_OBJECT_REMOVAL_BEGIN            0x40   //��Ʒ��ȡ��⿪ʼ
#define MINOR_SMART_OBJECT_REMOVAL_END              0x41   //��Ʒ��ȡ������
#define MINOR_SMART_VEHICLE_ALARM_START             0x46   //���Ƽ�⿪ʼ
#define MINOR_SMART_VEHICLE_ALARM_STOP              0x47   //���Ƽ�����
#define MINOR_THERMAL_FIREDETECTION                 0x48   //�ȳ���������⿪ʼ
#define MINOR_THERMAL_FIREDETECTION_END             0x49   //�ȳ�������������
#define MINOR_SMART_VANDALPROOF_BEGIN               0x50   //���ƻ���⿪ʼ
#define MINOR_SMART_VANDALPROOF_END                 0x51   //���ƻ�������

#define MINOR_FACESNAP_MATCH_ALARM_START            0x55  /*�����ȶԱ�����ʼ*/
#define MINOR_FACESNAP_MATCH_ALARM_STOP             0x56  /*�����ȶԱ�������*/
#define MINOR_WHITELIST_FACESNAP_MATCH_ALARM_START  0x57  /*�����������ȶԣ�İ���ˣ�������ʼ*/
#define MINOR_WHITELIST_FACESNAP_MATCH_ALARM_STOP   0x58  /*�����������ȶԣ�İ���ˣ���������*/

#define MINOR_THERMAL_SHIPSDETECTION                0x5a   //�ȳ���ֻ������
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_BEGIN 0x5b  //�ȳ������Ԥ����ʼ
#define MINOR_THERMAL_THERMOMETRY_EARLYWARNING_END  0x5c   //�ȳ������Ԥ������
#define MINOR_THERMAL_THERMOMETRY_ALARM_BEGIN       0x5d   //�ȳ�����±�����ʼ
#define MINOR_THERMAL_THERMOMETRY_ALARM_END         0x5e   //�ȳ�����±�������
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_BEGIN  0x5f   //�ȳ����²����ʼ
#define MINOR_THERMAL_THERMOMETRY_DIFF_ALARM_END    0x60   //�ȳ����²������
#define MINOR_FACE_THERMOMETRY_ALARM                0x63   //�������±���
#define MINOR_SMART_DENSEFOGDETECTION_BEGIN         0x6e   //������⿪ʼ
#define MINOR_SMART_DENSEFOGDETECTION_END           0x6f   //����������
#define MINOR_RUNNING_ALARM                         0x70   //���ܼ��
#define MINOR_RETENTION_ALARM                       0x71   //�������
#define MINOR_SAFETY_HELMET_ALARM_START             0x72  /*δ�����ȫñ��ⱨ����ʼ*/
#define MINOR_SAFETY_HELMET_ALARM_STOP              0x73  /*δ�����ȫñ��ⱨ������*/
#define MINOR_HFPD_ALARM_START                      0x74  /*��Ƶ��Ա��ⱨ����ʼ*/
#define MINOR_HFPD_ALARM_STOP                       0x75  /*��Ƶ��Ա��ⱨ������*/
#define MINOR_MIXED_TARGET_ALARM_START              0x76  /*���Ŀ���ⱨ����ʼ*/
#define MINOR_MIXED_TARGET_ALARM_STOP               0x77  /*���Ŀ���ⱨ������*/
#define MINOR_VCA_PLAY_CELLPHONE_ALARM_BEGIN  0x78  //���ֻ���ⱨ����ʼ
#define MINOR_VCA_PLAY_CELLPHONE_ALARM_END    0x79   //���ֻ���ⱨ������
#define MINOR_VCA_GET_UP_ALARM_BEGIN                0x80   //�𴲼�ⱨ����ʼ
#define MINOR_VCA_GET_UP_ALARM_END                  0x81   //�𴲼�ⱨ������
#define MINOR_VCA_ADV_REACH_HEIGHT_ALARM_BEGIN      0x82   //�����ʸ߱�����ʼ
#define MINOR_VCA_ADV_REACH_HEIGHT_ALARM_END        0x83   //�����ʸ߱�������
#define MINOR_VCA_TOILET_TARRY_ALARM_BEGIN          0x84   //��޳�ʱ������ʼ
#define MINOR_VCA_TOILET_TARRY_ALARM_END            0x85   //��޳�ʱ��������
#define MINOR_HUMAN_RECOGNITION_ALARM_BEGIN         0x86   //����ʶ�𱨾���ʼ
#define MINOR_HUMAN_RECOGNITION_ALARM_END           0x87   //����ʶ�𱨾�����
#define MINOR_STUDENTS_STOODUP_ALARM_BEGIN          0x88   //ѧ������������ʼ
#define MINOR_STUDENTS_STOODUP_ALARM_END            0x89   //ѧ��������������
#define MINOR_FRAMES_PEOPLE_COUNTING_ALARM          0x8a   //��������ͳ�Ʊ���
#define MINOR_FACE_SNAP_ALARM_BEGIN                 0x8b   //����ץ�ı�����ʼ
#define MINOR_FACE_SNAP_ALARM_END                   0x8c   //����ץ�ı�������
#define MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_BEGIN   0x8d   //��ʦ��Ϊ��ⱨ����ʼ
#define MINOR_TEACHER_BEHAVIOR_DETECT_ALARM_END     0x8e   //��ʦ��Ϊ��ⱨ������
#define MINOR_PERIMETER_CAPTURE_ALARM_BEGIN         0x8f   //�ܽ�ץ�ı�����ʼ
#define MINOR_PERIMETER_CAPTURE_ALARM_END           0x90   //�ܽ�ץ�ı�������
#define MINOR_UNREGISTERED_STREET_VENDOR_ALARM      0x91  //�Ƿ���̯����

#define MINOR_PERSON_QUEUE_TIME_ALARM_BEGIN         0x92   //�Ŷ�ʱ����ⱨ����ʼ
#define MINOR_PERSON_QUEUE_TIME_ALARM_END           0x93   //�Ŷ�ʱ����ⱨ������
#define MINOR_PERSON_QUEUE_COUNTING_ALARM_BEGIN     0x94   //�Ŷ�������ⱨ����ʼ
#define MINOR_PERSON_QUEUE_COUNTING_ALARM_END       0x95   //�Ŷ�������ⱨ������
#define MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_START   0x96   //�����ȶ�ʧ�ܱ�����ʼ
#define MINOR_FACE_SNAP_MATCH_FAILURE_ALARM_END     0x97   //�����ȶ�ʧ�ܱ�������


#define MINOR_ACCESS_CONTROLLER_EVENT               0x100  //�Ž������¼�
#define MINOR_VIDEO_INTERCOM_EVENT                  0x101  //���ӶԽ��豸�¼�
#define MINOR_GJD_EVENT                             0x102  //GJD���������¼�
#define MINOR_LUMINITE_EVENT                        0x103  // LUMINITE���������¼�
#define MINOR_OPTEX_EVENT                           0x104  // OPTEX���������¼�
#define MINOR_CAMERA_DETECTOR_EVENT                 0x105  // �������¼�
#define MINOR_SECURITY_CONTROL_PANEL_EVENT          0x106  //�������������¼�

#define MINOR_VCA_SPACE_CHANGE_START                0x10c //����쳣��⿪ʼ
#define MINOR_VCA_SPACE_CHANGE_STOP                 0x10d //����쳣������
#define MINOR_MANUAL_ALARM                          0x10e //�ֶ�����
#define MINOR_DETECTOR_ALARM                        0x10f //̽��������
#define MINOR_LINKAGE_ALARM                         0x110 //��������
#define MINOR_VCA_SITUATION_ANALYSIS_START          0x111 //̬�Ʒ�����⿪ʼ
#define MINOR_VCA_SITUATION_ANALYSIS_STOP           0x112 //̬�Ʒ���������
#define MINOR_FIRE_ALARM                            0x113 //�𾯱���
#define MINOR_SUPERVISE_ALARM                       0x114 //��ܱ���
#define MINOR_SHIELD_ALARM                          0x115 //���α���
#define MINOR_ABNORMAL_ALARM                        0x116 //���ϱ���
#define MINOR_RESIDUAL_CURRENT_ALARM                0x117 //ʣ���������
#define MINOR_TEMPERATURE_ALARM                     0x118 //�¶ȱ���
#define MINOR_ARC_ALARM                             0x119 //�绡����

#define MINOR_VCA_YARD_TARRY_ALARM_BEGIN      0x11a   //�ŷ糡����������ʼ
#define MINOR_VCA_YARD_TARRY_ALARM_END      0x11b   //�ŷ糡������������
#define MINOR_VCA_KEY_PERSON_GET_UP_ALARM_BEGIN   0x11c     //�ص���Ա��������ʼ
#define MINOR_VCA_KEY_PERSON_GET_UP_ALARM_END   0x11d     //�ص���Ա����������
#define MINOR_VCA_SIT_QUIETLY_ALARM_BEGIN     0x11e     //����������ʼ
#define MINOR_VCA_SIT_QUIETLY_ALARM_END     0x11f     //������������
#define MINOR_VCA_STAND_UP_ALARM_BEGIN     0x120     //վ��������ʼ
#define MINOR_VCA_STAND_UP_ALARM_END     0x121     //վ����������
#define MINOR_VCA_REACH_HIGHT_ALARM_BEGIN    0x122     //�ʸ߱�����ʼ
#define MINOR_VCA_REACH_HIGHT_ALARM_END    0x123     //�ʸ߱�������

#define MINOR_LFPD_ALARM_START                      0x124  /*��Ƶ��Ա��ⱨ����ʼ*/
#define MINOR_LFPD_ALARM_STOP                       0x125  /*��Ƶ��Ա��ⱨ������*/

#define MINOR_DREDGERDETECTION_ALARM                0x126// ��ɳ����ⱨ��
#define MINOR_STUDENT_BEHAVIOR_ALARM_BEGIN          0x127  //����ѧ����Ϊ������ʼ
#define MINOR_STUDENT_BEHAVIOR_ALARM_END            0x128  //����ѧ����Ϊ��������
#define MINOR_VCA_ALARM_VEHICLEMONITOR                 0x129   //�������ر���(���ڳ������ص�һ������������⣨������������Ϣ������־)
#define MINOR_WASTEGASDETECTION_ALARM                0x130// �����ŷż���¼��ϱ�
#define MINOR_GREYSCALE_ALARM                        0x131// �Ҷȱ���
#define MINOR_VIBRATION_DETECTION_ALARM_BEGIN          0x132  //����ⱨ����ʼ
#define MINOR_VIBRATION_DETECTION_ALARM_END            0x133  //����ⱨ������

//0x400-0x1000 �Ž�����
#define MINOR_ALARMIN_SHORT_CIRCUIT                 0x400  //������·����
#define MINOR_ALARMIN_BROKEN_CIRCUIT                0x401  //������·����
#define MINOR_ALARMIN_EXCEPTION                     0x402  //�����쳣����
#define MINOR_ALARMIN_RESUME                        0x403  //���������ָ�
#define MINOR_HOST_DESMANTLE_ALARM                  0x404  //�豸���𱨾�
#define MINOR_HOST_DESMANTLE_RESUME                 0x405  //�豸����ָ�
#define MINOR_CARD_READER_DESMANTLE_ALARM           0x406  //���������𱨾�
#define MINOR_CARD_READER_DESMANTLE_RESUME          0x407  //����������ָ�
#define MINOR_CASE_SENSOR_ALARM                     0x408  //�¼����뱨��
#define MINOR_CASE_SENSOR_RESUME                    0x409  //�¼�����ָ�
#define MINOR_STRESS_ALARM                          0x40a  //в�ȱ���
#define MINOR_OFFLINE_ECENT_NEARLY_FULL             0x40b  //�����¼���90%����
#define MINOR_CARD_MAX_AUTHENTICATE_FAIL            0x40c  //������֤ʧ�ܳ��α���
#define MINOR_SD_CARD_FULL                          0x40d  //SD���洢������
#define MINOR_LINKAGE_CAPTURE_PIC                   0x40e  //����ץ���¼�����
#define MINOR_SECURITY_MODULE_DESMANTLE_ALARM        0x40f  //�ſذ�ȫģ����𱨾�
#define MINOR_SECURITY_MODULE_DESMANTLE_RESUME        0x410  //�ſذ�ȫģ�����ָ�

#define MINOR_POS_START_ALARM                       0x411  //POS����
#define MINOR_POS_END_ALARM                         0x412  //POS����
#define MINOR_FACE_IMAGE_QUALITY_LOW                0x413  //����ͼ���ʵ�
#define MINOR_FINGE_RPRINT_QUALITY_LOW              0x414  //ָ��ͼ���ʵ�
#define MINOR_FIRE_IMPORT_SHORT_CIRCUIT             0x415  //���������·����
#define MINOR_FIRE_IMPORT_BROKEN_CIRCUIT            0x416  //���������·����
#define MINOR_FIRE_IMPORT_RESUME                    0x417  //��������ָ�
#define MINOR_FIRE_BUTTON_TRIGGER                   0x418  //������ť����
#define MINOR_FIRE_BUTTON_RESUME                    0x419  //������ť�ָ�
#define MINOR_MAINTENANCE_BUTTON_TRIGGER            0x41a  //ά����ť����
#define MINOR_MAINTENANCE_BUTTON_RESUME             0x41b  //ά����ť�ָ�
#define MINOR_EMERGENCY_BUTTON_TRIGGER              0x41c  //������ť����
#define MINOR_EMERGENCY_BUTTON_RESUME               0x41d  //������ť�ָ�
#define MINOR_DISTRACT_CONTROLLER_ALARM             0x41e  //�ֿ������𱨾�
#define MINOR_DISTRACT_CONTROLLER_RESUME            0x41f  //�ֿ������𱨾��ָ�

#define MINOR_PERSON_DENSITY_DETECTION_START        0x420  //��Ա�ܶȳ���ֵ������ʼ
#define MINOR_PERSON_DENSITY_DETECTION_END          0x421  //��Ա�ܶȳ���ֵ��������

#define MINOR_CHANNEL_CONTROLLER_DESMANTLE_ALARM    0x422  //ͨ�����������𱨾�
#define MINOR_CHANNEL_CONTROLLER_DESMANTLE_RESUME   0x423  //ͨ�����������𱨾��ָ�
#define MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM  0x424  //ͨ���������������뱨��
#define MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME 0x425  //ͨ���������������뱨���ָ�

#define MINOR_HEART_RATE_ABNORMAL_BEGIN             0x426    //�����쳣������ʼ
#define MINOR_HEART_RATE_ABNORMAL_END               0x427    //�����쳣��������
#define MINOR_BLOOD_OXYGEN_ABNORMAL_BEGIN           0x428    //Ѫ���쳣������ʼ
#define MINOR_BLOOD_OXYGEN_ABNORMAL_END             0x429    //Ѫ���쳣��������
#define MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN   0x42a    //Ѫѹ����ѹ�쳣������ʼ
#define MINOR_SYSTOLIC_BLOOD_PRESSURE_ABNORMAL_END     0x42b    //Ѫѹ����ѹ�쳣��������
#define MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_BEGIN  0x42c    //Ѫѹ����ѹ�쳣������ʼ
#define MINOR_DIASTOLIC_BLOOD_PRESSURE_ABNORMAL_END    0x42d    //Ѫѹ����ѹ�쳣��������
#define MINOR_VCA_LEAVE_POSITION_START              0x42e//��ڼ�⿪ʼ
#define MINOR_VCA_LEAVE_POSITION_STOP               0x42f//��ڼ�����
#define MINOR_VCA_STOOODUP_START                    0x430//������⿪ʼ
#define MINOR_VCA_STOOODUP_STOP                     0x431//����������
#define MINOR_VCA_PEOPLENUM_CHANGE_START            0x434//�����仯��ʼ
#define MINOR_VCA_PEOPLENUM_CHANGE_STOP             0x435//�����仯����
#define MINOR_VCA_RUNNING_START                     0x438//��Ա���ܿ�ʼ
#define MINOR_VCA_RUNNING_STOP                      0x439//��Ա���ܽ���
#define MINOR_VCA_VIOLENT_MOTION_START              0x43a//�����˶���ʼ
#define MINOR_VCA_VIOLENT_MOTION_STOP               0x43b//�����˶�����
#define MINOR_VCA_FAIL_DOWN_START                   0x43c//��Ա���ؿ�ʼ
#define MINOR_VCA_FAIL_DOWN_STOP                    0x43d//��Ա���ؽ���
#define MINOR_VCA_RETENTION_START                   0x43e//��Ա������ʼ
#define MINOR_VCA_RETENTION_STOP                    0x43f//��Ա��������

#define MINOR_PRINTER_OUT_OF_PAPER               0x440   //��ӡ��ȱֽ����
#define MINOR_LEGAL_EVENT_NEARLY_FULL            0x442   //���ߺϷ��¼���90%����

#define MINOR_ALARM_CUSTOM1                         0x900  //�Ž��Զ��屨��1
#define MINOR_ALARM_CUSTOM2                         0x901  //�Ž��Զ��屨��2
#define MINOR_ALARM_CUSTOM3                         0x902  //�Ž��Զ��屨��3
#define MINOR_ALARM_CUSTOM4                         0x903  //�Ž��Զ��屨��4
#define MINOR_ALARM_CUSTOM5                         0x904  //�Ž��Զ��屨��5
#define MINOR_ALARM_CUSTOM6                         0x905  //�Ž��Զ��屨��6
#define MINOR_ALARM_CUSTOM7                         0x906  //�Ž��Զ��屨��7
#define MINOR_ALARM_CUSTOM8                         0x907  //�Ž��Զ��屨��8
#define MINOR_ALARM_CUSTOM9                         0x908  //�Ž��Զ��屨��9
#define MINOR_ALARM_CUSTOM10                        0x909  //�Ž��Զ��屨��10
#define MINOR_ALARM_CUSTOM11                        0x90a  //�Ž��Զ��屨��11
#define MINOR_ALARM_CUSTOM12                        0x90b  //�Ž��Զ��屨��12
#define MINOR_ALARM_CUSTOM13                        0x90c  //�Ž��Զ��屨��13
#define MINOR_ALARM_CUSTOM14                        0x90d  //�Ž��Զ��屨��14
#define MINOR_ALARM_CUSTOM15                        0x90e  //�Ž��Զ��屨��15
#define MINOR_ALARM_CUSTOM16                        0x90f  //�Ž��Զ��屨��16
#define MINOR_ALARM_CUSTOM17                        0x910  //�Ž��Զ��屨��17
#define MINOR_ALARM_CUSTOM18                        0x911  //�Ž��Զ��屨��18
#define MINOR_ALARM_CUSTOM19                        0x912  //�Ž��Զ��屨��19
#define MINOR_ALARM_CUSTOM20                        0x913  //�Ž��Զ��屨��20
#define MINOR_ALARM_CUSTOM21                        0x914  //�Ž��Զ��屨��21
#define MINOR_ALARM_CUSTOM22                        0x915  //�Ž��Զ��屨��22
#define MINOR_ALARM_CUSTOM23                        0x916  //�Ž��Զ��屨��23
#define MINOR_ALARM_CUSTOM24                        0x917  //�Ž��Զ��屨��24
#define MINOR_ALARM_CUSTOM25                        0x918  //�Ž��Զ��屨��25
#define MINOR_ALARM_CUSTOM26                        0x919  //�Ž��Զ��屨��26
#define MINOR_ALARM_CUSTOM27                        0x91a  //�Ž��Զ��屨��27
#define MINOR_ALARM_CUSTOM28                        0x91b  //�Ž��Զ��屨��28
#define MINOR_ALARM_CUSTOM29                        0x91c  //�Ž��Զ��屨��29
#define MINOR_ALARM_CUSTOM30                        0x91d  //�Ž��Զ��屨��30
#define MINOR_ALARM_CUSTOM31                        0x91e  //�Ž��Զ��屨��31
#define MINOR_ALARM_CUSTOM32                        0x91f  //�Ž��Զ��屨��32
#define MINOR_ALARM_CUSTOM33                        0x920  //�Ž��Զ��屨��33
#define MINOR_ALARM_CUSTOM34                        0x921  //�Ž��Զ��屨��34
#define MINOR_ALARM_CUSTOM35                        0x922  //�Ž��Զ��屨��35
#define MINOR_ALARM_CUSTOM36                        0x923  //�Ž��Զ��屨��36
#define MINOR_ALARM_CUSTOM37                        0x924  //�Ž��Զ��屨��37
#define MINOR_ALARM_CUSTOM38                        0x925  //�Ž��Զ��屨��38
#define MINOR_ALARM_CUSTOM39                        0x926  //�Ž��Զ��屨��39
#define MINOR_ALARM_CUSTOM40                        0x927  //�Ž��Զ��屨��40
#define MINOR_ALARM_CUSTOM41                        0x928  //�Ž��Զ��屨��41
#define MINOR_ALARM_CUSTOM42                        0x929  //�Ž��Զ��屨��42
#define MINOR_ALARM_CUSTOM43                        0x92a  //�Ž��Զ��屨��43
#define MINOR_ALARM_CUSTOM44                        0x92b  //�Ž��Զ��屨��44
#define MINOR_ALARM_CUSTOM45                        0x92c  //�Ž��Զ��屨��45
#define MINOR_ALARM_CUSTOM46                        0x92d  //�Ž��Զ��屨��46
#define MINOR_ALARM_CUSTOM47                        0x92e  //�Ž��Զ��屨��47
#define MINOR_ALARM_CUSTOM48                        0x92f  //�Ž��Զ��屨��48
#define MINOR_ALARM_CUSTOM49                        0x930  //�Ž��Զ��屨��49
#define MINOR_ALARM_CUSTOM50                        0x931  //�Ž��Զ��屨��50
#define MINOR_ALARM_CUSTOM51                        0x932  //�Ž��Զ��屨��51
#define MINOR_ALARM_CUSTOM52                        0x933  //�Ž��Զ��屨��52
#define MINOR_ALARM_CUSTOM53                        0x934  //�Ž��Զ��屨��53
#define MINOR_ALARM_CUSTOM54                        0x935  //�Ž��Զ��屨��54
#define MINOR_ALARM_CUSTOM55                        0x936  //�Ž��Զ��屨��55
#define MINOR_ALARM_CUSTOM56                        0x937  //�Ž��Զ��屨��56
#define MINOR_ALARM_CUSTOM57                        0x938  //�Ž��Զ��屨��57
#define MINOR_ALARM_CUSTOM58                        0x939  //�Ž��Զ��屨��58
#define MINOR_ALARM_CUSTOM59                        0x93a  //�Ž��Զ��屨��59
#define MINOR_ALARM_CUSTOM60                        0x93b  //�Ž��Զ��屨��60
#define MINOR_ALARM_CUSTOM61                        0x93c  //�Ž��Զ��屨��61
#define MINOR_ALARM_CUSTOM62                        0x93d  //�Ž��Զ��屨��62
#define MINOR_ALARM_CUSTOM63                        0x93e  //�Ž��Զ��屨��63
#define MINOR_ALARM_CUSTOM64                        0x93f  //�Ž��Զ��屨��64
#define MINOR_LOCK_HIJIACK_FINGER_ALARM         0x950       //���������ٳ�ָ�Ʊ���
#define MINOR_LOCK_HIJIACK_PASSWORD_ALARM       0x951       //���������ٳ����뱨��
#define MINOR_LOCK_PRY_DOOR_ALARM               0x952       //���������ű���
#define MINOR_LOCK_LOCKED_ALARM                 0x953       //��������������
#define MINOR_LOCK_BATTERLOW_ALARM              0x954       //�������͵�ѹ����
#define MINOR_LOCK_BLACKLIST_DOOR_ALARM         0x955       //����������������
#define MINOR_LOCK_OFFLINE_ALARM                0x956       //���������߱���
#define MINOR_LOCK_UNCLOSED_ALARM               0x957       //���������ڱ���
#define MINOR_LOCK_NO_HOME_ALARM                0x958       //�������û�δ�ؼұ���
#define MINOR_LOCK_MAGNETOMETER_ALARM           0x959       //�Ŵ�̽��������
#define MINOR_LOCK_IR_DETECTOR_ALARM            0x95a       //����̽��������
#define MINOR_LOCK_FP_LOCKED_ALARM              0x95b       //ָ����������
#define MINOR_LOCK_PASSWORD_LOCKED_ALARM        0x95c       //������������
#define MINOR_LOCK_HIJIACK_ALARM              0x95d  //���������ٳֱ���

//2018-04-23 ͨ���������ر�����־����
#define MINOR_ALARMHOST_SHORT_CIRCUIT    	      0x1001      //��·����
#define MINOR_ALARMHOST_BROKEN_CIRCUIT   		  0x1002       //��·����
#define MINOR_ALARMHOST_ALARM_RESET      	      0x1003       //������λ
#define MINOR_ALARMHOST_ALARM_NORMAL			  0x1004   	//�����ָ�����
#define MINOR_ALARMHOST_PASSWORD_ERROR 		  0x1005		//�����������3�������������
#define MINOR_ALARMHOST_ID_CARD_ILLEGALLY 	  0x1006		//�Ƿ���Ӧ��ID
#define MINOR_ALARMHOST_KEYPAD_REMOVE 		  0x1007	//���̷���
#define MINOR_ALARMHOST_KEYPAD_REMOVE_RESTORE   0x1008	//���̷���λ

#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT1 	  0x1011	//ģ�������ڱ�����1
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT2 	  0x1012    //ģ�������ڱ�����2
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT3 	  0x1013    //ģ�������ڱ�����3
#define MINOR_ALARMHOST_BELOW_ALARM_LIMIT4 	  0x1014    //ģ�������ڱ�����4
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT1 	  0x1015    //ģ�������ڱ�����1
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT2 	0x1016    //ģ�������ڱ�����2
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT3 	0x1017     //ģ�������ڱ�����3
#define MINOR_ALARMHOST_ABOVE_ALARM_LIMIT4 	0x1018     //ģ�������ڱ�����4

#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_BANDIT 	0x1021      //������˾�
#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_FIRE 		0x1022       //�������
#define MINOR_ALARMHOST_VIRTUAL_DEFENCE_URGENT 		0x1023       //���������

#define MINOR_UPS_ALARM			0x1028      //UPS����
#define MINOR_ELECTRICITY_METER_ALARM 0x1029     //���ܵ����
#define MINOR_SWITCH_POWER_ALARM	  0x1030     //���ص�Դ����
#define MINOR_GAS_DETECT_SYS_ALARM	  0x1031    //������ϵͳ����
#define MINOR_TRANSFORMER_TEMPRATURE_ALARM 0x1032     //��������Ա���
#define MINOR_TEMP_HUMI_ALARM		0x1033   //��ʪ�ȴ���������
#define MINOR_UPS_ALARM_RESTORE	0x1034    //UPS�����ָ�
#define MINOR_ELECTRICITY_METER_ALARM_RESTORE 0x1035   //���ܵ�����ָ�
#define MINOR_SWITCH_POWER_ALARM_RESTORE	0x1036   //���ص�Դ�����ָ�
#define MINOR_GAS_DETECT_SYS_ALARM_RESTORE	  0x1037   //������ϵͳ�����ָ�
#define MINOR_TRANSFORMER_TEMPRATURE_ALARM_RESTORE 0x1038            //��������Ա����ָ�
#define MINOR_TEMP_HUMI_ALARM_RESTORE	0x1039     //��ʪ�ȴ����������ָ�
#define MINOR_WATER_LEVEL_SENSOR_ALARM 		0x1040     //ˮλ����������
#define MINOR_WATER_LEVEL_SENSOR_ALARM_RESTORE 	0x1041  //ˮλ�����������ָ�
#define MINOR_DUST_NOISE_ALARM 	0x1042  //�ﳾ��������������
#define MINOR_DUST_NOISE_ALARM_RESTORE 	0x1043     //�ﳾ���������������ָ�
#define MINOR_ENVIRONMENTAL_LOGGER_ALARM 	0x1044    //�����ɼ��Ǳ���
#define MINOR_ENVIRONMENTAL_LOGGER_ALARM_RESTORE 0x1045            //�����ɼ��Ǳ����ָ�

#define MINOR_TRIGGER_TAMPER    0x1046     //̽��������
#define MINOR_TRIGGER_TAMPER_RESTORE     0x1047    //̽��������ָ�
#define MINOR_EMERGENCY_CALL_HELP_ALARM    0x1048       //����������������
#define MINOR_EMERGENCY_CALL_HELP_ALARM_RESTORE 0x1049            //�����������������ָ�
#define MINOR_CONSULTING_ALARM     0x1050    //ҵ����ѯ����
#define MINOR_CONSULTING_ALARM_RESTORE   0x1051     //ҵ����ѯ�����ָ�
#define MINOR_ALARMHOST_ZONE_MODULE_REMOVE      0x1052    //����ģ�����
#define MINOR_ALARMHOST_ZONE_MODULE_RESET     0x1053       //����ģ�����λ

#define MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM      0x1054      //���ٴ������澯
#define MINOR_ALARMHOST_ALARM_WIND_SPEED_ALARM_RESTORE   0x1055      //���ٴ������澯�ָ�
#define MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_ALARM   0x1056   //ͨ����չ���ģ��澯
#define MINOR_ALARMHOST_ALARM_GENERATE_OUTPUT_RESTORE    0x1057     //ͨ����չ���ģ��澯�ָ�
#define MINOR_ALARMHOST_ALARM_SOAK_ALARM      0x1058      //ˮ���������澯
#define MINOR_ALARMHOST_ALARM_SOAK_ALARM_RESTORE   0x1059  //ˮ���������澯�ָ�
#define MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM    0x1060    //̫���ܴ������澯
#define MINOR_ALARMHOST_ALARM_SOLAR_POWER_ALARM_RESTORE 0x1061   //̫���ܴ������澯�ָ�
#define MINOR_ALARMHOST_ALARM_SF6_ALARM   0x1062      //SF6���������澯
#define MINOR_ALARMHOST_ALARM_SF6_ALARM_RESTORE   0x1063    //SF6���������澯�ָ�
#define MINOR_ALARMHOST_ALARM_WEIGHT_ALARM    0x1064      //�����Ǹ澯
#define MINOR_ALARMHOST_ALARM_WEIGHT_ALARM_RESTORE    0x1065   //�����Ǹ澯�ָ�
#define MINOR_ALARMHOST_ALARM_WEATHER_ALARM   0x1066   //����ɼ�ϵͳ�澯
#define MINOR_ALARMHOST_ALARM_WEATHER_ALARM_RESTORE    0x1067     //����ɼ�ϵͳ�澯�ָ�
#define MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM     0x1068  //ȼ�����ϵͳ�澯
#define MINOR_ALARMHOST_ALARM_FUEL_GAS_ALARM_RESTORE  0x1069 //ȼ�����ϵͳ�澯��
#define MINOR_ALARMHOST_ALARM_FIRE_ALARM   0x1070  //���ֱ���ϵͳ�澯
#define MINOR_ALARMHOST_ALARM_FIRE_ALARM_RESTORE    0x1071   //���ֱ���ϵͳ�澯�ָ�
#define  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_REMOVE     0x1072   //�������ģ�����
#define  MINOR_ALARMHOST_WIRELESS_OUTPUT_MODULE_RESET    0x1073  //�������ģ�����λ
#define  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_REMOVE   0x1074  //�����м�������

#define  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_REMOVE     0x1075  //���߾��ŷ���
#define  MINOR_ALARMHOST_WIRELESS_SIREN_MODULE_RESET     0x1076 //���߾��ŷ���λ

#define  MINOR_RS485_DEV_ALARM     0x1077      //RS485����豸����������豸����δ֪���豸��
#define  MINOR_RS485_DEV_RESTORE    0x1078     //RS485����豸�����ָ�������豸����δ֪���豸��
#define  MINOR_ALARMHOST_ALARM_HOST_ALARM     0x1079      //������������
#define  MINOR_ALARMHOST_ALARM_HOST_RESTORE    0x107a     //�������������ָ�

#define  MINOR_AIR_CONDITION_DEV_ALARM     0x107b      //�յ�����������
#define  MINOR_AIR_CONDITION_DEV_RESTORE    0x107c     //�յ������������ָ�

#define  MINOR_ALARMHOST_WIRELESS_REPEATER_MODULE_RESET  0x107d //�����м�������λ

#define	 MINOR_ALARM_ELEVATOR_BREAKDOWN     0x107e//���ݹ���
#define  MINOR_WATER_PRESSURE_SENSOR_ALARM      0x107f    //ˮѹ����������
#define  MINOR_FLOW_SENSOR_ALARM                0x1080    //��������������
#define  MINOR_SENSOR_LINKAGE_ALARM                0x1081    //��������������
#define  MINOR_SENSOR_LINKAGE_ALARM_RESTORE        0x1082    //���������������ָ�

//LED���������� 0x1201 ~ 0x1300
#define  MINOR_SYSTEM_CHECK_ALARM                  0x1201    //ϵͳ��ⱨ��

/* �쳣 */
//������
#define MAJOR_EXCEPTION                    0x2
//������
#define MINOR_SUBSYSTEM_ERROR           0x0a    /* ��ϵͳ�쳣 */
#define MINOR_RAID_ERROR                0x20    /* �����쳣 */
#define MINOR_VI_LOST                    0x21    /* ��Ƶ�źŶ�ʧ */
#define MINOR_ILLEGAL_ACCESS            0x22    /* �Ƿ����� */
#define MINOR_HD_FULL                    0x23    /* Ӳ���� */
#define MINOR_HD_ERROR                    0x24    /* Ӳ�̴��� */
#define MINOR_DCD_LOST                    0x25    /* MODEM ����(������ʹ��) */
#define MINOR_IP_CONFLICT                0x26    /* IP��ַ��ͻ */
#define MINOR_NET_BROKEN                0x27    /* ����Ͽ�*/
#define MINOR_REC_ERROR                 0x28    /* ¼����� */
#define MINOR_IPC_NO_LINK               0x29    /* IPC�����쳣 */
#define MINOR_VI_EXCEPTION              0x2a    /* ��Ƶ�����쳣(ֻ���ģ��ͨ��) */
#define MINOR_IPC_IP_CONFLICT           0x2b    /*ipc ip ��ַ ��ͻ*/
#define MINOR_SENCE_EXCEPTION           0x2c    // �����쳣

#define MINOR_PIC_REC_ERROR              0x2d    /* ץͼ����--��ȡͼƬ�ļ�ʧ��*/
#define MINOR_VI_MISMATCH                0x2e    /* ��Ƶ��ʽ��ƥ��*/
#define MINOR_RESOLUTION_MISMATCH        0x2f    /*ǰ��/¼��ֱ��ʲ�ƥ��  */

//2009-12-16 ������Ƶ�ۺ�ƽ̨��־����
#define MINOR_FANABNORMAL                0x31    /* ��Ƶ�ۺ�ƽ̨������״̬�쳣 */
#define MINOR_FANRESUME                    0x32    /* ��Ƶ�ۺ�ƽ̨������״̬�ָ����� */
#define MINOR_SUBSYSTEM_ABNORMALREBOOT    0x33    /* ��Ƶ�ۺ�ƽ̨��6467�쳣���� */
#define MINOR_MATRIX_STARTBUZZER        0x34    /* ��Ƶ�ۺ�ƽ̨��dm6467�쳣������������ */

//2010-01-22 ������Ƶ�ۺ�ƽ̨�쳣��־������
#define MINOR_NET_ABNORMAL                0x35    /*����״̬�쳣*/
#define MINOR_MEM_ABNORMAL                0x36    /*�ڴ�״̬�쳣*/
#define MINOR_FILE_ABNORMAL                0x37    /*�ļ�״̬�쳣*/
#define MINOR_PANEL_ABNORMAL            0x38 /*ǰ��������쳣*/
#define MINOR_PANEL_RESUME                0x39 /*ǰ���ָ�����*/    
#define MINOR_RS485_DEVICE_ABNORMAL        0x3a     /*RS485����״̬�쳣*/
#define MINOR_RS485_DEVICE_REVERT        0x3b    /*RS485����״̬�쳣�ָ�*/

//2012-2-18 ���Ӵ����������쳣��־������
#define MINOR_SCREEN_SUBSYSTEM_ABNORMALREBOOT   0x3c            //�Ӱ��쳣����
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALINSERT    0x3d            //�Ӱ����
#define    MINOR_SCREEN_SUBSYSTEM_ABNORMALPULLOUT    0x3e            //�Ӱ�γ�
#define    MINOR_SCREEN_ABNARMALTEMPERATURE        0x3f            //�¶��쳣
//2012-07-26 ��Ƶ�ۺ�ƽ̨v2.1
#define MINOR_HIGH_TEMPERATURE_PROTECT          0x40 //�Ӱ���ȱ���

//Netra 2.2.2
#define MINOR_RECORD_OVERFLOW                   0x41              /*���������*/  
#define MINOR_DSP_ABNORMAL                      0x42              //DSP�쳣 

//Netra 3.0.0
#define MINOR_ANR_RECORD_FAIED                 0x43         /*ANR¼��ʧ��*/ 
#define MINOR_SPARE_WORK_DEVICE_EXCEPT         0x44            /*�ȱ��豸�������쳣*/
#define MINOR_START_IPC_MAS_FAILED             0x45            /*����IPC MASʧ��*/ 
//������ 256·NVR
#define MINOR_IPCM_CRASH                       0x46         /*IPCM�쳣����*/
#define MINOR_POE_POWER_EXCEPTION              0x47         /*POE �����쳣*/
#define MINOR_UPLOAD_DATA_CS_EXCEPTION         0x48          //�ƴ洢�����ϴ�ʧ��/
#define MINOR_DIAL_EXCEPTION                   0x49         /*�����쳣*/
#define MINOR_DEV_EXCEPTION_OFFLINE            0x50  //�豸�쳣����
#define MINOR_UPGRADEFAIL                      0x51 //Զ�������豸ʧ��
#define MINOR_AI_LOST                           0x52    /* ��Ƶ�źŶ�ʧ */
#define MINOR_SYNC_IPC_PASSWD                   0x53    /* ͬ��IPC�����쳣 */
#define MINOR_EZVIZ_OFFLINE                        0x54    /* өʯ�����쳣*/
#define MINOR_VQD_ABNORMAL                        0x55 //VQD�쳣
#define MINOR_ACCESSORIES_PLATE                0x57 //������쳣
#define MINOR_KMS_EXPAMSION_DISK_LOST         0x58 // KMS�����̶�ʧ
#define MINOR_ABNORMAL_PORT                 0x59 // �˿��쳣
#define MINOR_CAMERA_ANGLE_ANOMALY          0x60//  ����ӽ��쳣
#define MINOR_DATA_DISK_ERROE               0x61//  �����̴���  
#define MINOR_INTELLIGENT_SYSTEM_RUNNING_ERROR     0x62//  ����ϵͳ�����쳣
#define MINOR_FACESNAP_RESOLUTION_OVERFLOW         0x63//  ����ץ�������ֱ��ʳ���
#define MINOR_SMD_RESOLUTION_OVERFLOW              0x64//  SMD�����ֱ��ʳ���
#define MINOR_AUDIO_LOSS_EXCEPTION                 0x65//  ��Ƶ��ʧ�쳣
#define MINOR_SAFETY_HELMET_EXCEPTION              0x66 //δ�����ȫñ����쳣
#define MINOR_VCA_PIC_LENGTH_OVERFLOW              0x67 // VCAͼƬ���ȹ��������糬��2M��С��ͼƬ��
#define MINOR_FACE_MODEL_EXCEPTION                 0x68//  ������ģ��ͬ���쳣
#define MINOR_SSD_EXCEPTION                        0x69 // SSD�쳣
//NVR��Ⱥ
#define MINOR_CLUSTER_DEVICE_OFFLINE                 0x70 // ��Ⱥ���豸����
#define MINOR_CLUSTER_CONFIG_FAILED                  0x71 // ��Ⱥ���豸����ʧ��
#define MINOR_CLUSTER_DISASTER_TOLERANCE_EXCEPT      0x72 // ��Ⱥ�����쳣:��ȺCMѡ��ʧ��,��Ⱥ�洢���ڲ���,��Ⱥ������,��Ⱥͨ����Դ����,��Ⱥ�豸�����
#define MINOR_CLUSTER_STORFULL_EXCEPTION             0x73 //��ȺӲ����
#define MINOR_CLUSTER_VERSION_EXCEPTION              0x74  //��Ⱥ�汾�쳣
#define MINOR_CLUSTER_OFFLINENODE_EXCEPTION          0x75   //��Ⱥ����������
#define MINOR_CLUSTER_RECORDCYCLE_EXCEPTION          0x76   //��Ⱥ¼�����ڲ���
#define MINOR_CLUSTER_IPCTRANSFER_EXCEPTION          0x77   //��ȺIPCǨ��ʧ��
#define MINOR_CLUSTER_IPCONFLICT_EXCEPTION           0x78   // ��ȺIP��ͻ����¼CM��IP��ַ

#define MINOR_GET_SUB_STREAM_FAILURE                 0x79//������ȡ��ʧ��
#define MINOR_HDD_SHM_DETECT_EXCEPTION               0x7a//Ӳ��SHM����쳣
#define MINOR_DEVICE_FORTIFY_FAILURE                 0x7b//ǰ���豸��������ʧ��
#define MINOR_EVENT_UPLOAD_EXCEPTION                 0x7c //�¼������쳣���豸�ϴ��¼�ʧ�ܻ��߶����ˣ�

#define MINOR_LORA_EXCEPTION                         0x7d//LoRa�쳣
#define MINOR_AK_OR_SK_IS_EMPTY                      0x7e//�ƴ洢������������Ϊ��

#define MINOR_HIGH_HD_TEMPERATURE   0x80  /*Ӳ���¶ȹ���*/
#define MINOR_LOW_HD_TEMPERATURE   0x81  /*Ӳ���¶ȹ���*/
#define MINOR_HD_IMPACT   0x82  /*Ӳ���ܵ����*/
#define MINOR_HD_BAD_BLOCK   0x83  /*Ӳ�̳��ֻ���*/
#define MINOR_SEVERE_HD_FAILURE   0x84  /*Ӳ�����ع���*/
#define MINOR_RELEASE_FAILED                         0x85 //��Ϣ����ʧ��
#define MINOR_PORT_CONFLICT                          0x86  //�˿ڳ�ͻ
#define MINOR_MODULE_STARTUP_FAILED                  0x87  //ģ������ʧ��
#define  MINIOR_VCA_RUNNING_EXCEPTION     0x88 //���ܰ������쳣

//0x400-0x1000 �Ž��쳣����
#define MINOR_DEV_POWER_ON                     0x400  //�豸�ϵ�����
#define MINOR_DEV_POWER_OFF                    0x401  //�豸����ر�
#define MINOR_WATCH_DOG_RESET                  0x402  //���Ź���λ
#define MINOR_LOW_BATTERY                      0x403  //���ص�ѹ��
#define MINOR_BATTERY_RESUME                   0x404  //���ص�ѹ�ָ�����
#define MINOR_AC_OFF                           0x405  //������ϵ�
#define MINOR_AC_RESUME                        0x406  //������ָ�
#define MINOR_NET_RESUME                       0x407  //����ָ�
#define MINOR_FLASH_ABNORMAL                   0x408  //FLASH��д�쳣
#define MINOR_CARD_READER_OFFLINE              0x409  //����������
#define MINOR_CARD_READER_RESUME               0x40a  //���������߻ָ�                   
#define MINOR_INDICATOR_LIGHT_OFF              0x40b  //ָʾ�ƹر�
#define MINOR_INDICATOR_LIGHT_RESUME           0x40c  //ָʾ�ƻָ�
#define MINOR_CHANNEL_CONTROLLER_OFF           0x40d  //ͨ������������
#define MINOR_CHANNEL_CONTROLLER_RESUME        0x40e  //ͨ���������ָ�
#define MINOR_SECURITY_MODULE_OFF               0x40f  //�ſذ�ȫģ�����
#define MINOR_SECURITY_MODULE_RESUME           0x410  //�ſذ�ȫģ������
#define MINOR_BATTERY_ELECTRIC_LOW             0x411  //��ص�ѹ��(�������豸ʹ��)
#define MINOR_BATTERY_ELECTRIC_RESUME          0x412  //��ص�ѹ�ָ�����(�������豸ʹ��)
#define MINOR_LOCAL_CONTROL_NET_BROKEN           0x413  //�͵ؿ���������Ͽ�
#define MINOR_LOCAL_CONTROL_NET_RSUME           0x414  //�͵ؿ���������ָ�
#define MINOR_MASTER_RS485_LOOPNODE_BROKEN     0x415  //����RS485��·�ڵ�Ͽ�
#define MINOR_MASTER_RS485_LOOPNODE_RESUME     0x416  //����RS485��·�ڵ�ָ�
#define MINOR_LOCAL_CONTROL_OFFLINE            0x417  //�͵ؿ���������
#define MINOR_LOCAL_CONTROL_RESUME             0x418  //�͵ؿ��������߻ָ�
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN  0x419  //�͵�����RS485��·�Ͽ�
#define MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME  0x41a  //�͵�����RS485��·�ָ�
#define MINOR_DISTRACT_CONTROLLER_ONLINE       0x41b  //�ֿ�������
#define MINOR_DISTRACT_CONTROLLER_OFFLINE      0x41c  //�ֿ�������
#define MINOR_ID_CARD_READER_NOT_CONNECT       0x41d  //���֤�Ķ���δ���ӣ�����ר�ã�
#define MINOR_ID_CARD_READER_RESUME            0x41e  //���֤�Ķ������ӻָ�������ר�ã�
#define MINOR_FINGER_PRINT_MODULE_NOT_CONNECT  0x41f  //ָ��ģ��δ���ӣ�����ר�ã�
#define MINOR_FINGER_PRINT_MODULE_RESUME       0x420  //ָ��ģ�����ӻָ�������ר�ã�
#define MINOR_CAMERA_NOT_CONNECT               0x421  //����ͷδ����
#define MINOR_CAMERA_RESUME                    0x422  //����ͷ���ӻָ�
#define MINOR_COM_NOT_CONNECT                  0x423  //COM��δ����
#define MINOR_COM_RESUME                       0x424  //COM�����ӻָ�
#define MINOR_DEVICE_NOT_AUTHORIZE             0x425  //�豸δ��Ȩ
#define MINOR_PEOPLE_AND_ID_CARD_DEVICE_ONLINE 0x426  //��֤�豸����
#define MINOR_PEOPLE_AND_ID_CARD_DEVICE_OFFLINE 0x427 //��֤�豸����
#define MINOR_LOCAL_LOGIN_LOCK                 0x428  //���ص�¼����
#define MINOR_LOCAL_LOGIN_UNLOCK               0x429  //���ص�¼����
#define MINOR_SUBMARINEBACK_COMM_BREAK         0x42a  //�뷴Ǳ�ط�����ͨ�ŶϿ�
#define MINOR_SUBMARINEBACK_COMM_RESUME        0x42b  //�뷴Ǳ�ط�����ͨ�Żָ�
#define MINOR_MOTOR_SENSOR_EXCEPTION           0x42c  //����򴫸����쳣
#define MINOR_CAN_BUS_EXCEPTION                0x42d  //CAN�����쳣
#define MINOR_CAN_BUS_RESUME                   0x42e  //CAN���߻ָ�
#define MINOR_GATE_TEMPERATURE_OVERRUN         0x42f  //բ��ǻ���¶ȳ���
#define MINOR_IR_EMITTER_EXCEPTION             0x430  //��������쳣
#define MINOR_IR_EMITTER_RESUME                0x431  //�������ָ�
#define MINOR_LAMP_BOARD_COMM_EXCEPTION        0x432  //�ư�ͨ���쳣
#define MINOR_LAMP_BOARD_COMM_RESUME           0x433  //�ư�ͨ�Żָ�
#define MINOR_IR_ADAPTOR_COMM_EXCEPTION        0x434  //����ת�Ӱ�ͨ���쳣
#define MINOR_IR_ADAPTOR_COMM_RESUME           0x435  //����ת�Ӱ�ͨ�Żָ�
#define MINOR_PRINTER_ONLINE                    0x436  //��ӡ������
#define MINOR_PRINTER_OFFLINE                    0x437  //��ӡ������
#define MINOR_4G_MOUDLE_ONLINE       0x438  //4Gģ������
#define MINOR_4G_MOUDLE_OFFLINE         0x439  //4Gģ������
#define MINOR_DSP_START_FAILED         0x43a  //DSP����ʧ��
#define MINOR_SMART_REGULATION_NOT_ALLOWED         0x43b  //���ܹ���֧��
#define MINOR_AUXILIARY_BOARD_OFFLINE          0x43c  //���������
#define MINOR_AUXILIARY_BOARD_RESUME           0x43d  //��������߻ָ�
#define MINOR_IDCARD_SECURITY_MOUDLE_EXCEPTION 0x43e  //���֤��ȫģ���쳣
#define MINOR_IDCARD_SECURITY_MOUDLE_RESUME    0x43f  //���֤��ȫģ��ָ�
#define MINOR_FP_PERIPHERAL_EXCEPTION          0x440  //ָ�Ʋɼ������쳣
#define MINOR_FP_PERIPHERAL_RESUME             0x441  //ָ�Ʋɼ�����ָ�


#define MINOR_EXCEPTION_CUSTOM1                 0x900  //�Ž��Զ����쳣1
#define MINOR_EXCEPTION_CUSTOM2                 0x901  //�Ž��Զ����쳣2
#define MINOR_EXCEPTION_CUSTOM3                 0x902  //�Ž��Զ����쳣3
#define MINOR_EXCEPTION_CUSTOM4                 0x903  //�Ž��Զ����쳣4
#define MINOR_EXCEPTION_CUSTOM5                 0x904  //�Ž��Զ����쳣5
#define MINOR_EXCEPTION_CUSTOM6                 0x905  //�Ž��Զ����쳣6
#define MINOR_EXCEPTION_CUSTOM7                 0x906  //�Ž��Զ����쳣7
#define MINOR_EXCEPTION_CUSTOM8                 0x907  //�Ž��Զ����쳣8
#define MINOR_EXCEPTION_CUSTOM9                 0x908  //�Ž��Զ����쳣9
#define MINOR_EXCEPTION_CUSTOM10                0x909  //�Ž��Զ����쳣10
#define MINOR_EXCEPTION_CUSTOM11                0x90a  //�Ž��Զ����쳣11
#define MINOR_EXCEPTION_CUSTOM12                0x90b  //�Ž��Զ����쳣12
#define MINOR_EXCEPTION_CUSTOM13                0x90c  //�Ž��Զ����쳣13
#define MINOR_EXCEPTION_CUSTOM14                0x90d  //�Ž��Զ����쳣14
#define MINOR_EXCEPTION_CUSTOM15                0x90e  //�Ž��Զ����쳣15
#define MINOR_EXCEPTION_CUSTOM16                0x90f  //�Ž��Զ����쳣16
#define MINOR_EXCEPTION_CUSTOM17                0x910  //�Ž��Զ����쳣17
#define MINOR_EXCEPTION_CUSTOM18                0x911  //�Ž��Զ����쳣18
#define MINOR_EXCEPTION_CUSTOM19                0x912  //�Ž��Զ����쳣19
#define MINOR_EXCEPTION_CUSTOM20                0x913  //�Ž��Զ����쳣20
#define MINOR_EXCEPTION_CUSTOM21                0x914  //�Ž��Զ����쳣21
#define MINOR_EXCEPTION_CUSTOM22                0x915  //�Ž��Զ����쳣22
#define MINOR_EXCEPTION_CUSTOM23                0x916  //�Ž��Զ����쳣23
#define MINOR_EXCEPTION_CUSTOM24                0x917  //�Ž��Զ����쳣24
#define MINOR_EXCEPTION_CUSTOM25                0x918  //�Ž��Զ����쳣25
#define MINOR_EXCEPTION_CUSTOM26                0x919  //�Ž��Զ����쳣26
#define MINOR_EXCEPTION_CUSTOM27                0x91a  //�Ž��Զ����쳣27
#define MINOR_EXCEPTION_CUSTOM28                0x91b  //�Ž��Զ����쳣28
#define MINOR_EXCEPTION_CUSTOM29                0x91c  //�Ž��Զ����쳣29
#define MINOR_EXCEPTION_CUSTOM30                0x91d  //�Ž��Զ����쳣30
#define MINOR_EXCEPTION_CUSTOM31                0x91e  //�Ž��Զ����쳣31
#define MINOR_EXCEPTION_CUSTOM32                0x91f  //�Ž��Զ����쳣32
#define MINOR_EXCEPTION_CUSTOM33                0x920  //�Ž��Զ����쳣33
#define MINOR_EXCEPTION_CUSTOM34                0x921  //�Ž��Զ����쳣34
#define MINOR_EXCEPTION_CUSTOM35                0x922  //�Ž��Զ����쳣35
#define MINOR_EXCEPTION_CUSTOM36                0x923  //�Ž��Զ����쳣36
#define MINOR_EXCEPTION_CUSTOM37                0x924  //�Ž��Զ����쳣37
#define MINOR_EXCEPTION_CUSTOM38                0x925  //�Ž��Զ����쳣38
#define MINOR_EXCEPTION_CUSTOM39                0x926  //�Ž��Զ����쳣39
#define MINOR_EXCEPTION_CUSTOM40                0x927  //�Ž��Զ����쳣40
#define MINOR_EXCEPTION_CUSTOM41                0x928  //�Ž��Զ����쳣41
#define MINOR_EXCEPTION_CUSTOM42                0x929  //�Ž��Զ����쳣42
#define MINOR_EXCEPTION_CUSTOM43                0x92a  //�Ž��Զ����쳣43
#define MINOR_EXCEPTION_CUSTOM44                0x92b  //�Ž��Զ����쳣44
#define MINOR_EXCEPTION_CUSTOM45                0x92c  //�Ž��Զ����쳣45
#define MINOR_EXCEPTION_CUSTOM46                0x92d  //�Ž��Զ����쳣46
#define MINOR_EXCEPTION_CUSTOM47                0x92e  //�Ž��Զ����쳣47
#define MINOR_EXCEPTION_CUSTOM48                0x92f  //�Ž��Զ����쳣48
#define MINOR_EXCEPTION_CUSTOM49                0x930  //�Ž��Զ����쳣49
#define MINOR_EXCEPTION_CUSTOM50                0x931  //�Ž��Զ����쳣50
#define MINOR_EXCEPTION_CUSTOM51                0x932  //�Ž��Զ����쳣51
#define MINOR_EXCEPTION_CUSTOM52                0x933  //�Ž��Զ����쳣52
#define MINOR_EXCEPTION_CUSTOM53                0x934  //�Ž��Զ����쳣53
#define MINOR_EXCEPTION_CUSTOM54                0x935  //�Ž��Զ����쳣54
#define MINOR_EXCEPTION_CUSTOM55                0x936  //�Ž��Զ����쳣55
#define MINOR_EXCEPTION_CUSTOM56                0x937  //�Ž��Զ����쳣56
#define MINOR_EXCEPTION_CUSTOM57                0x938  //�Ž��Զ����쳣57
#define MINOR_EXCEPTION_CUSTOM58                0x939  //�Ž��Զ����쳣58
#define MINOR_EXCEPTION_CUSTOM59                0x93a  //�Ž��Զ����쳣59
#define MINOR_EXCEPTION_CUSTOM60                0x93b  //�Ž��Զ����쳣60
#define MINOR_EXCEPTION_CUSTOM61                0x93c  //�Ž��Զ����쳣61
#define MINOR_EXCEPTION_CUSTOM62                0x93d  //�Ž��Զ����쳣62
#define MINOR_EXCEPTION_CUSTOM63                0x93e  //�Ž��Զ����쳣63
#define MINOR_EXCEPTION_CUSTOM64                0x93f  //�Ž��Զ����쳣64
#define MINOR_SWITCH_WIRED_NETWORK            0x950    //�л���������
#define MINOR_SWITCH_WIRELESS_NETWORK         0x951    //�л���������
#define MINOR_LOCK_ONLINE_RESUME              0x952    //�������ָ�����



//2018-04-23 ͨ�����������쳣��־����
#define MINOR_ALARMHOST_WDT_RESET 			    0x1003    //WDT ��λ
#define MINOR_ALARMHOST_RTC_EXCEPTION 			0x1007    //RTCʵʱʱ���쳣

#define MINOR_ALARMHOST_TEL_LINE_CONNECT_FAILURE 	0x100a    //�绰�����Ӷ�
#define MINOR_ALARMHOST_TEL_LINE_CONNECT_RESTORE 	0x100b    //�绰�����ӻָ�
#define MINOR_ALARMHOST_EXPANDER_BUS_LOSS 		0x100c    //��չ����ģ�����
#define MINOR_ALARMHOST_EXPANDER_BUS_RESTORE 	0x100d    //��չ����ģ����߻ָ�
#define MINOR_ALARMHOST_KEYPAD_BUS_LOSS 			0x100e    //��������ģ�����
#define MINOR_ALARMHOST_KEYPAD_BUS_RESTORE 		0x100f    //��������ģ����߻ָ�
#define MINOR_ALARMHOST_SENSOR_FAILURE 			0x1010    //ģ��������������
#define MINOR_ALARMHOST_SENSOR_RESTORE 			0x1011    //ģ�����������ָ�
#define MINOR_ALARMHOST_RS485_CONNECT_FAILURE 	0x1012    //RS485ͨ�����Ӷ�
#define MINOR_ALARMHOST_RS485_CONNECT_RESTORE 	0x1013    //RS485ͨ�����Ӷϻָ�

//�����������쳣���͡����������쳣�ָ�����������־�����������Ӷϡ����������ӻָ�����������־ʱһ���ģ���û���豸֧�֡����������쳣���͡����������쳣�ָ������������͡�
#define	MINOR_ALARMHOST_WIRED_NETWORK_ABNORMAL 	0x1015    //���������쳣
#define	MINOR_ALARMHOST_WIRED_NETWORK_RESTORE 		0x1016    //��������ָ�����
#define	MINOR_ALARMHOST_GPRS_ABNORMAL 				0x1017    //GPRSͨ���쳣
#define	MINOR_ALARMHOST_GPRS_RESTORE 					0x1018    //GPRS�ָ�����
#define	MINOR_ALARMHOST_3G_ABNORMAL 					0x1019    //3Gͨ���쳣
#define	MINOR_ALARMHOST_3G_RESTORE 					0x101a    //3G�ָ�����
#define	MINOR_ALARMHOST_SIM_CARD_ABNORMAL 			0x101b    //SIM���쳣
#define	MINOR_ALARMHOST_SIM_CARD_RESTORE 			0x101c    //SIM���ָ�����

#define	MINOR_FORMAT_HDD_ERROR  0x1026 //Զ�̸�ʽ��Ӳ��ʧ��
#define	MINOR_USB_ERROR		0x1027    //USBͨ�Ź���
#define	MINOR_USB_RESTORE		0x1028    //USBͨ�Ź��ϻָ�
#define	MINOR_PRINT_ERROR	  0x1029    //��ӡ������
#define	MINOR_PRINT_RESTORE   0x1030    //��ӡ�����ϻָ�
#define  MINOR_ALARMHOST_SUBSYSTEM_COMMUNICATION_ERROR    0x1031  //�Ӱ�ͨѶ����

#define  MINOR_MCU_RESTART    0x1035    //MCU����
#define  MINOR_GPRS_MODULE_FAULT    0x1036  //GPRSģ�����
#define  MINOR_TELEPHONE_MODULE_FAULT    0x1037     //�绰ģ�����
#define  MINOR_WIFI_ABNORMAL  0x1038    //WIFIͨ���쳣
#define  MINOR_WIFI_RESTORE    0x1039    //WIFI�ָ�����
#define  MINOR_RF_ABNORMAL   0x103a    //RF�ź��쳣
#define  MINOR_RF_RESTORE     0x103b   //RF�źŻָ�����
#define  MINOR_DETECTOR_ONLINE   0x103c    //̽��������
#define  MINOR_DETECTOR_OFFLINE    0x103d    //̽��������
#define  MINOR_DETECTOR_BATTERY_NORMAL    0x103e  //̽������������        
#define  MINOR_DETECTOR_BATTERY_LOW 0x103f  //̽��������Ƿѹ
#define  MINOR_DATA_TRAFFIC_OVERFLOW    0x1040    //��������
#define  MINOR_ALARMHOST_ZONE_MODULE_LOSS     0x1041    //����ģ�����
#define  MINOR_ALARMHOST_ZONE_MODULE_RESTORE     0x1042    //����ģ����߻ָ�
#define  MINOR_WIRELESS_OUTPUT_LOSS     0x1043    //�������ģ������
#define  MINOR_WIRELESS_OUTPUT_RESTORE    0x1044    //�������ģ��ָ�����
#define  MINOR_WIRELESS_REPEATER_LOSS    0x1045    //�����м�������
#define  MINOR_WIRELESS_REPEATER_RESTORE    0x1046    //�����м����ָ�����
#define  MINOR_ALARMHOST_TRIGGER_MODULE_LOSS     0x1047    //������ģ�����
#define  MINOR_ALARMHOST_TRIGGER_MODULE_RESTORE    0x1048    //������ģ����߻ָ�
#define  MINOR_ALARMHOST_WIRELESS_SIREN_LOSS    0x1049    //���߾�������
#define  MINOR_ALARMHOST_WIRELESS_SIREN_RESTORE     0x104a    //���߾��Żָ�����
#define  MINOR_TX1_SUB_SYSTEM_EXCEPTION             0x1050   /*TX1��ϵͳ�쳣*/
#define MINOR_TX1_REBOOT_EXCEPTION       0x1051   /*TX1ϵͳ�쳣����*/
#define MINOR_TX1_SUB_SYSTEM_LOSS      0x1052   /*������ϵͳ�쳣����*/
#define MINOR_TX1_SUB_SYSTEM_RESTORE     0x1053   /*������ϵͳ���߻ָ�*/
#define MINOR_WIRELESS_SPEED_EXCEPTION   0x1054   //���ߴ��������쳣

//LED �쳣������ 0x1201~0x1300
#define MINOR_LED_SYSTEM_EXCEPTION   0x1201   //LEDϵͳ�쳣
#define MINOR_FLASH_NOTENOUGH_EXCEPTION   0x1202   //FLASH�ռ䲻��

#define MINOR_LOG_EXCEPTION   0x1301   //��־���쳣

//[add]by silujie 2013-3-22 14:16
//0x2000~0x3fff Ϊ�豸������־
//0x4000~0x5000 Ϊ�豸�쳣��־
#define MINOR_SUBSYSTEM_IP_CONFLICT        0x4000        //�Ӱ�IP��ͻ
#define MINOR_SUBSYSTEM_NET_BROKEN        0x4001        //�Ӱ����
#define    MINOR_FAN_ABNORMAL                0x4002        //�����쳣
#define    MINOR_BACKPANEL_TEMPERATURE_ABNORMAL        0x4003        //�����¶��쳣

#define    MINOR_SDCARD_ABNORMAL            0x4004        //SD��������
#define    MINOR_SDCARD_DAMAGE                0x4005        //SD����
#define    MINOR_POC_ABNORMAL				0x4006   //�豸POCģ���쳣
#define MINOR_MAIN_POWER_FAULT              0x4007 //�������
#define MINOR_BACK_UP_POWER_FAULT           0x4008 //�������
#define MINOR_TAMPER_FAULT                  0x4009 //�������
#define MINOR_RS232_FAULT                   0x400a //232���߹���
#define MINOR_RS485_FAULT                   0x400b //485���߹���
#define MINOR_LAN_STATUS_FAULT              0x400c //LAN���߽���״̬����
#define MINOR_LAN_LINK1_FAULT               0x400d //LAN��·1����
#define MINOR_LAN_LINK2_FAULT               0x400e //LAN��·2����
#define MINOR_SIM_CARD_STATUS_FAULT         0x400f //4G-SIM��״̬����
#define MINOR_4G_LINK1_FAULT                0x4010 //4G��·1����
#define MINOR_4G_LINK2_FAULT                0x4011 //4G��·2����
#define MINOR_OTHER_FAULT                   0x4012 //��������
#define MINOR_FIRE_CONTROL_CONNECT_FAULT    0x4013 //�������������ӹ���
#define MINOR_SENSOR_SHORT_CIRCUIT          0x4014 //��������·
#define MINOR_SENSOR_OPEN_CIRCUIT           0x4015 //��������·
#define MINOR_SENSOR_MIS_CONNECT            0x4016 //���������
#define MINOR_SENSOR_FAULT_RESTORE          0x4017 //���������ϻָ�
#define MINOR_DEVICE_FAULT                  0x4018 //�豸����
#define MINOR_OVERVOLTAGE                   0X4019  //��Դ��ѹ����
#define MINOR_UNDERVOLTAGE                  0X401a  //��Դ��ѹ����
#define MINOR_PANLOCKING                    0x401b //��̨ˮƽ��ת
#define MINOR_TILTLOCKING                   0x401c //��̨��ֱ��ת
#define MINOR_SUBBOARD_TEMPERATURE_ABNORMAL   0x401d  //�Ӱ��¶��쳣
#define MINOR_EZVIZ_UPGRADE_EXCEPTION   0x401e   //өʯ�����쳣

//өʯ��ز����쳣��־
#define MINOR_EZVIZ_OPERATION_ABNORMAL   0x4020  //өʯ�����쳣

/* ���� */
//������
#define MAJOR_OPERATION                    0x3

//������
#define MINOR_VCA_MOTIONEXCEPTION        0x29  //��������쳣
#define MINOR_START_DVR                    0x41    /* ���� */
#define MINOR_STOP_DVR                    0x42    /* �ػ� */
#define MINOR_STOP_ABNORMAL                0x43    /* �쳣�ػ� */
#define MINOR_REBOOT_DVR                0x44    /*���������豸*/

#define MINOR_LOCAL_LOGIN                0x50    /* ���ص�½ */
#define MINOR_LOCAL_LOGOUT                0x51    /* ����ע����½ */
#define MINOR_LOCAL_CFG_PARM            0x52    /* �������ò��� */
#define MINOR_LOCAL_PLAYBYFILE          0x53    /* ���ذ��ļ��طŻ����� */
#define MINOR_LOCAL_PLAYBYTIME          0x54    /* ���ذ�ʱ��طŻ�����*/
#define MINOR_LOCAL_START_REC            0x55    /* ���ؿ�ʼ¼�� */
#define MINOR_LOCAL_STOP_REC            0x56    /* ����ֹͣ¼�� */
#define MINOR_LOCAL_PTZCTRL                0x57    /* ������̨���� */
#define MINOR_LOCAL_PREVIEW                0x58    /* ����Ԥ�� (������ʹ��)*/
#define MINOR_LOCAL_MODIFY_TIME         0x59    /* �����޸�ʱ��(������ʹ��) */
#define MINOR_LOCAL_UPGRADE             0x5a    /* �������� */
#define MINOR_LOCAL_RECFILE_OUTPUT      0x5b    /* ���ر���¼���ļ� */
#define MINOR_LOCAL_FORMAT_HDD          0x5c    /* ���س�ʼ��Ӳ�� */
#define MINOR_LOCAL_CFGFILE_OUTPUT      0x5d    /* �������������ļ� */
#define MINOR_LOCAL_CFGFILE_INPUT       0x5e    /* ���뱾�������ļ� */
#define MINOR_LOCAL_COPYFILE            0x5f    /* ���ر����ļ� */
#define MINOR_LOCAL_LOCKFILE            0x60    /* ��������¼���ļ� */
#define MINOR_LOCAL_UNLOCKFILE          0x61    /* ���ؽ���¼���ļ� */
#define MINOR_LOCAL_DVR_ALARM           0x62    /* �����ֶ�����ʹ�������*/
#define MINOR_IPC_ADD                   0x63    /* �������IPC */
#define MINOR_IPC_DEL                   0x64    /* ����ɾ��IPC */
#define MINOR_IPC_SET                   0x65    /* ��������IPC */
#define MINOR_LOCAL_START_BACKUP        0x66    /* ���ؿ�ʼ���� */
#define MINOR_LOCAL_STOP_BACKUP            0x67    /* ����ֹͣ����*/
#define MINOR_LOCAL_COPYFILE_START_TIME 0x68    /* ���ر��ݿ�ʼʱ��*/
#define MINOR_LOCAL_COPYFILE_END_TIME    0x69    /* ���ر��ݽ���ʱ��*/
#define MINOR_LOCAL_ADD_NAS             0x6a    /*�����������Ӳ�� ��nfs��iscsi��*/
#define MINOR_LOCAL_DEL_NAS             0x6b    /* ����ɾ��nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_SET_NAS             0x6c    /* ��������nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_RESET_PASSWD        0x6d    /* ���ػָ�����ԱĬ������*/ 

#define MINOR_REMOTE_LOGIN                0x70    /* Զ�̵�¼ */
#define MINOR_REMOTE_LOGOUT                0x71    /* Զ��ע����½ */
#define MINOR_REMOTE_START_REC            0x72    /* Զ�̿�ʼ¼�� */
#define MINOR_REMOTE_STOP_REC            0x73    /* Զ��ֹͣ¼�� */
#define MINOR_START_TRANS_CHAN            0x74    /* ��ʼ͸������ */
#define MINOR_STOP_TRANS_CHAN            0x75    /* ֹͣ͸������ */
#define MINOR_REMOTE_GET_PARM            0x76    /* Զ�̻�ȡ���� */
#define MINOR_REMOTE_CFG_PARM            0x77    /* Զ�����ò��� */
#define MINOR_REMOTE_GET_STATUS         0x78    /* Զ�̻�ȡ״̬ */
#define MINOR_REMOTE_ARM                0x79    /* Զ�̲��� */
#define MINOR_REMOTE_DISARM                0x7a    /* Զ�̳��� */
#define MINOR_REMOTE_REBOOT                0x7b    /* Զ������ */
#define MINOR_START_VT                    0x7c    /* ��ʼ�����Խ� */
#define MINOR_STOP_VT                    0x7d    /* ֹͣ�����Խ� */
#define MINOR_REMOTE_UPGRADE            0x7e    /* Զ������ */
#define MINOR_REMOTE_PLAYBYFILE         0x7f    /* Զ�̰��ļ��ط� */
#define MINOR_REMOTE_PLAYBYTIME         0x80    /* Զ�̰�ʱ��ط� */
#define MINOR_REMOTE_PTZCTRL            0x81    /* Զ����̨���� */
#define MINOR_REMOTE_FORMAT_HDD         0x82    /* Զ�̸�ʽ��Ӳ�� */
#define MINOR_REMOTE_STOP               0x83    /* Զ�̹ػ� */
#define MINOR_REMOTE_LOCKFILE            0x84    /* Զ�������ļ� */
#define MINOR_REMOTE_UNLOCKFILE         0x85    /* Զ�̽����ļ� */
#define MINOR_REMOTE_CFGFILE_OUTPUT     0x86    /* Զ�̵��������ļ� */
#define MINOR_REMOTE_CFGFILE_INTPUT     0x87    /* Զ�̵��������ļ� */
#define MINOR_REMOTE_RECFILE_OUTPUT     0x88    /* Զ�̵���¼���ļ� */
#define MINOR_REMOTE_DVR_ALARM          0x89    /* Զ���ֶ�����ʹ�������*/
#define MINOR_REMOTE_IPC_ADD            0x8a    /* Զ�����IPC */
#define MINOR_REMOTE_IPC_DEL            0x8b    /* Զ��ɾ��IPC */
#define MINOR_REMOTE_IPC_SET            0x8c    /* Զ������IPC */
#define MINOR_REBOOT_VCA_LIB            0x8d    /*�������ܿ�*/
#define MINOR_REMOTE_ADD_NAS            0x8e   /* Զ�����nas�� ��nfs��iscsi��*/
#define MINOR_REMOTE_DEL_NAS            0x8f   /* Զ��ɾ��nas�� ��nfs��iscsi��*/
#define MINOR_REMOTE_SET_NAS            0x90   /* Զ������nas�� ��nfs��iscsi��*/
#define MINOR_LOCAL_OPERATE_LOCK        0x9d            /* ���ز�������             */
#define MINOR_LOCAL_OPERATE_UNLOCK      0x9e            /* ���ز����������         */
#define MINOR_REMOTE_DELETE_HDISK       0x9a            /* Զ��ɾ���쳣�����ڵ�Ӳ�� */
#define MINOR_REMOTE_LOAD_HDISK         0x9b            /* Զ�̼���Ӳ��             */
#define MINOR_REMOTE_UNLOAD_HDISK       0x9c            /* Զ��ж��Ӳ��   */
#define MINOR_SCHEDULE_ANGLECALIBRATION 0x139            /*�������У׼*/
#define MINOR_OTHER_OPERATE             0x200    /* �������� */

//2010-05-26 ������ѶDVR��־����
#define MINOR_LOCAL_START_REC_CDRW      0x91   /* ���ؿ�ʼѶ�� */
#define MINOR_LOCAL_STOP_REC_CDRW       0x92   /* ����ֹͣѶ�� */
#define MINOR_REMOTE_START_REC_CDRW     0x93   /* Զ�̿�ʼѶ�� */
#define MINOR_REMOTE_STOP_REC_CDRW      0x94   /* Զ��ֹͣѶ�� */

#define MINOR_LOCAL_PIC_OUTPUT            0x95   /* ���ر���ͼƬ�ļ� */ 
#define MINOR_REMOTE_PIC_OUTPUT            0x96   /* Զ�̱���ͼƬ�ļ� */

//2011-07-26 ����81��ѶDVR��־����
#define MINOR_LOCAL_INQUEST_RESUME      0x97   /* ���ػָ���Ѷ�¼�*/
#define MINOR_REMOTE_INQUEST_RESUME     0x98   /* Զ�ָ̻���Ѷ�¼�*/

//2013-01-23 ����86������ѶNVR������־
#define MINOR_LOCAL_ADD_FILE            0x99        /*���ص����ļ�*/
#define MINOR_LOCAL_DEL_FILE            0x9f        /*����ɾ����Ѷ*/
#define MINOR_REMOTE_INQUEST_ADD_FILE   0x100       /*Զ�̵����ļ�*/ 

//2009-12-16 ������Ƶ�ۺ�ƽ̨��־����
#define MINOR_SUBSYSTEMREBOOT           0xa0    /*��Ƶ�ۺ�ƽ̨��dm6467 ��������*/
#define MINOR_MATRIX_STARTTRANSFERVIDEO 0xa1    /*��Ƶ�ۺ�ƽ̨�������л���ʼ����ͼ��*/
#define MINOR_MATRIX_STOPTRANSFERVIDEO    0xa2    /*��Ƶ�ۺ�ƽ̨�������л�ֹͣ����ͼ��*/
#define MINOR_REMOTE_SET_ALLSUBSYSTEM   0xa3    /*��Ƶ�ۺ�ƽ̨����������6467��ϵͳ��Ϣ*/
#define MINOR_REMOTE_GET_ALLSUBSYSTEM   0xa4    /*��Ƶ�ۺ�ƽ̨����ȡ����6467��ϵͳ��Ϣ*/
#define MINOR_REMOTE_SET_PLANARRAY      0xa5    /*��Ƶ�ۺ�ƽ̨�����üƻ���Ѳ��*/
#define MINOR_REMOTE_GET_PLANARRAY      0xa6    /*��Ƶ�ۺ�ƽ̨����ȡ�ƻ���Ѳ��*/
#define MINOR_MATRIX_STARTTRANSFERAUDIO 0xa7    /*��Ƶ�ۺ�ƽ̨�������л���ʼ������Ƶ*/
#define MINOR_MATRIX_STOPRANSFERAUDIO   0xa8    /*��Ƶ�ۺ�ƽ̨�������л�ֹͣ������Ƶ*/
#define MINOR_LOGON_CODESPITTER         0xa9    /*��Ƶ�ۺ�ƽ̨����½�����*/
#define MINOR_LOGOFF_CODESPITTER        0xaa    /*��Ƶ�ۺ�ƽ̨���˳������*/

//2010-01-22 ������Ƶ�ۺ�ƽ̨�н�����������־
#define MINOR_START_DYNAMIC_DECODE         0xb0    /*��ʼ��̬����*/
#define MINOR_STOP_DYNAMIC_DECODE        0xb1    /*ֹͣ��̬����*/
#define MINOR_GET_CYC_CFG                0xb2    /*��ȡ������ͨ����Ѳ����*/
#define MINOR_SET_CYC_CFG                0xb3    /*���ý���ͨ����Ѳ����*/
#define MINOR_START_CYC_DECODE            0xb4    /*��ʼ��Ѳ����*/
#define MINOR_STOP_CYC_DECODE            0xb5    /*ֹͣ��Ѳ����*/
#define MINOR_GET_DECCHAN_STATUS        0xb6    /*��ȡ����ͨ��״̬*/
#define MINOR_GET_DECCHAN_INFO            0xb7    /*��ȡ����ͨ����ǰ��Ϣ*/
#define MINOR_START_PASSIVE_DEC            0xb8    /*��ʼ��������*/
#define MINOR_STOP_PASSIVE_DEC            0xb9    /*ֹͣ��������*/
#define MINOR_CTRL_PASSIVE_DEC            0xba    /*���Ʊ�������*/
#define MINOR_RECON_PASSIVE_DEC            0xbb    /*������������*/
#define MINOR_GET_DEC_CHAN_SW            0xbc    /*��ȡ����ͨ���ܿ���*/
#define MINOR_SET_DEC_CHAN_SW            0xbd    /*���ý���ͨ���ܿ���*/
#define MINOR_CTRL_DEC_CHAN_SCALE        0xbe    /*����ͨ�����ſ���*/
#define MINOR_SET_REMOTE_REPLAY            0xbf    /*����Զ�̻ط�*/
#define MINOR_GET_REMOTE_REPLAY            0xc0    /*��ȡԶ�̻ط�״̬*/
#define MINOR_CTRL_REMOTE_REPLAY        0xc1    /*Զ�̻طſ���*/
#define MINOR_SET_DISP_CFG                0xc2    /*������ʾͨ��*/
#define MINOR_GET_DISP_CFG                0xc3    /*��ȡ��ʾͨ������*/
#define MINOR_SET_PLANTABLE                0xc4    /*���üƻ���Ѳ��*/
#define MINOR_GET_PLANTABLE                0xc5    /*��ȡ�ƻ���Ѳ��*/
#define MINOR_START_PPPPOE                0xc6    /*��ʼPPPoE����*/
#define MINOR_STOP_PPPPOE                0xc7    /*����PPPoE����*/
#define MINOR_UPLOAD_LOGO                0xc8    /*�ϴ�LOGO*/
//��ģʽ������־
#define MINOR_LOCAL_PIN                    0xc9    /* ����PIN���ܲ��� */
#define MINOR_LOCAL_DIAL                0xca    /* �����ֶ������Ͽ����� */    
#define MINOR_SMS_CONTROL                0xcb    /* ���ſ��������� */    
#define MINOR_CALL_ONLINE                0xcc    /* ���п������� */    
#define MINOR_REMOTE_PIN                0xcd    /* Զ��PIN���ܲ��� */

//2010-12-16 ��������־
#define MINOR_REMOTE_BYPASS             0xd0    /* Զ����·*/
#define MINOR_REMOTE_UNBYPASS           0xd1    /* Զ����·�ָ�*/
#define MINOR_REMOTE_SET_ALARMIN_CFG    0xd2    /* Զ�����ñ����������*/
#define MINOR_REMOTE_GET_ALARMIN_CFG    0xd3    /* Զ�̻�ȡ�����������*/
#define MINOR_REMOTE_SET_ALARMOUT_CFG   0xd4    /* Զ�����ñ����������*/
#define MINOR_REMOTE_GET_ALARMOUT_CFG   0xd5    /* Զ�̻�ȡ�����������*/
#define MINOR_REMOTE_ALARMOUT_OPEN_MAN  0xd6    /* Զ���ֶ������������*/
#define MINOR_REMOTE_ALARMOUT_CLOSE_MAN 0xd7    /* Զ���ֶ��رձ������*/
#define MINOR_REMOTE_ALARM_ENABLE_CFG   0xd8    /* Զ�����ñ���������RS485����ʹ��״̬*/
#define MINOR_DBDATA_OUTPUT                0xd9    /* �������ݿ��¼ */
#define MINOR_DBDATA_INPUT                0xda    /* �������ݿ��¼ */
#define MINOR_MU_SWITCH                    0xdb    /* �����л� */
#define MINOR_MU_PTZ                    0xdc    /* ����PTZ���� */
#define MINOR_DELETE_LOGO               0xdd    /* ɾ��logo */
#define MINOR_REMOTE_INQUEST_DEL_FILE   0xde       /*Զ��ɾ���ļ�*/

#define MINOR_LOCAL_CONF_REB_RAID       0x101           /*���������Զ��ؽ�*/
#define MINOR_LOCAL_CONF_SPARE          0x102           /*���������ȱ�*/
#define MINOR_LOCAL_ADD_RAID            0x103           /*���ش�������*/
#define MINOR_LOCAL_DEL_RAID            0x104           /*����ɾ������*/
#define MINOR_LOCAL_MIG_RAID            0x105           /*����Ǩ������*/
#define MINOR_LOCAL_REB_RAID            0x106           /* �����ֶ��ؽ�����*/
#define MINOR_LOCAL_QUICK_CONF_RAID     0x107           /*����һ������*/
#define MINOR_LOCAL_ADD_VD              0x108           /*���ش����������*/
#define MINOR_LOCAL_DEL_VD              0x109           /*����ɾ���������*/
#define MINOR_LOCAL_RP_VD               0x10a           /*�����޸��������*/
#define MINOR_LOCAL_FORMAT_EXPANDVD     0X10b           /*������չ�����������*/
#define MINOR_LOCAL_RAID_UPGRADE        0X10c           /*����raid������*/  
#define MINOR_LOCAL_STOP_RAID           0x10d           /*������ͣRAID����(����ȫ����)*/  
#define MINOR_REMOTE_CONF_REB_RAID      0x111           /*Զ�������Զ��ؽ�*/
#define MINOR_REMOTE_CONF_SPARE         0x112            /*Զ�������ȱ�*/
#define MINOR_REMOTE_ADD_RAID           0x113           /*Զ�̴�������*/
#define MINOR_REMOTE_DEL_RAID           0x114           /*Զ��ɾ������*/
#define MINOR_REMOTE_MIG_RAID           0x115           /*Զ��Ǩ������*/
#define MINOR_REMOTE_REB_RAID           0x116           /* Զ���ֶ��ؽ�����*/
#define MINOR_REMOTE_QUICK_CONF_RAID    0x117           /*Զ��һ������*/
#define MINOR_REMOTE_ADD_VD             0x118           /*Զ�̴����������*/
#define MINOR_REMOTE_DEL_VD             0x119           /*Զ��ɾ���������*/
#define MINOR_REMOTE_RP_VD              0x11a           /*Զ���޸��������*/
#define MINOR_REMOTE_FORMAT_EXPANDVD    0X11b           /*Զ�������������*/
#define MINOR_REMOTE_RAID_UPGRADE       0X11c           /*Զ��raid������*/  
#define MINOR_REMOTE_STOP_RAID          0x11d           /*Զ����ͣRAID����(����ȫ����)*/
#define MINOR_LOCAL_START_PIC_REC       0x121          /*���ؿ�ʼץͼ*/ 
#define MINOR_LOCAL_STOP_PIC_REC        0x122          /*����ֹͣץͼ*/
#define MINOR_LOCAL_SET_SNMP            0x125           /*��������SNMP*/
#define MINOR_LOCAL_TAG_OPT             0x126          /*���ر�ǩ����*/
#define MINOR_REMOTE_START_PIC_REC      0x131          /*Զ�̿�ʼץͼ*/
#define MINOR_REMOTE_STOP_PIC_REC       0x132           /*Զ��ֹͣץͼ*/
#define MINOR_REMOTE_SET_SNMP           0x135            /*Զ������SNMP*/
#define MINOR_REMOTE_TAG_OPT            0x136             /*Զ�̱�ǩ����*/  
#define MINOR_REMOTE_LOGIN_LOCK         0x137           //Զ�̵�¼����
#define MINOR_REMOTE_LOGIN_UNLOCK       0x138          //Զ�̵�¼����
// 9000 v2.2.0
#define MINOR_LOCAL_VOUT_SWITCH         0x140   /* ����������л�����*/
#define MINOR_STREAM_CABAC                 0x141   /* ����ѹ������ѡ�����ò���*/

//Netra 3.0.0
#define MINOR_LOCAL_SPARE_OPT           0x142   /*����N+1 �ȱ���ز���*/
#define MINOR_REMOTE_SPARE_OPT            0x143   /*Զ��N+1 �ȱ���ز���*/
#define MINOR_LOCAL_IPCCFGFILE_OUTPUT    0x144      /* ���ص���ipc�����ļ�*/
#define MINOR_LOCAL_IPCCFGFILE_INPUT      0x145   /* ���ص���ipc�����ļ� */
#define MINOR_LOCAL_IPC_UPGRADE         0x146   /* ��������IPC */
#define MINOR_REMOTE_IPCCFGFILE_OUTPUT  0x147   /* Զ�̵���ipc�����ļ�*/
#define MINOR_REMOTE_IPCCFGFILE_INPUT   0x148   /* Զ�̵���ipc�����ļ�*/
#define MINOR_REMOTE_IPC_UPGRADE        0x149   /* Զ������IPC */

#define MINOR_LOCAL_UNLOAD_HDISK        0x150     /*����ж��Ӳ��*/
#define MINOR_LOCAL_AUDIO_MIX           0x151     /*����������Ƶ��������*/
#define MINOR_REMOTE_AUDIO_MIX          0x152     /*Զ��������Ƶ��������*/
#define MINOR_LOCAL_TRIAL_PAUSE         0x153     /*������ͣѶ��*/
#define MINOR_LOCAL_TRIAL_RESUME        0x154     /*���ؼ���Ѷ��*/
#define MINOR_REMOTE_TRIAL_PAUSE        0x155     /*Զ����ͣѶ��*/
#define MINOR_REMOTE_TRIAL_RESUME       0x156     /*Զ�̼���Ѷ��*/
#define MINOR_REMOTE_MODIFY_VERIFICATION_CODE   0x157 /*�޸�ƽ̨����֤��*/

#define MINOR_LOCAL_MAKECALL            0x180          /*���غ���*/
#define MINOR_LOCAL_REJECTCALL          0x181          /*���ؾܽ�*/
#define MINOR_LOCAL_ANSWERCALL          0x182          /*���ؽ���*/
#define MINOR_LOCAL_HANGUPCALL          0x183          /*���عҶ�*/

#define MINOR_REMOTE_MAKECALL           0x188          /*Զ�̺���*/
#define MINOR_REMOTE_REJECTCALL         0x189          /*Զ�̾ܽ�*/
#define MINOR_REMOTE_ANSWERCALL         0x18a          /*Զ�̽���*/
#define MINOR_REMOTE_HANGUPCALL         0x18b          /*Զ�̹Ҷ�*/

#define MINOR_LOCAL_CHANNEL_ORDERED	         0x19b          /*����ͨ������*/

#define MINOR_SET_MULTI_MASTER          0x201    /*���ô�������*/
#define MINOR_SET_MULTI_SLAVE           0x202    /*���ô�������*/
#define MINOR_CANCEL_MULTI_MASTER       0x203    /*ȡ����������*/
#define MINOR_CANCEL_MULTI_SLAVE        0x204    /*ȡ����������*/

#define MINOR_DISPLAY_LOGO                0x205    /*��ʾLOGO*/
#define MINOR_HIDE_LOGO                 0x206    /*����LOGO*/
#define MINOR_SET_DEC_DELAY_LEVEL       0x207    /*����ͨ����ʱ��������*/
#define MINOR_SET_BIGSCREEN_DIPLAY_AREA 0x208    /*���ô�����ʾ����*/
#define MINOR_CUT_VIDEO_SOURCE          0x209    /*������ƵԴ�и�����*/
#define MINOR_SET_BASEMAP_AREA          0x210    /*������ͼ��������*/
#define MINOR_DOWNLOAD_BASEMAP          0x211    /*���ش�����ͼ*/
#define MINOR_CUT_BASEMAP               0x212    /*��ͼ�и�����*/
#define MINOR_CONTROL_ELEC_ENLARGE      0x213    /*���ӷŴ����(�Ŵ��ԭ)*/
#define MINOR_SET_OUTPUT_RESOLUTION     0x214    /*��ʾ����ֱ�������*/
#define MINOR_SET_TRANCSPARENCY         0X215    /*ͼ��͸��������*/
#define MINOR_SET_OSD                   0x216    /*��ʾOSD����*/
#define MINOR_RESTORE_DEC_STATUS        0x217    /*�ָ���ʼ״̬(�����л�ʱ������ָ���ʼ״̬)*/

//2011-11-11 ���Ӵ���������������־������
#define MINOR_SCREEN_OPEN_SCREEN        0x218   //����Ļ
#define MINOR_SCREEN_CLOSE_SCREEN       0x219   //�ر���Ļ
#define MINOR_SCREEN_SWITCH_SIGNAL      0x21a   //�ź�Դ�л�
#define MINOR_SCREEN_MODIFY_NETWORK     0x21b   //�����������
#define MINOR_SCREEN_MODIFY_LEDRES      0x21c   //���������LED�ֱ���
#define MINOR_SCREEN_SHOW_NORMAL        0x21d   //���ô�����ͨ��ʾģʽ
#define MINOR_SCREEN_SHOW_TILE          0x21e   //���ô���ƽ����ʾģʽ
#define MINOR_SCREEN_DEC_NORMAL         0x21f   //������ͨ����ģʽ
#define MINOR_SCREEN_DEC_LOWLATENCY     0x220   //���õ���ʱ����ģʽ
#define MINOR_SCREEN_MODIFY_SELFRES     0x221   //�����ź�Դ�Զ���ֱ���
#define MINOR_SCREEN_OUTPUT_POSITION    0x222   //����ڹ�����Ļ
#define MINOR_SCREEN_IMAGE_ENHANCE      0x223   //ͼ����ǿ
#define MINOR_SCREEN_JOIN_SIGNAL        0x224   //�ź�Դƴ��
#define MINOR_SCREEN_SIGNAL_OSD         0x225   //�ź�Դ�ַ�����
#define MINOR_SCREEN_ASSOCIATED_INTERACTION 0x226   //�ź�Դ������������������
#define MINOR_SCREEN_MODIFY_MATRIX      0x227   //���þ������
#define MINOR_SCREEN_WND_TOP_KEEP       0x228   //�����ö�����
#define MINOR_SCREEN_WND_OPEN_KEEP      0x229   //���ڴ򿪱���
#define MINOR_SCREEN_WALL_MIRROR        0x22a   //����ǽ������
#define MINOR_SCREEN_UPLOAD_BASEMAP     0x22b   //�ϴ���ͼ
#define MINOR_SCREEN_SHOW_BASEMAP       0x22c   //��ʾ��ͼ
#define MINOR_SCREEN_HIDE_BASEMAP       0x22d   //���ص�ͼ
#define MINOR_SCREEN_MODIFY_SERIAL      0x22e   //���ô��ڲ���

#define MINOR_SCREEN_SET_INPUT          0x251    /*�޸�����Դ*/
#define MINOR_SCREEN_SET_OUTPUT         0x252    /*�޸����ͨ��*/
#define MINOR_SCREEN_SET_OSD            0x253    /*�޸�����LED*/
#define MINOR_SCREEN_SET_LOGO           0x254    /*�޸�LOGO*/
#define MINOR_SCREEN_SET_LAYOUT         0x255    /*���ò���*/
#define MINOR_SCREEN_PICTUREPREVIEW     0x256    /*���Բ���*/


//2012-06-14 CVCS2.0, �������õȲ�����V1.0�� V1.1���Ѿ����ˣ���ʱ���豸��־��û�ж��� 
#define MINOR_SCREEN_GET_OSD            0x257   /*��ȡ����LED*/
#define MINOR_SCREEN_GET_LAYOUT            0x258   /*��ȡ����*/
#define MINOR_SCREEN_LAYOUT_CTRL        0x259   /*���ֿ���*/
#define MINOR_GET_ALL_VALID_WND            0x260    /*��ȡ������Ч����*/
#define MINOR_GET_SIGNAL_WND            0x261    /*��ȡ����������Ϣ*/
#define MINOR_WINDOW_CTRL                0x262    /*���ڿ���*/
#define MINOR_GET_LAYOUT_LIST            0x263    /*��ȡ�����б�*/
#define MINOR_LAYOUT_CTRL                0x264    /*���ֿ���*/
#define MINOR_SET_LAYOUT                0x265    /*���ò���*/
#define MINOR_GET_SIGNAL_LIST            0x266    /*��ȡ�����ź�Դ�б�*/
#define MINOR_GET_PLAN_LIST                0x267    /*��ȡԤ���б�*/
#define MINOR_SET_PLAN                    0x268    /*�޸�Ԥ��*/
#define MINOR_CTRL_PLAN                    0x269    /*����Ԥ��*/
#define MINOR_CTRL_SCREEN                0x270    /*��Ļ����*/
#define MINOR_ADD_NETSIG                0x271    /*����ź�Դ*/
#define MINOR_SET_NETSIG                0x272    /*�޸��ź�Դ*/
#define MINOR_SET_DECBDCFG                0x273    /*���ý�������*/
#define MINOR_GET_DECBDCFG                0x274    /*��ȡ��������*/
#define MINOR_GET_DEVICE_STATUS            0x275    /*��ȡ�豸��Ϣ*/
#define MINOR_UPLOAD_PICTURE            0x276    /*��ͼ�ϴ�*/
#define MINOR_SET_USERPWD                0x277    /*�����û�����*/
#define MINOR_ADD_LAYOUT                0x278    /*��Ӳ���*/
#define MINOR_DEL_LAYOUT                0x279    /*ɾ������*/
#define MINOR_DEL_NETSIG                0x280    /*ɾ���ź�Դ*/
#define MINOR_ADD_PLAN                    0x281    /*���Ԥ��*/
#define MINOR_DEL_PLAN                    0x282    /*ɾ��Ԥ��*/
#define MINOR_GET_EXTERNAL_MATRIX_CFG    0x283    //��ȡ��Ӿ�������
#define MINOR_SET_EXTERNAL_MATRIX_CFG    0x284    //������Ӿ�������
#define    MINOR_GET_USER_CFG                0x285    //��ȡ�û�����
#define    MINOR_SET_USER_CFG                0x286    //�����û�����
#define    MINOR_GET_DISPLAY_PANEL_LINK_CFG 0x287    //��ȡ��ʾǽ��������
#define    MINOR_SET_DISPLAY_PANEL_LINK_CFG 0x288    //������ʾǽ��������

#define    MINOR_GET_WALLSCENE_PARAM        0x289        //��ȡ����ǽ����
#define    MINOR_SET_WALLSCENE_PARAM        0x28a        //���õ���ǽ����
#define    MINOR_GET_CURRENT_WALLSCENE        0x28b        //��ȡ��ǰʹ�ó���
#define    MINOR_SWITCH_WALLSCENE            0x28c        //�����л�
#define    MINOR_SIP_LOGIN                    0x28d        //SIPע��ɹ�
#define MINOR_VOIP_START                0x28e        //VOIP�Խ���ʼ
#define MINOR_VOIP_STOP                    0x28f        //VOIP�Խ�ֹͣ
#define MINOR_WIN_TOP                   0x290       //����ǽ�����ö�
#define MINOR_WIN_BOTTOM                0x291       //����ǽ�����õ�
#define MINOR_SET_USER_ADD_CFG                0x292    //�����û�
#define MINOR_SET_USER_MODF_CFG                0x293    //�޸��û�
#define MINOR_SET_USER_DEL_CFG                0x294    //ɾ���û�

// Netra 2.2.2
#define MINOR_LOCAL_LOAD_HDISK          0x300            //���ؼ���Ӳ��             
#define MINOR_LOCAL_DELETE_HDISK        0x301            //����ɾ���쳣�����ڵ�Ӳ��

//KY2013 3.0.0
#define MINOR_LOCAL_MAIN_AUXILIARY_PORT_SWITCH    0X302 //�����������л�
#define MINOR_LOCAL_HARD_DISK_CHECK                0x303 //��������Ӳ���Լ�

//Netra3.1.0
#define MINOR_LOCAL_CFG_DEVICE_TYPE        0x310    //���������豸����
#define MINOR_REMOTE_CFG_DEVICE_TYPE    0x311    //Զ�������豸����
#define MINOR_LOCAL_CFG_WORK_HOT_SERVER    0x312    //�������ù������ȱ�������
#define MINOR_REMOTE_CFG_WORK_HOT_SERVER 0x313    //Զ�����ù������ȱ�������
#define MINOR_LOCAL_DELETE_WORK            0x314    //����ɾ��������
#define MINOR_REMOTE_DELETE_WORK        0x315    //Զ��ɾ��������
#define    MINOR_LOCAL_ADD_WORK            0x316    //������ӹ�����
#define MINOR_REMOTE_ADD_WORK            0x317    //Զ����ӹ�����
#define MINOR_LOCAL_IPCHEATMAP_OUTPUT   0x318            /* ���ص����ȶ�ͼ�ļ�      */
#define MINOR_LOCAL_IPCHEATFLOW_OUTPUT  0x319          /* ���ص����ȶ������ļ�      */
#define MINOR_REMOTE_SMS_SEND           0x350    /*Զ�̷��Ͷ���*/
#define MINOR_LOCAL_SMS_SEND            0x351   /*���ط��Ͷ���*/
#define MINOR_ALARM_SMS_SEND            0x352    /*���Ͷ��ű���*/
#define MINOR_SMS_RECV                  0x353     /*���ն���*/
//����ע��0x350��0x351��ָ�˹���GUI��IE�ؼ��ϱ༭�����Ͷ��ţ�
#define MINOR_LOCAL_SMS_SEARCH          0x354  /*������������*/
#define MINOR_REMOTE_SMS_SEARCH         0x355   /*Զ����������*/
#define MINOR_LOCAL_SMS_READ            0x356   /*���ز鿴����*/
#define MINOR_REMOTE_SMS_READ           0x357   /*Զ�̲鿴����*/
#define MINOR_REMOTE_DIAL_CONNECT       0x358   /*Զ�̿����ֶ�����*/
#define MINOR_REMOTE_DIAL_DISCONN       0x359   /*Զ��ֹͣ�ֶ�����*/
#define MINOR_LOCAL_WHITELIST_SET       0x35A   /*�������ð�����*/
#define MINOR_REMOTE_WHITELIST_SET      0x35B   /*Զ�����ð�����*/
#define MINOR_LOCAL_DIAL_PARA_SET       0x35C   /*�������ò��Ų���*/
#define MINOR_REMOTE_DIAL_PARA_SET      0x35D   /*Զ�����ò��Ų���*/
#define MINOR_LOCAL_DIAL_SCHEDULE_SET   0x35E   /*�������ò��żƻ�*/
#define MINOR_REMOTE_DIAL_SCHEDULE_SET  0x35F   /*Զ�����ò��żƻ�*/
#define MINOR_PLAT_OPER                 0x360   /* ƽ̨����*/
#define MINOR_REMOTE_CFG_POE_WORK_MODE  0x361//Զ������POE����ģʽ
#define MINOR_LOCAL_CFG_POE_WORK_MODE   0x362//��������POE����ģʽ
#define MINOR_REMOTE_CFG_FACE_CONTRAST  0x363//Զ�����������ȶ�����
#define MINOR_LOCAL_CFG_FACE_CONTRAST   0x364//�������������ȶ�����
#define MINOR_REMOTE_CFG_WHITELIST_FACE_CONTRAST   0x365//Զ�����ð����������ȶ�����
#define MINOR_LOCAL_CFG_WHITELIST_FACE_CONTRAST    0x366//�������ð����������ȶ�����
#define MINOR_LOCAL_CHECK_TIME          0x367   //�����ֶ�Уʱ
#define MINOR_VCA_ONEKEY_EXPORT_PICTURE 0x368 //һ������ͼƬ
#define MINOR_VCA_ONEKEY_DELETE_PICTURE 0x369 //һ��ɾ��ͼƬ
#define MINOR_VCA_ONEKEY_EXPORT_VIDEO   0x36a //һ������¼��
#define MINOR_VCA_ONEKEY_DELETE_VIDEO   0x36b //һ��ɾ��¼��
#define MINOR_REMOTE_CFG_WIRELESS_DIALPARAM 0x36c /*Զ���������߲��Ų���*/
#define MINOR_LOCAL_CFG_WIRELESS_DIALPARAM  0x36d /*�����������߲��Ų���*/
#define MINOR_REMOTE_CFG_WIRELESS_SMSPARAM  0x36e /*Զ���������߶������ò���*/
#define MINOR_LOCAL_CFG_WIRELESS_SMSPARAM   0x36f /*�����������߶������ò���*/
#define MINOR_REMOTE_CFG_WIRELESS_SMSSElFHELP  0x370 /*Զ���������߶����������ò���*/
#define MINOR_LOCAL_CFG_WIRELESS_SMSSElFHELP   0x371 /*�����������߶����������ò���*/
#define MINOR_REMOTE_CFG_WIRELESS_NETFLOWPARAM 0x372 /*Զ�����������������ò���*/
#define MINOR_LOCAL_CFG_WIRELESS_NETFLOWPARAM  0x373 /*�������������������ò���*/

//0x400-0x1000 �Ž���������
#define MINOR_REMOTE_OPEN_DOOR          0x400   //Զ�̿���
#define MINOR_REMOTE_CLOSE_DOOR         0x401   //Զ�̹���(�ܿ�)
#define MINOR_REMOTE_ALWAYS_OPEN        0x402   //Զ�̳���(����)
#define MINOR_REMOTE_ALWAYS_CLOSE       0x403   //Զ�̳���(����)
#define MINOR_REMOTE_CHECK_TIME         0x404   //Զ���ֶ�Уʱ
#define MINOR_NTP_CHECK_TIME            0x405   //NTP�Զ�Уʱ
#define MINOR_REMOTE_CLEAR_CARD         0x406   //Զ����տ���
#define MINOR_REMOTE_RESTORE_CFG        0x407   //Զ�ָ̻�Ĭ�ϲ���
#define MINOR_ALARMIN_ARM               0x408   //��������
#define MINOR_ALARMIN_DISARM            0x409   //��������
#define MINOR_LOCAL_RESTORE_CFG         0x40a   //���ػָ�Ĭ�ϲ��� 
#define MINOR_REMOTE_CAPTURE_PIC        0x40b  //Զ��ץ��
#define MINOR_MOD_NET_REPORT_CFG        0x40c   //�޸��������Ĳ�������
#define MINOR_MOD_GPRS_REPORT_PARAM     0x40d   //�޸�GPRS���Ĳ�������
#define MINOR_MOD_REPORT_GROUP_PARAM    0x40e   //�޸��������������
#define    MINOR_UNLOCK_PASSWORD_OPEN_DOOR  0x40f  //���������
#define MINOR_AUTO_RENUMBER              0x410  //�Զ����±��
#define MINOR_AUTO_COMPLEMENT_NUMBER     0x411  //�Զ�������
#define MINOR_NORMAL_CFGFILE_INPUT          0x412   //������ͨ�����ļ�
#define MINOR_NORMAL_CFGFILE_OUTTPUT     0x413   //������ͨ�����ļ�
#define MINOR_CARD_RIGHT_INPUT              0x414   //���뿨Ȩ�޲���
#define MINOR_CARD_RIGHT_OUTTPUT          0x415   //������Ȩ�޲���
#define MINOR_LOCAL_USB_UPGRADE             0x416   //����U������
#define MINOR_REMOTE_VISITOR_CALL_LADDER     0x417  //�ÿͺ���
#define MINOR_REMOTE_HOUSEHOLD_CALL_LADDER   0x418  //ס������
#define MINOR_REMOTE_ACTUAL_GUARD            0x419  //Զ��ʵʱ����
#define MINOR_REMOTE_ACTUAL_UNGUARD          0x41a  //Զ��ʵʱ����
#define MINOR_REMOTE_CONTROL_NOT_CODE_OPER_FAILED     0x41b   //ң����δ�������ʧ��
#define MINOR_REMOTE_CONTROL_CLOSE_DOOR               0x41c   //ң��������
#define MINOR_REMOTE_CONTROL_OPEN_DOOR                0x41d   //ң��������
#define MINOR_REMOTE_CONTROL_ALWAYS_OPEN_DOOR         0x41e   //ң����������
#define MINOR_M1_CARD_ENCRYPT_VERIFY_OPEN             0x41f    /*M1��������֤���ܿ���*/
#define MINOR_M1_CARD_ENCRYPT_VERIFY_CLOSE            0x420    /*M1��������֤���ܹر�*/
#define MINOR_NFC_FUNCTION_OPEN        0x421    /*NFC���Ź��ܿ���*/
#define MINOR_NFC_FUNCTION_CLOSE       0x422    /*NFC���Ź��ܹر�*/
#define MINOR_OFFLINE_DATA_OUTPUT         0x423    //���߲ɼ����ݵ���
#define MINOR_CREATE_SSH_LINK                         0x42d     //����SSH����
#define MINOR_CLOSE_SSH_LINK                          0x42e     //�Ͽ�SSH����

#define MINOR_OPERATION_CUSTOM1        0x900  //�Ž��Զ������1
#define MINOR_OPERATION_CUSTOM2        0x901  //�Ž��Զ������2
#define MINOR_OPERATION_CUSTOM3        0x902  //�Ž��Զ������3
#define MINOR_OPERATION_CUSTOM4        0x903  //�Ž��Զ������4
#define MINOR_OPERATION_CUSTOM5        0x904  //�Ž��Զ������5
#define MINOR_OPERATION_CUSTOM6        0x905  //�Ž��Զ������6
#define MINOR_OPERATION_CUSTOM7        0x906  //�Ž��Զ������7
#define MINOR_OPERATION_CUSTOM8        0x907  //�Ž��Զ������8
#define MINOR_OPERATION_CUSTOM9        0x908  //�Ž��Զ������9
#define MINOR_OPERATION_CUSTOM10       0x909  //�Ž��Զ������10
#define MINOR_OPERATION_CUSTOM11       0x90a  //�Ž��Զ������11
#define MINOR_OPERATION_CUSTOM12       0x90b  //�Ž��Զ������12
#define MINOR_OPERATION_CUSTOM13       0x90c  //�Ž��Զ������13
#define MINOR_OPERATION_CUSTOM14       0x90d  //�Ž��Զ������14
#define MINOR_OPERATION_CUSTOM15       0x90e  //�Ž��Զ������15
#define MINOR_OPERATION_CUSTOM16       0x90f  //�Ž��Զ������16
#define MINOR_OPERATION_CUSTOM17       0x910  //�Ž��Զ������17
#define MINOR_OPERATION_CUSTOM18       0x911  //�Ž��Զ������18
#define MINOR_OPERATION_CUSTOM19       0x912  //�Ž��Զ������19
#define MINOR_OPERATION_CUSTOM20       0x913  //�Ž��Զ������20
#define MINOR_OPERATION_CUSTOM21       0x914  //�Ž��Զ������21
#define MINOR_OPERATION_CUSTOM22       0x915  //�Ž��Զ������22
#define MINOR_OPERATION_CUSTOM23       0x916  //�Ž��Զ������23
#define MINOR_OPERATION_CUSTOM24       0x917  //�Ž��Զ������24
#define MINOR_OPERATION_CUSTOM25       0x918  //�Ž��Զ������25
#define MINOR_OPERATION_CUSTOM26       0x919  //�Ž��Զ������26
#define MINOR_OPERATION_CUSTOM27       0x91a  //�Ž��Զ������27
#define MINOR_OPERATION_CUSTOM28       0x91b  //�Ž��Զ������28
#define MINOR_OPERATION_CUSTOM29       0x91c  //�Ž��Զ������29
#define MINOR_OPERATION_CUSTOM30       0x91d  //�Ž��Զ������30
#define MINOR_OPERATION_CUSTOM31       0x91e  //�Ž��Զ������31
#define MINOR_OPERATION_CUSTOM32       0x91f  //�Ž��Զ������32
#define MINOR_OPERATION_CUSTOM33       0x920  //�Ž��Զ������33
#define MINOR_OPERATION_CUSTOM34       0x921  //�Ž��Զ������34
#define MINOR_OPERATION_CUSTOM35       0x922  //�Ž��Զ������35
#define MINOR_OPERATION_CUSTOM36       0x923  //�Ž��Զ������36
#define MINOR_OPERATION_CUSTOM37       0x924  //�Ž��Զ������37
#define MINOR_OPERATION_CUSTOM38       0x925  //�Ž��Զ������38
#define MINOR_OPERATION_CUSTOM39       0x926  //�Ž��Զ������39
#define MINOR_OPERATION_CUSTOM40       0x927  //�Ž��Զ������40
#define MINOR_OPERATION_CUSTOM41       0x928  //�Ž��Զ������41
#define MINOR_OPERATION_CUSTOM42       0x929  //�Ž��Զ������42
#define MINOR_OPERATION_CUSTOM43       0x92a  //�Ž��Զ������43
#define MINOR_OPERATION_CUSTOM44       0x92b  //�Ž��Զ������44
#define MINOR_OPERATION_CUSTOM45       0x92c  //�Ž��Զ������45
#define MINOR_OPERATION_CUSTOM46       0x92d  //�Ž��Զ������46
#define MINOR_OPERATION_CUSTOM47       0x92e  //�Ž��Զ������47
#define MINOR_OPERATION_CUSTOM48       0x92f  //�Ž��Զ������48
#define MINOR_OPERATION_CUSTOM49       0x930  //�Ž��Զ������49
#define MINOR_OPERATION_CUSTOM50       0x931  //�Ž��Զ������50
#define MINOR_OPERATION_CUSTOM51       0x932  //�Ž��Զ������51
#define MINOR_OPERATION_CUSTOM52       0x933  //�Ž��Զ������52
#define MINOR_OPERATION_CUSTOM53       0x934  //�Ž��Զ������53
#define MINOR_OPERATION_CUSTOM54       0x935  //�Ž��Զ������54
#define MINOR_OPERATION_CUSTOM55       0x936  //�Ž��Զ������55
#define MINOR_OPERATION_CUSTOM56       0x937  //�Ž��Զ������56
#define MINOR_OPERATION_CUSTOM57       0x938  //�Ž��Զ������57
#define MINOR_OPERATION_CUSTOM58       0x939  //�Ž��Զ������58
#define MINOR_OPERATION_CUSTOM59       0x93a  //�Ž��Զ������59
#define MINOR_OPERATION_CUSTOM60       0x93b  //�Ž��Զ������60
#define MINOR_OPERATION_CUSTOM61       0x93c  //�Ž��Զ������61
#define MINOR_OPERATION_CUSTOM62       0x93d  //�Ž��Զ������62
#define MINOR_OPERATION_CUSTOM63       0x93e  //�Ž��Զ������63
#define MINOR_OPERATION_CUSTOM64       0x93f  //�Ž��Զ������64

#define MINOR_SET_WIFI_PARAMETER               0x950    //����WIFI���ò���
#define MINOR_EZVIZ_LOGIN                      0x951    //өʯ�Ƶ�½
#define MINOR_EZVIZ_LOGINOUT                   0x952    //өʯ�Ƶǳ�
#define MINOR_LOCK_ADD                         0x953    //���������
#define MINOR_LOCK_DELETE                      0x954    //������ɾ��
#define MINOR_LOCK_GET_STATUS                  0x955    //������״̬��ȡ
#define MINOR_LOCK_SET_TMP_PASSWORD            0x956    //��������ʱ�����·�
#define MINOR_LOCK_SET_SILENT_MODE             0x957    //��������������
#define MINOR_LOCK_SET_LATE_WARNING            0x958    //�����������������
#define MINOR_LOCK_IPC_ADD                     0x959    //������IPC����
#define MINOR_LOCK_IPC_REMOVE                  0x95a    //������IPC�������
#define MINOR_LOCK_DETECTOR_ADD                0x95b    //������̽��������
#define MINOR_LOCK_DETECTOR_REMOVE             0x95c    //������̽�����������
#define MINOR_LOCK_MESSAGE_REMINDING_OPEN      0x95d    //��������Ϣ���Ѵ�
#define MINOR_LOCK_MESSAGE_REMINDING_CLOSE     0x95e    //��������Ϣ���ѹر�
#define MINOR_LOCK_SET_HEART_BEAT              0x95f    //��������������
#define MINOR_LOCK_REBOOT                      0x960        //����������
#define MINOR_LOCK_CLEAR_USER                  0x961        //����������û�
#define MINOR_LOCK_FORMAT                      0x962        //��������ʽ��
#define MINOR_LOCK_FINGER_CHANGE               0x963        //������ָ�ƸĶ�
#define MINOR_LOCK_PASSWORD_CHANGE             0x964     //����������Ķ�
#define MINOR_LOCK_CARD_CHANGE                 0x965     //����������Ϣ�Ķ�
#define MINOR_LOCK_USER_CHANGE                 0x966      //�������û���Ϣ�Ķ�
#define MINOR_LOCK_SYSTEM_CHANGE               0x967     //������ϵͳ��Ϣ�Ķ�
#define MINOR_LOCK_CHANGE_ADD_UESR             0x968      //�����������û�
#define MINOR_LOCK_CHANGE_DEL_UESR             0x969     //������ɾ���û�
#define MINOR_LOCK_CHANGE_CUSTOM_USER_NAME     0x96a    //�������Զ����û��û����Ķ�
#define MINOR_LOCK_CHANGE_REMOTE_DEVICE        0x96b  //������ң������Ϣ�Ķ�
#define MINOR_LOCK_CHANGE_ADD_FP               0x96c  //����������ָ��
#define MINOR_LOCK_CHANGE_DEL_FP               0x96d  //������ɾ��ָ��
#define MINOR_LOCK_CHANGE_ADD_PASSWORD         0x96e  //��������������
#define MINOR_LOCK_CHANGE_DEL_PASSWORD         0x96f  //������ɾ������
#define MINOR_LOCK_CHANGE_ADD_CARD             0x970  //������������Ƭ
#define MINOR_LOCK_CHANGE_DEL_CARD             0x971  //������ɾ����Ƭ
#define MINOR_LOCK_NETWORK_SWITCH              0x972  //���������繦�ܿ��ظĶ�
#define MINOR_LOCK_CLEAR_NETWORK_DATA          0x973  //�����������������
#define MINOR_LOCK_CLEAR_HOST_USER             0x974  //��������������û�
#define MINOR_LOCK_CLEAR_GUEST_USER            0x975  //��������տ����û�
#define MINOR_LOCK_CLEAN_ALL_REMOTE_DEVICE     0x976   //ң�����û���Ϣ���
#define MINOR_LOCK_CLEAN_NORMAL_USER_FINGRT    0x977    //�����������ͨ�û�ָ��
#define MINOR_LOCK_CLEAN_ALL_CARD              0x978      //������������п�Ƭ
#define MINOR_LOCK_CLEAN_ALL_PASSWORD          0x979    //�����������������
#define MINOR_START_WIRELESSSERVER             0x97a    //�����豸�ȵ�
#define MINOR_STOP_WIRELESSSERVER              0x97b    //�ر��豸�ȵ�
#define MINOR_EMERGENCY_CARD_AUTH_NORMAL_CARD  0x97c    //Ӧ��������Ȩ��ͨ��
#define MINOR_CHANGE_ALWAYS_OPEN_RIGHT         0x97d    //ͨ��ģʽ�Ķ�
#define MINOR_LOCK_DOOR_BELL_EVENT             0x97e    //�����¼���������������

//������Ϣ����������־
#define MINOR_BACKUP_DATA                           0xc41  //���ݱ���
#define MINOR_TRANSFER_DATA                         0xc42  //����Ǩ��
#define MINOR_RESTORE_DATA                          0xc43  //���ݻ�ԭ
#define MINOR_SET_INPUT_PLAN                        0xc44 //�����ն˶�ʱ�����л��ƻ�
#define MINOR_TERMINAL_ADB                          0xc45//�ն�ADB����
#define MINOR_TERMINAL_VOLUME                       0xc46  //�ն���������
#define MINOR_TERMINAL_LOGO                         0xc47 //�ն�LOGO����
#define MINOR_TERMINAL_DEFAULT_SCHEDULE             0xc48 //��Ƭ�ճ�ʹ��
#define MINOR_TERMINAL_PASSWORD                     0xc49 //�����ն�����
#define MINOR_TERMINAL_IP                           0xc4a//�ն�IP����
#define MINOR_TERMINAL_RELATE_IPC                   0xc4b//�ն˹���IPC
#define MINOR_TERMINAL_SERVER                       0xc4c//�ն˹�������������
#define MINOR_TERMINAL_SADP                         0xc4d//�ն�SADP��������
#define MINOR_TERMINAL_TIMEZONE                     0xc4e//�ն�ʱ������
#define MINOR_TERMINAL_TEMP_PROTECT                 0xc4f//�ն��¶ȱ�������
#define MINOR_ADD_ORGANIZATION                      0xc50 //�����֯
#define MINOR_DELETE_ORGANIZATION                   0xc51 //ɾ����֯
#define MINOR_MODIFY_ORGANIZATION                   0xc52 //�޸���֯ 
#define MINOR_WEATHER_FACTORY                       0xc53 //������������ 
#define MINOR_SADP_ENABLE                           0xc54 //sadp�������� 
#define MINOR_SSH_ENABLE                            0xc55 //SSH��������
#define MINOR_MODIFY_MATERIAL                       0xc56 //�زĲ����޸� 
#define MINOR_INSERT_CHARACTER                      0xc57 //�岥������Ϣ
#define MINOR_TERMINAL_BACKLIGHT                    0xc58 //�ն˱�������
#define MINOR_DOWNLOAD_MATERIAL_THUMBNAIL           0xc59 //�����ز�����ͼ
#define MINOR_UPLOAD_PROGRAM_THUMBNAIL              0xc5a//�ϴ���Ŀ����ͼ
#define MINOR_TDOWNLOAD_PROGRAM_THUMBNAIL           0xc5b//���ؽ�Ŀ����ͼ
#define MINOR_BATCH_DELETE_SCHEDULE_PLAN            0xc5c//����ɾ�������ƻ�
#define MINOR_REPUBLISH                             0xc5d//���·���
#define MINOR_CLEAR_TERMINAL_PLAY_INFO              0xc5e//����ն˲�����Ϣ
#define MINOR_GET_TERMINAL_RESOLUTION               0xc5f//��ȡ�ն˷ֱ���
#define MINOR_SET_TERMINAL_RESOLUTION               0xc60//�����ն˷ֱ���
#define MINOR_GET_BATCH_TERMINAL_UPGRATE_PROGRESS   0xc61//������ȡ�ն���������
#define MINOR_GET_BATCH_PROGRESS                    0xc62//������ȡ�ն˷�������
#define MINOR_GET_TEMPLATE                          0xc64//��ȡģ��
#define MINOR_INIT_TEMPLATE                         0xc65//��ʼ��ģ��
#define MINOR_GET_TERMINAL_NTP_SERVERS              0xc66//��ȡ�ն�NTP����
#define MINOR_SET_TERMINAL_NTP_SERVERS              0xc67//�����ն�NTP����
#define MINOR_GET_RELEASE_DETAILS                   0xc68//��ȡ������ϸ��Ϣ
#define MINOR_UPLOAD_TEMPLATE_THUMBNAIL             0xc69//�ϴ�ģ������ͼ
#define MINOR_DOWNLOAD_TEMPLATE_THUMBNAIL           0xc6a//����ģ������ͼ
#define MINOR_ADD_TEMPLATE                          0xc6b//���ģ��
#define MINOR_DELETE_TEMPLATE                       0xc6c//ɾ��ģ��
#define MINOR_MODIFY_TEMPLATE                       0xc6d//�޸�ģ��
#define MINOR_ADD_SCHEDULE_PLAN                     0xc6e//��ӷ����ƻ�
#define MINOR_MODIFY_SCHEDULE_PLAN                  0xc6f//�޸ķ����ƻ�
#define MINOR_CANCEL_SCHEDULE_RELEASE               0xc70//ȡ���ճ̷���
#define MINOR_GET_SCHEDULE                          0xc71//��ȡ�ճ�
#define MINOR_ADD_INSERT                            0xc72//�½��岥
#define MINOR_CANCEL_INSERT                         0xc73//ȡ���岥
#define MINOR_SWITCH_LANGUAGE                       0xc74//�л�����
#define MINOR_SET_ADMIN_INITIAL_PASSWORD            0xc75//����admin��ʼ����
#define MINOR_MODIFY_PORT                           0xc76//�޸Ķ˿�
#define MINOR_MODIFY_STORAGE_PATH                   0xc77//�޸Ĵ洢·��
#define MINOR_EXIT_PROGRAM                          0xc78//�˳�����
#define MINOR_MODULE_STARTUP_SUCCESS                0xc79//ģ�������ɹ�
#define MINOR_APPROVE_SCHEDULE                      0xc80//�ճ����
#define MINOR_GENERAL_DATA_SEND                     0xc81//�����������·�
#define MINOR_SET_SIGN_INTERFACE                    0xc82//����ǩ���������
#define MINOR_GET_SIGN_INTERFACE                    0xc83//��ȡǩ���������
#define MINOR_SET_SHOW_MODE                         0xc84//������ʾģʽ����
#define MINOR_GET_SHOW_MODE                         0xc85//��ȡ��ʾģʽ����
#define MINOR_SET_SCREEN_DIRECTION                  0xc86//������Ļ�������
#define MINOR_GET_SCREEN_DIRECTION                  0xc87//��ȡ��Ļ�������
#define MINOR_SET_LOCK_SCREEN                       0xc88//������������
#define MINOR_GET_LOCK_SCREEN                       0xc89//��ȡ��������
#define MINOR_SET_FACE_DATA_LIB                     0xc8a//�������������
#define MINOR_DELETE_FACE_DATA_LIB                  0xc8b//ɾ��������
#define MINOR_SET_SPEC_FACE_DATA_LIB                0xc8c//����ָ�����������
#define MINOR_DELETE_SPEC_FACE_DATA_LIB             0xc8d//ɾ��ָ�����������
#define MINOR_ADD_FACE_DATA                         0xc8e//�����������
#define MINOR_SEARCH_FACE_DATA                      0xc8f//��ѯ��������
#define MINOR_MODIFY_FACE_DATA                      0xc90//�޸���������
#define MINOR_DELETE_FACE_DATA                      0xc91//ɾ����������
#define MINOR_DELETE_USERINFO_DETAIL                0xc92//��Ա��Ϣ��Ȩ��ɾ��
#define MINOR_ADD_USERINFO                          0xc93//�����Ա��Ϣ
#define MINOR_MODIFY_USERINFO                       0xc94//�޸���Ա��Ϣ
#define MINOR_DELETE_USERINFO                       0xc95//ɾ����Ա��Ϣ
#define MINOR_ADD_CARD_INFO                         0xc96//��ӿ���Ϣ
#define MINOR_MODIFY_CARD_INFO                      0xc97//�޸Ŀ���Ϣ
#define MINOR_DELETE_CARD_INFO                      0xc98//ɾ������Ϣ
#define MINOR_SET_USER_RIGHT_WEEK                   0xc99//��ԱȨ���ܼƻ�����
#define MINOR_SET_USER_RIGHT_HOLIDAY                0xc9a//��ԱȨ�޽��ռƻ�����
#define MINOR_SET_USER_RIGHT_HOLIDAYGROUP           0xc9b//��ԱȨ�޼�����ƻ�����
#define MINOR_SET_USER_RIGHT_TEMPLATE               0xc9c//��ԱȨ�޼ƻ�ģ������

//2012-03-05 ITC������־����
#define MINOR_SET_TRIGGERMODE_CFG          0x1001    /*���ô���ģʽ����*/
#define MINOR_GET_TRIGGERMODE_CFG          0x1002    /*��ȡ����ģʽ����*/
#define MINOR_SET_IOOUT_CFG                0x1003    /*����IO�������*/
#define MINOR_GET_IOOUT_CFG                0x1004    /*��ȡIO�������*/
#define MINOR_GET_TRIGGERMODE_DEFAULT      0x1005    /*��ȡ����ģʽ�Ƽ�����*/
#define MINOR_GET_ITCSTATUS                0x1006    /*��ȡ״̬������*/
#define MINOR_SET_STATUS_DETECT_CFG        0x1007    /*����״̬������*/
#define MINOR_GET_STATUS_DETECT_CFG        0x1008    /*��ȡ״̬������*/
#define MINOR_SET_VIDEO_TRIGGERMODE_CFG    0x1009  /*������Ƶ����ģʽ����*/
#define MINOR_GET_VIDEO_TRIGGERMODE_CFG    0x100a   /*��ȡ��Ƶ����ģʽ����*/

//2018-04-23 ͨ���������ز�����־����
#define    MINOR_ALARMHOST_GUARD     		0x1010    //��ͨ����(�������)
#define    MINOR_ALARMHOST_UNGUARD 		0x1011    //��ͨ����
#define    MINOR_ALARMHOST_BYPASS 				0x1012    //��·
#define    MINOR_ALARMHOST_DURESS_ACCESS 			0x1013    //Ю��

#define    MINOR_ALARMHOST_RS485_PARAM               0x1018   //�޸�485���ò���
#define    MINOR_ALARMHOST_ALARM_OUTPUT 				0x1019    //���ƴ�����
#define    MINOR_ALARMHOST_ACCESS_OPEN 				0x101a    //�����Ž���
#define    MINOR_ALARMHOST_ACCESS_CLOSE 				0x101b    //�����Ž���
#define    MINOR_ALARMHOST_SIREN_OPEN 				0x101c    //���ƾ��ſ�
#define    MINOR_ALARMHOST_SIREN_CLOSE 				0x101d    //���ƾ��Ź�
#define    MINOR_ALARMHOST_MOD_ZONE_CONFIG 			0x101e    //�޸ķ�������
#define    MINOR_ALARMHOST_MOD_ALARMOUT_CONIFG 	0x101f    //�޸Ĵ���������
#define    MINOR_ALARMHOST_MOD_ANALOG_CONFIG 		0x1020    //�޸�ģ��������
#define    MINOR_ALARMHOST_RS485_CONFIG 				0x1021    //�޸�485ͨ������
#define    MINOR_ALARMHOST_PHONE_CONFIG 				0x1022    //�޸Ĳ�������
#define    MINOR_ALARMHOST_ADD_ADMIN 				0x1023    //���ӹ���Ա
#define    MINOR_ALARMHOST_MOD_ADMIN_PARAM 		0x1024    //�޸Ĺ���Ա����
#define    MINOR_ALARMHOST_DEL_ADMIN 					0x1025    //ɾ������Ա
#define    MINOR_ALARMHOST_ADD_NETUSER 				0x1026    //���Ӻ�˲���Ա
#define    MINOR_ALARMHOST_MOD_NETUSER_PARAM 		0x1027    //�޸ĺ�˲���Ա����
#define    MINOR_ALARMHOST_DEL_NETUSER 				0x1028    //ɾ����˲���Ա
#define    MINOR_ALARMHOST_ADD_OPERATORUSER 		0x1029    //����ǰ�˲���Ա
#define    MINOR_ALARMHOST_MOD_OPERATORUSER_PW 	0x102a    //�޸�ǰ�˲���Ա����
#define    MINOR_ALARMHOST_DEL_OPERATORUSER 		0x102b    //ɾ��ǰ�˲���Ա
#define    MINOR_ALARMHOST_ADD_KEYPADUSER 		0x102c    //���Ӽ���/�������û�	
#define    MINOR_ALARMHOST_DEL_KEYPADUSER 		0x102d    //ɾ������/�������û�	


#define    MINOR_ALARMHOST_MOD_HOST_CONFIG          0x1032    //�޸���������
#define    MINOR_ALARMHOST_RESTORE_BYPASS 			0x1033    //��·�ָ�

#define    MINOR_ALARMHOST_ALARMOUT_OPEN 			0x1034    //����������
#define    MINOR_ALARMHOST_ALARMOUT_CLOSE 			0x1035    //�������ر�
#define    MINOR_ALARMHOST_MOD_SUBSYSTEM_PARAM 	0x1036    //�޸���ϵͳ��������
#define    MINOR_ALARMHOST_GROUP_BYPASS 				0x1037    //����·
#define    MINOR_ALARMHOST_RESTORE_GROUP_BYPASS 	0x1038    //����·�ָ�
#define    MINOR_ALARMHOST_MOD_GRPS_PARAM 			0x1039    //�޸�GPRS����

#define    MINOR_ALARMHOST_MOD_REPORT_MOD 			0x103b    //�޸��ϴ���ʽ����
#define    MINOR_ALARMHOST_MOD_GATEWAY_PARAM 		0x103c    //�޸��Ž���������

#define    MINOR_STAY_ARM 	0x104c    //���ز���
#define    MINOR_QUICK_ARM 			0x104d    //��ʱ����
#define    MINOR_AUTOMATIC_ARM 		0x104e    //�Զ�����
#define    MINOR_AUTOMATIC_DISARM 		0x104f    //�Զ�����
#define    MINOR_KEYSWITCH_ARM 	0x1050  //Կ�ײ�������������
#define    MINOR_KEYSWITCH_DISARM	0x1051  //Կ�ײ�������������
#define    MINOR_CLEAR_ALARM	0x1052    //����
#define    MINOR_MOD_FAULT_CFG		0x1053  //�޸�ϵͳ��������
#define    MINOR_MOD_EVENT_TRIGGER_ALARMOUT_CFG	0x1054  //�޸��¼���������������
#define    MINOR_SEARCH_EXTERNAL_MODULE  0x1055 //�������ģ��
#define    MINOR_REGISTER_EXTERNAL_MODULE 0x1056  //����ע�����ģ��
#define    MINOR_CLOSE_KEYBOARD_ALARM	0x1057 //�رռ��̱�����ʾ��
#define    MINOR_MOD_3G_PARAM		0x1058  //�޸�3G����
#define    MINOR_MOD_PRINT_PARAM 0x1059  //�޸Ĵ�ӡ������
#define    MINOR_ALARMHOST_SD_CARD_FORMAT		0x1060    //SD����ʽ��
#define MINOR_ALARMHOST_SUBSYSTEM_UPGRADE  0x1061 //�Ӱ�̼�����

#define MINOR_PLAN_ARM_CFG     0x1062 //�ƻ���������������
#define MINOR_PHONE_ARM         0x1063 //�ֻ�����
#define MINOR_PHONE_STAY_ARM     0x1064 //�ֻ����ز���
#define MINOR_PHONE_QUICK_ARM   0x1065 //�ֻ���ʱ����
#define MINOR_PHONE_DISARM     0x1066 //�ֻ�����
#define MINOR_PHONE_CLEAR_ALARM     0x1067 //�ֻ�����
#define MINOR_WHITELIST_CFG     0x1068 //����������
#define MINOR_TIME_TRIGGER_CFG    0x1069 //��ʱ���ش���������
#define MINOR_CAPTRUE_CFG     0x106a //ץͼ��������
#define MINOR_TAMPER_CFG    0x106b //���������������

#define MINOR_REMOTE_KEYPAD_UPGRADE    0x106c //Զ����������
#define MINOR_ONETOUCH_AWAY_ARMING  0x106d //һ��������� 
#define MINOR_ONETOUCH_STAY_ARMING     0x106e //һ�����ز���
#define MINOR_SINGLE_PARTITION_ARMING_OR_DISARMING  0x106f //������������ 
#define MINOR_CARD_CONFIGURATION   0x1070 //����������
#define MINOR_CARD_ARMING_OR_DISARMING   0x1071 //ˢ��������
#define MINOR_EXPENDING_NETCENTER_CONFIGURATION    0x1072 //��չ������������
#define MINOR_NETCARD_CONFIGURATION    0x1073 //��������
#define MINOR_DDNS_CONFIGURATION      0x1074 //DDNS����
#define MINOR_RS485BUS_CONFIGURATION    0x1075 // 485���߲�������
#define MINOR_RS485BUS_RE_REGISTRATION     0x1076 //485��������ע��

#define MINOR_REMOTE_OPEN_ELECTRIC_LOCK 0x1077 //Զ�̴򿪵���
#define MINOR_REMOTE_CLOSE_ELECTRIC_LOCK 0x1078 //Զ�̹رյ���
#define MINOR_LOCAL_OPEN_ELECTRIC_LOCK 0x1079 //���ش򿪵���
#define MINOR_LOCAL_CLOSE_ELECTRIC_LOCK 0x107a //���عرյ���
#define MINOR_OPEN_ALARM_LAMP      0x107b //�򿪾���(Զ��)
#define MINOR_CLOSE_ALARM_LAMP      0x107c //�رվ���(Զ��)


#define MINOR_TEMPORARY_PASSWORD   0x107d //��ʱ���������¼

#define MINOR_HIDDNS_CONFIG     0x1082 // HIDDNS����
#define MINOR_REMOTE_KEYBOARD_UPDATA   0x1083 //Զ�̼���������־
#define MINOR_ZONE_ADD_DETECTOR      0x1084 //�������̽����
#define MINOR_ZONE_DELETE_DETECTOR    0x1085 //����ɾ��̽����
#define MINOR_QUERY_DETECTOR_SIGNAL   0x1086 //������ѯ̽�����ź�ǿ��
#define MINOR_QUERY_DETECTOR_BATTERY  0x1087 //������ѯ̽��������
#define MINOR_SET_DETECTOR_GUARD    0x1088 //̽��������
#define MINOR_SET_DETECTOR_UNGUARD   0x1089 //̽��������
#define MINOR_WIRELESS_CONFIGURATION     0x108a  //���߲�������
#define MINOR_OPEN_VOICE        0x108b //������
#define MINOR_CLOSE_VOICE       0x108c //�ر�����
#define MINOR_ENABLE_FUNCTION_KEY     0x108d //���ù��ܼ�
#define MINOR_DISABLE_FUNCTION_KEY      0x108e //�رչ��ܼ�
#define MINOR_READ_CARD    0x108f //Ѳ��ˢ��
#define MINOR_START_BROADCAST     0x1090 //�������㲥
#define MINOR_STOP_BROADCAST   0x1091 //�ر������㲥
#define MINOR_REMOTE_ZONE_MODULE_UPGRADE   0x1092 //Զ����������ģ��
#define MINOR_NETWORK_MODULE_EXTEND   0x1093 //����ģ���������
#define MINOR_ADD_CONTROLLER 	0x1094 //���ң�����û�
#define MINOR_DELETE_CONTORLLER 	0x1095 //ɾ��ң�����û�
#define MINOR_REMOTE_NETWORKMODULE_UPGRADE    0x1096 //Զ����������ģ��
#define MINOR_WIRELESS_OUTPUT_ADD   0x1097 //ע���������ģ��
#define MINOR_WIRELESS_OUTPUT_DEL    0x1098 //ɾ���������ģ��
#define MINOR_WIRELESS_REPEATER_ADD   0x1099 //ע�������м���
#define MINOR_WIRELESS_REPEATER_DEL    0x109a //ɾ�������м���
#define MINOR_PHONELIST_CFG     0x109b //�绰������������
#define MINOR_RF_SIGNAL_CHECK   0x109c // RF�źŲ�ѯ
#define MINOR_USB_UPGRADE   0x109d // USB����
#define MINOR_DOOR_TIME_REMINDER_CFG 0x109f //�ŴŶ�ʱ���Ѳ�������
#define MINOR_WIRELESS_SIREN_ADD    0x1100 //ע�����߾���
#define MINOR_WIRELESS_SIREN_DEL    0x1101 //ɾ�����߾���
#define MINOR_OUT_SCALE_OPEN    0x1102 //���翪��
#define MINOR_OUT_SCALE_CLOSE    0x1103 //����ر�

#define  MINOR_ALARMHOST_4G_MODULS_START  0x1108  //4Gģ������
#define  MINOR_ALARMHOST_4G_MODULS_STOP  0x1109  //4Gģ��ͣ��

#define  MINOR_EZVIZ_CLOUD_START   0x1110   //өʯ������
#define  MINOR_EZVIZ_CLOUD_STOP    0x1111   //өʯ��ͣ��
#define  MINOR_SIPUA_GRID_START    0x1112   //����B����
#define  MINOR_SIPUA_GRID_STOP    0x1113    //����Bͣ��

#define MINOR_MODBUS_FILE_DOWNLOAD   0x1114  //����modbusЭ�������ļ�
#define MINOR_MODBUS_FILE_UPLOAD      0x1115  //����modbusЭ�������ļ�

#define MINOR_RS485_DLL_FILE_DOWNLOAD   0x1116  //����485Э����ļ�
#define MINOR_RS485_DLL_FLIE_UPLOAD   0x1117  //����485Э����ļ�
#define MINOR_TX1_REBOOT              0x1118   //TX1ϵͳ��������

#define MINOR_LORA_PARAM                              0x1119   //LoRa����
#define MINOR_GB28181_PLATE_CFG_PARAM                   0x111a    //����ƽ̨�����������
#define MINOR_GB28181_SERVER_START                0x111b    //�����������
#define MINOR_GB28181_SERVER_STOP                0x111c    //�������ͣ��
#define MINOR_WEB_AUTHENTICATION                 0x111d    //web��֤��ʽ����
#define MINOR_SADP_ENABLED                 0x111e    //SADP��������
#define MINOR_HTTPS_ENABLED                 0x111f    //HTTPS��������
#define MINOR_EZVIZ_PARAM_CFG               0x1120    //өʯ������
#define MINOR_SET_MOTION_DETECTION_CFG      0x1121    //�����ƶ�����������
#define MINOR_GET_MOTION_DETECTION_CFG      0x1122    //��ȡ�ƶ�����������
#define MINOR_SET_SHELTER_ALARM_CFG         0x1123    //�����ڵ�������������
#define MINOR_GET_SHELTER_ALARM_CFG         0x1124    //��ȡ�ڵ�������������
#define MINOR_SET_VIDEO_LOSS_CFG            0x1125    //������Ƶ��ʧ��������
#define MINOR_GET_VIDEO_LOSS_CFG            0x1126    //��ȡ��Ƶ��ʧ��������
#define MINOR_SET_ABNORMAL_CFG              0x1127    //�����쳣��������
#define MINOR_GET_ABNORMAL_CFG              0x1128    //��ȡ�쳣��������
#define MINOR_SET_ALARM_LINKAGE_CFG         0x1129    //���ñ�����������
#define MINOR_GET_ALARM_LINKAGE_CFG         0x112a    //��ȡ������������
#define MINOR_SET_NETWORK_CFG               0x112b    //���������������
#define MINOR_GET_NETWORK_CFG               0x112c    //��ȡ�����������
#define MINOR_SET_VIDEO_MASK_CFG            0x112d    //������Ƶ�ڸǲ�������
#define MINOR_GET_VIDEO_MASK_CFG            0x112e    //��ȡ��Ƶ�ڸǲ�������

#define MINOR_BASIC_OPERATION_CFG           0x112f    //��������
#define MINOR_DISPLAY_EFFECT_ADJUST_CFG     0x1130    //��ʾЧ������
#define MINOR_DISPLAY_PROPERTY_CFG          0x1131    //��ʾ����������
#define MINOR_SIGNAL_CABLE_CFG              0x1132    //�ź���������
#define MINOR_BASIC_CFG                     0x1133    //��������
#define MINOR_IMAGE_ADJUST_CFG              0x1134    //ͼ���������
#define MINOR_IMAGE_ENHANCE_CFG             0x1135    //ͼ����ǿ����
#define MINOR_NOSIGN_SCREEN_SAVER_CFG       0x1136    //���ź�����
#define MINOR_ADVANCED_OPERATION_CFG        0x1137    //�߼�����
#define MINOR_RECEIVE_CARD_CFG              0x1138    //���տ�����
#define MINOR_INPUT_SUPPORT_CFG             0x1139    //����֧�ֹ���
#define MINOR_SYSTEM_MAINTAIN_CFG           0x113a    //ϵͳά������
#define MINOR_SYSTEM_TEST_CFG               0x113b    //ϵͳ�������
#define MINOR_JOINT_CFG                     0x113c    //ƴ������
#define MINOR_SHOW_MODE_CFG                 0x113d    //��ʾģʽ����
#define MINOR_ADVANCED_IMAGE_CFG            0x113e    //�߼�ͼ������


//2013-04-19 ITS������־����
#define MINOR_LOCAL_ADD_CAR_INFO            0x2001  /*������ӳ�����Ϣ*/
#define MINOR_LOCAL_MOD_CAR_INFO            0x2002  /*�����޸ĳ�����Ϣ*/
#define MINOR_LOCAL_DEL_CAR_INFO            0x2003  /*����ɾ��������Ϣ*/
#define MINOR_LOCAL_FIND_CAR_INFO           0x2004  /*���ز��ҳ�����Ϣ*/
#define MINOR_LOCAL_ADD_MONITOR_INFO        0x2005  /*������Ӳ�����Ϣ*/
#define MINOR_LOCAL_MOD_MONITOR_INFO        0x2006  /*�����޸Ĳ�����Ϣ*/
#define MINOR_LOCAL_DEL_MONITOR_INFO        0x2007  /*����ɾ��������Ϣ*/
#define MINOR_LOCAL_FIND_MONITOR_INFO       0x2008  /*���ز�ѯ������Ϣ*/
#define MINOR_LOCAL_FIND_NORMAL_PASS_INFO   0x2009  /*���ز�ѯ����ͨ����Ϣ*/
#define MINOR_LOCAL_FIND_ABNORMAL_PASS_INFO 0x200a  /*���ز�ѯ�쳣ͨ����Ϣ*/
#define MINOR_LOCAL_FIND_PEDESTRIAN_PASS_INFO   0x200b  /*���ز�ѯ����ͨ����Ϣ*/
#define MINOR_LOCAL_PIC_PREVIEW             0x200c  /*����ͼƬԤ��*/
#define MINOR_LOCAL_SET_GATE_PARM_CFG       0x200d  /*���ñ������ó���ڲ���*/
#define MINOR_LOCAL_GET_GATE_PARM_CFG       0x200e  /*��ȡ�������ó���ڲ���*/
#define MINOR_LOCAL_SET_DATAUPLOAD_PARM_CFG 0x200f  /*���ñ������������ϴ�����*/
#define MINOR_LOCAL_GET_DATAUPLOAD_PARM_CFG 0x2010  /*��ȡ�������������ϴ�����*/

//2013-11-19������־����
#define MINOR_LOCAL_DEVICE_CONTROL                         0x2011   /*�����豸����(���ؿ���բ)*/
#define MINOR_LOCAL_ADD_EXTERNAL_DEVICE_INFO               0x2012   /*�����������豸��Ϣ */
#define MINOR_LOCAL_MOD_EXTERNAL_DEVICE_INFO               0x2013   /*�����޸�����豸��Ϣ */
#define MINOR_LOCAL_DEL_EXTERNAL_DEVICE_INFO               0x2014   /*����ɾ������豸��Ϣ */
#define MINOR_LOCAL_FIND_EXTERNAL_DEVICE_INFO              0x2015   /*���ز�ѯ����豸��Ϣ */
#define MINOR_LOCAL_ADD_CHARGE_RULE                        0x2016   /*��������շѹ��� */
#define MINOR_LOCAL_MOD_CHARGE_RULE                        0x2017   /*�����޸��շѹ��� */
#define MINOR_LOCAL_DEL_CHARGE_RULE                        0x2018   /*����ɾ���շѹ��� */
#define MINOR_LOCAL_FIND_CHARGE_RULE                       0x2019   /*���ز�ѯ�շѹ��� */
#define MINOR_LOCAL_COUNT_NORMAL_CURRENTINFO               0x2020   /*����ͳ������ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_NORMAL_CURRENTINFO_REPORT       0x2021   /*���ص�������ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_COUNT_ABNORMAL_CURRENTINFO             0x2022   /*����ͳ���쳣ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_ABNORMAL_CURRENTINFO_REPORT     0x2023   /*���ص����쳣ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_COUNT_PEDESTRIAN_CURRENTINFO           0x2024   /*����ͳ������ͨ����Ϣ */
#define MINOR_LOCAL_EXPORT_PEDESTRIAN_CURRENTINFO_REPORT   0x2025   /*���ص�������ͨ����Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_FIND_CAR_CHARGEINFO                    0x2026   /*���ز�ѯ�����շ���Ϣ */
#define MINOR_LOCAL_COUNT_CAR_CHARGEINFO                   0x2027   /*����ͳ�ƹ����շ���Ϣ */
#define MINOR_LOCAL_EXPORT_CAR_CHARGEINFO_REPORT           0x2028   /*���ص��������շ���Ϣͳ�Ʊ��� */
#define MINOR_LOCAL_FIND_SHIFTINFO                         0x2029   /*���ز�ѯ���Ӱ���Ϣ */
#define MINOR_LOCAL_FIND_CARDINFO                          0x2030   /*���ز�ѯ��Ƭ��Ϣ */
#define MINOR_LOCAL_ADD_RELIEF_RULE                        0x2031   /*������Ӽ������ */
#define MINOR_LOCAL_MOD_RELIEF_RULE                        0x2032   /*�����޸ļ������ */
#define MINOR_LOCAL_DEL_RELIEF_RULE                        0x2033   /*����ɾ��������� */
#define MINOR_LOCAL_FIND_RELIEF_RULE                       0x2034   /*���ز�ѯ������� */
#define MINOR_LOCAL_GET_ENDETCFG                           0x2035   /*���ػ�ȡ����ڿ��ƻ����߼������ */ 
#define MINOR_LOCAL_SET_ENDETCFG                           0x2036   /*�������ó���ڿ��ƻ����߼������*/
#define MINOR_LOCAL_SET_ENDEV_ISSUEDDATA                   0x2037   /*�������ó���ڿ��ƻ��·���Ƭ��Ϣ */
#define MINOR_LOCAL_DEL_ENDEV_ISSUEDDATA                   0x2038   /*������ճ���ڿ��ƻ��·���Ƭ��Ϣ */

#define MINOR_REMOTE_DEVICE_CONTROL                        0x2101   /*Զ���豸����*/
#define MINOR_REMOTE_SET_GATE_PARM_CFG                     0x2102   /*����Զ�����ó���ڲ���*/
#define MINOR_REMOTE_GET_GATE_PARM_CFG                     0x2103   /*��ȡԶ�����ó���ڲ���*/
#define MINOR_REMOTE_SET_DATAUPLOAD_PARM_CFG               0x2104   /*����Զ�����������ϴ�����*/
#define MINOR_REMOTE_GET_DATAUPLOAD_PARM_CFG               0x2105   /*��ȡԶ�����������ϴ�����*/
#define MINOR_REMOTE_GET_BASE_INFO                         0x2106   /*Զ�̻�ȡ�ն˻�����Ϣ*/
#define MINOR_REMOTE_GET_OVERLAP_CFG                       0x2107   /*Զ�̻�ȡ�ַ����Ӳ�������*/              
#define MINOR_REMOTE_SET_OVERLAP_CFG                       0x2108   /*Զ�������ַ����Ӳ�������*/ 
#define MINOR_REMOTE_GET_ROAD_INFO                         0x2109   /*Զ�̻�ȡ·����Ϣ*/
#define MINOR_REMOTE_START_TRANSCHAN                       0x210a   /*Զ�̽���ͬ�����ݷ�����*/
#define MINOR_REMOTE_GET_ECTWORKSTATE                      0x210b   /*Զ�̻�ȡ������ն˹���״̬*/
#define MINOR_REMOTE_GET_ECTCHANINFO                       0x210c   /*Զ�̻�ȡ������ն�ͨ��״̬*/

//Զ�̿��� 2013-11-19
#define MINOR_REMOTE_ADD_EXTERNAL_DEVICE_INFO              0x210d   /*Զ���������豸��Ϣ */
#define MINOR_REMOTE_MOD_EXTERNAL_DEVICE_INFO              0x210e   /*Զ���޸�����豸��Ϣ */
#define MINOR_REMOTE_GET_ENDETCFG                          0x210f   /*Զ�̻�ȡ����ڿ��ƻ����߼������ */ 
#define MINOR_REMOTE_SET_ENDETCFG                          0x2110   /*Զ�����ó���ڿ��ƻ����߼������*/
#define MINOR_REMOTE_ENDEV_ISSUEDDATA                      0x2111   /*Զ�����ó���ڿ��ƻ��·���Ƭ��Ϣ */
#define MINOR_REMOTE_DEL_ENDEV_ISSUEDDATA                  0x2112   /*Զ����ճ���ڿ��ƻ��·���Ƭ��Ϣ */

//ITS 0x2115~0x2120 ͣ������λ��Ŀ
#define MINOR_REMOTE_ON_CTRL_LAMP           0x2115  /*����Զ�̿��Ƴ�λָʾ��*/       
#define MINOR_REMOTE_OFF_CTRL_LAMP          0x2116  /*�ر�Զ�̿��Ƴ�λָʾ��*/
//Netra3.1.0
#define MINOR_SET_VOICE_LEVEL_PARAM         0x2117  /*����������С */
#define MINOR_SET_VOICE_INTERCOM_PARAM      0x2118  /*��������¼�� */
#define MINOR_SET_INTELLIGENT_PARAM         0x2119  /*��������*/ 
#define MINOR_LOCAL_SET_RAID_SPEED          0x211a  /*��������raid�ٶ�*/
#define MINOR_REMOTE_SET_RAID_SPEED         0x211b /*Զ������raid�ٶ�*/
//Nerta3.1.2
#define MINOR_REMOTE_CREATE_STORAGE_POOL    0x211c   //Զ����Ӵ洢��
#define MINOR_REMOTE_DEL_STORAGE_POOL       0x211d    //Զ��ɾ���洢��

#define MINOR_REMOTE_DEL_PIC                0x2120   //Զ��ɾ��ͼƬ����
#define MINOR_REMOTE_DEL_RECORD             0x2121   //Զ��ɾ��¼������
#define MINOR_REMOTE_CLOUD_ENABLE           0x2123  //Զ��������ϵͳ����
#define MINOR_REMOTE_CLOUD_DISABLE          0x2124  //Զ��������ϵͳ����
#define MINOR_REMOTE_CLOUD_MODIFY_PARAM     0x2125  //Զ���޸Ĵ洢�ز���
#define MINOR_REMOTE_CLOUD_MODIFY_VOLUME    0x2126  //Զ���޸Ĵ洢������
#define MINOR_REMOTE_GET_GB28181_SERVICE_PARAM    0x2127  //Զ�̻�ȡGB28181�������
#define MINOR_REMOTE_SET_GB28181_SERVICE_PARAM    0x2128  //Զ������GB28181�������
#define MINOR_LOCAL_GET_GB28181_SERVICE_PARAM     0x2129  //���ػ�ȡGB28181�������
#define MINOR_LOCAL_SET_GB28181_SERVICE_PARAM     0x212a  //��������B28181�������
#define MINOR_REMOTE_SET_SIP_SERVER               0x212b  //Զ������SIP SERVER
#define MINOR_LOCAL_SET_SIP_SERVER                0x212c  //��������SIP SERVER
#define MINOR_LOCAL_BLACKWHITEFILE_OUTPUT         0x212d  //���غڰ���������
#define MINOR_LOCAL_BLACKWHITEFILE_INPUT          0x212e  //���غڰ���������
#define MINOR_REMOTE_BALCKWHITECFGFILE_OUTPUT     0x212f  //Զ�̺ڰ���������
#define MINOR_REMOTE_BALCKWHITECFGFILE_INPUT      0x2130  //Զ�̺ڰ���������


#define MINOR_REMOTE_CREATE_MOD_VIEWLIB_SPACE        0x2200    /*Զ�̴���/�޸���ͼ��ռ�*/
#define MINOR_REMOTE_DELETE_VIEWLIB_FILE            0x2201    /*Զ��ɾ����ͼ���ļ�*/
#define MINOR_REMOTE_DOWNLOAD_VIEWLIB_FILE            0x2202    /*Զ��������ͼ���ļ�*/
#define MINOR_REMOTE_UPLOAD_VIEWLIB_FILE            0x2203    /*Զ���ϴ���ͼ���ļ�*/
#define MINOR_LOCAL_CREATE_MOD_VIEWLIB_SPACE        0x2204    /*���ش���/�޸���ͼ��ռ�*/

#define MINOR_LOCAL_SET_DEVICE_ACTIVE   0x3000  //���ؼ����豸
#define MINOR_REMOTE_SET_DEVICE_ACTIVE  0x3001  //Զ�̼����豸
#define MINOR_LOCAL_PARA_FACTORY_DEFAULT    0x3002  //���ػظ���������
#define MINOR_REMOTE_PARA_FACTORY_DEFAULT   0x3003  //Զ�ָ̻���������

/*��Ϣ����������������־*/
#define MINOR_UPLAOD_STATIC_MATERIAL                0x2401  //��̬�ز��ϴ�
#define MINOR_UPLOAD_DYNAMIC_MATERIAL               0x2402  //��̬�ز��ϴ�
#define MINOR_DELETE_MATERIAL                       0x2403  //ɾ���ز�
#define MINOR_DOWNLOAD_STATIC_MATERIAL              0x2404  //��̬�ز�����
#define MINOR_COVER_STATIC_MATERIAL                 0x2405  //��̬�زĸ���
#define MINOR_APPROVE_MATERIAL                      0x2406  //�ز����
#define MINOR_UPLAOD_PROGRAM                        0x2407  //�ϴ���Ŀ
#define MINOR_DOWNLOAD_PROGRAM                      0x2408  //���ؽ�Ŀ
#define MINOR_DELETE_PROGRAM                        0x2409  //ɾ����Ŀ
#define MINOR_MODIFY_PROGRAM                        0x240a  //��Ŀ�����޸�
#define MINOR_APPROVE_PRAGRAM                       0x240b  //��Ŀ���
#define MINOR_UPLAOD_SCHEDULE                       0x240c  //�ϴ��ճ�
#define MINOR_DOWNLOAD_SCHEDULE                     0x240d  //�����ճ�
#define MINOR_DELETE_SCHEDULE                       0x240e  //ɾ���ճ�
#define MINOR_MODIFY_SCHEDULE                       0x240f  //�޸��ճ�����
#define MINOR_RELEASE_SCHEDULE                      0x2410  //�����ճ�
#define MINOR_ADD_TERMINAL                          0x2411  //����ն�
#define MINOR_DELETE_TERMINAL                       0x2412  //ɾ���ն�
#define MINOR_MODIFY_TERMIANL_PARAM                 0x2413  //�޸��ն˲���            
#define MINOR_MODIFY_TERMIANL_PLAY_PARAM            0x2414  //�����ն˲��Ų���
#define MINOR_ADD_TERMIANL_GROUP                    0x2415  //����ն���
#define MINOR_MODIFY_TERMINAL_GROUP_PARAM           0x2416  //�޸��ն������
#define MINOR_DELETE_TERMIANL_GROUP                 0x2417  //ɾ���ն���
#define MINOR_TERMINAL_PLAY_CONTROL                 0x2418  //�ն˲��ſ���
#define MINOR_TERMINAL_ON_OFF_LINE                  0x2419  //�ն�������
#define MINOR_SET_SWITCH_PLAN                       0x241a  //�����ն˶�ʱ���ػ��ƻ�
#define MINOR_SET_VOLUME_PLAN                       0x241b  //�����ն˶�ʱ�����ƻ�
#define MINOR_TERMINAL_SCREENSHOT                   0x241c  //�ն˽���
#define MINOR_SYSTEM_TIME_CFG                       0x241d   //ϵͳУʱ
#define MINOR_ADD_USER_CFG                          0x241e    //����û�����
#define MINOR_DEL_USER_CFG                          0x241f    //ɾ���û�����
#define MINOR_REMOTE_MANAGE_HDD                     0x2420   //Զ�̱༭Ӳ��
#define MINOR_TERMINAL_UPDATE_START                 0x2421   //�ն�����
#define MINOR_SVR_RESTORE_DEFAULT_PARAM             0x2422   //������Զ�ָ̻�Ĭ��
#define MINOR_SVR_REMOTE_RESTORE_FACTORY            0x2423   //������Զ�ָ̻���������
#define MINOR_SVR_REMOTE_REBOOT                     0x2424   //������Զ������
#define MINOR_SVR_MODIFY_NETWORK_PARAM              0x2425   //��������������޸�
#define MINOR_SVR_SOFTWARE_UPGRADE                  0x2426     //�������������



#define MINOR_REMOTE_CONFERENCE_CONFIG             0x2501  //MCU��������
#define MINOR_REMOTE_TERMINAL_CONFIG               0x2502  //MCU�ն�����
#define MINOR_REMOTE_GROUP_CONFIG                  0x2503  //MCU��������
#define MINOR_REMOTE_CONFERENCE_CTRL               0x2504  //MCU�������
#define MINOR_REMOTE_TERMINAL_CTRL                 0x2505  //MCU�ն˿���

//NVR���
#define MINOR_LOCAL_RESET_LOGIN_PASSWORD           0x2600    /* ��������admin��½����*/ 
#define MINOR_REMOTE_RESET_LOGIN_PASSWORD          0x2601    /* Զ������admin��¼���� */
#define MINOR_LOCAL_FACE_BASE_CREATE        0x2602    /* ���������Աȿⴴ��*/ 
#define MINOR_REMOTE_FACE_BASE_CREATE       0x2603    /* Զ�������Աȿⴴ��*/
#define MINOR_LOCAL_FACE_BASE_MODIFY        0x2604    /* ���������Աȿ��޸�*/ 
#define MINOR_REMOTE_FACE_BASE_MODIFY      0x2605    /* Զ�������Աȿ��޸�*/
#define MINOR_LOCAL_FACE_BASE_DELETE        0x2606    /* ���������Աȿ�ɾ��*/ 
#define MINOR_REMOTE_FACE_BASE_DELETE       0x2607    /* Զ�������Աȿ�ɾ��*/
#define MINOR_LOCAL_FACE_DATA_APPEND        0x2608    /* ����¼����������*/ 
#define MINOR_REMOTE_FACE_DATA_APPEND       0x2609    /* Զ��¼����������*/
#define MINOR_LOCAL_FACE_DATA_SEARCH       0x2610    /* ���������ȶ����ݲ���*/ 
#define MINOR_REMOTE_FACE_DATA_SEARCH       0x2611    /* Զ�������ȶ����ݲ���*/
#define MINOR_LOCAL_FACE_DATA_ANALYSIS        0x2612    /* ����ͼƬ��������*/ 
#define MINOR_REMOTE_FACE_DATA_ANALYSIS       0x2613    /* Զ��ͼƬ��������*/
#define MINOR_LOCAL_FACE_DATA_EDIT            0x2614    /* �������������޸�*/ 
#define MINOR_REMOTE_FACE_DATA_EDIT           0x2615    /* Զ�����������޸�*/

#define MINOR_LOCAL_FACE_DATA_DELETE          0x2616    /* ������������ɾ��*/ 
#define MINOR_REMOTE_FACE_DATA_DELET          0x2617    /* Զ����������ɾ��*/

#define MINOR_LOCAL_VCA_ANALYSIS_CFG          0x2618    /* �������ܷ�������*/ 
#define MINOR_REMOTE_VCA_ANALYSIS_CFG         0x2619    /* Զ�����ܷ�������*/

#define MINOR_LOCAL_FACE_BASE_IMPORT          0x261a    /* ���ص���������*/ 
#define MINOR_LOCAL_FACE_BASE_EXPORT          0x261b    /* ���ص���������*/
//NVR��Ⱥ
#define MINOR_REMOTE_CLUSTER_MODE_CONFIG      0x261c    /* Զ�̼�Ⱥģʽ���ò���*/
#define MINOR_LOCAL_CLUSTER_MODE_CONFIG       0x261d    /* ���ؼ�Ⱥģʽ���ò���*/
#define MINOR_REMOTE_CLUSTER_NETWORK_CONFIG   0x261e    /* Զ�̼�Ⱥ�������ò���*/
#define MINOR_LOCAL_CLUSTER_NETWORK_CONFIG    0x261f    /* ���ؼ�Ⱥ�������ò���*/
#define MINOR_REMOTE_CLUSTER_ADD_DEVICE       0x2620    /* Զ�̼�Ⱥ����豸����*/
#define MINOR_LOCAL_CLUSTER_ADD_DEVICE        0x2621    /* ���ؼ�Ⱥ����豸����*/
#define MINOR_REMOTE_CLUSTER_DEL_DEVICE       0x2622    /* Զ�̼�Ⱥɾ���豸����*/
#define MINOR_LOCAL_CLUSTER_DEL_DEVICE        0x2623    /* ���ؼ�Ⱥɾ���豸����*/
#define MINOR_REMOTE_HFPD_CFG                 0x2624  /* Զ�̸�Ƶ��Ա�������*/
#define MINOR_REMOTE_FACE_CONTRAST_TASK       0x2625 /* Զ�������ȶ��������� */
#define MINOR_REMOTE_LFPD_CFG                 0x2626  /* Զ�̵�Ƶ��Ա�������*/
#define MINOR_REMOTE_IOTCFGFILE_INPUT         0x2627//Զ�̵���IOT�����ļ�
#define MINOR_REMOTE_IOTCFGFILE_OUTPUT        0x2628//Զ�̵���IOT�����ļ�
#define MINOR_LOCAL_IOT_ADD                   0x2629//�������IOTͨ��
#define MINOR_REMOTE_IOT_ADD                  0x262a//Զ�����IOTͨ��
#define MINOR_LOCAL_IOT_DEL                   0x262b//����ɾ��IOTͨ��
#define MINOR_REMOTE_IOT_DEL                  0x262c//Զ��ɾ��IOTͨ��
#define MINOR_LOCAL_IOT_SET                   0x262d//��������IOTͨ��
#define MINOR_REMOTE_IOT_SET                  0x262e//Զ������IOTͨ��
#define MINOR_LOCAL_IOTCFGFILE_INPUT          0x262f //���ص���IOT�����ļ�
#define MINOR_LOCAL_IOTCFGFILE_OUTPUT         0x2630//���ص���IOT�����ļ�
#define MINOR_LOCAL_VAD_CFG                   0x2631  /* ����������������*/
#define MINOR_REMOTE_VAD_CFG                  0x2632  /* Զ��������������*/
#define MINOR_LOCAL_ADDRESS_FILTER_CONFIG     0x2633    /* ���ص�ַ��������*/ 
#define MINOR_REMOTE_ADDRESS_FILTER_CONFIG    0x2634    /* Զ�̵�ַ��������*/
#define MINOR_LOCAL_POE_CFG                     0x2635    /* ����POE����*/ 
#define MINOR_REMOTE_POE_CFG                    0x2636    /* Զ��POE����*/
#define MINOR_LOCAL_RESET_CHANNEL_PASSWORD        0x2637    /* ��������ͨ������*/ 
#define MINOR_REMOTE_RESET_CHANNEL_PASSWORD       0x2638    /* Զ������ͨ������*/
#define MINOR_LOCAL_SSD_UPGRADE_START                   0x2639    /* ����SSD�ļ�ϵͳ������ʼ*/ 
#define MINOR_LOCAL_SSD_UPGRADE_STOP                    0x2640    /* ����SSD�ļ�ϵͳ��������*/
#define MINOR_REMOTE_SSD_UPGRADE_START                   0x2641    /* Զ��SSD�ļ�ϵͳ������ʼ*/ 
#define MINOR_REMOTE_SSD_UPGRADE_STOP                    0x2642    /* Զ��SSD�ļ�ϵͳ��������*/
#define MINOR_LOCAL_SSD_FORMAT_START                   0x2643    /*����SSD�ļ�ϵͳ��ʽ����ʼ*/ 
#define MINOR_LOCAL_SSD_FORMAT_STOP                    0x2644    /*����SSD�ļ�ϵͳ��ʽ������*/
#define MINOR_REMOTE_SSD_FORMAT_START                   0x2645    /*Զ��SSD�ļ�ϵͳ��ʽ����ʼ*/ 
#define MINOR_REMOTE_SSD_FORMAT_STOP                    0x2646    /*Զ��SSD�ļ�ϵͳ��ʽ������*/
#define MINOR_LOCAL_AUTO_SWITCH_CONFIG                  0x2647    /* �����Զ����ػ�����*/ 
#define MINOR_REMOTE_AUTO_SWITCH_CONFIG                 0x2648    /* Զ���Զ����ػ�����*/

#define MINOR_LOCAL_SSD_INITIALIZATION_START            0x264a    /* ����SSD��ʼ����ʼ*/ 
#define MINOR_LOCAL_SSD_INITIALIZATION_END              0x264b    /* ����SSD��ʼ������*/
#define MINOR_REMOTE_SSD_INITIALIZATION_START           0x264c    /* Զ��SSD��ʼ����ʼ*/
#define MINOR_REMOTE_SSD_INITIALIZATION_END             0x264d    /* Զ��SSD��ʼ������*/


//����AI����ƽ̨�Ĳ�����־
#define MINOR_REMOTE_AI_MODEL_ADD    0x2650//ģ�Ͱ����
#define MINOR_REMOTE_AI_MODEL_QUERY    0x2651//ģ�Ͱ���ѯ
#define MINOR_REMOTE_AI_MODEL_DELETE    0x2652//ģ�Ͱ�ɾ��
#define MINOR_REMOTE_AI_MODEL_UPDATE    0x2653//ģ�Ͱ�����
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_ADD    0x2654//ͼƬ��ѯ��������
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_QUERY    0x2655//ͼƬ��ѯ�����ѯ
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_DELETE    0x2656//ͼƬ��ѯ����ɾ��
#define MINOR_REMOTE_AI_PICTURE_POLLING_TASK_MODIFY    0x2657//ͼƬ��ѯ�����޸�
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_ADD    0x2658//��Ƶ��ѯ��������
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_QUERY    0x2659//��Ƶ��ѯ�����ѯ
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_DELETE    0x265A//��Ƶ��ѯ����ɾ��
#define MINOR_REMOTE_AI_VIDEO_POLLING_TASK_MODIFY    0x265B//��Ƶ��ѯ�����޸�
#define MINOR_REMOTE_AI_PICTURE_TASK_ADD    0x265C//ͼƬ��������
#define MINOR_REMOTE_AI_PICTURE_TASK_QUERY    0x265D//ͼƬ�����ѯ
#define MINOR_REMOTE_AI_PICTURE_TASK_DELETE    0x265E//ͼƬ����ɾ��
#define MINOR_REMOTE_AI_PICTURE_TASK_MODIFY    0x265F//ͼƬ�����޸�
#define MINOR_REMOTE_AI_VIDEO_TASK_ADD    0x2660//��Ƶ��������
#define MINOR_REMOTE_AI_VIDEO_TASK_QUERY    0x2661//��Ƶ�����ѯ
#define MINOR_REMOTE_AI_VIDEO_TASK_DELETE    0x2662//��Ƶ����ɾ��
#define MINOR_REMOTE_AI_VIDEO_TASK_MODIFY    0x2663//��Ƶ�����޸�
#define MINOR_REMOTE_AI_RULE_CONFIG   0x2664//AI��������

#define MINOR_REMOTE_LOG_STORAGE_CONFIG 0x2665//��־�洢����
#define MINOR_REMOTE_LOG_SERVER_CONFIG 0x2666//��־��������������

#define MINOR_REMOTE_RESET_IPC_PASSWORD   0x2670//NVR����IPC������־ 

//����өʯƽ̨������־
#define MINOR_LOCAL_EZVIZ_OPERATION 0x2671 //����өʯ����(����өʯ�������ú�����)
#define MINOR_REMOTE_EZVIZ_OPERATION 0x2672 //Զ��өʯ����(����өʯ�������ú�����)

#define MINOR_EZVIZ_BITSTREAM_PARAMATERS_CONFIG 0x2673 /* өʯ������������*/
#define MINOR_EZVIZ_ALARM_PARAMATERS_CONFIG 0x2674 /* өʯ������������*/
#define MINOR_EZVIZ_UPGRADE          0x2675 /* өʯ����*/
#define MINOR_EZVIZ_REGISTER         0x2676 /* өʯע��*/
#define MINOR_EZVIZ_LOCAL_PARAMATERS_CONFIG    0x2677 /* өʯ���ز�������*/
#define MINOR_EZVIZ_REMOTE_PARAMATERS_CONFIG   0x2678 /* өʯԶ�̲�������*/


//����������־
#define MINOR_STOP_SOUND                0x2700   /*����*/
#define MINOR_SELF_CHECK                0x2701   /*�Լ�*/
#define MINOR_DUTY_CHECK                0x2702   /*���*/
#define MINOR_SWITCH_SIMPLE_WORKMODE    0x2703   /*�л�������ģʽ*/
#define MINOR_SWITCH_NORMAL_WORKMODE    0x2704   /*�л�����׼ģʽ*/
#define MINOR_LOCAL_SSD_OPERATE_START         0x2705    /* ����SSD������ʼ*/ 
#define MINOR_LOCAL_SSD_OPERATE_STOP           0x2706    /* ����SSD��������*/
#define MINOR_REMOTE_SSD_OPERATE_START        0x2707    /* Զ��SSD������ʼ*/ 
#define MINOR_REMOTE_SSD_OPERATE_STOP         0x2708    /* Զ��SSD��������*/

/*��־������Ϣ*/
//������
#define MAJOR_INFORMATION               0x4     /*������Ϣ*/
//������
#define MINOR_HDD_INFO                  0xa1 /*Ӳ����Ϣ*/
#define MINOR_SMART_INFO                0xa2 /*SMART��Ϣ*/
#define MINOR_REC_START                 0xa3 /*��ʼ¼��*/
#define MINOR_REC_STOP                  0xa4 /*ֹͣ¼��*/
#define MINOR_REC_OVERDUE                0xa5 /*����¼��ɾ��*/
#define MINOR_LINK_START                0xa6 //����ǰ���豸
#define MINOR_LINK_STOP                    0xa7 //�Ͽ�ǰ���豸��
#define MINOR_NET_DISK_INFO                0xa8 //����Ӳ����Ϣ
#define MINOR_RAID_INFO                 0xa9 //raid�����Ϣ
#define MINOR_RUN_STATUS_INFO           0xaa /*ϵͳ����״̬��Ϣ*/

//Netra3.0.0
#define MINOR_SPARE_START_BACKUP        0xab   /*�ȱ�ϵͳ��ʼ����ָ��������*/
#define MINOR_SPARE_STOP_BACKUP            0xac   /*�ȱ�ϵͳֹͣ����ָ��������*/
#define MINOR_SPARE_CLIENT_INFO         0xad   /*�ȱ��ͻ�����Ϣ*/
#define MINOR_ANR_RECORD_START            0xae   /*ANR¼��ʼ*/
#define MINOR_ANR_RECORD_END            0xaf   /*ANR¼�����*/
#define MINOR_ANR_ADD_TIME_QUANTUM        0xb0    /*ANR���ʱ���*/
#define MINOR_ANR_DEL_TIME_QUANTUM        0xb1    /*ANRɾ��ʱ���*/

#define MINOR_PIC_REC_START             0xb3  /* ��ʼץͼ*/    
#define MINOR_PIC_REC_STOP              0xb4  /* ֹͣץͼ*/
#define MINOR_PIC_REC_OVERDUE           0xb5  /* ����ͼƬ�ļ�ɾ�� */
//Netra3.1.0
#define  MINOR_CLIENT_LOGIN             0xb6   /*��¼�������ɹ�*/
#define  MINOR_CLIENT_RELOGIN            0xb7   /*���µ�¼������*/
#define  MINOR_CLIENT_LOGOUT            0xb8   /*�˳��������ɹ�*/
#define  MINOR_CLIENT_SYNC_START        0xb9   /*¼��ͬ����ʼ*/
#define  MINOR_CLIENT_SYNC_STOP            0xba   /*¼��ͬ����ֹ*/
#define  MINOR_CLIENT_SYNC_SUCC            0xbb   /*¼��ͬ���ɹ�*/
#define  MINOR_CLIENT_SYNC_EXCP            0xbc   /*¼��ͬ���쳣*/
#define  MINOR_GLOBAL_RECORD_ERR_INFO   0xbd   /*ȫ�ִ����¼��Ϣ*/
#define  MINOR_BUFFER_STATE             0xbe   /*������״̬��־��¼*/
#define  MINOR_DISK_ERRORINFO_V2        0xbf   /*Ӳ�̴�����ϸ��ϢV2*/
#define  MINOR_CS_DATA_EXPIRED          0xc0   //�ƴ洢���ݹ���
#define  MINOR_PLAT_INFO                0xc1   //ƽ̨������Ϣ
#define  MINOR_DIAL_STAT                0xc2   /*����״̬*/

#define MINOR_UNLOCK_RECORD             0xc3   //������¼
#define MINOR_VIS_ALARM                 0xc4   //��������
#define MINOR_TALK_RECORD               0xc5   //ͨ����¼
#define MINOR_ACCESSORIES_MESSAGE       0xc6 //�������Ϣ
#define MINOR_KMS_EXPAMSION_DISK_INSERT 0xc7// KMS�����̲���
#define MINOR_IPC_CONNECT               0xc8//  IPC������Ϣ
#define MINOR_INTELLIGENT_BOARD_STATUS  0xc9//  ���ܰ�״̬
#define MINOR_IPC_CONNECT_STATUS        0xca//  IPC����״̬
#define MINOR_AUTO_TIMING               0xcb  //�Զ�Уʱ
#define MINOR_EZVIZ_OPERATION           0xcc   //өʯ����״̬
//NVR��Ⱥ
#define MINOR_CLUSTER_DEVICE_ONLINE     0xcd   //��Ⱥ�豸����
#define MINOR_CLUSTER_MGR_SERVICE_STARTUP 0xce   //��Ⱥ�����������
#define MINOR_CLUSTER_BUSINESS_TRANSFER 0xcf   //��Ⱥҵ��Ǩ��
#define MINOR_CLUSTER_STATUS            0xd0   //��Ⱥ״̬��Ϣ
#define MINOR_CLUSTER_CS_STATUS            0xd1   //��ȺCS��CM�����豸״̬ʧ�ܣ���¼CS��CM��IP��ַ
#define MINOR_CLUSTER_CM_STATUS            0xd2   //CM״̬�л�����¼CMת��Ľ�ɫ����leader��follower��candidate
#define MINOR_VOICE_START_DETECTED         0xd3  /*��⵽������ʼ*/
#define MINOR_VOICE_END_DETECTED           0xd4  /*��⵽��������*/
#define MINOR_DOUBLE_VERIFICATION_PASS     0xd5  /*������֤ͨ��*/
#define MINOR_WIRELESS_RUNNING_STATUS       0xd6  /*��������״̬*/
#define MINOR_SYSTEM_DATA_SYNCHRONIZATION       0xd7  /*ϵͳ����ͬ��*/
#define MINOR_HD_FORMAT_START   0xd8  /*Ӳ�̸�ʽ����ʼ*/
#define MINOR_HD_FORMAT_STOP   0xd9  /*Ӳ�̸�ʽ������*/

//0x400-0x4ff �Ž�������Ϣ��־����
#define MINOR_LIVE_DETECT_OPEN         0x400    //���˼�⿪��
#define MINOR_LIVE_DETECT_CLOSE        0x401    //���˼��ر�
#define MINOR_CLEAR_DATA_COLLECTION    0x402    //�ɼ��������
#define MINOR_DELETE_DATA_COLLECTION   0x403    //�ɼ�����ɾ��
#define MINOR_EXPORT_DATA_COLLECTION   0x404    //�ɼ����ݵ���
#define MINOR_CARD_LEN_CONFIG          0x405    //����������
#define MINOR_DATA_BASE_INIT_FAILED   0x406    //���ݿ��ʼ��ʧ��
#define MINOR_DATA_BASE_PATCH_UPDATE   0x407    //���ݿⲹ������
#define MINOR_PSAM_CARD_INSERT         0x408    //Psam������
#define MINOR_PSAM_CARD_REMOVE         0x409    //Psam���γ�
#define MINOR_HARD_FAULT_REBOOT                0x40a  //Ӳ���쳣��hardfault������
#define MINOR_PSAM_CARD_OCP                    0x40b  //Psam����������
#define MINOR_STACK_OVERFLOW                   0x40c      //��ջ���
#define MINOR_PARM_CFG                         0x40d  //��������
#define MINOR_CLR_USER                         0x40e //��������û�
#define MINOR_CLR_CARD                         0x40f //������п�
#define MINOR_CLR_FINGER_BY_READER             0x410 //�������ָ��(��������)
#define MINOR_CLR_FINGER_BY_CARD               0x411 //�������ָ��(������)
#define MINOR_CLR_FINGER_BY_EMPLOYEE_ON        0x412 //�������ָ��(������)
#define MINOR_DEL_FINGER                       0x413 //ɾ��һ��ָ��
#define MINOR_CLR_WEEK_PLAN                    0x414 //���Ȩ���ܼƻ�
#define MINOR_SET_WEEK_PLAN                    0x415 //����Ȩ���ܼƻ�
#define MINOR_SET_HOLIDAY_PLAN                 0x416 //����Ȩ�޼��ռƻ�
#define MINOR_CLR_HOLIDAY_PLAN                 0x417 //���Ȩ�޼��ռƻ�
#define MINOR_SET_HOLIDAY_GROUP                0x418 //����Ȩ�޼�����ƻ�
#define MINOR_CLR_HOLIDAY_GROUP                0x419 //���Ȩ�޼�����ƻ�
#define MINOR_CLR_TEMPLATE_PLAN                0x41a //���Ȩ�޼ƻ�
#define MINOR_SET_TEMPLATE_PLAN                0x41b //����Ȩ�޼ƻ�
#define MINOR_ADD_CARD                         0x41c //������
#define MINOR_MOD_CARD                         0x41d //�޸Ŀ�
#define MINOR_ADD_FINGER_BY_CARD               0x41e //����ָ��(������)
#define MINOR_ADD_FINGER_BY_EMPLOYEE_NO        0x41f //����ָ��(������)
#define MINOR_MOD_FINGER_BY_CARD               0x420 //�޸�ָ��(������)
#define MINOR_MOD_FINGER_BY_EMPLOYEE_NO        0x421 //�޸�ָ��(������)
#define MINOR_IMPORT_USER_LIST                 0x422 //�û��б��루���߲ɼ���

//802.1x��֤������־
#define MINOR_802_1X_AUTH_SUCC          0x320   /*802.1x��֤�ɹ�*/
#define MINOR_802_1X_AUTH_FAIL          0x321   /*802.1x��֤ʧ��*/

/*�¼�*/
//������
#define MAJOR_EVENT                             0x5     /*�¼�*/
//������
#define MINOR_LEGAL_CARD_PASS                   0x01    //�Ϸ�����֤ͨ��
#define MINOR_CARD_AND_PSW_PASS                 0x02    //ˢ����������֤ͨ��
#define MINOR_CARD_AND_PSW_FAIL                 0x03    //ˢ����������֤ʧ��
#define MINOR_CARD_AND_PSW_TIMEOUT              0x04    //������������֤��ʱ
#define MINOR_CARD_AND_PSW_OVER_TIME            0x05    //ˢ�������볬��
#define MINOR_CARD_NO_RIGHT                     0x06    //δ����Ȩ��
#define MINOR_CARD_INVALID_PERIOD               0x07    //��Чʱ��
#define MINOR_CARD_OUT_OF_DATE                  0x08    //���Ź���
#define MINOR_INVALID_CARD                      0x09    //�޴˿���
#define MINOR_ANTI_SNEAK_FAIL                   0x0a    //��Ǳ����֤ʧ��
#define MINOR_INTERLOCK_DOOR_NOT_CLOSE          0x0b    //������δ�ر�
#define MINOR_NOT_BELONG_MULTI_GROUP            0x0c    //�������ڶ�����֤Ⱥ��
#define MINOR_INVALID_MULTI_VERIFY_PERIOD       0x0d    //�����ڶ�����֤ʱ�����
#define MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL     0x0e    //������֤ģʽ����Ȩ����֤ʧ��
#define MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL    0x0f    //������֤ģʽԶ����֤ʧ��
#define MINOR_MULTI_VERIFY_SUCCESS              0x10    //������֤�ɹ�
#define MINOR_LEADER_CARD_OPEN_BEGIN            0x11    //�׿����ſ�ʼ
#define MINOR_LEADER_CARD_OPEN_END              0x12    //�׿����Ž���
#define MINOR_ALWAYS_OPEN_BEGIN                 0x13    //����״̬��ʼ
#define MINOR_ALWAYS_OPEN_END                   0x14    //����״̬����
#define MINOR_LOCK_OPEN                         0x15    //������
#define MINOR_LOCK_CLOSE                        0x16    //�����ر�
#define MINOR_DOOR_BUTTON_PRESS                 0x17    //���Ű�ť��
#define MINOR_DOOR_BUTTON_RELEASE               0x18    //���Ű�ť�ſ�
#define MINOR_DOOR_OPEN_NORMAL                  0x19    //�������ţ��Ŵţ�
#define MINOR_DOOR_CLOSE_NORMAL                 0x1a    //�������ţ��Ŵţ�
#define MINOR_DOOR_OPEN_ABNORMAL                0x1b    //���쳣�򿪣��Ŵţ�
#define MINOR_DOOR_OPEN_TIMEOUT                 0x1c    //�Ŵ򿪳�ʱ���Ŵţ�
#define MINOR_ALARMOUT_ON                       0x1d    //���������
#define MINOR_ALARMOUT_OFF                      0x1e    //��������ر�
#define MINOR_ALWAYS_CLOSE_BEGIN                0x1f    //����״̬��ʼ
#define MINOR_ALWAYS_CLOSE_END                  0x20    //����״̬����                          
#define MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN     0x21    //���ض�����֤��ҪԶ�̿���
#define MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS  0x22  //������֤����������֤�ɹ��¼�
#define MINOR_MULTI_VERIFY_REPEAT_VERIFY        0x23    //������֤�ظ���֤�¼�
#define MINOR_MULTI_VERIFY_TIMEOUT               0x24    //������֤�ظ���֤�¼�
#define MINOR_DOORBELL_RINGING                  0x25    //������
#define MINOR_FINGERPRINT_COMPARE_PASS          0x26    //ָ�Ʊȶ�ͨ��
#define MINOR_FINGERPRINT_COMPARE_FAIL          0x27    //ָ�Ʊȶ�ʧ��
#define MINOR_CARD_FINGERPRINT_VERIFY_PASS              0x28    //ˢ����ָ����֤ͨ��
#define MINOR_CARD_FINGERPRINT_VERIFY_FAIL              0x29    //ˢ����ָ����֤ʧ��
#define MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT           0x2a    //ˢ����ָ����֤��ʱ
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS       0x2b    //ˢ����ָ�Ƽ�������֤ͨ��
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL       0x2c    //ˢ����ָ�Ƽ�������֤ʧ��
#define MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT    0x2d    //ˢ����ָ�Ƽ�������֤��ʱ
#define MINOR_FINGERPRINT_PASSWD_VERIFY_PASS            0x2e    //ָ�Ƽ�������֤ͨ��
#define MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL            0x2f    //ָ�Ƽ�������֤ʧ��
#define MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT         0x30    //ָ�Ƽ�������֤��ʱ
#define MINOR_FINGERPRINT_INEXISTENCE                   0x31    //ָ�Ʋ�����
#define MINOR_CARD_PLATFORM_VERIFY                      0x32    //ˢ��ƽ̨��֤
#define MINOR_CALL_CENTER                               0x33    //���������¼�
#define MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN       0x34    //�����̵�����ͨ�����ų���
#define MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL    0x35   //�����̵����ָ��Żָ�����
#define MINOR_FACE_AND_FP_VERIFY_PASS                   0x36    //������ָ����֤ͨ��
#define MINOR_FACE_AND_FP_VERIFY_FAIL                   0x37    //������ָ����֤ʧ��
#define MINOR_FACE_AND_FP_VERIFY_TIMEOUT                0x38    //������ָ����֤��ʱ
#define MINOR_FACE_AND_PW_VERIFY_PASS                   0x39    //������������֤ͨ��
#define MINOR_FACE_AND_PW_VERIFY_FAIL                   0x3a    //������������֤ʧ��
#define MINOR_FACE_AND_PW_VERIFY_TIMEOUT                0x3b    //������������֤��ʱ
#define MINOR_FACE_AND_CARD_VERIFY_PASS                 0x3c    //������ˢ����֤ͨ��
#define MINOR_FACE_AND_CARD_VERIFY_FAIL                 0x3d    //������ˢ����֤ʧ��
#define MINOR_FACE_AND_CARD_VERIFY_TIMEOUT              0x3e    //������ˢ����֤��ʱ
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS            0x3f    //�����������ָ����֤ͨ��
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL            0x40    //�����������ָ����֤ʧ��
#define MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT         0x41    //�����������ָ����֤��ʱ
#define MINOR_FACE_CARD_AND_FP_VERIFY_PASS              0x42    //������ˢ����ָ����֤ͨ��
#define MINOR_FACE_CARD_AND_FP_VERIFY_FAIL              0x43    //������ˢ����ָ����֤ʧ��
#define MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT           0x44    //������ˢ����ָ����֤��ʱ
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS             0x45    //���ż�ָ����֤ͨ��
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL             0x46    //���ż�ָ����֤ʧ��
#define MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT          0x47    //���ż�ָ����֤��ʱ
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS      0x48    //���ż�ָ�Ƽ�������֤ͨ��
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL      0x49    //���ż�ָ�Ƽ�������֤ʧ��
#define MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT   0x4a    //���ż�ָ�Ƽ�������֤��ʱ
#define MINOR_FACE_VERIFY_PASS                          0x4b    //������֤ͨ��
#define MINOR_FACE_VERIFY_FAIL                          0x4c    //������֤ʧ��
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS           0x4d    //���ż�������֤ͨ��
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL           0x4e    //���ż�������֤ʧ��
#define MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT        0x4f    //���ż�������֤��ʱ
#define MINOR_FACE_RECOGNIZE_FAIL                       0x50    //����ʶ��ʧ��
#define MINOR_FIRSTCARD_AUTHORIZE_BEGIN                    0x51    //�׿���Ȩ��ʼ
#define MINOR_FIRSTCARD_AUTHORIZE_END                    0x52    //�׿���Ȩ����
#define MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT                0x53    //���������·����
#define MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT                0x54    //���������·����
#define MINOR_DOORLOCK_INPUT_EXCEPTION                    0x55    //���������쳣����
#define MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT            0x56    //�Ŵ������·����
#define MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT            0x57    //�Ŵ������·����
#define MINOR_DOORCONTACT_INPUT_EXCEPTION                0x58    //�Ŵ������쳣����
#define MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT            0x59    //���Ű�ť�����·����
#define MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT            0x5a    //���Ű�ť�����·����
#define MINOR_OPENBUTTON_INPUT_EXCEPTION                0x5b    //���Ű�ť�����쳣����
#define MINOR_DOORLOCK_OPEN_EXCEPTION                    0x5c    //�����쳣��
#define MINOR_DOORLOCK_OPEN_TIMEOUT                        0x5d    //�����򿪳�ʱ
#define MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE            0x5e    //�׿�δ��Ȩ����ʧ��
#define MINOR_CALL_LADDER_RELAY_BREAK                   0x5f    //���ݼ̵����Ͽ�
#define MINOR_CALL_LADDER_RELAY_CLOSE                   0x60    //���ݼ̵����պ�
#define MINOR_AUTO_KEY_RELAY_BREAK                      0x61    //�Զ������̵����Ͽ�
#define MINOR_AUTO_KEY_RELAY_CLOSE                      0x62    //�Զ������̵����պ�
#define MINOR_KEY_CONTROL_RELAY_BREAK                   0x63    //�����ݿؼ̵����Ͽ�
#define MINOR_KEY_CONTROL_RELAY_CLOSE                   0x64    //�����ݿؼ̵����պ�
#define MINOR_EMPLOYEENO_AND_PW_PASS                    0x65    //���ż�������֤ͨ��
#define MINOR_EMPLOYEENO_AND_PW_FAIL                    0x66    //���ż�������֤ʧ��
#define MINOR_EMPLOYEENO_AND_PW_TIMEOUT                 0x67    //���ż�������֤��ʱ
#define MINOR_HUMAN_DETECT_FAIL                         0x68    //���˼��ʧ��
#define MINOR_PEOPLE_AND_ID_CARD_COMPARE_PASS           0x69    //��֤�ȶ�ͨ��
#define MINOR_PEOPLE_AND_ID_CARD_COMPARE_FAIL           0x70    //��֤�ȶ�ʧ��
#define MINOR_CERTIFICATE_BLACK_LIST                    0x71    //�������¼�
#define MINOR_LEGAL_MESSAGE                             0x72    //�Ϸ�����
#define MINOR_ILLEGAL_MESSAGE                           0x73    //�Ƿ�����
#define MINOR_DOOR_OPEN_OR_DORMANT_FAIL                 0x75   //��״̬���ջ�����״̬��֤ʧ��
#define MINOR_AUTH_PLAN_DORMANT_FAIL                    0x76   //��֤�ƻ�����ģʽ��֤ʧ��
#define MINOR_CARD_ENCRYPT_VERIFY_FAIL                  0x77   //������У��ʧ��
#define MINOR_SUBMARINEBACK_REPLY_FAIL                  0x78   //��Ǳ�ط�����Ӧ��ʧ��
#define MINOR_DOOR_OPEN_OR_DORMANT_OPEN_FAIL            0x82   //�ų��ջ�����ʱ���Ű�ť����ʧ��
#define MINOR_HEART_BEAT                                0x83    //�����¼�
#define MINOR_DOOR_OPEN_OR_DORMANT_LINKAGE_OPEN_FAIL    0x84   //�ų��ջ�����ʱ������������ʧ��
#define MINOR_TRAILING                                  0x85   //β��ͨ��
#define MINOR_REVERSE_ACCESS                            0x86   //������
#define MINOR_FORCE_ACCESS                              0x87   //������ײ
#define MINOR_CLIMBING_OVER_GATE                        0x88   //��Խ
#define MINOR_PASSING_TIMEOUT                           0x89   //ͨ�г�ʱ
#define MINOR_INTRUSION_ALARM                           0x8a   //�󴳱���
#define MINOR_FREE_GATE_PASS_NOT_AUTH                   0x8b   //բ������ͨ��ʱδ��֤ͨ��
#define MINOR_DROP_ARM_BLOCK                            0x8c   //�ڱ۱��赲
#define MINOR_DROP_ARM_BLOCK_RESUME                     0x8d   //�ڱ��赲����
#define MINOR_LOCAL_FACE_MODELING_FAIL                  0x8e   //�豸��������������ģʧ��
#define MINOR_STAY_EVENT                                0x8f   //�����¼�
#define MINOR_PASSWORD_MISMATCH                         0x97   //���벻ƥ��
#define MINOR_EMPLOYEE_NO_NOT_EXIST                     0x98   //���Ų�����
#define MINOR_COMBINED_VERIFY_PASS                      0x99   //�����֤ͨ��
#define MINOR_COMBINED_VERIFY_TIMEOUT                   0x9a   //�����֤��ʱ
#define MINOR_VERIFY_MODE_MISMATCH                      0x9b   //��֤��ʽ��ƥ��

#define MINOR_PASSPORT_VERIFY_FAIL                       0xa1   //������ϢУ��ʧ��
#define MINOR_INFORMAL_MIFARE_CARD_VERIFY_FAIL           0xa2   //������Mifare����֤ʧ��
#define MINOR_CPU_CARD_ENCRYPT_VERIFY_FAIL               0xa3   //CPU������У��ʧ��
#define MINOR_NFC_DISABLE_VERIFY_FAIL                    0xa4   //NFC���ܹر���֤ʧ��

#define MINOR_LORA_MODULE_ONLINE                        0xa5    //LoRaģ������
#define MINOR_LORA_MODULE_OFFLINE                       0xa6    //LoRaģ������
#define MINOR_MQTT_STATUS                               0xa7    //Mqtt����״̬

#define MINOR_EM_CARD_RECOGNIZE_NOT_ENABLED             0xa8   //EM��ʶ��δ����
#define MINOR_M1_CARD_RECOGNIZE_NOT_ENABLED             0xa9   //M1��ʶ��δ����
#define MINOR_CPU_CARD_RECOGNIZE_NOT_ENABLED            0xaa   //CPU��ʶ��δ����
#define MINOR_ID_CARD_RECOGNIZE_NOT_ENABLED             0xab   //���֤ʶ��δ����
#define MINOR_CARD_SET_SECRET_KEY_FAIL                  0xac   //����װ��Կʧ��
#define MINOR_LOCAL_UPGRADE_FAIL                        0xad    /* ��������ʧ�� */
#define MINOR_REMOTE_UPGRADE_FAIL                       0xae    /* Զ������ʧ�� */
#define MINOR_REMOTE_EXTEND_MODULE_UPGRADE_SUCC         0xaf    /*Զ����չģ�������ɹ�*/
#define MINOR_REMOTE_EXTEND_MODULE_UPGRADE_FAIL         0xb0    /*Զ����չģ������ʧ��*/
#define MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_SUCC   0xb1    /*Զ��ָ��ģ�������ɹ�*/
#define MINOR_REMOTE_FINGER_PRINT_MODULE_UPGRADE_FAIL   0xb2    /*Զ��ָ��ģ������ʧ��*/
#define MINOR_PASSWD_VERIFY_PASS                        0xb5    //������֤ͨ��


#define MINOR_EVENT_CUSTOM1                         0x500  //�Ž��Զ����¼�1
#define MINOR_EVENT_CUSTOM2                         0x501  //�Ž��Զ����¼�2
#define MINOR_EVENT_CUSTOM3                         0x502  //�Ž��Զ����¼�3
#define MINOR_EVENT_CUSTOM4                         0x503  //�Ž��Զ����¼�4
#define MINOR_EVENT_CUSTOM5                         0x504  //�Ž��Զ����¼�5
#define MINOR_EVENT_CUSTOM6                         0x505  //�Ž��Զ����¼�6
#define MINOR_EVENT_CUSTOM7                         0x506  //�Ž��Զ����¼�7
#define MINOR_EVENT_CUSTOM8                         0x507  //�Ž��Զ����¼�8
#define MINOR_EVENT_CUSTOM9                         0x508  //�Ž��Զ����¼�9
#define MINOR_EVENT_CUSTOM10                        0x509  //�Ž��Զ����¼�10
#define MINOR_EVENT_CUSTOM11                        0x50a  //�Ž��Զ����¼�11
#define MINOR_EVENT_CUSTOM12                        0x50b  //�Ž��Զ����¼�12
#define MINOR_EVENT_CUSTOM13                        0x50c  //�Ž��Զ����¼�13
#define MINOR_EVENT_CUSTOM14                        0x50d  //�Ž��Զ����¼�14
#define MINOR_EVENT_CUSTOM15                        0x50e  //�Ž��Զ����¼�15
#define MINOR_EVENT_CUSTOM16                        0x50f  //�Ž��Զ����¼�16
#define MINOR_EVENT_CUSTOM17                        0x510  //�Ž��Զ����¼�17
#define MINOR_EVENT_CUSTOM18                        0x511  //�Ž��Զ����¼�18
#define MINOR_EVENT_CUSTOM19                        0x512  //�Ž��Զ����¼�19
#define MINOR_EVENT_CUSTOM20                        0x513  //�Ž��Զ����¼�20
#define MINOR_EVENT_CUSTOM21                        0x514  //�Ž��Զ����¼�21
#define MINOR_EVENT_CUSTOM22                        0x515  //�Ž��Զ����¼�22
#define MINOR_EVENT_CUSTOM23                        0x516  //�Ž��Զ����¼�23
#define MINOR_EVENT_CUSTOM24                        0x517  //�Ž��Զ����¼�24
#define MINOR_EVENT_CUSTOM25                        0x518  //�Ž��Զ����¼�25
#define MINOR_EVENT_CUSTOM26                        0x519  //�Ž��Զ����¼�26
#define MINOR_EVENT_CUSTOM27                        0x51a  //�Ž��Զ����¼�27
#define MINOR_EVENT_CUSTOM28                        0x51b  //�Ž��Զ����¼�28
#define MINOR_EVENT_CUSTOM29                        0x51c  //�Ž��Զ����¼�29
#define MINOR_EVENT_CUSTOM30                        0x51d  //�Ž��Զ����¼�30
#define MINOR_EVENT_CUSTOM31                        0x51e  //�Ž��Զ����¼�31
#define MINOR_EVENT_CUSTOM32                        0x51f  //�Ž��Զ����¼�32
#define MINOR_EVENT_CUSTOM33                        0x520  //�Ž��Զ����¼�33
#define MINOR_EVENT_CUSTOM34                        0x521  //�Ž��Զ����¼�34
#define MINOR_EVENT_CUSTOM35                        0x522  //�Ž��Զ����¼�35
#define MINOR_EVENT_CUSTOM36                        0x523  //�Ž��Զ����¼�36
#define MINOR_EVENT_CUSTOM37                        0x524  //�Ž��Զ����¼�37
#define MINOR_EVENT_CUSTOM38                        0x525  //�Ž��Զ����¼�38
#define MINOR_EVENT_CUSTOM39                        0x526  //�Ž��Զ����¼�39
#define MINOR_EVENT_CUSTOM40                        0x527  //�Ž��Զ����¼�40
#define MINOR_EVENT_CUSTOM41                        0x528  //�Ž��Զ����¼�41
#define MINOR_EVENT_CUSTOM42                        0x529  //�Ž��Զ����¼�42
#define MINOR_EVENT_CUSTOM43                        0x52a  //�Ž��Զ����¼�43
#define MINOR_EVENT_CUSTOM44                        0x52b  //�Ž��Զ����¼�44
#define MINOR_EVENT_CUSTOM45                        0x52c  //�Ž��Զ����¼�45
#define MINOR_EVENT_CUSTOM46                        0x52d  //�Ž��Զ����¼�46
#define MINOR_EVENT_CUSTOM47                        0x52e  //�Ž��Զ����¼�47
#define MINOR_EVENT_CUSTOM48                        0x52f  //�Ž��Զ����¼�48
#define MINOR_EVENT_CUSTOM49                        0x530  //�Ž��Զ����¼�49
#define MINOR_EVENT_CUSTOM50                        0x531  //�Ž��Զ����¼�50
#define MINOR_EVENT_CUSTOM51                        0x532  //�Ž��Զ����¼�51
#define MINOR_EVENT_CUSTOM52                        0x533  //�Ž��Զ����¼�52
#define MINOR_EVENT_CUSTOM53                        0x534  //�Ž��Զ����¼�53
#define MINOR_EVENT_CUSTOM54                        0x535  //�Ž��Զ����¼�54
#define MINOR_EVENT_CUSTOM55                        0x536  //�Ž��Զ����¼�55
#define MINOR_EVENT_CUSTOM56                        0x537  //�Ž��Զ����¼�56
#define MINOR_EVENT_CUSTOM57                        0x538  //�Ž��Զ����¼�57
#define MINOR_EVENT_CUSTOM58                        0x539  //�Ž��Զ����¼�58
#define MINOR_EVENT_CUSTOM59                        0x53a  //�Ž��Զ����¼�59
#define MINOR_EVENT_CUSTOM60                        0x53b  //�Ž��Զ����¼�60
#define MINOR_EVENT_CUSTOM61                        0x53c  //�Ž��Զ����¼�61
#define MINOR_EVENT_CUSTOM62                        0x53d  //�Ž��Զ����¼�62
#define MINOR_EVENT_CUSTOM63                        0x53e  //�Ž��Զ����¼�63
#define MINOR_EVENT_CUSTOM64                        0x53f  //�Ž��Զ����¼�64

#define MINOR_LOCK_FINGER_OPEN_DOOR          0x600    //������ָ�ƿ���
#define MINOR_LOCK_PASSWORD_OPEN_DOOR        0x601    //���������뿪��
#define MINOR_LOCK_CARD_OPEN_DOOR            0x602    //������ˢ������
#define MINOR_LOCK_CENTER_OPEN_DOOR          0x603    //���������Ŀ���
#define MINOR_LOCK_APP_OPEN_DOOR             0x604    //������APP����
#define MINOR_LOCK_KEY_OPEN_DOOR             0x605    //������Կ�׿���
#define MINOR_LOCK_REMOTE_DEVICE_OPEN_DOOR   0x606    //������ң��������
#define MINOR_LOCK_TMP_PASSWORD_OPEN_DOOR    0x607    //��������ʱ���뿪��
#define MINOR_LOCK_BLUETOOTH_OPEN_DOOR       0x608    //��������������
#define MINOR_LOCK_MULTI_OPEN_DOOR           0x609 //���������ؿ���

//2018-04-23 ͨ�����������¼���־����
#define   MINOR_ALARMHOST_SCHOOLTIME_IRGI_B   0x1001     //B��Уʱ
#define   MINOR_ALARMHOST_SCHOOLTIME_SDK     0x1002     //SDKУʱ
#define   MINOR_ALARMHOST_SCHOOLTIME_SELFTEST    0x1003   //�����Լ�Уʱ
#define  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALINSERT   0x1004  //�Ӱ���� 
#define  MINOR_ALARMHOST_SUBSYSTEM_ABNORMALPULLOUT   0x1005  //�Ӱ�γ�

#define  MINOR_ALARMHOST_AUTO_ARM    0x1006  //�Զ�����
#define  MINOR_ALARMHOST_AUTO_DISARM    0x1007  //�Զ�����
#define  MINOR_ALARMHOST_TIME_TIGGER_ON    0x1008  //��ʱ����������
#define  MINOR_ALARMHOST_TIME_TIGGER_OFF   0x1009  //��ʱ�رմ�����
#define  MINOR_ALARMHOST_AUTO_ARM_FAILD    0x100a  //�Զ�����ʧ��
#define  MINOR_ALARMHOST_AUTO_DISARM_FAILD    0x100b  //�Զ�����ʧ��
#define  MINOR_ALARMHOST_TIME_TIGGER_ON_FAILD   0x100c  //��ʱ����������ʧ��
#define  MINOR_ALARMHOST_TIME_TIGGER_OFF_FAILD    0x100d  //��ʱ�رմ�����ʧ��
#define  MINOR_ALARMHOST_MANDATORY_ALARM    0x100e  //ǿ�Ʋ���
#define  MINOR_ALARMHOST_KEYPAD_LOCKED  0x100f  //��������
#define  MINOR_ALARMHOST_USB_INSERT   0x1010  //USB���� 
#define  MINOR_ALARMHOST_USB_PULLOUT   0x1011 //USB�γ�
#define  MINOR_ALARMHOST_4G_MODULS_ONLINE  0x1012  //4Gģ������
#define  MINOR_ALARMHOST_4G_MODULS_OFFLINE  0x1013  //4Gģ������

#define  MINOR_EZVIZ_CLOUD_ONLINE   0x1014   //өʯ������
#define  MINOR_EZVIZ_CLOUD_OFFLINE    0x1015   //өʯ������

#define  MINOR_SIPUA_GRID_ONLINE     0x1016   //����B����
#define  MINOR_SIPUA_GRID_OFFLINE    0x1017   //����B����

#define  MINOR_INTERNET_ACCESS_CONNECTED  0x1018   //��������
#define  MINOR_INTERNET_ACCESS_BREAK  0x1019  //���ڶϿ�

#define  MINOR_WIRELESS_CONNECTED   0x101a  //��������
#define  MINOR_WIRELESS_BREAK     0x101b   //���߶Ͽ�
#define  MINOR_PORT_LINK_DOWN    0x101c  //�˿�����down
#define  MINOR_PORT_LINK_UP    0x101d  //�˿�����up
#define  MINOR_POE_PORT_POWER_ON    0x101e  //POE�˿�power on
#define  MINOR_POE_PORT_POWER_OFF    0x101f  //POE�˿�power off
#define  MINOR_POE_TOTAL_POWER_MAX    0x1020  //POE�ܹ��ʴﵽpoe-max
#define  MINNOR_POE_TOTAL_POWER_RESUME   0x1021  //POE�ܹ��ʻָ�����


typedef enum tagALARMHOST_MAJOR_TYPE
{
    MAJOR_ALARMHOST_ALARM = 1,
        MAJOR_ALARMHOST_EXCEPTION,
        MAJOR_ALARMHOST_OPERATION,
        MAJ0R_ALARMHOST_EVENT
}ALARMHOST_MAJOR_TYPE;

typedef enum tagALARMHOST_MINOR_TYPE
{
    // ���� 
    MINOR_SHORT_CIRCUIT =0x01,      // ��·����
        MINOR_BROKEN_CIRCUIT,           // ��·����
        MINOR_ALARM_RESET,              // ������λ
        MINOR_ALARM_NORMAL,                // �����ָ�����
        MINOR_PASSWORD_ERROR,            // �����������3�������������
        MINOR_ID_CARD_ILLEGALLY,        // �Ƿ���Ӧ��ID
        MINOR_KEYPAD_REMOVE,            // ���̷���
        MINOR_KEYPAD_REMOVE_RESTORE,    // ���̷���λ
        MINOR_DEV_REMOVE,                // �豸����
        MINOR_DEV_REMOVE_RESTORE,        // �豸����λ
        MINOR_BELOW_ALARM_LIMIT1,        // ģ�������ڱ�����1
        MINOR_BELOW_ALARM_LIMIT2,        // ģ�������ڱ�����2
        MINOR_BELOW_ALARM_LIMIT3,        // ģ�������ڱ�����3
        MINOR_BELOW_ALARM_LIMIT4,        // ģ�������ڱ�����4
        MINOR_ABOVE_ALARM_LIMIT1,        // ģ�������ڱ�����1
        MINOR_ABOVE_ALARM_LIMIT2,        // ģ�������ڱ�����2
        MINOR_ABOVE_ALARM_LIMIT3,        // ģ�������ڱ�����3
        MINOR_ABOVE_ALARM_LIMIT4,        // ģ�������ڱ�����4
        MINOR_URGENCYBTN_ON,            // ������ť����
        MINOR_URGENCYBTN_OFF,            // ������ť��λ
        MINOR_VIRTUAL_DEFENCE_BANDIT,            //������˾�
        MINOR_VIRTUAL_DEFENCE_FIRE,                //�������
        MINOR_VIRTUAL_DEFENCE_URGENT,            //���������
        MINOR_ALARMHOST_MOTDET_START,            //�ƶ���ⱨ����ʼ
        MINOR_ALARMHOST_MOTDET_STOP,            //�ƶ���ⱨ������
        MINOR_ALARMHOST_HIDE_ALARM_START,        //�ڵ�������ʼ
        MINOR_ALARMHOST_HIDE_ALARM_STOP,        //�ڵ���������
        MINOR_ALARMHOST_UPS_ALARM,                //UPS����
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM, //��������
        MINOR_ALARMHOST_SWITCH_POWER_ALARM,        //���ص�Դ����
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM,      //������ϵͳ����
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM, //��������Ա���
        MINOR_ALARMHOST_TEMP_HUMI_ALARM,            //��ʪ�ȴ���������
        MINOR_ALARMHOST_UPS_ALARM_RESTORE,    //UPS�����ָ�
        MINOR_ALARMHOST_ELECTRICITY_METER_ALARM_RESTORE, //���������ָ�
        MINOR_ALARMHOST_SWITCH_POWER_ALARM_RESTORE,      //���ص�Դ�����ָ�
        MINOR_ALARMHOST_GAS_DETECT_SYS_ALARM_RESTORE,      //������ϵͳ�����ָ�
        MINOR_ALARMHOST_TRANSFORMER_TEMPRATURE_ALARM_RESTORE, //��������Ա����ָ�
        MINOR_ALARMHOST_TEMP_HUMI_ALARM_RESTORE,          //��ʪ�ȴ����������ָ�
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM,            //ˮλ����������
        MINOR_ALARMHOST_WATER_LEVEL_SENSOR_ALARM_RESTORE,    //ˮλ�����������ָ�
        MINOR_ALARMHOST_DUST_NOISE_ALARM,                    //�ﳾ��������������
        MINOR_ALARMHOST_DUST_NOISE_ALARM_RESTORE,            //�ﳾ���������������ָ�
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM,            //�����ɼ��Ǳ���
        MINOR_ALARMHOST_ENVIRONMENTAL_LOGGER_ALARM_RESTORE,    //�����ɼ��Ǳ����ָ�
        
        MINOR_ALARMHOST_TRIGGER_TAMPER,                //̽��������
        MINOR_ALARMHOST_TRIGGER_TAMPER_RESTORE,                //̽��������ָ�
        MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM,            //����������������
        MINOR_ALARMHOST_EMERGENCY_CALL_HELP_ALARM_RESTORE,    //�����������������ָ�
        MINOR_ALARMHOST_CONSULTING_ALARM,                     //ҵ����ѯ����
        MINOR_ALARMHOST_CONSULTING_ALARM_RESTORE,             //ҵ����ѯ�����ָ�
        MINOR_ZONE_MODULE_REMOVE,            // ����ģ�����
        MINOR_ZONE_MODULE_RESET,    // ����ģ�����λ

        MINOR_ALARM_WIND_SPEED_ALARM,               //���ٴ������澯
        MINOR_ALARM_WIND_SPEED_ALARM_RESTORE,       //���ٴ������澯�ָ�
        MINOR_ALARM_GENERATE_OUTPUT_ALARM,          //ͨ�����ģ��澯
        MINOR_ALARM_GENERATE_OUTPUT_RESTORE,        //ͨ�����ģ��澯�ָ�
        MINOR_ALARM_SOAK_ALARM,                     //��ˮ�������澯
        MINOR_ALARM_SOAK_ALARM_RESTORE,             //��ˮ�������澯�ָ�
        MINOR_ALARM_SOLAR_POWER_ALARM,              //̫���ܴ������澯
        MINOR_ALARM_SOLAR_POWER_ALARM_RESTORE,      //̫���ܴ������澯�ָ�
        MINOR_ALARM_SF6_ALARM,                      //SF6���������澯
        MINOR_ALARM_SF6_ALARM_RESTORE,              //SF6���������澯�ָ�
        MINOR_ALARM_WEIGHT_ALARM,                   //�����Ǹ澯
        MINOR_ALARM_WEIGHT_ALARM_RESTORE,           //�����Ǹ澯�ָ�
        MINOR_ALARM_WEATHER_ALARM,                  //����ɼ�ϵͳ�澯
        MINOR_ALARM_WEATHER_ALARM_RESTORE,          //����ɼ�ϵͳ�澯�ָ�
        MINOR_ALARM_FUEL_GAS_ALARM,                 //ȼ�����ϵͳ�澯
        MINOR_ALARM_FUEL_GAS_ALARM_RESTORE,         //ȼ�����ϵͳ�澯�ָ�
        MINOR_ALARM_FIRE_ALARM,                     //���ֱ���ϵͳ�澯
        MINOR_ALARM_FIRE_ALARM_RESTORE,             //���ֱ���ϵͳ�澯�ָ�

        MINOR_WIRELESS_OUTPUT_MODULE_REMOVE,            // �������ģ�����
        MINOR_WIRELESS_OUTPUT_MODULE_RESET,    // �������ģ�����λ
        MINOR_WIRELESS_REPEATER_MODULE_REMOVE,            // �����м�������
        MINOR_WIRELESS_REPEATER_MODULE_RESET,    // �����м�������λ
        MINOR_WIRELESS_SIREN_MODULE_REMOVE,            // ���߾��ŷ���
        MINOR_WIRELESS_SIREN_MODULE_RESET,    // ���߾��ŷ���λ
        MINOR_SOUND_INTENSITY_RISE,         // ��ǿ��������
        MINOR_SOUND_INTENSITY_RISE_RESET,   // ��ǿ���������ָ�
        MINOR_SOUND_INTENSITY_DROP,         // ��ǿ��������
        MINOR_SOUND_INTENSITY_DROP_RESET,   // ��ǿ���������ָ�
        MINOR_AUDIO_INPUT_EXCEPTION,        // ��Ƶ�����쳣����
        MINOR_AUDIO_INPUT_EXCEPTION_RESET,  // ��Ƶ�����쳣�����ָ�

        // �쳣
        MINOR_POWER_ON      = 0x01,    // �ϵ�
        MINOR_POWER_OFF,                // ����
        MINOR_WDT_RESET,                // WDT ��λ
        MINOR_LOW_BATTERY_VOLTAGE,        // ���ص�ѹ��
        MINOR_AC_LOSS,                    // ������ϵ�
        MINOR_AC_RESTORE,                // ������ָ�
        MINOR_RTC_EXCEPTION,            // RTCʵʱʱ���쳣
        MINOR_NETWORK_CONNECT_FAILURE,    // �������Ӷ�
        MINOR_NETWORK_CONNECT_RESTORE,    // �������ӻָ�
        MINOR_TEL_LINE_CONNECT_FAILURE,    // �绰�����Ӷ�
        MINOR_TEL_LINE_CONNECT_RESTORE,    // �绰�����ӻָ�
        MINOR_EXPANDER_BUS_LOSS,        // ��չ����ģ�����
        MINOR_EXPANDER_BUS_RESTORE,        // ��չ����ģ����߻ָ�
        MINOR_KEYPAD_BUS_LOSS,            // ��������ģ�����
        MINOR_KEYPAD_BUS_RESTORE,        // ��������ģ����߻ָ�
        MINOR_SENSOR_FAILURE,            // ģ��������������
        MINOR_SENSOR_RESTORE,            // ģ�����������ָ�
        MINOR_RS485_CONNECT_FAILURE,    // RS485ͨ�����Ӷ�
        MINOR_RS485_CONNECT_RESTORE,    // RS485ͨ�����Ӷϻָ�
        MINOR_BATTERT_VOLTAGE_RESTORE,  // ���ص�ѹ�ָ����� 
        MINOR_WIRED_NETWORK_ABNORMAL,    //���������쳣
        MINOR_WIRED_NETWORK_RESTORE,    //��������ָ�����
        MINOR_GPRS_ABNORMAL,            //GPRSͨ���쳣
        MINOR_GPRS_RESTORE,                //GPRS�ָ�����
        MINOR_3G_ABNORMAL,                //3Gͨ���쳣
        MINOR_3G_RESTORE,                //3G�ָ�����
        MINOR_SIM_CARD_ABNORMAL,        //SIM���쳣
        MINOR_SIM_CARD_RESTORE,            //SIM���ָ�����
        MINOR_ALARMHOST_VI_LOST,        // ��Ƶ�źŶ�ʧ
        MINOR_ALARMHOST_ILLEGAL_ACCESS,    // �Ƿ�����
        MINOR_ALARMHOST_HD_FULL,        // Ӳ����
        MINOR_ALARMHOST_HD_ERROR,        // Ӳ�̴���
        MINOR_ALARMHOST_DCD_LOST,        // MODEM ����(������ʹ��)
        MINOR_ALARMHOST_IP_CONFLICT,    // IP��ַ��ͻ
        MINOR_ALARMHOST_NET_BROKEN,        // ����Ͽ�
        MINOR_ALARMHOST_REC_ERROR,      // ¼�����
        MINOR_ALARMHOST_VI_EXCEPTION,   // ��Ƶ�����쳣(ֻ���ģ��ͨ��)
        MINOR_ALARMHOST_FORMAT_HDD_ERROR, //Զ�̸�ʽ��Ӳ��ʧ��
        MINOR_ALARMHOST_USB_ERROR,        //USBͨ�Ź���
        MINOR_ALARMHOST_USB_RESTORE,    //USBͨ�Ź��ϻָ�
        MINOR_ALARMHOST_PRINT_ERROR,    //��ӡ������
        MINOR_ALARMHOST_PRINT_RESTORE,    //��ӡ�����ϻָ�
        MINOR_SUBSYSTEM_COMMUNICATION_ERROR, //�Ӱ�ͨѶ����
        MINOR_ALARMHOST_IPC_NO_LINK,                /* IPC���ӶϿ�  */
        MINOR_ALARMHOST_IPC_IP_CONFLICT,            /*ipc ip ��ַ ��ͻ*/
        MINOR_ALARMHOST_VI_MISMATCH,                /*��Ƶ��ʽ��ƥ��*/
        MINOR_ALARMHOST_MCU_RESTART,                //MCU����
        MINOR_ALARMHOST_GPRS_MODULE_FAULT,          //GPRSģ�����
        MINOR_ALARMHOST_TELEPHONE_MODULE_FAULT,     //�绰ģ�����
        MINOR_ALARMHOST_WIFI_ABNORMAL,              //WIFIͨ���쳣
        MINOR_ALARMHOST_WIFI_RESTORE,               //WIFI�ָ�����
        MINOR_ALARMHOST_RF_ABNORMAL,                //RF�ź��쳣
        MINOR_ALARMHOST_RF_RESTORE,                 //RF�źŻָ�����
        MINOR_ALARMHOST_DETECTOR_ONLINE,            //̽��������
        MINOR_ALARMHOST_DETECTOR_OFFLINE,           //̽��������
        MINOR_ALARMHOST_DETECTOR_BATTERY_NORMAL,    //̽������������        
        MINOR_ALARMHOST_DETECTOR_BATTERY_LOW,       //̽��������Ƿѹ
        MINOR_ALARMHOST_DATA_TRAFFIC_OVERFLOW,     //��������
        MINOR_ZONE_MODULE_LOSS,            // ����ģ�����
        MINOR_ZONE_MODULE_RESTORE,        // ����ģ����߻ָ�
        MINOR_ALARMHOST_WIRELESS_OUTPUT_LOSS,   //�������ģ������
        MINOR_ALARMHOST_WIRELESS_OUTPUT_RESTORE,   //�������ģ��ָ�����
        MINOR_ALARMHOST_WIRELESS_REPEATER_LOSS,   //�����м�������
        MINOR_ALARMHOST_WIRELESS_REPEATER_RESTORE,   //�����м����ָ�����
        MINOR_TRIGGER_MODULE_LOSS,            // ������ģ�����
        MINOR_TRIGGER_MODULE_RESTORE,        // ������ģ����߻ָ�
        MINOR_WIRELESS_SIREN_LOSS,            // ���߾�������
        MINOR_WIRELESS_SIREN_RESTORE,    // ���߾��Żָ�����
        MINOR_ALARMHOST_WIRELESS_RS485_LOSS, //����RS485������ģ������
        MINOR_ALARMHOST_WIRELESS_RS485_RESTORE, //����RS485������ģ��ָ�����

        // ���� 
        MINOR_GUARD         = 0x01,        // ��ͨ����
        MINOR_UNGUARD,                    // ��ͨ����
        MINOR_BYPASS,                    // ��·
        MINOR_DURESS_ACCESS,            // Ю��
        MINOR_ALARMHOST_LOCAL_REBOOT,    // ��������
        MINOR_ALARMHOST_REMOTE_REBOOT,    // Զ������
        MINOR_ALARMHOST_LOCAL_UPGRADE,    // ��������
        MINOR_ALARMHOST_REMOTE_UPGRADE,    // Զ������
        MINOR_RECOVERY_DEFAULT_PARAM,    // �ָ�Ĭ�ϲ���
        MINOR_ALARM_OUTPUT,                // ���Ʊ������
        MINOR_ACCESS_OPEN,                // �����Ž���
        MINOR_ACCESS_CLOSE,                // �����Ž���
        MINOR_SIREN_OPEN,                // ���ƾ��ſ�
        MINOR_SIREN_CLOSE,                // ���ƾ��Ź�
        MINOR_MOD_ZONE_CONFIG,            // �޸ķ�������
        MINOR_MOD_ALARMOUT_CONIFG,        // ���Ʊ����������
        MINOR_MOD_ANALOG_CONFIG,        // �޸�ģ��������
        MINOR_RS485_CONFIG,                // �޸�485ͨ������
        MINOR_PHONE_CONFIG,                // �޸Ĳ�������
        MINOR_ADD_ADMIN,                // ���ӹ���Ա
        MINOR_MOD_ADMIN_PARAM,            // �޸Ĺ���Ա����
        MINOR_DEL_ADMIN,                // ɾ������Ա
        MINOR_ADD_NETUSER,                // ���Ӻ�˲���Ա
        MINOR_MOD_NETUSER_PARAM,        // �޸ĺ�˲���Ա����
        MINOR_DEL_NETUSER,                // ɾ����˲���Ա
        MINOR_ADD_OPERATORUSER,            // ����ǰ�˲���Ա
        MINOR_MOD_OPERATORUSER_PW,        // �޸�ǰ�˲���Ա����
        MINOR_DEL_OPERATORUSER,            // ɾ��ǰ�˲���Ա
        MINOR_ADD_KEYPADUSER,            // ���Ӽ���/�������û�    
        MINOR_DEL_KEYPADUSER,            // ɾ������/�������û�    
        MINOR_REMOTEUSER_LOGIN,            // Զ���û���½
        MINOR_REMOTEUSER_LOGOUT,        // Զ���û�ע��
        MINOR_REMOTE_GUARD,                // Զ�̲���
        MINOR_REMOTE_UNGUARD,            // Զ�̳���
        MINOR_MOD_HOST_CONFIG,          // �޸���������
        MINOR_RESTORE_BYPASS,            // ��·�ָ�
        MINOR_ALARMOUT_OPEN,            // �����������
        MINOR_ALARMOUT_CLOSE,            // ��������ر�
        MINOR_MOD_SUBSYSTEM_PARAM,        // �޸���ϵͳ��������
        MINOR_GROUP_BYPASS,                // ����·
        MINOR_RESTORE_GROUP_BYPASS,        // ����·�ָ�
        MINOR_MOD_GRPS_PARAM,            // �޸�GPRS����
        MINOR_MOD_NET_REPORT_PARAM,        // �޸������ϱ���������
        MINOR_MOD_REPORT_MOD,            // �޸��ϴ���ʽ����
        MINOR_MOD_GATEWAY_PARAM,        // �޸��Ž���������
        MINOR_ALARMHOST_REMOTE_START_REC,        // Զ�̿�ʼ¼��
        MINOR_ALARMHOST_REMOTE_STOP_REC,        // Զ��ֹͣ¼��
        MINOR_ALARMHOST_START_TRANS_CHAN,        // ��ʼ͸������
        MINOR_ALARMHOST_STOP_TRANS_CHAN,        // ֹͣ͸������
        MINOR_ALARMHOST_START_VT,                // ��ʼ�����Խ�
        MINOR_ALARMHOST_STOP_VTM,                // ֹͣ�����Խ�
        MINOR_ALARMHOST_REMOTE_PLAYBYFILE,        // Զ�̰��ļ��ط�
        MINOR_ALARMHOST_REMOTE_PLAYBYTIME,      // Զ�̰�ʱ��ط�
        MINOR_ALARMHOST_REMOTE_PTZCTRL,            // Զ����̨����
        MINOR_ALARMHOST_REMOTE_FORMAT_HDD,      // Զ�̸�ʽ��Ӳ��
        MINOR_ALARMHOST_REMOTE_LOCKFILE,        // Զ�������ļ�
        MINOR_ALARMHOST_REMOTE_UNLOCKFILE,      // Զ�̽����ļ�
        MINOR_ALARMHOST_REMOTE_CFGFILE_OUTPUT,  // Զ�̵��������ļ�
        MINOR_ALARMHOST_REMOTE_CFGFILE_INTPUT,  // Զ�̵��������ļ�
        MINOR_ALARMHOST_REMOTE_RECFILE_OUTPUT,  // Զ�̵���¼���ļ�
        
        MINOR_ALARMHOST_STAY_ARM,                        //���ز���
        MINOR_ALARMHOST_QUICK_ARM,                        //��ʱ����
        MINOR_ALARMHOST_AUTOMATIC_ARM,                    //�Զ�����
        MINOR_ALARMHOST_AUTOMATIC_DISARM,                //�Զ�����
        MINOR_ALARMHOST_KEYSWITCH_ARM,                    //Կ�׷�������
        MINOR_ALARMHOST_KEYSWITCH_DISARM,                //Կ�׷�������
        MINOR_ALARMHOST_CLEAR_ALARM,                    //����
        MINOR_ALARMHOST_MOD_FAULT_CFG,                    //�޸�ϵͳ��������
        MINOR_ALARMHOST_MOD_EVENT_TRIGGER_ALARMOUT_CFG,    //�޸��¼����������������
        MINOR_ALARMHOST_SEARCH_EXTERNAL_MODULE,            //�������ģ��
        MINOR_ALARMHOST_REGISTER_EXTERNAL_MODULE,        //����ע�����ģ��
        MINOR_ALARMHOST_CLOSE_KEYBOARD_ALARM,            //�رռ��̱�����ʾ��
        MINOR_ALARMHOST_MOD_3G_PARAM,                    //�޸�3G����
        MINOR_ALARMHOST_MOD_PRINT_PARAM, //�޸Ĵ�ӡ������
        MINOR_SD_CARD_FORMAT,        //SD����ʽ��
        MINOR_SUBSYSTEM_UPGRADE,        //�Ӱ�̼�����
        
        MINOR_ALARMHOST_PLAN_ARM_CFG,    //�ƻ���������������
        MINOR_ALARMHOST_PHONE_ARM,        //�ֻ�����
        MINOR_ALARMHOST_PHONE_STAY_ARM,    //�ֻ����ز���
        MINOR_ALARMHOST_PHONE_QUICK_ARM,//�ֻ���ʱ����
        MINOR_ALARMHOST_PHONE_DISARM,    //�ֻ�����
        MINOR_ALARMHOST_PHONE_CLEAR_ALARM,    //�ֻ�����
        MINOR_ALARMHOST_WHITELIST_CFG,    //����������
        MINOR_ALARMHOST_TIME_TRIGGER_CFG,            //��ʱ���ش���������
        MINOR_ALARMHOST_CAPTRUE_CFG,                //ץͼ��������
        MINOR_ALARMHOST_TAMPER_CFG,                //���������������

        MINOR_ALARMHOST_REMOTE_KEYPAD_UPGRADE,               //Զ����������
        MINOR_ALARMHOST_ONETOUCH_AWAY_ARMING,                //һ��������� 
        MINOR_ALARMHOST_ONETOUCH_STAY_ARMING,                //һ�����ز���
        MINOR_ALARMHOST_SINGLE_PARTITION_ARMING_OR_DISARMING,    //������������ 
        MINOR_ALARMHOST_CARD_CONFIGURATION,         //����������
        MINOR_ALARMHOST_CARD_ARMING_OR_DISARMING,         //ˢ��������
        MINOR_ALARMHOST_EXPENDING_NETCENTER_CONFIGURATION,         //��չ������������
        MINOR_ALARMHOST_NETCARD_CONFIGURATION,         //��������
        MINOR_ALARMHOST_DDNS_CONFIGURATION,         //DDNS����
        MINOR_ALARMHOST_RS485BUS_CONFIGURATION,        // 485���߲�������
        MINOR_ALARMHOST_RS485BUS_RE_REGISTRATION,            //485��������ע��

        MINOR_ALARMHOST_REMOTE_OPEN_ELECTRIC_LOCK,    //Զ�̴򿪵���
        MINOR_ALARMHOST_REMOTE_CLOSE_ELECTRIC_LOCK,    //Զ�̹رյ���
        MINOR_ALARMHOST_LOCAL_OPEN_ELECTRIC_LOCK,    //���ش򿪵���
        MINOR_ALARMHOST_LOCAL_CLOSE_ELECTRIC_LOCK,    //���عرյ���
        MINOR_ALARMHOST_OPEN_ALARM_LAMP,            //�򿪾���(Զ��)
        MINOR_ALARMHOST_CLOSE_ALARM_LAMP,            //�رվ���(Զ��)
       

        MINOR_ALARMHOST_TEMPORARY_PASSWORD,         //��ʱ���������¼
        MINOR_ALARMHOST_ONEKEY_AWAY_ARM,            //һ��������� 
        MINOR_ALARMHOST_ONEKEY_STAY_ARM,            //һ�����ز���
        MINOR_ALARMHOST_SINGLE_ZONE_ARM,            //���������� 
        MINOR_ALARMHOST_SINGLE_ZONE_DISARM,         //����������
        MINOR_ALARMHOST_HIDDNS_CONFIG,                // HIDDNS����
        MINOR_ALARMHOST_REMOTE_KEYBOARD_UPDATA,     //Զ�̼���������־
        MINOR_ALARMHOST_ZONE_ADD_DETECTOR,          //�������̽����
        MINOR_ALARMHOST_ZONE_DELETE_DETECTOR,       //����ɾ��̽����
        MINOR_ALARMHOST_QUERY_DETECTOR_SIGNAL,      //������ѯ̽�����ź�ǿ��
        MINOR_ALARMHOST_QUERY_DETECTOR_BATTERY,     //������ѯ̽��������
        MINOR_ALARMHOST_SET_DETECTOR_GUARD,         //̽��������
        MINOR_ALARMHOST_SET_DETECTOR_UNGUARD,       //̽��������
        MINOR_ALARMHOST_SET_WIFI_PARAMETER,         //����WIFI���ò���
        MINOR_ALARMHOST_OPEN_VOICE,                 //������
        MINOR_ALARMHOST_CLOSE_VOICE,                //�ر�����
        MINOR_ALARMHOST_ENABLE_FUNCTION_KEY,        //���ù��ܼ�
        MINOR_ALARMHOST_DISABLE_FUNCTION_KEY,        //�رչ��ܼ�
        MINOR_ALARMHOST_READ_CARD,                  //Ѳ��ˢ��
        MINOR_ALARMHOST_START_BROADCAST,             //�������㲥
        MINOR_ALARMHOST_STOP_BROADCAST,               //�ر������㲥
        MINOR_ALARMHOST_REMOTE_ZONE_MODULE_UPGRADE,            //Զ����������ģ��
        MINOR_ALARMHOST_NETWORK_MODULE_EXTEND,    //����ģ���������
        MINOR_ALARMHOST_ADD_CONTROLLER,		//���ң�����û�
        MINOR_ALARMHOST_DELETE_CONTORLLER,		//ɾ��ң�����û�
        MINOR_ALARMHOST_REMOTE_NETWORKMODULE_UPGRADE,            //Զ����������ģ��
        MINOR_ALARMHOST_WIRELESS_OUTPUT_ADD,   //ע���������ģ��
        MINOR_ALARMHOST_WIRELESS_OUTPUT_DEL,   //ɾ���������ģ��
        MINOR_ALARMHOST_WIRELESS_REPEATER_ADD,   //ע�������м���
        MINOR_ALARMHOST_WIRELESS_REPEATER_DEL,   //ɾ�������м���
        MINOR_ALARMHOST_PHONELIST_CFG,    //�绰������������
        MINOR_ALARMHOST_RF_SIGNAL_CHECK,  // RF�źŲ�ѯ
        MINOR_ALARMHOST_USB_UPGRADE,  // USB����
        MINOR_ALARMHOST_DOOR_TIME_REMINDER_CFG,//�ŴŶ�ʱ���Ѳ�������
        MINOR_ALARMHOST_WIRELESS_SIREN_ADD,   //ע�����߾���
        MINOR_ALARMHOST_WIRELESS_SIREN_DEL,   //ɾ�����߾���
        MINOR_ALARMHOST_OUT_SCALE_OPEN,   //���翪��
        MINOR_ALARMHOST_OUT_SCALE_CLOSE,   //����ر�

        MINOR_ALARMHOST_TIME_ZONE_CFG,//ʱ���޸�
        MINOR_ALARMHOST_NTP_START_AND_PARAMETERS_CFG,//NTP�����������޸�
        MINOR_ALARMHOST_DST_START_AND_PARAMETERS_CFG,//DST�����������޸�
        MINOR_ALARMHOST_DEVINFO_CFG,//�豸��Ϣ����
        MINOR_ALARMHOST_VIDEO_OVERLAP_CFG,//¼�񸲸�����
        MINOR_ALARMHOST_SSH_CFG,//SSH��������
        MINOR_ALARMHOST_PASSWORD_MANAGE_CFG,//�����������
        MINOR_ALARMHOST_RESTORE_DEFAULT_PARAMETERS,//�ָ�Ĭ�ϲ���
        MINOR_ALARMHOST_RESTORECOMPLETELY_DEFAULT_PARAMETERS,//��ȫ�ָ�Ĭ�ϲ���
        MINOR_ALARMHOST_AUDIO_AUTO_DETECT_CFG,//�Զ�����������
        MINOR_ALARMHOST_AUDIO_MANUAL_DETECT_CFG,//�ֶ����
        MINOR_ALARMHOST_NET_PARAMETERS_CFG,//�����������
        MINOR_ALARMHOST_MTU_CFG,//MTU����
        MINOR_ALARMHOST_PORT_CFG,//�˿�����
        MINOR_ALARMHOST_DEFAULT_ROUTER_CFG,//Ĭ��·������
        MINOR_ALARMHOST_DNS_PARAMETERS_CFG,//DNS��������
        MINOR_ALARMHOST_UNPNP_PARAMETERS_CFG,//UNPNP��������
        MINOR_ALARMHOST_SIP_PARAMETERS_CFG,//SIP��������
        MINOR_ALARMHOST_FLOW_LIMIT_CFG,//�����޶��������
        MINOR_ALARMHOST_APN_PARAMETERS_CFG,//APN��������
        MINOR_ALARMHOST_MESSAGE_TELEPHONENO_CFG,//���ŵ绰��������
        MINOR_ALARMHOST_EZVIZ_PARAMATERS_CFG,//өʯ��������
        MINOR_ALARMHOST_ISUP_PARAMATERS_CFG,//ISUP��������
        MINOR_ALARMHOST_SIP_SWITCH_CFG,//SIP��׼Э��˽��Э���л�
        MINOR_ALARMHOST_INFO_UPLOAD_TO_PLATFORM_CFG,//�ϴ�ƽ̨��Ϣ����
        MINOR_ALARMHOST_ONVIF_CONTROL,//ONVIF����(�������ر�)
        MINOR_ALARMHOST_ONVIF_USER_ADD,//onvif�û�������
        MINOR_ALARMHOST_ONVIF_USER_MOD,//onvif�û����޸�
        MINOR_ALARMHOST_ONVIF_USER_DELETE,//onvif�û���ɾ��
        MINOR_ALARMHOST_TIME_OF_BELLS_CFG,//����ʱ��
        MINOR_ALARMHOST_CALL_WAITTIME_CFG,//���еȴ�ʱ��
        MINOR_ALARMHOST_PROMPT_PARAMATERS_CFG,//��ʾ����������
        MINOR_ALARMHOST_MUTEPLAN_PARAMATERS_CFG,//�����ƻ���������
        MINOR_ALARMHOST_SD_PARTITION_CFG,//SD��������������
        MINOR_ALARMHOST_AUDIO_PARAMETERS_CFG,//����Ƶ��������
        MINOR_ALARMHOST_VOICETALK_AUDIO_ENCODING_CFG,//�Խ���Ƶ����
        MINOR_ALARMHOST_RECORD_PLAN_PARAMETERS_CFG,//¼��ƻ���������
        MINOR_ALARMHOST_RECORD_ADVANCE_PARAMETERS_CFG,//¼��߼���������
        MINOR_ALARMHOST_PICTURE_PLAN_PARAMETERS_CFG,//ץͼ�ƻ���������
        MINOR_ALARMHOST_PICTURE_ADVANCE_PARAMETERS_CFG,//ץͼ�߼���������
        MINOR_ALARMHOST_AUDIO_EXCEPTION_PARAMETERS_CFG,//��Ƶ�쳣��������
        MINOR_ALARMHOST_PATROL_CARD_CFG,//Ѳ��������
        MINOR_ALARMHOST_VOICE_VOLUME_CFG,//��������
        MINOR_ALARMHOST_VOICE_MODE_CFG,//����ģʽ���ã����룬������㲥ģʽ��
        MINOR_ALARMHOST_AUDIO_OR_MATERIALS_UPLOAD,//��Ƶ���ز��ļ��ϴ�
        MINOR_ALARMHOST_AUDIO_OR_MATERIALS_DELETE,//��Ƶ���ز��ļ�ɾ��
        MINOR_ALARMHOST_ALARM_LAMP_FLASH_TIME_CFG,//��˸ʱ��
        MINOR_ALARMHOST_ALARM_LAMP_FLASH_PLAN_CFG,//�ƻ���˸����
        MINOR_ALARMHOST_FRONT_END_VIDEO_PARAMETERS_CFG,//ǰ����Ƶ��������
        MINOR_ALARMHOST_WDR_CFG,//��̬����
        MINOR_ALARMHOST_BPFRAME_CFG,//PN֡����
        MINOR_ALARMHOST_PASSWORD_RESET_CFG,//������������
        MINOR_ALARMHOST_ACCOUNT_LOCK,//�˻�����
        MINOR_ALARMHOST_ACCOUNT_UNLOCK,//�˻�����
        MINOR_ALARMHOST_START_LIVEVIEW_REMOTELY,//Զ�̿���Ԥ��
        MINOR_ALARMHOST_STOP_LIVEVIEW_REMOTELT,//Զ�̹ر�Ԥ��
        MINOR_ALARMHOST_TELEPHONE_CENTER_SETTINGS,//�绰���Ĳ�������
        MINOR_ALARMHOST_NATIONAL_STANDARD_CFG,//��������

        MINOR_ALARMHOST_LOCAL_SET_DEVICE_ACTIVE = 0xf0,        //���ؼ����豸
        MINOR_ALARMHOST_REMOTE_SET_DEVICE_ACTIVE = 0xf1,        //Զ�̼����豸
        MINOR_ALARMHOST_LOCAL_PARA_FACTORY_DEFAULT = 0xf2,    //���ػظ���������
        MINOR_ALARMHOST_REMOTE_PARA_FACTORY_DEFAULT = 0xf3,    //Զ�ָ̻���������

        MINOR_ADD_IPC = 0xf4,       //IPC���(��������IPC)
        MINOR_MODIFY_IPC = 0xf5,    //IPC�޸�
        MINOR_DELETE_IPC = 0xf6,    //IPCɾ��
        MINOR_SYS_CHECK_START = 0xf7,  //ϵͳ��⿪ʼ
        MINOR_SYS_CHECK_STOP = 0xf8,  //ϵͳ�����ֹ   
        MINOR_SYS_CHECK_FINISH = 0xf9, //ϵͳ������


        // �¼� 
        MINOR_SCHOOLTIME_IRGI_B = 0x01,        // B��Уʱ
        MINOR_SCHOOLTIME_SDK,                // SDKУʱ
        MINOR_SCHOOLTIME_SELFTEST,            // ��ʱ�Լ�Уʱ
        MINOR_SUBSYSTEM_ABNORMALINSERT,        //�Ӱ���� 
        MINOR_SUBSYSTEM_ABNORMALPULLOUT,        //�Ӱ�γ�
        
        MINOR_AUTO_ARM,                    //�Զ�����
        MINOR_AUTO_DISARM,                //�Զ�����
        MINOR_TIME_TIGGER_ON,            //��ʱ����������
        MINOR_TIME_TIGGER_OFF,            //��ʱ�رմ�����
        MINOR_AUTO_ARM_FAILD,            //�Զ�����ʧ��
        MINOR_AUTO_DISARM_FAILD,        //�Զ�����ʧ��
        MINOR_TIME_TIGGER_ON_FAILD,        //��ʱ����������ʧ��
        MINOR_TIME_TIGGER_OFF_FAILD,    //��ʱ�رմ�����ʧ��
        MINOR_MANDATORY_ALARM,            //ǿ�Ʋ���
        MINOR_KEYPAD_LOCKED,            //��������
        MINOR_USB_INSERT,               //USB���� 
        MINOR_USB_PULLOUT,              //USB�γ�
}ALARMHOST_MINOR_TYPE;


//����־��������ΪMAJOR_OPERATION=03��������ΪMINOR_LOCAL_CFG_PARM=0x52����MINOR_REMOTE_GET_PARM=0x76
//����MINOR_REMOTE_CFG_PARM=0x77ʱ��dwParaType:����������Ч���京�����£�
#define PARA_VIDEOOUT    0x1
#define PARA_IMAGE        0x2
#define PARA_ENCODE        0x4
#define PARA_NETWORK    0x8
#define PARA_ALARM        0x10
#define PARA_EXCEPTION    0x20
#define PARA_DECODER    0x40    /*������*/
#define PARA_RS232        0x80
#define PARA_PREVIEW    0x100
#define PARA_SECURITY    0x200
#define PARA_DATETIME    0x400
#define PARA_FRAMETYPE    0x800    /*֡��ʽ*/
#define PARA_DETECTION  0x1000   //�������
#define PARA_VCA_RULE   0x1001  //��Ϊ���� 
#define PARA_VCA_CTRL   0x1002  //�������ܿ�����Ϣ
#define PARA_VCA_PLATE  0x1003 // ����ʶ��

#define PARA_CODESPLITTER 0x2000 /*���������*/
//2010-01-22 ������Ƶ�ۺ�ƽ̨��־��Ϣ������
#define PARA_RS485          0x2001            /* RS485������Ϣ*/
#define PARA_DEVICE          0x2002            /* �豸������Ϣ*/
#define PARA_HARDDISK      0x2003            /* Ӳ��������Ϣ */
#define PARA_AUTOBOOT      0x2004            /* �Զ�����������Ϣ*/
#define PARA_HOLIDAY      0x2005            /* �ڼ���������Ϣ*/            
#define PARA_IPC          0x2006            /* IPͨ������ */    
/*************************������������ end*******************************/


/*******************�����ļ�����־��������ֵ*************************/
#define NET_DVR_FILE_SUCCESS            1000    //����ļ���Ϣ
#define NET_DVR_FILE_NOFIND                1001    //û���ļ�
#define NET_DVR_ISFINDING                1002    //���ڲ����ļ�
#define    NET_DVR_NOMOREFILE                1003    //�����ļ�ʱû�и�����ļ�
#define    NET_DVR_FILE_EXCEPTION            1004    //�����ļ�ʱ�쳣

/*********************�ص��������� begin************************/

//�����ص�����
#define COMM_ALARM                           0x1100    //8000������Ϣ�����ϴ�

//��ӦNET_VCA_RULE_ALARM
#define COMM_ALARM_RULE                      0x1102     //��Ϊ����������Ϣ
#define COMM_ALARM_PDC                       0x1103  //����ͳ�Ʊ�����Ϣ
#define COMM_ALARM_VIDEOPLATFORM             0x1104  //��Ƶ�ۺ�ƽ̨����
#define COMM_ALARM_ALARMHOST                 0x1105  //���籨����������
#define COMM_ALARM_FACE                      0x1106  //�������ʶ�𱨾���Ϣ
#define COMM_RULE_INFO_UPLOAD                0x1107  // �¼�������Ϣ�ϴ�
#define COMM_ALARM_AID                       0x1110  //��ͨ�¼�������Ϣ
#define COMM_ALARM_TPS                       0x1111  //��ͨ����ͳ�Ʊ�����Ϣ
//��������ץ�Ľ���ϴ�
#define COMM_UPLOAD_FACESNAP_RESULT          0x1112  //����ʶ�����ϴ�
#define COMM_ALARM_TFS                       0x1113  //��ͨȡ֤������Ϣ
#define COMM_ALARM_TPS_V41                   0x1114  //��ͨ����ͳ�Ʊ�����Ϣ��չ
#define COMM_ALARM_AID_V41                   0x1115  //��ͨ�¼�������Ϣ��չ
#define COMM_ALARM_VQD_EX                    0x1116     //��Ƶ������ϱ���
#define COMM_ALARM_NOTIFICATION_REPORT       0x1117  //֪ͨ�¼��ϱ�
#define COMM_SENSOR_VALUE_UPLOAD             0x1120  //ģ��������ʵʱ�ϴ�
#define COMM_SENSOR_ALARM                    0x1121  //ģ���������ϴ�
#define COMM_SWITCH_ALARM                    0x1122     //����������
#define COMM_ALARMHOST_EXCEPTION             0x1123  //�����������ϱ���
#define COMM_ALARMHOST_OPERATEEVENT_ALARM    0x1124  //�����¼������ϴ�
#define COMM_ALARMHOST_SAFETYCABINSTATE      0x1125     //������״̬
#define COMM_ALARMHOST_ALARMOUTSTATUS        0x1126     //���������/����״̬
#define COMM_ALARMHOST_CID_ALARM               0x1127     //���汨���ϴ�
#define    COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM 0x1128     //������������豸�����ϴ�
#define COMM_ALARMHOST_DATA_UPLOAD           0x1129     //���������ϴ�
#define COMM_FACECAPTURE_STATISTICS_RESULT   0x112a  //����ץ��ͳ���ϴ�
#define COMM_ALARM_WIRELESS_INFO   0x122b  // ����������Ϣ�ϴ�
#define COMM_SCENECHANGE_DETECTION_UPLOAD     0x1130     //������������ϴ�(����)2013-7-16
#define COMM_CROSSLINE_ALARM                 0x1131    //ѹ�߱���(����) 2013-09-27
#define COMM_UPLOAD_VIDEO_INTERCOM_EVENT     0x1132  //���ӶԽ��¼���¼�ϴ�
#define COMM_ALARM_VIDEO_INTERCOM               0x1133  //���ӶԽ������ϴ�
#define COMM_UPLOAD_NOTICE_DATA              0x1134  //���ӶԽ�������Ϣ�ϴ�
#define COMM_ALARM_AUDIOEXCEPTION             0x1150     //����������Ϣ
#define COMM_ALARM_DEFOCUS                   0x1151     //�齹������Ϣ
#define COMM_ALARM_BUTTON_DOWN_EXCEPTION     0x1152     //��ť���±�����Ϣ
#define COMM_ALARM_ALARMGPS                  0x1202  //GPS������Ϣ�ϴ�
#define    COMM_TRADEINFO                       0x1500  //ATMDVR�����ϴ�������Ϣ
#define COMM_UPLOAD_PLATE_RESULT             0x2800     //�ϴ�������Ϣ
#define COMM_ITC_STATUS_DETECT_RESULT        0x2810  //ʵʱ״̬������ϴ�(���ܸ���IPC)
#define COMM_IPC_AUXALARM_RESULT             0x2820  //PIR���������߱��������ȱ����ϴ�
#define COMM_UPLOAD_PICTUREINFO              0x2900     //�ϴ�ͼƬ��Ϣ
#define COMM_SNAP_MATCH_ALARM                0x2902  //�������ȶԽ���ϴ�
#define COMM_ITS_PLATE_RESULT                0x3050  //�ն�ͼƬ�ϴ�
#define    COMM_ITS_TRAFFIC_COLLECT             0x3051  //�ն�ͳ�������ϴ�
#define COMM_ITS_GATE_VEHICLE                0x3052  //����ڳ���ץ�������ϴ�
#define COMM_ITS_GATE_FACE                   0x3053  //���������ץ�������ϴ�
#define COMM_ITS_GATE_COSTITEM                 0x3054  //����ڹ����շ���ϸ 2013-11-19
#define COMM_ITS_GATE_HANDOVER                 0x3055  //����ڽ��Ӱ����� 2013-11-19
#define COMM_ITS_PARK_VEHICLE                0x3056  //ͣ���������ϴ�
#define COMM_ITS_BLACKLIST_ALARM             0x3057  //�����������ϴ�

#define COMM_VEHICLE_CONTROL_LIST_DSALARM    0x3058  //�ڰ�����������Ҫͬ������2013-11-04
#define COMM_VEHICLE_CONTROL_ALARM           0x3059  //��������2013-11-04
#define COMM_FIRE_ALARM                      0x3060  //��������2013-11-04

#define COMM_ITS_GATE_ALARMINFO              0x3061  //����ڿ��ƻ������ϴ�

#define COMM_VEHICLE_RECOG_RESULT            0x3062  //��������ʶ�����ϴ� 2014-11-12 
#define COMM_PLATE_RESULT_V50                0x3063  //�����ϴ� V50

#define COMM_GATE_CHARGEINFO_UPLOAD          0x3064  //����ڸ�����Ϣ�ϴ�
#define COMM_TME_VEHICLE_INDENTIFICATION     0x3065  //TME����ץͼ�ϴ�
#define COMM_GATE_CARDINFO_UPLOAD            0x3066  //����ڿ�Ƭ��Ϣ�ϴ�
#define COMM_LOADING_DOCK_OPERATEINFO     0x3067        //��̨��ҵ�ϴ�

#define COMM_ALARM_SENSORINFO_UPLOAD         0x3077     //�������ϴ���Ϣ
#define COMM_ALARM_CAPTURE_UPLOAD             0x3078     //ץ��ͼƬ�ϴ�

#define COMM_ITS_RADARINFO                   0x3079  //�״ﱨ���ϴ�

#define COMM_SIGNAL_LAMP_ABNORMAL            0x3080  //�źŵ��쳣����ϴ�

#define COMM_ALARM_TPS_REAL_TIME             0x3081  //TPSʵʱ���������ϴ�
#define COMM_ALARM_TPS_STATISTICS            0x3082  //TPSͳ�ƹ��������ϴ�

#define COMM_ALARM_V30                         0x4000     //9000������Ϣ�����ϴ�
#define COMM_IPCCFG                             0x4001     //9000�豸IPC�������øı䱨����Ϣ�����ϴ�
#define COMM_IPCCFG_V31                         0x4002     //9000�豸IPC�������øı䱨����Ϣ�����ϴ���չ 9000_1.1
#define COMM_IPCCFG_V40                      0x4003  // IVMS 2000 ��������� NVR IPC�������øı�ʱ������Ϣ�ϴ�
#define COMM_ALARM_DEVICE                    0x4004  //�豸�������ݣ�����ͨ��ֵ����256����չ
#define COMM_ALARM_CVR                         0x4005  //CVR 2.0.X�ⲿ��������
#define COMM_ALARM_HOT_SPARE                 0x4006  //�ȱ��쳣������N+1ģʽ�쳣������
#define COMM_ALARM_V40                         0x4007    //�ƶ���⣬��Ƶ��ʧ���ڵ���IO�ź����ȱ�����Ϣ�����ϴ�����������Ϊ�ɱ䳤

#define COMM_UPLOAD_HEATMAP_RESULT           0x4008 //�ȶ�ͼ�����ϴ� 2014-03-21
#define COMM_ALARM_DEVICE_V40                0x4009  //�豸����������չ
#define COMM_ALARM_FACE_DETECTION            0x4010 //������ⱨ��
#define COMM_ALARM_TARGET_LEFT_REGION        0x4011 //���Ŀ���뿪������򱨾�(��ʦ����ѧ������(���������л�¼���������Ƽ��ѧ�������))
#define COMM_GISINFO_UPLOAD                  0x4012 //GIS��Ϣ�ϴ�
#define COMM_VANDALPROOF_ALARM               0x4013 //�ϴ����ƻ�������Ϣ
#define COMM_PEOPLE_DETECTION_UPLOAD         0x4014 //��Ա�����Ϣ�ϴ�
#define COMM_ALARM_STORAGE_DETECTION         0x4015 //�洢���ܼ�ⱨ���ϴ�
#define COMM_MVM_REGISTER                    0x4016 //�شŹ�������Magnetic Vehicle Manager��ע��
#define COMM_MVM_STATUS_INFO                 0x4017 //�شŹ�������Magnetic Vehicle Manager��״̬�ϱ�
#define COMM_UPLOAD_HEATMAP_RESULT_PDC           0x4018 //�ȶ�ͼ������ͳ�������ϴ��¼�
#define COMM_UPLOAD_HEATMAP_RESULT_DURATION      0x4019 //�ȶ�ͼ����Աͣ��ʱ��ͳ�������ϴ��¼�
#define COMM_UPLOAD_HEATMAP_RESULT_INTERSECTION  0x4020 //·�ڷ����ȶ�ֵ����ϴ�
#define COMM_UPLOAD_AIOP_VIDEO               0x4021 //�豸֧��AI����ƽ̨���룬�ϴ���Ƶ�������
#define COMM_UPLOAD_AIOP_PICTURE             0x4022 //�豸֧��AI����ƽ̨���룬�ϴ�ͼƬ�������
#define COMM_UPLOAD_AIOP_POLLING_SNAP        0x4023 //�豸֧��AI����ƽ̨���룬�ϴ���ѲץͼͼƬ������� ��Ӧ�Ľṹ��(NET_AIOP_POLLING_PICTURE_HEAD)
#define COMM_UPLOAD_AIOP_POLLING_VIDEO       0x4024 //�豸֧��AI����ƽ̨���룬�ϴ���Ѳ��Ƶ������� ��Ӧ�Ľṹ��(NET_AIOP_POLLING_VIDEO_HEAD)


#define    COMM_ITS_ROAD_EXCEPTION                 0x4500     //·���豸�쳣����
#define    COMM_ITS_EXTERNAL_CONTROL_ALARM         0x4520  //��ر���
#define COMM_ALARM_SHIPSDETECTION             0x4521    // ��ֻ��ⱨ����Ϣ

#define COMM_VCA_DBD_ALARM 0x4550       //��ʻ��Ϊ������Ϣ
#define COMM_VCA_ADAS_ALARM 0x4551      //�߼�������ʻ������Ϣ
#define COMM_VEH_REALTIME_INFO 0x4552   //�г�ʵʱ������Ϣ
#define COMM_VCA_ATTEND_ALARM 0x4553       //�����¼�������Ϣ

#define COMM_FIREDETECTION_ALARM             0x4991 //����ⱨ��
#define COMM_ALARM_DENSEFOGDETECTION    0x4992     //�����ⱨ����Ϣ
#define COMM_VCA_ALARM                     0x4993     //���ܼ�ⱨ��
#define COMM_FACE_THERMOMETRY_ALARM        0x4994     //�������±���

#define  COMM_TAPE_ARCHIVE_ALARM        0x4996 //�Ŵ���鵵����

#define    COMM_SCREEN_ALARM                    0x5000  //������������������
#define COMM_DVCS_STATE_ALARM                 0x5001  //�ֲ�ʽ���������������ϴ�
#define COMM_ALARM_ACS                         0x5002  //�Ž���������
#define COMM_ALARM_FIBER_CONVERT             0x5003  //�����շ�������
#define COMM_ALARM_SWITCH_CONVERT             0x5004  //����������
#define COMM_ALARM_DEC_VCA                   0x5010  //���ܽ��뱨��
#define COMM_ALARM_LCD                         0x5011     //��Ļ����
#define COMM_CONFERENCE_CALL_ALARM             0x5012     //������и澯

#define COMM_ALARM_WALL_CONFERNECE  0x5015  //MCU�����ѿ���Ļ�����Ϣ����

#define COMM_DIAGNOSIS_UPLOAD                0x5100  //��Ϸ�����VQD�����ϴ�
#define COMM_HIGH_DENSITY_UPLOAD             0x5101  //��Ա�ۼ��ܶ���������ϴ�

#define COMM_ID_INFO_ALARM                   0x5200  //���֤��Ϣ�ϴ�
#define COMM_PASSNUM_INFO_ALARM              0x5201  //ͨ�������ϱ�
#define COMM_PASSPORT_ALARM                   0x5202  //������Ϣ�ϴ�

#define COMM_THERMOMETRY_DIFF_ALARM          0x5211  //�²���ϴ�
#define COMM_THERMOMETRY_ALARM               0x5212  //�¶ȱ����ϴ�
#define COMM_PANORAMIC_LINKAGE_ALARM         0x5213  //ȫ��������λ�ϴ�
#define COMM_TAG_INFO_ALARM                  0x5215  // ��ǩ��Ϣ�ϴ�
#define COMM_ALARM_VQD                         0x6000  //VQD���������ϴ� 
#define COMM_PUSH_UPDATE_RECORD_INFO          0x6001  //��ģʽ¼����Ϣ�ϴ�
#define COMM_SWITCH_LAMP_ALARM               0x6002  //���صƼ��
#define COMM_INQUEST_ALARM             0x6005  // ��Ѷ���������ϴ�
#define COMM_VIDEO_PARKING_POLE_ALARM       0x6006  //��Ƶ׮����
#define COMM_GPS_STATUS_ALARM                0x6010  // GPS״̬�ϴ�
#define  COMM_BASE_STATION_INFO_ALARM        0x6011  //��վ��Ϣ�ϴ�
#define COMM_ALARM_SUBSCRIBE_EVENT           0x6012  //���Ľ���ϱ�

#define COMM_FACESNAP_RAWDATA_ALARM          0x6015  //�����ȶԱ���������͸����ʽ��
#define COMM_CLUSTER_ALARM       0x6020    //��Ⱥ�����ϴ�

#define COMM_ISAPI_ALARM  0x6009

//PJ01C20170209084����¼��NVS������ܿ���������Ŀר��
#define COMM_FRAMES_PEOPLE_COUNTING_ALARM	 0x6069	 //��֡��������ͳ�ƽ���ϴ�

#define  COMM_SIGN_ABNORMAL_ALARM            0x6120 //�����쳣����
#define  COMM_HFPD_ALARM                     0x6121 //��Ƶ��Ա��ⱨ��

#define   COMM_HCU_ALARM  0x6150  //�������ܺ��ӱ�����������SDK�ⲻʵ�֣������豸��DVRͨ��Э�飬ռλ��ֹ��ͻ��

#define  COMM_DEV_STATUS_CHANGED             0x7000  //�豸״̬�ı䱨���ϴ�

/*************�����쳣����(��Ϣ��ʽ, �ص���ʽ(����))****************/
#define EXCEPTION_EXCHANGE                0x8000    //�û�����ʱ�쳣
#define EXCEPTION_AUDIOEXCHANGE            0x8001    //�����Խ��쳣
#define EXCEPTION_ALARM                    0x8002    //�����쳣
#define EXCEPTION_PREVIEW                0x8003    //����Ԥ���쳣
#define EXCEPTION_SERIAL                0x8004    //͸��ͨ���쳣
#define EXCEPTION_RECONNECT                0x8005    //Ԥ��ʱ����
#define EXCEPTION_ALARMRECONNECT        0x8006    //����ʱ����
#define EXCEPTION_SERIALRECONNECT        0x8007    //͸��ͨ������
#define SERIAL_RECONNECTSUCCESS         0x8008    //͸��ͨ�������ɹ�
#define EXCEPTION_PLAYBACK                0x8010    //�ط��쳣
#define EXCEPTION_DISKFMT                0x8011    //Ӳ�̸�ʽ��
#define EXCEPTION_PASSIVEDECODE         0x8012  //���������쳣
#define EXCEPTION_EMAILTEST             0x8013  //�ʼ������쳣    
#define EXCEPTION_BACKUP                0x8014  //�����쳣
#define PREVIEW_RECONNECTSUCCESS        0x8015  //Ԥ��ʱ�����ɹ�
#define ALARM_RECONNECTSUCCESS          0x8016  //����ʱ�����ɹ�
#define RESUME_EXCHANGE                    0x8017    //�û������ָ�
#define NETWORK_FLOWTEST_EXCEPTION      0x8018  //������������쳣
#define EXCEPTION_PICPREVIEWRECONNECT    0x8019    //ͼƬԤ������
#define PICPREVIEW_RECONNECTSUCCESS        0x8020    //ͼƬԤ�������ɹ�
#define EXCEPTION_PICPREVIEW            0x8021    //ͼƬԤ���쳣
#define    EXCEPTION_MAX_ALARM_INFO        0x8022    //������Ϣ�����Ѵ�����
#define    EXCEPTION_LOST_ALARM            0x8023  //������ʧ
#define EXCEPTION_PASSIVETRANSRECONNECT 0x8024  //����ת������
#define PASSIVETRANS_RECONNECTSUCCESS   0x8025  //����ת�������ɹ�
#define EXCEPTION_PASSIVETRANS          0x8026  //����ת���쳣
#define SUCCESS_PUSHDEVLOGON            0x8030  //��ģʽ�豸ע��ɹ�
#define EXCEPTION_RELOGIN                0x8040    //�û��ص�½
#define RELOGIN_SUCCESS                    0x8041    //�û��ص�½�ɹ�
#define EXCEPTION_PASSIVEDECODE_RECONNNECT  0x8042  //������������
#define EXCEPTION_CLUSTER_CS_ARMFAILED      0x8043  //��Ⱥ�����쳣

#define EXCEPTION_RELOGIN_FAILED                0x8044   //�ص�½ʧ�ܣ�ֹͣ�ص�½
#define EXCEPTION_PREVIEW_RECONNECT_CLOSED      0x8045   //�ر�Ԥ����������
#define EXCEPTION_ALARM_RECONNECT_CLOSED        0x8046   //�رձ�����������
#define EXCEPTION_SERIAL_RECONNECT_CLOSED       0x8047   //�ر�͸��ͨ����������
#define EXCEPTION_PIC_RECONNECT_CLOSED          0x8048   //�رջ�����������
#define EXCEPTION_PASSIVE_DECODE_RECONNECT_CLOSED 0x8049 //�رձ���������������
#define EXCEPTION_PASSIVE_TRANS_RECONNECT_CLOSED 0x804a  //�رձ���ת���������� 
#define EXCEPTION_VIDEO_DOWNLOAD 0x804b // [add] by yangzheng 2019/11/09 ¼�������쳣

/********************Ԥ���ص�����*********************/
#define NET_DVR_SYSHEAD            1    //ϵͳͷ����
#define NET_DVR_STREAMDATA        2    //��Ƶ�����ݣ�����������������Ƶ�ֿ�����Ƶ�����ݣ�
#define NET_DVR_AUDIOSTREAMDATA    3    //��Ƶ������
#define NET_DVR_STD_VIDEODATA    4    //��׼��Ƶ������
#define NET_DVR_STD_AUDIODATA    5    //��׼��Ƶ������
#define NET_DVR_SDP             6   //SDP��Ϣ(Rstp����ʱ��Ч)
#define NET_DVR_CHANGE_FORWARD  10  //�����ı�Ϊ����  
#define NET_DVR_CHANGE_REVERSE  11  //�����ı�Ϊ����
#define NET_DVR_PLAYBACK_ALLFILEEND      12  //�ط��ļ��������
#define NET_DVR_VOD_DRAW_FRAME      13  //�طų�֡����
#define NET_DVR_VOD_DRAW_DATA       14  //�϶�ƽ������
#define NET_DVR_PRIVATE_DATA    112 //˽������,����������Ϣ

//�豸�ͺ�(DVR����)
/* �豸���� */
#define DVR                            1                /*����δ�����dvr���ͷ���DVR*/
#define ATMDVR                        2                /*atm dvr*/
#define DVS                            3                /*DVS*/
#define DEC                            4                /* 6001D */
#define ENC_DEC                        5                /* 6001F */
#define DVR_HC                        6                /*8000HC*/
#define DVR_HT                        7                /*8000HT*/
#define DVR_HF                        8                /*8000HF*/
#define DVR_HS                        9                /* 8000HS DVR(no audio) */
#define DVR_HTS                        10              /* 8016HTS DVR(no audio) */
#define DVR_HB                        11              /* HB DVR(SATA HD) */
#define DVR_HCS                        12              /* 8000HCS DVR */
#define DVS_A                        13              /* ��ATAӲ�̵�DVS */
#define DVR_HC_S                    14              /* 8000HC-S */
#define DVR_HT_S                    15              /* 8000HT-S */
#define DVR_HF_S                    16              /* 8000HF-S */
#define DVR_HS_S                    17              /* 8000HS-S */
#define ATMDVR_S                    18              /* ATM-S */
#define DVR_7000H                    19                /*7000Hϵ��*/
#define DEC_MAT                        20              /*��·������*/
#define DVR_MOBILE                    21                /* mobile DVR */                 
#define DVR_HD_S                    22              /* 8000HD-S */
#define DVR_HD_SL                    23                /* 8000HD-SL */
#define DVR_HC_SL                    24                /* 8000HC-SL */
#define DVR_HS_ST                    25                /* 8000HS_ST */
#define DVS_HW                        26              /* 6000HW */
#define DS630X_D                    27              /* ��·������ */
#define DS640X_HD                    28                /*640X���������*/
#define DS610X_D                    29              /*610X������*/
#define IPCAM                        30                /*IP �����*/
#define MEGA_IPCAM                    31                /*����IP�����*/
#define IPCAM_X62MF                    32                /*862MF���Խ���9000�豸*/
#define ITCCAM                      35              /*���ܸ������������*/
#define IVS_IPCAM                   36              /*���ܷ����������������*/
#define ZOOMCAM                     38              /*һ���*/
#define IPDOME                      40              /*IP �������*/
#define IPDOME_MEGA200              41              /*IP 200��������*/
#define IPDOME_MEGA130              42              /*IP 130��������*/
#define IPDOME_AI                   43              /*IP �������ܿ���*/
#define TII_IPCAM                   44              /*�����ȳ��������*/
#define IPTC_DOME                   45              /*�����ȳ���˫Ŀ���*/
#define DS_2DP_Z                    46              /*����ӥ�ۣ���*/
#define DS_2DP                       47              /*������ӥ�ۣ�С��*/
#define ITS_WMS                      48              /*�������ݹ��������*/
#define IPMOD                        50                /*IP ģ��*/
#define TRAFFIC_YTDOME              51              //��ͨ������̨�������״���٣�
#define TRAFFIC_RDDOME              52              //��ͨ������̨�����״���٣�
#define IDS6501_HF_P                60              // 6501 ���� 
#define IDS6101_HF_A                61              //����ATM
#define IDS6002_HF_B                62          //˫�����٣�DS6002-HF/B
#define IDS6101_HF_B                63              //��Ϊ������DS6101-HF/B DS6101-HF/B_SATA
#define IDS52XX                        64          //���ܷ�����IVMS
#define IDS90XX                        65                // 9000����
#define IDS8104_AHL_S_HX            66          // ��������ʶ�� ATM
#define IDS8104_AHL_S_H             67              // ˽������ʶ�� ATM
#define IDS91XX                        68                // 9100����
#define IIP_CAM_B                   69              // ������ΪIP�����
#define IIP_CAM_F                   70              //��������IP�����
#define DS71XX_H                    71                /* DS71XXH_S */
#define DS72XX_H_S                    72                /* DS72XXH_S */
#define DS73XX_H_S                    73                /* DS73XXH_S */
#define DS72XX_HF_S                 74              //DS72XX_HF_S
#define DS73XX_HFI_S                75              //DS73XX_HFI_S
#define DS76XX_H_S                    76                /* DVR,e.g. DS7604_HI_S */
#define DS76XX_N_S                    77                /* NVR,e.g. DS7604_NI_S */
#define DS_TP3200_EC                   78              /*�������ܼ����*/
#define DS81XX_HS_S                    81                /* DS81XX_HS_S */
#define DS81XX_HL_S                    82                /* DS81XX_HL_S */
#define DS81XX_HC_S                    83                /* DS81XX_HC_S */
#define DS81XX_HD_S                    84                /* DS81XX_HD_S */
#define DS81XX_HE_S                    85                /* DS81XX_HE_S */
#define DS81XX_HF_S                    86                /* DS81XX_HF_S */
#define DS81XX_AH_S                    87                /* DS81XX_AH_S */
#define DS81XX_AHF_S                88                /* DS81XX_AHF_S */
#define DS90XX_HF_S                    90              /*DS90XX_HF_S*/
#define DS91XX_HF_S                    91              /*DS91XX_HF_S*/
#define DS91XX_HD_S                    92              /*91XXHD-S(MD)*/
#define IDS90XX_A                    93                // 9000���� ATM
#define IDS91XX_A                    94                // 9100���� ATM
#define DS95XX_N_S                    95              /*DS95XX_N_S NVR �����κ����*/
#define DS96XX_N_SH                    96              /*DS96XX_N_SH NVR*/
#define DS90XX_HF_SH                97              /*DS90XX_HF_SH */   
#define DS91XX_HF_SH                98              /*DS91XX_HF_SH */
#define DS_B10_XY                   100             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�(X:�����Ƭ����Y:�����Ƭ��)*/
#define DS_6504HF_B10               101             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_6504D_B10                102             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_1832_B10                 103             /*��Ƶ�ۺ�ƽ̨�ڲ������*/
#define DS_6401HFH_B10              104             /*��Ƶ�ۺ�ƽ̨�ڲ����˰�*/
#define DS_65XXHC                    105                //65XXHC DVS
#define DS_65XXHC_S                    106                //65XXHC-SATA DVS
#define DS_65XXHF                    107                //65XXHF DVS
#define DS_65XXHF_S                    108                //65XXHF-SATA DVS
#define DS_6500HF_B                 109             //65 rack DVS
#define IVMS_6200_C                 110             // iVMS-6200(/C)  
#define IVMS_6200_B                 111             // iVMS-6200(/B)
#define DS_72XXHV_ST15                112                //72XXHV_ST  ��˼3515ƽ̨ DVR
#define DS_72XXHV_ST20                113                //72XXHV_ST  ��˼3520ƽ̨ DVR
#define IVMS_6200_T                    114             // IVMS-6200(/T)
#define IVMS_6200_BP                115             // IVMS-6200(/BP)
#define DS_81XXHC_ST                116                //DS_81XXHC_ST
#define DS_81XXHS_ST                117                //DS_81XXHS_ST
#define DS_81XXAH_ST                118                //DS_81XXAH_ST
#define DS_81XXAHF_ST                119                //DS_81XXAHF_ST
#define DS_66XXDVS                    120                //66XX DVS

#define DS_1964_B10                 121             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_B10N04_IN                122             /*��Ƶ�ۺ�ƽ̨�ڲ���������*/
#define DS_B10N04_OUT                123             /*��Ƶ�ۺ�ƽ̨�ڲ��������*/
#define DS_B10N04_INTEL             124             /*��Ƶ�ۺ�ƽ̨�ڲ�����*/
#define DS_6408HFH_B10E_RM          125             //V6����
#define DS_B10N64F1_RTM             126             //V6��������DSP
#define DS_B10N64F1D_RTM            127             //V6������DSP
#define DS_B10_SDS                  128             //��Ƶ�ۺ�ƽ̨���������
#define DS_B10_DS                   129             //��Ƶ�ۺ�ƽ̨�������
#define DS_6401HFH_B10V                130             //VGA���������
#define DS_6504D_B10B               131             /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define DS_6504D_B10H               132             /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define DS_6504D_B10V               133             /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
#define DS_6408HFH_B10S                134             //��Ƶ�ۺ�ƽ̨SDI�Ӱ� 
#define DS_18XX_N                      135             /* �����������*/ 
#define DS_6504HF_B10F_CLASS        136                //��˻�SD
#define DS_18XX_PTZ                    141                /*����������Ʒ*/
#define DS_19AXX                    142                /*ͨ�ñ����������Ʒ*/
#define DS_19BXX                    143                /*���ñ�������*/
#define DS_19CXX                    144                /*�������б�������*/
#define DS_19DXX                    145                /*������ر�������*/    
#define DS_19XX                     146             /*1900ϵ�б�������*/ 
#define DS_19SXX                    147                /*��Ƶ��������*/
#define DS_1HXX                        148                /*CS���Ʒ*/ //������
#define DS_PEAXX                    149                /*һ��ʽ����������Ʒ*/
#define DS_PWXX                     150                 /*���߱���������Ʒ*/
#define DS_PMXX                     151                 /*4G����ģ��*/
#define DS_19DXX_S                  152                /*��Ƶ�����������*/
#define DS_PWAXX                    153                 /* Axiom Hub���߱������� */
#define DS_PHAXX                    154                 /* Axiom Hybrid��ϱ������� */


//2011-11-30
#define    DS_C10H                        161                /*����������*/
#define DS_C10N_BI                    162                //BNC������
#define DS_C10N_DI                    163                //rbg������
#define DS_C10N_SI                    164                //����������
#define DS_C10N_DO                    165                //��ʾ������
#define DS_C10N_SERVER                166                //�ֲ�ʽ������


#define IDS_8104_AHFL_S_H           171             // 8104ATM 
#define IDS_65XX_HF_A               172             // 65 ATM
#define IDS90XX_HF_RH               173             // 9000 ����RH
#define IDS91XX_HF_RH               174             // 9100 ����RH�豸
#define IDS_65XX_HF_B               175             // 65 ��Ϊ����
#define IDS_65XX_HF_P               176             // 65 ����ʶ��
#define IVMS_6200_F                 177             // IVMS-6200(/F)
#define IVMS_6200_A                 178             //iVMS-6200(/A)
#define IVMS_6200_F_S                 179             // IVMS-6200(/F_S)���������������

#define DS90XX_HF_RH                181             // 9000 RH    648
#define DS91XX_HF_RH                182             // 9100 RH�豸 648
#define DS78XX_S                    183             // 78ϵ���豸 6446
#define DS81XXHW_S                    185                // 81 Resolution 960 KY2011
#define DS81XXHW_ST                    186             // DS81XXHW_ST  KY2011
#define DS91XXHW_ST                    187             // DS91XXHW_ST  KY2011
#define DS91XX_ST                    188             // DS91XX_ST netra
#define DS81XX_ST                    189             // DS81XX_ST netra
#define DS81XXHX_ST                    190             // DS81XXHDI_ST,DS81XXHE_ST ky2012
#define DS73XXHX_ST                    191             // DS73XXHI_ST ky2012
#define DS81XX_SH                   192             // ��Ѷ81SH,81SHF
#define DS81XX_SN                   193             // ��Ѷ81SNL

#define DS96XXN_ST                  194             //NVR:DS96xxN_ST
#define DS86XXN_ST                  195             //NVR:DS86xxN_ST
#define DS80XXHF_ST                 196             //DVR:DS80xxHF_ST
#define DS90XXHF_ST                 197             //DVR:DS90xxHF_ST
#define DS76XXN_ST                  198             //NVR:DS76xxN_ST

#define DS_9664N_RX                 199         //NVR:DS_9664N_RX
#define ENCODER_SERVER                200            // ���뿨������
#define DECODER_SERVER              201         // ���뿨������
#define PCNVR_SERVER                202         // PCNVR�洢������
#define CVR_SERVER                  203         // ��ŵCVR�������Լ���������ΪDVR_S-1
#define DS_91XXHFH_ST                204         // 91ϵ��HD-SDI����DVR
#define DS_66XXHFH                    205         // 66���������
#define    TRAFFIC_TS_SERVER            210           //�ն˷�����
#define    TRAFFIC_VAR                    211           //��Ƶ������¼��
#define IPCALL                      212        //IP���ӶԽ��ֻ�
#define SAN_SERVER                  213         //��CVR_SERVER��ͬ�ĳ���ֻ��ģʽ��ͬ

#define DS_B11_M_CLASS                 301             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�*/
#define DS_B12_M_CLASS                  302             /*��Ƶ�ۺ�ƽ̨�豸�ͺ�*/
#define DS_6504HF_B11_CLASS         303             /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define DS_6504HF_B12_CLASS         304              /*��Ƶ�ۺ�ƽ̨�ڲ�������*/
#define  DS_6401HFH_B11V_CLASS         305     //VGA����
#define  DS_6401HFH_B12V_CLASS         306     //VGA����
#define  DS_6408HFH_B11S_CLASS         307     //SDI
#define  DS_6408HFH_B12S_CLASS      308     //SDI
#define  DS_6504D_B11H_CLASS        309   /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B11B_CLASS        310    /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B12B_CLASS        311       /*��Ƶ�ۺ�ƽ̨�ڲ����������*/
#define  DS_6504D_B11V_CLASS        312      /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
#define  DS_6504D_B12V_CLASS        313     /*��Ƶ�ۺ�ƽ̨�ڲ�VGA������*/
//B10����
#define  DS_6401HFH_B10R_CLASS         314     //B10 RGB����
#define  DS_6401HFH_B10D_CLASS         315     //B10 DVI����
#define  DS_6401HFH_B10H_CLASS         316     //B10 HDMI����
//B11����
#define  DS_6401HFH_B11R_CLASS         317     //B11 RGB����
#define  DS_6401HFH_B11D_CLASS         318     //B11 DVI����
#define  DS_6401HFH_B11H_CLASS         319     //B11 HDMI����
//B12����
#define  DS_6401HFH_B12R_CLASS         320     //B12 RGB����
#define  DS_6401HFH_B12D_CLASS         321     //B12 DVI����
#define  DS_6401HFH_B12H_CLASS         322     //B12 HDMI����
#define  DS_65XXD_B10Ex_CLASS        323     //netra������� 

//B10 V2.1����
#define  DS_6516HW_B10_CLASS        324     //netra���߱���
#define  DS_6401HFH_B10F_RX_CLASS   326        //�����˻����루֧��1/2·��˻����룩
#define  DS_6502HW_B10F_RX_CLASS    327        //960H��˻����루֧��1/4/8·��˻����룩
//2012-5-16����
#define  DS_6504D_B11Ex_CLASS        328     //netra�������
#define  DS_6504D_B12Ex_CLASS        329     //netra�������
#define  DS_6512_B11_CLASS            330     //netra���߱���
#define  DS_6512_B12_CLASS            331     //netra���߱���
#define  DS_6504D_B10H_CLASS        332     //��Ƶ�ۺ�ƽ̨�ڲ����������

#define  DS_65XXT_B10_CLASS         333     //��Ƶ�ۺ�ƽ̨ת����ϵͳ
#define  DS_65XXD_B10_CLASS         335     //��Ƶ�ۺ�ƽ̨���ܽ����
#define  DS_IVMSE_B10X_CLASS        336     //X86��������ϵͳ
#define  DS_6532D_B10ES_CLASS        337     //��ǿ�ͽ����_SDI(B10)
#define  DS_6508HFH_B10ES_CLASS        338     //SDI���������ϵͳ
#define  DS_82NCG_CLASS                340     //���������е���ϵͳ
#define  DS_82VAG_CLASS                341     //���������е���ϵͳ 
#define  DS_1802XXF_B10_CLASS       342     //��ڽ�����ϵͳ
#define  iDS_6504_B10EVAC_CLASS     343     //������ϵͳ
#define  iDS_6504_B10EDEC_CLASS     344     //������ϵͳ
#define  DS_6402HFH_B10EV_CLASS     345     //netra����(VGA)
#define  DS_6402HFH_B10ED_CLASS     346     //netra����(DVI)
#define  DS_6402HFH_B10EH_CLASS     347     //netra����(HDMI)
#define  DS_6404HFH_B10T_RX_CLASS   348     //���˽������
#define  DS_6504D_AIO_CLASS         349        //netra�������
#define  DS_IVMST_B10_CLASS            350        //X86ת����ϵͳ
#define  DS_6402_AIO_CLASS          351     //netra����
#define  DS_iVMSE_AIO_CLASS         352     //x86��������ϵͳ
#define  DS_AIO_M_CLASS             353     //һ���


#define  DS_6508HF_B10E_CLASS        355        //BNC���������ϵͳ
#define  DS_6404HFH_B10ES_CLASS        356        //SDI���������ϵͳ
#define  DS_6402HFH_B10ER_CLASS        358        //RGB���������ϵͳ
#define  DS_6404HFH_B10T_RM_CLASS    361        //�������������ϵͳ
#define  DS_6516D_B10EB_CLASS        362        //BNC���������ϵͳ
#define  DS_6516D_B10ES_CLASS        363        //SDI���������ϵͳ

//DVI/HDMI/VGA���Խ��빫��һ������
#define  DS_6508D_B10FH_CLASS        364
#define  DS_6508D_B10FD_CLASS        364
#define  DS_6508D_B10FV_CLASS        364

#define  DS_6508_B11E_CLASS            365        //BNC���������ϵͳ
#define  DS_6402_B11ES_CLASS        366        //SDI���������ϵͳ
#define  DS_6402_B11EV_CLASS        367        //VGA���������ϵͳ
#define  DS_6402_B11ER_CLASS        368        //RGB���������ϵͳ
#define  DS_6402_B11ED_CLASS        369        //DVI���������ϵͳ
#define  DS_6402_B11EH_CLASS        370        //HDMI���������ϵͳ
#define  DS_6516D_B11EB_CLASS        371        //BNC���������ϵͳ
#define  DS_6516D_B11ES_CLASS        372        //SDI���������ϵͳ

#define  DS_6508_B12E_CLASS         373     //BNC���������ϵͳ
#define     DS_6402_B12ES_CLASS        375        //SDI���������ϵͳ
#define  DS_6402_B12EV_CLASS        376        //VGA���������ϵͳ
#define  DS_6402_B12ER_CLASS        377        //RGB���������ϵͳ
#define  DS_6402_B12ED_CLASS        378        //DVI���������ϵͳ
#define  DS_6402_B12EH_CLASS        379        //HDMI���������ϵͳ
#define  DS_6516D_B12EB_CLASS        380        //BNC���������ϵͳ

#define  DS_iVMSE_AIO_8100x_CLASS   381     //������ҵһ���X86��ϵͳ
#define  DS_iVMSE_AIO_87x_CLASS     382     //����¥��һ���X86��ϵͳ
#define  DS_6532D_B11ES_CLASS        384        //��ǿ�ͽ����_SDI(B11)
#define  DS_6532D_B12ES_CLASS        385        //��ǿ�ͽ����_SDI(B12)
//B20����
#define  DS_B20_MSU_NP              400     //B20���ذ�
#define  DS_6416HFH_B20S            401     //SDI�������
#define  DS_6416HFH_B20_RM          402     //��������������
#define  DS_6564D_B20D              403     //DVI����
#define  DS_6564D_B20H              404     //HDMI����
#define  DS_6564D_B20V              405     //VGA����
#define  DS_B20_6516D_DEV_CLASS     406     //B20������ϵͳ
#define  DS_6408HFH_B20V            407     //VGA�����
#define  DS_MMC_B20_CLASS           408     //B20����
#define  DS_CARD_CHIP_B20_CLASS     409     //B20�����Ӱ�
#define  DS_6564D_B20B_DEV_CLASS    410     //BNC������ϵͳ
#define  DS_6564D_B20S_DEV_CLASS    411     //SDI������ϵͳ
#define  DS_6532HF_B20B_DEV_CLASS   412     //BNC������ϵͳ
#define  DS_6408HFH_B20D_DEV_CLASS  413     //DVI������ϵͳ
#define  DS_6408HFH_B20H_DEV_CLASS  414     //HDMI������ϵͳ
#define  DS_IVMSE_B20_CLASS            415     //X86��������ϵͳ
#define  DS_6402HFH_B20Y_DEV_CLASS  416     //YUV������ϵͳ
#define  DS_6508HW_B20_DEV_CLASS    417     //HW������ϵͳ
#define  DS_B20N128Fx_B20_DEV_CLASS 418     //DS_B20N128Fx_M������
#define  DS_AIO_MCU_NP_DEV_CLASS    419     //IO���ذ�
#define  DS_6402_AIO_EV_DEV_CLASS   420     //VGA����
#define  DS_6508D_AIO_EV_DEV_CLASS  421     //VGA����
#define  DS_6508D_AIO_ED_DEV_CLASS  422     //DVI����
#define  DS_6508D_AIO_EH_DEV_CLASS  423     //HDMI����
#define  DS_6508HD_B20F_DEV_CLASS    424     //��Ƶ��ǿ��
#define  DS_6402HFH_B20ES_DEV_CLASS 425     //3G SID����
#define  DS_6532D_B20_DEV_CLASS     426     //B20������ϵͳ            
#define  DS_IVMST_B20_DEV_CLASS     427     //X86��������ϵͳ
#define  DS_6416HFH_B20DD_DEV_CLASS 428     //DVI˫��·
#define  DS_6441VS_B20_DEV_CLASS    429        //���ƴ������
#define  DS_6404HFH_B20T_CLASS         431        //TVI
#define  DS_FS22_B20_DEV_CLASS         432        //��������ϵͳ
#define  DS_IVMSE_B20UH_DEV_CLASS   433     //������X86����
#define  IDS_6524J_B20_DEV_CLASS    434
#define  IDS_6532B_B20_DEV_CLASS    435
#define DS_6404HFH_B20Fx_DEV_CLASS  436        //��˻�������ϵͳ
#define DS_N128x_B20Fy_CLASS        437     //������ϵͳ
#define DS_181600F_B20_CLASS        438     //���������ϵͳ
#define  DS_6904UD_B20H_CLASS       439     //�����������ϵͳ

#define DS_B21_MCU_NP_CLASS         440     //B21����
#define DS_B21_S10_x_CLASS          441     //B21���� x = A/S/D
#define DS_6402HFH_B21D_CLASS       442     //B21������ϵͳ
#define DS_6508HD_B21D_CLASS        443     //B21������ϵͳ
#define DS_iVMSE_B21HW_CLASS        444     //B21 X86��ϵͳ

#define  DS_C10S                    501     //C10S ����ʽ����������

#define  DS_C10N_SDI                551        //SDI������
#define  DS_C10N_BIW                552        //8·BNC������
#define  DS_C10N_DON                553        //��ʾ������
#define  DS_C10N_TVI                554     //TVI�����
#define  DS_C10N_DI2                555     //DVI 2·�����
#define  DS_C10N_AUDIO_OUT          556     //DVI��HDMI��VGA��������Ƶ
#define  DS_C10N_AUDIO_IN           557     //DVI��HDMI��VGA��������Ƶ

//��������汾�ķֲ�ʽ����������
#define  DS_C20N                    570     //�ֲ�ʽ����������
#define  DS_C20N_BNC                571     //BNC�����豸
#define  DS_C20N_DVI                572     //DVI�����豸
#define  DS_C20N_DP                 573     //DP�����豸
#define  DS_C20N_OUT                574     //����豸

//Ӳ�������汾�ķֲ�ʽ����������
#define DS_C20N_VWMS                5351    //C20N������
#define DS_C20N_DI2                 5352    //��·DVI�����豸
#define DS_C20N_DO2                 5353    //��·DVI����豸
#define DS_C20N_UHDI                5354    //DP/HDMI 1·4K�����������豸
#define DS_C20N_YI2                 5355    //��·YPbPr�����

#define DS_C12N_VWMS                5356    //C12N������
#define DS_C12N_DO                  5357    //1·DVI���
#define DS_C12N_HOE                 5358    //1·HDMI 4K���

#define DS_C20N_HI2             5359 // HDMI����ڵ�(2·)
#define DS_C20N_VI2             5360 //VGA����ڵ�(2·)
#define DS_C20N_SI2             5361 //SDI����ڵ�(2·)
#define DS_C20N_HO2             5362 //HDMI����ڵ�(2·)
#define DS_C20N_S24G            5363 //C20Nר��ǧ�׽�����(24·)
#define DS_C20N_S24X            5364 //C20Nר�����׽�����(24·)
#define DS_C12A_0104H           5365 //����ƴ�ӿ�����

//ȫϢ��ʾ�豸
#define DS_D1HXX                    5591    //ȫϢ��ʾ�豸

//���ߴ����豸
#define ELEVATO_BRIDGE  5751  //���ߵ�������
#define DS_3WF01S_5NG_M  5752  //5.8G����1�������߹�����
#define DS_3WF0EC_2N_D  5753  //2.4G����500������
#define DS_3WF0EC_5ACT  5754  //5.8G 11ac��������
#define DS_3WF03S_5AC    5755   //5.8G 3���ﾭ��������
#define DS_3WF0ES_5AC_H            5756    //5.8G����500�׸ߴ�͸����
#define DS_3WF05S_5AC_H            5765    //5.8G 5KMǧ�����ڲ�������
#define DS_3WSXXX      5766     //����·����ϵ�У�����AC��������
#define DS_3WAXXX      5767     //APϵ��
#define DS_3WRXXX      5768     //��ͨ����·����ϵ��
#define DS_3WMRXXX     5769     //MESH·����ϵ��


//�����豸
#define DS_19M00_MN                    601     //����������������ģ�� 
#define DS_KH8302_A                 602  //���ڻ�
#define DS_KD8101_2                 603  //�ſڻ�
#define DS_KM8301                   604  //�����
#define DS_KVXXXX_XX                605  //�����ſڻ�
#define DS_LHPM1D_C                 606  //�Ƶ���
#define DS_KAM03                      607 //������ת��ģ��

#define DS64XXHD_T                    701        //64-T���������
#define DS_65XXD                    703     //65���ܽ�����
#define DS63XXD_T                    704        //63-T���������
#define SCE_SERVER                  705     //ץ��������
#define DS_64XXHD_S                 706     //64XXHD-S���������
#define DS_68XXT                    707     //�๦������Ƶת����
#define DS_65XXD_T                  708     //65D-T���ܽ�����
#define DS_65XXHD_T                 709     //65HD-T���ܽ�����
#define DS_69XXUD                   710     //69XXUD�����������
#define DS_65XXUD                   711     //65XXUD������
#define DS_65XXUD_L                 712     //65XXUD_L������
#define DS_65XXUD_T                 713     //65XXUD_T������
#define DS_69XXHD                   5001    //69XXHD������

#define DS_D20XX                    750     //LCD��Ļ ���뿨
//SDI����
#define DS_C50S                     751     //SDI����
#define DS_D50XX                    752     //LCD��Ļ ���뿨

#define DS_D40                      760     //LED�����Ϳ�

#define DS_65VMXX                   770     //��Ƶ���������
#define DS_65VTXX                   771     //��Ƶ�����ն�
#define DS_65VTA                    772     //��Ƶ����һ��ʽ�ն�
#define DS_65VT_RX                  773     //������ѧ�ն�
#define DS_65VM_MCU_NP              774     //������MCU
#define DS_65VT0010                 5571    //һ��ʽ�ն�
#define DS_65VM_MCU                 5572    //���ܶ�MCU���ذ�
#define DS_65VM_MPC                 5573    //���ܶ�MCUý����Դ��
#define DS_65VT2XXYR_SF             5574    //˾����Ѷ�ն�
#define DS_65VT0XXY                 5575    //��Ƶ������ն�
#define DS_65VT0010Z                5576    //����һ��ʽ�ն�
#define DS_65VT0050Z                5577    //���ܷ���ʽ�ն�
#define DS_65VS0XXXS                5878    //opensips�������豸
#define DS_65VS0XXXM                5579    //��Ƶ������ƽ̨�豸
#define DS_65VM00XX_X               5580    //��Ƶ����X86ϵͳMCU
#define DS_65VA800_BOX              5581    //��Ƶ������˷�


#define DS_CS_SERVER                800     //������������
#define DS_68GAP_MCU                831     //��Ƶ��բ
#define DS_K260X                    850     //�Ž�����
#define DS_K1TXXX                   851     //ָ��һ���
#define DS_K280X                    852     //�������Ž�����
#define DS_K1T80X                   854     //�������Ž�һ���
#define RAC_6X00                    856     //����ָ���Ž�һ���
#define DS_K2602_AX                 857     //��Աͨ������
#define DS_K1T803F                  858     //������ָ���Ž���Ʒ
#define DS_K2700                    859     //�ֲ�ʽ����ܹ��Ž�����
#define DS_K270X                    860     //�ֲ�ʽ����ܹ��͵ؿ�����
#define DS_K1T500S                  861     //�����Ž�һ���
#define DS_K1A801F                  862     //������ָ���Ž���Ʒ
#define DS_K1T600X                  863     //����ʶ���Ž�һ���
#define DS_K22X                     864     //�ݿ���������
#define DS_K2M0016AX                865     //�ݿطֿ�����
#define DS_K2602S_AX                867     //��Աͨ����Ʒ
#define DS_K560XX                   870     //��ʽ/̨ʽ�������ʶ���ն�
#define DS_K260X_E                  873     //�Ͷ��Ž�����
#define DS_K5603X                   874     //̨ʽ/�ڹ�ʽǶ��ʽ��֤�豸
#define DS_K3M200X                  875     //Ȩ�޿�����
#define DS_K3M100X                  879     //ͨ��������
#define DS_K1T8101XT                881     //����������ʶ���Ž�һ���
#define DS_K1T8101XX                882     //����������ʶ���Ž�һ���
#define DS_K5604                    883     //5604��֤�豸
#define DS_K1T607XXXX               884     //�ж������Ž�һ���DS_K1T607��M/MF/E/EF/MG/MFG?MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW��
#define DS_K1A850X                  885     //�Ͷ˾���ָ�ƿ��ڻ�
#define DS_K1T800X                  886     //�Ͷ˾���ָ���Ž�һ���
#define DS_K1T610XXXX               887     //�ж������Ž�һ���DS_K1T610��M/MF/E/EF/MG/MFG?MW/MFW/TM/TMF/TE/TEF/TMG/TMFG/TMW/TMFW��
#define DS_K1T8115X                 888     //DS-K1T8115��DS-K1T8115M��DS-K1T8115M-Z ����������ʶ��һ���
#define DS_K1T815LC_M               889     //����������ʶ��һ���
#define DS_K1T606M_Z                890     //����������ʶ��һ���
#define DS_K5607_XXX                891     //K5607�ᱡ��ͨ���������
#define DS_K1T950MX                 893     //����������ָ���Ž�һ���
#define DS_K1T331XX                 894     //�Ͷ������Ž�����һ���
#define DS_K1T671T                  895     //�����Ž�һ���
#define DS_K1T671                   896     //�����Ž�һ���
#define DS_K5671                    897     //�ᱡ��ͨ���������
#define DS_K1T640                   898     //4.3�������Ž�һ���
#define DS_K1A802A                  899     //������ָ�ƿ��ڻ�

#define DS_6800M                    900     //68M������
#define DS_68NTH                    901     //��Ϣ��������
#define DS_D60S                     902     //��Ϣ����������
#define DS_D60W                     903     //��Ϣ����Windows�ն�
#define DS_D10                      931     //��Ͷ��ʾ�豸
#define DS_3K0X_NM                  951     //�����շ���
#define DS_3E2328                   952     //���׽�����
#define DS_3E1528                   953     //ǧ�׽�����
#define SCREEN_LINK_SERVER          971     //��Ļ������
#define DS_D51OPSXX                 972     //OPS���Ժ�
//һ�廯��̨
#define IP_PTSYS_MEGA200            1001   //IP 200��һ�廯��̨
#define IPCAM_FISHEYE               1002   //���������
#define IPCAM_FISHEYE_E             1003   //���������������

//68xxϵ��˫Ŀ3D���
#define IPCAM_BINOCULAR             1004   //˫Ŀ�����

#define IPCAM_365                    1010    //֧��365��ƽ̨��IPC CAM
#define IPCAM_R0                    1011    //֧��A5S��ƽ̨��IPC CAM
#define IPCAM_R1                    1012    //֧��385��ƽ̨��IPC CAM
#define IPCAM_R2                    1013    //֧��R2��ƽ̨��IPC CAM
#define IPCAM_R3                    1014    //֧��8127��ƽ̨��IPC CAM
#define IPCAM_R4                    1015    //֧��S2��ƽ̨��IPC CAM

#define IPDOME_365                    1110    //֧��365��ƽ̨��IPD CAM
#define IPDOME_R0                    1111    //֧��A5S��ƽ̨��IPD CAM
#define IPDOME_R1                    1112    //֧��385��ƽ̨��IPD CAM
#define IPDOME_R2                    1113    //֧��R2��ƽ̨��IPD CAM
#define IPDOME_R3                    1114    //֧��8127��ƽ̨��IPD CAM
#define IPDOME_R4                    1115    //֧��S2��ƽ̨��IPD CAM
#define ITCCAM_R3                    1211    //֧��8127��ƽ̨��ITCCAM

//���˻�ҵ���豸��1300~1350��
#define UAV_S                       1300    //���˻���վ�豸 ��Ummanned Aerial Vehicle �C Station��

//�����豸���� 2013-11-19
#define TRAFFIC_ECT                    1400  //ECT�豸����
#define TRAFFIC_PARKING_SERVER        1401  //ͣ����������
#define TRAFFIC_TME                    1402  //����ڿ��ƻ�
// DVR
#define DS90XXHW_ST                    2001    // DS90XXHW_ST���DVR
#define DS72XXHX_SH                 2002    // DS-72xxHV_SH, DS-72xxHF-SH 
#define DS_92XX_HF_ST                2003    // DS-92XX-HF-ST 
#define DS_91XX_HF_XT                2004    // 9100DVR_HF_XT
#define DS_90XX_HF_XT               2005    // 9000DVR_HF_XT 
#define DS_73XXHX_SH                2006    // 7300DVR_HX_SH  
#define DS_72XXHFH_ST                2007    // 7200DVR_HFH_ST
//DS_67ϵ��

#define DS_67XXHF_SATA              2008 // DS-67XXHF-SATA
#define DS_67XXHW                   2009 // DS-67XXHW 
#define DS_67XXHW_SATA              2010 // DS-67XXHW-SATA
#define DS_67XXHF                   2011 // DS-67XXHF

//Netra2.3
#define DS_72XXHF_SV                2012  // DS-72xxHF-SV 
#define DS_72XXHW_SV                2013   // DS-72xxHW-SV

#define DS_81XXHX_SH                2014   // 8100DVR_HX_SH

#define DS_71XXHX_SL                2015    //С��DVR

#define DS_76XXH_ST                    2016    //DS_76XXH_ST


#define DS_73XXHFH_ST               2017   //73HFHϵ��
#define DS_81XXHFH_ST               2018   //81HFHϵ�� ST

#define DS_72XXHFH_SL                2019    //hi3521 
#define DS_FDXXCGA_FLT                2020    //2��λATM

#define IDS_91XX_HF_ST_A            2100    //iDS-9100HF-ST/A
#define IDS_91XX_HF_ST_B            2101    //iDS-9100HF-ST/B
#define IDS_90XX_HF_ST_A            2102    //iDS-9000HF-ST/A
#define IDS_90XX_HF_ST_B            2103    //iDS-9000HF-ST/B
#define IDS_81XX_HF_ST_A            2104    //iDS-8100HF-ST/A
#define IDS_81XX_HF_ST_B            2105    //iDS-8100HF-ST/B
#define IDS_80XX_HF_ST_A            2106    //iDS-8000HF-ST/A
#define IDS_80XX_HF_ST_B            2107    //iDS-8000HF-ST/B
#define IDS_8104_AHFL_ST            2108    //���ܻ��ATM��
#define IDS_2CD6812F_C              2109    //��ֱ˫Ŀ���


// NVR
#define DS_77XXN_ST                    2201    //  NVR DS-77XXHF-ST
#define DS_95XX_N_ST                2202    //  95XXN_ST NVR          
#define DS_85XX_N_ST                2203    //  85XXN_ST NVR
#define DS_96XX_N_XT                2204    // 9600NVR_N_XT
#define DS_76XX_N_SE                2205    // 7600NVR_N_SE

//������Ѷ��
#define DS_86XXSN_SX                2206    // 8608NVR_SX������4������DS-8608SNL-SP��DS-8608SNL-ST��DS-8608SN-SP��DS-8608SN-ST��L��ʾ��LCD��P��POE

//#define DS_96XX_N_RX                2207  //DS-96XX-N-RX
#define DS_71XXN_SL                    2208  //DS-71XXN-SL ���ò�Ʒ
#define CS_N1_1XX                    2209  //CS_N1_1XX��������ҵ������

#define DS_71XXN_SN                    2210    //71XX_N_SN  ���������ò�Ʒ 
#define CS_N1_2XX                    2211    //N1_2XX        ������ҵ������
#define DS_76XX_N_SHT                2212    //76XX_N_SHT  ��˻��߲�Ʒ
#define DS_96XXX_N_E                2213    //��������NVR(256) 

#define    DS_76XXN_EX                    2214 /* 76 78ϵ��NVR��ע������ 4 8 16·��E1һ��λ�� 8 16 32· E2����λ�� /N /P�豸*/
#define DS_77XXN_E4                    2215/* 77ϵ��NVR��   ע������8 16 32·�� /N /P�豸*/
#define DS_86XXN_E8                    2216/* 86ϵ��NVR��   ע������8 16 32·�� /N /P�豸*/
#define DS_9616N_H8                 2217   //DS_9616N_H8
#define DS_72XXHX_EX_GXY            2218   //��ʾ72ϵ������DVR��Ʒ������72�����xx��ʾͨ������H���XĿǰ����HW,Ϊ�˺�����չ������E�����X��ʾ������λ����G XY��ʾ������������
#define DS_76XXN_EX_GXY             2219   //��ʾ��76ϵ������NVR��Ʒ������76�����xx��ʾͨ������E�����X��ʾ������λ����G XY��ʾ������������
#define DS_72XXHXH_SH_21            2220   //  72XXHXH_SH_21
#define DS_72XXHXH_SH_31            2221  //  72XXHXH_SH_31
#define DS_73XXHXH_SH_31            2222  // 73XXHXH_SH_31
#define DS_81XXHXH_SH_31            2223  //  81XXHXH_SH_31
#define DS_71XXHXH_SH_21            2224  // 71XXHXH_SH_21
#define DS_71XXHXH_SH_31            2225  // 71XXHXH_SH_31
#define DS_NBXX_N_E1_X              2226  //��Яʽ����
#define DS_96XXN_FX                 2230
#define DS_86XXN_FX                 2231
#define DS_96XXXN_HX                2232  //96ϵ�и������豸


#define DS_86XXN_I                    2233    //DS_86XXN_I
#define DS_77XX_N_I                    2234    //DS_77XX_N_I
#define DS_76XX_N_I                    2235    //DS_76XX_N_I
#define DS_78XX_N_I                    2236    //DS_78XX_N_I
#define DS_96XXXN_IX                2237    //DS-96XXX_N_I��DS-96128N-I16��DS-96128N-I24��DS-96256N-I16��DS-96256N-I24��

#define DS_90XXHXH_XT               2238    //DS_90XXHXH_XT��DS-9016HQH-XT��

//PCNVR
#define PCNVR_IVMS_4200             2301    // PCNVR_IVMS_4200


//���ܷ�����
#define IVMS_6200_TP                2401   //IVMS-6200 ��ͨ�յ�������
#define IVMS_6200_TF                2402   //IVMS-6200 ��ͨȡ֤������
#define IVMS_6200_D                 2403   //iVMS-6200(/D)
#define IDS_81XXAHW_ST              2405   //iDS-81xxAHW-ST
#define IDS_81XXAHW_SP              2406   //iDS-81xxAHW-SP
#define IDS_81XXAHWL_ST             2407   //iDS-81xxAHWL-ST 
#define IDS_81XXAHWL_SP             2408   //iDS-81xxAHWL-SP
#define IDS_9616N_H8                2409   //iDS_9616N_H8
#define IVMS_6200_SMD               2500   //IVMS_6200_SMD
//HISI3531ƽ̨���ATM DVR�� ����L��ʾ��Һ������P��ʾ��poe
#define DS_81XXAHW_ST                2501
#define DS_81XXAHW_SP                2502
#define DS_81XXAHWL_ST                2503
#define DS_81XXAHWL_SP                2504

//TVI ATM
#define DS_81XXAHGH_E4                2601    //DS_81XXAHGH_E4

/************************************************************************/
/* ��������ʾ��Ʒ�豸����start���������ϵ��豸���ͣ�                    */
/************************************************************************/

/** B20ϵ�У�4001-4900�� */

#define DS_6904UD_AIOE_H_CLASS      4002    //B20һ���
#define DS_6402HFH_B21B_CLASS       4005    //B21 ����
#define DS_6902UD_B21H_CLASS        4006    //B21 HDMI����
#define DS_6902UD_B21D_CLASS        4007    //B21 DVI����
#define DS_6902UD_B21V_CLASS        4008    //B21 VGA����
#define DS_6904UD_B20D_CLASS        4010    //B20 DVI����
#define DS_6904UD_B20V_CLASS        4011    //B20 VGA����

//B21һ����豸�ͺ�
#define DS_AIOH_MCU_NP              4042    //���ذ�
#define DS_6404HFH_AIOH_D           4043    //4·DVI�����
#define DS_6908UD_AIOH_D            4044    //4·DVI�����
#define DS_6908UD_AIOH_H            4045    //4·HDMI�����

//����һ����豸�ͺ�
#define DS_69XXUD_B                 4046    //����һ���
#define DS_6404HFH_I                4047    //4·DVI�����
#define DS_6904UD_O                 4048    //8·HDMI�����


//����ʽƴ����
#define DS_C12L_0204H                4060   //������С��ƴ����

//ת����    5401 - 5450  ��50��
#define DS_68VTG          5401 //�ۺ�ת������

//��Ƶ��ģ����Y10ϵ�У�
#define DS_Y10_MCU                  5771    //���ذ�
#define DS_Y10_SW1                  5772    //������
#define DS_6516UD_Y10D              5773    //8·DVI��ʾ�ӿڽ����
#define DS_6532UD_Y10D              5774    //16·DVI��ʾ�ӿڽ����
#define DS_6E2724_Y10               5775    //24�����׽ӿڱ�������
#define DS_68SAA_AA_Y10             5776    //˫·2620���ڴ�32Gҵ���
#define DS_68SBA_AA_Y10             5777    //˫·2630���ڴ�32Gҵ���
#define DS_68SCA_AA_Y10             5778    //˫·2650���ڴ�32Gҵ���
#define DS_68GPU_A1_Y10             5779    //P4�Կ���
#define DS_CPU_SERVER               5780    //CPU�����
#define DS_GPU_SERVER               5781    //GPU�����
#define DS_BIGDATA_SERVER           5782    //�����ݷ����


//����һ���ϵ��
#define DS_B80_MCU                 5821//���ذ�
#define DS_B80_SW                  5822//������
#define DS_B80_SR_01               5823//�����
#define DS_B80_AI04                5824//���ܷ����壬֧��4·��������
#define DS_B80_ST                  5825//�洢�壬֧��4��2.5��2TӲ��
#define DS_B80_D04                 5826//���ݲɼ�ҵ���
#define DS_B80_BNC08               5827//��������
#define DS_B80_SDI08               5828//��������
#define DS_B80_VP                  5829//ת��/�����
#define DS_B80_VO02                5830//��Ƶ�����


//������
#define DS_3LGCX                   5841//ͨ����������
#define DS_3LGRX                   5842//LoRa����
#define DS_3LGT4                   5843    //���������豸
#define DS_3LGT40_N 			   5844    //NB-IoT��������
#define DS_3LGS_I                  5845    //��������


//������
#define DS_3E11XX     5681    //���׽�����
#define DS_3E13XX     5682    //ǧ�����н�����
#define DS_3E15XX     5683    //ǧ�׽�����
#define DS_3E11XXP     5684    //����POE������
#define DS_3E13XXP     5685    //ǧ������POE������
#define DS_3E15XXP     5686    //ǧ��POE������
#define DS_3E1520U     5687    //USB����
#define DS_3EODM_H     5688     //����������
#define DS_3EODM_W     5689     //��ï������
#define DS_3T1XXX      5690     //DS-3T1XXXϵ�н�����

//�����շ���
#define DS_3D01R_NM     5691    //�շ������տ�
#define DS_3D01T_NM     5692    //�շ������ͻ�
#define DS_3K02_RNM     5693    //�շ������ܿ�


/************************************************************************/
/* ��������ʾ��Ʒ�豸����end���������ϵ��豸���ͣ�                      */
/************************************************************************/

#define IDS_90XX_HXH_XX_S            6001    //��������DVR��Ʒ
#define IDS_90XX_HXH_XX_FA           6002    //��������DVR��Ʒ

#define DS_81XX_SHXL_K4               6101    //KY2017ƽ̨��Ѷ��DS-8104SHFH��L��-K4/4P

#define DS_8116THFHL_F4               6201    //��׼ͥ������DS-8116THFHL-F4

#define DS_81XXAHQ_E4                 6301    //DS_81XXAHQ_E4(TVI ATM)
#define IDS_81XXAHQ_E4                6302    //IDS_81XXAHQ_E4(����TVI ATM)

#define IDS_86XX_NX_A               7501    //��������ATM NVR(iDS-8632NX-I8/A)
#define IDS_96XX_NX_S               7502    //���峬������NVR
#define IDS_96XX_NX_V               7503    //���Լ���վNVR
#define IDS_96XX_NX_FA              7504    //������������NVR iDS-9632NX-I8/FA
#define IDS_86XX_NX_IX_B            7505    //86ϵ�а�ȫñ���NVR��Ʒ
#define IDS_67XX_NX_S_X             7506    //�����������ܰ����ƷNVR(IDS_67XX_NX/S_X)
#define NP_ST204_X_                  7507    //�ڶ������ܰ�������ǣ�NP_ST204_S:NP_ST204_D:NP_ST204_D_4G��


#define IDS_ECDXX_HE                8001//ѧ����Ŀ���
#define IDS_ECDXX_HT                8002//��ʦ��Ŀ���

#define IDS_ECDXX_E                 8101//4K����

#define IDS_EPTXX_HF                8201//��������ץ�Ļ�


#define DS_2CD69XXX_I               8351    //3200Wȫ��ƴ��IPC�ͺ�
#define DS_TRIXX                    8471    //����Ƶ�̶�ʽ������DS_TRI900

#define DS_K1F600_D6EXX                  10501   //�๦�ܲɼ���
#define DS_K1T341                   10502   //���������Ž�
#define DS_K1T641XXX                10503   //�ж�ͨ�������Ž�
#define DS_K1T642XXX                10504   //�ж�ͨ�������Ž�
#define DS_K1T601                   10505   //�Ƶ�������Ʒ
#define DS_K1T672XXX                10506   //����7�糬���������Ž���Ʒ
#define DS_K56A0X                   10507   //��׿�ж���֤
#define DS_K56Q_F70                 10508   //�Ͷ����������������)
#define DS_K1T6Q_F70M               10509   //F70ϵ������ʶ��һ�����������)
#define DS_K1T6Q_F40X               10510   //F40ϵ������ʶ��һ�����������)
#define DS_K5604A_XXX               10511   //�еͶ��������
#define DS_K1A330X                  10512   //���Ͷ��������ڻ���������)
#define DS_K1T804A                  10513   //������ָ���Ž�һ���
#define DS_K1T202                   10514   //������ָ���Ž�һ���
#define DS_K1T343MX                 10515   //�����Ž�һ�����������)
#define DS_K1T331W_D                10516   //�Ͷ������Ž�����һ�����DS-K1T331W(D)��
#define DS_K1T671WX_D               10517   //�����Ž�һ�����DS-K1T671M(D) DS-K1T671MW(D) DS-K1T671MG(D)��
#define DS_K1T680X                  10518   //8.0�������������Ž���DS-K1T680M DS-K1T680D��

#define DS_IEXX_E_J                 11501    //�������ܷ�����

#define IDS_67XX_NX_A               12501    //67ϵ��NVS��Ʒ(iDS-6704NX/A)
#define IDS_67XX_NX_L               12502    //67ϵ��¼��NVS��Ʒ
#define IDS_ENIXX_XHE               12503    //¼��NVS��ҵרҵ��Ʒ
#define IDS_67XX_NX_V               12504    //���Լ���վNVS
#define IDS_67XX_NX_B               12505    //67ϵ�а�ȫñ���NVS��Ʒ

//�����������豸
#define DS_IE63XX_E_FA              13001 //���׵���
#define DS_DS_GPKIA                 13002 //��ӥ������
#define DS_DS_PURE                  13003 //���״�����
#define DS_DS_FS                    13004 //������̬���ݷ�����
#define DS_DS_FD                    13005 //ץ�ļ�������
#define DS_DS_BLADE                 13006 //����
#define DS_DS_HMCP                  13007 //ģ�ͶԱȷ�����

//�������豸
#define DS_LNX_RF                   13501 //����������

//�״��豸    13551-14000��500��
#define DS_PA_RADAR                 13551 //PA�״�
#define DS_PERIMETER_RADAR          13552 //�ܽ��״�
#define DS_SECURITY_RADAR           13553//120�װ����״�
//�����豸    14001-14500��500��
#define DS_N1104X                   14001 //��������
#define DS_N1103X                   14002 //�û���Ϣ�����豸
#define NP_FSC201                   14003 //��ˮ�豸
#define NP_FDC240                   14004 //���ʽ��������̽����
#define DS_N1107                    14005 //����������
#define NP_FAXXX                    14006 //����������

//�����豸 14501-15000��500��
#define NP_ST204_X                  14501 //�ڶ������ܰ��������
#define ISD_SG2XXL_X                14502 //������(ISD-SG206L ISD-SG218L ISD-SG218L-F)
/**********************�豸���� end***********************/
/**********************�豸���� begin**********************/

/* dvr��� 1-50 */
#define DEV_CLASS_DVR      1          //��ͨdvr����
#define DEV_CLASS_INTERROGATION  2    //��Ѷ��
#define DEV_CLASS_SIMPLE_TRAIL  3    //����ͥ������
#define DEV_CLASS_TRAIL  4           //��׼ͥ������
#define DEV_CLASS_RECORD_PLAY  5     //¼������
#define DEV_CLASS_ATM 6           //ATM��

/* dvs��� 51-100 */
#define DEV_CLASS_DVS 51          //��ͨdvs

/* nvr��� 101-150 */
#define DEV_CLASS_NVR 101          //��ͨnvr

/* ipc��� 151-200 */
#define DEV_CLASS_GUN 151          //ipcǹ��
#define DEV_CLASS_BALL 152          //ipc���
#define DEV_CLASS_SNAP 153          //ץ�Ļ�
#define DEV_CLASS_INTELLI_TILT 154   //������̨
#define DEV_CLASS_FISH_EYE 155          //����
#define DEV_CLASS_2DP_Z 156         //��ӥ��
#define DEV_CLASS_2DP 157   //Сӥ��
#define DEV_CLASS_PT 158   //ȫ��ϸ�����
#define DEV_CLASS_TRI 159   //����Ƶ�̶�ʽ������

/* CVR��� 201 - 250*/
#define DEV_CLASS_CVR 201          //CVR

/* ������� 251 - 300*/
#define DEV_CLASS_B20 251          //����B20ϵ��
#define DEV_CLASS_B10 252          //����B10ϵ��
#define DEV_CLASS_DECODER 253      //������
#define DEV_CLASS_MATRIXMANAGEDEVICE 254      //�����������
#define DEV_CLASS_OTICAL 255      //��˻�
#define DEV_CLASS_CODESPITTER 256      //�����
#define DEV_CLASS_ALARMHOST 257      //��ҵ��������
#define DEV_CLASS_MOVING_RING 258      //�����豸
#define DEV_CLASS_CVCS 259      //����ʽ����������
#define DEV_CLASS_DVCS 260      //�ֲ�ʽ����������
#define DEV_CLASS_TRANSCODER 261      //ת����
#define DEV_CLASS_LCD_SCREEN 262      //LCD��Ļ
#define DEV_CLASS_LED_SCREEN 263      //LED��Ļ
#define DEV_CLASS_MATRIX 264      //����
#define DEV_CLASS_CONFERENCE_SYSTEM 265      //��Ƶ�����豸
#define DEV_CLASS_INFORMATION_RELEASE_EQUIPMENT  266      //��Ϣ�����豸
#define DEV_CLASS_NET_GAP 267      //��բ
#define DEV_CLASS_MERGE 268      //������
#define DEV_CLASS_REAR_PROJECTION 269      //��Ͷ��ʾ�豸
#define DEV_CLASS_SWITCH 270      //������
#define DEV_CLASS_FIBER_CONVERTER 271      //�����շ���
#define DEV_CLASS_SCREEN_SERVER 272      //��Ļ������
#define DEV_CLASS_SCE_SERVER 273      //ץ��������
#define DEV_CLASS_WIRELESS_TRANS  274    //���ߴ����豸
#define DEV_CLASS_Y10_SERIES      275    //Y10ϵ��
#define DEV_CLASS_SAFETY_MAVHINE  276    //����һ���
#define DEV_CLASS_IOTGATEWAY 277    //����������
/* ����������� 301 - 350*/
#define DEV_CLASS_VIDEO_ALARM_HOST 301          //��Ƶ��������
#define DEV_CLASS_NET_ALARM_HOST 302          //���籨������
#define DEV_CLASS_ONE_KEY_ALARM 303      //һ��ʽ������Ʒ
#define DEV_CLASS_WIRELESS_ALARM_HOST 304      //���߱�������
#define DEV_CLASS_ALARM_MODULE 305      //����ģ��
#define DEV_CLASS_HOME_ALARM_HOST 306      //���ñ�������
#define DEV_CLASS_HYBRID_ALARM_HOST 307      //��ϱ�������

/* �Ž���� 351 - 400*/
#define DEV_CLASS_ACCESS_CONTROL 351          //�Ž���Ʒ

/* ���ӶԽ� 401 - 450*/
#define DEV_CLASS_VIDEO_INTERCOM 401          //���ӶԽ�

/* ���˻� 451 - 500*/
#define DEV_CLASS_UMMANNED_AERIAL_VEHICLE 451          //���˻���Ʒ

/* �ƶ���Ʒ: 501-550*/
#define DEV_CLASS_MOBILE 501          //�ƶ���Ʒ

/* �ƶ������豸: 551-600*/
#define DEV_CLASS_MOBILE_VEHICLE 551          //�ƶ������豸

//���ܷ����ǣ�601-650
#define DEV_CLASS_INTELLIGENT_ANALYZER 601  //���ܷ�����

//���ܽ�ͨ��������651-700
#define DEV_CLASS_INTELLIGENT_TRAFFIC_SERVER 651  //���ܽ�ͨ������
#define DS_TP2200_EC                         652  //�����ͻ�������

/* nvs��� 701-750 */
#define DEV_CLASS_NVS 701          //��ͨnvs

/*��ԴRFIDϵ�� 751-800*/
#define DS_TRI21A_1_P 751   //��ԴRFID��ȡ��

/* ���������豸801-850 */
#define DS_CLASS_FA              801 //���׵���
#define DS_CLASS_PURE            802 //���״�����
#define DS_CLASS_FS              803 //������̬���ݷ�����
#define DS_CLASS_FD              804 //ץ�ļ�������
#define DS_CLASS_HAWK            805 //��ӥ������
#define DS_CLASS_BLADE           806 //����
#define DS_CLASS_HMCP            807 //ģ�ͶԱȷ�����

/* ��������� 851 - 900*/
#define DEV_CLASS_SMART_LOCK     851  //����������

/* �״���� 901 - 950*/
#define DEV_CLASS_RADAR          901  //�״��Ʒ

/* �ǻ�������� 951 - 1000*/
#define DEV_CLASS_FIRE_CONTROL   951 //������Ʒ

/* ������� 1001 - 1050*/
#define DEV_CLASS_SECURITY_CHECK          1001  //�����Ʒ

/*ȫ��ϸ������� 8451-8470*/
#define iDS_PT              8451  //ȫ��ϸ�����

/* �����豸���� 65534 */
#define DEV_CLASS_DEFAULT 65534   //Ĭ���豸����
/**********************�豸���� end**********************/

/******************************��������ȡ*********************************/
//������ȡ����
#define DEVICE_SOFTHARDWARE_ABILITY         0x001  //�豸��Ӳ������
#define DEVICE_NETWORK_ABILITY              0x002  //�豸��������
#define DEVICE_ENCODE_ALL_ABILITY           0x003  //�豸���б�������
#define    DEVICE_ENCODE_CURRENT               0x004  //�豸��ǰ��������
#define IPC_FRONT_PARAMETER                    0x005     //ipcǰ�˲���1.0
#define IPC_UPGRADE_DESCRIPTION                0x006     //ipc������Ϣ
#define DEVICE_RAID_ABILITY                 0x007  //RAID����
#define DEVICE_ENCODE_ALL_ABILITY_V20       0x008     //�豸���б�������2.0
#define IPC_FRONT_PARAMETER_V20                0x009     //ipcǰ�˲���2.0
#define DEVICE_ALARM_ABILITY                0x00a  //������������
#define DEVICE_DYNCHAN_ABILITY                0x00b  //�豸����ͨ������
#define DEVICE_USER_ABILITY                 0x00c  //�豸�û������������
#define DEVICE_NETAPP_ABILITY               0x00d  //�豸����Ӧ�ò�������
#define DEVICE_VIDEOPIC_ABILITY             0x00e  //�豸ͼ���������
#define DEVICE_JPEG_CAP_ABILITY             0x00f  //�豸JPEGץͼ����
#define DEVICE_SERIAL_ABILITY               0x010  //RS232��RS485��������
#define DEVICE_ABILITY_INFO                    0x011     //�豸ͨ���������ͣ������������ݷ��͵������ڵ�������
#define STREAM_ABILITY                      0x012  //������
#define SYSTEM_MANAGEMENT_ABILITY           0x013  //�豸ϵͳ��������
#define IP_VIEW_DEV_ABILITY                    0x014  //IP���ӶԽ��ֻ�����
#define VCA_DEV_ABILITY                     0x100  //�豸���ܷ�����������
#define VCA_CHAN_ABILITY                    0x110  //��Ϊ��������
#define TRANSFER_ABILITY                    0x120  
#define MATRIXDECODER_ABILITY               0x200  //��·��������ʾ����������
#define VIDEOPLATFORM_ABILITY               0x210 //��Ƶ�ۺ�ƽ̨������
#define VIDEOPLATFORM_SBUCODESYSTEM_ABILITY 0x211 //��Ƶ�ۺ�ƽ̨������ϵͳ������
#define WALL_ABILITY                        0x212  //����ǽ������
#define MATRIX_ABILITY                      0x213  //SDI�������� 
#define DECODECARD_ABILITY                  0x220 //���뿨������������
#define VIDEOPLATFORM_ABILITY_V40           0x230 //��Ƶ�ۺ�ƽ̨������
#define MATRIXMANAGEDEVICE_ABILITY          0x240 //�����������������
#define MATRIXDECODER_ABILITY_V41           0x260 //������������
#define DECODER_ABILITY                     0x261 //������xml������
#define DECODECARD_ABILITY_V41              0x270 //���뿨������������V41
#define CODECARD_ABILITY                    0x271  //���뿨������
#define SNAPCAMERA_ABILITY                  0x300  //ץ�Ļ�������
#define ITC_TRIGGER_MODE_ABILITY            0x301  //����IPC�豸�Ĵ���ģʽ����
#define COMPRESSIONCFG_ABILITY              0x400  //��ȡѹ��������������
#define COMPRESSION_LIMIT                   0x401  //��ȡ��������ѹ��������������
#define PIC_CAPTURE_ABILITY                    0x402  //��ͼƬ�ֱ�����������
#define ALARMHOST_ABILITY                   0x500 //���籨������������ 
#define IT_DEVICE_ABILITY                   0x501  //���ܽ�ͨ������
#define    SCREENCONTROL_ABILITY                0x600     //����������������
#define    SCREENSERVER_ABILITY                0x610     //����������������
#define FISHEYE_ABILITY                     0x700   //����������
#define LCD_SCREEN_ABILITY                    0x800    //LCD��Ļ���� 2013-10-12
#define ACS_ABILITY                         0x801   //�Ž�����
#define MERGEDEV_ABILITY                    0x802   //������������
#define CAM_FUSION_ABILITY                  0x803   //���ƴ������
#define OPTICAL_DEV_ACCESS_ABILITY          0x805   //��˻���������
#define NET_RING_ABILITY                    0x806    //����������
#define LED_ABILITY                            0x807    //LED��������
#define PUBLISHDEV_ABILITY                    0x80a    //��Ϣ��������
#define SCREEN_EXCHANGE_ABILITY             0x80b   //��Ļ��������
#define REMOTE_NETMGR_FOT_ABILITY   0x80e   //Զ�������շ�������
/*************************************************
�������ýṹ������(����_V30Ϊ9000����)
**************************************************/

//�Ӱ��쳣��Ϣ
//������
#define EXCEPTION_MAJOR_MAINBOARD_BOOT                    0x1  //������������
//������
#define EXCEPTION_MINOR_PCIE_SCAN                        0x1  // pcie��·ɨ���쳣  
#define EXCEPTION_MINOR_DOWNLOAD_SUBBOARD                 0xa  //�����Ӱ�����쳣

//������
#define EXCEPTION_MAJOR_SUBBOARD_BOOT                    0x2  //�Ӱ���������
//������
#define EXCEPTION_MINOR_INEXISTENCE                       0x1  //PCI-Eɨ������ǰ�Ӱ岻����
#define EXCEPTION_MINOR_UBOOT_DOWNLOAD                  0xa  // uboot�����쳣
#define EXCEPTION_MINOR_UBOOT_INIT                      0xe  //uboot��ʼ���쳣
#define EXCEPTION_MINOR_ROOTFS_DOWNLOAD                 0x14  //rootfs.img�����쳣
#define EXCEPTION_MINOR_UIMAGE_DOWNLOAD                 0x19  //uImage�����쳣
#define EXCEPTION_MINOR_UBOOT_SETBOOTFLAG               0x1e  // uboot������־λ��λ�쳣    
#define EXCEPTION_MINOR_ROOTFS_BOOT_SUBBOARD            0x23  // rootfs�����쳣
#define EXCEPTION_MINOR_NEED_FILE_FINISH                0x28  //�Ӱ������ļ������쳣

//������
#define EXCEPTION_MAJOR_SUBBOARD_HARDWARE                0x3  //�Ӱ�Ӳ������
//������
#define EXCEPTION_MINOR_AD                               0x1  //AD�쳣  
#define EXCEPTION_MINOR_DA                                 0xa  // DA�쳣
#define EXCEPTION_MINOR_TIMER                            0xb     //ʱ���쳣

//������
#define EXCEPTION_MAJOR_FPGA                            0x4  //FPGA����
//������
#define EXCEPTION_MINOR_IDLE                              0x1  //�޷�IDLE  
#define EXCEPTION_MINOR_LANE                             0xa  // LANE OKʧ��
#define EXCEPTION_MINOR_REGISTER_ALL_F                     0xe  //FPGA�Ĵ���ȫF
#define EXCEPTION_MINOR_MEMORY_INIT_FAIL                 0x14 //FPGA�ڴ��ʼ��ʧ��
//������
#define EXCEPTION_MAJOR_DSP                                0x5  //DSP����

//������
#define EXCEPTION_MAJOR_ARM                                0x6  //ARM����

//������
#define EXCEPTION_MAJOR_BACKBOARD                        0x7  //��������
//������
#define EXCEPTION_MINOR_BLACKBOARD_TYPE                   0x1  //��ȡ���������쳣
#define EXCEPTION_MINOR_SERDES                           0xa  //��Ƶ����оƬ  
#define EXCEPTION_MINOR_CLOCK                             0xe  //ʱ�ӹ���
#define EXCEPTION_MINOR_SYNCH                             0x14  //ͬ���źŹ���

//������
#define EXCEPTION_MAJOR_SUBBOARD_NET                    0x8  //�Ӱ�����
//������
#define EXCEPTION_MINOR_IP_CONFLICT                       0x1  //IP��ͻ 
#define EXCEPTION_MINOR_DISCONNECT                         0x14  // ����

//[add]by zengxiaole 2017-09-27 DS-19D2000-S v2.0
#define MAX_FIRE_ALARM_ZONE         12           //�����������������������
#define MAX_FIRE_ALARM_POINT_ZONE   32           //���������������������


typedef enum tagCharEncodeType
{
    ENUM_MEM_CHAR_ENCODE_ERR  = -1,         //Error   
    ENUM_MEM_CHAR_ENCODE_NO   = 0,          //Don't know.
    ENUM_MEM_CHAR_ENCODE_CN   = 1,          //EUC-CN, GB2312
    ENUM_MEM_CHAR_ENCODE_GBK  = 2,          //GBK
    ENUM_MEM_CHAR_ENCODE_BIG5 = 3,          //BIG5
    ENUM_MEM_CHAR_ENCODE_JP   = 4,          //JISX0208-1, EUC-JP
    ENUM_MEM_CHAR_ENCODE_KR   = 5,          //EUC-KR
    ENUM_MEM_CHAR_ENCODE_UTF8 = 6,          //UTF-8
    ENUM_MEM_CHAR_ENCODE_ISO8859_1  = 7,    //ISO-8859-n: ENUM_MEM_CHAR_ENCODE_ISO8859_1 + n -1
    ENUM_MEM_CHAR_ENCODE_UNICODE = 8,       //Unicode
}CHAR_ENCODE_TYPE;


/////////////////////////////////////////////////////////////////////////
//Уʱ�ṹ����
typedef struct
{
    DWORD dwYear;        //��
    DWORD dwMonth;        //��
    DWORD dwDay;        //��
    DWORD dwHour;        //ʱ
    DWORD dwMinute;        //��
    DWORD dwSecond;        //��
}NET_DVR_TIME, *LPNET_DVR_TIME;

typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE    byISO8601;      /*�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч */
    WORD	wMilliSec;       //���룬���Ȳ�����Ĭ��Ϊ0
    char    cTimeDifferenceH;  		//��UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����, byISO8601Ϊ1ʱ��Ч
    char    cTimeDifferenceM;         	//��UTC��ʱ����ӣ���-30, 30, 45��+��ʾ������byISO8601Ϊ1ʱ��Ч
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct tagNET_DVR_TIME_SEARCH
{
    WORD     wYear;        //�꣬�豸OSDʱ��
    BYTE    byMonth;        //�£��豸OSDʱ��
    BYTE     byDay;        //�գ��豸OSDʱ��
    BYTE     byHour;        //ʱ���豸OSDʱ��
    BYTE     byMinute;    //�֣��豸OSDʱ��
    BYTE     bySecond;    //�룬�豸OSDʱ��
    char cTimeDifferenceH;        //����ʱ�׼ʱ���ʱ�Сʱ����-12 ... +14
    char cTimeDifferenceM;        //����ʱ�׼ʱ���ʱ����ӣ���-30, 0, 30, 45
    BYTE     byLocalOrUTC;      //0-ʱ����Ч���豸����ʱ�䣬���豸OSDʱ��  1-ʱ����Ч
    WORD     wMillisecond;      //���룬���Ȳ�����Ĭ��Ϊ0
}NET_DVR_TIME_SEARCH, *LPNET_DVR_TIME_SEARCH;

typedef struct tagNET_DVR_TIME_SEARCH_COND
{
    WORD wYear; //�� 
    BYTE byMonth; //��
    BYTE byDay; //��
    BYTE byHour; //ʱ
    BYTE byMinute; //��
    BYTE bySecond; //��
    BYTE byLocalOrUTC; //0-ʱ����Ч���豸����ʱ�䣬���豸OSDʱ��  1-ʱ����Ч
    WORD wMillisecond;       //���룬���Ȳ�����Ĭ��Ϊ0
    char cTimeDifferenceH;   //��UTC��ʱ�Сʱ����-12 ... +14��+��ʾ������byLocalOrUTCΪ1ʱ��Ч
    char cTimeDifferenceM;   //��UTC��ʱ����ӣ���-30, 0, 30, 45��+��ʾ������byLocalOrUTCΪ1ʱ��Ч
}NET_DVR_TIME_SEARCH_COND, *LPNET_DVR_TIME_SEARCH_COND;


typedef struct tagNET_DVR_TIME_V50
{
    WORD 		wYear;		//�� 
    BYTE		byMonth;    //��
    BYTE 		byDay;		//��
    BYTE 		byHour;		//ʱ
    BYTE 		byMinute;	//��
    BYTE 		bySecond;	//��
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    WORD  	    wMillisecond;       //���룬���Ȳ�����Ĭ��Ϊ0
    char cTimeDifferenceH;   //��UTC��ʱ�Сʱ����-12 ... +14��+��ʾ������byISO8601Ϊ1ʱ��Ч
    char cTimeDifferenceM;   //��UTC��ʱ����ӣ���-30, 0, 30, 45��+��ʾ������byISO8601Ϊ1ʱ��Ч
}NET_DVR_TIME_V50, *LPNET_DVR_TIME_V50;



typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME,*LPNET_DVR_CALIBRATE_TIME;

#define    MAX_TIMESIGN_LEN    32 //�Զ���Уʱ�����Ϣ����
typedef  struct tagNET_DVR_TIMESIGN_CFG
{
    DWORD  dwSize;
    BYTE  byCustomSetTimeSign[MAX_TIMESIGN_LEN/*32*/];//�Զ���Уʱ���
    BYTE  byRes[96]; 
}NET_DVR_TIMESIGN_CFG,*LPNET_DVR_TIMESIGN_CFG;


typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX,*LPNET_DVR_TIME_EX;

//ʱ���(�ӽṹ)
typedef struct
{
    //��ʼʱ��
    BYTE byStartHour;
    BYTE byStartMin;
    //����ʱ��
    BYTE byStopHour;
    BYTE byStopMin;
}NET_DVR_SCHEDTIME, *LPNET_DVR_SCHEDTIME;

/*�豸�������쳣����ʽ*/
/*�豸�������쳣����ʽ*/
#define NOACTION            0x0                /*����Ӧ*/
#define WARNONMONITOR        0x1                /*�������Ͼ���*/
#define WARNONAUDIOOUT        0x2                /*��������*/
#define UPTOCENTER            0x4                /*�ϴ�����*/
#define TRIGGERALARMOUT        0x8                /*�����������*/
#define TRIGGERCATPIC        0x10            /*����ץͼ���ϴ�E-mail*/
#define SEND_PIC_FTP        0x200           /*ץͼ���ϴ�ftp*/

typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD    wLength;        //�ṹ����
    BYTE    byVersion ;    /*�ߵ�4λ�ֱ����ߵͰ汾���������ݰ汾�ͳ��Ƚ�����չ����ͬ�İ汾�ĳ��Ƚ�������*/
    BYTE    byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{    
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    /*0x400: �齻��� ���� �۽�ģʽ���ṩ�������ԭ���豸�Զ���ɣ�IPC5.1.0*/
    /*0x800: PTZ��������(�������Ŀ��)*/
    /*0x4000:�׹�Ʊ���*/
    /*0x10000:���ű���*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧����
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //��������ͨ��  
    BYTE    byRes[64];           //����
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V40
{    
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x80: ��������¼��(Ŀǰֻ��PCNVR֧��) */
    /*0x100: ����������̨Ԥ�õ� (Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    /*0x400: �齻��� ���� �۽�ģʽ���ṩ�������ԭ���豸�Զ���ɣ�IPC5.1.0*/
    /*0x800: PTZ��������(�������Ŀ��)*/ 
    /*0x1000:ץͼ�ϴ�����*/
    /*0x2000:���ű���*/
    /*0x4000:�׹�Ʊ���*/
    /*0x8000:��������*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOutChanNum; //�����ı������ͨ���� ʵ��֧����
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //��������ͨ��  
    BYTE    byWhiteLightDurationTime;//�׹����˸����ʱ����1~60s(�������˰׹�Ʊ���ʱ��Ч)
    BYTE    byBrightness;//�׹�����ȣ���Χ0-100��Ĭ��50
    BYTE    byAudioType;//������������
    BYTE    byTimes;//����������������Χ��0-9��Ĭ��2, 0xff-����
    BYTE    byRes[60];           //����
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;

//�������쳣����ṹ(�ӽṹ)(�ദʹ��)(9000��չ)
typedef struct
{
    DWORD    dwHandleType;    /*����ʽ,����ʽ��"��"���*/
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/
    /*0x2000:���ű���*/
    BYTE byRelAlarmOut[MAX_ALARMOUT_V30];  
    //�������������ͨ��,�������������,Ϊ1��ʾ���������
}NET_DVR_HANDLEEXCEPTION_V30, *LPNET_DVR_HANDLEEXCEPTION_V30;

//�������쳣����ṹ(�ӽṹ)(�ദʹ��)
typedef struct
{
    DWORD    dwHandleType;            /*����ʽ,����ʽ��"��"���*/
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: Jpegץͼ���ϴ�EMail*/
    BYTE byRelAlarmOut[MAX_ALARMOUT];  //�������������ͨ��,�������������,Ϊ1��ʾ���������
}NET_DVR_HANDLEEXCEPTION, *LPNET_DVR_HANDLEEXCEPTION;

//DVR�豸����
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR����
    DWORD dwDVRID;                //DVR ID,����ң���� //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;        //�Ƿ�ѭ��¼��,0:����; 1:��
    //���²��ɸ���
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    DWORD dwSoftwareVersion;            //����汾��,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwSoftwareBuildDate;            //�����������,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;            //DSP����汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwDSPSoftwareBuildDate;        // DSP�����������,0xYYYYMMDD
    DWORD dwPanelVersion;                // ǰ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwHardwareVersion;    // Ӳ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    BYTE byAlarmInPortNum;        //DVR�����������
    BYTE byAlarmOutPortNum;        //DVR�����������
    BYTE byRS232Num;            //DVR 232���ڸ���
    BYTE byRS485Num;            //DVR 485���ڸ���
    BYTE byNetworkPortNum;        //����ڸ���
    BYTE byDiskCtrlNum;            //DVR Ӳ�̿���������
    BYTE byDiskNum;                //DVR Ӳ�̸���
    BYTE byDVRType;                //DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                //DVR ͨ������
    BYTE byStartChan;            //��ʼͨ����,����DVS-1,DVR - 1
    BYTE byDecordChans;            //DVR ����·��
    BYTE byVGANum;                //VGA�ڵĸ���
    BYTE byUSBNum;                //USB�ڵĸ���
    BYTE byAuxoutNum;            //���ڵĸ���
    BYTE byAudioNum;            //�����ڵĸ���
    BYTE byIPChanNum;            //�������ͨ����
}NET_DVR_DEVICECFG, *LPNET_DVR_DEVICECFG;

/*
IP��ַ
*/
typedef struct
{        
    char    sIpV4[16];                        /* IPv4��ַ */
    BYTE    byIPv6[128];                        /* ���� */
}NET_DVR_IPADDR, *LPNET_DVR_IPADDR;

typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP; //IP��ַ
    WORD wPort;    //�˿ں�
    BYTE byRes[2];
}NET_DVR_ADDRESS, *LPNET_DVR_ADDRESS;

/*
�������ݽṹ(�ӽṹ)(9000��չ)
*/
typedef struct 
{
    NET_DVR_IPADDR    struDVRIP;                              //DVR IP��ַ
    NET_DVR_IPADDR    struDVRIPMask;  //DVR IP��ַ����
    DWORD    dwNetInterface;                                   //����ӿ�1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M����Ӧ
    WORD    wDVRPort;                                        //�˿ں�
    WORD    wMTU;                                            //����MTU���ã�Ĭ��1500��
    BYTE    byMACAddr[MACADDR_LEN];                            // �����ַ
    BYTE    byEthernetPortNo;                                  //���ںţ�0-��Ч��1-����0��2-����1�Դ����ƣ�ֻ��
    BYTE    byRes[1];              //����
}NET_DVR_ETHERNET_V30, *LPNET_DVR_ETHERNET_V30;

/*
�������ݽṹ(�ӽṹ)
*/
typedef struct
{
    char sDVRIP[16];          //DVR IP��ַ
    char sDVRIPMask[16];      //DVR IP��ַ����
    DWORD dwNetInterface;     //����ӿ� 1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M����Ӧ
    WORD wDVRPort;              //�˿ں�
    BYTE byMACAddr[MACADDR_LEN];        //�������������ַ
}NET_DVR_ETHERNET;

//pppoe�ṹ
typedef struct 
{
    DWORD    dwPPPOE;                                        //0-������,1-����
    BYTE    sPPPoEUser[NAME_LEN];                            //PPPoE�û���
    char    sPPPoEPassword[PASSWD_LEN];                        // PPPoE����
    NET_DVR_IPADDR    struPPPoEIP;                            //PPPoE IP��ַ
}NET_DVR_PPPOECFG, *LPNET_DVR_PPPOECFG;

//�������ýṹ(9000��չ)
typedef struct
{    
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];        //��̫����
    NET_DVR_IPADDR    struRes1[2];                    /*����*/
    NET_DVR_IPADDR    struAlarmHostIpAddr;                    /* ��������IP��ַ */
    BYTE    byRes2[4];                                /* ���� */
    WORD    wAlarmHostIpPort;                                /* ���������˿ں� */
    BYTE    byUseDhcp;                                      /* �Ƿ�����DHCP 0xff-��Ч 0-������ 1-����*/
    BYTE    byIPv6Mode;                                //IPv6���䷽ʽ��0-·�ɹ��棬1-�ֶ����ã�2-����DHCP����
    NET_DVR_IPADDR    struDnsServer1IpAddr;                    /* ����������1��IP��ַ */
    NET_DVR_IPADDR    struDnsServer2IpAddr;                    /* ����������2��IP��ַ */
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                    /* IP����������������IP��ַ */
    WORD    wIpResolverPort;                                /* IP�����������˿ں� */
    WORD    wHttpPortNo;                                    /* HTTP�˿ں� */
    NET_DVR_IPADDR    struMulticastIpAddr;                    /* �ಥ���ַ */
    NET_DVR_IPADDR    struGatewayIpAddr;                        /* ���ص�ַ */
    NET_DVR_PPPOECFG struPPPoE;    
    BYTE    byEnablePrivateMulticastDiscovery;  //˽�жಥ������0~Ĭ�ϣ�1~���ã�2-����
    BYTE    byEnableOnvifMulticastDiscovery;  //Onvif�ಥ������0~Ĭ�ϣ�1~���ã�2-����
    BYTE    byEnableDNS; //DNS�Զ�ʹ��, 0-������1-�򿪣�2-�ر�
    BYTE    byRes[61];
} NET_DVR_NETCFG_V30, *LPNET_DVR_NETCFG_V30;

//���������������ṹ
typedef struct 
{
    NET_DVR_IPADDR struDVRIP;           //DVR IP��ַ
    NET_DVR_IPADDR struDVRIPMask;           //DVR IP��ַ����
    DWORD dwNetInterface;    //����ӿ�1-10MBase-T 2-10MBase-Tȫ˫�� 3-100MBase-TX 4-100Mȫ˫�� 5-10M/100M/1000M����Ӧ
    BYTE byCardType;  //�������ͣ�0-��ͨ������1-����������2-��������
    BYTE    byEnableDNS; //DNS�Ƿ��Զ�ʹ�ܣ�0-������1-��, 0-�ر�
    WORD wMTU;             //����MTU���ã�Ĭ��1500��
    BYTE byMACAddr[MACADDR_LEN]; //�����ַ��ֻ������ʾ
    BYTE byEthernetPortNo;        //���ںţ�0-��Ч��1-����0��2-����1�Դ����ƣ�ֻ��
    BYTE bySilkScreen; //˿ӡ��Ϣ��0-��Ч��1-GE1��2-GE2��3-G1��4-G2��ֻ��
    BYTE byUseDhcp;                          /* �Ƿ�����DHCP */
    BYTE byRes3[3];
    NET_DVR_IPADDR struGatewayIpAddr;     /* ���ص�ַ */
    NET_DVR_IPADDR struDnsServer1IpAddr; /* ����������1��IP��ַ */
    NET_DVR_IPADDR struDnsServer2IpAddr; /* ����������2��IP��ַ */
}NET_DVR_ETHERNET_MULTI, *LPNET_DVR_ETHERNET_MULTI;

//�������������ýṹ
typedef struct
{
    DWORD  dwSize;
    BYTE   byDefaultRoute;        //Ĭ��·�ɣ�0��ʾstruEtherNet[0]��1��ʾstruEtherNet[1]
    BYTE   byNetworkCardNum;      //�豸ʵ�ʿ����õ�������Ŀ
    BYTE   byWorkMode;   //0-��ͨ������ģʽ��1-����������ģʽ
    BYTE   byRes; //����
    NET_DVR_ETHERNET_MULTI struEtherNet[MAX_NETWORK_CARD]; //��̫����
    NET_DVR_IPADDR         struManageHost1IpAddr;     /* ����������IP��ַ */
    NET_DVR_IPADDR         struManageHost2IpAddr;     /* ����������IP��ַ */
    NET_DVR_IPADDR           struAlarmHostIpAddr; /* ��������IP��ַ */
    WORD wManageHost1Port;     /* �����������˿ں� */
    WORD wManageHost2Port;     /* �����������˿ں� */
    WORD wAlarmHostIpPort;     /* ���������˿ں� */
    BYTE  byIpResolver[MAX_DOMAIN_NAME];     /* IP����������������IP��ַ */
    WORD wIpResolverPort; /* IP�����������˿ں� */
    WORD wDvrPort; //ͨѶ�˿� Ĭ��8000 
    WORD wHttpPortNo; /* HTTP�˿ں� */
    WORD wDvrPort2; //ͨѶ�˿�2
    BYTE byRes2[4];
    NET_DVR_IPADDR   struMulticastIpAddr; /* �ಥ���ַ */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE byRes3[24];
}NET_DVR_NETCFG_MULTI, *LPNET_DVR_NETCFG_MULTI;

//�������ýṹ
typedef struct
{
    DWORD dwSize;
    NET_DVR_ETHERNET struEtherNet[MAX_ETHERNET];        /* ��̫���� */
    char sManageHostIP[16];        //Զ�̹���������ַ
    WORD wManageHostPort;        //Զ�̹��������˿ں�
    char sIPServerIP[16];            //IPServer��������ַ
    char sMultiCastIP[16];     //�ಥ���ַ
    char sGatewayIP[16];           //���ص�ַ
    char sNFSIP[16];            //NFS����IP��ַ
    BYTE sNFSDirectory[PATHNAME_LEN];//NFSĿ¼
    DWORD dwPPPOE;                //0-������,1-����
    BYTE sPPPoEUser[NAME_LEN];    //PPPoE�û���
    char sPPPoEPassword[PASSWD_LEN];// PPPoE����
    char sPPPoEIP[16];            //PPPoE IP��ַ(ֻ��)
    WORD wHttpPort;                //HTTP�˿ں�
}NET_DVR_NETCFG, *LPNET_DVR_NETCFG;

//�������ýṹ(V50)
typedef struct tagNET_DVR_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];        //��̫����
    NET_DVR_IPADDR    struRes1[2];                    /*����*/
    NET_DVR_IPADDR    struAlarmHostIpAddr;                    /* ��������IP��ַ */
    BYTE    byRes2[4];                                /* ���� */
    WORD    wAlarmHostIpPort;                                /* ���������˿ں� */
    BYTE    byUseDhcp;                                      /* �Ƿ�����DHCP 0xff-��Ч 0-������ 1-����*/
    BYTE    byIPv6Mode;                                //IPv6���䷽ʽ��0-·�ɹ��棬1-�ֶ����ã�2-����DHCP����
    NET_DVR_IPADDR    struDnsServer1IpAddr;                    /* ����������1��IP��ַ */
    NET_DVR_IPADDR    struDnsServer2IpAddr;                    /* ����������2��IP��ַ */
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                    /* IP����������������IP��ַ */
    WORD    wIpResolverPort;                                /* IP�����������˿ں� */
    WORD    wHttpPortNo;                                    /* HTTP�˿ں� */
    NET_DVR_IPADDR    struMulticastIpAddr;                    /* �ಥ���ַ */
    NET_DVR_IPADDR    struGatewayIpAddr;                        /* ���ص�ַ */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE    byEnablePrivateMulticastDiscovery;  //˽�жಥ������0~Ĭ�ϣ�1~���ã�2-����
    BYTE    byEnableOnvifMulticastDiscovery;  //Onvif�ಥ������0~Ĭ�ϣ�1~���ã�2-����
    WORD    wAlarmHost2IpPort;                                /* ��������2�˿ں� */
    NET_DVR_IPADDR    struAlarmHost2IpAddr;                    /* ��������2 IP��ַ */
    BYTE    byEnableDNS; //DNSʹ��, 0-�رգ�1-��
    BYTE    byRes[599];
}NET_DVR_NETCFG_V50, *LPNET_DVR_NETCFG_V50;

//sip����
typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //ʹ���Զ�ע�ᣬ0-��ʹ�ܣ�1-ʹ��
    BYTE byLoginStatus;  //ע��״̬��0-δע�ᣬ1-��ע�ᣬ�˲���ֻ�ܻ�ȡ
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP������IP
    WORD wServerPort;    //SIP�������˿�
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //ע���û���
    BYTE byPassWord[PASSWD_LEN]; //ע������
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //�豸��ʾ����
    WORD wLocalPort;     //���ض˿�
    BYTE byLoginCycle;   //ע�����ڣ�1-99����
    BYTE byType;//0-IP/IPV6,1-����
    BYTE byDomainName[MAX_DOMAIN_NAME]; //����
    BYTE byRes[64];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

typedef struct tagNET_DVR_SIP_CFG_V50
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //ʹ���Զ�ע�ᣬ0-��ʹ�ܣ�1-ʹ��
    BYTE byLoginStatus;  //ע��״̬��0-δע�ᣬ1-��ע�ᣬ�˲���ֻ�ܻ�ȡ
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP������IP
    WORD wServerPort;    //SIP�������˿�
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //ע���û���
    BYTE byPassWord[PASSWD_LEN]; //ע������
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //�豸��ʾ����
    WORD wLocalPort;     //���ض˿�
    BYTE byLoginCycle;   //ע�����ڣ�1-99����
    BYTE byRes3;
    BYTE bySIPServerDomain[MAX_DOMAIN_NAME];  //sip������������IP������ֻ��Ҫ����һ������ֵʱIP���ȣ�
    NET_DVR_IPADDR stuSTUNServerIP;  // STUN������IP
    BYTE bySTUNServerDomain[MAX_DOMAIN_NAME];  //STUN���������� ��IP������ֻ��Ҫ����һ������ֵʱIP���ȣ�
    WORD wSTUNServerPort;    // STUN�������˿�
    BYTE byRes4[2];
    NET_DVR_IPADDR stuProxyServerIP;  //���������IP
    BYTE byProxyServerDomain[MAX_DOMAIN_NAME];  //������������� ��IP������ֻ��Ҫ����һ������ֵʱIP���ȣ�
    WORD wProxyServerPort;    // ����������˿�
    BYTE byNetWork; //��ʾ�������ͣ�0-��Ч��1-��������1�� 2-��������2��3-��������
    BYTE byRes5;
    BYTE byCalledTargetName[NET_SDK_MAX_CALLEDTARGET_NAME];
    BYTE byRes[224];
}NET_DVR_SIP_CFG_V50, *LPNET_DVR_SIP_CFG_V50;

//IP���ӶԽ��ֻ�����
typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //Ĭ����������Χ1-6
    BYTE  byRingVolume;  //������������Χ0-9
    BYTE  byInputVolume; //��������ֵ����Χ0-6
    BYTE  byOutputVolume; //�������ֵ����Χ0-9    
    WORD  wRtpPort;  //Rtp�˿�
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //Ԥ����ʱ���ã�0-30��
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG,*LPNET_DVR_IP_VIEW_DEVCFG;

//Ip���ӶԽ���Ƶ��ز�������
typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;    
    BYTE  byAudioEncPri1; //��Ƶ�������ȼ�1��0-G722��1-G711_U��2-G711_A�� 5-MPEG2,6-G726��7-AAC
    BYTE  byAudioEncPri2; //��Ƶ�������ȼ�2����sip��������֧����Ƶ����1ʱ��ʹ����Ƶ����2��0-G722��1-G711_U��2-G711_A�� 5-MPEG2,6-G726��7-AAC
    WORD  wAudioPacketLen1; //��Ƶ����1���ݰ�����
    WORD  wAudioPacketLen2; //��Ƶ����2���ݰ�����
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG,*LPNET_DVR_IP_VIEW_AUDIO_CFG;

//IP�ֻ����жԽ��������ýṹ��
typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize ;
    BYTE  byEnableAutoResponse; //ʹ���Զ�Ӧ��,0-��ʹ�ܣ�1-ʹ��
    BYTE  byAudoResponseTime; //�Զ�Ӧ��ʱ�䣬0-30��
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //������������1��0-��������1-����
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //���к���1
    BYTE  byEnableAlarmNumber2; //������������2��0-��������1-����
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //���к���2�����к���1ʧ�᳢ܻ�Ժ��к���2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG,*LPNET_DVR_IP_VIEW_CALL_CFG;

//ͨ��ͼ��ṹ
//�ƶ����(�ӽṹ)(���鷽ʽ��չ)
typedef struct
{    
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwCurRecordChanNum;    //��ǰʵ�������õĹ���¼��ͨ����
    DWORD     dwRelRecordChan[MAX_CHANNUM_V30];     /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - MAX_CHANNUM_V30-1��Ч������м�����0xffffffff,�������Ч*/  
    BYTE       byRes[64];          //����
}NET_DVR_RECORDCHAN, *LPNET_DVR_RECORDCHAN;

//�ƶ����(�ӽṹ)(9000��չ)
typedef struct 
{
    BYTE byMotionScope[64][96];                                    /*�������,0-96λ,��ʾ64��,����96*64��С���,Ϊ1��ʾ���ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;                                        /*�ƶ����������, 0 - 5,Խ��Խ����,oxff�ر�*/
    BYTE byEnableHandleMotion;                                    /* �Ƿ����ƶ���� 0���� 1����*/ 
    BYTE byEnableDisplay;    /*�����ƶ���������ʾ��0-��1-��*/
    char reservedData;    
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;                /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];                                    /* ����������¼��ͨ��*/
}NET_DVR_MOTION_V30, *LPNET_DVR_MOTION_V30;

//�ƶ����(�ӽṹ)
typedef struct 
{
    BYTE byMotionScope[18][22];    /*�������,����22*18��С���,Ϊ1��ʾ�ĺ�����ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;        /*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byEnableHandleMotion;    /* �Ƿ����ƶ���� */
    BYTE byEnableDisplay;    /*�����ƶ���������ʾ��0-��1-��*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
}NET_DVR_MOTION, *LPNET_DVR_MOTION;

//�ڵ�����(�ӽṹ)(9000��չ)  �����С704*576
typedef struct 
{
    DWORD dwEnableHideAlarm;                /* �Ƿ������ڵ����� ,0-��,1-�������� 2-�������� 3-��������*/
    WORD wHideAlarmAreaTopLeftX;            /* �ڵ������x���� */
    WORD wHideAlarmAreaTopLeftY;            /* �ڵ������y���� */
    WORD wHideAlarmAreaWidth;                /* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;                /*�ڵ�����ĸ�*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
}NET_DVR_HIDEALARM_V30, *LPNET_DVR_HIDEALARM_V30;
//�ڵ�����(�ӽṹ)  �����С704*576
typedef struct 
{
    DWORD dwEnableHideAlarm;                /* �Ƿ������ڵ����� ,0-��,1-�������� 2-�������� 3-��������*/
    WORD wHideAlarmAreaTopLeftX;            /* �ڵ������x���� */
    WORD wHideAlarmAreaTopLeftY;            /* �ڵ������y���� */
    WORD wHideAlarmAreaWidth;                /* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;                /*�ڵ�����ĸ�*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
}NET_DVR_HIDEALARM, *LPNET_DVR_HIDEALARM;

//�źŶ�ʧ����(�ӽṹ)(9000��չ)
typedef struct 
{
    BYTE byEnableHandleVILost;    /* �Ƿ����źŶ�ʧ���� */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
}NET_DVR_VILOST_V30, *LPNET_DVR_VILOST_V30;

//�źŶ�ʧ����(�ӽṹ)
typedef struct 
{
    BYTE byEnableHandleVILost;    /* �Ƿ����źŶ�ʧ���� */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
}NET_DVR_VILOST, *LPNET_DVR_VILOST;

//�ڵ�����(�ӽṹ)
typedef struct 
{
    WORD wHideAreaTopLeftX;                /* �ڵ������x���� */
    WORD wHideAreaTopLeftY;                /* �ڵ������y���� */
    WORD wHideAreaWidth;                /* �ڵ�����Ŀ� */
    WORD wHideAreaHeight;                /*�ڵ�����ĸ�*/
}NET_DVR_SHELTER, *LPNET_DVR_SHELTER;

typedef struct
{
    BYTE byBrightness;      /*����,0-255*/
    BYTE byContrast;        /*�Աȶ�,0-255*/    
    BYTE bySaturation;      /*���Ͷ�,0-255*/
    BYTE byHue;                /*ɫ��,0-255*/
}NET_DVR_COLOR, *LPNET_DVR_COLOR;

typedef struct
{
    BYTE byRed;        //RGB��ɫ�������еĺ�ɫ
    BYTE byGreen;    //RGB��ɫ�������е���ɫ
    BYTE byBlue;    //RGB��ɫ�������е���ɫ
    BYTE byRes;        //����
}NET_DVR_RGB_COLOR, *LPNET_DVR_RGB_COLOR;

//����ֵ��һ��,������ֵΪ��ǰ����İٷֱȴ�С, ����ΪС�������λ
//������ṹ
typedef struct tagNET_VCA_POINT
{    
    float fX;                                // X������, 0.000~1
    float fY;                                //Y������, 0.000~1
}NET_VCA_POINT, *LPNET_VCA_POINT;

//ͨ��ͼ��ṹ(9000��չ)
typedef struct
{
    DWORD dwSize;
    BYTE  sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE  byReservedData[64];/*����*/
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ������,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;                /* ͨ��������ʾλ�õ�x���� */
    WORD wShowNameTopLeftY;                /* ͨ��������ʾλ�õ�y���� */
    //��Ƶ�źŶ�ʧ����
    NET_DVR_VILOST_V30 struVILost;
    NET_DVR_VILOST_V30 struRes;        /*����*/
    //    BYTE byRes1[328];
    //�ƶ����
    NET_DVR_MOTION_V30 struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM_V30 struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;        /* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;                /* OSD��x���� */
    WORD wOSDTopLeftY;                /* OSD��y���� */
    BYTE byOSDType;                    /* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;                /* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;                /* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    BYTE byHourOSDType;                /* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
    BYTE byFontSize;//�����С��16*16(��)/8*16(Ӣ)��1-32*32(��)/16*32(Ӣ)��2-64*64(��)/32*64(Ӣ)  3-48*48(��)/24*48(Ӣ) 4-24*24(��)/12*24(Ӣ) 5-96*96(��)/48*96(Ӣ) 6-128*128(��)/64*128(Ӣ) 7-80*80(��)/40*80(Ӣ) 8-112*112(��)/56*112(Ӣ) 0xff-����Ӧ(adaptive)
    BYTE byOSDColorType;    //0-Ĭ�ϣ��ڰף���1-�Զ���
    /*�����뷽ʽѡ�����ģʽʱ�����Էֱ�����½ǡ����½������������ַ����ӡ�
    ���½�����
    ��֧��6���ַ����ӣ�����ͨ��NET_DVR_SET_SHOWSTRING_V30�ַ����ӽӿڣ���ӦNET_DVR_SHOWSTRINGINFO�ṹ�������еĵ�0����5���±��ֵ�������ַ��ķ�ʽΪ���µ��ϵķ�ʽ��
    ���½�����
    ��֧��2���ַ����ӣ�����ͨ��NET_DVR_SET_SHOWSTRING_V30�ַ����ӽӿڣ���ӦNET_DVR_SHOWSTRINGINFO�ṹ�������еĵ�6�͵�7���±��ֵ�������ַ��ķ�ʽΪ���µ��ϵķ�ʽ��
    */
    BYTE byAlignment;//���뷽ʽ 0-����Ӧ��1-�Ҷ���, 2-�����,3-����ģʽ, 4-ȫ���Ҷ���(���������ַ���ʱ���Լ����������OSD�ַ�)��5-ȫ�������(���������ַ���ʱ���Լ����������OSD�ַ�)
    BYTE byOSDMilliSecondEnable;//��Ƶ����ʱ��֧�ֺ��룻0~������, 1-����
    NET_DVR_RGB_COLOR struOsdColor;//OSD��ɫ
    DWORD dwBoundary; //�߽�ֵ������룬�Ҷ����Լ�����ģʽ�ı߽�ֵ��0-��ʾĬ��ֵ����λ������
    NET_DVR_RGB_COLOR struOsdBkColor; //�Զ���OSD����ɫ
    BYTE byOSDBkColorMode; //OSD����ɫģʽ��0-Ĭ�ϣ�1-�Զ���OSD����ɫ
    BYTE    byUpDownBoundary; //������С�߽�ֵѡ���λΪ�ַ���������Χ�ǣ�0,1,2��, ����ģʽ����Ч��byAlignment=3���ֶ���Ч��ͨ��dwBoundary���б߽����ã�.byAlignment������3������£� byUpDownBoundary/byLeftRightBoundary���óɹ���dwBoundaryֵ������Ч
    BYTE    byLeftRightBoundary; //������С�߽�ֵѡ���λΪ�ַ���������Χ�ǣ�0,1,2��, ����ģʽ����Ч��byAlignment=3���ֶ���Ч��ͨ��dwBoundary���б߽����ã�.byAlignment������3������£� byUpDownBoundary/byLeftRightBoundary���óɹ���dwBoundaryֵ������Ч
    BYTE    byAngleEnabled;//OSD�Ƿ���Ӹ�������Ϣ,0~������, 1-����
    WORD    wTiltAngleTopLeftX;    /* ��������Ϣ��ʾλ�õ�x���� */
    WORD    wTiltAngleTopLeftY;  /* ��������Ϣ��ʾλ�õ�y���� */
    BYTE byRes[40];
}NET_DVR_PICCFG_V30, *LPNET_DVR_PICCFG_V30;

//ͨ��ͼ��ṹSDK_V14��չ
typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*����,0-255*/
    BYTE byContrast;        /*�Աȶ�,0-255*/    
    BYTE bySaturation;      /*���Ͷ�,0-255 */
    BYTE byHue;                /*ɫ��,0-255*/
    //��ʾͨ����
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ������,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;                /* ͨ��������ʾλ�õ�x���� */
    WORD wShowNameTopLeftY;                /* ͨ��������ʾλ�õ�y���� */
    //�źŶ�ʧ����
    NET_DVR_VILOST struVILost;
    //�ƶ����
    NET_DVR_MOTION struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;        /* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;                /* OSD��x���� */
    WORD wOSDTopLeftY;                /* OSD��y���� */
    BYTE byOSDType;                    /* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;                /* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;                /* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    BYTE byHourOsdType;        /* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
}NET_DVR_PICCFG_EX, *LPNET_DVR_PICCFG_EX;

//ͨ��ͼ��ṹ(SDK_V13��֮ǰ�汾)
typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*����,0-255*/
    BYTE byContrast;        /*�Աȶ�,0-255*/    
    BYTE bySaturation;      /*���Ͷ�,0-255 */
    BYTE byHue;                /*ɫ��,0-255*/
    //��ʾͨ����
    DWORD dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ������,0-����ʾ,1-��ʾ �����С704*576
    WORD wShowNameTopLeftX;                /* ͨ��������ʾλ�õ�x���� */
    WORD wShowNameTopLeftY;                /* ͨ��������ʾλ�õ�y���� */
    //�źŶ�ʧ����
    NET_DVR_VILOST struVILost;
    //�ƶ����
    NET_DVR_MOTION struMotion;
    //�ڵ�����
    NET_DVR_HIDEALARM struHideAlarm;
    //�ڵ�  �����С704*576
    DWORD dwEnableHide;        /* �Ƿ������ڵ� ,0-��,1-��*/
    WORD wHideAreaTopLeftX;                /* �ڵ������x���� */
    WORD wHideAreaTopLeftY;                /* �ڵ������y���� */
    WORD wHideAreaWidth;                /* �ڵ�����Ŀ� */
    WORD wHideAreaHeight;                /*�ڵ�����ĸ�*/
    //OSD
    DWORD dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ �����С704*576
    WORD wOSDTopLeftX;                /* OSD��x���� */
    WORD wOSDTopLeftY;                /* OSD��y���� */
    BYTE byOSDType;                    /* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE byDispWeek;                /* �Ƿ���ʾ���� */
    BYTE byOSDAttrib;                /* OSD����:͸������˸ */
    /* 1: ͸��,��˸ */
    /* 2: ͸��,����˸ */
    /* 3: ��˸,��͸�� */
    /* 4: ��͸��,����˸ */
    char reservedData2;
}NET_DVR_PICCFG, *LPNET_DVR_PICCFG;

typedef enum _BITRATE_ENCODE_INDEX_
{
    BITRATE_ENCODE_def = 0,
        BITRATE_ENCODE_8kps = 1,
        BITRATE_ENCODE_16kps = 2,
        BITRATE_ENCODE_32kps = 3,
        BITRATE_ENCODE_64kps = 4,
        BITRATE_ENCODE_128kps = 5,
        BITRATE_ENCODE_192kps = 6,
        BITRATE_ENCODE_40kps = 7,
        BITRATE_ENCODE_48kps = 8,
        BITRATE_ENCODE_56kps = 9,
        BITRATE_ENCODE_80kps = 10,
        BITRATE_ENCODE_96kps = 11,
        BITRATE_ENCODE_112kps = 12,
        BITRATE_ENCODE_144kps = 13,
        BITRATE_ENCODE_160kps = 14,
        BITRATE_ENCODE_224kps = 15,
        BITRATE_ENCODE_256kps = 16,
        BITRATE_ENCODE_320kps = 17
}BITRATE_ENCODE_INDEX;

//����ѹ������(�ӽṹ)(9000��չ)
typedef struct 
{
    BYTE byStreamType;        //�������� 0-��Ƶ��, 1-������, ��ʾ�¼�ѹ������ʱ���λ��ʾ�Ƿ�����ѹ������
                            /*�ֱ���0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,             
                            4-2CIF                      5��������,                 6-QVGA(320*240),        7-QQVGA(160*120),  
                            12-384*288                  13-576*576,                   
                            16-VGA��640*480��,          17-UXGA��1600*1200��,      18-SVGA(800*600),       19-HD720p(1280*720��,   
                            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,              
                            24-1920*1920,               27-HD1080i,                   
                            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,                
                            32-2448*1200,               33-2448*800,               34-XGA��1024*768����    35-SXGA��1280*1024��,         
                            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),  
                            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,                 
                            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,                 
                            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,                 
                            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
                            56-2304*1296                57-WXGA(1280*800),         58-1600*600,               59-1600*900,
                            60-2752*2208,                61-����,                   62-4000*3000,           63-4096*2160,
                            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
                            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
                            72-160*128,                 73-324*240,                74-324*256,             75-336*256,             
                            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216, 
                            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
                            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
                            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
                            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
                            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
                            100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
                            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
                            108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
                            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
                            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
                            120-480*768,                121-768*480,               122-320*512,             123-512*320,
                            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
                            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
                            132-2720*1192,              133-3MP(1920*1536/2048*1536)��                     134-5MP(2560*1944)��
                            135-2560*960,               136-2064*1544              137-4096*1200,
                            138-3840*1080               139-2720*800               140-512*232             141-704*200,
                            142-512*152,                143-2048*896               144-2048*600            145-1280*376,
                            146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
                            150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
                            154-480*720,                155-800*450,               156-480*270,            157-2560*1536,
                            160-3264*2448,              161-288*320,               162-144*176,            163-480*640,  
                            164-240*320,                165-120*160,               166-576*720,            167-720*1280,
                            168-576*960,                169-2944*1656,             170-432*240,            171-2160*3840,
                            172-1080*1920,              173-7008*1080,             174-3504*540,           175-1752*270,
                            176-876*135,                177-4096*1440,             178-4096*1080,          179-1536*864,
                            180-180*240,                181-360*480,               182-540*720,            183-720*960,  
                            184-960*1280,               185-1080*1440,
                            186-3200*1800,              187-1752*272,              188-872*136,            189-1280*1440,
                            190-3520*544,               191-1728*256,              192-864*128,            193-5470*3684,
                            194-2560*750,               195-1600*480,              196-1024*300,           197-848*480,
							198-8160*3616,				199-8160*2304,             200-4064*2560,          201-1400*1050,
                            202-2688*1512,              203-704*288,               204-1560*656,           205-3072*1280,
                            206-4320*1808,              207-6120*2560,              208-1280*960,          209-3000*3000,
                            210-2032*3616,              211-7680*4320,             212-5760*3240,          213-3264*1836,
                            214-2712*1536,              215-1080*720(ռλ��δ����),  216-360x640(ռλ��δ����),217-1440*812,
                            218-8160*2416,              219-5760*1712,               220-4080*1200,          221-6144*2560,
                            222-1568*656,               223-4096*1808,               224-2720*1200,          225-2896*848
                            226-2048*608                227-3840*1120                228-2720*784            229-1920*560,
                            230-1360*400                231-704*208                  232-496*144             233-352*128,
                            234-512*240                 235-512*160                  236-368*128            237-256*128
                            238-2048*592                239-1456*416                 240-1024*304            241-1280*368
                            242-912*256                 243-640*192                  244-252*112 ��δʹ�ã�            245-(576*704[P��]/480*704[N��])
                            
                            254-��ʾ�������ֶη�Χ��ʹ��NET_DVR_MULTI_STREAM_COMPRESSIONCFG�е�dwResolution��ʾ�ֱ���
                            0xff-Auto(ʹ�õ�ǰ�����ֱ���)
                            256-3888*1696                257-2784*1200               258-496*224              259-352*160
                            260-912*400                  261-640*288                 262-1456*640             263-1024*448
                            264-2896*1280                265-2544*1080               266-2736*768             267-1920*544
                            268-3840*1696                269-2880*848                270-5424*2400            271-5520*1600
                            272-848*376                  273-912*272                 274-1360*600             275-1456*432
                            276-2736*1200                277-5760*1696               278-8160*2400            279-5520*2400
                            280-4608*2592                281-4944*3280               282-6016*4008            283-720*480
                            284-3200*2400                285-2784*800                286-1968*848             287-1392*608
                            288-2736*1184                289-1920*848                290-2560*2880            291-1944*1212
                            292-1920*2400                293-384*384                 294-768*768              295-4800*2688
                            296-6480*1080                297-8640*1440               298-4800*800             299-6720*1200
                            300-3600*600                 301-4800*840                302-2400*400             303-3072*540
                            304-1440*810                 305-1920*320                306-2688*480             307-1440*240
                            308-4800*1792                309-3360*1264               310-2304*880             311-3840*1440
                            312-2688*1008                313-1824*704                314-1248*496             315-1920*720
                            316-1344*496                 317-912*336                 318-1280*480             319-864*336
                            320-576*224                  321-2704*1008               322-1904*704             323-1808*672
                            324-1264*464                 325-944*336                 326-2400*1344            327-2032*1440
                            328-4064*1792                329-304*112                 330-960*360              331-672*240
                            332-464*160                  333-896*336                 334-624*224              335-640*240
                            336-448*160                  337-4976*1452               338-1968*560             339-2736*784
                            340-3888*1136                341-6120*1800               342-4320*1280            343-3056*896
                            344-1776*528                 345-1392*400                346-7256*1520            347-512*288   
                            348-1936*1210                349-640*400                 350-2688*1792            351-2464*2056
                            352-2720*1600                353-4800*1600               354-3600*1200            355-δ����
                            356-2400*800                 357-1200*400
    */
    BYTE byResolution;      
    BYTE byBitrateType;        //�������� 0:������, 1:������,0xfe:�Զ�����Դһ��
    BYTE byPicQuality;        //ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��,�Զ�����Դһ��
                            /*��Ƶ����:0-������1-16K(����)��2-32K��3-48k��4-64K��5-80K��6-96K��7-128K��8-160k��9-192K��10-224K��
                            11-256K��12-320K��13-384K��14-448K��15-512K��16-640K��17-768K��18-896K��19-1024K��20-1280K��21-1536K��22-1792K��23-2048K��
    24-3072K��25-4096K��26-8192K��27-16384K�����λ(31λ)�ó�1��ʾ���Զ���������0��30λ��ʾ����ֵ����Сֵ16k,0xfffffffe���Զ�����Դһ��*/
    DWORD dwVideoBitrate;      
    DWORD dwVideoFrameRate;    //֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; V2.0�汾���¼�14-15; 15-18; 16-22;
    //17-25��18-30��19-35��20-40��21-45��22-50��23-55��24-60��25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,33-8.3,0xfffffffe-�Զ�����Դһ��
    WORD  wIntervalFrameI;  //I֡���,0xfffe �Զ�����Դһ��
    BYTE  byIntervalBPFrame;//0-BBP֡; 1-BP֡; 2-��P֡(2006-08-11 ���ӵ�P֡�����ýӿڣ����Ը���ʵʱ����ʱ����)��0xfe-�Զ�����Դһ��
    BYTE  byres1;        //����
    BYTE  byVideoEncType;   //��Ƶ�������� 0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��8-MPEG2��9-SVAC, 10-��׼h265, 0xfe-�Զ�����Դһ�£���0xff-��Ч 
    BYTE  byAudioEncType;   //��Ƶ�������� 0-G722;1-G711_U;2-G711_A;5-MP2L2;6-G276;7-AAC;8-PCM;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;0xff-��Ч
    BYTE  byVideoEncComplexity; //��Ƶ���븴�Ӷȣ�0-�ͣ�1-�У�2��,0xfe:�Զ�����Դһ��
    BYTE  byEnableSvc; //0 - ������SVC���ܣ�1- ����SVC����; 2-�Զ�����SVC����
    BYTE  byFormatType; //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP,9-RTP+PS�����꣺GB28181����0xff-��Ч
    BYTE  byAudioBitRate; //��Ƶ���� �ο� BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;//����ƽ�� 1��100��1�ȼ���ʾ����(Clear)��100��ʾƽ��(Smooth)��
    BYTE  byAudioSamplingRate;//��Ƶ������0-Ĭ��,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;///*bit0-�����ܱ��� 0-�رգ�1-�򿪣�bit1 - ������ģʽ 0 - �رգ�1 - ��*/
    BYTE  byDepthMapEnable;// ���ͼʹ�ܿ��أ�0-�رգ�1-�򿪣���������󣬵ڶ�ͨ������������˫Ŀ������Ƶ�������������ã�Ĭ����� 960*540 �����ͼ��
    //ƽ�����ʣ���SmartCodecʹ�ܿ�������Ч��, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
    //���λ(15λ)�ó�1��ʾ���Զ�������, 0-14λ��ʾ����ֵ(MIN- 0 K)��
    WORD  wAverageVideoBitrate; 
}NET_DVR_COMPRESSION_INFO_V30, *LPNET_DVR_COMPRESSION_INFO_V30;

//ͨ��ѹ������(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;    //¼�� ��Ӧ8000����ͨ
    NET_DVR_COMPRESSION_INFO_V30 struRes;//���� char reserveData[28];
    NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;       //�¼�����ѹ������
    NET_DVR_COMPRESSION_INFO_V30 struNetPara;               //����(������)
}NET_DVR_COMPRESSIONCFG_V30, *LPNET_DVR_COMPRESSIONCFG_V30;

//����ѹ������(�ӽṹ)
typedef struct 
{
    BYTE byStreamType;        //��������0-��Ƶ��,1-������,��ʾѹ������ʱ���λ��ʾ�Ƿ�����ѹ������
    BYTE byResolution;      //�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(����ר��)
    BYTE byBitrateType;        //��������0:�����ʣ�1:�����ʣ�2��������
    BYTE  byPicQuality;        //ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��
    DWORD dwVideoBitrate;     //��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;    //֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20;
}NET_DVR_COMPRESSION_INFO, *LPNET_DVR_COMPRESSION_INFO;

//ͨ��ѹ������
typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara; //¼��/�¼�����¼��
    NET_DVR_COMPRESSION_INFO struNetPara;    //����/����
}NET_DVR_COMPRESSIONCFG, *LPNET_DVR_COMPRESSIONCFG;

//����ѹ������(�ӽṹ)(��չ) ����I֡���
typedef struct 
{
    BYTE byStreamType;        //��������0-��Ƶ��, 1-������
    BYTE byResolution;      //�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(����ר��)
    BYTE byBitrateType;        //��������0:�����ʣ�1:�����ʣ�2��������
    BYTE  byPicQuality;        //ͼ������ 0-��� 1-�κ� 2-�Ϻ� 3-һ�� 4-�ϲ� 5-��
    DWORD dwVideoBitrate;     //��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;    //֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0����14-15, 15-18, 16-22;
    WORD  wIntervalFrameI;  //I֡���
    //2006-08-11 ���ӵ�P֡�����ýӿڣ����Ը���ʵʱ����ʱ����
    BYTE  byIntervalBPFrame;//0-BBP֡; 1-BP֡; 2-��P֡
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX, *LPNET_DVR_COMPRESSION_INFO_EX;

//ͨ��ѹ������(��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara; //¼��
    NET_DVR_COMPRESSION_INFO_EX struNetPara;    //����
}NET_DVR_COMPRESSIONCFG_EX, *LPNET_DVR_COMPRESSIONCFG_EX;


//ʱ���¼���������(�ӽṹ)
typedef struct 
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;    //0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&����, 5:�����, 6: ����¼��,10-PIR������11-���߱�����12-���ȱ�����13-���б���,14-���ܽ�ͨ�¼���15Խ����⣬16����������⣬17��Ƶ�쳣���
    char reservedData[3];
}NET_DVR_RECORDSCHED, *LPNET_DVR_RECORDSCHED;

//ȫ��¼���������(�ӽṹ)
typedef struct 
{
    WORD wAllDayRecord;                /* �Ƿ�ȫ��¼�� 0-�� 1-��*/
                                    BYTE byRecordType;                /* ¼������ 0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����, 6: ����¼��,
                                                                    10-PIR������11-���߱�����12-���ȱ�����13-�ƶ�|��������|PIR|���߱���|���ȱ���,14-���ܽ�ͨ�¼�,15-Խ�����,16-��������,17-�����쳣,
                                    18-����������,19-������⣨Խ�����|��������|��������|�뿪����|����ʶ��,20���������, 21-POS¼��*/
                                    char reservedData;
}NET_DVR_RECORDDAY, *LPNET_DVR_RECORDDAY;

//ͨ��¼���������(9000��չ)
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* ¼����ʱ���� 0-5�룬 1-10�룬 2-30�룬 3-1���ӣ� 4-2���ӣ� 5-5���ӣ� 6-10����*/
    DWORD    dwPreRecordTime;                /* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
    DWORD    dwRecorderDuration;                /* ¼�񱣴���ʱ�� */
    BYTE    byRedundancyRec;    /*�Ƿ�����¼��,��Ҫ����˫���ݣ�0/1*/
    BYTE    byAudioRec;        /*¼��ʱ����������ʱ�Ƿ��¼��Ƶ���ݣ������д˷���*/
    BYTE    byStreamType;  // 0-��������1-��������2-��������ͬʱ 3-������
    BYTE    byPassbackRecord;  // 0:���ش�¼�� 1���ش�¼��
    WORD    wLockDuration;  // ¼������ʱ������λСʱ 0��ʾ��������0xffff��ʾ����������¼��ε�ʱ�����������ĳ���ʱ����¼�񣬽���������
    BYTE    byRecordBackup;  // 0:¼�񲻴浵 1��¼��浵
    BYTE     bySVCLevel;    //SVC��֡���ͣ�0-���飬1-�����֮һ 2-���ķ�֮��
    BYTE    byRecordManage;   //¼����ȣ�0-���ã� 1-������; ����ʱ���ж�ʱ¼�񣻲�����ʱ�����ж�ʱ¼�񣬵���¼��ƻ�����ʹ�ã������ƶ���⣬�ش������ڰ�����¼��ƻ�����
    BYTE    byExtraSaveAudio;        //��Ƶ�������0-�ǵ�����棬1-�������
    /*��������¼���ܺ��㷨�����Զ���������¼���㷨���书��Ϊ��¼������Ŀ����֣��ή�����ʡ�֡�ʣ���Ŀ�����ʱ�ָֻ�ȫ���ʼ�֡�ʣ��Ӷ��ﵽ������Դ���ĵ�Ŀ��*/
    BYTE   byIntelligentRecord;//�Ƿ�������¼���� 0-�� 1-��
    BYTE    byReserve;
}NET_DVR_RECORD_V30, *LPNET_DVR_RECORD_V30;

//ʱ���¼���������(�ӽṹ)
typedef struct 
{
    NET_DVR_SCHEDTIME  struRecordTime;
    /*¼�����ͣ�0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����, 
    6-���ܱ���¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼�,14-���ܽ�ͨ�¼�, 
    15-Խ�����,16-��������,17-�����쳣,18-����������,
    19-�������(Խ�����|��������|�������|�����쳣|����������),20���������,21-POS¼��,
    22-�����������, 23-�뿪�������,24-�ǻ����,25-��Ա�ۼ����,26-�����˶����,27-ͣ�����,
    28-��Ʒ�������,29-��Ʒ��ȡ���,30-����⣬31-���ƻ����,32-��ܶ�Ź�¼�(˾��),33-�����¼�(˾��), 34-�˯�¼�(˾��)
    35-��ֻ���, 36-����Ԥ����37-���±�����38-�²����39-���߲��±���,40-����������41-��������,42-ҵ����ѯ,43-������,44-�����ʸ�,45-��޳�ʱ��46-����ץ�ģ�47-�Ƿ���̯,48-Ŀ��ץ��,
    49-�����˶���50��ڼ�⣬51-������52�����仯 53-�����ŷż�� 54-�Ҷȱ���*/
    BYTE byRecordType; 
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

//ȫ��¼���������(�ӽṹ)
typedef struct 
{
    BYTE byAllDayRecord; /* �Ƿ�ȫ��¼�� 0-�� 1-��*/
                         /*¼�����ͣ�0:��ʱ¼��1:�ƶ���⣬2:����¼��3:����|������4:����&���� 5:�����, 
                         6-���ܱ���¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼�,14-���ܽ�ͨ�¼�, 
                         15-Խ�����,16-��������,17-�����쳣,18-����������,
                         19-�������(Խ�����|��������|�������|�����쳣|����������),20���������,21-POS¼��,
                         22-�����������, 23-�뿪�������,24-�ǻ����,25-��Ա�ۼ����,26-�����˶����,27-ͣ�����,
                         28-��Ʒ�������,29-��Ʒ��ȡ���,30-����⣬31-���ƻ����,32-��ܶ�Ź�¼�(˾��),33-�����¼�(˾��), 34-�˯�¼�(˾��)
                         35-��ֻ���, 36-����Ԥ����37-���±�����38-�²����39-���߲��±���,40-����������41-��������,42-ҵ����ѯ,43-������,44-�����ʸ�,45-��޳�ʱ,46-����ץ��,47-�Ƿ���̯,48-Ŀ��ץ��,
                         49-�����˶���50��ڼ�⣬51-������52�����仯  53-�����ŷż��  54-�Ҷȱ���*/
    BYTE byRecordType; 
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY_V40    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40 struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* ¼����ʱ���� 0-5�룬 1-10�룬 2-30�룬 3-1���ӣ� 4-2���ӣ� 5-5���ӣ� 6-10����*/
    DWORD    dwPreRecordTime;                /* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
    DWORD    dwRecorderDuration;                /* ¼�񱣴���ʱ�� */
    BYTE    byRedundancyRec;    /*�Ƿ�����¼��,��Ҫ����˫���ݣ�0/1*/
    BYTE    byAudioRec;        /*¼��ʱ����������ʱ�Ƿ��¼��Ƶ���ݣ������д˷���*/
    BYTE    byStreamType;  // 0-��������1-��������2-��������ͬʱ 3-������
    BYTE    byPassbackRecord;  // 0:���ش�¼�� 1���ش�¼��
    WORD    wLockDuration;  // ¼������ʱ������λСʱ 0��ʾ��������0xffff��ʾ����������¼��ε�ʱ�����������ĳ���ʱ����¼�񣬽���������
    BYTE    byRecordBackup;  // 0:¼�񲻴浵 1��¼��浵
    BYTE     bySVCLevel;    //SVC��֡���ͣ�0-���飬1-�����֮һ 2-���ķ�֮��
    BYTE    byRecordManage;   //¼����ȣ�0-���ã� 1-������; ����ʱ���ж�ʱ¼�񣻲�����ʱ�����ж�ʱ¼�񣬵���¼��ƻ�����ʹ�ã������ƶ���⣬�ش������ڰ�����¼��ƻ�����
    BYTE    byExtraSaveAudio;//��Ƶ�����洢
    /*��������¼���ܺ��㷨�����Զ���������¼���㷨���书��Ϊ��¼������Ŀ����֣��ή�����ʡ�֡�ʣ���Ŀ�����ʱ�ָֻ�ȫ���ʼ�֡�ʣ��Ӷ��ﵽ������Դ���ĵ�Ŀ��*/
    BYTE   byIntelligentRecord;//�Ƿ�������¼���� 0-�� 1-��
    BYTE    byRes[125];
}NET_DVR_RECORD_V40, *LPNET_DVR_RECORD_V40;

//ͨ��¼���������
typedef struct 
{
    DWORD dwSize;
    DWORD dwRecord;  /*�Ƿ�¼�� 0-�� 1-��*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;    /* ¼��ʱ�䳤�� */
    DWORD dwPreRecordTime;    /* Ԥ¼ʱ�� 0-��Ԥ¼ 1-5�� 2-10�� 3-15�� 4-20�� 5-25�� 6-30�� 7-0xffffffff(������Ԥ¼) */
}NET_DVR_RECORD, *LPNET_DVR_RECORD;

//��̨Э���ṹ����
typedef struct
{ 
    DWORD dwType;               /*����������ֵ*/    
    BYTE  byDescribe[DESC_LEN]; /*������������������8000�е�һ��*/    
}NET_DVR_PTZ_PROTOCOL;

typedef struct
{    
    DWORD   dwSize;    
    NET_DVR_PTZ_PROTOCOL struPtz[PTZ_PROTOCOL_NUM];/*���200��PTZЭ��*/    
    DWORD   dwPtzNum;           /*��Ч��ptzЭ����Ŀ����0��ʼ(������ʱ��1)*/
    BYTE    byRes[8];
}NET_DVR_PTZCFG, *LPNET_DVR_PTZCFG;

/***************************��̨����(end)******************************/
typedef struct tagNET_DVR_SERIALSTART_V40   //͸��ͨ��
{
    DWORD  dwSize;         //�ṹ���С
    DWORD  dwSerialType;    //���ںţ�1-232���ڣ�2-485���ڣ�
    BYTE   bySerialNum;   //���ڱ��
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40,*LPNET_DVR_SERIALSTART_V40;

//ͨ��������(��̨)�������� ��չ
typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;       //�ṹ���С
    DWORD     dwBaudRate;       //������ 0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k; 
    BYTE     byDataBit;       //�����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE     byStopBit;       //ֹͣλ 0��1λ��1��2λ
    BYTE     byParity;       //У�� 0����У�飬1����У�飬2��żУ��
    BYTE     byFlowcontrol;  //0���ޣ�1��������,2-Ӳ����
    WORD     wDecoderType;    //����������*/
    WORD     wDecoderAddress;    //��������ַ��0-255
    BYTE     bySetPreset [MAX_PRESET_V30];  //Ԥ�õ��Ƿ�����,0-û������,1-����
    BYTE     bySetCruise[MAX_CRUISE_V30];  //Ѳ���Ƿ�����: 0-û������,1-����
    BYTE     bySetTrack [MAX_TRACK_V30];    //�켣�Ƿ�����,0-û������,1-����
    BYTE     bySerialNO;          //���ڱ��
    BYTE     byWorkMode;          /*����ģʽ�� 1-���󴮿ڿ��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PPPģʽ 5-����̨ģʽ 6-����ֱ�� 7-���̿��� 8-��ذ���� 9-������̨ 12-LED��ʾ��13-����ץ�����ݴ���*/
    BYTE     byRes[254];         //����
}NET_DVR_DECODERCFG_V40,*LPNET_DVR_DECODERCFG_V40;

typedef	struct tagNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO
{
    float fMaxTemperature;//����£���ȷ��С�����һλ
    float fMinTemperature;//����£���ȷ��С�����һλ
    float fAverageTemperature;//ƽ���£���ȷ��С�����һλ
    NET_VCA_POINT struHighestPoint; //����¶�λ������
    NET_VCA_POINT struLowestPoint; //����¶�λ������
	BYTE       byIsFreezedata;//�Ƿ����ݶ��� 0-�� 1-��
    BYTE  byRes[15];
}NET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO, *LPNET_DVR_THERMOMETRYRULE_TEMPERATURE_INFO;

//ͨ��������(��̨)��������(9000��չ)
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;// �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    WORD wDecoderType;//����������, ��0��ʼ����ӦptzЭ���б��NET_DVR_IPC_PROTO_LIST�õ�
    WORD wDecoderAddress;    /*��������ַ:0 - 255*/
    BYTE bySetPreset[MAX_PRESET_V30];        /* Ԥ�õ��Ƿ�����,0-û������,1-����*/
    BYTE bySetCruise[MAX_CRUISE_V30];        /* Ѳ���Ƿ�����: 0-û������,1-���� */
    BYTE bySetTrack[MAX_TRACK_V30];            /* �켣�Ƿ�����,0-û������,1-����*/
}NET_DVR_DECODERCFG_V30, *LPNET_DVR_DECODERCFG_V30;

//ͨ��������(��̨)��������
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;       //������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;         // �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;         // ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;          // У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;     // 0���ޣ�1��������,2-Ӳ����
    WORD wDecoderType;      //����������  NET_DVR_IPC_PROTO_LIST�еõ�
    WORD wDecoderAddress;    /*��������ַ:0 - 255*/
    BYTE bySetPreset[MAX_PRESET];        /* Ԥ�õ��Ƿ�����,0-û������,1-����*/
    BYTE bySetCruise[MAX_CRUISE];        /* Ѳ���Ƿ�����: 0-û������,1-���� */
    BYTE bySetTrack[MAX_TRACK];        /* �켣�Ƿ�����,0-û������,1-����*/
}NET_DVR_DECODERCFG, *LPNET_DVR_DECODERCFG;

//ppp��������(�ӽṹ)
typedef struct 
{
    NET_DVR_IPADDR struRemoteIP;    //Զ��IP��ַ
    NET_DVR_IPADDR struLocalIP;        //����IP��ַ
    char sLocalIPMask[16];            //����IP��ַ����
    BYTE sUsername[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    BYTE byPPPMode;                    //PPPģʽ, 0��������1������
    BYTE byRedial;                    //�Ƿ�ز� ��0-��,1-��
    BYTE byRedialMode;                //�ز�ģʽ,0-�ɲ�����ָ��,1-Ԥ�ûز�����
    BYTE byDataEncrypt;                //���ݼ���,0-��,1-��
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //�绰����
}NET_DVR_PPPCFG_V30, *LPNET_DVR_PPPCFG_V30;

//ppp��������(�ӽṹ)
typedef struct 
{
    char sRemoteIP[16];                //Զ��IP��ַ
    char sLocalIP[16];                //����IP��ַ
    char sLocalIPMask[16];            //����IP��ַ����
    BYTE sUsername[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    BYTE byPPPMode;                    //PPPģʽ, 0��������1������
    BYTE byRedial;                    //�Ƿ�ز� ��0-��,1-��
    BYTE byRedialMode;                //�ز�ģʽ,0-�ɲ�����ָ��,1-Ԥ�ûز�����
    BYTE byDataEncrypt;                //���ݼ���,0-��,1-��
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //�绰����
}NET_DVR_PPPCFG, *LPNET_DVR_PPPCFG;

//RS232���ڲ�������(9000��չ)
typedef struct
{
    DWORD dwBaudRate;   /*������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;*/
    BYTE byDataBit;     /* �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ */
    BYTE byStopBit;     /* ֹͣλ 0��1λ��1��2λ */
    BYTE byParity;      /* У�� 0����У�飬1����У�飬2��żУ�� */
    BYTE byFlowcontrol; /* 0���ޣ�1��������,2-Ӳ���� */
    DWORD dwWorkMode;   //����ģʽ��0��232��������PPP���ţ�1��232�������ڲ������ƣ�2��͸��ͨ�� 3- ptzģʽ,��Ѷ��ʪ�ȴ�����, 4-������ģʽ  5-���󴮿ڿ��� 6-��Ļ���� 7-����ֱ�� 8-���̿��� 9-��ذ���� 10-������̨
}NET_DVR_SINGLE_RS232;

typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate;   /*������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;*/
    BYTE byDataBit;     /* �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ */
    BYTE byStopBit;     /* ֹͣλ 0��1λ��1��2λ */
    BYTE byParity;      /* У�� 0����У�飬1����У�飬2��żУ�� */
    BYTE byFlowcontrol; /* 0���ޣ�1��������,2-Ӳ���� */
    BYTE byVirtualSerialPort;  //���⴮�ڱ��
    BYTE byRes[3];
}NET_DVR_USB_RS232,*LPNET_DVR_USB_RS232;

//RS232���ڲ�������(9000��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*ע�⣺�˽ṹ�޸��ˣ�ԭ���ǵ����ṹ�������޸�Ϊ������ṹ*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30, *LPNET_DVR_RS232CFG_V30;

//RS232���ڲ�������
typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//������(bps)��0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byDataBit;// �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    DWORD dwWorkMode;// ����ģʽ��0��խ������(232��������PPP����)��1������̨(232�������ڲ�������)��2��͸��ͨ��
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG, *LPNET_DVR_RS232CFG;


typedef struct 
{
    DWORD dwEnablePresetChan;    /*����Ԥ�õ��ͨ��, 0xfffffff��ʾ������Ԥ�õ�*/
    DWORD dwPresetPointNo;        /*����Ԥ�õ�ͨ����Ӧ��Ԥ�õ����, 0xfffffff��ʾ������Ԥ�õ㡣*/
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct 
{
    DWORD dwEnableCruiseChan;    /*����Ѳ����ͨ��*/
    DWORD dwCruiseNo;        /*Ѳ��ͨ����Ӧ��Ѳ�����, 0xfffffff��ʾ��Ч*/
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct 
{
    DWORD dwEnablePtzTrackChan;    /*������̨�켣��ͨ��*/
    DWORD dwPtzTrackNo;        /*��̨�켣ͨ����Ӧ�ı��, 0xfffffff��ʾ��Ч*/
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_COND
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blackListFaceContrast
    21-whiteListFaceContrast
    22- humanRecognition
    23- faceContrast
    */
    WORD    byEventType;
    BYTE    byRes[2];
    DWORD   dwChannel;
    BYTE    byRes1[128];
}NET_DVR_PTZ_NOTIFICATION_COND, *LPNET_DVR_PTZ_NOTIFICATION_COND;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_CFG
{
    DWORD   dwSize;
    DWORD   dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ(������������ ptz)
    DWORD   dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ(������������ ptz)
    DWORD   dwEnablePtzTrackChanNum;  //��ǰ��������̨�켣��ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ(������������ ptz)
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION_CFG, *LPNET_DVR_PTZ_NOTIFICATION_CFG;


typedef struct tagNET_DVR_PTZ_NOTIFICATION
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection��
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blackListFaceContrast
    21-whiteListFaceContrast
    22- humanRecognition
    */
    WORD    byEventType;
    BYTE    byRes[62];
    DWORD   dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ(������������ ptz)
    DWORD   dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ(������������ ptz)
    DWORD   dwEnablePtzTrackChanNum;  //��ǰ��������̨�켣��ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ(������������ ptz)
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION, *LPNET_DVR_PTZ_NOTIFICATION;

#define NET_SDK_MAX_EVENT_NUM 64  //����¼����֧�ָ���

//���������������(256·NVR��չ)
typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* ���� */
    BYTE byAlarmType;                //����������,0������,1������
    BYTE byAlarmInHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byInputType;                //��������  0-��������ʽ  1-�ź�����ʽ
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    /*0x1000:ץͼ�ϴ�����*/
    /*0x2000:���ű���*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOutChanNum; //�����ı������ͨ���� ʵ��֧����
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //��������ͨ��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    /*������¼��ͨ��*/
    DWORD   dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD   dwCurRecordChanNum;    //��ǰʵ�������õĹ���¼��ͨ����
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];     /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - dwCurRecordChanNum -1��Ч������м�����0xffffffff,�������Ч*/ 
    DWORD   dwMaxEnablePtzCtrlNun; //�������õ���̨��������(ֻ��)
    DWORD   dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ
    BYTE    byPresetDurationTime[MAX_CHANNUM_V40];//Ԥ�õ�ͣ��ʱ�� ��Χ0-20s��Ĭ��10s��
    BYTE    byRes2[4];                    /*����*/
    DWORD   dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ
    DWORD   dwEnablePtzTrackChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ
    WORD   wEventType[NET_SDK_MAX_EVENT_NUM/*64*/]; /*����¼����ͣ�ÿһ��λ��Ӧһ���¼�����*/
    BYTE    byRes[128];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

//���������������(9000��չ)
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* ���� */
    BYTE byAlarmType;                //����������,0������,1������
    BYTE byAlarmInHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byInputType;                //��������  0-��������ʽ  1-�ź�����ʽ    
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byEnablePreset[MAX_CHANNUM_V30];        /* �Ƿ����Ԥ�õ� 0-��,1-��*/
    BYTE byPresetNo[MAX_CHANNUM_V30];            /* ���õ���̨Ԥ�õ����,һ������������Ե��ö��ͨ������̨Ԥ�õ�, 0xff��ʾ������Ԥ�õ㡣*/
    BYTE byRes2[192];                    /*����*/
    BYTE byEnableCruise[MAX_CHANNUM_V30];        /* �Ƿ����Ѳ�� 0-��,1-��*/
    BYTE byCruiseNo[MAX_CHANNUM_V30];            /* Ѳ�� */
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];        /* �Ƿ���ù켣 0-��,1-��*/
    BYTE byPTZTrack[MAX_CHANNUM_V30];            /* ���õ���̨�Ĺ켣��� */
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30, *LPNET_DVR_ALARMINCFG_V30;


typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    /*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ��3���ƶ���⣬4��Ӳ��δ��ʽ��,5-дӲ�̳���,6-�ڵ�������
    7-��ʽ��ƥ��, 8-�Ƿ����ʣ�9-��Ƶ�ź��쳣��10-¼���쳣��11-���ܳ����仯��12-�����쳣��13-ǰ��/¼��ֱ��ʲ�ƥ��, 
    14-���������Դʧ��,15-������ⱨ��, 16-�ȱ��쳣��17-¼������������18-�����Խ����󱨾�,19-��Ƶ��ʧ��20-����¼��
    21-�ر�¼��22-��������㷨�쳣��23-���屨��,24-������Ӳ���쳣,25-��������,26-������ͼƬ���,27-POC�쳣,28-����ӽ��쳣��
    30-ȱ��SD��,32-��̨��ת�쳣*/
    DWORD dwAlarmType;//��������
    NET_DVR_TIME_EX struAlarmTime;    //����������ʱ��
    union
    {
        BYTE    byUnionLen[116];  //�ֳ�ȥ8���ֽ�������չʱ��
        struct
        {
            DWORD    dwAlarmInputNo;        //���������ı�������ͨ���ţ�һ��ֻ��һ��
            DWORD    dwTrigerAlarmOutNum;    /*�����ı���������������ں������䳤���ݲ��������д����ı������ͨ���ţ����ֽڱ�ʾһ��*/
            DWORD    dwTrigerRecordChanNum;    /*������¼��ͨ�����������ں������䳤���ݲ��������д�����¼��ͨ���ţ����ֽڱ�ʾһ��*/
        }struIOAlarm;    // ��������dwAlarmTypeΪ0ʱ��Ч
        struct
        {
            DWORD    dwAlarmChanNum;    /*��������ͨ�����ݸ��������ں������䳤���ݲ��������з����ı���ͨ���ţ����ֽڱ�ʾһ��*/
            DWORD    dwPicLen;//JpegͼƬ����
            BYTE     byPicURL; //ͼƬ���ݲ���URL��ʽ 0-������ͼƬ���ݣ�1-ͼƬ������URL��ʽ
            BYTE    byTarget; /*0-������ʶ��Ŀ�꣬1-ʶ��Ŀ��Ϊ�ˣ�2-ʶ��Ŀ��Ϊ��*/
            BYTE    byRes1[2]; //����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
            char*  pDataBuff; //����ͼƬ����ͼƬURL
#else
            char*   pDataBuff; //����ͼƬ����ͼƬURL	
            BYTE  byRes3[4];
#endif
        }struAlarmChannel;    // dwAlarmTypeΪ2��3��6��9��10��13��28ʱ��Ч
        struct
        {
            DWORD    dwAlarmHardDiskNum;    /*����������Ӳ�����ݳ��ȣ����ں������䳤���ݲ��������з���������Ӳ�̺ţ��Ľڱ�ʾһ��*/
        }struAlarmHardDisk;    // dwAlarmTypeΪ1,4,5ʱ��Ч
        struct
        {
            BYTE       bySubAlarmType;  //���������ͣ�1-һ���ӳ�¼�� 
            BYTE       byRes1[3]; //����
            NET_DVR_TIME_EX  struRecordEndTime; //¼������ʱ��
        }struRecordingHost;  //¼������ר�ñ���
        struct
        {
            float          fVoltageValue;//��Դ��ѹֵ,��λV,��ȷ��0.1
            BYTE       byVoltageAlarmType;  //��Դ��ѹ�������ͣ�0-��Դ��ѹ���ߣ�1-��Դ��ѹ���� 
            BYTE       byRes1[3]; //�����ֽ�
        }struVoltageInstable;  //dwAlarmType=31ʱ��Ч

        struct
        {
            float      fTemperature;//�������¶ȣ���ȷ��С�����1λ
            DWORD      dwCustomInfoLength; //�Զ�����Ϣ����
            BYTE*      pCustomInfo; //�Զ�����Ϣ
            BYTE       byType;  //��̨��ת���� 1-ˮƽ��ת 2-��ֱ��ת
            BYTE       byDeicingEnabled;  // ��̨��������ʹ�� 0-�ر� 1-����
        }struPTLocking;  //��̨��ת�쳣 dwAlarmType=32ʱ��Ч

        struct
        {
            BYTE       byExceptionType;	//�쳣����,0-����, 1- ��־�洢�쳣��2-��־����
        }struLogException;  //dwAlarmType=33ʱ��Ч,��־�쳣��Ϣ

    }uStruAlarm;
    DWORD*  pRes;    //���ڼ���64λ�½ṹ���ֽڲ���������
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    byRes2[5]; //����
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

//�ϴ�������Ϣ(256·NVR��չ)
typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER     struAlarmFixedHeader;    //�����̶�����
    DWORD*                        pAlarmData;    //�����ɱ䲿������
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

//���������������
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* ���� */
    BYTE byAlarmType;    //����������,0������,1������
    BYTE byAlarmInHandle;    /* �Ƿ��� 0-������ 1-����*/
    BYTE byChannel;                 // �������봥������ʶ��ͨ��
    BYTE byRes;                     
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE byRelRecordChan[MAX_CHANNUM]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byEnablePreset[MAX_CHANNUM];        /* �Ƿ����Ԥ�õ� 0-��,1-��*/
    BYTE byPresetNo[MAX_CHANNUM];            /* ���õ���̨Ԥ�õ����,һ������������Ե��ö��ͨ������̨Ԥ�õ�, 0xff��ʾ������Ԥ�õ㡣*/
    BYTE byEnableCruise[MAX_CHANNUM];        /* �Ƿ����Ѳ�� 0-��,1-��*/
    BYTE byCruiseNo[MAX_CHANNUM];            /* Ѳ�� */
    BYTE byEnablePtzTrack[MAX_CHANNUM];        /* �Ƿ���ù켣 0-��,1-��*/
    BYTE byPTZTrack[MAX_CHANNUM];            /* ���õ���̨�Ĺ켣��� */
}NET_DVR_ALARMINCFG, *LPNET_DVR_ALARMINCFG;

//ģ�ⱨ�������������
typedef struct
{
    DWORD     dwSize;
    BYTE        byEnableAlarmHandle; //����������
    BYTE        byRes1[3];
    BYTE        byAlarmInName[NAME_LEN]; //ģ�ⱨ����������
    WORD        wAlarmInUpper; //ģ�������ѹ���ޣ�ʵ��ֵ��10����Χ0~360
    WORD        wAlarmInLower; //ģ�������ѹ���ޣ�ʵ��ֵ��10����Χ0~360 
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */ 
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    BYTE        byRelRecordChan[MAX_CHANNUM_V30]; //��������¼��ͨ��
    BYTE        byRes2[100];
}NET_DVR_ANALOG_ALARMINCFG, *LPNET_DVR_ANALOG_ALARMINCFG;

//�ϴ�������Ϣ(9000��չ)
typedef struct 
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣,
                      10-¼���쳣,11- ���ܳ����仯,12-�����쳣,13-ǰ��/¼��ֱ��ʲ�ƥ��,14-���������Դʧ��,15-�������, 16-POE�����쳣����,17-������쳣,
    18-�����������쳣����,19-��Ƶ��ʧ��20-����¼��21-�ر�¼��22-��������㷨�쳣��23-���屨��,24-������Ӳ���쳣,25-��������,26-������ͼƬ���,27-POC�쳣
    28-����ӽ��쳣,29-�����ͣ�30-ȱ��SD��*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*����������˿ڣ�Ϊ1��ʾ��Ӧ���*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*������¼��ͨ����Ϊ1��ʾ��Ӧ¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmTypeΪ2��3,6,9,10,14,19,28ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]��Ӧ��1��Ӳ��*/
    #ifdef SDK_CHEZAI
    NET_DVR_ADDIT_POSITION GPS_pos;  /* GPS��λ��Ϣ */
    #endif
}NET_DVR_ALARMINFO_V30, *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;   //�ṹ��
    DWORD  dwExceptionCase;   //����ԭ��   0-�����쳣
    NET_DVR_IPADDR  struDeviceIP;    //�����쳣���豸IP��ַ
    BYTE    byRes[256];         //����
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct 
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*����������˿ڣ���һλΪ1��ʾ��Ӧ��һ�����*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*������¼��ͨ������һλΪ1��ʾ��Ӧ��һ·¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmTypeΪ2��3,6,9,10ʱ����ʾ�ĸ�ͨ����dwChannel[0]λ��Ӧ��1��ͨ��*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]λ��Ӧ��1��Ӳ��*/
}NET_DVR_ALARMINFO, *LPNET_DVR_ALARMINFO;

//////////////////////////////////////////////////////////////////////////////////////
//IPC�����������
/* IP�豸�ṹ */
typedef struct 
{
    DWORD dwEnable;                    /* ��IP�豸�Ƿ����� */
    BYTE sUserName[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */ 
    NET_DVR_IPADDR struIP;            /* IP��ַ */
    WORD wDVRPort;                     /* �˿ں� */
    BYTE byRes[34];                /* ���� */
}NET_DVR_IPDEVINFO, *LPNET_DVR_IPDEVINFO;

#define  DEV_ID_LEN           32    //�豸ID����

//ipc�����豸��Ϣ��չ��֧��ip�豸���������
typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;                    //��IP�豸�Ƿ���Ч
    BYTE byProType;                    //Э�����ͣ�0-˽��Э�飬1-����Э�飬2-����
    BYTE byEnableQuickAdd;        // 0 ��֧�ֿ������  1 ʹ�ÿ������ 
    // ���������Ҫ�豸IP��Э�����ͣ�������Ϣ���豸Ĭ��ָ��
    BYTE byCameraType;    //ͨ�������������ͣ�ֵΪ 0-�����壬1-��ʦ���٣�2-ѧ�����٣�3-��ʦȫ����4-ѧ��ȫ����5-��ý�壬6�C��ʦ��λ,7-ѧ����λ,8-���鶨λ,9-�������
    BYTE sUserName[NAME_LEN];        //�û���
    BYTE sPassword[PASSWD_LEN];        //����
    BYTE byDomain[MAX_DOMAIN_NAME];    //�豸����
    NET_DVR_IPADDR struIP;            //IP��ַ
    WORD wDVRPort;                     // �˿ں�
    BYTE  szDeviceID[DEV_ID_LEN];  //�豸ID
    BYTE byEnableTiming;  //0-������1-������NVR��IPC�Զ�Уʱ��2-����NVR��IPC�Զ�Уʱ
    BYTE byCertificateValidation;//֤����֤
    // byCertificateValidation:bit0: 0-������֤����֤ 1-����֤����֤
    // byCertificateValidation:bit1: 0-������Ĭ��ͨ�Ŷ˿� 1-����Ĭ��ͨ�Ŷ˿�
}NET_DVR_IPDEVINFO_V31, *LPNET_DVR_IPDEVINFO_V31;

/* IPͨ��ƥ����� */
typedef struct 
{
    BYTE byEnable;                    /* ��ͨ���Ƿ����� */
    BYTE byIPID;                    //IP�豸ID��8λ�����豸IDΪ0ʱ��ʾͨ��������
    BYTE byChannel;                    /* ͨ���� */
    BYTE byIPIDHigh;                // IP�豸ID�ĸ�8λ
    BYTE byTransProtocol;            //����Э������0-TCP/auto(�������豸����)��1-UDP 2-�ಥ 3-��TCP 4-auto
    BYTE byGetStream;         /* �Ƿ�Ը�ͨ��ȡ����0-�ǣ�1-��*/
    BYTE byres[30];                    /* ���� */
} NET_DVR_IPCHANINFO, *LPNET_DVR_IPCHANINFO;

/* IP�������ýṹ */
typedef struct 
{
    DWORD dwSize;                                        /* �ṹ��С */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];    /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-32ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IPͨ�� */    
}NET_DVR_IPPARACFG, *LPNET_DVR_IPPARACFG;
/* ��չIP�������ýṹ */
typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;                                        /* �ṹ��С */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];    /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-32ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IPͨ�� */    
}NET_DVR_IPPARACFG_V31, *LPNET_DVR_IPPARACFG_V31;

typedef  struct tagNET_DVR_IPSERVER_STREAM
{
    BYTE    byEnable;   // �Ƿ�����
    BYTE    byRes[3];               // �����ֽ�
    NET_DVR_IPADDR struIPServer;    //IPServer ��ַ
    WORD    wPort;                  //IPServer �˿�
    WORD    wDvrNameLen;            // DVR ���Ƴ���
    BYTE    byDVRName[NAME_LEN];    // DVR����
    WORD    wDVRSerialLen;          // ���кų���
    WORD    byRes1[2];              // �����ֽ�
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR���кų���
    BYTE    byUserName[NAME_LEN];   // DVR ��½�û���
    BYTE    byPassWord[PASSWD_LEN]; // DVR��½����
    BYTE    byChannel;              // DVR ͨ��
    BYTE    byRes2[11];             //  �����ֽ�
}NET_DVR_IPSERVER_STREAM, *LPNET_DVR_IPSERVER_STREAM;

//��ý���������������
typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE    byValid;            /*�Ƿ����*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR  struDevIP;      
    WORD    wDevPort;            /*��ý��������˿�*/    
    BYTE    byTransmitType;        /*����Э������ 0-TCP��1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

//�豸ͨ����Ϣ
typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP��ַ
    WORD     wDVRPort;                 //�˿ں�
    BYTE     byChannel;                //ͨ����
    BYTE    byTransProtocol;        //����Э������0-TCP��1-UDP
    BYTE    byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE    byFactoryType;            /*ǰ���豸��������,ͨ���ӿڻ�ȡ*/
    BYTE    byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ������Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE    bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã���������������ݸò������������Դ
    BYTE    byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];    //�豸����
    BYTE    sUserName[NAME_LEN];    //���������½�ʺ�
    BYTE    sPassword[PASSWD_LEN];    //�����������
}NET_DVR_DEV_CHAN_INFO,*LPNET_DVR_DEV_CHAN_INFO;

//ֱ��ͨ����ý��ȡ��
typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD                                dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG,*LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   // �Ƿ�����
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;            //��ý���������ַ
    WORD   wStreamServerPort;           //��ý��������˿�   
    BYTE   byStreamServerTransmitType;  //��ý�崫��Э������ 0-TCP��1-UDP
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;          //IPSERVER��ַ
    WORD   wIPServerPort;        //IPserver�˿ں�
    BYTE   byRes3[2];           
    BYTE   sDVRName[NAME_LEN];   //DVR����
    WORD   wDVRNameLen;            // DVR���Ƴ���
    WORD   wDVRSerialLen;          // ���кų���
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    // DVR���к�
    BYTE   sUserName[NAME_LEN];   // DVR ��½�û���
    BYTE   sPassWord[PASSWD_LEN]; // DVR��½����
    WORD   wDVRPort;   //DVR�˿ں�
    BYTE   byRes4[2];    
    BYTE   byChannel;              // DVR ͨ��
    BYTE   byTransProtocol; //����Э������0-TCP��1-UDP
    BYTE   byTransMode; //��������ģʽ 0�������� 1��������
    BYTE   byFactoryType; //ǰ���豸��������,ͨ���ӿڻ�ȡ
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

#define URL_LEN     240   //URL����
typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable; 
    BYTE    strURL[URL_LEN];
    BYTE    byTransPortocol ; // ����Э������ 0-tcp  1-UDP
    WORD    wIPID;  //�豸ID�ţ�wIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE    byChannel;  //ͨ����
    BYTE    byRes[7];   
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;                 // �Ƿ�����
    BYTE    byRes[3];               // �����ֽ�
    BYTE    byDDNSDomain[64];        // hiDDNS������
    WORD    wPort;                  // hiDDNS �˿�
    WORD    wAliasLen;              // ��������
    BYTE    byAlias[NAME_LEN];         // ����
    WORD    wDVRSerialLen;          // ���кų���
    BYTE    byRes1[2];              // �����ֽ�
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR���к�
    BYTE    byUserName[NAME_LEN];   // DVR ��½�û���
    BYTE    byPassWord[PASSWD_LEN]; // DVR��½����
    BYTE    byChannel;              // DVRͨ��
    BYTE    byRes2[11];             // ������    
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;                /* ��ͨ���Ƿ����� */
    BYTE    byRes1;
    WORD    wIPID;                  //IP�豸ID
    DWORD     dwChannel;                //ͨ����
    BYTE    byTransProtocol;        //����Э������0-TCP��1-UDP��2- �ಥ��3-RTSP��0xff- auto(�Զ�)
    BYTE    byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE    byFactoryType;            /*ǰ���豸��������,ͨ���ӿڻ�ȡ*/
    BYTE    byRes;
    BYTE    strURL[URL_LEN/*240*/];   /*RTSPЭ��ȡ��URL ����RTSPЭ��ʱ��Ч��*/
}NET_DVR_IPCHANINFO_V40,*LPNET_DVR_IPCHANINFO_V40;

// ��ŵCVR
#define MAX_ID_COUNT    256
#define MAX_STREAM_ID_COUNT    1024
#define STREAM_ID_LEN   32
#define PLAN_ID_LEN  32
#define DEVICE_NO_LEN  24
#define MAX_VOLUMENAME_LEN 32  //¼�������
#define MAX_VAG_CHANNO_LEN  32  //VAGЭ��ȡ��ʱͨ���ű��볤��

#define MAX_STREAM_ID_NUM    30        //�����ID��Ŀ

// ����Ϣ - 72�ֽڳ�
typedef struct tagNET_DVR_STREAM_INFO 
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID����
    DWORD dwChannel;                //�����豸ͨ��������0xffffffffʱ����ʾ������
    BYTE  byRes[32];                //����
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{ 
    BYTE    byEnable;
    BYTE    byLocalBackUp; //�Ƿ񱾵ر��� 
    BYTE    byRes[2]; 
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;   //Э������
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //ǰ��IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD    wPort;
    BYTE    byRes1[122];             //����
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;

typedef union tagNET_DVR_GET_STREAM_UNION
{
    NET_DVR_IPCHANINFO      struChanInfo;    /*IPͨ����Ϣ*/
    NET_DVR_IPSERVER_STREAM struIPServerStream;  // IPServerȥ��
    NET_DVR_PU_STREAM_CFG   struPUStream;     //  ͨ��ǰ���豸��ȡ��ý��ȥ��
    NET_DVR_DDNS_STREAM_CFG struDDNSStream;     //ͨ��IPServer����ý��ȡ��
    NET_DVR_PU_STREAM_URL   struStreamUrl;        //ͨ����ý�嵽urlȡ��
    NET_DVR_HKDDNS_STREAM    struHkDDNSStream;   //ͨ��hiDDNSȥȡ��
    NET_DVR_IPCHANINFO_V40 struIPChan; //ֱ�Ӵ��豸ȡ������չ��
}NET_DVR_GET_STREAM_UNION, *LPNET_DVR_GET_STREAM_UNION;

typedef enum
{
    NET_SDK_IP_DEVICE = 0,
        NET_SDK_STREAM_MEDIA,
        NET_SDK_IPSERVER,
        NET_SDK_DDNS_STREAM_CFG,
        NET_SDK_STREAM_MEDIA_URL,
        NET_SDK_HKDDNS,
        NET_SDK_IP_DEVICE_ADV,
        NET_SDK_IP_DEVICE_V40, 
        NET_SDK_RTSP  
}GET_STREAM_TYPE;

typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //ȡ����ʽGET_STREAM_TYPE��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��,3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸����
    //4-ͨ����ý����URLȥȡ��,5-ͨ��hkDDNSȡ����6-ֱ�Ӵ��豸ȡ��(��չ)��ʹ��NET_DVR_IPCHANINFO_V40�ṹ, 7-ͨ��RTSPЭ�鷽ʽ����ȡ��
    BYTE    byRes[3];        //�����ֽ�
    NET_DVR_GET_STREAM_UNION uGetStream;    // ��ͬȡ����ʽ�ṹ��
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;

//��չIP���������豸
typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;                            /* �ṹ��С */
    DWORD       dwGroupNum;                    //     �豸֧�ֵ�������    
    DWORD      dwAChanNum;                    //���ģ��ͨ������
    DWORD      dwDChanNum;                  //����ͨ������
    DWORD      dwStartDChan;                    //��ʼ����ͨ��
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    /* ģ��ͨ���Ƿ����ã��ӵ͵��߱�ʾ1-64ͨ����0��ʾ��Ч 1��Ч */
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      /* IP�豸 */
    NET_DVR_STREAM_MODE  struStreamMode[MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 // �����ֽ�
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;


//ΪCVR��չ�ı�������
typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;  //0-������(ͨ��)�ź���������1-˽�о���𻵣�2- NVR�����˳���
    //3-������״̬�쳣��4-ϵͳʱ���쳣��5-¼���ʣ���������ͣ�
    //6-������(ͨ��)�ƶ���ⱨ����7-������(ͨ��)�ڵ���������8-¼��ʧ����; 9-��Ƶʵʱ��ⱨ��; 10-��Դʹ���ʸ澯; 11- CVR�Զ��޸��쳣�� 12-¼���쳣
    NET_DVR_TIME   struTime;     //����ʱ��
    BYTE       byRes[32];    //����
    DWORD      dwNumber;     //��Ŀ
    WORD       *pNO;         //dwNumber��WORD; ÿ��WORD��ʾһ��ͨ���ţ����ߴ��̺�, ��ЧʱΪ0
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

/* ����������� */
typedef struct 
{
    BYTE byIPID;                    /* IP�豸IDȡֵ1- MAX_IP_DEVICE */
    BYTE byAlarmOut;                /* ��������� */
    BYTE byRes[18];                    /* ���� */
}NET_DVR_IPALARMOUTINFO, *LPNET_DVR_IPALARMOUTINFO;

/* IP����������ýṹ */
typedef struct 
{
    DWORD dwSize;                                    /* �ṹ��С */    
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];/* IP������� */
}NET_DVR_IPALARMOUTCFG, *LPNET_DVR_IPALARMOUTCFG;

/* IP����������� */
typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;                    /* IP�豸ID */
    DWORD dwAlarmOut;                /* IP�豸ID��Ӧ�ı�������� */
    BYTE  byRes[32];                /* ���� */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;/*�����������*/

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;  //�ṹ�峤��
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];/*IP�������*/
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40; /*IP�������*/

/* ����������� */
typedef struct 
{
    BYTE byIPID;                    /* IP�豸IDȡֵ1- MAX_IP_DEVICE */
    BYTE byAlarmIn;                    /* ��������� */
    BYTE byRes[18];                    /* ���� */
}NET_DVR_IPALARMININFO, *LPNET_DVR_IPALARMININFO;

/* IP�����������ýṹ */
typedef struct 
{
    DWORD dwSize;                                    /* �ṹ��С */    
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];/* IP�������� */
}NET_DVR_IPALARMINCFG, *LPNET_DVR_IPALARMINCFG;

/* IP����������� */
typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;                    /* IP�豸ID */
    DWORD dwAlarmIn;                /* IP�豸ID��Ӧ�ı�������� */
    BYTE  byRes[32];                /* ���� */
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;   /* ����������� */

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;  //�ṹ�峤��
    DWORD   dwCurIPAlarmInNum;  //��ǰ�����������
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];/* IP��������*/
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40; /*IP����������Դ*/

//ipc alarm info
typedef struct tagNET_DVR_IPALARMINFO
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];            /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */
}NET_DVR_IPALARMINFO, *LPNET_DVR_IPALARMINFO;

//ipc���øı䱨����Ϣ��չ 9000_1.1
typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];            /* IP�豸 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */   
}NET_DVR_IPALARMINFO_V31, *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];           // IP�豸
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];           /* ģ��ͨ���Ƿ����ã�0-δ���� 1-���� */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];            /* IPͨ�� */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP�������� */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP������� */   
    BYTE                    byRes[20];                          // �����ֽ�
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;

typedef enum _HD_STAT_
{
    HD_STAT_OK                    =    0,    /* ���� */
        HD_STAT_UNFORMATTED            =    1,    /* δ��ʽ�� */
        HD_STAT_ERROR               =    2,    /* ���� */
        HD_STAT_SMART_FAILED        =    3,    /* SMART״̬ */
        HD_STAT_MISMATCH            =    4,    /* ��ƥ�� */
        HD_STAT_IDLE                =    5,    /* ����*/
        NET_HD_STAT_OFFLINE         =    6,    /* �����̴���δ����״̬ */
        HD_RIADVD_EXPAND            =   7,    /* ������̿����� */
        HD_STAT_REPARING            =   10,   /* Ӳ�������޸�(9000 2.0) */
        HD_STAT_FORMATING           =   11,   /* Ӳ�����ڸ�ʽ��(9000 2.0) */ 
}HD_STAT;


//����Ӳ����Ϣ����
typedef struct
{
    DWORD dwHDNo;         /*Ӳ�̺�, ȡֵ0~MAX_DISKNUM_V30-1*/
    DWORD dwCapacity;     /*Ӳ������(��������)*/
    DWORD dwFreeSpace;    /*Ӳ��ʣ��ռ�(��������)*/
    DWORD dwHdStatus;     //Ӳ��״̬(��������) HD_STAT 0-����, 1-δ��ʽ��, 2-����, 3-SMART״̬, 
    //4-��ƥ��, 5-���� 6-����Ӳ�̲����� 7-������̿����� 10-Ӳ�������޸�
    //11-Ӳ�����ڸ�ʽ�� 12-Ӳ�����ڵȴ���ʽ�� 13-Ӳ����ж�� 14-����Ӳ�̲�����
    //15-����ɾ��(����Ӳ��),16-������
    BYTE  byHDAttr;       /*0-��ͨ, 1-����; 2-ֻ�� 3-�浵��CVRר�ã���4-���ɶ�д*/
    BYTE  byHDType;          /*0-����Ӳ��,1-ESATAӲ��,2-NASӲ��,3-iSCSIӲ�� 4-Array�������,5-SD��,6-minSAS*/
    BYTE  byDiskDriver;   // ֵ ������ASCII�ַ� 
    BYTE  byRes1;
    DWORD dwHdGroup;      /*�����ĸ����� 1-MAX_HD_GROUP*/
    BYTE  byRecycling;   // �Ƿ�ѭ������ 0����ѭ�����ã�1��ѭ������
    BYTE  bySupportFormatType;    /*��ǰӲ����֧�ֵĸ�ʽ������,ֻ������ǰ�ýڵ��֧��byHDType=5(SD��)ʱ;
                                  ��bySupportFormatType=0,������豸���������Ĭ����������ʽ��Ӳ��;
                                  bySupportFormatType:bit0: 0-����֧��FAT32��ʽ������,1-����֧��;
                                  bySupportFormatType:bit1: 0-����֧��EXT4��ʽ������,1-����֧��;*/
    BYTE  byFormatType;         /*��ǰӲ�̸�ʽ����������: 0-�豸Ĭ�ϸ�ʽ������,1-ָ��FAT32��ʽ��(byHDType=5(SD��)ʱ��Ч),
                                2-ָ��EXT4��ʽ��(byHDType=5(SD��)ʱ��Ч)*/
    BYTE  byRes2;
    DWORD  dwStorageType;    //��λ��ʾ 0-��֧�� ��0-֧��
    // dwStorageType & 0x1 ��ʾ�Ƿ�����ͨ¼��ר�ô洢��     
    // dwStorageType & 0x2  ��ʾ�Ƿ��ǳ�֡¼��ר�ô洢��
    // dwStorageType & 0x4 ��ʾ�Ƿ���ͼƬ¼��ר�ô洢��
    
    DWORD dwPictureCapacity; //Ӳ��ͼƬ����(��������)����λ:MB
    DWORD dwFreePictureSpace; //ʣ��ͼƬ�ռ�(��������)����λ:MB
    BYTE  byRes3[104];
}NET_DVR_SINGLE_HD, *LPNET_DVR_SINGLE_HD;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;          /*Ӳ����(��������)*/
    NET_DVR_SINGLE_HD struHDInfo[MAX_DISKNUM_V30];//Ӳ����ز�������Ҫ����������Ч��
}NET_DVR_HDCFG, *LPNET_DVR_HDCFG;

//����Ӳ����Ϣ����
typedef struct
{
    DWORD dwHDNo;         /*Ӳ�̺�, ȡֵ0~MAX_DISKNUM_V30-1*/
    DWORD dwCapacity;     /*Ӳ������(��������)*/
    DWORD dwFreeSpace;    /*Ӳ��ʣ��ռ�(��������)*/
    DWORD dwHdStatus;     //Ӳ��״̬(��������) HD_STAT 0-����, 1-δ��ʽ��, 2-����, 3-SMART״̬, 
    //4-��ƥ��, 5-���� 6-����Ӳ�̲����� 7-������̿����� 10-Ӳ�������޸�
    //11-Ӳ�����ڸ�ʽ�� 12-Ӳ�����ڵȴ���ʽ�� 13-Ӳ����ж�� 14-����Ӳ�̲�����
    //15-����ɾ��(����Ӳ��),16-������,17-���棨��ʱ���ɻ��̣�,18-���̣��Ѿ��𻵵�Ӳ�̣�,19-�����̣������쳣���߳����У�������ֻ�������,20-δ��֤��δ��⣬��Ҫ��CVR�жԴ��̽��м�⣩
    //21-δ��¼�������и�ʽ��
    BYTE  byHDAttr;       /*0-��ͨ, 1-����; 2-ֻ����3-�浵��4-���ɶ�д*/
    BYTE  byHDType;          /*0-����Ӳ��,1-ESATAӲ��,2-NASӲ��,3-iSCSIӲ�� 4-Array�������,5-SD��,6-minSAS*/
    BYTE  byDiskDriver;   // ֵ ������ASCII�ַ� 
    BYTE  byGenusGruop;  //���飺0-������1-���У�2-�洢�أ�3-�������̣�4-δ��ʼ����5-��Ч�̣�6-�����ȱ���7-ȫ���ȱ���ֻ��
    DWORD dwHdGroup;      /*�����ĸ����� 1-MAX_HD_GROUP*/
    BYTE  byRecycling;   // �Ƿ�ѭ������ 0����ѭ�����ã�1��ѭ������
    BYTE  bySupportFormatType;    /*��ǰӲ����֧�ֵĸ�ʽ������,ֻ������ǰ�ýڵ��֧��byHDType=5(SD��)ʱ;
                                  ��bySupportFormatType=0,������豸���������Ĭ����������ʽ��Ӳ��;
                                  bySupportFormatType:bit0: 0-����֧��FAT32��ʽ������,1-����֧��;
                                  bySupportFormatType:bit1: 0-����֧��EXT4��ʽ������,1-����֧��;*/
    BYTE  byFormatType;         /*��ǰӲ�̸�ʽ����������: 0-�豸Ĭ�ϸ�ʽ������,1-ָ��FAT32��ʽ��(byHDType=5(SD��)ʱ��Ч),
                                2-ָ��EXT4��ʽ��(byHDType=5(SD��)ʱ��Ч)*/
    BYTE  byRes2;
    DWORD  dwStorageType;    //��λ��ʾ 0-��֧�� ��0-֧��
    // dwStorageType & 0x1 ��ʾ�Ƿ�����ͨ¼��ר�ô洢��     
    // dwStorageType & 0x2  ��ʾ�Ƿ��ǳ�֡¼��ר�ô洢��
    // dwStorageType & 0x4 ��ʾ�Ƿ���ͼƬ¼��ר�ô洢��

    DWORD dwPictureCapacity; //Ӳ��ͼƬ����(��������)����λ:MB
    DWORD dwFreePictureSpace; //ʣ��ͼƬ�ռ�(��������)����λ:MB
    BYTE  byDiskLocation[NET_SDK_DISK_LOCATION_LEN/*16*/];//Ӳ��λ�ã������ʽ����ע��ֻ��
    BYTE  bySupplierName[NET_SDK_SUPPLIER_NAME_LEN/*32*/];//��Ӧ�����ƣ�ֻ��
    BYTE  byDiskModel[NET_SDK_DISK_MODEL_LEN /*64*/];//Ӳ���ͺţ�ֻ��
    char  szHDLocateIP[SDK_MAX_IP_LEN];//��������IP��Ϣ
    BYTE  byRes3[80];
}NET_DVR_SINGLE_HD_V50, *LPNET_DVR_SINGLE_HD_V50;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDCount;          /*Ӳ����(��������)*/
    NET_DVR_SINGLE_HD_V50 struHDInfoV50[MAX_DISKNUM_V30];//Ӳ����ز�������Ҫ����������Ч��
    BYTE  byRes[128];
}NET_DVR_HDCFG_V50, *LPNET_DVR_HDCFG_V50;

typedef struct tagNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO
{
    DWORD  dwSize;
    BYTE  byHDVolumeNo;      /*Ӳ�̾�ID(��������)*/
    BYTE  byType;       /*Ӳ�̾�����:0-¼������ڱ���¼�񣩣�1-�浵�����ڴ浵¼���·�¼��ƻ�ʱ�����ܹ����浵��,
                        2-�ļ���ֻ���ڴ洢�ͻ����ϴ����ļ����·�¼��ƻ�ʱ�����ܹ����ļ�����Ҫ���˵���3-ͼƬ��ֻ���ڴ洢�ͻ����ϴ���ͼƬ��*/
    BYTE  byRes1[2];
    DWORD  dwCapacity;     /*Ӳ�̾���������λMB(��������)*/
    DWORD  dwFreeSpace;    /*Ӳ�̾�ʣ��ռ䣬��λMB(��������) */
    BYTE  byHDVolumeName[NET_SDK_DISK_VOLUME_LEN/*36*/];  /*Ӳ�̾�����(��������)*/
    BYTE  byLoopCover;    /*�Ƿ�ѭ�����ǣ�0-��ѭ�����ǣ�1-ѭ�����ǣ�Ӳ�̾�����֮��ѭ���������ϵ�¼��*/
    BYTE  byRes[63];
}NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO, *LPNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO;

typedef struct tagNET_DVR_HARD_DISK_VOLUME_INFO
{
    DWORD  dwSize;
    DWORD  dwHDVolumeCount;      /*��ǰӲ�̾�����(��������)*/
    NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO struSingleVolumeInfo[NET_SDK_MAX_DISK_VOLUME/*33*/];    /*����Ӳ�̾���Ϣ*/
    BYTE  byRes[128];
}NET_DVR_HARD_DISK_VOLUME_INFO, *LPNET_DVR_HARD_DISK_VOLUME_INFO;

//����������Ϣ������չ
typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD     dwHDGroupNo;       /*�����(��������) 1-MAX_HD_GROUP*/        
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40];  //������¼��ͨ������ֵ��ʾ������0xffffffffʱ������Ϊ��Ч     
    BYTE       byRes[64];                /* ���� */
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD      dwSize;                //�ṹ���С
    DWORD     dwMaxHDGroupNum;           //�豸֧�ֵ����������-ֻ��
    DWORD     dwCurHDGroupNum;       /*��ǰ���õ�������*/
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //Ӳ����ز�������Ҫ����������Ч��
    BYTE       byRes[128]; //����
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;

//����������Ϣ����
typedef struct
{
    DWORD dwHDGroupNo;       /*�����(��������) 1-MAX_HD_GROUP*/        
    BYTE byHDGroupChans[MAX_CHANNUM_V30]; /*�����Ӧ��¼��ͨ��, 0-��ʾ��ͨ����¼�󵽸����飬1-��ʾ¼�󵽸�����*/
    BYTE byRes[8];
}NET_DVR_SINGLE_HDGROUP, *LPNET_DVR_SINGLE_HDGROUP;

typedef struct
{
    DWORD dwSize;
    DWORD dwHDGroupCount;        /*��������(��������)*/
    NET_DVR_SINGLE_HDGROUP struHDGroupAttr[MAX_HD_GROUP];//Ӳ����ز�������Ҫ����������Ч��
}NET_DVR_HDGROUP_CFG, *LPNET_DVR_HDGROUP_CFG;


//�������Ų����Ľṹ
typedef struct
{
    DWORD dwSize;
    DWORD dwMajorScale;    /* ����ʾ 0-�����ţ�1-����*/
    DWORD dwMinorScale;    /* ����ʾ 0-�����ţ�1-����*/
    DWORD dwRes[2];
}NET_DVR_SCALECFG, *LPNET_DVR_SCALECFG;



//DVR�������(9000��չ)
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* ���� */
    DWORD dwAlarmOutDelay;    /* �������ʱ��(-1Ϊ���ޣ��ֶ��ر�) */
    //0-5��,1-10��,2-30��,3-1����,4-2����,5-5����,6-10����,7-�ֶ�,8-1��,9-2��,10-3��,11-4��
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30];/* �����������ʱ��� */
    BYTE byAlarmOutHandle;            /* �Ƿ��� 0-���� 1-������*/
    BYTE byNormalSatus;            /* ��̬ 0-���� 1-����*/
    BYTE byRes[14];
}NET_DVR_ALARMOUTCFG_V30, *LPNET_DVR_ALARMOUTCFG_V30;

//DVR�������
typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* ���� */
    DWORD dwAlarmOutDelay;    /* �������ʱ��(-1Ϊ���ޣ��ֶ��ر�) */
    //0-5��,1-10��,2-30��,3-1����,4-2����,5-5����,6-10����,7-�ֶ�, 8-1��, 9-3��
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];/* �����������ʱ��� */
}NET_DVR_ALARMOUTCFG, *LPNET_DVR_ALARMOUTCFG;

//DVR����Ԥ������(9000��չ)
/*�л���ָ�ڵ�ǰԤ��ģʽ���л���ʾ���棬�������л�Ԥ��ģʽ������byPreviewNumberΪ0��1���棩��bySwitchSeq[0][0] = 1,bySwitchSeq[0][1] = 2,bySwitchSeq[0][2] = 3 
�򱾵ػ���һֱ��1���棬Ȼ����������水1,2,3ͨ��˳���л�*/
typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//Ԥ��ģʽ,0-1����,1-4����,2-9����,3-16����,0xff:�����
    BYTE byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
    WORD wSwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30];//�л�˳��,���lSwitchSeq[i]Ϊ 0xff��ʾ����
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30, *LPNET_DVR_PREVIEWCFG_V30;

//DVR����Ԥ������
typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16����,0xff:�����
    BYTE byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
    WORD wSwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_WINDOW];//�л�˳��,���lSwitchSeq[i]Ϊ 0xff��ʾ����
}NET_DVR_PREVIEWCFG, *LPNET_DVR_PREVIEWCFG;

//DVR��Ƶ���
typedef struct 
{
    WORD wResolution;                            /* �ֱ��� */
    WORD wFreq;                                    /* ˢ��Ƶ�� */
    DWORD dwBrightness;                            /* ���� */
}NET_DVR_VGAPARA;

/*
* MATRIX��������ṹ
*/
typedef struct
{        
    WORD    wOrder[MAX_ANALOG_CHANNUM];        /* Ԥ��˳��, 0xff��ʾ��Ӧ�Ĵ��ڲ�Ԥ�� */
    WORD    wSwitchTime;                /* Ԥ���л�ʱ�� */
    BYTE    res[14];
}NET_DVR_MATRIXPARA_V30, *LPNET_DVR_MATRIXPARA_V30;

typedef struct 
{
    WORD wDisplayLogo;                        /* ��ʾ��Ƶͨ���� */
    WORD wDisplayOsd;                        /* ��ʾʱ�� */
}NET_DVR_MATRIXPARA;

typedef struct 
{
    BYTE byVideoFormat;                        /* �����ʽ,0-PAL,1-NTSC */
    BYTE byMenuAlphaValue;                    /* �˵��뱳��ͼ��Աȶ� */
    WORD wScreenSaveTime;                    /* ��Ļ����ʱ�� 0-�Ӳ�,1-1����,2-2����,3-5����,4-10����,5-20����,6-30���� */
    WORD wVOffset;                            /* ��Ƶ���ƫ�� */
    WORD wBrightness;                        /* ��Ƶ������� */
    BYTE byStartMode;                        /* ��������Ƶ���ģʽ(0:�˵�,1:Ԥ��)*/
    BYTE byEnableScaler;                    /* �Ƿ��������� (0-������, 1-����)*/
}NET_DVR_VOOUT;

//DVR��Ƶ���(9000��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];    /* VGA���� */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];        /* MATRIX���� */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30, *LPNET_DVR_VIDEOOUT_V30;

//DVR��Ƶ���
typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];    /* VGA���� */
    NET_DVR_MATRIXPARA struMatrixPara;        /* MATRIX���� */
}NET_DVR_VIDEOOUT, *LPNET_DVR_VIDEOOUT;


//���û�����(�ӽṹ)(��չ)
typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE    sUserName[NAME_LEN];            /* �û���ֻ����16�ֽ� */
    BYTE    sPassword[PASSWD_LEN];            /* ���� */
    BYTE    byLocalRight[MAX_RIGHT];    /* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */    
    BYTE    byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */    
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/    
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */    
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* Զ�̿���Ԥ����ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* ���ؿ���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* Զ�̿���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* ���ؿ��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* Զ�̿��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* ���ؿ���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* Զ�̿���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* ���ر���Ȩ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    NET_DVR_IPADDR    struUserIP;                /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE     byMACAddr[MACADDR_LEN];    /* �����ַ */
    BYTE     byPriority;                /* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
                                        /* �ޡ�����ʾ��֧�����ȼ�������
                                        �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��
                                        ״̬,���غ�Զ�̹ػ�/����
                                        �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�
                                        Զ�̻ط�,�����Խ���Զ��Ԥ�������ر���,����/Զ�̹ػ�/����
    �ߡ�������Ա */
    BYTE    byAlarmOnRight;         // ��������ڲ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byAlarmOffRight;         // ��������ڳ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byBypassRight;           // �����������·Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ�� 
    BYTE    byRes1[2];               //���ֽڶ���
    BYTE    byPublishRight[MAX_RIGHT];  //��Ϣ����ר��Ȩ��
    /*����0: �ز����Ȩ��*/
    /*����1: ��Ŀ���Ȩ��*/
    /*����2: �ճ����Ȩ��*/
    /*����3: �ϴ��ز�Ȩ��*/
    /*����4: �½���ĿȨ��*/
    /*����5: �½��ճ�Ȩ��*/
    /*����6: ��Ϣ����Ȩ��*/
    /*����7: �ն˹���Ȩ��*/
    /*����8: ��ҵ����Ȩ��*/    
    BYTE    byRes[84];    
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;

//���û�����(�ӽṹ)(��չ)
typedef struct tagNET_DVR_USER_INFO_V51
{
    BYTE    sUserName[NAME_LEN/*32*/];            /* �û���ֻ����16�ֽ� */
    BYTE    sPassword[PASSWD_LEN/*16*/];            /* ���� */
    BYTE    byLocalRight[MAX_RIGHT/*32*/];    /* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */
    /*����10: ����Ԥ�� */
    BYTE    byRemoteRight[MAX_RIGHT/*32*/];/* Զ��Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿���Ԥ����ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40/*512*/];                /* ���ؿ���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40/*512*/];                /* Զ�̿���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40/*512*/];            /* ���ر���Ȩ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* ����Ԥ��Ȩ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    NET_DVR_IPADDR    struUserIP;                /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE     byMACAddr[MACADDR_LEN/*6*/];    /* �����ַ */
    BYTE     byPriority;                /* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
    /* �ޡ�����ʾ��֧�����ȼ�������
    �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��
    ״̬,���غ�Զ�̹ػ�/����
    �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�
    Զ�̻ط�,�����Խ���Զ��Ԥ�������ر���,����/Զ�̹ػ�/�����ߡ�������Ա */
    BYTE    byAlarmOnRight;         // ��������ڲ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byAlarmOffRight;         // ��������ڳ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byBypassRight;           // �����������·Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ�� 
    BYTE    byRes1[2];               //���ֽڶ���
    BYTE    byPublishRight[MAX_RIGHT/*32*/];  //��Ϣ����ר��Ȩ��
    /*����0: �ز����Ȩ��*/
    /*����1: ��Ŀ���Ȩ��*/
    /*����2: �ճ����Ȩ��*/
    /*����3: �ϴ��ز�Ȩ��*/
    /*����4: �½���ĿȨ��*/
    /*����5: �½��ճ�Ȩ��*/
    /*����6: ��Ϣ����Ȩ��*/
    /*����7: �ն˹���Ȩ��*/
    /*����8: ��ҵ����Ȩ��*/
    DWORD    dwPasswordValidity;   //������Ч��,������Ա�û������޸�,��λ���죬��0��ʾ������Ч
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //��������
    BYTE    byUserOperateType;    //�û��������ͣ�1-�����û���2-�����û���3-�����û�+�����û�
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V51, *LPNET_DVR_USER_INFO_V51;

typedef struct  tagNET_DVR_USER_V51
{
    DWORD dwSize;  //�ṹ���С
    DWORD dwMaxUserNum; //�豸֧�ֵ�����û���-ֻ��
    NET_DVR_USER_INFO_V51 struUser[MAX_USERNUM_V30/*32*/];  /* �û����� */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* ��½����ȷ�� */
    BYTE     byRes[240]; //����
}NET_DVR_USER_V51, *LPNET_DVR_USER_V51;

//���û�����(�ӽṹ)(��չ)
typedef struct tagNET_DVR_USER_INFO_V52
{
    BYTE    sUserName[NAME_LEN/*32*/];            /* �û���ֻ����16�ֽ� */
    BYTE    sPassword[PASSWD_LEN/*16*/];            /* ���� */
    BYTE    byLocalRight[MAX_RIGHT/*32*/];    /* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */
    /*����10: ����Ԥ�� */
    BYTE    byRemoteRight[MAX_RIGHT/*32*/];/* Զ��Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿���Ԥ����ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿���¼���ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿��Իطŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40/*512*/];                /* ���ؿ���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40/*512*/];                /* Զ�̿���PTZ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40/*512*/];            /* ���ر���Ȩ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* ����Ԥ��Ȩ��ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ��Զ�����֤�طŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwLocalDoubleVerificationBackupRight[MAX_CHANNUM_V40/*512*/];            /* ���ؿ��Զ�����֤���ݵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    DWORD    dwNetDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* Զ�̿��Զ�����֤�طŵ�ͨ������ǰ����˳�����У�����0xffffffff������Ϊ��Ч*/
    NET_DVR_IPADDR    struUserIP;                /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE     byMACAddr[MACADDR_LEN/*6*/];    /* �����ַ */
    BYTE     byPriority;                /* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
    /* �ޡ�����ʾ��֧�����ȼ�������
    �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��
    ״̬,���غ�Զ�̹ػ�/����
    �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�
    Զ�̻ط�,�����Խ���Զ��Ԥ�������ر���,����/Զ�̹ػ�/�����ߡ�������Ա */
    BYTE    byAlarmOnRight;         // ��������ڲ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byAlarmOffRight;         // ��������ڳ���Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byBypassRight;           // �����������·Ȩ�� 1-��Ȩ�ޣ�0-��Ȩ�� 
    BYTE    byRes1[2];               //���ֽڶ���
    BYTE    byPublishRight[MAX_RIGHT/*32*/];  //��Ϣ����ר��Ȩ��
    /*����0: �ز����Ȩ��*/
    /*����1: ��Ŀ���Ȩ��*/
    /*����2: �ճ����Ȩ��*/
    /*����3: �ϴ��ز�Ȩ��*/
    /*����4: �½���ĿȨ��*/
    /*����5: �½��ճ�Ȩ��*/
    /*����6: ��Ϣ����Ȩ��*/
    /*����7: �ն˹���Ȩ��*/
    /*����8: ��ҵ����Ȩ��*/
    DWORD    dwPasswordValidity;   //������Ч��,������Ա�û������޸�,��λ���죬��0��ʾ������Ч
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //��������
    BYTE    byUserOperateType;    //�û��������ͣ�1-�����û���2-�����û���3-�����û�+�����û�
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V52, *LPNET_DVR_USER_INFO_V52;

typedef struct  tagNET_DVR_USER_V52
{
    DWORD dwSize;  //�ṹ���С
    DWORD dwMaxUserNum; //�豸֧�ֵ�����û���-ֻ��
    NET_DVR_USER_INFO_V52 struUser[MAX_USERNUM_V30/*32*/];  /* �û����� */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* ��½����ȷ�� */
    BYTE     byRes[240]; //����
}NET_DVR_USER_V52, *LPNET_DVR_USER_V52;

//���û�����(�ӽṹ)(9000��չ)
typedef struct
{
    BYTE sUserName[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    BYTE byLocalRight[MAX_RIGHT];    /* ����Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    /*����6: ���ز鿴���� */
    /*����7: ���ع���ģ���IP camera */
    /*����8: ���ر��� */
    /*����9: ���عػ�/���� */    
    BYTE byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */    
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/    
    /*����11: Զ�̲鿴���� */
    /*����12: Զ�̹���ģ���IP camera */
    /*����13: Զ�̹ػ�/���� */
    BYTE byNetPreviewRight[MAX_CHANNUM_V30];        /* Զ�̿���Ԥ����ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalPlaybackRight[MAX_CHANNUM_V30];    /* ���ؿ��Իطŵ�ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetPlaybackRight[MAX_CHANNUM_V30];    /* Զ�̿��Իطŵ�ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalRecordRight[MAX_CHANNUM_V30];        /* ���ؿ���¼���ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetRecordRight[MAX_CHANNUM_V30];        /* Զ�̿���¼���ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalPTZRight[MAX_CHANNUM_V30];        /* ���ؿ���PTZ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byNetPTZRight[MAX_CHANNUM_V30];            /* Զ�̿���PTZ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE byLocalBackupRight[MAX_CHANNUM_V30];        /* ���ر���Ȩ��ͨ�� 0-��Ȩ�ޣ�1-��Ȩ��*/
    NET_DVR_IPADDR struUserIP;        /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];    /* �����ַ */
    BYTE byPriority;                /* ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--�� */
                                    /*
                                    �ޡ�����ʾ��֧�����ȼ�������
                                    �͡���Ĭ��Ȩ��:�������غ�Զ�̻ط�,���غ�Զ�̲鿴��־��״̬,���غ�Զ�̹ػ�/����
                                    �С����������غ�Զ�̿�����̨,���غ�Զ���ֶ�¼��,���غ�Զ�̻ط�,�����Խ���Զ��Ԥ��
                                    ���ر���,����/Զ�̹ػ�/����
                                    �ߡ�������Ա
    */
    BYTE    byAlarmOnRight;         // ��������ڲ���Ȩ��
    BYTE    byAlarmOffRight;        // ��������ڳ���Ȩ��
    BYTE    byBypassRight;          // �����������·Ȩ��
    BYTE    byRes[14];    
}NET_DVR_USER_INFO_V30, *LPNET_DVR_USER_INFO_V30;

//���û�����(SDK_V15��չ)(�ӽṹ)
typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    DWORD dwLocalRight[MAX_RIGHT];    /* Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    DWORD dwLocalPlaybackRight;        /* ���ؿ��Իطŵ�ͨ�� bit0 -- channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    DWORD dwNetPreviewRight;        /* Զ�̿���Ԥ����ͨ�� bit0 -- channel 1*/
    DWORD dwNetPlaybackRight;        /* Զ�̿��Իطŵ�ͨ�� bit0 -- channel 1*/
    char sUserIP[16];                /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];    /* �����ַ */
}NET_DVR_USER_INFO_EX, *LPNET_DVR_USER_INFO_EX;

//���û�����(�ӽṹ)
typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    DWORD dwLocalRight[MAX_RIGHT];    /* Ȩ�� */
    /*����0: ���ؿ�����̨*/
    /*����1: �����ֶ�¼��*/
    /*����2: ���ػط�*/
    /*����3: �������ò���*/
    /*����4: ���ز鿴״̬����־*/
    /*����5: ���ظ߼�����(��������ʽ�����������ػ�)*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* Ȩ�� */
    /*����0: Զ�̿�����̨*/
    /*����1: Զ���ֶ�¼��*/
    /*����2: Զ�̻ط� */
    /*����3: Զ�����ò���*/
    /*����4: Զ�̲鿴״̬����־*/
    /*����5: Զ�̸߼�����(��������ʽ�����������ػ�)*/
    /*����6: Զ�̷��������Խ�*/
    /*����7: Զ��Ԥ��*/
    /*����8: Զ�����󱨾��ϴ����������*/
    /*����9: Զ�̿��ƣ��������*/
    /*����10: Զ�̿��ƴ���*/
    char sUserIP[16];                /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE byMACAddr[MACADDR_LEN];    /* �����ַ */
}NET_DVR_USER_INFO, *LPNET_DVR_USER_INFO;

//DVR�û�����(��չ)
typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;  //�ṹ���С
    DWORD dwMaxUserNum; //�豸֧�ֵ�����û���-ֻ��
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* �û����� */
}NET_DVR_USER_V40,*LPNET_DVR_USER_V40;
typedef struct  tagNET_DVR_USER_V50
{
    DWORD dwSize;  //�ṹ���С
    DWORD dwMaxUserNum; //�豸֧�ֵ�����û���-ֻ��
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* �û����� */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* ��½����ȷ�� */
    BYTE     byRes[240]; //����
}NET_DVR_USER_V50, *LPNET_DVR_USER_V50;
//DVR�û�����(9000��չ)
typedef struct
{
    DWORD dwSize;
    NET_DVR_USER_INFO_V30 struUser[MAX_USERNUM_V30];
}NET_DVR_USER_V30, *LPNET_DVR_USER_V30;

//DVR�û�����(SDK_V15��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX, *LPNET_DVR_USER_EX;

//DVR�û�����
typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER, *LPNET_DVR_USER;

typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize ;             //�ṹ���С
    DWORD             dwMaxGroupNum ;    //�豸֧�ֵ��������
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];    
    BYTE                byRes[128];          //����
}NET_DVR_EXCEPTION_V40,*LPNET_DVR_EXCEPTION_V40; /*�쳣����������չ�ṹ��*/

//DVR�쳣����(9000��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*����0-����,1- Ӳ�̳���,2-���߶�,3-��������IP ��ַ��ͻ, 4-�Ƿ�����, 5-����/�����Ƶ��ʽ��ƥ��, 6-��Ƶ�ź��쳣, 7-¼���쳣 8-�����쳣��9-ǰ��/¼��ֱ��ʲ�ƥ���쳣��10-�г�����(����ר��) 11-�ȱ��쳣��N+1ʹ�ã�12-�¶ȣ�13-��ϵͳ�쳣��14-�����쳣, 15-POE�����쳣, 16-POC�쳣,����17-��Դ��ѹ�����쳣*/
}NET_DVR_EXCEPTION_V30, *LPNET_DVR_EXCEPTION_V30;



//DVR�쳣����
typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*����0-����,1- Ӳ�̳���,2-���߶�,3-��������IP ��ַ��ͻ,4-�Ƿ�����, 5-����/�����Ƶ��ʽ��ƥ��, 6-��Ƶ�ź��쳣*/
}NET_DVR_EXCEPTION, *LPNET_DVR_EXCEPTION;

//ͨ��״̬(9000��չ)
typedef struct 
{
    BYTE byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE bySignalStatic; //���ӵ��ź�״̬,0-����,1-�źŶ�ʧ
    BYTE byHardwareStatic;//ͨ��Ӳ��״̬,0-����,1-�쳣,����DSP����
    BYTE byRes1;        //����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    NET_DVR_IPADDR struClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
    DWORD dwIPLinkNum;//�����ͨ��ΪIP���룬��ô��ʾIP���뵱ǰ��������
    BYTE byExceedMaxLink;        // �Ƿ񳬳��˵�·6·������ 0 - δ����, 1-����
    BYTE byRes[3];        // �����ֽ�
    DWORD dwAllBitRate;      //����ʵ������֮��
    DWORD dwChannelNo;    //��ǰ��ͨ���ţ�0xffffffff��ʾ��Ч
}NET_DVR_CHANNELSTATE_V30, *LPNET_DVR_CHANNELSTATE_V30;

//ͨ��״̬
typedef struct 
{
    BYTE byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE bySignalStatic; //���ӵ��ź�״̬,0-����,1-�źŶ�ʧ
    BYTE byHardwareStatic;//ͨ��Ӳ��״̬,0-����,1-�쳣,����DSP����
    char reservedData;        //����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    DWORD dwClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
}NET_DVR_CHANNELSTATE, *LPNET_DVR_CHANNELSTATE;

//Ӳ��״̬
typedef struct 
{
    DWORD dwVolume;//Ӳ�̵�����
    DWORD dwFreeSpace;//Ӳ�̵�ʣ��ռ�
    DWORD dwHardDiskStatic; //Ӳ�̵�״̬,��λ:1-����,2-������,3-����Ӳ�̳���,4-δ��ʽ��, 5-δ����״̬(����Ӳ��),6-Ӳ�����ڸ�ʽ��,7-Ӳ����(δ����ѭ�����ǵ������),8-�����쳣�����豸��ͳ�ƣ�
}NET_DVR_DISKSTATE, *LPNET_DVR_DISKSTATE;

typedef struct tagNET_DVR_WORKSTATE_V40
{ 
    DWORD   dwSize ;            //�ṹ���С
    DWORD   dwDeviceStatic;      //�豸��״̬,0-����,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬,һ�����ֻ�ܻ�ȡ33��Ӳ����Ϣ
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//ͨ����״̬����ǰ����˳������
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/]; //�б����ı�������ڣ���ֵ��ʾ�����±�ֵ˳�����У�ֵΪ0xffffffffʱ��ǰ������ֵ��Ч
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/]; //�б�������ı�������ڣ���ֵ��ʾ�����±�ֵ˳�����У�ֵΪ0xffffffffʱ��ǰ������ֵ��Ч
    DWORD   dwLocalDisplay;            //������ʾ״̬,0-����,1-������
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];        //��λ��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ���У���0λ��ʾ��1������ͨ��
    BYTE    byRes1[2];
    float    fHumidity;    //��������֪��ʪ��,��Χ:0.0 ~100.0
    float    fTemperature;    //��������֪���¶ȣ���Χ��-20.0 ~ 90.0
    BYTE    byRes[116];                 //����
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40; /*�豸����״̬��չ�ṹ��*/

typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize ;  //�ṹ�峤��
    BYTE    byFindHardByCond; /*0-����ȫ������(��һ�����ֻ�ܲ���33��)����ʱdwFindHardStatusNum��Ч*/
    BYTE    byFindChanByCond ;  /*0-����ȫ��ͨ������ʱdwFindChanNum��Ч*/
    BYTE    byRes1[2] ;//����    
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/] ; /*Ҫ���ҵ�Ӳ�̺ţ���ֵ��ʾ����ֵ����˳�����У� ����0xffffffff����Ϊ������Ч */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/] ; /*Ҫ���ҵ�ͨ���ţ���ֵ��ʾ����ֵ����˳�����У� ����0xffffffff����Ϊ������Ч */
    BYTE     byRes[64] ; //����
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

//DVR����״̬(9000��չ)
typedef struct 
{
    DWORD dwDeviceStatic;     //�豸��״̬,0-����,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30];//ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30]; //�����˿ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD  dwLocalDisplay;//������ʾ״̬,0-����,1-������
    BYTE  byAudioChanStatus[MAX_AUDIO_V30];//��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30, *LPNET_DVR_WORKSTATE_V30;

//DVR����״̬
typedef struct 
{
    DWORD dwDeviceStatic;     //�豸��״̬,0-����,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM];//ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN]; //�����˿ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD  dwLocalDisplay;//������ʾ״̬,0-����,1-������
}NET_DVR_WORKSTATE, *LPNET_DVR_WORKSTATE;



//��־��Ϣ(9000��չ)
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //������ 1-����; 2-�쳣; 3-����; 0xff-ȫ��
    DWORD    dwMinorType;//������ 0-ȫ��;
    BYTE    sPanelUser[MAX_NAMELEN]; //���������û���
    BYTE    sNetUser[MAX_NAMELEN];//����������û���
    NET_DVR_IPADDR    struRemoteHostAddr;//Զ��������ַ
    DWORD    dwParaType;//��������,9000�豸MINOR_START_VT/MINOR_STOP_VTʱ����ʾ�����Խ��Ķ��Ӻ�
    DWORD    dwChannel;//ͨ����
    DWORD    dwDiskNumber;//Ӳ�̺�
    DWORD    dwAlarmInPort;//��������˿�
    DWORD    dwAlarmOutPort;//��������˿�
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;

//��־��Ϣ
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //������ 1-����; 2-�쳣; 3-����; 0xff-ȫ��
    DWORD    dwMinorType;//������ 0-ȫ��;
    BYTE    sPanelUser[MAX_NAMELEN]; //���������û���
    BYTE    sNetUser[MAX_NAMELEN];//����������û���
    char    sRemoteHostAddr[16];//Զ��������ַ
    DWORD    dwParaType;//��������
    DWORD    dwChannel;//ͨ����
    DWORD    dwDiskNumber;//Ӳ�̺�
    DWORD    dwAlarmInPort;//��������˿�
    DWORD    dwAlarmOutPort;//��������˿�
}NET_DVR_LOG, *LPNET_DVR_LOG;


typedef struct tagNET_DVR_FIND_LOG_COND
{
    DWORD            dwSelectMode;  // 0��ȫ����1�������ͣ�2����ʱ�䣻3����ʱ�������            
    DWORD            dwMainType;	//��־������
    DWORD            dwSubType;		//��־������
    NET_DVR_TIME_V50 struStartTime; //��ʼʱ��
    NET_DVR_TIME_V50 struEndTime;   //����ʱ��
    BOOL 		     bOnlySmart;    //�Ƿ�ֻ������S.M.A.R.T��Ϣ����־
    BYTE             byRes[128];
}NET_DVR_FIND_LOG_COND, *LPNET_DVR_FIND_LOG_COND;


typedef struct
{
    NET_DVR_TIME_V50 	struLogTime;    //��־������ʱ��
    DWORD               dwMajorType;    //������ 1-����; 2-�쳣; 3-����; 0xff-ȫ��
    DWORD               dwMinorType;    //������ 0-ȫ��;
    BYTE                sPanelUser[MAX_NAMELEN];//���������û���
    BYTE                sNetUser[MAX_NAMELEN];  //����������û���
    NET_DVR_IPADDR      struRemoteHostAddr;     //Զ��������ַ
    DWORD               dwParaType; //��������,9000�豸MINOR_START_VT/MINOR_STOP_VTʱ����ʾ�����Խ��Ķ��Ӻ�
    DWORD               dwChannel;  //ͨ����
    DWORD               dwDiskNumber;   //Ӳ�̺�
    DWORD               dwAlarmInPort;  //��������˿�
    DWORD               dwAlarmOutPort; //��������˿�
    DWORD               dwInfoLen;
    char                sInfo[LOG_INFO_LEN];
    BYTE                byRes[128];
}NET_DVR_LOG_V50, *LPNET_DVR_LOG_V50;


/************************DVR��־ end***************************/

/************************������������������־���� begin************************************************/
typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;        // ������
    WORD            wMinorType;        // ������ 
    NET_DVR_TIME    struStartTime;    // ��ʼʱ�� 
    NET_DVR_TIME    struEndTime;    // ����ʱ��
    BYTE            byRes[8];        // �����ֽ�
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME    struLogTime;                //  ��־ʱ��
    BYTE            sUserName[NAME_LEN];     // �����û�
    NET_DVR_IPADDR    struIPAddr;                 // ����IP��ַ
    WORD            wMajorType;                 // ������ 
    WORD            wMinorType;                 // ������
    WORD            wParam;                        // ��������
    BYTE            byRes[10];
    DWORD            dwInfoLen;                    // ������Ϣ����
    char            sInfo[LOG_INFO_LEN];       // ������Ϣ
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

/*************************������������������־���� end***********************************************/

//�������״̬(9000��չ)
typedef struct 
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30, *LPNET_DVR_ALARMOUTSTATUS_V30;

//�������״̬
typedef struct 
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS, *LPNET_DVR_ALARMOUTSTATUS;

//������Ϣ
typedef struct 
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];    //�豸����
    DWORD dwChannelNumer;    //ͨ����
    BYTE CardNumber[32];    //����
    char cTradeType[12];    //��������
    DWORD dwCash;            //���׽��
}NET_DVR_TRADEINFO, *LPNET_DVR_TRADEINFO;


//ATMר��
/****************************ATM(begin)***************************/
#define NCR        0
#define DIEBOLD    1
#define WINCOR_NIXDORF    2
#define SIEMENS    3
#define OLIVETTI    4
#define FUJITSU    5
#define HITACHI    6
#define SMI        7
#define IBM        8
#define BULL    9
#define YiHua    10
#define LiDe    11
#define GDYT    12
#define Mini_Banl    13
#define GuangLi    14
#define DongXin    15
#define ChenTong    16
#define NanTian    17
#define XiaoXing    18
#define GZYY    19
#define QHTLT    20
#define DRS918    21
#define KALATEL    22
#define NCR_2    23    
#define NXS        24


/*֡��ʽ*/
typedef struct 
{
    BYTE code[12];        /* ���� */
}NET_DVR_FRAMETYPECODE;


//ATM����
typedef struct 
{
    DWORD dwSize;
    char sATMIP[16];                        /* ATM IP��ַ */
    DWORD dwATMType;                        /* ATM���� */
    DWORD dwInputMode;                        /* ���뷽ʽ    0-�������� 1-������� 2-����ֱ������ 3-����ATM��������*/
    DWORD dwFrameSignBeginPos;              /* ���ı�־λ����ʼλ��*/
    DWORD dwFrameSignLength;                /* ���ı�־λ�ĳ��� */
    BYTE  byFrameSignContent[12];            /* ���ı�־λ������ */
    DWORD dwCardLengthInfoBeginPos;            /* ���ų�����Ϣ����ʼλ�� */
    DWORD dwCardLengthInfoLength;            /* ���ų�����Ϣ�ĳ��� */
    DWORD dwCardNumberInfoBeginPos;            /* ������Ϣ����ʼλ�� */
    DWORD dwCardNumberInfoLength;            /* ������Ϣ�ĳ��� */
    DWORD dwBusinessTypeBeginPos;           /* �������͵���ʼλ�� */
    DWORD dwBusinessTypeLength;                /* �������͵ĳ��� */
    NET_DVR_FRAMETYPECODE frameTypeCode[10];/* ���� */
}NET_DVR_FRAMEFORMAT, *LPNET_DVR_FRAMEFORMAT;

//ATM����(9000��չ)
typedef struct
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struATMIP;                   /* ATM IP��ַ */
    DWORD    dwATMType;                            /* ATM���� */
    DWORD    dwInputMode;                        /* ���뷽ʽ    0-�������� 1-������� 2-����ֱ������ 3-����ATM��������*/
    DWORD    dwFrameSignBeginPos;                /* ���ı�־λ����ʼλ��*/
    DWORD    dwFrameSignLength;                    /* ���ı�־λ�ĳ��� */
    BYTE     byFrameSignContent[12];                /* ���ı�־λ������ */
    DWORD    dwCardLengthInfoBeginPos;            /* ���ų�����Ϣ����ʼλ�� */
    DWORD    dwCardLengthInfoLength;                /* ���ų�����Ϣ�ĳ��� */
    DWORD    dwCardNumberInfoBeginPos;            /* ������Ϣ����ʼλ�� */
    DWORD    dwCardNumberInfoLength;                /* ������Ϣ�ĳ��� */
    DWORD    dwBusinessTypeBeginPos;                /* �������͵���ʼλ�� */
    DWORD    dwBusinessTypeLength;                /* �������͵ĳ��� */
    NET_DVR_FRAMETYPECODE    frameTypeCode[10];    /* ���� */
    WORD     wATMPort;                            /* ���Ų�׽�˿ں�(����Э�鷽ʽ) (����)0xffff��ʾ��ֵ��Ч*/
    WORD     wProtocolType;                        /* ����Э������(����) 0xffff��ʾ��ֵ��Ч*/
    BYTE     byRes[24];
}NET_DVR_FRAMEFORMAT_V30, *LPNET_DVR_FRAMEFORMAT_V30;

//SDK_V31 ATM

/*��������*/
typedef struct    tagNET_DVR_FILTER
{    
    BYTE                    byEnable;            //0,������;1,����
    BYTE                    byMode;                //0,ASCII;1,HEX    
    BYTE                    byFrameBeginPos;    // ��Ҫ����Ŀ���ַ�����ʼλ��     
    BYTE                    byRes;           // �����ֽ�
    BYTE                     byFilterText[16];    //�����ַ���
    BYTE                    byRes2[12];         // �����ֽ�
}NET_DVR_FILTER, *LPNET_DVR_FILTER;

//���ݰ����� ���ݰ���ʶ
typedef struct    tagNET_DVR_IDENTIFICAT
{    
    BYTE                    byStartMode;        //��ʼ�ַ�ģʽ:0,ASCII;1,HEX
    BYTE                    byEndMode;            //�����ַ�ģʽ��0,ASCII;1,HEX
    BYTE                    byRes[2];           //�����ֽ�
    NET_DVR_FRAMETYPECODE    struStartCode;        //���ݰ���ʼ��ʶ�ַ�
    NET_DVR_FRAMETYPECODE    struEndCode;        //���ݰ�������ʶ�ַ�
    BYTE                    byRes1[12];         //�����ֽ�
}NET_DVR_IDENTIFICAT, *LPNET_DVR_IDENTIFICAT;

typedef struct    tagNET_DVR_PACKAGE_LOCATION/*������Ϣλ��*/
{    
    BYTE                     byOffsetMode;            /*����λ����Ϣģʽ 0,token(�ַ���־ģʽ);1,fix���̶�ģʽ��*/
    BYTE                    byRes1[3];                // �����ֽ�
    DWORD                      dwOffsetPos;            /*modeΪ1��ʱ��ʹ��,�̶�ƫ�ƴ�С*/
    NET_DVR_FRAMETYPECODE    struTokenCode;            /*��־λ*/
    BYTE                    byMultiplierValue;        /*��־λ���ٴγ���*/
    BYTE                    byEternOffset;            /*�����ַ�ƫ����*/
    BYTE                    byCodeMode;                /*0,ASCII;1,HEX*/
    BYTE                     byRes2[9];                //�����ֽ�
}NET_DVR_PACKAGE_LOCATION, *LPNET_DVR_PACKAGE_LOCATION;


typedef struct    tagNET_DVR_PACKAGE_LENGTH//������Ϣ����
{    
    BYTE                    byLengthMode;            //�������ͣ�0,�ɱ䳤��;1,�̶�����;2,��������(�ӿ����л�ȡ)
    BYTE                    byRes1[3];              // �����ֽ�
    DWORD                      dwFixLength;                //modeΪ1��ʱ��ʹ��,�̶����ȴ�С
    DWORD                    dwMaxLength;            //������Ϣ��󳤶�  byLengthModeΪ0ʱʹ��
    DWORD                    dwMinLength;            //������Ϣ��С����  byLengthModeΪ0ʱʹ��
    BYTE                    byEndMode;                //�ɱ䳤�� �ս��ģʽ 0,ASCII;1,HEX    
    BYTE                    byRes2[3];              //�����ֽ�
    NET_DVR_FRAMETYPECODE    struEndCode;        //�ɱ䳤���ս��
    DWORD                    dwLengthPos;            //lengthModeΪ2��ʱ��ʹ�ã����ų����ڱ����е�λ��
    DWORD                    dwLengthLen;            //lengthModeΪ2��ʱ��ʹ�ã����ų��ȵĳ���
    BYTE                    byRes3[8];              // �����ֽ�
}NET_DVR_PACKAGE_LENGTH,* LPNET_DVR_PACKAGE_LENGTH;

typedef struct    tagNET_DVR_OSD_POSITION//OSD ���ӵ�λ��
{    
    BYTE                    byPositionMode;        //���ӷ�񣬹�2�֣�0������ʾ��1���Զ���
    BYTE                    byRes1[3];          // �����ֽ�
    DWORD                     dwPosX;                //x���꣬���ӷ��Ϊ�Զ���ʱʹ��
    DWORD                    dwPosY;                //y���꣬���ӷ��Ϊ�Զ���ʱʹ��
    BYTE                    byRes2[8];          //�����ֽ�
}NET_DVR_OSD_POSITION, *LPNET_DVR_OSD_POSITION;

typedef struct    tagNET_DVR_DATE_FORMAT//������ʾ��ʽ
{    
    BYTE                    byMonth;                //Month,0.mm;1.mmm;2.mmmm                            
    BYTE                     byDay;                    //Day,0.dd;                                    
    BYTE                     byYear;                    //Year,0.yy;1.yyyy    
    BYTE                    byDateForm;                //0~5�������յ��������
    BYTE                    byRes[20];              // �����ֽ�
    char                    chSeprator[4];            //�ָ���
    char                    chDisplaySeprator[4];    //��ʾ�ָ���
    BYTE                    byDisplayForm;            //0~5��3��item���������
    BYTE                    res[27];                // �����ֽ�
}NET_DVR_DATE_FORMAT, *LPNET_DVR_DATE_FORMAT;
typedef struct    tagNET_DVRT_TIME_FORMAT//ʱ����ʾ��ʽ
{    
    BYTE                    byTimeForm;                //1. HH MM SS;0. HH MM
    BYTE                     byRes1[23];             // �����ֽ�
    BYTE                    byHourMode;             //0,12;1,24 
    BYTE                    byRes2[3];              // �����ֽ�
    char                    chSeprator[4];             //���ķָ�������ʱû��
    char                    chDisplaySeprator[4];    //��ʾ�ָ���
    BYTE                    byDisplayForm;            //0~5��3��item���������
    BYTE                    byRes3[3];              // �����ֽ�
    BYTE                    byDisplayHourMode;        //0,12;1,24 
    BYTE                    byRes4[19];             // �����ֽ�
}NET_DVR_TIME_FORMAT, *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{    
    BYTE                    byChannel[64];//���ӵ�ͨ�� ÿ���ֽڱ�ʶһ��ͨ���� ����byChannel[0]ֵΪ1��Ӧ����ͨ��1��0��ʾ������ͨ��1��
    DWORD                    dwDelayTime;            //������ʱʱ��
    BYTE                    byEnableDelayTime;        //�Ƿ����õ�����ʱ
    BYTE                    byRes[11];          // �����ֽ�
}NET_DVR_OVERLAY_CHANNEL, *LPNET_DVR_OVERLAY_CHANNEL;

// ATM ������Ϊ��Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// ����λ����Ϣ
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD ����λ��
    NET_DVR_FRAMETYPECODE        struActionCode;        //����������Ϊ��
    NET_DVR_FRAMETYPECODE        struPreCode;        //�����ַ�ǰ���ַ�
    BYTE                    byActionCodeMode;        //����������Ϊ��ģʽ0,ASCII;1,HEX
    BYTE                    byRes[7];               // �����ֽ�
}NET_DVR_ATM_PACKAGE_ACTION, *LPNET_DVR_ATM_PACKAGE_ACTION;

// ATM ����DATA��Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// �����ڱ����е�λ����Ϣ
    NET_DVR_DATE_FORMAT            struDateForm;        //������ʾ��ʽ
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD����λ����Ϣ
    BYTE                        res[8];             // �����ֽ�
}NET_DVR_ATM_PACKAGE_DATE, *LPNET_DVR_ATM_PACKAGE_DATE;


//ATM����ʱ����Ϣ
typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{    
    NET_DVR_PACKAGE_LOCATION    location;        // ʱ���ڱ����е�λ����Ϣ
    NET_DVR_TIME_FORMAT            struTimeForm;    // ʱ����ʾ��ʽ
    NET_DVR_OSD_POSITION        struOsdPosition;// OSD ����λ����Ϣ
    BYTE                        byRes[8];        // �����ֽ�
}NET_DVR_ATM_PACKAGE_TIME, *LPNET_DVR_ATM_PACKAGE_TIME;


// ATM ����������Ϣ�����ţ����׽�������ţ�
typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; //����λ����Ϣ
    NET_DVR_PACKAGE_LENGTH    struPackageLength;        //������Ϣ
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD����λ����Ϣ
    NET_DVR_FRAMETYPECODE        struPreCode;        //�����ַ�ǰ���ַ�
    BYTE                    res[8];                    //�����ֽ�
}NET_DVR_ATM_PACKAGE_OTHERS, *LPNET_DVR_ATM_PACKAGE_OTHERS;


//�û��Զ���Э��
typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;  //���ı�־
    NET_DVR_FILTER             struFilter; //���ݰ���������
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara; //���ӿ�������
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE]; //���ӽ�����Ϊ���� 0-9 ���ζ�ӦInCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara; //���ӽ��׽������
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara; //���ӽ����������
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan; //����ͨ������
    NET_DVR_ATM_PACKAGE_DATE   struRes1; //�������ڣ�����
    NET_DVR_ATM_PACKAGE_TIME   struRes2; //����ʱ�䣬����
    BYTE                       byRes3[124];        //����
}NET_DVR_ATM_USER_DEFINE_PROTOCOL, *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{        
    DWORD                        dwSize;                 //�ṹ��С
    BYTE                        byEnable;                /*�Ƿ�����0,������;1,����*/
    BYTE                        byInputMode;            /**���뷽ʽ:0-���������1����Э�顢2-���ڼ�����3-����Э��*/
    BYTE                        byRes1[34];              //�����ֽ� 
    NET_DVR_IPADDR                struAtmIp;                /*ATM ��IP �������ʱʹ�� */
    WORD                        wAtmPort;                /* ����Э�鷽ʽʱ��ʹ��*/
    BYTE                        byRes2[2];              // �����ֽ�
    DWORD                        dwAtmType;                /*ATMЭ�����ͣ���NET_DVR_ATM_PROTOCOL�ṹ�л�ȡ���������Ϊ�Զ���ʱʹ���û��Զ���Э��*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol; //�û��Զ���Э�飬��ATM����Ϊ�Զ�ʱ��Ҫʹ�øö���
    BYTE                        byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30, *LPNET_DVR_ATM_FRAMEFORMAT_V30;

//ATMЭ������
typedef enum _ATM_PROTO_TYPE_
{
    ATM_PROTO_NCR = 0,//NCR
    ATM_PROTO_DIEBOLD = 1,//DIEBOLD
    ATM_PROTO_WINCOR_NIXDORF = 2,//WINCOR-NIXDORF
    ATM_PROTO_SIEMENS = 4,//SIEMENS
    ATM_PROTO_OLIVETTI = 5,//OLIVETTI
    ATM_PROTO_FUJITSU = 6,//FUJITSU
    ATM_PROTO_HITACHI = 7,//HITACHI
    ATM_PROTO_SMI = 8,//SMI
    ATM_PROTO_BULL = 9,//BULL
    ATM_PROTO_YIHUA = 10,//����
    ATM_PROTO_LIDE = 11,//����
    ATM_PROTO_GDYT = 12,//�����ͨ
    ATM_PROTO_MINI_BANL = 13,//Mini-Banl
    ATM_PROTO_GUANGLI = 14,//����
    ATM_PROTO_DONGXIN = 15,//����
    ATM_PROTO_CHENTONG = 16,//��ͨ
    ATM_PROTO_NANTIAN = 17,//����
    ATM_PROTO_XIAOXING = 18,//����
    ATM_PROTO_GZYY = 19,//��������
    ATM_PROTO_QHTLT = 20,//���̩����
    ATM_PROTO_DRS918 = 21,//DRS918 
    ATM_PROTO_KALATEL = 22,//KALATEL 
    ATM_PROTO_NCR_2 = 23,//NCR_2
    ATM_PROTO_NXS = 24,//NXS
    ATM_PROTO_ICBC = 25,//��������
    ATM_PROTO_PSBC = 26,//�й�������������
    ATM_PROTO_CUSTOM = 1025//�Զ���
}ATM_PROTO_TYPE;

typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType; //ATMЭ�����ͣ�ͬʱ��Ϊ������� ATM �����е�dwAtmType �Զ���ʱΪ1025
    char chDesc[ATM_DESC_LEN]; //ATMЭ�������
}NET_DVR_ATM_PROTO_TYPE, *LPNET_DVR_ATM_PROTO_TYPE; //Э����Ϣ���ݽṹ

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM Э���б�
{
    DWORD                  dwAtmProtoNum;           // Э���б�ĸ���
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM]; //Э���б���Ϣ
}NET_DVR_ATM_PROTO_LIST, *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList; // �������Э������
    NET_DVR_ATM_PROTO_LIST struSerialListenList; //���ڼ���Э������
    NET_DVR_ATM_PROTO_LIST struNetProtoList;     //����Э������
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;   //����Э������
    NET_DVR_ATM_PROTO_TYPE struCustomProto;        //�Զ���Э��
}NET_DVR_ATM_PROTOCOL, *LPNET_DVR_ATM_PROTOCOL;
// SDK_V31

/*****************************DS-6001D/F(begin)***************************/
//DS-6001D Decoder
typedef struct 
{
    BYTE byEncoderIP[16];        //�����豸���ӵķ�����IP
    BYTE byEncoderUser[16];        //�����豸���ӵķ��������û���
    BYTE byEncoderPasswd[16];    //�����豸���ӵķ�����������
    BYTE bySendMode;            //�����豸���ӷ�����������ģʽ
    BYTE byEncoderChannel;        //�����豸���ӵķ�������ͨ����
    WORD wEncoderPort;            //�����豸���ӵķ������Ķ˿ں�
    BYTE reservedData[4];        //����
}NET_DVR_DECODERINFO, *LPNET_DVR_DECODERINFO;

typedef struct 
{
    BYTE byEncoderIP[16];        //�����豸���ӵķ�����IP
    BYTE byEncoderUser[16];        //�����豸���ӵķ��������û���
    BYTE byEncoderPasswd[16];    //�����豸���ӵķ�����������
    BYTE byEncoderChannel;        //�����豸���ӵķ�������ͨ����
    BYTE bySendMode;            //�����豸���ӵķ�����������ģʽ
    WORD wEncoderPort;            //�����豸���ӵķ������Ķ˿ں�
    DWORD dwConnectState;        //�����豸���ӷ�������״̬
    BYTE reservedData[4];        //����
}NET_DVR_DECODERSTATE, *LPNET_DVR_DECODERSTATE;

/*�����豸�����붨��*/
#define NET_DEC_STARTDEC        1
#define NET_DEC_STOPDEC            2
#define NET_DEC_STOPCYCLE        3
#define NET_DEC_CONTINUECYCLE    4
/*���ӵ�ͨ������*/
typedef struct 
{
    char sDVRIP[16];                /* DVR IP��ַ */
    WORD wDVRPort;                     /* �˿ں� */
    BYTE sUserName[NAME_LEN];        /* �û��� */
    BYTE sPassword[PASSWD_LEN];        /* ���� */
    BYTE byChannel;                    /* ͨ���� */
    BYTE byLinkMode;                /* ����ģʽ */
    BYTE byLinkType;                /* �������� 0�������� 1�������� */
}NET_DVR_DECCHANINFO, *LPNET_DVR_DECCHANINFO;

/*ÿ������ͨ��������*/
typedef struct 
{
    BYTE    byPoolChans;            /*ÿ·����ͨ���ϵ�ѭ��ͨ������, ���4ͨ�� 0��ʾû�н���*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE    byEnablePoll;            /*�Ƿ���Ѳ 0-�� 1-��*/
    BYTE    byPoolTime;                /*��Ѳʱ�� 0-���� 1-10�� 2-15�� 3-20�� 4-30�� 5-45�� 6-1���� 7-2���� 8-5���� */
}NET_DVR_DECINFO, *LPNET_DVR_DECINFO;

/*�����豸��������*/
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwDecChanNum;         /*����ͨ��������*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG, *LPNET_DVR_DECCFG;

//2005-08-01
/* �����豸͸��ͨ������ */
typedef struct 
{
    DWORD dwEnableTransPort;    /* �Ƿ�����͸��ͨ�� 0�������� 1������*/
    char sDecoderIP[16];        /* DVR IP��ַ */
    WORD wDecoderPort;            /* �˿ں� */
    WORD wDVRTransPort;            /* ����ǰ��DVR�Ǵ�485/232�����1��ʾ232����,2��ʾ485���� */
    char cReserve[4];
}NET_DVR_PORTINFO, *LPNET_DVR_PORTINFO;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM]; /* ����0��ʾ232 ����1��ʾ485 */
}NET_DVR_PORTCFG, *LPNET_DVR_PORTCFG;

/* ���������ļ��ط� */
typedef struct 
{
    DWORD dwSize;
    char sDecoderIP[16];        /* DVR IP��ַ */
    WORD wDecoderPort;            /* �˿ں� */
    WORD wLoadMode;                /* �ط�����ģʽ 1�������� 2����ʱ�� */
    union
    {
        BYTE byFile[100];        /* �طŵ��ļ��� */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];    /*������Ƶ�û���*/
            BYTE sPassword[PASSWD_LEN];    /* ���� */
            NET_DVR_TIME struStartTime;    /* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;    /* ��ʱ��طŵĽ���ʱ�� */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE, *LPNET_DVR_PLAYREMOTEFILE;

/*��ǰ�豸��������״̬*/
typedef struct 
{
    DWORD dwWorkType;        /*������ʽ��1����Ѳ��2����̬���ӽ��롢3���ļ��ط����� 4����ʱ��ط�����*/
    char sDVRIP[16];        /*���ӵ��豸ip*/
    WORD wDVRPort;            /*���Ӷ˿ں�*/
    BYTE byChannel;            /* ͨ���� */
    BYTE byLinkMode;        /* ����ģʽ */
    DWORD    dwLinkType;        /*�������� 0�������� 1��������*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];    /*������Ƶ�û���*/
            BYTE sPassword[PASSWD_LEN];    /* ���� */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD    dwChannel;
            BYTE    sUserName[NAME_LEN];    /*������Ƶ�û���*/
            BYTE    sPassword[PASSWD_LEN];    /* ���� */
            NET_DVR_TIME struStartTime;        /* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;        /* ��ʱ��طŵĽ���ʱ�� */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS, *LPNET_DVR_DECCHANSTATUS;

typedef struct 
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS, *LPNET_DVR_DECSTATUS;
/*****************************DS-6001D/F(end)***************************/

//���ַ�����(�ӽṹ)
typedef struct 
{
    WORD wShowString;                // Ԥ����ͼ�����Ƿ���ʾ�ַ�,0-����ʾ,1-��ʾ ����Ԥ�������С704*576,�����ַ��Ĵ�СΪ32*32
    WORD wStringSize;                /* �����ַ��ĳ��ȣ����ܴ���44���ַ� */
    WORD wShowStringTopLeftX;        /* �ַ���ʾλ�õ�x���� */
    WORD wShowStringTopLeftY;        /* �ַ�������ʾλ�õ�y���� */
    char sString[44];                /* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRINGINFO, *LPNET_DVR_SHOWSTRINGINFO;

//�����ַ�(9000��չ)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];                /* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING_V30, *LPNET_DVR_SHOWSTRING_V30;

//�����ַ���չ(8���ַ�)
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];                /* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING_EX, *LPNET_DVR_SHOWSTRING_EX;

//�����ַ�
typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];                /* Ҫ��ʾ���ַ����� */
}NET_DVR_SHOWSTRING, *LPNET_DVR_SHOWSTRING;

/****************************DS9000�����ṹ(begin)******************************/
/*
EMAIL�����ṹ
*/
typedef struct
{        
    DWORD        dwSize;
    BYTE        sAccount[NAME_LEN];                /* �˺�*/ 
    BYTE        sPassword[MAX_EMAIL_PWD_LEN];            /*���� */
    struct
    {
        BYTE    sName[NAME_LEN];                /* ���������� */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];        /* �����˵�ַ */
    }struSender;
    BYTE        sSmtpServer[MAX_EMAIL_ADDR_LEN];    /* smtp������ */
    BYTE        sPop3Server[MAX_EMAIL_ADDR_LEN];    /* pop3������ */
    struct
    {
        BYTE    sName[NAME_LEN];                /* �ռ������� */
        BYTE    sAddress[MAX_EMAIL_ADDR_LEN];        /* �ռ��˵�ַ */
    }struReceiver[3];                            /* ����������3���ռ��� */
    BYTE        byAttachment;                    /* �Ƿ������ */
    BYTE        bySmtpServerVerify;                /* ���ͷ�����Ҫ�������֤ */
    BYTE        byMailInterval;                 /* mail interval */
    BYTE        byEnableSSL;                    //ssl�Ƿ�����9000_1.1
    WORD        wSmtpPort;                        //gmail��465����ͨ��Ϊ25 
    BYTE        byEnableTLS;                    /*TLS�Ƿ�����*/
    BYTE        byStartTLS;                     /*�Ƿ�����StartTLS*/
    BYTE        byRes[72];                        /*����*/
} NET_DVR_EMAILCFG_V30, *LPNET_DVR_EMAILCFG_V30;

/*
DVRʵ��Ѳ�����ݽṹ
*/
typedef struct
{    
    DWORD     dwSize;
    BYTE    byPresetNo[CRUISE_MAX_PRESET_NUMS];        /* Ԥ�õ�� */
    BYTE     byCruiseSpeed[CRUISE_MAX_PRESET_NUMS];    /* Ѳ���ٶ� */
    WORD    wDwellTime[CRUISE_MAX_PRESET_NUMS];        /* ͣ��ʱ�� */
    BYTE    byEnableThisCruise;                        /* �Ƿ����� */
    BYTE    res[15];
}NET_DVR_CRUISE_PARA, *LPNET_DVR_CRUISE_PARA; 
/****************************DS9000�����ṹ(end)******************************/

//ʱ���
typedef struct 
{
    DWORD dwMonth;        //�� 0-11��ʾ1-12����
    DWORD dwWeekNo;        //�ڼ��� 0����1�� 1����2�� 2����3�� 3����4�� 4�����һ��
    DWORD dwWeekDate;    //���ڼ� 0�������� 1������һ 2�����ڶ� 3�������� 4�������� 5�������� 6��������
    DWORD dwHour;        //Сʱ    ��ʼʱ��0��23 ����ʱ��1��23
    DWORD dwMin;        //��    0��59
}NET_DVR_TIMEPOINT;

//����ʱ����
typedef struct 
{
    DWORD dwSize;
    DWORD dwZoneIndex; //Ӧ�ò����ʹ��NET_DVR_NTPPARA �е�cTimeDifferenceH ��cTimeDifferenceM ������ʱ�����˴��û�ȡ��ֵ��䣬�����û��ṩ����༭��
    BYTE byRes1[12];            //����
    DWORD dwEnableDST;        //�Ƿ�������ʱ�� 0�������� 1������
    BYTE byDSTBias;    //����ʱƫ��ֵ��30min, 60min, 90min, 120min, �Է��Ӽƣ�����ԭʼ��ֵ
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;    //��ʱ�ƿ�ʼʱ��
    NET_DVR_TIMEPOINT struEndPoint;    //��ʱ��ֹͣʱ��
}NET_DVR_ZONEANDDST, *LPNET_DVR_ZONEANDDST;

//ͼƬ����
typedef struct 
{
/*ע�⣺��ͼ��ѹ���ֱ���ΪVGAʱ��֧��0=CIF, 1=QCIF, 2=D1ץͼ��
���ֱ���Ϊ3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
    ��֧�ֵ�ǰ�ֱ��ʵ�ץͼ*/
    
    /* ����ͨ����������ȡ
       0-CIF��           1-QCIF��           2-D1��         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)��
       6-VGA��           7-XVGA��           8-HD900p��     9-HD1080��     10-2560*1920��
       11-1600*304��     12-2048*1536��     13-2448*2048,  14-2448*1200�� 15-2448*800��
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576��     
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    55-3072*2048,
       64-3840*2160,     70-2560*1440,      75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       161-288*320,   162-144*176,   163-480*640,
       164-240*320,      165-120*160,       166-576*720,   167-720*1280,  168-576*960,
       180-180*240,      181-360*480,       182-540*720,    183-720*960,  184-960*1280,
       185-1080*1440,      215-1080*720(ռλ��δ����),  216-360x640(ռλ��δ����),245-576*704(ռλ��δ����)
       500-384*288,
       0xff-Auto(ʹ�õ�ǰ�����ֱ���)
    */
    WORD    wPicSize;            
    WORD    wPicQuality;            /* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
}NET_DVR_JPEGPARA, *LPNET_DVR_JPEGPARA;

//�����ṹ
typedef struct tagNET_VCA_RECT
{
    float fX;               //�߽�����Ͻǵ��X������, 0.000~1
    float fY;               //�߽�����Ͻǵ��Y������, 0.000~1
    float fWidth;           //�߽��Ŀ��, 0.000~1
    float fHeight;          //�߽��ĸ߶�, 0.000~1
}NET_VCA_RECT, *LPNET_VCA_RECT;

typedef struct tagNET_DVR_JPEGPICTURE_WITH_APPENDDATA
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    DWORD   dwJpegPicLen;//JpegͼƬ����
    char    *pJpegPicBuff;//JpegͼƬָ��
    DWORD   dwJpegPicWidth;  // ͼ����
    DWORD   dwJpegPicHeight;  //ͼ��߶�
    DWORD   dwP2PDataLen;//ȫ���������ݳ���
    char    *pP2PDataBuff; //ȫ����������ָ��   
    BYTE    byIsFreezedata;//�Ƿ����ݶ��� 0-�� 1-��
    BYTE    byRes1[3];
    DWORD   dwVisiblePicLen;//�ɼ���ͼƬ����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    char    *pVisiblePicBuff;//�ɼ���ͼƬָ��
#else
    char    *pVisiblePicBuff;//�ɼ���ͼƬָ��
    BYTE    byRes2[4];
#endif 
    NET_VCA_RECT struThermalValidRect;//�ȳ�����Ч����
    NET_VCA_RECT struVisibleValidRect;//�ɼ�����Ч����
    BYTE    byRes[208];
}NET_DVR_JPEGPICTURE_WITH_APPENDDATA, *LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA;

//ץͼ����
typedef  struct
{
    NET_DVR_JPEGPARA  struParam;
    BYTE   byPicFormat;            // �豸ץͼͼƬ��ʽ 0-Jpeg
    BYTE   byCapturePicType;        // �豸ץͼ���� 0-�豸ͨ��ץͼ��1-ӥ�۱궨ͼƬ��FPJA����ˢ�»�ȡͼƬ ���ʱ3min��,2-��Flash�л�ȡ�Ѵ���ӥ�۱궨ͼƬ,3-��ȡ�������Բ��ͼƬ
    BYTE   bySceneID;               //0-��֧�֣�1-����1��2-����2 ����
    BYTE   byRes[253];
}NET_DVR_PICPARAM_V50, *LPNET_DVR_PICPARAM_V50;
/* aux video out parameter */
//���������������
typedef struct 
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                       /* ѡ�񱨾������󱨾�ͨ���л�ʱ�䣺1��������ͨ��: 0:�����/1:��1/2:��2/3:��3/4:��4 */
    DWORD dwAlarmChanSwitchTime;                /* :1�� - 10:10�� */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];            /* ��������л�ʱ��: 0-���л�,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s */
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];    /* �������Ԥ��˳��, 0xff��ʾ��Ӧ�Ĵ��ڲ�Ԥ�� */
}NET_DVR_AUXOUTCFG, *LPNET_DVR_AUXOUTCFG;


//ntp
typedef struct 
{
    BYTE sNTPServer[64];   /* Domain Name or IP addr of NTP server */
    WORD wInterval;         /* adjust time interval(hours) */
    BYTE byEnableNTP;    /* enable NPT client 0-no��1-yes*/
    signed char cTimeDifferenceH; /* ����ʱ�׼ʱ��� Сʱƫ��-12 ... +13 */
    signed char cTimeDifferenceM;/* ����ʱ�׼ʱ��� ����ƫ��0, 30, 45*/
    BYTE res1;
    WORD wNtpPort;         /* ntp server port 9000���� �豸Ĭ��Ϊ123*/
    BYTE res2[8];
}NET_DVR_NTPPARA, *LPNET_DVR_NTPPARA;

//ddns
typedef struct 
{
    BYTE sUsername[NAME_LEN];  /* DDNS�˺��û���/���� */
    BYTE sPassword[PASSWD_LEN];
    BYTE sDomainName[64];       /* ���� */
    BYTE byEnableDDNS;            /*�Ƿ�Ӧ�� 0-��1-��*/
    BYTE res[15];
}NET_DVR_DDNSPARA, *LPNET_DVR_DDNSPARA;


typedef struct
{
    BYTE byHostIndex;                    /* 0-˽��DDNS 1��Dyndns 2��PeanutHull(������)*/
    BYTE byEnableDDNS;                    /*�Ƿ�Ӧ��DDNS 0-��1-��*/
    WORD wDDNSPort;                        /* DDNS�˿ں� */
    BYTE sUsername[NAME_LEN];            /* DDNS�û���*/
    BYTE sPassword[PASSWD_LEN];            /* DDNS���� */
    BYTE sDomainName[MAX_DOMAIN_NAME];    /* �豸�䱸��������ַ */
    BYTE sServerName[MAX_DOMAIN_NAME];    /* DDNS ��Ӧ�ķ�������ַ��������IP��ַ������ */
    BYTE byRes[16];
}NET_DVR_DDNSPARA_EX, *LPNET_DVR_DDNSPARA_EX;

//9000��չ
typedef struct
{
    BYTE byEnableDDNS;
    BYTE byHostIndex;/*0-IPServer 1��Dyndns 2��PeanutHull(������)��3- NO-IP, 4- hiDDNS*/
    BYTE byRes1[2];
    struct
    {    
        BYTE sUsername[NAME_LEN];            /* DDNS�˺��û���*/
        BYTE sPassword[PASSWD_LEN];            /* ���� */
        BYTE sDomainName[MAX_DOMAIN_NAME];    /* �豸�䱸��������ַ */
        BYTE sServerName[MAX_DOMAIN_NAME];    /* DDNSЭ���Ӧ�ķ�������ַ��������IP��ַ������ */
        WORD wDDNSPort;                        /* �˿ں� */
        WORD    wCountryID;        //���ұ�ţ�����byHostIndex = 4ʱ��Ч��0��ʾĬ��
                                BYTE byStatus;                      /* DDNS����״̬��ֻ������
                                                                    0-������
                                                                    1-���ӷ�����ʧ��(connServerfail)��
                                                                    2-������������Ϣʧ��(solveServerMesFail)��
                                                                    3-��������������ʧ��(connHeartSrvfail)��
                                                                    4-����������������Ϣʧ��(solveHeartSrvMesFail)��
                                                                    5-��������������ʧ��(connHostSrvfail)��
                                                                    6-����������������Ϣʧ��(solveHostSrvMesFail)��
                                                                    7-DDNS״̬����(updateSuccess)��
                                                                    8-δ����(disable)��
                                                                    9-ע�������ɹ�(registHostSuccess)��
                                                                    10-DNS���������ô���(DNSSrvError)��
                                                                    11-������ռ��(DomainConflict)��
                                                                    12-����(����)���Ϸ�(invalidAlias)��
                                                                    13-��Ȩʧ��(authenticationFail)
                                                                    14-ע�����������(registServerError)
                                                                    15-ע��ʧ��(registFail)
                                */
                                BYTE byRes[7];
    } struDDNS[MAX_DDNS_NUMS];
    BYTE byRes2[16];
}NET_DVR_DDNSPARA_V30, *LPNET_DVR_DDNSPARA_V30;

//email
typedef struct 
{
    BYTE sUsername[64];  /* �ʼ��˺�/���� */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];   /* email */
    BYTE sEventMailAddr1[64];  /* �ϴ�����/�쳣�ȵ�email */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA, *LPNET_DVR_EMAILPARA;

//�����������
typedef struct 
{
    DWORD  dwSize;
    char  sDNSIp[16];                /* DNS��������ַ */
    NET_DVR_NTPPARA  struNtpClientParam;      /* NTP���� */
    NET_DVR_DDNSPARA struDDNSClientParam;     /* DDNS���� */
    BYTE res[464];            /* ���� */
}NET_DVR_NETAPPCFG, *LPNET_DVR_NETAPPCFG;

//nfs�ṹ����
typedef struct
{
    char sNfsHostIPAddr[16];
    BYTE sNfsDirectory[PATHNAME_LEN];        // PATHNAME_LEN = 128
}NET_DVR_SINGLE_NFS, *LPNET_DVR_SINGLE_NFS;

typedef struct 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG, *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{   
    DWORD dwSize;                   // �ṹ��С
    WORD wVrmPort;                  // VRM �����˿�
    BYTE byEnable;                  // �Ƿ����� ISCSI�洢
    BYTE byRes[69];                 // �����ֽ�
    NET_DVR_IPADDR struVrmAddr;          // VRM ip��ַ 16λ
    char chNvtIndexCode[64];        //nvt index Code 
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;  

//Ѳ��������(˽��IP����ר��)
typedef struct
{
    BYTE    PresetNum;    //Ԥ�õ�
    BYTE    Dwell;        //ͣ��ʱ��
    BYTE    Speed;        //�ٶ�
    BYTE    Reserve;    //����
}NET_DVR_CRUISE_POINT, *LPNET_DVR_CRUISE_POINT;

typedef struct 
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];            //���֧��32��Ѳ����
}NET_DVR_CRUISE_RET, *LPNET_DVR_CRUISE_RET;

/************************************��·������(begin)***************************************/
typedef struct 
{
    DWORD    dwSize;
    char    sFirstDNSIP[16];
    char    sSecondDNSIP[16];
    char    sRes[32];
}NET_DVR_NETCFG_OTHER, *LPNET_DVR_NETCFG_OTHER;

typedef struct 
{
    char     sDVRIP[16];                /* DVR IP��ַ */
    WORD     wDVRPort;                 /* �˿ں� */
    BYTE     byChannel;                /* ͨ���� */
    BYTE    byTransProtocol;            /* ����Э������ 0-TCP, 1-UDP */
    BYTE    byTransMode;                /* ��������ģʽ 0�������� 1��������*/
    BYTE    byRes[3];
    BYTE    sUserName[NAME_LEN];            /* ���������½�ʺ� */
    BYTE    sPassword[PASSWD_LEN];            /* ����������� */
}NET_DVR_MATRIX_DECINFO, *LPNET_DVR_MATRIX_DECINFO;

//����/ֹͣ��̬����
typedef struct 
{
    DWORD    dwSize;                
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* ��̬����ͨ����Ϣ */
}NET_DVR_MATRIX_DYNAMIC_DEC, *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct  
{
    DWORD     dwSize;
    DWORD   dwIsLinked;         /* ����ͨ��״̬ 0������ 1���������� 2�������� 3-���ڽ��� */
    DWORD   dwStreamCpRate;     /* Stream copy rate, X kbits/second */
    char    cRes[64];        /* ���� */
}NET_DVR_MATRIX_DEC_CHAN_STATUS, *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct 
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* ����ͨ����Ϣ */
    DWORD    dwDecState;    /* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;        /* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;        /* ��ʱ��ط�ֹͣʱ�� */
    char    sFileName[128];        /* ���ļ��ط��ļ��� */
}NET_DVR_MATRIX_DEC_CHAN_INFO, *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

//���ӵ�ͨ������ 2007-11-05
typedef struct 
{
    DWORD dwEnable;                    /* �Ƿ����� 0���� 1������*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* ��Ѳ����ͨ����Ϣ */
}NET_DVR_MATRIX_DECCHANINFO, *LPNET_DVR_MATRIX_DECCHANINFO;

//2007-11-05 ����ÿ������ͨ��������
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPoolTime;            /*��Ѳʱ�� */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO, *LPNET_DVR_MATRIX_LOOP_DECINFO;

//2007-12-22
typedef struct 
{
    BYTE    baudrate;     /* ������ */
    BYTE    databits;        /* ����λ */
    BYTE    stopbits;        /* ֹͣλ */
    BYTE    parity;        /* ��żУ��λ */
    BYTE    flowcontrol;    /* ���� */
    BYTE    res[3];
}TTY_CONFIG, *LPTTY_CONFIG;

typedef struct  
{
    BYTE byTranChanEnable;    /* ��ǰ͸��ͨ���Ƿ�� 0���ر� 1���� */    
                            /*
                            *    ��·������������1��485���ڣ�1��232���ڶ�������Ϊ͸��ͨ��,�豸�ŷ������£�
                            *    0 RS485
                            *    1 RS232 Console
    */
    BYTE    byLocalSerialDevice;            /* Local serial device */
                                            /*
                                            *    Զ�̴��������������,һ��RS232��һ��RS485
                                            *    1��ʾ232����
                                            *    2��ʾ485����
    */
    BYTE    byRemoteSerialDevice;            /* Remote output serial device */
    BYTE    res1;                            /* ���� */
    char    sRemoteDevIP[16];                /* Remote Device IP */
    WORD    wRemoteDevPort;                /* Remote Net Communication Port */
    BYTE    res2[2];                        /* ���� */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct  
{
    DWORD dwSize;
    BYTE     by232IsDualChan; /* ������·232͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE    by485IsDualChan; /* ������·485͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE    res[2];    /* ���� */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM];/*ͬʱ֧�ֽ���MAX_SERIAL_NUM��͸��ͨ��*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

//2007-12-24 Merry Christmas Eve...
typedef struct 
{
    DWORD    dwSize;
    char    sDVRIP[16];        /* DVR IP��ַ */    
    WORD    wDVRPort;            /* �˿ں� */    
    BYTE    byChannel;            /* ͨ���� */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* �û��� */
    BYTE    sPassword[PASSWD_LEN];        /* ���� */
    DWORD    dwPlayMode;       /* 0�����ļ� 1����ʱ��*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

/* �ļ��������� */
#define NET_DVR_PLAYSTART        1//��ʼ����
#define NET_DVR_PLAYSTOP        2//ֹͣ����
#define NET_DVR_PLAYPAUSE        3//��ͣ����
#define NET_DVR_PLAYRESTART        4//�ָ�����
#define NET_DVR_PLAYFAST        5//���
#define NET_DVR_PLAYSLOW        6//����
#define NET_DVR_PLAYNORMAL        7//�����ٶ�
#define NET_DVR_PLAYSTARTAUDIO    9//������
#define NET_DVR_PLAYSTOPAUDIO    10//�ر�����
#define NET_DVR_PLAYSETPOS        12//�ı��ļ��طŵĽ���
#define NET_DVR_RESETBUFFER	    37  //��վ�����뻺������Զ�̻ط��ļ���

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* �������� ���ļ���������*/
    DWORD    dwCmdParam;        /* ����������� */
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct  
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;        /* ��ǰ���ŵ�ý���ļ����� */       
    DWORD dwCurMediaFilePosition;    /* ��ǰ�����ļ��Ĳ���λ�� */        
    DWORD dwCurMediaFileDuration;    /* ��ǰ�����ļ�����ʱ�� */        
    DWORD dwCurPlayTime;            /* ��ǰ�Ѿ����ŵ�ʱ�� */        
    DWORD dwCurMediaFIleFrames;        /* ��ǰ�����ļ�����֡�� */        
    DWORD dwCurDataType;            /* ��ǰ������������ͣ�19-�ļ�ͷ��20-�����ݣ� 21-���Ž�����־ */        
    BYTE res[72];    
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

//2009-4-11 added by likui ��·������new
typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD    wTransProtol;        //����Э�飬0-TCP, 1-UDP, 2-MCAST
    WORD    wPassivePort;        //UDP�˿�, TCPʱĬ��
    NET_DVR_IPADDR  struMcastIP;    //TCP,UDPʱ��Ч, MCASTʱΪ�ಥ��ַ
    BYTE    byStreamType;/* ���ݲ���ģʽ:REAL_TIME_STREAM(1)ʵʱ��,RECORD_STREAM(2)�ļ��� */
    BYTE    byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE, *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30 
{
    BYTE  byTranChanEnable;            /* ��ǰ͸��ͨ���Ƿ�� 0���ر� 1���� */    
    BYTE  byLocalSerialDevice;      /* Local serial device */
                                    /*
                                    *  ��·������������1��485���ڣ�1��232���ڶ�������Ϊ͸��ͨ��,�豸�ŷ������£�
                                    *  0 RS485
                                    *  1 RS232 Console
                                    *  2 Dual Scom
                                    */
    BYTE  byRemoteSerialDevice;        /* Remote output serial device */
                                    /*
                                    *  Զ�̴��������������,һ��RS232��һ��RS485
                                    *  1 ��ʾ232����
                                    *  2 ��ʾ485����
                                    */
    BYTE  byRes1;                    /* ���� */        
    NET_DVR_IPADDR struRemoteDevIP; /* Remote Device IP */
    WORD  wRemoteDevPort;            /* Remote Net Communication Port */
    BYTE  byIsEstablished;            /* ͸��ͨ�������ɹ���־��0-û�гɹ���1-�����ɹ� */
    BYTE  byRes2;                    /* ���� */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE  byUsername[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    DWORD dwLocalSerialNo;          /* ���ش��� */
    DWORD dwRemoteSerialNo;         /* Զ�̴��� */
    BYTE  byRes3[8];
} NET_DVR_MATRIX_TRAN_CHAN_INFO_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG 
{
    DWORD dwSize;
    BYTE  by232IsDualChan; /* ������·232͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE  by485IsDualChan; /* ������·485͸��ͨ����ȫ˫���� ȡֵ1��MAX_SERIAL_NUM */
    BYTE  byRes[2];           /* ���� */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*ͬʱ֧�ֽ���MAX_SERIAL_NUM��͸��ͨ��*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;

typedef struct  
{
    DWORD                                dwEnable;    /* �Ƿ����� 0���� 1������*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG    streamMediaServerCfg;    
    NET_DVR_DEV_CHAN_INFO         struDevChanInfo;        /* ��Ѳ����ͨ����Ϣ */
}NET_DVR_MATRIX_CHAN_INFO_V30,*LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*��Ѳ���*/
    NET_DVR_MATRIX_CHAN_INFO_V30    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30,*LPNET_DVR_MATRIX_LOOP_DECINFO_V30;


typedef struct tagDEC_MATRIX_CHAN_INFO_V30
{
    DWORD    dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;    /*��ý�����������*/
    NET_DVR_DEV_CHAN_INFO               struDevChanInfo;        /* ����ͨ����Ϣ */
    DWORD    dwDecState;        /* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;        /* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;        /* ��ʱ��ط�ֹͣʱ�� */
    char    sFileName[128];        /* ���ļ��ط��ļ��� */
    DWORD   dwGetStreamMode;    /*ȡ��ģʽ:1-������2-����*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE    byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

#define MAX_RESOLUTIONNUM    64 //֧�ֵ����ֱ�����Ŀ
typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];     /*VGA֧�ֵĴ���ģʽ��VGA1�����ɻ�����*/
    BYTE  byBNCWindowMode[4];           /*BNC֧�ֵĴ���ģʽ*/
    BYTE  byDspNums;   
    BYTE  byHDMINums;//HDMI��ʾͨ����������25��ʼ��
    BYTE  byDVINums;//DVI��ʾͨ����������29��ʼ��
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM];//���������ö�ٶ���,һ���ֽڴ���һ���ֱ�����//��֧�֣�1��֧�֣�0����֧��
    BYTE  byHDMIWindowMode[4][8];//HDMI֧�ֵĴ���ģʽ
    BYTE  byDVIWindowMode[4][8];//DVI֧�ֵĴ���ģʽ
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY, *LPNET_DVR_MATRIX_ABILITY;
//�ϴ�logo�ṹ
typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD        dwCorordinateX;    //ͼƬ��ʾ����X����
    DWORD        dwCorordinateY;    //ͼƬ��ʾ����Y����
    WORD        wPicWidth; //ͼƬ��
    WORD        wPicHeight; //ͼƬ��
    BYTE        byRes1[4];
    BYTE        byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE        byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE        byRes2[6];                //����
    DWORD        dwLogoSize;//LOGO��С������BMP���ļ�ͷ
}NET_DVR_DISP_LOGOCFG,*LPNET_DVR_DISP_LOGOCFG;

/*��������*/
#define NET_DVR_ENCODER_UNKOWN 0 /*δ֪�����ʽ*/
#define NET_DVR_ENCODER_H264   1 /*˽�� 264*/
#define NET_DVR_ENCODER_S264   2 /*Standard H264*/
#define NET_DVR_ENCODER_MPEG4  3 /*MPEG4*/
#define NET_DVR_ORIGINALSTREAM 4 /*Original Stream*/
#define NET_DVR_PICTURE           5/*Picture*/
#define NET_DVR_ENCODER_MJPEG  6
#define NET_DVR_ENCODER_MPEG2  7
#define NET_DVR_ENCODER_H265   8
#define NET_DVR_ENCODER_SVAC    9
#define NET_DVR_ENCODER_SMART264                   10/*Smart 264*/
#define NET_DVR_ENCODER_SMART265                   11/*Smart 265*/

/* �����ʽ */
#define NET_DVR_STREAM_TYPE_UNKOWN   0     /*δ֪�����ʽ*/
#define NET_DVR_STREAM_TYPE_PRIVT    1     /*˽�и�ʽ*/
#define NET_DVR_STREAM_TYPE_TS       7   /* TS��� */
#define NET_DVR_STREAM_TYPE_PS       8   /* PS��� */
#define NET_DVR_STREAM_TYPE_RTP      9    /* RTP��� */
#define NET_DVR_STREAM_TYPE_ORIGIN   10 //δ���(��Ƶ�ۺ�ƽ̨������ϵͳ��)

/*����ͨ��״̬*/
typedef struct
{
    BYTE  byDecodeStatus; /*��ǰ״̬:0:δ������1����������*/
    BYTE  byStreamType;    /*��������*/
    BYTE  byPacketType;     /*�����ʽ*/
    BYTE  byRecvBufUsage; /*���ջ���ʹ����*/
    BYTE  byDecBufUsage; /*���뻺��ʹ����*/
    BYTE  byFpsDecV; /*��Ƶ����֡��*/
    BYTE  byFpsDecA; /*��Ƶ����֡��*/
    BYTE  byCpuLoad;     /*DSP CPUʹ����*/ 
    BYTE  byRes1[4];    
    DWORD dwDecodedV; /*�������Ƶ֡*/
    DWORD dwDecodedA; /*�������Ƶ֡*/
    WORD wImgW; /*��������ǰ��ͼ���С,��*/
    WORD wImgH; //��
    BYTE byVideoFormat; /*��Ƶ��ʽ:0-NON,NTSC--1,PAL--2*/
    BYTE  byRes2[3];
    DWORD  dwDecChan;       /*��ȡȫ������ͨ��״̬ʱ��Ч������ʱ����0*/
    BYTE  byRes3[20]; 
}NET_DVR_MATRIX_CHAN_STATUS, *LPNET_DVR_MATRIX_CHAN_STATUS;

/*��ʾͨ��״̬*/
#define NET_DVR_MAX_DISPREGION 16         /*ÿ����ʾͨ����������ʾ�Ĵ���*/
//�ֱ���
//
typedef enum
{
    /*VGA*/
    VGA_NOT_AVALIABLE,
        VGA_THS8200_MODE_SVGA_60HZ,    //(800*600)
        VGA_THS8200_MODE_SVGA_75HZ,    //(800*600)
        VGA_THS8200_MODE_XGA_60HZ,     //(1024*768)
        VGA_THS8200_MODE_XGA_75HZ,     //(1024*768)
        VGA_THS8200_MODE_SXGA_60HZ,    //(1280*1024)
        VGA_THS8200_MODE_720P_60HZ,    //(1280*720)
        VGA_THS8200_MODE_1080I_60HZ,   //(1920*1080)
        VGA_THS8200_MODE_1080P_30HZ,   //(1920*1080)
        VGA_THS8200_MODE_UXGA_30HZ,    //(1600*1200)
        /*HDMI*/    
        HDMI_SII9134_MODE_XGA_60HZ,       //(1024*768)
        HDMI_SII9134_MODE_SXGA_60HZ,   //(1280*1024)
        HDMI_SII9134_MODE_SXGA2_60HZ,  //(1280*960)
        HDMI_SII9134_MODE_720P_60HZ,   //(1280*720)    
        HDMI_SII9134_MODE_720P_50HZ,   //(1280*720)        
        HDMI_SII9134_MODE_1080I_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080I_50HZ,  //(1920*1080)    
        HDMI_SII9134_MODE_1080P_25HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_30HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_50HZ,  //(1920*1080)
        HDMI_SII9134_MODE_1080P_60HZ,  //(1920*1080)
        HDMI_SII9134_MODE_UXGA_60HZ,   //(1600*1200)
        /*DVI*/    
        DVI_SII9134_MODE_XGA_60HZ,       //(1024*768)
        DVI_SII9134_MODE_SXGA_60HZ,       //(1280*1024)
        DVI_SII9134_MODE_SXGA2_60HZ,   //(1280*960)
        DVI_SII9134_MODE_720P_60HZ,       //(1280*720)    
        DVI_SII9134_MODE_720P_50HZ,    //(1280*720)        
        DVI_SII9134_MODE_1080I_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080I_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_25HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_30HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_50HZ,   //(1920*1080)
        DVI_SII9134_MODE_1080P_60HZ,   //(1920*1080)
        DVI_SII9134_MODE_UXGA_60HZ,     //(1600*1200)
        VGA_DECSVR_MODE_SXGA2_60HZ,
        HDMI_DECSVR_MODE_1080P_24HZ,
        DVI_DECSVR_MODE_1080P_24HZ,
        YPbPr_DECSVR_MODE_720P_60HZ,
        YPbPr_DECSVR_MODE_1080I_60HZ
}VGA_MODE;

//��֡�ʶ���
#define           LOW_DEC_FPS_1_2                51
#define           LOW_DEC_FPS_1_4                52
#define           LOW_DEC_FPS_1_8                53
#define           LOW_DEC_FPS_1_16               54

/*��Ƶ��ʽ��׼*/
typedef enum
{
    VS_NON = 0,
        VS_NTSC = 1,
        VS_PAL = 2
}VIDEO_STANDARD;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*��Ƶ�Ƿ���,0-��1-��*/
    BYTE    byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE     byVgaResolution;      /*VGA�ķֱ���*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwWindowMode;        /*����ģʽ,����������ȡ,Ŀǰ֧��1,2,4,9,16*/       
    BYTE    byJoinDecChan[MAX_WINDOWS];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE    byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    union
    {
        BYTE byRes[16];
        struct
        {
            /*�����Ӵ��ڶ�Ӧ����ͨ������Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
            BYTE     byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE     byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*���ֹ����壬0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-������������ʾͨ������*/
    BYTE        byUnionType;
    BYTE        byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
}NET_DVR_VGA_DISP_CHAN_CFG,*LPNET_DVR_VGA_DISP_CHAN_CFG;


/*��ʾͨ��״̬*/
#define NET_DVR_MAX_DISPREGION 16 /*ÿ����ʾͨ����������ʾ�Ĵ���*/
typedef struct
{
    BYTE  byDispStatus;          /*��ʾ״̬��0��δ��ʾ��1��������ʾ*/
    BYTE  byBVGA;                /*0-BNC��1-VGA�� 2-HDMI��3-DVI*/
    BYTE  byVideoFormat;        /*��Ƶ��ʽ:1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;        /*��ǰ����ģʽ*/
    BYTE  byJoinDecChan[MAX_WINDOWS];        /*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE  byFpsDisp[NET_DVR_MAX_DISPREGION]; /*ÿ���ӻ������ʾ֡��*/
    BYTE  byScreenMode;            //��Ļģʽ0-��ͨ 1-����
    BYTE  byRes2[31];
}NET_DVR_DISP_CHAN_STATUS, *LPNET_DVR_DISP_CHAN_STATUS;

#define MAX_DECODECHANNUM   32//��·������������ͨ����
#define MAX_DISPCHANNUM   24//��·�����������ʾͨ����

/*�������豸״̬*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM]; /*����ͨ��״̬*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];  /*��ʾͨ��״̬*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];         /*��������״̬*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];       /*�������״̬*/
    BYTE byAudioInChanStatus;          /*�����Խ�״̬*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS,*LPNET_DVR_DECODER_WORK_STATUS;

//2009-12-1 ���ӱ������벥�ſ���
typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* �������� ���ļ���������*/
    DWORD    dwCmdParam;        /* ����������� */
    BYTE    byRes[16];//Reverse
}NET_DVR_PASSIVEDECODE_CONTROL,*LPNET_DVR_PASSIVEDECODE_CONTROL;

#define        PASSIVE_DEC_PAUSE            1    /*����������ͣ(���ļ�����Ч)*/
#define        PASSIVE_DEC_RESUME            2    /*�ָ���������(���ļ�����Ч)*/
#define     PASSIVE_DEC_FAST              3   /*���ٱ�������(���ļ�����Ч)*/
#define     PASSIVE_DEC_SLOW            4   /*���ٱ�������(���ļ�����Ч)*/
#define     PASSIVE_DEC_NORMAL          5   /*������������(���ļ�����Ч)*/
#define     PASSIVE_DEC_ONEBYONE          6  /*�������뵥֡����(����)*/
#define     PASSIVE_DEC_AUDIO_ON         7   /*��Ƶ����*/
#define     PASSIVE_DEC_AUDIO_OFF        8       /*��Ƶ�ر�*/
#define        PASSIVE_DEC_RESETBUFFER        9    /*��ջ�����*/
//2009-12-16 ���ӿ��ƽ���������ͨ������
typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{        
    DWORD    dwSize;
    BYTE    byDecChanScaleStatus;/*����ͨ����ʾ���ſ���,1��ʾ������ʾ��0��ʾ��ʵ��ʾ*/
    BYTE    byDecodeDelay;//������ʱ��0-Ĭ�ϣ�1-ʵʱ�Ժã�2-ʵʱ�ԽϺã�3-ʵʱ���У��������У�4-�����ԽϺã�5-�����Ժã�0xff-�Զ�����   
    BYTE    byEnableSpartan;//����ʹ�ܣ�0-�أ�1-��
    BYTE    byLowLight;      //���նȡ�0-�أ�1-8������նȵȼ����ȼ�Խ��ǿ��Խ��
    BYTE    byNoiseReduction; //3D���룬0-�أ�1-����2-�Զ�
    BYTE    byDefog;         //͸��0-�أ�1-7����͸��ȼ����ȼ�Խ��ǿ��Խ��
    BYTE    byEnableVcaDec; //�Ƿ��������ܽ��룬0-�����ã���0-����
    BYTE    byEnableAudio; //�Ƿ�����Ƶ��0-��Ч��1-������2-�ر�
    DWORD   dwAllCtrlType;    //�����Ӵ���һ����������ͣ�����ʱ��Ч����λ��ʾ
    //dwAllCtrlType & 0x01,�����ر����ܽ���
    BYTE    byVolume; //volume,[0-100]
    BYTE    byRes[55];
}NET_DVR_MATRIX_DECCHAN_CONTROL,*LPNET_DVR_MATRIX_DECCHAN_CONTROL;

/************************************��·������(end)***************************************/
//2009-8-19 ��Ƶ�ۺ�ƽ̨�ӿں���
/************************************��Ƶ�ۺ�ƽ̨(begin)***************************************/
#define MAX_SUBSYSTEM_NUM    80   //һ������ϵͳ�������ϵͳ����
#define MAX_SERIALLEN        36  //������кų���
#define MAX_LOOPPLANNUM        16//���ƻ��л���
#define DECODE_TIMESEGMENT 4//�ƻ�����ÿ��ʱ�����
typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE        bySubSystemType;//��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��        
    BYTE        byChan;//��ϵͳͨ���������������ϵͳ������485�����������˲���ֻ�ܻ�ȡ��                    
    BYTE        byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-������
    BYTE        byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP��ַ�����޸ģ�*/
    WORD        wSubSystemPort;        //��ϵͳ�˿ںţ����޸ģ�
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask;//��������
    NET_DVR_IPADDR    struGatewayIpAddr;    /* ���ص�ַ*/   
    BYTE        sUserName[NAME_LEN];    /* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE        sPassword[PASSWD_LEN];    /*���루�˲���ֻ�ܻ�ȡ��*/
    char        sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS������IP��ַ*/
    BYTE        sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
}NET_DVR_SUBSYSTEMINFO, *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO, *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct  tagNET_DVR_LOOPPLAN_SUBCFG
{
    DWORD                             dwSize;
    DWORD                            dwPoolTime;        /*��Ѳ�������λ����*/      
    NET_DVR_MATRIX_CHAN_INFO_V30 struChanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
}NET_DVR_LOOPPLAN_SUBCFG,*LPNET_DVR_LOOPPLAN_SUBCFG;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD     dwSize;
    BYTE    byAlarmMode;//�����������ͣ�1-��Ѳ��2-����        
    WORD    wLoopTime;//��Ѳʱ��, ��λ����            
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG,*LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD            dwSize;
    NET_DVR_IPADDR   struIP;        /*�����IP��ַ*/
    WORD        wPort;                    //������˿ں�
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* �û��� */
    BYTE        sPassword[PASSWD_LEN];    /*���� */
    BYTE        byChan;//�����485��
    BYTE        by485Port;//485�ڵ�ַ
    BYTE        byRes2[14];
} NET_DVR_CODESPLITTERINFO, *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE    byAssociateType;//�������ͣ�1-����
    WORD    wAlarmDelay;//������ʱ��0��5�룻1��10�룻2��30�룻3��1���ӣ�4��2���ӣ�5��5���ӣ�6��10���ӣ�
    BYTE    byAlarmNum;//�����ţ������ֵ��Ӧ�ø�����ͬ�ı�������ͬ��ֵ
    BYTE    byRes[8];
} NET_DVR_ASSOCIATECFG,*LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD                            dwSize;
    NET_DVR_ASSOCIATECFG           struAssociateCfg;//������̬��������ṹ
    NET_DVR_PU_STREAM_CFG        struPuStreamCfg;//��̬����ṹ
    BYTE                            byRes[8];
}NET_DVR_DYNAMICDECODE,*LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime;//
    BYTE  byDecodeType;/*0-�ޣ�1-��Ѳ���룬2-��̬����*/
    BYTE  byLoopGroup;//��Ѳ���
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec;//��̬����
} NET_DVR_DECODESCHED, *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT];//��һ��Ϊ��ʼ����9000һ��
    BYTE byRes[8];
} NET_DVR_PLANDECODE,*LPNET_DVR_PLANDECODE;

//end
/************************************��Ƶ�ۺ�ƽ̨(end)***************************************/
typedef struct 
{    /* 12 bytes */
    DWORD    dwSize;
    char    sUserName[32];
    char     sPassWord[32];
    char     sFromName[32];            /* Sender *///�ַ����еĵ�һ���ַ������һ���ַ�������"@",�����ַ�����Ҫ��"@"�ַ�
    char     sFromAddr[48];            /* Sender address */
    char     sToName1[32];            /* Receiver1 */
    char     sToName2[32];            /* Receiver2 */
    char     sToAddr1[48];            /* Receiver address1 */
    char     sToAddr2[48];            /* Receiver address2 */
    char    sEmailServer[32];        /* Email server address */
    BYTE    byServerType;            /* Email server type: 0-SMTP, 1-POP, 2-IMTP��*/
    BYTE    byUseAuthen;            /* Email server authentication method: 1-enable, 0-disable */
    BYTE    byAttachment;            /* enable attachment */
    BYTE    byMailinterval;            /* mail interval 0-2s, 1-3s, 2-4s. 3-5s*/
} NET_DVR_EMAILCFG, *LPNET_DVR_EMAILCFG;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;    //��ʱ¼��
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;    //�¼�����¼��
}NET_DVR_COMPRESSIONCFG_NEW, *LPNET_DVR_COMPRESSIONCFG_NEW;

//���λ����Ϣ
typedef struct
{
    WORD wAction;//��ȡʱ���ֶ���Ч
    WORD wPanPos;//ˮƽ����
    WORD wTiltPos;//��ֱ����
    WORD wZoomPos;//�䱶����
}NET_DVR_PTZPOS, *LPNET_DVR_PTZPOS;

//�����Χ��Ϣ
typedef struct
{
    WORD wPanPosMin;//ˮƽ����min
    WORD wPanPosMax;//ˮƽ����max
    WORD wTiltPosMin;//��ֱ����min
    WORD wTiltPosMax;//��ֱ����max
    WORD wZoomPosMin;//�䱶����min
    WORD wZoomPosMax;//�䱶����max
}NET_DVR_PTZSCOPE, *LPNET_DVR_PTZSCOPE;

//rtsp���� ipcameraר��
typedef struct
{
    DWORD dwSize;         //����
    WORD  wPort;          //rtsp�����������˿�
    BYTE  byReserve1[40];  //Ԥ��
    WORD  wRtspsPort;     //rtsps�����������˿�
    BYTE  byReserve[12];
}NET_DVR_RTSPCFG, *LPNET_DVR_RTSPCFG;

/********************************�ӿڲ����ṹ(begin)*********************************/

//NET_DVR_Login()�����ṹ
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];   //���к�
    BYTE byAlarmInPortNum;                //DVR�����������
    BYTE byAlarmOutPortNum;                //DVR�����������
    BYTE byDiskNum;                        //DVRӲ�̸���
    BYTE byDVRType;                        //DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                        //DVR ͨ������
    BYTE byStartChan;                    //��ʼͨ����,����DVS-1,DVR - 1
}NET_DVR_DEVICEINFO, *LPNET_DVR_DEVICEINFO;

//NET_DVR_Login_V30()�����ṹ
typedef struct
{
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    BYTE byAlarmInPortNum;                //�����������
    BYTE byAlarmOutPortNum;                //�����������
    BYTE byDiskNum;                    //Ӳ�̸���
    BYTE byDVRType;                    //�豸����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                    //ģ��ͨ������
    BYTE byStartChan;                    //��ʼͨ����,����DVS-1,DVR - 1
    BYTE byAudioChanNum;                //����ͨ����
    BYTE byIPChanNum;                    //�������ͨ����������λ  
    BYTE byZeroChanNum;            //��ͨ��������� //2010-01-16
    BYTE byMainProto;            //����������Э������ 0-private, 1-rtsp,2-ͬʱ֧��private��rtsp
    BYTE bySubProto;                //����������Э������0-private, 1-rtsp,2-ͬʱ֧��private��rtsp
    BYTE bySupport;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧�֣�
    //bySupport & 0x1, ��ʾ�Ƿ�֧����������
    //bySupport & 0x2, ��ʾ�Ƿ�֧�ֱ���
    //bySupport & 0x4, ��ʾ�Ƿ�֧��ѹ������������ȡ
    //bySupport & 0x8, ��ʾ�Ƿ�֧�ֶ�����
    //bySupport & 0x10, ��ʾ֧��Զ��SADP
    //bySupport & 0x20, ��ʾ֧��Raid������
    //bySupport & 0x40, ��ʾ֧��IPSAN Ŀ¼����
    //bySupport & 0x80, ��ʾ֧��rtp over rtsp
    BYTE bySupport1;        // ���������䣬λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport1 & 0x1, ��ʾ�Ƿ�֧��snmp v30
    //bySupport1 & 0x2, ֧�����ֻطź�����
    //bySupport1 & 0x4, �Ƿ�֧�ֲ������ȼ�    
    //bySupport1 & 0x8, �����豸�Ƿ�֧�ֲ���ʱ�����չ
    //bySupport1 & 0x10, ��ʾ�Ƿ�֧�ֶ������������33����
    //bySupport1 & 0x20, ��ʾ�Ƿ�֧��rtsp over http    
    //bySupport1 & 0x80, ��ʾ�Ƿ�֧�ֳ����±�����Ϣ2012-9-28, �һ���ʾ�Ƿ�֧��NET_DVR_IPPARACFG_V40�ṹ��
    BYTE bySupport2; /*������λ����Ϊ0��ʾ��֧�֣���0��ʾ֧��                            
                     bySupport2 & 0x1, ��ʾ�������Ƿ�֧��ͨ��URLȡ������
                     bySupport2 & 0x2,  ��ʾ֧��FTPV40
                     bySupport2 & 0x4,  ��ʾ֧��ANR
                     bySupport2 & 0x8,  ��ʾ֧��CCD��ͨ����������
                     bySupport2 & 0x10,  ��ʾ֧�ֲ��������ش���Ϣ����֧��ץ�Ļ����� ���ϱ����ṹ��
                     bySupport2 & 0x20,  ��ʾ�Ƿ�֧�ֵ�����ȡ�豸״̬����
    bySupport2 & 0x40,  ��ʾ�Ƿ������������豸*/
    WORD wDevType;              //�豸�ͺ�
    BYTE bySupport3; //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport3 & 0x1, ��ʾ�Ƿ�֧���������ö���������
    // bySupport3 & 0x4 ��ʾ֧�ְ������ã� ������� ͨ��ͼ��������������������IP�������롢������������
    // �û��������豸����״̬��JPEGץͼ����ʱ��ʱ��ץͼ��Ӳ��������� 
    //bySupport3 & 0x8Ϊ1 ��ʾ֧��ʹ��TCPԤ����UDPԤ�����ಥԤ���е�"��ʱԤ��"�ֶ���������ʱԤ������������ʹ�����ַ�ʽ������ʱԤ����������bySupport3 & 0x8Ϊ0ʱ����ʹ�� "˽����ʱԤ��"Э�顣
    //bySupport3 & 0x10 ��ʾ֧��"��ȡ����������Ҫ״̬��V40��"��
    //bySupport3 & 0x20 ��ʾ�Ƿ�֧��ͨ��DDNS��������ȡ��
    
    BYTE byMultiStreamProto;//�Ƿ�֧�ֶ�����,��λ��ʾ,0-��֧��,1-֧��,bit1-����3,bit2-����4,bit7-��������bit-8������
    BYTE byStartDChan;        //��ʼ����ͨ����,0��ʾ��Ч
    BYTE byStartDTalkChan;    //��ʼ���ֶԽ�ͨ���ţ�������ģ��Խ�ͨ���ţ�0��ʾ��Ч
    BYTE byHighDChanNum;        //����ͨ����������λ
    BYTE bySupport4;        //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport4 & 0x4��ʾ�Ƿ�֧��ƴ��ͳһ�ӿ�
    // bySupport4 & 0x80 ֧���豸�ϴ����ı���ʹ�ܡ���ʾ�жϵ��ýӿ��� NET_DVR_PDC_RULE_CFG_V42���� NET_DVR_PDC_RULE_CFG_V41
    BYTE byLanguageType;// ֧����������,��λ��ʾ,ÿһλ0-��֧��,1-֧��  
    //  byLanguageType ����0 ��ʾ ���豸
    //  byLanguageType & 0x1��ʾ֧������
    //  byLanguageType & 0x2��ʾ֧��Ӣ��
    BYTE byVoiceInChanNum;   //��Ƶ����ͨ���� 
    BYTE byStartVoiceInChanNo; //��Ƶ������ʼͨ���� 0��ʾ��Ч
    BYTE  bySupport5;  //��λ��ʾ,0-��֧��,1-֧��,bit0-֧�ֶ�����
    //bySupport5 &0x01��ʾ֧��wEventTypeEx ,����dwEventType ���¼����ͣ�֧����Ϊ�¼���չ��--��ռס����ֹ��ͻ
    //bySupport5 &0x04��ʾ�Ƿ�֧��ʹ����չ�ĳ���ģʽ�ӿ�
    /*
       bySupport5 &0x08 �豸���ظ�ֵ��ʾ�Ƿ�֧�ּƻ�¼������V40�ӿ�Э��(DVR_SET_RECORDCFG_V40/ DVR_GET_RECORDCFG_V40)(�ڸ�Э�����豸֧����������13������)
       ֮ǰ�Ĳ��ַ������豸��֧��¼������13��������¼������13�������֧�֣�ͳһת����¼������3���ݴ���SDKͨ������̽�⴦��)
       bySupport5 &0x10 �豸���ظ�ֵ��ʾ֧�ֳ���255��Ԥ�õ�
    */
    BYTE  bySupport6;   //��������λ��ʾ��0-��֧��,1-֧��
    //bySupport6 0x1  ��ʾ�豸�Ƿ�֧��ѹ�� 
    //bySupport6 0x2 ��ʾ�Ƿ�֧����ID��ʽ��������Դ��չ���DVR_SET_STREAM_SRC_INFO_V40
    //bySupport6 0x4 ��ʾ�Ƿ�֧���¼�����V40�ӿ�
    //bySupport6 0x8 ��ʾ�Ƿ�֧����չ���������������
    //bySupport6 0x40��ʾͼƬ��ѯ���V40��չ
    BYTE  byMirrorChanNum;    //����ͨ��������<¼�����������ڱ�ʾ����ͨ��>
    WORD wStartMirrorChanNo;  //��ʼ����ͨ����
    BYTE bySupport7;   //����,��λ��ʾ,0-��֧��,1-֧��
    // bySupport7 & 0x1  ��ʾ�豸�Ƿ�֧�� INTER_VCA_RULECFG_V42 ��չ
    // bySupport7 & 0x2  ��ʾ�豸�Ƿ�֧�� IPC HVT ģʽ��չ
    // bySupport7 & 0x04  ��ʾ�豸�Ƿ�֧�� ��������ʱ��
    // bySupport7 & 0x08  ��ʾ������̨PTZλ��ʱ���Ƿ�֧�ִ�ͨ����
    // bySupport7 & 0x10  ��ʾ�豸�Ƿ�֧��˫ϵͳ��������
    // bySupport7 & 0x20  ��ʾ�豸�Ƿ�֧�� OSD�ַ����� V50
    // bySupport7 & 0x40  ��ʾ�豸�Ƿ�֧�� ���Ӹ��٣����������
    // bySupport7 & 0x80  ��ʾ�豸�Ƿ�֧�� ���ļ���
    BYTE  byRes2;        //����
}NET_DVR_DEVICEINFO_V30, *LPNET_DVR_DEVICEINFO_V30;

typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //�豸֧���������ܣ����ֶ���SDK�����豸����ֵ����ֵ�ġ�bySupportLockΪ1ʱ��dwSurplusLockTime��byRetryLoginTime��Ч
    BYTE  byRetryLoginTime;        //ʣ��ɳ��Ե�½�Ĵ������û������������ʱ���˲�����Ч
    BYTE  byPasswordLevel;      //admin���밲ȫ�ȼ�0-��Ч��1-Ĭ�����룬2-��Ч����,3-���սϸߵ����롣���û�������Ϊ����Ĭ�����루12345�����߷��սϸߵ�����ʱ���ϲ�ͻ�����Ҫ��ʾ�û��������롣4-����Ա����һ����ͨ�û�Ϊ���������룬����ͨ�û���ȷ��¼�豸��Ҫ��ʾ�����޸ĳ�ʼ��¼���롱��δ�޸ĵ�����£��û�ÿ�ε��붼��������ѣ�5-����ͨ�û������뱻����Ա�޸ģ�����ͨ�û��ٴ���ȷ��¼�豸����Ҫ��ʾ�����������õ�¼���롱��δ�޸ĵ�����£��û�ÿ�ε��붼���������;
    BYTE  byProxyType;  //�������ͣ�0-��ʹ�ô���, 1-ʹ��socks5����, 2-ʹ��EHome����
    DWORD dwSurplusLockTime;    //ʣ��ʱ�䣬��λ�룬�û�����ʱ���˲�����Ч
    BYTE  byCharEncodeType;     //�ַ���������
    BYTE  bySupportDev5;//֧��v50�汾���豸������ȡ���豸���ƺ��豸�������Ƴ�����չΪ64�ֽ�
    BYTE  bySupport;  //��������չ��λ������0- ��֧�֣�1- ֧��
    // bySupport & 0x1:  ����
    // bySupport & 0x2:  0-��֧�ֱ仯�ϱ� 1-֧�ֱ仯�ϱ�
    BYTE  byLoginMode; //��¼ģʽ 0-Private��¼ 1-ISAPI��¼
    DWORD dwOEMCode;
    int iResidualValidity;   //���û�����ʣ����Ч��������λ���죬���ظ�ֵ����ʾ�����Ѿ�����ʹ�ã����硰-3��ʾ�����Ѿ�����ʹ��3�족
    BYTE  byResidualValidity; // iResidualValidity�ֶ��Ƿ���Ч��0-��Ч��1-��Ч
    BYTE  bySingleStartDTalkChan;	//�������������豸����ʼ����ͨ���ţ�0-Ϊ�����ֽڣ���ʵ�ʺ��壬����ͨ���Ų��ܴ�0��ʼ
    BYTE  bySingleDTalkChanNums;	//�������������豸��ͨ��������0-��ʾ��֧��
    BYTE  byPassWordResetLevel; //0-��Ч��1-����Ա����һ���ǹ���Ա�û�Ϊ���������룬�÷ǹ���Ա�û���ȷ��¼�豸��Ҫ��ʾ�����޸ĳ�ʼ��¼���롱��δ�޸ĵ�����£��û�ÿ�ε��붼��������ѣ�2-���ǹ���Ա�û������뱻����Ա�޸ģ��÷ǹ���Ա�û��ٴ���ȷ��¼�豸����Ҫ��ʾ�����������õ�¼���롱��δ�޸ĵ�����£��û�ÿ�ε��붼��������ѡ�
    BYTE  bySupportStreamEncrypt;  //��������չ��λ������0- ��֧�֣�1- ֧�� bySupportStreamEncrypt & 0x1:��ʾ�Ƿ�֧��RTP/TLSȡ�� bySupportStreamEncrypt & 0x2:  ��ʾ�Ƿ�֧��SRTP/UDPȡ�� bySupportStreamEncrypt & 0x4:  ��ʾ�Ƿ�֧��SRTP/MULTICASTȡ��
    BYTE byMarketType;//0-��Ч��δ֪���ͣ�,1-�����ͣ�2-��ҵ��
    BYTE  byRes2[238];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

typedef void (CALLBACK *fLoginResultCallBack) (LONG lUserID, DWORD dwResult, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo , void* pUser);

#define NET_DVR_DEV_ADDRESS_MAX_LEN 129
#define NET_DVR_LOGIN_USERNAME_MAX_LEN 64
#define NET_DVR_LOGIN_PASSWD_MAX_LEN 64

typedef struct  
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byUseTransport;    //�Ƿ�����������͸����0--������͸����Ĭ�ϣ�1--����͸��
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType; //0:��ʹ�ô���1��ʹ�ñ�׼����2��ʹ��EHome����
    BYTE byUseUTCTime;    //0-������ת����Ĭ��,1-�ӿ����������ȫ��ʹ��UTCʱ��,SDK���UTCʱ�����豸ʱ����ת��,2-�ӿ����������ȫ��ʹ��ƽ̨����ʱ�䣬SDK���ƽ̨����ʱ�����豸ʱ����ת��
    BYTE byLoginMode; //0-Private 1-ISAPI 2-����Ӧ
    BYTE byHttps;    //0-������tls��1-ʹ��tls 2-����Ӧ
    LONG iProxyID;    //�����������ţ���Ӵ����������Ϣʱ�����Ӧ�ķ����������±�ֵ
    BYTE byVerifyMode;  //��֤��ʽ��0-����֤��1-˫����֤��2-������֤����֤����ʹ��TLS��ʱ����Ч;
    BYTE byRes3[119];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;

//sdk���绷��ö�ٱ���������Զ������
typedef enum _SDK_NET_ENV
{
    LOCAL_AREA_NETWORK = 0,
        WIDE_AREA_NETWORK
}SDK_NETWORK_ENVIRONMENT;

//��ʾģʽ
typedef enum
{
    NORMALMODE = 0,
        OVERLAYMODE
}DISPLAY_MODE;

//����ģʽ
typedef enum
{
    PTOPTCPMODE = 0,
        PTOPUDPMODE,
        MULTIMODE,
        RTPMODE,
        RESERVEDMODE
}SEND_MODE;

//ץͼģʽ
typedef enum 
{
    BMP_MODE = 0,        //BMPģʽ
        JPEG_MODE = 1        //JPEGģʽ 
}CAPTURE_MODE;

//ʵʱ����ģʽ
typedef enum
{
    MONOPOLIZE_MODE = 1,//��ռģʽ
        SHARE_MODE = 2        //����ģʽ
}REALSOUND_MODE;

//�����Ԥ������
typedef struct
{
    LONG lChannel;//ͨ����
    LONG lLinkMode;//���λ(31)Ϊ0��ʾ��������Ϊ1��ʾ�ӣ�0��30λ��ʾ�������ӷ�ʽ: 0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;//���Ŵ��ڵľ��,ΪNULL��ʾ������ͼ��
    char* sMultiCastIP;//�ಥ���ַ
    BYTE byProtoType; //Ӧ�ò�ȡ��Э�飬0-˽��Э�飬1-RTSPЭ��
    BYTE byRes[3];
}NET_DVR_CLIENTINFO, *LPNET_DVR_CLIENTINFO;

//SDK״̬��Ϣ(9000����)
typedef struct 
{
    DWORD dwTotalLoginNum;        //��ǰlogin�û���
    DWORD dwTotalRealPlayNum;    //��ǰrealplay·��
    DWORD dwTotalPlayBackNum;    //��ǰ�طŻ�����·��
    DWORD dwTotalAlarmChanNum;    //��ǰ��������ͨ��·��
    DWORD dwTotalFormatNum;        //��ǰӲ�̸�ʽ��·��
    DWORD dwTotalFileSearchNum;    //��ǰ��־���ļ�����·��
    DWORD dwTotalLogSearchNum;    //��ǰ��־���ļ�����·��
    DWORD dwTotalSerialNum;        //��ǰ͸��ͨ��·��
    DWORD dwTotalUpgradeNum;    //��ǰ����·��
    DWORD dwTotalVoiceComNum;    //��ǰ����ת��·��
    DWORD dwTotalBroadCastNum;    //��ǰ�����㲥·��
    DWORD dwTotalListenNum;        //��ǰ�������·��
    DWORD dwEmailTestNum;       //��ǰ�ʼ�����·��
    DWORD dwBackupNum;          // ��ǰ�ļ�����·��
    DWORD dwTotalInquestUploadNum; //��ǰ��Ѷ�ϴ�·��
    DWORD dwRes[6];
}NET_DVR_SDKSTATE, *LPNET_DVR_SDKSTATE;

//SDK����֧����Ϣ(9000����)
typedef struct 
{
    DWORD dwMaxLoginNum;        //���login�û��� MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;        //���realplay·�� WATCH_NUM
    DWORD dwMaxPlayBackNum;        //���طŻ�����·�� WATCH_NUM
    DWORD dwMaxAlarmChanNum;    //���������ͨ��·�� ALARM_NUM
    DWORD dwMaxFormatNum;        //���Ӳ�̸�ʽ��·�� SERVER_NUM
    DWORD dwMaxFileSearchNum;    //����ļ�����·�� SERVER_NUM
    DWORD dwMaxLogSearchNum;    //�����־����·�� SERVER_NUM
    DWORD dwMaxSerialNum;        //���͸��ͨ��·�� SERVER_NUM
    DWORD dwMaxUpgradeNum;        //�������·�� SERVER_NUM
    DWORD dwMaxVoiceComNum;        //�������ת��·�� SERVER_NUM
    DWORD dwMaxBroadCastNum;    //��������㲥·�� MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL, *LPNET_DVR_SDKABL;

//�����豸��Ϣ
typedef struct
{   
    BYTE byUserIDValid;                 /* userid�Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE bySerialValid;                 /* ���к��Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byVersionValid;                /* �汾���Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byDeviceNameValid;             /* �豸�����Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byMacAddrValid;                /* MAC��ַ�Ƿ���Ч 0-��Ч��1-��Ч */    
    BYTE byLinkPortValid;               /* login�˿��Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE byDeviceIPValid;               /* �豸IP�Ƿ���Ч 0-��Ч��1-��Ч */
    BYTE bySocketIPValid;               /* socket ip�Ƿ���Ч 0-��Ч��1-��Ч */
    LONG lUserID;                       /* NET_DVR_Login()����ֵ, ����ʱ��Ч */
    BYTE sSerialNumber[SERIALNO_LEN];    /* ���к� */
    DWORD dwDeviceVersion;                /* �汾��Ϣ ��16λ��ʾ���汾����16λ��ʾ�ΰ汾*/
    char sDeviceName[NAME_LEN];            /* �豸���� */
    BYTE byMacAddr[MACADDR_LEN];        /* MAC��ַ */    
    WORD wLinkPort;                     /* link port */
    char sDeviceIP[128];                /* IP��ַ */
    char sSocketIP[128];                /* ���������ϴ�ʱ��socket IP��ַ */
    BYTE byIpProtocol;                  /* IpЭ�� 0-IPV4, 1-IPV6 */
    BYTE byRes1[2];
    BYTE bJSONBroken;                   //JSON����������־��0����������1������
    WORD wSocketPort;
    BYTE byRes2[6];
}NET_DVR_ALARMER, *LPNET_DVR_ALARMER;

//Ӳ������ʾ�������(�ӽṹ)
typedef struct
{
    long bToScreen;
    long bToVideoOut;
    long nLeft;
    long nTop;
    long nWidth;
    long nHeight;
    long nReserved;
}NET_DVR_DISPLAY_PARA, *LPNET_DVR_DISPLAY_PARA;

//Ӳ����Ԥ������
typedef struct
{
    LONG lChannel;//ͨ����
    LONG lLinkMode; //���λ(31)Ϊ0��ʾ��������Ϊ1��ʾ�ӣ�0��30λ��ʾ�������ӷ�ʽ:0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-�绰�ߣ�5��128k�����6��256k�����7��384k�����8��512k�����
    char* sMultiCastIP;
    NET_DVR_DISPLAY_PARA struDisplayPara;
}NET_DVR_CARDINFO, *LPNET_DVR_CARDINFO;

//¼���ļ�����
typedef struct 
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
}NET_DVR_FIND_DATA, *LPNET_DVR_FIND_DATA;

//¼���ļ�����(9000)
typedef struct 
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
    BYTE byLocked;//9000�豸֧��,1��ʾ���ļ��Ѿ�������,0��ʾ�������ļ�
    BYTE byFileType;  //�ļ�����:0����ʱ¼��,1-�ƶ���� ��2������������
    //3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ���,14-���ܽ�ͨ�¼�
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30, *LPNET_DVR_FINDDATA_V30;

//¼���ļ�����(cvr)
typedef struct 
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
    BYTE byLocked;//9000�豸֧��,1��ʾ���ļ��Ѿ�������,0��ʾ�������ļ�
    BYTE byFileType;  //�ļ�����:0����ʱ¼��,1-�ƶ���� ��2������������
    //3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ���,14-���ܽ�ͨ�¼�
    BYTE byQuickSearch; //0:��ͨ��ѯ�����1�����٣���������ѯ���
    BYTE byRes;
    DWORD dwFileIndex; //�ļ�������
    BYTE byStreamType;
    BYTE byRes1[127];    
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;

typedef struct tagNET_DVR_FINDDATA_V50
{
    char sFileName[100];
    NET_DVR_TIME_SEARCH   struStartTime;
    NET_DVR_TIME_SEARCH   struStopTime;
    NET_DVR_ADDRESS struAddr; //Ƭ�����ڵĵ�ַ��Ϣ����Ⱥ�ط�ʱ�õ�
    DWORD   dwFileSize; //�ļ���С //���ڴ��ļ���������ʱ��byBigFileTypeΪ1������ֵ������
    BYTE    byLocked; //�ļ��Ƿ�������1���ļ���������0���ļ�δ����
    BYTE   byFileType; //�ļ����ͣ���V40��ͬ
    BYTE   byQuickSearch; //0- ��ͨ��ѯ�����1- ���٣���������ѯ���
    BYTE  byStreamType; //�������ͣ�0- ��������1- ��������2- ������
    DWORD  dwFileIndex; //�ļ�������
    char  sCardNum[32]; //����
    DWORD  dwTotalLenH; // ���ڴ��ļ�������ʱ����������ܳ��ȣ���32�ֽ�
    DWORD  dwTotalLenL; // ���ڴ��ļ�������ʱ����������ܳ��ȣ���32�ֽ�
    BYTE    byBigFileType;  // 0Ϊ��ͨƬ��������1Ϊ���ļ�����          
    BYTE    byRes[247];
}NET_DVR_FINDDATA_V50, *LPNET_DVR_FINDDATA_V50;

//¼���ļ�����(������)
typedef struct 
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD, *LPNET_DVR_FINDDATA_CARD;


//¼���ļ����������ṹ
typedef struct 
{
    LONG lChannel;//ͨ����
    DWORD dwFileType;//¼���ļ�����
       //�������ţ�0xff��ȫ����0����ʱ¼��,1-�ƶ���� ��2������������3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7-����¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    //�����ţ�0xff��ȫ����0����ʱ¼��1-�ƶ���⣬2���ӽ�������3������������4������������5-�������6���ֶ�¼��7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    DWORD dwIsLocked;//�Ƿ����� 0-�����ļ�,1-�����ļ�, 0xff��ʾ�����ļ�
    DWORD dwUseCardNo;//�Ƿ�ʹ�ÿ���
    BYTE sCardNumber[32];//����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
}NET_DVR_FILECOND, *LPNET_DVR_FILECOND;

//��̨����ѡ��Ŵ���С(˽�� ����ר��)
typedef struct 
{
    int xTop;     //������ʼ���x����
    int yTop;     //����������y����
    int xBottom;  //����������x����
    int yBottom;  //����������y����
    int bCounter; //����
}NET_DVR_POINT_FRAME, *LPNET_DVR_POINT_FRAME;

//�����Խ�����
typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;   //��Ƶ�������� 0-OggVorbis(G722.1);1-G711_U;2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM;9-G722.1.C;12-AAC_LC;13-AAC_LD;14-Opus;
    BYTE  byAudioSamplingRate;//��Ƶ������ 0-Ĭ�ϣ�1-16kHZ��2-32kHZ��3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// ��Ƶ���� �ο� BITRATE_ENCODE_INDEX
    BYTE  byres[4];//���ﱣ����Ƶ��ѹ������  
    BYTE  bySupport;//bySupport Bit0��ʾ Mp2l2ǰ4���ֽڵĺ����ʾ����������Ƶ���ݳ��� 
}NET_DVR_COMPRESSION_AUDIO, *LPNET_DVR_COMPRESSION_AUDIO;

//2009-7-22


#define IW_ESSID_MAX_SIZE                         32
#define WIFI_WEP_MAX_KEY_COUNT                     4
#define WIFI_WEP_MAX_KEY_LENGTH                     33
#define WIFI_WPA_PSK_MAX_KEY_LENGTH                 63
#define WIFI_WPA_PSK_MIN_KEY_LENGTH                 8
#define WIFI_MAX_AP_COUNT                         20
#define WIFI_WPA_PSK_MAX_HEXKEY_LENGTH           68   //WPA16������Կ��󳤶�

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;                        /* 0 mange ģʽ;1 ad-hocģʽ���μ�NICMODE */
    DWORD  dwSecurity;           /*0 �����ܣ�1 wep���ܣ�2 wpa-psk;3 wpa-Enterprise;4-WPA2_PSK�μ�WIFISECURITY*/
    DWORD  dwChannel;            /*1-11��ʾ11��ͨ��*/
    DWORD  dwSignalStrength;    /*0-100�ź���������Ϊ��ǿ*/
    DWORD  dwSpeed;               /*����,��λ��0.01mbps*/
}NET_DVR_AP_INFO,*LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;        /*����AP������������20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST,*LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{    
    char sIpAddress[16];                /*IP��ַ*/
    char sIpMask[16];                    /*����*/    
    BYTE    byMACAddr[MACADDR_LEN];        /*�����ַ��ֻ������ʾ*/
    BYTE    byCloseWifi;        //�Ƿ�ر�wifi���ӣ�0-���رգ�1-�ر�
    BYTE    bRes;
    DWORD    dwEnableDhcp;                /*�Ƿ�����dhcp  0������ 1����*/
    DWORD    dwAutoDns;                    /*�������dhcp�Ƿ��Զ���ȡdns,0���Զ���ȡ 1�Զ���ȡ�����������������dhcpĿǰ�Զ���ȡdns*/    
    char sFirstDns[16];                         /*��һ��dns����*/
    char sSecondDns[16];                     /*�ڶ���dns����*/
    char sGatewayIpAddr[16];                 /* ���ص�ַ*/
    BYTE   bRes2[8];
}NET_DVR_WIFIETHERNET,*LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;        /*wifi����*/
    char sEssid[IW_ESSID_MAX_SIZE];     /*SSID*/
    DWORD dwMode;      /* 0 mange ģʽ;1 ad-hocģʽ���μ�*/
    DWORD dwSecurity; /*0-������;1-WEP����;2-WPA-personal; 3-WPA-enterprise;4-WPA2-personal;5-WPA2-enterprise */
    union 
    {
        struct 
        {
            DWORD dwAuthentication;/*0 -����ʽ 1-����ʽ*/
            DWORD dwKeyLength;/* 0 -64λ��1- 128λ��2-152λ*/
            DWORD dwKeyType;/*0 16����;1 ASCI */
            DWORD dwActive;/*0 ������0---3��ʾ����һ����Կ*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct 
        {
            DWORD dwKeyLength;/*8-63��ASCII�ַ�*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2ģʽ�¼�������,0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//����Կ��֧��8-63��ASCII�ַ��Լ�64��ʮ�����ַ���Կ��
            //��byKeyTypeΪ0ʱ������sKeyInfo����byKeyTypeΪ1ʱ������sNewKeyInfo
            //��Կ���ͣ�0 ~ ����Կ���ͣ�ֻ֧��8-63��ASCII�ַ�����1 ~����Կ���ͣ�֧��8-63��ASCII�ַ��Լ�64��ʮ�����ַ���Կ��
            BYTE byKeyType; 
            BYTE byRes[7];
        }wpa_psk;
        struct 
        {
            BYTE byEncryptType;  /*��������,0-AES, 1-TKIP*/
            BYTE byAuthType; //��֤���ͣ�0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct 
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byAuthType; //�ڲ���֤��ʽ��0-PAP��1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity [NAME_LEN]; //�������
                    BYTE byUserName[NAME_LEN]; //�û���
                    BYTE byPassword[NAME_LEN]; //����
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterprisģʽ����
                struct 
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byAuthType; //�ڲ���֤��ʽ��0-GTC��1-MD5��2-MSCHAPV2
                    BYTE byPeapVersion; //PEAP�汾��0-�汾0��1-�汾1
                    BYTE byPeapLabel; //PEAP��ǩ��0-�ϱ�ǩ��1-�±�ǩ
                    BYTE byAnonyIdentity[NAME_LEN]; //�������
                    BYTE byUserName[NAME_LEN]; //�û���
                    BYTE byPassword[NAME_LEN]; //����
                    BYTE byRes[44]; 
                }EAP_PEAP; //WPA-enterprise/WPA2-enterprisģʽ����
                struct 
                {
                    BYTE byEapolVersion; //EAPOL�汾��0-�汾1��1-�汾2
                    BYTE byRes1[3]; 
                    BYTE byIdentity[NAME_LEN]; //���
                    BYTE byPrivateKeyPswd[NAME_LEN]; //˽Կ����
                    BYTE byRes[76]; 
                }EAP_TLS; 
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterprisģʽ����
    }key;    
}NET_DVR_WIFI_CFG_EX,*LPNET_DVR_WIFI_CFG_EX;

//wifi���ýṹ
typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG,*LPNET_DVR_WIFI_CFG;

//wifi����״̬
typedef     struct  tagNET_DVR_WIFI_CONNECT_STATUS
{
    DWORD        dwSize;
    BYTE        byCurStatus;    //1-�����ӣ�2-δ���ӣ�3-��������
    BYTE        byRes1[3];        //����
    DWORD        dwErrorCode;    // byCurStatus = 2ʱ��Ч,1-�û������������,2-�޴�·����,3-δ֪����
    BYTE        byRes[244];
}NET_DVR_WIFI_CONNECT_STATUS,*LPNET_DVR_WIFI_CONNECT_STATUS;

//wifi����ģʽ
typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode; /*0 �Զ��л�ģʽ��1 ����ģʽ*/
}NET_DVR_WIFI_WORKMODE,*LPNET_DVR_WIFI_WORKMODE;

//�ṹ�����궨�� 
#define VCA_MAX_POLYGON_POINT_NUM        10        //����������֧��10����Ķ����
#define MAX_RULE_NUM                    8        //����������
#define MAX_RULE_NUM_V42                16      //������������չ
#define MAX_TARGET_NUM                    30        //���Ŀ�����
#define MAX_CALIB_PT                     6        //���궨�����
#define MIN_CALIB_PT                     4        //��С�궨�����
#define MAX_TIMESEGMENT_2                2        //���ʱ�����
#define DATA_INDEX_LEN                  64      //������ˮ��
#define MAX_DEV_DATAINDEX_LEN           64      //�豸������ˮ��
#define MAX_TRAFFIC_PICTURE_NUM         8      //��ͨͼƬ����
#define MAX_LICENSE_LEN                    16        //���ƺ���󳤶�
#define MAX_LICENSE_LEN_EX                 32        //���ƺ���󳤶�
#define MAX_CARDNO_LEN                  48      //������󳤶� 2013-11-04
#define MAX_OPERATE_INDEX_LEN           32      //��������󳤶�2014-03-03
#define MAX_PLATE_NUM                    3        //���Ƹ���
#define MAX_MASK_REGION_NUM                4       //����ĸ���������
#define MAX_SEGMENT_NUM                    6       //������궨�����������Ŀ
#define MIN_SEGMENT_NUM                    3       //������궨��С��������Ŀ
#define MAX_REL_SNAPCHAN_NUM            3       //������ץͼͨ����
#define MAX_PIC_SWITCH_STORAGE_SERVER   64      //�ƴ洢�������洢�����ͼƬ������
#define MAX_INFO_SWITCH_STORAGE_SERVER  64      //�ƴ洢�������洢����󸽼���Ϣ������
#define RTMP_URL_LEN                    128     //RTMP URL ����
#define MAX_ID_LEN_128                  128     //�����ļ�ID����
#define MAX_DEBUGCMD_LEN                1024    //�豸����������󳤶�
#define MAX_DEBUGINFO_LEN               1400    //�豸������Ϣ��󳤶�
#define MAX_VEHICLE_ID_LEN              32      //�������ʶ����
#define LEN_PROPERTY                    128
typedef    struct
{
    DWORD    dwSize; //���α��ĳ���,
    NET_DVR_TIME_EX    strStartTime;  //��ʼʱ��
    NET_DVR_TIME_EX    strStopTime;  //����ʱ��
    char     sLicense[MAX_LICENSE_LEN_EX/*32*/];    //���ƺ���
    DWORD      dwChannel;
    BYTE      byRegion;
    BYTE      byRes[127]; // ��������ֵ 0-������1-ŷ��(Europe Region)��2-��������(Russian Region)��3-ŷ��&����˹(EU&CIS) , 4-�ж���Middle East����0xff-����
}NET_DVR_VEHICLE_INFO_COND, *LPNET_DVR_VEHICLE_INFO_COND;

typedef  struct
{
    DWORD     dwSize;
    DWORD     dwIndex;//���    
    BYTE    byDeviceID[DEVICE_ID_LEN/*48*/];    //�豸���
    BYTE    byBelieve;//���Ŷȣ�0-100    
    BYTE    byDir;//����0-�����壬1-����2-����3-δ֪
    BYTE    byLineID;//������
    BYTE   byRes1;
    NET_DVR_TIME_EX  struSnapTime;//ץ��ʱ��
    char    sLicense[MAX_LICENSE_LEN_EX/*32*/];        //���ƺ���
    BYTE    byMonitoringSiteID[MONITORSITE_ID_LEN /*48*/];    //������
    BYTE    byCountry; // ��������ֵ������ö��COUNTRY_INDEX����֧�֡�COUNTRY_ALL = 0xff, //ALL  ȫ������
    BYTE    byMatchingResult;//�ڰ�����ƥ������0-������1-��������2-��������3-����
    BYTE    byArea;                         //����ʡ�ݣ����������ڲ�����ö�٣����������� EMI_AREA
    BYTE    byPlateType;                    //�������� �ο� VCA_PLATE_TYPE
    char    sDeviceName[NAME_LEN/*32*/];    //�豸����
    BYTE  	byPlateColor;						//������ɫ �ο� VCA_PLATE_COLOR
    BYTE  	byPlateSize;						//���Ƴߴ磬0~δ֪��1~long, 2~short(�ж�����ʹ��)
    BYTE    byRes2[2];
    char    sPlateCategory[MAX_CATEGORY_LEN/*8*/];		//���Ƹ�����Ϣ, ������С����Ϣ��(Ŀǰֻ���ж�����֧��)
    char    sPlateImageURL[URL_LEN_V40/*256*/];         //����СͼURL
    char    sEffectiveTime[ISO_8601_LEN/*32*/];    //������Ϣ��Чʱ�䣬ʹ��ISO8601 time��ʽ���磺2009-11-14T15:27Z
    BYTE    byRes[176];
}NET_DVR_VEHICLE_INFO_CFG, *LPNET_DVR_VEHICLE_INFO_CFG;

//���ܿ�����Ϣ
#define MAX_VCA_CHAN  16//�������ͨ����
typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;        //�Ƿ�������
    BYTE   byVCAType;        //�����������ͣ�VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //�������Ƿ��������Ϣ
    BYTE   byMode;            //ģʽ��ATM����ʱ����VCA_CHAN_MODE_TYPE ,TFS����ʱ����TFS_CHAN_MODE_TYPE
    BYTE   byControlType;   //�������ͣ���λ��ʾ��0-��1-��
    // byControlType &1 �Ƿ�����ץ�Ĺ���
    BYTE   byPicWithVCA ;// ����ץͼ����Ŀ����Ϣ(Ŀ���)��0-�����ӣ�Ĭ�ϣ���1-���ӣ�
    BYTE   byRes[2];         //����������Ϊ0 
}NET_VCA_CTRLINFO, * LPNET_VCA_CTRLINFO;

//���ܿ�����Ϣ�ṹ
typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN];     //������Ϣ,����0��Ӧ�豸����ʼͨ��
    BYTE byRes[16];
}NET_VCA_CTRLCFG, * LPNET_VCA_CTRLCFG;

//�����豸������
typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;              //�ṹ����
    BYTE byVCAChanNum;         //����ͨ������
    BYTE byPlateChanNum;       //����ͨ������
    BYTE byBBaseChanNum;       //��Ϊ���������
    BYTE byBAdvanceChanNum;    //��Ϊ�߼������
    BYTE byBFullChanNum;       //��Ϊ���������
    BYTE byATMChanNum;           //����ATM����
    BYTE byPDCChanNum;         //����ͳ��ͨ������
    BYTE byITSChanNum;         //��ͨ�¼�ͨ������
    BYTE byBPrisonChanNum;     //��Ϊ������(����)ͨ������
    BYTE byFSnapChanNum;       //����ץ��ͨ������
    BYTE byFSnapRecogChanNum;  //����ץ�ĺ�ʶ��ͨ������
    BYTE byFRetrievalChanNum;  //�������������
    BYTE bySupport;            //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport & 0x1����ʾ�Ƿ�֧�����ܸ��� 2012-3-22
    //bySupport & 0x2����ʾ�Ƿ�֧��128·ȡ����չ2012-12-27
    BYTE byFRecogChanNum;      //����ʶ��ͨ������
    BYTE byBPPerimeterChanNum; //��Ϊ������(�ܽ�)ͨ������
    BYTE byTPSChanNum;         //��ͨ�յ�ͨ������
    BYTE byTFSChanNum;         //��·Υ��ȡ֤ͨ������
    BYTE byFSnapBFullChanNum;  //����ץ�ĺ���Ϊ����ͨ������
    BYTE byHeatMapChanNum;     //�ȶ�ͼͨ������
    BYTE bySmartVehicleNum;    //SMART�¼�+�������ͨ������
    BYTE bySmartHVTNum;       //SMART�¼�+���м��ͨ������
    BYTE bySmartNum;          //SMART�¼�����
    BYTE byVehicleNum;        //�������ͨ������
    BYTE bySmartRoadDetectionNum ; // SMART�¼�+��·���ͨ������
    BYTE bySmartFaceDetectionNum ; // SMART�¼�+�������ͨ������
    BYTE bySmartHeatMapNum ; // SMART�¼�+�ȶ�ͼͨ������
    BYTE byHumanRecognitionNum; //����ʶ��ͨ������
    BYTE byEdcationStudentNum; //����¼����ѧ���������&&ѧ������ͳ�ƣ�֧�ֵ�ͨ����
    BYTE byRoadDetectionNum;//��·���ͨ������
    BYTE byPersonDensityDetection; //��Ա�ܶȼ��ͨ������
    BYTE bySafetyHelmetDetection; //��ȫñ���ͨ������
    BYTE byPerimeterCapture;//�ܽ�ץ��ͨ������
    BYTE byHeelPDC;//��б����ͨ������
    BYTE by12MPLiveView;// ������ 1200W@20fpsԤ����4000*3000��
    BYTE byTeacherBehaviorDetectNum; //����¼������ʦ��Ϊ��⣩֧�ֵ�ͨ����
    BYTE byMixedTargetDetection;//���Ŀ����ͨ������
    BYTE byFaceContrast;//�����ȶԼ��ͨ������
    BYTE byCityManagement;//�ǻ۳ǹܼ��ͨ������
    BYTE byMixedTargetDetectionSmart;//���Ŀ����+Smart�¼�
    BYTE byRes;
}NET_VCA_DEV_ABILITY, *LPNET_VCA_DEV_ABILITY;


//��Ϊ������������
typedef enum _VCA_ABILITY_TYPE_
{
    TRAVERSE_PLANE_ABILITY      = 0x01,       //��Խ������
        ENTER_AREA_ABILITY          = 0x02,       //��������
        EXIT_AREA_ABILITY           = 0x04,       //�뿪����
        INTRUSION_ABILITY           = 0x08,       //����
        LOITER_ABILITY              = 0x10,       //�ǻ�
        LEFT_TAKE_ABILITY           = 0x20,       //��Ʒ������ȡ
        PARKING_ABILITY             = 0x40,       //ͣ��
        RUN_ABILITY                 = 0x80,       //�����ƶ�
        HIGH_DENSITY_ABILITY        = 0x100,      //��Ա�ۼ�
        LF_TRACK_ABILITY            = 0x200,      //�������
        VIOLENT_MOTION_ABILITY        = 0x400,      //�����˶����
        REACH_HIGHT_ABILITY            = 0x800,      //�ʸ߼��
        GET_UP_ABILITY                = 0x1000,     //������
        LEFT_ABILITY                = 0x2000,     //��Ʒ����
        TAKE_ABILITY                = 0x4000,     //��Ʒ��ȡ
        LEAVE_POSITION              = 0x8000,     //���
        TRAIL_ABILITY               = 0x10000,    //β�� 
        KEY_PERSON_GET_UP_ABILITY   = 0x20000,    //�ص���Ա������
        STANDUP_ABILITY             = 0x40000,   //����
        FALL_DOWN_ABILITY           = 0x80000,    //����
        AUDIO_ABNORMAL_ABILITY      = 0x100000,   //��ǿͻ��
        ADV_REACH_HEIGHT_ABILITY    = 0x200000,   //�����ʸ�
        TOILET_TARRY_ABILITY        = 0x400000,   //��޳�ʱ
        YARD_TARRY_ABILITY          = 0x800000,   //�ŷ糡����
        ADV_TRAVERSE_PLANE_ABILITY  = 0x1000000,  //���߾�����
        LECTURE_ABILITY                = 0x2000000,  //�ڿ�
        ANSWER_ABILITY                = 0x4000000,  //�ش�����
        HUMAN_ENTER_ABILITY         = 0x10000000, //�˿���ATM ,ֻ��ATM_PANELģʽ��֧��
        OVER_TIME_ABILITY           = 0x20000000, //������ʱ,ֻ��ATM_PANELģʽ��֧��
        STICK_UP_ABILITY            = 0x40000000, //��ֽ��
        INSTALL_SCANNER_ABILITY     = 0x80000000  //��װ������
}VCA_ABILITY_TYPE;

typedef enum _VCA_ABILITY_TYPE_EX_
{ 
    PEOPLENUM_CHANGE_ABILITY = 0x00000002, //�����仯���
    SPACING_CHANGE_ABILITY = 0x00000004,    //���仯���
    EVENT_COMBINED_ABILITY = 0x00000008,    //����¼�����
    EVENT_SIT_QUIETLY =        0x00000010,    //����
    EVENT_HIGH_DENSITY_STATUS_ABILITY = 0x00000020,    //��Ա�ۼ�״̬
    EVENT_RUNNING = 0x00000040,        //����
    EVENT_RETENTION = 0x00000080, //����
    EVENT_TEACHER_WRITING = 0x00000100 //����
}VCA_ABILITY_TYPE_EX;

//����ͨ������
typedef enum _VCA_CHAN_ABILITY_TYPE_
{
    VCA_BEHAVIOR_BASE     =  1,          //��Ϊ����������
    VCA_BEHAVIOR_ADVANCE  =  2,          //��Ϊ�����߼���
    VCA_BEHAVIOR_FULL     =  3,          //��Ϊ����������
    VCA_PLATE               =  4,          //��������
    VCA_ATM               =  5,          //ATM����
    VCA_PDC               =  6,          //������ͳ��
    VCA_ITS               =  7,          //���� ��ͨ�¼�
    VCA_BEHAVIOR_PRISON   =  8,          //��Ϊ����������(����) 
    VCA_FACE_SNAP         =  9,          //����ץ������
    VCA_FACE_SNAPRECOG    = 10,          //����ץ�ĺ�ʶ������
    VCA_FACE_RETRIEVAL    = 11,          //�������������
    VCA_FACE_RECOG        = 12,          //����ʶ������
    VCA_BEHAVIOR_PRISON_PERIMETER =  13, // ��Ϊ���������� (�ܽ�)
    VCA_TPS               = 14,          //��ͨ�յ�
    VCA_TFS               = 15,          //��·Υ��ȡ֤
    VCA_BEHAVIOR_FACESNAP = 16,          //����ץ�ĺ���Ϊ��������
    VCA_HEATMAP           =  17,         //�ȶ�ͼ
    VCA_SMART_VEHICLE_DETECTION  =  18,  // SMART�¼�+�������
    VCA_SMART_HVT_DETECTION      =  19,  // SMART�¼�+���м��
    VCA_SMART_EVENT          =  20,      // SMART�¼�
    VCA_VEHICLE_DETECTION    =  21,      // �������
    VCA_SMART_ROAD_DETECTION =  22,      // SMART�¼�+��·���
    VCA_SMART_FACE_DETECTION =  23,      // SMART�¼�+�������
    VCA_SMART_HEATMAP        =  24,       // SMART�¼�+�ȶ�ͼ
    VCA_HUMAN_RECOGNITION = 25 ,      // ����ʶ��
    VCA_EDUCATION_STUDENT_DETECTION = 26,  //����¼����ѧ���������&&ѧ������ͳ�ƣ�
    VCA_ROAD_DETECTION = 27,      //��·���
    VCA_PERSON_DENSITY_DETECTION = 28,     //��Ա�ܶȼ��
    VCA_PERIMETER_CAPTURE = 29,            //�ܽ�ץ��
    VCA_SAFETY_HELMET_DETECTION = 30,      //��ȫñ���
    VCA_HEEL_PDC = 31,                      //��б����
    VCA_12MPLIVE_VIEW = 32,                 //������ 1200W@20fpsԤ����4000*3000��
    VCA_TEACHER_BEHAVIOR_DETECTION = 33,    //��ʦ��Ϊ���
    VCA_MIXED_TARGET_DETECTION = 34,    //���Ŀ����
    VCA_FACE_CONTRAST = 35,             //�����Աȼ��(ͬʱ֧������ץ�ļ������Աȹ��ܣ������㷨���Ĳ�ͬ���㷨���������ȶ�Ϊ���ģ�ȷ��ÿ�αȶԳɹ�����Ŀ�겻�ʺ϶Ա��������Ը�Ŀ�����ץ�ġ�)
    VCA_CITY_MANAGEMENT = 36,             //�ǻ۳ǹ�
    VCA_MIXED_TARGET_DETECTION_SMART = 37   //���Ŀ�����Smart
}VCA_CHAN_ABILITY_TYPE;

//����ATMģʽ����(ATM��������)
typedef enum _VCA_CHAN_MODE_TYPE_
{
    VCA_ATM_PANEL     =  0,  //ATM���
        VCA_ATM_SURROUND  =  1,  //ATM����
        VCA_ATM_FACE      =  2,     //ATM����
        VCA_ATM_SAFETYCABIN = 3  //ATM������
}VCA_CHAN_MODE_TYPE;

//��ͨȡ֤TFSͨ��ģʽ(TFS��������)
typedef enum _TFS_CHAN_MODE_TYPE_
{
    TFS_CITYROAD    =  0,  //TFS ���е�·
        TFS_FREEWAY     =  1   //TFS ���ٵ�·
}TFS_CHAN_MODE_TYPE;

//��Ϊ��������ģʽ
typedef enum _BEHAVIOR_SCENE_MODE_TYPE_
{
    BEHAVIOR_SCENE_DEFAULT = 0, //ϵͳĬ��
        BEHAVIOR_SCENE_WALL = 1,    //Χǽ
        BEHAVIOR_SCENE_INDOOR = 2   //����
}BEHAVIOR_SCENE_MODE_TYPE;

//����ģʽ
typedef enum _BEHAVIOR_PRISON_MODE_TYPE_
{
    BEHAVIOR_PRISON                 = 0, //����
        BEHAVIOR_HEARING                  = 1, //��Ѷ��
        BEHAVIOR_RECFIELD                 = 2  //�ŷ糡
}BEHAVIOR_PRISON_MODE_TYPE,LPBEHAVIOR_PRISON_MODE_TYPE;


//ͨ�������������
typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;        //VCA_CHAN_ABILITY_TYPEö��ֵ
    BYTE byMode;        //ģʽ��ATM ����ʱ����VCA_CHAN_MODE_TYPE,TFS����ʱ����TFS_CHAN_MODE_TYPE,��VCA_TYPE Ϊ��ͨ�¼�ʱ����TRAFFIC_SCENE_MODE
    BYTE byRes[2];         //����������Ϊ0 
}NET_VCA_CHAN_IN_PARAM, *LPNET_VCA_CHAN_IN_PARAM;


//��Ϊ�������ṹ
typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;         //�ṹ����
    DWORD dwAbilityType; //֧�ֵ��������ͣ���λ��ʾ����VCA_ABILITY_TYPE����
    BYTE  byMaxRuleNum;     //��������
    BYTE  byMaxTargetNum; //���Ŀ����
    BYTE  bySupport;        // ֧�ֵĹ�������   ��λ��ʾ  
    // bySupport & 0x01 ֧�ֱ궨����
    BYTE  byRes[5];         //����������Ϊ0 
    DWORD dwAbilityTypeEx;  //֧�ֵ��������ͣ���λ��ʾ����VCA_ABILITY_TYPE_EX����
}NET_VCA_BEHAVIOR_ABILITY, *LPNET_VCA_BEHAVIOR_ABILITY;

//����������ݸ��²���
typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD    dwSize;
    BYTE    byIDCount;    //ʵ����ID��
    BYTE    byRes1[3];
    BYTE    byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

// ��ͨ�������ṹ
typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD     dwSize;             // �ṹ���С
    DWORD     dwAbilityType;      // ֧�ֵ������б�  ����ITS_ABILITY_TYPE
    BYTE     byMaxRuleNum;         //��������
    BYTE     byMaxTargetNum;     //���Ŀ����
       BYTE    byRes[10];            // ����
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;

/***********************************end*******************************************/

/************************************���ܲ����ṹ*********************************/
//���ܹ��ýṹ
//����ֵ��һ��,������ֵΪ��ǰ����İٷֱȴ�С, ����ΪС�������λ

//��Ϊ�����¼�����
typedef enum _VCA_EVENT_TYPE_
{
    VCA_TRAVERSE_PLANE     = 0x1,        //��Խ������
        VCA_ENTER_AREA         = 0x2,        //Ŀ���������,֧���������
        VCA_EXIT_AREA           = 0x4,        //Ŀ���뿪����,֧���������
        VCA_INTRUSION          = 0x8,        //�ܽ�����,֧���������
        VCA_LOITER             = 0x10,       //�ǻ�,֧���������
        VCA_LEFT_TAKE          = 0x20,       //��Ʒ������ȡ,֧���������
        VCA_PARKING               = 0x40,       //ͣ��,֧���������
        VCA_RUN                   = 0x80,       //�����ƶ�,֧���������
        VCA_HIGH_DENSITY       = 0x100,      //��������Ա�ۼ�,֧���������
        VCA_VIOLENT_MOTION     = 0x200,         //�����˶����
        VCA_REACH_HIGHT        = 0x400,         //�ʸ߼��
        VCA_GET_UP             = 0x800,         //������
        VCA_LEFT               = 0x1000,     //��Ʒ����
        VCA_TAKE               = 0x2000,     //��Ʒ��ȡ
        VCA_LEAVE_POSITION     = 0x4000,     //���
        VCA_TRAIL              = 0x8000,     //β��
        VCA_KEY_PERSON_GET_UP  = 0x10000,    //�ص���Ա������
        VCA_STANDUP            = 0x20000,    //����
        VCA_FALL_DOWN          = 0x80000,    //���ؼ��
        VCA_AUDIO_ABNORMAL     = 0x100000,   //��ǿͻ����
        VCA_ADV_REACH_HEIGHT   = 0x200000,   //�����ʸ�
        VCA_TOILET_TARRY       = 0x400000,   //��޳�ʱ
        VCA_YARD_TARRY         = 0x800000,   //�ŷ糡����
        VCA_ADV_TRAVERSE_PLANE = 0x1000000,  //���߾�����
        VCA_LECTURE            = 0x2000000,  //�ڿ�
        VCA_ANSWER             = 0x4000000,  //�ش�����
        VCA_HUMAN_ENTER        = 0x10000000, //�˿���ATM           ֻ��ATM_PANELģʽ��֧��
        VCA_OVER_TIME          = 0x20000000, //������ʱ            ֻ��ATM_PANELģʽ��֧��
        VCA_STICK_UP           = 0x40000000, //��ֽ��,֧���������
        VCA_INSTALL_SCANNER    = 0x80000000  //��װ������,֧���������
}VCA_EVENT_TYPE;

//��Ϊ�����¼�������չ
typedef enum _VCA_RULE_EVENT_TYPE_EX_
{
    ENUM_VCA_EVENT_TRAVERSE_PLANE     = 1,   //��Խ������
        ENUM_VCA_EVENT_ENTER_AREA         = 2,   //Ŀ���������,֧���������
        ENUM_VCA_EVENT_EXIT_AREA          = 3,   //Ŀ���뿪����,֧���������
        ENUM_VCA_EVENT_INTRUSION          = 4,   //�ܽ�����,֧���������
        ENUM_VCA_EVENT_LOITER             = 5,   //�ǻ�,֧���������
        ENUM_VCA_EVENT_LEFT_TAKE          = 6,   //��Ʒ������ȡ,֧���������
        ENUM_VCA_EVENT_PARKING            = 7,   //ͣ��,֧���������
        ENUM_VCA_EVENT_RUN                = 8,   //�����ƶ�,֧���������
        ENUM_VCA_EVENT_HIGH_DENSITY       = 9,   //��������Ա�ۼ�,֧���������
        ENUM_VCA_EVENT_VIOLENT_MOTION     = 10,  //�����˶����
        ENUM_VCA_EVENT_REACH_HIGHT        = 11,  //�ʸ߼��
        ENUM_VCA_EVENT_GET_UP             = 12,  //������
        ENUM_VCA_EVENT_LEFT               = 13,  //��Ʒ����
        ENUM_VCA_EVENT_TAKE               = 14,  //��Ʒ��ȡ
        ENUM_VCA_EVENT_LEAVE_POSITION     = 15,  //���
        ENUM_VCA_EVENT_TRAIL              = 16,  //β��
        ENUM_VCA_EVENT_KEY_PERSON_GET_UP  = 17,  //�ص���Ա������
        ENUM_VCA_EVENT_STANDUP            = 18,  //����
        ENUM_VCA_EVENT_FALL_DOWN          = 20,  //���ؼ��
        ENUM_VCA_EVENT_AUDIO_ABNORMAL     = 21,  //��ǿͻ����
        ENUM_VCA_EVENT_ADV_REACH_HEIGHT   = 22,  //�����ʸ�
        ENUM_VCA_EVENT_TOILET_TARRY       = 23,  //��޳�ʱ
        ENUM_VCA_EVENT_YARD_TARRY         = 24,  //�ŷ糡����
        ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,  //���߾�����
        ENUM_VCA_EVENT_LECTURE            = 26,  //�ڿΣ��Ḷ̌�
        ENUM_VCA_EVENT_ANSWER             = 27,  //�ش����⣨�Ḷ̌�
        ENUM_VCA_EVENT_HUMAN_ENTER        = 29,  //�˿���ATM,ֻ��ATM_PANELģʽ��֧��   
        ENUM_VCA_EVENT_OVER_TIME          = 30,  //������ʱ,ֻ��ATM_PANELģʽ��֧��
        ENUM_VCA_EVENT_STICK_UP           = 31,  //��ֽ��,֧���������
        ENUM_VCA_EVENT_INSTALL_SCANNER    = 32,  //��װ������,֧���������
        ENUM_VCA_EVENT_PEOPLENUM_CHANGE   = 35,  //�����仯�¼�
        ENUM_VCA_EVENT_SPACING_CHANGE     = 36,  //���仯�¼�
        ENUM_VCA_EVENT_COMBINED_RULE      = 37,   //��Ϲ����¼�
        ENUM_VCA_EVENT_SIT_QUIETLY        = 38,   //һ��������������    ���¼�
        ENUM_VCA_EVENT_HIGH_DENSITY_STATUS= 39,   //��������Ա�ۼ�״̬
        ENUM_VCA_EVENT_RUNNING = 40, //���ܼ��
        ENUM_VCA_EVENT_RETENTION = 41, //�������
        ENUM_VCA_EVENT_BLACKBOARD_WRITE = 42,   //����
        ENUM_VCA_EVENT_SITUATION_ANALYSIS = 43,   //̬�Ʒ���
        ENUM_VCA_EVENT_PLAY_CELLPHONE = 44,    //���ֻ����
        ENUM_VCA_EVENT_DURATION = 45     //��������
} VCA_RULE_EVENT_TYPE_EX;

//�����洩Խ��������
typedef enum _VCA_CROSS_DIRECTION_
{
    VCA_BOTH_DIRECTION,  // ˫�� 
        VCA_LEFT_GO_RIGHT,   // �������� 
        VCA_RIGHT_GO_LEFT    // �������� 
}VCA_CROSS_DIRECTION;

//�߽ṹ
typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;    //��� 
    NET_VCA_POINT struEnd;      //�յ�
}NET_VCA_LINE, *LPNET_VCA_LINE;

//����ͽṹ��
typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                  //��Ч�� ���ڵ���3������3����һ��������Ϊ����Ч�����߽�����Ϊ����Ч���� 
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM]; //����α߽��,���ʮ�� 
}NET_VCA_POLYGON, *LPNET_VCA_POLYGON;

//���������
typedef struct tagNET_VCA_TRAVERSE_PLANE
{    
    NET_VCA_LINE struPlaneBottom;          //������ױ�
    VCA_CROSS_DIRECTION dwCrossDirection;  //��Խ����: 0-˫��1-�����ң�2-���ҵ���
    BYTE bySensitivity;                    //�����Ȳ�������Χ[1,5]
    BYTE byPlaneHeight;                    //������߶�
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//���ȼ�,0~��,1~��,2~��
    BYTE byRes2[36];                       //������
}NET_VCA_TRAVERSE_PLANE, *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//����Χ
    //���򴥷�˳��0-˳������򴥷���1-˳�򴥷�
    DWORD   dwDuration;         //����ʱ��  ��λs ��Χ1-3600
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

//����/�뿪�������
typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1,5]
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//���ȼ�,0~��,1~��,2~��
    BYTE byRes[5];
}NET_VCA_AREA, *LPNET_VCA_AREA;

//���ݱ����ӳ�ʱ������ʶ�����д�ͼƬ�����������IO����һ�£�1�뷢��һ����
//���ֲ���
typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration;            //��Ϊ�¼�����ʱ����ֵ: 1-120�룬����5�룬�ж�����Ч������ʱ��  ��ATMϵͳ�д����ļ���ֵΪ 1-1000��
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byRate;               //ռ�ȣ�����������δ����Ŀ��ߴ�Ŀ��ռ��������ı��أ���һ��Ϊ����
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//���ȼ�,0~��,1~��,2~��
    BYTE byRes[2];             //����
}NET_VCA_INTRUSION, *LPNET_VCA_INTRUSION;

//�ǻ�����
typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��1-120�룬����10��
    BYTE bySensitivity;            //�����Ȳ�������Χ[1,5]
    BYTE byRes[1];
    DWORD dwLoiterDistance; //�г��ܾ�����ֵ��100-5000��Ĭ��1000cm
}NET_VCA_LOITER, *LPNET_VCA_LOITER;

//��Ʒ����/��Ʒ��ȡ����
typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��1-120�룬����10��
    BYTE bySensitivity;            //�����Ȳ�������Χ[1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT, *LPNET_VCA_TAKE_LEFT;

//ͣ������
typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;    //����Χ
    WORD wDuration;                //����ʱ����ֵ��1-100�룬����10��
    BYTE bySensitivity;            //�����Ȳ�������Χ[1,5]
    BYTE byRes[5];
}NET_VCA_PARKING, *LPNET_VCA_PARKING;

//�����ƶ�����
typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion;    //����Χ
    float  fRunDistance;        //�˿����ƶ�������, ��Χ: [0.1, 1.00] ����ģʽ ʵ��ģʽ(1,20)m/s
    BYTE bySensitivity;            //�����Ȳ�������Χ[1,5]
    BYTE byMode;     // 0 ����ģʽ  1 ʵ��ģʽ
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ������
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes;
}NET_VCA_RUN, *LPNET_VCA_RUN;

//��Ա�ۼ�����
typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;        //����Χ
    float           fDensity;       //�ۼ�����, ��Χ: [0.1, 1.0]
    BYTE            bySensitivity;    //�����Ȳ�������Χ[1,5]
    BYTE            byRes;          // �����ֽ�
    WORD            wDuration;      // ������Ա�ۼ�����������ֵ 20-360s
}NET_VCA_HIGH_DENSITY, *LPNET_VCA_HIGH_DENSITY; 

//�����˶�����
typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wDuration;           //���������˶�������ֵ��1-50��
    BYTE  bySensitivity;       //�����Ȳ�������Χ[1,5]
    BYTE  byMode;              //0-����Ƶģʽ��1-����Ƶ����ģʽ��2-����Ƶģʽ
    BYTE  byRes[4];            //����
}NET_VCA_VIOLENT_MOTION, *LPNET_VCA_VIOLENT_MOTION; 

// �ʸ߲���
typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;   //�ʸ߾�����
    WORD wDuration; //�����ʸ߱�����ֵ��1-120��
    BYTE    byRes[6];           // �����ֽ�
}NET_VCA_REACH_HIGHT, *LPNET_VCA_REACH_HIGHT;

// �𴲲���
typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion; //����Χ
    WORD    wDuration;            //�����𴲱�����ֵ1-100 ��
    BYTE    byMode;             //������ģʽ,0-��ͨ��ģʽ,1-�ߵ���ģʽ,2-��ͨ����������ģʽ
    BYTE    bySensitivity;      //�����Ȳ�������Χ[1,10]
    BYTE    byRes[4];            //�����ֽ�
}NET_VCA_GET_UP, * LPNET_VCA_GET_UP;

// ��Ʒ����
typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion; // ����Χ
    WORD       wDuration;       // ������Ʒ����������ֵ 10-100��
    BYTE       bySensitivity;   // �����Ȳ�������Χ[1,5] 
    BYTE       byRes[5];        // �����ֽ�
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

// ��Ʒ��ȡ
typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // ����Χ
    WORD            wDuration;      // ������Ʒ��ȡ������ֵ10-100��
    BYTE            bySensitivity;  // �����Ȳ�������Χ[1,5] 
    BYTE            byRes[5];       // �����ֽ�
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion;    // ����Χ
    WORD               wDuration;  // ��������ʱ����ֵ 4s-60000s
    BYTE   byRes[6];   // �����ֽ�
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];            //�����ֽ�
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

//��ֽ������
typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //����ʱ����ֵ��4-60�룬����10��
    BYTE  bySensitivity;       //�����Ȳ�������Χ[1,5]
    BYTE byRes[5];
}NET_VCA_STICK_UP, *LPNET_VCA_STICK_UP; 

//����������
typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //��������ʱ�䣺4-60��
    BYTE bySensitivity;       //�����Ȳ�������Χ[1,5]
    BYTE byRes[5];
}NET_VCA_SCANNER, *LPNET_VCA_SCANNER; 

//����¼�
typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //����Χ
    WORD   wLeaveDelay;  //���˱���ʱ�䣬��λ��s
    WORD   wStaticDelay; //˯������ʱ�䣬��λ��s
    BYTE   byMode;       //ģʽ��0-����¼���1-˯���¼���2-���˯���¼�
    BYTE   byPersonType; //ֵ���������ͣ�0-����ֵ�ڣ�1-˫��ֵ��
    BYTE   byOnPosition; //�ڸ�������1-10��Ĭ��1
    BYTE   bySensitivity;     //�����Ȳ�������Χ[1,5]
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

//β�����
typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wRes;      /* ���� */
    BYTE  bySensitivity;       /* �����Ȳ�������Χ[1,5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

//���ز���
typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD  wDuration;      /* �����¼���ֵ 1-60s*/
    BYTE  bySensitivity;       /* �����Ȳ�������Χ[1,5] */
    BYTE  byHeightThreshold; //�߶���ֵ����Χ[0,250]��Ĭ��90����λ������
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

//����
typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //����Χ
    BYTE  bySensitivity;     //�����Ȳ�������Χ[1,100]
    BYTE  byHeightThreshold; //�߶���ֵ����Χ[0,250]��Ĭ��130����λ������
    WORD  wDuration;         //�����¼���ֵ[1,3600]��Ĭ��2����λ����
    BYTE  byRes[4];          //����
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;


//�����仯
typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //����Χ
    BYTE  bySensitivity;  //�����Ȳ�������Χ[1,100]
    BYTE  byPeopleNumThreshold; //������ֵ����Χ[0,5]��Ĭ��1 
    BYTE  byDetectMode; //��ⷽʽ����������ֵ��Ƚϡ�1-���ڣ�2-С�ڣ�3-���ڣ�4-������
    BYTE  byNoneStateEffective; //����״̬�Ƿ���Ч��0-��Ч��1-��Ч
    WORD  wDuration;  //����ʱ����ֵ[1,3600]��Ĭ��2����λ����
    BYTE  byPeopleNum; //��������������ֻ�����������ϱ����豸����0��ʾ��֧�ֱ������ϱ���0xff��ʾ��������Ϊ0
    BYTE  byRes;   //����
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

//���仯
typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //����Χ
    float fSpacingThreshold; //�����ֵ����Χ[0,10.0]��Ĭ��1.0����λ����
    BYTE  bySensitivity;  //�����Ȳ�������Χ[1,100]
    BYTE  byDetectMode; //��ⷽʽ��������ֵ��Ƚϡ�1-���ڣ�2-С��
    WORD  wDuration;  //����ʱ����ֵ[1,3600]��Ĭ��2����λ����
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;


//��ǿͻ�����
typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //����ǿ��
    BYTE bySensitivity;  //�����Ȳ�������Χ[1,100] 
    BYTE byAudioMode;    //�������ģʽ��0-�����ȼ�⣬1-�ֱ���ֵ��⣬2-��������ֱ���ֵ��� 
    BYTE byEnable;       //ʹ�ܣ��Ƿ���(��ǿͻ�䣬����)
    BYTE byThreshold;    //������ֵ[1,100]
    BYTE byRes[54];      //����   
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

//��ǿ���� 2014-03-21
typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* �����Ȳ�������Χ[1,100] */
    BYTE  byEnable;        //ʹ�ܣ��Ƿ���(��ǿͻ�䣬����)
    BYTE  byRes[6];    
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;


typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;//ʹ�ܣ��Ƿ���
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;  
    NET_DVR_SCHEDTIME            struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;     //�쳣����ʽ
    DWORD                       dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD                       dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //��ǿ����
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDelay;        //��޳�ʱʱ��[1,3600]����λ����
    BYTE byRes[6];    
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDelay;        //�ŷ糡����ʱ��[1,120]����λ����
    BYTE byRes[6];    
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //�ʸ�����
    DWORD   dwCrossDirection;   //��Խ����(���VCA_CROSS_DIRECTION): 0-˫��1-������2-���ҵ���
    BYTE    byRes[4];            // �����ֽ�
}NET_VCA_ADV_REACH_HEIGHT, * LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //����������
    DWORD   dwCrossDirection;   //��Խ����(���VCA_CROSS_DIRECTION): 0-˫��1-������2-���ҵ���
    BYTE    bySensitivity;      //�����Ȳ�������Χ[1,5] 
    BYTE    byRes[3];            //�����ֽ�
} NET_VCA_ADV_TRAVERSE_PLANE,*LPNET_VCA_ADV_TRAVERSE_PLANE;

typedef struct tagNET_VCA_PLAY_CELLPHONE
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration;    //���ֻ���ʱʱ��[1,600]��, Ĭ��20��
    BYTE byRes[6];     //�����ֽ�
}NET_VCA_PLAY_CELLPHONE, *LPNET_VCA_PLAY_CELLPHONE;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//����Χ
    WORD wDuration; //��Ϊ�¼�����ʱ����ֵ: 1-10�룬����1�룬�ж�����Ч������ʱ��
    BYTE bySensitivity; //�����Ȳ�������Χ[1-100]
    BYTE byAlarmState;//ֻ���ֶν��治��ʾ��0-����,1-������ʼ,2-�������� 
    BYTE byTrackingMode ;//����ģʽ��0-�Զ�(Ĭ��) , 1-ˮƽ, 2-��ֱ
    BYTE byZoomMode;//�䱶ģʽ, 0-�̶�(Ĭ��), 1-�Զ�
    BYTE byZoomOver;//0-����,1-�䱶��λ(�����ϴ�¼����������Ϊ�л������ж�����)
    BYTE byTrackStatus;//����״̬ 0-������1-��ʼ�ڿΣ�A��ȫ���� 2-���ڸ��٣�2,��д����3 -���ٶ�ʧ��2,ȫ����
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;//�����Ȳ�������Χ[1-100]
    BYTE byAlarmState;//ֻ���ֶν��治��ʾ��0-����,1-������ʼ,2-��������
    BYTE byZoomOver;//0-����,1-�䱶��λ(�����ϴ�¼����������Ϊ�л������ж�����)
    BYTE byAnswerStudent;//0-������1-��ѧ��������2-����ѧ��������3-���ѧ������,4-����ѧ������, 5-����ѧ���߶�
    BYTE byRes[4];             //����
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

//��������ṹ��
typedef struct tagNET_VCA_RELATE_RULE_PARAM
{   
    BYTE  byRuleID;  //������� 0-��ʾ��
    BYTE  byRes;  //����
    WORD  wEventType;        //��Ϊ�¼����ͣ��ο�VCA_RULE_EVENT_TYPE_EX��
}NET_VCA_RELATE_RULE_PARAM,*LPNET_VCA_RELATE_RULE_PARAM;

typedef struct tagNET_VCA_COMBINED_RULE_
{
    //���򴥷�˳��0-˳������򴥷���1-˳�򴥷�
    BYTE    byRuleSequence; 
    BYTE    byRes[7];
    DWORD  dwMinInterval;    //��Сʱ��������λ����
    DWORD  dwMaxInterval;  //���ʱ��������λ����
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//����1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//����2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;

//�����¼�
typedef struct  tagNET_VCA_BLACKBOARD_WRITE
{
    NET_VCA_POLYGON struRegion;//����Χ���������򣬱����в����и�����
    BYTE    byTeacherState;//��ʦ״̬��0~��ʦ��д��1~��ʦȫ����2~��̨����״̬
    BYTE    byWritingState;//����״̬��0~���鿪ʼ��1~�������
    BYTE    byWritingArea;//��������0~�������飬1~������ߣ�2~�����ұ�
    BYTE    byRes[5];
}NET_VCA_BLACKBOARD_WRITE, *LPNET_VCA_BLACKBOARD_WRITE;

//��Ա�ۼ�״̬
typedef struct tagNET_VCA_HIGH_DENSITY_STATUS
{
    NET_VCA_POLYGON struRegion;        //����Χ
    float           fDensity;       //�ۼ�����, ��Χ: [0.1, 1.0]
    BYTE            bySensitivity;    //�����Ȳ�������Χ[1,5]
    BYTE            byRes[3];          // �����ֽ�
}NET_VCA_HIGH_DENSITY_STATUS, *LPNET_VCA_HIGH_DENSITY_STATUS; 

//���ܼ��
typedef struct _NET_VCA_RUNNING_
{
    NET_VCA_POLYGON  struRegion;  //����Χ
    DWORD  dwSpeed;      //�����ٶȣ���Χ[1,10]
    WORD   wDuration;      // ��������ʱ����ֵ
    BYTE   byRunMode;    //����ģʽ��0-����,1�����˱���,2:���˱���
    BYTE   byRes;
}NET_VCA_RUNNING, *LPNET_VCA_RUNNING;

// �������
typedef struct tagNET_VCA_RETENTION
{
    NET_VCA_POLYGON struRegion; // ����Χ
    WORD       wDuration;       //��������������ֵʱ�䣨60-3600�룩Ĭ��1800��
    BYTE       byRes[6];        // �����ֽ�
}NET_VCA_RETENTION, *LPNET_VCA_RETENTION;

// ̬�Ʒ�������
typedef struct tagNET_VCA_SITUATION_ANALYSIS
{
    NET_VCA_POLYGON struRegion; // ����Χ
    WORD       wPeopleNum;       //��������
    BYTE       byRes[6];        // �����ֽ�
}NET_VCA_SITUATION_ANALYSIS, *LPNET_VCA_SITUATION_ANALYSIS;

//��������
typedef struct _NET_VCA_DURATION_
{
    WORD   wRelationEventType;  //�ο�VCA_RULE_EVENT_TYPE_EX
    BYTE   byRes[90];
}NET_VCA_DURATION, *LPNET_VCA_DURATION;

//�����¼�����
typedef union tagNET_VCA_EVENT_UNION
{
    DWORD                      uLen[23];            //����
    NET_VCA_TRAVERSE_PLANE     struTraversePlane;   //��Խ��������� 
    NET_VCA_AREA               struArea;            //����/�뿪�������
    NET_VCA_INTRUSION          struIntrusion;       //���ֲ���
    NET_VCA_LOITER             struLoiter;          //�ǻ�����
    NET_VCA_TAKE_LEFT          struTakeTeft;        //��Ʒ����/��Ʒ��ȡ����
    NET_VCA_PARKING            struParking;            //ͣ������
    NET_VCA_RUN                struRun;                //�����ƶ�����
    NET_VCA_HIGH_DENSITY       struHighDensity;        //��Ա�ۼ�����  
    NET_VCA_VIOLENT_MOTION     struViolentMotion;    //�����˶�
    NET_VCA_REACH_HIGHT           struReachHight;      //�ʸ�
    NET_VCA_GET_UP               struGetUp;           //��
    NET_VCA_LEFT               struLeft;            //��Ʒ����
    NET_VCA_TAKE               struTake;            // ��Ʒ��ȡ
    NET_VCA_HUMAN_ENTER        struHumanEnter;      //��Ա����
    NET_VCA_OVER_TIME          struOvertime;        //������ʱ
    NET_VCA_STICK_UP            struStickUp;            //��ֽ��
    NET_VCA_SCANNER            struScanner;            //����������     
    NET_VCA_LEAVE_POSITION     struLeavePos;        //��ڲ���
    NET_VCA_TRAIL              struTrail;           //β�����
    NET_VCA_FALL_DOWN          struFallDown;        //���ز���
    NET_VCA_AUDIO_ABNORMAL     struAudioAbnormal;   //��ǿͻ��
    NET_VCA_ADV_REACH_HEIGHT   struReachHeight;     //�����ʸ߲���
    NET_VCA_TOILET_TARRY       struToiletTarry;     //��޳�ʱ����
    NET_VCA_YARD_TARRY         struYardTarry;       //�ŷ糡��������
    NET_VCA_ADV_TRAVERSE_PLANE struAdvTraversePlane;//���߾��������
    NET_VCA_LECTURE            struLecture;            //�ڿ��¼�
    NET_VCA_ANSWER             struAnswer;            //�ش������¼�
    NET_VCA_STANDUP               struStandUp;         //��������
    NET_VCA_PEOPLENUM_CHANGE   struPeopleNumChange; //�����仯����
    NET_VCA_SPACING_CHANGE     struSpacingChange;   //���仯����
    NET_VCA_COMBINED_RULE      struCombinedRule;    //��Ϲ������
    NET_VCA_SIT_QUIETLY        struSitQuietly;      //��������
    NET_VCA_HIGH_DENSITY_STATUS       struHighDensityStatus;        //��Ա�ۼ�״̬ 
    NET_VCA_RUNNING     struRunning; //���ܲ���
    NET_VCA_RETENTION   struRetention;//�������
    NET_VCA_BLACKBOARD_WRITE   struBlackboardWrite; //�������
    NET_VCA_SITUATION_ANALYSIS   struSituationAnalysis; //̬�Ʒ�������
    NET_VCA_PLAY_CELLPHONE    struPlayCellphone; //���ֻ�������
    NET_VCA_DURATION            struDruation;//������������
}NET_VCA_EVENT_UNION, *LPNET_VCA_EVENT_UNION;

// �ߴ����������
typedef enum _VCA_SIZE_FILTER_MODE_
{
    IMAGE_PIX_MODE, //�������ش�С����
        REAL_WORLD_MODE, //����ʵ�ʴ�С����
        DEFAULT_MODE     // Ĭ��ģʽ
}SIZE_FILTER_MODE;
//�ߴ������
typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;            //�Ƿ񼤻�ߴ������ 0-�� ��0-��
    BYTE    byMode;         //������ģʽSIZE_FILTER_MODE
    BYTE    byRes[2];        //��������0
    NET_VCA_RECT struMiniRect;    //��СĿ���,ȫ0��ʾ������
    NET_VCA_RECT struMaxRect;      //���Ŀ���,ȫ0��ʾ������
}NET_VCA_SIZE_FILTER, *LPNET_VCA_SIZE_FILTER;

//�������ṹ
typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;                    //�Ƿ񼤻����,0-��,��0-��
    BYTE   byRes[7];                     //����������Ϊ0�ֶ�
    BYTE   byRuleName[NAME_LEN];        //��������
    VCA_EVENT_TYPE dwEventType;            //��Ϊ�����¼�����
    NET_VCA_EVENT_UNION uEventParam;    //��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //����ʽ 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];            //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
}NET_VCA_ONE_RULE, *LPNET_VCA_ONE_RULE;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;            //�ṹ����
    BYTE   byPicProType;    //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE   byUpLastAlarm; //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE   byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE   byRes;
    NET_DVR_JPEGPARA  struPictureParam;         //ͼƬ���ṹ
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];  //��������
}NET_VCA_RULECFG, *LPNET_VCA_RULECFG;

//ǰ���豸��ַ��Ϣ�����ܷ����Ǳ�ʾ����ǰ���豸�ĵ�ַ��Ϣ�������豸��ʾ�����ĵ�ַ
/*
�������豸ģ��ͨ��(IPC/DVR/DVS/IVMS)������ʱ�������ֶ���д�豸��IP��ַ���˿ڣ�byChannel��byIvmsChannel ��Ϊ��ǰ��ģ��ͨ����
eg:
struDevIP =  ģ��ͨ����Ӧ�豸��IP��ַ
wPort  =  ģ��ͨ����Ӧ�豸�Ķ˿�
byChannel =  ������Ӧģ��ͨ����ͨ����
byIvmsChannel = ������Ӧģ��ͨ����ͨ����

  �������豸����ͨ��(DVR/DVS/IVMS)������ʱ�������ֶ���д����ͨ�������豸��IP��ַ���˿ڣ�byChannelΪ����ͨ�������豸��ͨ���ţ�byIvmsChannelΪ����ͨ����
  eg:
  struDevIP =  ����ͨ�������豸��IP��ַ
  wPort  =  ����ͨ�������豸�Ķ˿�
  byChannel =  ����ͨ�������豸��ͨ����
  byIvmsChannel = ����ͨ����    
*/
typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP; //ǰ���豸��ַ�� 
    WORD wPort;             //ǰ���豸�˿ںţ� 
    BYTE byChannel;          //ǰ���豸ͨ���� 
    BYTE byIvmsChannel;        // Ivms ͨ�� 
}NET_VCA_DEV_INFO, *LPNET_VCA_DEV_INFO;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize; //�ṹ��С
    DWORD     dwRelativeTime; //���ʱ��
    DWORD        dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    BYTE     byTargetType;//���Ŀ������ 0-��ЧĿ�꣬1-��ʦ 2-ѧ��   
    BYTE     byLeftDirection;//���Ŀ���뿪��������0-����,1-��,2-��,3-��,4-��
    BYTE     byTargetStatus;//0-����(��������) 
    BYTE     byRes[125];
}NET_DVR_TARGET_LEFT_REGION_ALARM,*LPNET_DVR_TARGET_LEFT_REGION_ALARM;

/* ����ͼƬͼƬ��Ϣ */
typedef struct
{
    /*20-˾������   ˾�������ӳ��̿�ʼ, 21-˾����绰, 22-˾��ƣ�ͼ�ʻ, 23-˾��û��Ŀ��ǰ������ڣ�,24-˾����ⲻ��ͷ��, 25-˾��ϵ��ȫ��,
    26-˾����ʰ��Ʒ, 27-˾�����Ƿ, 28-˾���Զ������ˮ, 29-˾������, 31-˾��δ��������*/
    DWORD dwPicType;                /* ����ͼƬ���� */
    char *pPicBuf;                  /*ͼƬָ��*/
    DWORD dwPicLen;                 /* ����ͼƬ���ȣ�Ϊ0ʱ��ʾû��ͼƬ */
    DWORD dwTime;                   /* ץͼʱ�� */
    char *pVideoBuf;                /*��Ƶָ��, xxx.mp4*/
    DWORD dwVideoLen;               /* ץͼ��Ƶ�ĳ��ȣ�0��ʾû�б�����Ƶ 20180518 */
    BYTE byRes[12];                /* Ԥ�� */
}NET_DVR_DBD_PICTURE_INFO, *LPNET_DVR_DBD_PICTURE_INFO;

/* ����λ����Ϣ */
typedef struct
{/* 24 bytes */
    DWORD bValid;                   /* ��λ��Ϣ�Ƿ���Ч */
    DWORD dwLongitude;              /* ���� = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD dwLatitude;               /* γ�� = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD dwVehicleSpeed;           /* �ٶ� = ʵ���ٶ�*1000*100 */
    DWORD dwVehicleDirection;       /* �ٶȷ���� = ʵ�ʷ���*100 */
    DWORD dwAltitude;                  /* ���θ߶�(����) */
}NET_DVR_DBD_POSITION_INFO, *LPNET_DVR_DBD_POSITION_INFO;

/* ����״̬��Ϣ */
typedef struct
{/* 24 bytes */
    BYTE bySmoke;              /* ���� */
    BYTE byPhone;              /* ��绰 */
    BYTE byTiredDriving;       /* ƣ�ͼ�ʻ */
    BYTE byNoVisualFront;      /* û��Ŀ��ǰ�� */
    BYTE byNoHead;             /* ��� */
    BYTE byWithoutBelt;        /* ��ϵ��ȫ�� */
    BYTE byPickingUpThing;     /* ��ʰ��Ʒ */
    BYTE byYawn;               /* ���Ƿ */
    BYTE byEatOrDrink;         /* �Ժ� */
    BYTE byChatting;           /* ���� */
    BYTE byTampering;          /* �ڵ�IPC */
    BYTE byWithoutUniform;     /* δ�������� */
    BYTE byDriverCmpFail;     /* ���ʶ���쳣*/
    BYTE byDriverChange;         /* ��ʻԱ����*/
    BYTE byDriveLongTime;     /*��ʱ��ʻ*/
    BYTE byInfraredBlockingSunglasses;   /* �������ī�� */
    BYTE byOutOfWheel;    /* 0-������1-�������뷽���̣�2-˫�����뷽���� */
    BYTE byRes[7];
}NET_DVR_DBD_ALARM_STATE, *LPNET_DVR_DBD_ALARM_STATE;

/* ��ʻ��Ϊ������Ϣ */
typedef struct
{
    DWORD dwSize;               /* �����ϴ��ṹ���С 4*/
    BYTE byChannel;            /* ͨ���� 1*/
    BYTE byLevel;              /*�����ȼ�,��ǰֻ��1*/
    BYTE byRes1[2];            /* �����ֽ� 3*/
    NET_VCA_DEV_INFO struIpcInfo;       		/* ����IPͨ����Ϣ 24*/
    NET_DVR_DBD_POSITION_INFO struPosInfo;  /* ����λ����Ϣ 24*/
    NET_DVR_DBD_PICTURE_INFO struPicInfo;   /* ����ͼƬ��Ϣ*/
    NET_DVR_DBD_ALARM_STATE struAlarmState; /* ����״̬��Ϣ 24*/
    BYTE byRes2[20];           /* ����   20*/
}NET_DVR_DBD_ALRAM_INFO, *LPNET_DVR_DBD_ALRAM_INFO;

/* ADAS����ͼƬ��Ϣ */
typedef struct
{
    DWORD dwPicType;                /* ����ͼƬ���� */
    char *pPicBuf;                  /*ͼƬָ��*/
    DWORD dwPicLen;                 /* ����ͼƬ���ȣ�Ϊ0ʱ��ʾû��ͼƬ */
    DWORD dwTime;                   /* ץͼʱ�� */
    char *pVideoBuf;                /*��Ƶָ��, xxx.mp4*/
    DWORD dwVideoLen;               /* ץͼ��Ƶ�ĳ��ȣ�0��ʾû�б�����Ƶ 20180518 */
    BYTE byRes[12];                /* Ԥ�� */
} NET_DVR_ADAS_PICTURE_INFO, *LPNET_DVR_ADAS_PICTURE_INFO;

/* ADAS����λ����Ϣ */
typedef struct
{/* 24 bytes */
    DWORD dwValid;                   /* ��λ��Ϣ�Ƿ���Ч */
    DWORD dwLongitude;              /* ���� = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD dwLatitude;               /* γ�� = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD dwVehicleSpeed;           /* �ٶ� = ʵ���ٶ�*1000*100 */
    DWORD dwVehicleDirection;       /* �ٶȷ���� = ʵ�ʷ���*100 */
    DWORD dwAltitude;                  /* ���θ߶�(����) */
}NET_DVR_ADAS_POSITION_INFO, *LPNET_DVR_ADAS_POSITION_INFO;

/* ADAS����״̬��Ϣ */
typedef struct
{/* 24 bytes */
    BYTE dwFcw;              /* ǰ����ײ��0�ޣ�1�¼����� */
    BYTE dwLdw;              /* ����ƫ�룬0�ޣ�1���ƫ�룬2�Ҳ�ƫ�� */
    BYTE dwHmw;       		 /* �����⣬0�ޣ�1�¼����� */
    BYTE dwPcw;      		 /* ������ײ��0�ޣ�1�¼����� */
    BYTE dwBsd;      		 /* ä����⣬0�ޣ�1�¼����� , 2-�Ҳ�ä��������3-���ä������, 4-���ä������*/
    BYTE byAcc;      	 /* �����٣�0�ޣ�1�¼����� */
    BYTE byBrake;      	 /*�����٣�0�ޣ�1�¼����� */
    BYTE byTurn;      	/* ��ת�䣬0�ޣ�1�Ҽ�ת�䣬2��ת�� */
    BYTE byRollover;     /* �෭��0�ޣ�1�¼����� */
    BYTE byNoCourtesy;  /* δ�������ˣ�0�ޣ�1�¼����� */
    BYTE byTsr;    /*��ͨ��ʶ���棬0�ޣ�1���٣�2�޸ߣ�3�޿� */
    BYTE byRes[13];
}NET_DVR_ADAS_ALARM_STATE, *LPNET_DVR_ADAS_ALARM_STATE;

/* ADAS��ʻ��Ϊ������Ϣ */
typedef struct
{
    DWORD dwSize;               /* �����ϴ��ṹ���С 4*/
    BYTE byChannel;            /* ͨ���� 1*/
    BYTE byRes1[3];            /* �����ֽ� 3*/
    NET_VCA_DEV_INFO struIpcInfo;       		/* ����IPͨ����Ϣ 28*/
    NET_DVR_ADAS_POSITION_INFO struPosInfo;  /* ����λ����Ϣ 24*/
    NET_DVR_ADAS_PICTURE_INFO struPicInfo;   /* ����ͼƬ��Ϣ*/
    NET_DVR_ADAS_ALARM_STATE struAlarmState; /* ����״̬��Ϣ 24*/
    BYTE byRes2[20];           /* ����   20*/
}NET_DVR_ADAS_ALRAM_INFO, *LPNET_DVR_ADAS_ALRAM_INFO;

/* �г�ʵʱ���� */
typedef struct
{
    DWORD dwSize;               /* �����ϴ��ṹ���С */
    DWORD dwSpeedValue;         /* �ٶ�ֵ */
    DWORD dwSpeedPulse;         /* �������� */
    BYTE byUpgPercent;         /* �������ȣ�����0-100������ʧ�ܷ���255��ÿ�ο�ʼ����ʱ��������Ҫ�Ƚ���0���ű�ʾ׼����ʼ�� 20180508��չ*/
    BYTE byRes1[3];
    DWORD dwVideoLostChans;    /*��λ��ʾ��0��ʾ������1-��ʾ��Ƶ��ʧ����һλ��ʾ��һͨ��*/
    BYTE byRes2[44];
}NET_DVR_VEH_REALTIME_DATA_INFO, *LPNET_DVR_VEH_REALTIME_DATA_INFO;

#define VCA_ATTEND_MAX_PIC_NUM            3             //�����¼����ͼƬ����
#define VCA_ATTEND_DRIVER_NAME_LEN        64            //������Ϣ˾�����ֳ���
#define VCA_ATTEND_CARD_ID_LEN            32            //������Ϣ˾��֤�����볤��
#define VCA_ATTEND_MAX_ALARM_ID_LEN       32            //�����¼�Ψһ��ŵ���󳤶�

typedef struct
{
    DWORD  dwPicLen;    //����ͼƬ���ȣ�Ϊ0ʱ��ʾû��ͼƬ 
    char   *pPicBuf;    //ͼƬָ��
    BYTE   byRes[12];   //Ԥ�� 
}NET_DVR_VCA_ATTEND_PICDATA, *LPNET_DVR_VCA_ATTEND_PICDATA;

/* �����¼�ͼƬ��Ϣ */
typedef struct
{
    BYTE   byPicNum;    //����ͼƬ����
    BYTE   byRes1[3];   //Ԥ��
    NET_DVR_VCA_ATTEND_PICDATA struPicData[VCA_ATTEND_MAX_PIC_NUM]; //����ͼƬ����
    DWORD  dwVideoLen;  //ץͼ��Ƶ�ĳ��ȣ�0��ʾû�б�����Ƶ 
    char   *pVideoBuf;  //��Ƶָ��
    BYTE   byRes[64];   //Ԥ�� 
}NET_DVR_VCA_ATTEND_PICTURE_INFO, *LPNET_DVR_VCA_ATTEND_PICTURE_INFO;

/* �����¼��ϴ���Ϣ*/
typedef struct
{
    DWORD  dwSize;         // �����ϴ��ṹ���С
    BYTE   byMethod;       //���ڷ�ʽ 0-IC������,1-��������
    BYTE   byStatus;       //����״̬ 0-������1-�ϰ�,2-�°ࣨ�������򻻰ࣩ
    BYTE   byCertIDType;   //��ʻԱ֤�����ͣ�0-Ӫ���ʸ�֤��1-���֤
    BYTE   byCertIDLen;    //��ʻԱ��ҵ�ʸ�֤���볤��
    char   sCertId[VCA_ATTEND_CARD_ID_LEN];           //��ʻԱ��ҵ�ʸ�֤����	
    DWORD  dwTime;         //����ʱ��
    char   sName[VCA_ATTEND_DRIVER_NAME_LEN];         //��ʻԱ����
    char   sAlarmIdNo[VCA_ATTEND_MAX_ALARM_ID_LEN];   //������ʶ��
    NET_DVR_VCA_ATTEND_PICTURE_INFO struPicInfo;     //����ͼƬ��Ϣ
    BYTE   byRes[128];     //����
}NET_DVR_VCA_ATTEND_ALARM_INFO, *LPNET_DVR_VCA_ATTEND_ALARM_INFO;

//�ߴ���˲���
typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //�ߴ���˲��� 0 - ������ 1-�߶ȺͿ�ȹ���,2-�������
    BYTE    byRes[11];       //����
}NET_VCA_FILTER_STRATEGY,*LPNET_VCA_FILTER_STRATEGY;

//���򴥷�����
typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //����Ĵ�����ʽ��0- �����ã�1- �켣�� 2- Ŀ����� 
    BYTE   byTriggerPoint;  //�����㣬������ʽΪ�켣��ʱ��Ч 0- ��,1-��,2-��
    BYTE   byRes1[2];       //����
    float  fTriggerArea;    //����Ŀ������ٷֱ� [0,100]��������ʽΪĿ�����ʱ��Ч
    BYTE   byRes2[4];       //����
}NET_VCA_RULE_TRIGGER_PARAM,*LPNET_VCA_RULE_TRIGGER_PARAM;

//�������ṹ
typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //�Ƿ񼤻����,0-��,��0-��
    BYTE   byRes1[4];  //����������Ϊ0�ֶ�
    BYTE   byEventTypeFlag;  //��־��Ϊ�¼������ֶε���Ч�ԣ�0-dwEventType��Ч��1-wEventTypeEx��Ч
    //ע�����ֶ�byEventTypeFlagֻ�����ò���ʱ��Ч�����豸��ȡ����ʱ����ֱ�Ӵ�wEventTypeEx��ȡ�¼����ͣ������жϴ��ֶε�ֵ
    WORD   wEventTypeEx; //��Ϊ�¼�������չ�����ڴ����ֶ�dwEventType���ο�VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //��������
    VCA_EVENT_TYPE dwEventType;    //��Ϊ�¼����ͣ�������Ϊ�˼��ݣ���������ʹ��wEventTypeEx��ȡ�¼�����
    NET_VCA_EVENT_UNION uEventParam; //��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //����ʽ 
    BYTE   byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    WORD   wAlarmDelay; //���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2]; //����
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //�ߴ���˲���
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //���򴥷�����
    BYTE   byRes[32];
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;            //�ṹ����
    BYTE    byPicProType;    //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE    byUpLastAlarm; //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE    byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE    byRes1;
    NET_DVR_JPEGPARA struPictureParam;         //ͼƬ���ṹ
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //��������
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE   byRes[26];
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

//�������ṹ
typedef struct NET_VCA_ONE_RULE_V42_  
{
    BYTE           byActive;       //�Ƿ񼤻����, 0-�񣬷�0-��
    BYTE        byEventPriority;//�¼����ȼ� 0-�ͣ�1-�У�2-��
    BYTE        byBackgroundSuppression;//������������ 0-�ر� 1-���� 2-����Ӧ
    BYTE           byRes1[3];           //����������Ϊ0�ֶ�
    WORD          wEventType;        //��Ϊ�¼����ͣ��ο�VCA_RULE_EVENT_TYPE_EX
    BYTE        byRuleName[NAME_LEN/*32*/];        //��������
    NET_VCA_EVENT_UNION  uEventParam;            //��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;          //�ߴ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*����ʽ*/
    //�쳣����ʽ�б������������Ű󶨣������Ϊ0ʱ����ʾ�����ı�������ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ�����ı�������ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں����ı���������Ч
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];    /* ����������¼��ͨ�������ֽڵ�ͨ���ţ���ʼֵ�� 0xffffffff��*/
    //������¼��ͨ��������Ű󶨣������Ϊ0ʱ����ʾ������ͨ���ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ������ͨ���ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں����Ĺ���ͨ������Ч
    WORD          wAlarmDelay; //���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE           byRes2[2];           //����
    NET_VCA_FILTER_STRATEGY     struFilterStrategy;  //�ߴ���˲���
    NET_VCA_RULE_TRIGGER_PARAM     struTriggerParam; //���򴥷�����
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;


typedef struct    tagNET_DVR_PTZ_POSITION
{
    // �Ƿ����ó����������ó�����Ϊ�����ʱ����ֶ���Ч������������������ó���λ����Ϣʱ��Ϊʹ��λ
    BYTE byEnable;
    BYTE byRes1[3];  //����
    BYTE byPtzPositionName[NAME_LEN]; //����λ������
    NET_DVR_PTZPOS struPtzPos; //ptz ����
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION, *LPNET_DVR_PTZ_POSITION;

//��Ϊ�������ýṹ��
typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD            dwSize;             //�ṹͼ��С
    BYTE                byPicProType;            //����ʱͼƬ����ʽ 0-������ 1-�ϴ�
    BYTE            byUpLastAlarm;         //�Ƿ����ϴ����һ�εı�����0-��1-��
    BYTE             byPicRecordEnable;   //�Ƿ�����ͼƬ�洢, 0-������, 1-����
    BYTE            byRes1;
    NET_DVR_JPEGPARA     struPicParam;         //ͼƬ���ṹ
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42 /*16*/];       /* ��������*/
    WORD            wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE            byTrackEnable; //�Ƿ����ø���
    BYTE            byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //����λ����Ϣ
    WORD            wTrackDuration; //���ٳ���ʱ�䣬��λs
    WORD            wIntervalTime; //���α������ʱ�䣨�룩[1-7200]��Ĭ��Ϊ600��
    WORD            wHeightLimit;//Ŀ����߶����ޣ����ף�[0-250]��Ĭ��Ϊ80cm����С�ڴ˸߶ȵ�Ŀ�꽫����ΪĿ����м��
    BYTE            byRes[58];//����
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;


//��Ŀ��ṹ��
typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;                //Ŀ��ID ,��Ա�ۼ����߱���ʱΪ0
    NET_VCA_RECT struRect;      //Ŀ��߽�� 
    BYTE      byRes[4];            //����
}NET_VCA_TARGET_INFO, *LPNET_VCA_TARGET_INFO;

//�򻯵Ĺ�����Ϣ, ��������Ļ�����Ϣ
typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;                //����ID,0-7
    BYTE   bySceneID;                //����ID,����0��Ч
    WORD   wEventTypeEx;            //��Ϊ�¼�������չ�����ڴ����ֶ�dwEventType���ο�VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN];    //��������
    VCA_EVENT_TYPE  dwEventType;    //��Ϊ�¼����ͣ�������Ϊ�˼��ݣ���������ʹwEventTypeEx��ȡ�¼�����
    NET_VCA_EVENT_UNION uEventParam;//�¼�����
}NET_VCA_RULE_INFO, *LPNET_VCA_RULE_INFO;

//��Ϊ��������ϱ��ṹ
typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;                        //�ṹ����
    DWORD    dwRelativeTime;                //���ʱ��,��ʷԭ��ʵ��û�ã����汾��������byRelativeTimeFlagΪ1ʱ����ʾΪUTC��ʱ��
    DWORD    dwAbsTime;                        //����ʱ��,��ʷԭ������ʵ��ΪOSDʱ��
    NET_VCA_RULE_INFO     struRuleInfo;        //�¼�������Ϣ
    NET_VCA_TARGET_INFO  struTargetInfo;    //����Ŀ����Ϣ
    NET_VCA_DEV_INFO       struDevInfo;        //ǰ���豸��Ϣ
    DWORD dwPicDataLen;                        //����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ����*/
    BYTE       byPicType;        //  0-����ץ��ͼƬ 1-�Ա�ͼƬ
    BYTE       byRelAlarmPicNum; //����ͨ������ͼƬ����
    BYTE       bySmart;//IDS�豸����0(Ĭ��ֵ)��Smart Functiom Return 1
    BYTE       byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    DWORD      dwAlarmID;     //����ID�����Ա�ʶͨ���������������ϱ�����0��ʾ��Ч
    WORD       wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE       byRelativeTimeFlag;      //dwRelativeTime�ֶ��Ƿ���Ч  0-��Ч�� 1-��Ч��dwRelativeTime��ʾUTCʱ�� 
    BYTE       byAppendInfoUploadEnabled; //������Ϣ�ϴ�ʹ�� 0-���ϴ� 1-�ϴ�
    BYTE       *pAppendInfo;     //ָ�򸽼���ϢNET_VCA_APPEND_INFO��ָ�룬byAppendInfoUploadEnabledΪ1ʱ����byTimeDiffFlagΪ1ʱ��Ч
    BYTE       *pImage;       //ָ��ͼƬ��ָ��
}NET_VCA_RULE_ALARM, *LPNET_VCA_RULE_ALARM;

//��Ϊ����������Ϣ
typedef struct tagNET_VCA_APPEND_INFO
{
    DWORD   dwSize;  //�ṹ����
    DWORD   dwAppendPicLen;//����ͼƬ����
    BYTE*   pAppendPicBuff;//����ͼƬָ��
    BYTE    byAppendPicType;//����ͼƬ���ͣ�0-����;1-�ɼ���ͼƬ;2-�ȳ���ͼƬ;
    BYTE    byUID[64];//�豸����UID
    BYTE    byRes1[3]; //����
    DWORD   dwTargetSpeed;  //�״��⵽Ŀ���ٶ�,��λ:km/h
    DWORD   dwTargetDistance;  //�״��⵽Ŀ�����,��λ:m/��
    BYTE    byAlarmType;//�������� 0-��Ƶ 1-�״�
    BYTE    byRadarChannel; //�״�ͨ������1��ʼ�ۼ�
    BYTE    byRes[50]; //����
}NET_VCA_APPEND_INFO, *LPNET_VCA_APPEND_INFO;


//��Ϊ��������DSP��Ϣ���ӽṹ
typedef struct tagNET_VCA_DRAW_MODE
{ 
    DWORD  dwSize;
    BYTE    byDspAddTarget;            //�����Ƿ����Ŀ��
    BYTE    byDspAddRule;            //�����Ƿ���ӹ���
    BYTE    byDspPicAddTarget;        //ץͼ�Ƿ����Ŀ��
    BYTE    byDspPicAddRule;        //ץͼ�Ƿ���ӹ���
    BYTE    byRes[4];            
}NET_VCA_DRAW_MODE, *LPNET_VCA_DRAW_MODE;

//��������
typedef enum tagOBJECT_TYPE_ENUM
{    
    ENUM_OBJECT_TYPE_COAT  = 1  //����
}OBJECT_TYPE_ENUM;

//������ɫ�����ṹ��
typedef struct tagNET_DVR_OBJECT_COLOR_COND
{   
    DWORD  dwChannel;   //ͨ����
    DWORD  dwObjType;   //�������ͣ��μ�OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //����
}NET_DVR_OBJECT_COLOR_COND,*LPNET_DVR_OBJECT_COLOR_COND;

//ͼƬ����
typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //ͼƬ���ͣ�1-jpg
    BYTE   byRes1[3];        //����
    DWORD  dwPicWidth;       //ͼƬ���
    DWORD  dwPicHeight;      //ͼƬ�߶�
    DWORD  dwPicDataLen;     //ͼƬ����ʵ�ʴ�С
    DWORD  dwPicDataBuffLen; //ͼƬ���ݻ�������С
    BYTE*  byPicDataBuff;    //ͼƬ���ݻ�����
    BYTE   byRes2[40];       //����
}NET_DVR_PIC,*LPNET_DVR_PIC;

//��ɫ������
typedef union tagNET_DVR_OBJECT_COLOR_UNION
{    
    NET_DVR_COLOR  struColor;   //��ɫֵ
    NET_DVR_PIC    struPicture; //ͼƬ
    BYTE           byRes[64];   //����
}NET_DVR_OBJECT_COLOR_UNION,*LPNET_DVR_OBJECT_COLOR_UNION;

//������ɫ�����ṹ��
typedef struct tagNET_DVR_OBJECT_COLOR
{    
    DWORD  dwSize;       //�ṹ���С
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byColorMode;  //ȡɫ��ʽ��1-��ɫֵ��2-ͼƬ
    BYTE   byRes1[2];    //����
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //������ɫ�����壬ȡֵ������ȡɫ��ʽ
    BYTE   byRes2[64];   //����
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;

//��������
typedef enum tagAREA_TYPE_ENUM
{    
    ENUM_OVERLAP_REGION  = 1,//��ͬ����
        ENUM_BED_LOCATION  = 2   //����λ��
}AREA_TYPE_ENUM;

//��������
typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //�������ͣ��μ�AREA_TYPE_ENUM
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byRes1[3];     //����
    NET_VCA_POLYGON struPolygon; //����
    BYTE   byRes2[16];   //����
}NET_DVR_AUXAREA,*LPNET_DVR_AUXAREA;

//���������б�
typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD     dwSize;    // �ṹ���С
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //��������
    BYTE    byRes2[64];    // ����
}NET_DVR_AUXAREA_LIST,*LPNET_DVR_AUXAREA_LIST;

//ͨ������ģʽ
typedef enum tagCHAN_WORKMODE_ENUM
{    
    ENUM_CHAN_WORKMODE_INDEPENDENT = 1,  //����ģʽ
        ENUM_CHAN_WORKMODE_MASTER  = 2,      //��ģʽ
        ENUM_CHAN_WORKMODE_SLAVE  = 3        //��ģʽ
}CHAN_WORKMODE_ENUM;

//ͨ������ģʽ�����ṹ��
typedef struct tagNET_DVR_CHANNEL_WORKMODE
{   
    DWORD dwSize;        //�ṹ���С
    BYTE  byWorkMode;    //����ģʽ���μ�CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //����
}NET_DVR_CHANNEL_WORKMODE,*LPNET_DVR_CHANNEL_WORKMODE;

//�豸ͨ�������ṹ��
typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];    //�豸IP������
    WORD   wDVRPort;                     //�˿ں�
    BYTE   byRes1[2];                   //����
    BYTE   sUserName[NAME_LEN];            //�����û���
    BYTE   sPassword[PASSWD_LEN];       //��������
    DWORD  dwChannel;                   //ͨ����
    BYTE   byRes2[32];                  //����
}NET_DVR_CHANNEL,*LPNET_DVR_CHANNEL;

//��ͨ����Ϣ������
typedef union tagNET_DVR_SLAVE_CHANNEL_UNION
{
    BYTE            byRes[152];        //�������С
    DWORD           dwLocalChannel;    //����ͨ��
    NET_DVR_CHANNEL struRemoteChannel; //Զ��ͨ��
}NET_DVR_SLAVE_CHANNEL_UNION,*LPNET_DVR_SLAVE_CHANNEL_UNION;

//��ͨ�������ṹ��
typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //��ͨ�����ͣ�1-����ͨ����2-Զ��ͨ�� 
    BYTE   byRes1[3];    //����
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //��ͨ�������壬ȡֵ������byChanType
    BYTE   byRes2[64];   //����
}NET_DVR_SLAVE_CHANNEL_PARAM,*LPNET_DVR_SLAVE_CHANNEL_PARAM;


//��ͨ���������ýṹ��
typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{   
    DWORD dwSize;   //�ṹ���С
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//��ͨ������
    BYTE  byRes[64];  //����
}NET_DVR_SLAVE_CHANNEL_CFG,*LPNET_DVR_SLAVE_CHANNEL_CFG;

//��Ƶ������ϼ���¼�
typedef enum tagVQD_EVENT_ENUM
{    
    ENUM_VQD_EVENT_BLUR           = 1,  //ͼ��ģ��
        ENUM_VQD_EVENT_LUMA           = 2,  //�����쳣
        ENUM_VQD_EVENT_CHROMA         = 3,  //ͼ��ƫɫ
        ENUM_VQD_EVENT_SNOW           = 4,  //ѩ������
        ENUM_VQD_EVENT_STREAK         = 5,  //���Ƹ���
        ENUM_VQD_EVENT_FREEZE         = 6,  //���涳��
        ENUM_VQD_EVENT_SIGNAL_LOSS    = 7,  //�źŶ�ʧ
        ENUM_VQD_EVENT_PTZ            = 8,  //��̨ʧ��
        ENUM_VQD_EVENT_SCNENE_CHANGE  = 9,  //����ͻ��
        ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10, //��Ƶ�쳣
        ENUM_VQD_EVENT_VIDEO_BLOCK    = 11, //��Ƶ�ڵ�
        ENUM_VQD_EVENT_CLARTY           = 12, //�������쳣
        ENUM_VQD_EVENT_JITTER           = 13, //���涶��
        ENUM_VQD_EVENT_FLOWERS          = 14, //����
        ENUM_VQD_EVENT_NOISE            = 15, //���
        ENUM_VQD_EVENT_GHOST            = 16, //�쳣���
        ENUM_VQD_EVENT_PURPLE           = 17, //�ϱ�
        ENUM_VQD_EVENT_ICR              = 18, // ICR����쳣
        ENUM_VQD_EVENT_PROTECTFILM      = 19 //����Ĥδ˺
}VQD_EVENT_ENUM;

//��Ƶ��������¼������ṹ��
typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //ͨ����
    DWORD dwEventType; //����¼����ͣ��μ�VQD_EVENT_ENUM
    BYTE  byRes[64];   //����
}NET_DVR_VQD_EVENT_COND,*LPNET_DVR_VQD_EVENT_COND;

//��Ƶ��������¼�����
typedef struct tagNET_DVR_VQD_EVENT_PARAM
{ 
    BYTE   byThreshold;    //������ֵ����Χ[0,100]
    BYTE   byTriggerMode;  //1-����������2-���δ���
    BYTE   byUploadPic;    //0-���ϴ�ͼƬ��1-�ϴ�ͼƬ�������Ƿ��ϴ�ͼƬ���º󶼿��Դ��豸��ȡ���¼�����Ӧ���µ�һ�ű���ͼƬ���μ��ӿ�NET_DVR_StartDownload
    BYTE   byRes1;         //����
    DWORD  dwTimeInterval; //������������ʱ��������Χ[0,3600] ��λ����
    BYTE   byRes2[64];     //����
}NET_DVR_VQD_EVENT_PARAM,*LPNET_DVR_VQD_EVENT_PARAM;

//��Ƶ��������¼�����
typedef struct tagNET_DVR_VQD_EVENT_RULE
{   
    DWORD  dwSize;       //�ṹ���С 
    BYTE   byEnable;     //0-�����ã�1-����
    BYTE   byRes1[3];    //����
    NET_DVR_VQD_EVENT_PARAM struEventParam; //��Ƶ��������¼�����
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//���ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //����ʽ
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //����������¼��ͨ����1��ʾ������ͨ����0��ʾ������ 
    BYTE   byRes2[128];    //����
}NET_DVR_VQD_EVENT_RULE,*LPNET_DVR_VQD_EVENT_RULE;

//��׼��������
typedef struct tagNET_DVR_BASELINE_SCENE
{   
    DWORD dwSize;     //�ṹ���С
    BYTE  byEnable;   //0-�����ã�1-����
    BYTE  byRes[63];  //����
}NET_DVR_BASELINE_SCENE,*LPNET_DVR_BASELINE_SCENE;

//��׼�������������ṹ��
typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{   
    DWORD dwSize;     //�ṹ���С
    DWORD dwChannel;  //ͨ����
    BYTE  byCommand;  //�������ͣ�1-���ֶα������ݲ�ʹ�ã�2-���»�׼����
    BYTE  byRes[127];  //����
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM,*LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

//��Ƶ������ϱ����ṹ��
typedef struct tagNET_DVR_VQD_ALARM
{   
    DWORD  dwSize;                //�ṹ���С
    DWORD  dwRelativeTime;        //���ʱ��
    DWORD  dwAbsTime;              //����ʱ��
    NET_VCA_DEV_INFO struDevInfo; //ǰ���豸��Ϣ 
    DWORD  dwEventType;           //�¼����ͣ��ο�VQD_EVENT_ENUM
    float  fThreshold;            //������ֵ[0.000,1.000]
    DWORD  dwPicDataLen;          //ͼƬ���ȣ�Ϊ0��ʾû��ͼƬ
    BYTE   *pImage;               //ָ��ͼƬ��ָ��           
    BYTE   byRes[128];            //����
}NET_DVR_VQD_ALARM,*LPNET_DVR_VQD_ALARM;

//�궨���ӽṹ
typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;     //�궨�㣬���������ǹ����
    NET_DVR_PTZPOS struPtzPos;  //��������PTZ����
    BYTE    byRes[8];
}NET_DVR_CB_POINT, LPNET_DVR_CB_POINT;

//�궨�������ýṹ
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{    
    BYTE byPointNum;            //��Ч�궨�����
    BYTE byRes[3];                
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //�궨����
}NET_DVR_TRACK_CALIBRATION_PARAM, *LPNET_DVR_TRACK_CALIBRATION_PARAM;

//������ýṹ
typedef struct tagNET_DVR_TRACK_CFG 
{    
    DWORD dwSize;                //�ṹ����    
    BYTE byEnable;                //�궨ʹ��
    BYTE byFollowChan;          // �����ƵĴ�ͨ��
    BYTE byDomeCalibrate;            //�������ܸ�������궨��1���� 0������ 
    BYTE byRes;                    // �����ֽ�
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam; //�궨����
}NET_DVR_TRACK_CFG, *LPNET_DVR_TRACK_CFG ;

//����ģʽ
typedef enum _TRACK_MODE_
{
    MANUAL_CTRL = 0,  //�ֶ�����
        ALARM_TRACK    //������������
}TRACK_MODE;

//�ֶ����ƽṹ
typedef struct tagNET_DVR_MANUAL_CTRL_INFO 
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO, *LPNET_DVR_MANUAL_CTRL_INFO ;

//����ģʽ�ṹ
typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;        //�ṹ����
    BYTE byTrackMode;   //����ģʽ
    BYTE byRuleConfMode;   //�������ø���ģʽ0-�������ø��٣�1-Զ�����ø���
    BYTE byRes[2];   //��������0
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl;//�ֶ����ٽṹ
    }uModeParam;
}NET_DVR_TRACK_MODE,*LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;        /*����ʱͼƬ����ʽ 0-������ 1-�ϴ�*/
    BYTE    byRes[3];           //�����ֽ�
    NET_DVR_JPEGPARA struPicParam;                 /*ͼƬ���ṹ*/
}NET_DVR_ALARM_JPEG, *LPNET_DVR_ALARM_JPEG;

/**********************ipc/d5.3.0********************************/
typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;//����������
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//���Ӹ��� �������ID���[1,4]
    BYTE             byRes1[3];
    DWORD           dwSceneID;// scene Id 
    BYTE             byRes[56];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE                 byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    WORD                wPort;            /*�˿�*/
    BYTE               byLoginStatus; /*���豸�ĵ�½״̬ 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];//��������ַ������ 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP��ַ*/        //IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64    
    BYTE                szUserName[NAME_LEN/*32*/];        /*�û���*/
    BYTE                szPassWord[PASSWD_LEN/*16*/];        /*����*/
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus ;//����״̬ 0- δ���ӣ�1-����
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];//�����±�0��ʾ�������ID 1,��������
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{    
    float fPan;
    float fTilt;
    float fZoom;
    DWORD dwFocus;// �۽��������۽���Χ����һ��0-100000
    BYTE  byRes[4];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_BV_CALIB_POSITION
{
    DWORD  dwSize;  //�ṹ����
    NET_PTZ_INFO struInitialPos;  //��ʼ����
    NET_PTZ_INFO struAdjustPos;  //��������
    BYTE  byRes[300]; //����
}NET_DVR_BV_CALIB_POSITION, *LPNET_DVR_BV_CALIB_POSITION;

typedef struct tagNET_DVR_HUMAN_CALIB_CFG
{
    DWORD  dwSize;  //�ṹ����
    NET_VCA_POINT struLeftPos;   //�����������
    NET_VCA_POINT struRightPos;  //�����������
    BYTE  byRes[300]; //����
}NET_DVR_HUMAN_CALIB_CFG, *LPNET_DVR_HUMAN_CALIB_CFG;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;//�궨����
    int                iHorValue;//˫Ŀ�궨 ˮƽֵ cm���ֶ�ģʽ����Ч ˫Ŀ������ã�
    int                iVerValue;//˫Ŀ�궨 ��ֱֵ cm���ֶ�ģʽ����Ч ˫Ŀ������ã�
    BYTE      byRes[8];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE              byCalibMode;//�궨ģʽ: 0-����,1-�Զ��궨, 2-�ֶ��궨
    BYTE             byRes[3]; 
    //�����±�0��ʾ�������ID 1����������
    //�ֶ��궨ģʽ��֧�����ã�����&&��ȡ�����Զ�ģʽ��֧�ֻ�ȡ����
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];//ֻ���ֶ��궨ģʽ����Ч
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;        //�ṹ����
    BYTE byEnable;      //ʹ�� 0-false,1-true
    BYTE byMode;        //ģʽ 0-�رգ�1-�ֶ���2-�Զ�
    WORD  wTrackingTime;//����ʱ�䣺[0,60]s
    NET_VCA_POLYGON struRegion;//�ֶ�����Ŀ������Χ
    BYTE byRes[64];
}NET_DVR_TRACKING,*LPNET_DVR_TRACKING;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V50
{
    DWORD            dwSize;
    BYTE               byCalibMode;//�궨ģʽ: 0-����,1-�Զ��궨, 2-�ֶ��궨
    BYTE             byRes[3]; 
    //�����±�0��ʾ�������ID 1����������
    //�ֶ��궨ģʽ��֧�����ã�����&&��ȡ�����Զ�ģʽ��֧�ֻ�ȡ����
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/]; 
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_V50, *LPNET_DVR_SLAVECAMERA_CALIB_V50;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V51
{
    DWORD            dwSize;
    BYTE               byCalibMode;//�궨ģʽ: 0-����,1-�Զ��궨, 2-�ֶ��궨
    BYTE             byRes[3];
    //�����±�0��ʾ�������ID 1����������
    //�ֶ��궨ģʽ��֧�����ã�����&&��ȡ�����Զ�ģʽ��֧�ֻ�ȡ����
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE            byRes1[512];
}NET_DVR_SLAVECAMERA_CALIB_V51, *LPNET_DVR_SLAVECAMERA_CALIB_V51;

//���⹦��ץͼ����ṹ��ӥ����Ŀ��
typedef    struct tagNET_DVR_CAPTURE_PICTURE_RESULT
{
    DWORD        dwSize;//�ṹ���С
    DWORD    dwReturnPicSize;//���ص�ͼƬ��С
    BYTE        byRes[256];
}NET_DVR_CAPTURE_PICTURE_RESULT, *LPNET_DVR_CAPTURE_PICTURE_RESULT;

typedef struct tagNET_DVR_GOTOSCENE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    DWORD            dwSceneID;//����ID��
    BYTE              byRes[512];
}NET_DVR_GOTOSCENE_COND, *LPNET_DVR_GOTOSCENE_COND;

typedef struct tagNET_DVR_TRACK_INITPOSTION
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//���Ӹ��� �������ID���[1,4]
    BYTE             byRes[127];
}NET_DVR_TRACK_INITPOSTION, *LPNET_DVR_TRACK_INITPOSTION;

typedef struct tagNET_DVR_MANUAL_TRACKRATIO
{
    DWORD            dwSize;
    BYTE             byCoefficient;//����ϵ��[1,60]
    BYTE             byRes[127];
}NET_DVR_MANUAL_TRACKRATIO, *LPNET_DVR_MANUAL_TRACKRATIO;

/**********************ipc/d5.3.0********************************/

//��������Ϊ��������ṹ
//�������ṹ
typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;           /* �Ƿ񼤻����,0-��, ��0-�� */
    BYTE    byRes1[7];    //����������Ϊ0�ֶ�
    BYTE   byRuleName[NAME_LEN]; //��������
    VCA_EVENT_TYPE dwEventType;   //��Ϊ�����¼�����
    NET_VCA_EVENT_UNION uEventParam;//��Ϊ�����¼�����
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    BYTE byRes2[68]; /*����������Ϊ0*/
}NET_IVMS_ONE_RULE, *LPNET_IVMS_ONE_RULE;

// �����ǹ���ṹ
typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];   //��������
}NET_IVMS_RULECFG, *LPNET_IVMS_RULECFG;

// IVMS��Ϊ�������ýṹ
typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;        //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam;                 //ͼƬ���ṹ
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT];//ÿ��ʱ��ζ�Ӧ����
} NET_IVMS_BEHAVIORCFG, *LPNET_IVMS_BEHAVIORCFG;

//���ܷ�����ȡ���ƻ��ӽṹ
typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME     struTime;       //ʱ�����
    NET_DVR_PU_STREAM_CFG struPUStream; //ǰ��ȡ������
}NET_IVMS_DEVSCHED, *LPNET_IVMS_DEVSCHED;

//���ܷ����ǲ������ýṹ
typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED    struDevSched[MAX_DAYS][MAX_TIMESEGMENT];//��ʱ�������ǰ��ȡ���Լ�������Ϣ
} NET_IVMS_STREAMCFG, *LPNET_IVMS_STREAMCFG;

//��������
typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;            //�Ƿ񼤻�, 0-�񣬷�0-��
    BYTE byRes[3];         //��������0
    NET_VCA_POLYGON  struPolygon; //���ζ����
}NET_VCA_MASK_REGION, * LPNET_VCA_MASK_REGION;

//������������ṹ
typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;     //�ṹ����
    BYTE byRes[4];     //��������0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM]; //������������
}NET_VCA_MASK_REGION_LIST, *LPNET_VCA_MASK_REGION_LIST;


//ATM�����������
typedef struct tagNET_VCA_ENTER_REGION//��ֹ����ATM���
{
    DWORD dwSize;
    BYTE byEnable;            //�Ƿ񼤻0-�񣬷�0-��
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon; //��������
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION, * LPNET_VCA_ENTER_REGION;

//IVMS������������
typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;    //�ṹ����
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][ MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST, *LPNET_IVMS_MASK_REGION_LIST;

//IVMS��ATM�����������
typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][ MAX_TIMESEGMENT]; //��������
}NET_IVMS_ENTER_REGION, *LPNET_IVMS_ENTER_REGION;

// ivms ����ͼƬ�ϴ��ṹ
typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;               
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;     
}NET_IVMS_ALARM_JPEG, *LPNET_IVMS_ALARM_JPEG;

// IVMS ���������
typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay;// Զ�̻ط�
    NET_IVMS_ALARM_JPEG         struAlarmJpeg; // �����ϴ�ͼƬ����
    NET_IVMS_RULECFG           struRuleCfg;   //IVMS ��Ϊ��������
}NET_IVMS_SEARCHCFG, *LPNET_IVMS_SEARCHCFG;

//�궨�����ṹ��
typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{    
    BYTE byPointNum;    //��Ч�궨�����
    BYTE byRes[3];        //����
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //�궨����
    NET_DVR_PTZPOS struHorizonPtzPos;  //���ˮƽ��PTZ����
    BYTE byRes2[256];    //����
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

//�����豸���ò���
typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{    
    DWORD  dwSize;         //�ṹ���С
    BYTE   byEnable;       //���ô˸����豸, 0-������, 1 -����
    BYTE   byTransMode;    //ͨѶ��ʽ��0-����SDK��1-485����
    BYTE   byRes1[2];       //����    
    NET_DVR_CHANNEL  struTrackDevChan; //���������豸����    
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //�����豸�궨����    
    BYTE    byRes2[256];    //����    
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;
/************************************end******************************************/
//NAS��֤����
typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE    sUserName[NAME_LEN];        /* �û��� 32*/
    BYTE    sPassword[PASSWD_LEN];        /* ���� 16*/
    BYTE    byRes1[4];    //����
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;

typedef union tagNET_DVR_MOUNT_PARAM_UNION
{
    BYTE  uLen[52];                    //������ṹ��С
    NET_DVR_IDENTIFICATION_PARAM struIdentificationParam;//(SMB/CIFSʱ��Ч)
} NET_DVR_MOUNT_PARAM_UNION, *LPNET_DVR_MOUNT_PARAM_UNION;

typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0������,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;

typedef union tagNET_DVR_MOUNTMETHOD_PARAM_UNION
{
    BYTE  uLen[56]; //������ṹ��С                    
    NET_DVR_NAS_MOUNT_PARAM struNasMountParam;//NAS���ط�ʽ (byNetDiskTypeΪNFS(NAS)ʱ��Ч) 
}NET_DVR_MOUNTMETHOD_PARAM_UNION, *LPNET_DVR_MOUNTMETHOD_PARAM_UNION;

//����Ӳ�̽ṹ����
typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;                        //����Ӳ������, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //����
    NET_DVR_IPADDR struNetDiskAddr;            //����Ӳ�̵�ַ
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    WORD wPort;                                //iscsi�ж˿ڣ�����ΪĬ��
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];                //����
}NET_DVR_SINGLE_NET_DISK_INFO, *LPNET_DVR_SINGLE_NET_DISK_INFO;

#define MAX_NET_DISK    16//�������Ӳ�̸���

typedef struct tagNET_DVR_NET_DISKCFG 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG, *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;                        //����Ӳ������, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //����
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];    /*���� 64*/
    WORD wPort;                                //iscsi�ж˿ڣ�����ΪĬ��
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE    byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40, *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;
//�¼�����
//������
typedef enum _MAIN_EVENT_TYPE_
{
    EVENT_MOT_DET = 0,        //�ƶ����
        EVENT_ALARM_IN = 1,        //��������
        EVENT_VCA_BEHAVIOR = 2,    // ��Ϊ����
        EVENT_INQUEST = 3,       //��Ѷ�¼�
        EVENT_VCA_DETECTION = 4, //�������
        EVENT_POS = 5,
        EVENT_TRIAL_CASE = 6,//ͥ�󰸼���Ϣ
        EVENT_ACS_CASE = 7,  //�Ž��¼�
        EVENT_IOT_CASE = 8,  //����Ƶ�����¼��������¼���Ϊ����Ƶ�豸������Ƶ�豸�������¼�������������Ƶ�豸������¼�
        EVENT_STREAM_INFO = 100  //��ID��Ϣ
}MAIN_EVENT_TYPE;

#define INQUEST_START_INFO        0x1001       /*Ѷ�ʿ�ʼ��Ϣ*/
#define INQUEST_STOP_INFO         0x1002       /*Ѷ��ֹͣ��Ϣ*/
#define INQUEST_TAG_INFO          0x1003       /*�ص�����Ϣ*/
#define INQUEST_SEGMENT_INFO      0x1004       /*��ѶƬ��״̬��Ϣ*/
#define INQUEST_CASE_INFO          0x1005        // ������Ϣ����

typedef enum _VCA_DETECTION_MINOR_TYPE_
{
    EVENT_VCA_TRAVERSE_PLANE     = 1,           //Խ�����
        EVENT_FIELD_DETECTION,                        //�����������
        EVENT_AUDIO_INPUT_ALARM,                    //��Ƶ�����쳣
        EVENT_SOUND_INTENSITY_ALARM,                //��ǿͻ�����
        EVENT_FACE_DETECTION,                       //�������
        EVENT_VIRTUAL_FOCUS_ALARM,                  //�齹���
        EVENT_SCENE_CHANGE_ALARM,                   //����������
        EVENT_PIR_ALARM,                            //PIR����
        EVENT_ENTER_REGION,                           //��������
        EVENT_EXIT_REGION,                            //Ŀ���뿪����
        EVENT_LOITERING,                               //�ǻ�
        EVENT_GROUPDETECTION,                       //��������Ա�ۼ�,֧���������
        EVENT_RAPIDMOVE,                            //�����ƶ�
        EVENT_PARK,                              //ͣ��
        EVENT_UNATTENDED_BAGGAGE,                   //��Ʒ����
        EVENT_ATTENDEDBAGGAGE,                      //��Ʒ��ȡ
        EVENT_VEHICLE_DETECTION,                     //�������
        EVENT_ALL = 0xffffffff                        //��ʾȫ��
}VCA_DETECTION_MINOR_TYPE;



//��Ϊ���������Ͷ�Ӧ�Ĵ����ͣ� 0xffff��ʾȫ��
typedef enum _BEHAVIOR_MINOR_TYPE_
{
    EVENT_TRAVERSE_PLANE     = 0,    // ��Խ������
        EVENT_ENTER_AREA,                //Ŀ���������,֧���������
        EVENT_EXIT_AREA,                //Ŀ���뿪����,֧���������
        EVENT_INTRUSION,                 // �ܽ�����,֧���������
        EVENT_LOITER,                 //�ǻ�,֧���������
        EVENT_LEFT_TAKE,                //��Ʒ������ȡ,֧���������
        EVENT_PARKING,                    //ͣ��,֧���������
        EVENT_RUN,                    //�����ƶ�,֧���������
        EVENT_HIGH_DENSITY,                 //��������Ա�ۼ�,֧���������
        EVENT_STICK_UP,                //��ֽ��,֧���������
        EVENT_INSTALL_SCANNER,                //��װ������,֧���������
        EVENT_OPERATE_OVER_TIME,        // ������ʱ
        EVENT_FACE_DETECT,              // �쳣����
        EVENT_LEFT,                     // ��Ʒ����
        EVENT_TAKE,                      // ��Ʒ��ȡ
        EVENT_LEAVE_POSITION,         //����¼�
        EVENT_TRAIL_INFO = 16,            //β��
        EVENT_HUMAN_ENTER = 18,                 //��Ա����
        EVENT_FALL_DOWN_INFO = 19,                 //����
        EVENT_OBJECT_PASTE        =20,        // ����ճ������
        EVENT_FACE_CAPTURE_INFO = 21,                //��������
        EVENT_MULTI_FACES_INFO = 22,                  //��������
        EVENT_AUDIO_ABNORMAL_INFO = 23,             //��ǿͻ��
        EVENT_SUNGLASSES_FACE_INFO = 25,             //��ī������
        EVENT_CALLING_FACE_INFO = 26,                   //��绰����
        EVENT_VIOLENT_MOTION = 27,                   //�����˶�
        EVENT_SAFETY_HELMET = 28,                     //��ȫñ���
        EVENT_PEOPLE_NUM_CHANGE = 29,                 //�����仯
        EVENT_GET_UP = 30,                            //����
        EVENT_ADV_REACH_HEIGHT = 31,                  //�����ʸ�
        EVENT_STOOD_UP = 32,                           //����
        EVENT_PERSON_DENSITY = 33,                     //��Ա�ܶȣ�����Ԥ����
        EVENT_MANUAL_ALARM = 34,                     //�ֶ�����
        EVENT_VIOLATION_HIGH_SPEED = 35,             //����
        EVENT_GSENSOR = 36, // G-Sensor�¼��������١������١�����ת�䡢����ת�䡢����������������ײ��
        EVENT_SENSOR_IN = 37, // Sensor-In��Ϊ��ɲ������ת����ת��������
        EVENT_VCA_DBD = 38, //˾����ʻ��Ϊ
        EVENT_VCA_ABS = 39, //�߼�������ʻ
        EVENT_TOILET_TARRY = 40                      //��޳�ʱ
}BEHAVIOR_MINOR_TYPE;

//������6��Ӧ�Ĵ�����
typedef enum _TRIAL_CASE_MINOR_TYPE_
{
    TRIAL_START_INFO  = 0x1001,    // ͥ��ʼ�¼�
        TRIAL_STOP_INFO   = 0x1002,        //ͥ������¼�
        TRIAL_TAG_INFO    = 0x1003,        //ͥ���ص��ע�¼�
        TRIAL_SEGMENT_INFO = 0x1004,    // ͥ��Ƭ��״̬��Ϣ
        TRIAL_JUDGE_CASE_INFO=0x1005 //ͥ�󰸼���Ϣ
}TRIAL_CASE_MINOR_TYPE;

// ������100����Ӧ��С����
typedef enum _STREAM_INFO_MINOR_TYPE_
{
    EVENT_STREAM_ID  = 0,                    // ��ID
        EVENT_TIMING = 1,                    // ��ʱ¼��
        EVENT_MOTION_DETECT = 2,            // �ƶ����
        EVENT_ALARM = 3,                    // ����¼��
        EVENT_ALARM_OR_MOTION_DETECT = 4,    // �������ƶ����
        EVENT_ALARM_AND_MOTION_DETECT = 5,    // �������ƶ����
        EVENT_COMMAND_TRIGGER = 6,            // �����
        EVENT_MANNUAL = 7,                    // �ֶ�¼��
        EVENT_BACKUP_VOLUME = 8,            // �浵��¼��
        STREAM_EVENT_SEMAPHORE,                //�ź���
        STREAM_EVENT_HIDE,                    //�ڵ�
        STREAM_EVENT_INVERSE,                //����
        STREAM_EVENT_VIDEO_LOST,            //��Ƶ��ʧ
        STREAM_EVENT_WIRELESS_ALARM,        //���߱���
        STREAM_EVENT_PIR_ALARM,                //PIR����
        STREAM_EVENT_CALLHELP_ALARM,        //���ȱ���
        
        STREAM_EVENT_FACESNAP,                //����ץ��
        STREAM_EVENT_FACE_DETECTION,        //�������
        STREAM_EVENT_ITS_PLATE,                //�������
        STREAM_EVENT_PDC,                    //������ͳ��
        STREAM_EVENT_SCENECHANGE_DETECTION,    //�������
        STREAM_EVENT_DEFOCUS_DETECTION,        //�齹���
        STREAM_EVENT_AUDIOEXCEPTION,        //��Ƶ�쳣
        
        //����Ϊ��Ϊ������COMM_ALARM_RULE���������ͣ������VCA_EVENT_TYPE
        VCA_EVENT_TRAVERSE_PLANE,            //��Խ������
        VCA_EVENT_INTRUSION,                //�ܽ�����
        VCA_EVENT_ENTER_AREA,                //��������
        VCA_EVENT_EXIT_AREA,                //�뿪����
        VCA_EVENT_LOITER,                    //�ǻ����
        VCA_EVENT_HIGH_DENSITY,                //��Ա�ۼ�
        VCA_EVENT_RUN,                        //�����ƶ�
        VCA_EVENT_PARKING,                    //�Ƿ�ͣ��
        VCA_EVENT_LEFT,                        //��Ʒ����
        VCA_EVENT_TAKE,                        //��Ʒ��ȡ
}STREAM_INFO_MINOR_TYPE;

// typedef enum tagITS_MINOR_TYPE
// {
//     ITS_EVENT_CONGESTION    = 0,    // ӵ��
//     ITS_EVENT_PARKING,              // ͣ��
//     ITS_EVENT_INVERSE,              // ����
//     ITS_EVENT_PEDESTRIAN,           // ����
//     ITS_EVENT_DEBRIS                // �������������Ƭ
// }ITS_MINOR_TYPE;


#define SEARCH_EVENT_INFO_LEN   300    //�¼���Ϣ����
#define CASE_NO_LEN                64
#define CASE_NAME_LEN            128
#define LITIGANT_LEN            32
#define CHIEF_JUDGE_LEN         32
#define     SEARCH_CASE_NO_LEN        56
#define  SEARCH_CASE_NAME_LEN    100
#define  SEARCH_LITIGANT_LEN    32
#define  SEARCH_CHIEF_JUDGE_LEN 32
#define     CASE_NO_RET_LEN        52
#define  CASE_NAME_RET_LEN        64
#define     LITIGANT_RET_LEN        24
#define     CHIEF_JUDGE_RET_LEN    24
#define  NET_SDK_CASETYPE_LEN      32
//�¼���������
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;            //0-�ƶ���⣬1-��������, 2-�����¼�
    WORD wMinorType;            //����������- ���������ͱ仯��0xffff��ʾȫ��
    NET_DVR_TIME struStartTime;    //�����Ŀ�ʼʱ�䣬ֹͣʱ��: ͬʱΪ(0, 0) ��ʾ�������ʱ�俪ʼ���������ǰ���4000���¼�
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-ȫ����0-δ����1-����
    BYTE             byValue;            //0-��λ��ʾ��1-��ֵ��ʾ
    BYTE             byRes[130];        // ����
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];          
        struct//��������
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];    //��������ţ�byAlarmInNo[0]����1���ʾ�����ɱ�������1�������¼�
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30];
        }struAlarmParam;
        
        struct//��������--��ֵ
        {
            WORD wAlarmInNo[128];     /*��������ţ���ֵ��ʾ,���ý���������*/
            BYTE byRes[44]; //����
        }struAlarmParamByValue;
        
        struct//�ƶ����
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30];//�ƶ����ͨ����byMotDetChanNo[0]����1���ʾ������ͨ��1�����ƶ���ⴥ�����¼�
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30];
        }struMotionParam;
        
        struct//�ƶ����--��ֵ
        {
            WORD wMotDetChanNo[64];        /* �ƶ����ͨ������ֵ��ʾ ,���ý���������*/
            BYTE byRes[172];                /*����*/
        }struMotionParamByValue;
        
        struct//��Ϊ����
        {
            BYTE byChanNo[MAX_CHANNUM_V30];    //�����¼���ͨ��
            BYTE byRuleID;                    //����ID��0xff��ʾȫ��
            BYTE byRes1[43];                //����
        }struVcaParam;
        
        struct //��Ϊ����--��ֵ��ʽ���� 
        {
            WORD wChanNo[64];     //��Ϊ������Ӧ��ͨ������ֵ��ʾ,���ý���������
            BYTE byRuleID;      //��Ϊ�������ͣ�����0xff��ʾȫ������0��ʼ
            BYTE byRes[171];     /*����*/           
        }struVcaParamByValue;
        
        struct//��Ѷ�¼���������
        {            
            BYTE byRoomIndex;    //��Ѷ�ұ��,��ֵ��ʾ����1��ʼ
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //����
        } struInquestParam;
        struct  //��������������
        {
            BYTE byChan [256];//������������ͨ���ţ��������±��ʾ��byChan[0]����1���ʾ������ͨ��1�����ƶ���ⴥ�����¼� 
        }struVCADetectByBit;
        
        struct//�������������� ��ͨ���Ű�ֵ��ʾ
        {
            DWORD dwChanNo[MAX_CHANNUM_V30-1];// ����ͨ����,��ֵ��ʾ��0xffffffff��Ч���Һ�������Ҳ��ʾ��Чֵ
            BYTE byAll;//0-��ʾ����ȫ����1-��ʾȫ����
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // ��id��Ϣ��72�ֽڳ�
            DWORD                dwCmdType;  // �ⲿ�������ͣ�NVR�����ƴ洢ʹ��
            BYTE                byBackupVolumeNum; //�浵��ţ�CVRʹ��
            BYTE                byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];  //�������
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN]; //�������ƣ�
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN]; //������1��
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN]; //������2��
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];//���г�
            BYTE    byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM, *LPNET_DVR_SEARCH_EVENT_PARAM;

#define  MAX_POS_KEYWORDS_NUM               3          //֧�ֹؼ��ֲ�������
#define  MAX_POS_KEYWORD_LEN                128         //ÿ���ؼ��ֳ���
#define  SEARCH_EVENT_INFO_LEN_V40             800

//�¼���������
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;            //0-�ƶ���⣬1-��������, 2-�����¼� 5-pos¼�� 7-�Ž��¼�
    WORD wMinorType;            //����������- ���������ͱ仯��0xffff��ʾȫ��
    NET_DVR_TIME struStartTime;    //�����Ŀ�ʼʱ�䣬ֹͣʱ��: ͬʱΪ(0, 0) ��ʾ�������ʱ�俪ʼ���������ǰ���4000���¼�
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-ȫ����0-δ����1-����
    BYTE            byQuickSearch;        // �Ƿ����ÿ��ٲ�ѯ��0-�����ã�1-���ã����ٲ�ѯ���᷵���ļ���С�������豸���ݿ���в�ѯ������Ƶ������Ӳ�̣�
    BYTE             byRes[130];        // ����
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];          
        struct//��������
        {
            /*��������ţ���ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wAlarmInNo[128];     
            BYTE byRes[544]; //����
        }struAlarmParam;
        
        struct//�ƶ����
        {
            /* �ƶ����ͨ������ֵ��ʾ ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];        
            BYTE byRes[672];                /*����*/
        }struMotionParam;
        
        struct //��Ϊ���� 
        {
            //��Ϊ������Ӧ��ͨ������ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //��Ϊ�������ͣ�����0xff��ʾȫ������0��ʼ
            BYTE     byDriverBehaviortType;  //˾����ʻ��Ϊ���ͣ�0-������1-���̡�2-�Ӵ�绰��3-ƣ�ͼ�ʻ��4-�������ѡ�5-��ʻԱ�쳣��6-δϵ��ȫ����7-�������ī��
            BYTE     byADASType;  //�߼�������ʻ���ͣ�0-������1-ǰ����ײ��2-����ƫ�롢3-ä����⡢4-�����⡢5-���˷�ײ��6-�����١�7-�����١�8-����ת�䡢9-����ת�䡢10-����������11-δ��������
            BYTE     byGSensorType;  // G-Sensor�¼���0-������1-�����١�2-�����١�3-����ת�䡢4-����ת�䡢5-����������6-������ײ
            BYTE     bySensorInType;  // Sensor-In��Ϊ��0-������1-ɲ����2-��ת��3-��ת��4-����
            BYTE byRes[667];     /*����*/
        }struVcaParam;
        
        struct//��Ѷ�¼���������
        {            
            BYTE byRoomIndex;    //��Ѷ�ұ��,��1��ʼ
            BYTE byRes[799];     //����
        } struInquestParam;
        
        struct//�������������� ��ͨ���Ű�ֵ��ʾ
        {
            BYTE byAll;                //����ȫ��ͨ����0-�񣬴�ʱdwChanNo������Ч��
            //1-����ȫ��ͨ������ʱdwChanNo������Ч��
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// ����ͨ����,��ֵ��ʾ��0xffff��Ч���Һ�������Ҳ��ʾ��Чֵ
            BYTE byRes[668];
        }struVCADetect;
        
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // ��id��Ϣ��72�ֽڳ�
            DWORD                dwCmdType;  // �ⲿ�������ͣ�NVR�����ƴ洢ʹ��
            BYTE                byBackupVolumeNum; //�浵��ţ�CVRʹ��
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //�浵��ǩ��CVRʹ��
            BYTE                byRes[656];
        }struStreamIDParam;
        
        struct //pos¼��
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //ͨ������ֵ��ʾ,���������У�����0xffffʱ��ʾ�������ֵ��Ч
            BYTE     byAllChan;        //�Ƿ����ȫ��ͨ����0-�񣬴�ʱwChannel��Ч��1-ȫ��ͨ������ʱwChannel��Ч
            BYTE      byCaseSensitive;      //0-�����ִ�Сд�� 1-���ִ�Сд
            BYTE      byCombinateMode;  //�ؼ�����Ϸ�ʽ��0-��1-��
            BYTE      byRes1;              //����
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN]; 
                                             //�ؼ��ֲ���ʱ������
            BYTE    byRes[284];          //����
        }struPosAlarm;
        
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];       //�������
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];   //��������
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];   //������1
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];   //������2
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];   //���г�
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;

        struct //�Ž��¼���������
        {
            DWORD dwMajor; //���������ͣ����¼��ϴ�������һ�£�0����ȫ����
            DWORD dwMinor; //���������ͣ����¼��ϴ�������һ�£�0����ȫ����
            BYTE byCardNo[ACS_CARD_NO_LEN]; //����
            BYTE byName[NAME_LEN/*32*/]; //����
            BYTE byMACAddr[MACADDR_LEN]; //����MAC��ַ
            BYTE byRes[722];
        }struACSAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;

//�¼���������
typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V50
{
    WORD wMajorType;            //0-�ƶ���⣬1-��������, 2-�����¼� 5-pos¼�� 7-�Ž��¼�, 8-����Ƶ�����¼�
    WORD wMinorType;            //����������- ���������ͱ仯��0xffff��ʾȫ��
    NET_DVR_TIME_SEARCH_COND struStartTime;    //�����Ŀ�ʼʱ�䣬ֹͣʱ��: ͬʱΪ(0, 0) ��ʾ�������ʱ�俪ʼ���������ǰ���4000���¼�
    NET_DVR_TIME_SEARCH_COND struEndTime;    //�����Ľ���ʱ��
    BYTE            byLockType;        // 0xff-ȫ����0-δ����1-����
    BYTE            byQuickSearch;        // �Ƿ����ÿ��ٲ�ѯ��0-�����ã�1-���ã����ٲ�ѯ���᷵���ļ���С�������豸���ݿ���в�ѯ������Ƶ������Ӳ�̣�
    BYTE             byRes[254];        // ����
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct//��������
        {
            /*��������ţ���ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wAlarmInNo[128];
            BYTE byRes[544]; //����
        }struAlarmParam;

        struct//�ƶ����
        {
            /* �ƶ����ͨ������ֵ��ʾ ,���ý��������У�0xffff��ʾ������Ч*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];                /*����*/
        }struMotionParam;

        struct //��Ϊ���� 
        {
            //��Ϊ������Ӧ��ͨ������ֵ��ʾ,���ý��������У�0xffff��ʾ������Ч
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //��Ϊ�������ͣ�����0xff��ʾȫ������0��ʼ
            BYTE     byDriverBehaviortType;  //˾����ʻ��Ϊ���ͣ�0-������1-���̡�2-�Ӵ�绰��3-ƣ�ͼ�ʻ��4-�������ѡ�5-��ʻԱ�쳣��6-δϵ��ȫ����7-�������ī��
            BYTE     byADASType;  //�߼�������ʻ���ͣ�0-������1-ǰ����ײ��2-����ƫ�롢3-ä����⡢4-�����⡢5-���˷�ײ��6-�����١�7-�����١�8-����ת�䡢9-����ת�䡢10-����������11-δ��������
            BYTE     byGSensorType;  // G-Sensor�¼���0-������1-�����١�2-�����١�3-����ת�䡢4-����ת�䡢5-����������6-������ײ
            BYTE     bySensorInType;  // Sensor-In��Ϊ��0-������1-ɲ����2-��ת��3-��ת��4-����
            BYTE byRes[667];     /*����*/
        }struVcaParam;

        struct//��Ѷ�¼���������
        {
            BYTE byRoomIndex;    //��Ѷ�ұ��,��1��ʼ
            BYTE byRes[799];     //����
        } struInquestParam;

        struct//�������������� ��ͨ���Ű�ֵ��ʾ
        {
            BYTE byAll;                //����ȫ��ͨ����0-�񣬴�ʱdwChanNo������Ч��
            //1-����ȫ��ͨ������ʱdwChanNo������Ч��
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// ����ͨ����,��ֵ��ʾ��0xffff��Ч���Һ�������Ҳ��ʾ��Чֵ
            BYTE byRes[668];
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // ��id��Ϣ��72�ֽڳ�
            DWORD                dwCmdType;  // �ⲿ�������ͣ�NVR�����ƴ洢ʹ��
            BYTE                byBackupVolumeNum; //�浵��ţ�CVRʹ��
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //�浵��ǩ��CVRʹ��
            BYTE                byRes[656];
        }struStreamIDParam;

        struct //pos¼��
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //ͨ������ֵ��ʾ,���������У�����0xffffʱ��ʾ�������ֵ��Ч
            BYTE     byAllChan;        //�Ƿ����ȫ��ͨ����0-�񣬴�ʱwChannel��Ч��1-ȫ��ͨ������ʱwChannel��Ч
            BYTE      byCaseSensitive;      //0-�����ִ�Сд�� 1-���ִ�Сд
            BYTE      byCombinateMode;  //�ؼ�����Ϸ�ʽ��0-��1-��
            BYTE      byRes1;              //����
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
            //�ؼ��ֲ���ʱ������
            BYTE    byRes[284];          //����
        }struPosAlarm;

        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[547];
        }struTrialParam;

        struct //�Ž��¼���������
        {
            DWORD dwMajor; //���������ͣ����¼��ϴ�������һ�£�0����ȫ����
            DWORD dwMinor; //���������ͣ����¼��ϴ�������һ�£�0����ȫ����
            BYTE byCardNo[ACS_CARD_NO_LEN]; //����
            BYTE byName[NAME_LEN/*32*/]; //����
            BYTE byMACAddr[MACADDR_LEN]; //����MAC��ַ
            BYTE byRes[722];
        }struACSAlarm;
        struct //����Ƶ�����¼���������
        {
            WORD      wDeviceType;            //�豸����,0-�����Ž�������1-�������ӶԽ��豸, 2-��������������Ԥ���� 3-GJD�������� 4-Luminite��������, 5-OPTEX��������,6-cameraDetectorģ������������豸
            WORD      wEventType;            //����������- ���������ͱ仯��0xffff��ʾȫ��
            WORD      wChannel[MAX_CHANNUM_V30/*64*/];        //ͨ���ţ���ֵ��ʾ,���������У�����0xffffʱ��ʾ�������ֵ��Ч
            BYTE      byAllChan;        //�Ƿ����ȫ��ͨ����0-�񣬴�ʱwChannel��Ч��1-ȫ��ͨ������ʱwChannel��Ч
            BYTE      byCaseSensitive;      //0-�����ִ�Сд�� 1-���ִ�Сд
            BYTE      byCombinateMode;  //�ؼ�����Ϸ�ʽ��0-��1-��
            BYTE      bySearchType;      //������ʽ��0-����ƵԴ��������ʱͨ����Ϊ��Ƶͨ���ţ�
            char      sKeyWord[MAX_POS_KEYWORDS_NUM/*3*/][MAX_POS_KEYWORD_LEN/*128*/];//�ؼ��ֲ���ʱ������
            WORD      wZoneNo;      //�����ţ������豸����Ϊ��������������������Ϊ������wEventTypeΪ1��ʱ��Ч
            BYTE      byRes[278];   //����
        }struIOTAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V50, *LPNET_DVR_SEARCH_EVENT_PARAM_V50;


//���ҷ��ؽ��
typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;            //������
    WORD wMinorType;            //������
    NET_DVR_TIME struStartTime;    //�¼���ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ�䣬�����¼�ʱ�Ϳ�ʼʱ��һ��
    BYTE byChan[MAX_CHANNUM_V30];    
    BYTE byChanEx[32];   //����ͨ������λ��ʾ��ʹ�ø��ֶκ�byChan���Բ�ʹ��
    BYTE byRes[4];
    union        
    {
        struct//����������
        {
            DWORD dwAlarmInNo;     //���������
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//�ƶ������
        {
            DWORD dwMotDetNo;    //�ƶ����ͨ��
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//��Ϊ�������  
        {
            DWORD dwChanNo;                    //�����¼���ͨ����
            BYTE byRuleID;                    //����ID
            BYTE byRes1[3];                    //����
            BYTE byRuleName[NAME_LEN];        //��������
            NET_VCA_EVENT_UNION uEvent;     //��Ϊ�¼�����
        }struVcaRet;
        struct//��Ѷ�¼�
        {
            BYTE  byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE  byDriveIndex;    //��¼�����,��1��ʼ
            BYTE  byRes1[6];       //����
            DWORD dwSegmentNo;     //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ 
            WORD  wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM 
            WORD  wSegmentState;   //��Ƭ��״̬ 0 ��¼������1 ��¼�쳣��2 ����¼��Ѷ
            BYTE  byRes2[288];     //����
        }struInquestRet;
        struct //��id¼���ѯ���
        {
            DWORD dwRecordType;    /*¼������ 0-��ʱ¼��,1-�ƶ����,2-��������,3-����|�ƶ����, 4-����&�ƶ����,5-�����,6-�ֶ�¼��,7-�𶯱���,8-������������, 
                                   9-���ܱ���,10-PIR����,11-���߱���,12-���ȱ���,13- PIR|���߱���|���ȱ�, 14-���ܽ�ͨ�¼�,15-Խ�����,16-��������,17-�����쳣,
                                   18-����������, 19-ȫ�������ܣ�Խ�����|��������|��������|�뿪����|����ʶ��, 20-�ź���,21-�ش���22-��Ǩ¼��,23-�ڵ� 24-¼��ƴ�Ӵ浵*/
            DWORD dwRecordLength;    //¼���С
            BYTE  byLockFlag;    // ������־ 0��û���� 1������
            BYTE  byDrawFrameType;    // 0���ǳ�֡¼�� 1����֡¼��
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //�ļ���
            DWORD dwFileIndex;            // �浵���ϵ��ļ�����
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE    byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE    byDriveIndex;    //��¼�����,��1��ʼ
            WORD    wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            DWORD    dwSegmentNo;    //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            BYTE    bySegmentState;   //��Ƭ��״̬��0-��¼������1-��¼�쳣��2-����¼��Ѷ
            BYTE    byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //�������
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //�������ƣ�
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //������1��
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //������2��
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//���г�
            BYTE    byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET, *LPNET_DVR_SEARCH_EVENT_RET;

#define NET_SDK_MAX_TAPE_INDEX_LEN  32  //�Ŵ������󳤶�
#define NET_SDK_MAX_FILE_LEN        256  //�ļ�����󳤶�

//���ҷ��ؽ��
typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;            //������
    WORD wMinorType;            //������
    NET_DVR_TIME struStartTime;    //�¼���ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ�䣬�����¼�ʱ�Ϳ�ʼʱ��һ��
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //������ͨ���ţ�0xffff��ʾ������Ч
    BYTE byRes[36];
    union        
    {
        BYTE  byLen[800];               //�����峤��
        struct//����������
        {
            DWORD dwAlarmInNo;     //���������
            BYTE byRes[796];
        }struAlarmRet;
        struct//�ƶ������
        {
            DWORD dwMotDetNo;    //�ƶ����ͨ��
            BYTE byRes[796];
        }struMotionRet;
        struct//��Ϊ�������  
        {
            DWORD dwChanNo;                    //�����¼���ͨ����
            BYTE byRuleID;                    //����ID
            BYTE byRes1[3];                    //����
            BYTE byRuleName[NAME_LEN];        //��������
            NET_VCA_EVENT_UNION uEvent;     //��Ϊ�¼�����
            BYTE byRes[668];                    //����
        }struVcaRet;
        
        struct//��Ѷ�¼�
        {
            BYTE  byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE  byDriveIndex;    //��¼�����,��1��ʼ
            BYTE  byRes1[6];       //����
            DWORD dwSegmentNo;     //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ 
            WORD  wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM 
            WORD  wSegmentState;   //��Ƭ��״̬ 0 ��¼������1 ��¼�쳣��2 ����¼��Ѷ
            BYTE  byRes2[784];     //����
        }struInquestRet;
        
        struct //��id¼���ѯ���
        {
            DWORD dwRecordType;    //¼������ 0-��ʱ¼�� 1-�ƶ���� 2-����¼�� 3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼�� 7-�𶯱��� 8-�������� 9-���ܱ��� 10-�ش�¼��
            DWORD dwRecordLength;    //¼���С
            BYTE  byLockFlag;    // ������־ 0��û���� 1������
            BYTE  byDrawFrameType;    // 0���ǳ�֡¼�� 1����֡¼��
            BYTE  byPosition;// �ļ����ڴ洢λ�ã�0-�����ϣ�1-�����λ�ϣ�����ֱ�����أ�2-�Ŵ����ڣ���Ҫ�Ѵ����л�����λ�ϣ�3-���ڴŴ����У���Ҫ�Ѵ��̲嵽�Ŵ�����
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];     //�ļ���
            DWORD dwFileIndex;            // �浵���ϵ��ļ�����
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //�ļ����ڴŴ����
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //�ļ�����չ
            BYTE  byRes[464];
        }struStreamIDRet;
        
        struct//POS¼���ѯ���
        {
            DWORD dwChanNo;        //��������pos�¼���ͨ��
            BYTE  byRes[796];
        }struPosRet;
        
        struct
        {
            BYTE    byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE    byDriveIndex;    //��¼�����,��1��ʼ
            WORD    wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            DWORD    dwSegmentNo;    //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            BYTE    bySegmentState;   //��Ƭ��״̬��0-��¼������1-��¼�쳣��2-����¼��Ѷ
            BYTE    byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //�������
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //�������ƣ�
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //������1��
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //������2��
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//���г�
            BYTE    byRes1[600];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;

//���ҷ��ؽ��
typedef struct tagNET_DVR_SEARCH_EVENT_RET_V50
{
    WORD wMajorType;            //������
    WORD wMinorType;            //������
    NET_DVR_TIME_SEARCH struStartTime;    //�¼���ʼ��ʱ��
    NET_DVR_TIME_SEARCH struEndTime;   //�¼�ֹͣ��ʱ�䣬�����¼�ʱ�Ϳ�ʼʱ��һ��
    NET_DVR_ADDRESS struAddr;  //Ƭ�����ڵĵ�ַ��Ϣ����Ⱥ�ط�ʱ�õ�
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //������ͨ���ţ�0xffff��ʾ������Ч
    BYTE byRes[256];
    union
    {
        BYTE  byLen[800];               //�����峤��
        struct//����������
        {
            DWORD dwAlarmInNo;     //���������
            BYTE byRes[796];
        }struAlarmRet;
        struct//�ƶ������
        {
            DWORD dwMotDetNo;    //�ƶ����ͨ��
            BYTE byRes[796];
        }struMotionRet;
        struct//��Ϊ�������  
        {
            DWORD dwChanNo;                    //�����¼���ͨ����
            BYTE byRuleID;                    //����ID
            BYTE byRes1[3];                    //����
            BYTE byRuleName[NAME_LEN];        //��������
            NET_VCA_EVENT_UNION uEvent;     //��Ϊ�¼�����
            BYTE byRes[668];                    //����
        }struVcaRet;

        struct//��Ѷ�¼�
        {
            BYTE  byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE  byDriveIndex;    //��¼�����,��1��ʼ
            BYTE  byRes1[6];       //����
            DWORD dwSegmentNo;     //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ 
            WORD  wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM 
            WORD  wSegmentState;   //��Ƭ��״̬ 0 ��¼������1 ��¼�쳣��2 ����¼��Ѷ
            BYTE  byRes2[784];     //����
        }struInquestRet;

        struct //��id¼���ѯ���
        {
            DWORD dwRecordType;    //¼������ 0-��ʱ¼�� 1-�ƶ���� 2-����¼�� 3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼�� 7-�𶯱��� 8-�������� 9-���ܱ��� 10-�ش�¼��
            DWORD dwRecordLength;    //¼���С
            BYTE  byLockFlag;    // ������־ 0��û���� 1������
            BYTE  byDrawFrameType;    // 0���ǳ�֡¼�� 1����֡¼��
            BYTE  byPosition;// �ļ����ڴ洢λ�ã�0-�����ϣ�1-�����λ�ϣ�����ֱ�����أ�2-�Ŵ����ڣ���Ҫ�Ѵ����л�����λ�ϣ�3-���ڴŴ����У���Ҫ�Ѵ��̲嵽�Ŵ�����
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];     //�ļ���
            DWORD dwFileIndex;            // �浵���ϵ��ļ�����
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //�ļ����ڴŴ����
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //�ļ�����չ
            BYTE  byRes[464];
        }struStreamIDRet;

        struct//POS¼���ѯ���
        {
            DWORD dwChanNo;        //��������pos�¼���ͨ��
            BYTE byRes[796];
        }struPosRet;

        struct
        {
            BYTE    byRoomIndex;     //��Ѷ�ұ��,��1��ʼ
            BYTE    byDriveIndex;    //��¼�����,��1��ʼ
            WORD    wSegmetSize;     //��Ƭ�ϵĴ�С, ��λM
            DWORD    dwSegmentNo;    //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ
            BYTE    bySegmentState;   //��Ƭ��״̬��0-��¼������1-��¼�쳣��2-����¼��Ѷ
            BYTE    byCaseType; //�������ͣ�0-ȫ����1-���°�����2-���°���
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //�������
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //�������ƣ�
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //������1��
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //������2��
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//���г�
            BYTE    byRes1[600];
        }struTrialRet;
        struct//����Ƶͨ����ѯ���
        {
            DWORD dwChanNo;        //���������¼���ͨ���ţ��¼�Դͨ����
            BYTE byRes[796];
        }struIOTRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V50, *LPNET_DVR_SEARCH_EVENT_RET_V50;

//SDK_V35  2009-10-26

// �궨��������
typedef enum tagCALIBRATE_TYPE
{
    PDC_CALIBRATE  = 0x01,  // PDC �궨
        BEHAVIOR_OUT_CALIBRATE  = 0x02, //��Ϊ���ⳡ���궨  
        BEHAVIOR_IN_CALIBRATE = 0x03,    // ��Ϊ���ڳ����궨 
        ITS_CALBIRETE       = 0x04,      //  ��ͨ�¼��궨
        BV_DIRECT_CALIBRATE      = 0x05,   //˫Ŀֱ�ӱ궨
        PDC_LINE_CALIBRATE  = 0x06  //PDC �� �궨
}CALIBRATE_TYPE;

#define MAX_RECT_NUM  6
typedef struct tagNET_DVR_RECT_LIST
{    
    BYTE    byRectNum;    // ���ο�ĸ���
    BYTE    byRes1[11];  //�����ֽ� 
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM]; // ���Ϊ6��Rect 
}NET_DVR_RECT_LIST, *LPNET_DVR_RECT_LIST;

// PDC �궨����
typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;       // �궨���ο��б�
    BYTE           byRes[120];       // �����ֽ� 
}NET_DVR_PDC_CALIBRATION, *LPNET_DVR_PDC_CALIBRATION;


// �궨�ߵ��������������ʾ��ǰ�궨����ʵ�ʱ�ʾ���Ǹ߶��߻��ǳ����ߡ�
typedef enum tagLINE_MODE
{
    HEIGHT_LINE,        //�߶�������
        LENGTH_LINE        //����������
}LINE_MODE;
/*
�����ñ궨��Ϣ��ʱ�������Ӧλ������ʹ�ܣ���������ز�����
��û������ʹ�ܣ���궨����Ի�ȡ��ص����������
*/
typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;     // �Ƿ�ʹ������������߶���
    BYTE    byEnableAngle;      // �Ƿ�ʹ����������������Ƕ�
    BYTE    byEnableHorizon;    // �Ƿ�ʹ�������������ƽ��
    BYTE    byRes[5];   // �����ֽ� 
    float   fCameraHeight;    // ������߶�
    float   fCameraAngle;     // ����������Ƕ�
    float   fHorizon;         // �����еĵ�ƽ��
}NET_DVR_CAMERA_PARAM, *LPNET_DVR_CAMERA_PARAM;
/*
��fValue��ʾĿ��߶ȵ�ʱ��struStartPoint��struEndPoint�ֱ��ʾĿ��ͷ����ͽŲ��㡣
��fValue��ʾ�߶γ��ȵ�ʱ��struStartPoint��struEndPoint�ֱ��ʾ�߶���ʼ����յ㣬
mode��ʾ��ǰ�����߱�ʾ�߶��߻��ǳ����ߡ�
*/
typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;     // ���� LINE_MODE
    BYTE            byRes[3];       // �����ֽ� 
    NET_VCA_POINT   struStartPoint;  
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT, *LPNET_DVR_LINE_SEGMENT;

#define  MAX_LINE_SEG_NUM 8

/*
�궨������Ŀǰ��Ҫ4-8�������ߣ��Ի�ȡ�������ز���
*/
typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;          // �����߸���
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];    // ������������
    NET_DVR_CAMERA_PARAM    struCameraParam;    // ���������
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION, *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

/*
�ýṹ���ʾIAS���ܿ�궨������
���а���һ��Ŀ����һ����Ӧ�ĸ߶ȱ궨�ߣ�
Ŀ���Ϊվ����������Ӿ��ο򣻸߶���������ʶ����ͷ���㵽�ŵ�ı궨�ߣ�
�ù�һ�������ʾ��
*/
typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;   // Ŀ���
    NET_DVR_LINE_SEGMENT struLineSegment;    // �߶ȱ궨��
}NET_DVR_IN_CAL_SAMPLE, *LPNET_DVR_IN_CAL_SAMPLE;

#define  MAX_SAMPLE_NUM 5  //ֱ�ӱ궨��������
#define  MAX_SAMPLE_NUM_EX 7 //�����궨�������չ

typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION 
{
    DWORD    dwCalSampleNum;      //  �궨��������
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM]; // �궨����������
    NET_DVR_CAMERA_PARAM    struCameraParam;    // ���������
    BYTE byRes[16];
}NET_DVR_BEHAVIOR_IN_CALIBRATION, *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

#define  CALIB_PT_NUM 4
typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum; //�궨����
    NET_VCA_POINT struPoint[CALIB_PT_NUM]; //ͼ������
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];        // �����ֽ�
}NET_DVR_ITS_CALIBRATION, *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{   
    DWORD  dwCameraHeight;  //������߶ȣ���λcm
    float  fPitchAngle;     //��������ӽǶ�[0��, 60��],
    float  fInclineAngle;   //�������б�Ƕ�[-20��,20��]
    BYTE   byRes1[228];     //����
}NET_DVR_BV_DIRECT_CALIBRATION,*LPNET_DVR_BV_DIRECT_CALIBRATION;

// PDC �궨����
typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[224];// �����ֽ� 
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;

// �궨����������
// ��������ر궨�������Է��ڸýṹ����
typedef union tagNET_DVR_CALIBRATION_PRARM_UNION
{
    BYTE byRes[240];                    //������ṹ��С
    NET_DVR_PDC_CALIBRATION struPDCCalibration;  //PDC �궨����
    NET_DVR_BEHAVIOR_OUT_CALIBRATION  struBehaviorOutCalibration;  //  ��Ϊ���ⳡ���궨  ��ҪӦ����IVS��
    NET_DVR_BEHAVIOR_IN_CALIBRATION  struBehaviorInCalibration;     // ��Ϊ���ڳ����궨����ҪӦ��IAS�� 
    NET_DVR_ITS_CALIBRATION struITSCalibration;
    NET_DVR_BV_DIRECT_CALIBRATION struBvDirectCalibration; //˫Ŀֱ�ӱ궨
    NET_DVR_PDC_LINE_CALIBRATION struPDCLineCalibration; //PDC �߱궨����
}NET_DVR_CALIBRATION_PRARM_UNION, *LPNET_DVR_CALIBRATION_PRARM_UNION;


// �궨���ýṹ
typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;               //�궨�ṹ��С
    BYTE    byEnable;           // �Ƿ����ñ궨
    BYTE    byCalibrationType;    // �궨���� ���ݲ�ͬ��������������ѡ��ͬ�ı궨 �ο�CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;  // �궨����������
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG, *LPNET_DVR_CALIBRATION_CFG; 

//����ͳ�Ʒ���ṹ��
typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint; //����ͳ�Ʒ�����ʼ��
    NET_VCA_POINT struEndPoint;    // ����ͳ�Ʒ�������� 
}NET_DVR_PDC_ENTER_DIRECTION, *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;              //�ṹ��С
    BYTE            byEnable;             // �Ƿ񼤻����;
    BYTE            byRes1[23];       // �����ֽ� 
    NET_VCA_POLYGON          struPolygon;            // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // �������뷽��
} NET_DVR_PDC_RULE_CFG, *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;              //�ṹ��С
    BYTE            byEnable;             // �Ƿ񼤻����;
    BYTE            byRes1[23];       // �����ֽ� 
    NET_VCA_POLYGON struPolygon;            // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // �������뷽��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_TIME_EX struDayStartTime; //���쿪ʼʱ�䣬ʱ������Ч
    NET_DVR_TIME_EX struNightStartTime; //ҹ��ʼʱ�䣬ʱ������Ч
    BYTE            byRes[100];       // �����ֽ�
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

/********* IPC5.1.7 ������ͳ�ƹ��� Begin 2014-03-21***********/
//�����ṹ
typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize; //�ṹ��С
    DWORD  dwChannel; //ͨ����
    DWORD dwID; //����ID����������ೡ����������ϰ汾SDK�������豸ʱ�������ֽ�Ϊ0���������������ֽ�Ϊ0ʱ��ҲĬ��Ϊ����1 
    BYTE  byRes[60]; 
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

//���߽ṹ��
typedef struct tagNET_VCA_POLYLINE
{
    NET_VCA_POINT struPoint[4];    //���ߵ� 
}NET_VCA_POLYLINE, *LPNET_VCA_POLYLINE;

//���ýṹ
typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize; //�ṹ��С
    BYTE   byEnable; //�Ƿ񼤻����;
    BYTE   byOSDEnable;//����ͳ��OSD��ʾ�Ƿ�����,  0-��0-�ޣ���1-�ǣ�0-������뿪���� 2-���룬 3-�뿪   �������豸�Ĳ�����OSD���Ӷ�Ӧ���ޣ������ö�Ӧ������/�뿪����4-����������5-����;�����
    BYTE   byCurDetectType;//��ǰ����������ͣ�0-����Σ�1-�����, 2-���߼��
    BYTE   byInterferenceSuppression; //�������ƣ���λ��ʾ,0-δ��ѡ,1-��ѡ��bit0-��Ӱ��bit1-�ǻ���bit2-�Ƴ�
    NET_VCA_POINT   struOSDPoint;//����ͳ����ʾOSD��ʾ���Ͻ�����
    //��������������ϴ����ڣ�0-15��1-1��2-5��3-10��4-20��5-30��6-60����λ������
    BYTE   byDataUploadCycle; 
    //ÿ���ϴ�����ʹ�ܣ�0-�رգ�1-������
    BYTE   bySECUploadEnable;
    BYTE   byEmailDayReport;//�����ձ���ʹ�� 0-�رգ�1-����
    BYTE   byEmailWeekReport;//�����ܱ���ʹ�� 0-�رգ�1-����
    BYTE   byEmailMonthReport;//�����±���ʹ��0-�رգ�1-����
    BYTE   byEmailYearReport;//�����걨��ʹ��0-�رգ�1-����
    BYTE   byRes2[6];// �����ֽ�  
    NET_VCA_POLYGON          struPolygon; // �����
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // �������뷽��
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_TIME_EX struDayStartTime; //���쿪ʼʱ�䣬ʱ������Ч
    NET_DVR_TIME_EX struNightStartTime; //ҹ��ʼʱ�䣬ʱ������Ч
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*����ʽ ��֧���ϴ�����*/
    BYTE   byDetecteSensitivity;//Ŀ���������ȣ���Χ1-100��Ĭ��50
    BYTE   byGenerateSpeedSpace;//Ŀ�������ٶȣ����򣩣���Χ1-100��Ĭ��50
    BYTE   byGenerateSpeedTime;// Ŀ�������ٶȣ�ʱ�򣩣���Χ1-100��Ĭ��50
    BYTE   byCountSpeed;// �����ٶȣ���Χ1-100��Ĭ��50
    BYTE   byDetecteType;// Ŀ�������ͣ�0-�Զ���1-��ͷ��2-ͷ�磬Ĭ��0-�Զ����Զ�ģʽ��DSP�����㷨�Ĳ������ø��㷨��
    BYTE   byTargetSizeCorrect;//Ŀ��ߴ���������Χ1-100��Ĭ��50
    BYTE   byStreamOverlayRuleInfos;//����������Ϣ���� 0-��1-��
    BYTE   byRes3;// �����ֽ�
    NET_VCA_LINE  struLine;//�����
    BYTE byHeightFilterEnable;//�߶ȹ����Ƿ�����0-������1-�رգ�2-����
    BYTE  byDetectThreshold;//�����ֵ,��Χ[0,100],Ĭ�� 90(�ڲ�ʹ�ã��ݲ�����)�����趨�㷨���б����Ŀ������Ŷ���ֵ�����Ŷȵ��ڸ���ֵ��Ŀ�꣬�����ڸ��ټ�����
    BYTE  byAidedTrackEnabled;//�������ٿ��أ�0~������1~�رգ�Ĭ�Ͽ���(�ڲ�ʹ��) ���ڿ����͹ر��㷨����ģ���еĹ����������٣����ٿ�����Ա�����Ӿ�׼�ȡ�
    BYTE byRes4;
    float fHeightFilter;//���˸߶ȣ���λ�����ף�Ĭ��ֵ��120���ף���Χ��40-200���ס�byHeightFilterEnableΪ2�ǲ���Ч
    BYTE byCalibrateType;//�궨���ͣ�0-δ���б궨��1-�Զ��궨��2-�ֶ��궨
    BYTE byCountingType;//����������ʽ 0-��,1-�������봥��,2-��Ƶ��������
    BYTE bySignalType;//�ź����� 0-��ƽ��1-����
    BYTE byRS485TransmissionEnabled;//����485���� 0-�رգ�1-����
    float fTiltAngle;//������,��λ���ȣ�������Ĭ��ֵ��0�������Ƿ�Χ��0-180��,ֻ��
    float fHeelAngle;//��б��,��λ���ȣ���б��Ĭ��ֵ��0����б�Ƿ�Χ��-90-90��,ֻ��
    float fHeight;//�߶ȣ��߶ȵ�λ�����ף��߶�Ĭ��ֵ300���ף��߶ȷ�Χ��200-500����,��byCalibrateTypeΪ2ʱ������Ч������ʱֻ��
    NET_VCA_POLYGON struCountPolygon;//�������򣺸ò���Ĭ��Ϊֻ�����ԣ�������ͨ�����������з�����<CountingPolygon>�����ڵ㣬�����ò���֧�����á�
    NET_VCA_POLYGON struAutoCalibPolygon;//�궨���򣬵�byCalibrateTypeΪ1ʱ��Ч
    NET_DVR_TIME_EX struDailyResetTime; //��ʱ����
    NET_VCA_POLYLINE struPolyLine;//���߼�������������ߺ�struLine������ʾ��
    BYTE   byRes[4]; //�����ֽ�
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;
/********* IPC5.1.7 ������ͳ�ƹ��� End 2014-03-21***********/

//���ð���Ϣ�ṹ��
typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //������ʣ��ʱ�䣬0xffff��ʾ��Ч����λ����
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byRes[64]; 
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byMode; //��Чģʽ��0-��ʱ��1-�ֶ�
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//��������ʱ�䣬ʱ������Ч
    BYTE  byRes[64]; 
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

#define NET_SDK_MAX_RELATED_CHAN_NUM  4 //������ͨ����

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;     //�Ƿ�������
    BYTE   byVCAType;       //�����������ͣ�VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //�������Ƿ��������Ϣ
    BYTE   byMode;            //ģʽ��ATM ����ʱ����VCA_CHAN_MODE_TYPE ,TFS ����ʱ���� TFS_CHAN_MODE_TYPE����Ϊ����������ʱ����BEHAVIOR_SCENE_MODE_TYPE
    BYTE   byControlType;   //�������ͣ���λ��ʾ��0-��1-��
    //byControlType &1 �Ƿ�����ץ�Ĺ���
    //byControlType &2 �Ƿ���������ǰ���豸
    BYTE   byRes1[3];
    WORD   wRelatedChannel[NET_SDK_MAX_RELATED_CHAN_NUM/*4*/];/*����ͨ���ţ�0-����������ǰ��ATM�豸ʹ�ã�������ͨ��ģʽΪATM���ʱ�����Թ���һ·ATM����ͨ����*/
    BYTE   byRes[72];       //����������Ϊ0
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;

//����������ͳ�Ʋ���  ������Ϊ�ڲ��ؼ��ֲ��� 
// HUMAN_GENERATE_RATE
// Ŀ�������ٶȲ���������PDC������Ŀ����ٶȡ��ٶ�Խ�죬Ŀ��Խ�������ɡ���������Ƶ���������ϲ�ԱȶȽϵ�ʱ���������õĹ��������Сʱ��Ӧ�ӿ�Ŀ�������ٶȣ� ����Ŀ���©�죻��������Ƶ�жԱȶȽϸ�ʱ�����߹�������ϴ�ʱ��Ӧ�ý���Ŀ�������ٶȣ��Լ�����졣Ŀ�������ٶȲ�������5����1���ٶ�������5����죬Ĭ�ϲ���Ϊ3��
// 
// DETECT_SENSITIVE
// Ŀ���������ȿ��Ʋ���������PDC����һ���������򱻼��ΪĿ��������ȡ�������Խ�ߣ���������Խ���ױ����ΪĿ�꣬������Խ����Խ�Ѽ��ΪĿ�ꡣ��������Ƶ���������ϲ�ԱȶȽϵ�ʱ��Ӧ��߼�������ȣ� ����Ŀ���©�죻��������Ƶ�жԱȶȽϸ�ʱ��Ӧ�ý��ͼ�������ȣ��Լ�����졣��Ӧ��������5��������1��������ͣ�5����ߣ�Ĭ�ϼ���Ϊ3��
// TRAJECTORY_LEN
// �켣���ɳ��ȿ��Ʋ�������ʾ���ɹ켣ʱҪ��Ŀ������λ�����ء���Ӧ��������5��������1�����ɳ�������켣����������5�����ɳ�����̣��켣������죬Ĭ�ϼ���Ϊ3��
// TRAJECT_CNT_LEN
// �켣�������ȿ��Ʋ�������ʾ�켣����ʱҪ��Ŀ������λ�����ء���Ӧ��������5��������1������Ҫ�󳤶�����켣����������5������Ҫ�󳤶���̣��켣������죬Ĭ�ϼ���Ϊ3��
// PREPROCESS
// ͼ��Ԥ������Ʋ�����0 - ������1 - ����Ĭ��Ϊ0��
// CAMERA_ANGLE
// ������Ƕ���������� 0 - ��б�� 1 - ��ֱ��Ĭ��Ϊ0��
typedef enum tagPDC_PARAM_KEY
{
    HUMAN_GENERATE_RATE = 50,              // Ŀ�������ٶ� ��50��ʼ
        DETECT_SENSITIVE    = 51,               // ���������
}PDC_PARAM_KEY;

typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                 // Ŀ��id 
    NET_VCA_RECT struTargetRect;               // Ŀ���
    BYTE      byRes1[8];        // �����ֽ�
}NET_DVR_PDC_TARGET_INFO, *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                   //Ŀ�����
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];   //Ŀ����Ϣ����
    BYTE    byRes2[8];                  // �����ֽ�
}NET_DVR_PDC_TARGET_IN_FRAME, *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;          // PDC�����������ϴ��ṹ���С
    BYTE                        byMode;          // 0 ��֡ͳ�ƽ�� 1��Сʱ���ͳ�ƽ�� 2 �ź���������������ڡ�ͳ����ʼʱ�䡱&&��ͳ�ƽ���ʱ�䡱�� 
    BYTE                        byChannel;       // �����ϴ�ͨ����
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE                        bySmart;         //רҵ���ܷ���0��Smart ���� 1
    BYTE                        byRes1;          // �����ֽ�    
    /********* IPC5.1.7 �������� End 2014-03-21***********/
    NET_VCA_DEV_INFO       struDevInfo;             //ǰ���豸��Ϣ
    union        
    {
        struct   // ��֡ͳ�ƽ��ʱʹ��
        {
            DWORD   dwRelativeTime;     // ���ʱ��
            DWORD   dwAbsTime;          // ����ʱ��
            BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
            char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
            char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
            BYTE    byRes[89];            
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // ͳ����ʼʱ�� 
            NET_DVR_TIME                      tmEnd;  //  ͳ�ƽ���ʱ�� 
            BYTE	        byTimeDifferenceFlag;   /*0-Ĭ����Ϊ��cStartTimeDifferenceH,��ʱ����Ϣ��Ч��1-ʱ����Ϣ��Ч*/
            char            cStartTimeDifferenceH;      /*��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����*/
            char            cStartTimeDifferenceM;      /*��ʼʱ����UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����*/
            char            cStopTimeDifferenceH;        /*����ʱ����UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����*/
            char            cStopTimeDifferenceM;       /*����ʱ����UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����*/
            BYTE            byRes[87];
        }struStatTime;
    }uStatModeParam;  // ��Ϊһ�������� ��֡��ʱ�����֡��Ŀ����Ϣ ��Сʱ���ͳ�ƽ����Ҫͳ��ʱ�� ����
    DWORD                       dwLeaveNum;        // �뿪����
    DWORD                       dwEnterNum;        // ��������
    BYTE                        byBrokenNetHttp;     //����������־λ��0-�����ش����ݣ�1-�ش�����
    BYTE                        byRes3;
    WORD                        wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx
    DWORD                       dwPassingNum;        // ��������������������ǻ�û�д������롢�뿪��������
    DWORD                       dwChildLeaveNum;        // С���뿪����
    DWORD                       dwChildEnterNum;        // С����������
    DWORD                       dwDuplicatePeople;        // �ظ�����
    DWORD                       dwXmlLen;//XML͸�����ݳ���, ��EventNotificationAlert XML Block�����ݳ���
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    char*  pXmlBuf; // XML������Ϣָ��,��XML��Ӧ��EventNotificationAlert XML Block
#else
    char*   pXmlBuf; // XML������Ϣָ��,��XML��Ӧ��EventNotificationAlert XML Block
    BYTE  byRes4[4];
#endif 
    BYTE                        byRes2[8];           // �����ֽ�
}NET_DVR_PDC_ALRAM_INFO, *LPNET_DVR_PDC_ALRAM_INFO;


//  ��������Ϣ��ѯ 
typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD       dwLeaveNum;
    DWORD       dwEnterNum; 
    BYTE        byRes1[256];
}NET_DVR_PDC_QUERY, *LPNET_DVR_PDC_QUERY;

typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;             // �ṹ��С 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // ����λ����Ϣ
    NET_VCA_RULECFG         struVcaRuleCfg;     //��Ϊ��������
    BYTE                    byRes2[80];         // �����ֽ�
}NET_DVR_POSITION_RULE_CFG, *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // �ṹ��С 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // ����λ����Ϣ
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //��Ϊ��������
    BYTE  byTrackEnable; //�Ƿ����ø���
    BYTE  byRes1;
    WORD wTrackDuration; //���ٳ���ʱ�䣬��λs
    BYTE                    byRes2[76];         // �����ֽ�
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;


typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;    // �Ƿ����ó�����λ����
    BYTE                byRes1[3];
    NET_DVR_PTZPOS      struUp;     // ����λ
    NET_DVR_PTZPOS      struDown;   // ����λ
    NET_DVR_PTZPOS      struLeft;   // ����λ
    NET_DVR_PTZPOS      struRight;  // ����λ
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE, *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    // ��������
    BYTE    byRes1;
    WORD    wDwell;    // ͣ��ʱ�� 
    BYTE    byRes2[4];   // �����ֽ�
}NET_DVR_POSITION_INDEX, *LPNET_DVR_POSITION_INDEX;

#define  MAX_POSITION_NUM 10
typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD dwSize;
    BYTE    byNum; // ��������
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG, *LPNET_DVR_POSITION_TRACK_CFG;

//Ѳ��·��������Ϣ
typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;         // ͣ��ʱ�� 30-300
    BYTE   byPositionID;   // ������1-10��Ĭ��0��ʾ��Ѳ���㲻��ӳ���
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO, *LPNET_DVR_PATROL_SCENE_INFO;

// ����Ѳ������������Ϣ
typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                 // �ṹ��С
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];    // Ѳ��·��
    BYTE   byRes[16];                              // �����ֽ�
}NET_DVR_PATROL_TRACKCFG, *LPNET_DVR_PATROL_TRACKCFG;

//������ع���˵����ýṹ��
typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // �ṹ��С
    WORD    wAlarmDelayTime;    // ������ʱʱ�䣬Ŀǰ���ֻ֧��ȫ������ ��Χ1-120��
    WORD    wTrackHoldTime;     // �������ٳ���ʱ��  ��Χ0-300��
    BYTE    byTrackMode;        //  ���� IPDOME_TRACK_MODE
    BYTE     byPreDirection;    // ���ٷ���Ԥ�� 0-������ 1-����
    BYTE      byTrackSmooth;        // ��������  0-������ 1-����
    BYTE     byZoomAdjust;    // ����ϵ������ �μ��±�
    BYTE    byMaxTrackZoom;    //�����ٱ���ϵ��,0-��ʾĬ�ϱ���ϵ��,�ȼ�6-�궨ֵ*1.0(Ĭ��),1-5Ϊ��С�궨ֵ��ֵԽС����С�ı���Խ��,7-15Ϊ�Ŵ�ֵԽ�󣬷Ŵ�ı���Խ��
    BYTE   byStopTrackWhenFindFace;  //������⵽���Ƿ�ֹͣ���� 0-�� 1-��
    BYTE   byStopTrackThreshold;   //������ֹ������ֵ
    BYTE   byRes[9];          //  �����ֽ�                
}NET_DVR_TRACK_PARAMCFG, *LPNET_DVR_TRACK_PARAMCFG;

// �����о����
typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;   // ��������ϵ��
    BYTE    byRes[42];  // �����ֽ�
}NET_DVR_DOME_MOVEMENT_PARAM, *LPNET_DVR_DOME_MOVEMENT_PARAM;

/********************************���ܽ�ͨ�¼� begin****************************************/
#define  MAX_REGION_NUM            8       // �����б������Ŀ
#define  MAX_TPS_RULE            8       // ������������Ŀ
#define  MAX_AID_RULE            8      // ����¼�������Ŀ
#define  MAX_LANE_NUM            8        // ��󳵵���Ŀ

//��ͨ�¼����ͣ�
typedef enum tagTRAFFIC_AID_TYPE
{
    CONGESTION          = 0x01,    //ӵ��
    PARKING             = 0x02,    //ͣ��  
    INVERSE             = 0x04,    //����
    PEDESTRIAN          = 0x08,    //����                      
    DEBRIS              = 0x10,    //������ ��������Ƭ 
    SMOKE               = 0x20,    //����  
    OVERLINE            = 0x40,     //ѹ��
    VEHICLE_CONTROL_LIST  = 0x80,  //����������
    SPEED                 = 0x100,  //����
    LANECHANGE         = 0x200,      //���
    TURNAROUND         = 0x400,     //��ͷ
    VEHICLE_OCCUPANCY_NONVEHICLE = 0x800, //������ռ�÷ǻ�����λ
    GASSER            = 0x1000,   //����
    ROADBLOCK         = 0x2000,   //·��
    CONSTRUCTION      = 0x4000,    //ʩ��
    TRAFFIC_ACCIDENT = 0x8000,    //��ͨ�¹ʼ�⣨��ͨ�¹�Ŀǰ���������¹ʣ�׷β���в���㷨�жϳ��복֮��켣�н��棬�������������򱨾���
    PARALLEL_PARKING = 0x10000,   //�෽λͣ�����
    FOG_DETECTION = 0x20000,       //Ũ����
    OCCUPY_EMERGENCY_LANE = 0x40000, //ռ�ý�������
    CONFLAGRATION = 0X80000,     //����
    TFS_MANUAL_TRIGGER = 0x100000,  //�ֶ�Υ��ȡ֤�¼� 
    LOADING_DOCK_TRIGGER_UPLOAD = 0x200000, //��̨�����ϴ�
    OCCUPY_OVERTAKING_LANE = 0x400000, //ռ�ó�����
    PROHIBITION_MARK_VIOLATION = 0x800000, //Υ�������־
    CHECK_POINT = 0x1000000, //����
    SUDDEN_SPEED_DROP = 0x2000000, //�ٶ��轵
    SLOW_MOVING = 0x4000000 //��������
}TRAFFIC_AID_TYPE;

typedef enum tagTRAFFIC_SCENE_MODE
{
    FREEWAY = 0,    //  ���ٻ��ⳡ��
        TUNNEL,         //  �����������
        BRIDGE          //  ������������
}TRAFFIC_SCENE_MODE;

typedef enum tagITS_ABILITY_TYPE
{
    ITS_CONGESTION_ABILITY             = 0x01,      //ӵ��
        ITS_PARKING_ABILITY                = 0x02,      //ͣ��  
        ITS_INVERSE_ABILITY                = 0x04,      //����
        ITS_PEDESTRIAN_ABILITY             = 0x08,      //����                      
        ITS_DEBRIS_ABILITY                 = 0x10,      //������ ��������Ƭ
        ITS_SMOKE_ABILITY                  = 0x20,      //����-���
        ITS_OVERLINE_ABILITY               = 0x40,      //ѹ��
        ITS_VEHICLE_CONTROL_LIST_ABILITY   = 0x80,        //����������
        ITS_SPEED_ABILITY                   = 0x100,        //����        
        ITS_LANECHANGE_ABILITY             = 0x200,     //���
        ITS_TURNAROUND_ABILITY             = 0x400,      //��ͷ
        ITS_LANE_VOLUME_ABILITY            = 0x010000,  //��������
        ITS_LANE_VELOCITY_ABILITY          = 0x020000,  //����ƽ���ٶ�
        ITS_TIME_HEADWAY_ABILITY           = 0x040000,  //��ͷʱ��
        ITS_SPACE_HEADWAY_ABILITY          = 0x080000,  //��ͷ���
        ITS_TIME_OCCUPANCY_RATIO_ABILITY   = 0x100000,  //����ռ���ʣ���ʱ����)
        ITS_SPACE_OCCUPANCY_RATIO_ABILITY  = 0x200000,  //����ռ���ʣ��ٷֱȼ��㣨�ռ���)
        ITS_LANE_QUEUE_ABILITY             = 0x400000,  //�Ŷӳ���
        ITS_VEHICLE_TYPE_ABILITY           = 0x800000,  //��������
        ITS_TRAFFIC_STATE_ABILITY          = 0x1000000  //��ͨ״̬
}ITS_ABILITY_TYPE;

// ��ͨͳ�Ʋ���
typedef enum tagITS_TPS_TYPE
{
    LANE_VOLUME           = 0x01,    //��������
        LANE_VELOCITY         = 0x02,    //�����ٶ�
        TIME_HEADWAY          = 0x04,    //��ͷʱ��
        SPACE_HEADWAY         = 0x08,    //��ͷ���
        TIME_OCCUPANCY_RATIO  = 0x10,    //����ռ���� (ʱ����)
        SPACE_OCCUPANCY_RATIO = 0x20,    //����ռ���ʣ��ٷֱȼ���(�ռ���)
        QUEUE                 = 0x40,    //�Ŷӳ���
        VEHICLE_TYPE          = 0x80,    //��������
        TRAFFIC_STATE         = 0x100    //��ͨ״̬
}ITS_TPS_TYPE; 

typedef struct tagNET_DVR_REGION_LIST 
{
    DWORD    dwSize;    // �ṹ���С
    BYTE    byNum;      // �������
    BYTE    byRes1[3];    // �����ֽ�
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM]; // ����
    BYTE    byRes2[20];    // �����ֽ�
}NET_DVR_REGION_LIST,*LPNET_DVR_REGION_LIST;


// ����ṹ��
typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // ������ʼ��
    NET_VCA_POINT struEndPoint;     // ��������� 
}NET_DVR_DIRECTION, *LPNET_DVR_DIRECTION;

// ��������
typedef struct tagNET_DVR_ONE_LANE
{
    BYTE    byEnable;                   // �����Ƿ�����
    BYTE    byRes1[11];                    // �����ֽ�
    BYTE    byLaneName[NAME_LEN];       // ������������
    NET_DVR_DIRECTION struFlowDirection;// �����ڳ�������
    NET_VCA_POLYGON struPolygon;        // ��������
}NET_DVR_ONE_LANE, *LPNET_DVR_ONE_LANE;

// ��������
typedef struct tagNET_DVR_LANE_CFG
{
    DWORD    dwSize;    // �ṹ���С
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];    // �������� �����±���Ϊ����ID��
    BYTE    byRes1[40];     // �����ֽ�
}NET_DVR_LANE_CFG, *LPNET_DVR_LANE_CFG;

// ��ͨ�¼�����
typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;       // Υͣ���������  10-120s
    WORD    wPedestrianDuration;    // ���˳���ʱ��    1-120s
    WORD    wDebrisDuration;        // ���������ʱ��  10-120s
    WORD    wCongestionLength;      // ӵ�³�����ֵ    5-200���ף�
    WORD    wCongestionDuration;    // ӵ�³�������    10-120s
    WORD    wInverseDuration;       // ���г���ʱ��    1-10s
    WORD    wInverseDistance;       // ���о�����ֵ ��λm ��Χ[2-100] Ĭ�� 10��
    WORD    wInverseAngleTolerance; // ����Ƕ�ƫ�� 90-180��,��������������ļн�
    WORD    wIllegalParkingTime;    // Υͣʱ��[4,60]����λ������ ,TFS(��ͨΥ��ȡ֤) ����ģʽ��
    WORD    wIllegalParkingPicNum;  // ΥͣͼƬ����[1,6], TFS(��ͨΥ��ȡ֤) ����ģʽ��
    BYTE    byMergePic;             // ͼƬƴ��,TFS ����ģʽ�� 0- ��ƴ�� 1- ƴ��
    BYTE    byRes1[23];             // �����ֽ�
}NET_DVR_AID_PARAM, *LPNET_DVR_AID_PARAM;

// ������ͨ�¼�����ṹ��
typedef struct tagNET_DVR_ONE_AID_RULE
{   
    BYTE    byEnable;                   // �Ƿ������¼�����
    BYTE    byRes1[3];                  // �����ֽ�
    BYTE    byRuleName[NAME_LEN];       // �������� 
    DWORD   dwEventType;                // ��ͨ�¼�������� TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; // �ߴ������
    NET_VCA_POLYGON     struPolygon;    // ��������
    NET_DVR_AID_PARAM   struAIDParam;   //  �¼�����
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //����ʽ 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];        //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes2[20];
}NET_DVR_ONE_AID_RULE, *LPNET_DVR_ONE_AID_RULE;

// ��ͨ�¼�����
typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;                    // �ṹ���С 
    BYTE    byPicProType;              //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];                 // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam; //ͼƬ���ṹ
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];
    BYTE    byRes2[32];
}NET_DVR_AID_RULECFG, *LPNET_DVR_AID_RULECFG;

// ������ͨ�¼�����ṹ��(��չ)
typedef struct tagNET_DVR_ONE_AID_RULE_V41
{   
    BYTE                        byEnable;                 // �Ƿ������¼�����
    BYTE                        byLaneNo;                 // ����������
    BYTE                        byRes1[2];                // �����ֽ�
    BYTE                        byRuleName[NAME_LEN];     // �������� 
    DWORD                       dwEventType;              // ��ͨ�¼�������� TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // �ߴ������
    NET_VCA_POLYGON             struPolygon;              // ��������
    NET_DVR_AID_PARAM           struAIDParam;             // �¼�����
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// ����ʱ���
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;              //����ʽ 
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //����������¼��ͨ����1��ʾ������ͨ����0��ʾ������ 
    BYTE                        byRes2[60];               //����
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

// ��ͨ�¼�����(��չ)
typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // �ṹ���С 
    BYTE    byPicProType;               // ����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];                  // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam;     // ͼƬ���ṹ
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //��������
    BYTE    byRes2[128];                //����
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

// ��ͨͳ�Ʋ����ṹ��
typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;                   //�Ƿ�ʹ�ܳ�����ͨ�������
    BYTE    byLaneID;                    //����ID
    BYTE    byRes1[2];
    DWORD   dwCalcType;                 //ͳ�Ʋ�������ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; //�ߴ������ 
    NET_VCA_POLYGON struVitrualLoop;    //������Ȧ
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //����ʽ,һ��Ϊ�����Ƿ��ϴ����ģ��������ܲ���Ҫ
    BYTE    byRes2[20];                         //�����ֽ�
}NET_DVR_ONE_TPS_RULE, *LPNET_DVR_ONE_TPS_RULE;

// ��ͨ����ͳ�ƹ������ýṹ��
typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;              // �ṹ��С
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE]; // �±��Ӧ��ͨ����ID
    BYTE    byRes2[40];         // �����ֽ�
}NET_DVR_TPS_RULECFG, *LPNET_DVR_TPS_RULECFG;

// ��ͨͳ�Ʋ����ṹ��(��չ)
typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //�Ƿ�ʹ�ܳ�����ͨ�������
    BYTE    byLaneID;                      //����ID
    BYTE    byRes1[2];                    //����
    DWORD   dwCalcType;                   // ͳ�Ʋ�������ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������ 
    NET_VCA_POLYGON      struVitrualLoop; //������Ȧ
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;       //����ʽ 
    BYTE    byRes2[60];                   // �����ֽ�
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;


// ��ͨ����ͳ�ƹ������ýṹ��(��չ)
typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         // �ṹ��С
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; // �±��Ӧ��ͨ����ID
    BYTE    byRes[128];     // ����
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;

//��ͨ�¼�������չ
typedef enum tagTRAFFIC_AID_TYPE_EX
{
    ENUM_AID_TYPE_CONGESTION = 1,    //ӵ��
    ENUM_AID_TYPE_PARKING = 2,    //ͣ��  
    ENUM_AID_TYPE_INVERSE = 3,    //����
    ENUM_AID_TYPE_PEDESTRIAN = 4,    //����                      
    ENUM_AID_TYPE_DEBRIS = 5,    //������ ��������Ƭ 
    ENUM_AID_TYPE_SMOKE = 6,    //����  
    ENUM_AID_TYPE_OVERLINE = 7,     //ѹ��
    ENUM_AID_TYPE_VEHICLE_CONTROL_LIST = 8,  //����������
    ENUM_AID_TYPE_SPEED = 9,  //����
    ENUM_AID_TYPE_LANECHANGE = 10,      //���
    ENUM_AID_TYPE_TURNAROUND = 11,     //��ͷ
    ENUM_AID_TYPE_VEHICLE_OCCUPANCY_NONVEHICLE = 12, //������ռ�÷ǻ�����λ
    ENUM_AID_TYPE_GASSER = 13,   //����
    ENUM_AID_TYPE_ROADBLOCK = 14,   //·��
    ENUM_AID_TYPE_CONSTRUCTION = 15,    //ʩ��
    ENUM_AID_TYPE_TRAFFIC_ACCIDENT = 16,    //��ͨ�¹ʼ�⣨��ͨ�¹�Ŀǰ���������¹ʣ�׷β���в���㷨�жϳ��복֮��켣�н��棬�������������򱨾���
    ENUM_AID_TYPE_PARALLEL_PARKING = 17,   //�෽λͣ�����
    ENUM_AID_TYPE_FOG_DETECTION = 18,       //Ũ����
    ENUM_AID_TYPE_OCCUPY_EMERGENCY_LANE = 19, //ռ�ý�������
    ENUM_AID_TYPE_CONFLAGRATION = 20,     //����
    ENUM_AID_TYPE_TFS_MANUAL_TRIGGER = 21,  //�ֶ�Υ��ȡ֤�¼� 
    ENUM_AID_TYPE_LOADING_DOCK_TRIGGER_UPLOAD = 22, //��̨�����ϴ�
    ENUM_AID_TYPE_OCCUPY_OVERTAKING_LANE = 23, //ռ�ó�����
    ENUM_AID_TYPE_PROHIBITION_MARK_VIOLATION = 24, //Υ�������־
    ENUM_AID_TYPE_CHECK_POINT = 25, //����
    ENUM_AID_TYPE_SUDDEN_SPEED_DROP = 26, //�ٶ��轵
    ENUM_AID_TYPE_SLOW_MOVING = 27, //��������
    ENUM_AID_TYPE_NOT_KEEP_DISTANCE = 28, //δ���ֳ���
    ENUM_AID_TYPE_NOT_SLOW_ZEBRA_CROSSING = 29, //������δ����
    ENUM_AID_TYPE_OVER_TAKE_RIGHT_SIDE = 30, //�Ҳ೬��
    ENUM_AID_TYPE_LOW_SPEED = 31, //������������ʻ
    ENUM_AID_TYPE_DRAG_RACING = 32, //쭳�
    ENUM_AID_TYPE_CHANGE_LANE_CONTINUOUSLY = 33, //�������
    ENUM_AID_TYPE_S_SHARP_DRIVING = 34, //������ʻ
    ENUM_AID_TYPE_LARGE_VEHICLE_OCCUPY_LINE = 35, //��ռ��
}TRAFFIC_AID_TYPE_EX;

// ��ͨ�¼���Ϣ
typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;   // ������ţ�Ϊ�������ýṹ�±꣬0-16
    BYTE            byVisibilityLevel; // �ܼ��ȵȼ���0-������1-����~����2-����~����3-����~Ũ��4-Ũ������
    BYTE            byRes1[2];
    BYTE            byRuleName[NAME_LEN]; //  ��������
    DWORD           dwAIDType;  // �����¼�����
    NET_DVR_DIRECTION   struDirect; // ����ָ������  
    BYTE    bySpeedLimit; //����ֵ����λkm/h[0,255]
    BYTE    byCurrentSpeed; //��ǰ�ٶ�ֵ����λkm/h[0,255]
    BYTE    byVehicleEnterState;//��������״̬ 0-��Ч 1-ʻ�� 2-ʻ��
    BYTE            byState; //0-�仯�ϴ���1-��Ѳ�ϴ���2-��ǰ�豸��ʱץ�ĵ������ϴ���ʵ��������ƽ̨�γ�ͼƬ���У����ڷ����㷨û�м�⵽��ͣ������������ֵ2�ڡ�dwAIDType;//�����¼����͡�Ϊ ��ͣ���¼�����ʱ����Ч��
    BYTE            byParkingID[16]; //ͣ��λ���
    DWORD           dwAIDTypeEx;  // �����¼�������չ,�ο�TRAFFIC_AID_TYPE_EX
    BYTE            byRes2[16];  // �����ֽ� 
}NET_DVR_AID_INFO, *LPNET_DVR_AID_INFO;

// ��ͨ�¼����� 
typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;         // �ṹ����
    DWORD               dwRelativeTime;    // ���ʱ��
    DWORD               dwAbsTime;        // ����ʱ��
    NET_VCA_DEV_INFO      struDevInfo;    // ǰ���豸��Ϣ
    NET_DVR_AID_INFO    struAIDInfo;    // ��ͨ�¼���Ϣ
    DWORD               dwPicDataLen;   // ����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ����
    BYTE                *pImage;        // ָ��ͼƬ��ָ�� 
    BYTE                byRes[40];      // �����ֽ�  
}NET_DVR_AID_ALARM, *LPNET_DVR_AID_ALARM;

// �������нṹ�� 
typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;       //����ͷ
    NET_VCA_POINT   struTail;       //����β
    DWORD           dwLength;      //ʵ�ʶ��г��� ��λΪ�� [0-500]
}NET_DVR_LANE_QUEUE, *LPNET_DVR_LANE_QUEUE; 

typedef enum tagTRAFFIC_DATA_VARY_TYPE
{
    NO_VARY,         //�ޱ仯 
        VEHICLE_ENTER,   //��������������Ȧ
        VEHICLE_LEAVE,   //�����뿪������Ȧ 
        UEUE_VARY        //���б仯             
}TRAFFIC_DATA_VARY_TYPE; 

typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];  //������������ 
    BYTE    byRuleID;              //������ţ�Ϊ�������ýṹ�±꣬0-7 
    BYTE    byVaryType;            //������ͨ�����仯���� ���� TRAFFIC_DATA_VARY_TYPE
    BYTE    byLaneType;               //�������л�����
    BYTE    byRes1;
    DWORD    dwLaneVolume;         //�������� ��ͳ���ж��ٳ���ͨ��
    DWORD   dwLaneVelocity;        //�����ٶȣ��������
    DWORD   dwTimeHeadway;         //��ͷʱ�࣬�������
    DWORD   dwSpaceHeadway;        //��ͷ��࣬����������
    float   fSpaceOccupyRation;    //����ռ���ʣ��ٷֱȼ��㣨�ռ���)
    NET_DVR_LANE_QUEUE  struLaneQueue;    //�������г���
    NET_VCA_POINT       struRuleLocation; //��Ȧ��������ĵ�λ��
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM, *LPNET_DVR_LANE_PARAM;


typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;   // ��ͨ�����ĳ�����Ŀ
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO, *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD             dwSize;          //�ṹ���С
    DWORD             dwRelativeTime;  //���ʱ��
    DWORD             dwAbsTime;       //����ʱ��
    NET_VCA_DEV_INFO  struDevInfo;     //ǰ���豸��Ϣ
    NET_DVR_TPS_INFO  struTPSInfo;     //��ͨ�¼���Ϣ
    BYTE              byRes1[32];      //�����ֽ�
}NET_DVR_TPS_ALARM, *LPNET_DVR_TPS_ALARM;

typedef enum tagTRAFFIC_DATA_VARY_TYPE_EX_ENUM
{    
    ENUM_TRAFFIC_VARY_NO             = 0x00,   //�ޱ仯
        ENUM_TRAFFIC_VARY_VEHICLE_ENTER  = 0x01,   //��������������Ȧ
        ENUM_TRAFFIC_VARY_VEHICLE_LEAVE  = 0x02,   //�����뿪������Ȧ
        ENUM_TRAFFIC_VARY_QUEUE          = 0x04,   //���б仯
        ENUM_TRAFFIC_VARY_STATISTIC      = 0x08,   //ͳ�����ݱ仯��ÿ���ӱ仯һ�ΰ���ƽ���ٶȣ������ռ�/ʱ��ռ���ʣ���ͨ״̬��        
}TRAFFIC_DATA_VARY_TYPE_EX_ENUM;  

typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; // ������������
    BYTE               byRuleID;             // ������ţ�Ϊ�������ýṹ�±꣬0-7 
    BYTE               byLaneType;             // �������л�����
    BYTE               byTrafficState;       // �����Ľ�ͨ״̬��0-��Ч��1-��ͨ��2-ӵ����3-����
    BYTE               byLaneNo;            //������
    DWORD              dwVaryType;           // ������ͨ�����仯���Ͳ���  TRAFFIC_DATA_VARY_TYPE_EX_ENUM����λ����
    DWORD              dwTpsType;            // ���ݱ仯���ͱ�־����ʾ��ǰ�ϴ���ͳ�Ʋ����У���Щ������Ч������ITS_TPS_TYPE,��λ����
    DWORD              dwLaneVolume;         // ����������ͳ���ж��ٳ���ͨ��
    DWORD              dwLaneVelocity;       // �����ٶȣ��������
    DWORD              dwTimeHeadway ;       // ��ͷʱ�࣬�������
    DWORD              dwSpaceHeadway;       // ��ͷ��࣬����������
    float              fSpaceOccupyRation;   // ����ռ���ʣ��ٷֱȼ��㣨�ռ���)
    float              fTimeOccupyRation;    // ʱ��ռ���ʣ��ٷֱȼ���
    DWORD              dwLightVehicle;       // С�ͳ�����
    DWORD              dwMidVehicle;         // ���ͳ�����
    DWORD              dwHeavyVehicle;       // ���ͳ�����
    NET_DVR_LANE_QUEUE struLaneQueue;        // �������г���
    NET_VCA_POINT      struRuleLocation;     // ����λ��������Ȧ������
    DWORD               dwOversizeVehicle;    // ���ͳ�����
    BYTE               byRes2[60];           // ����
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;


typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          // ��ͨ�����ĳ�����Ŀ
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE];
    DWORD                   dwSceneID;//����ID
    BYTE                    byRes[28];         //����
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

// ������������ 
typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              // �ṹ���С
    BYTE           byEnable;            // �Ƿ�����
    BYTE           byEventType;            //�����¼����ͣ� 0-�쳣����; 1-��������;2-�쳣����&��������;4-��������&�쳣����;5-��������&��������; 6-��������&�쳣����&��������; 7-�������� 
    BYTE           byUpLastAlarm;       //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE           byUpFacePic; //�Ƿ��ϴ�������ͼ��0-��1-��    
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon;    // ��������������
    BYTE           byPicProType;    //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE           bySensitivity;   // ����������
    WORD            wDuration;      // ������������ʱ����ֵ
    NET_DVR_JPEGPARA    struPictureParam;         //ͼƬ���ṹ
    NET_VCA_SIZE_FILTER struSizeFilter;         //�ߴ������
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //����ʽ 
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];            //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE           byPicRecordEnable;  /*2012-3-1�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE           byRes1[3];         //�����ֽ�
    /*
    �����¼����ͣ���Ŀǰ�¼����Ͱ�λ��ʾ��������ѡ������1�ֻ��߼��ֽ�����ϣ�
    0x00: ��Ч
    0x01: �쳣����
    0x02: ��������
    0x04: ��������
    0x08: ��ī������
    0x10: ��绰����
    */
    DWORD          dwEventTypeEx; //dwEventTypeEx�ֶ���Ϊ0ʱ��byEventType�ֶ���Ч����dwEventTypeEx��byEventType�ֶζ���ֵʱ����dwEventTypeEx�ֶ�Ϊ׼���ϲ�����dwEventTypeEx�ֶκ󣬻Ὣֵͬ����byEventType�С�
    BYTE            byRes2[32];         //�����ֽ�
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{    
    BYTE byEnable; //�Ƿ������л�
    BYTE byBackChannel; //����ͨ���ţ����ͨ����
    BYTE byPosition; //����λ�ã�0-����,1-����,2-����,3-����
    BYTE byPIPDiv; //����ϵ��(��������:��廭��)��0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              // �ṹ���С
    BYTE  byEnable;            // �Ƿ�����
    BYTE  byEventType;            //�����¼����ͣ� 0-�쳣����; 1-��������;2-�쳣����&��������;4-��������&�쳣����;5-��������&��������; 6-��������&�쳣����&��������; 7-�������� 
    BYTE  byUpLastAlarm;       //2011-04-06 �Ƿ����ϴ����һ�εı���
    BYTE  byUpFacePic; //�Ƿ��ϴ�������ͼ��0-��1-��    
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    // ��������������
    BYTE  byPicProType;    //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE  bySensitivity;   // ����������
    WORD  wDuration;      // ������������ʱ����ֵ
    NET_DVR_JPEGPARA    struPictureParam;         //ͼƬ���ṹ
    NET_VCA_SIZE_FILTER struSizeFilter;         //�ߴ������
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//����ʱ��
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //����ʽ 
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];            //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE  byPicRecordEnable;  /*2012-10-22�Ƿ�����ͼƬ�洢, 0-������, 1-����*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22���ܱ�����ʱ��0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7���л�����
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //����ץͼͨ��������ͨ������ʱ��ͬʱ���ϴ�����ͨ����ץ��ͼƬ��0��ʾ������������ֵΪ����ͨ����
    BYTE  byRes2[2];         //�����ֽ�
    /*
    �����¼����ͣ���Ŀǰ�¼����Ͱ�λ��ʾ��������ѡ������1�ֻ��߼��ֽ�����ϣ�
    0x00: ��Ч
    0x01: �쳣����
    0x02: ��������
    0x04: ��������
    0x08: ��ī������
    0x10: ��绰����
    */
    DWORD dwEventTypeEx; //dwEventTypeEx�ֶ���Ϊ0ʱ��byEventType�ֶ���Ч����dwEventTypeEx��byEventType�ֶζ���ֵʱ����dwEventTypeEx�ֶ�Ϊ׼���ϲ�����dwEventTypeEx�ֶκ󣬻Ὣֵͬ����byEventType�С�
    BYTE  byRes[16];         //�����ֽ�
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD   dwSize;         //�ṹ��С
    DWORD     dwRelativeTime; //���ʱ��
    DWORD    dwAbsTime;        //����ʱ��
    BYTE    byRuleName[NAME_LEN];   //��������
    NET_VCA_TARGET_INFO  struTargetInfo;//����Ŀ����Ϣ
    NET_VCA_DEV_INFO       struDevInfo;//ǰ���豸��Ϣ
    DWORD   dwPicDataLen;    //����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ����*/
    BYTE    byAlarmPicType;    // 0-�쳣��������ͼƬ 1- ����ͼƬ,2-��������, 3-��ī������, 4-��绰���� 
    BYTE    byPanelChan;    /*2012-3-1����ͨ�����������ͨ��*/
    BYTE    byRelAlarmPicNum; //����ͨ������ͼƬ����
    BYTE    byRes1;
    DWORD   dwFacePicDataLen;//����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ����*/
    DWORD   dwAlarmID;    //����ID�����Ա�ʶͨ���������������ϱ�����0��ʾ��Ч
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE    byRes2[42];   // �����ֽ�
    BYTE    *pFaceImage; //ָ������ͼָ��
    BYTE    *pImage;                           //ָ��ͼƬ��ָ��
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD   uLen[3];            // �������СΪ12�ֽ�
    DWORD  dwHumanIn;      //�����˽ӽ� 0 - ���� 1- ����  
    float       fCrowdDensity;  // ��Ա�ۼ�ֵ
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

// Ŀǰֻ�����������¼�����Ա�ۼ��¼�ʵʱ�����ϴ�
typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;                // Rule ID
    BYTE   byRes[3];                // �����ֽ�
    BYTE   byRuleName[NAME_LEN];    // ��������
    DWORD       dwEventType;            // ����VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;  // 
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE            byNum;        // �¼�ʵʱ��Ϣ����
    BYTE            byRes1[3];            // �����ֽ�
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];    // �¼�ʵʱ��Ϣ
}NET_DVR_EVENT_INFO_LIST,*LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD             dwSize;                // �ṹ���С
    DWORD         dwRelativeTime;     // ���ʱ��
    DWORD        dwAbsTime;            // ����ʱ��
    NET_VCA_DEV_INFO      struDevInfo;        // ǰ���豸��Ϣ
    NET_DVR_EVENT_INFO_LIST struEventInfoList;    //�¼���Ϣ�б�
    BYTE            byRes2[40];            // �����ֽ�
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

//��������ʱ���
typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 -��Ч,1�C��Ч
    BYTE     byRes1[3];                    //����
    DWORD    dwSceneID;                    //����ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //������Чʱ��
    BYTE     byRes2[16];                   //����
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME ;

//������Чʱ�������
typedef struct tagNET_DVR_SCENE_TIME_CFG
{   
    DWORD  dwSize;                                               //�ṹ��С
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //����ʱ�������
    BYTE   byRes[64];                                            //����
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;


//��������������Ϣ
typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{    
    BYTE   byEnable;                 //�Ƿ����øó���,0-������ 1- ����
    BYTE   byDirection;              //��ⷽ�� 1-���У�2-���У�3-˫��4-�ɶ�������5-�����򱱣�6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE   byRes1[2];                //����
    DWORD  dwSceneID;                //����ID(ֻ��), 0 - ��ʾ�ó�����Ч
    BYTE   bySceneName[NAME_LEN];    //��������
    NET_DVR_PTZPOS struPtzPos;       //ptz ����
    DWORD  dwTrackTime;              //�������ʱ��[5,300] �룬TFS(��ͨȡ֤)ģʽ����Ч
    BYTE   byRes2[24];               //����
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;

//�������ýṹ��
typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //�ṹ��С
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //����������Ϣ
    BYTE   byRes[40];                                      //����
}NET_DVR_SCENE_CFG,*LPNET_DVR_SCENE_CFG;

//�ೡ����������
typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //�ṹ��С
    LONG    lChannel;     //ͨ����
    DWORD   dwSceneID;    //����ID, 0-��ʾ�ó�����Ч
    BYTE    byRes[48];    //����
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

//ȡ֤��ʽ
typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //�ṹ��С
    BYTE   byMode;      // 0-�ֶ�ȡ֤ ,1-�Զ�ȡ֤��2-���Զ����ٺ;�̬ȡ֤
    BYTE   byRes[23];   //����
}NET_DVR_FORENSICS_MODE,*LPNET_DVR_FORENSICS_MODE;

//����������Ϣ
typedef struct tagNET_DVR_SCENE_INFO_
{  
    DWORD           dwSceneID;              //����ID, 0 - ��ʾ�ó�����Ч
    BYTE            bySceneName[NAME_LEN];  //��������
    BYTE            byDirection;            //��ⷽ�� 1-���У�2-���У�3-˫��4-�ɶ�������5-�����򱱣�6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE            byRes1[3];              //����
    NET_DVR_PTZPOS  struPtzPos;             //Ptz ����
    BYTE            byRes2[64] ;            //����
}NET_DVR_SCENE_INFO,*LPNET_DVR_SCENE_INFO;

//��ͨ�¼�����(��չ)
typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //�ṹ����
    DWORD              dwRelativeTime;        //���ʱ��
    DWORD              dwAbsTime;            //����ʱ��
    NET_VCA_DEV_INFO   struDevInfo;            //ǰ���豸��Ϣ
    NET_DVR_AID_INFO   struAIDInfo;         //��ͨ�¼���Ϣ
    NET_DVR_SCENE_INFO struSceneInfo;       //������Ϣ
    DWORD              dwPicDataLen;        //ͼƬ����
    BYTE               *pImage;             //ָ��ͼƬ��ָ��
    // 0-����ֱ���ϴ�; 1-�ƴ洢������URL(3.7Ver)ԭ�ȵ�ͼƬ���ݱ��URL���ݣ�ͼƬ���ȱ��URL����
    BYTE               byDataType;
    BYTE               byLaneNo;  //���������� 
    WORD               wMilliSecond;        //ʱ�����
    //�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE               byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE               byDeviceID[DEVICE_ID_LEN/*48*/];//�豸���
    DWORD              dwXmlLen;//XML������Ϣ����
    char*              pXmlBuf;// XML������Ϣָ��,��XML��Ӧ��EventNotificationAlert XML Block
    BYTE               byTargetType;// ����Ŀ�����ͣ�0~δ֪��1~���ˡ�2~���ֳ���3~���ֳ�(���˼���з���)
    BYTE               byRes[7]; // �����ֽ�   
    DWORD              dwPlateSmallPicDataLen;      //����СͼͼƬ����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    char*                   pPlateSmallImage;  // //ָ����Сͼ��ָ��
#else
    char*                   pPlateSmallImage;   //ָ����Сͼ��ָ��
    BYTE                   byRes1[4];
#endif  
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

//��ͨͳ����Ϣ����(��չ)
typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwRelativeTime;  // ���ʱ��
    DWORD                 dwAbsTime;       // ����ʱ��
    NET_VCA_DEV_INFO      struDevInfo;     // ǰ���豸��Ϣ
    NET_DVR_TPS_INFO_V41  struTPSInfo;     // ��ͨ����ͳ����Ϣ 
    //�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE           byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE           byDeviceID[DEVICE_ID_LEN/*48*/];//�豸��� 
    DWORD                dwStartTime;  // ��ʼͳ��ʱ��
    DWORD                dwStopTime;    // ����ͳ��ʱ��
    BYTE                   byRes[24];      // ����
} NET_DVR_TPS_ALARM_V41,*LPNET_DVR_TPS_ALARM_V41;

/*******************************���ܽ�ͨ�¼� end*****************************************/

#define XXX_MAJOR_VERSION      2

/* �Ӱ汾�ţ������Ż����ֲ��ṹ������ģ���ڼ�������������汾����ʱ���������31 */

#define XXX_SUB_VERSION        3

/* �����汾�ţ�����bug����������31 */

#define XXX_REVISION_VERSION   4

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;        // ���汾��
    WORD    wMinorVersion;        // �ΰ汾��
    WORD    wRevisionNumber;    // ������
    WORD    wBuildNumber;        // �����
    WORD    wVersionYear;        //    �汾����-��
    BYTE    byVersionMonth;        //    �汾����-��
    BYTE    byVersionDay;        //    �汾����-��
    BYTE    byType;/*�㷨���������ƣ�0-������1-��������,2-��Ϊ����,3-��������,4-����ץ��,5����ʶ�� 6-�����Ա�,7-ѧ��վ�����, 
                   8-��������ͳ��,9-�������ֿ�,10-��ȫñ���,11-���ݼ���㷨��,12-������ͳ��,13-(����Ŀ��ṹ���㷨)HMS, 
                   14-��ʦ��Ϊ���, 15-��Ա�ܶȣ�16-�����쳣��17-��ڼ�⣬18-��Ա������19-������ģץ�ģ�20-HMS��ģ,21-̬�Ʒ���,
                   22-�ǹ��㷨,23-�ŶӼ��*/
    BYTE    byRes[7];            // �����ֽ�
}NET_DVR_VCA_VERSION, *LPNET_DVR_VCA_VERSION;


/******************************���� end***********************************/

/******************************����ʶ�� begin******************************************/
typedef struct tagNET_DVR_PLATE_PARAM
{    
    BYTE    byPlateRecoMode;    //����ʶ���ģʽ,Ĭ��Ϊ1(��Ƶ����ģʽ)
    BYTE    byBelive;            //�������Ŷ���ֵ, ֻ������Ƶʶ��ʽ, ���ݱ������ӳ̶�����, �󴥷��ʸ߾����, ©���ʸ߾����, ������80-90��Χ��
    BYTE    byRes[22];          //�����ֽ�
}NET_DVR_PALTE_PARAM, *LPNET_DVR_PALTE_PARAM;

typedef struct tagNET_DVR_PLATECFG
{    
    DWORD        dwSize;
    DWORD    dwEnable;                           /* �Ƿ�������Ƶ����ʶ�� 0���� 1���� */
    BYTE    byPicProType;    //����ʱͼƬ����ʽ 0-������ ��0-�ϴ�
    BYTE    byRes1[3];  // �����ֽ�
    NET_DVR_JPEGPARA struPictureParam;         //ͼƬ���ṹ
    NET_DVR_PALTE_PARAM struPlateParam;   // ����ʶ���������
    NET_DVR_HANDLEEXCEPTION struHandleType;       /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//����ʱ��
    BYTE    byRelRecordChan[MAX_CHANNUM];        //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE   byRes[20];   // �����ֽ�
}NET_DVR_PLATECFG, *LPNET_DVR_PLATECFG;

// ����ʶ�����ӽṹ
typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;                    //��������
    BYTE  byColor;                        //������ɫ
    BYTE  byBright;                        //��������
    BYTE  byLicenseLen;                    //�����ַ�����
    BYTE  byEntireBelieve;                //�������Ƶ����Ŷȣ�-100
    BYTE  byRegion;                       // ��������ֵ 0-������1-ŷ��(EU)��2-��������(ER)��3-ŷ��&����˹(EU&CIS) ,4-�ж�(ME),0xff-����
    BYTE  byCountry;                      // ��������ֵ������ö��COUNTRY_INDEX����֧��"COUNTRY_ALL = 0xff, //ALL  ȫ��"��
    BYTE  byArea;                         //����ʡ�ݣ����������ڲ�����ö�٣����������� EMI_AREA
    BYTE  byPlateSize;                    //���Ƴߴ磬0~δ֪��1~long, 2~short(�ж�����ʹ��)
    /*������Ϣ��ʶ�����Ƿ���NET_DVR_VEHICLE_ADDINFO�ṹ�壩,0-�޸�����Ϣ, 1-�и�����Ϣ��*/
    BYTE  byAddInfoFlag;
    //���ֶ�����byCountry���������ϣ���չ������������֮��ʹ�ø��ֶδ���byCountry������ʹ��wCRIndex�ֶ�
    //Ϊ�˼������û���������ֶ�ֵ����256�����������򣩣���byCountry��ֵΪ0xfd�������ֶ���Ч����
    WORD  wCRIndex ;//����/��������������ֵ�ο�_CR_ INDEX_
    BYTE  byRes[4];	             //����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    BYTE*  pAddInfoBuffer;
#else
    /*������Ϣָ��,ָ��NET_DVR_VEHICLE_ADDINFO�ṹ��*/
    BYTE*   pAddInfoBuffer;
    BYTE  byRes2[4];
#endif 
    char  sPlateCategory[MAX_CATEGORY_LEN/*8*/];//���Ƹ�����Ϣ, ���ж������г��ƺ����Աߵ�С����Ϣ��(Ŀǰֻ���ж�����֧��)
    DWORD dwXmlLen;                        //XML������Ϣ����
    char* pXmlBuf;                      // XML������Ϣָ��,��������Ϊ COMM_ITS_PLATE_RESULʱ��Ч����XML��Ӧ��EventNotificationAlert XML Block
    NET_VCA_RECT    struPlateRect;        //����λ��
    char sLicense[MAX_LICENSE_LEN];        //���ƺ���,ע���ж����������С��Ҳ���복�ƺ��룬С�ֺͳ��ƺ��м��ÿո�ָ�
    BYTE byBelieve[MAX_LICENSE_LEN];    //����ʶ���ַ������Ŷȣ����⵽����"��A12345", ���Ŷ�Ϊ,20,30,40,50,60,70�����ʾ"��"����ȷ�Ŀ�����ֻ��%��"A"�ֵ���ȷ�Ŀ�������%
}NET_DVR_PLATE_INFO, *LPNET_DVR_PLATE_INFO;

typedef struct tagNET_DVR_PLATERECO_RESULE
{
    DWORD dwSize;
    DWORD    dwRelativeTime;                //���ʱ��
    DWORD    dwAbsTime;                        //����ʱ��
    NET_VCA_DEV_INFO struDevInfo;           // ǰ���豸��Ϣ
    NET_DVR_PLATE_INFO struPlateInfo;
    DWORD dwPicDataLen;                        //����ͼƬ�ĳ��� Ϊ0��ʾû��ͼƬ������0��ʾ�ýṹ�������ͼƬ����*/
    DWORD dwRes[4];                            //����������Ϊ0
    BYTE  *pImage;                           //ָ��ͼƬ��ָ��
}NET_DVR_PLATERECO_RESULE, *LPNET_DVR_PLATERECO_RESULE;

/******************************����ʶ�� end******************************************/

/*******************************��Ƶ�ۺ�ƽ̨***********************************/
typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //Main type 1-alarm; 2-abnormal; 3-operation; 0xff-all 
    DWORD    dwMinorType;    //Hypo-Type 0-all;
    BYTE    sPanelUser[MAX_NAMELEN]; //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN];//user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr;//remote host IP
    DWORD    dwParaType;//parameter type
    DWORD    dwChannel;//channel number
    DWORD    dwDiskNumber;//HD number
    DWORD    dwAlarmInPort;//alarm input port
    DWORD    dwAlarmOutPort;//alarm output port
    DWORD   dwInfoLen;
    BYTE    byDevSequence;//��λ��
    BYTE    byMacAddr[MACADDR_LEN];//MAC��ַ,6
    BYTE    sSerialNumber[SERIALNO_LEN];//���кţ�48
    char    sInfo[LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1 ];
}NET_DVR_LOG_MATRIX, *LPNET_DVR_LOG_MATRIX;

//2009-11-21 ��Ƶ�ۺ�ƽ̨
typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition;//����������0-����λ��������1-�����к�������2-��MAC��ַ��������
    //��λ�ţ�0-79����Ӧ��ϵͳ�Ĳ�λ�ţ�
    //0xff����ʾ�������е���־������78K������6467��
    //0xfe����ʾ����78K�ϵ���־��0xfd��������־��0xfc������־����
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN];//���кţ�48
    BYTE  byMacAddr[MACADDR_LEN];//MAC��ַ,6
} NET_DVR_VEDIOPLATLOG, *LPNET_DVR_VEDIOPLATLOG;

typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion;//�������汾�ţ���16λ��ʾ���汾����16λ��ʾ�ΰ汾 
    DWORD dwSupportMaxVideoFrameRate;//��λ(K)
                                     /*��λ:
                                     0:��ʱ¼��
                                     1:��ʱ|�¼�����¼�� 
                                     2:�ƶ����¼��
                                     3:���翪��������¼��
                                     4:�ƶ����|���翪��������¼��
                                     5:�ƶ����&���翪��������¼��
                                     6:�ܽ��������¼��
                                     7:������ⴥ��¼��
                                     8:����ʶ�𴥷�¼��
    9:�ֶ�¼��*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode;//��λ:��0λ:��ʾ����������1λ:��ʾ������
    BYTE  bySupportStringRow;//֧���ַ���������
    BYTE  bySupportHideNum;//֧����Ƶ�ڵ�����
    BYTE  byRes1;
    /*0-DCIF��1-CIF��2-QCIF��3-4CIF��4-2CIF��6-QVGA(320*240), 16-VGA��17-UXGA��18-SVGA��19-HD720p��20-XVGA��21-HD900p��22-SXGAp��27-HD1080i��28-2560*1920��29-1600*304��30-2048*1536��31-2448*2048��32-2448*1200��33-2448*800 ��34-XGA��1024x768����35-SXGA��1280x1024��*/
    BYTE  byMainStreamSupportResolution[8];//������֧�ֵķֱ��ʣ���λ
    BYTE  bySubStreamSupportResolution[8];//������֧�ֵķֱ��ʣ���λ
    BYTE  byEventStreamSupportResolution[8];//�¼���������֧�ֵķֱ��ʣ���λ
    BYTE  byNotSupportPreview;//�Ƿ�֧��Ԥ��,1-��֧�֣�0-֧��
    BYTE  byNotSupportStorage;//�Ƿ�֧�ִ洢,1-��֧�֣�0-֧��
    BYTE  byRes2[98];//����        
}NET_DVR_CODESYSTEMABILITY, *LPNET_DVR_CODESYSTEMABILITY;

/********************************end*******************************************/

/******************************ץ�Ļ�*******************************************/
//IO��������
typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus;//�����IO��״̬��0-�½��أ�1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE    byRes[3];//�����ֽ�
}NET_DVR_IO_INCFG, *LPNET_DVR_IO_INCFG;

//IO�������
typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus;//IOĬ��״̬��0-�͵�ƽ��1-�ߵ�ƽ 
    BYTE    byIoOutStatus;//IO��Чʱ״̬��0-�͵�ƽ��1-�ߵ�ƽ��2-����
    WORD    wAheadTime;//���IO��ǰʱ�䣬��λus
    DWORD   dwTimePluse;//������ʱ�䣬��λus
    DWORD   dwTimeDelay;//IO��Ч����ʱ�䣬��λus
    BYTE    byFreqMulti;        //��Ƶ����ֵ��Χ[1,15]
    BYTE    byDutyRate;        //ռ�ձȣ�[0,40%]
    BYTE    byRes[2];
}NET_DVR_IO_OUTCFG, *LPNET_DVR_IO_OUTCFG;

//���������
typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;//�������˸ģʽ��0-������1-����2-��������3-����
    BYTE   byRelatedIoIn;//����ƹ���������IO�ţ�������ʱ�˲�����Ч��
    BYTE   byRecognizedLane;  /*������IO�ţ���λ��ʾ��bit0��ʾIO1�Ƿ������0-��������1-����*/
    BYTE   byDetectBrightness;/*�Զ��������ʹ�������0-����⣻1-���*/
    BYTE   byBrightnessThreld;/*ʹ�������������ֵ����Χ[0,100],������ֵ��*/
    BYTE   byStartHour;        //��ʼʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE   byStartMinute;        //��ʼʱ��-��,ȡֵ��Χ0-59
    BYTE   byEndHour;             //����ʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE   byEndMinute;        //����ʱ��-��,ȡֵ��Χ0-59
    BYTE   byFlashLightEnable;    //���������ʱ��ʹ��:0-��;1-��
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

//���̵ƹ��ܣ�2��IO����һ�飩
typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE    byLightIoIn;//���̵Ƶ�IO ��
    BYTE    byTrigIoIn;//������IO��
    BYTE    byRelatedDriveWay;//����IO�����ĳ�����
    BYTE    byTrafficLight; //0-�ߵ�ƽ��ƣ��͵�ƽ�̵ƣ�1-�ߵ�ƽ�̵ƣ��͵�ƽ���
    BYTE     bySnapTimes1; //���ץ�Ĵ���1��0-��ץ�ģ���0-���Ĵ��������5�� 
    BYTE     bySnapTimes2; //�̵�ץ�Ĵ���2��0-��ץ�ģ���0-���Ĵ��������5�� 
    BYTE    byRes1[2];
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//������ļ��ʱ�䣬ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//�̵����ļ��ʱ�䣬ms
    BYTE    byRecord;//���������¼���־��0-��¼��1-¼��
    BYTE    bySessionTimeout;//���������¼��ʱʱ�䣨�룩
    BYTE    byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ��(��)
    BYTE    byVideoDelay;//�����¼��Ƭ����ʱʱ�䣨�룩
    BYTE    byRes2[32];//�����ֽ�
}NET_DVR_LIGHTSNAPCFG, *LPNET_DVR_LIGHTSNAPCFG;

//���ٹ���(2��IO����һ�飩
typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE    byTrigIo1;   //���ٵ�1��Ȧ
    BYTE    byTrigIo2;   //���ٵ�2��Ȧ
    BYTE    byRelatedDriveWay;//����IO�����ĳ�����
    BYTE    byTestSpeedTimeOut;//����ģʽ��ʱʱ�䣬��λs
    DWORD   dwDistance;//��Ȧ����,cm
    BYTE    byCapSpeed;//����ģʽ�����ٶȣ���λkm/h
    BYTE    bySpeedLimit;//����ֵ����λkm/h
    BYTE     bySnapTimes1; //��Ȧ1ץ�Ĵ�����0-��ץ�ģ���0-���Ĵ��������5�� 
    BYTE     bySnapTimes2; //��Ȧ2ץ�Ĵ�����0-��ץ�ģ���0-���Ĵ��������5�� 
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//��Ȧ1���ļ��ʱ�䣬ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//��Ȧ2���ļ��ʱ�䣬ms
    BYTE    byRes[32];//�����ֽ�
}NET_DVR_MEASURESPEEDCFG, *LPNET_DVR_MEASURESPEEDCFG;


//��������
typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND,*LPNET_DVR_CLOUDSTORAGE_COND;

//���ýṹ
typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// �ƴ洢����ڵ��
    BYTE    byRes[4];
}NET_DVR_POOLPARAM,*LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//0-��������1-����
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort;//���ݶ˿�
    BYTE    byRes1[2];
    char    szUser[CLOUD_NAME_LEN/*48*/]; //�û���
    char    szPassword[CLOUD_PASSWD_LEN/*48*/];     // ����
    NET_DVR_POOLPARAM  struPoolInfo[16];//����0��ʾ����¼��أ�����1��ʾΥ��¼��أ�����2��ʾ����������ݳأ�IPC/D��
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG,*LPNET_DVR_CLOUDSTORAGE_CFG;

typedef  struct  tagNET_DVR_PARKLAMP_COND
{ 
    DWORD  dwSize;
    DWORD  dwChannel;   //ͨ����
    BYTE   byParkingIndex;   //��Գ�λ�ţ�1��4��
    BYTE   byRes[15];     //����
}NET_DVR_PARKLAMP_COND, *LPNET_DVR_PARKLAMP_COND;

typedef  struct  tagNET_DVR_PARKLAMP_INFOCFG
{ 
    DWORD dwSize;
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    char  sParkingNo[MAX_LICENSE_LEN/*16*/];//��λ���(ʵ�ʵĳ�λ���)
    BYTE   byLampFlicker;//0~����˸ 1 ����˸ (��λָʾ����˸)
    BYTE   byLampColor;//0- �� 1-�� 2-��  3-��  4-�� 5-Ʒ�� 6-�� 7-��ɫ  (��λָʾ����ɫ)
    BYTE   byStatus; //��λ״̬ 0-�޳���1-�г�
    BYTE   byColorDepth; //������ɫ��ǳ��0-��ɫ��1-ǳɫ,0xff-δ֪
    BYTE   byColor;//������ɫ��0-����ɫ��1-��ɫ��2-��ɫ��3-��ɫ��4-��ɫ��5-��ɫ��6-������7-��ɫ��8-��ɫ��9-��ɫ��10-��ɫ��11-��ɫ��12-��ɫ��0xff-δ���г�����ɫʶ�� 
    //����Ʒ������ʶ�� �ο�ö������ VLR_VEHICLE_CLASS
    BYTE   byVehicleLogoRecog; 
    BYTE   byRes[250];//����
}NET_DVR_PARKLAMP_INFOCFG, *LPNET_DVR_PARKLAMP_INFOCFG;

//��Ƶ��������
typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel; /*0-100*/
    BYTE byContrastLevel; /*0-100*/
    BYTE bySharpnessLevel; /*0-100*/
    BYTE bySaturationLevel; /*0-100*/
    BYTE byHueLevel; /*0-100,��������*/
    BYTE byEnableFunc; //ʹ�ܣ���λ��ʾ��bit0-SMART IR(������)��bit1-���ն�,bit2-ǿ������ʹ�ܣ�0-��1-��
    BYTE byLightInhibitLevel; //ǿ�����Ƶȼ���[1-3]��ʾ�ȼ�
    BYTE byGrayLevel; //�Ҷ�ֵ��0-[0-255]��1-[16-235]
}NET_DVR_VIDEOEFFECT, *LPNET_DVR_VIDEOEFFECT;

//��������
typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel; /*���棺0-100*/
    BYTE byGainUserSet; /*�û��Զ������棻0-100������ץ�Ļ�����CCDģʽ�µ�ץ������*/
    BYTE byRes[2];
    DWORD dwMaxGainValue;/*�������ֵ����λdB*/
}NET_DVR_GAIN, *LPNET_DVR_GAIN;

//��ƽ������
typedef struct tagNET_DVR_WHITEBALANCE
{
BYTE byWhiteBalanceMode; /*0-�ֶ���ƽ�⣨MWB��,1-�Զ���ƽ��1��AWB1��,2-�Զ���ƽ��2 (AWB2),3-�Զ����Ƹ���Ϊ������ƽ��(Locked WB)��
                         4-����(Indoor)��5-����(Outdoor)6-�չ��(Fluorescent Lamp)��7-�Ƶ�(Sodium Lamp)��
                         8-�Զ�����(Auto-Track)9-һ�ΰ�ƽ��(One Push)��10-�����Զ�(Auto-Outdoor)��
                         11-�Ƶ��Զ� (Auto-Sodiumlight)��12-ˮ����(Mercury Lamp)��13-�Զ���ƽ��(Auto)��
14-�׳�� (IncandescentLamp)��15-ů���(Warm Light Lamp)��16-��Ȼ��(Natural Light) */
BYTE byWhiteBalanceModeRGain; /*�ֶ���ƽ��ʱ��Ч���ֶ���ƽ�� R����*/
BYTE byWhiteBalanceModeBGain; /*�ֶ���ƽ��ʱ��Ч���ֶ���ƽ�� B����*/
BYTE byRes[5];
}NET_DVR_WHITEBALANCE, *LPNET_DVR_WHITEBALANCE;

//�ع����
typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode; /*0 �ֶ��ع� 1�Զ��ع�*/
    BYTE  byAutoApertureLevel; /* �Զ���Ȧ������, 0-10 */ 
    BYTE  byRes[2];
    DWORD dwVideoExposureSet; /* �Զ�����Ƶ�ع�ʱ�䣨��λus��*//*ע:�Զ��ع�ʱ��ֵΪ�ع�����ֵ ����20-1s(1000000us)*/        
    DWORD dwExposureUserSet; /* �Զ����ع�ʱ��,��ץ�Ļ���Ӧ��ʱ��CCDģʽʱ��ץ�Ŀ����ٶ�*/   
    DWORD dwRes;    
} NET_DVR_EXPOSURE, *LPNET_DVR_EXPOSURE;

//��̬����
typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled; /*��̬��0 dsibale  1 enable 2 auto*/
    BYTE byWDRLevel1; /*0-F*/
    BYTE byWDRLevel2; /*0-F*/
    BYTE byWDRContrastLevel; /*0-100*/
    BYTE byRes[16];
} NET_DVR_WDR, *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;   //�ṹ���С
    NET_DVR_WDR  struWDR; //������Ϣ
}NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;


//��ҹת����������
typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType; /*��ҹ�л���0-���죬1-ҹ��2-�Զ���3-��ʱ��4-�������봥��, 5-�Զ�ģʽ2���޹�����,6-�ڹ⣬7-�ڹ��Զ���8-�ڹⶨʱ*/
    BYTE bySwitchScheduleEnabled; /*0 dsibale  1 enable,(����)*/
    //��ʱģʽ����
    BYTE byBeginTime; /*��ʼʱ�䣨Сʱ����0-23*/
    BYTE byEndTime; /*����ʱ�䣨Сʱ����0-23*/
    //ģʽ2
    BYTE byDayToNightFilterLevel; //0-7
    BYTE byNightToDayFilterLevel; //0-7
    BYTE byDayNightFilterTime;//(60��)
    //��ʱģʽ����
    BYTE byBeginTimeMin; //��ʼʱ�䣨�֣���0-59
    BYTE byBeginTimeSec; //��ʼʱ�䣨�룩��0-59
    BYTE byEndTimeMin; //����ʱ�䣨�֣���0-59
    BYTE byEndTimeSec; //����ʱ�䣨�룩��0-59
    //�������봥��ģʽ����
    BYTE byAlarmTrigState; //�������봥��״̬��0-���죬1-ҹ��
} NET_DVR_DAYNIGHT, *LPNET_DVR_DAYNIGHT;

//GammaУ��
typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled; /*0 dsibale  1 enable*/
    BYTE byGammaCorrectionLevel; /*0-100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT, *LPNET_DVR_GAMMACORRECT;

//���ⲹ������
typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode; /*���ⲹ��:0 off 1 UP��2 DOWN��3 LEFT��4 RIGHT��5MIDDLE��6�Զ��壬10-����11-�Զ���12-�����򱳹ⲹ��*/
    BYTE byBacklightLevel; /*0x0-0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1; //��X����1��
    DWORD dwPositionY1; //��Y����1��
    DWORD dwPositionX2; //��X����2��
    DWORD dwPositionY2; //��Y����2��
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT, *LPNET_DVR_BACKLIGHT;

//���ֽ��빦��
typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable; /*0-�����ã�1-��ͨģʽ���ֽ��룬2-ר��ģʽ���ֽ���*/
    BYTE byDigitalNoiseRemoveLevel; /*��ͨģʽ���ֽ��뼶��0x0-0xF*/
    BYTE bySpectralLevel;       /*ר��ģʽ�¿���ǿ�ȣ�0-100*/
    BYTE byTemporalLevel;   /*ר��ģʽ��ʱ��ǿ�ȣ�0-100*/
    BYTE byDigitalNoiseRemove2DEnable;         /* ץ��֡2D���룬0-�����ã�1-���� */    
    BYTE byDigitalNoiseRemove2DLevel;            /* ץ��֡2D���뼶��0-100 */
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE, *LPNET_DVR_NOISEREMOVE;

//CMOSģʽ��ǰ�˾�ͷ����
typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;   //ץ��ģʽ��0-ץ��ģʽ1��1-ץ��ģʽ2
    BYTE byBrightnessGate;//������ֵ
    BYTE byCaptureGain1;   //ץ������1,0-100
    BYTE byCaptureGain2;   //ץ������2,0-100
    DWORD dwCaptureShutterSpeed1;//ץ�Ŀ����ٶ�1
    DWORD dwCaptureShutterSpeed2;//ץ�Ŀ����ٶ�2
    BYTE  byRes[4];
}NET_DVR_CMOSMODECFG, *LPNET_DVR_CMOSMODECFG;

//ǰ�˲�������
typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*���ȡ��Աȶȡ����Ͷȡ���ȡ�ɫ������*/    
    NET_DVR_GAIN struGain;/*�Զ�����*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*��ƽ��*/
    NET_DVR_EXPOSURE struExposure; /*�ع����*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*GammaУ��*/
    NET_DVR_WDR struWdr;/*��̬*/
    NET_DVR_DAYNIGHT struDayNight;/*��ҹת��*/
    NET_DVR_BACKLIGHT struBackLight;/*���ⲹ��*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*���ֽ���*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
        0-�Զ���Ȧ, 
        1-�ֶ���Ȧ, 
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-HIK 3.8-16mm F1.5��HV3816P-8MPIR)
        6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
        7-HIK 2.7-12mm F1.2��TV2712P-MPIR��
        8- MZ5721D-12MPIR
        9- MZ1555D-12MPIR
        10- MZ5721D-12MPIR(RS485)
        11- MZ1555D-12MPIR(RS485)
    */
    BYTE byIrisMode;  
    BYTE byMirror ;  /* ����0 off��1- leftright��2- updown��3-center */
    BYTE byDigitalZoom;  /*��������:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*������,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*�ڵ�ƽ���� ,  0-255*/ 
    BYTE byEptzGate;// EPTZ���ر���:0-�����õ�����̨��1-���õ�����̨
    BYTE byLocalOutputGate;//����������ر���0-��������ر�1-����BNC����� 2-HDMI����ر�  11-���������12-�ü������13-�ü��������
    //20-HDMI_720P50�����
    //21-HDMI_720P60�����
    //22-HDMI_1080I60�����
    //23-HDMI_1080I50�����
    //24-HDMI_1080P24�����
    //25-HDMI_1080P25�����
    //26-HDMI_1080P30�����
    //27-HDMI_1080P50�����
    //28-HDMI_1080P60�����
    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60,
    //49-SDI_720P25
    //50-SDI_720P30 
    //51-SDI_1080I25
    //52-SDI_1080I30
    //60- YPBPR_720P50
    //61-YPBPR_720P60
    //62-YPBPR_1080I50
    //63-YPBPR_1080I60
    //64-YPBPR_1080P24
    //65-YPBPR_1080P25
    //66-YPBPR_1080P30
    //67-YPBPR_1080P50
    //68-YPBPR_1080P60
    //69-YPBPR_720P25 
    //70-YPBPR_720P30
    //71- HDMI_1080P�������û�о���֡�ʣ�֡�����豸�����captureMode����һ�£�
    //72- HDMI_720P�������û�о���֡�ʣ�֡�����豸�����captureMode����һ�£�
    //73- HDMI_2160P�������û�о���֡�ʣ�֡�����豸�����captureMode����һ�£�
    BYTE byCoderOutputMode;//������fpga���ģʽ0ֱͨ3���ذ��
    BYTE byLineCoding; //�Ƿ����б��룺0-��1-��
    BYTE byDimmerMode; //����ģʽ��0-���Զ���1-�Զ�
    BYTE byPaletteMode; //��ɫ�壺0-���ȣ�1-���ȣ�2-��ɫ��2������8-��ɫ��8
    BYTE byEnhancedMode; //��ǿ��ʽ��̽�������ܱߣ���0-����ǿ��1-1��2-2��3-3��4-4
    BYTE byDynamicContrastEN;    //��̬�Աȶ���ǿ 0-1
    BYTE byDynamicContrast;    //��̬�Աȶ� 0-100
    BYTE byJPEGQuality;    //JPEGͼ������ 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOSģʽ��ǰ�˲������ã���ͷģʽ����������ȡ
    BYTE byFilterSwitch; //�˲����أ�0-�����ã�1-����
    BYTE byFocusSpeed; //��ͷ�����ٶȣ�0-10
    BYTE byAutoCompensationInterval; //��ʱ�Զ����Ų�����1-120����λ������
    BYTE bySceneMode;  //����ģʽ��0-���⣬1-���ڣ�2-Ĭ�ϣ�3-����
}NET_DVR_CAMERAPARAMCFG, *LPNET_DVR_CAMERAPARAMCFG;

//͸��
typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //ģʽ��0-�����ã�1-�Զ�ģʽ��2-����ģʽ
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6]; 
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

//���ӷ���
typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;//ʹ�� 0- �����ã�1- ����
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6]; 
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

//����ģʽ
typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; //�Ƿ���������ģʽ 0�������ã� 1������
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

// SMART IR(������)���ò���
typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0���ֶ���1���Զ�
    BYTE  byIRDistance;//�������ȼ�(�ȼ�������������)level:1~100 Ĭ��:50���ֶ�ģʽ�����ӣ�
    BYTE  byShortIRDistance;// ����ƾ���ȼ�(1~100)
    BYTE  byLongIRDistance;// Զ��ƾ���ȼ�(1~100)
}NET_DVR_SMARTIR_PARAM,*LPNET_DVR_SMARTIR_PARAM;

//��byIrisMode ΪP-Iris1ʱ��Ч�����ú����Ȧ��С�ȼ�������ģʽ
typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0-�Զ���1-�ֶ�
    BYTE  byPIrisAperture;//�����Ȧ��С�ȼ�(�ȼ�,��Ȧ��С������)level:1~100 Ĭ��:50���ֶ�ģʽ�����ӣ�
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM,*LPNET_DVR_PIRIS_PARAM;


//����������� 2014-02-25
typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE    byControlMode;        //����ģʽ            0-��Ч��1-�Զ���2-�ֶ� Ĭ���Զ�
    BYTE    bySensitivity;        //�����������        0-100 Ĭ��50
    BYTE    byTriggerMode;        //����ƴ���ģʽ    0-��Ч��1-��о������2-�������� Ĭ�ϻ�о����
    BYTE    byBrightness;        //����ģʽΪ�ֶ�ģʽ����Ч�����������        0-255 Ĭ��100
    BYTE    byAngle;            //����ƽǶ�        0-��Ч����Χ1-36  Ĭ��12����������䷶ΧΪһ��ԲȦ�����ڼ���Ƕ��ǵ������Բ�İ뾶�Ĵ�С
    BYTE    byLimitBrightness;  //����ģʽΪ�Զ�ģʽ����Ч��������������� 0~100 ��������2014-01-26
    BYTE    byEnabled ;         //�ֶ����Ƽ����ʹ�� 0-�رգ�1-����
    BYTE    byIllumination;     //�����ǿ������0~100
    BYTE    byLightAngle;       //����Ƕ� 0~100
    BYTE    byRes[7];           //����
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off 
    BYTE   byMode;
    //��ʱ��:��������ʾ����λ���ӣ�ѡ����10,20,30,40,50,60,120,180,240��
    BYTE   byRes1;
    WORD   wCompensateTime; //��ʱģʽ����Ч
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM,*LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM   //��sensor�����
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//��ͨģʽ�ȼ���Χ[1,100]����ͨģʽ����Ч
    BYTE  byExpertLevel;//ר��ģʽ�ȼ���Χ[1,100]��ר��ģʽ����Ч
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM,*LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//���ȵȼ�[1,100]���ֶ�ģʽ����Ч
    BYTE  byGainLevel; //����ȼ�[1,100]���ֶ�ģʽ����Ч
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM,*LPNET_DVR_AGC_PARAM;

//ץ�Ļ�CCD���� ��64�ֽ�
typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG 
{
    BYTE byWDRMode;   // ��̬ģʽ;0~�رգ�1~���ֿ�̬ 2~��̬
    BYTE byWDRType;    // ��̬�л�ģʽ; 0~ǿ�����ã�1~��ʱ�����ã�2~����������
    BYTE byWDRLevel;   // ��̬�ȼ���0~6������Ӧ1-7��Ĭ������2����3������
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //��ʼ��̬ʱ��
    NET_DVR_TIME_EX struEndTime; //������̬ʱ��
    BYTE byDayNightBrightness; //��ҹת��������ֵ��0-100��Ĭ��50��
    //����ɫ��ǿ
    BYTE byMCEEnabled;//����ɫ��ǿʹ�ܣ�true��������false���ر�
    BYTE byMCELevel;//����ɫ��ǿǿ�ȣ�0~100��Ĭ��ֵ50
    //�Զ��Աȶ�
    BYTE byAutoContrastEnabled;//�Զ��Աȶ�ʹ�ܣ�true��������false���ر�
    BYTE byAutoContrastLevel;//�Զ��Աȵȼ���0-100��,Ĭ��50
    //ϸ����ǿ
    BYTE byLSEDetailEnabled;//ϸ����ǿʹ�ܣ�true��������false���ر�
    BYTE byLSEDetailLevel;//ϸ����ǿ�ȼ���0-100��,Ĭ��50
    // License Plate Definition Enhancement������ǿ
    BYTE byLPDEEnabled;//������ǿʹ�ܣ�true��������false���ر�
    BYTE byLPDELevel;//������ǿ�ȼ���0-100��,Ĭ��50
    //�Աȶ���ǿ
    BYTE byLseEnabled; //�Աȶ���ǿʹ�ܣ�true��������false���ر�
    BYTE byLseLevel; //�Աȶ���ǿ�ȼ���0-100��,Ĭ��0
    BYTE byLSEHaloLevel;//�������Ƶȼ�����Χ 0-100,Ĭ��0
    BYTE byLseType; //�Աȶ���ǿ�л�ģʽ; 0~ǿ�����ã�1~��ʱ�����ã�2~���������ã����ֶο�ͬʱ����byLseLevel��byLSEHaloLevel����������
    BYTE byRes2[3];
    NET_DVR_TIME_EX struLSEStartTime; //��ʼ�Աȶ���ǿʱ�䣨��byLseTypeΪ1ʱ��Ч��
    NET_DVR_TIME_EX struLSEEndTime; //�����Աȶ���ǿʱ�䣨��byLseTypeΪ1ʱ��Ч��
    BYTE byLightLevel;//Ϊ���ȵȼ�������0-100��,Ĭ��0������byLseTypeΪ2ʱ��Ч��
    //���ƶԱȶ�
    BYTE byPlateContrastLevel;//���ƶԱȶȵȼ���0~100��Ĭ��0
    //���Ʊ��Ͷ�
    BYTE byPlateSaturationLevel;//���Ʊ��Ͷȵȼ���0~100��Ĭ��0
    BYTE byRes[9];
} NET_DVR_SNAP_CAMERAPARAMCFG,*LPNET_DVR_SNAP_CAMERAPARAMCFG;

//��ѧ͸�����
typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~�����ù�ѧ͸��1~���ù�ѧ͸��
    BYTE byRes[7]; 
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

//����AGC���ã�������AGCģʽΪ��Чʱ����NET_DVR_AGC_PARAM���ò���Ϊ׼��������AGCģʽΪ�Զ������ֶ�ʱ��NET_DVR_AGC_PARAM���ò�����Ч
typedef struct tagNET_DVR_THERMOMETRY_AGC
{
    BYTE  byMode;//AGCģʽ��0~��Ч��1~�Զ���2~�ֶ�
    BYTE  byRes1[3];
    int     iHighTemperature;//����¶ȣ���ΧΪ��-273~9999���϶ȣ�1~�ֶ�ģʽ����Ч��
    int     iLowTemperature;//����¶ȣ���ΧΪ��-273~9999���϶ȣ�1~�ֶ�ģʽ����Ч��
    BYTE  byRes[8];
}NET_DVR_THERMOMETRY_AGC, *LPNET_DVR_THERMOMETRY_AGC;

//ǰ�˲�������
typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*���ȡ��Աȶȡ����Ͷȡ���ȡ�ɫ������*/    
    NET_DVR_GAIN struGain;/*�Զ�����*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*��ƽ��*/
    NET_DVR_EXPOSURE struExposure; /*�ع����*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*GammaУ��*/
    NET_DVR_WDR struWdr;/*��̬*/
    NET_DVR_DAYNIGHT struDayNight;/*��ҹת��*/
    NET_DVR_BACKLIGHT struBackLight;/*���ⲹ��*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*���ֽ���*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
    0-�Զ���Ȧ,
    1-�ֶ���Ȧ,
    2-P-Iris1,
    3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
    4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
    5-HIK 3.8-16mm F1.5��HV3816P-8MPIR)
    6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
    7-HIK 2.7-12mm F1.2��TV2712P-MPIR��
    8- MZ5721D-12MPIR
    9- MZ1555D-12MPIR
    10- MZ5721D-12MPIR(RS485)
    11- MZ1555D-12MPIR(RS485)
    */
    BYTE byIrisMode;
    BYTE byMirror ;  /* ����0 off��1- leftright��2- updown��3-center 4-Auto*/
    BYTE byDigitalZoom;  /*��������:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*������,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*�ڵ�ƽ���� ,  0-255*/ 
    BYTE byEptzGate;// EPTZ���ر���:0-�����õ�����̨��1-���õ�����̨
    BYTE byLocalOutputGate;//����������ر���0-��������ر�1-����BNC����� 2-HDMI����ر�  
    //20-HDMI_720P50�����
    //21-HDMI_720P60�����
    //22-HDMI_1080I60�����
    //23-HDMI_1080I50�����
    //24-HDMI_1080P24�����
    //25-HDMI_1080P25�����
    //26-HDMI_1080P30�����
    //27-HDMI_1080P50�����
    //28-HDMI_1080P60�����
    BYTE byCoderOutputMode;//������fpga���ģʽ0ֱͨ3���ذ��
    BYTE byLineCoding; //�Ƿ����б��룺0-��1-��
    BYTE byDimmerMode; //����ģʽ��0-���Զ���1-�Զ�
    BYTE byPaletteMode; //��ɫ�壺0-���ȣ�1-���ȣ�2-��ɫ��2������8-��ɫ��8, 9-�ں�1,10-�ʺ�,11-�ں�2,12-����1,13-����2,14-���ɫ,15-ɫ��1,16-ɫ��2,17-����,18-��,19-����,20-����,21-������22-ɫ��3
    BYTE byEnhancedMode; //��ǿ��ʽ��̽�������ܱߣ���0-����ǿ��1-1��2-2��3-3��4-4
    BYTE byDynamicContrastEN;    //��̬�Աȶ���ǿ 0-1
    BYTE byDynamicContrast;    //��̬�Աȶ� 0-100
    BYTE byJPEGQuality;    //JPEGͼ������ 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOSģʽ��ǰ�˲������ã���ͷģʽ����������ȡ
    BYTE byFilterSwitch; //�˲����أ�0-�����ã�1-����
    BYTE byFocusSpeed; //��ͷ�����ٶȣ�0-10
    BYTE byAutoCompensationInterval; //��ʱ�Զ����Ų�����1-120����λ������
    BYTE bySceneMode;  //����ģʽ��0-���⣬1-���ڣ�2-Ĭ�ϣ�3-����
    NET_DVR_DEFOGCFG struDefogCfg;//͸�����
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//���ӷ���
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//����ģʽ
    BYTE   byExposureSegmentEnable; //0~������,1~����  �ع�ʱ�������ʽ���״�����������ع����ϵ���ʱ��������ع�ʱ�䵽�м�ֵ��Ȼ��������浽�м�ֵ��������ع⵽���ֵ�����������浽���ֵ
    BYTE   byBrightCompensate;//������ǿ [0~100]
    /*
    0-�رա�1-640*480@25fps��2-640*480@30ps��3-704*576@25fps��4-704*480@30fps��5-1280*720@25fps��6-1280*720@30fps��
    7-1280*720@50fps��8-1280*720@60fps��9-1280*960@15fps��10-1280*960@25fps��11-1280*960@30fps��
    12-1280*1024@25fps��13--1280*1024@30fps��14-1600*900@15fps��15-1600*1200@15fps��16-1920*1080@15fps��
    17-1920*1080@25fps��18-1920*1080@30fps��19-1920*1080@50fps��20-1920*1080@60fps��21-2048*1536@15fps��22-2048*1536@20fps��
    23-2048*1536@24fps��24-2048*1536@25fps��25-2048*1536@30fps��26-2560*2048@25fps��27-2560*2048@30fps��
    28-2560*1920@7.5fps��29-3072*2048@25fps��30-3072*2048@30fps��31-2048*1536@12.5��32-2560*1920@6.25��
    33-1600*1200@25��34-1600*1200@30��35-1600*1200@12.5��36-1600*900@12.5��37-1280*960@12.5fps��38-800*600@25fps��39-800*600@30fps40��
    4000*3000@12.5fps��41-4000*3000@15fps��42-4096*2160@20fps��43-3840*2160@20fps ��44-960*576@25fps��45-960*480@30fps��46-752*582@25fps��
    47-768*494@30fps��48-2560*1440@25fps��49-2560*1440@30fps ��50-720P@100fps��51-720P@120fps��52-2048*1536@50fps��53-2048*1536@60fps��
    54-3840*2160@25fps��55-3840*2160@30fps��56-4096*2160@25fps��57-4096*2160@30fps ��58-1280*1024@50fps��59-1280*1024@60fps��
    60-3072*2048@50fps��61-3072*2048@60fps��62-3072*1728@25fps��63-3072*1728@30fps��64-3072*1728@50fps��65-3072*1728@60fps��66-336*256@50fps��67-336*256@60fps��
    68-384*288@50fps��69-384*288@60fps ��70- 640 * 512@50fps ��71- 640 * 512@60fps��72-2592*1944@25fps��73-2592*1944@30fps��74-2688*1536@25fps��75-2688*1536@30fps 
    76-2592*1944@20fps��77-2592*1944@15fps��78-2688*1520@20fps��79-2688*1520@15fps��80-2688*1520@25fps��81-2688*1520@30fps��82- 2720*2048@25fps�� 83- 2720*2048@30fps��
    84-336*256@25fps��85- 384*288@25fps��86-640*512@25fps��87-1280*960@50fps��88-1280*960@60fps��89-1280*960@100fps��90-1280*960@120fps��91-4000*3000@20fps��
    92-1920*1200@25fps��93-1920*1200@30fps��94-2560*1920@25fps��95-2560*1920@20fps��96-2560*1920@30fps��97-1280*1920@25fps��98-1280*1920@30fps
    99-4000*3000@24fps��100-4000*3000@25fps��101-4000*3000@10fps��102- 384*288@30fps��103-2560*1920@15fps��104-2400*3840@25fps��105-1200*1920@25fps
    106-4096*1800@30fps��107-3840*1680@30fps��108-2560*1120@30fps��109-704*320@30fps��110-1280*560@30fps��111-4096*1800@25fps��112-3840*1680@25fps
    113-2560*1120@25fps��114-704*320@25fps��115-1280*560@25fps��116-2400*3840@24fps��117-3840*2400@24fps��118-3840*2400@25fps��119-2560*1920@12.5fps
    120-2560*2048@12fps��121-2560*2048@15fps��122-2560*1536@25fps��123-2560*1536@30fps��124-2256*2048@25fps��125-2256*2048@30fps��126-2592*2592@12.5fps��127-2592*2592@15fps��
    128 - 640*512@30fps��129-2048*1520@30fps��130-2048*1520@25fps��131-3840*2160@24fps��132-2592*1520@25fps��133-2592*1520@30fps��134-2592*1536@25fps��135-2592*1536@30fps
    136-640*960@25fps��137-640*960@24fps��142-2992*2192@25fps��143-2992*2192@30fps��144-3008*2160@25fps��145-3008*2160@30fps��146-3072*1728@20fps��147-2560*1440@20fps��
    148-2160*3840@25fps��149-2160*3840@30fps��150-7008*1080@25fps��151-7008*1080@30fps��152-3072*2048@20fps��153-1536*864@25fps��154-2560*1920@24fps��155-2400*3840@30fps��
    156-3840*2400@30fps��157-3840*2160@15fps
    158-384*288@8.3fps��159-640*512@8.3fps��160-160*120@8.3fps��161-1024*768@8.3fps��162-640*480@8.3fps��163-3840*2160@12.5fps��164-2304*1296@30fps��165-2304*1296@25fps��
    166-2560*1440@24fps��167-2688*1512@25fps��168-2688*1512@30fps��169-2688*1512@50fps��170-2688*1512@60fps��171-1536*864@30fps��172-2560*1440@50fps��173-2560*1440@60fps��
    174-2048*2048@25fps��175-2048*2048@30fps��176-4000*3060@20fps��177-3060*3060@25fps��178-3060*3060@30fps��179-3000*3000@25fps��180-3000*3000@30fps��181-8160*3616@30fps��
    182-8160*3616@25fps��183-3000*3000@20fps��184-3000*3000@15fps��185-3000*3000@12.5fps��186-5472*3648@25fps��187-5472*3648@30fps��188-7680*4320@25fps��189-7680*4320@30fps��
    190-8160*2400@25fps��191-8160*2400@30fps��192-5520*2400@25fps��193-5520*2400@30fps��194-2560*1440@15fps��195-1944*1212@24fps��196-1944*1212@25fps��197-3456*1920@30fps��
    198-4800*2688@25fps��199-4800*2688@30fps��200-6480*1080@25fps��201-6480*1080@30fps��202-8640*1440@25fps��203-8640*1440@30fps��204-3456*1920@25fps��205-2688*1520@50fps��
    206-2688*1520@60fps��207-4976*1452@25fps��208-4976*1452@30fps�� 209-3200*1800@25fps��210-3200*1800@30fps��211-5472*3648@24fps��212-1920*1080@12.5fps��213-2944*1656@20fps��
    214-1920*1080@24fps��215-4800*1600@25fps��216-4800*1600@30fps*/
    BYTE   byCaptureModeN; //��Ƶ����ģʽ��N�ƣ�
    BYTE   byCaptureModeP; //��Ƶ����ģʽ��P�ƣ�
    NET_DVR_SMARTIR_PARAM struSmartIRParam; //����Ź���������Ϣ
    NET_DVR_PIRIS_PARAM struPIrisParam;//PIris������Ϣ��ӦbyIrisMode�ֶδ�2-PIris1��ʼ��Ч
    //2014-02-25 ��������
    NET_DVR_LASER_PARAM_CFG struLaserParam;    //�������
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//��ͷ����У�� 0-�ر�,1-����
    BYTE byDistortionCorrectionLevel;//����У���ȼ���0-������1-�ȼ�һ��2-�ȼ�����3-�ȼ���;255-�Զ���
    BYTE byCalibrationAccurateLevel;// ����У��ǿ��[0-100]
    BYTE byZoomedInDistantViewLevel;//Զ�˷Ŵ�ȼ�[0-100]
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD ; //ץ�Ļ�CCD������ֻ����ץ�Ļ�
    NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//��ѧ͸�����
    NET_DVR_THERMOMETRY_AGC struThermAGC;//����AGC����
    BYTE   byFusionMode;//˫������Ƶ�ں�ģʽ��0~�ȳ���ģʽ��1~�ں�ģʽ��2~���л�ģʽ,3~�ɼ���ģʽ, 4~�ںϺڰ�ģʽ, 5~�ںϲ�ɫģʽ-�ݵأ�6~�ںϲ�ɫģʽ-�ĵأ�7~�ںϲ�ɫģʽ-ѩ�أ�8~�ںϲ�ɫģʽ-����9~�ںϲ�ɫģʽ-����
    BYTE   byHorizontalFOV;//ˮƽ�ӳ���[0-100]
    BYTE   byVerticalFOV;//��ֱ�ӳ���[0-100]
    BYTE   byBrightnessSuddenChangeSuppression;//����ͻ������0-�ر�,1-����
    BYTE   byGPSEnabled;//GPS����ʹ�ܣ�0-�أ�1-��
    BYTE   byRes2[155];
}NET_DVR_CAMERAPARAMCFG_EX, *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD   dwSize;
    BYTE    byState;//�۽���λ״̬���� 0-����λ��1-��λ
    BYTE    byRes[31];    
}NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;

typedef enum _VCA_PLATE_COLOR_
{
    VCA_BLUE_PLATE  = 0,   //��ɫ����
        VCA_YELLOW_PLATE,      //��ɫ����
        VCA_WHITE_PLATE,       //��ɫ����
        VCA_BLACK_PLATE,       //��ɫ����
        VCA_GREEN_PLATE,       //��ɫ����
        VCA_BKAIR_PLATE,       //�񺽺�ɫ����
        VCA_RED_PLATE,         //��ɫ����
        VCA_ORANGE_PLATE,      //��ɫ����
        VCA_OTHER = 0xff       //����
}VCA_PLATE_COLOR;

//��������
typedef enum _VCA_PLATE_TYPE_
{
    VCA_STANDARD92_PLATE = 0,    //��׼���ó������
    VCA_STANDARD02_PLATE,        //02ʽ���ó��� 
    VCA_WJPOLICE_PLATE,            //�侯�� 
    VCA_JINGCHE_PLATE,            //����
    STANDARD92_BACK_PLATE,         //���ó�˫��β��
    VCA_SHIGUAN_PLATE,          //ʹ�ݳ���
    VCA_NONGYONG_PLATE,         //ũ�ó�
    VCA_MOTO_PLATE,              //Ħ�г�
    NEW_ENERGY_PLATE,             //����Դ����
    //2017-05-18 ���� �ж�������������
    TRANSPORT_PLATE = 0x20,     //���䳵
    COMMERCIAL_PLATE,           //���ó�
    PRIVATE_PLATE,              //˽�ҳ�
    LEARNING_PLATE,             //������
    CD_PLATE,                   //ʹ�ݳ�
    CC_PLATE,                   //ʹ�ݳ�
    ARMY_PLATE,                 //����
    PROTOCOL_PLATE,             //PROTOCOL
    GOVERNMENT_PLATE,           //������
    EXPORT_PLATE,               //EXPORT
    TAXI_PLATE,                 //���⳵
    TESTING_PLATE,              //TESTING
    TRANSFER_PLATE,             //TRANSFER
    TRUCK_PLATE,                //����
    BUS_PLATE,                  //������
    PUBLIC_PLATE,               //PUBLIC
    PUB_TRANS_PLATE,            //PUBLIC TRANSFER
    PRI_TRANS_PLATE,            //PRIVATE TRANSPORT
    UNKNOWN_PLATE = 0xff,       //δ֪��δʶ��
}VCA_PLATE_TYPE;

//����ʶ����
typedef enum _VTR_RESULT
{
    VTR_RESULT_OTHER      =  0,  //δ֪
    VTR_RESULT_BUS        =  1,  //�ͳ�
    VTR_RESULT_TRUCK      =  2,  //����
    VTR_RESULT_CAR        =  3,  //�γ�
    VTR_RESULT_MINIBUS    =  4,  //�����
    VTR_RESULT_SMALLTRUCK =  5,  //С����
    VTR_RESULT_HUMAN      =  6,  //����
    VTR_RESULT_TUMBREL    =  7,  //���ֳ�
    VTR_RESULT_TRIKE      =  8,  //���ֳ�
    VTR_RESULT_SUV_MPV    =  9,  //SUV/MPV
    VTR_RESULT_MEDIUM_BUS =  10,  //���Ϳͳ�
    VTR_RESULT_MOTOR_VEHICLE = 11, //������
    VTR_RESULT_NON_MOTOR_VEHICLE = 12,  //�ǻ�����
    VTR_RESULT_SMALLCAR   = 13,   //С�ͽγ�
    VTR_RESULT_MICROCAR   = 14,   //΢�ͽγ�
    VTR_RESULT_PICKUP     = 15,    //Ƥ����
    VTR_RESULT_CONTAINER_TRUCK = 16, // ��װ�俨��
    VTR_RESULT_MINI_TRUCK = 17, // ΢�������忨
    VTR_RESULT_SLAG_CAR = 18, // ������
    VTR_RESULT_CRANE = 19, // ���������̳�
    VTR_RESULT_OIL_TANK_TRUCK = 20, // �͹޳�
    VTR_RESULT_CONCRETE_MIXER = 21, // ���������賵
    VTR_RESULT_PLATFORM_TRAILER = 22, // ƽ���ϳ�
    VTR_RESULT_HATCHBACK = 23, // ����γ�
    VTR_RESULT_SALOON = 24, // ����γ�
    VTR_RESULT_SPORT_SEDAN = 25,  // ����
    VTR_RESULT_SMALL_BUS = 26  //С�Ϳͳ�
}VTR_RESULT;


//������ɫ
typedef enum _VCR_CLR_CLASS
{
    VCR_CLR_UNSUPPORT  = 0,      //��֧��
        VCR_CLR_WHITE       = 1,   //��
        VCR_CLR_SILVER        = 2,   //��
        VCR_CLR_GRAY       = 3,      //��
        VCR_CLR_BLACK      = 4,      //��
        VCR_CLR_RED           = 5,      //��
        VCR_CLR_DARKBLUE   = 6,      //����
        VCR_CLR_BLUE       = 7,      //��
        VCR_CLR_YELLOW     = 8,      //��
        VCR_CLR_GREEN      = 9,      //��
        VCR_CLR_BROWN      = 10,  //��
        VCR_CLR_PINK       = 11,  //��
        VCR_CLR_PURPLE     = 12,  //��
        VCR_CLR_DARKGRAY   = 13,  //���
        VCR_CLR_CYAN       = 14  //��ɫ
}VCR_CLR_CLASS;

//������������ 2013-11-04
typedef enum _VCA_OPERATE_TYPE_
{
    VCA_LICENSE_TYPE       = 0x1,  //���ƺ���
        VCA_PLATECOLOR_TYPE    = 0x2,  //������ɫ
        VCA_CARDNO_TYPE        = 0x4,  //����
        VCA_PLATETYPE_TYPE     = 0x8,  //��������
        VCA_LISTTYPE_TYPE      = 0x10, //������������
        VCA_INDEX_TYPE         = 0x20, //������ˮ�� 2014-02-25
        VCA_OPERATE_INDEX_TYPE = 0x40  //������ 2014-03-03
}VCA_OPERATE_TYPE;

typedef enum _VCA_ILLEGAL_TYPE_
{
    VCA_POSTPIC_TYPE          = 0x1, //����ͼƬ
        VCA_LOWSPEED_TYPE         = 0x2,  //����
        VCA_HIGHSPEED_TYPE        = 0x4,  //����
        VCA_RETROGRADE_TYPE       = 0x8,  //����
        VCA_RUSH_REDLIGHT_TYPE    = 0x10,   //�����
        VCA_PRESS_LANE_TYPE       = 0x20, //ѹ������
        VCA_VIOLATE_GUIDE_TYPE    = 0x40,//��������
        VCA_ROAD_STRAND_TYPE      = 0x80,//·������(�豸��֧��)
        VCA_VEHICLE_ILLEGAL_LANE_TYPE  = 0x100,//��ռ��
        VCA_ILLEGAL_LANE_CHANGE_TYPE   = 0x200,//Υ�����
        VCA_ILLEGAL_LANE_DRIVE_TYPE    = 0x400,//��������
        VCA_VIOLATE_BAN_TYPE           = 0x800,//Υ������
        VCA_CROSS_PARKING_TYPE         = 0x1000,//·��ͣ��
        VCA_GREEN_PARKING_TYPE         = 0x2000//�̵�ͣ��
}VCA_ILLEGAL_TYPE;

typedef enum _VCA_VEHICLE_TYPE_
{
    VCA_OTHER_TYPE          = 0x1,  //��������
        VCA_SMALLCAR_TYPE       = 0x2,  //С�ͳ�
        VCA_BIGCAR_TYPE         = 0x4,  //���ͳ�
        VCA_BUS_TYPE            = 0x8,  //�ͳ�
        VCA_TRUCK_TYPE          = 0x10,  //����
        VCA_CAR_TYPE            = 0x20,   //�γ�
        VCA_MINIBUS_TYPE        = 0x40,   //�����
        VCA_SMALL_TRUCK_TYPE    = 0x80  //С����
}VCA_VEHICLE_TYPE;

//����Ʒ��������
typedef enum _VLR_VEHICLE_CLASS
{
        VLR_OTHER       = 0,    //����
        VLR_VOLKSWAGEN  = 1,    //����
        VLR_BUICK       = 2,    //���
        VLR_BMW         = 3,    //����
        VLR_HONDA       = 4,    //����
        VLR_PEUGEOT     = 5,    //����
        VLR_TOYOTA      = 6,    //����
        VLR_FORD        = 7,    //����
        VLR_NISSAN      = 8,    //�ղ�
        VLR_AUDI        = 9,    //�µ�
        VLR_MAZDA       = 10,   //���Դ�
        VLR_CHEVROLET   = 11,   //ѩ����
        VLR_CITROEN     = 12,   //ѩ����
        VLR_HYUNDAI     = 13,   //�ִ�
        VLR_CHERY       = 14,   //����
        VLR_KIA         = 15,   //����
        VLR_ROEWE       = 16,   //����
        VLR_MITSUBISHI  = 17,   //����
        VLR_SKODA       = 18,   //˹�´�
        VLR_GEELY       = 19,   //����
        VLR_ZHONGHUA    = 20,   //�л�
        VLR_VOLVO       = 21,   //�ֶ���
        VLR_LEXUS       = 22,   //�׿���˹
        VLR_FIAT        = 23,   //������
        VLR_EMGRAND     = 24,   //�ۺ�(����)
        VLR_DONGFENG    = 25,   //����
        VLR_BYD         = 26,   //���ǵ�
        VLR_SUZUKI      = 27,   //��ľ
        VLR_JINBEI      = 28,   //��
        VLR_HAIMA       = 29,   //����
        VLR_SGMW        = 30,   //����
        VLR_JAC         = 31,   //����
        VLR_SUBARU      = 32,   //˹��³
        VLR_ENGLON      = 33,   //Ӣ��(����)
        VLR_GREATWALL   = 34,   //����
        VLR_HAFEI       = 35,   //����
        VLR_ISUZU       = 36,   //��ʮ��(����)
        VLR_SOUEAST     = 37,   //����
        VLR_CHANA       = 38,   //����
        VLR_FOTON       = 39,   //����
        VLR_XIALI       = 40,   //����(һ��)
        VLR_BENZ        = 41,   //����
        VLR_FAW         = 42,   //һ��
        VLR_NAVECO      = 43,   //��ά��
        VLR_LIFAN       = 44,   //����
        VLR_BESTURN     = 45,   //һ������(һ��)
        VLR_CROWN       = 46,   //�ʹ�(����)
        VLR_RENAULT     = 47,   //��ŵ
        VLR_JMC         = 48,   //JMC(����)
        VLR_MG          = 49,   //MG����
        VLR_KAMA        = 50,   //����
        VLR_ZOTYE       = 51,   //��̩
        VLR_CHANGHE     = 52,   //����
        VLR_XMKINGLONG  = 53,   //���Ž���(����)
        VLR_HUIZHONG    = 54,   //�Ϻ�����(��������)
        VLR_SZKINGLONG  = 55,   //���ݽ���
        VLR_HIGER       = 56,   //����
        VLR_YUTONG      = 57,   //��ͨ
        VLR_CNHTC       = 58,   //�й�����
        VLR_BEIBEN      = 59,   //�����ؿ�
        VLR_XINGMA      = 60,   //��������
        VLR_YUEJIN      = 61,   //Ծ��
        VLR_HUANGHAI    = 62,   //�ƺ�
        VLR_OLDWALL     = 63,   //�Ͽ��
        VLR_CHANACOMMERCIAL = 64,   //��������
        VLR_PORSCHE                   = 65,               // ��ʱ��
        VLR_CADILLAC                  = 66,               // ��������
        VLR_INFINITI                  = 67,               // Ӣ�����
        VLR_GLEAGLE                   = 68,               // ����ȫ��ӥ(����)
        VLR_JEEP                      = 69,               // JEEP(����)
        VLR_LANDROVER                 = 70,               // ·��
        VLR_CHANGFENG                 = 71,               // ����
        VLR_BENNI                     = 72,               // ��������(����)
        VLR_ERA                       = 73,               // ����ʱ��(ʱ��)
        VLR_TAURUS                    = 74,               // ������ţ��(��������)
        VLR_EADO                      = 75,               // �����ݶ�
        VLR_SHANQI                    = 76,               // ����
        VLR_HONGYAN                   = 77,               // ��������(������ά�º���)
        VLR_DRAGON                    = 78,               // ��������(��������)
        VLR_JACTEXT                   = 79,               // ����JAC (����)
        VLR_JACBUS                    = 80,               // �����ִ��ͳ� (����)
        VLR_ANKAI                     = 81,               // �����ͳ�
        VLR_SHENLONG                  = 82,               // �����ͳ�
        VLR_DAEWOO                    = 83,               // ����ͳ�
        VLR_WUZHENG                   = 84,               // ��������
        VLR_MAN                       = 85,               // MAN����
        VLR_ZHONGTONG                 = 86,               // ��ͨ�ͳ�
        VLR_BAOJUN                    = 87,               // ����
        VLR_BQWEIWANG                 = 88,               // ��������
        VLR_TRUMPCHE                  = 89,               // ����
        VLR_LUFENG                    = 90,               // ½��
        VLR_HMZHENGZHOU               = 91,               // ����֣��
        VLR_BEIJING                   = 92,               // ��������
        VLR_ZHONGSHUN                 = 93,               // ��˳
        VLR_WEILIN                    = 94,               // ��������
        VLR_OPEL                      = 95,               // ŷ��
        VLR_KARRY                     = 96,               // ����
        VLR_SMA                       = 97,               // ��������
        VLR_SMATEXT                   = 98,               // ������������SMA
        VLR_YUWIN                     = 99,               // ����Ԧʤ
        VLR_MINI                      = 100,               // ����MINI
        VLR_MARK                      = 101,               // ����MARKX 
        VLR_HAVAL                     = 102,               // ����HAVAL
        VLR_OGA                       = 103,               // ک��
        VLR_VENUCIA                   = 104,               // ����
        VLR_BYD2                      = 105,               // ���ǵ���ʽ2 (���ǵ�)
        VLR_SMART                     = 106,               // ����SMART
        VLR_BAW                       = 107,               // �����������쳧BAW
        VLR_LUXGEN                    = 108,               // ���ǽ�
        VLR_YEMA                      = 109,               // Ұ��
        VLR_ZTE                       = 110,               // ����
        VLR_EVERUS                    = 111,               // ����
        VLR_CHRYSLER                  = 112,               // ����˹��
        VLR_GONOW                     = 113,               // ��������
        VLR_SHJIANG                   = 114,               // �ɻ���
        VLR_RUILIN                    = 115,               // ����
        VLR_FORTA                     = 116,               // ����
        VLR_GAGUAR                    = 117,               // �ݱ�
        VLR_HEIBAO                    = 118,               // �ڱ�
        VLR_TKING                     = 119,               // �ƿ�
        VLR_TKINGTEXT                 = 120,               // �ƿ�����
        VLR_FODAY                     = 121,               // ����
        VLR_LOTUS                     = 122,               // ��������
        VLR_NANJUN                    = 123,               // �Ͽ�
        VLR_SHUANGHUAN                = 124,               // ˫������
        VLR_SAIBAO                    = 125,               // ��������
        VLR_HAWTAI                    = 126,               // ��̩
        VLR_LIFO                      = 127,               // ��Դ�ɵ�
        VLR_JONWAY                    = 128,               // ��Դ����
        VLR_FULONGMA                  = 129,               // ������
        VLR_WEILI                     = 130,               // Ϋ��
        VLR_ANCHI                     = 131,               // ��������
        VLR_PAIXI                     = 132,               // ��ϲ
        VLR_HIGERTEXT                 = 133,               // ����HIGER����
        VLR_RIYECAR                   = 134,               // ������Ұ�Ῠ
        VLR_RIYETRUCK                 = 135,               // ������Ұ�ؿ�
        VLR_JIANGNAN                  = 136,               // ����
        VLR_OLDZOTYE                  = 137,               // �Ͽ���̩
        VLR_OLDXIALI                  = 138,               // �Ͽ�����
        VLR_NEWAOCHI                  = 139,               // �°³�
        VLR_CDW                       = 140,               // ��������
        VLR_CDWTEXT                   = 141,               // ������������
        VLR_CIIMO                     = 142,               // ����˼��
        VLR_CHANADS                   = 143,               // �����а���
        VLR_DS                        = 144,               // ����
        VLR_ROHENS                    = 145,               // �ִ��Ͷ�˹����
        VLR_YANTAI                    = 146,               // ��̨
        VLR_SHUANGLONG                = 147,               // ˫��
        VLR_FENGLING                  = 148,               // ʱ������
        VLR_XINKAI                    = 149,               // �¿�
        VLR_GMC                       = 150,               // GMC
        VLR_DATONG                    = 151,               // ������ͨ
        VLR_BQYINXIANG                = 152,               // ��������
        VLR_NEWCHERY                  = 153,               // ������
        VLR_MUDAN                     = 154,               // ĵ��
        VLR_DAYUN                     = 155,               // ��������
        VLR_DONGWO                    = 156,               // ��������
        VLR_UNION                     = 157,               // ��������
        VLR_CHUNZHOU                  = 158,               // ���޿ͳ�
        VLR_SANY                      = 159,               // ��һ�ع�
        VLR_YAXING                    = 160,               // ���ǿͳ�
        VLR_HENGTONG                  = 161,               // ��ͨ�ͳ�
        VLR_SHAOLIN                   = 162,               // ���ֿͳ�
        VLR_YOUNG                     = 163,               // ����ͳ�
        VLR_STOM                      = 164,               // ʮͨ
        VLR_SANHUAN                   = 165,               // ����
        VLR_XUGONG                    = 166,               // �칤
        VLR_BEIFANG                   = 167,               // ��������
        VLR_JIANGHUAN                 = 168,               // ��������
        VLR_BJFARM                    = 169,               // ����ũ��
        VLR_NEWDADI                   = 170,               // �´������
        VLR_SUNWIN                    = 171,               // ���ֿͳ�
        VLR_YINGTIAN                  = 172,               // Ӣ��
        VLR_QINGQI                    = 173,               // ����
        VLR_CHUFENG                   = 174,               // ��������
        VLR_SCANIA                    = 175,               // ˹������
        VLR_JIULONG                   = 176,               // �����ͳ�
        VLR_YOUYI                     = 177,               // ����ͳ�
        VLR_SHANGRAO                  = 178,               // ���Ŀͳ�
        VLR_JIJIANG                   = 179,               // ����
        VLR_YANGZI                    = 180,               // ���ӿͳ�
        VLR_XIWO                      = 181,               // ���ֿͳ�
        VLR_CHANGJIANG                = 182,               // �����ͳ�
        VLR_WUYI                      = 183,               // ����
        VLR_CHENGDU                   = 184,               // �ɶ��ͳ�
        VLR_TIANMA                    = 185,               // ����
        VLR_BAOLONG                   = 186,               // ����
        VLR_NEWYATU                   = 187,               // ����;
        VLR_BARUI                     = 188,               // ���ǰ���
        VLR_GUANZHI                   = 189,               // ����
        VLR_XIYATE                    = 190,               // ������
        VLR_BINLI                     = 191,               // ����
        VLR_DADI                      = 192,               // ���
        VLR_FUQI                      = 193,               // ����
        VLR_HANGTIAN                  = 194,               // ��������
        VLR_HENGTIAN                  = 195,               // ��������
        VLR_JMCCAR                    = 196,               // ��������
        VLR_KAERSEN                   = 197,               // ����ɭ����
        VLR_KAWEI                     = 198,               // ��������
        VLR_LANBOJINI                 = 199,               // ��������
        VLR_MASHALADI                 = 200,               // ��ɯ����
        VLR_SHUCHI                    = 201,               // ��ۿͳ�
        VLR_SHILI                     = 202,               // ʵ���ͳ�
        VLR_HUABEI                    = 203,               // �пͻ���
        VLR_YIZHENG                   = 204,               // ��������
        VLR_CHUNLAN                   = 205,               // ��������
        VLR_DAFA                      = 206,               // ������
        VLR_SHENYE                    = 207,               // ��Ұ����
        VLR_FALALI                    = 208,               // ����������
        VLR_FUXING                    = 209,               // ��������
        VLR_ANYUAN                    = 210,               // ��Դ�ͳ�
        VLR_JINGHUA                   = 211,               // �����ͳ�
        VLR_TAIHU                     = 212,               // ̫���ͳ�
        VLR_WUZHOULONG                = 213,               // ������
        VLR_CHANGLONG                 = 214,               // ��¡�ͳ�
        VLR_YUEXI                     = 215,               // �����ͳ�
        VLR_SHENMA                    = 216,               // ����ͳ�
        VLR_LUSHAN                    = 217,               // ®ɽ��
        VLR_WANFENG                   = 218,               // �����
        VLR_GZYUNBAO                  = 219,               // �����Ʊ�
        VLR_ZHONGDA                   = 220,               // �д�����
        VLR_THREEWHEEL                = 221,               // ���ֳ�
        VLR_TWOWHEEL                  = 222,               // ���ֳ�
        VLR_JBC                       = 223,              // ��JBC
        VLR_YZJIANG                   = 224,               // ���ӽ��ͳ�
        VLR_CNJ                       = 225,               // �Ͽ�CNJ
        VLR_FORLAND                   = 226,               // ����ʱ������
        VLR_FARMCAR                   = 227,               // ũ�ó�
        VLR_DONGFANGHONG              = 228,               // ������
        VLR_STEYR                     = 229,               // ˹̫������
        VLR_HONGQI                    = 230,               // ����
        VLR_USER1       = 231,   //�û�1
        VLR_USER2       = 232,   //�û�2
        VLR_USER3       = 233,   //�û�3
        VLR_USER4       = 234,   //�û�4
        VLR_USER5       = 235,   //�û�5
        VLR_USER6       = 236,   //�û�6
        VLR_USER7       = 237,   //�û�7
        VLR_USER8       = 238    //�û�8
}VLR_VEHICLE_CLASS;

/********************����Ʒ��������Begin*************************/
//������Ʒ������
typedef enum _VSB_VOLKSWAGEN_CLASS
{
    VSB_VOLKSWAGEN_OTHER          = 0,   // ������������
        VSB_VOLKSWAGEN_LAVIDA         = 1,   // ����
        VSB_VOLKSWAGEN_CROSSLAVIDA    = 2,   // �ʾ�
        VSB_VOLKSWAGEN_TIGUAN         = 3,   // ;��
        VSB_VOLKSWAGEN_TOURAN         = 4,   // ;��
        VSB_VOLKSWAGEN_SANTANA        = 5,   // ɣ����
        VSB_VOLKSWAGEN_SANTANA2000    = 6,   // ɣ����2000
        VSB_VOLKSWAGEN_SANTANA3000    = 7,   // ɣ����3000
        VSB_VOLKSWAGEN_VISTA          = 8,   // ɣ����-־��
        VSB_VOLKSWAGEN_PASSAT         = 9,   // ������
        VSB_VOLKSWAGEN_PASSATLINGYU   = 10,  // ������-��Ԧ
        VSB_VOLKSWAGEN_POLO           = 11,  // ����
        VSB_VOLKSWAGEN_POLOCROSS      = 12,  // ����-�˶���
        VSB_VOLKSWAGEN_POLOGTI        = 13,  // ����-GTI
        VSB_VOLKSWAGEN_SAGITAR        = 14,  // ����
        VSB_VOLKSWAGEN_MAGOTAN        = 15,  // ����
        VSB_VOLKSWAGEN_JETTA          = 16,  // �ݴ�
        VSB_VOLKSWAGEN_BORA           = 17,  // ����
        VSB_VOLKSWAGEN_NEWGOLF        = 18,  // �¸߶���
        VSB_VOLKSWAGEN_GOLFGTI        = 19,  // �߶���-GTI
        VSB_VOLKSWAGEN_GOL            = 20,  // �߶�
        VSB_VOLKSWAGEN_CADDY          = 21,  // ����
        VSB_VOLKSWAGEN_PHAETON        = 22,  // ����
        VSB_VOLKSWAGEN_TOUREG         = 23,  // ;��
        VSB_VOLKSWAGEN_SCIROCCO       = 24,  // �п�
        VSB_VOLKSWAGEN_BEETLE         = 25,  // �׿ǳ�
        VSB_VOLKSWAGEN_SHARAN         = 26,  // ����
        VSB_VOLKSWAGEN_MULTIVAN       = 27,  // ������
        VSB_VOLKSWAGEN_CARBONCOPY     = 28,  // һ������-CC
        VSB_VOLKSWAGEN_VISTACHANGDA   = 29,  // ɣ����־��-����
        VSB_VOLKSWAGEN_BORASPORTLINE  = 30,   // ����-SPORTLINE
        VSR_VOLKSWAGEN_CC_1             =31,   //����-CC-2012,2011,2010
        VSR_VOLKSWAGEN_Cross_POLO_1     = 32,   //����-Cross-POLO-2010,2007
        VSR_VOLKSWAGEN_Cross_POLO_2     = 33,   //����-Cross-POLO-2014,2012
        VSR_VOLKSWAGEN_MULTIVAN_1       = 34,   //����-Multivan-2014,2012,2011
        VSR_VOLKSWAGEN_POLO_1           = 35,   //����-POLO-2006,2005,2004,2003,2002
        VSR_VOLKSWAGEN_POLO_2           = 36,   //����-POLO-2013,2012,2011
        VSR_VOLKSWAGEN_POLO_JINQU_1     = 37,   //����-POLO��ȡ-2009,2008,2007,2006
        VSR_VOLKSWAGEN_POLO_JINQU_2     = 38,   //����-POLO��ȡ-2011
        VSR_VOLKSWAGEN_Tiguan_1         = 39,   //����-Tiguan-2011,2009
        VSR_VOLKSWAGEN_Tiguan_2         = 40,   //����-Tiguan-2014,2013,2012
        VSR_VOLKSWAGEN_XIALANG_1        = 41,   //����-����-2013,2012
        VSR_VOLKSWAGEN_BAOLAI_1         = 42,   //����-����-2005,2004
        VSR_VOLKSWAGEN_BAOLAI_2         = 43,   //����-����-2006
        VSR_VOLKSWAGEN_BAOLAI_3         = 44,   //����-����-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_BAOLAI_4         = 45,   //����-����-2014,2013
        VSR_VOLKSWAGEN_SHANGKU_1        = 46,   //����-�п�-2014,2013
        VSR_VOLKSWAGEN_PASATE_1         = 47,   //����-������-2003����,2001��Ԧ
        VSR_VOLKSWAGEN_PASATE_2         = 48,   //����-������-2007,2006,2005��Ԧ
        VSR_VOLKSWAGEN_PASATE_3         = 49,   //����-������-2009,2008,2007,2005,2004,2003,2001,2000
        VSR_VOLKSWAGEN_PASATE_4         = 50,   //����-������-2011,2009��Ԧ
        VSR_VOLKSWAGEN_PASATE_5         = 51,   //����-������-2014,2013,2012,2011
        VSR_VOLKSWAGEN_JIEDA_1          = 52,   //����-�ݴ�-2005CIF���,2002
        VSR_VOLKSWAGEN_JIEDA_2          = 53,   //����-�ݴ�-2009,2008,2006,2005,2004
        VSR_VOLKSWAGEN_JIEDA_3          = 54,   //����-�ݴ�-2012,2010
        VSR_VOLKSWAGEN_JIEDA_4          = 55,   //����-�ݴ�-2013
        VSR_VOLKSWAGEN_LANGYI_1         = 56,   //����-����-2012,2011,2010,2009,2008
        VSR_VOLKSWAGEN_LANGYI_2         = 57,   //����-����-2013
        VSR_VOLKSWAGEN_SANGTANA_1       = 58,   //����-ɣ����-2007,2002,2000,1999,1995
        VSR_VOLKSWAGEN_SANGTANA_2       = 59,   //����-ɣ����-2014,2013
        VSR_VOLKSWAGEN_SANGTANA_3       = 60,   //����-ɣ����2000-2003,2001,2000,1999,1998,1996
        VSR_VOLKSWAGEN_SANGTANA_4       = 61,   //����-ɣ����3000-2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_1 = 62,   //����-ɣ����־��(vista)-2011,2010,2009,2008
        VSR_VOLKSWAGEN_SANGTANAZHIJUN_2 = 63,   //����-ɣ����־��(vista)-2006
        VSR_VOLKSWAGEN_JIAKECHONG_1     = 64,   //����-�׿ǳ�-2010,2009,2008,2007,2006,2005
        VSR_VOLKSWAGEN_JIAKECHONG_2     = 65,   //����-�׿ǳ�-2014,2013
        VSR_VOLKSWAGEN_HUITENG_2        = 66,   //����-����-2010,2009,2007,2006
        VSR_VOLKSWAGEN_MAITENG_1        = 67,   //����-����-2011,2010,2009,2008,2007
        VSR_VOLKSWAGEN_MAITENG_2        = 68,   //����-����-2013,2012
        VSR_VOLKSWAGEN_TUAN_3           = 69,   //����-;��-2006,2005,2004
        VSR_VOLKSWAGEN_TUAN_1           = 70,   //����-;��-2010,2009,2008
        VSR_VOLKSWAGEN_TUAN_2           = 71,   //����-;��-2013,2012,2011
        VSR_VOLKSWAGEN_TUGUAN_1         = 72,   //����-;��-2012,2011,2010
        VSR_VOLKSWAGEN_TURUI_1          = 73,   //����-;��-2006,2005,2003
        VSR_VOLKSWAGEN_TURUI_2          = 74,   //����-;��-2014,2013,2012,2011
        VSR_VOLKSWAGEN_SUTENG_1         = 75,   //����-����-2010,2009,2007,2006
        VSR_VOLKSWAGEN_SUTENG_2         = 76,   //����-����-2011
        VSR_VOLKSWAGEN_SUTENG_3         = 77,   //����-����-2014,2013,2012
        VSR_VOLKSWAGEN_GAOERFU_1        = 78,   //����-�߶���-2008,2007,2006,2005,2004,2003
        VSR_VOLKSWAGEN_GAOERFU_2        = 79,   //����-�߶���-2012,2011����,2012,2011,2010
        VSR_VOLKSWAGEN_GAOERFU_3        = 80,   //����-�߶���GTI-2013,2012,2011,2010
        VSR_VOLKSWAGEN_LANGYI_3         = 81,   //����-����-2014
        VSR_VOLKSWAGEN_HUITENG_1        = 82   //����-����-2004
} VSB_VOLKSWAGEN_CLASS;

//�����Ʒ������
typedef enum _VBR_BUICK_CLASS
{
    VBR_BUICK_OTHER        = 0,   // ������������
        VBR_BUICK_ENCORE       = 1,   // ������
        VBR_BUICK_GL8          = 2,   // GL8
        VBR_BUICK_LEGAL        = 3,   // ����
        VBR_BUICK_LACROSS      = 4,   // ��Խ
        VBR_BUICK_EXCELLE      = 5,   // ��Խ
        VBR_BUICK_EXCELLEGT    = 6,   // Ӣ��GT
        VBR_BUICK_WXCELLEXT    = 7,   // Ӣ��XT
        VBR_BUICK_ENCLAVE      = 8,   // ������
        VBR_BUICK_ROYAUM       = 9,   // ����
        VBR_BUICK_SAIL         = 10,  // �����ŷ
        VBR_BUICK_EXCELLEHRV   = 11,  // ��ԽHRV
        VBR_BUICK_PARKAVENUE   = 12,  // ������
        VBR_BUICK_CENTURY      = 13,   // ������
        VBR_BUICK_GL8_1          = 14,   // ���-GL8-2004,2003
        VBR_BUICK_GL8_2          = 15,   // ���-GL8-2007,2006,2005
        VBR_BUICK_GL8_3          = 16,   // ���-GL8-2010_2008_2006_2005½��
        VBR_BUICK_GL8_4          = 17,   // ���-GL8-2014,2013,2012,2011
        VBR_BUICK_GL8_5          = 18,   // ���-GL8-2014_2013_2011������
        VBR_BUICK_ENCORE_1       = 19,   // ���-������-2014,2013
        VBR_BUICK_ENCLAVE_1      = 20,   // ���-������-2013,2010,2009
        VBR_BUICK_LEGAL_1        = 21,   // ���-����-2001,2000,1999
        VBR_BUICK_LEGAL_2        = 22,   // ���-����-2008,2006,2005,2004,2002
        VBR_BUICK_LEGAL_3        = 23,   // ���-����-2013,2012,2011,2010,2009
        VBR_BUICK_LEGAL_4        = 24,   // ���-����-2013_2012_2011�˶���
        VBR_BUICK_LEGAL_5        = 25,   // ���-����-2014
        VBR_BUICK_LEGAL_6        = 26,   // ���-����-2014�˶���
        VBR_BUICK_LACROSS_1      = 27,   // ���-��Խ-2008,2007,2006
        VBR_BUICK_LACROSS_2      = 28,   // ���-��Խ-2012,2011,2010,2009
        VBR_BUICK_LACROSS_3      = 29,   // ���-��Խ-2013
        VBR_BUICK_EXCELLE_1      = 30,   // ���-��Խ-2006,2005,2004
        VBR_BUICK_EXCELLE_2      = 31,   // ���-��Խ-2008_2006_2005_2004HRV
        VBR_BUICK_EXCELLE_3      = 32,   // ���-��Խ-2011,2009,2008
        VBR_BUICK_EXCELLE_4      = 33,   // ���-��Խ-2013
        VBR_BUICK_PARKAVENUE_1   = 34,   // ���-������-2011,2010,2009,2008,2007
        VBR_BUICK_SAIL_1         = 35,   // ���-��ŷ-2004,2003
        VBR_BUICK_EXCELLEGT_1    = 36,   // ���-Ӣ��GT-2013,2012,2011,2010
        VBR_BUICK_WXCELLEXT_1    = 37,   // ���-Ӣ��XT-2014,2013,2012,2010
        VBR_BUICK_CENTURY_1      = 38,   // ���-������-2000
        VBR_BUICK_RONGYU_1       = 39   // ���-����-2005,2004
}VBR_BUICK_CLASS;

//������Ʒ������
typedef enum _VSB_BMW_CLASS
{
    VSB_BMW_OTHER       = 0,   // ������������
        VSB_BMW_3SERIES     = 1,   // ����3ϵ
        VSB_BMW_5SERIES     = 2,   // ����5ϵ
        VSB_BMW_X1          = 3,   // ����X1
        VSB_BMW_1SERIES     = 4,   // ����1ϵ
        VSB_BMW_7SERIES     = 5,   // ����7ϵ
        VSB_BMW_X3          = 6,   // ����X3
        VSB_BMW_X5          = 7,   // ����X5
        VSB_BMW_X6          = 8,   // ����X6
        VSB_BMW_Z4          = 9,   // ����Z4
        VSB_BMW_MINI        = 10,  // ����
        VSB_BMW_6SERIES     = 11,   //����6ϵ
        VSB_BMW_YIXI_1      = 12,     // ����-1ϵ-2011,2010,2008,2007
        VSB_BMW_YIXI_2      = 13,     // ����-1ϵ-2013,2012
        VSB_BMW_SANXI_1     = 14,     // ����-3ϵ-2004
        VSB_BMW_SANXI_2     = 15,     // ����-3ϵ-2007,2005
        VSB_BMW_SANXI_3     = 16,     // ����-3ϵ-2012,2011,2010,2009
        VSB_BMW_SANXI_4     = 17,     // ����-3ϵ-2014,2013
        VSB_BMW_WUXI_1      = 18,     // ����-5ϵ-2010,2009,2008
        VSB_BMW_WUXI_2      = 19,     // ����-5ϵ-2013,2012,2011
        VSB_BMW_LIUXI_1     = 20,     // ����-6ϵ-δ֪
        VSB_BMW_QIXI_1      = 21,     // ����-7ϵ-2011,2010,2009
        VSB_BMW_QIXI_2      = 22,     // ����-7ϵ-2013
        VSB_BMW_X1_1        = 23,     // ����-X1-2012,2010
        VSB_BMW_X1_2        = 24,     // ����-X1-2014,2013
        VSB_BMW_X3_1        = 25,     // ����-X3-2009,2008,2006
        VSB_BMW_X3_2        = 26,     // ����-X3-2013,2012,2011
        VSB_BMW_X5_1        = 27,     // ����-X5-2010,2009,2008
        VSB_BMW_X5_2        = 28,     // ����-X5-2013,2012,2011
        VSB_BMW_X5_3        = 29,     // ����-X5-2013�˶���
        VSB_BMW_X6_1        = 30,     // ����-X6-2013,2012,2011,2009,2008
        VSB_BMW_Z4_1        = 31     // ����-Z4-2004
}VSB_BMW_CLASS;

//������Ʒ������
typedef enum _VSB_HONDA_CLASS
{
    VSB_HONDA_OTHER       = 0,   // ������������
        VSB_HONDA_CRV         = 1,   // ����CR-V(˼��)
        VSB_HONDA_JADE        = 2,   // �ܵ�
        VSB_HONDA_CIVIC       = 3,   // ˼��
        VSB_HONDA_SPIRIOR     = 4,   // ˼���
        VSB_HONDA_CIIMO       = 5,   // ˼��
        VSB_HONDA_ELYSION     = 6,   // ������
        VSB_HONDA_OBYSSEY     = 7,   // ������
        VSB_HONDA_FIT         = 8,   // �ɶ�
        VSB_HONDA_NEWCITY     = 9,   // �淶
        VSB_HONDA_CROSSTOUR   = 10,  // ��ʫͼ
        VSB_HONDA_CRIDER      = 11,  // ����
        VSB_HONDA_ACCORD      = 12,  // �Ÿ�
        VSB_HONDA_CITY        = 13,  // ˼��
        VSB_HONDA_ANTILOCK    = 14,  // ���µ�
        VSB_HONDA_CRZ         = 15,   // ����CR-Z
        VSB_HONDA_CRV_1       = 16,   // ����-CR-V-2004
        VSB_HONDA_CRV_2       = 17,   // ����-CR-V-2005
        VSB_HONDA_CRV_3       = 18,   // ����-CR-V-2008,2007
        VSB_HONDA_CRV_4       = 19,   // ����-CR-V-2010
        VSB_HONDA_CRV_5       = 20,   // ����-CR-V-2013,2012
        VSB_HONDA_CRIDER_1    = 21,   // ����-����-2014,2013
        VSB_HONDA_OBYSSEY_1   = 22,   // ����-�µ���-2002
        VSB_HONDA_OBYSSEY_2   = 23,   // ����-�µ���-2006,2005,2004
        VSB_HONDA_OBYSSEY_3   = 24,   // ����-�µ���-2008,2007
        VSB_HONDA_OBYSSEY_4   = 25,   // ����-�µ���-2011������
        VSB_HONDA_CIVIC_1     = 26,   // ����-˼��-2007
        VSB_HONDA_CIVIC_5     = 27,   // ����-˼��-1996
        VSB_HONDA_CIVIC_2     = 28,   // ����-˼��-2008,2006
        VSB_HONDA_CIVIC_3     = 29,   // ����-˼��-2009
        VSB_HONDA_CIVIC_4     = 30,   // ����-˼��-2013,2012,2011
        VSB_HONDA_CITY_1      = 31,   // ����-˼��-2008,2007,2006
        VSB_HONDA_SPIRIOR_1   = 32,   // ����-˼���-2009
        VSB_HONDA_SIMING_1    = 33,   // ����-˼��-2012
        VSB_HONDA_JIEDE_1     = 34,   // ����-�ܵ�-2013
        VSB_HONDA_CROSSTOUR_1 = 35,   // ����-��ʫͼ-2013,2012,2010
        VSB_HONDA_AILISHEN_1  = 36,   // ����-������-2012
        VSB_HONDA_NEWCITY_1   = 37,   // ����-�淶-2009
        VSB_HONDA_NEWCITY_2   = 38,   // ����-�淶-2011
        VSB_HONDA_NEWCITY_3   = 39,   // ����-�淶-2014,2012
        VSB_HONDA_ACCORD_1    = 40,   // ����-�Ÿ�-1996
        VSB_HONDA_ACCORD_2    = 41,   // ����-�Ÿ�-1999
        VSB_HONDA_ACCORD_3    = 42,   // ����-�Ÿ�-2001
        VSB_HONDA_ACCORD_4    = 43,   // ����-�Ÿ�-2003
        VSB_HONDA_ACCORD_5    = 44,   // ����-�Ÿ�-2008
        VSB_HONDA_ACCORD_6    = 45,   // ����-�Ÿ�-2010
        VSB_HONDA_ACCORD_7    = 46,   // ����-�Ÿ�-2011
        VSB_HONDA_ACCORD_8    = 47,   // ����-�Ÿ�-2012
        VSB_HONDA_ACCORD_9    = 48,   // ����-�Ÿ�-2013
        VSB_HONDA_ACCORD_10   = 49,   // ����-�Ÿ�-2014
        VSB_HONDA_FIT_1       = 50,   // ����-�ɶ�-2004
        VSB_HONDA_FIT_2       = 51,   // ����-�ɶ�-2004����
        VSB_HONDA_FIT_3       = 52,   // ����-�ɶ�-2005
        VSB_HONDA_FIT_4       = 53,   // ����-�ɶ�-2007
        VSB_HONDA_FIT_5       = 54,   // ����-�ɶ�-2008
        VSB_HONDA_FIT_6       = 55   // ����-�ɶ�-2013,2011
}VSB_HONDA_CLASS;

//������Ʒ������
typedef enum _VSB_PEUGEOT_CLASS
{
    VSB_PEUGEOT_OTHER      = 0,   // ������������
        VSB_PEUGEOT_2008       = 1,   // ����2008
        VSB_PEUGEOT_207        = 2,   // ����207
        VSB_PEUGEOT_SENNA      = 3,   // ����
        VSB_PEUGEOT_3008       = 4,   // ����3008
        VSB_PEUGEOT_301        = 5,   // ����301
        VSB_PEUGEOT_307        = 6,   // ����307
        VSB_PEUGEOT_308        = 7,   // ����308
        VSB_PEUGEOT_408        = 8,   // ����408
        VSB_PEUGEOT_508        = 9,   // ����508
        VSB_PEUGEOT_206        = 10,  // ����206
        VSB_PEUGEOT_407        = 11,   // ����407
        VSB_PEUGEOT_206_1      = 12, // ����-206-δ֪
        VSB_PEUGEOT_207_1      = 13, // ����-207����-2011,2010,2009
        VSB_PEUGEOT_207_2      = 14, // ����-207����-2013
        VSB_PEUGEOT_3008_1     = 15, // ����-3008-2014,2013
        VSB_PEUGEOT_301_1      = 16, // ����-301-δ֪
        VSB_PEUGEOT_307_1      = 17, // ����-307����-2007,2006,2005,2004
        VSB_PEUGEOT_307_2      = 18, // ����-307����-2010,2009,2008
        VSB_PEUGEOT_307_3      = 19, // ����-307����-2013_2012_2011CROSS
        VSB_PEUGEOT_308_1      = 20, // ����-308-2014,2013,2012
        VSB_PEUGEOT_407_1      = 21, // ����-407-δ֪
        VSB_PEUGEOT_408_1      = 22, // ����-408-2012,2011,2010
        VSB_PEUGEOT_408_2      = 23, // ����-408-2013
        VSB_PEUGEOT_508_1      = 24, // ����-508-2014,2013,2012,2011
        VSB_PEUGEOT_207_3      = 25, // ����-207����-2011,2010,2009
        VSB_PEUGEOT_307_4      = 26 // ����-307����-2013,2012,2010,2009,2008
        
}VSB_PEUGEOT_CLASS;

//������Ʒ������
typedef enum _VSB_TOYOTA_CLASS
{
    VSB_TOYOTA_OTHER            = 0,   // ������������
        VSB_TOYOTA_HIGHLANDER       = 1,   // ������
        VSB_TOYOTA_CAMRY            = 2,   // ������
        VSB_TOYOTA_YARIS            = 3,   // ����ʿ
        VSB_TOYOTA_YARISL           = 4,   // YARIS L����
        VSB_TOYOTA_VERSO            = 5,   // ����
        VSB_TOYOTA_HUAGUAN          = 6,   // ����
        VSB_TOYOTA_CROWN            = 7,   // �ʹ�
        VSB_TOYOTA_COROLLA          = 8,   // ������
        VSB_TOYOTA_COSTER           = 9,   // ��˹��
        VSB_TOYOTA_PRADO            = 10,  // ������
        VSB_TOYOTA_PRIUS            = 11,  // ����˹
        VSB_TOYOTA_RAV4             = 12,  // ����RAV4
        VSB_TOYOTA_REZI             = 13,  // ��־
        VSB_TOYOTA_VIOS             = 14,  // ����
        VSB_TOYOTA_PREVIA           = 15,  // ����ά��
        VSB_TOYOTA_HIACE            = 16,  // ��ʨ
        VSB_TOYOTA_86               = 17,  // ����86
        VSB_TOYOTA_SPEQUOIA         = 18,  // ��ɼ
        VSB_TOYOTA_LANDCRUISER      = 19,  // ½��Ѳ��(���¿�·��)
        VSB_TOYOTA_SIENNA           = 20,  // ����
        VSB_TOYOTA_CAMRYHYBRID      = 21,  // ������-HYBRID
        VSB_TOYOTA_GRACE            = 22,  // ����˹
        VSB_TOYOTA_ALPHARD          = 23,   // ������
        VSB_TOYOTA_RAV4_1           = 24,   // ����-RAV4-2012�ֶ������,2011,2010,2009
        VSB_TOYOTA_RAV4_2           = 25,   // ����-RAV4-2013
        VSB_TOYOTA_86_1             = 26,   // ����-����86-δ֪
        VSB_TOYOTA_JIAMEI_2         = 27,   // ����-����-2001,2000,1999,1998
        VSB_TOYOTA_JIAMEI_3         = 28,   // ����-����-2004,2003,2002
        VSB_TOYOTA_LANDEKLZ_1       = 29,   // ����-���¿�·��-2011�ж���,2010,2007
        VSB_TOYOTA_KAIMEIRUI_1      = 30,   // ����-������-2008,2007,2006
        VSB_TOYOTA_KAIMEIRUI_2      = 31,   // ����-������-2012����
        VSB_TOYOTA_KAIMEIRUI_3      = 32,   // ����-������-2012�����,2011,2010,2009
        VSB_TOYOTA_KAIMEIRUI_4      = 33,   // ����-������-2013,2012
        VSB_TOYOTA_KAIMEIRUI_5      = 34,   // ����-������-2013�����
        VSB_TOYOTA_KAIMEIRUI_6      = 35,   // ����-������-2014,2012����
        VSB_TOYOTA_KALUOLA_1        = 36,   // ����-������-2010,2009,2008,2007,2006
        VSB_TOYOTA_KALUOLA_2        = 37,   // ����-������-2013,2012,2011
        VSB_TOYOTA_AIERFA_1         = 38,   // ����-������-2011,2010
        VSB_TOYOTA_AIERFA_2         = 39,   // ����-������-2013,2012
        VSB_TOYOTA_WEICHI_1         = 40,   // ����-����-2004,2003
        VSB_TOYOTA_WEICHI_2         = 41,   // ����-����-2007,2006,2005
        VSB_TOYOTA_WEICHI_3         = 42,   // ����-����-2009,2008
        VSB_TOYOTA_WEICHI_4         = 43,   // ����-����-2013,2012,2011,2010
        VSB_TOYOTA_WEICHI_5         = 44,   // ����-����-2014
        VSB_TOYOTA_PULADUO_1        = 45,   // ����-������-2007,2006,2005,2004
        VSB_TOYOTA_PULADUO_2        = 46,   // ����-������-2010
        VSB_TOYOTA_PULADUO_3        = 47,   // ����-������-2014
        VSB_TOYOTA_PURUIWEIYA_1     = 48,   // ����-����ά��-2004
        VSB_TOYOTA_PURUIWEIYA_4     = 49,   // ����-����ά��-2005
        VSB_TOYOTA_PURUIWEIYA_2     = 50,   // ����-����ά��-2006
        VSB_TOYOTA_PURUIWEIYA_3     = 51,   // ����-����ά��-2012,2010,2008,2007
        VSB_TOYOTA_KESIDA_1         = 52,   // ����-��˹��-2007
        VSB_TOYOTA_KESIDA_2         = 53,   // ����-��˹��-2011
        VSB_TOYOTA_HANLANDA_1       = 54,   // ����-������-2011,2009
        VSB_TOYOTA_HANLANDA_2       = 55,   // ����-������-2012
        VSB_TOYOTA_HANLANDA_3       = 56,   // ����-������-2013
        VSB_TOYOTA_HAISHI_1         = 57,   // ����-��ʨ-2001
        VSB_TOYOTA_HUANGGUAN_1      = 58,   // ����-�ʹ�-1999
        VSB_TOYOTA_HUANGGUAN_2      = 59,   // ����-�ʹ�-2009,2008,2007,2006,2005
        VSB_TOYOTA_HUANGGUAN_3      = 60,   // ����-�ʹ�-2010
        VSB_TOYOTA_HUANGGUAN_4      = 61,   // ����-�ʹ�-2012,2011
        VSB_TOYOTA_HONGSHAN_1       = 62,   // ����-��ɼ-δ֪
        VSB_TOYOTA_HUAGUAN_1        = 63,   // ����-����-2006,2005,2004
        VSB_TOYOTA_HUAGUAN_2        = 64,   // ����-����-2009,2008,2007
        VSB_TOYOTA_HUAGUAN_3        = 65,   // ����-����-2011,2010
        VSB_TOYOTA_YIZHI_1          = 66,   // ����-����-2014,2012,2011
        VSB_TOYOTA_RUIZHI_1         = 67,   // ����-��־-2006,2005
        VSB_TOYOTA_RUIZHI_2         = 68,   // ����-��־-2009,2008,2007
        VSB_TOYOTA_RUIZHI_3         = 69,   // ����-��־-2010��Ȱ�
        VSB_TOYOTA_RUIZHI_4         = 70,   // ����-��־-2012,2010
        VSB_TOYOTA_LUDIXUNYANG_1    = 71,   // ����-½��Ѳ��-δ֪
        VSB_TOYOTA_YALISHI_1        = 72,   // ����-����ʿ-2009,2008,2007
        VSB_TOYOTA_YALISHI_2        = 73,   // ����-����ʿ-2012,2011,2010
        VSB_TOYOTA_RAV4_3           = 74,   // ����-RAV4-2013����,��Ӣ,���,2012
        VSB_TOYOTA_YARiSL_1         = 75,   // ����-YARiS-L
        VSB_TOYOTA_JIAMEI_1         = 76,   // ����-����-1996
        VSB_TOYOTA_PLATZ_1          = 77,   // ����-PLATZ-1999
        VSB_TOYOTA_LANDEKLZ_2       = 78   // ����-���¿�·��-2014,2012�ж���,2012
}VSB_TOYOTA_CLASS;

//������Ʒ������
typedef enum _VSB_FORD_CLASS
{
    VSB_FORD_OTHER       = 0,   // ������������
        VSB_FORD_FOCUS       = 1,   // ����˹
        VSB_FORD_FIESTA      = 2,   // ���껪
        VSB_FORD_SMAX        = 3,   // ���˹
        VSB_FORD_MONDEO      = 4,   // �ɵ�ŷ
        VSB_FORD_ECOSPORT    = 5,   // ��
        VSB_FORD_ESCAPE      = 6,   // ��
        VSB_FORD_ZHISHENG    = 7,   // ��ʤ
        VSB_FORD_ESCORT      = 8,   // ���˹
        VSB_FORD_EXPLORER    = 9,   // ����̽����
        VSB_FORD_EDGE        = 10,  // ���
        VSB_FORD_TRANSIT     = 11,   // ȫ˳
        VSB_FORD_QUANSHUN_1      = 12,    // ����-ȫ˳-δ֪
        VSB_FORD_JIANIANHUA_1    = 13,    // ����-���껪����-2006,2005,2004
        VSB_FORD_JIANIANHUA_2    = 14,    // ����-���껪����-2011,2010,2009
        VSB_FORD_JIANIANHUA_3    = 15,    // ����-���껪����-2013
        VSB_FORD_JIANIANHUA_4    = 16,    // ����-���껪����-2012
        VSB_FORD_TANXIANZHE_1    = 17,    // ����-̽����-2013,2011
        VSB_FORD_FOCUS_1         = 18,    // ����-����˹����-2005
        VSB_FORD_FOCUS_2         = 19,    // ����-����˹����-2005������
        VSB_FORD_FOCUS_3         = 20,    // ����-����˹����-2008,2007,2006
        VSB_FORD_FOCUS_4         = 21,    // ����-����˹����-2013,2012����,2011,2009
        VSB_FORD_FOCUS_5         = 22,    // ����-����˹����-2012
        VSB_FORD_FOCUS_6         = 23,    // ����-����˹����-2012����,ʱ��,2011,2010,2009,2008
        VSB_FORD_YIBO_1          = 24,    // ����-��-2013
        VSB_FORD_YIHU_1          = 25,    // ����-��-2013
        VSB_FORD_MENGDIOU_1      = 26,    // ����-�ɵ�ŷ-2003
        VSB_FORD_MENGDIOU_2      = 27,    // ����-�ɵ�ŷ-2005,2004
        VSB_FORD_MENGDIOU_3      = 28,    // ����-�ɵ�ŷ-2006
        VSB_FORD_MENGDIOU_4      = 29,    // ����-�ɵ�ŷ-2013
        VSB_FORD_MENGDIOU_5      = 30,    // ����-�ɵ�ŷ-��ʤ-2010,2008,2007
        VSB_FORD_MENGDIOU_6      = 31,    // ����-�ɵ�ŷ-��ʤ-2011
        VSB_FORD_RUIJIE_1        = 32,    // ����-���-2012,2011
        VSB_FORD_MAIKESI_1       = 33    // ����-���˹-2008,2007
}VSB_FORD_CLASS;

//�ղ���Ʒ������
typedef enum _VSB_NISSAN_CLASS
{
    VSB_NISSAN_OTHER              = 0,   // ������������
        VSB_NISSAN_XTRAIL             = 1,   // �濥
        VSB_NISSAN_MURANO             = 2,   // ¥��
        VSB_NISSAN_LIVINA             = 3,   // ����
        VSB_NISSAN_MARCH              = 4,   // ���
        VSB_NISSAN_TIIDA              = 5,   // ���
        VSB_NISSAN_TEANA              = 6,   // ����
        VSB_NISSAN_QASHQAI            = 7,   // �п�
        VSB_NISSAN_SYLPHY             = 8,   // ����
        VSB_NISSAN_SUNNY              = 9,   // ����
        VSB_NISSAN_D22PICKUP          = 10,  // D22Ƥ��
        VSB_NISSAN_D22VAN             = 11,  // D22��ʽ��
        VSB_NISSAN_CABSTAR            = 12,  // ����˹��
        VSB_NISSAN_HV200              = 13,  // NV200
        VSB_NISSAN_PALADIN            = 14,  // ������
        VSB_NISSAN_YIDA               = 15,  // �ô�
        VSB_NISSAN_DUCK               = 16,  // ����
        VSB_NISSAN_CEFIRO             = 17,  // ���
        VSB_NISSAN_FENGSHENBLUEBIRD   = 18,  // ��������
        VSB_NISSAN_FENGSHENSUNNY      = 19,  // ��������
        VSB_NISSAN_SUCCE              = 20,  // ˧��
        VSB_NISSAN_FUGA               = 21,  // ����
        VSB_NISSAN_BLUEBIRD4          = 22,  // ����4��
        VSB_NISSAN_VENUCIA            = 23,  // ����
        VSB_NISSAN_QUEST              = 24,  // ��ʿ
        VSB_NISSAN_GENISS             = 25,   // ����
        VSB_NISSAN_NV200_1            = 26,  // �ղ�-NV200-2013,2012,2011,2010
        VSB_NISSAN_TIANLAI_1          = 27,  // �ղ�-����-2005,2004
        VSB_NISSAN_TIANLAI_2          = 28,  // �ղ�-����-2007,2006
        VSB_NISSAN_TIANLAI_3          = 29,  // �ղ�-����-2010,2008
        VSB_NISSAN_TIANLAI_4          = 30,  // �ղ�-����-2012,2011
        VSB_NISSAN_TIANLAI_5          = 31,  // �ղ�-����-2012�ư�ȫ��,2011����
        VSB_NISSAN_TIANLAI_6          = 32,  // �ղ�-����-2014,2013
        VSB_NISSAN_QIJUN_1            = 33,  // �ղ�-�濥-2010,2008
        VSB_NISSAN_QIJUN_2            = 34,  // �ղ�-�濥-2012,2011����
        VSB_NISSAN_PALADING_1         = 35,  // �ղ�-������-2013,2011,2006,2004
        VSB_NISSAN_LOULAN_1           = 36,  // �ղ�-¥��-2013,2011
        VSB_NISSAN_LOULAN_2           = 37,  // �ղ�-���-2010
        VSB_NISSAN_LANNIAO_1          = 38,  // �ղ�-����-2002
        VSB_NISSAN_LANNIAO_2          = 39,  // �ղ�-����-2003
        VSB_NISSAN_LANNIAO_3          = 40,  // �ղ�-����-2004
        VSB_NISSAN_GUISHI_1           = 41,  // �ղ�-��ʿ-2005
        VSB_NISSAN_XUANYI_1           = 42,  // �ղ�-����-2006
        VSB_NISSAN_XUANYI_2           = 43,  // �ղ�-����-2012����,2009,2007
        VSB_NISSAN_XUANYI_3           = 44,  // �ղ�-����-2014,2012
        VSB_NISSAN_XIAOKE_1           = 45,  // �ղ�-�п�-2009,2008
        VSB_NISSAN_XIAOKE_2           = 46,  // �ղ�-�п�-2013,2012,2011
        VSB_NISSAN_SUNNY_3            = 47,  // �ղ�-����-2004
        VSB_NISSAN_SUNNY_1            = 48,  // �ղ�-����-2006,2005
        VSB_NISSAN_SUNNY_2            = 49,  // �ղ�-����-2012,2011
        VSB_NISSAN_YIDA_1             = 50,  // �ղ�-�ô�-2008,2006,2005
        VSB_NISSAN_YIDA_2             = 51,  // �ղ�-�ô�-δ֪
        VSB_NISSAN_FENGDU_1           = 52,  // �ղ�-���-δ֪
        VSB_NISSAN_FENGYA_1           = 53,  // �ղ�-����-δ֪
        VSB_NISSAN_LIWEI_1            = 54,  // �ղ�-����-2008,2007
        VSB_NISSAN_LIWEI_2            = 55,  // �ղ�-����-2009
        VSB_NISSAN_LIWEI_3            = 56,  // �ղ�-����-2010
        VSB_NISSAN_LIWEI_4            = 57,  // �ղ�-����-2011,2010����,2008������
        VSB_NISSAN_JUNYI_1            = 58,  // �ղ�-����-2006
        VSB_NISSAN_QIDA_1             = 59,  // �ղ�-���-2006,2005
        VSB_NISSAN_QIDA_2             = 60,  // �ղ�-���-2009,2008
        VSB_NISSAN_QIDA_3             = 61,  // �ղ�-���-2013,2012,2011
        VSB_NISSAN_RUIQI_1            = 62   // �ղ�-����Ƥ��-2009������
}VSB_NISSAN_CLASS;

//�µ���Ʒ������
typedef enum _VSB_AUDI_CLASS
{
    VSB_AUDI_OTHER        = 0,   // ������������
        VSB_AUDI_A3           = 1,   // �µ�A3
        VSB_AUDI_A4L          = 2,   // �µ�A4L
        VSB_AUDI_A6L          = 3,   // �µ�A6L
        VSB_AUDI_Q3           = 4,   // �µ�Q3
        VSB_AUDI_Q5           = 5,   // �µ�Q5
        VSB_AUDI_A1           = 6,   // �µ�A1
        VSB_AUDI_A4           = 7,   // �µ�A4
        VSB_AUDI_A5           = 8,   // �µ�A5
        VSB_AUDI_A6           = 9,   // �µ�A6
        VSB_AUDI_A7           = 10,  // �µ�A7
        VSB_AUDI_A8L          = 11,  // �µ�A8L
        VSB_AUDI_Q7           = 12,  // �µ�Q7
        VSB_AUDI_S5           = 13,  // �µ�S5
        VSB_AUDI_TT           = 14,  // �µ�TT
        VSB_AUDI_100          = 15,  // �µ�100
        VSB_AUDI_200          = 16,  // �µ�200
        VSB_AUDI_S7           = 17,  // �µ�S7
        VSB_AUDI_S8           = 18,  // �µ�S8
        VSB_AUDI_100_1        = 19,   // �µ�-100-δ֪
        VSB_AUDI_200_1        = 20,   // �µ�-200-δ֪
        VSB_AUDI_A1_1         = 21,   // �µ�-A1-2014,2013,2012
        VSB_AUDI_A3_1         = 22,   // �µ�-A3-2013,2010���ʰ�
        VSB_AUDI_A3_2         = 23,   // �µ�-A3-2013������,2011,2010
        VSB_AUDI_A4_1         = 24,   // �µ�-A4-2005����,2000���ڰ�
        VSB_AUDI_A4_2         = 25,   // �µ�-A4-2007,2006����,2004����
        VSB_AUDI_A4L_1        = 26,   // �µ�-A4L-2013
        VSB_AUDI_A5_1         = 27,   // �µ�-A5-2011,2010
        VSB_AUDI_A6_1         = 28,   // �µ�-A6-1996,1995,1991
        VSB_AUDI_A6L_1        = 29,   // �µ�-A6L-2008,2007,2006,2005
        VSB_AUDI_A6L_2        = 30,   // �µ�-A6L-2011,2010,2009
        VSB_AUDI_A6L_3        = 31,   // �µ�-A6L-2014,2013,2012
        VSB_AUDI_A7_1         = 32,   // �µ�-A7-2014,2013��ȡ��,2012,2011
        VSB_AUDI_A8L_1        = 33,   // �µ�-A8L-2006
        VSB_AUDI_A8L_2        = 34,   // �µ�-A8L-2009,2008
        VSB_AUDI_A8L_3        = 35,   // �µ�-A8L-2011
        VSB_AUDI_A8L_4        = 36,   // �µ�-A8L-2013,2012
        VSB_AUDI_Q3_1         = 37,   // �µ�-Q3-2014,2013,2012
        VSB_AUDI_Q5_1         = 38,   // �µ�-Q5-2012,2010�˶� 
        VSB_AUDI_Q5_2         = 39,   // �µ�-Q5-2012������,2010ԽҰ��
        VSB_AUDI_Q5_3         = 40,   // �µ�-Q5-2012��ȡ��,2011,2010,2009
        VSB_AUDI_Q5_4         = 41,   // �µ�-Q5-2013
        VSB_AUDI_Q7_1         = 42,   // �µ�-Q7-2007
        VSB_AUDI_Q7_2         = 43,   // �µ�-Q7-2014,2013
        VSB_AUDI_S7_1         = 44,   // �µ�-S7-2013
        VSB_AUDI_S8_1         = 45,   // �µ�-S8-2013
        VSB_AUDI_TT_2         = 46,   // �µ�-TT-2010,2008,2007
        VSB_AUDI_TT_3         = 47,   // �µ�-TT-2012,2011
        VSB_AUDI_TT_4         = 48,   // �µ�-TT-2013,2013,2011TTS
        VSB_AUDI_TT_1         = 49   // �µ�-TT-2008TTS
}VSB_AUDI_CLASS;

//���Դ���Ʒ������
typedef enum _VSB_MAZDA_CLASS
{
    VSB_MAZDA_OTHER         = 0,   // ������������
        VSB_MAZDA_CX5           = 1,   // ���Դ�CX5
        VSB_MAZDA_2             = 2,   // ���Դ�2
        VSB_MAZDA_3             = 3,   // ���Դ�3
        VSB_MAZDA_6             = 4,   // ���Դ�6
        VSB_MAZDA_8             = 5,   // ���Դ�8
        VSB_MAZDA_COREWING      = 6,   // ���
        VSB_MAZDA_CX7           = 7,   // ���Դ�CX7
        VSB_MAZDA_X5            = 8,   // ���Դ�X5
        VSB_MAZDA_5             = 9,   // ���Դ�5
        VSB_MAZDA_PREMACY       = 10,  // �Ͽ�������
        VSB_MAZDA_MPV           = 11,   // ���Դ�MPV
        VSB_MAZDA_CX5_1         = 12,   // ���Դ�-CX-5-2014,2013,2012����
        VSB_MAZDA_CX7_1         = 13,   // ���Դ�-CX-7-2014,2013,2011,2010
        VSB_MAZDA_2_1           = 14,   // ���Դ�-Mazda2����-2011,2009,2008,2007A
        VSB_MAZDA_3_1           = 15,   // ���Դ�-Mazda3����-2004,2002
        VSB_MAZDA_3_2           = 16,   // ���Դ�-Mazda3����-2009,2007
        VSB_MAZDA_3_3           = 17,   // ���Դ�-Mazda3����-2012,2010
        VSB_MAZDA_3_4           = 18,   // ���Դ�-Mazda3�ǳ�����-2013,2012
        VSB_MAZDA_5_1           = 19,   // ���Դ�-Mazda5-2010,2008,2007
        VSB_MAZDA_5_2           = 20,   // ���Դ�-Mazda5-2013,2012,2011
        VSB_MAZDA_6_2           = 21,   // ���Դ�-Mazda6-2006
        VSB_MAZDA_6_3           = 22,   // ���Դ�-Mazda6-2007
        VSB_MAZDA_8_1           = 23,   // ���Դ�-Mazda8-2013,2011,2010
        VSB_MAZDA_PREMACY_1     = 24,   // ���Դ�-������-2003
        VSB_MAZDA_PREMACY_2     = 25,   // ���Դ�-������-2006,2005,2004
        VSB_MAZDA_COREWING_1    = 26,   // ���Դ�-���-2012,2011,2010,2009
        VSB_MAZDA_COREWING_2    = 27,   // ���Դ�-������-2011,2010
        VSB_MAZDA_COREWING_3    = 28,   // ���Դ�-������-2012
        VSB_MAZDA_2_2           = 29,   // ���Դ�-Mazda2����(����)-2011,2010,2008
        VSB_MAZDA_6_1           = 30,   // ���Դ�-Mazda6-2004
        VSB_MAZDA_6_4           = 31   // ���Դ�-Mazda6-2014,2013,2012,2011,2010
}VSB_MAZDA_CLASS;

//ѩ������Ʒ������
typedef enum _VSB_CHEVROLET_CLASS
{
    VSB_CHEVROLET_OTHER          = 0,   // ������������
        VSB_CHEVROLET_NEWAVEO        = 1,   // ��Ψŷ
        VSB_CHEVROLET_EPICA          = 2,   // ����
        VSB_CHEVROLET_CRUZE          = 3,   // ��³��
        VSB_CHEVROLET_CAPTIVA        = 4,   // ������
        VSB_CHEVROLET_MALIBU         = 5,   // ����
        VSB_CHEVROLET_SAIL           = 6,   // ��ŷ
        VSB_CHEVROLET_CAMARO         = 7,   // ������
        VSB_CHEVROLET_LECHENG        = 8,   // �ֳ�
        VSB_CHEVROLET_LOVA           = 9,   // �ַ�
        VSB_CHEVROLET_OLDAVEO        = 10,  // �ֳ�-�ϿΨŷ
        VSB_CHEVROLET_SPARK          = 11,  // �ֳ�
        VSB_CHEVROLET_SAILSRV        = 12,   // ��ŷSRV
        VSB_CHEVROLET_LOVA_1         = 13,   // ѩ����-�ַ�-2009,2008,2007,2006
        VSB_CHEVROLET_LOVA_2         = 14,   // ѩ����-�ַ�-2010
        VSB_CHEVROLET_SPARK_1        = 15,   // ѩ����-�ֳ�-2010,2009,2006,2005,2004
        VSB_CHEVROLET_SPARK_2        = 16,   // ѩ����-�ֳ�-2010�˶���
        VSB_CHEVROLET_OLDAVEO_1      = 17,   // ѩ����-�ֳ�-2005
        VSB_CHEVROLET_OLDAVEO_2      = 18,   // ѩ����-�ֳ�-2010,2009,2008
        VSB_CHEVROLET_EPICA_1        = 19,   // ѩ����-����-2005
        VSB_CHEVROLET_EPICA_3        = 20,   // ѩ����-����-2012,2011,2010
        VSB_CHEVROLET_EPICA_4        = 21,   // ѩ����-����-2012,2011,2010�����
        VSB_CHEVROLET_EPICA_5        = 22,   // ѩ����-����-2013
        VSB_CHEVROLET_NEWAVEO_1      = 23,   // ѩ����-��Ψŷ����-2013,2012,2011
        VSB_CHEVROLET_CAPTIVA_1      = 24,   // ѩ����-������-2010,2008
        VSB_CHEVROLET_CAPTIVA_2      = 25,   // ѩ����-������-2014,2013,2012,2011
        VSB_CHEVROLET_KEMAILUO_1     = 26,   // ѩ����-������-2012,2011
        VSB_CHEVROLET_CRUZE_1        = 27,   // ѩ����-��³��-2014,2013,2012,2011,2010,2009
        VSB_CHEVROLET_SAIL_1         = 28,   // ѩ����-��ŷ����-2005
        VSB_CHEVROLET_SAIL_2         = 29,   // ѩ����-��ŷ����-2013,2011,2010
        VSB_CHEVROLET_MALIBU_1       = 30,   // ѩ����-����-2014,2013,2012
        VSB_CHEVROLET_EPICA_2        = 31   // ѩ����-����-2009,2008,2007
}VSB_CHEVROLET_CLASS;

//ѩ������Ʒ������
typedef enum _VSB_CITROEN_CLASS
{
    VSB_CITROEN_OTHER                 = 0,   // ������������
        VSB_CITROEN_C2                    = 1,   // ѩ����C2
        VSB_CITROEN_C4L                   = 2,   // ѩ����C4L
        VSB_CITROEN_C5                    = 3,   // ѩ����C5
        VSB_CITROEN_ELYSEE                = 4,   // ����������
        VSB_CITROEN_CQUATRELIANGXIANG     = 5,   // ��������
        VSB_CITROEN_CQUATRESANXIANG       = 6,   // ��������
        VSB_CITROEN_SAEAPICASSO           = 7,   // ����-�ϼ���
        VSB_CITROEN_PICASSO               = 8,   // �ϼ���
        VSB_CITROEN_CTRIOMPHE             = 9,   // ����
        VSB_CITROEN_XSARA                 = 10,  // ����  
        VSB_CITROEN_SHENLONGFUKANG        = 11,  // ��������
        VSB_CITROEN_CHANGANDS             = 12,   // ����DS
        VSB_CITROEN_C2_1                  = 13,   // ѩ����-C2-2012,2010,2008,2007,2006
        VSB_CITROEN_C4L_1                 = 14,   // ѩ����-C4L-2014,2013
        VSB_CITROEN_C4PICASSO_1           = 15,   // ѩ����-C4�ϼ���-2009���ʰ�
        VSB_CITROEN_C5_1                  = 16,   // ѩ����-C5-2012,2011,2010
        VSB_CITROEN_CQUATRESANXIANG_1     = 17,   // ѩ����-��������-2013,2012
        VSB_CITROEN_CQUATRELIANGXIANG_1   = 18,   // ѩ����-��������-2011,2010,2009,2008
        VSB_CITROEN_CTRIOMPHE_1           = 19,   // ѩ����-����-2010,2009,2008,2006
        VSB_CITROEN_FUKANG_1              = 20,   // ѩ����-����-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_1              = 21,   // ѩ����-����������-2006,2005,2004,2003,2002
        VSB_CITROEN_ELYSEE_2              = 22,   // ѩ����-����������-2013,2012,2011,2010,2009,2008,2007
        VSB_CITROEN_SAEAPICASSO_1         = 23    // ѩ����-����-�ϼ���-2014 
}VSB_CITROEN_CLASS;

//�ִ���Ʒ������
typedef enum _VSB_HYUNDAI_CLASS
{
    VSB_HYUNDAI_OTHER            = 0,   // ������������
        VSB_HYUNDAI_IX35             = 1,   // �ִ�IX35
        VSB_HYUNDAI_LANGDONG         = 2,   // �ʶ�
        VSB_HYUNDAI_MOINCA           = 3,   // ��Ԧ
        VSB_HYUNDAI_SHENGDA          = 4,   // ʤ��
        VSB_HYUNDAI_VERNA            = 5,   // ����
        VSB_HYUNDAI_RUIYI            = 6,   // ����
        VSB_HYUNDAI_SONATAEIGHT      = 7,   // ��������
        VSB_HYUNDAI_TUCSON           = 8,   // ;ʤ
        VSB_HYUNDAI_YUEDONG          = 9,   // �ö�
        VSB_HYUNDAI_ELANTRA          = 10,  // ������
        VSB_HYUNDAI_GRANDSANTAFE     = 11,  // ����
        VSB_HYUNDAI_COUPE            = 12,  // ����
        VSB_HYUNDAI_MATRIX           = 13,  // ����
        VSB_HYUNDAI_ACCENT           = 14,  // ������
        VSB_HYUNDAI_IX30             = 15,  // �ִ�IX30
        VSB_HYUNDAI_SONATA           = 16,  // ������
        VSB_HYUNDAI_REFINE           = 17,  // �ִ��������
        VSB_HYUNDAI_MISTRA           = 18,  // ��ͼ
        VSB_HYUNDAI_SONATAYUFENG     = 19,  // ������-����
        VSB_HYUNDAI_SANTAFE          = 20,  // �ִ�ʥ���
        VSB_HYUNDAI_HUIYI            = 21,   // ���ڻ���
        VSB_HYUNDAI_I30_1            = 22,   // �ִ�-i30-2010,2009
        VSB_HYUNDAI_IX35_1           = 23,   // �ִ�-ix35-2012,2011,2010
        VSB_HYUNDAI_YILANTE_1        = 24,   // �ִ�-������-2006,2005,2004
        VSB_HYUNDAI_YILANTE_2        = 25,   // �ִ�-������-2007����
        VSB_HYUNDAI_YILANTE_3        = 26,   // �ִ�-������-2011
        VSB_HYUNDAI_SHENGDA_1        = 27,   // �ִ�-ȫ��ʤ��-2013,2012
        VSB_HYUNDAI_MINGTU_1         = 28,   // �ִ�-��ͼ-2014,2013
        VSB_HYUNDAI_MINGYU_1         = 29,   // �ִ�-��Ԧ-2013,2011,2009
        VSB_HYUNDAI_SHENGDAFEI_1     = 30,   // �ִ�-ʥ���-δ֪
        VSB_HYUNDAI_YUXIANG_1        = 31,   // �ִ�-����-2005���ʰ�
        VSB_HYUNDAI_YUXIANG_2        = 32,   // �ִ�-����-2006,2005
        VSB_HYUNDAI_YUEDONG_1        = 33,   // �ִ�-�ö�-2010,2009,2008
        VSB_HYUNDAI_YUEDONG_2        = 34,   // �ִ�-�ö�-2012,2011
        VSB_HYUNDAI_SHENGDA_2        = 35,   // �ִ�-��ʤ��-2009,2006
        VSB_HYUNDAI_SHENGDA_3        = 36,   // �ִ�-��ʤ��-2012,2011,2010
        VSB_HYUNDAI_LANGDONG_1       = 37,   // �ִ�-�ʶ�-2013,2012
        VSB_HYUNDAI_GERUI_1          = 38,   // �ִ�-����-δ֪
        VSB_HYUNDAI_RUIYI_1          = 39,   // �ִ�-����-2014
        VSB_HYUNDAI_RUINA_1          = 40,   // �ִ�-��������-2013,2010
        VSB_HYUNDAI_RUINA_2          = 41,   // �ִ�-��������-2014,2013,2011
        VSB_HYUNDAI_RUIFENG_1        = 42,   // �ִ�-���-δ֪
        VSB_HYUNDAI_SUONATA_1        = 43,   // �ִ�-������-2008,2007,2006,2004,2003��׼��
        VSB_HYUNDAI_SUONATA_2        = 44,   // �ִ�-������-2010,2009,2008,2006,2004
        VSB_HYUNDAI_SOUNATA_3        = 45,   // �ִ�-��������-2011,2010
        VSB_HYUNDAI_WEILAKESI_1      = 46,   // �ִ�-ά����˹-2012,2010,2008,2007
        VSB_HYUNDAI_MEIJIA_1         = 47,   // �ִ�-����-δ֪
        VSB_HYUNDAI_JINKOUHUIYI_1    = 48,   // �ִ�-���ڻ���-δ֪
        VSB_HYUNDAI_TUSHENG_1        = 49,   // �ִ�-;ʤ-2005
        VSB_HYUNDAI_TUSHENG_2        = 50,   // �ִ�-;ʤ-2011,2009,2008,2006
        VSB_HYUNDAI_TUSHENG_3        = 51,   // �ִ�-;ʤ-2013
        VSB_HYUNDAI_KUPAI_1          = 52,   // �ִ�-����-δ֪
        VSB_HYUNDAI_YASHENTE_1       = 53,   // �ִ�-������-2008,2006
        VSB_HYUNDAI_YASHENTE_2       = 54,   // �ִ�-������-2011
        VSB_HYUNDAI_LINGXIANG_1      = 55,   // �ִ�-����-2009,2008
        VSB_HYUNDAI_FEISI_1          = 56    // �ִ�-��˼-2011
}VSB_HYUNDAI_CLASS;

//������Ʒ������
typedef enum _VSB_CHERY_CLASS
{
    VSB_CHERY_OTHER        = 0,   // ������������
        VSB_CHERY_A1           = 1,   // ����A1
        VSB_CHERY_A3           = 2,   // ����A3
        VSB_CHERY_EASTAR       = 3,   // ����֮��
        VSB_CHERY_FULWIN       = 4,   // ����
        VSB_CHERY_QQ           = 5,   // ����QQ
        VSB_CHERY_E5           = 6,   // ����E5
        VSB_CHERY_COWIN        = 7,   // ����
        VSB_CHERY_TIGGO        = 8,   // ��
        VSB_CHERY_A5           = 9,   // ����A5
        VSB_CHERY_S16          = 10,  // ����S16
        VSB_CHERY_YOUYA        = 11,  // ����
        VSB_CHERY_V5           = 12,  // ����V5
        VSB_CHERY_E3           = 13,   // ����E3
        VSB_CHERY_A1_1                = 14,     // ����-A1-2011,2008,2007
        VSB_CHERY_A3LIANGXIANG_1      = 15,     // ����-A3����-2012,2010,2009
        VSB_CHERY_A5_1                = 16,     // ����-A5-2009,2007,2006
        VSB_CHERY_QQ_1                = 17,     // ����-QQ-2006,2005,2004
        VSB_CHERY_QQ_2                = 18,     // ����-QQ-2010,2007,2006
        VSB_CHERY_QQ_3                = 19,     // ����-QQ-2012,2011,2010,2009,2007
        VSB_CHERY_QQ_4                = 20,     // ����-QQ-2012�˶���
        VSB_CHERY_QQ_5                = 21,     // ����-QQ-2013
        VSB_CHERY_DONGFANGZHIZI_1     = 22,     // ����-����֮��-2005,2004,2003
        VSB_CHERY_DONGFANGZHIZI_2     = 23,     // ����-����֮��-2007,2006
        VSB_CHERY_DONGFANGZHIZI_3     = 24,     // ����-����֮��CROSS-2009,2008,2007
        VSB_CHERY_YOUYA_1             = 25,     // ����-����-δ֪
        VSB_CHERY_E3_1                = 26,     // ����-����E3-2013
        VSB_CHERY_E5_1                = 27,     // ����-����E5-2014,2012,2011
        VSB_CHERY_QIYUN1_1            = 28,     // ����-����1-2010
        VSB_CHERY_QIYUN1_2            = 29,     // ����-����1-2012
        VSB_CHERY_QIYUN_1             = 30,     // ����-����-2004
        VSB_CHERY_QIYUN_2             = 31,     // ����-����-2009,2008,2007,2006
        VSB_CHERY_QIYUN2_1            = 32,     // ����-����2-2012
        VSB_CHERY_QIYUN2_2            = 33,     // ����-����2-2012������,2010
        VSB_CHERY_QIYUN3_1            = 34,     // ����-����3-2010
        VSB_CHERY_RUIHU_1             = 35,     // ����-��-2007,2006,2005
        VSB_CHERY_RUIHU_2             = 36,     // ����-��-2009,2007
        VSB_CHERY_RUIHU_3             = 37,     // ����-��-2012,2011
        VSB_CHERY_RUIHU_4             = 38,     // ����-��-2013,2012�Զ�DVVT������
        VSB_CHERY_RUIHU_5             = 39,     // ����-��-2013��Ӣ�������,2012��Ӣ��������
        VSB_CHERY_FENGYUN2SANXIANG_1  = 40,     // ����-����2����-2010
        VSB_CHERY_AIRUIZE7_1          = 41     // ����-������7-2014,2013
}VSB_CHERY_CLASS;

//������Ʒ������
typedef enum _VSB_KIA_CLASS
{
    VSB_KIA_OTHER        = 0,   // ������������
        VSB_KIA_K2           = 1,   // ����K2
        VSB_KIA_K3           = 2,   // ����K3
        VSB_KIA_K5           = 3,   // ����K5
        VSB_KIA_RIO          = 4,   // ��ŷ
        VSB_KIA_CERATO       = 5,   // ����ͼ
        VSB_KIA_SPORTAGER    = 6,   // ʨ��
        VSB_KIA_SOUL         = 7,   // ���
        VSB_KIA_ZHIPAO       = 8,   // ����
        VSB_KIA_CARENS       = 9,   // ����
        VSB_KIA_CARNIVAL     = 10,  // �λ�
        VSB_KIA_OPTIMA       = 11,  // Զ��
        VSB_KIA_OPIRUS       = 12,  // ŷ����˹
        VSB_KIA_MAXIMA       = 13,  // ǧ����
        VSB_KIA_FORTE        = 14,  // �����
        VSB_KIA_SORENTO      = 15,  // ������
        VSB_KIA_K2_1         = 16,   // ����-K2-2013,2012,2011
        VSB_KIA_K3_1         = 17,   // ����-K3-2012
        VSB_KIA_K5_1         = 18,   // ����-K5-2012,2011
        VSB_KIA_RUIOU_1      = 19,   // ����-RIO��ŷ-2009,2007
        VSB_KIA_QIANLIMA_1   = 20,   // ����-ǧ����-2004
        VSB_KIA_QIANLIMA_2   = 21,   // ����-ǧ����-2006,2005
        VSB_KIA_JIAHUA_1     = 22,   // ����-�λ�-δ֪
        VSB_KIA_XINJIALE_1   = 23,   // ����-�¼���-2011
        VSB_KIA_ZHIPAO_1     = 24,   // ����-����-2014,2012,2011,2010
        VSB_KIA_SHIPAO_1     = 25,  // ����-ʨ��-2008,2007,2005
        VSB_KIA_SHIPAO_2     = 26,  // ����-ʨ��-2011,2009
        VSB_KIA_SHIPAO_3     = 27,  // ����-ʨ��-2012
        VSB_KIA_SHIPAO_4     = 28,  // ����-ʨ��-2013
        VSB_KIA_FURUIDI_1    = 29,  // ����-�����-2012,2011,2009
        VSB_KIA_FURUIDI_2    = 30,  // ����-�����-2014
        VSB_KIA_XIUER_1      = 31,  // ����-���-2012,2010
        VSB_KIA_SUOLANTUO_1  = 32,  // ����-������-2006
        VSB_KIA_SUOLANTUO_2  = 33,  // ����-������-2012,2010,2009
        VSB_KIA_SAILATU_1    = 34,  // ����-����ͼ-2006,2005
        VSB_KIA_SAILATU_2    = 35,  // ����-����ͼ-2007
        VSB_KIA_SAILATU_3    = 36,  // ����-����ͼ-2012,2010GLS
        VSB_KIA_YUANJIAN_1   = 37   // ����-Զ��-δ֪
}VSB_KIA_CLASS;

//������Ʒ������
typedef enum _VSB_BENZ_CLASS
{
    VSB_BENZ_OTHER         = 0,   // ������������
        VSB_BENZ_C             = 1,   // ����C��
        VSB_BENZ_E             = 2,   // ����E��
        VSB_BENZ_GLK           = 3,   // ����GLK��
        VSB_BENZ_WEITING       = 4,   // ����-PINYIN
        VSB_BENZ_SPRINTER      = 5,   // ����
        VSB_BENZ_VIANO         = 6,   // Ψ��ŵ
        VSB_BENZ_M             = 7,   // ����Mϵ
        VSB_BENZ_CLK           = 8,   // ����CLKϵ
        VSB_BENZ_G             = 9,   // ����Gϵ
        VSB_BENZ_GL            = 10,  // ����GLϵ
        VSB_BENZ_R             = 11,  // ����Rϵ
        VSB_BENZ_S             = 12,  // ����Sϵ
        VSB_BENZ_A             = 13,  // ����Aϵ
        VSB_BENZ_SMART         = 14,  // ˹����(����)
        VSB_BENZ_B             = 15,  // ����Bϵ
        VSB_BENZ_SLK           = 16,  // ����SLKϵ
        VSB_BENZ_MB100         = 17,  // ����MB100
        VSB_BENZ_VITO          = 18,  // ����
        VSB_BENZ_CLS           = 19,  // ����CLSϵ
        VSB_BENZ_SL            = 20,   // ����SLϵ
        VSB_BENZ_AJI_1         = 21,   // ����-A��-2011,2009
        VSB_BENZ_AJI_2         = 22,   // ����-A��-2013
        VSB_BENZ_BJI_1         = 23,   // ����-B��-2010,2009
        VSB_BENZ_CJI_1         = 24,   // ����-C��-2010,2008,2007ʱ����
        VSB_BENZ_CJI_2         = 25,   // ����-C��-2013,2011,CGI
        VSB_BENZ_CJI_3         = 26,   // ����-C��-2013,2011ʱ����
        VSB_BENZ_EJI_1         = 27,   // ����-E��-2002
        VSB_BENZ_EJI_2         = 28,   // ����-E��-2007,2006
        VSB_BENZ_EJI_3         = 29,   // ����-E��-2013,2012,2011,2010,2009
        VSB_BENZ_EJI_4         = 30,   // ����-E��-2013,2012,2011,2010,2009ʱ����
        VSB_BENZ_GLKJI_1       = 31,   // ����-GLK��-2012,2011
        VSB_BENZ_GLKJI_2       = 32,   // ����-GLK��-2012,2011������,2008
        VSB_BENZ_GLKJI_3       = 33,   // ����-GLK��-2014,2013
        VSB_BENZ_GLJI_1        = 34,   // ����-GL��-2011
        VSB_BENZ_GLJI_2        = 35,   // ����-GL��-2011�����,2010
        VSB_BENZ_GLJI_3        = 36,   // ����-GL��-2012,2010������
        VSB_BENZ_GJI_1         = 37,   // ����-G��-2013,2010,2009
        VSB_BENZ_MB100_1       = 38,   // ����-MB100-2000
        VSB_BENZ_MLJI_1        = 39,   // ����-ML��-2006,2005
        VSB_BENZ_MLJI_2        = 40,   // ����-ML��-2010,2008
        VSB_BENZ_MLJI_3        = 41,   // ����-ML��-2014,2012
        VSB_BENZ_RJI_1         = 42,   // ����-R��-2006
        VSB_BENZ_RJI_2         = 43,   // ����-R��-2007
        VSB_BENZ_RJI_3         = 44,   // ����-R��-2014,2011,2010,2009
        VSB_BENZ_SLKJI_2       = 45,   // ����-SLK��-2006,2004
        VSB_BENZ_SLKJI_3       = 46,   // ����-SLK��-2010,2009
        VSB_BENZ_SLKJI_1       = 47,   // ����-SLK��-2011
        VSB_BENZ_SJI_1         = 48,   // ����-S��-2004
        VSB_BENZ_SJI_2         = 49,   // ����-S��-2009_Hybrid,2008,2006
        VSB_BENZ_SJI_3         = 50,   // ����-S��-2009,2008������
        VSB_BENZ_SJI_4         = 51,   // ����-S��-2012,2011,2010
        VSB_BENZ_LINGTE_1      = 52,   // ����-����-2013,2012,2011
        VSB_BENZ_WEIYANUO_1    = 53,   // ����-Ψ��ŵ-2010,2006,2004
        VSB_BENZ_WEIYANUO_2    = 54,   // ����-Ψ��ŵ-2014,2013,2012,2011
        VSB_BENZ_WEITING_1     = 55,   // ����-����-2013,2011,2010
        VSB_BENZ_KECHE_1       = 56    // ����-�ͳ�����1-A��
}VSB_BENZ_CLASS;

//˹�´���Ʒ������
typedef enum _VSB_SKODA_CLASS
{
    VSB_SKODA_OTHER            = 0,   // ������������
        VSB_SKODA_HAORUI           = 1,   // ���
        VSB_SKODA_FABIA            = 2,   // ����
        VSB_SKODA_OCTAVIA          = 3,   // ����
        VSB_SKODA_SUPERB           = 4,   // ����
        VSB_SKODA_SPACEBACK        = 5,   // 꿶�
        VSB_SKODA_RAPID            = 6,   // ���
        VSB_SKODA_YETI             = 7,    // Ұ��
        VSB_SKODA_HAORUI_1         = 8,      // ˹�´�-���-2013,2012,2010,2009
        VSB_SKODA_MINGRUI_1        = 9,      // ˹�´�-����-2009,2008,2007
        VSB_SKODA_MINGRUI_2        = 10,      // ˹�´�-����-2014,2013,2012,2011,2010
        VSB_SKODA_MINGRUI_3        = 11,      // ˹�´�-����RS-2010
        VSB_SKODA_XINRUI_1         = 12,      // ˹�´�-���-2013��ѡ��
        VSB_SKODA_JINGRUI_1        = 13,      // ˹�´�-����-2011,2009,2008
        VSB_SKODA_JINGRUI_2        = 14,      // ˹�´�-����-2014,2013,2012
        VSB_SKODA_JINGRUI_3        = 15,      // ˹�´�-����-2014,2013,2012Sport��
        VSB_SKODA_SUPAI_1          = 16,      // ˹�´�-����-2013
        VSB_SKODA_YEDI_1           = 17      // ˹�´�-Ұ��-2014,2013
}VSB_SKODA_CLASS;

//������Ʒ������
typedef enum _VSB_DONGFENG_CLASS
{
    VSB_DONGFENG_OTHER                 = 0,   // ������������
        VSB_DONGFENG_JOYEARX5              = 1,   // ����X5
        VSB_DONGFENG_LINGZHI               = 2,   // ����
        VSB_DONGFENG_JOYEARX3              = 3,   // ����X3
        VSB_DONGFENG_JOYEAR                = 4,   // ����
        VSB_DONGFENG_FENGXINGCM7           = 5,   // ����CM7
        VSB_DONGFENG_YUFENG                = 6,   // ����
        VSB_DONGFENG_FENGSHENA60           = 7,   // ����A60
        VSB_DONGFENG_FENGSHENS30           = 8,   // ����S30
        VSB_DONGFENG_FENGSHENH30CROSS      = 9,   // ����H30-CROSS
        VSB_DONGFENG_PICKUP                = 10,  // ����Ƥ��
        VSB_DONGFENG_ZHONGXINGMIANBAOCHE   = 11,  // �������������
        VSB_DONGFENG_XIAOXINGMIANBAOCHE    = 12,  // ����С�������
        VSB_DONGFENG_ZHONGXINGVAN          = 13,  // �������ͻ���
        VSB_DONGFENG_QINGXINGXIANGSHIVAN   = 14,  // ����������ʽ����
        VSB_DONGFENG_QINGZHONGXINGVAN      = 15,  // ������������ͨ����
        VSB_DONGFENG_FENGSHENMERCURY       = 16,  // ����ˮ��
        VSB_DONGFENG_SUCCE                 = 17,  // ˧��
        VSB_DONGFENG_ODIN                  = 18,  // �¶�
        VSB_DONGFENG_YUMSUN                = 19,  // ����
        VSB_DONGFENG_RUIQI                 = 20,  // ����
        VSB_DONGFENG_FENGGUANG             = 21,  // ���
        VBR_DONGFENG_C35_1                 = 22,   // ����-C35-2013
        VBR_DONGFENG_K07_1                 = 23,   // ����-K07-2008
        VBR_DONGFENG_K07_2                 = 24,   // ����-K07-2010,2006
        VBR_DONGFENG_V21_1                 = 25,   // ����-V21-2011
        VBR_DONGFENG_JIALONG_1             = 26,   // ����-�������-�ػ���
        VBR_DONGFENG_XKFG_1                = 27,   // ����-����С�����-2013
        VBR_DONGFENG_CV03_1                = 28,   // ����-����CV03-2012
        VBR_DONGFENG_KAIPUTE_1             = 29,   // ����-������-C390
        VBR_DONGFENG_DUOLIKA_1             = 30,   // ����-������-S2800
        VBR_DONGFENG_DUOLIKA_2             = 31,   // ����-������-XL�п�
        VBR_DONGFENG_DUOLIKA_3             = 32,   // ����-������-�п�
        VBR_DONGFENG_TIANJIN_1             = 33,   // ����-���-4X2�ػ���
        VBR_DONGFENG_TIANJIN_2             = 34,   // ����-���-A��
        VBR_DONGFENG_XBW_1                 = 35,   // ����-С����-�Ῠ1
        VBR_DONGFENG_XBW_2                 = 36,   // ����-С����-�Ῠ2
        VBR_DONGFENG_MENGKA_1              = 37,   // ����-�ο�-�Ῠ
        VBR_DONGFENG_FURUIKA_1             = 38,   // ����-����-�Ῠ1
        VBR_DONGFENG_RUIQI_1               = 39,   // ����-����Ƥ��-2013,2010,2009
        VBR_DONGFENG_A60_1                 = 40,   // �������-A60-2014,2012
        VBR_DONGFENG_H30_1                 = 41,   // �������-H30-Cross-2012,2011
        VBR_DONGFENG_H30_2                 = 42,   // �������-H30-Cross-2014,2013
        VBR_DONGFENG_H30_3                 = 43,   // �������-H30-2012
        VBR_DONGFENG_JINGYI_1              = 44,   // �������-����-2014_2012LV,2011������
        VBR_DONGFENG_JINGYI_2              = 45,   // �������-����-2014_2012XL,2011,2010,2009,2008,2007
        VBR_DONGFENG_JINGYI_3              = 46,   // �������-����X5-2014,2013
        VBR_DONGFENG_LINGZHI_1             = 47,   // �������-����-2004
        VBR_DONGFENG_LINGZHI_2             = 48,   // �������-����-2011,2008,2007
        VBR_DONGFENG_LINGZHI_3             = 49,   // �������-����-2011Q3��׼��,2010Q7
        VBR_DONGFENG_LINGZHI_4             = 50,   // �������-����-2014_2013M3
        VBR_DONGFENG_LINGZHI_5             = 51   // �������-����-2014_2013V3,2011M3_���ð�_������
}VSB_DONGFENG_CLASS;

//���ǵ���Ʒ������
typedef enum _VSB_BYD_CLASS
{
    VSB_BYD_OTHER         = 0,   // ������������
        VSB_BYD_F0            = 1,   // ���ǵ�F0
        VSB_BYD_F3            = 2,   // ���ǵ�F3
        VSB_BYD_F3R           = 3,   // ���ǵ�F3R
        VSB_BYD_F6            = 4,   // ���ǵ�F6
        VSB_BYD_G3            = 5,   // ���ǵ�G3
        VSB_BYD_G3R           = 6,   // ���ǵ�G3R
        VSB_BYD_G6            = 7,   // ���ǵ�G6
        VSB_BYD_L3            = 8,   // ���ǵ�L3
        VSB_BYD_M6            = 9,   // ���ǵ�M6
        VSB_BYD_S6            = 10,  // ���ǵ�S6
        VSB_BYD_SURUI         = 11,  // ����
        VSB_BYD_FOLEL         = 12,  // �ش�������
        VSB_BYD_SIRUI         = 13,  // ˼��
        VSB_BYD_MT5           = 14,  // ���ǵ�MT5(����)
        VSB_BYD_F0_1          = 15,        // ���ǵ�-F0-2013,2012,2011,2010,2009,2008
        VSB_BYD_F3R_1         = 16,        // ���ǵ�-F3R-2011,2009,2008,2007
        VSB_BYD_F6_1          = 17,        // ���ǵ�-F6-2011,2009,2008
        VSB_BYD_G3R_1         = 18,        // ���ǵ�-G3R-2011
        VSB_BYD_G6_1          = 19,        // ���ǵ�-G6-2013,2012,2011
        VSB_BYD_L3_1          = 20,        // ���ǵ�-L3-2013,2012,2011,2010
        VSB_BYD_M6_1          = 21,        // ���ǵ�-M6-2013,2011,2010
        VSB_BYD_S6_1          = 22,        // ���ǵ�-S6-2014,2013,2012,2011
        VSB_BYD_FULAIER_1     = 23,        // ���ǵ�-������-2005������
        VSB_BYD_SURUI_1       = 24        // ���ǵ�-����-2014,2013,2012
}VSB_BYD_CLASS;

//��ľ��Ʒ������
typedef enum _VSB_SUZUKI_CLASS
{
    VSB_SUZUKI_OTHER           = 0,   // ������������
        VSB_SUZUKI_ALTO            = 1,   // ��������
        VSB_SUZUKI_SCROSS          = 2,   // ��Ԧ
        VSB_SUZUKI_SWIFT           = 3,   // ����
        VSB_SUZUKI_SX4             = 4,   // ����
        VSB_SUZUKI_LINGYANG        = 5,   // ����
        VSB_SUZUKI_BEIDOUXING      = 6,   // ������
        VSB_SUZUKI_LIANAA6         = 7,   // ������-A6
        VSB_SUZUKI_LANDY           = 8,   // �˵�
        VSB_SUZUKI_SPLASH          = 9,   // ��ϲ
        VSB_SUZUKI_GRANDVITARA     = 10,  // ����ά����
        VSB_SUZUKI_JIMNY           = 11,  // ��ķ��
        VSB_SUZUKI_KAZASHI         = 12,  // ������
        VSB_SUZUKI_LIANA           = 13,   // ������
        VSB_SUZUKI_LIANA_1           = 14,     // ��ľ-����������-2012,2011,2010,2008,2007,2005
        VSB_SUZUKI_LIANA_2           = 15,     // ��ľ-����������-2013,2012,2011
        VSB_SUZUKI_BEIDOUXING_1      = 16,     // ��ľ-������-2012,2011,2010,2009,2008,2007,2005,2004��׼��
        VSB_SUZUKI_BEIDOUXING_2      = 17,     // ��ľ-������-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003
        VSB_SUZUKI_BEIDOUXING_3      = 18,     // ��ľ-������-2013,2012,2011,2010,2009,2008,2007,2005,2004,2003������
        VSB_SUZUKI_BEIDOUXING_4      = 19,     // ��ľ-������-2013X5
        VSB_SUZUKI_JIMUNI_1          = 20,     // ��ľ-��ķ��-2011,2010,2009,2007
        VSB_SUZUKI_JIMUNI_2          = 21,     // ��ľ-��ķ��-2012
        VSB_SUZUKI_SX4_1             = 22,     // ��ľ-����SX4����-2008,2006
        VSB_SUZUKI_SX4_2             = 23,     // ��ľ-����SX4����-2010,2009
        VSB_SUZUKI_SX4_3             = 24,     // ��ľ-����SX4����-2011A,2009,2008,2007
        VSB_SUZUKI_SX4_4             = 25,     // ��ľ-����SX4����-2011B
        VSB_SUZUKI_SX4_5             = 26,     // ��ľ-����SX4����-2013,2012,2011
        VSB_SUZUKI_ALTO_1            = 27,     // ��ľ-����-2006,2001,2000,1999,1993��׼��
        VSB_SUZUKI_ALTO_2            = 28,     // ��ľ-����-2006,2004,2001,2000,1999,1993
        VSB_SUZUKI_ALTO_3            = 29,     // ��ľ-����-2013
        VSB_SUZUKI_ALTO_4            = 30,     // ��ľ-����-2014,2012,2011,2010,2009
        VSB_SUZUKI_SPLASH_1          = 31,     // ��ľ-��ϲ-2013,2012,2011
        VSB_SUZUKI_LANDY_1           = 32,     // ��ľ-�˵�-2011,2010,2007
        VSB_SUZUKI_LINGYANG_2        = 33,     // ��ľ-����-2006,2004,2003
        VSB_SUZUKI_LINGYANG_3        = 34,     // ��ľ-����-2009,2008,2007
        VSB_SUZUKI_LINGYANG_4        = 35,     // ��ľ-����-2011
        VSB_SUZUKI_LINGYANG_5        = 36,     // ��ľ-����-2012
        VSB_SUZUKI_GRANDVITARA_1     = 37,     // ��ľ-����ά����-2011,2008,2007,2006
        VSB_SUZUKI_FENGYU_1          = 38,     // ��ľ-��Ԧ-2014
        VSB_SUZUKI_SWIFT_1           = 39,     // ��ľ-����-2011_1.3L,2009,2008,2007,2005
        VSB_SUZUKI_SWIFT_2           = 40,     // ��ľ-����-2012,2011
        VSB_SUZUKI_KINGCHANG_1       = 41,     // ��ľ-������-2004
        VSB_SUZUKI_LINGYANG_1        = 42     // ��ľ-����-2002
}VSB_SUZUKI_CLASS;

//������Ʒ������
typedef enum _VSB_SGMW_CLASS
{
    VSB_SGMW_OTHER               = 0,   // ������������
        VSB_SGMW_HONGGUANG           = 1,   // ������
        VSB_SGMW_HONGGUANGS          = 2,   // ������S
        VSB_SGMW_ZHIGUANG            = 3,   // ����֮��
        VSB_SGMW_RONGGUANGS          = 4,   // �����ٹ�S
        VSB_SGMW_RONGGUANG           = 5,   // �����ٹ�
        VSB_SGMW_HONGTU              = 6,   // �����;
        VSB_SGMW_XINGWANG            = 7,   // ��������
        VSB_SGMW_YANGGUANG           = 8,   // �������
        VSB_SGMW_XIAOXUANFENG        = 9,   // ����С����
        VSB_SGMW_WULINGZHIGUANG_1    = 10,       // ����-����֮��-2010,2009��ҵ
        VSB_SGMW_WULINGZHIGUANG_2    = 11,       // ����-����֮��-2010�̳���,������
        VSB_SGMW_WULINGZHIGUANG_3    = 12,       // ����-����֮��-2010������,2008��ʽ,2007
        VSB_SGMW_XINGWANG_1          = 13,       // ����-���������-2003
        VSB_SGMW_XINGWANG_2          = 14,       // ����-���������-2009��׼
        VSB_SGMW_XINGWANG_3          = 15,       // ����-���������-2010,2009,2007,2006,2005,2004
        VSB_SGMW_HONNGUANG_1         = 16,       // ����-���-2013,2010
        VSB_SGMW_HONNGUANG_2         = 17,       // ����-���-2014,2013S
        VSB_SGMW_XIAOXUANFENG_1      = 18,       // ����-С����-2006
        VSB_SGMW_YANGGUANG_1         = 19,       // ����-���-2006,2005,2004
        VSB_SGMW_YANGGUANG_2         = 20,       // ����-���-2008,2007
        VSB_SGMW_YANGGUANG_3         = 21,       // ����-���-2009,2006,2005�ֶ���׼��
        VSB_SGMW_RONGGUANG_1         = 22,       // ����-�ٹ������-2012,2011,2008����
        VSB_SGMW_RONGGUANG_2         = 23,       // ����-�ٹ������-2012,2011,2008��׼
        VSB_SGMW_HONGTU_1            = 24        // ����-��;-2010,2009,2008,2007
}VSB_SGMW_CLASS;

//������Ʒ������
typedef enum _VSB_CHANA_CLASS
{
    VSB_CHANA_OTHER                = 0,   // ������������
        VSB_CHANA_HONOR                = 1,   // ŷŵ
        VSB_CHANA_XINGKA               = 2,   // �����ǿ�
        VSB_CHANA_ZHIXING              = 3,   // ����֮��
        VSB_CHANA_PICKUP               = 4,   // ��������С��(����Ƥ��)
        VSB_CHANA_ZHIXING2             = 5,   // ����֮��2��
        VSB_CHANA_TAURUS               = 6,   // ��ţ��
        VSB_CHANA_XINGGUANG            = 7,   // �����ǹ�
        VSB_CHANA_BENNI                = 8,   // ����
        VSB_CHANA_ALSVIN               = 9,   // ����
        VSB_CHANA_CX20                 = 10,  // ����CX20
        VSB_CHANA_CX30                 = 11,  // ����CX30
        VSB_CHANA_EADO                 = 12,  // �ݶ�
        VSB_CHANA_ZHIXINGS460          = 13,  // ����֮��S460
        VSB_CHANA_CM8                  = 14,  // ����CM8
        VSB_CHANA_XINBAO               = 15,  // �±�
        VSB_CHANA_XUNLONG              = 16,  // ѫ��
        VSB_CHANA_YUNTONG              = 17,  // ��ͨ
        VSB_CHANA_LEIMENG              = 18,  // ����
        VSB_CHANA_XINGYUN              = 19,  // ��������
        VSB_CHANA_OULIWEI              = 20,  // ŷ����
        VSB_CHANA_EADOXT               = 21,   // ����XT
        VSB_CHANA_XINGYUN_1            = 22,      // ��������-����-2004,2003,2000
        VSB_CHANA_OULIWEI_1            = 23,      // ��������-ŷ����-2013
        VSB_CHANA_YUNTONG_1            = 24,      // ��������-��ͨ-2004
        VSB_CHANA_TAURUS_1             = 25,      // ��������-��ţ��-2013,2012,2011,2010
        VSB_CHANA_LEIMENG_1            = 26,      // ��������-����-2005,2003
        VSB_CHANA_ZHIXING_1            = 27,      // ��������-����֮��-2010,2009
        VSB_CHANA_ZHIXING_2            = 28,      // ��������-����֮��-2013
        VSB_CHANA_ZHIXING_3            = 29,      // ��������-����֮��2-2009,2008
        VSB_CHANA_ZHIXING_4            = 30,      // ��������-����֮��2-2012
        VSB_CHANA_ZHIXING_5            = 31,      // ��������-����֮��S460-2010,2009
        VSB_CHANA_ZHIXING_6            = 32,      // ��������-����֮��SC6350-2003
        VSB_CHANA_PICKUP_1             = 33,      // ��������-����΢������-2013,2012
        VSB_CHANA_XINGGUANG_1          = 34,      // ��������-�����ǹ�4500-2009,2007
        VSB_CHANA_XINGGUANG_2          = 35,      // ��������-�����ǹ�4500-2012
        VSB_CHANA_HONOR_1              = 36      // ��������-����ŷŵ-2014,2012
}VSB_CHANA_CLASS;

//�����γ���Ʒ������
typedef enum _VSB_EADO_CLASS
{
    VSB_EADO_OTHER                = 0,       // ������������
        VSB_EADO_CS_1                 = 1,       // �����γ�-CS35-2014,2013,2012
        VSB_EADO_CX_1                 = 2,       // �����γ�-CX20-2011
        VSB_EADO_CX_2                 = 3,       // �����γ�-CX30����-2010
        VSB_EADO_BENBEN_1             = 4,       // �����γ�-����-2008,2007,2006
        VSB_EADO_BENBEN_2             = 5,       // �����γ�-����-2008������,2007�˶���
        VSB_EADO_BENBEN_3             = 6,       // �����γ�-����-2010
        VSB_EADO_BENBEN_4             = 7,       // �����γ�-����MINI-2011,2010
        VSB_EADO_BENBEN_5             = 8,       // �����γ�-����MINI-2012
        VSB_EADO_YUEXIANG_1           = 9,       // �����γ�-����-2011,2010,2009
        VSB_EADO_YUEXIANG_2           = 10,       // �����γ�-����-2012
        VSB_EADO_YUEXIANG_3           = 11,       // �����γ�-����V3-2013,2012
        VSB_EADO_YUEXIANG_4           = 12,       // �����γ�-����V5-2012
        VSB_EADO_YIDONG_1             = 13        // �����γ�-�ݶ�-2014,2013,2012
}VSB_EADO_CLASS;

//����Ʒ������
typedef enum _VSB_JINBEI_CLASS
{
    VSB_JINBEI_OTHER           = 0,   // ������������
        VSB_JINBEI_GRACE           = 1,   // �𱭸���˹
        VSB_JINBEI_HIACE           = 2,   // �𱭺�ʨ
        VSB_JINBEI_HAIXING         = 3,   // ����
        VSB_JINBEI_BADAO           = 4,   // �𱭰Ե�
        VSB_JINBEI_LINGQI          = 5,   // ����
        VSB_JINBEI_JINQI           = 6,   // ����
        VSB_JINBEI_LINGCHI         = 7,   // ���
        VSB_JINBEI_QIYUN           = 8,   // ����
        VSB_JINBEI_ZHISHANG_1      = 9,       // ��-����S30-2014,2013,2012
        VSB_JINBEI_HAIXING_1       = 10,       // ��-����-2012
        VSB_JINBEI_HAIXING_2       = 11,       // ��-����-2012A7�ػ���,2011
        VSB_JINBEI_HIACE_1         = 12,       // ��-��ʨ-2008
        VSB_JINBEI_HIACE_2         = 13,       // ��-��ʨ-2013,2011,2010
        VSB_JINBEI_HIACE_3         = 14,       // ��-��ʨ-2013������,2011����,2008��׼��
        VSB_JINBEI_JINDIAN_1       = 15,       // ��-���-2009
        VSB_JINBEI_GRACE_1         = 16,       // ��-����˹MPV-2011,2008,2007
        VSB_JINBEI_GRACE_2         = 17,       // ��-����˹MPV-2011���������,2010,2009,2007��׼9��
        VSB_JINBEI_BADAO_1         = 18       // ��-�Ե�SUV-2011,2008 
        
}VSB_JINBEI_CLASS;

//������Ʒ������
typedef enum _VSB_GEELY_CLASS
{
    VSB_GEELY_OTHER              = 0,   // ������������
        VSB_GEELY_EC7                = 1,   // �����ۺ�EC7
        VSB_GEELY_EC8                = 2,   // �����ۺ�EC8                                                          
        VSB_GEELY_SC3                = 3,   // ����SC3
        VSB_GEELY_SC5RV              = 4,   // ����SC5-RV
        VSB_GEELY_SC6                = 5,   // ����SC6
        VSB_GEELY_JINGYING           = 6,   // ��ӥ
        VSB_GEELY_JINGGANG           = 7,   // ���
        VSB_GEELY_SX7                = 8,   // ����SX7
        VSB_GEELY_HAOQING            = 9,   // ����
        VSB_GEELY_MEIRI              = 10,  // ����
        VSB_GEELY_YINGLUNSC7         = 11,  // Ӣ��SC7
        VSB_GEELY_PANDA              = 12,  // ��è
        VSB_GEELY_YUANJING           = 13,  // Զ��
        VSB_GEELY_ZIYOUJIAN          = 14   // ���ɽ�
}VSB_GEELY_CLASS;

//������Ʒ������
typedef enum _VSB_MITSUBISHI_CLASS
{
    VSB_MITSUBISHI_OTHER                 = 0,   // ������������
        VSB_MITSUBISHI_GALANT                = 1,   // ����
        VSB_MITSUBISHI_ZINGER                = 2,   // ����
        VSB_MITSUBISHI_LANCER                = 3,   // ��ɪ
        VSB_MITSUBISHI_LANCEREX              = 4,   // ����
        VSB_MITSUBISHI_PAJERO                = 5,   // ������
        VSB_MITSUBISHI_PAJEROSPORT           = 6,   // ������-����
        VSB_MITSUBISHI_JINGXUANASX           = 7,   // ����ASX
        VSB_MITSUBISHI_GRANDIS               = 8,   // ���������
        VSB_MITSUBISHI_OUTLANDER             = 9,   // ŷ����
        VSB_MITSUBISHI_QINXINGYUEYE          = 10,  // ��������ԽҰ
        VSB_MITSUBISHI_GTO                   = 11,  // ����GTO
        VSB_MITSUBISHI_SOVERAN               = 12,  // ��������
        VSB_MITSUBISHI_LIONVEL               = 13,  // ��������
        VSB_MITSUBISHI_HAFEISIMBO            = 14,   // ��������
        VSB_MITSUBISHI_LANCEREX_1            = 15,   // ����-��������-2012,2011,2010
        VSB_MITSUBISHI_JINGXUAN_1            = 16,   // ����-����-2012,2011
        VSB_MITSUBISHI_ZINGER_1              = 17,   // ����-����-2011,2009
        VSB_MITSUBISHI_PAJERO_1              = 18,   // ����-������-2004����
        VSB_MITSUBISHI_PAJERO_2              = 19,   // ����-������-2004����
        VSB_MITSUBISHI_PAJERO_3              = 20,   // ����-������-2010����
        VSB_MITSUBISHI_PAJEROSPORT_1         = 21,   // ����-�����޾���-2011
        VSB_MITSUBISHI_GALANT_1              = 22,   // ����-����-2009
        VSB_MITSUBISHI_GALANDI_1             = 23,   // ����-������-2007
        VSB_MITSUBISHI_GALANDI_2             = 24,   // ����-������-2010
        VSB_MITSUBISHI_OUTLANDER_1           = 25,   // ����-ŷ����-2012,2011,2010
        VSB_MITSUBISHI_OUTLANDER_2           = 26,   // ����-ŷ����-2013
        VSB_MITSUBISHI_LINGYUE_1             = 27,   // ����-����-δ֪
        VSB_MITSUBISHI_LANCER_1              = 28   // ����-��ɪ-2010
}VSB_MITSUBISHI_CLASS;

//�׿���˹��Ʒ������
typedef enum _VSB_LEXUS_CLASS
{
    VSB_LEXUS_OTHER             = 0,   // ������������
        VSB_LEXUS_ES                = 1,   // �׿���˹ES
        VSB_LEXUS_CT                = 2,   // �׿���˹CT                                                          
        VSB_LEXUS_RX                = 3,   // �׿���˹RX
        VSB_LEXUS_IS                = 4,   // �׿���˹IS
        VSB_LEXUS_LX                = 5,   // �׿���˹LX
        VSB_LEXUS_GS                = 6,   // �׿���˹GS
        VSB_LEXUS_GX                = 7,   // �׿���˹GX
        VSB_LEXUS_LS                = 8,    // �׿���˹LS
        VSB_LEXUS_CT_1              = 9,   // �׿���˹-CT-2013,2012,2011
        VSB_LEXUS_ES_1              = 10,   // �׿���˹-ES-1994
        VSB_LEXUS_ES_2              = 11,   // �׿���˹-ES-2010,2009,2006
        VSB_LEXUS_ES_3              = 12,   // �׿���˹-ES-2013,2012
        VSB_LEXUS_GS_1              = 13,   // �׿���˹-GS-2011,2010,2009,2008,2005
        VSB_LEXUS_GX_1              = 14,   // �׿���˹-GX-2012,2010
        VSB_LEXUS_IS_1              = 15,   // �׿���˹-IS-2011
        VSB_LEXUS_LS_1              = 16,   // �׿���˹-LS-1994
        VSB_LEXUS_LS_2              = 17,   // �׿���˹-LS-2005,2004
        VSB_LEXUS_LS_3              = 18,   // �׿���˹-LS-2009,2007,2006
        VSB_LEXUS_LX_1              = 19,   // �׿���˹-LX-2013,2012
        VSB_LEXUS_RX_1              = 20,   // �׿���˹-RX-2011,2010,2009
        VSB_LEXUS_RX_2              = 21,   // �׿���˹-RX-2013,2012
        VSB_LEXUS_RX_3              = 22   // �׿���˹-RX-2007
}VSB_LEXUS_CLASS;

//������Ʒ������
typedef enum _VSB_ROEWE_CLASS
{
    VSB_ROEWE_OTHER              = 0,   // ������������
        VSB_ROEWE_350                = 1,   // ����350
        VSB_ROEWE_550                = 2,   // ����550                                                          
        VSB_ROEWE_W5                 = 3,   // ����W5
        VSB_ROEWE_950                = 4,   // ����950
        VSB_ROEWE_750                = 5,   // ����750
        VSB_ROEWE_350_1              = 6,   // ����-350-2011Ѹ�ǰ�,2010
        VSB_ROEWE_350_2              = 7,   // ����-350-2014,2013,2012,2011
        VSB_ROEWE_550_1              = 8,   // ����-550-2012,2010,2009,2008
        VSB_ROEWE_750_1              = 9,   // ����-750-2009,2008,2007,2006
        VSB_ROEWE_750_2              = 10,  // ����-750-2012,2011
        VSB_ROEWE_950_1              = 11   // ����-950-2012
}VSB_ROEWE_CLASS;


//������Ʒ������
typedef enum _VSB_HAIMA_CLASS
{
    VSB_HAIMA_OTHER               = 0,   // ������������
        VSB_HAIMA_PREMARIN            = 1,   // ������
        VSB_HAIMA_S7                  = 2,   // ����S7
        VSB_HAIMA_PRINCE              = 3,   // ��������
        VSB_HAIMA_CUPID               = 4,   // ����2-�����
        VSB_HAIMA_HATCHBACK           = 5,   // ����3-����
        VSB_HAIMA_KNIGHT              = 6,   // ��ʿ
        VSB_HAIMA_HAPPIN              = 7,   // ������
        VSB_HAIMA_FAMILY              = 8,   // ������
        VSB_HAIMA_M3                  = 9,    // ����M3
        VSB_HAIMA_CUPID_1             = 10,   // ����-�����-2012,2011,2010
        VSB_HAIMA_PREMARIN_1          = 11,   // ����-������-2007
        VSB_HAIMA_PREMARIN_2          = 12,   // ����-������-2012,2010
        VSB_HAIMA_HATCHBACK_1         = 13,   // ����-����-2010,2009
        VSB_HAIMA_HAPPIN_1            = 14,   // ����-������-2010,2009,2008,2007,2004
        VSB_HAIMA_HAPPIN_2            = 15,   // ����-������-2012,2011
        VSB_HAIMA_M3_1                = 16,   // ����-����3-2010,2008,2007
        VSB_HAIMA_FAMILY_1            = 17,   // ����-������-2007,2006
        VSB_HAIMA_FAMILY_2            = 18,   // ����-������-2010,2009,2008
        VSB_HAIMA_FAMILY_3            = 19,   // ����-������-2011
        VSB_HAIMA_FAMILY_4            = 20,   // ����-������-2014,2013,2012
        VSB_HAIMA_KNIGHT_1            = 21,   // ����-��ʿ-2013_2012A,2011,2010
        VSB_HAIMA_KNIGHT_2            = 22,   // ����-��ʿ-2013_2012B
        VSB_HAIMA_NEWHONGDA_1         = 23,   // �������ó�-�º��-2009
        VSB_HAIMA_NEWHONDGA_2         = 24,   // �������ó�-�º��-2012
        VSB_HAIMA_PRINCE_1            = 25,   // �������ó�-��������-2010
        VSB_HAIMA_RONGDA_1            = 26   // �������ó�-�ٴ�-2012
        
}VSB_HAIMA_CLASS;

//������Ʒ������
typedef enum _VSB_GREATWALL_CLASS
{
    VSB_GREATWALL_OTHER               = 0,   // ������������
        VSB_GREATWALL_SING                = 1,   // ��Ӱ
        VSB_GREATWALL_SAIJUN              = 2,   // ����
        VSB_GREATWALL_HAVAL               = 3,   // ����
        VSB_GREATWALL_SAFE                = 4,   // ����
        VSB_GREATWALL_SAIKU               = 5,   // ����
        VSB_GREATWALL_SAILING             = 6,   // ����
        VSB_GREATWALL_KINGDEER            = 7,   // ��϶�
        VSB_GREATWALL_DEER                = 8,   // �϶�
        VSB_GREATWALL_WINGLE              = 9,   // �翥
        VSB_GREATWALL_COOLBEAR            = 10,  // ����
        VSB_GREATWALL_LINGAO              = 11,  // ���
        VSB_GREATWALL_CROSS               = 12,  // ����
        VSB_GREATWALL_GWPERI              = 13,  // ����
        VSB_GREATWALL_COWRY               = 14,  // ����
        VSB_GREATWALL_M4                  = 15,   // ����M4
        VSB_GREATWALL_LINGAO_1            = 16,   // ����-���-2010
        VSB_GREATWALL_HAVAL_1             = 17,   // ����-����H3-2010,2009
        VSB_GREATWALL_HAVAL_2             = 18,   // ����-����H3-2012,2010,2009�����
        VSB_GREATWALL_HAVAL_3             = 19,   // ����-����H5-2012,2011,2010
        VSB_GREATWALL_HAVAL_4             = 20,   // ����-����H5-2012,2011,2010�̾�������
        VSB_GREATWALL_HAVAL_5             = 21,   // ����-����H5-2012������
        VSB_GREATWALL_HAVAL_6             = 22,   // ����-����H5-2014,2013
        VSB_GREATWALL_HAVAL_8             = 23,   // ����-����H6-2014,2013������
        VSB_GREATWALL_HAVAL_9             = 24,   // ����-����M2-2010
        VSB_GREATWALL_HAVAL_10            = 25,   // ����-����M2-2013,2012
        VSB_GREATWALL_HAVAL_11            = 26,   // ����-����M4-2012
        VSB_GREATWALL_HAVAL_12            = 27,   // ����-������-2011
        VSB_GREATWALL_CROSS_1             = 28,   // ����-����-2009,2008
        VSB_GREATWALL_CROSS_2             = 29,   // ����-����CROSS-2011,2009
        VSB_GREATWALL_JINGLING_1          = 30,   // ����-����-δ֪
        VSB_GREATWALL_SING_1              = 31,   // ����-��Ӱ-2003
        VSB_GREATWALL_SAIKU_1             = 32,   // ����-����-2004
        VSB_GREATWALL_SAILING_1           = 33,   // ����-����-δ֪
        VSB_GREATWALL_DIER_1              = 34,   // ����-�϶�-δ֪
        VSB_GREATWALL_COOLBEAR_1          = 35,   // ����-����-2010,2009
        VSB_GREATWALL_KINGDEER_1          = 36,   // ����-��϶�-2008,2007,2004,2003
        VSB_GREATWALL_GREATWALL_1         = 37,   // ����-����C20R-2013,2011
        VSB_GREATWALL_GREATWALL_2         = 38,   // ����-����C30-2010
        VSB_GREATWALL_GREATWALL_3         = 39,   // ����-����C30-2012
        VSB_GREATWALL_GREATWALL_4         = 40,   // ����-����C30-2013
        VSB_GREATWALL_GREATWALL_5         = 41,   // ����-����C50-2013,2012
        VSB_GREATWALL_GREATWALL_6         = 42,   // ����-����V80-2013,2012,2010,2009,2008
        VSB_GREATWALL_WINGLE_1            = 43,   // ����-�翥3-2011,2010,2007,2006
        VSB_GREATWALL_WINGLE_2            = 44,   // ����-�翥5-2014,2012,2011,2009 
        VSB_GREATWALL_HAVAL_7             = 45   // ����-����H6-2013,2012,2011
}VSB_GREATWALL_CLASS;

//������Ʒ������
typedef enum _VSB_DS_CLASS
{
    VSB_DS_OTHER                      = 0,          // ������������
        VSB_DS_KUBO_1                     = 1,          // ����-�Ძ-2011,2010,2009,2008
        VSB_DS_KUWEI_1                    = 2,          // ����-����-2011,2010,2009
        VSB_DS_KUWEI_2                    = 3           // ����-����-2013
}VSB_DS_CLASS;

//·����Ʒ������
typedef enum _VSB_LANDROVER_CLASS
{
    VSB_LANDROVER_OTHER              = 0,   // ������������
        VSB_LANDROVER_FAXIAN_1           = 1,   // ·��-����-2005,2004
        VSB_LANDROVER_FAXIAN_2           = 2,   // ·��-����-2013,2011,2010
        VSB_LANDROVER_LANSHENG_1         = 3,   // ·��-��ʤ-2012,2011,2010
        VSB_LANDROVER_LANSHENG_2         = 4,   // ·��-��ʤ����-2014,2013,2012,2011
        VSB_LANDROVER_LANSHENG_3         = 5,   // ·��-��ʤ�˶���-2013,2012,2011,2010
        VSB_LANDROVER_LANSHENG_4         = 6,   // ·��-��ʤ�˶���-2013Ԧ��������
        VSB_LANDROVER_SXZ_1              = 7   // ·��-������2��-2014,2013,2011
}VSB_LANDROVER_CLASS;

//������Ʒ������
typedef enum _VSB_MG_CLASS
{
    VSB_MG_OTHER             = 0,  // ������������
        VSB_MG_3SW_1             = 1,  // MG-MG-3SW-2009,2008
        VSB_MG_MG3_1             = 2,  // MG-MG3-2013,2012,2011
        VSB_MG_MG5_1             = 3,  // MG-MG5-2014,2013,2012
        VSB_MG_MG6_1             = 4,  // MG-MG6����-2012,2011
        VSB_MG_MG7_1             = 5,  // MG-MG7-2010,2009,2008,2007
}VSB_MG_CLASS;

//һ����Ʒ������
typedef enum _VSB_FAW_CLASS
{
    VSB_FAW_OTHER                                       = 0,    // ������������
        VSB_FAW_501_1                                        = 1,    //һ��-501-�Ῠ
        VSB_FAW_N3_1                                        = 2,    //һ��-N3+����-2006
        VSB_FAW_N3_2                                        = 3,    //һ��-N3+����-2008
        VSB_FAW_JIABAO_1                                    = 4,    //һ��-�ѱ�����-2011T50,T57
        VSB_FAW_JIABAO_2                                    = 5,    //һ��-�ѱ������-2000
        VSB_FAW_JIABAO_3                                    = 6,    //һ��-�ѱ������-2006
        VSB_FAW_JIABAO_4                                    = 7,    //һ��-�ѱ������-2012,2011V50���ʰ�
        VSB_FAW_JIABAO_5                                    = 8,    //һ��-�ѱ������-2012,2011V70
        VSB_FAW_JIABAO_6                                    = 9,    //һ��-�ѱ������-2013,2012,2011V52ʵ����
        VSB_FAW_JIABAO_7                                    = 10,    //һ��-�ѱ������-2014,2013V80
        VSB_FAW_XIALI_1                                        = 11,    //һ��-����-1999,1997
        VSB_FAW_XIALI_2                                        = 12,    //һ��-����2000-2003,2002
        VSB_FAW_XIALI_3                                        = 13,    //һ��-����A+-2011,2010,2006,2005
        VSB_FAW_XIALI_4                                        = 14,    //һ��-����N3-2012
        VSB_FAW_XIALI_5                                        = 15,    //һ��-����N5-2014,2013,2011,2010,2009
        VSB_FAW_XIALI_6                                        = 16,    //һ��-����N7-2013
        VSB_FAW_AOWEI_1                                        = 17,    //һ��-����J5P-2005,2004,2003
        VSB_FAW_AOWEI_2                                        = 18,    //һ��-����J5P-4X2������ǣ����,��ж��
        VSB_FAW_AOWEI_3                                        = 19,    //һ��-����J5P-4X2ǣ����,ж����
        VSB_FAW_AOWEI_4                                        = 20,    //һ��-����J5P-6X6ԽҰ��ж��
        VSB_FAW_AOXING_1                                    = 21,    //һ��-����-2004
        VSB_FAW_WEILE_1                                        = 22,    //һ��-����-2004
        VSB_FAW_WEILE_2                                        = 23,    //һ��-����-2008,2007
        VSB_FAW_WEIZI_1                                        = 24,    //һ��-����-2004
        VSB_FAW_WEIZHI_1                                    = 25,    //һ��-��־V2-2012�ֶ�CROSS
        VSB_FAW_WEIZHI_2                                    = 26,    //һ��-��־V2-2012�Զ�CROSS,2010
        VSB_FAW_WEIZHI_3                                    = 27,    //һ��-��־V5-2013,2012
        VSB_FAW_WEIZHI_4                                    = 28,    //һ��-��־����-2009,2008,2007
        VSB_FAW_WEIZHI_5                                    = 29,    //һ��-��־����-2011
        VSB_FAW_XIAOJIEFANG_1                                = 30,    //һ��-С���-90,109�����Ῠ
        VSB_FAW_HANWEI_1                                    = 31,    //һ��-����J5M-4X4�ػ���
        VSB_FAW_HANWEI_2                                    = 32,    //һ��-����J5M-6X6ǣ����,6X4��ж��
        VSB_FAW_HANWEI_3                                    = 33,    //һ��-����J5M-8X8��ж��
        VSB_FAW_XINDAWEI_1                                    = 34,    //һ��-�´���-2010
        VSB_FAW_XINHANWEI_1                                    = 35,    //һ��-�º���-2011
        VSB_FAW_SENYA_1                                        = 36,    //һ��-ɭ��M80-2012,2011,2009
        VSB_FAW_TENGWEI_1                                    = 37,    //һ��-����L5M-�ؿ�
        VSB_FAW_JIEFANG_1                                    = 38,    //һ��-���J4R-A��
        VSB_FAW_JIEFANG_2                                    = 39,    //һ��-���J4R-��ж��,ǣ����
        VSB_FAW_JIEFANG_3                                    = 40,    //һ��-���J6-2004
        VSB_FAW_JIEFANG_4                                    = 41,    //һ��-���J6-�ؿ�
        VSB_FAW_JIEFANG_5                                    = 42,    //һ��-���J6L-�п�
        VSB_FAW_JIEFANG_6                                    = 43,    //һ��-���L5-A��
        VSB_FAW_SAILONG_1                                    = 44,    //һ��-����-�п�
        VSB_FAW_JUNWEI_1                                    = 45,    //һ��-����J5K-�п�
        VSB_FAW_B50_1                                        = 46,    //һ��-����B50-2012,2011,2009
        VSB_FAW_B50_2                                        = 47    //һ��-����B50-2013
}VSB_FAW_CLASS;


//������Ʒ������
typedef enum _VSB_SAICMOTOR_CLASS
{
    VSB_SAICMOTOR_OTHER               = 0,    // ������������
        VSB_HONGYAN_JIESHI_1              = 1,    // ������ά�º���-��ʨ-2012
        VSB_DATONG_V80_1                  = 2     // ������ͨ-V80-2014,2013,2012,2011
}VSB_SAICMOTOR_CLASS;

//����������Ʒ������
typedef enum _VSB_SOUEAST_CLASS
{
    VSB_SOUEAST_OTHER                 = 0,    // ������������
        VSB_SOUEAST_V3_1                  = 1,    // ����-V3����-2011��ֵ�Ҹ���,2010,2009,2008
        VSB_SOUEAST_V3_2                  = 2,    // ����-V3����-2012
        VSB_SOUEAST_V3_3                  = 3,    // ����-V3����-2012�콢��,2011,2010�·�ɰ�
        VSB_SOUEAST_V3_4                  = 4,    // ����-V3����-2012��ɰ�
        VSB_SOUEAST_V5_1                  = 5,    // ����-V5����-2014,2013,2012
        VSB_SOUEAST_XIWANG_1              = 6,    // ����-ϣ��-2011,2010
        VSB_SOUEAST_DELIKA_1              = 7,    // ����-������-2003,2002
        VSB_SOUEAST_DELIKA_2              = 8,    // ����-������-2005
        VSB_SOUEAST_DELIKA_3              = 9,    // ����-������-2008
        VSB_SOUEAST_DELIKA_4              = 10,    // ����-������-2009
        VSB_SOUEAST_LINGSHUAI_1           = 11,    // ����-��˧-2005,2004GLXi
        VSB_SOUEAST_FULIKA_1              = 12,    // ����-������-2005
        VSB_SOUEAST_FULIKA_2              = 13    // ����-������-2007
}VSB_SOUEAST_CLASS;


//����������Ʒ������
typedef enum _VSB_ZTE_CLASS
{
    VSB_ZTE_OTHER                     = 0,        // ������������
        VSB_ZTE_WEIHU_1                   = 1,        // ����-����-2012,2010
        VSB_ZTE_WEIHU_2                   = 2,        // ����-����TUV-2010,2006
        VSB_ZTE_WUXIAN_1                  = 3,        // ����-����-2008
        VSB_ZTE_WUXIAN_2                  = 4         // ����-����-2012,2011,2010,2009
}VSB_ZTE_CLASS;


//�л�������Ʒ������
typedef enum _VSB_ZHONGHUA_CLASS
{
    VSB_ZHONGHUA_OTHER                = 0,    // ������������
        VSB_ZHONGHUA_H230_1               = 1,   // �л�-H230-2012
        VSB_ZHONGHUA_H320_1               = 2,   // �л�-H320-2012
        VSB_ZHONGHUA_H330_1               = 3,   // �л�-H330-2013
        VSB_ZHONGHUA_H530_1               = 4,   // �л�-H530-2012,2011
        VSB_ZHONGHUA_V5_1                 = 5,   // �л�-V5-2012,2011
        VSB_ZHONGHUA_ZUNCHI_1             = 6,   // �л�-���-2004
        VSB_ZHONGHUA_ZUNCHI_2             = 7,   // �л�-���-2005,2003
        VSB_ZHONGHUA_KUBAO_1              = 8,   // �л�-�ᱦ-2007
        VSB_ZHONGHUA_JUNJIE_1             = 9,   // �л�-����-2010,2009,2008,2007,2006
        VSB_ZHONGHUA_JUNJIE_2             = 10,   // �л�-����-2012,2011
        VSB_ZHONGHUA_JUNJIECROSS_1        = 11,   // �л�-����cross-2010,2009
        VSB_ZHONGHUA_JUNJIEFRV_1          = 12,   // �л�-����FRV-2009,2008
        VSB_ZHONGHUA_JUNJIEFRV_2          = 13,   // �л�-����FRV-2010
        VSB_ZHONGHUA_JUNJIEFSV_1          = 14,   // �л�-����FSV-2009
        VSB_ZHONGHUA_JUNJIEFSV_2          = 15,   // �л�-����FSV-2010
        VSB_ZHONGHUA_JUNJIEFSV_3          = 16   // �л�-����FSV-2011
}VSB_ZHONGHUA_CLASS;


//�й�������Ʒ������
typedef enum _VSB_CNHTC_CLASS
{
    VSB_CNHTC_OTHER                   = 0,    // ������������
        VSB_CNHTC_HOKA_2                  = 1,      // �й�����-HOKA-ǣ����,��ж��
        VSB_CNHTC_HOWO_1                  = 2,      // �й�����-HOWO-A7
        VSB_CNHTC_HOWO_2                  = 3,      // �й�����-HOWO-T7H
        VSB_CNHTC_HOWO_3                  = 4,      // �й�����-HOWO-�Ῠ
        VSB_CNHTC_HOWO_4                  = 5,      // �й�����-HOWO�ؿ�-ǣ����
        VSB_CNHTC_HOWO_5                  = 6,      // �й�����-HOWO�ؿ�-��ж��A
        VSB_CNHTC_HOWO_6                  = 7,      // �й�����-HOWO�ؿ�-��ж��B
        VSB_CNHTC_HOWO_7                  = 8,      // �й�����-HOWO�ؿ�-�ػ���A
        VSB_CNHTC_HOWO_8                  = 9,      // �й�����-HOWO�ؿ�-�ػ���C
        VSB_CNHTC_SITAIERWANG_1           = 10,      // �й�����-˹̫����-ǣ����A,�ػ���,���賵
        VSB_CNHTC_HAOHAN_1                = 11,      // �й�����-���-A��
        VSB_CNHTC_HAOYUN_1                = 12,      // �й�����-����-ǣ����B,�ػ���,��ж��
        VSB_CNHTC_JINWANGZI_1             = 13,      // �й�����-�������ؿ�-ǣ����B
        VSB_CNHTC_HOKA_1                  = 14      // �й�����-HOKA-H7
}VSB_CNHTC_CLASS;

//��ͨ��Ʒ������
typedef enum _VSB_ZHONGTONG_CLASS
{
    VSB_ZHONGTONG_OTHER               = 0,  // ������������
        VSB_ZHONGTONG_KAICHI_1            = 1,  // ��ͨ�ͳ�-����A-A��
        VSB_ZHONGTONG_LINGYU_1            = 2,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGXIU_1           = 3,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGHANG_1          = 4,  // ��ͨ�ͳ�-�캽-A��
        VSB_ZHONGTONG_SHIJI_1             = 5,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_KAIXUAN_1           = 6,  // ��ͨ�ͳ�-����-A��
        VSB_ZHONGTONG_LINGYUN_1           = 7,  // ��ͨ�ͳ�-����A-A��
        VSB_ZHONGTONG_YANGGUANG_1         = 8  // ��ͨ�ͳ�-����-A��
}VSB_ZHONGTONG_CLASS;


//������Ʒ������
typedef enum _VSB_JIULONG_CLASS
{
    VSB_JIULONG_OTHER                 = 0,    // ������������
        VSB_JIULONG_JIULONGA5_1           = 1,    // ����-����A5-2011
}VSB_JIULONG_CLASS;

//��̩��Ʒ������
typedef enum _VSB_ZOTYE_CLASS
{
    VSB_ZOTYE_OTHER                  = 0,       // ������������
        VSB_ZOTYE_2008_2                  = 1,      // ��̩-2008-2011,2010,2008
        VSB_ZOTYE_5008_1                  = 2,      // ��̩-5008-2013,2011,2010,2008
        VSB_ZOTYE_Z300_1                  = 3,      // ��̩-Z300-2013,2012
        VSB_ZOTYE_2008_1                  = 4      // ��̩-2008-2007
}VSB_ZOTYE_CLASS;

//��ά����Ʒ������
typedef enum _VSB_NAVECO_CLASS
{
    VSB_NAVECO_OTHER                  = 0,       // ������������
        VSB_NAVECO_Daily_1                = 1,     // ��ά��-Daily-2006,2004,2003
        VSB_NAVECO_Power_1                = 2,     // ��ά��-Power-Daily
        VSB_NAVECO_Turbo_1                = 3,     // ��ά��-Turbo-Daily-2014,2012,2011
        VSB_NAVECO_Venice_1               = 4,     // ��ά��-Venice-2011,2008
        VSB_NAVECO_BAODI_1                = 5,     // ��ά��-����-2012,2009
        VSB_NAVECO_DEYIHUOCHE_1           = 6,     // ��ά��-�������-2011
        VSB_NAVECO_DULING_1               = 7     // ��ά��-����-2010,2009,2007
}VSB_NAVECO_CLASS;

//��ʱ����Ʒ������
typedef enum _VSB_PORSCHE_CLASS
{
    VSB_PORSCHE_OTHER                 = 0,    // ������������
        VBR_PORSCHE_PANAMERA_1            = 1,    // ��ʱ��-panamera-2013,2012,2010
        VBR_PORSCHE_CAYENNE_1             = 2,    // ��ʱ��-����Cayenne-2014,2013,2011,2010
}VSB_PORSCHE_CLASS;


//����˹����Ʒ������
typedef enum _VSB_CHRYSLER_CLASS
{
    VSB_CHRYSLER_OTHER                = 0,    // ������������
        VSB_CHRYSLER_300C_1               = 1,   // ����˹��-300C-2007,2006,2004
        VSB_CHRYSLER_PTMANBUZHE_1         = 2,   // ����˹��-PT������-2007
}VSB_CHRYSLER_CLASS;

//����������Ʒ������
typedef enum _VSB_CADILLAC_CLASS
{
    VSB_CADILLAC_OTHER                = 0,    // ������������
        VSB_CADILLAC_ATS_1                = 1,   // ��������-ATS-2014
        VSB_CADILLAC_CTS_1                = 2,   // ��������-CTS-2012
        VSB_CADILLAC_CTS_3                = 3,   // ��������-CTS-2012��Ӣ�˶���,2011,2010,2009,2008
        VSB_CADILLAC_SLS_1                = 4,   // ��������-SLS����-2007,2006
        VSB_CADILLAC_SLS_2                = 5,   // ��������-SLS����-2012,2011,2010
        VSB_CADILLAC_SRX_1                = 6,   // ��������-SRX-2012,2011,2010,2009
        VSB_CADILLAC_CTS_2                = 7,   // ��������-CTS-2012,2009CTS
        VSB_CADILLAC_KAILEIDE_1           = 8   // ��������-���׵�-2011,2010,2008,2007,2006
}VSB_CADILLAC_CLASS;


//����KAMA��Ʒ������
typedef enum _VSB_KAMA_CLASS
{
    VSB_KAMA_OTHER                    = 0,       // ������������
        VSB_KAMA_QINGKA_2                 = 1,       // ����KAMA-����-�ῨD
        VSB_KAMA_FULAIKA_1                = 2,       // ����KAMA-������-�ῨA
        VSB_KAMA_JINYUNKA_1               = 3,       // ����KAMA-���˿�-�Ῠ
        VSB_KAMA_JUNWEIKA_1               = 4,       // ����KAMA-��������-2014,2011
        VSB_KAMA_QINGKA_1                 = 5       // ����KAMA-����-�ῨC
}VSB_KAMA_CLASS;

//������Ʒ������
typedef enum _VSB_LIFAN_CLASS
{
    VSB_LIFAN_OTHER                   = 0,      // ������������
        VSB_LIFAN_320_1                   = 1,      // ����-320-2012,2011,2009
        VSB_LIFAN_520_1                   = 2,      // ����-520-2007,2006
        VSB_LIFAN_520_2                   = 3,      // ����-520-2013,2011,2010,2008
        VSB_LIFAN_620_1                   = 4,      // ����-620-2012,2010,2009,2008
        VSB_LIFAN_X60_1                   = 5,      // ����-X60-2013,2012,2011
        VSB_LIFAN_FENGSHUN_1              = 6      // ����-��˳-2011
}VSB_LIFAN_CLASS;


//������Ʒ������
typedef enum _VSB_BEIJING_CLASS
{
    VSB_BEIJING_OTHER                 = 0,      // ������������
        VSB_BEIJING_E_1                   = 1,    // ��������-Eϵ������-2014,2013,2012
}VSB_BEIJING_CLASS;

//����������Ʒ������
typedef enum _VSB_BEIBEN_CLASS
{
    VSB_BEIBEN_OTHER                  = 0,      // ������������
        VSB_BEIBEN_NG80_1                 = 1,     // ��������-NG80-�ؿ�A
        VSB_BEIBEN_NG80_2                 = 2,     // ��������-NG80-�ؿ�B
        VSB_BEIBEN_NG80_3                 = 3,     // ��������-NG80-�ؿ�C
        VSB_BEIBEN_V3_1                   = 4,     // ��������-����V3-V3H1
        VSB_BEIBEN_V3_2                   = 5     // ��������-����V3-�ؿ�A
}VSB_BEIBEN_CLASS;

//�����ͳ���Ʒ������
typedef enum _VSB_BEIFANG_CLASS
{
    VSB_BEIFANG_OTHER                 = 0,      // ������������
        VSB_BEIFANG_A_1                   = 1       // �����ͳ�-�ͳ�����1-A��
}VSB_BEIFANG_CLASS;


//����������Ʒ������
typedef enum _VSB_BAW_CLASS
{
    VSB_BAW_OTHER                     = 0,        // ������������
        VSB_BAW_YUSHENG007_1              = 1,        // ��������-��ʤ007-2013,2011
        VSB_BAW_QILING_1                  = 2,        // ��������-����-A��
        VSB_BAW_LUBA_1                    = 3,        // ��������-½��-2004
        VSB_BAW_QISHI_1                   = 4         // ��������-��ʿ-2009,2007
}VSB_BAW_CLASS;

//����������Ʒ������
typedef enum _VSB_BQWEIWANG_CLASS
{
    VSB_BQWEIWANG_OTHER               = 0,  // ������������
        VSB_BQWEIWANG_205_1               = 1,  // ��������-205-2013
        VSB_BQWEIWANG_306_1               = 2   // ��������-306-2014,2013,2011
}VSB_BQWEIWANG_CLASS;


//������Ʒ������
typedef enum _VSB_SMA_CLASS
{
    VSB_SMA_OTHER                     = 0,        // ������������
        VSB_SMA_HAIYU_1                   = 1,        // ����-����-2007,2005,2004
        VSB_SMA_HAIYU_2                   = 2,        // ����-����-2007����MB
        VSB_SMA_HAISHANG_1                = 3,        // ����-����-2008,2005
        VSB_SMA_HAIJING_1                 = 5,        // ����-����-2010,2009
        VSB_SMA_HAIXUN_1                  = 4,        // ����-��Ѹ-2005,2004쭷�
        VSB_SMA_HAIXUN_2                  = 6,        // ����-��Ѹ-2007,2006
}VSB_SMA_CLASS;

//����������Ʒ������
typedef enum _VSB_XINGMA_CLASS
{
    VSB_XINGMA_OTHER                  = 0,        // ������������
        VSB_XINGMA_XINGKAIMA_1            = 1         // ��������-�ǿ���-ǣ������1,�ػ�����1
}VSB_XINGMA_CLASS;

//˫����Ʒ������
typedef enum _VSB_SHUANGHUAN_CLASS
{
    VSB_SHUANGHUAN_OTHER              = 0,        // ������������
        VSB_SHUANGHUAN_SCEO_1             = 1,        // ˫��-SCEO-2011,2009,2006,2005
}VSB_SHUANGHUAN_CLASS;

//������Ʒ������
typedef enum _VSB_JEEP_CLASS
{
    VSB_JEEP_OTHER                    = 0,       // ������������
        VSB_JEEP_DAQIENUOJI_1             = 1,       // ����-����ŵ��(����)-2014,2013,2012,2011
        VSB_JEEP_DAQIENUOJI_2             = 2,       // ����-����ŵ��(����)-2014��������
        VSB_JEEP_ZHINANZHE_1              = 3,       // ����-ָ����-2010,2007
        VSB_JEEP_ZHINANZHE_2              = 4,       // ����-ָ����-2014,2013,2012,2011
        VSB_JEEP_MUMAREN_1                = 5,       // ����-������-2012ʹ���ٻ�������,2011
        VSB_JEEP_MUMAREN_2                = 6,       // ����-������-2014,2013,2012,2011,2010,2009,2008
        VSB_JEEP_ZIYOUKE                  = 7,       // ����-���ɿ�-2014,2013,2012,2011
}VSB_JEEP_CLASS;

//������Ʒ������
typedef enum _VSB_VENUCIA_CLASS
{
    VSB_VENUCIA_OTHER                 = 0,       // ������������
        VSB_VENUCIA_D50_1                 = 1        // ����-D50-2014,2013,2012
}VSB_VENUCIA_CLASS;

//������Ʒ������
typedef enum _VSB_HAFEI_CLASS
{
    VSB_HAFEI_OTHER                   = 0,      // ������������
        VSB_HAFEI_XINMINYI_1              = 1,      // ����-���������-2010
        VSB_HAFEI_XINMINYI_2              = 2,      // ����-�����������-2012
        VSB_HAFEI_MINYI_1                 = 3,      // ����-�������-2006
        VSB_HAFEI_MINYI_2                 = 4,      // ����-���������-2008
        VSB_HAFEI_SAIBAO_1                = 5,      // ����-������-2012
        VSB_HAFEI_SAIMA_1                 = 6,      // ����-����-2002
        VSB_HAFEI_SAIMA_2                 = 7,      // ����-����-2004,2003
        VSB_HAFEI_SAIMA_3                 = 8,      // ����-����-2009
        VSB_HAFEI_LUBAO_1                 = 9,      // ����-·��-2004
        VSB_HAFEI_LUBAO_2                 = 10,      // ����-·��-2008,2007
        VSB_HAFEI_LUBAO_3                 = 11,      // ����-·��-2012
        VSB_HAFEI_LUZUNXIAOBAWANG_1       = 12,      // ����-·��С����-2011,2010
        VSB_HAFEI_RUIYI_1                 = 13,      // ����-����-2009
        VSB_HAFEI_JUNYI_1                 = 14       // ����-����-2012,2010
}VSB_HAFEI_CLASS;

//�ƿ�ŷ����Ʒ������
typedef enum _VSB_TKING_CLASS
{
    VSB_TKING_OTHER                   = 0,      // ������������
        VSB_TKING_OUGUAN_1                = 1,      // �ƿ�ŷ��-ŷ��-2011
        VSB_TKING_OUGUAN_2                = 2,      // �ƿ�ŷ��-ŷ��-�ῨB
        VSB_TKING_OUTENG_1                = 3,      // �ƿ�ŷ��-ŷ��-�ῨA
        VSB_TKING_FUXING_1                = 4,      // �ƿ�ŷ��-����-2006
        VSB_TKING_QINGKAWANG_1            = 5,      // �ƿ�ŷ��-�Ῠ��-�Ῠ
        VSB_TKING_AFANDA_1                = 6,      // �ƿ�ŷ��-������-���ؿ�
        VSB_TKING_JUNQI_1                 = 7       // �ƿ�ŷ��-����-���ؿ�A
}VSB_TKING_CLASS;

//������Ʒ������
typedef enum _VSB_DAEWOO_CLASS
{
    VSB_DAEWOO_OTHER                  = 0,    // ������������
        VBR_DAEWOO_6960H3_1               = 1     // ����-6960H3-A��
}VSB_DAEWOO_CLASS;

//����������Ʒ������
typedef enum _VSB_DAYUN_CLASS
{
    VSB_DAYUN_OTHER                   = 0,     // ������������
        VBR_DAYUN_ZHONGKA_1               = 1      // ��������-�ؿ�-A��
}VSB_DAYUN_CLASS;

//������Ʒ������
typedef enum _VSB_BESTURN_CLASS
{
    VSB_BESTURN_OTHER                 = 0,   // ������������
        VSB_BESTURN_B70_1                 = 1,    // ����-B70-2009,2007,2006
        VSB_BESTURN_B70_2                 = 2,    // ����-B70-2011
        VSB_BESTURN_B70_3                 = 3,    // ����-B70-2011��Ӣ��,2010
        VSB_BESTURN_B70_4                 = 4,    // ����-B70-2012
        VSB_BESTURN_B90_1                 = 5,    // ����-B90-2012
        VSB_BESTURN_AOXING_1              = 6       // һ��-����-2004
}VSB_BESTURN_CLASS;

//������Ʒ������
typedef enum _VSB_WEILIN_CLASS
{
    VSB_WEILIN_OTHER                 = 0,      // ������������
        VSB_WEILIN_H3_1                   = 1,     // ����-H3-2011
        VSB_WEILIN_V5_1                   = 2,     // ����-V5-2012,2009
        VSB_WEILIN_X5_1                   = 3      // ����-X5-2012,2011,2010
}VSB_WEILIN_CLASS;

//��ͨ��Ʒ������
typedef enum _VSB_YUTONG_CLASS
{
    VSB_YUTONG_OTHER                  = 0,     // ������������
        VSB_YUTONG_8XI_1                  = 1,     // ��ͨ-8ϵ-2012,2005
        VSB_YUTONG_KECHE_1                = 2,     // ��ͨ-�ͳ�����10-2013,2010
        VSB_YUTONG_KECHE_3                = 3,     // ��ͨ-�ͳ�����2-A��
        VSB_YUTONG_KECHE_4                = 4,     // ��ͨ-�ͳ�����8-2004
        VSB_YUTONG_KECHE_5                = 5,     // ��ͨ-�ͳ�����9-2014
        VSB_YUTONG_KECHE_2                = 6      // ��ͨ-�ͳ�����12-A��
}VSB_YUTONG_CLASS;

//������Ʒ������
typedef enum _VSB_ANKAI_CLASS
{
    VSB_ANKAI_OTHER                   = 0,      // ������������
        VSB_ANKAI_KECHE_1                 = 1,      // ����-�ͳ�����1-A��
        VSB_ANKAI_KECHE_2                 = 2       // ����-�ͳ�����3-A��
}VSB_ANKAI_CLASS;

//������Ʒ������
typedef enum _VSB_BAOJUN_CLASS
{
    VSB_BAOJUN_OTHER            = 0,   // ������������
        VSB_BAOJUN_630_1                  = 1      // ����-����630-2014,2013,2012,2011
}VSB_BAOJUN_CLASS;

//������Ʒ������
typedef enum _VSB_BINLI_CLASS
{
    VSB_BINLI_OTHER                   = 0,     // ������������
        VSB_BINLI_OULU_1                  = 1      // ����-ŷ½-2009,2008
}VSB_BINLI_CLASS;

//����������Ʒ������
typedef enum _VSB_TRUMPCHE_CLASS
{
    VSB_TRUMPCHE_OTHER                = 0,   // ������������
        VSB_TRUMPCHE_GA5_1                = 1,   // ��������-GA5-2012,2011
        VSB_TRUMPCHE_GA5_2                = 3,   // ��������-GA5-2013,2012�Զ���Ӣ��
        VSB_TRUMPCHE_GS5_1                = 2    // ��������-GS5-2014,2013,2012
}VSB_TRUMPCHE_CLASS;

//�������� ��Ʒ������
typedef enum _VSB_GONOW_CLASS
{
    VSB_GONOW_OTHER                   = 0,   // ������������
        VSB_GONOW_G3_1                    = 1,      // ��������-G3-2011
        VSB_GONOW_G5_1                    = 2,      // ��������-G5-2012,2011
        VSB_GONOW_SHUAIJIAN_1             = 4,      // ��������-˧��-2012,2009
        VSB_GONOW_XINGWANGM1_1            = 3,      // ��������-����M1-2012
        VSB_GONOW_CAIYUN500_1             = 5      // ��������-����500-2010
}VSB_GONOW_CLASS;

//������Ʒ������
typedef enum _VSB_ISUZU_CLASS
{
    VSB_ISUZU_OTHER                   = 0,   // ������������
        VSB_ISUZU_ZHONGXINGSHANGYONG_1    = 1,      // ����-�������ó�-2011
        VSB_ISUZU_WUSHILINGPIKA_1         = 2,      // ����-��ʮ��Ƥ��-2009
        VSB_ISUZU_WUSHILINGPIKA_2         = 3,      // ����-��ʮ��Ƥ��-2014,2009
        VSB_ISUZU_JINGJIZHE_1             = 4      // ����-������-2004,2002
}VSB_ISUZU_CLASS;


//������Ʒ������
typedef enum _VSB_KARRY_CLASS
{
    VSB_KARRY_OTHER                   = 0,   // ������������
        VSB_KARRY_YOU_2                   = 1,      // ����-����-2013,2012
        VSB_KARRY_YOUJIN_1                = 2,      // ����-�ž�-2012,2011������,2010
        VSB_KARRY_YOUSHENG_1              = 3,      // ����-��ʤ-2010
        VSB_KARRY_YOUSHENG_2              = 4,      // ����-��ʤ-2012,2011
        VSB_KARRY_YOUYA                   = 5,      // ����-����-2012,2011,2007
        VSB_KARRY_YOU_1                   = 6      // ����-����-2011,2010,2009
}VSB_KARRY_CLASS;

//�ݱ���Ʒ������
typedef enum _VSB_GAGUAR_CLASS
{
    VSB_GAGUAR_OTHER                  = 0,   // ������������
        VSB_GAGUAR_XF_1                   = 1,     // �ݱ�-XF-2014,2013
        VSB_GAGUAR_XJ_1                   = 2     // �ݱ�-XJ-2014,2013,2012,2011,2010
}VSB_GAGUAR_CLASS;

//˹��³��Ʒ������
typedef enum _VSB_SUBARU_CLASS
{
    VSB_SUBARU_OTHER                  = 0,   // ������������
        VSB_SUBARU_AOHU_1                 = 1,     // ˹��³-����-2012,2011,2010
        VSB_SUBARU_LISHI_1                = 2,     // ˹��³-��ʨ�γ�-2008,2006
        VSB_SUBARU_LISHI_2                = 3,     // ˹��³-��ʨ�γ�-2011,2010
        VSB_SUBARU_XV_1                   = 4,     // ˹��³-˹��³XV-2014,2012
        VSB_SUBARU_SENLINREN_1            = 5,     // ˹��³-ɭ����-2007,2006
        VSB_SUBARU_SENLINREN_2            = 6     // ˹��³-ɭ����-2012,2011,2010,2009,2008
}VSB_SUBARU_CLASS;

//ʱ��������Ʒ������
typedef enum _VSB_ERA_CLASS
{
    VSB_ERA_OTHER                     = 0,   // ������������
        VSB_ERA_XIAOKA_1                  = 1,        // ʱ������-С��֮��-С��֮��1,2,Q2
        VSB_ERA_XIAOKA_3                  = 2,        // ʱ������-С��֮��-С��֮��5
        VSB_ERA_XIAOKA_4                  = 3,        // ʱ������-С��֮��-����
        VSB_ERA_KANGRUI_1                 = 4,        // ʱ������-����-����H1
        VSB_ERA_KANGRUI_2                 = 5,        // ʱ������-����-����H3
        VSB_ERA_KANGRUI_3                 = 6,        // ʱ������-����-����K1,KQ1
        VSB_ERA_RUIWO_1                   = 7,        // ʱ������-����-RC1
        VSB_ERA_RUIWO_2                   = 8,        // ʱ������-����-RC2
        VSB_ERA_RUIWO_3                   = 9,        // ʱ������-����-����II�ῨA
        VSB_ERA_JINGANG                   = 10,        // ʱ������-���-���568
        VSB_ERA_LINGHANG_1                = 11,        // ʱ������-�캽-�캽2
        VSB_ERA_LINGHANG_2                = 12,        // ʱ������-�캽-�캽3
        VSB_ERA_YULING_1                  = 13,        // ʱ������-Ԧ��-Ԧ��V1
        VSB_ERA_YULING_2                  = 14,        // ʱ������-Ԧ��-Ԧ��V5,VQ5
        VSB_ERA_YULING_3                  = 15,        // ʱ������-Ԧ��-Ԧ��VQ1,VQ2
        VSB_ERA_YULING_4                  = 17,        // ʱ������-Ԧ��-����
        VSB_ERA_XIAOKA_2                  = 17,        // ʱ������-С��֮��-С��֮��3
}VSB_ERA_CLASS;

//������Ʒ������
typedef enum _VSB_CHANGHE_CLASS
{
    VSB_CHANGHE_OTHER           = 0,  // ������������
        VSB_CHANGHE_CH6321_1        = 1,  // ����-CH6321-2000
        VSB_CHANGHE_DANSHUANGPAI_1  = 2,  // ����-�����µ�˫��-1999
        VSB_CHANGHE_AIDIER_1        = 3,  // ����-���϶�-2004
        VSB_CHANGHE_AIDIER_2        = 4,  // ����-���϶���-2007,2006
        VSB_CHANGHE_FURUIDA_1       = 5   // ����-����������-2014,2013,2011,2009
}VSB_CHANGHE_CLASS;

//ŷ����Ʒ������
typedef enum _VSB_OPEL_CLASS
{
    VSB_OPEL_OTHER              = 0,    // ������������
        VSB_OPEL_YATE_1             = 1     // ŷ��-����-2010GTCȫ���絲��,2007,2006
}VSB_OPEL_CLASS;

//��Դ��Ʒ������
typedef enum _VSB_JONWAY_CLASS
{
    VSB_JONWAY_OTHER            = 0,   // ������������
        VSB_JONWAY_A380_1           = 1    // ��Դ-A380-2010,2009,2008
}VSB_JONWAY_CLASS;

//������Ʒ������
typedef enum _VSB_JIANGNAN_CLASS
{
    VSB_JIANGNAN_OTHER          = 0,   // ������������
        VSB_JIANGNAN_TT_1           = 1    // ����-����TT-2011,2010,2004
}VSB_JIANGNAN_CLASS;

//����ȫ��ӥ��Ʒ������
typedef enum _VSB_GLEAGLE_CLASS
{
    VSB_GLEAGLE_OTHER                      = 0,   // ������������
        VSB_GLEAGLE_EAGLE_GC7_1                = 1,   // ����ȫ��ӥ-GC7-2013,2012
        VSB_GLEAGLE_EAGLE_GX2_1                = 2,   // ����ȫ��ӥ-GX2-2012,2011
        VSB_GLEAGLE_EAGLE_GX7_1                = 3,   // ����ȫ��ӥ-GX7-2013,2012
        VSB_GLEAGLE_EAGLE_PANDA_1              = 4,   // ����ȫ��ӥ-��è-2013,2011,2010,2009
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_1          = 5,   // ����ȫ��ӥ-���ɽ�-2009���±�׼��,2007
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_2          = 6,   // ����ȫ��ӥ-���ɽ�-2010,2009,2008,2006,2005
        VSB_GLEAGLE_EAGLE_ZIYOUJIAN_3          = 7,   // ����ȫ��ӥ-���ɽ�-2012,2011
        VSB_GLEAGLE_EAGLE_YUANJING_1           = 8,   // ����ȫ��ӥ-Զ��-2011,2010,2009,2008,2006
        VSB_GLEAGLE_EAGLE_YUANJING_2           = 9,   // ����ȫ��ӥ-Զ��-2013,2012
}VSB_GLEAGLE_CLASS;

//�����ۺ���Ʒ������
typedef enum _VSB_EMGRAND_CLASS
{
    VSB_EMGRAND_OTHER                      = 0,   // ������������
        VSB_EMGRAND_EC7_2                      = 1,   // �����ۺ�-EC7-2013
        VSB_EMGRAND_EC7_3                      = 2,   // �����ۺ�-EC7-RV
        VSB_EMGRAND_EC8_1                      = 3,   // �����ۺ�-EC8-2013,2011,2010
        VSB_EMGRAND_EC7_1                      = 4    // �����ۺ�-EC7-2012,2010,2009
}VSB_EMGRAND_CLASS;


//����Ӣ����Ʒ������
typedef enum _VSB_ENGLON_CLASS
{
    VSB_ENGLON_OTHER                       = 0,    // ������������
        VSB_ENGLON_SC3_1                       = 1,    // ����Ӣ��-SC3-2012
        VSB_ENGLON_SC5_1                       = 2,    // ����Ӣ��-SC5-RV-2012
        VSB_ENGLON_SC6_1                       = 3,    // ����Ӣ��-SC6-2012
        VSB_ENGLON_SC7_1                       = 4,    // ����Ӣ��-SC7-2013,2012,2011,2010
        VSB_ENGLON_SX7_1                       = 5,    // ����Ӣ��-SX7-2014,2013
        VSB_ENGLON_JINGANG_1                   = 6,    // ����Ӣ��-���-2010,2007,2006
        VSB_ENGLON_JINYING_1                   = 7     // ����Ӣ��-��ӥ-2011,2010,2008
}VSB_ENGLON_CLASS;


//����-��Ʒ������
typedef enum _VSB_JAC_CLASS
{
    VSB_JAC_OTHER               = 0,      // ������������
        VSB_JAC_TONGYUE_1           = 1,      // ����-ͬ��-2012,2010,2008
        VSB_JAC_HEYUE_1             = 2,      // ����-����-2012,2011,2010
        VSB_JAC_HEYUEA30_2          = 3,      // ����-����A30-2013
        VSB_JAC_HEYUERS_3           = 4,      // ����-����RS-2012,2011
        VSB_JAC_HAOYUN_1            = 5,      // ����-����-�Ῠ1
        VSB_JAC_WEILING_2           = 6,      // ����-����-�Ű��Ῠ
        VSB_JAC_WEILING_3           = 7,      // ����-����-�����ػ���
        VSB_JAC_WEILING_4           = 8,      // ����-����-�Ῠ
        VSB_JAC_KECHE_1             = 9,      // ����-�ͳ�-A��
        VSB_JAC_BINYUE_1            = 10,      // ����-����-2010,2008
        VSB_JAC_SHUAILING_2         = 11,      // ����-˧��-�Ῠ
        VSB_JAC_KANGLING_1          = 12,      // ����-����-�Ῠ1
        VSB_JAC_KANGLING_2          = 13,      // ����-����-�Ῠ2
        VSB_JAC_YUEYUE_1            = 14,      // ����-����-2013,2012,2011,2010
        VSB_JAC_XINGRUI_1           = 15,      // ����-����-2012,2011
        VSB_JAC_GEERFA_H_1          = 16,      // ����-�����H-�����ػ���
        VSB_JAC_GEERFA_K_2          = 17,      // ����-�����K-�ؿ�1
        VSB_JAC_GEERFA_K_3          = 18,      // ����-�����K-�ؿ�2
        VSB_JAC_GEERFA_M_4          = 19,      // ����-�����M-�����ػ���
        VSB_JAC_RUIFENG_1           = 20,      // ����-���-2011,2009,2007�ֶ�
        VSB_JAC_RUIFENG_2           = 21,      // ����-���-2013,2012,2011,2010,2007,2005
        VSB_JAC_RUIFENG_3           = 22,      // ����-���M5-2012,2011
        VSB_JAC_RUIFENG_4           = 23,      // ����-���S5-2013
        VSB_JAC_RUIYING_1           = 24,      // ����-��ӥ-2009,2007
        VSB_JAC_RUIYING_2           = 25,      // ����-��ӥ-2013,2012,2011
        VSB_JAC_JUNLING_2           = 26,      // ����-����-խ���,�����
        VSB_JAC_WEILING_1           = 27,      // ����-����-��ʽ�Ῠ
        VSB_JAC_SHUAILING_1         = 28,      // ����-˧��-��ʮ��
        VSB_JAC_RUILING_1           = 29,      // ����-����-2012
        VSB_JAC_JUNLING_1           = 30      // ����-����-�콢��
}VSB_JAC_CLASS;


//������Ʒ������
typedef enum _VSB_JMC_CLASS
{
    VSB_JMC_OTHER               = 0,      // ������������
        VSB_JMC_KAIYUN_1            = 1,      // ����-����-102,109�����Ῠ
        VSB_JMC_KAIYUN_2            = 2,      // ����-����-95�����Ῠ
        VSB_JMC_YUHU_1              = 3,      // ����-��-2012
        VSB_JMC_BAODIAN_1           = 4,      // ����-����-2007
        VSB_JMC_BAODIAN_2           = 5,      // ����-����-2009��׼��,2008
        VSB_JMC_BAODIAN_3           = 6,      // ����-����-2014,2012,2009������
        VSB_JMC_BAOWEI_1            = 7,      // ����-����-2005
        VSB_JMC_BAOWEI_2            = 8,      // ����-����-2009
        VSB_JMC_QUANSHUN_1          = 9,      // ����-����������ȫ˳-2010,2008
        VSB_JMC_QUANSHUN_2          = 10,      // ����-����ȫ˳-2006
        VSB_JMC_QUANSHUN_3          = 11,      // ����-����ȫ˳-2013,2011,2010
        VSB_JMC_SHUNDA_1            = 12,      // ����-˳��-2004,2003
        VSB_JMC_SHUNDA_2            = 13,      // ����-˳��-2011,2010,2008
        VSB_JMC_YUSHENG_1           = 14,      // ����-Ԧʤ-2013
        VSB_JMC_YUSHENG_2           = 15       // ����-Ԧʤ-2013�ֶ���װ��,2012,2011
}VSB_JMC_CLASS;

// �ֶ�����Ʒ������
typedef enum _VSB_VOLVO_CLASS
{
    VSB_VOLVO_OTHER             = 0,   // ������������
        VSB_VOLVO_C30_1             = 1,    // �ֶ���-C30-2013,2012,2011,2010
        VSB_VOLVO_S40_1             = 2,    // �ֶ���-S40-2012,2011,2010,2009,2008,2007
        VSB_VOLVO_S60_1             = 3,    // �ֶ���-S60-2003
        VSB_VOLVO_S60_2             = 4,    // �ֶ���-S60-2013,2012,2011
        VSB_VOLVO_S80L_1            = 5,    // �ֶ���-S80L-2012,2011,2010,2009
        VSB_VOLVO_XC60_1            = 6,    // �ֶ���-XC60-2013,2012,2011,2010,2009
        VSB_VOLVO_XC90_1            = 7     // �ֶ���-XC90-2013,2012,2011,2008
}VSB_VOLVO_CLASS;

// ������Ʒ������
typedef enum _VSB_HIGER_CLASS
{
    VSB_HIGER_OTHER             = 0,   // ������������
        VSB_HIGER_H8_1              = 1,    // ����-H8-A��
        VSB_HIGER_H92_1             = 2,    // ����-H92-A��
        VSB_HIGER_V7_1              = 3,    // ����-V7,V8-2006
        VSB_HIGER_KECHE_1           = 4,    // ����-�ͳ�����5-A��
        VSB_HIGER_LONGWEI_1         = 5,    // ����-����-2012,2011
        VSB_HIGER_H7V_1             = 6     // ����-����H7V-2010
}VSB_HIGER_CLASS;

// ������Ʒ������
typedef enum _VSB_RUILIN_CLASS
{
    VSB_RUILIN_OTHER            = 0,   // ������������
        VSB_RUILIN_G3_1             = 1,   // ����-G3-2012,2010
        VSB_RUILIN_G5_1             = 2,   // ����-G5-2012,2011,2010
        VSB_RUILIN_M1_1             = 3,   // ����-M1-2013,2011,2010,2009
        VSB_RUILIN_X1_1             = 4,   // ����-X1-2012A,2011,2010
        VSB_RUILIN_X1_2             = 5    // ����-X1-2012B
}VSB_RUILIN_CLASS;

// ������Ʒ������
typedef enum _VSB_SHENLONG_CLASS
{
    VSB_SHENLON_OTHER                  = 0,         // ������������
        VSB_SHENLONG_KECHE_1               = 1          //�����ͳ�-�ͳ�����4-A��
}VSB_SHENLONG_CLASS;

// ������Ʒ������
typedef enum _VSB_FOTON_CLASS
{
    VSB_FOTON_OTHER                    = 0,            // ������������
        VSB_FOTON_AOLING_1                 = 1,            // ����-����-�п�
        VSB_FOTON_AOLING_2                 = 2,            // ����-����-��ʽ����
        VSB_FOTON_AOLING_3                 = 3,            // ����-����-����TX,CTX
        VSB_FOTON_OUMAN_1                  = 4,            // ����-ŷ��-GTL6ϵB
        VSB_FOTON_OUMAN_2                  = 5,            // ����-ŷ��-TX6ϵ,9ϵ
        VSB_FOTON_OUMAN_3                  = 6,            // ����-ŷ��-ŷ���ؿ�1
        VSB_FOTON_OUMAN_4                  = 7,            // ����-ŷ��-��ʨ6ϵ,9ϵ
        VSB_FOTON_OUHUI_1                  = 8,            // ����-ŷ�Կͳ�-D��
        VSB_FOTON_OUMAKE_1                 = 9,            // ����-ŷ���-3ϵ
        VSB_FOTON_OUMAKE_2                 = 10,            // ����-ŷ���-5ϵ
        VSB_FOTON_SAPU_1                   = 11,            // ����-����-2011
        VSB_FOTON_SAPU_3                   = 12,            // ����-����-2011���͹���
        VSB_FOTON_MENGPAIKE_1              = 13,            // ����-���ɿ�-2013
        VSB_FOTON_MIDI_1                   = 14,            // ����-�Ե�-2011,2009
        VSB_FOTON_FENGJING_1               = 15,            // ����-�羰ϵ��-2012,2011,2009
        VSB_FOTON_SAPU_2                  = 16            // ����-����-2011����������Z7
}VSB_FOTON_CLASS;

//������Ʒ������
typedef enum _VSB_FODAY_CLASS
{
    VSB_FODAY_OTHER                    = 0,            // ������������
        VSB_FODAY_CHAOREN_1                = 1,            // ����-С����Ƥ��-2009,2006
        VSB_FODAY_CHAOREN_2                = 2,            // ����-С����Ƥ��-2011
        VSB_FODAY_TANSUOZHE_1              = 3,            // ����-̽����6-2013,2011,2010
        VSB_FODAY_TANSUOZHE_2              = 4,            // ����-̽���ߢ�-2011,2010,2009
        VSB_FODAY_TANSUOZHE_3              = 5,            // ����-̽���ߢ�-2011,2004
        VSB_FODAY_XIONGSHI_1               = 6             // ����-��ʨF16Ƥ��-2012
}VSB_FODAY_CLASS;

// ������Ʒ������
typedef enum _VSB_HONGQI_CLASS
{
    VSB_HONGQI_OTHER                   = 0,         // ������������
        VSB_HONGQI_MINGSHI_1               = 1           // ����-����-2007,2003,2001,2000,1999
}VSB_HONGQI_CLASS;


// ���ǽ� ��Ʒ������
typedef enum _VSB_LUXGEN_CLASS
{
    VSB_LUXGEN_OTHER                   = 0,         // ������������
        VSB_LUXGEN_DASEVEN_1               = 1          // ���ǽ�-��7-SUV
}VSB_LUXGEN_CLASS;

// ������Ʒ������
typedef enum _VSB_XIALI_CLASS
{
    VSB_XIALI_OTHER                    = 0,         // ������������
        VSB_XIALI_QIBING_1                 = 1,         // ����(����)-���-2010
}VSB_XIALI_CLASS;

// ��ۿͳ���Ʒ������
typedef enum _VSB_SHUCHI_CLASS
{
    VSB_SHUCHI_OTHER                   = 0,         // ������������
        VSB_SHUCHI_A_1                     = 1          // ��ۿͳ�-�ͳ�-A��
}VSB_SHUCHI_CLASS;

//Ӣ�������Ʒ������
typedef enum _VSB_INFINITI_CLASS
{
    VSB_INFINITI_OTHER                 = 0,         // ������������
        VSB_INFINITI_EX_1                  = 1,         // Ӣ�����-EX-2013,2011,2010,2009,2008
        VSB_INFINITI_FX_1                  = 2,         // Ӣ�����-FX-2007
        VSB_INFINITI_FX_2                  = 3,         // Ӣ�����-FX-2011,2010,2009
        VSB_INFINITI_FX_3                  = 4,         // Ӣ�����-FX-2013,2012FX35
        VSB_INFINITI_G_1                   = 5,         // Ӣ�����-G-2013,2010
        VSB_INFINITI_JX_1                  = 6          // Ӣ�����-JX-2013,2011
}VSB_INFINITI_CLASS;


// ������Ʒ������
typedef enum _VSB_LOTUS_CLASS
{
    VSB_LOTUS_OTHER                    = 0,            // ������������
        VSB_LOTUS_L3_1                     = 1,            // ����-L3����-2010������,2009
        VSB_LOTUS_L3_2                     = 2             // ����-L5����-2012,2011
}VSB_LOTUS_CLASS;

//��������Ʒ������
typedef enum _VSB_FIAT_CLASS
{
    VSB_FIAT_OTHER                     = 0,            // ������������
        VSB_FIAT_FEIYUE_1                  = 1             // ������-��Ծ-2014,2013,2012
}VSB_FIAT_CLASS;

//ک����Ʒ������
typedef enum _VSB_OGA_CLASS
{
    VSB_OGA_OTHER                      = 0,              // ������������
        VSB_OGA_MDX_1                      = 1,              // ک��-MDX-2010
        VSB_OGA_MDX_2                      = 2               // ک��-MDX-2011
}VSB_OGA_CLASS;



// Ծ����Ʒ������
typedef enum _VSB_YUEJIN_CLASS
{
    VSB_YUEJIN_OTHER                   = 0,           // ������������
        VSB_YUEJIN_SHUAIHU_1               = 1,           // Ծ��-˧��-H100,H300
        VSB_YUEJIN_CAISHEN_1               = 2,           // Ծ��-����-S100
        VSB_YUEJIN_CAISHEN_2               = 3,           // Ծ��-����-S300
        VSB_YUEJIN_CAISHEN_3               = 4            // Ծ��-����-S500
}VSB_YUEJIN_CLASS;

//Ұ����Ʒ������
typedef enum _VSB_YEMA_CLASS
{
    VSB_YEMA_OTHER                     = 0,        // ������������
        VSB_YEMA_F99_1                     = 1            // Ұ��-F99-2012,2011,2010,2009 
}VSB_YEMA_CLASS;

//������Ʒ������
typedef enum _VSB_SZKINGLONG_CLASS
{
    VSB_SZKINGLONG_OTHER               = 0,        // ������������
        VSB_SZKINGLONG_BUS11_1             = 1,       // ����-�ͳ�����11-A��
        VSB_SZKINGLONG_BUS12_1             = 2,       // ����-�ͳ�����12-A��
        VSB_SZKINGLONG_BUS13_1             = 3,       // ����-�ͳ�����13-A��
        VSB_SZKINGLONG_BUS14_1             = 4,       // ����-�ͳ�����14-A��
        VSB_SZKINGLONG_BUS16_1             = 5,       // ����-�ͳ�����16-A��
        VSB_SZKINGLONG_BUS18_1             = 6,       // ����-�ͳ�����18-A��
        VSB_SZKINGLONG_BUS1_1              = 7,       // ����-�ͳ�����1-A��
        VSB_SZKINGLONG_BUS20_1             = 8,       // ����-�ͳ�����20-A��
        VSB_SZKINGLONG_BUS2_1              = 9,       // ����-�ͳ�����2-A��
        VSB_SZKINGLONG_BUS5_1              = 10,       // ����-�ͳ�����5-A��
        VSB_SZKINGLONG_BUS6_1              = 11,       // ����-�ͳ�����6-A��
        VSB_SZKINGLONG_BUS9_1              = 12,       // ����-�ͳ�����9-A��
        VSB_SZKINGLONG_BUS10_1             = 13,       // ����-�ͳ�����10-A��
        VSB_SZKINGLONG_BUS15_1             = 14        // ����-�ͳ�����15-A��
}VSB_SZKINGLONG_CLASS;

//�����Ա���Ʒ������
typedef enum _VSB_CHANGFENG_CLASS
{
    VSB_CHANGFENG_OTHER                = 0,        // ������������
        VSB_CHANGFENG_CS7_1                = 1,        // �����Ա�-CS7-2009
        VSB_CHANGFENG_QIBING_1             = 2,        // �����Ա�-���-2010,2009
        VSB_CHANGFENG_LIEBAO_1             = 3,        // �����Ա�-�Ա�CS6-2010,2008
        VSB_CHANGFENG_FULING_1             = 4,        // �����Ա�-����Ƥ��-A��
        VSB_CHANGFENG_FEIYANG_1            = 5,        // �����Ա�-����Ƥ��-2010,2009,2005
        VSB_CHANGFENG_FEITENG_1            = 6,        // �����Ա�-����-2010,2009,2006
        VSB_CHANGFENG_BLACKJINGANG_1       = 7,        // �����Ա�-�ڽ��-2013,2010,2009,2008,2006
}VSB_CHANGFENG_CLASS;

//½����Ʒ������
typedef enum _VSB_LUFENG_CLASS
{
    VSB_LUFENG_OTHER                   = 0,           // ������������
        VSB_LUFENG_X6_1                    = 1,           // ½��-X6-2005
        VSB_LUFENG_X6_2                    = 2,           // ½��-X6-2006
        VSB_LUFENG_X6_3                    = 3,           // ½��-X6-2011,2010,2008,2007
        VSB_LUFENG_LUFENGX5_1              = 4,           // ½��-½��X5-2013
        VSB_LUFENG_LUFENGX8_1              = 5,           // ½��-½��X8-2013,2012,2011,2009
        VSB_LUFENG_LUFENGX8_2              = 6,           // ½��-½��X8-2014,2012̽����
        VSB_LUFENG_FENGHUA_1               = 7,           // ½��-�绪-2008,2007
        VSB_LUFENG_X6_4                    = 8,           // ½��-X6-2011����
        VSB_LUFENG_FENGSHANG_1             = 9            // ½��-����-2011,2006 
}VSB_LUFENG_CLASS;

//�����ؿ���Ʒ������
typedef enum _VSB_SHANQI_CLASS
{
    VSB_SHANQI_OTHER                   = 0,           // ������������
        VSB_SHANQI_AOLONG_1                = 1,           // �����ؿ�-����-�ؿ�A
        VSB_SHANQI_AOLONG_2                = 2,           // �����ؿ�-����-�ؿ�B
        VSB_SHANQI_DELONG_1                = 3,           // �����ؿ�-����F2000-4X2ǣ����
        VSB_SHANQI_DELONG_2                = 4,           // �����ؿ�-����F3000-B��
        VSB_SHANQI_DELONG_3                = 5,           // �����ؿ�-����M3000-�ؿ� 
}VSB_SHANQI_CLASS;


//Ұ����Ʒ������
typedef enum _VSB_RENAULT_CLASS
{
    VSB_RENAULT_OTHER                  = 0,          // ������������
        VSB_RENAULT_MEIGANNA_1             = 1,          // ��ŵ-÷����-2006
        VSB_RENAULT_KELEIAO_1              = 2,          // ��ŵ-���װ�-2010,2009
        VSB_RENAULT_KELEIAO_2              = 3,          // ��ŵ-���װ�-2013,2012
        VSB_RENAULT_SCENE_1                = 4,          // ��ŵ-�羰-2007
        VSB_RENAULT_FENGLANG_1             = 5,          // ��ŵ-����-2011
        VSB_RENAULT_TAFEIKE_1              = 6           // ��ŵ-���ƿ�-2004    
}VSB_RENAULT_CLASS;

//�ƺ���Ʒ������
typedef enum _VSB_HUANGHAI_CLASS
{
    VSB_HUANGHAI_OTHER                 = 0,         // ������������
        VSB_HUANGHAI_DACAISHEN_1           = 1,         // �ƺ�-�����-2013,2012
        VSB_HUANGHAI_DACAISHEN_2           = 2,         // �ƺ�-�����-2013,2012,2011,2010,2009���Ͱ�
        VSB_HUANGHAI_BUS4_1                = 3,         // �ƺ�-�ͳ�����4-2012,2011
        VSB_HUANGHAI_CHALLENGER_1          = 4,         // �ƺ�-��ս��-2011,2010,2009,2008
        VSB_HUANGHAI_AOLONGCUV_1           = 5,         // �ƺ�-����CUV-2010,2009
        VSB_HUANGHAI_AOJUN_1               = 6,         // �ƺ�-����-2009
        VSB_HUANGHAI_AOJUN_2               = 7,         // �ƺ�-����-2010,2009
        VSB_HUANGHAI_QISHENGV3_1           = 8,         // �ƺ�-��ʤV3-2011
        VSB_HUANGHAI_LINGHANGZHE_1         = 9,         // �ƺ�-�캽��-2007,2005
        VSB_HUANGHAI_FENGCHI_1             = 10         // �ƺ�-���-A��
}VSB_HUANGHAI_CLASS;

/********************����Ʒ��������End*************************/

//������Ϣ
typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;          //�������
    BYTE  byVehicleType;    //�������� 0 ��ʾ�������ͣ�1 ��ʾС�ͳ���2 ��ʾ���ͳ� ,3��ʾ���˴��� ,4��ʾ���ֳ����� 5��ʾ���ֳ�����(3.5Ver)  6��ʾ����������
    BYTE  byColorDepth;        //������ɫ��ǳ
    BYTE  byColor;          //������ɫ,�ο�VCR_CLR_CLASS
    /*�״��쳣״̬��
    0~�״�������
    1~�״����
    2~�״�һֱ����ĳһ����ͬ�ٶ�ֵ
    3~�״��ͳ�����Ϊ0
    4~�״��ͳ����ݹ�����߹�С
    */
    BYTE  byRadarState;
    WORD  wSpeed;           //��λkm/h
    WORD  wLength;          //ǰһ�����ĳ�����  
                            /*Υ�����ͣ�0-������1-���٣�2-���٣�3-���У�4-�����,5-ѹ������,6-��������7-·��������
                            8-��ռ�ǣ�9-Υ�������10-�������� 11-Υ�����12-·��ͣ����13-�̵�ͣ��, 14-δ��������(Υ������1357), 
    15-Υ��ͣ����16-Υ�µ�ͷ,17-ռ��Ӧ������,18-����,19-����,20-ѹ����,21-δϵ��ȫ��,22-���˴����,23-����,24-Υ��ʹ��Զ��ƣ�
    25-��ʻʱ��������ֳֵ绰��26-��ת����ֱ�У�27-��ת������ת��28-��ͷ����ֱ�У�29-����Сת, 30-���̵ƣ�31-δ��ͷ����
    32-�ǻ��������ˣ�33-�ǻ�����ռ�û���������34-�ǻ�������ɡ��, 35-���̳�, 36-����,37-ѹ��ͣ��,38-��λͣ��,39-ѹ���ҿ�λͣ��
    40-�����ҷ���·�������� 41-���뻷��·��δ������·���ڵĻ��������� 42-���������ѵ�������·δ����
    */
    BYTE  byIllegalType;
    BYTE  byVehicleLogoRecog; //�ο�ö������ VLR_VEHICLE_CLASS
    BYTE  byVehicleSubLogoRecog; //����Ʒ��������ʶ�𣻲ο�VSB_VOLKSWAGEN_CLASS��������ö�١�
    BYTE  byVehicleModel; //������Ʒ����0-δ֪���ο�"������Ʒ�����.xlsx"
    BYTE  byCustomInfo[16];  //�Զ�����Ϣ
    WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" (���ֶμ���byVehicleLogoRecog);
    BYTE  byIsParking;//�Ƿ�ͣ�� 0-��Ч��1-ͣ����2-δͣ��
    BYTE  byRes;//�����ֽ�
    DWORD dwParkingTime; //ͣ��ʱ�䣬��λ��s
    BYTE  byBelieve; //byIllegalType���Ŷȣ�1-100
    BYTE  byCurrentWorkerNumber;//��ǰ��ҵ����
    BYTE  byCurrentGoodsLoadingRate;//��ǰ����װ���� 0-�� 1-�� 2-�� 3-�� 4-��
    BYTE  byDoorsStatus;//����״̬ 0-���Źر� 1-���ſ���
    BYTE  byRes3[4];
}NET_DVR_VEHICLE_INFO, *LPNET_DVR_VEHICLE_INFO;

//���Ƽ����
typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;            //�ṹ����
    BYTE    byResultType;    //0-��Ƶʶ������1ͼ��ʶ���� 2 ����10Mʱ������·��
    BYTE    byChanIndex;    //ͨ����
    WORD    wAlarmRecordID;    //����¼��ID(���ڲ�ѯ¼�񣬽���byResultTypeΪ2ʱ��Ч)
    DWORD   dwRelativeTime;    //���ʱ���  
    BYTE    byAbsTime[32];    //����ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999�����룩
    DWORD   dwPicLen;        //ͼƬ����(����ͼ)
    DWORD    dwPicPlateLen;  //����СͼƬ����
    DWORD   dwVideoLen;        //¼�����ݳ���
    BYTE    byTrafficLight;    //0-�Ǻ��̵�ץ�ģ�1-�̵�ʱץ�ģ�2-���ʱץ��
    BYTE    byPicNum;       //���ĵ�ͼƬ���
    BYTE    byDriveChan;    //����������
    BYTE     byVehicleType; //�������ͣ��ο�VTR_RESULT
    DWORD   dwBinPicLen;    //���ƶ�ֵͼ����
    DWORD   dwCarPicLen;    //����ԭͼ����
    DWORD   dwFarCarPicLen; //Զ��ͼ����
    BYTE    *pBuffer3;      //���ƶ�ֵͼ
    BYTE    *pBuffer4;      //����ԭͼ
    BYTE    *pBuffer5;      //Զ��ͼ
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //����������ʻ�ķ���0��ʾ�������£�1��ʾ�������ϣ�����ʵ�ʳ�������ʻ�����������֣�,2��ʾδ֪
    BYTE    byRes3[6];   
    NET_DVR_PLATE_INFO  struPlateInfo;    //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE    *pBuffer1;                   // ���ϴ�����ͼƬ(����ͼ)��ָ��ָ��ͼƬ��Ϣ�����ϴ�������Ƶ��ָ��ָ����Ƶ��Ϣ�����������ͼƬ����Ƶ��Ϣ����NULL(DVS��������ͼ)
    BYTE    *pBuffer2;                  // ���ϴ�����ͼƬ(����ͼ)ʱ��ָ����ͼƬ��ָ�루DVS���Ʋ�ͼ��
}NET_DVR_PLATE_RESULT, *LPNET_DVR_PLATE_RESULT;
//�������ͼƬ���ݺ�¼�����ݣ�ֻ��һ�֣�ͼƬ����Ϊ����ͼƬ+����СͼƬ

typedef struct tagNET_VPD_SHUTTER
{
    DWORD dwCommmand;    //����:0,������ 1,���� 2,���� 3,���� 4,ֱ���������ֵ
    DWORD dwCode;       //����ֵ, ������dwCommmandΪ4, �ò�������Ϊ��
    BYTE  byRes[60];            //����
}NET_VPD_SHUTTER, *LPNET_VPD_SHUTTER;

//ͼ�������Ϣ����        
typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD        dwSize;
    BYTE        byOverlayInfo;//����ʹ�ܿ��أ�0-�����ӣ�1-����
    BYTE        byOverlayMonitorInfo;//�Ƿ���Ӽ�����Ϣ��0-�����ӣ�1-����
    BYTE        byOverlayTime;//�Ƿ����ʱ�䣬0-�����ӣ�1-����
    BYTE        byOverlaySpeed;//�Ƿ�����ٶȣ�0-�����ӣ�1-����
    BYTE        byOverlaySpeeding;//�Ƿ���ӳ��ٱ�����0-�����ӣ�1-����
    BYTE        byOverlayLimitFlag;//�Ƿ�������ٱ�־��0-�����ӣ�1-����
    BYTE        byOverlayPlate;//�Ƿ���ӳ��ƺţ�0-�����ӣ�1-����
    BYTE        byOverlayColor;//�Ƿ���ӳ�����ɫ��0-�����ӣ�1-����
    BYTE        byOverlayLength;//�Ƿ���ӳ�����0-�����ӣ�1-����
    BYTE        byOverlayType;//�Ƿ���ӳ��ͣ�0-�����ӣ�1-����
    BYTE        byOverlayColorDepth;//�Ƿ���ӳ�����ɫ��ǳ��0-�����ӣ�1-����
    BYTE        byOverlayDriveChan;//�Ƿ���ӳ�����0-�����ӣ�1-����
    BYTE        byOverlayMilliSec; //���Ӻ�����Ϣ 0-�����ӣ�1-����
    BYTE        byOverlayIllegalInfo; //����Υ����Ϣ 0-�����ӣ�1-����
    BYTE        byOverlayRedOnTime;  //���Ӻ������ʱ�� 0-�����ӣ�1-����
    BYTE        byFarAddPlateJpeg;      //Զ��ͼ�Ƿ���ӳ��ƽ�ͼ,0-������,1-����
    BYTE        byNearAddPlateJpeg;      //����ͼ�Ƿ���ӳ��ƽ�ͼ,0-������,1-����
    BYTE        byRes1[3];    //����
    BYTE        byMonitorInfo1[32];    //������Ϣ1
    BYTE        byMonitorInfo2[44]; //������Ϣ2
    BYTE        byRes2[52];    //����
}NET_DVR_IMAGEOVERLAYCFG, *LPNET_DVR_IMAGEOVERLAYCFG;

//��IO����ץ�Ĺ�������
typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE    byRelatedDriveWay;//����IO�����ĳ�����
    BYTE     bySnapTimes; //��Ȧץ�Ĵ�����0-��ץ�ģ���0-���Ĵ�����Ŀǰ���5��  
    WORD    wSnapWaitTime;  //ץ�ĵȴ�ʱ�䣬��λms��ȡֵ��Χ[0,60000]
    WORD    wIntervalTime[MAX_INTERVAL_NUM];//���ļ��ʱ�䣬ms
    DWORD   dwSnapVehicleNum; //ץ�ĳ�����š�
    NET_DVR_JPEGPARA  struJpegPara;//ץ��ͼƬ����
    BYTE    byRes2[16];//�����ֽ�
}NET_DVR_SNAPCFG, *LPNET_DVR_SNAPCFG;

typedef enum _ITC_MAINMODE_ABILITY_
{
    ITC_MODE_UNKNOW    = 0x0,   //��
        ITC_POST_MODE  = 0x1,  //����ģʽ
        ITC_EPOLICE_MODE      = 0x2,  //�羯ģʽ
        ITC_POSTEPOLICE_MODE  = 0x4  //��ʽ�羯ģʽ
}ITC_MAINMODE_ABILITY;

typedef enum _ITC_RECOG_REGION_TYPE_
{
    ITC_REGION_RECT    = 0x0,   //����
        ITC_REGION_POLYGON  = 0x1,  //�����
}ITC_RECOG_REGION_TYPE;

typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum;//IO�������
    BYTE  byIoOutNum;//IO�������
    BYTE  bySingleSnapNum;//��IO��������
    BYTE  byLightModeArrayNum;//���̵�ģʽ����
    BYTE  byMeasureModeArrayNum;//����ģʽ����
    BYTE  byPlateEnable; //����ʶ������
    BYTE  byLensMode;//��ͷģʽ0-CCD,1-CMOS
    BYTE  byPreTriggerSupport; //�Ƿ�֧��ԭ����ģʽ��0-֧�֣�1-��֧��
    DWORD dwAbilityType; //֧�ֵĴ���ģʽ��������λ��ʾ�������ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //֧�ֵ�IO��������
    BYTE  byIoLightGroup; //֧�ֵ�IO���̵�����
    BYTE  byRecogRegionType; //��ʶ����֧�ֵ����ͣ��������ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport&0x1����ʾ�Ƿ�֧����չ���ַ���������
    // bySupport&0x2����ʾ�Ƿ�֧����չ��Уʱ���ýṹ
    // bySupport&0x4, ��ʾ�Ƿ�֧�ֶ�����(��������)
    // bySupport&0x8, ��ʾ�Ƿ�֧��������bonding����(�����ݴ�)
    // bySupport&0x10, ��ʾ�Ƿ�֧�������Խ�
    //2013-07-09 ����������
    WORD wSupportMultiRadar;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // wSupportMultiRadar&0x1����ʾ ����RS485�״� ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x2����ʾ ����������Ȧ ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x4����ʾ ���п��� ֧�ֳ��������״ﴦ��
    // wSupportMultiRadar&0x8����ʾ ��Ƶ��� ֧�ֳ��������״ﴦ��
    BYTE  byICRPresetNum;
    // ��ʾ֧�ֵ�ICRԤ�õ㣨�˹�Ƭƫ�Ƶ㣩��
    BYTE  byICRTimeSlot;//��ʾ֧�ֵ�ICR��ʱ�������1��8��
    BYTE  bySupportRS485Num;//��ʾ֧�ֵ�RS485�ڵ�����
    BYTE  byExpandRs485SupportSensor;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // byExpandRs485SupportSensor &0x1����ʾ�羯������֧�ֳ�����
    // byExpandRs485SupportSensor &0x2����ʾ��ʽ�羯������֧�ֳ�����
    BYTE  byExpandRs485SupportSignalLampDet;// �豸��������λ��ʾ��0-��֧�֣�1-֧��
    // byExpandRs485SupportSignalLampDet &0x1����ʾ�羯������֧������źŵƼ����
    // byExpandRs485SupportSignalLampDet &0x2����ʾ��ʽ�羯������֧������źŵƼ����
    BYTE  byRelayNum;// ��ʾ֧�̵ּ����ĸ��� 2013-11-04
    BYTE  bySupport1; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport1&0x1����ʾ�Ƿ�֧���Զ���Уʱ��Ϣ����
    // bySupport1&0x2,  ��ʾ�Ƿ�֧����Ƶ�����Ż�����
    // bySupport1&0x4,  ��ʾ�Ƿ�֧��DDNS���÷���
    // bySupport1&0x8,  ��ʾ�Ƿ�֧�ֻ�ȡ�豸��ǰ����ģʽ�ӿ�����
    // bySupport1&0x10, ��ʾ�Ƿ�֧�ֳ�������� 2014-03-03
    // bySupport1&0x20,  ��ʾ�Ƿ�֧��GPSģ���������
    // bySupport1&0x40,  ��ʾ�Ƿ�֧��NTPУʱ���֧�ַ�������
    // bySupport1&0x80,  ��ʾ�Ƿ�֧��tps���������ϴ�
    BYTE  bySupport2; //�豸��������λ��ʾ��0-��֧�֣�1-֧��
    // bySupport2&0x01,  ��ʾ�Ƿ�֧������������Ϣ����
    // bySupport2&0x02,  ��ʾͨ��ͼ�������INTER_PICCFG_V30�����Ƿ�֧����Ƶ����ʱ��������ò�����byOSDMilliSecondEnable��
    // bySupport2&0x04,   ��ʾ��բ���ƣ�NET_DVR_BARRIERGATE_CFG����byBarrierGateCtrl�ֶ�֧������4~������բ����֧��byUnlock����ʹ�ܡ���֮���ʶ��֧��
    BYTE  bySupportWhiteBalance; //��ƽ��������Ĭ�϶���֧���ֶ���ƽ�⡢�Զ���ƽ�⡢�Զ���ƽ��2��3��ģʽ��
    // bySupportWhiteBalance &0x01,  ��ʾ�Ƿ�֧���չ��ģʽ
    // bySupportWhiteBalance &0x02,  ��ʾ�Ƿ�֧����Ȼ��ģʽ
    // bySupportWhiteBalance &0x04,  ��ʾ�Ƿ�֧��ů���ģʽ
    // bySupportWhiteBalance &0x08,  ��ʾ�Ƿ�֧�ְ׳��ģʽ
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY, *LPNET_DVR_SNAP_ABILITY;

typedef struct tagNET_DVR_TRANSFER_CAP
{
    BYTE  byAbility;
    BYTE  byRes[63];
}NET_DVR_TRANSFER_CAP, *LPNET_DVR_TRANSFER_CAP;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//Ԥ�õ��1��8 , 0������
    BYTE   bySubSwitchMode;//1~���죬2~���� (��Ԥ�õ����0 ��ʱ����Ч)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM  //156
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//�Զ��л�ʱ��� (�Զ��л��� ʱ������Ч ����֧��4�飬Ԥ��4��)
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч������������̬��ʾ [0~100] �����±��ʾԤ�õ��1��8 ��0��7 ���Ӧ��
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{    
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч������������̬��ʾ [0~100]
    BYTE  bySubSwitchMode;//1~���죬2~����
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //ʵ����Ч������������̬��ʾ [0~100] �����±��ʾԤ�õ��1��8 ��0��7 ���Ӧ��
    BYTE  byICRAutoSwitch; // ICR�Զ��л�����ֵѡ��, ȡֵ��Χ[0 100]
    BYTE  byRes[147];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

//�㷨�Զ�
typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//�����ֵ,��Χ[0,100],Ĭ�� 58
    BYTE  byAbBrightnessThreshold; //�쳣������ֵ����Χ[0,100]��Ĭ��12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;

typedef union tagNET_ITC_ICR_PARAM_UNION
{
    BYTE uLen[156];
    NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
    NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
    NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
    NET_ITC_ICR_ALGAOTOSWITCH_PARAM strICRAlgorithmAutoSwitch;
}NET_ITC_ICR_PARAM_UNION,*LPNET_ITC_ICR_PARAM_UNION;

typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~�Զ��л���2~�ֶ��л� ,3~��ʱ�л�,4~�㷨�Զ� 
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;

//2013-07-09 �쳣����
typedef struct
{    
    DWORD   dwHandleType; //�쳣����,�쳣����ʽ��"��"���
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: ��������������̵��������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/  
    BYTE     byEnable; //0�������ã�1������
    BYTE    byRes;
    WORD    wDuration;//����ʱ��(��λ/s)
    BYTE    byAlarmOutTriggered[MAX_ITC_EXCEPTIONOUT];//�������ͨ��
    BYTE    byRes1[8];
} NET_ITC_HANDLEEXCEPTION, *LPNET_ITC_HANDLEEXCEPTION;

typedef struct
{
    DWORD dwSize;
    NET_ITC_HANDLEEXCEPTION struSnapExceptionType[MAX_EXCEPTIONNUM_V30]; //�����ÿ��Ԫ�ض���ʾһ���쳣������0- Ӳ�̳���,1-���߶�,2-IP ��ַ��ͻ, 3-�������쳣, 4-�źŵƼ�����쳣
}NET_ITC_EXCEPTION,*LPNET_ITC_EXCEPTION;

typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX; /*��Ȧ���ϽǺ����꣨2���ֽڣ�*/
    WORD wTopLeftY; /*��Ȧ���Ͻ������꣨2���ֽڣ�*/
    WORD wWdith; /*��Ȧ��ȣ�2���ֽڣ�*/
    WORD wHeight; /*��Ȧ�߶ȣ�2���ֽڣ�*/
} NET_DVR_TRIGCOORDINATE, *LPNET_DVR_TRIGCOORDINATE;

typedef enum _PROVINCE_CITY_IDX_
{
    ANHUI_PROVINCE             = 0,              //����
        AOMEN_PROVINCE             = 1,              //����
        BEIJING_PROVINCE           = 2,              //����
        CHONGQING_PROVINCE         = 3,              //����
        FUJIAN_PROVINCE            = 4,              //����
        GANSU_PROVINCE             = 5,              //����
        GUANGDONG_PROVINCE         = 6,              //�㶫
        GUANGXI_PROVINCE           = 7,              //����
        GUIZHOU_PROVINCE           = 8,              //����
        HAINAN_PROVINCE            = 9,              //����
        HEBEI_PROVINCE             = 10,             //�ӱ�
        HENAN_PROVINCE             = 11,             //����
        HEILONGJIANG_PROVINCE      = 12,             //������
        HUBEI_PROVINCE             = 13,             //����
        HUNAN_PROVINCE             = 14,             //����
        JILIN_PROVINCE             = 15,             //����
        JIANGSU_PROVINCE           = 16,             //����
        JIANGXI_PROVINCE           = 17,             //����
        LIAONING_PROVINCE          = 18,             //����
        NEIMENGGU_PROVINCE         = 19,             //���ɹ�
        NINGXIA_PROVINCE           = 20,             //����
        QINGHAI_PROVINCE           = 21,             //�ຣ
        SHANDONG_PROVINCE          = 22,             //ɽ��
        SHANXI_JIN_PROVINCE        = 23,             //ɽ��
        SHANXI_SHAN_PROVINCE       = 24,             //����
        SHANGHAI_PROVINCE          = 25,             //�Ϻ�
        SICHUAN_PROVINCE           = 26,             //�Ĵ�
        TAIWAN_PROVINCE            = 27,             //̨��
        TIANJIN_PROVINCE           = 28,             //���
        XIZANG_PROVINCE            = 29,             //����
        XIANGGANG_PROVINCE         = 30,             //���
        XINJIANG_PROVINCE          = 31,             //�½�
        YUNNAN_PROVINCE            = 32,             //����
        ZHEJIANG_PROVINCE          = 33              //�㽭
}PROVINCE_CITY_IDX;

typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2]; /*����*/
    DWORD dwCity; /*���У����PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;

//����ģʽ
typedef enum _SCENE_MODE_
{
    UNKOWN_SCENE_MODE   = 0,            //δ֪����ģʽ
        HIGHWAY_SCENE_MODE  = 1,            //���ٳ���ģʽ
        SUBURBAN_SCENE_MODE = 2,            //��������ģʽ(����)
        URBAN_SCENE_MODE    = 3,            //��������ģʽ
        TUNNEL_SCENE_MODE   = 4             //�������ģʽ(����)
}SCENE_MODE;
// ˽����Ϣģ������
typedef enum _PRIDATA_RENDER
{
    RENDER_ANA_INTEL_DATA = 0x00000001, //���ܷ���
    RENDER_MD = 0x00000002, //�ƶ����
    RENDER_ADD_POS = 0x00000004, //POS��Ϣ�����        
    RENDER_ADD_PIC = 0x00000008, //ͼƬ����
    RENDER_FIRE_DETCET = 0x00000010,  //�ȳ�����Ϣ
    RENDER_TEM = 0x00000020,   //�¶���Ϣ
    RENDER_TRACK_TEM = 0x00000040 //�켣��Ϣ
}PRIDATA_RENDER;

typedef enum _FIRE_ALARM{
    FIRE_FRAME_DIS = 0x00000001, //������ʾ
    FIRE_MAX_TEMP = 0x00000002, //����¶�
    FIRE_MAX_TEMP_POSITION = 0x00000004, //����¶�λ����ʾ
    FIRE_DISTANCE = 0x00000008, //����¶Ⱦ���}FIRE_ALARM
}FIRE_ALARM;

typedef enum _TEM_FLAG{
    TEM_REGION_BOX = 0x00000001, //�����
    TEM_REGION_LINE = 0x00000002, //�߲���
    TEM_REGION_POINT = 0x00000004, //�����}TEM_FLAG
}TEM_FLAG;

typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;  /* �Ƿ�ʹ��������Ȧ��0-��ʹ�ã�1-ʹ��*/
    BYTE    byIsDisplay; /* �Ƿ���ʾ������Ȧ��0-����ʾ��1-��ʾ*/
    BYTE    byLoopPos; //��䴥����Ȧ��ƫ��0-���ϣ�1-����
    BYTE    bySnapGain; /*ץ������*/
    DWORD   dwSnapShutter; /*ץ�Ŀ����ٶ�*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate; //����
    NET_DVR_TRIGCOORDINATE struRes[MAX_VL_NUM];
    BYTE    byTotalLaneNum;/*��Ƶ�����ĳ�����1*/
    BYTE    byPolarLenType; /*ƫ�����ͣ�0������ƫ�񾵣�1����ʩ�͵�ƫ�񾵡�*/
    BYTE    byDayAuxLightMode; /*���츨������ģʽ��0���޸���������1��LED��������2�����������*/
    BYTE    byLoopToCalRoadBright; /*���Լ���·�����ȵĳ���(������Ȧ)*/
    BYTE    byRoadGrayLowTh; /*·�����ȵ���ֵ��ʼ��ֵ1*/
    BYTE    byRoadGrayHighTh; /*·�����ȸ���ֵ��ʼ��ֵ140*/
    WORD    wLoopPosBias; /*��䴥����Ȧλ��30*/
    DWORD   dwHfrShtterInitValue; /*����ͼ���ع�ʱ��ĳ�ʼֵ2000*/
    DWORD   dwSnapShtterInitValue; /*ץ��ͼ���ع�ʱ��ĳ�ʼֵ500*/
    DWORD   dwHfrShtterMaxValue; /*����ͼ���ع�ʱ������ֵ20000*/
    DWORD   dwSnapShtterMaxValue; /*ץ��ͼ���ع�ʱ������ֵ1500*/
    DWORD   dwHfrShtterNightValue; /*�������ͼ���ع�ʱ�������ֵ3000*/
    DWORD   dwSnapShtterNightMinValue; /*���ץ��ͼ���ع�ʱ�����Сֵ3000*/
    DWORD   dwSnapShtterNightMaxValue; /*���ץ��ͼ���ع�ʱ������ֵ5000*/
    DWORD   dwInitAfe; /*����ĳ�ʼֵ200*/
    DWORD   dwMaxAfe; /*��������ֵ400*/
    WORD    wResolutionX;/* �豸��ǰ�ֱ��ʿ�*/
    WORD    wResolutionY;/* �豸��ǰ�ֱ��ʸ�*/
    DWORD   dwGainNightValue; /*������棬Ĭ��ֵ70*/
    DWORD   dwSceneMode; /*����ģʽ�� ���SCENE_MODE */
    DWORD   dwRecordMode; /*¼���־��0-��¼��1-¼��*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*��ַλ��*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*������־��0-��ͷ������1-��β������2-��ͷ/��β������*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*���������ȣ�1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM, *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD dwSize;
    BYTE  byPlateEnable;//�Ƿ�֧�ֳ���ʶ��0-��֧�֣�1-֧��
    BYTE  byRes1[2];   //����
    BYTE  byFrameFlip;   //ͼ���Ƿ�ת 0-����ת��1-��ת
    WORD  wFlipAngle;    //ͼ��ת�Ƕ� 0,90,180,270
    WORD  wLightPhase;   //��λ��ȡֵ��Χ[0, 360]
    BYTE  byLightSyncPower;  //�Ƿ��źŵƵ�Դͬ����0-��ͬ����1-ͬ��
    BYTE  byFrequency;        //�ź�Ƶ��
    BYTE  byUploadSDEnable;  //�Ƿ��Զ��ϴ�SDͼƬ��0-��1-��
    BYTE  byPlateMode; //ʶ��ģʽ����:0-��Ƶ����,1-�ⲿ����
    BYTE  byUploadInfoFTP; //�Ƿ��ϴ�ץ�ĸ�����Ϣ��FTP��0-��1-��
    BYTE  byAutoFormatSD; //�Ƿ��Զ���ʽ��SD����0-��1-��
    WORD  wJpegPicSize; //JpegͼƬ��С[64-8196]
    BYTE  bySnapPicResolution;  //ץ��ͼƬ�ֱ���(��NET_DVR_COMPRESSION_INFO_V30�зֱ��ʱ���һ��)
    BYTE  byRes[55]; //����
}NET_DVR_SNAPENABLECFG, *LPNET_DVR_SNAPENABLECFG;

/*ftp�ϴ�����*/
typedef struct 
{
    DWORD    dwSize;
    DWORD    dwEnableFTP;            /*�Ƿ�����ftp�ϴ�����*/
    char    sFTPIP[16];                /*ftp ������*/
    DWORD    dwFTPPort;                /*ftp�˿�*/
    BYTE    sUserName[NAME_LEN];    /*�û���*/
    BYTE    sPassword[PASSWD_LEN];    /*����*/
    DWORD    dwDirLevel;    /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    WORD     wTopDirMode;    /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x=6�Զ���,0x7=Υ������,0x8=����,0x9=�ص�*/
    WORD     wSubDirMode;    /* ����Ŀ¼��0x1 = ʹ��ͨ����,0x2 = ʹ��ͨ���ţ�,0x3=ʹ��ʱ��(������),0x4=ʹ�ó�����,0x=5�Զ���,0x6=Υ������,0x7=����,0x8=�ص�*/
    BYTE    byEnableAnony; //����������0-��1-��
    BYTE    byPicArchivingInterval;//ͼƬ�鵵���[1~30],0��ʾ�ر�
    BYTE    byRes[22];
}NET_DVR_FTPCFG, *LPNET_DVR_FTPCFG;

/*����������ͼƬ�����Ԫ�� */
#define PICNAME_ITEM_DEV_NAME         1        /*�豸��*/
#define PICNAME_ITEM_DEV_NO         2        /*�豸��*/
#define PICNAME_ITEM_DEV_IP         3        /*�豸IP*/
#define PICNAME_ITEM_CHAN_NAME         4        /*ͨ����*/
#define PICNAME_ITEM_CHAN_NO         5        /*ͨ����*/
#define PICNAME_ITEM_TIME             6        /*ʱ��*/
#define PICNAME_ITEM_CARDNO            7        /*����*/
#define PICNAME_ITEM_PLATE_NO       8   /*���ƺ���*/
#define PICNAME_ITEM_PLATE_COLOR    9   /*������ɫ*/
#define PICNAME_ITEM_CAR_CHAN       10  /*������*/
#define PICNAME_ITEM_CAR_SPEED      11  /*�����ٶ�*/
#define PICNAME_ITEM_CARCHAN        12  /*����*/
#define PICNAME_ITEM_PIC_NUMBER     13  //ͼƬ���
#define PICNAME_ITEM_CAR_NUMBER     14  //�������
#define PICNAME_MAXITEM             15

#define PICNAME_ITEM_SPEED_LIMIT_VALUES    15 //����ֵ
#define PICNAME_ITEM_ILLEGAL_CODE          16 //����Υ������
#define PICNAME_ITEM_CROSS_NUMBER          17 //·�ڱ��
#define PICNAME_ITEM_DIRECTION_NUMBER      18 //������

//(3.7Ver)
#define PICNAME_ITEM_CAR_COLOR             19 //������ɫ
#define PICNAME_ITEM_PLATE_COORDINATE      20 //��������
#define PICNAME_ITEM_CAR_TYPE              21 //��������
#define PICNAME_ITEM_VIOLATION_TYPE        22 //Υ������
#define PICNAME_ITEM_CUSTOM                255//�Զ���



//ͼƬ����
typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    �����鶨���ļ������Ĺ��� */
    BYTE     byDelimiter;        /*�ָ�����һ��Ϊ'_'*/
}NET_DVR_PICTURE_NAME, *LPNET_DVR_PICTURE_NAME;

//��������2013-09-27
#define PICNAME_ITEM_PARK_DEV_IP             1        /*�豸IP*/
#define PICNAME_ITEM_PARK_PLATE_NO          2       /*���ƺ���*/
#define PICNAME_ITEM_PARK_TIME                 3        /*ʱ��*/
#define PICNAME_ITEM_PARK_INDEX             4       /*��λ���*/
#define PICNAME_ITEM_PARK_STATUS            5       /*��λ״̬*/
#define PICNAME_ITEM_BUILDING_NUMBER        6       /*���ŵ�Ԫ��*/
#define PICNAME_ITEM_OUTDOOR_UNIT_ID        7       /*�ſڻ����*/
#define PICNAME_ITEM_UNLOCK_TYPE            8       /*������ʽ*/
#define PICNAME_ITEM_DEVICE_NAME            9       //�豸����
#define PICNAME_ITEM_PERIOD_NO              10      /*�ں�*/
#define PICNAME_ITEM_DEV_INDEX              11      /*�豸���*/
#define PICNAME_PREFIX                      32      /*ͼƬ���Զ���ǰ׺����*/
//ͼƬ������չ 2013-09-27
typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    �����鶨���ļ������Ĺ��� */
    BYTE     byDelimiter;                    /*�ָ�����һ��Ϊ'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //ͼƬ���Զ���ǰ׺
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

/* ����ץͼ����*/
typedef struct 
{
    BYTE    byStrFlag;    /*�������ݿ�ʼ��*/
    BYTE     byEndFlag;    /*������*/
    WORD    wCardIdx;    /*���������ʼλ*/
    DWORD     dwCardLen;    /*���ų���*/
    DWORD   dwTriggerPicChans;    /*��������ͨ���ţ���λ���ӵ�1λ��ʼ�ƣ���0x2��ʾ��һͨ��*/
}NET_DVR_SERIAL_CATCHPIC_PARA, *LPNET_DVR_SERIAL_CATCHPIC_PARA;

//DVRץͼ�������ã����ߣ�
typedef struct 
{
    DWORD    dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];    /*ÿ��ͨ����ͼ�����*/
    WORD    wBurstMode;                            /*ץͼ��ʽ,��λ����.0x1=�������봥����0x2=�ƶ���ⴥ�� 0x4=232������0x8=485������0x10=���紥��*/
    WORD    wUploadInterval;                    /*ͼƬ�ϴ����(��)[0,65535]*/
    NET_DVR_PICTURE_NAME     struPicNameRule;    /* ͼƬ�������� */
    BYTE    bySaveToHD;        /*�Ƿ񱣴浽Ӳ��*/
    BYTE    byRes1;
    WORD    wCatchInterval;        /*ץͼ���(����)[0,65535]*/
    BYTE    byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];    /* ÿ��ͨ��һ�δ������մ��� */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30]; /*��������ץ��ͨ��,��λ���ã��ӵ�1λ��ʼ*/
}NET_DVR_JPEGCFG_V30, *LPNET_DVR_JPEGCFG_V30;

//ץ�Ĵ�������ṹ(����)
typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-���ر�(Ĭ��)��1-�ر�
    BYTE   byLaneNo;//������, ��ΧΪ1-6��Ĭ��Ϊ1(ץ�Ļ��ڲ�����ʹ��)
    BYTE   byChannel;//ͨ����
    BYTE   byRes[21]; //����
}NET_DVR_MANUALSNAP, *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG    
{
    DWORD dwSize; 
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д*/
    BYTE byPlateOSD;    /*0:�����ͳ��Ʋ�ɫͼ,1:���ͳ��Ʋ�ɫͼ*/
    BYTE bySendJPEG1;   /*0-�����ͽ���JPEGͼ,1-���ͽ���JPEGͼ*/
    BYTE bySendJPEG2;   /*0-������Զ��JPEGͼ,1-����Զ��JPEGͼ*/
    WORD wDesignedPlateWidth;   /*������ƿ��*/
    BYTE byTotalLaneNum;  /*ʶ��ĳ�����*/
    BYTE byRes1;      /*����*/
    WORD wRecognizedLane;  /*ʶ��ĳ����ţ���λ��ʾ��bit0��ʾ����1�Ƿ�ʶ��0-��ʶ��1-ʶ��*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];  /*����ʶ������*/
                                                  DWORD dwRecogMode;  /*ʶ������ͣ�
                                                                      bit0-����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) �� 
                                                                      bit1-����ʶ���С����ʶ��0-С����ʶ��1-����ʶ�� ��
                                                                      bit2-������ɫʶ��0-�����ó�����ɫʶ���ڱ���ʶ���С����ʶ��ʱ��ֹ���ã�1-������ɫʶ��
                                                                      bit3-ũ�ó�ʶ��0-������ũ�ó�ʶ��1-ũ�ó�ʶ�� 
                                                                      bit4-ģ��ʶ��0-������ģ��ʶ��1-ģ��ʶ��
                                                                      bit5-֡��λ�򳡶�λ��0-֡��λ��1-����λ��
                                                                      bit6-֡ʶ���ʶ��0-֡ʶ��1-��ʶ�� 
                                                  bit7-���ϻ���죺0-���죬1-���� */
                                                  BYTE  bySendPRRaw;           //�Ƿ���ԭͼ��0-�����ͣ�1-���� 
                                                  BYTE  bySendBinImage;      //�Ƿ��ͳ��ƶ�ֵͼ��0-�����ͣ�1-���� 
                                                  BYTE  byDelayCapture;  //��ʱץ�Ŀ���,��λ��֡
                                                  BYTE  byUseLED;    //ʹ��LED���ƣ�0-��1-��
                                                  BYTE  byRes2[68];    //����
}NET_DVR_SPRCFG, *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;    //�Ƿ����ó������Ȳ�����Ĭ�����ã���0-�رգ�1-���� 
    BYTE byPlateExpectedBright;    //���Ƶ�Ԥ�����ȣ�Ĭ��ֵ50��, ��Χ[0, 100]
    BYTE byRes1[2];    //���� 
    BYTE byTradeoffFlash;     //�Ƿ�������Ƶ�Ӱ��: 0 - ��;  1 - ��(Ĭ��); 
    //ʹ������Ʋ���ʱ, ������Ǽ�������Ƶ�������ǿЧӦ, ����Ҫ��Ϊ1;����Ϊ0
    BYTE byCorrectFactor;     //����ϵ��, ��Χ[0, 100], Ĭ��ֵ50 (��tradeoff_flash�л�ʱ,�ָ�Ĭ��ֵ��
    WORD wLoopStatsEn;  //�Ƿ����Ȧ�����ȣ���λ��ʾ��0-��ͳ�ƣ�1-ͳ��
    BYTE byPlcBrightOffset;// �������Ȳ���������(������Ȧģʽ��Ч)��ȡֵ��Χ1~100
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //Ԥ�����Ӹ���
    WORD wFortifyLinkNum; //�������Ӹ���
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //Ԥ�����û�IP��ַ
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //�������ӵ��û�IP��ַ
    DWORD dwVideoFrameRate;    //֡�ʣ�0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;      //�ֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;      //ץ�ķֱ���0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //�������ͣ�0-��������1-������
    BYTE byTriggerType; //����ģʽ��0-��Ƶ������1-��ͨ����
    DWORD dwSDVolume;  //SD������
    DWORD dwSDFreeSpace; //SD��ʣ��ռ�
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //������״̬��0-δʹ�ã�1-������2-�쳣
    BYTE byDetectorLinkState; //����������״̬��0-δ���ӣ�1-����
    BYTE bySDStatus;    //SD��״̬ 0�����1�����ߣ�2���쳣��3-��sd��
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //�����ȼ���0-�ޣ�1-һ�ȼ����ߣ���2-���ȼ����У���3-���ȼ����ͣ�
    BYTE byRes2[116]; //����
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//��Ȧ����,��λcm��ȡֵ��Χ[0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];    //�źŵ�ͨ����
    BYTE  byCapSpeed;//��־���٣���λkm/h��ȡֵ��Χ[0,255]
    BYTE  bySpeedLimit;//����ֵ����λkm/h��ȡֵ��Χ[0,255]
    BYTE  byTrafficDirection;//��������0-�ɶ�������1-�����򶫣�2-�����򱱣�3-�ɱ�����
    BYTE  byRes1; //����
    WORD  wLoopPreDist;        /*�����ӳپ��� ����λ������*/
    WORD  wTrigDelay;             /*����Ӳ��ʱʱ�� ����λ������*/
    BYTE  byRes[124];//�����ֽ�
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;


//�źŵ��쳣���
typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;        //�ṹ����
    //����ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999  �����λΪ������
    BYTE    byAbsTime[32];    
    NET_DVR_IPADDR    struAlarmCamIP;//���������IP
    DWORD   dwPic1Len;     //�쳣ͼƬ1����
    DWORD   dwPic2Len;     //�쳣ͼƬ2����
    char    *pPic1Buffer;    //����ָ��  ���ӳ�����ͼƬ
    char    *pPic2Buffer;    //����ָ��  �����źŵ�״̬ͼƬ
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize; // �ṹ���С
    DWORD         dwChannel;                //ͨ����    
    BYTE          byExternalDevType;// 0-��Чֵ��������1-�źŵ�,2-�����
    BYTE          byRes[63];             // �����ֽ�
}NET_DVR_EXDEVDET_COND,*LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize; // �ṹ���С
    BYTE          byExternalDevStatus;// 0-����1-�쳣
    BYTE          byRes[63];// �����ֽ�
} NET_DVR_EXDEVDET_CFG,*LPNET_DVR_EXDEVDET_CFG;

/***************************** end *********************************************/

#define IPC_PROTOCOL_NUM      50   //ipc Э��������

//Э������
typedef struct tagNET_DVR_PROTO_TYPE
{ 
    DWORD dwType;               /*ipcЭ��ֵ*/    
    BYTE  byDescribe[DESC_LEN]; /*Э�������ֶ�*/    
}NET_DVR_PROTO_TYPE, *LPNET_DVR_PROTO_TYPE;

//Э���б�
typedef struct tagNET_DVR_IPC_PROTO_LIST
{    
    DWORD   dwSize; 
    DWORD   dwProtoNum;           /*��Ч��ipcЭ����Ŀ*/   
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM];   /*��Ч��ipcЭ��*/    
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST, *LPNET_DVR_IPC_PROTO_LIST;

//Э���б�V41
typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;  
    DWORD   dwProtoNum;  //��Ч��ipcЭ����Ŀ
    BYTE    *pBuffer;    //Э���б�����, dwProtoNum ��NET_DVR_PROTO_TYPE�ṹ  
    DWORD   dwBufferLen; //����������
    BYTE    byRes[32];   
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P������ˮƽ������
    DWORD    dwTiltPos;    // T��������ֱ������
    DWORD    dwZoomPos;  // Z�������䱶������
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;

//��������ʶ�����ṹ��
typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;    //�����,�μ� HUMAN_AGE_GROUP_ENUM
    BYTE bySex;         //�Ա�, 0-��ʾ��δ֪�����㷨��֧�֣�,1 �C �� , 2 �C Ů, 0xff-�㷨֧�֣�����û��ʶ�����
    BYTE byEyeGlass;    //�Ƿ���۾� 0-��ʾ��δ֪�����㷨��֧�֣�,1 �C ����, 2 �C ��,0xff-�㷨֧�֣�����û��ʶ�����
    //ץ��ͼƬ���������ʹ�÷�ʽ����byAgeΪ15,byAgeDeviationΪ1,��ʾ��ʵ������ͼƬ�����Ϊ14-16֮��
    BYTE byAge;//���� 0-��ʾ��δ֪�����㷨��֧�֣�,0xff-�㷨֧�֣�����û��ʶ�����
    BYTE byAgeDeviation;//�������ֵ
    BYTE byEthnic; 
    BYTE byMask;       //�Ƿ������ 0-��ʾ��δ֪�����㷨��֧�֣�,1 �C ����, 2 �C����ͨ�۾�, 3 �C��ī��,0xff-�㷨֧�֣�����û��ʶ�����
    BYTE bySmile;      //�Ƿ�΢Ц 0-��ʾ��δ֪�����㷨��֧�֣�,1 �C ��΢Ц, 2 �C ΢Ц, 0xff-�㷨֧�֣�����û��ʶ�����
    BYTE byFaceExpression;    /* ����,�μ�FACE_EXPRESSION_GROUP_ENUM*/
    BYTE byBeard; // ����, 0-��֧�֣�1-û�к��ӣ�2-�к��ӣ�0xff-unknow��ʾδ֪,�㷨֧��δ���
    BYTE byRace;
    BYTE byHat; // ñ��, 0-��֧��,1-����ñ��,2-��ñ��,0xff-unknow��ʾδ֪,�㷨֧��δ���
    BYTE byRes[4];    //����
}NET_VCA_HUMAN_FEATURE ,*LPNET_VCA_HUMAN_FEATURE;

//������ɫ����
typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;            //��ɫ���ƶ������е�ռ����ֵ
    BYTE  byRed;                        // RGB��ɫ�������еĺ�ɫ
    BYTE  byGreen;                    // RGB��ɫ�������е���ɫ
    BYTE  byBlue;                   // RGB��ɫ�������е���ɫ
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE ,*LPNET_DVR_OBJECT_FEATURE;

//�����������
typedef union tagNET_DVR_ADVANCE_COND_UNION
{  
    BYTE                  byLen[36];  //�����峤��
    NET_VCA_HUMAN_FEATURE      struHumanFeature; //��������
    NET_DVR_OBJECT_FEATURE     struObjectFeature; //��������
}NET_DVR_ADVANCE_COND_UNION,*LPNET_DVR_ADVANCE_COND_UNION;


#define MAX_ALERTLINE_NUM    8 //��󾯽�������    


typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{    
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];  //��Խ���������
    DWORD dwPreTime;   /*���ܱ�����ǰʱ�� ��λ:��*/
    DWORD dwDelayTime; /*���ܱ����ӳ�ʱ�� ��λ:��*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ������Ϣ
    BYTE  byAdvanceType;   //��Ϸ�ʽ��0-��ʹ����ţ�1-������������ϣ�2-��������ɫռ�����
    BYTE  byRes1[3];  //����
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //�������
    BYTE  byRes[5604]; //����
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND; //Խ������ѯ����

#define MAX_INTRUSIONREGION_NUM    8 //�����������
typedef struct tagNET_DVR_INTRUSION_SEARCHCOND  
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/]; //��������
    DWORD dwPreTime;   /*���ܱ�����ǰʱ�� ��λ:��*/
    DWORD dwDelayTime; /*���ܱ����ӳ�ʱ�� ��λ:��*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ������Ϣ
    BYTE  byAdvanceType;//��Ϸ�ʽ��0-��ʹ����ţ�1-������������ϣ�2-��������ɫռ�����
    BYTE  byRes1[3];  //����
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //�������
    BYTE byRes[5348]; //����
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND; //��������


typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //ʶ������
    DWORD           dwPreTime;   /*����¼����ǰʱ�� ��λ:��*/
    DWORD           dwDelayTime; /*����¼���ӳ�ʱ�� ��λ:��*/
    BYTE byRes[5972]; //����
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND; //�������


typedef union tagNET_DVR_AREA_SMARTSEARCH_COND_UNION
{  
    BYTE    byLen[6144];  //�ṹ�峤��
    BYTE    byMotionScope[64][96]; //������� 0-96λ��ʾ64�У�����96*64��С��飬1-���ƶ��������0-���ƶ�������� 
    NET_DVR_TRAVERSE_PLANE_SEARCHCOND struTraversPlaneCond; //Խ�����
    NET_DVR_INTRUSION_SEARCHCOND struIntrusionCond; //��������
    NET_DVR_FACEDETECTION_SEARCHCOND struFaceSnapCond; //�����������
}NET_DVR_AREA_SMARTSEARCH_COND_UNION,
*LPNET_DVR_AREA_SMARTSEARCH_COND_UNION;


//������������
typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE      byChan;                    //ͨ����
    BYTE      bySearchCondType; //���ܲ���������NET_DVR_AREA_SMARTSEARCH_COND_UNION������     
    /*0-�ƶ�������� ��1-Խ����⣬ 2-��������, 3-������� */
    WORD      wChan;                //ͨ���ţ� ���ֶ��Ƕ�byChan����չ��ʹ�ø��ֶκ�byChan���Բ���ʹ��
    NET_DVR_TIME struStartTime;        //¼��ʼ��ʱ��
    NET_DVR_TIME struEndTime;        //¼��ֹͣ��ʱ��
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //���ܲ�������
    BYTE  bySensitivity;               //�ƶ��������������,1    >80%  2 40%~80%  3 1%~40%    
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM, *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{  
    DWORD                   dwSize;                 //�ṹ���С
    NET_DVR_STREAM_INFO   struIDInfo;           //ͨ����Ϣ
    BYTE                   bySearchCondType;     //���ܲ������������� 0-�������, 1-Խ�����, 2-��������,3-�������, 4-���Ƽ��
    BYTE                  bySensitivity; //�������̬����������,1-100
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;  
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //���ܲ�������
    BYTE   	           byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char        cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ����byISO8601Ϊ1ʱ��Ч
    char        cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ����byISO8601Ϊ1ʱ��Ч
    char        cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ����byISO8601Ϊ1ʱ��Ч
    char        cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ����byISO8601Ϊ1ʱ��Ч
    BYTE               byRes2[251];
}NET_DVR_SMART_SEARCH_PARAM_V40,*LPNET_DVR_SMART_SEARCH_PARAM_V40;



typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;    //�ƶ���ⱨ����ʼ��ʱ��
    NET_DVR_TIME struEndTime;   //�¼�ֹͣ��ʱ��
    BYTE   	     byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char  cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char  cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char  cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char  cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE         byRes[59];
}NET_DVR_SMART_SEARCH_RET, *LPNET_DVR_SMART_SEARCH_RET;

// IPSAN �ļ�Ŀ¼����
typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IP��ַ
    WORD            wPort;      // IPSAN  �˿�
    BYTE            byRes[10];  // �����ֽ�
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // ���ص��ļ�Ŀ¼
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;

//DVR�豸����
typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NAME_LEN];     //DVR����
    DWORD dwDVRID;                //DVR ID,����ң���� //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;        //�Ƿ�ѭ��¼��,0:����; 1:��
    //���²��ɸ���
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    DWORD dwSoftwareVersion;            //����汾��,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwSoftwareBuildDate;            //�����������,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;            //DSP����汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwDSPSoftwareBuildDate;        // DSP�����������,0xYYYYMMDD
    DWORD dwPanelVersion;                // ǰ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwHardwareVersion;    // Ӳ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    BYTE byAlarmInPortNum;        //DVR�����������
    BYTE byAlarmOutPortNum;        //DVR�����������
    BYTE byRS232Num;            //DVR 232���ڸ���
    BYTE byRS485Num;            //DVR 485���ڸ��� 
    BYTE byNetworkPortNum;        //����ڸ���
    BYTE byDiskCtrlNum;            //DVR Ӳ�̿���������
    BYTE byDiskNum;                //DVR Ӳ�̸���
    BYTE byDVRType;                //DVR����, 1:DVR 2:ATM DVR 3:DVS ......
    BYTE byChanNum;                //DVR ͨ������
    BYTE byStartChan;            //��ʼͨ����,����DVS-1,DVR - 1
    BYTE byDecordChans;            //DVR ����·��
    BYTE byVGANum;                //VGA�ڵĸ��� 
    BYTE byUSBNum;                //USB�ڵĸ���
    BYTE byAuxoutNum;            //���ڵĸ���
    BYTE byAudioNum;            //�����ڵĸ���
    BYTE byIPChanNum;            //�������ͨ���� ��8λ����8λ��byHighIPChanNum 
    BYTE byZeroChanNum;            //��ͨ���������
    BYTE bySupport;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧�֣�
    //bySupport & 0x1, ��ʾ�Ƿ�֧����������
    //bySupport & 0x2, ��ʾ�Ƿ�֧�ֱ���
    //bySupport & 0x4, ��ʾ�Ƿ�֧��ѹ������������ȡ
    //bySupport & 0x8, ��ʾ�Ƿ�֧�ֶ�����
    //bySupport & 0x10, ��ʾ֧��Զ��SADP
    //bySupport & 0x20, ��ʾ֧��Raid������
    //bySupport & 0x40, ��ʾ֧��IPSAN����
    //bySupport & 0x80, ��ʾ֧��rtp over rtsp
    BYTE byEsataUseage;        //Esata��Ĭ����;��0-Ĭ�ϱ��ݣ�1-Ĭ��¼��
    BYTE byIPCPlug;            //0-�رռ��弴�ã�1-�򿪼��弴��
    BYTE byStorageMode;        //0-����ģʽ,1-�������, 2��֡ģʽ, 3-�Զ�
    BYTE bySupport1;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport1 & 0x1, ��ʾ�Ƿ�֧��snmp v30
    //bySupport1 & 0x2, ֧�����ֻطź�����
    //bySupport1 & 0x4, �Ƿ�֧�ֲ������ȼ�    
    //bySupport1 & 0x8, �����豸�Ƿ�֧�ֲ���ʱ�����չ
    //bySupport1 & 0x10, ��ʾ�Ƿ�֧�ֶ������������33����
    //bySupport1 & 0x20, ��ʾ�Ƿ�֧��rtsp over http    
    WORD wDevType;//�豸�ͺ�
    BYTE  byDevTypeName[DEV_TYPE_NAME_LEN];//�豸�ͺ����� 
    BYTE bySupport2; //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport2 & 0x1, ��ʾ�Ƿ�֧����չ��OSD�ַ�����(�ն˺�ץ�Ļ���չ����)
    BYTE byAnalogAlarmInPortNum; //ģ�ⱨ���������
    BYTE byStartAlarmInNo;    //ģ�ⱨ��������ʼ��
    BYTE byStartAlarmOutNo;  //ģ�ⱨ�������ʼ��
    BYTE  byStartIPAlarmInNo;  //IP����������ʼ��
    BYTE  byStartIPAlarmOutNo; //IP���������ʼ��
    BYTE byHighIPChanNum;      //����ͨ����������8λ 
    BYTE byEnableRemotePowerOn;//�Ƿ��������豸���ߵ�״̬��Զ�̿������ܣ�0-�����ã�1-����
    WORD wDevClass; //�豸���౸�������ĸ���Ʒ�ߣ�0 ������1-50 DVR��51-100 DVS��101-150 NVR��151-200 IPC��65534 ������������෽�������豸���Ͷ�Ӧ���кź�����ֵ.docx��
    BYTE byRes2[6];    //����
}NET_DVR_DEVICECFG_V40, *LPNET_DVR_DEVICECFG_V40;

typedef struct
{
    DWORD dwSize;
    BYTE sDVRName[NET_DEV_NAME_LEN];     //DVR����
    DWORD dwDVRID;                //DVR ID,����ң���� //V1.4(0-99), V1.5(0-255)
    DWORD dwRecycleRecord;        //�Ƿ�ѭ��¼��,0:����; 1:��
    //���²��ɸ���
    BYTE sSerialNumber[SERIALNO_LEN];  //���к�
    DWORD dwSoftwareVersion;            //����汾��,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwSoftwareBuildDate;            //�����������,0xYYYYMMDD
    DWORD dwDSPSoftwareVersion;            //DSP����汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwDSPSoftwareBuildDate;        // DSP�����������,0xYYYYMMDD
    DWORD dwPanelVersion;                // ǰ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    DWORD dwHardwareVersion;    // Ӳ���汾,��16λ�����汾,��16λ�Ǵΰ汾
    BYTE byAlarmInPortNum;        //DVR�����������
    BYTE byAlarmOutPortNum;        //DVR�����������
    BYTE byRS232Num;            //DVR 232���ڸ���
    BYTE byRS485Num;            //DVR 485���ڸ��� --
    BYTE byNetworkPortNum;        //����ڸ���
    BYTE byDiskCtrlNum;            //DVR Ӳ�̿���������
    BYTE byDiskNum;                //DVR Ӳ�̸���
    BYTE byDVRType;                //DVR����, 1:DVR 2:ATM DVR 3:DVS ......--
    BYTE byChanNum;                //DVR ͨ������
    BYTE byStartChan;            //��ʼͨ����,����DVS-1,DVR - 1
    BYTE byDecordChans;            //DVR ����·��
    BYTE byVGANum;                //VGA�ڵĸ��� --
    BYTE byUSBNum;                //USB�ڵĸ���
    BYTE byAuxoutNum;            //���ڵĸ���
    BYTE byAudioNum;            //�����ڵĸ���
    BYTE byIPChanNum;            //�������ͨ����  --
    BYTE byZeroChanNum;        //��ͨ���������
    BYTE bySupport;        //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧�֣�
    //bySupport & 0x1, ��ʾ�Ƿ�֧����������
    //bySupport & 0x2, ��ʾ�Ƿ�֧�ֱ���
    //bySupport & 0x4, ��ʾ�Ƿ�֧��ѹ������������ȡ
    //bySupport & 0x8, ��ʾ�Ƿ�֧�ֶ�����
    //bySupport & 0x10, ��ʾ֧��Զ��SADP
    //bySupport & 0x20, ��ʾ֧��Raid������
    //bySupport & 0x40, ��ʾ֧��IPSAN����
    //bySupport & 0x80, ��ʾ֧��rtp over rtsp
    BYTE byEsataUseage;        //Esata��Ĭ����;��0-Ĭ�ϱ��ݣ�1-Ĭ��¼��
    BYTE byIPCPlug;            //0-�رռ��弴�ã�1-�򿪼��弴��
    BYTE byStorageMode;        //0-����ģʽ,1-�������,2��֡ģʽ
    BYTE bySupport1;                //������λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport1 & 0x1, ��ʾ�Ƿ�֧��snmp v30
    //bySupport1 & 0x2, ֧�����ֻطź�����
    //bySupport1 & 0x4, �Ƿ�֧�ֲ������ȼ�    
    //bySupport1 & 0x8, �����豸�Ƿ�֧�ֲ���ʱ�����չ
    //bySupport1 & 0x10, ��ʾ�Ƿ�֧�ֶ������������33����
    //bySupport1 & 0x20, ��ʾ�Ƿ�֧��rtsp over http    
    WORD wDevType;//�豸�ͺ���չ
    BYTE  byDevTypeName[NET_DEV_TYPE_NAME_LEN];//�豸�ͺ�����
    BYTE bySupport2; //��������չ��λ����Ϊ0��ʾ��֧�֣�1��ʾ֧��
    //bySupport2 & 0x1, ��ʾ�Ƿ�֧����չ��OSD�ַ�����(�ն˺�ץ�Ļ���չ����)
    BYTE  byAnalogAlarmInPortNum; //ģ�ⱨ��������Ŀ
    BYTE  byStartAlarmInNo;    //ģ�ⱨ��������ʼ��
    BYTE  byStartAlarmOutNo;  //ģ�ⱨ�������ʼ��
    BYTE  byStartIPAlarmInNo;  //IP����������ʼ��
    BYTE  byStartIPAlarmOutNo; //IP���������ʼ��
    BYTE  byHighIPChanNum;     //����ͨ����������8λ 
    BYTE  byEnableRemotePowerOn;//�Ƿ��������豸���ߵ�״̬��Զ�̿������ܣ�0-�����ã�1-����
    BYTE  byRes[256];            //����
}NET_DVR_DEVICECFG_V50, *LPNET_DVR_DEVICECFG_V50;
#define MAX_ZEROCHAN_NUM    16
//��ͨ��ѹ�����ò���
typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;            //�ṹ����
    BYTE  byEnable;            //0-ֹͣ��ͨ�����룬1-��ʾ������ͨ������
    BYTE  byRes1[3];            //����
    DWORD dwVideoBitrate;     //��Ƶ���� 0-���� 1-16K(����) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //���λ(31λ)�ó�1��ʾ���Զ�������, 0-30λ��ʾ����ֵ(MIN-32K MAX-8192K)��
    DWORD dwVideoFrameRate;    //֡�� 0-ȫ��; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0����14-15, 15-18, 16-22;
    BYTE  byRes2[32];        //����
}NET_DVR_ZEROCHANCFG, *LPNET_DVR_ZEROCHANCFG;

//��ͨ�����Ų���
typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;                //�ṹ����
    NET_VCA_POINT  struPoint;    //�����е������
    BYTE byState;                //���ڵ�״̬��0-��С��1-�Ŵ�  
    BYTE byPreviewNumber;       //Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16���� �ò���ֻ��
    BYTE byPreviewSeq[MAX_WINDOW_V30];//����ͨ����Ϣ �ò���ֻ��
    BYTE byRes[30];                //���� 
}NET_DVR_ZERO_ZOOMCFG, *LPNET_DVR_ZERO_ZOOMCFG;

#define DESC_LEN_64 64
typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;            //�ṹ����
    BYTE    byEnable;            //0-����SNMP��1-��ʾ����SNMP
    BYTE    byRes1[3];            //����
    WORD    wVersion;        //snmp �汾  v1 = 1, v2 =2, v3 =3���豸Ŀǰ��֧�� v3
    WORD    wServerPort; //snmp��Ϣ���ն˿ڣ�Ĭ�� 161
    BYTE    byReadCommunity[NAME_LEN]; //����ͬ�壬���31,Ĭ��"public"
    BYTE    byWriteCommunity[NAME_LEN];//д��ͬ��,���31 �ֽ�,Ĭ�� "private"
    BYTE     byTrapHostIP [DESC_LEN_64];    //��������ip��ַ������֧��IPV4 IPV6����������    
    WORD    wTrapHostPort;   // trap�����˿�
    BYTE    byTrapName[NAME_LEN];    
    BYTE    byRes2[70];    //����
}NET_DVR_SNMPCFG, *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE    byUserName[NAME_LEN];            // �û���                
    BYTE    bySecLevel;                        // ��ȫ���� 0-���� 1-��У�� 2-����ȨУ�� 3-��ȨУ��
    BYTE    byAuthtype;                        // ��֤���� 0-MD5��֤ 1-SHA��֤ 2: none
    BYTE    byPrivtype;                        // 0: DES; 1: AES; 2: none;
    BYTE    byRes[5];
    BYTE    byAuthpass[PASSWD_LEN];            // ��֤����
    BYTE    byPrivpass[PASSWD_LEN];            // ��������
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

// snmpv30
typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD                dwSize;            //�ṹ����
    BYTE                byEnableV1;        //0-����SNMP V1��1-��ʾ����SNMP V1
    BYTE                byEnableV2;        //0-����SNMP V2��1-��ʾ����SNMP V2
    BYTE                byEnableV3;        //0-����SNMP V3��1-��ʾ����SNMP V3
    BYTE                byRes1[3];
    WORD                wServerPort;                    //snmp��Ϣ���ն˿ڣ�Ĭ�� 161
    BYTE                byReadCommunity[NAME_LEN];        //����ͬ�壬���31,Ĭ��"public"
    BYTE                byWriteCommunity[NAME_LEN];        //д��ͬ��,���31 �ֽ�,Ĭ�� "private"
    BYTE                 byTrapHostIP [DESC_LEN_64];        //��������ip��ַ������֧��IPV4 IPV6����������    
    WORD                wTrapHostPort;                    // trap�����˿�
    BYTE                byRes2[2];       
    NET_DVR_SNMPv3_USER    struRWUser;    // ��д�û�
    NET_DVR_SNMPv3_USER    struROUser;    // ֻ���û�
    BYTE                byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

#define  PROCESSING          0     //���ڴ���
#define  PROCESS_SUCCESS     100   //�������
#define  PROCESS_EXCEPTION   400   //�����쳣
#define  PROCESS_FAILED      500   //����ʧ��
#define  PROCESS_QUICK_SETUP_PD_COUNT 501 //һ����������3��Ӳ��

#define  SOFTWARE_VERSION_LEN 48
#define  NET_SDK_DEVICE_MODEL_LEN 24 //�豸�ͺų���
typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;     // �豸IP��ַ
    WORD            wPort;      // �豸�˿ں�
    WORD            wFactoryType;   // �豸��������
    char            chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char            chSerialNo[16]; // ���к�
    WORD            wEncCnt;       // ����ͨ������
    BYTE            byMACAddr[MACADDR_LEN];        // MAC ��ַ
    NET_DVR_IPADDR  struSubDVRIPMask;   // DVR IP��ַ����
    NET_DVR_IPADDR  struGatewayIpAddr;  // ����
    NET_DVR_IPADDR    struDnsServer1IpAddr;            /* ����������1��IP��ַ */
    NET_DVR_IPADDR    struDnsServer2IpAddr;            /* ����������2��IP��ַ */
    BYTE            byDns;
    BYTE            byDhcp;
    BYTE            szGB28181DevID[DEV_ID_LEN];  //GB28181Э�����ʱ���豸ID������IPC��GB28181Э�����
    BYTE            byActivated;//0-��Ч��1-�Ѽ��2-δ����
    BYTE            byDeviceModel[NET_SDK_DEVICE_MODEL_LEN/*24*/];//�豸�ͺ�
    BYTE            byRes[101];     // �����ֽ�
}NET_DVR_SADPINFO, *LPNET_DVR_SADPINFO;

#define  MAX_SADP_NUM   256   // �������豸�����Ŀ
typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD            dwSize;   //  �ṹ��С
    WORD             wSadpNum;   // �������豸��Ŀ
    BYTE             byRes[6];   // �����ֽ�
    NET_DVR_SADPINFO struSadpInfo[MAX_SADP_NUM]; // ����
}NET_DVR_SADPINFO_LIST, *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY, *LPNET_DVR_SADP_VERIFY;

/*******************************���ݽӿ� begin********************************/
//��ȡ�����豸��Ϣ�ӿڶ���
#define DESC_LEN_32          32   //�����ֳ���
#define MAX_NODE_NUM         256  //�ڵ����

typedef struct tagNET_DVR_DESC_NODE
{ 
    int   iValue;           
    BYTE  byDescribe[DESC_LEN_32]; //�����ֶ� 
    DWORD dwFreeSpace;           //��ȡ�����б�ר��,��λΪM
    BYTE  byRes[12];              //����  
}NET_DVR_DESC_NODE, *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{ 
    DWORD     dwSize;            //�ṹ����
    DWORD     dwNodeNum;         //����������
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //��������  
}NET_DVR_DISKABILITY_LIST, *LPNET_DVR_DISKABILITY_LIST;

//���ݽ����б�
#define BACKUP_SUCCESS                100  //�������
#define BACKUP_CHANGE_DEVICE          101  //�����豸�����������豸��������

#define BACKUP_SEARCH_DEVICE          300  //�������������豸
#define BACKUP_SEARCH_FILE            301  //��������¼���ļ�
#define BACKUP_SEARCH_LOG_FILE        302  //����������־�ļ�
#define BACKUP_CHANGE_DISK            303  //���ڸ�������

#define BACKUP_EXCEPTION              400  //�����쳣
#define BACKUP_FAIL                      500  //����ʧ��

#define BACKUP_TIME_SEG_NO_FILE       501  //ʱ�������¼���ļ�
#define BACKUP_NO_RESOURCE            502  //���벻����Դ
#define BACKUP_DEVICE_LOW_SPACE       503  //�����豸��������
#define BACKUP_DISK_FINALIZED         504  //��¼���̷���
#define BACKUP_DISK_EXCEPTION         505  //��¼�����쳣
#define BACKUP_DEVICE_NOT_EXIST       506  //�����豸������
#define BACKUP_OTHER_BACKUP_WORK      507  //���������ݲ����ڽ���
#define BACKUP_USER_NO_RIGHT          508  //�û�û�в���Ȩ��
#define BACKUP_OPERATE_FAIL           509  //����ʧ��
#define BACKUP_NO_LOG_FILE            510  //Ӳ��������־

//���ݹ��̽ӿڶ���
typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;   //�ļ�����
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM]; //�ļ��б�
    BYTE byDiskDes[DESC_LEN_32];   //���ݴ�������
    BYTE byWithPlayer;      //�Ƿ񱸷ݲ�����
    BYTE byContinue;    /*�Ƿ�������� 0������ 1����*/
    BYTE byRes[34];         //����
}NET_DVR_BACKUP_NAME_PARAM, *LPNET_DVR_BACKUP_NAME_PARAM;

typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;        //��ʱ�䱸�ݵ�ͨ��
    NET_DVR_TIME    struStartTime;   //���ݵ���ʼʱ��
    NET_DVR_TIME    struStopTime;    //���ݵ���ֹʱ��
    BYTE            byDiskDes[DESC_LEN_32];     //���ݴ�������
    BYTE            byWithPlayer;               //�Ƿ񱸷ݲ�����
    BYTE            byContinue;                 //�Ƿ�������� 0������ 1����
    BYTE            byDrawFrame;                 //0 ����֡  1 ��֡
    BYTE            byUseBackCfgParam;          //ʹ�ñ��������еĲ�����0-��Ч��1-����(���ú�ͨ������Ч)��2-������
    DWORD           dwStreamType;                //�����������ͣ���λ��ʾ
    //&0x1-��ʾ������ 
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    BYTE            byRes[28];                     // �����ֽ� 
}NET_DVR_BACKUP_TIME_PARAM, *LPNET_DVR_BACKUP_TIME_PARAM;
/********************************* end *******************************************/

typedef enum _COMPRESSION_ABILITY_TYPE_
{
    COMPRESSION_STREAM_ABILITY = 0, //����ѹ������
        MAIN_RESOLUTION_ABILITY = 1,    //������ѹ���ֱ���
        SUB_RESOLUTION_ABILITY  = 2,    //������ѹ���ֱ���
        EVENT_RESOLUTION_ABILITY =  3,  //�¼�ѹ�������ֱ���
        FRAME_ABILITY = 4,                //֡������
        BITRATE_TYPE_ABILITY = 5,        //λ����������
        BITRATE_ABILITY = 6,            //λ������
        THIRD_RESOLUTION_ABILITY = 7,   //������ѹ���ֱ���
        STREAM_TYPE_ABILITY = 8,        //��������
        PIC_QUALITY_ABILITY = 9,         //ͼ������
        INTERVAL_BPFRAME_ABILITY = 10,  //BP֡���
        VIDEO_ENC_ABILITY = 11,           //��Ƶ��������
        AUDIO_ENC_ABILITY = 12,           //��Ƶ��������
        VIDEO_ENC_COMPLEXITY_ABILITY = 13, //��Ƶ���븴�Ӷ�����
        FORMAT_ABILITY = 14, //��װ��ʽ����
}COMPRESSION_ABILITY_TYPE;

//�����б�
typedef struct tagNET_DVR_ABILITY_LIST
{ 
    DWORD     dwAbilityType;    //�������� COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];        //�����ֽ�
    DWORD     dwNodeNum;        //����������
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //��������  
}NET_DVR_ABILITY_LIST, *LPNET_DVR_ABILITY_LIST;

#define MAX_ABILITYTYPE_NUM  12   //���������
// ѹ�����������б�
typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{ 
    DWORD     dwSize;            //�ṹ����
    DWORD     dwAbilityNum;        //�������͸���
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM]; //��������  
}NET_DVR_COMPRESSIONCFG_ABILITY, *LPNET_DVR_COMPRESSIONCFG_ABILITY;
/********************************9000RH begin****************************************/
#define SUPPORT_PD_NUM            16
#define SUPPORT_ARRAY_NUM        8
#define SUPPORT_VD_NUM            128
#define SUPPORT_PD_NUM_            16
#define SUPPORT_PD_NUM_PARTTWO    8

typedef enum tagRAID_MODE
{
    RAID0 = 1,
        RAID1,
        RAID10,
        RAID1E,
        RAID5,
        RAID6,
        RAID50,
        JBOD, 
        RAID60
}RAID_MODE;

typedef enum tagHD_SUPPORT_TYPE
{
    HD_TYPE_SATA    = 0x01,
        HD_TYPE_PATA    = 0x02,
        HD_TYPE_SAS     = 0x04,
        HD_TYPE_ATAPI   = 0x08,
        HD_TYPE_TAPE    = 0x10,
        HD_TYPE_SES     = 0x20
}HD_SUPPORT_TYPE;

// ��λ��ʾ λΪ0��ʾ��֧��  1��ʾ֧��
typedef enum tagSUPPORT_RAID_TYPE
{
    RAID0_ABILITY   = 0x0001,
        RAID1_ABILITY   = 0x0002,
        RAID10_ABILITY  = 0x0004,
        RAID1E_ABILITY  = 0x0008,
        RAID5_ABILITY   = 0x0010,
        RAID6_ABILITY   = 0x0020,
        RAID50_ABILITY  = 0x0040,
        JBOD_ABILITY    = 0x0080,
        RAID60_ABILITY  = 0x0100
}SUPPORT_RAID_TYPE;

// ������� 
typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;         // Ӳ�̲�λ 
    BYTE    byType;         // Ӳ����Ϣ��0 ��ͨ��1ȫ���ȱ���2-�����ȱ� 3-������
    BYTE    byStatus;       // Ӳ��״̬��  0-���� 1-���� 2-��ɾ�� 3-���̶�ʧ 4-���� 5-������ 6-���� 7-�쳣 8-SMART״̬�쳣 9-���� 10-�л���,11-SMRӲ�̲�֧�����й���,0xff-������
    BYTE    byMode[40];   // Ӳ������ �ַ���
    DWORD   dwHCapacity;    //  ����������32λ ��λkb
    DWORD   dwLCapacity;    //  ����������32λ
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;          // ��������ID
    BYTE    byArrayInformation;   // �Ƿ���������Ϣ��0 ��1��
    BYTE    byRes[101];         // �����ֽ�  
}NET_DVR_PHY_DISK_INFO, *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST, *LPNET_DVR_PHY_DISK_LIST;

typedef enum tagBGA_TYPE
{
    BGA_REBUILD = 0x01,            // �ؽ�
        BGA_CONSISTENCY_FIX = 0x02,    // һ���Լ�鲢�޸�
        BGA_CONSISTENCY_CHECK = 0x04,  // һ���Լ��
        BGA_INIT_QUICK = 0x08,         // ��ʼ��(��)
        BGA_INIT_BACK = 0x10,          // ��ʼ��(��ȫ)
        BGA_MIGRATION = 0x20,       // Ǩ��
        BGA_INIT_FORE = 0x40,           // ��ʼ��
        BGA_COPYBACK = 0x80             // ��Ǩ
}BGA_TYPE;

typedef enum tagBGA_STATE
{
    BGA_STATE_NONE = 0,     //  �޺�̨����
        BGA_STATE_RUNNING,       //  ��̨������������
        BGA_STATE_ABORTED,       //  ��̨����ȡ��
        BGA_STATE_PAUSED         //  ��̨������ͣ     
}BGA_STATE;
typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;  // ��̨�������� 
    BYTE    byBgaState;           /*��������ֵ--��̨����״̬*/
    WORD    wBgaPercentage;     /*��������ֵ--��̨����ִ�аٷֱ�*/
    BYTE    byRes[4];  // �����ֽ�
}NET_DVR_BGA_INFO, *LPNET_DVR_BGA_INFO;

// ������Ϣ
typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID; // ����ID
    BYTE    byRaidMode; // raidģʽ  ����RAID_MODE
    BYTE    byStatus;  // 0-���� 1-���̶�ʧ 2-���� 3-���� 4-�쳣 5-������ 6-������  7-��ɾ�� 8-SMART״̬�쳣 0xff-������
    DWORD   dwHCapacity; // ����������32λ
    DWORD   dwLCapacity; // ����������32λ
    DWORD   dwHFreeSpace;   // ����ʣ��ռ��32λ
    DWORD   dwLFreeSpace;   // ����ʣ��ռ��32λ
    BYTE    byArrayName[MAX_NAMELEN]; // ��������
    BYTE    byPDCount;  // ���������Ŀ
    BYTE    bySpareCount;   // �ȱ���Ŀ
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];    // �����������
    WORD    wSparePDSlots[SUPPORT_PD_NUM];    // �ȱ���������
    NET_DVR_BGA_INFO    struBgaInfo;    // ��̨��������״̬
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //�������������չ��0��ʾ��Ч
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];    // �ȱ�����������չ��0��ʾ��Ч
    BYTE    byRes2[48]; // �����ֽ�
}NET_DVR_ARRAY_INFO, *LPNET_DVR_ARRAY_INFO;


typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;     // �ṹ���С
    DWORD   dwCount;    // ���и���
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST, *LPNET_DVR_ARRAY_LIST;

//���������Ϣ
typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;    //������̲�λ  
    BYTE    byStatus; // ״̬0-���� 1-���� 2-��ɾ�� 3-���̶�ʧ 4-���� 5-������ 6-���� 7-�쳣 8-SMART״̬�쳣 0xff-������ 
    BYTE    byRaidMode; // Raid ģʽ ���� RAID_MODE
    WORD    wArrayID;      // ��������ID
    BYTE    byRepair;   // �Ƿ���Ҫ�޸� 0 ����Ҫ 1��Ҫ
    BYTE    byUsage;          //LUN���ʹ�÷�ʽ  0-IPSAN 1-FCSAN 2-DVR���� 3-NAS 4-¼���
    BYTE    byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];    // �������������
    DWORD   dwHCapacity;    // �������������32λ
    DWORD   dwLCapacity;    // �������������32λ
    DWORD   dwHFreeSpace;   // �������ʣ��ռ��32λ
    DWORD   dwLFreeSpace;   // �������ʣ��ռ��32λ
    NET_DVR_BGA_INFO    struBgaInfo;    // ��̨����״̬
    DWORD                dwBlockSize;    //��С�洢��Ԫ���С
    NET_DVR_IPADDR        struWarrantIP;    // ��Ȩ��DVR����IP
    char                szArrayGroup[NAME_LEN];     //ʹ�õ����������飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
    BYTE                byRes[20];
}NET_DVR_VD_INFO, *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;     // �ṹ���С
    DWORD   dwCount;    // ������̸���
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];  //�����������
}NET_DVR_VD_LIST, *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION, *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD  wVDSlot;
    BYTE  byAlloc;  // �Ƿ��Ѿ�����
    BYTE  byRes[5];
    DWORD dwHVDSlotSize;    // ������̿ռ��С��32λ
    DWORD dwLVDSlotSize;    // ������̿ռ��С��32λ
}NET_DVR_VD_SLOT, *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;                        /*current number of slots in DG*/ 
    BYTE    byRes1[3];              // �����ֽ�
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO, *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;    // �ṹ���С
    NET_DVR_ADAPTER_VERSION struVersion;    // �������汾��
    BYTE    bySlotCount;    //��������λ��
    BYTE    bySupportMigrate;  // Ǩ��(1-֧��  0-��֧��)
    BYTE    bySupportExpand;   // ����  (1-֧��  0-��֧��)
    BYTE    bySupportRebuild;  // �Ƿ�֧���ؽ����� (1��֧�� 0-��֧��)
    WORD    wSlotSupportType; //  ��λ��ʾ HD_SUPPORT_TYPE
    WORD    wSupportRaidType;      // ֧��Raid ���� ��λ��ʾ  
    BYTE    byAutoRebuild;      // 0 ���Զ��ؽ� 1�Զ��ؽ� ����
    BYTE    byRes[27];      // �����ֽ�
}NET_DVR_RAID_ADAPTER_INFO, *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    //�Ƿ�һ������  ���Ϊһ���������򴴽�ʱʱ���֮��Ҫarray���ƣ�������Ҫ��������
    // �����������豸���д���
    BYTE    byRaidMode;     // ����/Ǩ��ʱRaid������
    BYTE    byPDCount;  // ���������Ŀ
    WORD    wArrayID;   // Ǩ�ƻ����ؽ�ʱ��Ҫָ������ID      
    WORD    wPDSlots[SUPPORT_PD_NUM];// ������� 
    BYTE    byName[MAX_NAMELEN];  // array ����
    BYTE    byInitMode;              //��ʼ����ʽ
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];       //���������Ϣ
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM, *LPNET_DVR_OPERATE_ARRAY_PARAM;


#define INIT_QUICK                                      0    /*���ٳ�ʼ��*/
#define INIT_FULLFOREGROUND                             1    /*��ȫ��ʼ��(ǰ̨)*/
#define INIT_FULLBACKGROUND                             2    /*��ȫ��ʼ��(��̨)*/

typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;        // ����ID
    BYTE    bySlot;            // �����������ָ����λ
    BYTE    byInitType;     // �����������ʱ��ʼ������ 0 - ���ٳ�ʼ�� 1 - ǰ̨��ȫ��ʼ�� 2 - ��̨��ȫ��ʼ��
    DWORD    dwHCapacity;    // ������̴�С��32λ
    DWORD    dwLCapacity;    // ������̴�С��32λ
    BYTE    byName[MAX_NAMELEN]; // �����������
    BYTE    byRes2[16];          // �����ֽ� 
}NET_DVR_OPERATE_VD_PARAM, *LPNET_DVR_OPERATE_VD_PARAM;


typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;        // ������̲�λ
    WORD    wArrayID;       // ����������
    BYTE    bySpareType;    // �ȱ����� 1-ȫ���ȱ�  2 ָ������  ��Ϊָ�����е�ʱ����Ҫָ���������е�ID
    BYTE    byRes[7];       // �����ֽ�
}NET_DVR_SPARE_DISK_PARAM, *LPNET_DVR_SPARE_DISK_PARAM;

/********************************9000RH End****************************************/


#define MATRIX_MAXDECSUBSYSTEMCHAN    4//��Ƶ�ۺ�ƽ̨������ϵͳͨ����

//��ȡ������ϵͳ������Ϣ
typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE    byJoinStatus;//����״̬��0-û�й�����1-�Ѿ�����
    BYTE    byJoinSubSystem;//��������ϵͳ��λ��
    BYTE    byJoinDispNum;//��������ʾͨ����
    BYTE    byJoinSubWindowNum;//�������Ӵ��ں�
    BYTE    byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS,LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE    bySubSystemType;//��ϵͳ���ͣ�0-�ޣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ,5-�����ϵͳ��6-������ϵͳ
    BYTE    byConnectStatus;//����ϵͳ����״̬��1-����������2-���ӶϿ�
    BYTE    byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE    bySubSystemNum;//������ϵͳ��λ�ţ�0~79����ϵͳ������3��4ʱ����    
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE    byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE    byRes[7];
}NET_DVR_SINGLESUBSYSTEMJOININFO,LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM];//80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

//2010-04-13 ����NAT�����������
typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD                  dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2];//NAT IP��ַ 
    BYTE                byNATEnable;//�Ƿ�����NAT���ܣ�0-�����ã���0-����
    BYTE   byNATCfgMode; //NAT����ģʽ��0-�ֶ����䣬1-�Զ�����
    BYTE   byRes[62];
}NET_DVR_NATASSOCIATECFG, *LPNET_DVR_NATASSOCIATECFG;

//2010-06-01 ��Ƶ�ۺ�ƽ̨��������
typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE     byEnableTemperatureAlarm;//ʹ���¶ȳ��ޱ�����0-������1-������
    BYTE     byRes1[3];
    int      iTemperatureUpLimited;    //��ȷ��С�������λ����1234��ʾ�¶�12.34��
    int      iTemperatureDownLimited;    
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE     byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG, *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm;//�Ȳ�α���ʹ�ܣ�1-������0-������
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;    /* ����ʽ */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG, *LPNET_DVR_BOARDALARMCFG;


typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD                          dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;    
    NET_DVR_BOARDALARMCFG          struBoardAlarmCfg;    
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM];//0-�����쳣��1-��ϵͳ�쳣��2-IP��ַ��ͻ��3-���߶ϣ�4-�Ƿ����ʣ�5-�����쳣��6-ǰ����쳣
    BYTE                         byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG,*LPNET_DVR_VIDEOPLATFORMALARMCFG;
//2010-05-17
typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD        dwSize;
    NET_DVR_IPADDR   struIP;  /*������IP��ַ*/
    WORD        wPort;        //�������˿ں�
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* �û�����32�� */
    BYTE        sPassword[PASSWD_LEN];    /*���� ��16��*/
    BYTE        byChan;//������ͨ����
    BYTE        byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE, *LPNET_DVR_CODESPLITTERASSOCIATE;

//2010-06-01 ��Ƶ�ۺ�ƽ̨�����ϴ��ṹ
typedef struct tagNET_DVR_MATRIXSUBSYSTEMINFO
{
    BYTE   byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE    bySubSystemNum;//��ϵͳ��λ��
    BYTE   byRes [14];
} NET_DVR_MATRIXSUBSYSTEMINFO, *LPNET_DVR_MATRIXSUBSYSTEMINFO;

typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;      //�ṹ���С
    BYTE   byAlarmType;    // 0-�γ��Ӱ壬1-�����Ӱ�,2-�¶ȳ����ޱ�����3-�¶ȳ����ޱ�����4-����״̬�쳣��5-��ϵͳ�쳣,6-�Ƿ����ʣ�7-�����쳣����,8-ǰ����쳣����
    BYTE   byBoardNum;     //�Ӱ�ţ���1��B10��֧�ָ��ֶΣ���Ч����Ϊ0xff
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8]; //�Ӱ��λ��,һ���Ӱ�����8����ϵͳ����ֱ��Ӧ�Ĳ�λ�ţ���ϵͳ�쳣ʱ��bySubSystemChan[0]��ʾ��Ӧ��ϵͳ���        
    int    iTemperature;  //�¶ȳ��ޱ���ʱ���ã��¶�ֵ
    BYTE   byMainboardSeq;//�¶ȳ��ޱ���ʱ���ã�0-�����壬1-����
    BYTE   byRes2[3];
    BYTE   byFanSequence[32];//�쳣���ȣ�byFanSequence[i] = 1��ʾ����i+1�쳣��byFanSequence[i] = 0��ʾ����i+1����    
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;// �����쳣����ʱʹ�ã�������
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;//�����쳣����ʱʹ�ã�������
    BYTE   byRes3[68];    
}NET_DVR_VIDEOPLATFORM_ALRAMINFO,*LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

/***************************��ѶDVR begin *****************************/
#define MAX_INQUEST_PIP_NUM        3     //��ͨ����ʾ�Ļ��л���Ŀ
#define MAX_INQUEST_CDRW_NUM    4     //����¼����Ŀ
#define MAX_INQUEST_PIP_NUM_EX    16        //��Ѷ�����л�������

typedef struct 
{
    DWORD      dwSize;
    DWORD      dwNum;                       //��¼��������
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30];// �Ƿ�ѡ�иù���
    DWORD      dwModeSelect;                //0��ʾѭ����¼ģʽ  1��ʾ���п�¼ģʽ(Ĭ��ģʽ)
    BYTE       byRes[24];                   //����
    DWORD       dwStartCDRW;                 //DVR �����Ѿ���ʼ��¼
    DWORD      dwHdExcp;                    //Ӳ������ ��
    DWORD       dwInterval;                  //ʱ������10����(0)��20����(1)��30����(2)
    char        sLable[64];                  //��������
}NET_DVR_INQUEST_CDRW_CFG, *LPNET_DVR_INQUEST_CDRW_CFG;

typedef struct
{
    char      sFileName[36];             //�ļ���
    DWORD     dwFileLen;                 //�ļ�����
}NET_DVR_INQUEST_FILEINFO, *LPNET_DVR_INQUEST_FILEINFO;

typedef struct 
{
    DWORD     dwFileNum;                     // ��Ҫ��¼����ɾ�����ļ��������һ��20��
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //�������������ڱ�ʾ��¼���ļ�ʱʹ��
    DWORD     dwCDIndex;                    //��¼����������1:ѡ��1�ſ�¼����2:ѡ��2�ſ�¼���� 3:3�ſ�¼��,4:4�ſ�¼��,5:���п�¼��
    DWORD      bFinalizeDisc;                 // 0=��¼��֮�󲻷��̣�1=��¼��֮�����
}NET_DVR_INQUEST_FILES, *LPNET_DVR_INQUEST_FILES;

typedef struct 
{    
    DWORD     dwEnable;            //��¼��״̬�Ƿ���Ч,0-��Ч,1-��Ч    
                                DWORD     dwStatus;            /* ��dwType=0ʱ��
                                                            0-����������1-�޹��̻�����쳣,
                                                            ��dwType=1��2ʱ��
                                                            0-��¼������1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻�㣬
                                                            4-�쳣������Ѷ��ֹ(81��֧��)
                                                            ��dwType=3ʱ��
                                                            0-��¼������1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻��
                                                            ��dwType=4ʱ��
                                                            0-��¼������1-�޹��̻�����쳣��
                                                            2-�����ѷ���(81��֧��)��3-���̿ռ䲻��
                                                            ��dwType=5ʱ,
                                                            0-���������� 1-�޹��̻�����쳣,
                                                            2-�����ѷ���(81��֧��)
                                                            ��dwType=6��7ʱ,
                                                            0-��¼����, 1-�޹��̻�����쳣,
                                2-�����ѷ���(81��֧��), 3-���̿ռ䲻��*/        
                                DWORD    dwVolumn;      //��������,��λM
                                DWORD    dwFreeSpace;   //����ʣ������,��λM    
                                DWORD    dwTimeLeft;     // ����ʣ��ʱ�䣬��λ��
                                BYTE          byCDType;         // ��������
                                BYTE       byRes[3];      //�����ֽ�
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct 
{    
/*����״̬��0-��Ѷ��ʼ��
1-��Ѷ�����п�¼��2-��Ѷֹͣ��
3-��¼��Ѷ�ļ�, 
4-����(�º󱸷ݺͱ��ر���)
5-����
6-��ʼ��Ӳ��
    7-�ָ���Ѷ*/
    DWORD    dwType;            
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];   //����0��ʾ��¼��1    
    NET_DVR_TIME_EX            struInquestStartTime;        //��Ѷ��ʼ��ʱ���
    BYTE                    byRes[16];             //����
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;

typedef struct
{
    BYTE     byPipChan;              //���л���ʾ��ͨ�� 0xFF�ر�
    BYTE     byRes[3];              //�����ֽ�
    WORD     wTopLeftX;              //���л���x����
    WORD     wTopLeftY;              //���л���Y����
}NET_DVR_INQUEST_PIP_PARAM, *LPNET_DVR_INQUEST_PIP_PARAM;

typedef struct 
{
    BYTE     byBaseChan;          //��ʾ���л����ڵ�ͨ��
    BYTE     byBackChan;          //��ʾ���л�����ͨ��
                                  BYTE     byPIPMode;           /*�Ƿ���, 
                                                                0 ��ǰ������С����
                                                                1 ��ǰ������1��С����
                                                                2 ��ǰ������2��С����
                                                                3 ��ǰ������3��С����
                                  */
                                  BYTE     byRes;               //�����ֽ�
                                  NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];  //����λ�õĲ���    
}NET_DVR_INQUEST_PIP_STATUS, *LPNET_DVR_INQUEST_PIP_STATUS;

//V40��չ�������л�������չΪ32��
typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*���л���ʾ��ͨ�� 0xFF�ر�*/ 
    BYTE     byRes1[3];
    WORD     wTopLeftX;         /*���л���x����*/
    WORD     wTopLeftY;         /*���л���Y����*/
    WORD     wHeight;            /*���л��ĸ� */
    WORD     wWidth;            /*���л��Ŀ� */
    BYTE     byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD    struStructHead;
    BYTE             byBaseChan;     /*��ʾ���л����ڵ�ͨ��*/
    BYTE             byBackChan;     /*��ʾ���л�����ͨ��*/
                                    BYTE             byPIPMode;      /*�Ƿ���, 0 ��ǰ������С����
                                                                    1 ��ǰ������1��С����
                                                                    2 ��ǰ������2��С����
                                                                    3 ��ǰ������3��С����
                                                                    4 ��ǰ������4��С����
                                                                    5 ��ǰ������5��С����
                                                                    6 ��ǰ������6��С����
                                                                    7 ��ǰ������7��С����
                                                                    8 ��ǰ������8��С����
                                                                    9 ��ǰ������9��С����
                                    255  ��ǰ���ڹر�Ԥ������*/
                                    BYTE                         byPipCount;          /*С����ĸ���*/
                                    BYTE                        byPicShowMode; /*������ʾģʽ��0-���л���1-�������2-����ƴ��*/
                                    BYTE                        byRes[31];        /*����*/
                                    NET_DVR_INQUEST_PIP_PARAM_V40     strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*����λ�õĲ���*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct 
{
    BYTE    sSecretKey[16];        /*����������Կ*/
    BYTE    byRes[64];             /*�����ֽ�*/
}NET_DVR_INQUEST_SECRET_INFO, *LPNET_DVR_INQUEST_SECRET_INFO;


/***************************��ѶDVR end *****************************/


/********************************�ӿڲ����ṹ(end)*********************************/
#define        MAX_BIGSCREENNUM    100//������ƴ����

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE    byScreenSeq;//��Ļ��ţ�0xff��ʾ���ô���,64-T��������һ����ʾ����
    BYTE    bySubSystemNum;//������ϵͳ��λ��,��������ֵû����
    BYTE    byDispNum;//������ϵͳ�϶�Ӧ��ʾͨ���ţ�64-T�������и�ֵ��ʾ����������ʾͨ����
    BYTE    byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE    byEnable;//����ƴ��ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE    byModeX;/*����ƴ��ģʽ*/
    BYTE    byModeY;
    BYTE    byMainDecodeSystem;//�ۺ�ƽ̨�Ľ�����и�ֵ��ʾ������λ�ţ�64-T�������и�ֵ��ʾ����ͨ����
    BYTE    byMainDecoderDispChan;//����������ʾͨ���ţ�1.1netra�汾������netra��������������ʾͨ�������ܹ���Ϊ������64-T�и�ֵ��Ч
    BYTE    byVideoStandard;      //����ÿ��������ʽ��ͬ 1:NTSC,2:PAL
    BYTE    byRes1[2];
    DWORD  dwResolution;         //����ÿ�������ֱ�����ͬ
    //����ƴ�Ӵ���Ļ��Ϣ
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM]; 
    //��ʼ�������Ϊ��׼�����������
    WORD    wBigScreenX; //�����ڵ���ǽ����ʼX����
    WORD    wBigScreenY; //�����ڵ���ǽ����ʼY����
    BYTE    byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;


#define    DECODEPIC_LEFTADJUST            1        /*ͼ������*/
#define    DECODEPIC_RIGHTADJUST            2        /*ͼ������*/
#define    DECODEPIC_UPADJUST                3        /*ͼ������*/
#define    DECODEPIC_DOWNADJUST            4        /*ͼ������*/
#define    DECODEPIC_REDUCEADJUST            5        /*ͼ����С*/  
#define    DECODEPIC_FULL_SCREEN_ADJUST    6        /*ͼ��ȫ��*/
#define    DECODEPIC_CANCEL_FULL_SCREEN_ADJUST    7        /*ͼ��ȡ��ȫ����ʾ*/   
#define DECODEPIC_AUTOADJUST           8        /*  ͼ���Զ����� */
#define DECODEPIC_HEIGHTADJUST         9       /* ͼ��߶ȵ��� */
#define DECODEPIC_WIDTHADJUST             10       /* ͼ���ȵ��� */

#define     MAX_UNITEDMATRIX_NUM        8//�����������Ƶ�ۺ�ƽ̨����
#define     MAX_SUBDOMAIN_NUM            4//�����������������
typedef struct tagNET_DVR_SUBSERVERINFO
{
    BYTE        bySequence;//��ţ���������������ţ�������Ƶ�ۺ�ƽ̨����ƽ̨�ţ�0��ʾ�޴�ƽ̨\����
    BYTE        byBelongSubDomain;//����ƽ̨��Ч����ʾ�����ĸ�����
    BYTE        byRes1[6];
    DWORD       dwMaxIpcNums;//���ӵ����IPC����
    NET_DVR_IPADDR struSubMatrixIP;        /*IP��ַ*/
    WORD        wSubMatrixPort;        /*��ϵͳ�˿ں�*/
    BYTE        byRes2[6];
}NET_DVR_SUBSERVERINFO, *LPNET_DVR_SUBSERVERINFO;

typedef struct tagNET_DVR_UNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBSERVERINFO struDomainInfo;
    NET_DVR_SUBSERVERINFO struSubDomainInfo[MAX_SUBDOMAIN_NUM];//������Ϣ
    NET_DVR_SUBSERVERINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];//��Ƶ�ۺ�ƽ̨��Ϣ
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXINFO, *LPNET_DVR_UNITEDMATRIXINFO;        

typedef struct tagNET_DVR_REGCALLBACKPARAM
{
    char sDeviceID[NAME_LEN];//�豸ID��
    char sPassword[PASSWD_LEN];
    BYTE sSerialNumber[SERIALNO_LEN]; /* �豸���к� */
    DWORD dwDeviceType;//�豸����
    BYTE nStatus;// ������״̬��0���ߣ�1���ߣ�
    /* net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks */
    BYTE byNetType;    
    BYTE byRes[14];
}NET_DVR_REGCALLBACKPARAM, *LPNET_DVR_REGCALLBACKPARAM;

typedef struct tagNET_DVR_LOGONREPONSEPARAM
{
    //����ʱ��������λ����, 5�ı�����180�����ڡ�Ĭ����15�롣
    WORD wHeartbeatTime;
    BYTE byOvertimes;// �豸������ʱ������Ĭ����3��
    BYTE byRes[13];    
}NET_DVR_LOGONREPONSEPARAM, *LPNET_DVR_LOGONREPONSEPARAM;


typedef struct tagNET_DVR_PREVIEWPARAM
{
    BYTE byTransProtol;        //����Э�飬0-TCP, 1-UDP
    BYTE byTransMode;        ///* ��������ģʽ 0�������� 1��������*/ 
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD wPort;/*CU�˿�*/
    WORD wUdpPort;
    BYTE bySupportQos;//�Ƿ�����QOS,1-���ã�0-������
    //�Ƿ���NATԤ������0-��1-��(ֻ��byTransMode�ֶ�)
    BYTE  byNatRequest;
    BYTE  byPreviewType;// 0-��ͨԤ�� 1-��ʱԤ��
    BYTE  byRes[7];
}NET_DVR_PREVIEWPARAM, *LPNET_DVR_PREVIEWPARAM;
typedef struct tagNET_DVR_DEVICENATINFO
{
    NET_DVR_IPADDR struPuIp; //PU������IP��ַ
    WORD    wOuterPort;/*PU�����˿�*/
    WORD    wInterPort;//PU������Ƶ�ı��ض˿�
    DWORD   nSessionID;//CMS�����sessionID
    BYTE    byRes[4];
}NET_DVR_DEVICENATINFO, *LPNET_DVR_DEVICENATINFO;


typedef struct tagNET_DVR_PREVIEWCALLBACKPARAM
{
    LONG lChannel;
    BYTE nLinkProtocol;
    BYTE nTransMode;
    BYTE byPreviewType; //0-��ͨԤ�� 1-��ʱԤ��
    BYTE byRes[5];
    DWORD nSessionID;//CMS�����sessionID
}NET_DVR_PREVIEWCALLBACKPARAM, *LPNET_DVR_PREVIEWCALLBACKPARAM;

//�ط�
typedef struct tagNET_DVR_PLAYBACKREQUESTPARAM
{
    BYTE byPlayBackMode;        /* �ط�����ģʽ 1�������� 2����ʱ�� */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* �طŵ��ļ��� */
        struct 
        {
            LONG    lChannel;                /*�طŵ�ͨ����*/
            NET_DVR_TIME struStartTime;            /* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;            /* ��ʱ��طŵĽ���ʱ�� */
            BYTE    byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD    wPort;/*CU�˿�*/
    BYTE    byRes2[2];
    DWORD   dwSessionID;//CMS�����sessionID,�������
    BYTE    byRes3[16];
}NET_DVR_PLAYBACKREQUESTPARAM, *LPNET_DVR_PLAYBACKREQUESTPARAM;    

//2010-10-06
typedef struct tagNET_DVR_PLAYBACKCALLBACKPARAM
{
    BYTE byPlayBackMode;        /* �ط�����ģʽ 1�������� 2����ʱ�� */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* �طŵ��ļ��� */
        struct 
        {
            LONG        lChannel;                /*�طŵ�ͨ����*/
            NET_DVR_TIME struStartTime;            /* ��ʱ��طŵĿ�ʼʱ�� */
            NET_DVR_TIME struStopTime;            /* ��ʱ��طŵĽ���ʱ�� */
            BYTE       byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    DWORD nSessionID;//CMS�����sessionID
    BYTE byRes2[44];
}NET_DVR_PLAYBACKCALLBACKPARAM, *LPNET_DVR_PLAYBACKCALLBACKPARAM;  

typedef struct tagNET_DVR_VOICEREQUESETPARAM
{
    BYTE    nVoiceChannel;        //�Խ�ͨ����
    BYTE    byRes1[3];
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD     wPort;/*CU�˿�*/
    BYTE    byRes2[10];
}NET_DVR_VOICEREQUESTPARAM, *LPNET_DVR_VOICEREQUESTPARAM;             

typedef struct tagNET_DVR_ALARMSETUPREQUESETPARAM
{
    NET_DVR_IPADDR struCuIp; //CU��IP��ַ
    WORD     wPort;/*CU�˿�*/
    BYTE    byRes[2];
}NET_DVR_ALARMSETUPREQUESTPARAM, *LPNET_DVR_ALARMSETUPREQUESTPARAM;        

typedef struct tagNET_DVR_GPSALARMINFO
{
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    NET_DVR_TIME_EX struGpsTime;    /*GPS�ϴ���ʱ��*/
    DWORD    dwLongitude;    /* ����*/
    DWORD    dwLatitude;  /* γ��*/
    int     iTimeZone; /*ʱ�����÷�������ʾ��+60����1����+480����8����-60����������-480������8�������ֶκ�GPSTime����һ��������ʱ������*/ 
    DWORD dwDirection; /*��������=ʵ�ʷ����Զ�Ϊ��λ����������Ϊ��˳ʱ�뷽����㣩*100*/
    WORD  wSatellites; /*��������*/
    WORD  wPrecision; /*����*/
    DWORD dwHeight; /*�߶�:���ף�Ԥ��*/
    DWORD dwGPSSeq; /*GPS��ţ�GPS����ʱҪ�õ�*/
    WORD  wSpeed;//�ٶȣ���λ��km/h
    /* direction[0]:'E'or'W'(����/����), direction[1]:'N'or'S'(��γ/��γ)*/
    char sDirection[2]; 
    BYTE byLocateMode;/*��λģʽ(��ֵ0)��1,������λ,2,���3,����,4,������Ч��65,��Ч��λ��78����Ч��λ*/  
    BYTE byRes[3];
}NET_DVR_GPSALARMINFO, *LPNET_DVR_GPSALARMINFO;

//ͼƬ��Ϣ�ϴ�
typedef struct tagNET_DVR_PICINFO
{
    DWORD   dwSize;                //�ṹ����
    BYTE    byChanIndex;            //ͨ����
    BYTE    byRes1[3];                //����
    BYTE     byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE    byAbsTime[32];        //����ʱ���, yyyymmddhhmmssxxx,
    DWORD   dwPicLen;                    //ͼƬ����
    BYTE    byRes2[32];
    BYTE    *pPicBuffer;
}NET_DVR_PICTUREINFO, *LPNET_DVR_PICTUREINFO;

//ƽ̨����
typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;//CMS����UDP������ѯ�Ķ˿�
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;

///���Ź���
#define DIALPASSWD_LEN  32 //�������볤��

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;    /* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;    /* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;    /* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;


typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];        /* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];    /* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];    /* password, eg. "card" */
    BYTE byApn[NAME_LEN];        /* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;        /* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;    /* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];    
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

#define MAX_PHONE_NUM                32//����볤��

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;        /* 0: disable; 1: enable 3g */
    BYTE byDialMethod;        /* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;    /* switch methold: 0: auto switch;1��3G���ȣ�2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* ʹ�ܱ������봥������; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;        /* auto off line when no connection exist,��λ�����ӣ���Χ��5~65535���� */    
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;        /*�������*/
    BYTE byNetType;        /* ָ�����ĳ�������Ĭ�ϲ��Ų���������ʱ�˲���û�á�0���Զ���1��CDMA��2��EVDO��3��WCDMA��4��TD-SCDMA */
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;


/* UIM card information */
typedef enum
{
    UIM_UNKNOWN = 0,
        UIM_VALID = 1,
        UIM_NOVALID = 4,
        UIM_ROAM = 11,
        UIM_NOEXIST = 255
}UIM_INFO;

/* real 3g mode */
typedef enum
{
    /* evdo */
    RMODE_CDMA1X = 12,
        RMODE_EVDO = 14,
        RMODE_CDMAHYBRID = 18,
        /* wcdma */
        RMODE_GSM = 21,
        RMODE_GPRS = 22,
        RMODE_EDGE = 23,
        RMODE_WCDMA = 24,
        RMODE_HSDPA = 25,
        RMODE_HSUPA = 26,
        RMODE_HSPA = 27,
        /* tdscdma */
        RMODE_TGSM = 31,
        RMODE_TGPRS = 32,
        RMODE_TEDGE = 33,
        RMODE_TDSCDMA = 34,
        RMODE_TDHSDPA = 35,
        RMODE_TDHSUPA = 36,
        RMODE_TDHSPA = 37
}REAL_MODE;

typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;        /* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;        /* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;            /* signal RSSI */
    DWORD dwDialStatus;        /* dial status */
    NET_DVR_IPADDR struLocalIp;    /* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;    /* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;    /* wireless networks netmask */
    NET_DVR_IPADDR struDns;        /* wireless networks DNS */     
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

//���Ź���
#define MAX_WHITELIST_NUM            8 //����������
#define NET_SDK_MAX_WHITELIST_NUM_32    32 //����������

#define HARDDISKFULL_EXCEPTION      0x0     /*Ӳ����*/
#define HARDDISKERROR_EXCEPTION     0x1     /*Ӳ�̴�*/
#define ETHERNETBROKEN_EXCEPTION    0x2     /*���߶�*/
#define IPADDRCONFLICT_EXCEPTION    0x3     /*IP��ַ��ͻ*/
#define ILLEGALACCESS_EXCEPTION     0x4     /*�Ƿ�����*/
#define VI_EXCEPTION                0x5     /*��Ƶ�ź��쳣*/
#define VS_MISMATCH_EXCEPTION       0x6     /*����/�����Ƶ��ʽ��ƥ�� */
#define VIDEOCABLELOSE_EXCEPTION    0x7     /*��Ƶ���ź�*/
#define AUDIOCABLELOSE_EXCEPTION    0x8     /*��Ƶ���ź�*/
#define ALARMIN_EXCEPTION           0x9     /*��������*/
#define MASKALARM_EXCEPTION         0xa     /*�ڵ�����*/
#define MOTDET_EXCEPTION            0xb     /*�ƶ����*/
#define RECORDING_EXCEPTION         0xc     /*¼���쳣*/
#define WIRELESS_EXCEPTION          0xd     /*PIR����*/
#define PIR_EXCEPTION                0xe     /*���߱���*/
#define CALLHELP_EXCEPTION          0xf     /*���ȱ���*/

#define AUDIO_DETECTION_EXCEPTION              0x10    /*��Ƶ�쳣��ⱨ��*/
#define SCENECHANGE_DETECTION_EXCEPTION        0x11    /*������ⱨ��*/
#define DEFOCUS_DETECTION_EXCEPTION            0x12    /*�齹��ⱨ��*/
#define FACE_DETECTION_ENTRANCE_EXCEPTION      0x13    /*������ⱨ��*/
#define LINE_DETECTION_ENTRANCE_EXCEPTION      0x14    /*Խ����ⱨ��*/
#define FIELD_DETECTION_ENTRANCE_EXCEPTION     0x15    /*����������ⱨ��*/
#define REGION_EXITING_EXCEPTION               0x16    /*�뿪������ⱨ��*/
#define REGION_ENTRANCE_EXCEPTION              0x17    /*�������򱨾�*/
#define LOITERING_EXCEPTION                    0x18    /*��Ա�ǻ���ⱨ��*/
#define GROUP_EXCEPTION                        0x19    /*��Ա�ۼ���ⱨ��*/
#define RAPIDMOVE_EXCEPTION                    0x1a    /*�����ƶ���ⱨ��*/
#define PARKING_EXCEPTION                      0x1b    /*ͣ����ⱨ��*/
#define UNATTENDEDBAGGAGE_EXCEPTION            0x1c    /*��Ʒ������ⱨ��*/
#define ATTENDEDBAGGAGE_EXCEPTION              0x1d    /*��Ʒ��ȡ��ⱨ��*/
#define DATATRAFFIC_EXCESS                     0x1e    /*��������*/
#define VOLTAGEINSTABLE_EXCEPTION              0x1f    /*��Դ��ѹ�쳣����*/
#define ALL_EXCEPTION                          0xff    /*�����¼��������¼�������ʽ�ж��Ƿ�����������*/


#define PHONECFG_RECEIVE_SMS        0x0    /* ֧�ֽ��ձ������� */
#define PHONECFG_SMS_CONTROL        0x1    /* ֧�ֶ��ſ��������� */
#define PHONECFG_CALL_CONTROL       0x2    /* ֧�ֺ��п������� */
#define PHONECFG_SMS_REBOOT         0x3    /*֧�ֶ�������*/
#define PHONECFG_DOOR_CONTROL       0x4    /* ֧���Ų�������*/
#define PHONECFG_SMS_GET_DAIL_STATUS       0x5   /* ֧�ֶ��Ż�ȡ����״̬*/


typedef struct tagNET_DVR_PHONECFG
{
    BYTE byWhiteList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*���ֽڱ�ʾ�Ƿ�ʹ�ܸú����ĳ���ܣ�����λ����ĺ���
    ��PHONECFG_RECEIVE_SMS�ȶ��� */
    BYTE byAlarmHandler[32];   /*���ֽڱ�ʾ�Ƿ�ʹ�ܶ�ĳ���������͵Ķ��ŷ���*/
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struWhiteList[MAX_WHITELIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;

typedef struct tagNET_DVR_PHONECFG_V50
{
    BYTE byWhiteList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*���ֽڱ�ʾ�Ƿ�ʹ�ܸú����ĳ���ܣ�����λ����ĺ���
                              ��PHONECFG_RECEIVE_SMS�ȶ��� */
    BYTE byAlarmHandler[32];   /*���ֽڱ�ʾ�Ƿ�ʹ�ܶ�ĳ���������͵Ķ��ŷ���(�Ž�������ʱ�ò���)*/
    BYTE byAcsPassword[16];       /*��������*/
    BYTE byName[NAME_LEN/*32*/];     /*����*/
    BYTE byRes[80];
} NET_DVR_PHONECFG_V50, *LPNET_DVR_PHONECFG_V50;

typedef struct tagNET_DVR_SMSRELATIVEPARAM_V50
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG_V50 struWhiteList[NET_SDK_MAX_WHITELIST_NUM_32];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM_V50, *LPNET_DVR_SMSRELATIVEPARAM_V50;

#define NET_SDK_MONITOR_ID_LEN 64 //��ص�ID����

typedef struct tagNET_DVR_ACS_EVENT_COND
{
    DWORD dwSize;
    DWORD dwMajor; //���������ͣ��ο��¼��ϴ��궨�壬0-ȫ��
    DWORD dwMinor; //���������ͣ��ο��¼��ϴ��궨�壬0-ȫ��
    NET_DVR_TIME    struStartTime; //��ʼʱ��
    NET_DVR_TIME    struEndTime; //����ʱ��
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byName[NAME_LEN]; //�ֿ�������
    BYTE byPicEnable; //�Ƿ��ͼƬ��0-����ͼƬ��1-��ͼƬ
    BYTE byTimeType; //ʱ�����ͣ�0-�豸����ʱ�䣨Ĭ�ϣ���1-UTCʱ�䣨struStartTime��struEndTime��ʱ�䣩
    BYTE byRes2[2]; //����
    DWORD dwBeginSerialNo; //��ʼ��ˮ�ţ�Ϊ0ʱĬ��ȫ����
    DWORD dwEndSerialNo; //������ˮ�ţ�Ϊ0ʱĬ��ȫ����
    DWORD dwIOTChannelNo; //IOTͨ���ţ�0-��Ч
    WORD  wInductiveEventType; //�����¼����ͣ�0-��Ч������ֵ�μ�2.2�½ڣ��ͻ����жϸ�ֵΪ��0ֵ�󣬱�������ͨ�������¼��������֣�����ͨ��ԭ�б����������ͣ�dwMajor��dwMinor������
    BYTE   bySearchType;      //������ʽ��0-������1-���¼�Դ��������ʱͨ����Ϊ����Ƶͨ���ţ���2-����ص�ID����
    BYTE   byEventAttribute; //�¼����ԣ�0-δ���壬1-�Ϸ��¼���2-����
    char     szMonitorID[NET_SDK_MONITOR_ID_LEN/*64*/];          //��ص�ID�����豸���кš�ͨ�����͡������ɣ������Ž��㣺�豸���к�+��DOOR��+�ű�ţ�
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE byRes[140]; //����
}NET_DVR_ACS_EVENT_COND, *LPNET_DVR_ACS_EVENT_COND;

typedef struct tagNET_DVR_ACS_EVENT_DETAIL
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //���ţ�mac��ַ����Ϊ0��Ч
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������Ϊ0��Ч
    BYTE byWhiteListNo; //����������,1-8��Ϊ0��Ч
    BYTE byReportChannel; //�����ϴ�ͨ����1-�����ϴ���2-������1�ϴ���3-������2�ϴ���Ϊ0��Ч
    BYTE byCardReaderKind; //������������һ�࣬0-��Ч��1-IC��������2-���֤��������3-��ά�������,4-ָ��ͷ
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    DWORD dwDoorNo; //�ű�ţ�¥���ţ���Ϊ0��Ч
    DWORD dwVerifyNo; //���ؿ���֤��ţ�Ϊ0��Ч
    DWORD dwAlarmInNo;  //��������ţ�Ϊ0��Ч
    DWORD dwAlarmOutNo; //��������ţ�Ϊ0��Ч
    DWORD dwCaseSensorNo; //�¼����������
    DWORD dwRs485No;    //RS485ͨ���ţ�Ϊ0��Ч
    DWORD dwMultiCardGroupNo; //Ⱥ����
    WORD wAccessChannel;    //��Աͨ����
    BYTE  byDeviceNo; //�豸��ţ�Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byDistractControlNo;//�ֿ�����ţ�Ϊ0��Ч
    DWORD dwEmployeeNo; //���ţ�Ϊ0��Ч
    WORD wLocalControllerID; //�͵ؿ�������ţ�0-�Ž�������1-64����͵ؿ�����
    BYTE  byInternetAccess; //����ID����1-��������1,2-��������2,3-��������1��
    BYTE  byType;     //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷���,10-�Ž��������ŷ�����11-�Ž��������ŷ��� 0xff-��
    BYTE  byMACAddr[MACADDR_LEN]; //�����ַ��Ϊ0��Ч
    BYTE  bySwipeCardType;//ˢ�����ͣ�0-��Ч��1-��ά��
    BYTE  byEventAttribute; //�¼����ԣ�0-δ���壬1-�Ϸ���֤��2-����
    DWORD dwSerialNo; //�¼���ˮ�ţ�Ϊ0��Ч
    BYTE  byChannelControllerID; //ͨ��������ID��Ϊ0��Ч��1-��ͨ����������2-��ͨ��������
    BYTE  byChannelControllerLampID; //ͨ���������ư�ID��Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byChannelControllerIRAdaptorID; //ͨ������������ת�Ӱ�ID��Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byChannelControllerIREmitterID; //ͨ���������������ID��Ϊ0��Ч����Ч��Χ1-255��
    DWORD dwRecordChannelNum; //¼��ͨ����Ŀ
    char    *pRecordChannelData;//¼��ͨ������СΪsizeof(DWORD)* dwRecordChannelNum
    BYTE  byUserType; //��Ա���ͣ�0-��Ч��1-��ͨ�ˣ����ˣ���2-�������ÿͣ���3-�������ˣ�4-����Ա
    BYTE  byCurrentVerifyMode; //��������ǰ��֤��ʽ��0-��Ч��1-���ߣ�2-ˢ��+���룬3-ˢ����4-ˢ�������룬5-ָ�ƣ�6-ָ��+���룬7-ָ�ƻ�ˢ����8-ָ��+ˢ����9-ָ��+ˢ��+���룬10-������ָ�ƻ�ˢ�������룬11-����+ָ�ƣ�12-����+���룬
            //13-����+ˢ����14-������15-����+���룬16-ָ�ƻ����룬17-����+ָ�ƣ�18-����+ָ��+���룬19-����+ָ��+ˢ����20-����+����+ָ�ƣ�21-����+������22-����������+ˢ����23-ָ�ƻ�������24-ˢ�������������룬25-ˢ����������26-ˢ����������ָ�ƣ�27-ˢ����ָ�ƻ�����
    BYTE  byAttendanceStatus;  //����״̬��0-δ����,1-�ϰ࣬2-�°࣬3-��ʼ��Ϣ��4-������Ϣ��5-��ʼ�Ӱ࣬6-�����Ӱ�
    BYTE  byStatusValue;  //����״ֵ̬
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID���������豸��˵�����ʹ���˹��ţ���ԱID���ֶΣ�byEmployeeNoһ��Ҫ���ݣ����byEmployeeNo��ת��ΪdwEmployeeNo����ô���ֶ�ҲҪ���ݣ������ϲ�ƽ̨��ͻ�����˵�����Ƚ���byEmployeeNo�ֶΣ�����ֶ�Ϊ�գ��ٿ��ǽ���dwEmployeeNo�ֶΣ�
    BYTE  byRes[64];
}NET_DVR_ACS_EVENT_DETAIL, *LPNET_DVR_ACS_EVENT_DETAIL;

typedef struct tagNET_DVR_ACS_EVENT_CFG
{
    DWORD dwSize;
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME struTime; //ʱ��
    BYTE    sNetUser[MAX_NAMELEN];//����������û���
    NET_DVR_IPADDR    struRemoteHostAddr;//Զ��������ַ
    NET_DVR_ACS_EVENT_DETAIL struAcsEventInfo; //��ϸ����
    DWORD dwPicDataLen;   //ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pPicData;
    WORD  wInductiveEventType; //�����¼����ͣ�0-��Ч������ֵ�μ�2.2�½ڣ��ͻ����жϸ�ֵΪ��0ֵ�󣬱�������ͨ�������¼��������֣�����ͨ��ԭ�б����������ͣ�dwMajor��dwMinor������
    BYTE byTimeType; //ʱ�����ͣ�0-�豸����ʱ�䣨Ĭ�ϣ���1-UTCʱ�䣨struTime��ʱ�䣩
    BYTE byRes[61];
}NET_DVR_ACS_EVENT_CFG, *LPNET_DVR_ACS_EVENT_CFG;

typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;//��������
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;//������ָ�볤�ȣ��������
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;            /* the index of sms */
    BYTE byStatus;            /* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;        /* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

#define    MAX_SMSCONTENT_LEN        140//�������ݳ���
typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;     

//pin������
typedef enum
{
    CPIN_READY = 1,
        CPIN_PIN = 2,
        CPIN_PUK = 3,
        CPIN_PIN2 = 4,
        CPIN_PUK2 = 5
}PIN_READY;

typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;        /* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;    /* remain input PIN times */
    BYTE byPukTimes;    /* remain input PUK times */    
    BYTE bEnableLock;    /* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;

typedef enum
{
    PIN_ENABLE = 1,
        PIN_DISABLE = 2,
        PIN_VERIFY = 3,
        PUK_VERIFY = 4,
        PIN_CHANGE = 5
}PIN_CMD;
#define MAX_PIN_LEN        12  //PIN����󳤶�
typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;        /* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];        /* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];    /* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;


//ͼƬ����
typedef struct 
{
    /* 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA*/
    WORD    wPicSize;
    WORD    wPicQuality; /* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
    //ץͼͼƬ����ʽ��1-�ϴ����ģ�2-�豸���ر��棬3-�ϴ�����ͬʱ�豸���ر���
    BYTE    byPicTackleMode; 
    BYTE   byRes[11];
}NET_DVR_PUSHJPEGPARA, *LPNET_DVR_PUSHJPEGPARA;


#define    COM_PUSHALARM        0x1200    //�豸����������Ϣ�ϴ�����ģʽ�豸ʹ��
#define    COM_PUSHALARM_V30    0x1201    //�豸����������Ϣ�ϴ�v30����ģʽ�豸ʹ��
typedef struct tagNET_DVR_PUSHALARMINFO
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����*/
    DWORD dwAlarmInputNumber;/*��������˿�*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*����������˿ڣ���һλΪ1��ʾ��Ӧ��һ�����*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*������¼��ͨ������һλΪ1��ʾ��Ӧ��һ·¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmTypeΪ2��3,6ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]λ��Ӧ��1��Ӳ��*/
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[4];
}NET_DVR_PUSHALARMINFO, *LPNET_DVR_PUSHALARMINFO;

typedef struct 
{
    DWORD dwAlarmType;/*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯  12-�����쳣 */
    DWORD dwAlarmInputNumber;/*��������˿�*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*����������˿ڣ�Ϊ1��ʾ��Ӧ���*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*������¼��ͨ����Ϊ1��ʾ��Ӧ¼��, dwAlarmRelateChannel[0]��Ӧ��1��ͨ��*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmTypeΪ2��3,6��9��10ʱ����ʾ�ĸ�ͨ����dwChannel[0]��Ӧ��1��ͨ��*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmTypeΪ1,4,5ʱ,��ʾ�ĸ�Ӳ��, dwDiskNumber[0]��Ӧ��1��Ӳ��*/
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[7];
}NET_DVR_PUSHALARMINFO_V30, *LPNET_DVR_PUSHALARMINFO_V30;

//2011-04-20
//��������
typedef struct tagNET_DVR_MB_AUTOWORKPARA
{
    /*��ǰ�������Ʒ�ʽ 0:  Ԥ��,  1:  ��ʱ�ػ�,  2:  �Զ����ػ�*/
    BYTE    byCurPowerCtrlType;   
    BYTE    byRes[3];
    NET_DVR_SCHEDTIME    struWorkTime[MAX_DAYS][2];    
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD     dwHaltDelay; /* �ػ��ӳ�ʱ��,��λmin */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*����������ز�������*/
    BYTE       byEnableUnderVoltProtect;   /*�Ƿ���Ƿѹ����*/
    BYTE       byUnderVoltPercent;   /*Ƿѹ�����ٷֱȣ���85��90��95������Чֵ*/
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;
/*ע��1�����ػ��ӳ�ʱ��, ��ѡʱ��Ϊ 0��5���ӣ�10���� ��20���� 25���� 30���� 35���� 40���� ��45 ���� 50���� ��60���� ��60*2���� ��60*3  60 *4   60*5  60*6 */

//�Զ�����
typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* �Ƿ����Զ����� 0 �ر� ��1 ���� */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30];     /*��Ҫ���ݵ�ͨ��*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*��������*/
                                        /* �����ļ����� 
                                        {0,ALL_RECORD_TYPE,ȫ��},
                                        {1,TIMING_REC,��ʱ},
                                        {2,MOTION_DETECT_REC,�ƶ���� },
                                        {3,ALARM_REC,���� },
    {4,MANUAL_REC,�ֶ�¼��}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];    /* �Զ�����ʱ���*/                
    BYTE  byRes2[36];                        /* �����ֽ�*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;


typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;    /*�Ƿ�����GPS */
    BYTE  byGpsInterface;/*gps���սӿ�0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*�ٶȵ�λ��0������/Сʱ��1 ��Ӣ��/Сʱ*/
    BYTE  byEnableRetrieve; /* ä������(1���ã�0������) */
    int      iAdjustTime;/*ʱ��*/
    BYTE  byEnableAdjustTime;/*�Ƿ�����GPSУʱ�� 1-����, 0-������*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;    /* GPS�ϴ����, ��*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD ��ʾ��ÿ�ֽڴ���һ· */
    DWORD dwSpeedLimit;    /* ���ٱ���*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm; 
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;
/*ע��1��������λΪ����/Сʱ ʱ��ΧΪ��0 ,965����������Ӣ��/Сʱ����λ��ʱ�� ������ٶȷ�ΧΪ��0-600*/

#define         SENSOR_IN_NUMBER          8
typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*�г�״̬��ش�����������ֻ�ú�4�����ֱ����ɲ������ת����ת��������0-�ߵ�ƽ��1-�͵�ƽ*/
    BYTE  byTriggerChannel [SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay [MAX_CHANNUM_V30];/*OSD��ʾ,ÿλ����һ·*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;


typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD    dwMaxXAcc;    /* X����ٶȱ���ֵ ����ȡֵΪʵ����ֵ����10,��СΪ0*/
    DWORD    dwMaxYAcc;    /* Y����ٶȱ���ֵ ����ȡֵΪʵ����ֵ����10.��СΪ0*/
    DWORD    dwMaxZAcc;    /* Z����ٶȱ���ֵ�� ��ȡֵΪʵ����ֵ����10,��СΪ0*/
    BYTE    byRes[4];
}NET_DVR_ACCELERATIONCFG,*LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*ģ��ѡ��0����/1����*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];    /*������չ�ֽ�*/
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR    struDownloadSvrIp;        /* �Զ����ط�������ַ */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA,*LPNET_DVR_MB_DOWNLOADSVRPARA;

/* ����ʶ�����ز���*/
typedef struct tagNET_DVR_PLATERECOG_PARA
{
    DWORD dwSize;
    BYTE byPrMode; /* ����ʶ���ģʽ, ��̬ͼ��0/��̬��Ƶ1 */
    BYTE byPrScene; /* ����ʶ��ĳ���, ���ٳ���0/���ٳ���1 */
    BYTE byPrDetRect; /* 0:ȫ��Ļ;1:�������� */
    BYTE byPrPicQuality; /* ����ʶ�𷵻ص�ͼƬ����, 0:���/3:��� */    
    BYTE byPrPicMode;/*����ʶ�𷵻ص�ͼƬ�ֱ���: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF */
    BYTE byPlateOsdDisplay; /* ����OSD�Ƿ���ʾ 0:����ʾ/1:��ʾ */
    BYTE byPrProvCharIndex;    /* ����ʶ��ʡ���׺��ֶ�Ӧ������ */
    BYTE byPrProvCharIndex1;    /* ����ʶ�𳣼��׺���1��Ӧ������ */
    BYTE byPrProvCharIndex2;    /* ����ʶ�𳣼��׺���2��Ӧ������ */
    BYTE byRes[7];
}NET_DVR_PLATERECOG_PARA, *LPNET_DVR_PLATERECOG_PARA;


/* ��̬ȡ֤ϵͳ,�������ò����Ľṹ*/
typedef struct tagNET_DVR_SPEEDLMT_PARA
{
    BYTE    bStartMaxSpeedLimit;        /* ������������ */
    BYTE    bStartMinSpeedLimit;        /* ������������ */
    BYTE    byRes[6];
    DWORD    dwMaxSpeedLimit;                /* ������� */
    DWORD    dwMinSpeedLimit;                /* ������� */
}NET_DVR_SPEEDLMT_PARA, *LPNET_DVR_SPEEDLMT_PARA;

/* ��̬ȡ֤ϵͳ,���ƱȶԲ����Ľṹ*/
typedef struct tagNET_DVR_PLATECHECK_PARA
{
    BYTE    bAlarmWhenChecked;            /* ����ɹ��Ƿ񱨾� */
    BYTE    bInformWhenChecked;            /* ����ɹ��Ƿ�Ի�����ʾ */
    BYTE    byRes[6];
    NET_DVR_IPADDR struBlackFtpServer;            /* ������FTP��������ַ */
}NET_DVR_PLATECHECK_PARA, *LPNET_DVR_PLATECHECK_PARA;

typedef struct tagNET_DVR_ENFORCESYS_PARA
{
    DWORD dwSize;
    NET_DVR_SPEEDLMT_PARA    struSpeedLmtPara;    /*��������*/
    NET_DVR_PLATECHECK_PARA struPlateCheckPara;    /*���Ʊȶ�*/
    BYTE    bySelPeccType;    /*�Ƿ�ѡ��Υ������*/
    BYTE    byEnfOptHabit; /*ȡ֤����ϰ��, 0:����ȡ֤;1:�̰�����ȡ֤*/
                           /*Ԥ��֡�ʵ���ģʽ�����֣�
                           A �ر� adjPrevFpsMode=0
                           �Թ̶���֡��(25FPS)Ԥ��
                           B ��׼ adjPrevFpsMode=1
                           �Թ̶���֡��(6FPS)Ԥ��
                           C ����Ӧ adjPrevFpsMode=2
                           ����GPS�ٶ���Ϣ��̬����Ԥ��֡�ʣ�
    3������ЧGPS������£��Թ̶���֡��Ԥ��*/
    BYTE    byAdjPrevFpsMode;        
    BYTE    byRes1;
    NET_DVR_IPADDR  struUploadServerIp; //�ϴ���������ַ
    WORD    wUploadServerPort;
    BYTE    byRes2[18];
}NET_DVR_ENFORCESYS_PARA, *LPNET_DVR_ENFORCESYS_PARA;

typedef struct tagNET_DVR_PUSHMODEPARAM
{
    //ֱ��ģʽ��UDPԤ��ģʽ��1-ͬ�˿ڶ�·����2-һ�˿�һ·��
    BYTE byUdpPreviewMode; 
    //�����Խ�����ģʽ��0-�����Խ���1-����ת����SDK�����������Ĳɼ��Ͳ��ţ�
    BYTE byVoiceWorkMode; 
    BYTE byRes[18];    
}NET_DVR_PUSHMODEPARAM, *LPNET_DVR_PUSHMODEPARAM;

#define MAX_ALARMHOST_ALARMIN_NUM            512//���籨��������󱨾��������
#define MAX_ALARMHOST_ALARMOUT_NUM            512//���籨��������󱨾��������

#define ALARMHOST_MAX_AUDIOOUT_NUM            32//���籨������������������
#define ALARMHOST_MAX_ELECTROLOCK_NUM        32//���籨��������������
#define ALARMHOST_MAX_MOBILEGATE_NUM        32//���籨����������ƶ�����
#define ALARMHOST_MAX_SIREN_NUM             8 // ��󾯺���Ŀ
#define MAX_ALARMHOST_SUBSYSTEM             32//�������������ϵͳ��
#define ALARMHOST_DETECTOR_SERIAL_LEN       9//������������̽�������кų���
#define ALARMHOST_DETECTOR_SERIAL_LEN_V50   16 //������������̽�������к�V50����
#define MAX_DETECTOR_NUM                    128//������̽������
#define MAX_DETECTOR_NUM_V51        256     //������̽������
#define MAX_REPEATER_NUM        16     //����м�����
#define MAX_OUTPUT_MODULE_NUM        64     //������ģ����
#define MAX_ELECTRIC_LOCK_NUM        64     //����������

//����������
typedef enum tagSENSOR_TYPE
{
    SENSOR_TYPE_NONE = 0,                   // ��
        SENSOR_TYPE_TEMPERATURE = 1,            // �¶�
        SENSOR_TYPE_HUMIDITY ,                  // ʪ��
        SENSOR_TYPE_WINDSPEED,                  // ����
        SENSOR_TYPE_GAS,                        // ����
        SENSOR_AC_VOLTAGE,                      // ������ѹ
        SENSOR_AC_CURRENT,                      // ��������
        SENSOR_DC_VOLTAGE,                      // ֱ����ѹ
        SENSOR_DC_CURRENT,                      // ֱ������
        SENSOR_WATER_PRESSURE,                  // ˮѹ
        SENSOR_PRESSURE_TRANSMITTER,            // ѹ��������
        SENSOR_FLOW_TRANSMITTER,                // ����������
        SENSOR_WATER_LEAKAGE,                   // ©ˮ������
        SENSOR_INTERGRATED_TEMPERATURE_DETECTOR,//һ�廯�±�
        SENSOR_ISOLATION_TEMPERATURE_DETECTOR,  //����ʽ�±�
        SENSOR_RESIDUAL_CHLORINE,               //����������
        SENSOR_TYPE_AC_TERMINAL = 16,           // AC����              
        SENSOR_TYPE_AC_SOCKET = 17,             // AC����
        SENSOR_TYPE_HUMITURE,                   // ��ʪ��
        SENSOR_TYPE_FLOW,                       // ����
        SENSOR_LIQUID_LEVEL,                    // Һλ
        SENSOR_TYPE_ARC,                        // �绡
        SENSOR_TYPE_UNKNOW = 255                // δ����
}SENSOR_TYPE;

typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD  dwSize;                 // �ṹ���С
    BYTE    byName[NAME_LEN];    // ����������
    BYTE    byEnable;               // �Ƿ����� 
    BYTE    byValid;                // �Ƿ���Ч ����������������(�ò���ֻ�ܻ�ȡ���ܸ�����)
    BYTE    byType;                 // ģ�������� ����SENSOR_TYPE
    BYTE    byAlarmMode;//����ģʽ�����֣�15-HHHH��14-HHHL��12-HHLL��8HLLL��0-LLLL������1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������)
    float   fMeasureHigh;           // ��������
    float   fMeasureLow;            // ��������
    float    fAlarm1;           //������1,������1-4 ��������
    float    fAlarm2;           //������2
    float    fAlarm3;           //������3
    float    fAlarm4;           //������4
    DWORD   dwOsdCfg;          //ģ�����ַ����ӣ���λ��ʾ0-15��Ӧ��Ƶͨ��1-16
    float    fSensitive;            // �����ȱ�ʾ��ʵʱֵ�ı仯���������ȵķ�Χʱ�����ʾʵʱֵ�����˱仯��������Ϊû�з����仯���磺������Ϊ0.1�����ʾǰ���������ֵ֮�����0.1ʱ������Ϊ���ݷ����仯����0.1����Ҫ�ϴ������Ϊ1�����ʾ�仯����1ʱ�ϱ���
    BYTE    bySensorStandard;    //���������0- 0~20mA��1- 0~5V��2- 0~2.5Mpa��3- 0~1.6Mpa��4- 0~5m
    BYTE    byChan;            //ģ����ͨ����
    BYTE    byRes3[114];            // �����ֽ�
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;                    // �ṹ��С
    BYTE    byName[NAME_LEN];        // ����
    WORD    wDelay;                    // ����ӳ� ��λΪ��, ��Χ 0~5599s 0��ʾһֱ�����
    BYTE    byRes1[2];
    DWORD   dwOverallEventJointSirenOn;        //ȫ���¼�������������������¼����Ͱ�λ��ʾ��bit0-��������, bit1-ȫ�ּ��̽�������,bit2-������ϵ磬bit3-��ص�ѹ��,bit4-�绰�ߵ���,bit5-���������쳣,bit6-���������쳣,  bit7-����485���ߣ�bit8- WIFIͨ�Ź��ϣ�bit9-RF�źŸ��Ź���
    DWORD    dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//��ϵͳ�¼�����������������������±��ʾ��ϵͳ�ţ�ÿһ��Ԫ�ذ�λ��ʾ�¼����ͣ�bit0-��������
    BYTE    byRes2[448];  // �����ֽڡ���
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD    dwSize;        // �ṹ���С
    BYTE    byEnable;    // 0--�ػ� 1--����
    BYTE    byMode;        // �յ�ģʽ
    BYTE    byTemperature;    // �¶ȣ�����ֵ��ʾ ͨ��Ϊ16-30��
    BYTE	byAirConditionNo;	// �յ����
    BYTE    byRes[8];        // �����ֽ�
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;

typedef enum tagDETECTOR_TYPE
{
    PANIC_BUTTON = 0,               // ������ť
        MAGNETIC_CONTACT,               // �Ŵ�
        SMOKE_DETECTOR,                 // �̸�̽����
        ACTIVE_INFRARED_DETECTOR,       // ��������̽����
        PASSIVE_INFRARED_DETECTOR,      // ��������̽����
        GLASS_BREAK_DETECTOR,           // ��������̽����
        VIBRATION_DETECTOR,             // ��̽����
        DUAL_TECHNOLOGY_PIR_DETECTOR,   // ˫��̽����
        TRIPLE_TECHNOLOGY_PIR_DETECTOR, // ������̽����
        HUMIDITY_DETECTOR,              // ʪ��̽����
        TEMPERATURE_DETECTOR,           // �¸�̽����
        COMBUSTIBLE_GAS_DETECTOR,        // ��ȼ����̽����
        DYNAMIC_SWITCH,                    //�涯����
        CONTROL_SWITCH,                    //���ƿ���
        SMART_LOCK,                        //������
        WATER_DETECTOR,                 //ˮ��̽����
        DISPLACEMENT_DETECTOR,    //λ��̽����
        SINGLE_INFRARED_DETECTOR,    //�����Ŵ�̽����
        SINGLE_ZONE_MODULE,    //���ߵ�����ģ��
        CURTAIN_INFRARED_DETECTOR,   //Ļ����������̽����19
        //20
        DOORBELL_SWITCH=21,              //���忪��21
		MEDICAL_HELP_BUTTON,			//ҽ��������ť
		OUTDOOR_DUAL_TECH,				//����˫��������
	
        OTHER_DETECTOR = 0xffff          // ����̽����   
}DETECTOR_TYPE;

typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷���,10-�Ž��������ŷ�����11-�Ž��������ŷ��� ��12-��ʱ������13-����������0xff-��
    BYTE    byUploadAlarmRecoveryReport;    //�Ƿ��ϴ����������ָ����棬0-���ϴ���1-�ϴ�        
    DWORD    dwParam;    // ��������  ��ʱ������ʱ�೤ʱ��, �������������������б�����������ʱʱ��ͨ��������������� , �������������÷�ʽͨ���������е�bySupportAlarmInDelay�ֶ�������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*����ʱ��ʱ���*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // ������������������
    BYTE    byAssociateSirenOut[8];        //  ������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE    bySensitivityParam;//���������Ȳ���, 0-10ms��1-250ms��2-500ms��3-750ms
    BYTE    byArrayBypass;//�Ƿ������·��,0-��֧������·,1-֧������·
    BYTE    byJointSubSystem; //������������ϵͳ�ţ��ò���ֻ�ܻ�ȡ  
    BYTE    byModuleStatus;    //ģ��״̬ 1-���� 2-����
    WORD    wModuleAddress;    //ģ���ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE    byModuleChan;    //ģ��ͨ���ţ���1��ʼ�����ֵ����ģ��������������0xFF��ʾ��Ч
    BYTE    byModuleType;    //ģ�����ͣ�1-���ط�����2-��������3-˫������4-8������5-8·ģ��������, 6-������������, 7-1�ž͵ؿ�������8-2�ž͵ؿ�������9-4�ž͵ؿ�������10-8�������ߡ�11-���̡�12-8�������ߡ�13-��չ����
    WORD    wZoneIndex;        //�����ţ��ò���ֻ�ܻ�ȡ      
    WORD    wInDelay;    //������ʱ��0-255��
    WORD    wOutDelay;    //�˳���ʱ��0-255��
    BYTE    byAlarmType;     //���������� 0-��Ч��1-������2-����
    BYTE    byZoneResistor;    //�������裬��λǧŷ  0-��Ч 1--2.2 ��2--3.3��3--4.7��4--5.6 �� 5--8.2 ��0xff-�Զ���
    float    fZoneResistorManual;/*�����ֶ����裬1.0-10.0����ȷ��С�����һλ����λǧŷ��byZoneResistorΪ0xffʱ��Ч*/
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //̽�������кţ�ֻ��
    BYTE    byZoneSignalType;    //�����źŴ�������(ֻ��)��0-���߷�����1-���߷���
    BYTE    byDisableDetectorTypeCfg;    //̽���������Ƿ񲻿��䣬0-���䣬1-������
    BYTE    byTimeOutRange;      // ��ʱʱ�䷶Χ��0:1~599s,1:1~65535s
    BYTE    byAssociateLampOut[8];//  ������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    WORD   wTimeOut;  //��ʱʱ�䣬��
    BYTE    byDetectorSignalIntensity;      // ̽�����ź�ǿ�ȣ�ֻ������0~100
    BYTE    byTimeOutMethod;    //��ʱ������ʱ��ʽ��0-������ʱ��1-�ָ���ʱ
    BYTE    byRes3[8];      // �����ֽ�
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷��� ��12-��ʱ������13-����������14-ȼ��������0xff-��
    BYTE    byUploadAlarmRecoveryReport;    //�Ƿ��ϴ����������ָ����棬0-���ϴ���1-�ϴ�        
    DWORD    dwParam;    // ��������  ��ʱ������ʱ�೤ʱ��, �������������������б�����������ʱʱ��ͨ��������������� , �������������÷�ʽͨ���������е�bySupportAlarmInDelay�ֶ�������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*����ʱ��ʱ���*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // ������������������
    BYTE    byAssociateSirenOut[8];        //  ������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE    bySensitivityParam;//���������Ȳ���, 0-10ms��1-250ms��2-500ms��3-750ms
    BYTE    byArrayBypass;//�Ƿ������·��,0-��֧������·,1-֧������·
    BYTE    byJointSubSystem; //������������ϵͳ�ţ��ò���ֻ�ܻ�ȡ  
    BYTE    byModuleStatus;    //ģ��״̬ 1-���� 2-����
    WORD    wModuleAddress;    //ģ���ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE    byModuleChan;    //ģ��ͨ���ţ���1��ʼ�����ֵ����ģ��������������0xFF��ʾ��Ч
    BYTE    byModuleType;    //ģ�����ͣ�1-���ط�����2-��������3-˫������4-8������5-8·ģ��������, 6-������������, 7-1�ž͵ؿ�������8-2�ž͵ؿ�������9-4�ž͵ؿ�������10-8�������ߡ�11-���̡�12-8�������ߡ�13-��չ����
    WORD    wZoneIndex;        //�����ţ��ò���ֻ�ܻ�ȡ      
    WORD    wInDelay;    //������ʱ��0-255��
    WORD    wOutDelay;    //�˳���ʱ��0-255��
    BYTE    byAlarmType;     //���������� 0-��Ч��1-������2-����
    BYTE    byZoneResistor;    //�������裬��λǧŷ  0-��Ч 1--2.2 ��2--3.3��3--4.7��4--5.6 �� 5--8.2 ��0xff-�Զ���
    float    fZoneResistorManual;/*�����ֶ����裬1.0-10.0����ȷ��С�����һλ����λǧŷ��byZoneResistorΪ0xffʱ��Ч*/
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN_V50]; //̽�������кţ�ֻ��
    BYTE    byZoneSignalType;    //�����źŴ�������(ֻ��)��0-���߷�����1-���߷���
    BYTE    byDisableDetectorTypeCfg;    //̽���������Ƿ񲻿��䣬0-���䣬1-������
    WORD   wTimeOut;  //��ʱʱ�䣬��    
    BYTE    byAssociateLampOut[8];//  ������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ�����
    BYTE    byVoiceFileName[32];   //�����ļ���
    BYTE    byTimeOutRange;      // ��ʱʱ�䷶Χ��0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // ̽�����ź�ǿ�ȣ�ֻ������0~100
    BYTE    byTimeOutMethod;    //��ʱ������ʱ��ʽ��0-������ʱ��1-�ָ���ʱ
    BYTE    byAssociateFlashLamp;//  �������� 0-��Ч��1-�������2-���
    BYTE    byStayAwayEnabled;//  ��ʱ�����ڼ���·ʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    bySilentModeEnabled;//  ����ģʽʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    byRelativeChannel[RELATIVE_CHANNEL_LEN];// ������ͨ���ţ�0��ʾ��Ч��һ��byte�ֽڱ�ʾһ��ͨ����
    BYTE    byDetectorVersion[VERSION_INFO_LEN];   //̽�����汾��ֻ��
    BYTE    byDetectorMAC[MACADDR_LEN];    //̽����MAC��ַ��ֻ��
    BYTE    byLinkageAlarmType;    //�����������ͣ�1-�𾯣�2-��ܣ�3-������4-���Σ�5-����
    BYTE    byRes3[465];  // �����ֽ�
}NET_DVR_ALARMIN_PARAM_V50, *LPNET_DVR_ALARMIN_PARAM_V50;

#define MAX_MAX_ALARMIN_NUM            64    /* ������ȡ��������*/
typedef    struct tagNET_DVR_MULTI_ALARMIN_COND
{
    DWORD    dwSize;
    int        iZoneNo[MAX_MAX_ALARMIN_NUM];    //������,��0��ʼ��С��0��ʾ��Ч
    BYTE    byRes[256];
}NET_DVR_MULTI_ALARMIN_COND, *LPNET_DVR_MULTI_ALARMIN_COND;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM
{
    DWORD   dwSize;
    WORD    wZoneNo;        //�����ţ��ò���ֻ�ܻ�ȡ
    BYTE    byJointSubSystem; //������������ϵͳ�ţ��ò���ֻ�ܻ�ȡ 
    BYTE    byType;            //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷���,12-��ʱ����,13-��������14-ȼ��������0xff-��
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //������ʱ��0-255��
    WORD    wOutDelay;        //�˳���ʱ��0-255��
    BYTE    byAlarmType;    //����������  0-��Ч 1-���� 1-����
    BYTE    byZoneSignalType;    //�����źŴ������ͣ�0-���߷�����1-���߷���
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //̽�������кţ�ֻ��
    BYTE    byDisableDetectorTypeCfg;    //̽���������Ƿ񲻿��䣬0-���䣬1-������
    BYTE    byTimeOutRange;      // ��ʱʱ�䷶Χ��0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // ̽�����ź�ǿ�ȣ�ֻ������0~100
    WORD   wTimeOut;  //��ʱʱ�䣬��
    BYTE    byTimeOutMethod;    //��ʱ������ʱ��ʽ��0-������ʱ��1-�ָ���ʱ
    BYTE    byAssociateFlashLamp;//  �������� 0-��Ч��1-�������2-���
    BYTE    byStayAwayEnabled;//  ��ʱ�����ڼ���·ʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    bySilentModeEnabled;//  ����ģʽʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    byRes2[110];    // �����ֽ�
}NET_DVR_SINGLE_ALARMIN_PARAM, *LPNET_DVR_SINGLE_ALARMIN_PARAM;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    WORD    wZoneNo;        //�����ţ��ò���ֻ�ܻ�ȡ
    BYTE    byJointSubSystem; //������������ϵͳ�ţ��ò���ֻ�ܻ�ȡ 
    BYTE    byType;            //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷���,12-��ʱ����,13-��������14-ȼ��������0xff-��
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //������ʱ��0-255��
    WORD    wOutDelay;        //�˳���ʱ��0-255��
    BYTE    byAlarmType;    //����������  0-��Ч 1-���� 1-����
    BYTE    byZoneSignalType;    //�����źŴ������ͣ�0-���߷�����1-���߷���
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //̽�������кţ�ֻ��
    BYTE    byDisableDetectorTypeCfg;    //̽���������Ƿ񲻿��䣬0-���䣬1-������
    BYTE    byTimeOutRange;      // ��ʱʱ�䷶Χ��0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // ̽�����ź�ǿ�ȣ�ֻ������0~100
    WORD   wTimeOut;  //��ʱʱ�䣬��
    BYTE    byTimeOutMethod;    //��ʱ������ʱ��ʽ��0-������ʱ��1-�ָ���ʱ
    BYTE    byAssociateFlashLamp;//  �������� 0-��Ч��1-�������2-���
    BYTE    byStayAwayEnabled;//  ��ʱ�����ڼ���·ʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    bySilentModeEnabled;//  ����ģʽʹ�� 0-��Ч��1-��ʹ�ܣ�2-ʹ��
    BYTE    byRes3[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // ������������������
    BYTE    byRes2[128];    // �����ֽ�
}NET_DVR_SINGLE_ALARMIN_PARAM_V50, *LPNET_DVR_SINGLE_ALARMIN_PARAM_V50;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST
{
    DWORD    dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM    struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST, *LPNET_DVR_ALARMIN_PARAM_LIST;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST_V50
{
    DWORD	dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM_V50	struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE	byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST_V50, *LPNET_DVR_ALARMIN_PARAM_LIST_V50;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             // �ṹ���С
    BYTE    byName[NAME_LEN];   // ����
    WORD    wDelay;             // ����ӳ� ��λs, ��Χ��0~3599s 0 ��ʾһֱ�����
    WORD    wTriggerIndex;        //�������ţ��ò���ֻ�ܻ�ȡ
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //��ʾ���Ÿ���ı�������ͨ�� �������������ͬʱ����һ����������������±�0��ʾ��������1���������� 0-������ 1-����
    BYTE    byModuleType;   //��Ӵ��������ͣ�1-���ش������� 2-4·��������3-8·������ 4-��������������5-32·��������6-1�ž͵ؿ�������7-2�ž͵ؿ�������8-4�ž͵ؿ�����,9-2·��������10-���̣�11-��չ������
    BYTE    byModuleStatus;    //��Ӵ�����״̬ 1-���� 2-����
    WORD    wModuleAddress;    //��Ӵ�������ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE    byModuleChan;    //��Ӵ�����ͨ���ţ���1��ʼ�����ֵ����ģ��������������0xFF��ʾ��Ч
    BYTE    byWorkMode;        //����ģʽ��1-������2-�涯
    BYTE    byAlarmOutMode;    //���ģʽ��1-������ģʽ��2-����ģʽ
    BYTE    byTimeOn;        //��ʱ�� 1~60s
    BYTE    byTimeOff;        //��ʱ�� 1~60s
    BYTE       byRes2[51];             //�����ֽ�
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//��������ͨ�� �����±�0��Ӧ���������1����������
    BYTE byRes[100];//�����ֽ�
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize; 
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڲ���״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ��������ڴ��ڳ���״̬��1-��Ӧ��������ڴ��ڲ���״̬
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڱ���״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ��������ڵ�ǰ�ޱ�����1-��Ӧ��������ڵ�ǰ�б���
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//���������״̬��(���֧��512����������ڲ�ѯ)��0-��Ӧ����������ޱ�����1-��Ӧ����������б���
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // ��·״̬ �����±��ʾ0��Ӧ���������1 0-��ʾ���������û����· 1-��ʾ�����������·
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //��ϵͳ����״̬,0-��Ӧ��ϵͳ���ڳ���״̬��1-��Ӧ��ϵͳ���ڲ���״̬
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڹ���״̬��0-��Ӧ��������ڴ�������״̬��1-��Ӧ��������ڴ��ڹ���״̬
    BYTE   byRes[56];      //  �����ֽ�
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��(���֧��512��������ѯ)��0-��Ӧ�������ڳ���״̬��1-��Ӧ�������ڲ���״̬
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��(���֧��512��������ѯ)��0-��Ӧ������ǰ�ޱ�����1-��Ӧ������ǰ�б���
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //������״̬��(���֧��512����������ѯ)��0-��Ӧ�������ޱ�����1-��Ӧ�������б���
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��·״̬ �����±��ʾ0��Ӧ����1 0-��ʾ����û����· 1-��ʾ������·
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬,0-��Ӧ��ϵͳ���ڳ���״̬��1-��Ӧ��ϵͳ���ڲ���״̬
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��0-��Ӧ������������״̬��1-��Ӧ�������ڹ���״̬
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM]; //������������״̬�� 0-��Ӧ������ǰ�ޱ�����1-��Ӧ������ǰ�б���
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��0-��Ӧ�����ޱ�����1-��Ӧ�����б���
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬��0-��Ч��1-��Ӧ��ϵͳδ���ã�2-��Ӧ��ϵͳ����
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM]; //��ϵͳ����״̬��0-��Ч��1-���������2-��ʱ������3-�ڼҲ���
    BYTE   byRes[448]; //�����ֽ�
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V51
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��(���֧��512��������ѯ)��0xff-��Ч��0-��Ӧ�������ڳ���״̬��1-��Ӧ�������ڲ���״̬��2-��Ӧ�������ڲ�����
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬������״̬����(���֧��512��������ѯ)��0xff-��Ч��0-��Ӧ������ǰ�ޱ�����1-��Ӧ������ǰ�б���
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //������״̬��(���֧��512����������ѯ)��0xff-��Ч��0-��Ӧ�������ޱ�����1-��Ӧ�������б�����2-δ������3-���ߣ�4-�����쳣
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM]; //������·״̬�������±��ʾ0��Ӧ����1��0xff-��Ч��0-��ʾ����û����· 1-��ʾ������·
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬��0xff-��Ч��0-��Ӧ��ϵͳ���ڳ���״̬��1-��Ӧ��ϵͳ���ڲ���״̬��2-��Ӧ��ϵͳ���ڲ�����
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��0xff-��Ч��0-��Ӧ������������״̬��1-��Ӧ�������ڹ���״̬
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM]; //������������״̬������״̬���� 0xff-��Ч��0-��Ӧ������ǰ�ޱ�����1-��Ӧ������ǰ�б���
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��0xff-��Ч��0-��Ӧ�����ޱ�����1-��Ӧ�����б���
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ����״̬��0-��Ч��1-��Ӧ��ϵͳδ���ã�2-��Ӧ��ϵͳ����
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM]; //��ϵͳ�������ͣ�0-��Ч��1-���������2-��ʱ������3-�ڼҲ���
    BYTE   bySubSystemAlarm[MAX_ALARMHOST_SUBSYSTEM]; //��ϵͳ����״̬��0-��Ч��1-������2-����
    BYTE   byAlarmOutCharge[MAX_ALARMHOST_ALARMOUT_NUM]; //����������״̬��(���֧��512����������ѯ)��0-��Ч��1-������2-������
    BYTE   byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //����������״̬��(���֧��512����������ѯ)��0-��Ч��1-����2-�޷���
    BYTE   byAlarmInShieldedStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������״̬��0-��Ч��1-���Σ�2-������
    BYTE   byAlarmOutLinkage[MAX_ALARMHOST_ALARMOUT_NUM]; //�����������¼����ͣ�(���֧��512����������ѯ)��0-��Ч��1-������2-������3-������4-�ֶ�����
    BYTE   byRes[512]; //�����ֽ�
}NET_DVR_ALARMHOST_MAIN_STATUS_V51, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V51;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    // �������״̬ 0-���Ŵ����ޱ���״̬��1-���Ŵ����б���״̬
    BYTE   byRes[92];             // �����ֽ�
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V50
{
    DWORD  dwSize;
    //����DS-PEAϵ��һ��ʽ����������Ʒ�������±�0��Ӧ����״̬�������±�1��Ӧ����״̬,�����±�2��ʼ��Ӧ�������״̬
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM]; //�������״̬��0xff-��Ч��0-���Ŵ����ޱ���״̬��1-���Ŵ����б���״̬��2-δ������3-���ߣ�4-�����쳣
    BYTE   byDetetorPower[MAX_DETECTOR_NUM]; //̽��������״̬��0xff-��Ч������ֵΪ0-100��Ĭ�ϵ���С��20ΪǷѹ״̬
    BYTE   byDetetorConnection[MAX_DETECTOR_NUM]; //̽��������״̬��0xff-��Ч��0-��ʾδע�ᣬ1-��ʾ�����ߣ� 2-��ʾ���ߣ�3-�����쳣
    BYTE   bySirenPower[ALARMHOST_MAX_SIREN_NUM]; //���ŵ���״̬��0-��Ч��1-������2-Ƿѹ
    BYTE   bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM]; //���ŷ���״̬��0-��Ч��1-����2-�޷���
    BYTE   byPowerStausEnabled[MAX_DETECTOR_NUM / 8]; //̽��������״̬�Ƿ���Ч����λ��ʾ��0-��Ч��1-��Ч
    BYTE   byDetetorPowerStatus[MAX_DETECTOR_NUM / 8]; //̽��������״̬����λ��ʾ��0-������1-������
    BYTE   byDetetorPowerType; //̽���������ı�ʾ���ͣ�0-���յ���ֵ��ʾ��ʹ��byDetetorPower �ֶΣ�1-���յ���״̬��ʾ��ʹ��byPowerStausEnabled��byDetetorPowerStatus�ֶ�
    BYTE   byRes[975]; //�����ֽ�
}NET_DVR_ALARMHOST_OTHER_STATUS_V50, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V50;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V51
{
    DWORD   dwSize;
    //����DS-PEAϵ��һ��ʽ����������Ʒ�������±�0��Ӧ����״̬�������±�1��Ӧ����״̬,�����±�2��ʼ��Ӧ�������״̬
    BYTE    bySirenStatus[ALARMHOST_MAX_SIREN_NUM]; //�������״̬��0xff-��Ч��0-���Ŵ����ޱ���״̬��1-���Ŵ����б���״̬��2-δ������3-����
    BYTE    byDetetorPower[MAX_DETECTOR_NUM_V51]; //̽����������0xff-��Ч������ֵΪ0-100��Ĭ�ϵ���С��20ΪǷѹ״̬��byDetetorPowerTypeΪ0ʱ��Ч
    BYTE    byDetetorConnection[MAX_DETECTOR_NUM_V51]; //̽��������״̬��0xff-��Ч��0-��ʾδע�ᣬ1-��ʾ�����ߣ� 2-��ʾ����
    BYTE    bySirenPower[ALARMHOST_MAX_SIREN_NUM]; //���ŵ���״̬��0-��Ч��1-������2-Ƿѹ
    BYTE    bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM]; //���ŷ���״̬��0-��Ч��1-����2-�޷���
    BYTE    byPowerStausEnabled[MAX_DETECTOR_NUM_V51 / 8]; //̽��������״̬�Ƿ���Ч����λ��ʾ��0-��Ч��1-��Ч
    BYTE    byDetetorPowerStatus[MAX_DETECTOR_NUM_V51 / 8]; //̽��������״̬����λ��ʾ��0-������1-������
    BYTE    byDetetorPowerType; //̽���������ı�ʾ���ͣ�0-���յ���ֵ��ʾ��ʹ��byDetetorPower �ֶΣ�1-���յ���״̬��ʾ��ʹ��byPowerStausEnabled��byDetetorPowerStatus�ֶ�
    BYTE    byRes2[3];
    BYTE    byRepeaterStatus[MAX_REPEATER_NUM];    //�м���״̬��0-��Ч��1-���ߣ�2-���ߣ�3-δ����
    BYTE    byRepeaterTamperStatus[MAX_REPEATER_NUM / 8];    //�м�������״̬����λ��ʾ��0-��Ӧ�м����ޱ�����1-��Ӧ�м����б���
    BYTE    byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM / 8];    //����������̵���������״̬����λ��ʾ��0-��Ӧ��������ޱ�����1-��Ӧ��������б���
    BYTE    byOutputModuleTamperStatus[MAX_OUTPUT_MODULE_NUM / 8];    //���ģ�����״̬����λ��ʾ��0-��Ӧ���ģ���ޱ�����1-��Ӧ���ģ���б���
    BYTE    byElectricLockStatus[MAX_ELECTRIC_LOCK_NUM]; //����״̬ 0-�رգ�1 �C�򿪣�Ϊȷ�������ԣ���һ��������״̬��bySirenStatus��0λҲ��Ҫ��д
    BYTE    byRes[274]; //�����ֽ�
}NET_DVR_ALARMHOST_OTHER_STATUS_V51, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V51;


//ʹ��״̬����
typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//�������ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//����ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//�ƶ���ʹ�ܣ�0-���ܣ�1-ʹ��
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//����ʹ�ܣ� 0-���ܣ�1-ʹ��
    BYTE  bySerialPurpose;//������;��0-���ڼ�������������1-����PTZ����
    BYTE  byRes[63];    
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;                      // �ṹ���С
    WORD    wTotalAlarmInNum;         // �������������(����),��������
    WORD    wLocalAlarmInNum;         // ���ر��������
    WORD    wExpandAlarmInNum;        // ����չ�ı��������
    WORD    wTotalAlarmOutNum;        // ������������� ���豸֧�ֵ�������
    WORD    wLocalAlarmOutNum;        // ���ر�������ڸ���
    WORD    wExpandAlarmOutNum;       // ����չ�ı��������
    WORD    wTotalRs485Num;           // ������������� ���豸֧�ֵ�������
    WORD    wLocalRs485Num;           // ����485����
    WORD    wExpandRs485Num;          // ����չ��485����
    WORD    wFullDuplexRs485Num;    // ȫ˫����485����
    WORD    wTotalSensorNum;          // ģ���������� (�豸֧�ֵ�����)
    WORD    wLocalSensorNum;        // ����ģ��������
    WORD    wExpandSensorNum;         // ����չ��ģ��������
    WORD    wAudioOutNum;                //�����������
    WORD    wGatewayNum;            //�Ž�����
    WORD    wElectroLockNum;            //��������
    WORD    wSirenNum;                 // ����������Ŀ
    WORD    wSubSystemNum;            // �ɻ�����ϵͳ��Ŀ
    WORD    wNetUserNum;            // �����û���
    WORD    wKeyboardNum;           // ������
    WORD    wOperatorUserNum;           // �����û���
    BYTE    bySupportDetector;//�Ƿ�֧�ֳ���������̽������1-֧�֣�0-��֧��
    BYTE    bySupportSensitivity;//�Ƿ�֧�ַ��������ȣ�1-֧�֣�0-��֧��
    BYTE    bySupportArrayBypass;//�Ƿ�֧������·��1-֧�֣�0-��֧��
    BYTE    bySupportAlarmInDelay;//�Ƿ�֧�ַ����ӳ�,1-֧�֣�0-��֧��
    //���bySupportAlarmInDelayΪ1ʱ����ʾ�ͻ���Ӧ��ʹ��NET_DVR_ALARMIN_PARAM �е�dwParam��������ʱʱ�䣬�������������������б�������ʹ������������ʱ��ʽ;
    //���bySupportAlarmInDelayΪ0ʱ����ʾͨ��NET_DVR_ALARMSUBSYSTEMPARAM �е�wEnterDelay ��wExitDelay ������
    BYTE    bySupportAlarmInType[16];//֧�ֵķ�������,����0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ�������� 8-24Сʱ����������9-24Сʱ�𶯷���,10-�Ž��������ŷ�����11-�Ž��������ŷ���15-��
    BYTE    byTelNum;        //֧�ֵ绰����
    BYTE    byCenterGroupNum;    //���������
    BYTE    byGPRSNum;        //GPRS�����������4��
    BYTE    byNetNum;        //���������������4��
    BYTE    byAudioNum;        //��Ƶ����
    BYTE    by3GNum;        //3Gģ�����
    BYTE    byAnalogVideoChanNum;        //ģ����Ƶͨ������
    BYTE    byDigitalVideoChanNum;        //������Ƶͨ������
    BYTE    bySubSystemArmType;        //��ϵͳ�������ͣ�0-��ʾ��֧�֣�1-��ʾ֧�֡�bit0-��ͨ������ע������С����ֻ֧����ͨ���������������м�����ֶε�ʱ������С�����Ѿ���������������С�����и��ֶ�Ϊ0��������0��ʾ֧�֣�1��ʾ��֧�֡�����ӿ���SDK�ڲ��������ݣ���bit1-��ʱ������bit2-���ز�����    
    BYTE    byPublicSubSystemNum;    //������ϵͳ����
    DWORD    dwSupport1;    //��λ��ʾ�������0��ʾ֧�֣�0��ʾ��֧��
    // bit0:     �Ƿ�֧����ϵͳ�����þ������ʱ�䣬���֧���򾯺����ʱ����ÿ����ϵͳ�����ã������֧�֣�����ʱ���ھ��Ų���������������
    // bit1:    �Ƿ�֧���¼����������������
    // bit2:    �Ƿ�֧���¼�������������ر�
    // bit3:    �Ƿ�֧����ϵͳʹ��
    // bit4;    �Ƿ�֧�ַ�������
    // bit5;    �Ƿ�֧����ϵͳ�Զ�������
    // bit6:    �Ƿ�֧�־�����Ϲ����������
    // bit7:    �Ƿ�֧�ֹ���״̬��ѯ
    // bit8:    �Ƿ�֧����ϵͳ��չ����
    // bit9:    �Ƿ�֧��Կ�׷���������ϵͳ
    // bit10:   �Ƿ�֧��"������ʾ�ɹ����ͱ���"����
    // bit11:   �Ƿ�֧�ֵ��뵼����������
    // bit12:   �Ƿ�֧��LED��Ļ��������
    // bit13: �Ƿ�֧�ֹ��Ϲ������ع��ϵ����
    DWORD    dwSubSystemEvent;        //��ϵͳ�¼�����λ��ʾ��0��ʾ��֧�֣���0��ʾ֧��,bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������������
    DWORD    dwOverallEvent;            //ȫ���¼�����λ��ʾ��0��ʾ��֧�֣���0��ʾ֧�֣�bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣��bit5-Ӳ�̹���,bit6-3G/4G�ź��쳣, bit7-��ģ�����ӣ���������������,bit8-WIFIͨ�Ź��ϣ�bit9-RF�źŸ��Ź���
    DWORD    dwFaultType;            //�豸֧�ֵĹ������ͣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-�����̵��ߣ�bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣    
    BYTE    byPublicSubsystemAssociateSubsystemNum;    //������ϵͳ�ɹ�������ϵͳ����
    BYTE    byOverallKeyboard;    //ȫ�ּ��̸���
    WORD    wSafetyCabinSupport; //�����տ�������������λ��ʾ�������0��ʾ֧�֣�0��ʾ��֧��    
    //bit0: �Ƿ�֧�ַ����տ���������ģʽ����
    //bit1: �Ƿ�֧�����źŴ�������������
    //bit2: �Ƿ�֧��Ļ���������������ã�̽���ӳ�ʱ�䡢��״̬�仯��Ӧʱ�䣩
    //bit3: �Ƿ�֧�ֺ�����䴫�����������ã��˲���
    //bit4: �Ƿ�֧�ַ�����ʹ�ó�ʱʱ������
    BYTE    by485SlotNum;        //485�����λ��
    BYTE    bySubSystemAttributeAbility;  // ֵ��Ϊ1����ֹ1����ϵͳ�ر�ʹ��
    WORD    wKeyboardAddrNum;      // ���̵�ַ��
    BYTE     byAlarmLampNum;         //������Ŀ
    BYTE    byRes[117];            //  �����ֽ�
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

#define MAX_485CHAN                256    //485ͨ����
#define MAX_485SLOT                256    //485��λ��
typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-����ȫ����ȡ��1-ȫ����ȡ
    BYTE        byres[3];
    BYTE        byIndex[MAX_485SLOT];            //485��λ��
    BYTE           byRes[64];      //����
}NET_DVR_485_SLOT_LIST_INFO,* LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-����ȫ����ȡ��1-ȫ����ȡ
    BYTE        byres[3];
    BYTE        byIndex[MAX_485CHAN];            //485ͨ���� �±��ʾͨ���ţ�ֵ0-��ʾ��ʹ�ã�1��ʾʹ��
    BYTE       byRes[64];      //����
}NET_DVR_485LIST_INFO,*LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    sDeviceName[NAME_LEN];  // ǰ���豸���� 
    WORD    wDeviceType;            // ǰ���豸����,ͨ��NET_DVR_GetDeviceTypeList��ȡ
    WORD    wDeviceProtocol;        // ǰ���豸Э�� ͨ����ȡЭ���б��ȡ    
    DWORD   dwBaudRate;             //������(bps)��0-50��1-75��2-110��3-150��4-300��5-600��6-1200��7-2400��8-4800��9-9600��10-19200��11-38400��12-57600��13-76800��14-115.2k 
    BYTE    byDataBit;              // �����м�λ��0-5λ��1-6λ��2-7λ��3-8λ 
    BYTE    byStopBit;              // ֹͣλ��0-1λ��1-2λ 
    BYTE    byParity;               //�Ƿ�У�飺0-��У�飬1-��У�飬2-żУ�� 
    BYTE    byFlowcontrol;           // �Ƿ����أ�0-�ޣ�1-������,2-Ӳ���� 
    BYTE    byDuplex;                // 0 - ��˫��1- ȫ˫��  ֻ��ͨ��1������ȫ˫��������ֻ���ǰ�˫��
    BYTE    byWorkMode;                // ����ģʽ 0-����̨ 1-͸��ͨ��,2-�ݿأ�3-������,4-�Ž���ȫģ��,0xfe-�Զ��壬0xff-����
    BYTE    byChannel;                //485ͨ����
    BYTE    bySerialType;            //��������: 0--485, 1--232
    BYTE    byMode;                 //ģʽ 0-���Ӷ����� 1-���ӿͻ��� 2-������չģ�� 3-�����Ž����� 4-�����ݿ�����  0xff-����
    BYTE    byOutputDataType;  //0-��Ч��1-������ţ�2-�������
    BYTE    byAddress;               //���ڵ�ַ
    BYTE    byRes[33];              // �����ֽ�
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

#define MAX_DEVICE_PROTO_NUM       256
#define MAX_DEVICE_TYPE_NUM            256

// 485ǰ���豸֧��Э���б�
typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             // �ṹ���С
    DWORD   dwProtoNum;         // Э�����
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  // Э������
    BYTE    byRes[12];          // �����ֽ�
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD    dwType;
    BYTE    byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD    dwSize;                // �ṹ���С
    DWORD    dwTypeNum;            // ���͸���
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE    byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

#define    MAX_ALARMHOST_VIDEO_CHAN    64
typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                 // �ṹ���С
    BYTE   sUserName[NAME_LEN];    // �û���
    BYTE   sPassword[PASSWD_LEN];    // ����
    NET_DVR_IPADDR    struUserIP;                    /* �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ) */
    BYTE   byMACAddr[MACADDR_LEN];            /* �����ַ */
    BYTE   byUserType; // 0-��ͨ�û� 1-����Ա�û�
    BYTE   byAlarmOnRight;         // ����Ȩ��
    BYTE   byAlarmOffRight;        // ����Ȩ��
    BYTE   byBypassRight;          // ��·Ȩ��
    BYTE   byOtherRight[MAX_RIGHT];  // ����Ȩ��
    // 0 -- ��־Ȩ��
    // 1 -- �����ػ�
    // 2 -- ��������Ȩ��
    // 3 --    ������ȡȨ��
    // 4 -- �ָ�Ĭ�ϲ���Ȩ��
    // 5 -- �������Ȩ��
    // 6 -- PTZ ����Ȩ��
    // 7 -- Զ������Ȩ��
    // 8 -- Զ��Ԥ��
    // 9 -- Զ���ֶ�¼��
    // 10 -- Զ�̻ط�
    BYTE    byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // Զ�̿���Ԥ����ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // Զ�̿���¼���ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN/8]; // Զ�̿��Իطŵ�ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    BYTE    byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN/8];        // Զ�̿���PTZ��ͨ������λ��ʾ��ͨ����bit0-channel 1����1-��Ȩ�ޣ�0-��Ȩ��
    //BYTE    byPriority;                                        // ���ȼ���0xff-�ޣ�0--�ͣ�1--�У�2--��
    //�ޣ���ʾ��֧�����ȼ������ã�
    //�ͣ�Ĭ��Ȩ�ޣ�����Զ�̻طţ�Զ�̲鿴��־��״̬��Զ�̹ػ�/������
    //�У�����Զ�̿�����̨��Զ���ֶ�¼��Զ�̻طţ������Խ���Զ��Ԥ�������ر��ݣ�����/Զ�̹ػ�/������
    //�ߣ�����Ա��
    BYTE        sOriginalPassword[PASSWD_LEN];        // ԭʼ����
    BYTE        byRes2[152];                  // �����ֽ�
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;

typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD     dwSize;     // �ṹ���С
    DWORD    dwID;        // �����û�ID
    BYTE    byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //����Ȩ��  �������±��ʾ ���֧��512������ 0 - ��Ȩ�� 1- ��Ȩ��
    BYTE    byRes[560];        // �����ֽ�
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;

typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD     dwSize;        // �ṹ���С
    BYTE    sUserName[NAME_LEN];    // �û���
    BYTE    sPassword[PASSWD_LEN];  // ����
                                    BYTE   bySubSystemPermission;/*0-��װԱȨ�� ����ԱȨ�ޣ�������ϵͳ�����£� 1-���������޲������棬������· 2-���������޳������棬������· 3-���������޲��������棬������· 
                                                                 4-���������в�//�����棬������· 5-���������г������棬������· 6-���������в��������棬������·  7-���������޲��������棬������· 
                                                                 8-���������޲��������棬������· 9-���������޲��������棬������· 10-���������в������棬������· 11-���������г������棬������· 1
                                    2-���������в��������棬������·*/
                                    BYTE    byRes[63];             //  �����ֽ�
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD    dwSize;        // �ṹ���С
    BYTE    byName[NAME_LEN];    //  �Ž�����    
    BYTE    byEnable;    // �Ƿ�����
    BYTE    byLocalEnable;  //  �����Ƿ�����
    WORD    wDelayTime;    // ������ʱʱ��    ��λΪ��0-65535 0Ϊһֱ����
    BYTE    byLockWorkMode;//��������ģʽ��0-ͨ��������1-�ϵ�����
    BYTE    byRes[31];    // �����ֽ�
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD   dwSize;                // �ṹ���С
    DWORD   dwAbsTime;            // ����ʱ����Ϣ  OSD��ʾ��Ϣ
    BYTE    byName[NAME_LEN];     // sensor ����
    BYTE    bySensorChannel;    // ģ����ͨ��
    BYTE    byType;             // ģ��������
    BYTE    byAlarmType;        // 1-��4��2-��3��3-��2��4-��1��5-��1��6-��2��7-��3��8-��4 �͵�ǰģʽ�й�
    // ���統Ϊ1000ʱ,����1��1��2��3�������ֱ���
    BYTE    byAlarmMode;        //����ģʽ�����֣�-HHHH��-HHHL��-HHLL��HLLL��-LLLL�� ��Ϊƽ̨�����̶��жϹ���,����1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������) 
    float    fValue;                // ��ǰģ������ֵ
    float   fOriginalValue; //ԭʼ������ѹֵ������С�������λ������ֵ��ʾ�������ǵ�ѹ����NET_DVR_SENSOR_INFO��bySensorStandard����
    BYTE    byRes2[28];		    // �����ֽ�
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;

#define PROTOCOL_VERTION_LEN    32

typedef struct tagNET_DVR_RS485_PROTOCOL_VERSION
{
    DWORD  dwSize;
    BYTE   byProtocleVersion[PROTOCOL_VERTION_LEN];//RS485Э���汾��Ϣ
    BYTE   byRes[128];
}NET_DVR_RS485_PROTOCOL_VERSION, *LPNET_DVR_RS485_PROTOCOL_VESRION;


typedef struct 
{
    /*Ԥ����Ŀǰ���������ı���û������(���������򣬼���������)*/
    DWORD  dwAlarmType;             
    /*����0��Ӧ��1������˿�*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE    byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO,*LPNET_DVR_ALARMHOST_ALARMINFO;
// �����������ϴ�
typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN];     // switch ����
    WORD  wSwitchChannel;     // ������ͨ��, 0-255
    BYTE    byAlarmType;        // �������� 0--������1--��·��2--��·,3-�쳣 
    BYTE     byRes[41];            // �����ֽ�
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;

typedef union tagNET_DVR_ALARMHOST_EXCEPTION_PARAM
{
    DWORD   dwUnionSize[20];        // �������С    
}NET_DVR_ALARMHOST_EXCEPTION_PARAM, *LPNET_DVR_ALARMHOST_EXCEPTION_PARAM;

typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // �ṹ���С
    // �쳣����  1-�豸���𱨾� 2-�豸������ָ����� 3-����Դ���籨�� 4-����Դ�����ָ����� 5-�ڲ�ͨ�Ź��ϱ��� 
    // 6-�ڲ�ͨ�Ź��Ϻ�ָ�����  7-�绰�߶��� 8-�绰�߶��߻ָ� 9-�Լ�ʧ�ܱ���  10-�Լ�ʧ�ܺ�ָ�����    
    // 11����Ƿѹ  12���ص�ѹ�ָ�������13-���ع��ϣ�14-MBUSģ����ߣ�15-MBUSģ����߻ָ���16-���̵��ߣ�
    //17-���̵��߻ָ���18-�豸���ƶ���19-�豸���ƶ���λ  20-485������·�ϱ���  21-485������·�Ϻ�ָ�����
    //25-�Ӱ�1����,26-�Ӱ�1�γ�, 27-�Ӱ�2����,28-�Ӱ�2�γ�
    DWORD   dwExceptionType;    
    BYTE   byRes[36];          // ����
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

//�����в��Ų������ü����÷�ʽ����
#define MAX_CENTERNUM            4        //G1,G2 G3 G4����N1��N2��N3��N4����T1��T2��T3��T4
typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //���ĺ���  
    BYTE byRepeatCall;          //�ظ����Ŵ�����1~15��
    BYTE byPstnProtocol;        //ͨ��Э�飬0-CID��
    BYTE byDialDelay;           //������ʱ�����150s, 0-150
    BYTE byPstnTransMode;       //���䷽ʽ��0-DTMF 5/S��1-DTMF 10/S��
    BYTE byEnable;       //ʹ�ܣ�0-�رգ�1-����
    BYTE byRes1[5];
    BYTE byReceiverId[6];         //���ջ�ʶ���˺ţ�
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//�����Ĳ���
    WORD wReportPeriod;      //���Ա����ϴ����ڣ�Сʱ�������ֵ֧��7�죬��168Сʱ), ��Χ��1-168
    WORD wFirstReportTime;     //���豸��������һ�����Ա����ϴ���1~3600����
    BYTE  byReportValid;    //0-�����ò��Ա����ϴ� 1-���ò��Ա����ϴ�
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//���÷�ʽ��0�������ã�1��һֱ���ã�2:���߶����ã�����ʱ�رգ�
    BYTE byCallType; //�ϴ����ķ�ʽ��1-�����ģ�2-˫���ģ�3��һ��һ��
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

#define  MAX_PU_CHAN_NUM    512

typedef struct tagNET_DVR_PU_CHAN_INFO
{
    NET_DVR_IPADDR  struIpAddr;     // ip��ַ
    WORD            wPort;          // �˿�
    WORD            wChannel;       // ͨ��     
    BYTE            byRes[24];      // 
}NET_DVR_PU_CHAN_INFO, *LPNET_DVR_PU_CHAN_INFO;

typedef struct tagNET_DVR_PU_CHAN_LIST
{
    DWORD   dwSize;     // �ṹ��
    DWORD   dwNum;      // ǰ��ͨ������
    NET_DVR_PU_CHAN_INFO struPuChanInfo[MAX_PU_CHAN_NUM];
}NET_DVR_PU_CHAN_LIST, *LPNET_DVR_PU_CHAN_LIST;

#define  MAX_ALARM_CAM_NUM    32        // ��������CAM������

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   // �Ƿ�����PTZ����
    BYTE    byType;     // PTZ ���Ƶ����� 1- Ԥ�õ� 2 -Ѳ��  3-�켣
    BYTE    byPtzNo;    //  ptz ���Ƶ�Ԥ�õ� Ѳ�� �켣��
    BYTE    byRes[5];    // �����ֽ�
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD            dwCamID;      // ������CAMͨ������
    DWORD           dwRecordTime;   // ����¼��ʱ�� ��λΪs  -1��ʾһֱ¼�� 0 ��ʾ��¼��
    DWORD           dwMonID;      // ����Cam��Mon����ʾ
    DWORD           dwResidentTime; // ��Ѳͣ��ʱ�䵥λΪs  -1��ʾһֱͣ�� 0 ��ʾ��ͣ��
    NET_DVR_PTZ_CTRL struPtzCtrl;    // PTZ������Ϣ
    BYTE            byAlarmOffMode;        // �����л���ǽȡ��ģʽ   0-����ȡ����1-�Զ�ȡ����2-�ֶ�ȡ�� ����ȡ��������ȡ��ʱ����ȡ��������ǽ   �Զ�ȡ��������ȡ��ʱ�ȴ�һ��ʱ���ȡ��������ǽ������Լ����20��  �ֶ�ȡ�����û�ͨ���ֶ��ķ�ʽȡ��
    BYTE            byDevType;        // ���豸Ϊ�����豸ʱ����Ч��ʾ���ܱ����豸ȡ��Դ 1-���뿨     2-���뿨
    BYTE            byDecChan;        // ��Ϊ����ͨ��Ϊ����ͨ����
    BYTE            byRes[17];      // �����ֽ�
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD        dwSize;            // �ṹ���С
    BYTE        byEnable;       // �Ƿ����ñ�������CAM���� �豸Ĭ�ϲ�����
    BYTE        byRes[7];       // �����ֽ�
    DWORD        dwNum;            // ����CAM�����ĸ��� ��ȡ�����ǰ������Ч����  
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

#define MAX_GATEWAY_NUM         8  // ����Ž�����
typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD         dwSize;
    BYTE        byEnterDoor[8];    // �±��ʾ�Ž��ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE        byExitDoor[8];     // �±��ʾ�Ž��ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE         byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  //�����������룬�±��ʾ��������ţ�Ԫ����ֵ��ʾ������Ϣ��0��ʾ�������� 1-8��ʾ��������Ƶ��
    BYTE         byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

//�����ϴ����أ������ϴ����ص���չ��
typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byUploadType;    /*�ϴ���ʽ��1-�����ļ������Ե�ַ��ȡ�����ļ��ϴ��� 2-�ӻ�������ȡ�����ϴ�*/
    BYTE        byDataType;        //�������ͣ�1-��Ƶ����
    BYTE        byDataNum;        //���ݱ�ţ��磺�ϴ���������ò�����ʾ�����ţ��������������ţ��ε������ˡ������ڵ���
    BYTE        byAudioType;        //������ʽ��0-wave
    char        sFileName[260];        //�����ļ���ȫ·��
    char        *lpBuffer;            //���ݻ�����
    DWORD        dwBufferSize;        //��������С
    BYTE        byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef void (CALLBACK *DATADOWNLOAD)(LONG nDownloadHandle, DWORD dwDataType, void* pBuffer, DWORD dwBufSize, void *pUser);
typedef struct tagNET_DVR_ALARMHOST_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*���ص����ݱ��淽ʽ��1-�����ļ������Ե�ַ�������ݣ� 2-ͨ���ص�������ȡ����*/
    BYTE        byDataType;        //�������ͣ�1-��Ƶ����
    BYTE        byDataNum;        //���ݱ�ţ��磺������������ò�����ʾ�����ţ��������������ţ��ε������ˡ������ڵ���
    BYTE        byRes1;
    char        sFileName[260];        //�����ļ���ȫ·��
    DATADOWNLOAD lpDataCallBack; //����ʱ�Ļص��������
    void*        pUserData;    //�û����ݣ����ڻص������д���
    BYTE        byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;


typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*���ص����ݱ��淽ʽ��1-�����ļ������Ե�ַ�������ݣ� 2-ͨ���ص�������ȡ����*/
    BYTE        byDataType;        //�������ͣ�1-��Ƶ����
    BYTE        byDataNum;        //���ݱ�ţ��磺������������ò�����ʾ�����ţ��������������ţ��ε������ˡ������ڵ���
    BYTE        byRes1;
    char        sFileName[260];        //�����ļ���ȫ·��
    DATADOWNLOAD lpDataCallBack; //����ʱ�Ļص��������
    void*        pUserData;    //�û����ݣ����ڻص������д���
    BYTE        byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;

//LED��Ļ����
typedef  struct tagNET_DVR_LED_SCREEN_CFG
{
    DWORD         dwSize;
    BYTE        sLEDName[NAME_LEN/*32*/];    // LED��Ļ����
    BYTE        byTransMode;                 // ��ֻ֧�ִ���ͨѶ 1-����ͨ��
    BYTE        byProtocolType;                // Э�����ͣ���ӦLED���ĳ���
    BYTE        byLEDColor;                 // 1-��ɫ�� 2-˫ɫ�� 3-256���Ҷ�˫��ɫ�� 4- ȫ��ɫ��Ŀǰֻ�õ�ɫ��
    BYTE        byDataPolarity;                // ���ݼ��� .0-������1-����
    BYTE        byOEPolarity;                // 0-����Ч 1-����Ч
    BYTE        byScanMode;                 // 1-1/16,  2-1/8,  3-1/4,  4-1/2,  5-��̬
    BYTE        byRes1[2];
    //��Ļ��Ⱥ͸߶���С��16*16�㣬�����8����    
    WORD        wLEDWidth;                     // 16~2048
    WORD         wLEDHeight;                    // 16~2048
    BYTE        byRes2[64];
}NET_DVR_LED_SCREEN_CFG, *LPNET_DVR_LED_SCREEN_CFG;

//LED��������
#define  MAX_CONTENT_LEN  512
typedef  struct tagNET_DVR_LED_CONTENT_CFG
{
    DWORD         dwSize;
    BYTE        sLEDContent[MAX_CONTENT_LEN];    // LED��Ļ��ʾ����
    BYTE        byContentAct;                    // 1-��̬��2-���ٴ����3-�����ƶ���4-�����ƶ��� 5-�����ƶ��� 6-�����ƶ�
    BYTE        byContentSpeed;                    // 1-24��1��죬24������    
    BYTE        byContentStayTime;                 // 0-127.5s(����0.5s�� SDK����ʱ��*2����������ֵ0-255���豸����ʹ�õ�ʱ�������2)
    BYTE        byRes[33];
}NET_DVR_LED_CONTENT_CFG, *LPNET_DVR_LED_CONTENT_CFG;

//LED��ʱ���ػ�
#define     LED_TIMER_NUM             3            // LED�������ػ�ʱ������
#define        TIME_SEGMENT_A_DAY        48            // ʱ��θ�����һ��24Сʱ����Сʱһ����

typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE    byValid;                // ���鶨ʱʱ���Ƿ���Ч��ʱ���ǳɶ����õ�
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTimeOn;     // ����ʱ��
    NET_DVR_TIME_EX struTimeOff;     // �ػ�ʱ��
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;


typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD        dwSize;
    NET_DVR_SWITCH_TIME struTimer[LED_TIMER_NUM /*3*/];         //��ʱ���ػ�ʱ�䣬�ṹ����ֻ��Сʱ�ͷ�������������Ч��ÿ�鿪��ʱ��Ҫ���ڸ���Ĺػ�ʱ�䣬����ǰһ��Ĺػ�ʱ��Ҫ�����磺struTimer[0]�Ĺػ�ʱ����10��00��ô��struTimer[0]�Ŀ���ʱ��������Ϊ10:00֮ǰ�� struTimer[1]�Ŀ���ʱ��������Ϊ10��:00�Ժ�
    BYTE        byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

//��ʱ���ȵ���
typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD         dwSize;
    BYTE        byValid;        //��ʱ���ȵ����Ƿ���Ч
    BYTE        byRes1[3];
    BYTE         byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/];     //��ȫ��24��Сʱ��Ϊ48��ʱ�Σ�ÿ30����һ��ʱ�Σ���48���ֽڱ�ʾÿ��ʱ�ε����ȼ������ȹ�16������0~15��ʾ��
    BYTE        byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD    dwSize;
    BYTE    bySwitchState;        //1-����״̬ 2-�ػ�״̬
    BYTE    byBrightness;        //����ֵ����Χ0-15
    BYTE    byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;

//2010-12-28 ������뿨������ begin
//�µĽ��뿨������������
#define        MAX_DECODE_CARD_NUM            6   //��������뿨��
/********************������뿨���ģʽ�궨��********************/
typedef enum _HD_DISPLAY_FORMAT
{
    HD_DISPLAY_FORMAT_INVALID = 0x00000000,
        HD_DISPLAY_FORMAT_CVBS = 0x00000001,
        HD_DISPLAY_FORMAT_DVI = 0x00000002,
        HD_DISPLAY_FORMAT_VGA = 0x00000004, 
        HD_DISPLAY_FORMAT_HDMI = 0x00000008, 
        HD_DISPLAY_FORMAT_YPbPr = 0x00000010
}HD_DISPLAY_FORMAT,*LPHD_DISPLAY_FORMAT;

/********************������뿨���ģʽ�궨��********************/
typedef struct tagNET_DVR_DECCARD_ABILITY      /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //����ͨ����
    BYTE byDispNums;      //��ʾͨ����
    BYTE byDecStartIdx;     //�׸�����ͨ�������н���ͨ���е�����
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byDispResolution[80]; //���ģʽ֧�ֵķֱ���
    BYTE byDispFormat[8];     //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT)
    BYTE byWindowMode[4][8]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes[35];
} NET_DVR_DECCARD_ABILITY,*LPNET_DVR_DECCARD_ABILITY;

typedef struct tagNET_DVR_DECODESVR_ABILITY
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY, *LPNET_DVR_DECODESVR_ABILITY;

typedef struct tagNET_MATRIX_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP��ַ
    WORD     wDVRPort;                 //�˿ں�
    BYTE     byChannel;                //ͨ����
    BYTE    byTransProtocol;        //����Э������0-TCP��1-UDP
    BYTE    byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE    byFactoryType;            /*ǰ���豸��������,ͨ���ӿڻ�ȡ*/
    BYTE    byUsedSlotNum;            //�Ƿ�ʹ�ò�λ�ţ�0-��ʹ�ã�1-ʹ��
    BYTE    bySlotNum;//��λ��
    BYTE    byRes[68];
    BYTE    sUserName[NAME_LEN];    //���������½�ʺ�
    BYTE    sPassword[PASSWD_LEN];    //�����������
}NET_MATRIX_DEV_CHAN_INFO,*LPNET_MATRIX_DEV_CHAN_INFO;

typedef struct tagNET_MATRIX_PU_STREAM_CFG
{
    DWORD                            dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_MATRIX_DEV_CHAN_INFO        struDevChanInfo;
} NET_MATRIX_PU_STREAM_CFG,LPNET_MATRIX_PU_STREAM_CFG;

/*camera���õ�Ԫ�ṹ*/
typedef struct tagNET_DVR_MATRIX_CAMERACFG
{
    DWORD                    dwGlobalIndex;//ȫ�ֱ��
    DWORD                    dwInterIndex;//�ֲ����
    BYTE                    sCamName[NAME_LEN];
    NET_MATRIX_PU_STREAM_CFG struPuStreamCfg;
} NET_DVR_MATRIX_CAMERACFG,*LPNET_DVR_MATRIX_CAMERACFG;

typedef struct tagNET_DVR_MATRIX_CAMERALIST
{
    DWORD            dwSize;
    BYTE            byRes[12];
    DWORD            dwCamNum;//CAM����
    BYTE              *pBuffer;
    DWORD             dwBufLen;//������ָ�볤�ȣ��������
} NET_DVR_MATRIX_CAMERALIST,*LPNET_DVR_MATRIX_CAMERALIST;

typedef struct tagNET_DVR_DISP_CHAN_INFO
{
    NET_DVR_IPADDR    struIP;                /* ������ IP��ַ */
    WORD     wDVRPort;                 /* �˿ں� */
    BYTE     byDispChannel;            /* ��ʾͨ���� */
    BYTE    byUsedSlotNum;            //�Ƿ�ʹ�ò�λ�ţ�0-ʹ�ã�1-��ʹ��
    BYTE    bySlotNum;//��λ��
    BYTE    byRes[7];
    BYTE    sUserName[NAME_LEN];    /*��½�ʺ� */
    BYTE    sPassword[PASSWD_LEN];    /*���� */
}NET_DVR_DISP_CHAN_INFO,*LPNET_DVR_DISP_CHAN_INFO;

/*monitor���õ�Ԫ�ṹ*/
typedef struct tagNET_DVR_MATRIX_MONITORCFG
{
    DWORD                        dwGlobalIndex;//ȫ�ֱ��
    DWORD                        dwInterIndex;
    BYTE                        sMonName[NAME_LEN];
    NET_DVR_DISP_CHAN_INFO        struDispChanCfg;
} NET_DVR_MATRIX_MONITORCFG,*LPNET_DVR_MATRIX_MONITORCFG;

typedef struct tagNET_DVR_MATRIX_MONITORLIST
{
    DWORD        dwSize;
    BYTE        byRes[12];
    DWORD        dwMonNum;//MON����
    BYTE          *pBuffer;
    DWORD         dwBufLen;//������ָ�볤�ȣ��������
} NET_DVR_MATRIX_MONITORLIST,*LPNET_DVR_MATRIX_MONITORLIST;

#define     MAX_SUBMATRIX_NUM        8//������������ϵͳ����
typedef struct tagNET_DVR_SUBMATRIXINFO
{
    BYTE        byMainMatrix;//�Ƿ�����ϵͳ��1-�ǣ�0-��
    BYTE        bySubMatrixSequence;//��������Ƶ�ۺ�ƽ̨ϵͳ���
    BYTE        byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-������
    BYTE        byRes1[9];
    NET_DVR_IPADDR  struSubMatrixIP;        /*IP��ַ�����޸ģ�*/
    WORD        wSubMatrixPort;        /*��ϵͳ�˿ںţ����޸ģ�*/
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubMatrixIPMask;    /*IP��ַ����*/
    NET_DVR_IPADDR    struGatewayIpAddr;         /* ���ص�ַ */    
    BYTE        sUserName[NAME_LEN];    /* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE        sPassword[PASSWD_LEN];    /*���� ���˲���ֻ�ܻ�ȡ��*/
    char        sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS������IP��ַ*/
    BYTE        sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
    BYTE        byRes3[16];
}NET_DVR_SUBMATRIXINFO, *LPNET_DVR_SUBMATRIXINFO;

typedef struct tagNET_DVR_ALLUNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBMATRIXINFO struSubMatrixInfo[MAX_SUBMATRIX_NUM];
    BYTE  byRes2[32];
}NET_DVR_ALLUNITEDMATRIXINFO, *LPNET_DVR_ALLUNITEDMATRIXINFO;

#define    MAX_GATEWAYTRUNKNUM        1024 //������Ƶ�ۺ�ƽ̨�����·�ɸ�����

typedef struct tagNET_DVR_MATRIXGATEWAYNOTE
{
    WORD    wTrunkInToOutAbility;//���ߴ�����D1�ı�׼��������4��ʾ֧��4��D1
    WORD    wTrunkOutToInAbility;//���ߴ�����D1�ı�׼��������4��ʾ֧��4��D1��˫�����ʱ�õ���ֵ
    BYTE    byRes[4];
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;
}NET_DVR_MATRIXGATEWAYNOTE, *LPNET_DVR_MATRIXGATEWAYNOTE;

typedef struct tagNET_DVR_MATRIXGATEWAYINFO
{
    DWORD dwSize;
    NET_DVR_MATRIXGATEWAYNOTE struGatewayNote[MAX_GATEWAYTRUNKNUM];
    BYTE  byRes [32];
}NET_DVR_MATRIXGATEWAYINFO, *LPNET_DVR_MATRIXGATEWAYINFO;

typedef struct tagNET_DVR_MATRIXCODESYSTEMINFO
{
    BYTE   byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE    bySubSystemNum;//��ϵͳ��λ��
    BYTE    byChan;//����ͨ��
    BYTE   byRes [13];
}NET_DVR_MATRIXCODESYSTEMINFO,*LPNET_DVR_MATRIXCODESYSTEMINFO;
typedef struct tagNET_DVR_MATRIXDECODESYSTEMINFO
{
    BYTE    byMatrixNum;//��Ƶ�ۺ�ƽ̨��
    BYTE    bySubSystemNum;//��ϵͳ��λ��
    BYTE    byDispChan;//��ʾͨ��
    BYTE    bySubDispChan;//��ʾͨ����ͨ����
    BYTE    byRes [12];
}NET_DVR_MATRIXDECODESYSTEMINFO,*LPNET_DVR_MATRIXDECODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXSWITCH
{
    NET_DVR_MATRIXCODESYSTEMINFO struInputNote;
    NET_DVR_MATRIXDECODESYSTEMINFO struOutputNote;
    BYTE    byRes[32];
}NET_DVR_MATRIXSWITCH, *LPNET_DVR_MATRIXSWITCH;

typedef enum {
    ENC_CARD = 0,
        DEC_CARD,
        SD_DEC_CARD,
        FPGA_CARD,
        CS_CARD,
        ALERTOR_CARD,
        NAT_0,
        NAT_1,
        VCA_CARD,
        VGA_DEC_CARD,
        VGA_ENC_CARD,
        ERR_CARD,
} DEV_TYPE;

typedef struct tagNET_DVR_MATRIXSWITCHCTRL
{
    DWORD dwCamId;//�����ȫ�ֱ��
    DWORD dwMonId;//������ȫ�ֱ��
    BYTE  bySubWindowNum;//��������Ӧ�Ӵ��ں�
    BYTE   bySwitchType;/*�л����ͣ�0:�����л���1:���������л���2:����ȡ����0xff:��ʾ��MON�����б���ȫ��ȡ��*/
    WORD   wAlarmType;//�����豸���ͣ�1:����������2�������豸
    DWORD  dwResidentTime;/* ��ʾפ��ʱ�䣬0xFFFFFFFF ʱ Ϊ��פ�����������ʾ*/
    BYTE   byVcaDevType;//�������豸������"�����豸"ʱ����DEV_TYPE����
    BYTE   byWallNo;//ǽ��
    BYTE   byRes[18];
}NET_DVR_MATRIXSWITCHCTRL, *LPNET_DVR_MATRIXSWITCHCTRL;

typedef struct tagNET_DVR_MATRIXDATABASE
{
    //�����ļ����ͣ�1-�����ݿ������ļ���2-�������ݿ������ļ���3-ƽ̨���ݿ������ļ���4-���������ļ���0xff���һ��ʧ�ܵ����ݿ����
    DWORD dwDevType; 
    DWORD dwParam; //������������š�����š�ƽ̨�ţ����������ļ�ʱ��ֵ����
    BYTE  byFileType;//�ļ����ͣ�1-sql��䣬2-db��䣬3-���������ļ�
    BYTE  byRes [3];
} NET_DVR_MATRIXDATABASE, *LPNET_DVR_MATRIXDATABASE;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
/*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��
    9-V6��ϵͳ��10-ת����ϵͳ��11-X86��������ϵͳ��12-������������ϵͳ��13-X86���ķ���壬14- X86ҵ�����壬15-�����ƴ����ϵͳ�� 16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��19-��Ƶ��ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE        bySubSystemType;
    //��ϵͳͨ���������������ϵͳ������485�����������˲���ֻ�ܻ�ȡ��
    BYTE        byChan;
    BYTE        byLoginType;//ע�����ͣ�1-ֱ����2-DNS��3-������
    BYTE        bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    BYTE        byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP��ַ�����޸ģ�*/
    NET_DVR_IPADDR   struSubSystemIPMask;//��������
    NET_DVR_IPADDR   struGatewayIpAddr;    /* ���ص�ַ */
    WORD        wSubSystemPort;        //��ϵͳ�˿ںţ����޸ģ�
    BYTE        byRes2[6];
    BYTE        sUserName[NAME_LEN];    /* �û��� ���˲���ֻ�ܻ�ȡ��*/
    BYTE        sPassword[PASSWD_LEN];    /*����(���޸�)*/
    char        sDomainName[MAX_DOMAIN_NAME];//����(���޸�)
    char        sDnsAddress[MAX_DOMAIN_NAME];/*DNS������IP��ַ*/
    BYTE        sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
    BYTE        byBelongBoard;//�����Ӱ�ţ���1��ʼ��0xff��ʾ��Ч
    BYTE        byInterfaceType;//�ӿ����ͣ�0-�����ͣ�1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��10-3GSDI, 11-VGA/DVI����Ӧ��12-HDTVI��13-HDBaseT��14-DP��15-DVIT��16-TVI,17-VSCREEN,18-miniDP,0xff-��Ч
    BYTE        byInterfaceNums;//�ӿڸ�����0xff��ʾ��Ч
    BYTE        byInterfaceStartNum;//�ӿ���ʼ�ţ�0xff��ʾ��Ч
    BYTE        byDeviceName[20];//��ϵͳ����
    BYTE        byAudioChanNums; //��Ƶͨ������
    BYTE        byAudioChanStartNum; //��Ƶͨ����ʼ��
    BYTE        byAudioChanType;//��Ƶͨ�����ͣ�0-��Ч��1-��Ƶ���룬2-��Ƶ���
    BYTE        byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

#define  MAX_SUBSYSTEM_NUM_V40  120
typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_SUBSYSTEM_BASIC_INFO
{
    DWORD       dwSize;
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-Fpga������ϵͳ��9-Fpga��ϵͳ��10-ת����ϵͳ��11-X86��������ϵͳ��12-������������ϵͳ��13-X86���ķ���壬 14- X86ҵ�����壬15-�����ƴ����ϵͳ�� 16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��19-�źŽ�����ϵͳ,0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE        bySubSystemType;
    //��ϵͳͨ���������������ϵͳ������485�����������˲���ֻ�ܻ�ȡ��
    BYTE        bySubSystemNo;//��ϵͳ�ţ��˲���ֻ�ܻ�ȡ
    BYTE        byInterfaceType;//�ӿ����ͣ�0-�����ͣ�1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, 7-RGB, 8-YprPb, 9-VGA/HDMI/DVI����Ӧ��10-3GSDI, 11-VGA/DVI����Ӧ��12-HDTVI��13-HDBaseT��14-DP��15-DVIT��0xff-��Ч
    BYTE        byRes1;
    DWORD       dwChan;
    NET_DVR_IPADDR   struSubSystemIP; /*IP��ַ�����޸ģ�*/
    NET_DVR_IPADDR   struSubSystemIPMask;//��������
    NET_DVR_IPADDR   struGatewayIpAddr; /* ���ص�ַ */
    WORD        wSubSystemPort;        //��ϵͳ�˿ںţ����޸ģ�
    BYTE        byRes2[6];
    BYTE        sSerialNumber[SERIALNO_LEN];//���кţ��˲���ֻ�ܻ�ȡ��
    BYTE        byBelongBoard;//�����Ӱ�ţ���1��ʼ��0xff��ʾ��Ч������byBelongBoardH��Ϊ0ʱ���ֶο���Ϊ0xff
    BYTE        byBelongBoardH; //�����Ӱ�Ÿ�λ
    BYTE        byRes3[2];
    BYTE        byDeviceName[20];//��ϵͳ����
    DWORD       dwStartChanNo;//��ʼͨ����
    BYTE        byDevNo; //�豸��
    BYTE        byRes4[63];
}NET_DVR_SUBSYSTEM_BASIC_INFO, *LPNET_DVR_SUBSYSTEM_BASIC_INFO;

typedef struct NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE
{
    DWORD dwSize;
    DWORD dwErrorCode; //����
    BYTE   byDevNo; //�豸��
    BYTE    bySubSystemNo;//��ϵͳ��
    BYTE   byRes[30];
} NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE,*LPNET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE;

typedef struct NET_DVR_CAMERA_INFO_RESPONSE
{
    DWORD dwErrorCode; //����
    DWORD dwCamId; /*cam ��ͳһ���*/
    BYTE   byRes[4];
} NET_DVR_CAMERA_INFO_RESPONSE,*LPNET_DVR_CAMERA_INFO_RESPONSE;

typedef struct NET_DVR_MONITOR_INFO_RESPONSE
{
    DWORD dwErrorCode; //����
    DWORD dwMonId; /*mon ��ͳһ���*/
    BYTE   byRes[4];
} NET_DVR_MONITOR_INFO_RESPONSE, *LPNET_DVR_MONITOR_INFO_RESPONSE;

typedef struct tagNET_DVR_AUDIO_INFO
{
    DWORD    dwSize;
    BYTE    byAudioChanType;//��Ƶͨ�����ͣ�1-��Ƶ���룬2-��Ƶ���
    BYTE       byRes1[3];
    DWORD    dwAudioNo; //��Ƶ��(1�ֽ��豸��+1�ֽ��Ӱ��+2�ֽ���Ƶ�ں�)
    BYTE      byRes2[16];
}NET_DVR_AUDIO_INFO, *LPNET_DVR_AUDIO_INFO;


typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V40
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE   bySubSystemType; 
    BYTE   byConnectStatus;//����ϵͳ����״̬��1-����������2-���ӶϿ�
    BYTE   byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE   bySubSystemNum;//������ϵͳ��λ�ţ�0~79����ϵͳ������3��4ʱ����
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE   byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE   bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    //��ϵͳ����Ϊ1��ʱ���ã�0-δ������1-D1��2-720��3-1080
    BYTE   byDecodeAbility; 
    BYTE   byUsedTrunk;
    BYTE   byRes[64];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V40,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V40
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V40 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V40, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

#define  MAX_OPTICALFIBER_NUM  16
typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
/*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��
    10-ת����ϵͳ��11-X86��������ϵͳ���壬 14- X86ҵ�����壬15-�����ƴ����ϵͳ�� 16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��0-NULL���˲���0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE  bySubSystemType;
    BYTE  byChanNum;//��ϵͳͨ����
    BYTE  byStartChan;//��ϵͳ��ʼͨ����
    BYTE  bySlotNum ;//��λ�� 
    BYTE  byRes1[4];
    union
    {
        BYTE byRes[200];        
        struct
        {
            BYTE byDecode;        //�Ƿ��Ǵ����빦�ܵ����ܰ�,1-�ǣ�0-��
            BYTE byNeedPreAllocDec; //�Ƿ���ҪԤ���������Դ��1-�ǣ�0-��
            BYTE byVACType;  //������ϵͳ���ͣ�0-��ͨ�ͣ�1-��ǿ��
            BYTE byRes[197];
        }struVACSystemAbility;
        struct
        {
            BYTE  byVGANums;//VGA��ʾͨ����������1��ʼ��
            BYTE  byBNCNums;//BNC��ʾͨ����������9��ʼ��
            BYTE  byHDMINums;//HDMI��ʾͨ����������25��ʼ��
            BYTE  byDVINums;//DVI��ʾͨ����������29��ʼ��
            BYTE  byLayerNums ;//����ƴ���У�������ʱ��֧��ͼ����
            BYTE  bySpartan;//���Թ��ܣ�0-��֧�֣�1-֧��
            BYTE  byDecType; //������ϵͳ���ͣ�0-��ͨ��,1-��ǿ��(��ͨ�ͷ���ʱǰ4������ʹ��������Դ����ǿ���޴����ƣ���ǿ�����ɱ�������ϵͳ��16·D1������Դ
            //��ǿ�ͱ���������Ϊ��������Դ�ɱ����ã���ͨ�����ܱ�����)
            //2-���ܹ���������ϵͳ��3-ת�����������ϵͳ�����ܺ�ת�������ϵͳ�������ڽ�����ǽ��
            BYTE  byOutputSwitch;//�Ƿ�֧��HDMI/DVI�����л���0-��֧�֣�1-֧��
            BYTE  bySDINums;//SDI��ʾͨ����������33��ʼ��
            BYTE  byRes1[38];               
            BYTE  byDecoderType ; //������Ƿ�֧�ֶ೧���������룬0-��֧�֣�1-֧��
            BYTE  byRes2[152];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byCoderType;//���������ͣ�0-���壬1-����, 2-ģ�����
            BYTE  byOptical;//��˻����룬0-��1-��
            BYTE  byOpticalSubChan; //ÿ������ŵ���            
            BYTE  bySupportAVSeparate;//�Ƿ�֧������Ƶ���룬0-��֧�֣�1-֧��
            BYTE  byRes[196];
        }struCoderSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//���ߴ�����D1�ı�׼��������4��ʾ֧��4��D1
            BYTE    byOpticalFiberNum;//��������
            BYTE    byRes[197];
        }struInputSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//���ߴ�����D1�ı�׼��������4��ʾ֧��4��D1
            BYTE    byOpticalFiberNum;//��������
            BYTE    byRes[197];
        }struOutputSystemAbility;
        struct
        {
            BYTE    by485Num;//�����ϵͳ��485����
            BYTE    bySlotNum;//ÿ��485��λ��
            BYTE    byRes[198];
        }struCodeSpitterSystemAbility;
        struct
        {
            WORD    wAlarmInNums;
            WORD    wAlarmOutNums;
            /* ��ʶ�������Ƿ����ӣ� 1��ʾ�����ӣ� Ϊ0 ��ʾδ���� */
            BYTE  byAlarmBoxEnable[4][8];
            BYTE  bySupportContact; /* ��Ƶ�ۺ�ƽ̨�ڲ�����������0-��֧��,1-֧�� */
            BYTE  byRes[163];
        }struAlarmHostSystemAbility;
        struct
        {
            BYTE  byOpticalFiberNum;//��������
            BYTE  byRes1[3];
            //���˴�����D1�ı�׼��������4��ʾ֧��4��D1
            WORD    wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
            BYTE  byRes2[164];
        }struInOutputSystemAbility;
        struct
        {
            BYTE  bySupportRingProtocol;   //�Ƿ�֧�ֻ���Э��
            BYTE  bySupportRingNums; //֧�ֻ�������
            BYTE  bySupportPortNums;  //֧�ֵĶ˿�����
            BYTE  byRes[1]; 
            DWORD dwPortSupportRingProto; //ÿ���˿��Ƿ�֧�ֻ���Э�飬��λ�㣬1��32λ�ֱ��ʾ1��32�˿ڣ�0-��֧�֣�1-��ʾ֧�� 
            BYTE  byRes2[192];
        } struFiberSwitchSystemAbility;    
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;//������ϵͳ����
    BYTE    byDecodeSubSystemNums;//������ϵͳ����
    BYTE    bySupportNat;//�Ƿ�֧��NAT��0-��֧�֣�1-֧��
    BYTE    byInputSubSystemNums;//����������ϵͳ����
    BYTE    byOutputSubSystemNums;//���������ϵͳ����
    BYTE    byCodeSpitterSubSystemNums;//�����ϵͳ����
    BYTE    byAlarmHostSubSystemNums;//������ϵͳ����
    BYTE    bySupportBigScreenNum;//��֧�������ɴ����ĸ���
    BYTE    byVCASubSystemNums;//������ϵͳ����
    BYTE    byV6SubSystemNums;//V6��ϵͳ����
    BYTE    byV6DecoderSubSystemNums;//V6������ϵͳ����
    BYTE    bySupportBigScreenX;/*����ƴ�ӵ�ģʽ��m��n*/
    BYTE    bySupportBigScreenY;
    BYTE    bySupportSceneNums;//֧�ֳ���ģʽ�ĸ���
    BYTE    byVcaSupportChanMode;//����֧�ֵ�ͨ��ʹ��ģʽ��0-ʹ�ý���ͨ����1-ʹ����ʾͨ������ͨ����
    BYTE    bySupportScreenNums;//��֧�ֵĴ�������Ļ������
    BYTE    bySupportLayerNums;//��֧�ֵ�ͼ������0xff-��Ч
    BYTE    byNotSupportPreview;//�Ƿ�֧��Ԥ��,1-��֧�֣�0-֧��
    BYTE    byNotSupportStorage;//�Ƿ�֧�ִ洢,1-��֧�֣�0-֧��
    BYTE    byUploadLogoMode;//�ϴ�logoģʽ��0-�ϴ�������ͨ����1-�ϴ�����ʾͨ��
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE    by485Nums;//485���ڸ���
    BYTE    by232Nums;//232���ڸ���
    BYTE    bySerieStartChan;//��ʼͨ��
    BYTE    byScreenMode;//����ģʽ��0-�����ɿͻ��˷��䣬1-�������豸�˷���
    BYTE    byDevVersion;//�豸�汾��0-B10/B11/B12��1-B20
    BYTE    bySupportBaseMapNums;//��֧�ֵĵ�ͼ������ͼ�Ŵ�1��ʼ
    WORD    wBaseLengthX;//ÿ������С�Ļ�׼ֵ��B20ʹ��
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;  //�Ƿ�֧��ͼƬ���ԣ�0-��֧�֣�1-֧��    
    BYTE    bySupportPreAllocDec;   //�Ƿ�֧�����ܽ�����ԴԤ���䣬0-��֧�֣�1-֧��
    BYTE    bySupportDecAutoManage; //�Ƿ�֧�ֽ�����Դ����
    BYTE    byTranDevSubSystemNums; //ת����ϵͳ����
    BYTE    byFiberSwitchNums;  //���������ϵͳ����
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums;//������ϵͳ����
    BYTE  byDecodeSubSystemNums;//������ϵͳ����
    BYTE  bySupportNat;//�Ƿ�֧��NAT��0-��֧�֣�1-֧��
    BYTE  byInputSubSystemNums;//����������ϵͳ����
    BYTE  byOutputSubSystemNums;//���������ϵͳ����
    BYTE  byCodeSpitterSubSystemNums;//�����ϵͳ����
    BYTE  byAlarmHostSubSystemNums;//������ϵͳ����
    BYTE  bySupportBigScreenNum;//��֧��������ƴ������
    BYTE  byVCASubSystemNums;//������ϵͳ����
    BYTE  byRes1[11];   
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  by485Nums;//485���ڸ���
    BYTE  by232Nums;//485���ڸ���
    BYTE  bySerieStartChan;//��ʼͨ��
    BYTE  byRes2[637];    
}NET_DVR_VIDEOPLATFORM_ABILITY, *LPNET_DVR_VIDEOPLATFORM_ABILITY;
//��ȡ�������ӿ�

//ģʽA 
typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;    // ��ʼ�� ��1��ʼ
    BYTE    byStartDay;        // ��ʼ�� ��1��ʼ
    BYTE    byEndMonth;        // ������ 
    BYTE    byEndDay;        // ������
    BYTE    byRes[4];        // �����ֽ�
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE    byStartMonth;    // ��1��ʼ
    BYTE    byStartWeekNum;    // �ڼ������� ��1��ʼ 
    BYTE    byStartWeekday;    // ���ڼ�
    BYTE    byEndMonth;        // ��1��ʼ
    BYTE    byEndWeekNum;    // �ڼ������� ��1��ʼ 
    BYTE    byEndWeekday;    // ���ڼ�    
    BYTE    byRes[2];        // �����ֽ� 
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD    wStartYear;        // ��
    BYTE    byStartMon;        // ��
    BYTE    byStartDay;        // ��
    WORD    wEndYear;        // ��
    BYTE    byEndMon;        // ��
    BYTE    byEndDay;        // ��
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;

typedef union tagNET_DVR_HOLIDATE_UNION
{    
    // �������С 12�ֽ�
    DWORD                    dwSize[3];
    NET_DVR_HOLIDATE_MODEA    struModeA;    // ģʽA
    NET_DVR_HOLIDATE_MODEB    struModeB;    // ģʽB
    NET_DVR_HOLIDATE_MODEC    struModeC;    // ģʽC
}NET_DVR_HOLIDATE_UNION, *LPNET_DVR_HOLIDATE_UNION;

typedef enum tagHOLI_DATE_MODE
{
    HOLIDATE_MODEA = 0,
        HOLIDATE_MODEB,
        HOLIDATE_MODEC
}HOLI_DATE_MODE;

typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE    byEnable;            // �Ƿ�����
    BYTE    byDateMode;            // ����ģʽ 0-ģʽA 1-ģʽB 2-ģʽC
    BYTE    byRes1[2];            // �����ֽ�
    NET_DVR_HOLIDATE_UNION uHolidate;    // ��������
    BYTE    byName[NAME_LEN];    // ��������
    BYTE    byRes2[20];            // �����ֽ�
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

#define  MAX_HOLIDAY_NUM    32

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD    dwSize;            // �ṹ���С
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];    // ���ղ���
    DWORD    byRes[40];        // ��������
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

// ���ձ�������ʽ
typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD    dwSize;                // �ṹ���С
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];    // ����ʱ���
    BYTE    byRes2[240];        // �����ֽ�
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;                // �ṹ���С
    DWORD    dwChannel;            //ͨ����
    DWORD    dwSMDHandleType;    //�������ܼ��ղ������� 0-��Ƶ�쳣��⣬1-�齹��⣬2-����������
    BYTE     byRes2[32];        // �����ֽ�
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD           dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // ¼�����
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // ¼��ʱ���
    BYTE      byRes[20];      //  �����ֽ�
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

#define  MAX_LINK_V30  128

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // �ͻ���IP
    LONG            lChannel;   // ͨ����
    BYTE            byRes[32];  // �����ֽ�
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      // �ṹ���С
    WORD    wLinkNum;    // ���ӵ���Ŀ
    BYTE    byRes1[2];  // �����ֽ�
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   // ���ӵĿͻ�����Ϣ
    BYTE    byRes[32];  // �����ֽ�
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

#define MAX_BOND_NUM  2

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;                // ����ģʽ0 - �����ݴ� 1 - ���ؾ���
    BYTE    byUseDhcp;            // �Ƿ�ʹ��dhcp
    BYTE    byMasterCard;        //  ָ����������Ϊ������        
    BYTE    byStatus;           // BONDING��״̬  0 - �쳣 1-���� ֻ�ܻ�ȡ��������
    BYTE    byBond[MAX_NETWORK_CARD];// byBond[0]== 1 ��ʾʹ��eh0  0��ʾ��ʹ��eh0
    NET_DVR_ETHERNET_V30    struEtherNet;        // ��������
    NET_DVR_IPADDR    struGatewayIpAddr;  // ���ص�ַ
    BYTE  byEnableDNS; //DNSʹ��, 0-�رգ�1-�� 
    BYTE  byBondMode; //�󶨷�ʽ, 0-��Ч��1-����ģʽ��2-��תģʽ��3-XORģʽ��4-�㲥ģʽ��5-802.3adģʽ��6-T1bģʽ��7-���⻯ģʽ
    BYTE  byRes1[2];
    BYTE  byBond2[MAX_NETWORK_CARD_EX/*12*/];// byBond2[0]== 1 ��ʾʹ��eh4  0��ʾ��ʹ��eh4������byBond��չ
    BYTE  byRes[4];// �����ֽ�
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         // �ṹ���С
    BYTE    byEnable;       // �Ƿ�����bonding����
    BYTE    byNum;          // Bonding�����ĸ���
    BYTE    byRes1[2];         //  �����ֽ�
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE    byRes2[40];        // �����ֽ�
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;


// �������
typedef struct tagNET_DVR_DISK_QUOTA 
{
    BYTE    byQuotaType;     // �����������,1 - ������ 2-��������3-��ʱ��
    BYTE    byRes1[5];       // �����ֽ�
    WORD    wStoragePeriod;  //¼��洢���ڣ���λ�죬�������Ϊ��ʱ��ʱ��Ч
    DWORD   dwHCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwLCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwHUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    DWORD   dwLUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    BYTE    byQuotaRatio;    //    ����Ĵ��̱���,��λ:%
    BYTE    byRes2[21];      // �����ֽ�
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         // �ṹ���С
    NET_DVR_DISK_QUOTA    struPicQuota;       //  ͼƬ���
    NET_DVR_DISK_QUOTA    struRecordQuota;    //  ¼�����
    NET_DVR_DISK_QUOTA    struAddInfoQuota;   //  ������Ϣ��� (�����ƴ洢��������Ŀǰ֧�ֵĸ�����Ϣ�У��ȶ�ͼ��������)
    BYTE    byRes[12];      //�����ֽ�
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_DISK_QUOTA_V60
{
    BYTE    byQuotaType;     // �����������,1 - ������ 2-��������3-��ʱ��
    BYTE    byRes1[5];       // �����ֽ�
    WORD    wStoragePeriod;  //¼��洢���ڣ���λ�죬�������Ϊ��ʱ��ʱ��Ч
    DWORD   dwHCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwLCapacity;     // ����Ĵ���������32λ ��λMB
    DWORD   dwHUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    DWORD   dwLUsedSpace;    // ��ʹ�õĴ��̴�С��32λ ��λMB
    BYTE    byQuotaRatio;    //    ����Ĵ��̱���,��λ:%
    BYTE    byRes2[23];      // �����ֽ�
}NET_DVR_DISK_QUOTA_V60, *LPNET_DVR_DISK_QUOTA_V60;

typedef struct tagNET_DVR_DISK_QUOTA_CFG_V60
{
    DWORD  dwSize;         // �ṹ���С
    NET_DVR_DISK_QUOTA_V60    struPicQuota;    //  ͼƬ���
    NET_DVR_DISK_QUOTA_V60    struRecordQuota;    //  ¼�����
    NET_DVR_DISK_QUOTA_V60   struAddInfoQuota;   //  ������Ϣ��� (�����ƴ洢��������Ŀǰ֧�ֵĸ�����Ϣ�У��ȶ�ͼ��������)
    NET_DVR_DISK_QUOTA_V60   struPubInfoFile; // ������Ϣ�ļ����ٷֱ�
    BYTE   byRes[256];      //�����ֽ��ֽ�
}NET_DVR_DISK_QUOTA_CFG_V60, *LPNET_DVR_DISK_QUOTA_CFG_V60;


typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // ��ʱץͼͼƬ����
    DWORD      dwPicInterval;  // ��ʱץͼʱ����,��λs   1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    BYTE       byRes[12];      // �����ֽ�
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    // ��λ��ʾ
    BYTE    byRes[20];          // �����ֽ�
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

#define MAX_PIC_EVENT_NUM      32
#define MAX_ALARMIN_CAPTURE   16

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //���ɴ����Ĺ���ͨ����-ֻ������
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //�����Ĺ���ץͼͨ���ţ���ֵ��ʾ�����ý���������,0xffffffff��ʾ������Ч
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   // �¼�ץͼͼƬ����
    DWORD   dwPicInterval;   // �¼�ץͼʱ����  ��λΪ�� 
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   // �����±� 0 �ƶ���ⴥ��ץͼ 1 ��Ƶ�ڵ�����ץͼ 2 ��Ƶ��ʧ����ץͼ,����3��ʾPIR����ץͼ������4��ʾ���߱���ץͼ������5��ʾ���ȱ���ץͼ,����6��ʾ����ץͼ
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // �������봥��ץͼ���±�0 ����������1 ��������
    DWORD   dwMaxGroupNum;  //�豸֧�ֵ���󱨾�����������ÿ��16����������
    BYTE      byCapTimes; //ץͼ����
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;


typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // �¼�ץͼͼƬ����
    DWORD       dwPicInterval;  // �¼�ץͼʱ����  ��λΪ��  1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    /*
    �����±� 0 �ƶ���ⴥ��ץͼ 1 ��Ƶ�ڵ�����ץͼ��2 ��Ƶ��ʧ����ץͼ,����3��ʾPIR����ץͼ��
    ����4��ʾ���߱���ץͼ������5��ʾ���ȱ���ץͼ,����6��ʾ����ץͼ,����7 ��ʾ�������ץͼ��
    ����8 ��ʾ-Խ��������ץͼ������9 ��ʾ�����������ץͼ,����10��ʾ����������ץͼ, 
    ����11-�����������,����12-�뿪�������,����13-�ǻ����,����14-��Ա�ۼ����,����15-�����˶����,
    ����16-ͣ�����,����17-��Ʒ�������,����18-��Ʒ��ȡ��⡣
    */
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM]; 
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // �������봥��ץͼ���±�0 ����������1 ��������
    BYTE       byCapTimes; //ץͼ����
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD                             dwSize;               //�ṹ�峤��
    NET_DVR_TIMING_CAPTURE        struTimingCapture;    
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;//ץͼ�������� 0-��������1-������
    BYTE       byRes3[19];     // �����ֽ�
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         // �ṹ���С
    NET_DVR_TIMING_CAPTURE struTimingCapture;    
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;//ץͼ�������� 0-��������1-������
    BYTE       byRes3[19];     // �����ֽ�
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;  

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE    byAllDayCapture;    // �Ƿ�ȫ��ץͼ
    BYTE    byCaptureType;        // ץͼ���ͣ�0-��ʱץͼ��1-�ƶ����ץͼ��2-����ץͼ��3-�ƶ����򱨾�ץͼ��4-�ƶ����ͱ���ץͼ��6-���ܱ���ץͼ,7-�������ץͼ��8-ȫ���¼� ,39-���߲���ץͼ,40-����������41-��������,42ҵ����ѯ  43-�����ŷż�� 44-�Ҷȱ���
    BYTE    byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;        // ץͼʱ���
    BYTE        byCaptureType;       // ץͼ���ͣ�0-��ʱץͼ��1-�ƶ����ץͼ��2-����ץͼ��3-�ƶ����򱨾�ץͼ��4-�ƶ����ͱ���ץͼ��6-���ܱ���ץͼ,7-�������ץͼ��8-ȫ���¼�  ,39-���߲���ץͼ ,40-����������41-��������,42ҵ����ѯ 43-�����ŷż�� 44-�Ҷȱ���
    BYTE        byRes[3];           // �����ֽ�
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

// ͨ��ץͼ�ƻ�
typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     // �ṹ��
    BYTE    byEnable;    // �Ƿ�ץͼ
    BYTE    byRes1[3];    // �����ֽ�
    NET_DVR_CAPTURE_DAY    struCaptureDay[MAX_DAYS];    // ȫ��ץͼ�ƻ�
    NET_DVR_CAPTURE_SCHED    struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    // ʱ���ץͼ�����ƻ�
    NET_DVR_CAPTURE_DAY    struCaptureHoliday;            // ����ץͼ�ƻ�
    NET_DVR_CAPTURE_SCHED    struHolidaySched[MAX_TIMESEGMENT_V30];    // ʱ��μ���ץͼ�����ƻ�
    DWORD    dwRecorderDuration;    // ץͼ�����ʱ�� 0xffffffff��ʾ��ֵ��Ч 
    DWORD    dwDelayTime;           /* ץͼ��ʱʱ�� 0- ����ʱ�� 1-3�룬 2-4�룬 3-5�룬 4-10�룬 5-30�룬 6-60�룬 7- 120�룬8-300��*/
    BYTE      byRes[36];            // �����ֽ�
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;


typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;              //�ṹ��С
    LONG   lCardIndex;         //��������
    DWORD  dwInterval;         //�豸�ϴ�����ʱ����, ��λ:100ms
    BYTE   byRes[8];           //�����ֽ�
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //�ṹ��С
    DWORD  dwSendFlowSize;     //����������С,��λkbps
    DWORD  dwRecvFlowSize;     //����������С,��λkbps
    BYTE   byRes[20];          //���� 
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

//  ¼���ǩ
#define LABEL_NAME_LEN 40
typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;                    // �ṹ���С
    NET_DVR_TIME  struTimeLabel;            // ��ǩ��ʱ�� 
    BYTE    byQuickAdd;                // �Ƿ������� �������ʱ��ǩ������Ч
    BYTE    byRes1[3];                // �����ֽ�
    BYTE    sLabelName[LABEL_NAME_LEN];    // ��ǩ������ ����Ϊ40�ֽ�  
    BYTE    byRes2[40];                // �����ֽ�
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

#define  LABEL_IDENTIFY_LEN     64
typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64�ֽڱ�ʶ
    BYTE    byRes[8];               // �����ֽ�
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

#define MAX_DEL_LABEL_IDENTIFY  20// ɾ��������ǩ��ʶ����

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       // �ṹ���С
    BYTE    byMode;   // ��λ��ʾ,0x01��ʾ����ʶɾ��
    BYTE    byRes1;
    WORD    wLabelNum;      // ��ǩ��Ŀ      
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; // ��ǩ��ʶ
    BYTE    byRes2[160];   //�����ֽ�    
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //Ҫ�޸ĵı�ǩ��ʶ
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];    //�޸ĺ�ı�ǩ����
    BYTE byRes2[40];                
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

// ��ǩ�����ṹ��
typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;          // �ṹ���С
    LONG        lChannel;        // ���ҵ�ͨ��
    NET_DVR_TIME    struStartTime;    // ��ʼʱ��
    NET_DVR_TIME    struStopTime;    // ����ʱ��
    BYTE        sLabelName[LABEL_NAME_LEN];    //  ¼���ǩ���� �����ǩ����Ϊ�գ���������ֹʱ�����б�ǩ
    BYTE        byDrawFrame;        //0:����֡��1����֡
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE        byRes[34];        // �����ֽ�
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

// ��ǩ��Ϣ�ṹ��
typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE    sLabelName[LABEL_NAME_LEN];    // ��ǩ����
    NET_DVR_TIME struTimeLabel;        // ��ǩʱ��
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; // ��ǩ��ʶ
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE        byRes[29];            // �����ֽ�
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;

#define CARDNUM_LEN_V30 40
//����ö��
typedef enum _COUNTRY_INDEX_
{
    COUNTRY_NONSUPPORT = 0,   //0-�㷨�ⲻ֧����ʶ����
    /*����� һ����235���Һ͵��� */
    /*ŷ�� 48�����Һ͵��� ���� ����·˹(Cyprus)������ŷ���޽������*/
    COUNTRY_CZE = 1, //Czech Republic �ݿ˹��͹�
    COUNTRY_FRA = 2, //France ����
    COUNTRY_DEU = 3, //Germany �¹�
    COUNTRY_ESP = 4, //Spain ������
    COUNTRY_ITA = 5, //Italy �����
    COUNTRY_NLD = 6, //Netherlands ����
    COUNTRY_POL = 7, //Poland ����
    COUNTRY_SVK = 8, //Slovakia ˹�工��
    COUNTRY_BLR = 9, //Belarus �׶���˹
    COUNTRY_MDA = 10, //Moldova Ħ������
    COUNTRY_RUS = 11, //Russia ����˹
    COUNTRY_UKR = 12, //Ukraine �ڿ���
    COUNTRY_BEL = 13, //Belgium ����ʱ
    COUNTRY_BGR = 14, //Bulgaria ��������
    COUNTRY_DNK = 15, //Denmark ����
    COUNTRY_FIN = 16, //Finland ����
    COUNTRY_GBR = 17, //United Kingdom Ӣ��
    COUNTRY_GRC = 18, //Greece ϣ��
    COUNTRY_HRV = 19, //Croatia ���޵���
    COUNTRY_HUN = 20, //Hungary ������
    COUNTRY_ISR = 21, //Israel ��ɫ��(����)
    COUNTRY_LUX = 22, //Luxembourg ¬ɭ��
    COUNTRY_MKD = 23, //Macedonia ����ٹ��͹�
    COUNTRY_NOR = 24, //Norway  Ų��
    COUNTRY_PRT = 25, //Portuga ������
    COUNTRY_ROU = 26, //Romania ��������
    COUNTRY_SRB = 27, //Serbia ����ά��
    COUNTRY_AZE = 28, //Azerbaijan ��������͹�(����)
    COUNTRY_GEO = 29, //Georgia  ��³����(����)
    COUNTRY_KAZ = 30, //Kazakhstan ������˹̹(����)
    COUNTRY_LTU = 31, //Lithuania �����𹲺͹�
    COUNTRY_TKM = 32, //Turkmenistan ������˹̹(����)
    COUNTRY_UZB = 33, //Uzbekistan ���ȱ��˹̹(����)
    COUNTRY_LVA = 34, //Latvia ����ά��
    COUNTRY_EST = 35, //Estonia ��ɳ����
    COUNTRY_ALB = 36, //Albania ����������
    COUNTRY_AUT = 37, //Austria �µ���
    COUNTRY_BIH = 38, //Bosnia and Herzegovina ��˹���Ǻͺ�����ά��
    COUNTRY_IRL = 39, //Ireland ������
    COUNTRY_ISL = 40, //Iceland ����
    COUNTRY_VAT = 41, //Vatican ��ٸ�
    COUNTRY_MLT = 42, //Malta �����
    COUNTRY_SWE = 43, //Sweden ���
    COUNTRY_CHE = 44, //Switzerland ��ʿ
    COUNTRY_CYP = 45, //Cyprus ����·˹
    COUNTRY_TUR = 46, //Turkey ������
    COUNTRY_SVN = 47, //Slovenia ˹��������
    COUNTRY_MTG = 48, //Montenegro ��ɽ���͹�
    COUNTRY_KOV = 49, //Kosovo ������
    COUNTRY_ADR = 50, //Andorra ������
    COUNTRY_ARM = 51, //Armenia ��������(����)
    COUNTRY_MON = 52, //Monaco Ħ�ɸ�
    COUNTRY_LIE = 53, //Liechtenstein ��֧��ʿ��
    COUNTRY_SMO = 54, //San Marino ʥ����ŵ
    COUNTRY_ORN = 55, //Aland ����(����������)
    COUNTRY_RES2 = 56, //�����ֶ�
    COUNTRY_RES3 = 57, //�����ֶ�
    COUNTRY_RES4 = 58, //�����ֶ�
    /*���� 48������ ���� ����·˹(Cyprus)������ŷ���޽������*/
    COUNTRY_CHI = 59, //China �й�
    COUNTRY_IBN = 60, //In bahrain ����
    COUNTRY_SKR = 61, //South Korea ����
    COUNTRY_LEB = 62, //Lebanon �����
    COUNTRY_NEP = 63, //Nepal �Ჴ�� 
    COUNTRY_THA = 64, //Thailand ̩��
    COUNTRY_PAK = 65, //Pakistan �ͻ�˹̹
    COUNTRY_EMI = 66, //The united Arab emirates ����������������
    COUNTRY_BHU = 67, //Bhutan ����
    COUNTRY_OMA = 68, //Oman ����
    COUNTRY_KOR = 69, //North Korea ����
    COUNTRY_PHI = 70, //The Philippines ���ɱ�
    COUNTRY_CAM = 71, //Cambodia ����կ
    COUNTRY_QAT = 72, //Qatar ������
    COUNTRY_KYR = 73, //Kyrgyzstan ������˹˹̹
    COUNTRY_MAL = 74, //The maldives �������
    COUNTRY_MLY = 75, //Malaysia ��������
    COUNTRY_MOG = 76, //Mongolia �ɹ�
    COUNTRY_ARA = 77, //Saudi Arabia ɳ�ذ�����
    COUNTRY_BRU = 78, //brunei ����
    COUNTRY_LAO = 79, //Laos ����
    COUNTRY_JAP = 80, //Japan �ձ�
    COUNTRY_RES19 = 81, //�����ֶ�
    COUNTRY_PAS = 82, //Palestinian state ����˹̹��
    COUNTRY_TAJ = 83, //Tajikistan ������˹̹
    COUNTRY_KUW = 84, //Kuwait ������
    COUNTRY_SYR = 85, //Syria ������
    COUNTRY_IND = 86, //India ӡ��
    COUNTRY_ISA = 87, //Indonesia ӡ��������
    COUNTRY_AFG = 88, //Afghanistan ������
    COUNTRY_LAN = 89, //Sri Lanka ˹������
    COUNTRY_IRQ = 90, //Iraq ������
    COUNTRY_VIE = 91, //Vietnam Խ��
    COUNTRY_IRA = 92, //Iran ����
    COUNTRY_YEM = 93, //yemen Ҳ��
    COUNTRY_JOR = 94, //Jordan Լ��
    COUNTRY_BUR = 95, //Burma ���
    COUNTRY_SIK = 96, //Sikkim ����
    COUNTRY_BAN = 97, //Bangladesh �ϼ�����
    COUNTRY_SGA = 98, //Singapore �¼���
    COUNTRY_EAT = 99, //East timor �����루�������������������������Ҳ����ϣ�
    COUNTRY_RES5 = 100, //�����ֶ�
    COUNTRY_RES6 = 101, //�����ֶ�
    COUNTRY_RES7 = 102, //�����ֶ�
    COUNTRY_RES8 = 103, //�����ֶ�
    /*���� 60�����Һ͵���*/
    COUNTRY_EGT = 104, //Egypt ����
    COUNTRY_LIY = 105, //Libya ������
    COUNTRY_SUA = 106, //Sudan �յ�
    COUNTRY_TUN = 107, //Tunisia ͻ��˹
    COUNTRY_ALG = 108, //Algeria ����������
    COUNTRY_MCC = 109, //Morocco Ħ���
    COUNTRY_ETH = 110, //Ethiopia ���������
    COUNTRY_ERI = 111, //Eritrea ����������
    COUNTRY_SDE = 112, //Somalia Democratic ������
    COUNTRY_DJI = 113, //Djibouti ������
    COUNTRY_KEN = 114, //Kenya ������
    COUNTRY_TAI = 115, //Tanzania ̹ɣ����
    COUNTRY_UGA = 116, //Uganda �ڸɴ�
    COUNTRY_RWA = 117, //Rwanda ¬����
    COUNTRY_BUD = 118, //Burundi ��¡��
    COUNTRY_SEY = 119, //Seychelles �����
    COUNTRY_CHA = 120, //Chad է��
    COUNTRY_CEA = 121, //Central African �з�
    COUNTRY_CON = 122, //Cameroon ����¡ 
    COUNTRY_EQG = 123, //Equatorial Guinea���������
    COUNTRY_GAB = 124, //Gabon ����
    COUNTRY_TCO = 125, //the Congo �չ����͹��������չ���������
    COUNTRY_DRC = 126, //Democratic Republic of the Congo �չ��������͹��������չ����𣩣�
    COUNTRY_STP = 127, //Sao Tome and Principe ʥ��������������
    COUNTRY_MAN = 128, //Mauritania ë��������
    COUNTRY_WSA = 129, //Western Sahara ������������������
    COUNTRY_SEL = 130, //Senegal ���ڼӶ�
    COUNTRY_TGA = 131, //the Gambia �Ա���
    COUNTRY_MAI = 132, //Mali ����
    COUNTRY_BUF = 133, //Burkina Faso �����ɷ���
    COUNTRY_GUI = 134, //Guinea ������
    COUNTRY_GUB = 135, //Guinea-Bissau �����Ǳ���
    COUNTRY_CAV = 136, //Cape Verde ��ý� 
    COUNTRY_SLE = 137, //Sierra Leone ��������
    COUNTRY_LIR = 138, //Liberia ��������
    COUNTRY_IVC = 139, //Ivory Coast ���ص���
    COUNTRY_GHA = 140, //Ghana ����
    COUNTRY_TGO = 141, //Togo ���
    COUNTRY_BEN = 142, //Benin ����
    COUNTRY_NIG = 143, //Niger ���ն�
    COUNTRY_ZAB = 144, //Zambia �ޱ���
    COUNTRY_ANG = 145, //Angola ������
    COUNTRY_ZBE = 146, //Zimbabwe ��Ͳ�Τ
    COUNTRY_MAW = 147, //Malawi ����ά
    COUNTRY_MOQ = 148, //Mozambique Īɣ�ȿ�
    COUNTRY_BOT = 149, //Botswana ��������
    COUNTRY_NAM = 150, //Namibia ���ױ���
    COUNTRY_SAF = 151, //South Africa �Ϸ�
    COUNTRY_SWD = 152, //Swaziland ˹��ʿ��
    COUNTRY_LES = 153, //Lesotho ������
    COUNTRY_MAG = 154, //Madagasca ����˹��
    COUNTRY_UOC = 155, //Union of Comoros ��Ħ��
    COUNTRY_MAT = 156, //Mauritius ë����˹
    COUNTRY_NGE = 157, //Nigeria ��������
    COUNTRY_SSD = 158, //South Sudan ���յ� 
    COUNTRY_SAH = 159, //Saint Helena ʥ�����ã�Ӣ������ʡ��
    COUNTRY_MYT = 160, //Mayotte ��Լ�أ���������ʡ��
    COUNTRY_REN = 161, //Reunion ����������������ʡ��
    COUNTRY_CAI = 162, //Canary Islands ������Ⱥ��������������������
    COUNTRY_AZO = 163, //AZORES ���ٶ�Ⱥ���������������������������������
    COUNTRY_MAD = 164, //Madeira �����Ⱥ���������������������������������
    COUNTRY_RES9 = 165, //�����ֶ�
    COUNTRY_RES10 = 166, //�����ֶ�
    COUNTRY_RES11 = 167, //�����ֶ�
    COUNTRY_RES12 = 168, //�����ֶ�
    /*���� 55�����Һ͵���*/
    COUNTRY_CAD = 169, //Canada ���ô�
    COUNTRY_GRE = 170, //Greenland Nuuk �����������������ĺ�������������
    COUNTRY_PIE = 171, //Pierre and Miquelon ʥƤ�������ܿ�¡����������������
    COUNTRY_USA = 172, //United States ����
    COUNTRY_BER = 173, //Bermuda ��Ľ��Ӣ������������
    COUNTRY_MEX = 174, //Mexico ī����
    COUNTRY_GUA = 175, //Guatemala Σ������
    COUNTRY_BLI = 176, //Belize ������
    COUNTRY_SAR = 177, //El Salvador �����߶�
    COUNTRY_HOR = 178, //Honduras �鶼��˹
    COUNTRY_NIC = 179, //Nicaragua �������
    COUNTRY_COR = 180, //Costa Rica ��˹�����
    COUNTRY_PAN = 181, //Panama ������
    COUNTRY_TBM = 182, //The Bahamas �͹���
    COUNTRY_TCI = 183, //The Turks and Caicos Islands �ؿ�˹Ⱥ���Ϳ���˹Ⱥ����Ӣ������������
    COUNTRY_CUB = 184, //Cuba �Ű�
    COUNTRY_JAM = 185, //Jamaica �����
    COUNTRY_CAY = 186, //Cayman Islands ����Ⱥ����Ӣ������������
    COUNTRY_HAT = 187, //Haiti ����
    COUNTRY_TDO = 188, //The Dominican �������
    COUNTRY_PUR = 189, //Puerto Rico �����������������������
    COUNTRY_VIL = 190, //The United States Virgin Islands����ά����Ⱥ��
    COUNTRY_BVI = 191, //The British Virgin Islands Ӣ��ά����Ⱥ��
    COUNTRY_ATV = 192, //Anguilla The Valley ��������Ӣ������������
    COUNTRY_ANB = 193, //Antigua and Barbuda ����ϺͰͲ���
    COUNTRY_CSM = 194, //Collectivit�� de Saint-Martin ����ʥ������������������
    COUNTRY_ACY = 195, //Autonomous country ����ʥ�����������������ι� ��
    COUNTRY_SBY = 196, //Saint-Barth��lemy ʥ��̩���׵�����������������
    COUNTRY_SKN = 197, //Saint Kitts and Nevis ʥ���ĺ���ά˹
    COUNTRY_MOT = 198, //Montserrat ���������أ�Ӣ������������
    COUNTRY_GLP = 199, //Guadeloupe �ϵ����գ���������������
    COUNTRY_DOM = 200, //Dominica �������
    COUNTRY_MTE = 201, //Martinique ������ˣ���������������
    COUNTRY_LUC = 202, //St. Lucia ʥ¬����
    COUNTRY_SVG = 203, //Saint Vincent and the Grenadines ʥ��ɭ�غ͸����ɶ�˹
    COUNTRY_GRD = 204, //Grenada �����ɴ�
    COUNTRY_BAR = 205, //Barbados �ͰͶ�˹
    COUNTRY_TRT = 206, //Trinidad and Tobago �������Ͷ�͸�
    COUNTRY_CUR = 207, //Cura?ao ������������������һ�����ι���
    COUNTRY_ARB = 208, //Aruba ��³�ͣ�����������һ�����ι���
    COUNTRY_NEA = 209, //Netherlands Antilles ����������˹
    COUNTRY_COL = 210, //Colombia ���ױ���
    COUNTRY_VEN = 211, //Venezuela ί������
    COUNTRY_GUY = 212, //Guyana ������
    COUNTRY_SUR = 213, //Suriname ������
    COUNTRY_FRN = 214, //Guyane Francaise ����������
    COUNTRY_ECU = 215, //Ecuador ��϶��
    COUNTRY_PER = 216, //Peru ��³
    COUNTRY_BOL = 217, //Bolivia ����ά��
    COUNTRY_PAR = 218, //Paraguay ������
    COUNTRY_CLE = 219, //Chile ����
    COUNTRY_BRA = 220, //Brazil ����
    COUNTRY_UGY = 221, //Uruguay ������
    COUNTRY_ARG = 222, //Argentina ����͢
    COUNTRY_RES13 = 223, //�����ֶ�
    COUNTRY_RES14 = 224, //�����ֶ�
    COUNTRY_RES15 = 225, //�����ֶ�
    COUNTRY_RES16 = 226, //�����ֶ�
    /*������ 25�����Һ͵��� */
    COUNTRY_ATN = 227, //Australien �Ĵ�����
    COUNTRY_NED = 228, //Neuseeland ������
    COUNTRY_PNG = 229, //Papua New Guinea �Ͳ����¼�����
    COUNTRY_SAN = 230, //Salomonen ������Ⱥ��
    COUNTRY_VAU = 231, //Vanuatu ��Ŭ��ͼ
    COUNTRY_NCN = 232, //New Caledonia �¿�������ǣ������ĺ������أ�
    COUNTRY_PAU = 233, //Palau ����
    COUNTRY_FSM = 234, //Federated States of Micronesia �ܿ�������������
    COUNTRY_MRI = 235, //Marshall Island  ���ܶ�Ⱥ��
    COUNTRY_CNM = 236, //Commonwealth of the Northern Mariana Islands ����������Ⱥ���������ĺ������أ�
    COUNTRY_TEG = 237, //The Territory of Guahan �ص��������ĺ������أ�
    COUNTRY_NUR = 238, //Nauru �³
    COUNTRY_KIB = 239, //Kiribati �����˹
    COUNTRY_FID = 240, //Fidschi 쳼�Ⱥ��
    COUNTRY_TNG = 241, //Tonga ����
    COUNTRY_TUV = 242, //Tuvalu ͼ��¬
    COUNTRY_WEF = 243, //Wallis et Futuna  ����˹�͸�ͼ�ɣ������ĺ������أ�
    COUNTRY_TIS = 244, //The Independent State of Samoa ��Ħ��
    COUNTRY_EAS = 245, //Eastern Samoa ������Ħ��
    COUNTRY_TOE = 246, //Tokelau �п��ͣ���������
    COUNTRY_NUE = 247, //Niue Ŧ������������
    COUNTRY_TCD = 248, //The Cook Islands ���Ⱥ������������
    COUNTRY_PFP = 249, //Polyn��sie fran?aiseFrench Polynesia ��������������
    COUNTRY_PID = 250, //Pitcairn Islands Ƥ�ؿ���Ⱥ����Ӣ���ĺ������أ�
    COUNTRY_HAW = 251, //Hawaii State �����ģ������ĺ������أ�
    COUNTRY_RES17 = 252, //�����ֶ�
    COUNTRY_INVALID = 0xfd, //�ֶ���Ч����Ҫʹ����չ�ֶ�CRIndex(_CR_INDEX_)
    COUNTRY_UNRECOGNIZED = 0xfe, //Unrecognized �޷�ʶ��
    COUNTRY_ALL = 0xff, //ALL  ȫ��
}COUNTRY_INDEX;

// ���� / ����ö��
typedef enum _CR_INDEX_
{
    CR_NONSUPPORT = 0,   //0-�㷨�ⲻ֧����ʶ����
    /*����� һ����235���Һ͵��� */
    /*ŷ�� 48�����Һ͵��� ���� ����·˹(Cyprus)������ŷ���޽������*/
    CR_CZE = 1, //Czech Republic �ݿ˹��͹�
    CR_FRA = 2, //France ����
    CR_DEU = 3, //Germany �¹�
    CR_ESP = 4, //Spain ������
    CR_ITA = 5, //Italy �����
    CR_NLD = 6, //Netherlands ����
    CR_POL = 7, //Poland ����
    CR_SVK = 8, //Slovakia ˹�工��
    CR_BLR = 9, //Belarus �׶���˹
    CR_MDA = 10, //Moldova Ħ������
    CR_RUS = 11, //Russia ����˹
    CR_UKR = 12, //Ukraine �ڿ���
    CR_BEL = 13, //Belgium ����ʱ
    CR_BGR = 14, //Bulgaria ��������
    CR_DNK = 15, //Denmark ����
    CR_FIN = 16, //Finland ����
    CR_GBR = 17, //United Kingdom Ӣ��
    CR_GRC = 18, //Greece ϣ��
    CR_HRV = 19, //Croatia ���޵���
    CR_HUN = 20, //Hungary ������
    CR_ISR = 21, //Israel ��ɫ��(����)
    CR_LUX = 22, //Luxembourg ¬ɭ��
    CR_MKD = 23, //Macedonia ����ٹ��͹�
    CR_NOR = 24, //Norway  Ų��
    CR_PRT = 25, //Portuga ������
    CR_ROU = 26, //Romania ��������
    CR_SRB = 27, //Serbia ����ά��
    CR_AZE = 28, //Azerbaijan ��������͹�(����)
    CR_GEO = 29, //Georgia  ��³����(����)
    CR_KAZ = 30, //Kazakhstan ������˹̹(����)
    CR_LTU = 31, //Lithuania �����𹲺͹�
    CR_TKM = 32, //Turkmenistan ������˹̹(����)
    CR_UZB = 33, //Uzbekistan ���ȱ��˹̹(����)
    CR_LVA = 34, //Latvia ����ά��
    CR_EST = 35, //Estonia ��ɳ����
    CR_ALB = 36, //Albania ����������
    CR_AUT = 37, //Austria �µ���
    CR_BIH = 38, //Bosnia and Herzegovina ��˹���Ǻͺ�����ά��
    CR_IRL = 39, //Ireland ������
    CR_ISL = 40, //Iceland ����
    CR_VAT = 41, //Vatican ��ٸ�
    CR_MLT = 42, //Malta �����
    CR_SWE = 43, //Sweden ���
    CR_CHE = 44, //Switzerland ��ʿ
    CR_CYP = 45, //Cyprus ����·˹
    CR_TUR = 46, //Turkey ������
    CR_SVN = 47, //Slovenia ˹��������
    CR_MTG = 48, //Montenegro ��ɽ���͹�
    CR_KOV = 49, //Kosovo ������
    CR_ADR = 50, //Andorra ������
    CR_ARM = 51, //Armenia ��������(����)
    CR_MON = 52, //Monaco Ħ�ɸ�
    CR_LIE = 53, //Liechtenstein ��֧��ʿ��
    CR_SMO = 54, //San Marino ʥ����ŵ
    CR_ORN = 55, //Aland ����(����������)
    CR_RES2 = 56, //�����ֶ�
    CR_RES3 = 57, //�����ֶ�
    CR_RES4 = 58, //�����ֶ�
    /*���� 48������ ���� ����·˹(Cyprus)������ŷ���޽������*/
    CR_CHI = 59, //China �й�
    CR_IBN = 60, //In bahrain ����
    CR_SKR = 61, //South Korea ����
    CR_LEB = 62, //Lebanon �����
    CR_NEP = 63, //Nepal �Ჴ�� 
    CR_THA = 64, //Thailand ̩��
    CR_PAK = 65, //Pakistan �ͻ�˹̹
    CR_EMI = 66, //The united Arab emirates ����������������
    CR_BHU = 67, //Bhutan ����
    CR_OMA = 68, //Oman ����
    CR_KOR = 69, //North Korea ����
    CR_PHI = 70, //The Philippines ���ɱ�
    CR_CAM = 71, //Cambodia ����կ
    CR_QAT = 72, //Qatar ������
    CR_KYR = 73, //Kyrgyzstan ������˹˹̹
    CR_MAL = 74, //The maldives �������
    CR_MLY = 75, //Malaysia ��������
    CR_MOG = 76, //Mongolia �ɹ�
    CR_ARA = 77, //Saudi Arabia ɳ�ذ�����
    CR_BRU = 78, //brunei ����
    CR_LAO = 79, //Laos ����
    CR_JAP = 80, //Japan �ձ�
    CR_RES19 = 81, //�����ֶ�
    CR_PAS = 82, //Palestinian state ����˹̹��
    CR_TAJ = 83, //Tajikistan ������˹̹
    CR_KUW = 84, //Kuwait ������
    CR_SYR = 85, //Syria ������
    CR_IND = 86, //India ӡ��
    CR_ISA = 87, //Indonesia ӡ��������
    CR_AFG = 88, //Afghanistan ������
    CR_LAN = 89, //Sri Lanka ˹������
    CR_IRQ = 90, //Iraq ������
    CR_VIE = 91, //Vietnam Խ��
    CR_IRA = 92, //Iran ����
    CR_YEM = 93, //yemen Ҳ��
    CR_JOR = 94, //Jordan Լ��
    CR_BUR = 95, //Burma ���
    CR_SIK = 96, //Sikkim ����
    CR_BAN = 97, //Bangladesh �ϼ�����
    CR_SGA = 98, //Singapore �¼���
    CR_EAT = 99, //East timor �����루�������������������������Ҳ����ϣ�
    CR_RES5 = 100, //�����ֶ�
    CR_RES6 = 101, //�����ֶ�
    CR_RES7 = 102, //�����ֶ�
    CR_RES8 = 103, //�����ֶ�
    /*���� 60�����Һ͵���*/
    CR_EGT = 104, //Egypt ����
    CR_LIY = 105, //Libya ������
    CR_SUA = 106, //Sudan �յ�
    CR_TUN = 107, //Tunisia ͻ��˹
    CR_ALG = 108, //Algeria ����������
    CR_MCC = 109, //Morocco Ħ���
    CR_ETH = 110, //Ethiopia ���������
    CR_ERI = 111, //Eritrea ����������
    CR_SDE = 112, //Somalia Democratic ������
    CR_DJI = 113, //Djibouti ������
    CR_KEN = 114, //Kenya ������
    CR_TAI = 115, //Tanzania ̹ɣ����
    CR_UGA = 116, //Uganda �ڸɴ�
    CR_RWA = 117, //Rwanda ¬����
    CR_BUD = 118, //Burundi ��¡��
    CR_SEY = 119, //Seychelles �����
    CR_CHA = 120, //Chad է��
    CR_CEA = 121, //Central African �з�
    CR_CON = 122, //Cameroon ����¡ 
    CR_EQG = 123, //Equatorial Guinea���������
    CR_GAB = 124, //Gabon ����
    CR_TCO = 125, //the Congo �չ����͹��������չ���������
    CR_DRC = 126, //Democratic Republic of the Congo �չ��������͹��������չ����𣩣�
    CR_STP = 127, //Sao Tome and Principe ʥ��������������
    CR_MAN = 128, //Mauritania ë��������
    CR_WSA = 129, //Western Sahara ������������������
    CR_SEL = 130, //Senegal ���ڼӶ�
    CR_TGA = 131, //the Gambia �Ա���
    CR_MAI = 132, //Mali ����
    CR_BUF = 133, //Burkina Faso �����ɷ���
    CR_GUI = 134, //Guinea ������
    CR_GUB = 135, //Guinea-Bissau �����Ǳ���
    CR_CAV = 136, //Cape Verde ��ý� 
    CR_SLE = 137, //Sierra Leone ��������
    CR_LIR = 138, //Liberia ��������
    CR_IVC = 139, //Ivory Coast ���ص���
    CR_GHA = 140, //Ghana ����
    CR_TGO = 141, //Togo ���
    CR_BEN = 142, //Benin ����
    CR_NIG = 143, //Niger ���ն�
    CR_ZAB = 144, //Zambia �ޱ���
    CR_ANG = 145, //Angola ������
    CR_ZBE = 146, //Zimbabwe ��Ͳ�Τ
    CR_MAW = 147, //Malawi ����ά
    CR_MOQ = 148, //Mozambique Īɣ�ȿ�
    CR_BOT = 149, //Botswana ��������
    CR_NAM = 150, //Namibia ���ױ���
    CR_SAF = 151, //South Africa �Ϸ�
    CR_SWD = 152, //Swaziland ˹��ʿ��
    CR_LES = 153, //Lesotho ������
    CR_MAG = 154, //Madagasca ����˹��
    CR_UOC = 155, //Union of Comoros ��Ħ��
    CR_MAT = 156, //Mauritius ë����˹
    CR_NGE = 157, //Nigeria ��������
    CR_SSD = 158, //South Sudan ���յ� 
    CR_SAH = 159, //Saint Helena ʥ�����ã�Ӣ������ʡ��
    CR_MYT = 160, //Mayotte ��Լ�أ���������ʡ��
    CR_REN = 161, //Reunion ����������������ʡ��
    CR_CAI = 162, //Canary Islands ������Ⱥ��������������������
    CR_AZO = 163, //AZORES ���ٶ�Ⱥ���������������������������������
    CR_MAD = 164, //Madeira �����Ⱥ���������������������������������
    CR_RES9 = 165, //�����ֶ�
    CR_RES10 = 166, //�����ֶ�
    CR_RES11 = 167, //�����ֶ�
    CR_RES12 = 168, //�����ֶ�
    /*���� 55�����Һ͵���*/
    CR_CAD = 169, //Canada ���ô�
    CR_GRE = 170, //Greenland Nuuk �����������������ĺ�������������
    CR_PIE = 171, //Pierre and Miquelon ʥƤ�������ܿ�¡����������������
    CR_USA = 172, //United States ����
    CR_BER = 173, //Bermuda ��Ľ��Ӣ������������
    CR_MEX = 174, //Mexico ī����
    CR_GUA = 175, //Guatemala Σ������
    CR_BLI = 176, //Belize ������
    CR_SAR = 177, //El Salvador �����߶�
    CR_HOR = 178, //Honduras �鶼��˹
    CR_NIC = 179, //Nicaragua �������
    CR_COR = 180, //Costa Rica ��˹�����
    CR_PAN = 181, //Panama ������
    CR_TBM = 182, //The Bahamas �͹���
    CR_TCI = 183, //The Turks and Caicos Islands �ؿ�˹Ⱥ���Ϳ���˹Ⱥ����Ӣ������������
    CR_CUB = 184, //Cuba �Ű�
    CR_JAM = 185, //Jamaica �����
    CR_CAY = 186, //Cayman Islands ����Ⱥ����Ӣ������������
    CR_HAT = 187, //Haiti ����
    CR_TDO = 188, //The Dominican �������
    CR_PUR = 189, //Puerto Rico �����������������������
    CR_VIL = 190, //The United States Virgin Islands����ά����Ⱥ��
    CR_BVI = 191, //The British Virgin Islands Ӣ��ά����Ⱥ��
    CR_ATV = 192, //Anguilla The Valley ��������Ӣ������������
    CR_ANB = 193, //Antigua and Barbuda ����ϺͰͲ���
    CR_CSM = 194, //Collectivit�� de Saint-Martin ����ʥ������������������
    CR_ACY = 195, //Autonomous country ����ʥ�����������������ι� ��
    CR_SBY = 196, //Saint-Barth��lemy ʥ��̩���׵�����������������
    CR_SKN = 197, //Saint Kitts and Nevis ʥ���ĺ���ά˹
    CR_MOT = 198, //Montserrat ���������أ�Ӣ������������
    CR_GLP = 199, //Guadeloupe �ϵ����գ���������������
    CR_DOM = 200, //Dominica �������
    CR_MTE = 201, //Martinique ������ˣ���������������
    CR_LUC = 202, //St. Lucia ʥ¬����
    CR_SVG = 203, //Saint Vincent and the Grenadines ʥ��ɭ�غ͸����ɶ�˹
    CR_GRD = 204, //Grenada �����ɴ�
    CR_BAR = 205, //Barbados �ͰͶ�˹
    CR_TRT = 206, //Trinidad and Tobago �������Ͷ�͸�
    CR_CUR = 207, //Cura?ao ������������������һ�����ι���
    CR_ARB = 208, //Aruba ��³�ͣ�����������һ�����ι���
    CR_NEA = 209, //Netherlands Antilles ����������˹
    CR_COL = 210, //Colombia ���ױ���
    CR_VEN = 211, //Venezuela ί������
    CR_GUY = 212, //Guyana ������
    CR_SUR = 213, //Suriname ������
    CR_FRN = 214, //Guyane Francaise ����������
    CR_ECU = 215, //Ecuador ��϶��
    CR_PER = 216, //Peru ��³
    CR_BOL = 217, //Bolivia ����ά��
    CR_PAR = 218, //Paraguay ������
    CR_CLE = 219, //Chile ����
    CR_BRA = 220, //Brazil ����
    CR_UGY = 221, //Uruguay ������
    CR_ARG = 222, //Argentina ����͢
    CR_RES13 = 223, //�����ֶ�
    CR_RES14 = 224, //�����ֶ�
    CR_RES15 = 225, //�����ֶ�
    CR_RES16 = 226, //�����ֶ�
    /*������ 25�����Һ͵��� */
    CR_ATN = 227, //Australien �Ĵ�����
    CR_NED = 228, //Neuseeland ������
    CR_PNG = 229, //Papua New Guinea �Ͳ����¼�����
    CR_SAN = 230, //Salomonen ������Ⱥ��
    CR_VAU = 231, //Vanuatu ��Ŭ��ͼ
    CR_NCN = 232, //New Caledonia �¿�������ǣ������ĺ������أ�
    CR_PAU = 233, //Palau ����
    CR_FSM = 234, //Federated States of Micronesia �ܿ�������������
    CR_MRI = 235, //Marshall Island  ���ܶ�Ⱥ��
    CR_CNM = 236, //Commonwealth of the Northern Mariana Islands ����������Ⱥ���������ĺ������أ�
    CR_TEG = 237, //The Territory of Guahan �ص��������ĺ������أ�
    CR_NUR = 238, //Nauru �³
    CR_KIB = 239, //Kiribati �����˹
    CR_FID = 240, //Fidschi 쳼�Ⱥ��
    CR_TNG = 241, //Tonga ����
    CR_TUV = 242, //Tuvalu ͼ��¬
    CR_WEF = 243, //Wallis et Futuna  ����˹�͸�ͼ�ɣ������ĺ������أ�
    CR_TIS = 244, //The Independent State of Samoa ��Ħ��
    CR_EAS = 245, //Eastern Samoa ������Ħ��
    CR_TOE = 246, //Tokelau �п��ͣ���������
    CR_NUE = 247, //Niue Ŧ������������
    CR_TCD = 248, //The Cook Islands ���Ⱥ������������
    CR_PFP = 249, //Polyn��sie fran?aiseFrench Polynesia ��������������
    CR_PID = 250, //Pitcairn Islands Ƥ�ؿ���Ⱥ����Ӣ���ĺ������أ�
    CR_HAW = 251, //Hawaii State �����ģ������ĺ������أ�
    CR_RES17 = 252, //�����ֶ�
    CR_RES18 = 253, //�����ֶ�
    CR_UNRECOGNIZED = 0xfe, //Unrecognized �޷�ʶ��
    CR_ALL = 0xff, //ALL  ȫ��

    //����������������
    CR_TAIWAN = 256, //Taiwan(China) ̨�壨�й���
}CR_INDEX;

//��������������������ö��
typedef enum _EMI_AREA_
{
    EMI_AREA_UNKNOWN = 0,        //��֧������ʶ��
    EMI_AREA_AD,                //��������
    EMI_AREA_FJR,               //��������
    EMI_AREA_DB,                //�ϰ�
    EMI_AREA_RAK,               //�������
    EMI_AREA_AM,                //������
    EMI_AREA_SJ,                //ɳ��
    EMI_AREA_UMW,               //��ķ����
    EMI_AREA_OTHER = 0xff,       //δʶ�𣨵����豸֧�ָ��㷨�����ڻ�����ԭ����δʶ��
} EMI_AREA;

typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         // �ṹ���С 
    LONG   lChannel;       // ͨ����
    /* ���ҵ�ͼƬ����:0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ��
    3 ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ 6 �ֶ�ץͼ ,
    9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���, 
    0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬
    0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������,
    0x13-�����������,0x14-�뿪�������,0x15-�ǻ����,
    0x16-��Ա�ۼ����,0x17-�����˶����,0x18-ͣ�����,
    0x19-��Ʒ�������,0x1a-��Ʒ��ȡ���, 0x1b-�������,
    0x1c-���м��,0x1d-ȡ֤�¼�,0x1e-�����,0x1f-���ƻ����,
    0x20-��ֻ��⣬0x21-����Ԥ����0x22-���±���, 0x23����, 
    0x24Υͣ���,0x25-����ץ��,0x26-���߲��±���,0x2a-������,
    0x2b-�����ʸ�,0x2c-��޳�ʱ,0x2d-��ȫñ���,0x2e-�ܽ�ץ��,
    0x2f-����Ŀ��ץ��,0x30-����ץ�Ľ�ģ, 0x31-���Ŀ����,
    0x32-��������, 0x33-��������, 0x34-ҵ����ѯ,0x35-�Ƿ���̯,
    0x36-��Ա�ܶȣ�����Ԥ����,0x37-��ڼ��,0x38-�����쳣���, 
    0x39-�����˶����, 0x3a-Υͣ, 0x3b-����,0x3c-ѹ��,0x3d-��ռ��,0x3e-���,0x3f-��ͷ,0x40-���˼��,0x41-·��,
    0x42-������,0x43-Ũ����,0x44-ʩ��,0x45-ӵ��,0x46-��ͨ�¹ʼ��, 0x47-�෽ͣ����0x48-�ֶ���������,
    0x49-���ֻ����,0x4b-˾����ʻ��Ϊ,0x4c-�߼�������ʻ,0x4d-��ɳ����ⱨ��,
    0x52-�ŶӼ������,0x53-�ŶӼ��ʱ��,0x54-��������(�����ֶ����أ��ճ������Լ�ƽ̨����), 0x55-��ʱ����ץ��, 0x56-�����ŷż�� , 
    0x57-�Ҷȱ���, 0x58-�����,0x59-��Ա����,0x5a-��Ա����,0x5b-����쳣,0x5c-��Ա����,0xff- ȫ������*/
    BYTE   byFileType;        
    BYTE   byNeedCard;     // �Ƿ���Ҫ����
                           /*
                           0-������1-�ģ�2-����3-�壬4-����5-�ʣ�6-����7-��
                           8-��9-��10-����11-ԥ��12-�ڣ�13-����14-�棬
                           15-����16-�գ�17-�ӣ�18-�ɣ�19-�ɣ�20-����21-�࣬
                           22-³��23-����24-�£�25-����26-����27-̨��28-��
                           29-�أ�30-�ۣ�31-�£�32-�ƣ�33-�㣬34-�0xff-ȫ��
    */
    BYTE   byProvince;     //ʡ������ֵ
    BYTE   byEventType;      // �¼����ͣ�0������1-��ͨ�¼���2-Υ��ȡ֤��3-�����¼�
    BYTE   sCardNum[CARDNUM_LEN_V30];     // ����
    NET_DVR_TIME  struStartTime;//����ͼƬ�Ŀ�ʼʱ��
    NET_DVR_TIME  struStopTime;// ����ͼƬ�Ľ���ʱ��
    //ITC3.7 ����
    DWORD    dwTrafficType; //ͼƬ������Ч�� �ο� VCA_OPERATE _TYPE 
    DWORD    dwVehicleType; //�������� �ο� VCA_VEHICLE_TYPE
    //Υ�������Ͳο� VCA_ILLEGAL_TYPE ��ǰ��֧�ָ�ѡ
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //������(1~99)
    BYTE     bySubHvtType ;//0-����,1-������(��������������֧�ֳ��Ƽ�����ʡ�ݼ���),2-�ǻ�����,3-����
    BYTE     bySubDriveType;  //��ʻ������
    //��byFileTypeΪ0x4b-˾����ʻ��Ϊʱ������Ϊ˾����ʻ��Ϊ���ͣ����嶨�壺0-������1-���̡�2-�Ӵ�绰��3-ƣ�ͼ�ʻ��4-�������ѡ�5-��ʻԱ�쳣��6-δϵ��ȫ����7-�������ī����8-˫�����뷽���̡�9-�������뷽���̡�10-��ʻԱ����쳣��11-��ʱ��ʻ��12-��ʻԱ���
    //��byFileTypeΪ0x4c-�߼�������ʻʱ������Ϊ�߼�������ʻ���ͣ����嶨�壺0-������1-ǰ����ײ��2-����ƫ��(��)��3-����ƫ��(��)��4-���������5-���˷�ײ��6-ä�����(�Һ�)��7-ä�����(���)��8-ä�����(��)
    BYTE   byRes2;//�����ֽ�
    char     sLicense[MAX_LICENSE_LEN/*16*/];    //���ƺ���
    BYTE     byRegion;     // ��������ֵ 0-������1-ŷ��(Europe Region)��2-��������(Russian Region)��3-ŷ��&����˹(EU&CIS), 4-�ж�(Middle East),0xff-����
    BYTE     byCountry;     // ��������ֵ�����գ�COUNTRY_INDEX 
    BYTE     byArea;  //����
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

//PC NVR���ļ���������
typedef struct tagNET_DVR_FIND_FILE_PCNVR
{
    DWORD           dwSize;     //�ṹ���С
    NET_DVR_IPADDR  struIpAddr; //IP��ַ
    WORD            wIpPort;    //�˿ں�
    BYTE            byRes[2];   //�����ֽ�
    char            sDomainName[MAX_DOMAIN_NAME]; //����(��ʱû��)
    char            sSerial[SERIALNO_LEN]; //���к�

    DWORD           lChannel;               //ͨ����
    DWORD           dwFileType;            //¼���ļ�����0xff��ȫ����0����ʱ¼��,1-�ƶ���� ��2������������
    //3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��
    DWORD           dwIsLocked;            //�Ƿ����� 0-�����ļ�,1-�����ļ�, 0xff��ʾ�����ļ�
    DWORD           dwUseCardNo;           //�Ƿ�ʹ�ÿ���
    BYTE            sCardNumber[CARDNUM_LEN_V30];      //����
    NET_DVR_TIME    struStartTime;       //��ʼʱ��
    NET_DVR_TIME    struStopTime;        //����ʱ��
}NET_DVR_FILE_COND_PCNVR, *LPNET_DVR_FILE_COND_PCNVR;

//PCNVR��¼����������ļ�
typedef struct tagNET_DVR_FINDDATA_PCNVR
{
    char sFileName[100];//�ļ���
    NET_DVR_TIME struStartTime;//�ļ��Ŀ�ʼʱ��
    NET_DVR_TIME struStopTime;//�ļ��Ľ���ʱ��
    DWORD dwFileSize;//�ļ��Ĵ�С
    char sCardNum[CARDNUM_LEN_V30];
    BYTE byLocked;//9000�豸֧��,1��ʾ���ļ��Ѿ�������,0��ʾ�������ļ�
    BYTE byFileType;  //�ļ�����
    BYTE byRes[2];
}NET_DVR_FINDDATA_PCNVR, *LPNET_DVR_FINDDATA_PCNVR;

#define PICTURE_NAME_LEN 64
#define PICTURE_INFO_MAX_SIZE 640*960*1.5

typedef struct
{
    char    sFileName[PICTURE_NAME_LEN];//ͼƬ��
    NET_DVR_TIME struTime;//ͼƬ��ʱ��
    DWORD dwFileSize;//ͼƬ�Ĵ�С
    char    sCardNum[CARDNUM_LEN_V30];    //����
    BYTE   byPlateColor ;//�ο��ṹ VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//�ο��ṹ VLR_VEHICLE_CLASS
    BYTE   byEventSearchStatus; //����ͼƬ��ʾͬһ���ҽ����ʱ��0-��ʾ����û��ͼƬ��Ϣ��1-��ʾ���滹��ͼƬ��Ϣ���ܹ�ͼƬ��Ϣ�������һ��״̬Ϊ0��ͼƬ��
    BYTE   byRecogResult ;//ʶ�����ο��ṹVTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //���ƺ���
    BYTE   byRes[12];
}NET_DVR_FIND_PICTURE,*LPNET_DVR_FIND_PICTURE;

#define MAX_RECORD_PICTURE_NUM  50      //  ��󱸷�ͼƬ����  

typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         // �ṹ���С   
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*�Ƿ�������� 0������ 1����*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct 
{    
    DWORD dwSize;           //�ṹ���С
    DWORD dwChannel;        //ͨ����
    BYTE  byCompressType;   //����ȡ��ѹ����������1,������2,������3,�¼�
    BYTE  byRes[15];        //����
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //��ǰѹ����������
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

#define   STEP_READY       0    //׼������
#define   STEP_RECV_DATA   1    //��������������
#define   STEP_UPGRADE     2    //����ϵͳ
#define   STEP_BACKUP      3    //����ϵͳ
#define   STEP_SEARCH      255  //���������ļ�

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //����[0,255]
    DWORD dwContrastValue;    //�Աȶ�[0,255]
    DWORD dwSaturationValue;  //���Ͷ�[0,255]
    DWORD dwHueValue;         //ɫ��[0,255]
    DWORD dwSharpness;          //���[0,255]
    DWORD dwDenoising;          //ȥ��[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{    
    DWORD                    dwSize;                //�ṹ���С
    WORD                    wEffectMode;        //ģʽ 0-��׼ 1-���� 2-���� 3-����  255-�Զ���
    BYTE                    byRes1[146];        //����
    NET_DVR_VIDEO_EFFECT    struVideoEffect;    //��ƵЧ������
    BYTE                    byRes2[60];            //����
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;


typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD    dwChannel;            // ͨ����
    DWORD    dwVideoParamType;      // ��Ƶ�������� 0-���� 1-�Աȶ� 2-���Ͷ� 3-ɫ�� 4-��� 5-ȥ��
    DWORD    dwVideoParamValue;  //��Ӧ����Ƶ����ֵ����Χ����������
    BYTE     byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD    dwSize;            // �ṹ���С
    DWORD    dwChannel;        // ͨ����
    DWORD    dwVideoMode;    // ģʽ
    BYTE    byRes[32];      // ����
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD    dwSize;            // �ṹ���С
    BYTE    byJointed;        //  0 û�й��� 1 �Ѿ�����
    BYTE    byDevType;        // ���������豸����  1 ���������豸
    BYTE    byRes1[2];        // �����ֽ�
    NET_DVR_IPADDR    struIP;            // �����ı�ȡ���豸IP��ַ
    WORD    wPort;            // �����ı�ȡ���豸�˿ں�
    WORD    wChannel;        // �����ı�ȡ���豸ͨ����
    BYTE    byRes2[20];            // �����ֽ�
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;    

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE    byJointed;                // 0-û�й���  1-�Ѿ�����
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;                    // ������ȡ���豸IP��ַ
    WORD    wPort;                    // ������ȡ���豸�˿ں�
    WORD    wChannel;                // ������ȡ���豸ͨ����
    BYTE    byVcaChanStatus;        // 0 - δ���� 1 - ����
    BYTE    byRes2[19];                // �����ֽ�
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD    dwSize;            // �ṹ���С
    BYTE    byDeviceStatus;    // �豸��״̬0 - �������� 1- ����������
    BYTE    byCpuLoad;        // CPUʹ����0-100 �ֱ����ʹ�ðٷ���
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD    dwRes[40];        // �����ֽ�
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{        
    DWORD    dwSize; 
    BYTE   byAudio;            /*��Ƶ�Ƿ���*/
    BYTE   byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE     byVgaResolution;      /*�ֱ��ʣ�����������ȡ*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL��0-NULL*/
    DWORD    dwWindowMode;        /*����ģʽ����������ȡ*/       
    BYTE      byJoinDecChan[MAX_WINDOWS];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE    byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    BYTE    byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
    /*���ֹ����壬0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-������������ʾͨ������*/
    BYTE    byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*�����Ӵ��ڶ�Ӧ����ͨ������Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
            BYTE    byJoinDecoderId[MAX_WINDOWS];
            //��ʾ����������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ���ݴ�//�ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ
            //����������˽���ͨ��
            BYTE    byDecResolution;
            BYTE    byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE    byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE    byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40,*LPNET_DVR_VGA_DISP_CHAN_CFG_V40;

typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE        bySerialTrans;//�Ƿ�͸����0-��1-��
    BYTE        byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;




typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //���0-���뻵��ģʽ��1-��ӻ��㣬2-���滵�㣬3-�˳�����
    DWORD dwDeadPixelX; //����X����
    DWORD dwDeadPixelY; //����Y����
    BYTE byRes[12]; //����
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

#define MAX_REDAREA_NUM   6   //�����̵��������

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;//�ƵƵļ��ʱ�䣬��λ���루s��
    BYTE byDigTrafficLight;//�Ƿ��ǽ�ͨ���ֻƵƣ�0-���ǣ�1-��
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS,*LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable; //�Ƿ���У�����ܣ�0-�رգ�1-����
    DWORD dwCorrectLevel; //У������1(У�������)-10(У�������),Ĭ��Ϊ5
    DWORD dwAreaNum; //У���������
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM]; //У������
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/]; //У���������Ժ�У�������Ӧ
    BYTE   byRes2[8]; //����
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //��ʷ���ݸ���
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;


#define INQUEST_MESSAGE_LEN     44    //��Ѷ�ص�����Ϣ����
#define INQUEST_MAX_ROOM_NUM    2     //�����Ѷ�Ҹ���
#define MAX_RESUME_SEGMENT      2     //֧��ͬʱ�ָ���Ƭ����Ŀ

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE        byRoomIndex;     //��Ѷ�ұ��
    BYTE        byFileType;        //0-��Ѷ�ļ���1-��ͥ�ϴ��ļ�
    BYTE        byMode;     /* 0 ʹ�����г�������; ��0������modeֵ��  1-��Ӱ 2-���л�1  3-���л�2    4-˫����   5-������1   6-������2   7-�Ļ���1   8-�Ļ���2 */
    BYTE        byQuick;     /* �Ƿ�Ϊ�������ã� 1-�������ã������ò�����flash����0-�������ã����ò�����Flash�� �� ����mode �� 0 ��Ч*/
    BYTE        byRes[20];       //����
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char         sMessage[INQUEST_MESSAGE_LEN]; //�ص�����Ϣ
    BYTE    byRes[46];                     //����
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD    wDeviceType;    //���ݲɼ��豸�ͺ�:0-�� 1-���� 2-�ز� 3-���� 4-���� 5-���ء�6-���ϡ�7-ά��˹��
    WORD    wDeviceAddr;    //���ݲɼ��豸��ַ    
    BYTE     byRes[28];        //����
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //֧��Э������,��λ��ʾ, �°汾����������������չ���ֶ�
    //0x1:���� 0x2:�ز� 0x4:����
    BYTE    byRes[120];        //����
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char        szCDName[NAME_LEN];    //�������ƣ�����˫�̹���������һ����
    union
    {
        BYTE     byBitRate;    // byCalcTypeΪ0ʱ��Ч��(0-32��1-48��2-64��3-80��4-96��5-128��
                                //6-160��7-192��8-224��9-256��10-320��11-384��12-448��
                                //13-512��14-640��15-768��16-896ǰ16��ֵ����)17-1024��18-1280��19-1536��
                                //20-1792��21-2048��22-3072��23-4096��24-8192
        BYTE    byInquestTime;  // byCalcTypeΪ1ʱ��Ч��0-1Сʱ, 1-2Сʱ,2-3Сʱ,3-4Сʱ, 4-6Сʱ,5-8Сʱ,6-10Сʱ,7-12Сʱ
        //8-16Сʱ, 9-20Сʱ,10-22Сʱ,11-24Сʱ
    }uCalcMode;
    BYTE        byCalcType;            //��¼��������0-������ 1-��ʱ��
    BYTE        byAutoDelRecord;    // �Ƿ��Զ�ɾ��¼��0-��ɾ����������ʱ����¼�� 1-ɾ��
    BYTE        byAlarmThreshold;        // ����������ֵ
    BYTE        byInquestChannelResolution;     //��Ѷͨ���ֱ��ʣ�0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE        byAutoOpenTray;        //�Ƿ��Զ����� 0-��1-��
    BYTE        byRes[10];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD    dwRecordMode;         //��¼ģʽ:1 ����˫��ģʽ 2 �����ֿ�ģʽ 3 ˫��˫��ģʽ���޸���Ҫ�����豸��
    DWORD    dwWorkMode;           //����ģʽ:0 ��׼ģʽ 1 ͨ��ģʽ(������Ŀǰֻ�б�׼ģʽ)
    DWORD    dwResolutionMode;     //�豸�ֱ��ʣ�0:���� 1:D1 2:720P 3:1080P��������Ѷ�����ô��ֶΣ�
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //��ʪ�ȴ���������    
    NET_DVR_INQUEST_ROOM_INFO     struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE    byEnableHashCheck;        //�Ƿ����öԹ�������HASHֵУ�� 0-�����壬1-�����ã�2-����
    BYTE    byEnableInitCD;        //�Ƿ����ó�ʼ������ 0-�����壬1-�����ã�2-����
    BYTE    byRes[22];             //����
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct _NET_DVR_INQUEST_ALARM_
{
    DWORD dwSize;
    DWORD dwAlarmType;    /*�������� 0-������ 1-���̴��� 2-��Ѷ��ʱ����*/
    BYTE byTrayNo;     /*������*/
    BYTE byRes[3];   
    DWORD dwInquestTime;   /*����Ѷʱ��,��dwAlarmType=2ʱ��Ч,��λ:��*/
    DWORD dwNotifyChannel; /*��Ѷʱ�䳬ʱ����ͨ����*/
    BYTE byRes1[244];
}NET_DVR_INQUEST_ALARM, *LPNET_DVR_INQUEST_ALARM;

typedef struct _NET_DVR_VIDEO_PARKING_POLE_ALARM_
{
    DWORD  dwSize;  //�ṹ���С
    NET_DVR_TIME_V30  struTime;  //����ʱ��
    BYTE  byParkingNum[32];  //��λ���
    BYTE  byAlarmType;  //�������ͣ�0-δ֪��1-��ͷ�ڵ�������2-��ť������3-�Ƿ�ռ�ñ�����4-��λ״̬�仯
    BYTE  byVehicleEnterState; //��������״̬��0-δ֪��1-���룬2-�뿪
    BYTE  byRes[78];
}NET_DVR_VIDEO_PARKING_POLE_ALARM, *LPNET_DVR_VIDEO_PARKING_POLE_ALARM;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //�¼���ʼʱ��
    NET_DVR_TIME  struStopTime;  //�¼���ֹʱ��
    BYTE    byRoomIndex;         //��Ѷ�ұ��,��1��ʼ
    BYTE    byDriveIndex;        //��¼�����,��1��ʼ
    WORD    wSegmetSize;         //��Ƭ�ϵĴ�С, ��λM 
    DWORD   dwSegmentNo;         //��Ƭ���ڱ�����Ѷ�е����,��1��ʼ 
    BYTE    byRes[24];           //����
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //��ָ����¼�����
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE    byResumeMode;        //�ָ�ģʽ��0-�����ָ̻���1-˫���ָ̻�
    BYTE    byRes[199];        //����
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
BYTE  byMainVersion;         /*�������汾.
                             0 : δ֪
                             1 : 8000��ѶDVR
                             �ΰ汾: 1 : 8000HD-S
                             2 : 8100��ѶDVR 
                             �ΰ汾: 1 : ��Ѷ81SNL
                             2 : ��Ѷ81SH
                             3 : ��Ѷ81SFH
                             3 : 8608������Ѷ��NVR 
                             �ΰ汾: 1 : DS-8608SN-SP
                             2 : DS-8608SN-ST
*/
BYTE  bySubVersion;          //���ߴΰ汾
BYTE  byUpgradeVersion;      //�����汾,δ����Ϊ0
BYTE  byCustomizeVersion;     //���ư汾,�Ƕ���Ϊ0
BYTE  byRes[60];             //����
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

typedef struct tagNET_DVR_DISK_RAID_INFO 
{
    DWORD dwSize;   //�ṹ���С
    BYTE byEnable;  //����Raid�Ƿ����
    BYTE bySleepStatus;    //0-��Ч�� 1-���ߣ�2-������
    BYTE byRes[34];  //�����ֽ�
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;


typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //�ṹ���С
    BYTE  byEnable;  //�Ƿ����ã�Ϊǰ��IPCͬ���豸����
    BYTE  byRes[7];  //����
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //�ṹ���С
    char sOldPasswd[PASSWD_LEN];  //IPC�ľ����룬����DVR��DVR��֤
    char sNewPasswd[PASSWD_LEN];  //IPC��������
    BYTE byRes[32];
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

//ͨ����ȡDVR������״̬����λbps
typedef struct tagNET_DEVICE_NET_USING_INFO 
{
    DWORD dwSize;    //�ṹ���С
    DWORD dwPreview;   //Ԥ��
    DWORD dwPlayback;  //�ط�
    DWORD dwIPCModule; //IPC����
    DWORD dwNetDiskRW; //���̶�д
    BYTE res[32];
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

//ͨ��DVR����ǰ��IPC��IP��ַ
typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_IPADDR struIP;       //IPC��IP��ַ
    WORD wPort;       //IPC�Ķ˿�
    char res[126];  
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

//��ʱ������
typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //ͨ����, 0xff��ʾ����ͨ��
    DWORD   dwRecordType;     //¼������:  0xffffffff��ȫ����0����ʱ¼��1-�ƶ���⣬2������������3-�����������ƶ���⣬4-�����������ƶ���⣬5-�������6-�ֶ�¼��7-����¼��(ͬ�ļ�����)
    DWORD   dwLockDuration;   //��������ʱ��,��λ��,0xffffffff��ʾ��������
    NET_DVR_TIME_EX strUnlockTimePoint;    //����ʱ��Ч����dwLockDuration��Ϊ��������ʱ������������ʱ�䵽��ʱ�����Զ�����
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //�ṹ���С
    NET_DVR_TIME strBeginTime; 
    NET_DVR_TIME strEndTime;
    BYTE         byISO8601;      		//�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч,0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char         cTimeDifferenceH;      //��UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����, byISO8601Ϊ1ʱ��Ч
    char         cTimeDifferenceM;      //��UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����, byISO8601Ϊ1ʱ��Ч
    BYTE    byRes[17];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;

//67DVS
//֤����������
typedef enum 
{
    UPGRADE_CERT_FILE = 0, 
    UPLOAD_CERT_FILE = 1,
    TRIAL_CERT_FILE = 2,
    CONFIGURATION_FILE = 3,
    UPLOAD_RECORD_FILE = 4 , //�ϴ�¼���ļ�
    SCENE_CONFIGURATION_FILE = 5, //���������ļ��ϴ�
    UPLOAD_PICTURE_FILE = 6,  //�ϴ�ͼƬ�ļ�
    UPLOAD_VIOLATION_FILE = 7,  //�ϴ�Υ���ֵ��ļ�
    UPLOAD_TG_FILE = 8,  //�ϴ�TG��Timing Generator���ļ�������T1���ԣ�
    UPLOAD_DATA_TO_DB = 9,        //�ϴ��ļ�����ͼ��
    UPLOAD_BACKGROUND_PIC = 10, //�ϴ�����ͼƬ
    UPLOAD_CALIBRATION_FILE = 11, //�ϴ��궨�ļ�
    UPLOAD_TME_FILE = 12, //�ϴ�����ڹ����ļ�
    
    //UPLOAD_TME_FILE = 12, //�ϴ�����ڹ����ļ�
    UPLOAD_VEHICLE_BLACKWHITELST_FILE = 13,
    UPLOAD_PICTURE_TO_CLOUD = 15,    //�ϴ�ͼƬ���ƴ洢
    UPLOAD_VIDEO_FILE = 16,  //�ϴ���Ƶ�ļ�
    UPLOAD_SCREEN_FILE = 17,    //�ϴ���Ļ�������ļ�
    UPLOAD_PUBLISH_MATERIAL = 18,    //�ϴ���Ϣ������̬�ز��ļ�
    UPLOAD_PUBLISH_UPGRADE_FILE = 19,    //�ϴ���Ϣ�������ļ�
    UPLOAD_RING_FILE = 20,   //�ϴ������ļ�
    UPLOAD_ENCRYPT_CERT = 21,    //�ϴ�����֤��
    UPLOAD_THERMOMETRIC_FILE = 22, //�ϴ����±궨�ļ�
    UPLOAD_SUBBRAND_FILE = 23, //�ϴ�������Ʒ���ļ�
    UPLOAD_LED_CHECK_FILE = 24,    //�ϴ�LEDУ���ļ�
    BATCH_UPLOAD_PICTURE_FILE = 25,  //�����ϴ�ͼƬ�ļ�
    UPLOAD_EDID_CFG_FILE = 26, //�ϴ�EDID�����ļ�
    UPLOAD_PANORAMIC_STITCH = 27,//�ϴ�ȫ���Զ�ƴ�������ļ�
    UPLOAD_BINOCULAR_COUNTING = 28,//�ϴ���ֱ����������
    UPLOAD_AUDIO_FILE = 29,  //�ϴ������ļ�
    UPLOAD_PUBLISH_THIRD_PARTY_FILE = 30,  //�ϴ��������ļ�
    UPLOAD_DEEPEYES_BINOCULAR = 31,//�ϴ�TX1˫Ŀ������
    UPLOAD_CERTIFICATE_BLACK_LIST = 32,  //�ϴ����֤������
    UPLOAD_HD_CAMERA_CORRECT_TABLE = 33,//�ϴ�2400W������
    UPLOAD_FD_DATA = 35,//�����������ݵ�������
    UPLOAD_FACE_DATA = 36,//��������ͼƬ���ݵ�������
    UPLOAD_FACE_ANALYSIS_DATA = 37,//����ͼƬ���ݵ��豸ʶ��ͼƬĿ��
    UPLOAD_FILEVOLUME_DATA = 38,//�ϴ��ļ��������ļ�(Ŀǰֻ��CVR��ʵ��)
    IMPORT_DATA_TO_FACELIB = 39,//�����������ݣ�����ͼƬ+ͼƬ������Ϣ ���豸�����⣩
    UPLOAD_LEFTEYE_4K_CALIBFILE = 40,//���ۡ�4K����궨�ڲ������ϴ��������Ŀ����¼�������
    UPLOAD_SECURITY_CFG_FILE = 41,//�����ļ���ȫ����
    UPLOAD_RIGHT_CONTROLLER_AUDIO = 42, //�ϴ�Ȩ�޿�������Ƶ�ļ�
    UPLOAD_MODBUS_CFG_FILE = 43, //����ModbusЭ�������ļ�
    UPLOAD_NOTICE_VIDEO_DATA = 44, //������Ƶ�·�
    UPLOAD_RS485_PROTOCOL_DLL_FILE = 45, //����RS485Э�鶯̬���ļ�
    UPLOAD_PIC_BY_BUF = 46,//��ͼƬ���浼��ͼƬ�ļ�
    UPLOAD_CLIENT_CALIBFILE = 47,//�ͻ��궨�ļ�����(.pto��ʽ�ļ�)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W = 48,//3200W������(.cal��ʽ�ļ�)
    UPLOAD_DOOR_CONTENT = 49, //�ϴ���Ԫ�ſ���ϵ����Ϣ
	UPLOAD_ASR_CONTROL_FILE = 50, //����ʶ������ļ��ϴ�
    UPLOAD_APP_FILE = 51,//�ϴ�HEOP APP�ļ�
    UPLOAD_AI_ALGORITHM_MODEL = 52,    //AI����ƽ̨�������ϴ��㷨ģ�͵��豸
    UPLOAD_PUBLISH_PROGRAM_THUMBNAIL = 53,   //�ϴ���Ϣ������Ŀ����ͼ
    UPLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 54,   //�ϴ���Ϣ����ģ������ͼ
    UPLOAD_AI_PICTURE = 55,//AI����ƽ̨��ͼƬ�����·�ͼƬΪ�����Ƹ�ʽ
    UPLOAD_OFFLINE_CAPTURE_INFO = 56,        //���߲ɼ��û��б���
	UPLOAD_FONT_TYPE_DLL_FILE = 57,            //����⵼��
    UPLOAD_CLIENT_CALIBFILE_FILE = 58,   //�ͻ��궨�ļ�����(.pto��ʽ�ļ�,��ͨ��)
    UPLOAD_HD_CAMERA_CORRECT_TABLE_3200W_FILE = 59  //3200W������(.cal��ʽ�ļ�,��ͨ��)
}NET_SDK_UPLOAD_TYPE;  

typedef enum 
{
    NET_SDK_DOWNLOAD_CERT = 0,        //����֤��
    NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,//����IPC�����ļ�
    NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2, //���ػ�׼����ͼƬ
    NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3,       //����VQD����ͼƬ
    NET_SDK_DOWNLOAD_CONFIGURATION_FILE = 4,   //���������ļ�
    NET_SDK_DOWNLOAD_SCENE_CONFIGURATION_FILE = 5, //���س��������ļ�
    NET_SDK_DOWNLOAD_FILE_FORM_DB = 6,                //����ͼ��������
    // NET_SDK_DOWNLOAD_TME_FILE = 7  //���س���ڹ����ļ�

    NET_SDK_DOWNLOAD_TME_FILE = 7,  //���س���ڹ����ļ�
    NET_SDK_DOWNLOAD_VEHICLE_BLACKWHITELST_FILE = 8, //���غڰ����������ļ�
    NET_SDK_DOWNLOAD_GUID_FILE = 9, //����GUID�ļ� 
    NET_SDK_DOWNLOAD_FILE_FORM_CLOUD = 10,    //���ƴ洢����ͼƬ
    NET_SDK_DOWNLOAD_PICTURE = 11, //����ͼƬ
    NET_SDK_DOWNLOAD_VIDEO = 12, //������Ƶ
    NET_DVR_DOWNLOAD_SCREEN_FILE = 13, //������Ļ�������ļ�
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL = 14,    //������Ϣ������̬�ز��ļ�
    NET_SDK_DOWNLOAD_THERMOMETRIC_FILE = 15,//���ز��±궨�ļ�
    NET_SDK_DOWNLOAD_LED_CHECK_FILE = 16,//����LEDУ���ļ�
    NET_SDK_DOWNLOAD_VEHICLE_INFORMATION = 17,//������Ϣ����
    NET_SDK_DOWNLOAD_CERTIFICATE_BLACK_LIST_TEMPLET = 18, //�������֤������ģ��
    NET_SDK_DOWNLOAD_LOG_FILE = 19, //��־����
    NET_SDK_DOWNLOAD_FILEVOLUME_DATA = 20,//�����ļ��������ļ���Ŀǰֻ��CVR�豸֧�֣�
    NET_SDK_DOWNLOAD_FD_DATA = 21,//����ָ�������������
    NET_SDK_DOWNLOAD_SECURITY_CFG_FILE = 22,//�����ļ���ȫ����
    NET_SDK_DOWNLOAD_PUBLISH_SCHEDULE = 23, //�ճ̵���
    NET_SDK_DOWNLOAD_RIGHT_CONTROLLER_AUDIO = 24, //����Ȩ�޿�������Ƶ�ļ�
    NET_SDK_DOWNLOAD_MODBUS_CFG_FILE = 25, //����ModbusЭ�������ļ�
    NET_SDK_DOWNLOAD_RS485_PROTOCOL_DLL_FILE = 26, //����RS485Э�鶯̬���ļ�
    NET_SDK_DOWNLOAD_CLUSTER_MAINTENANCE_LOG = 27, //��Ⱥά����־����
    NET_SDK_DOWNLOAD_SQL_ARCHIVE_FILE = 28, //�鵵���ݿ��¼����
	NET_SDK_DOWNLOAD_SUBWIND_STREAM = 29,//�����Ӵ�������
    NET_SDK_DOWNLOAD_DEVTYPE_CALIBFILE = 30,//�ͺű궨�ļ�����(.cal��ʽ�ļ�)
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE = 31,// 2400W/3200W��������(.cal��ʽ�ļ�)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE = 32,//�ͻ��궨�ļ�����(.pto��ʽ�ļ�)
    NET_SDK_DOWNLOAD_FOUE_CAMERAS_PICTURES = 33,//��ͨ��ͼƬ������(.tar��ʽ�ļ�)
    NET_SDK_DOWNLOAD_DOOR_CONTENT = 34, //�����ſ���ϵ����Ϣ
    NET_SDK_DOWNLOAD_PUBLISH_MATERIAL_THUMBNAIL = 35,    //������Ϣ������̬�ز�����ͼ
    NET_SDK_DOWNLOAD_PUBLISH_PROGRAM_THUMBNAIL = 36,   //������Ϣ������Ŀ����ͼ
    NET_SDK_DOWNLOAD_PUBLISH_TEMPLATE_THUMBNAIL = 37,   //������Ϣ����ģ������ͼ
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_MAIN = 38,//�ڹ�������ļ�(������)
    NET_SDK_DOWNLOAD_DARK_FIGHTER_X_CORRECT_TABLE_BACKUP = 39,//�ڹ�������ļ������ݷ�����
    NET_SDK_DOWNLOAD_OFFLINE_CAPTURE_INFO_TEMPLATE = 40,  //���زɼ��û��б�ģ��
    NET_SDK_DOWNLOAD_CAPTURE_DATA = 41, //�������߲ɼ�����
    NET_SDK_DOWNLOAD_HD_CAMERA_CORRECT_TABLE_FILE = 42, // 2400W/3200W��������(.cal��ʽ�ļ�, ��ͨ��)
    NET_SDK_DOWNLOAD_CLIENT_CALIBFILE_FILE = 43, //�ͻ��궨�ļ�����(.pto��ʽ�ļ�, ��ͨ��)
    NET_SDK_DOWNLOAD_FOUR_CAMERAS_PICTURES_FILE = 44 //��ͨ��ͼƬ������(.tar��ʽ�ļ�, ��ͨ��)
}NET_SDK_DOWNLOAD_TYPE;

//����״̬
typedef enum 
{
    NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,    //���سɹ�
    NET_SDK_DOWNLOAD_STATUS_PROCESSING,        //��������
    NET_SDK_DOWNLOAD_STATUS_FAILED,            //����ʧ��
    NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR,    //δ֪���� 
    NET_SDK_DOWNLOAD_STATUS_RESOURCE,         //�ڴ治��
    NET_SDK_DOWNLOAD_STATUS_GUIDFILE_EXPORT_FAIL        //GUID�ļ�����ʧ��
}NET_SDK_DOWNLOAD_STATUS;

//���ؿ�����������
typedef enum tagNET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM
{
    ENUM_DOWNLOAD_CONTROL_ERR = -1,
    ENUM_DOWNLOAD_CONTROL_QOS = 1        //����
}NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM;

typedef struct tagNET_DVR_PANORAMIC_STITCH_UPLOAD
{
    DWORD     dwSize;
    DWORD        dwChannel;// ͨ����
    BYTE        byRes[128];
}NET_DVR_PANORAMIC_STITCH_UPLOAD, *LPNET_DVR_PANORAMIC_STITCH_UPLOAD;

typedef struct NET_DVR_FD_DATA_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];   //������ID
    char        szCheckCode[NET_SDK_CHECK_CODE_LEN/*128*/];   //У����
    BYTE         byCover;//�Ƿ񸲸�ʽ���� 0-��1-��
    BYTE        byRes[127];
}NET_DVR_FD_DATA_COND, *LPNET_DVR_FD_DATA_COND;

typedef struct NET_DVR_UPLOAD_FACE_DATA
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];   //������ID
    BYTE        byFDLibType; //����������0-����;1-��������2-������
    BYTE        byRes1[3];
    char        szCustomInfo[NET_SDK_FDPIC_CUSTOM_INFO_LEN/*96*/];   //������ͼƬ�Զ�����Ϣ
    BYTE        byRes[512];
}NET_DVR_UPLOAD_FACE_DATA, *LPNET_DVR_UPLOAD_FACE_DATA;

typedef struct NET_DVR_UPLOAD_FACE_DATA_OUT
{
    char        szPicID[NET_SDK_MAX_PICID_LEN/*256*/];   //ͼƬID
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_DATA_OUT;

typedef struct NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT
{
    DWORD       dwSize;
    DWORD       dwPID;//ͼƬID
    DWORD       dwFaceAnalysisNum;//ʶ����������������
    NET_VCA_RECT       struVcaRect[NET_DVR_MAX_FACE_ANALYSIS_NUM];  //ʶ�����������Ŀ�꣬��������
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT;

typedef struct NET_DVR_SECURITY_CFG_FILE_COND
{
    DWORD       dwSize;
    char        szSecretKey[NET_SDK_SECRETKEY_LEN/*128*/];//У����Կ
    BYTE        byRes[128];
}NET_DVR_SECURITY_CFG_FILE_COND, *LPNET_DVR_SECURITY_CFG_FILE_COND;

typedef struct tagNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM_
{
    DWORD     dwSize;
    BYTE      byType;   //��־���ͣ�0-ȫ����1-����2-Ĭ��
    BYTE      byRes[255];
}NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM, *LPNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM;


typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD    dwSize;                // �ṹ���С
    BYTE    byEnableBonjour;        // Bonjourʹ�� 0 ������ 1���ر�
    BYTE     byRes1[3];                
    BYTE     byFriendlyName[MAX_DOMAIN_NAME];     // ������
    BYTE     byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD            dwSize;                // �ṹ���С
    BYTE            byEnableSocks;          // ʹ�� 0���ر� 1������
    BYTE             byVersion;              // SOCKS�汾 4��SOCKS4   5��SOCKS5
    WORD            wProxyPort;                // ����˿ڣ�Ĭ��1080
    BYTE            byProxyaddr[MAX_DOMAIN_NAME];      // ����IP��ַ������������
    BYTE             byUserName[MAX_DOMAIN_NAME];     // �û��� SOCKS����
    BYTE             byPassword[NAME_LEN];            // ����SOCKS5����
    BYTE             byLocalAddr[MAX_LOCAL_ADDR_LEN];  //��ʹ��socks��������Σ���ʽΪ"ip/netmask;ip/netmask;��"
    BYTE             byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;



typedef struct tagNET_DVR_QOS_CFG
{
    DWORD        dwSize;
    BYTE        byManageDscp;   // �������ݵ�DSCPֵ [0-63]
    BYTE        byAlarmDscp;    // �������ݵ�DSCPֵ [0-63]
    BYTE        byVideoDscp;    // ��Ƶ���ݵ�DSCPֵ [0-63]��byFlagΪ0ʱ����ʾ����Ƶ
    BYTE        byAudioDscp;    // ��Ƶ���ݵ�DSCPֵ [0-63]��byFlagΪ1ʱ��Ч
    BYTE        byFlag;            // 0������Ƶ��һ��1������Ƶ�ֿ�
    BYTE        byEnable;
    BYTE         byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD        dwSize;
    WORD        wHttpsPort;        // HTTPS�˿�
    BYTE        byEnable;        // ʹ�� 0���ر� 1������
    BYTE        byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

//֤�����
typedef struct tagNET_DVR_CERT_NAME
{
    BYTE    byCountry[MAX_COUNTRY_NAME_LEN];              //���Ҵ��� CN��
    BYTE     byState[MAX_DOMAIN_NAME];                //�޻�ʡ
    BYTE     byLocality[MAX_DOMAIN_NAME];            //����
    BYTE     byOrganization[MAX_DOMAIN_NAME];        //��֯
    BYTE     byUnit[MAX_DOMAIN_NAME];                //��λ
    BYTE     byCommonName[MAX_DOMAIN_NAME];
    BYTE     byEmail[MAX_DOMAIN_NAME];  
    BYTE     byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME ;

typedef struct tagNET_DVR_CERT_ADDITION_PARAM
{
    DWORD dwSize;
    char  csCustomID[64]; //�û��Զ���ID
    BYTE  byRes1[2];
    BYTE  byCertificateMode;//wCertTypeΪ1-Certificateʱ��Ч��0-��ǩ��֤�飬1-֤���˽Կ��ʽ
    BYTE  byPrivateKeyMode;// byCertificateModeΪ1-֤���˽Կ��ʽʱ��Ч 0-����key 1-PKCS#12
    BYTE  byPassword[64];  //���룬��PrivateKeyModeΪ0ʱΪ˽Կ�����룬Ϊ1ʱΪPKCS#12������
    BYTE  byRes[128];
}NET_DVR_CERT_ADDITION_PARAM, *LPNET_DVR_CERT_ADDITION_PARAM;


typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //֤�����࣬0-802.1x(Ӧ����WIFI����֤��),1-HTTPS, 3-ieee802.1x(Ӧ��������LAN������֤)
    WORD wCertType; //֤�����ͣ�0-CA��1-Certificate,2-˽Կ�ļ�
    BYTE byFileType; //֤���ļ����ͣ�0-PEM,1-PFX
    BYTE byRes1[2];//�����ֽ�
    BYTE byAddition;//�Ƿ�ʹ�ø��ӽṹ�壬0-��ʹ��;1-ʹ��
    NET_DVR_CERT_ADDITION_PARAM * pStruAdditionParam;//������Ϣ�ṹ��ָ��
    BYTE byRes[28];
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

#define UPLOAD_CERTIFICATE  1 //�ϴ�֤��


typedef struct tagNET_DVR_CERT_INFO
{
    DWORD                 dwSize;
    NET_DVR_CERT_PARAM     struCertParam;    //֤�����
    DWORD                dwValidDays;   //��Ч����������Ϊ��ǩ��ʱ��Ч
    BYTE                 byPasswd[NAME_LEN];   //˽Կ����
    NET_DVR_CERT_NAME     struCertName;    // ֤������
    NET_DVR_CERT_NAME     struIssuerName;    // ֤�鷢�������ƣ���ǩ��֤����Ϣ��ȡʱ��Ч��
    NET_DVR_TIME_EX         struBeginTime;   //֤�鴴��ʱ�䣨��ǩ��֤����Ϣ��ȡʱ��Ч��
    NET_DVR_TIME_EX         struEndTime;   //֤���ֹʱ�䣨��ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE                 serialNumber[NAME_LEN];   //֤���ʶ�루��ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE                 byVersion; 
    BYTE                 byKeyAlgorithm;            //�������� 0-RSA  1-DSA
    BYTE                  byKeyLen;                //���ܳ��� 0-512  1-1024�� 2-2048
    BYTE                 bySignatureAlgorithm; //ǩ���㷨���ͣ���ǩ��֤����Ϣ��ȡʱ��Ч��
    BYTE                 byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;


//channel record status
//***ͨ��¼��״̬*****//
typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE    byValid;       //�Ƿ���Ч
                           /*(ֻ��)¼������:0: ����¼��1����¼�� 2-���� 
                           3-������ 4-��������Ƶ 5-δ���� 6-�浵�� 7-�ش��� 
    8-�û���������� 9-δ��֤,10-�浵�к�¼���� 11-¼��ش��к�¼���� 12-token��֤ʧ��*/
    BYTE    byRecord;     
    WORD    wChannelNO;   //ͨ����
    DWORD   dwRelatedHD;  //��������
    BYTE    byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE    byRes[7];      //�����ֽ�
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;


typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize; 
    DWORD dwIPAlarmInGroup;      //IPͨ��������������
    DWORD dwIPAlarmInNum;       //IPͨ�������������
    DWORD dwIPAlarmOutGroup;     //IPͨ�������������
    DWORD dwIPAlarmOutNum;      //IPͨ�������������
    BYTE byRes[64];  
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;
//****NVR end***//

typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //һ��64��
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;


typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; /*�������Ͻ���ʼ��X����*/
    WORD wYCoordinate; /*�������Ͻ�Y����*/
    WORD wWidth;       /*���ο��*/
    WORD wHeight;      /*���θ߶�*/
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;
/*������Ϣ*/
typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;          /*����Դ����*/
    BYTE  byLayerIdx;          /*ͼ�㣬0Ϊ��ײ�*/
    BYTE  byTransparency; //͸���ȣ�0��100 
    NET_DVR_RECTCFG  struWin;//Ŀ�Ĵ���(�����ʾǽ)
    WORD wScreenHeight;//������
    WORD wScreenWidth;//������
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

#define  MAX_LAYERNUMS    32

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;//������
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;//ͼ���
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

//2011-04-18
/*�������Ϣ,���9999������1��ʼ */
typedef struct tagNET_MATRIX_CAMERAINFO
{  
    DWORD dwGlobalCamId;      /* cam��ȫ�ֱ��*/
    BYTE  sCamName[NAME_LEN]; /*cam������*/
    DWORD dwMatrixId;          /*cam��Ӧ����ı��*/
    DWORD dwLocCamId;         /*cam��Ӧ������ڲ����*/ 
    BYTE  byValid;    /*�Ƿ���Ч��0-��1-��*/
    BYTE  byPtzCtrl; /* �Ƿ�ɿأ�0-��1-��*/
    BYTE  byUseType; //*ʹ�����ͣ�0-����Ϊ����ʹ�ã�1-BNC��2-SP3,3-V6���ˣ�4-��������*/ 
    BYTE  byUsedByTrunk;//��ǰʹ��״̬��0-û�б�ʹ�ã�1-������ʹ�� 
    BYTE  byTrunkReq; /*������ֱ���,��D1Ϊ��λ��1 - 1��D1��2- 2��D1����Ϊ����ʹ��ʱ��ָ���Ǹ��ߵĴ���*/
    BYTE  byRes1[3];
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE  sPurpose[NAME_LEN];/*��;����*/
    BYTE  byRes2[20];  
}NET_MATRIX_CAMERAINFO, *LPNET_MATRIX_CAMERAINFO;

/*��������Ϣ�����2048��*/
typedef struct tagNET_MATRIX_MONITORINFO 
{
    DWORD    dwGloalMonId; /*mon ��ͳһ���*/
    BYTE    sMonName[NAME_LEN];
    DWORD    dwMatrixId;  /*mon���ھ���ı��*/
    DWORD    dwLocalMonId; /*mon���ڲ����*/
    BYTE    byValid;    /*�Ƿ���Ч��0-��1-��*/
    BYTE    byTrunkType; /*ʹ�����ͣ�0-����Ϊ����ʹ�ã�1-BNC��2-SP3,3-V6���ˣ�4-��������*/ 
    BYTE    byUsedByTrunk;//��ǰʹ��״̬��0-û�б�ʹ�ã�1-������ʹ�� 
    BYTE    byTrunkReq; /*�ֱ���, ��D1Ϊ��λ��1- 1��D1��2- 2��D1����Ϊ����ʹ��ʱ��ָ���Ǹ��ߵĴ���*/
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE    sPurpose[NAME_LEN];/*��;����*/
    BYTE    byRes[20];  
}NET_MATRIX_MONITORINFO, *LPNET_MATRIX_MONITORINFO;

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress; /*�豸Ϊ�����豸ʱ��IP��Ϣ*/
    WORD    wPort;
    BYTE    byNicNum; /*0 - eth0, 1 - eth1, ����˫�������ͨ�ż���󶨵�����*/
    BYTE    byRes[69];   
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;
typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE    bySerPortNum;   /*���ӵĴ��ں�  0xff-��ͨ����*/
    BYTE    byMatrixSerPortType;/* ����������صĴ�����ģ�����ļ��̿�(����Э��)���ӻ��������ͨ�ſڣ�����Э�飩���� ��0 --- ����Э��ͨѶ�� 1 --- ����ͨѶ��*/
    BYTE    byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;    //232���ڲ���  ��ͨ����ʱ�˲�����Ч
    BYTE    byRes2[200];      
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;

typedef union tagNET_MATRIX_UNION
{
    NET_MATRIX_DIGITALMATRIX struDigitalMatrix;
    NET_MATRIX_ANALOGMATRIX struAnalogMatrix;
}NET_MATRIX_UNION, *LPNET_MATRIX_UNION;
/*����������Ϣ�����20��*/
typedef struct tagNET_MATRIX_MATRIXINFO 
{
    DWORD   dwSize;
    DWORD    dwMatrixId;  /*������*/
    BYTE    sDevName[NAME_LEN];
    BYTE    byCtrlType; /*ָͨѶ��ʽ�Ǵ���ͨ��, ��������ͨ��*/
    BYTE    byProtocolType;/*����ͨ�ſ���Э��*/
    BYTE    byRes1[6];   /*Ԥ��*/
    NET_MATRIX_UNION struMatrixUnion;
    DWORD    dwMaxPortsIn; /*����������*/
    DWORD    dwMaxPortsOut;/*���������*/
    BYTE    sUserName[NAME_LEN];   /*��¼�û���*/
    BYTE    sPassword[PASSWD_LEN];  /*��¼����*/        
    NET_DVR_TIME struInstallTime;//��װʱ��
    BYTE    sPurpose[NAME_LEN];/*��;����*/
    BYTE    byRes2[20];   /*Ԥ��*/
}NET_MATRIX_MATRIXINFO, *LPNET_MATRIX_MATRIXINFO;


typedef struct tagNET_DVR_MATRIXLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwMatrixNum;//�豸���صľ�������
    BYTE    *pBuffer;//������Ϣ������
    DWORD   dwBufLen;//������ָ�볤�ȣ��������
}NET_DVR_MATRIXLIST,*LPNET_DVR_MATRIXLIST;

/*����������Ϣ*/
typedef struct tagNET_MATRIX_UARTPARAM
{    
    DWORD dwSize;
    BYTE  byPortName[NAME_LEN];
    WORD  wUserId; /*�û���ţ��������豸Ϊ����ʱ����һ���û�������Ȩ�޹���*/
    BYTE  byPortType;    /*�������ͣ�����0-RS232/1-RS485/2-RS422*/
    BYTE  byFuncType; /*�������ӵ��豸������0-���У�1-���̣�2-����͸��ͨ��(485���ڲ������ó�͸��ͨ��),3-ģ�����*/     
    BYTE  byProtocolType;  /*����֧�ֵ�Э������, �����Ӽ����豸ʱ��Ҫ����Ϣ,��ȡ����֧��Э��ı�ż�������*/
    BYTE  byBaudRate;
    BYTE  byDataBits;
    BYTE  byStopBits;   /*ֹͣλ*/
    BYTE  byParity;      /*У��*/
    BYTE  byFlowCtrl;   /*���أ�������أ�������*/
    BYTE  byRes[22];     /*Ԥ��*/
}NET_MATRIX_UARTPARAM, *LPNET_MATRIX_UARTPARAM;

//���256���û���1��256
typedef struct tagNET_MATRIX_USERPARAM 
{
    DWORD dwSize;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN/*16*/];
    BYTE    byRole;/*�û���ɫ:0-����Ա,1-����Ա��ֻ��һ��ϵͳ����Ա��255������Ա*/
    BYTE    byLevel;  /*ͳһ�������ڲ����������,1- 255*/
    BYTE    byRes[18];
}NET_MATRIX_USERPARAM, *LPNET_MATRIX_USERPARAM;

//���255����Դ��
typedef struct tagNET_MATRIX_RESOURSEGROUPPARAM
{
    DWORD dwSize;
    BYTE  byGroupName[NAME_LEN];
    BYTE  byGroupType;/*0-�����CAM�飬1-������MON��*/
    BYTE  byRes1;
    WORD  wMemNum;
    DWORD dwGlobalId[512];
    BYTE  byRes2[20];
}NET_MATRIX_RESOURCEGROUPPARAM,*LPNET_MATRIX_RESOURSEGROUPPARAM;

//���255���û���
typedef struct tagNET_MATRIX_USERGROUPPARAM
{
    DWORD dwSize;
    BYTE  sGroupName[NAME_LEN];
    WORD  wUserMember[255];  /*�������û���Ա*/
    WORD  wResorceGroupMember[255]; /*��������Դ���Ա*/
    BYTE  byPermission[32];//Ȩ�ޣ�����0-ptzȨ�ޡ��л�Ȩ�ޡ���ѯȨ��
    BYTE  byRes[20];
} NET_MATRIX_USERGROUPPARAM, *LPNET_MATRIX_USERGROUPPARAM;

typedef struct tagNET_MATRIX_TRUNKPARAM
{
    DWORD    dwSize;
    DWORD    dwTrunkId;
    BYTE    sTrunkName[NAME_LEN];
    DWORD    dwSrcMonId;
    DWORD    dwDstCamId;
    BYTE    byTrunkType;  /*ʹ������  1-BNC��2-SP3���˸��壬3-SP3����D1�� 4-V6���ˣ�5-��������*/
    BYTE    byAbility;     /*��ʾ���˵Ĵ������Դ��伸·*/
    BYTE    bySubChan;   /*��Թ��˸��߶��ԣ���ʾ��ͨ����*/
    BYTE    byLevel;        /* ���߼��� 1-255*/
    WORD    wReserveUserID;    //Ԥ�����û�ID�� 1~256 ��0��ʾ�ͷ�Ԥ��
    BYTE   byRes[18]; 
} NET_MATRIX_TRUNKPARAM, *LPNET_MATRIX_TRUNKPARAM;

typedef struct tagNET_DVR_MATRIX_TRUNKLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwTrunkNum;//�豸���صĸ�������
    BYTE    *pBuffer;//������Ϣ������
    DWORD   dwBufLen;//������ָ�볤�ȣ��������
}NET_DVR_MATRIX_TRUNKLIST,*LPNET_DVR_MATRIX_TRUNKLIST;

#define MATRIX_PROTOCOL_NUM    20    //֧�ֵ�������Э����
#define KEYBOARD_PROTOCOL_NUM  20    //֧�ֵ�������Э����
typedef struct tagNET_DVR_PROTO_TYPE_EX
{ 
    WORD wType;               /*ipcЭ��ֵ*/  
    WORD wCommunitionType;        /*0��ģ�� 1������ 2������ģ�⡢����*/
    BYTE  byDescribe[DESC_LEN]; /*Э�������ֶ�*/    
}NET_DVR_PROTO_TYPE_EX, LPNET_DVR_PROTO_TYPE_EX;

typedef struct tagNET_DVR_MATRIXMANAGE_ABIILITY
{
    DWORD    dwSize;
    DWORD    dwMaxCameraNum;//���Camera����
    DWORD    dwMaxMonitorNum;//������������
    WORD    wMaxMatrixNum;//����������
    WORD    wMaxSerialNum;//��������
    WORD    wMaxUser;//����û���
    WORD    wMaxResourceArrayNum;//�����Դ����
    WORD    wMaxUserArrayNum;//����û�����
    WORD    wMaxTrunkNum;//��������
    BYTE    nStartUserNum;//��ʼ�û���
    BYTE    nStartUserGroupNum;//��ʼ�û����
    BYTE    nStartResourceGroupNum;//��ʼ��Դ���
    BYTE    nStartSerialNum;//��ʼ���ں�
    DWORD   dwMatrixProtoNum;     /*��Ч�ľ���Э����Ŀ����0��ʼ*/
    NET_DVR_PROTO_TYPE_EX struMatrixProto[MATRIX_PROTOCOL_NUM];/*���Э���б���*/    
    DWORD   dwKeyBoardProtoNum;     /*��Ч�ļ���Э����Ŀ����0��ʼ*/
    NET_DVR_PROTO_TYPE_EX struKeyBoardProto[KEYBOARD_PROTOCOL_NUM];/*���Э���б���*/   
    BYTE   byDelMonitorLongCfg;  //�Ƿ�֧��ɾ��monitor����������
    BYTE   byDelCamonitorLongCfg;//�Ƿ�֧��ɾ��camera����������
    BYTE   byAudioSwitchContorl;//�Ƿ�֧����Ƶ���ؿ���
    BYTE    byRes[29];
} NET_DVR_MATRIXMANAGE_ABILITY, *LPNET_DVR_MATRIXMANAGE_ABILITY;


//����ץ�Ĺ���(����)
typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;                //�Ƿ񼤻����0-��1-��
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    //�����Զ�ROI����ʹ��
    BYTE byAutoROIEnable;//0-�ر�,1-����
    BYTE byRes[2]; //����
    /********* IPC5.1.7 �������� End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //�ߴ������
    NET_VCA_POLYGON     struVcaPolygon;        //����ʶ������
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

//����ץ�Ĺ������
typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;                    //����Ŀ��������ץ�Ĵ���0-10
    BYTE bySnapInterval;                 //ץ�ļ������λ��֡
    BYTE bySnapThreshold;               //ץ����ֵ��0-100
    BYTE byGenerateRate;         //Ŀ�������ٶ�,��Χ[1, 5]    
    BYTE bySensitive;            //Ŀ���������ȣ���Χ[1, 5]
    BYTE byReferenceBright; //2012-3-27�ο�����[0,100]
    BYTE byMatchType;         //2012-5-3�ȶԱ���ģʽ��0-Ŀ����ʧ�󱨾���1-ʵʱ����
    BYTE byMatchThreshold;  //2012-5-3ʵʱ�ȶ���ֵ��0~100
    NET_DVR_JPEGPARA  struPictureParam; //ͼƬ���ṹ
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //����ץ�Ĺ���
    //�����ع���̳���ʱ�䣨�����ֽڣ�
    WORD wFaceExposureMinDuration;//��Χ(1~3600�룬Ĭ��60)��Ч���Զ�ģʽ��
    //�����ع�ģʽ
    BYTE byFaceExposureMode;//1-�رգ�2-������0-�Զ������������жϣ�
    BYTE byBackgroundPic;//����ͼ�ϴ�ʹ�� 0-Ĭ��ֵ����������1-��ֹ
    DWORD dwValidFaceTime;    //��Ч������̳���ʱ�䣬��λ����
    DWORD dwUploadInterval; //����ץ��ͳ�������ϴ����ʱ�䣬��λ���룬Ĭ��900��
    DWORD dwFaceFilteringTime;//����ͣ��ʱ�����,Ĭ��5�룬��Χ0-100�롣0���ʾ������
    BYTE  bySceneID;     //������,Ŀǰ֧��1~4������0Ϊ��Ч
    BYTE byInvalCapFilterEnable;//��Чץ�Ĺ���ʹ�ܣ�0Ϊ�رգ�1Ϊ������Ĭ��Ϊ0
    BYTE byInvalCapFilterThreshold;//��Чץ�Ĺ�����ֵ��0~100����byInvalCapFilterEnableΪ1ʱ��Ч
    BYTE byRes2[81];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

typedef struct tagNET_DVR_FIRMWARE_VERSION_IFNO
{
    DWORD       dwSize;//�ṹ���С
    char        szFirmwareVersion[LEN_PROPERTY/*128*/];  //���ذ汾���� ֻ��
    BYTE        byRes2[128];
}NET_DVR_FIRMWARE_VERSION_IFNO, *LPNET_DVR_FIRMWARE_VERSION_IFNO;

//�����
typedef enum tagHUMAN_AGE_GROUP_ENUM
{    
        ENUM_AGE_GROUP_INFANT      = 1,   //Ӥ�׶�
        ENUM_AGE_GROUP_CHILD       = 2,   //��ͯ
        ENUM_AGE_GROUP_YOUNGSTER   = 3,   //����
        ENUM_AGE_GROUP_ADOLESCENT  = 4,   //������
        ENUM_AGE_GROUP_YOUTH       = 5,   //����
        ENUM_AGE_GROUP_PRIME       = 6,   //׳��
        ENUM_AGE_GROUP_MIDLIFE     = 7,   //����
        ENUM_AGE_GROUP_MIDAGE      = 8,   //������
        ENUM_AGE_GROUP_OLD         = 9,    //����
        ENUM_AGE_GROUP_ALL         = 0xfe,    //ȫ��
        ENUM_AGE_GROUP_UNKNOW      = 0xff   //δ֪,�㷨֧��δ���
}HUMAN_AGE_GROUP_ENUM;

//��������
typedef enum tagFACE_EXPRESSION_GROUP_ENUM
{
    ENUM_EXPRESSION_GROUP_SURPRISED     = 1,   //����
    ENUM_EXPRESSION_GROUP_PANIC         = 2,   //����
    ENUM_EXPRESSION_GROUP_DISGUUSTED    = 3,   //���
    ENUM_EXPRESSION_GROUP_HAPPY         = 4,   //����
    ENUM_EXPRESSION_GROUP_SAD           = 5,   //�ѹ�
    ENUM_EXPRESSION_GROUP_ANGRY         = 6,   //��ŭ
    ENUM_EXPRESSION_GROUP_POKER         = 7,   //����
    ENUM_EXPRESSION_GROUP_ALL           = 0xfe,    //ȫ��
    ENUM_EXPRESSION_GROUP_UNKNOW        = 0xff   //δ֪,�㷨֧��δ���
}FACE_EXPRESSION_GROUP_ENUM;

//����ץ�ĸ�����Ϣ�ṹ��
typedef struct tagNET_VCA_FACESNAP_ADDINFO
{
    //�������ο�,������Ϊ����Сͼ(ͷ����)������������
    NET_VCA_RECT  struFacePicRect;
    int    iSwingAngle;//��ת��, -90~90��
    int    iTiltAngle;//������, -90~90��
    DWORD  dwPupilDistance;//ͫ��,��ΧΪ����СֵΪ10����,���ֵΪ��ǰ�ֱ��ʿ��/1.6
    BYTE   byBlockingState;//Ŀ���ڵ�״̬�� 0-��ʾ��δ֪�����㷨��֧�֣�,1~���ڵ�,2~˲ʱ����ڵ���3~��������ڵ���4~�����ڵ�
    BYTE   byFaceSnapThermometryEnabled;//����ץ�Ĳ���ʹ�� 1-���� 0-�ر�
    BYTE   byIsAbnomalTemperature;//����ץ�Ĳ����Ƿ��¶��쳣 1-�� 0-��
    BYTE   byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    NET_DVR_TIME_EX  struEnterTime;   // ���ץ���½���ʱ��
    NET_DVR_TIME_EX  struExitTime;    // ���ץ�����뿪ʱ��
    float       fFaceTemperature; // �����¶ȣ� - 20.0��~150.0�棬��ȷ��С�����1λ��
    float       fAlarmTemperature;// ���±�������ֵ����ȷ��С�����1λ��
    BYTE   byRes[472];// �����ֽ�
}NET_VCA_FACESNAP_ADDINFO, *LPNET_VCA_FACESNAP_ADDINFO;

//����ץ�Ľ��
typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;             // �ṹ��С
    DWORD     dwRelativeTime;     // ���ʱ��
    DWORD    dwAbsTime;            // ����ʱ��
    DWORD   dwFacePicID;       //����ͼID
    DWORD   dwFaceScore;        //��������,0-100
    NET_VCA_TARGET_INFO  struTargetInfo;//����Ŀ����Ϣ
    NET_VCA_RECT         struRect;      //������ͼ����
    NET_VCA_DEV_INFO       struDevInfo;    //ǰ���豸��Ϣ
    DWORD   dwFacePicLen;        //������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    DWORD   dwBackgroundPicLen; //����ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ(����)
    BYTE    bySmart;            //IDS�豸����0(Ĭ��ֵ)��Smart Functiom Return 1
    BYTE    byAlarmEndMark;//�����������0-������1-������ǣ����ֶν������ID�ֶ�ʹ�ã���ʾ��ID��Ӧ���±�����������Ҫ�ṩ��NVRʹ�ã������жϱ�����������ȡʶ��ͼƬ�����У���������ߵ�ͼƬ��
    BYTE    byRepeatTimes;   //�ظ�����������0-������
    BYTE    byUploadEventDataType;//����ͼƬ���ݳ�����ʽ��0-���������ݣ�1-URL
    NET_VCA_HUMAN_FEATURE   struFeature;  //��������
    float   fStayDuration;  //ͣ��������ʱ��(��λ: ��)
    char    sStorageIP[16];        //�洢����IP��ַ
    WORD    wStoragePort;            //�洢����˿ں�
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    /*������ͼͼƬ���������ȼ���0-�͵�����,1-�е�����,2-�ߵ�����,
    ��������ץ���������ֻ�����ԭ�е�������������
    ԭ�е�����������������ץ����ʵ�֣�Ŀ����ȷ��һ������ץ���л�ȡ��õ�ͼ��Ч������һ�����ͼ�����������֣���������ץ���������ֻ���������Ѿ�ץ����ɵ�����ͼƬ��ʹ��ͼ���㷨��ͼ�������������ۣ����������Ҫ����Ϣ���з���������ͳһ�ı�׼������ͼƬЧ��������������*/
    BYTE    byFacePicQuality;
    BYTE    byUIDLen;     // �ϴ������ı�ʶ����
    BYTE    byLivenessDetectionStatus;// ������״̬��0-������1-δ֪(���ʧ��)��2-������������3-����������4-δ����������
    /*������Ϣ��ʶλ�����Ƿ���NET_VCA_FACESNAP_ADDINFO�ṹ�壩,0-�޸�����Ϣ, 1-�и�����Ϣ��*/
    BYTE    byAddInfo;
    BYTE    *pUIDBuffer;  //��ʶָ��
    //������Ϣָ��,ָ��NET_VCA_FACESNAP_ADDINFO�ṹ��
    BYTE   *pAddInfoBuffer;
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    byBrokenNetHttp;     //����������־λ��0-�����ش����ݣ�1-�ش�����
    BYTE*   pBuffer1;  //������ͼ��ͼƬ����
    BYTE*   pBuffer2;  //����ͼ��ͼƬ���ݣ�������ͨ�����ұ���ͼ�ӿڿ��Ի�ȡ����ͼ��
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
    DWORD dwImageLen;  //ͼƬ���ݳ���
    DWORD dwFaceScore;        //��������,0-100
    NET_VCA_RECT struVcaRect; //������ͼ����
    NET_VCA_POINT struLeftEyePoint;  //����λ��
    NET_VCA_POINT struRightEyePoint; //����λ��
    BYTE       byDistance;           //���ۼ��
    BYTE       bySex;
    BYTE       byAgeGroup; 
    BYTE       byEyeGlass; 
    NET_VCA_RECT struPosRect;  //����λ������
    BYTE       byRes[20];  //����
    BYTE       *pImage;  //ͼƬ����
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD     dwSize; //�ṹ��С
    DWORD        dwRelativeTime; //���ʱ��
    DWORD       dwAbsTime; //����ʱ��
    DWORD      dwBackgroundPicLen; //����ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//������ͼ����
    BYTE   byFacePicNum;//��ͼ����
    BYTE   byUploadEventDataType;//ͼƬ���ݳ�����ʽ��0-���������ݣ�1-URL
    WORD   wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE   byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char   cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char   cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE   byRes[249];
    BYTE*  pBackgroundPicpBuffer; //����ͼ��ͼƬ����
}NET_DVR_FACE_DETECTION,*LPNET_DVR_FACE_DETECTION;

typedef struct tagNET_DVR_UPGRADE_PARAM
{
    DWORD dwUpgradeType;
    char *sFileName;
    void *pInbuffer;
    DWORD dwBufferLen;
    char *pUnitIdList[64];
    BYTE  byRes[112];
}NET_DVR_UPGRADE_PARAM, *LPNET_DVR_UPGRADE_PARAM;


typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
    DWORD dwSize;   //�ṹ��С
    DWORD dwImageId; //��ͼID
    BYTE byRes[20]; //����
    DWORD dwSubImageNum;  //������ͼ����
    NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];  //������ͼ��Ϣ
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

//�齹�����
typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     /*�ṹ����*/
    NET_VCA_DEV_INFO       struDevInfo;/*�豸��Ϣ*/
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE    byRes1[2];     //�����ֽ�
    DWORD  dwRelativeTime; //���ʱ��
    DWORD     dwAbsTime; //����ʱ��
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    byRes[49];        // �����ֽ�
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

//���������
typedef struct  tagNET_DVR_DENSEFOGDETECTION_ALARM
{
    DWORD   dwSize;     /*�ṹ����*/
    NET_VCA_DEV_INFO       struDevInfo;/*�豸��Ϣ*/
    DWORD  dwRelativeTime; //���ʱ��
    DWORD     dwAbsTime; //����ʱ��
    BYTE    byFogLevel; //��ĵȼ���0-����~���� ��1-����~���� 2-����~Ũ�� 3-Ũ������
    BYTE    byRes[259];  // �����ֽ�
}NET_DVR_DENSEFOGDETECTION_ALARM, *LPNET_DVR_DENSEFOGDETECTION_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     /*�ṹ����*/
    BYTE  byAlarmType;//�������ͣ�1-��Ƶ�����쳣��2-��Ƶ����ͻ�䣨��ǿ��������3-��ǿ������4-��Ƶ��ʧ
    BYTE  byRes1;
    WORD wAudioDecibel;//����ǿ�ȣ���Ƶ����ͻ��ʱ�õ���
    NET_VCA_DEV_INFO       struDevInfo;/*�豸��Ϣ*/
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE    byRes[62];        // �����ֽ�
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct  tagNET_BUTTON_DOWN_EXCEPTION_ALARM
{
    DWORD      dwSize;     /*�ṹ����*/
    NET_VCA_DEV_INFO       struDevInfo;/*�豸��Ϣ*/
    BYTE    byRes[64];        // �����ֽ�
}NET_BUTTON_DOWN_EXCEPTION_ALARM, *LPNET_BUTTON_DOWN_EXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //�Ҷ�ͼ�����ݿ��
    DWORD   dwHeight;                 //�Ҷ�ͼ��߶�
    DWORD   dwImageLen;  //�Ҷ�ͼ�����ݳ���
    BYTE     byRes[20];  //����
    BYTE     *pImage;    //�Ҷ�ͼ������
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //�ṹ��С
    BYTE     byEnable;         //�Ƿ񼤻����;
    BYTE     bySensitivity;      //��������ȣ�[0,5]
    BYTE     byRes1[22];       //�����ֽ� 
    NET_VCA_SIZE_FILTER  struSizeFilter;  //�ߴ������
    NET_VCA_POLYGON   struPolygon;    //�����
    NET_VCA_FD_IMAGE_CFG struFDImage;  //ͼƬ��Ϣ
    BYTE     byRes2[20];    //����
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;  //ͼƬ���ݳ���
    DWORD dwFaceScore;        //��������,0-100
    NET_VCA_RECT struVcaRect; //������ͼ����
    BYTE  byRes[20];  //����
    BYTE  *pImage;  //ͼƬ����
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;   //�ṹ��С
    DWORD dwImageId; //��ͼID
    BYTE byRes[20]; //����
    DWORD dwSubImageNum;  //������ͼ����
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //������ͼ��Ϣ
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //ͼƬ���ݳ���
    DWORD dwModelLen;  //ģ�����ݳ���
    BYTE  byRes[20]; //����
    BYTE  *pImage;  //����ͼƬ����ָ��
    BYTE  *pModel;  //ģ������ָ��
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //��ͼID
    DWORD dwFaceScore;        //��������,0-100
    NET_VCA_RECT struVcaRect;  //������ͼ����
    BYTE  byRes[20];  //����
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

#define MAX_HUMAN_PICTURE_NUM  10   //�����Ƭ��
#define MAX_HUMAN_BIRTHDATE_LEN 10   //���������³���

typedef struct tagNET_DVR_AREAINFOCFG
{ 
    WORD wNationalityID; //����
    WORD wProvinceID; //ʡ
    WORD wCityID; //��
    WORD wCountyID; //��
	/*
	if (dwCode != 0) dwCode ��ֵ���� ��ȫ����ʡ�ݳ����б�.txt��
	else dwCode ��ֵ�������� PROVINCE_CITY_IDX
	*/
    DWORD dwCode;
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //�Ա�0-�У�1-Ů��0xff-δ֪
    BYTE   byCertificateType; //֤�����ͣ�0-���֤��1-����֤��2-����֤��3-���գ�4-������0xff-δ֪
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //�������£��磺201106
    BYTE   byName[NAME_LEN]; //����
    NET_DVR_AREAINFOCFG struNativePlace; //�������
    BYTE   byCertificateNumber[NAME_LEN];  //֤����
	/*
	dwPersonInfoExtendLen && pPersonInfoExtend ��ӦURL(/ISAPI/System/Video/inputs/channels/<ID>/faceContrast/personInfoExtend)��ʾ�� PersonInfoExtendList XML Block
	�������ڣ�ƽ̨���Ĺ����ʱ�򣬵���picture���ݵ��Զ�����Ϣ�����豸���ƥ�䱨����Я����Ϊƥ����Ϣһ���ϴ���ƽ̨���Ĺ���ƥ�䣻
	*/
    DWORD  dwPersonInfoExtendLen;// ��Ա��ǩ��Ϣ��չ����
    BYTE  *pPersonInfoExtend;  //��Ա��ǩ��Ϣ��չ��Ϣ
    BYTE   byAgeGroup;//����Σ����HUMAN_AGE_GROUP_ENUM���紫��0xff��ʾδ֪
    BYTE   byRes2[11];
}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE   byCertificateType; //֤�����ͣ�0-�����ã�1-���֤��2-����֤
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE   byName[NAME_LEN]; //����
    NET_DVR_AREAINFOCFG struNativePlace; //�������
    BYTE   byCertificateNumber[NAME_LEN];  //֤����
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;


typedef struct tagNET_VCA_BLACKLIST_INFO
{
    DWORD  dwSize;   //�ṹ��С
    DWORD  dwRegisterID;  //����ע��ID�ţ�ֻ����
    DWORD  dwGroupNo; //�����
    BYTE   byType; //�ڰ�������־��0-ȫ����1-��������2-������
    BYTE   byLevel; //�������ȼ���0-ȫ����1-�ͣ�2-�У�3-��
    BYTE   byRes1[2];  //����
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE   byRemark[NAME_LEN]; //��ע��Ϣ
    DWORD dwFDDescriptionLen;//�������������ݳ���
    BYTE  *pFDDescriptionBuffer;//��������������ָ��
    DWORD dwFCAdditionInfoLen;//ץ�Ŀ⸽����Ϣ����
    BYTE  *pFCAdditionInfoBuffer;//ץ�Ŀ⸽����Ϣ����ָ�루FCAdditionInfo�а������PTZ���꣩
    BYTE   byRes2[4];
}NET_VCA_BLACKLIST_INFO, *LPNET_VCA_BLACKLIST_INFO;

typedef struct tagNET_VCA_BLACKLIST_PARA
{
    DWORD dwSize;   //�ṹ��С
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //��������������
    DWORD dwRegisterPicNum;  //������ͼ����
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //������ͼƬ��Ϣ
    BYTE  byRes[40]; //����
}NET_VCA_BLACKLIST_PARA, *LPNET_VCA_BLACKLIST_PARA;

typedef struct tagNET_VCA_BLACKLIST_COND
{
    LONG  lChannel; //ͨ����
    DWORD dwGroupNo; //�����
    BYTE  byType; //�ڰ�������־��0-ȫ����1-��������2-������
    BYTE  byLevel; //�������ȼ���0-ȫ����1-�ͣ�2-�У�3-��
    BYTE  byRes1[2];  //����
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //��Ա��Ϣ
    BYTE  byRes[20];
}NET_VCA_BLACKLIST_COND, *LPNET_VCA_BLACKLIST_COND;

typedef struct tagNET_VCA_BLACKLIST_PIC
{
    DWORD dwSize;   //�ṹ��С
    DWORD dwFacePicNum;  //����ͼ����
    BYTE  byRes[20]; //����
    NET_VCA_PICMODEL_RESULT  struBlackListPic[MAX_HUMAN_PICTURE_NUM];  //������Ƭ��Ϣ
}NET_VCA_BLACKLIST_PIC, *LPNET_VCA_BLACKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE byRes[12]; //����
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

#define MAX_FACE_PIC_LEN   6144   //�������ͼƬ���ݳ���
typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ���ݳ���
    NET_DVR_TIME struSnapTime;  //ץ��ʱ��
    DWORD dwSimilarity; //���ƶ�
    BYTE  byRes[16];  //����
    char  sPicBuf[MAX_FACE_PIC_LEN];  //ͼƬ����
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //����ͼƬID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //��ͼID
    DWORD dwFaceScore;  //��������
    NET_VCA_RECT struVcaRect; //������ͼ����
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;

typedef union tagNET_VCA_FIND_SNAPPIC_UNION
{
    NET_VCA_NORMAL_FIND  struNormalFind; //��ͨ����
    NET_VCA_ADVANCE_FIND struAdvanceFind; //�߼�����
}NET_VCA_FIND_SNAPPIC_UNION, *LPNET_VCA_FIND_SNAPPIC_UNION;

typedef enum _VCA_FIND_SNAPPIC_TYPE_
{
    VCA_NORMAL_FIND  = 0x00000000,   //��ͨ����
        VCA_ADVANCE_FIND  = 0x00000001  //�߼�����
}VCA_FIND_SNAPPIC_TYPE;

typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE byThreshold;  //��ֵ��0-100
    BYTE byRes[23]; //����
    VCA_FIND_SNAPPIC_TYPE dwFindType;//�������ͣ����VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //��������
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;     // ���ʱ��
    DWORD dwAbsTime;            // ����ʱ��
    DWORD dwSnapFacePicID;       //ץ������ͼID
    DWORD dwSnapFacePicLen;        //ץ��������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    NET_VCA_DEV_INFO struDevInfo;        //ǰ���豸��Ϣ
    BYTE  byFaceScore;        //�������֣�ָ������ͼ������������,0-100
    BYTE bySex;//�Ա�0-δ֪��1-�У�2-Ů,0xff-�㷨֧�֣�����û��ʶ�����
    BYTE byGlasses;//�Ƿ���۾���0-δ֪��1-�ǣ�2-��,3-��ī��, 0xff-�㷨֧�֣�����û��ʶ�����
	/*
	ʶ������������η�Χ[byAge-byAgeDeviation,byAge+byAgeDeviation]
	*/
    BYTE byAge;//����,0-��ʾ��δ֪�����㷨��֧�֣�,0xff-�㷨֧�֣�����û��ʶ�����
    BYTE byAgeDeviation;//�������ֵ
    BYTE byAgeGroup;//����Σ����HUMAN_AGE_GROUP_ENUM��������0xff��ʾδ֪
    /*������ͼͼƬ���������ȼ���0-�͵�����,1-�е�����,2-�ߵ�����,
    �����������㷨�����������ͼ����ͼƬ,������ͨ����̬�������ȡ��ڵ��������������ȿ�Ӱ������ʶ�����ܵ������ۺ������Ľ��*/
    BYTE byFacePicQuality;
    BYTE  byEthnic; 
    DWORD dwUIDLen; // �ϴ������ı�ʶ����
    BYTE  *pUIDBuffer;  //��ʶָ��
    float fStayDuration;  //ͣ��������ʱ��(��λ: ��)
    BYTE  *pBuffer1;  //ץ��������ͼ��ͼƬ����
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //������������Ϣ
    DWORD dwBlackListPicLen;       //������������ͼ�ĳ��ȣ�Ϊ0��ʾû��ͼƬ������0��ʾ��ͼƬ
    DWORD  dwFDIDLen;// ������ID����
    BYTE  *pFDID;  //������Idָ��
    DWORD  dwPIDLen;// ������ͼƬID����
    BYTE  *pPID;  //������ͼƬIDָ��
    WORD  wThresholdValue; //��������ֵ[0,100]
    BYTE  byIsNoSaveFDPicture;//0-����������ͼƬ,1-������������ͼƬ, �������˵���ͼƬ���߽�ģʱ������ԭͼ����ʱ,���ֶη���1,��ʱ������ͼƬ�����ٷ���
    BYTE  byRealTimeContrast;//�Ƿ�ʵʱ���� 0-ʵʱ 1-��ʵʱ
    BYTE  *pBuffer1;  //������������ͼ��ͼƬ����
}NET_VCA_BLACKLIST_INFO_ALARM, *LPNET_VCA_BLACKLIST_INFO_ALARM;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;             // �ṹ��С
    float fSimilarity; //���ƶȣ�[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //ץ����Ϣ
    NET_VCA_BLACKLIST_INFO_ALARM struBlackListInfo; //��������Ϣ
    char         sStorageIP[16];        //�洢����IP��ַ
    WORD            wStoragePort;            //�洢����˿ں�
    BYTE  byMatchPicNum; //ƥ��ͼƬ��������0-���������豸���ֵĬ��0�����豸���ֵΪ0ʱ��ʾ����û��ƥ���ͼƬ��Ϣ��
    BYTE  byPicTransType;//ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    DWORD dwSnapPicLen;//�豸ʶ��ץ��ͼƬ����
    BYTE  *pSnapPicBuffer;//�豸ʶ��ץ��ͼƬָ��
    NET_VCA_RECT  struRegion;//Ŀ��߽���豸ʶ��ץ��ͼƬ�У�������ͼ����
    DWORD dwModelDataLen;//��ģ���ݳ���
    BYTE  *pModelDataBuffer;// ��ģ����ָ��
    BYTE  byModelingStatus;// ��ģ״̬
    BYTE  byLivenessDetectionStatus;//������״̬��0-������1-δ֪�����ʧ�ܣ���2-������������3-����������4-δ����������
    char  cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,0xff��Ч*/
    char  cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������0xff��Ч*/
    BYTE  byMask;                //ץ��ͼ�Ƿ�����֣�0-������1-δ֪��2-�������֣�3-������
    BYTE  bySmile;               //ץ��ͼ�Ƿ�΢Ц��0-������1-δ֪��2-��΢Ц��3-΢Ц
    BYTE  byContrastStatus;      //�ȶԽ����0-������1-�ȶԳɹ���2-�ȶ�ʧ��
    BYTE  byBrokenNetHttp;     //����������־λ��0-�����ش����ݣ�1-�ش�����
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;

typedef struct tagNET_VCA_BLACKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLACKLIST_INFO struBlackListInfo; //������������Ϣ
    DWORD dwBlackListPicID;       //������������ͼID�����ڲ���ͼƬ
       BYTE  byRes[20];              // �����ֽ�
}NET_VCA_BLACKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLACKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;     // ���ʱ��
    DWORD dwAbsTime;            // ����ʱ��
    DWORD dwSnapFacePicID;       //ץ������ͼID
    NET_VCA_DEV_INFO       struDevInfo;        //ǰ���豸��Ϣ
       BYTE  byRes[20];              // �����ֽ�
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;             // �ṹ��С
    float fSimilarity; //���ƶȣ�[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //ץ����Ϣ
    NET_VCA_BLACKLIST_INFO_ALARM_LOG struBlackListInfoLog; //��������Ϣ
    BYTE  byRes[60];              // �����ֽ�
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;

typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;             // �ṹ��С
       DWORD dwSnapFaceID; //ץ��������ͼID
    DWORD dwBlackListID; //ƥ��ĺ�����ID
    DWORD dwBlackListFaceID; //�ȶԵĺ�����������ͼID
    BYTE  byRes[20];              // �����ֽ�
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;             // �ṹ��С
       DWORD dwSnapFaceLen; //ץ��������ͼ����
    DWORD dwBlackListFaceLen; //�ȶԵĺ�����������ͼ����
    BYTE  byRes[20];              //�����ֽ�
    BYTE *pSnapFace;  //ץ��������ͼ��ͼƬ����
    BYTE *pBlackListFace;  //�ȶԵĺ�����������ͼ����
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLACKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //�ṹ��С
    NET_VCA_BLACKLIST_INFO struBlackListInfo;  //��������������
    DWORD dwImageLen;  //ͼ�����ݳ���
    BYTE  byRes[124];  //����
    BYTE  *pImage;    //ͼ������
}NET_VCA_BLACKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLACKLIST_FASTREGISTER_PARA;

/*******PJ01C20170209084����¼��NVS������ܿ���������Ŀר��******/
//��֡��������ͳ�ƽ���ϴ�
typedef struct tagNET_DVR_FRAMES_PEOPLE_COUNTING
{
    DWORD  dwSize;          // �ṹ���С
    NET_VCA_DEV_INFO   struDevInfo;//ǰ���豸��Ϣ
    DWORD  dwRelativeTime; //���ʱ��
    DWORD  dwAbsTime;      // ����ʱ��
    DWORD  dwPeopleCountingNum; //�����е�����ͳ������
    DWORD  dwPicLen;       //�豸ʶ��ץ�ĵ�ȫ��ͼƬ���ݳ���
    BYTE   *pPicBuffer;    //�豸ʶ��ץ�ĵ�ȫ��ͼƬ����ָ��
    BYTE   byRes[512];     // �����ֽ�
}NET_DVR_FRAMES_PEOPLE_COUNTING, *LPNET_DVR_FRAMES_PEOPLE_COUNTING;
/*******PJ01C20170209084����¼��NVS������ܿ���������Ŀר��******/

//������������
typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  // �Ƿ����,0-��,1-�� 
    BYTE  byType;   //0-�洢ץ�ģ�1-�洢�������ȶԱ�����2-�洢ץ�ĺͺ������ȶԱ�����0xff-��Ч
    BYTE  bySaveAlarmPic; //�Ƿ����ڱ�������ı���ͼƬ��0-��1-��
    BYTE  byRes1[5]; //����
    DWORD dwDiskDriver;   //�̷��ţ���0��ʼ
    DWORD dwLeftSpace;   //Ԥ����������λΪG��
    BYTE  byRes2[8]; //����
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

//�洢·������
typedef struct tagNET_VCA_SAVE_PATH_CFG
{ 
    DWORD dwSize;   //�ṹ��С
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //��������
    BYTE  byRes[40]; //����
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR     struIP;        //�����豸��IP��ַ
    WORD     wDevicePort;                 //�˿ں�
    BYTE    byEnable;                 //�Ƿ����ã�0-��1-��
    BYTE     byRes1;                //����
    BYTE    sUserName[NAME_LEN];    //�����豸�ĵ�¼�ʺ�
    BYTE    sPassword[PASSWD_LEN];    //�����豸�ĵ�¼����
    BYTE    byRes2[60];
}NET_DVR_DEV_ACCESS_CFG,*LPNET_DVR_DEV_ACCESS_CFG;

/********************************��������ʶ�� end****************************/
//�ֱ���
#define MAKE_RESOLUTION(_interlace_, _width_, _height_, _fps_) \
    (((_interlace_)<<28) \
    |((((_width_)>>3)&0x1ff)<<19)| \
    ((((_height_)>>1)&0x7ff)<<8)| \
((_fps_)&0xff))
#define GET_RES_INTERLACE(_res_) \
(((_res_)>>28)&0x1)
#define GET_RES_WIDTH(_res_) \
((((_res_)>>19)&0x1ff)<<3)
#define GET_RES_HEIGHT(_res_) \
((((_res_)>>8)&0x7ff)<<1)
#define GET_RES_FPS(_res_) \
((_res_)&0xff)

#define NOT_AVALIABLE    MAKE_RESOLUTION (0,0,0,0)
#define SVGA_60HZ         MAKE_RESOLUTION(0, 800, 600, 60)
#define SVGA_75HZ         MAKE_RESOLUTION(0, 800, 600, 75)
#define XGA_60HZ         MAKE_RESOLUTION(0, 1024, 768, 60) 
#define XGA_75HZ         MAKE_RESOLUTION(0, 1024, 768, 75)
#define SXGA_60HZ          MAKE_RESOLUTION(0, 1280, 1024, 60)
#define SXGA2_60HZ      MAKE_RESOLUTION(0, 1280, 960, 60)
#define _720P_24HZ      MAKE_RESOLUTION(0, 1280, 720, 24)
#define _720P_25HZ      MAKE_RESOLUTION(0, 1280, 720, 25)
#define _720P_30HZ      MAKE_RESOLUTION(0, 1280, 720, 30)  
#define _720P_60HZ      MAKE_RESOLUTION(0, 1280, 720, 60)
#define _720P_50HZ      MAKE_RESOLUTION(0, 1280, 720, 50) 
#define _1080I_60HZ     MAKE_RESOLUTION(1, 1920, 1080, 60)
#define _1080I_50HZ      MAKE_RESOLUTION(1, 1920, 1080, 50)
#define _1080P_60HZ     MAKE_RESOLUTION(0, 1920, 1080, 60)
#define _1080P_50HZ     MAKE_RESOLUTION(0, 1920, 1080, 50)
#define _1080P_30HZ     MAKE_RESOLUTION(0, 1920, 1080, 30)
#define _1080P_25HZ     MAKE_RESOLUTION(0, 1920, 1080, 25)
#define _1080P_24HZ     MAKE_RESOLUTION(0, 1920, 1080, 24)
#define UXGA_60HZ          MAKE_RESOLUTION(0, 1600, 1200, 60)
#define UXGA_30HZ          MAKE_RESOLUTION(0, 1600, 1200, 30)
#define WSXGA_60HZ         MAKE_RESOLUTION(0, 1680, 1050, 60)
#define WUXGA_60HZ      MAKE_RESOLUTION(0, 1920, 1200, 60)
#define WUXGA_30HZ         MAKE_RESOLUTION(0, 1920, 1200, 30)
#define WXGA_60HZ          MAKE_RESOLUTION(0, 1360, 768, 60)
#define SXGA_PLUS_60HZ    MAKE_RESOLUTION(0, 1400, 1050, 60)
#define VGA_MODE_3840x2160_30HZ MAKE_RESOLUTION(0, 3840, 2160, 30)
#define VGA_MODE_3840x2160_60HZ MAKE_RESOLUTION(0, 3840, 2160, 60)



//��ʾͨ������ָ�ģʽ
#define  MAX_WINDOWS_NUM 12        //����ָ�ģʽ������
#define  MAX_SUPPORT_RES 32
#define  MAX_DISPNUM_V41 32
#define  MAX_SDI_RES     16     //SDI��ʾͨ�����֧�ֱַ�����

typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//��ʾͨ�����ͣ�0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
    BYTE byDispChanSeq;//��ʾͨ�����,��1��ʼ�����������VGA�����ʾ�ڼ���VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;

typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//ͨ������
    BYTE  byStartChan;//��ʼͨ��
    BYTE  byRes[2];
    DWORD    dwSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֱַ���
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

//����ƴ����Ϣ
typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//������ƴ������
    BYTE  byStartBigScreenNum;//����ƴ����ʼ��
    BYTE  byMaxScreenX;//����ƴ��ģʽ
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//ͨ������
    BYTE  byStartChan;//��ʼͨ��
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//֧�ֱַ���
}NET_DVR_SDI_INFO,*LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP����  
    BYTE  byDecChanNums;//����ͨ����
    BYTE  byStartChan;//��ʼ����ͨ��
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//VGA��ʾͨ����Ϣ
    NET_DVR_DISPINFO struBncInfo;//BNC��ʾͨ����Ϣ
    NET_DVR_DISPINFO struHdmiInfo;//HDMI��ʾͨ����Ϣ
    NET_DVR_DISPINFO struDviInfo;//DVI��ʾͨ����Ϣ
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //�Ƿ�֧���Զ�������0-��֧�֣�1-֧��
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI��ʾͨ����Ϣ
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;

//��ʾͨ������
#define  MAX_WINDOWS                16
#define  MAX_WINDOWS_V41            36

#define  STARTDISPCHAN_VGA        1
#define  STARTDISPCHAN_BNC        9
#define  STARTDISPCHAN_HDMI        25
#define  STARTDISPCHAN_DVI        29

typedef union tagNET_DVR_VIDEO_PLATFORM
{
    BYTE byRes[160];
    struct
    {
        /*�����Ӵ��ڶ�Ӧ����ͨ������Ӧ�Ľ�����ϵͳ�Ĳ�λ��(������Ƶ�ۺ�ƽ̨�н�����ϵͳ��Ч)*/
        //����ۺ�ƽ̨֧���Զ����������Դ���˲�������Ҫ���
        BYTE    byJoinDecoderId[MAX_WINDOWS_V41];
        //��ʾ����������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ���ݴ˷ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ����������˽���ͨ��
        BYTE    byDecResolution[MAX_WINDOWS_V41];
        NET_DVR_RECTCFG struPosition; //��ʾͨ���ڵ���ǽ��λ��
        BYTE    byRes[80];
    }struVideoPlatform;
    struct
    {
        BYTE    byRes[160];
    }struNotVideoPlatform;
}NET_DVR_VIDEO_PLATFORM, LPNET_DVR_VIDEO_PLATFORM;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*��Ƶ�Ƿ���*/
    BYTE    byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE    byDispChanType;      /*��ʾͨ�����ͣ�0-BNC��1-VGA��2-HDMI��3-DVI��4-YPbPr(���뿨������DECODER_SERVERר��)*/   
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL��0-NULL*/
    DWORD    dwResolution;//�ֱ���
    DWORD    dwWindowMode;        /*����ģʽ����������ȡ*/       
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*�����Ӵ��ڹ����Ľ���ͨ��,�豸֧�ֽ�����Դ�Զ�����ʱ�˲����������*/
    BYTE    byEnlargeStatus;          /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�
    BYTE    byScale; /*��ʾģʽ��0---��ʵ��ʾ��1---������ʾ( ���BNC )*/
    BYTE    byUnionType;/*���ֹ�����,0-��Ƶ�ۺ�ƽ̨�ڲ���������ʾͨ�����ã�1-������������ʾͨ������*/
    NET_DVR_VIDEO_PLATFORM        struDiff;
    DWORD   dwDispChanNum; //��ʾ����ţ��˲�����ȫ����ȡʱ��Ч
    WORD     wLEDWidth;     //LED�ֱ��ʿ�0Ϊ��Ч   
    WORD     wLEDHeight;    //LED�ֱ��ʸߣ�0Ϊ��Ч
    BYTE      byEnableVideoEffect;  //��ʾЧ��ʹ�ܣ� 0-��ʹ�ܣ� !0-ʹ��
    BYTE      byRes[3];  //�����ֶ�
    NET_DVR_VIDEOEFFECT struVideoEffect;   //��ʾЧ��
    BYTE    byRes2[60];
}NET_DVR_MATRIX_VOUTCFG,*LPNET_DVR_MATRIX_VOUTCFG;

/*�������豸״̬*/
typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*��ʾ״̬��0��δ��ʾ��1��������ʾ*/
    BYTE  byBVGA;              /*0-BNC��1-VGA�� 2-HDMI��3-DVI��4-SDI 0xff-��Ч*/
    BYTE  byVideoFormat;     /*��Ƶ��ʽ��1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;       /*����ģʽ*/
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*�����ӻ�������Ľ���ͨ��*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*ÿ���ӻ������ʾ֡��*/
    BYTE  byScreenMode;        /*��Ļģʽ0-��ͨ 1-����*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*��ȡȫ����ʾͨ��״̬ʱ��Ч������ʱ����0*/
    BYTE  byRes2[24];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

/*�������豸״̬*/
typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*����ͨ��״̬*/
    /*��ʾͨ��״̬*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];     
    BYTE byAlarmInStatus[32];         /*��������״̬*/
    BYTE byAlarmOutStatus[32];       /*�������״̬*/
    BYTE byAudioInChanStatus;          /*�����Խ�״̬*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41,*LPNET_DVR_DECODER_WORK_STATUS_V41;
/*******************************�ļ��ط�-Զ�̻ط�����*******************************/
typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struIP;        /* DVR IP��ַ */    
    WORD    wDVRPort;            /* �˿ں� */    
    BYTE    byChannel;            /* ͨ���� */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* �û��� */
    BYTE    sPassword[PASSWD_LEN];        /* ���� */
    DWORD    dwPlayMode;       /* 0�����ļ� 1����ʱ��*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE    byRes[64];        /*����*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;


#define  MAX_BIGSCREENNUM_SCENE 100
#define  MAX_LAYERNUMS    32

//��ʾͨ�����ýṹ
typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; /*�������Ͻ���ʼ��X����*/
    WORD wYCoordinate; /*�������Ͻ�Y����*/
    WORD wWidth;       /*���ο��*/
    WORD wHeight;      /*���θ߶�*/
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{       
    BYTE    byEnable;//�Ƿ����ã�0-�����ã�1-����
    BYTE    bySoltNum;//��λ��
    BYTE    byRes1[2]; 
    BYTE    byDispChanNum; 
    BYTE    byAudio;                /*��Ƶ�Ƿ���,0-��1-��*/
    BYTE    byAudioWindowIdx;      /*��Ƶ�����Ӵ���*/
    BYTE    byVedioFormat;          /*1:NTSC,2:PAL��0-NULL*/
    BYTE    byWindowMode;            /*����ģʽ������������ȡ*/   
    BYTE    byEnlargeStatus;         /*�Ƿ��ڷŴ�״̬��0�����Ŵ�1���Ŵ�*/
    BYTE    byEnlargeSubWindowIndex;//�Ŵ���Ӵ��ں�    
    BYTE    byScale; /*��ʾģʽ��0-��ʵ��ʾ��1-������ʾ( ���BNC )*/
    DWORD   dwResolution;//�ֱ���
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*�����Ӵ��ڹ����Ľ���ͨ��*/
    BYTE    byJoinDecoderId[MAX_WINDOWS_V41];/*��λ��*/
    //��ʾ����������Ƶ�ֱ��ʣ�1-D1,2-720P,3-1080P���豸����Ҫ���ݴ�//�ֱ��ʽ��н���ͨ���ķ��䣬��1�������ó�1080P�����豸���4������ͨ����������˽���ͨ��
    BYTE    byDecResolution[MAX_WINDOWS_V41];
    BYTE    byRow;//�������ڵ��е����
    BYTE    byColumn;//�������ڵ��е����
    BYTE    byRes2[5];
    NET_DVR_RECTCFG struDisp; //����ǽ��ʾλ��
} NET_DVR_SCENEDISPCFG,*LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;                /* DVR IP��ַ */
    WORD     wDVRPort;                 /* �˿ں� */
    BYTE     byChannel;        /* ͨ���ţ�����9000���豸��IPC���룬ͨ���Ŵ�33��ʼ */
    BYTE    byTransProtocol;        /* ����Э������0-TCP��1-UDP ��2-MCAST��3-RTP*/
    BYTE    byTransMode;            /* ��������ģʽ 0�������� 1��������*/
    BYTE    byFactoryType;                /*ǰ���豸��������*/
    BYTE    byDeviceType;            //�豸���ͣ�1-IPC��2- ENCODER
    BYTE    byRes[5];
    BYTE    sUserName[NAME_LEN];    /* ���������½�ʺ� */
    BYTE    sPassword[PASSWD_LEN];    /* ����������� */
} NET_DVR_DEV_CHAN_INFO_SCENE,*LPNET_DVR_DEV_CHAN_INFO_SCENE;

/*��ý���������������*/
typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE    byValid;            /*�Ƿ�������ý�������ȡ��,0��ʾ��Ч*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR struDevIP;    /*��ý���������ַ*/
    WORD    wDevPort;            /*��ý��������˿�*/
    BYTE    byTransmitType;        /*����Э������0-TCP��1-UDP */
    BYTE    byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE,*LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE                            byEnable;    /* �Ƿ����� 0���� 1������*/
    BYTE                            byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    struStreamMediaSvrCfg;    
    NET_DVR_DEV_CHAN_INFO_SCENE            struDecChanInfo;    /*��Ѳ����ͨ����Ϣ*/
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE,*LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

//��Ѳ����ṹ
typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD    wPoolTime;        /*��ѯ���*/
    BYTE    byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE    struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE,*LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

//��������ͨ�����ýṹ��
typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE    byDecodeEnable;//������ͣ��־��0-ֹͣ��1-���ö�̬���룬2-������Ѳ����
    BYTE    bySlotNum;//��λ��
    BYTE    byDecChan;
    BYTE    byJointAllDecodeChan;        //�Ƿ�������ܽ���ͨ�� 0-��������1-����
    BYTE    byJointSlotNum;            //�����Ĳ�λ�ţ����ܽ����Ĳ�λ�ţ�
    BYTE    byJointChanNum;        //������ͨ���ţ����ܽ����ͨ���ţ�
    BYTE    byRes[2];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg; 
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE,*LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid; /*����ʹ�ܱ�־ */
    BYTE byAssociateBaseMap;//�����ĵ�ͼ��ţ�0��������
    BYTE byEnableSpartan;//��������ʹ�ܣ�1-����0-��
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;//�����ĸ��������ֵͨ����������ȡ
    BYTE  byRes1[3];
    WORD  wDecChanNums;//�����н���ͨ���ĸ���
    WORD  wDispChanNums;//��������ʾͨ���ĸ���
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//�������û�����, byBigScreenNums��sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;//����ͨ�����û�����, wDecChanNums��sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;//��ʾͨ�����û�����, wDispChanNums��sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;



typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;//ʹ�ܵ�ͼ��ʾ
    BYTE  byAssociateBaseMap;//�����ĵ�ͼ��ţ�0��������
    BYTE  byEnableSpartan;//��������ʹ�ܣ�1-����0-��
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;
/*******************************��������*******************************/
#define MAX_WIN_COUNT  224 //֧�ֵ���󿪴���

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD    dwSize;
    BYTE    byVaild;
    BYTE    byInputType;        //��CAM_MDOE
    WORD    wInputIdx;            /*����Դ����*/
    DWORD    dwLayerIdx;            /*ͼ�㣬0Ϊ��ײ�*/
    NET_DVR_RECTCFG  struWin;    //Ŀ�Ĵ���(�����ʾǽ)
    BYTE    byWndIndex;            //���ں�
    BYTE    byCBD;                //0-�ޣ�1-��������2-��������
    BYTE    bySubWnd;            //0���ǣ�1��
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//�豸���
    BYTE    byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD    dwSize;
    WORD    wScreenSeq;    //�豸���
    BYTE    byRes[10];
    DWORD    dwWinNum;    //�豸���صĴ�������
    BYTE    *pBuffer;    //������Ϣ�����������Ϊ224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;    //������ָ�볤��
}NET_DVR_WINLIST,*LPNET_DVR_WINLIST;

#define MAX_LAYOUT_COUNT 16        //��󲼾���
typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;                                //�����Ƿ���Ч
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];            //��������            
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];    //�����ڴ��ڲ���
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];   //���в���
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;

#define MAX_CAM_COUNT       224
#define MAX_CAM_COUNT_V50    512

typedef enum tagNET_DVR_CAM_MODE
{
    NET_DVR_UNKNOW  = 0,//��Ч
        NET_DVR_CAM_BNC,
        NET_DVR_CAM_VGA,
        NET_DVR_CAM_DVI,
        NET_DVR_CAM_HDMI,
        NET_DVR_CAM_IP,
        NET_DVR_CAM_RGB,
        NET_DVR_CAM_DECODER,
        NET_DVR_CAM_MATRIX,
        NET_DVR_CAM_YPBPR,
        NET_DVR_CAM_USB,
        NET_DVR_CAM_SDI,
        NET_DVR_CAM_HDI,
        NET_DVR_CAM_DP, //��������Ƶ�ۺ�ƽ̨������
        NET_DVR_CAM_HDTVI,
        NET_DVR_CAM_JOINT, //ƴ���ź�Դ
        NET_DVR_CAM_HDBASET,
        NET_DVR_CAM_DVIT, //DVI˫��·����������Ƶ�ۺ�ƽ̨������
        NET_DVR_CAM_FUSION, //��IPCƴ��
        NET_DVR_CAM_VSCREEN, //������
        NET_DVR_CAM_FIBER, //����
        NET_DVR_CAM_3GSDI, //3G-SDI
        NET_DVR_CAM_DISTRIBUTED_IP, //�ֲ�ʽ����Դ
        NET_DVR_CAM_JONIT_X86,// x86ƴ����ϵͳ��ƴ��ͨ��
        NET_DVR_CAM_TVI, //TVI�ź�Դ
}NET_DVR_CAM_MODE;

typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD    dwSize ;
    BYTE    byValid;
    BYTE    byCamMode;                        //�ź�����Դ���ͣ���NET_DVR_CAM_MODE
    WORD    wInputNo;                        //�ź�Դ���0-224
    BYTE    sCamName[NAME_LEN] ;            //�ź�����Դ����
    NET_DVR_VIDEOEFFECT struVideoEffect;    //��Ƶ����
    NET_DVR_PU_STREAM_CFG    struPuStream;    //ip����ʱʹ��
    WORD    wBoardNum ;                        //�ź�Դ���ڵİ忨��
    WORD    wInputIdxOnBoard;                //�ź�Դ�ڰ忨�ϵ�λ��
    DWORD   dwResolution;//�ֱ���
    BYTE    byVideoFormat;//��Ƶ��ʽ����VIDEO_STANDARD
    BYTE    byStatus;    //�ź�Դ״̬��0-�ֶ���Ч 1-���ź� 2-���ź� 3-�쳣 
    BYTE    sGroupName[NAME_LEN/*32*/];    //�����ź�Դ���� ����
    BYTE    byJointMatrix;            //  �������� ��0-������  1-����
    BYTE    byRes;  
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT]; //�����ź�Դ
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

/*******************************�����������*******************************/
/*���ͨ������*/
typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;        /*�������ģʽ,1-BNC,2-VGA,3-DVI,4-HDMI*/
    BYTE   byRes1[3];
    DWORD  dwResolution;    /*�ֱ��ʣ�������������ȡ��֧�ֵĽ�������*/
    NET_DVR_VIDEOEFFECT  struVideoEffect;    /*���ͨ����Ƶ��������*/
    BYTE    byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD    dwSize;
    BYTE    byScreenLayX;                        //��������-������
    BYTE    byScreenLayY;                        //��������-������
    WORD    wOutputChanNum;                    //���ͨ��������0��ʾ�豸֧�ֵ�������ͨ������������������������ȡ������ֵ��ʾʵ�����ͨ������
    BYTE    byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;    /*���ͨ����Ƶ��������*/
    BYTE    sWallName[16];                    //����ǽ����
    BYTE    byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

/*******************************������*******************************/
#define SCREEN_PROTOCOL_NUM      20    //֧�ֵ�������������Э����
//����������������
typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;               /*�ṹ����*/
    BYTE byIsSupportScreenNum; /*��֧�ִ�������������Ŀ*/
    BYTE bySerialNums;            //���ڸ���
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//��������-�������������
    BYTE byMaxScreenLayY;//��������-��������������
    WORD wMatrixProtoNum; /*��Ч�Ĵ���Э����Ŀ*/
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];/*���Э���б�*/
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

//����������������
typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;           /*�ṹ����*/
    BYTE byLayoutNum;         /* ���ָ���*/
    BYTE byWinNum;             /*��Ļ���ڸ���*/
    BYTE byOsdNum;          /*OSD����*/
    BYTE byLogoNum;         /*Logo����*/
    BYTE byInputStreamNum;  //����Դ���� ---�豸֧���������ͨ��������������������Դ����������Դ��
    BYTE byOutputChanNum;    //���ͨ������---�豸֧��������ͨ������
    BYTE byCamGroupNum;        /*�������*/
    BYTE byPlanNum;            /*Ԥ������*/
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  /*�Ƿ�֧�ֻط�*/    
    BYTE byMatrixInputNum;  //֧���������������
    BYTE byMatrixOutputNum; //֧���������������
    NET_DVR_DISPINFO struVgaInfo;//VGA�����Ϣ
    NET_DVR_DISPINFO struBncInfo;//BNC�����Ϣ
    NET_DVR_DISPINFO struHdmiInfo;//HDMI�����Ϣ
    NET_DVR_DISPINFO struDviInfo;//DVI�����Ϣ
    BYTE byMaxUserNums;//֧���û���
    BYTE byPicSpan;        //��ͼ��ȣ�һ�ŵ�ͼ���ɸ��ǵ���Ļ��
    WORD wDVCSDevNum;    //�ֲ�ʽ��������������豸��
    WORD wNetSignalNum;    //�����������Դ����
    WORD wBaseCoordinateX;//��׼����
    WORD wBaseCoordinateY; 
    BYTE byExternalMatrixNum;    //�����Ӿ������
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

/*******************************�����ź�״̬*******************************/
typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD    dwLostFrame;        /*��Ƶ���붪֡��*/
    BYTE    byHaveSignal;        /*�Ƿ�����Ƶ�ź�����*/
    BYTE    byVideoFormat;        /*��Ƶ��ʽ��1��NTSC,2��PAL,0����*/
    BYTE    byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;

typedef union tagNET_DVR_INPUTSTATUS_UNION
{
    NET_DVR_MATRIX_CHAN_STATUS struIpInputStatus;
    NET_DVR_ANALOGINPUTSTATUS struAnalogInputStatus;
} NET_DVR_INPUTSTATUS_UNION, *LPNET_DVR_INPUTSTATUS_UNION;

typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD    wInputNo;        /*�ź�Դ���*/
    BYTE    byInputType;    //��NET_DVR_CAM_MODE
    BYTE    byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE    byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwNums;        //�豸���ص�����Դ״̬������
    BYTE    *pBuffer;    //������
    DWORD   dwBufLen;    //������ָ�볤�ȣ��������
}NET_DVR_SCREENINPUTSTATUS,*LPNET_DVR_SCREENINPUTSTATUS;

typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD    dwSize;
    BYTE    byAlarmType;    //�������ͣ�1-�Ӱ�γ���2-�Ӱ���룬3-��ϵͳ״̬�쳣��4-��ϵͳ�ָ��ָ� 5-����Դ�쳣   6-�¶ȱ��� 7-FPGA�汾��ƥ�� 8-Ԥ����ʼ 9-Ԥ������ 10-�������� 11-�����IP��ַ��ͻ��12-�����쳣
    BYTE    byBoardType;    // 1-����� 2-����� ��3-���壬4-���壬��������Ϊ1��2��3��6��ʱ��ʹ�� 
    BYTE    bySubException;    //�����쳣ʱ�������쳣 1- �ֱ��������ı� 2-����˿����͸ı�3-�ֱ��ʴ���4-�ֱ��ʸı䵼�½�����Դ���㣬�رո�����Դ��Ӧ���ڡ�5-�ֱ��ʸı䣬�����ѿ��������ű�������1/8��8����Χ��6-�ֱ��ʻָ�����,7-�ֱ��ʸı䵼�����������������,�豸�رմ��� 
    BYTE    byRes1;
    WORD    wStartInputNum; // �쳣����Դ���쳣��㣩 
    WORD    wEndInputNum;    // �쳣����Դ���쳣�յ㣩 
    BYTE    byRes2[16];       
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;                //�ж��Ƿ���ģ������Ƿ���Ч��
    BYTE  byCommandProtocol;    //ģ������ָ�4�֣�
    BYTE  byScreenType;            //����    
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];    //ģ�������������Ļ�Ķ�Ӧ��ϵ
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;/*�豸Ϊ�����豸ʱ��IP��Ϣ*/
    WORD            wPort;        //ͨ����
    BYTE            byRes[26];  //����
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;
typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE    byDevSerPortNum;   /*�����豸�Ĵ��ں�*/
    BYTE    byScreenSerPort;  /*���Ӵ����Ĵ��ں�*/
    BYTE    byRes[130];   
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;

typedef union tagNET_DVR_SCREEN_UNION
{
    NET_DVR_DIGITALSCREEN struDigitalScreen;
    NET_DVR_ANALOGSCREEN struAnalogScreen;
}NET_DVR_SCREEN_UNION, *LPNET_DVR_SCREEN_UNION;
typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;                //�Ƿ���Ч
    BYTE nLinkMode;                //���ӷ�ʽ��0-���ڣ�1-����
    BYTE byDeviceType;            //�豸�ͺţ���������ȡ
    BYTE byScreenLayX;            //��������-������
    BYTE byScreenLayY;            //��������-������
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];    /*��¼�û���*/
    BYTE sPassword[PASSWD_LEN]; /*��¼����*/   
    BYTE sDevName[NAME_LEN];    /*�豸����*/
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;            // ����Դ����
    BYTE byOutputNum;            // ���Դ����
    BYTE byCBDNum;                //CBD����
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

/*******************************��ͼ�ϴ�*******************************/
typedef struct tagNET_DVR_BASEMAP_CFG
{    
    BYTE byScreenIndex;         //��Ļ�����
    BYTE byMapNum;                /*���ָ���˶��ٿ� */
    BYTE res[2];
    WORD wSourWidth;            /* ԭͼƬ�Ŀ�� */
    WORD wSourHeight;            /* ԭͼƬ�ĸ߶� */
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;


typedef struct tagNET_DVR_PICCFG
{
    DWORD    dwSize;        //��С
    BYTE    byUseType;    //1-��ͼ��2-GIFͼƬ��3-CADͼƬ 4-�����ͼƬ
    BYTE    bySequence;//���  
    BYTE    byOverlayEnabled; //ͼƬ����ʹ�ܣ��Ƿ����ϴ�ͼƬ����ͼƬ���Ӳ��� 1-�������Ӳ�����0-������
    BYTE    byRes[1];
    NET_DVR_BASEMAP_CFG    struBasemapCfg;
    BYTE    sPicName[NAME_LEN];//ͼƬ����
    DWORD   dwVideoWall;       //ǽ�ţ�1�ֽ�ǽ�ţ����ں���������ֵ�̶�Ϊ1���ɣ�+1�ֽ�ͨ�����+2�ֽڴ��ںţ�
    BYTE   	byFlash; //ͼƬ��˸ʹ�ܣ�1-��˸��0-����˸
    BYTE   	byTranslucent; //ͼƬ��͸��ʹ�ܣ�1-��͸����0-����͸��
    BYTE    byShowEnabled; //ͼƬ��ʾʹ�ܣ�1-��ʾ��0-����
    BYTE    byPictureType; //ͼƬ���ͣ�1-bmp��2-jpg��3-png������
    BYTE    byRes2[24];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;

/*******************************OSD*******************************/
#define MAX_OSDCHAR_NUM 256
typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*�Ƿ���Ч 0��Ч 1��Ч*/
    BYTE    byDispMode;  //��ʾģʽ��1-͸����2-��͸����3-��������ģʽ
    BYTE    byFontColorY; /*������ɫY,0-255*/
    BYTE    byFontColorU; /*������ɫU,0-255*/
    BYTE    byFontColorV; /*������ɫV,0-255*/
    BYTE    byBackColorY; /*������ɫY,0-255*/
    BYTE    byBackColorU; /*������ɫU,0-255*/
    BYTE    byBackColorV; /*������ɫV,0-255*/
    WORD    wXCoordinate;   /*OSD����Ļ���Ͻ�λ��x*/
    WORD    wYCoordinate;   /*OSD����Ļ���Ͻ�λ��y*/
    WORD    wWidth;       /*OSD���*/
    WORD    wHeight;      /*OSD�߶�*/
    DWORD   dwCharCnt;     /*�ַ��ĸ���*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM];       /*OSD�ַ�����*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;


/*******************************��ȡ������Ϣ*******************************/
typedef struct tagNET_DVR_SERIAL_CONTROL
{ 
    DWORD    dwSize ;
    BYTE    bySerialNum;        // ���ڸ���
    BYTE    byRes1[3];
    BYTE    bySerial[32];
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;

/*******************************��Ļ����*******************************/
//��Ļ����Դ����
typedef enum tagINPUT_INTERFACE_TYPE
{
    INTERFACE_VGA = 0,
        INTERFACE_SVIDEO, // 2046NL��֧�֣�2046NH֧��
        INTERFACE_YPBPR,
        INTERFACE_DVI ,
        INTERFACE_BNC , 
        INTERFACE_DVI_LOOP,//(��ͨ) 2046NH��֧�֣�2046NL֧��
        INTERFACE_BNC_LOOP, //(��ͨ) 2046NH��֧�֣�2046NL.֧��
        INTERFACE_HDMI,
        INTERFACE_IP,
        INTERFACE_USB,
        INTERFACE_SDI,
        INTERFACE_DP,
        INTERFACE_HDBASET
}INPUT_INTERFACE_TYPE;
typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE    byInputSourceType;    //��INPUT_INTERFACE_TYPE
    BYTE    byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;
//��ʾ��Ԫ��ɫ����
typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE    byColorType;        //1-���� 2-�Աȶ� 3-���Ͷ� 4-������
    char    byScale;            //-1 ��0��+1����ֵ
    BYTE    byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;
//��ʾ��Ԫλ�ÿ���
typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE    byPositionType;    //1-ˮƽλ�� 2-��ֱλ�ã�
    char    byScale;            //-1 ��0��+1����ֵ
    BYTE    byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;


/*******************************��Ļ����V41*******************************/
typedef struct tagNET_DVR_RECTCFG_EX 
{
    DWORD dwXCoordinate; /*�������Ͻ���ʼ��X����*/
    DWORD dwYCoordinate; /*�������Ͻ�Y����*/
    DWORD dwWidth;       /*���ο��*/
    DWORD dwHeight;      /*���θ߶�*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;

/*******************************Ԥ������*******************************/
#define        MAX_PLAN_ACTION_NUM     32     //Ԥ����������
#define        DAYS_A_WEEK                7    //һ��7��
#define        MAX_PLAN_COUNT            16    //Ԥ������


typedef enum
{
    NET_DVR_SWITCH_LAYOUT = 1,         // �����л� Ĭ��
        NET_DVR_SCREEN_POWER_OFF,          // �رմ���Ļ��ʾ
        NET_DVR_SCREEN_POWER_ON,           // �򿪴���Ļ��ʾ
        NET_DVR_SWITCH_BASEMAP            //��ͼ�л�
}NET_DVR_PLAN_OPERATE_TYPE;

/*Ԥ������Ϣ*/
typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE      byValid;          // �����Ƿ���Ч
    BYTE      byType;           // ������NET_DVR_PLAN_OPERATE_TYPE
    WORD      wLayoutNo;      // ���ֺ�
    BYTE    byScreenStyle;    //��Ļ�ͺţ����ػ����ã�1�ǵ�����2�Ǹ���
    BYTE  byBaseMapType;  //��ͼ���ͣ�1-ͼƬ��ͼ��2-�����������ͼ����ͼ�л�ʱ��Ч
    BYTE  byRes1[2];
    DWORD      dwDelayTime;      // һ���������ʱ��, ��λ��
    DWORD   dwSerialNo;        //���ںţ���Ļ����ʱʹ��
    DWORD  dwBaseMapWndNo; //��ͼ���ںţ���ͼ�л�ʱ��Ч
    DWORD  dwBaseMapNo;   //��ͼ�ţ���ͼ�л�ʱ��Ч����ͼ����Ϊ1ʱ���˲���ΪͼƬ��ţ���ͼ����Ϊ2ʱ�˲���Ϊ������������ϵͳ����ţ�1�ֽ��豸��+1�ֽ��Ӱ��+2�ֽ���ʾ������ţ�
    BYTE    byRes2[20];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;

typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE    byValid; 
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;
/*Ԥ������*/
typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD     dwSize;
    BYTE      byValid;          // ��Ԥ���Ƿ���Ч
    BYTE      byWorkMode;      // Ԥ������ģʽ 1��ʾ�ֶ���2�Զ���3Ԥ��ѭ��
    BYTE    byWallNo;        //����ǽ�ţ���1��ʼ
    BYTE    byPlanNo;    //Ԥ���ţ���ȡԤ���б�ʱ��Ч��0-��Ч��֧��
    BYTE      byPlanName[NAME_LEN/*32*/]; //Ԥ������
    NET_DVR_TIME_EX struTime; // ����ģʽΪ�Զ�ʱʹ��
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*ѭ��ʱ�䣬����Ϊһ�����ڣ��ꡢ�¡�������������ʹ�á��磺struTimeCycle[0]�е�byValid��ֵ��1����ʾ������ִ�и�Ԥ��������ȡֵ����Ϊ[0,6]������0���������죬1��������һ���Դ�����*/
    DWORD     dwWorkCount;      // Ԥ������ִ�д���
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // Ԥ��ִ�е�����
    DWORD		dwPlanNo; //4�ֽ�Ԥ���ţ��ͻ���ͳһʹ��4�ֽڵ�Ԥ���ţ����ֽڵ�Ԥ���Ų���ʹ��
    BYTE		byRes2[60];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;


/*******************************��ȡ�豸״̬*******************************/
/*Ԥ���б�*/
typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD        dwSize;
    DWORD        dwPlanNums;            //�豸�����ź�Դ����
    BYTE          *pBuffer;            //ָ��dwInputSignalNums��NET_DVR_PLAN_CFG�ṹ��С�Ļ�����
    BYTE        byWallNo;            //ǽ�ţ���1��ʼ
    BYTE        byRes1[2];
    DWORD         dwBufLen;            //�����仺�������ȣ�������������ڵ���dwInputSignalNums��NET_DVR_PLAN_CFG�ṹ��С��
    BYTE        byRes2[64];
} NET_DVR_PLAN_LIST,*LPNET_DVR_PLAN_LIST;


/*******************************Ԥ������*******************************/
//�ýṹ�����Ϊͨ�ÿ��ƽṹ��
typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD    dwSize;
    BYTE    sDeviceID[NAME_LEN]; //�����豸���豸ID
    WORD    wChan;                 //����ͨ��
    BYTE    byIndex;             //������������������ȷ�������ʾʲô����
    BYTE    byRes1;
    DWORD    dwControlParam;
    BYTE    byMandatoryAlarm;    //1-ʹ��  0-��ʹ��
    BYTE      byRes2;
    WORD     wZoneIndex;            //������
    BYTE      byOperatorCode[16];   //�ؿ���
    DWORD	dwPlanNo; //4�ֽ�Ԥ���ţ��ͻ���ͳһʹ��4�ֽڵ�Ԥ���ţ����ֽڵ�Ԥ���Ų���ʹ��
    BYTE	byRes3[8];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

/*******************************��ȡ�豸״̬*******************************/
typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD 	dwSize;
    DWORD   dwMemoryTotal;		    //�ڴ���������λKbyte
    DWORD	dwMemoryUsage;		    //�ڴ�ʹ��������λKbyte
    BYTE	byCPUUsage;			    //CPUʹ���ʣ�0-100
    BYTE    byMainFrameTemp;   	    //�����¶ȣ���λ�����϶�
    BYTE    byBackPanelTemp;    	//�����¶ȣ���λ�����϶�
    BYTE    byRes1;
    BYTE    byLeftDecResource[32];	//�������ʣ�������Դ���Խ�D1�ֱ�����ԴΪ��λ��byLeftDecResource[i],��ʾ��λ��i�����ʣ����Դ��0xff��ʾ��Ч���ǽ�����û����ӣ�
    float	fNetworkFlow; 		    //������������λ��KB/s����һ����������С�������λ
    BYTE	byRes2[88];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

// 91ϵ��HD-SDI����DVR �����Ϣ
typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;
       char  sCameraInfo[32];        // ǰ�������Ϣ
    BYTE  byInterfaceType;        // ǰ�˽���ӿ����ͣ�1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
       BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //��Ƶ�������ͣ�0-mic in��1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter; //�Ƿ�����������-�أ�-��
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-�����ã�1-�Զ�ģʽ��2-��
    BYTE byLevel; //�ȼ���0-100
    BYTE byRes[6]; 
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD        dwSize;
    DWORD        dwInputSignalNums;    //�豸�����ź�Դ����
    BYTE          *pBuffer;            //ָ��dwInputSignalNums��NET_DVR_INPUTSTREAMCFG�ṹ��С�Ļ�����
    BYTE        byRes1[3];
    DWORD         dwBufLen;            //�����仺�������ȣ�������������ڵ���dwInputSignalNums��NET_DVR_INPUTSTREAMCFG�ṹ��С��
    BYTE        byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST,*LPNET_DVR_INPUT_SIGNAL_LIST;

// ��ȫ����״̬
#define PULL_DISK_SUCCESS        1   // ��ȫ���̳ɹ�
#define PULL_DISK_FAIL            2   // ��ȫ����ʧ��
#define PULL_DISK_PROCESSING    3   // ����ֹͣ����
#define PULL_DISK_NO_ARRAY         4    // ���в����� 
#define PULL_DISK_NOT_SUPPORT    5     // ��֧�ְ�ȫ����

// ɨ������״̬
#define SCAN_RAID_SUC            1     // ɨ�����гɹ�
#define SCAN_RAID_FAIL            2     // ɨ������ʧ��
#define SCAN_RAID_PROCESSING    3    // ����ɨ������
#define SCAN_RAID_NOT_SUPPORT    4     // ��֧������ɨ��

// ����ǰ���������״̬
#define SET_CAMERA_TYPE_SUCCESS            1   // �ɹ�
#define SET_CAMERA_TYPE_FAIL            2   // ʧ��
#define SET_CAMERA_TYPE_PROCESSING        3   // ���ڴ���

//9000 2.2
typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD    dwSize;    //�ṹ���С
    BYTE    byType;    //0 ��������Ƶ¼��, 1ͼƬͨ��¼��, 2ANRͨ��¼��, 3��֡ͨ��¼��
    BYTE     byRes[63]; //����
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD          dwSize;        //�ṹ���С
    NET_DVR_TIME  strBeginTime;  //��ʼʱ��
    NET_DVR_TIME  strEndTime;    //����ʱ��
    BYTE          byType;        //0 ��������Ƶ¼��, 1ͼƬͨ��¼��, 2ANRͨ��¼��, 3��֡ͨ��¼��
    BYTE           byRes[35];     //����
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;                    //�ṹ���С
    BYTE     byPicQuota;                //ͼƬ�ٷֱ�     [0%,  30%]
    BYTE     byRecordQuota;                //��ͨ¼��ٷֱ� [20%, 40%]
    BYTE     byDrawFrameRecordQuota;    //��֡¼��ٷֱ� [30%, 80%]
    BYTE     byRes[61];                    //�����ֽ�
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //�ö˿��Ƿ�ʹ��ӳ��
    WORD wExtPort;        //ӳ����ⲿ�˿ں�
    BYTE byRes[12];       //����
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //�ṹ���С
    WORD wEnableUpnp;     //UPNP�����Ƿ�����
    WORD wEnableNat;        //UPNP�˿�ӳ�䣨NAT�������Ƿ�����(��������wEnableUpnp����һ��)
    NET_DVR_IPADDR  struIpAddr;      //NAT·����LAN IP��ַ
    NET_DVR_NAT_PORT    struHttpPort;   //web server http�˿�ӳ������
    NET_DVR_NAT_PORT    struCmdPort; //����˿�ӳ������(8000)
    NET_DVR_NAT_PORT    struRtspPort;  //rtsp�˿�ӳ������
    BYTE byFriendName[64]; //������
    BYTE byNatType; //UPNP�˿�ӳ�����ͣ�0-�ֶ���1-�Զ�
    BYTE            byRes1[3];    //����
    NET_DVR_NAT_PORT    struHttpsPort;     //https�˿�ӳ������
    NET_DVR_NAT_PORT    struSDKOverTLSPort;  //SDKOverTLS�˿�ӳ������
    NET_DVR_NAT_PORT    struRtspsPort;  //Rtsps�˿�ӳ������
    BYTE                byres[44];    //����
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;

typedef struct
{
    DWORD  dwEnabled;               //�ö˿��Ƿ�ʹ��ӳ��
    WORD   wInternalPort;           //ӳ��ǰ�Ķ˿�
    WORD   wExternalPort;           //ӳ���Ķ˿�
                                    DWORD  dwStatus;                 /*�˿�ӳ��״̬
                                                                     0 δ��Ч
                                                                     1 δ��Ч��ӳ��Դ�˿���Ŀ�Ķ˿���һ��
                                                                     2 δ��Ч:  ӳ��˿ں��ѱ�ʹ��
                                                                     3 ��Ч
                                    */
                                    NET_DVR_IPADDR    struNatExternalIp;       //ӳ�����ⲿ��ַ
                                    NET_DVR_IPADDR    struNatInternalIp;       //NAT·����LAN IP��ַ
                                    BYTE   byRes[16];               //����
}NET_DVR_UPNP_PORT_STATE, *LPNET_DVR_UPNP_PORT_STATE;


typedef struct
{
    NET_DVR_UPNP_PORT_STATE strUpnpPort[UPNP_PORT_NUM];     //�˿�ӳ��״̬,����0 web server�˿� ����1 ����˿� ����2 rtsp�˿�
    BYTE   byRes[200];              //����
}NET_DVR_UPNP_NAT_STATE, *LPNET_DVR_UPNP_NAT_STATE;

typedef struct tagNET_DVR_PLAYCOND
{
    DWORD             dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE             byDrawFrame;  //0:����֡��1����֡
    BYTE             byStreamType ; //�������ͣ�0-������ 1-������ 2-������
    BYTE             byStreamID[STREAM_ID_LEN];
    BYTE             byCourseFile;    //�γ��ļ�0-��1-��
    BYTE             byDownload;    //�Ƿ����� 0-��1-��
    BYTE             byOptimalStreamType;    //�Ƿ������������ͻط� 0-��1-�ǣ�����˫�����豸��ĳһ��ʱ���ڵ�¼���ļ���ָ���������Ͳ�ͬ���򷵻�ʵ���������͵�¼��
    BYTE             byVODFileType; // ����¼���ļ����ļ���ʽ 0-PS������ʽ��1-3GP��ʽ 
    BYTE             byRes[26];    //����
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //�������� 0-ȫ����1-��ѯ�� 2-ȡ� 3-�� 4-�޸����룬5-ת�ˣ� 6-�޿���ѯ 7-�޿��� 8-�̳� 9-�̿� 10-�Զ���
    BYTE    byRes[3] ;    //����
    DWORD  dwTransationAmount ;     //���׽�� ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO ;

typedef union  tagNET_DVR_SPECIAL_FINDINFO_UNION
{
    BYTE  byLenth[8] ;
    NET_DVR_ATMFINDINFO      struATMFindInfo;           //ATM��ѯ
}NET_DVR_SPECIAL_FINDINFO_UNION, *LPNET_DVR_SPECIAL_FINDINFO_UNION;


typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;/*��������¼���ļ�����0xff-ȫ����0-��ʱ¼��1-�ƶ���⣬2-����������3-�����������ƶ���⣬4-�����������ƶ���⣬5-�������6-�ֶ�¼��
    7-����¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼���15-Խ����⣬16-�������֣�17-�����쳣��18-���������⣬19-������⣨Խ�����|��������|�������|�����쳣|���������⣩��
    20-������⣬ 21-�ź�����22-�ش���23-��Ǩ¼��24-�ڵ���25-pos¼��26-�����������, 27-�뿪�������,28-�ǻ����,29-��Ա�ۼ����,30-�����˶����,31-ͣ�����,32-��Ʒ�������,33-��Ʒ��ȡ���, 
    34-�����⣬35-���ƻ���⣬36-��ֻ��⣬37-����Ԥ��,38-���±���,39-��ܶ�Ź������40-�����⣬41-�˯��⣬42-�²����43-���߲��±���,44-����������45-��������,46-ҵ����ѯ,47-������,48-�����ʸ�,49-��޳�ʱ��50-���ܼ�⣬51-������⣬52-����ץ��, 53-�Ƿ���̯, 54-Ŀ��ʶ��,
    55-�����˶���56-��ڼ�⣬57-������58-�����仯��59-Υͣ, 60-����,61-ѹ��,62-��ռ��,63-���,64-��ͷ,65-���˼��,66-·��,67-������,68-Ũ����,69-ʩ��,70-ӵ��,71-��ͨ�¹ʼ��, 72-�෽ͣ����73-�ֶ���������,74-��ͨΥ�£�75-��ɳ����ⱨ�� 76-�����ŷż��77-�Ҷȱ���
*/
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;//�Ƿ��ATM��Ϣ���в�ѯ��0-����ATM��Ϣ��1-�����׿��Ų�ѯ��2-���������Ͳ�ѯ��3-�����׽���ѯ��4-�����š��������ͼ����׽�����ϲ�ѯ 5-���γ����Ʋ��ң���ʱ���ű�ʾ�γ�����
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0:����֡��1����֡
    BYTE        byFindType; //0:��ѯ��ͨ��1����ѯ�浵��
    BYTE        byQuickSearch; //0:��ͨ��ѯ��1�����٣���������ѯ
    BYTE        bySpecialFindInfoType ;    //ר�в�ѯ�������� 0-��Ч�� 1-��ATM��ѯ����  
    DWORD       dwVolumeNum;  //�浵���
    BYTE        byWorkingDeviceGUID[GUID_LEN];    //������GUID��ͨ����ȡN+1�õ�
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo ;   //ר�в�ѯ����
    BYTE        byStreamType;    //0-ͬһ��ʱ���ֻ����һ��¼�����ȼ�˳��Ϊ��������������������������1-��������2-��������3-��������254-˫��������(���ȷ���������¼��û��������¼��ʱ����������¼��)
    BYTE        byAudioFile;                //��Ƶ�ļ� 0-����Ƶ�ļ���1-��Ƶ�ļ�
    BYTE        byRes2[30];    //����
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

//¼���ļ����������ṹV50
typedef struct tagNET_DVR_FILECOND_V50
{
    NET_DVR_STREAM_INFO struStreamID; //��ID��ͨ����
    NET_DVR_TIME_SEARCH_COND    struStartTime; //��ʼʱ��
    NET_DVR_TIME_SEARCH_COND    struStopTime; //����ʱ��
    BYTE  byFindType; //0-��ѯ��ͨ��1-��ѯ�浵�� 2-��ѯN+1¼���ļ�
    BYTE  byDrawFrame; //�Ƿ��֡ 0-����֡ 1-��֡
    BYTE  byQuickSearch; //0-��ͨ��ѯ��1-���٣���������ѯ
    BYTE  byStreamType; //0-��������1-��������2-3������0xff-ȫ��
    DWORD  dwFileType; // �ļ�����
    DWORD  dwVolumeNum; //�浵��ţ�byFindTypeΪ1ʱ��Ч
    BYTE  byIsLocked; //�Ƿ����� 0-�����ļ�,1-�����ļ�, 0xff��ʾ�����ļ�
    BYTE  byNeedCard; //�Ƿ���Ҫ��ѯ����0-����Ҫ 1-��Ҫ
    BYTE  byOnlyAudioFile;        //��Ƶ�ļ� 0-��Ƶ�ļ� 1-��Ƶ�ļ�
    BYTE  bySpecialFindInfoType; //0-��Ч�� 1-��ATM��ѯ����
    char  szCardNum[32];  //���ţ�byNeedCardΪ1ʱ��Ч
    char    szWorkingDeviceGUID[16]; //������GUID��ͨ����ȡN+1�õ���byFindTypeΪ2ʱ��Ч
    NET_DVR_SPECIAL_FINDINFO_UNION    uSpecialFindInfo; //ר�в�ѯ����������
    BYTE                              byRes[256];
}NET_DVR_FILECOND_V50, *LPNET_DVR_FILECOND_V50;

typedef struct 
{
    BYTE    sAESKey[16];        /*����������Կ*/
    BYTE    byRes[64];          /*�����ֽ�*/
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;

typedef struct
{
    NET_DVR_IPADDR struIP;     //IP��ַ
    BYTE  byRes[128]; //����
}NET_DVR_POE_CFG, *LPNET_DVR_POE_CFG;

#define MAX_PRO_PATH         256    //���Э��·������

typedef struct
{
    DWORD dwSize;              //�ṹ���С
    DWORD dwEnabled;           //�Ƿ����ø�Э��0 ������ 1 ����
    char  sProtocalName[DESC_LEN];   //�Զ���Э������, 16λ
    BYTE  byRes1[64];          //����,����Э��������չ
    DWORD dwEnableSubStream;   //�������Ƿ�����0 ������ 1 ����
    
    BYTE  byMainProType;        //������Э������ 1 RTSP
    BYTE  byMainTransType;        //�������������� 0��Auto 1��udp 2��rtp over rtsp
    WORD  wMainPort;           //�������˿�    
    char  sMainPath[MAX_PRO_PATH];  //������·��
    
    BYTE  bySubProType;         //������Э������ 1 RTSP
    BYTE  bySubTransType;        //�������������� 0��Auto 1��udp 2��rtp over rtsp
    WORD  wSubPort;            //�������˿�
    char  sSubPath[MAX_PRO_PATH];   //������·�� 
    
    BYTE  byRes2[200];          //����
}NET_DVR_CUSTOM_PROTOCAL, *LPNET_DVR_CUSTOM_PROTOCAL;


//B10��֧��PSIA�豸
//ѭ����ǽ�ṹ�壨ʵʱ��
typedef struct  
{
    DWORD    dwEnable; /* �Ƿ����� 0���� 1������*/
    BYTE    byType; //�豸���� 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    BYTE    byRes[3];  //����
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg; 
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; /* ��ѭ����ͨ����Ϣ */
    BYTE    sRtspUrl[128];//����ַ
}NET_DVR_MATRIX_CHAN_INFO_EX,*LPNET_DVR_MATRIX_CHAN_INFO_EX;

typedef struct
{
    DWORD    dwSize;
    DWORD    dwPoolTime;    /*��ѯ���*/
    NET_DVR_MATRIX_CHAN_INFO_EX        struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE    byRes[16];
}NET_DVR_MATRIX_LOOP_DECINFO_EX,*LPNET_DVR_MATRIX_LOOP_DECINFO_EX;

//ʵʱԤ����ǽ�ṹ��
typedef struct
{
    DWORD dwSize;
    BYTE byType; //�豸���� 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME 3:DEV_OTHERES
    BYTE byRes[3]; //����
    NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO struDevChanInfo;
    BYTE sRtspUrl[128];//����ַ
}NET_DVR_PU_STREAM_CFG_EX,*LPNET_DVR_PU_STREAM_CFG_EX;

typedef struct tagNET_DVR_MATRIX_TRUNKCFG
{
    DWORD     dwGlobalIndex;  //����
    DWORD     dwInterIndex;   //����ȫ�ֱ��
    BYTE      sTrunkName[NAME_LEN];
    BYTE      byType;   //�豸����1-bnc, 2-SP3, 3-V6
    BYTE      byDir;   //���߷��� 1-����2-���
    BYTE      byAbility;   //����������D1����
    BYTE      bySubsys;   //��ϵͳID
    BYTE      byChan;     //ͨ��ID
    BYTE      byRes[255];     //Ԥ��
} NET_DVR_MATRIX_TRUNKCFG,*LPNET_DVR_MATRIX_TRUNKCFG;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//����״̬��0-û�й�����1-�Ѿ�������ͨ�������ֶ��жϱ��Լ�������������ϵͳ������2-��ռ�ã�byDecodeAbility����1ʱ��Ч��3-����������������4-��������������
    BYTE        byJoinSubSystem;// ��������ռ�õ���ϵͳ��λ��
    BYTE        byJoinDispNum;// ��������ռ�õ���ʾͨ����
    BYTE        byJoinSubWindowNum;// ��������ռ�õ��Ӵ��ں�
    BYTE        byDecodeAbility;   //����ͨ���ĵ�ǰ����������0-δ������1-D1��2-720��3-1080
    BYTE        byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-V6������ϵͳ��9-V6��ϵͳ��0-NULL���˲���ֻ�ܻ�ȡ��*/
    BYTE    bySubSystemType; 
    BYTE    byConnectStatus;//����ϵͳ����״̬��1-����������2-���ӶϿ�
    BYTE    byMatrixNum;//������Ƶ�ۺ�ƽ̨�ţ���ϵͳ������3��4ʱ����
    BYTE    bySubSystemNum;//������ϵͳ��λ�ţ���ϵͳ������3��4ʱ����
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE    byBindStatus;//��״̬��0-û�а󶨣�1-�Ѿ��󶨣�����ƴ��ʱ�õ���
    BYTE    bySlotNum ;//��λ�ţ��˲���ֻ�ܻ�ȡ
    BYTE    byUsedTrunk;//�Ƿ񱻸���ʹ�ã�0-δ��ʹ�ã�1-��ʹ��
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;

//////////��ϵͳ����/////////////
#define MAX_ALARMHOSTKEYBOARD 64 //���籨��������������
typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //������ϵͳ�ţ���λ��ʾ��bit0��ʾ�ù�����ϵͳ������ϵͳ1.
    DWORD    dwJointSubSystem;
    BYTE    byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //��ʾ����Щ������ϵͳ��������λ��ʾ��bit0 ��ʾ������ϵͳ.��������������ϵͳ1
    DWORD    dwBeJoinedSubSystem;
    BYTE    byRes[16];    
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;

typedef union tagNET_DVR_JOINT_SUB_SYSTEM
{
    // byPublicAttributeEnableΪ0ʱʹ�øñ���
    NET_DVR_NOAMAL_SUB_SYSTEM     struNormalSubSystem;
    //byPublicAttributeEnableΪ1ʱʹ�øñ���
    NET_DVR_PUBLIC_SUB_SYSTEM        struPublicSubSystem;
    BYTE    byRes[20];    
}NET_DVR_JOINT_SUB_SYSTEM,*LPNET_DVR_JOINT_SUB_SYSTEM;

#define MAX_SUBSYSTEM_ID_LEN 16 //��ϵͳID��󳤶�

//////////GPRS��������/////////////
#define    ACCOUNTNUM_LEN             6
#define ACCOUNTNUM_LEN_32             32
#define ACCOUNTNUM_LEN_V40      9
#define    APN_NAME_LEN            32
#define    APN_USERNAME_LEN        24
#define    APN_USERPASSWORD_LEN    16

typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD        dwSize;
    WORD        wEnterDelay;                    //������ʱ,��λ:��, ��Χ��10-150 �������������������б�����������ʱʱ���� NET_DVR_ALARMIN_PARAM �е�dwParam��������ʱʱ��
    //�������������÷�ʽͨ���������е�bySupportAlarmInDelay�ֶ�������
    WORD        wExitDelay;//�˳���ʱ,��λ:�룬 ��Χ10-300
    BYTE        byHostageReport;                //Ю�ֱ��棬0���� 1ʹ��
    BYTE        bySubsystemEnable;                //��ϵͳʹ��
    BYTE        byKeyToneOfArmOrDisarm;            // �ɹ����Ͳ����������Ƿ������ʾ��0-���̲���ʾ 1-���������ʾ��
    BYTE        byKeyToneOfManualTestReport;    //�ɹ����Ͳ��Ա����Ƿ������ʾ��0-���̲���ʾ 1-���������ʾ��
    WORD        wDelayTime;                        //���������ʱ������������dwSupport1�е�bit0λΪ1ʱ��ʹ�øò������þ������ʱ�䡣bit0Ϊ0ʱ��ʹ��NET_DVR_SIREN_PARAM�е�wDelay�������þ������ʱ��
    BYTE        byEnableAlarmInDelay;//0--������(ʹ����ϵͳ��ʱ),1--����(ʹ�÷�����ʱ)��Ĭ�ϲ�����
    BYTE         byPublicAttributeEnable;        //�Ƿ�Ϊ������ϵͳ
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;        
    BYTE        byKeyZoneArm;                    //�Ƿ�֧��Կ�׷�������ϵͳ���в�������
    BYTE        byKeyZoneArmReport;                //�Ƿ�֧��Կ�׷�������ϵͳ����ʱ���Ͳ�������
    BYTE        byKeyZoneDisarm;                //�Ƿ�֧��Կ�׷�������ϵͳ���г�������
    BYTE        byKeyZoneDisarmReport;            //�Ƿ�֧��Կ�׷�������ϵͳ���г�������ʱ���ͳ�������
    BYTE        bySubSystemID[MAX_SUBSYSTEM_ID_LEN];    //��ϵͳID
    BYTE        byKeyZoneArmReportEnable;    //Կ�׷����ϴ���������ʹ�� 0-���� 1-ʹ��
    BYTE        byKeyZoneArmEnable;    //Կ�׷���ʹ�ܣ� 0 -���� 1-ʹ��
    BYTE        byOneKeySetupAlarmEnable;          //һ������ʹ��
    BYTE        bySingleZoneSetupAlarmEnable;       //������������ʹ��
    BYTE        byCenterType;                    //0-��Ч, 1-�����˺�(����6),2-��չ�������˺�(����9)
    BYTE        sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //�����ʺ�
    BYTE        sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //�����˺�V40,ʹ�ô��ֶ�ʱsCenterAccount��Ч
    BYTE        byRes2[565];                    // �����ֽ�
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;//�Ƿ����ñ������� 0-�����ã�1-����
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME,*LPNET_DVR_REMIND_TIME;

//��ϵͳ����������չ
#define    MAX_KEYBOARD_USER_NUM    256
typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD     dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //������ʱ��
    BYTE    byAlarmInAdvance;            // ��������ǰ��ʾʱ��0~45��
    BYTE    byRes1[3];
    BYTE     byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//��λ����ʾ��ϵͳ�����ı�������ͨ���ţ�0-�����룬1-����
    BYTE     byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//��λ����ʾ֧�ֵļ��̺ţ�0-�����룬1-����
    BYTE    byJointOpetaterUser[MAX_KEYBOARD_USER_NUM/8];//��λ��ʾ��bit0��ʾ���̲����û�1 ��0-������ 1-����
    NET_DVR_REMIND_TIME    struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];//MAX_TIMESEGMENT_V30��ʾÿ�����֧��8������
    BYTE             byRes2[288];            // �����ֽ�
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;


typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD     dwSize;
    BYTE     byPrinterEnable;        //�Ƿ����ô�ӡ��
    BYTE    byPrintTime;            //�Ƿ��ӡʱ��
    BYTE     byFaultDetect;            //�Ƿ����ӡ������
    BYTE    byRes1;
    DWORD    dwAlarmInfo;            //������Ϣ����λ��ʾ��bit0-����������bit1-���������ָ���bit2-����������bit-3Ю�ֱ���
    DWORD    dwDeviceInfo;            //�豸��Ϣ����λ��ʾ��bit0-������ϵ硢bit1-������ϵ�ָ���bit2-����Ƿѹ��bit3-����Ƿѹ�ָ���bit4-�绰�߶��ߡ�bit5-�绰�߶��߻ָ���bit6-���Ա��桢bit7-����bit8-����ָ���bit9-485�豸���ߡ�bit10-485�豸���߻ָ���bit11-���������쳣��bit12-��������ָ�������bit13-���������쳣��bit14-��������ָ�������bit15-��չ�����쳣��bit17-��չ���߻ָ�������bit17-Ӳ�̹��ϡ�bit18-Ӳ�̹��ϻָ���bit19-��������
    DWORD    dwOperateInfo;            //������Ϣ����λ��ʾ��bit0-������bit1-������bit2-������bit3-��·��bit4-��·�ָ���bit5-�����̡�bit6-�˳���̡�bit7-������λ
    BYTE     byRes2[256];            // �����ֽ�
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{ 
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    byAddressType;    //0 - ������, 1 - ipv4/ipv6��ַ��2 - ����
    BYTE    byRes1[1];
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //������GPRS�������á������������ʱ���ֶξ���Ч
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //Э��ΪNAL2300ʱ��Ч
    BYTE    byRes2[7]; //GPRS�������������ڹ̶��ķ������Ͻ��еģ����Բ���Ҫ����������������ϢԤ��һЩ�ֶ�
}NET_DVR_ALARMHOST_NETPARAM,  *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_REGISTER_RS485CFG
{
    DWORD   dwSize;                 // �ṹ���С
    WORD    wDeviceProtocol;        // ǰ���豸Э�� ͨ����ȡЭ���б��ȡ    
    BYTE    byRes[2];
    DWORD   dwBaudRate;             //������(bps)��0-50��1-75��2-110��3-150��4-300��5-600��6-1200��7-2400��8-4800��9-9600��10-19200��11-38400��12-57600��13-76800��14-115.2k 
    BYTE    byRes1[124];              // �����ֽ�
}NET_DVR_REGISTER_RS485CFG, *LPNET_DVR_REGISTER_RS485CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD    dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //���� GPRS������ز��������� 
    BYTE     byAPNName[APN_NAME_LEN/*32*/];
    BYTE    byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE    byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE    byReconnTime;    //����ʱ�䣬����ʧЧ������������ʱ�䣬10��Ϊ��λ,ȡֵ��Χ1-30
    BYTE    byOverTime;        //��ʱʱ�䣬����OverTimeʱ��û���յ���Ч��������������Χ1-254����λ30��
    BYTE    byDetectLinkTime;    //    //̽����·�Ƿ񻹱��֣���Χ1-30����λ10s
    BYTE    byRes1;
    BYTE    bySIMNum[NAME_LEN/*32*/]; //SIM���ţ��ֻ��ţ�
    NET_DVR_IPADDR    struSIMIP;      //��½���������������IP��ַ��ֻ�ܻ�ȡ
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;


//////////�����������/////////////
typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM     struNetCenter[MAX_CENTERNUM];
    BYTE    byRes1[32];
}NET_DVR_ALARMHOST_NETCFG,  *LPNET_DVR_ALARMHOST_NETCFG;

//////////��ľ�ϴ���ʽ/////////////
#define    MAX_REPORTCHAN_NUM        4
#define    MAX_CENTERGROUP_NUM        16
typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD    dwSize;
    BYTE    byValid;                //�Ƿ�����
    BYTE    byRes[3]; //����1
    BYTE    byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //�����鱨��ͨ���� 1-T1��2-T2�� 3-N1�� 4-N2��5-G1�� 6-G2
    BYTE    byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //��ָ�������鷢��ʧ�ܱ��棬�������±��ʾ���ĸ������飬0-��ѡ��1-ѡ��
    BYTE    byDataType;    //1-�������� 2-�Ǳ������� 3-��������
    BYTE    byRes2[15];    //����2
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

#define MAX_EVENT_NUM 32//���籨����������¼���
typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD        dwSize;            
    BYTE        byValid;            //�Ƿ�����
    BYTE        byDataType;            //1-���б������� 2-���зǱ������� 3-�������ݣ�4-�����������棬5-�Ƿ�����������
    BYTE        byRes[2];             //����1
    BYTE        byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //�����鱨��ͨ���� 1-T1��2-T2�� 3-N1�� 4-N2��5-G1�� 6-G2��7-N3�� 8-N4(����豸֧��3G��G1��G2��ʾ3Gģ�飬�����֧�֣���ʾGPRSģ�飬һ���豸��3Gģ���GPRSģ��ֻ�����һ��)
    BYTE        byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //��ָ�������鷢��ʧ�ܱ��棬�������±��ʾ���ĸ������飬0-��ѡ��1-ѡ��
    BYTE         byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];    //�����������ͣ�0-���ϴ���1-�ϴ� 
    BYTE        byNonZoneReport[MAX_EVENT_NUM]; //�Ƿ�����������, ÿһ��Ԫ�ر�ʾһ���¼����ͣ�0-���ϴ���1-�ϴ���byNonZoneReport[0]-��������� byNonZoneReport[1]-ϵͳ״̬���� byNonZoneReport[2]-ȡ������ byNonZoneReport[3]-���Ա��� byNonZoneReport[4]-�������� byNonZoneReport[5]-�������� byNonZoneReport[6]-Ю�ֱ��� byNonZoneReport[7]-�����ָ����� byNonZoneReport[8]-��·���� byNonZoneReport[9]-��·�ָ����档byNonZoneReport[10]-̽��������״̬���棨���ߡ����ߣ���byNonZoneReport[11]-̽��������״̬���棨��ѹ������Ƿѹ��byNonZoneReport[12]-��Ƶ��������
    BYTE        byAlarmNetCard[MAX_REPORTCHAN_NUM/*4*/];    //�����鱨���������ģ�0-����������1��1-����������2��2-��չ��������1,3-��չ��������2������ͨ��ΪN1��N2��N3��N4ʱ��Ч��
    BYTE        byRes2[252];            //����2
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;


//////////������״̬�ϴ�/////////////
typedef  struct tagNET_DVR_ALARMHOST_SAFETYCABINSTATE
{
    DWORD    dwSize;
    BYTE    byEnterButton;    //���Ű�ť״̬ 0-������ 1-��ť����
    BYTE    byExitButton;    //���Ű�ť״̬ 0-������ 1-��ť����
    BYTE    byDoorState;    //��״̬    0-�Źر� 1-�Ŵ�
    BYTE    byLockState;    //��״̬ 0-����    1-����
    BYTE    byUrgencyButton;    //������ť״̬    0-������ 1-��ť����
    BYTE    byManState;        //��״̬     0-û�� 1-����
    BYTE    byAbnormal; //�쳣״̬  0-���� 1-�쳣(������ʹ�ó�ʱ�ϴ��쳣)
    BYTE    byLightState;   //�ƹ�״̬ 0-�� ��1-��
    BYTE    byFanState;     //����״̬ 0-�أ�1-��
    BYTE    byFollow;  //β�����״̬ 0-��β�棬1-��β��
    BYTE    byFighting;  //��״̬ 0-�޴򶷣�1-�д�
    BYTE    byFaint;  //�ε�״̬ 0-���ε���1-�����ε�
    BYTE    byManyPerson;  //����״̬ 0-�޶��˽��գ�1-���˽���
    BYTE    byRes[59];  //����
}NET_DVR_ALARMHOST_SAFETYCABINSTATE,*LPNET_DVR_ALARMHOST_SAFETYCABINSTATE;

/////////��������ڣ�����״̬�ϴ�/////////////
typedef  struct tagNET_DVR_ALARMHOST_ALARMOUTSTATUS
{
    DWORD    dwSize;
    BYTE    byName[32];        //������������ƻ򾯺�����
    BYTE    byAlarmType;    //1-���������״̬�� 2-����״̬
    WORD    wChan;            //����Ǳ��������״̬����ֵ�ķ�ΧΪ0-511������Ǿ���״̬����Χ1-8��������ֻ��1�����������
    BYTE    byAlarmStatus; //����״̬ 0-�ޱ��� 1-�б���
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_ALARMOUTSTATUS,*LPNET_DVR_ALARMHOST_ALARMOUTSTATUS;

//////////�����ϴ�����/////////////
typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD        dwSize;
    BYTE        byAudioFormat;      //��Ƶ��ʽ��1-G711��2-G722 
    BYTE        byRes1;
    WORD        wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD        dwSamplesPerSec;    //������
    BYTE        byRes2[20];            //����
    DWORD        dwAudioSize;        //��Ƶ���ȴ�С��ѹ����Ĵ�С
}NET_DVR_AUDIO_PARAM,*LPNET_DVR_AUDIO_PARAM;

//Ԥ��V40�ӿ�
typedef struct tagNET_DVR_PREVIEWINFO
{
    LONG lChannel;//ͨ����
    DWORD dwStreamType;    // �������ͣ�0-��������1-��������2-����3��3-����4, 4-����5,5-����6,7-����7,8-����8,9-����9,10-����10
    DWORD dwLinkMode;// 0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-RTP/RTSP,5-RSTP/HTTP ,6- HRUDP���ɿ����䣩 ,7-RTSP/HTTPS
    HWND hPlayWnd;//���Ŵ��ڵľ��,ΪNULL��ʾ������ͼ��
    DWORD bBlocked;  //0-������ȡ��, 1-����ȡ��, �������SDK�ڲ�connectʧ�ܽ�����5s�ĳ�ʱ���ܹ�����,���ʺ�����ѯȡ������.
    DWORD bPassbackRecord; //0-������¼��ش�,1����¼��ش�
    BYTE byPreviewMode;//Ԥ��ģʽ��0-����Ԥ����1-�ӳ�Ԥ��
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//��ID��lChannelΪ0xffffffffʱ���ô˲���
    BYTE byProtoType; //Ӧ�ò�ȡ��Э�飬0-˽��Э�飬1-RTSPЭ��,2-SRTP�������ܣ���Ӧ�˽ṹ����dwLinkMode �ֶΣ�֧�����·�ʽ, Ϊ1����ʾudp���䷽ʽ��������TLS���ܣ�������SRTP���ܣ�Ϊ2����ʾ�ಥ���䷽ʽ��������TLS���ܣ�������SRTP���ܣ�
    BYTE byRes1;
    BYTE byVideoCodingType; //�������ݱ�������� 0-ͨ�ñ������� 1-�ȳ���̽����������ԭʼ���ݣ��¶����ݵļ�����Ϣ��ͨ��ȥ�������㣬��ԭʼ���������ʵ���¶�ֵ��
    DWORD dwDisplayBufNum; //���ſⲥ�Ż�������󻺳�֡������Χ1-50����0ʱĬ��Ϊ1 
    BYTE byNPQMode;	//NPQ��ֱ��ģʽ�����ǹ���ý�� 0-ֱ�� 1-����ý��
    BYTE byRecvMetaData;  //�Ƿ����metadata���ݣ��豸�Ƿ�֧�ָù���ͨ��GET /ISAPI/System/capabilities ��DeviceCap.SysCap.isSupportMetadata�Ƿ������Ϊtrue
    BYTE byRes[214];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;

//���������豸ȡ��
typedef struct tagNET_DVR_PREVIEWINFO_SPECIAL
{
    char sURL[1024];  //ȡ��URL����Ӧ/ISAPI/SDT/Management/Region/ID���ص�ȡ��URL�������豸���ص�URL���Ϸ�����Ҫ�����û�������ڵ㣬�����û�����������Ϣ����deviceUser��devicePassword�ڵ�
    //ʾ����rtsp://admin:abcd12345@10.7.37.2:554/Streaming/Channels/101?transportmode=unicast
    DWORD dwLinkMode;// 0��TCP��ʽ,1��UDP��ʽ,2���ಥ��ʽ,3 - RTP��ʽ��4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;//���Ŵ��ڵľ��,ΪNULL��ʾ������ͼ��
    DWORD bBlocked;  //0-������ȡ��, 1-����ȡ��, �������SDK�ڲ�connectʧ�ܽ�����5s�ĳ�ʱ���ܹ�����,���ʺ�����ѯȡ������.
    DWORD dwDisplayBufNum; //���ſⲥ�Ż�������󻺳�֡������Χ1-50����0ʱĬ��Ϊ1 
    BYTE byRes[64];
}NET_DVR_PREVIEWINFO_SPECIAL, *LPNET_DVR_PREVIEWINFO_SPECIAL;


//�¼������������

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD    dwSize;
    DWORD    dwOverallEventTriggerAlarmoutOn;    //ȫ���¼��������������������λ��bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣 ,bit5-Ӳ�̹���, bit6-3G/4G�ź��쳣, bit7-��ģ�����ӣ��������������� ��bit8- WIFIͨ�Ź��ϣ�bit9-RF�źŸ��Ź���
    DWORD    dwOverallEventTriggerAlarmoutOff;    //ȫ���¼��������������������λ��bit0-��������磬bit1-��ص�ѹ�ͣ�bit2-�绰�ߵ��ߣ�bit3-���������쳣��bit4-���������쳣 ,bit5-Ӳ�̹���, bit6-3G/4G�ź��쳣, bit7-��ģ�����ӣ��������������� ��bit8- WIFIͨ�Ź��ϣ�bit9-RF�źŸ��Ź���
    DWORD    dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ�¼����������������,dwSubSystemEvent[0]��ʾ��ϵͳ1��dwSubSystemEvent[2]��ʾ��ϵͳ2���������ϵͳ��������������ȡ��wSubSystem����ÿ����ϵͳ���¼���λ��ʾ��bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������������,bit6-�����ָ�,bit7-��������,bit8-��������ָ�
    DWORD    dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //��ϵͳ�¼�������������ر�,wSubSystemEvent[0]��ʾ��ϵͳ1��dwSubSystemEvent[2]��ʾ��ϵͳ2���������ϵͳ��������������ȡ��wSubSystem����ÿ����ϵͳ���¼���λ��ʾ��bit0-������ʱ��bit1-�˳���ʱ��bit2-������bit3-������bit4-������bit5-������������,bit6-�����ָ�,bit7-��������,bit8-��������ָ�
    BYTE    byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

//���ϴ�������
typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD     dwSize;
    DWORD    dwCheckFault;    //�Ƿ�����ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣��bit9- FPGA���ϣ�bit10- ģ��������, bit11-������չ���쳣��bit12-WIFIͨ�Ź��ϣ�bit13-RF�źŸ��Ź��ϣ�����֧�ֵĹ������ʹ���������ȡ
    DWORD    dwOverallFaultJointLED;        //���Ϲ���ȫ�ּ���ָʾ����� bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣������֧�ֵĹ������ʹ���������ȡ
    DWORD    dwOverallFaultJointSound;    //���Ϲ���ȫ�ּ���������� bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣������֧�ֵĹ������ʹ���������ȡ
    DWORD    dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*���Ϲ�����ϵͳ����ָʾ�������dwSubSystemFaultJointLED[0]��ʾ��ϵͳ1�Ĺ�����Ϣ��dwSubSystemFaultJointLED[0]��ÿһλ��ʾһ�й��ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣; dwSubSystemFaultJointLED[1]��ʾ��ϵͳ2���Դ�����*/
    DWORD    dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*���Ϲ�����ϵͳ������������������ڼ����������dwSubSystemFaultJointLED[0]��ʾ��ϵͳ1�Ĺ�����Ϣ��dwSubSystemFaultJointSound [0]��ÿһλ��ʾһ�й��ϣ�bit0-������ϵ磬bit1-����Ƿѹ��bit2-�������𿪣�bit3-�绰�ߵ��ߣ�bit4-485�豸�쳣��bit5-������ϣ�bit6-�����쳣��bit7-��չ�����쳣��bit8-Ӳ���쳣; dwSubSystemFaultJointSound [1]��ʾ��ϵͳ2���Դ�����*/
    DWORD    dwFaultJointFaultLight;//���Ϲ������ϵ����
    BYTE    byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD    dwSize;
    BYTE    byIndex;            //��ϵͳ�ţ�0xff��ʾ������ϵͳ
    BYTE       byRes[63];      //����
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;

#define CID_CODE_LEN 4
#define DEV_SERIAL_LEN 9
typedef enum tagNET_DVR_ALARMHOST_REPORT_TYPE
{
    NET_DVR_DEFENCE_ALARM = 1,        //��������
        NET_DVR_VIDEO_ALARM,            //��Ƶ����
        NET_DVR_VIRTUAL_DEFENCE_ALARM,    //���������
        NET_DVR_HOSTAGE_ALARM,            //Ю�ֱ���
        NET_DVR_KNOCK_DOWN_ALARM,        //���𱨾�
        NET_DVR_OPERATE_ALARM,            //��������
        NET_DVR_OHTER_ABNORMAL_ALARM    //�쳣����
}NET_DVR_ALARMHOST_REPORT_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MAIN_TYPE
{
    CID_ENTER = 1000,    /*��������Ļ���*/
    CID_EXIT = 3000        /*�ָ�����Ļ���*/
}NET_DVR_ALARMHOST_CID_MAIN_TYPE;


typedef enum tagNET_DVR_ALARMHOST_CID_MINOR_TYPE
{
    CID_MEDICAL_ALARM = 100,                /*�Ȼ�����*/
    CID_ALARM = 103,                        /*����*/
    CID_FIRE_ALARM = 110,                   /*��*/
    CID_ABDUCT_REPORT = 121,                /*Ю�ֱ���*/
    CID_SILENT_24 = 122,                    /*24Сʱ����*/
    CID_AUDIO_24 = 123,                     /*24Сʱ����*/
    CID_AUXILIARY_24 = 124,                 /*24Сʱ����*/
    CID_SHOCK_24 = 125,                     /*24Сʱ��*/
    CID_OVERTIME_ALARM = 126,               /*��ʱ����*/
    CID_EMERGENCE_CALL_HELP = 129,          /*������������*/
    CID_BURGLARY_ALARM = 130,               /*���Ա���*/
    CID_PERIMETER_ALARM = 131,              /*�ܽ�*/
    CID_INNET_ALARM = 132,                  /*�ڲ�����*/
    CID_ENTER_EXIT = 134,                   /*����*/
    CID_DEVICE_OPEN = 137,                  /*�豸����*/
    CID_ZONE_BUS_BREAK = 141,               /*���߿�·*/
    CID_ZONE_BUS_SHORT = 142,               /*���߶�·*/
    CID_MOTION_ALARM = 148,                 /*�ƶ�����*/
    CID_GAS_LEAKAGE = 151,                  /*ȼ��й©*/
    CID_ZONE_EARLY_WARNING = 207,           /*����Ԥ��*/
    CID_AC_LOSS = 301,                      /*��������*/
    CID_LOW_BATT_VOL = 302,                 /*���ص�ѹ��*/
    CID_DEV_RESET = 305,                    /*������λ*/
    CID_MBUS_MODEL_FAULT = 333,             /*��չģ�����*/
    CID_PRINTER_FAIL = 336,                 /*��ӡ������*/
    CID_LOW_EXPANDER_VOL = 338,             /*��չģ���ѹ��*/
    CID_EXPANDER_OPEN = 341,                /*��չģ�鱻��*/
    CID_EXPANDER_AC_POWER_DOWN = 342,       /*��չģ�齻�������*/
    CID_WIRELESS_REPEATER_TAMPERED = 343,   /*�����м������𴥷�*/
    CID_WIRELESS_SIREN_TAMPERED = 344,      /*���߾��ŷ��𴥷�*/
    CID_WIRELESS_SIREN_DISCONNECTED = 345,  /*���߾��ŵ���*/
    CID_LINE_LOSS = 354,                    /*�绰��ͨѶʧ��*/
    CID_BUS_LOSS = 382,                     /*��չ����ģ�����*/
    CID_DETECTOR_OPEN = 383,                /*������Ӧ������*/
    CID_ZONE_OPEN_CIRCUIT = 386,            /*������·����*/
    CID_ZONE_SHORT_CIRCUIT = 387,           /*������·����*/
    CID_GUARD = 401,                        /*��������*/
    CID_GUARD_AUTO = 403,                   /*�Զ�������*/
    CID_CANCEL_ARM = 406,                   /*����*/
    CID_GUARD_IMME = 408,                   /*��ʱ������*/
    CID_KEY_ZONE_GUARD = 409,               /*Կ�׷���������*/
    CID_GUARD_STAY = 441,                   /*���ز�����*/
    CID_FORCED_ARM = 442,                   /*ǿ�Ʋ���*/
    CID_AUTOCTRL_TRIG = 443,                /*��ʱ��/�ش�����*/
    CID_ONETOUCH_AWAY_ARMING = 444,         /*һ���������*/
    CID_ONETOUCH_STAY_ARMING = 445,         /*һ�����ز���*/
    CID_CARD_ARMING_OR_DISARMING = 446,     /*ˢ��������*/
    CID_LATE_TO_DISARM = 452,               /*�ٵ�����*/
    CID_AUTOGUARD_FAIL = 455,               /*�Զ�����ʧ��*/
    CID_AOPEN_TRIG_FAIL = 460,              /*��ʱ����������ʧ��*/
    CID_ACLOSE_TRIG_FAIL = 461,             /*��ʱ�رմ�����ʧ��*/
    CID_AUTOUNGUARD_FAIL = 462,             /*�Զ�����ʧ��*/
    CID_BYPASS = 570,                       /*��·�¼�*/
    CID_GROUP_BYPASS = 574,                 /*����·*/
    CID_MANUAL_TEST_RPT = 601,              /*�ֶ����Ա���*/
    CID_AUTO_TEST_RPT = 602,                /*��ʱ���Ա���*/
    CID_PHONE_CONNET_TEST = 617,            /*�绰��·����*/
    CID_ENTER_PROG = 627,                   /*������*/
    CID_EXIT_PROG = 628,                    /*�˳����*/
    CID_FIELD_DETECTION = 759,              /*��������*/
    CID_LINE_DETECTION = 773,               /*��籨��*/
    CID_PIR_ALARM = 774,                    /*PIR����*/
    CID_SOUND_INTENSITY_RISE = 775,         /*��ǿ��������*/
    CID_SOUND_INTENSITY_DROP = 776,         /*��ǿ��������*/
    CID_AUDIO_INPUT_EXCEPTION = 777,        /*��Ƶ�����쳣����*/
    CID_SOFT_INSTAND = 810,                 /*�������������*/
    CID_SOFT_FIRE = 811,                    /*�������*/
    CID_SOFT_MOBS = 812,                    /*������˾�mobster*/
    CID_KEYPAD_LOCKED = 862,                /*��������*/
    CID_ABSENCE_ALARM = 863,                /*ֵ�����*/
    CID_KEY_FAIL = 910,                     /*���̵���*/
    CID_TRIGGER_FAIL = 911,                 /*���������ϴ���������*/
    CID_GPK_FAIL = 912,                     /*����������GP/K����*/
    CID_MODULE_FAIL = 913,                  /*����������MN/K����*/
    CID_WIRELESS_DETECTOR_FAIL = 914,       /*����̽��������*/
    CID_WIRELESS_DETECTOR_BATTERY_LOW = 915,/*����̽����Ƿѹ/�����ָ�����*/
    CID_EXPANDER_DISCONNECT = 916,          /*��չģ�����*/
    CID_WIRELESS_REPEATER_DISCONNECT = 917, /*�����м�������*/
    CID_RADAR_TRANS_FAULT = 918,            /*�״��ź��쳣*/
    CID_WIRELESS_SIREN_LOW_BATTERY = 919,   /*���߾��ŵ�����*/
    CID_WRIE_LESS_NET = 920,                /*�����������*/
    CID_SIM_FAULT = 921,                    /*SIM������*/
    CID_WIFI_ABNORMAL = 922,                /*WIFIͨ���쳣/�ָ�����*/
    CID_RF_ABNORMAL = 923,                  /*RF�ź��쳣/�ָ�����*/
    CID_DATE_TRAFFIC_OVERFLOW = 924,        /*��������*/
    CID_IPADDR_CONFLICT = 930,              /*IP��ͻ*/
    CID_ETHERNET_BROKEN = 931,              /*���߶�*/
    CID_GROUP_OUT_RP = 932,                 /*���ͨѶʧ��*/
    CID_GROUP_IN_RP = 933,                  /*ͨ��ͨѶʧ��*/
    CID_MOTION_DECTECT = 940,               /*�ƶ���ⱨ����ʼ/����*/
    CID_MASK_ALARM = 941,                   /*�ڵ�������ʼ/����*/
    CID_VI_LOST = 942,                      /*��Ƶ��ʧ��ʼ/����*/
    CID_VS_MISMATCH = 943,                  /*����/�����Ƶ��ʽ��ƥ��*/
    CID_VI_EXCEPTION = 944,                 /*��Ƶ�����쳣/�ָ�����*/
    CID_HD_FULL = 945,                      /*Ӳ����/�ָ�����*/
    CID_HD_ERROR = 946,                     /*Ӳ�̴�/�ָ�����*/
    CID_PIC_SEND_FAILED = 947,              /*ͼƬ�ϴ�ʧ��*/
    CID_KEY_LOCKED = 948,                   /*��������*/
    CID_NETWORK_CAMERA_DISCONNECT = 949,    /*IPC�Ͽ�����*/
    CID_DUTY_CHECKING = 960,                /*ֵ�ز��*/
    CID_POST_RESPONSE = 961,                /*ֵ��Ӧ��*/
    CID_ZONE_BUS_SEARCH = 970,              /*��������*/
    CID_ZONE_BUS_REGIST = 971,              /*����ע��*/
    CID_GUARD_DELAY_OP = 972,               /*�Զ���������ʱ����*/
    CID_GUARD_SINGLE = 973,                 /*������������*/
    CID_SINGLE_ZONE_CLEARED = 974,          /*����������*/
    CID_ZONE_ASSOCIATED_DETECTOR = 975,     /*�������/ɾ��̽����*/
    CID_ZONE_CONSULTING = 976,              /*ҵ����ѯ*/
    CID_EXPANDER_DELETED = 977,             /*ɾ����չģ��*/
    CID_WIRELESS_REPEATER_DELETED = 978,    /*ɾ�������м���*/
    CID_WIRELESS_SIREN_DELETED = 979,       /*ɾ�����߾���*/
}NET_DVR_ALARMHOST_CID_MINOR_TYPE;

typedef enum tagNET_DVR_ALARMHOST_CID_ALL_MINOR_TYPE
{
    CID_TYPE_MEDICAL_ALARM = 1100,                      /*���˾Ȼ�����*/
    CID_TYPE_MEDICAL_ALARM_RESET = 3100,                /*���˾Ȼ������ָ�*/
    CID_TYPE_ALARM = 1103,                              /*��ʱ����*/
    CID_TYPE_ALARM_RESET = 3103,                        /*��ʱ�����ָ�*/
    CID_TYPE_FIRE_ALARM = 1110,                         /*�𾯱���*/
    CID_TYPE_FIRE_ALARM_RESET = 3110,                   /*�𾯱����ָ�*/
    CID_TYPE_ABDUCT_REPORT = 1121,                      /*Ю�ֱ���*/
    CID_TYPE_SILENT_24 = 1122,                          /*24Сʱ��������*/
    CID_TYPE_SILENT_24_RESET = 3122,                    /*24Сʱ���������ָ�*/
    CID_TYPE_AUDIO_24 = 1123,                           /*24Сʱ��������*/
    CID_TYPE_AUDIO_24_RESET = 3123,                     /*24Сʱ���������ָ�*/
    CID_TYPE_AUXILIARY_24 = 1124,                       /*24Сʱ��������*/
    CID_TYPE_AUXILIARY_24_RESET = 3124,                 /*24Сʱ���������ָ�*/
    CID_TYPE_SHOCK_24 = 1125,                           /*24Сʱ�𶯱���*/
    CID_TYPE_SHOCK_24_RESET = 3125,                     /*24Сʱ�𶯱����ָ�*/
    CID_TYPE_TIMEOUT = 1126,                            /*��ʱ����*/
    CID_TYPE_TIMEOUT_RESET = 3126,                      /*��ʱ�����ָ�*/
    CID_TYPE_EMERGENCE_CALL_HELP = 1129,                /*������������*/
    CID_TYPE_EMERGENCE_CALL_HELP_RESET = 3129,          /*�������������ָ�*/
    CID_TYPE_BURGLARY_ALARM = 1130,                     /*���Ա���*/
    CID_TYPE_BURGLARY_ALARM_RESET = 3130,               /*���Ա����ָ�*/
    CID_TYPE_PERIMETER_ALARM = 1131,                    /*�ܽ籨��*/
    CID_TYPE_PERIMETER_ALARM_RESET = 3131,              /*�ܽ籨���ָ�*/
    CID_TYPE_INNET_ALARM = 1132,                        /*�ڲ���ʱ����*/
    CID_TYPE_INNET_ALARM_RESET = 3132,                  /*�ڲ���ʱ�����ָ�*/
    CID_TYPE_ENTER_EXIT = 1134,                         /*��ʱ����*/
    CID_TYPE_ENTER_EXIT_RESET = 3134,                   /*��ʱ�����ָ�*/
    CID_TYPE_DEVICE_OPEN = 1137,                        /*�豸���𱨾�*/
    CID_TYPE_DEVICE_OPEN_RESET = 3137,                  /*�豸���𱨾��ָ�*/
    CID_TYPE_ZONE_BUS_BREAK = 1141,                     /*���߿�·����*/
    CID_TYPE_ZONE_BUS_BREAK_RESET = 3141,               /*���߿�·�����ָ�*/
    CID_TYPE_ZONE_BUS_SHORT = 1142,                     /*���߶�·����*/
    CID_TYPE_ZONE_BUS_SHORT_RESET = 3142,               /*���߶�·�����ָ�*/
    CID_TYPE_MOTION_ALARM = 1148,                       /*�豸�ƶ�����*/
    CID_TYPE_MOTION_ALARM_RESET = 3148,                 /*�豸�ƶ������ָ�*/
    CID_TYPE_GAS_LEAKAGE_ALARM = 1151,                  /*ȼ��й©����*/
    CID_TYPE_GAS_LEAKAGE_ALARM_RESET = 3151,            /*ȼ��й©�����ָ�*/
    CID_TYPE_ZONE_EARLY_WARNING = 1207,                 /*����Ԥ��*/
    CID_TYPE_ZONE_EARLY_WARNING_RESET = 3207,           /*����Ԥ���ָ�*/
    CID_TYPE_AC_LOSS = 1301,                            /*���������*/
    CID_TYPE_AC_LOSS_RESET = 3301,                      /*������ָ�*/
    CID_TYPE_LOW_BATT_VOL = 1302,                       /*���ص�ѹ��*/
    CID_TYPE_LOW_BATT_VOL_NORMAL = 3302,                /*���ص�ѹ����*/
    CID_TYPE_DEV_RESET = 1305,                          /*������λ*/
    CID_TYPE_MBUS_MODEL_FAULT = 1333,                   /*��չģ�����*/
    CID_TYPE_MBUS_MODEL_RESET = 3333,                   /*��չģ��ָ�*/
    CID_TYPE_PRINTER_OFF = 1336,                        /*��ӡ������*/
    CID_TYPE_PRINTER_ON = 3336,                         /*��ӡ���ָ�*/
    CID_TYPE_EXTEND_MODULE_VOL_LOW = 1338,              /*��չģ���ѹ��*/
    CID_TYPE_EXTEND_MODULE_VOL_NORMAL = 3338,           /*��չģ���ѹ����*/
    CID_TYPE_EXTEND_MODULE_REMOVE = 1341,               /*��չģ����𴥷�*/
    CID_TYPE_EXTEND_MODULE_RECOVER = 3341,              /*��չģ�����ָ�*/
    CID_TYPE_EXTEND_MODULE_AC_LOSS = 1342,              /*��չģ�齻�������*/
    CID_TYPE_EXTEND_MODULE_AC_LOSS_RESET = 3342,        /*��չģ�齻����ָ�*/
    CID_TYPE_WIRELESS_REPEATER_TAMPER = 1343,           /*�����м������𴥷�*/
    CID_TYPE_WIRELESS_REPEATER_RESTORE = 3343,          /*�����м�������ָ�*/
    CID_TYPE_WIRELESS_SIREN_TAMPER = 1344,              /*���߾��ŷ��𴥷�*/
    CID_TYPE_WIRELESS_SIREN_RESTORE = 3344,             /*���߾��ŷ���ָ�*/
    CID_TYPE_WIRELESS_SIREN_DISCONNECT = 1345,          /*���߾��ŵ���*/
    CID_TYPE_WIRELESS_SIREN_CONNECT = 3345,             /*���߾��ŵ��߻ָ�*/
    CID_TYPE_LINE_LOSS = 1354,                          /*�绰�߶Ͽ�*/
    CID_TYPE_LINE_LOSS_RESET = 3354,                    /*�绰������*/
    CID_TYPE_BUS_LOSS = 1382, 	                        /*��չ����ģ�����*/
    CID_TYPE_BUS_LOSS_RESET = 3382, 	                /*��չ����ģ����߻ָ�*/
    CID_TYPE_SENSOR_TAMPER = 1383, 	                    /*������Ӧ������*/
    CID_TYPE_SENSOR_TAMPER_RESET = 3383, 	            /*������Ӧ������ָ�*/
    CID_TYPE_ZONE_OPEN_CIRCUIT_ALARM = 1386,            /*������·����*/
    CID_TYPE_ZONE_SHORT_CIRCUIT_ALARM = 1387,           /*������·����*/
    CID_TYPE_DISARM = 1401,                             /*����*/
    CID_TYPE_ARM = 3401,                                /*�������*/
    CID_TYPE_DISARM_AUTO = 1403,                        /*�Զ�����*/
    CID_TYPE_ARM_AUTO = 3403,                           /*�Զ�����*/
    CID_TYPE_CANCEL_ARM = 1406,                         /*����*/
    CID_TYPE_ARM_IMME = 3408,                           /*��ʱ����*/
    CID_TYPE_KEY_ZONE_ARM = 1409,                       /*Կ�׷�������*/
    CID_TYPE_KEY_ZONE_DISARM = 3409,                    /*Կ�׷�������*/
    CID_TYPE_GUARD_STAY = 3441,                         /*���ز���*/
    CID_TYPE_FORCED_ARM = 3442,                         /*ǿ�Ʋ���*/
    CID_TYPE_AUTOCTRL_TRIG_ON = 1443,                   /*��ʱ��������*/
    CID_TYPE_AUTOCTRL_TRIG_OFF = 3443,                  /*��ʱ�ش�����*/
    CID_TYPE_LATE_TO_DISARM = 1452,                     /*�ٵ�����*/
    CID_TYPE_AUTOGUARD_FAIL = 1455,                     /*�Զ�������ʧ��*/
    CID_TYPE_AOPEN_TRIG_FAIL = 1460,                    /*��ʱ����������ʧ��*/
    CID_TYPE_ACLOSE_TRIG_FAIL = 1461,                   /*��ʱ�رմ�����ʧ��*/
    CID_TYPE_AUTOUNGUARD_FAIL = 1462,                   /*�Զ�����ʧ��*/
    CID_TYPE_BYPASS = 1570,                             /*��·*/
    CID_TYPE_BYPASS_RESET = 3570,                       /*��·�ָ�*/
    CID_TYPE_GROUP_BYPASS = 1574,                       /*��ϵͳ����·*/
    CID_TYPE_GROUP_BYPASS_RESET = 3574,                 /*��ϵͳ����·�ָ�*/
    CID_TYPE_MANUAL_TEST_RPT = 1601,                    /*�ֶ����Ա���*/
    CID_TYPE_AUTO_TEST_RPT = 1602,                      /*��ʱ���Ա���*/
    CID_TYPE_LINE_TEST = 1617,                          /*�绰��·����*/
    CID_TYPE_ENTER_PROG = 1627,                         /*������*/
    CID_TYPE_EXIT_PROG = 1628,                          /*�˳����*/
    CID_TYPE_FIELD_DETECTION = 1759,                    /*��������*/
    CID_TYPE_FIELD_DETECTION_RESET = 3759,              /*�������ָֻ�*/
    CID_TYPE_LINE_DETECTION = 1773,                     /*��籨��*/
    CID_TYPE_LINE_DETECTION_RESET = 3773,               /*��籨���ָ�*/
    CID_TYPE_PIR_ALARM = 1774,                          /*PIR����*/
    CID_TYPE_PIR_ALARM_RESET = 3774,                    /*PIR�����ָ�*/
    CID_TYPE_SOUND_INTENSITY_RISE = 1775,               /*��ǿ��������*/
    CID_TYPE_SOUND_INTENSITY_RISE_RESET = 3775,         /*��ǿ���������ָ�*/
    CID_TYPE_SOUND_INTENSITY_DROP = 1776,               /*��ǿ��������*/
    CID_TYPE_SOUND_INTENSITY_DROP_RESET = 3776,         /*��ǿ���������ָ�*/
    CID_TYPE_AUDIO_INPUT_EXCEPTION = 1777,              /*��Ƶ�����쳣����*/
    CID_TYPE_AUDIO_INPUT_EXCEPTION_RESET = 3777,        /*��Ƶ�����쳣�����ָ�*/
    CID_TYPE_SOFT_INSTAND = 1810,                       /*�������������*/
    CID_TYPE_SOFT_FIRE = 1811,                          /*�������*/
    CID_TYPE_SOFT_MOBS = 1812,                          /*������˾�*/
    CID_TYPE_KEYPAD_LOCK = 1862,                        /*��������*/
    CID_TYPE_KEYPAD_UNLOCK = 3862,                      /*���̽���*/
    CID_TYPE_ABSENCE_ALARM = 1863,                      /*ֵ�����*/
    CID_TYPE_KEY_FAIL = 1910,                           /*���̵���*/
    CID_TYPE_KEY_RESET = 3910,                          /*���ָ̻�*/
    CID_TYPE_TRIGGER_FAIL = 1911,                       /*���������ϴ���������*/
    CID_TYPE_TRIGGER_RESET = 3911,                      /*���������ϴ������ָ�*/
    CID_TYPE_GPK_FAIL = 1912,                           /*����������GP/K����*/
    CID_TYPE_GPK_RESET = 3912,                          /*����������GP/K�ָ�*/
    CID_TYPE_MODULE_FAIL = 1913,                        /*����������MN/K����*/
    CID_TYPE_MODULE_RESET = 3913,                       /*����������MN/K�ָ�*/
    CID_TYPE_WIRELESS_DETECTOR_FAIL = 1914,             /*����̽��������*/
    CID_TYPE_WIRELESS_DETECTOR_RESET = 3914,            /*����̽�������߻ָ�*/
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_LOW = 1915,      /*����̽������ѹ��*/
    CID_TYPE_WIRELESS_DETECTOR_BATTERY_NORMAL = 3915,   /*����̽������ѹ����*/
    CID_TYPE_EXTEND_MODULE_LOSS = 1916,                 /*��չģ�����*/
    CID_TYPE_EXTEND_MODULE_LOSS_RESET = 3916,           /*��չģ����߻ָ�*/
    CID_TYPE_WIRELESS_REPEATER_DISCONNECT = 1917,       /*�����м�������*/
    CID_TYPE_WIRELESS_REPEATER_CONNECT = 3917,          /*�����м������߻ָ�*/
    CID_TYPE_RADAR_TRANS_FAULT = 1918,                  /*�״��ź��쳣*/
    CID_TYPE_RADAR_TRANS_RESET = 3918,                  /*�״��ź��쳣�ָ�*/
    CID_TYPE_WRIELESS_SIREN_LOW_BATTERY = 1919,         /*���߾��ŵ�����*/
    CID_TYPE_NORMAL_WRIELESS_SIREN_BATTERY = 3919,      /*���߾��ŵ�������*/
    CID_TYPE_WRIELESS_NET_FAULT = 1920,                 /*�����������*/
    CID_TYPE_WRIELESS_NET_RESET = 3920,                 /*����������ϻָ�*/
    CID_TYPE_SIM_FAULT = 1921,                          /*SIM���쳣*/
    CID_TYPE_SIM_RESET = 3921,                          /*SIM���쳣�ָ�*/
    CID_TYPE_WIFI_ABNORMAL = 1922,		                /*WIFIͨ���쳣*/
    CID_TYPE_WIFI_NORMAL = 3922,		                /*WIFIͨ�Żָ�����*/
    CID_TYPE_RF_ABNORMAL = 1923,		                /*RF�ź��쳣*/
    CID_TYPE_RF_NORMAL = 3923,		                    /*RF�ź�����*/
    CID_TYPE_DATE_TRAFFIC_OVERFLOW = 1924,              /*��������*/
    CID_TYPE_IPADDR_CONFLICT = 1930,                    /*IP��ͻ*/
    CID_TYPE_IPADDR_NORMAL = 3930,                      /*IP����*/
    CID_TYPE_ETHERNET_BROKEN = 1931,                    /*�����������*/
    CID_TYPE_ETHERNET_NORMAL = 3931,                    /*����������ϻָ�*/
    CID_TYPE_MOTION_DECTECT_START = 1940,               /*�ƶ���ⱨ����ʼ*/
    CID_TYPE_MOTION_DECTECT_STOP = 3940,                /*�ƶ���ⱨ������*/
    CID_TYPE_MASK_ALARM_START = 1941,                   /*�ڵ�������ʼ*/
    CID_TYPE_MASK_ALARM_STOP = 3941,                    /*�ڵ���������*/
    CID_TYPE_VI_LOST_START = 1942,                      /*��Ƶ�źŶ�ʧ*/
    CID_TYPE_VI_LOST_STOP = 3942,                       /*��Ƶ�źŻָ�*/
    CID_TYPE_VS_MISMATCH = 1943,                        /*����/�����Ƶ��ʽ��ƥ��*/
    CID_TYPE_VS_MATCH = 3943,                           /*����/�����Ƶ��ʽ�ָ�����*/
    CID_TYPE_VI_EXCEPTION = 1944,                       /*��Ƶ�����쳣*/
    CID_TYPE_VI_NORMAL = 3944,                          /*��Ƶ����ָ�����*/
    CID_TYPE_HD_FULL = 1945,                            /*Ӳ����*/
    CID_TYPE_HD_FREE = 3945,                            /*Ӳ�̿���*/
    CID_TYPE_HD_ERROR = 1946,                           /*Ӳ���쳣*/
    CID_TYPE_HD_RESET = 3946,                           /*Ӳ�ָ̻�����*/
    CID_TYPE_PIC_SEND_FAILED = 1947,                    /*ͼƬ�ϴ�ʧ��*/
    CID_TYPE_SENDING_EMAIL_FAILED = 1948,               /*�ʼ�����ʧ��*/
    CID_TYPE_NETWORK_CAMERA_DISCONNECT = 1949,          /*IPC�Ͽ�����*/
    CID_TYPE_NETWORK_CAMERA_CONNECT = 3949,             /*IPC�ָ�����*/
    CID_TYPE_DUTY_CHECKING = 1960,                      /*ֵ�ز��*/
    CID_TYPE_POST_RESPONSE = 1961,                      /*ֵ��Ӧ��*/
    CID_TYPE_ZONE_BUS_SEARCH = 1970,                    /*��������*/
    CID_TYPE_ZONE_BUS_REGIST = 1971,                    /*����ע��*/
    CID_TYPE_GUARD_SINGLE_ARM = 1973,                   /*����������*/
    CID_TYPE_GUARD_SINGLE_DISARM = 3973,                /*����������*/
    CID_TYPE_SINGLE_ZONE_ALARM_CLEARED = 1974,          /*����������*/
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_DEL = 1975,       /*ɾ��̽����*/
    CID_TYPE_ZONE_ASSOCIATED_DETECTOR_ADD = 3975,       /*���̽����*/
    CID_TYPE_ZONE_CONSULT = 1976,                       /*ҵ����ѯ*/
    CID_TYPE_ZONE_CONSULT_STOP = 3976,                  /*ҵ����ѯ����*/
    CID_TYPE_EXTEND_MODULE_DEL = 1977,                  /*ɾ����չģ��*/
    CID_TYPE_EXTEND_MODULE_ADD = 3977,                  /*�����չģ��*/
    CID_TYPE_WIRELESS_REPEATER_DEL = 1978,              /*ɾ�������м���*/
    CID_TYPE_WIRELESS_REPEATER_ADD = 3978,              /*��������м���*/
    CID_TYPE_WIRELESS_SIREN_DEL = 1979,                 /*ɾ�����߾���*/
    CID_TYPE_WIRELESS_SIREN_ADD = 3979                  /*������߾���*/
}NET_DVR_ALARMHOST_CID_ALL_MINOR_TYPE;


typedef struct tagNET_DVR_CID_ALARM
{
    DWORD    dwSize;
    BYTE    sCIDCode[CID_CODE_LEN/*4*/];    //CID�¼���
    BYTE    sCIDDescribe[NAME_LEN/*32*/];    //CID�¼���
    NET_DVR_TIME_EX struTriggerTime;            //����������ʱ���
    NET_DVR_TIME_EX struUploadTime;                //�ϴ�������ʱ���
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //�����ʺ�
    BYTE    byReportType;                    //������NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE    byUserType;                        //�û����ͣ�0-�����û� 1-�����û�,2-�ֻ��û�,3-ϵͳ�û�
    BYTE    sUserName[NAME_LEN/*32*/];        //�����û��û���
    WORD    wKeyUserNo;                        //�����û���    0xFFFF��ʾ��Ч
    BYTE    byKeypadNo;                        //���̺�        0xFF��ʾ��Ч
    BYTE    bySubSysNo;                        //��ϵͳ��        0xFF��ʾ��Ч
    WORD    wDefenceNo;                        //������        0xFFFF��ʾ��Ч
    BYTE    byVideoChanNo;                    //��Ƶͨ����   0��ʾ��Ч����ʾ�豸�Դ���Ĭ����Ƶͨ����
    BYTE    byDiskNo;                        //Ӳ�̺�        0xFF��ʾ��Ч
    WORD    wModuleAddr;                    //ģ���ַ        0xFFFF��ʾ��Ч
    BYTE    byCenterType;                    //0-��Ч, 1-�����˺�(����6),2-��չ�������˺�(����9)
    BYTE    byRelativeChannel;              //��ӵ���Ƶͨ���ţ�0��ʾ��Ч���ֽڱ�ʾͨ����
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //�����˺�V40,ʹ�ô��ֶ�ʱsCenterAccount��Ч
    BYTE   byDevSerialNo[DEV_SERIAL_LEN];   /*��Ʒ���к�*/
    BYTE    byRepeaterNo;    //�м����ţ�Ϊ0��Ч
    WORD    wRemoteCtrllerUserNo;    //ң�����û��ţ�Ϊ0��Ч
    DWORD dwIOTChannelNo;    //IOTͨ����
    BYTE    standardCIDcode;  //��׼CID��
    BYTE    byRes2[11];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD dwSize;
    BYTE    byModuleType;    //1-������2-������ 3-����������      
    BYTE    byZoneType;        //�������ͣ�1-���ط�����2-��������3-˫������4-8������5-8·ģ����������6-��������������0xff��ʾ�ò�����Ч
    BYTE    byTriggerType;    //���������ͣ�1-���ش������� 2-4·��������3-8·��������4-��������������0xff��ʾ�ò�����Ч
    BYTE    byRes1[1];
    char    sModelInfo[MODULE_INFO_LEN];                //ģ����Ϣ
    char    sDeviceVersionInfo[VERSION_INFO_LEN];                /* �汾��Ϣ*/
    BYTE    byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;


#define MAX_DECODE_CARD_SUPPORTDISPNUMS 8//ÿ�����뿨���֧�ֵ���ʾͨ����
#define MAX_SUPPORT_RES 32
typedef struct tagNET_DVR_DECCARD_ABILITY_V41 /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //����ͨ���� 
    BYTE byDispNums;      //��ʾͨ���� 
    BYTE byDecStartIdx;     //�׸�����ͨ�������н���ͨ���е����� 
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    BYTE byDispFormat[MAX_DECODE_CARD_SUPPORTDISPNUMS];   //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT�е�ö��) 
    BYTE byWindowMode[MAX_DECODE_CARD_SUPPORTDISPNUMS][12]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes2[36];
} NET_DVR_DECCARD_ABILITY_V41,*LPNET_DVR_DECCARD_ABILITY_V41;

#define        MAX_DECODE_CARD_NUM            6   //��������뿨��
typedef struct tagNET_DVR_DECODESVR_ABILITY_V41
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY_V41 struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY_V41, *LPNET_DVR_DECODESVR_ABILITY_V41;

// ��¼��״̬
typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD           dwSize;
    BYTE            byRecord;         //(ֻ��)¼������, 0������¼��1����¼�� 2-���� 
    //3-������ 4-��������Ƶ 5-δ���� 6-�浵��
    //7-�ش��� 8-�û���������� 9-δ��֤
    //10-�浵�к�¼���� 11-¼��ش��к�¼����12-token��֤ʧ��
    //13-��ǰ����������¼��ƻ����� 14-ͨ�������쳣����ͨ��״̬�� 15-Ӳ����
    //16-Ӳ�̴� 17-��Ӳ��
    BYTE            byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE            byRes1[2];        //�����ֽ�
    DWORD            dwRelatedHD;      //��������
    BYTE            byRes2[8];        //�����ֽ�
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

#define  CHAN_NO_LEN   24

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE        byEnable;                    //�Ƿ�����
    BYTE        byProType;                    //Э�����ͣ�0-˽��Э��(default), (��Ҫ���豸��ȡ����)
    BYTE          byZeroChan;                    //�Ƿ�����ͨ��,0-���ǣ�1-��
    BYTE        byPriority;                //���ȼ�
    BYTE        sUserName[NAME_LEN];        //�û���
    BYTE        sPassword[PASSWD_LEN];        //����
    BYTE        byDomain[MAX_DOMAIN_NAME];    //�豸����
    NET_DVR_IPADDR  struIP;                        //IP��ַ
    WORD        wDVRPort;                     //�˿ں�
    BYTE        byStreamType;               //������:0; ��������1
    BYTE        byOnline;                    //ֻ����0-������ 1-����
    DWORD        dwChannel;                  //ͨ����
    BYTE        byTransProtocol;            //Э�����ͣ�0-TCP��1-UDP��2-�ಥ
    BYTE        byLocalBackUp;                //���ر���: 0-������CVR���ر��ݣ�1-����CVR���ر���--���ط�ʱ����һ����¼���һ���ڴ浵�����ر��ݣ�
    WORD        wDirectLastTime;            //��������ʱ��
    BYTE        byChanNo[CHAN_NO_LEN];     //ͨ�����--����VAGȡ��
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE    byEnable;                    //�Ƿ�����
    BYTE    byProType;                    //Э�����ͣ�0-˽��Э��(default), 1-����Э�飬2-����, 3-�� (��Ҫ���豸��ȡ����)
    BYTE    byZeroChan;                    //�Ƿ�����ͨ��,0-���ǣ�1-��
    BYTE    byRes1;                        //�����ֶΣ���0
    BYTE    sUserName[NAME_LEN];        //�û���
    BYTE    sPassword[PASSWD_LEN];        //����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //ǰ��IP��������,��Ҫ�豸 ������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD    wDVRPort;                     //�˿ں�
    BYTE    byStreamType;               //������:0; ��������1
    BYTE    byOnline;                    //ֻ����0-������ 1-����
    DWORD   dwChannel;                //ͨ����
    BYTE    byTransProtocol;            //����Э�����ͣ�0-TCP��1-UDP 2-�ಥ
    BYTE    byLocalBackUp;                     //���ر��ݣ�0-������CVR���ر��ݣ�1-����CVR���ر���--��¼��ʱ����һ����¼���һ���ڴ浵�����ر��ݣ�
    BYTE    byRes2[2];                //�����ֶΣ���0
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //Э������ΪVAGʱ����Ӧ��VAGͨ�����
    BYTE    byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;


typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//��ý��IP 
    WORD    wStreamMediaPort; //��ý��˿�
    BYTE    byTransmitType; //��ý�崫��Э�� 0- TCP  1- UDP
    BYTE    byRes1[33];
    BYTE    byDevIP[64]; //�豸IP 
    WORD    wDevPort; //�豸�˿�
    BYTE    byChannel; //ͨ����
    BYTE    byTransMode; //����ģʽ 0-������ 1- ������ 
    BYTE    byProType;    
    //�������� 0-˽�� 1-�� 2-���� 3-�ɳ� 4-��ɫ�Ǽ� NET_DVR_GetIPCProtoList�ӿڻ�ȡ
    //VQD��ý����ֻ֧�� 0��1��ʽ��ֱ��֧�� 0��1��2��3��4
    BYTE    byTransProtocol; //����Э������0-TCP,  1-UDP,  2-�ಥ��ʽ,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byRes2[28];  //Ԥ��  
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//��ý��IP 
    WORD   wStreamMediaPort; //��ý��˿�
    BYTE    byTransmitType; //��ý�崫��Э�� 0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64]; //�豸IP 
    WORD   wDevPort; //�豸�˿�
    BYTE    byChannel; //ͨ����
    BYTE    byTransMode; //����ģʽ 0-������ 1- ������ 
    BYTE    byProType;    
    //�������� 0-���� 1-�� 2-���� 3-�ɳ� 4-��ɫ�Ǽ� NET_DVR_GetIPCProtoList�ӿڻ�ȡ
    //VQD��ý����ֻ֧�� 0��1��ʽ��ֱ��֧�� 0��1��2��3��4
    BYTE    byTransProtocol; //����Э������0-TCP,  1-UDP  2-�ಥ��ʽ
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byRes2[308];  //Ԥ��  
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable; 
    BYTE    byStreamType; //��������
    BYTE    byLocalBackUp; //�Ƿ񱾵ر���
    BYTE     byRes;
    BYTE    strURL[URL_LEN_V40]; //��ý��URL�����Լ���
    DWORD   dwProtocalType;   //IPCЭ������ֵ������ͨ����ȡIPCЭ���б�õ�
    BYTE    sUserName[NAME_LEN];   //�豸��½�û���
    BYTE    sPassWord[PASSWD_LEN]; // �豸��½����
    BYTE    byAddress[MAX_DOMAIN_NAME];  //����ԴIP��������,��Ҫ���� ������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    WORD    wIPPort;  //����Դ��Ӧ�Ķ˿ں�
    WORD    wChanNo; //����Դ�豸IPͨ����
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //����Դͨ�����,����VAG����
    BYTE     byRes1[88];   
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;

typedef union tagNET_DVR_STREAM_TYPE_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO    struChanInfo;          //IPͨ����Ϣ  ����ֵΪ0
    NET_DVR_PU_STREAM_URL                struStreamUrl;        //ͨ����ý�嵽urlȡ��������ֵΪ4
    NET_DVR_PU_STREAM_URL_CFG           struStreamUrlCfg; //ͨ����ý�嵽ָ������豸��ȡ��������ֵΪ6
}NET_DVR_STREAM_TYPE_UNION, *LPNET_DVR_STREAM_TYPE_UNION;

typedef union tagNET_DVR_STREAM_TYPE_V40_UNION
{
    NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40    struChanInfo;     //IPͨ����Ϣ������ֵΪ0
    NET_DVR_PU_STREAM_URL struPuStreamUrl;        //ͨ����ý�嵽urlȡ��������ֵΪ4
    NET_DVR_PU_STREAM_URL_CFG_V40   struStreamUrlCfg; //ͨ����ý�嵽���urlȡ��������ֵΪ6
    NET_DVR_RTSP_PROTOCAL_CFG struRtspCfg;        //�ɱ�׼RTSP����ȡ�� ����ֵ7
    NET_DVR_STREAM_URL_V40  struStreamUrlV40;  //ͨ����ý�壨֧�ּ�����ʽ��������Դȡ��������ֵΪ8
}NET_DVR_STREAM_TYPE_V40_UNION, *LPNET_DVR_STREAM_TYPE_V40_UNION;


typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE                    byGetStreamType;    //ȡ����ʽ��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��, 3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸���� 4-ͨ����ý����URLȥȡ��
    BYTE                    byRes[3];            // �����ֽ�
    NET_DVR_STREAM_TYPE_UNION    uGetStream;            // ��ͬȡ����ʽ�ṹ��
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

// ����Դ��Ϣ
typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD                        dwSize;
    NET_DVR_STREAM_MODE_TYPE    struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO,*LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD                    dwSize;
    BYTE                    byGetStreamType;    //ȡ����ʽ��0-ֱ�Ӵ��豸ȡ����1-����ý��ȡ����2-ͨ��IPServer���ip��ַ��ȡ��, 3.ͨ��IPServer�ҵ��豸����ͨ����ý��ȥ�豸���� 4-ͨ����ý����URLȥȡ�� 6-ͨ����ý�嵽ָ������豸��ȡ��
    BYTE                    byRes1[3];            // �����ֽ�
    NET_DVR_STREAM_TYPE_V40_UNION    uGetStream;            // ��ͬȡ����ʽ�ṹ��
    BYTE                    byMonitorName[128];/*��ص����ƣ�֧�����ģ���Сд��ĸ�����֣��»��ߵȷ������ַ��������ʽ���ݵ�¼���ص�byCharEncodeType�ֶ��жϣ�
                                                    ĿǰCVR��Ӣ�İ汾��һ�����в�ͬѡ������CVRҪ���ص�����Ϊgbk��Ӣ�İ汾CVRҪ���ص�����Ϊiso8859-1���硰����A��¥_��ص�1����*/
    BYTE                    byRes[384];            // �����ֽ�
}NET_DVR_STREAM_SRC_INFO_V40,*LPNET_DVR_STREAM_SRC_INFO_V40;


// ��¼����Ϣ
typedef struct 
{
    DWORD            dwSize;
    NET_DVR_RECORD_V30    struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

// ����ID��ʱ��μ���
typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD            dwSize;                // �ṹ���С
    NET_DVR_TIME    strBeginTime;        // ��ʼʱ��
    NET_DVR_TIME    strEndTime;            // ����ʱ��
    NET_DVR_STREAM_INFO struStreamInfo;        // ����Ϣ
    DWORD            dwRecordType;        // ¼������:  0xffffffff��ȫ��������ʱ¼��-�ƶ���⣬������������-�����������ƶ���⣬-�����������ƶ���⣬-�������-�ֶ�¼��-����¼��(ͬ�ļ�����)
    DWORD            dwLockDuration;        // ��������ʱ��,��λ�룬0xffffffff��ʾ��������
    NET_DVR_TIME_EX        strUnlockTimePoint;    // ����ʱ��Ч����dwLockDuration��Ϊ��������ʱ������������ʱ�䵽��ʱ�����Զ�����
    BYTE   		 	 byISO8601;      		//�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч,0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char       		 cTimeDifferenceH;      //��UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����, byISO8601Ϊ1ʱ��Ч
    char             cTimeDifferenceM;      //��UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����, byISO8601Ϊ1ʱ��Ч
    BYTE                byRes[1];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;

//�طų�֡�ӿ� ��ʼ��֡���� NET_DVR_START_DRAWFRAME����Ӧ�Ŀ��ƽṹ��
typedef struct tagNET_DVR_VOD_DRAWFRAME_PARA
{
    NET_DVR_TIME_EX struTime;
    /*
    dwDrawTypeֻ���豸֧��ѡ���Գ�֡ʱ����������Ч������֡��ʽ�У�
    0��ֻ��I֡
    1����1/2 P֡��ֻ��svc����֧�֣�
    2����3/4P֡ ��ֻ��svc����֧�֣�
    3����1/2 I֡(ֻ��I֡����ÿ2��I֡��һ����)
    4����1/4 I��(ֻ��I֡����ÿ4��I֡��һ����)
    5����1/8 I֡(ֻ��I֡����ÿ8��I֡��һ����)
    */
    DWORD  dwDrawType;
    BYTE   byRes[128];
}NET_DVR_VOD_DRAWFRAME_PARA, *LPNET_DVR_VOD_DRAWFRAME_PARA;

// ��ID+ʱ��طŽṹ��
typedef struct tagNET_DVR_VOD_PARA
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO struIDInfo; 
    NET_DVR_TIME        struBeginTime;
    NET_DVR_TIME        struEndTime;
    HWND                hWnd;
    BYTE                byDrawFrame; //0:����֡��1����֡
    BYTE                byVolumeType;  //0-��ͨ¼���  1-�浵��
    BYTE                byVolumeNum;  //��ţ�Ŀǰָ�浵���
    BYTE                byStreamType;   //�������� 0-�������� 1-��������2-������
    DWORD                   dwFileIndex;      //�浵���ϵ�¼���ļ������������浵��¼��ʱ���ص�ֵ
    BYTE                byAudioFile;    //��Ƶ�ļ�0-��1-��
    BYTE                byCourseFile;    //�γ��ļ�0-��1-��
    BYTE                byDownload;    //�Ƿ����� 0-��1-��
    BYTE                byOptimalStreamType;    //�Ƿ������������ͻط� 0-��1-�ǣ�����˫�����豸��ĳһ��ʱ���ڵ�¼���ļ���ָ���������Ͳ�ͬ���򷵻�ʵ���������͵�¼��
    BYTE                byRes2[20];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

typedef struct tagNET_DVR_VOD_PARA_V50
{
    DWORD                   dwSize;
    NET_DVR_STREAM_INFO     struIDInfo;
    NET_DVR_TIME_V50        struBeginTime;
    NET_DVR_TIME_V50        struEndTime;
    HWND                    hWnd;
    BYTE                    byDrawFrame; //0:����֡��1����֡
    BYTE                    byVolumeType;  //0-��ͨ¼���  1-�浵��
    BYTE                    byVolumeNum;  //��ţ�Ŀǰָ�浵���
    BYTE                    byStreamType;   //�������� 0-�������� 1-��������2-������
    DWORD                   dwFileIndex;      //�浵���ϵ�¼���ļ������������浵��¼��ʱ���ص�ֵ
    BYTE                    byAudioFile;    //�ط���Ƶ�ļ���0-���ط���Ƶ�ļ���1-���ط���Ƶ�ļ�
    BYTE                    byCourseFile;    //�طſγ��ļ�0-��1-��
    BYTE                    byPlayMode;    //���ŷ�ʽ0-���ţ�1-����
    BYTE                    byLinkMode;    //���ӷ�ʽ0-TCP��1-AdaptiveUDP
    BYTE                    byDownload;    //�Ƿ����� 0-��1-��
    BYTE                    byOptimalStreamType;    //�Ƿ������������ͻط� 0-��1-�ǣ�����˫�����豸��ĳһ��ʱ���ڵ�¼���ļ���ָ���������Ͳ�ͬ���򷵻�ʵ���������͵�¼��
    BYTE                    byDisplayBufNum;  //���ò��Ż���֡������Ϊ0ʱ��Ĭ��Ϊ3֡��hWnd��Ϊ��ʱ��Ч
    BYTE 					byNPQMode;	   //NPQ��ֱ��ģʽ�����ǹ���ý�� 0-ֱ�� 1-����ý��
    BYTE                    sUserName[NAME_LEN/*32*/]; //������֤�û���
    BYTE                    sPassword[PASSWD_LEN/*16*/]; //������֤����
    BYTE                    byRemoteFile;    //�ط�Զ���ļ�0-��1-��
    BYTE                    byRes2[203];
    char*					pSavedFileName;	//����ʱ�������¼���ļ�·����byDownloadΪ1ʱ��Ч�����ȳ���256���ᱻ�ض�
}NET_DVR_VOD_PARA_V50, *LPNET_DVR_VOD_PARA_V50;

// �ֶ�¼��
typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo; 
    DWORD            lRecordType;
    BYTE            byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;


// CABAC����ѹ������ѡ����������20%��ֻ��ģ��ͨ��������
typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD        dwSize;                  //�ṹ���С
    BYTE         byCabacEnable;           //����ѹ������ѡ��ֵ0 ������ 1 ����
    BYTE          byRes1[31];                  //����
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

#define  MAX_IOSPEED_GROUP_NUM      4 //IO���������
#define  MAX_IOOUT_NUM              4  //���IO����ڸ���
#define  MAX_IOIN_NUM               8  //���IO����ڸ���
#define  MAX_RELAY_NUM              12 //�̵��������豸����� 2013-11-04
#define  MAX_VEHICLE_TYPE_NUM        8  //������Ϣ�ܿ������2013-11-04
#define  MAX_IOIN_NUMEX             10 //���IO����ڸ���(��չ)
#define  MAX_ITC_LANE_NUM           6  //��󳵵�����
#define  MAX_LANEAREA_NUM           2  //����������������
#define  ITC_MAX_POLYGON_POINT_NUM    20    //����������֧��20����Ķ����
#define  MAX_ITC_SERIALCHECK_NUM    8 //����У�����͸���
#define  MAX_LIGHT_NUM              6 //���ͨ����
#define  MAX_VIDEO_INTERVAL_NUM     2  //���ץ�ļ����
#define  MAX_VIDEO_DETECT_LIGHT_NUM  12  //��Ƶ�������������
#define  MAX_CALIB_RECOG_NUM        2  //�궨�������
#define  MAX_RS485_NUM  12 //485�����֧����
#define  MAX_MOBILE_POLYGON_NUM     3 //�ƶ�����֧�������ʶ�������
#define  MAX_MOBILE_DETECTLINE_NUM  3 //�ƶ�����֧�����Υ�����߸���
#define  MAX_IOOUT_K_NUM            8  //Kϵ�����IO����ڸ���

//IO����ڲ�����3.1�汾������֮��
typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IOĬ��״̬��0-�͵�ƽ��1-�ߵ�ƽ 
    BYTE     byIOOutStatus;//IO��Чʱ״̬��0-�͵�ƽ��1-�ߵ�ƽ��2-����
    BYTE     byMode; //����ƹ�����ʽ,��λ��ʾ��0-��ʾ������1-��ʾ��������bit0-��Ƶ��bit1-���ڣ�bit2-Υ��
    BYTE     byIOWorkMode;//IO����ڹ���ģʽ��0-����ƣ�1-ƫ��,  2-������
    DWORD    dwTimeDelay;//IO��Ч����ʱ�䣬��λus
    WORD     wAheadTime;//���IO��ǰʱ�䣬��λus
    BYTE     byFreqMulti;        //��Ƶ����ֵ��Χ[1,15]
    BYTE     byDutyRate;        //ռ�ձȣ�[0,40%]
    BYTE     byDetectBrightness;/*�Զ��������ʹ�������0-����⣻1-���*/
    BYTE     byBrightnessThreld;/*ʹ�������������ֵ����Χ[0,100],������ֵ��*/
    BYTE     byFlashLightEnable;    //���������ʱ��ʹ��:0-��;1-��
    BYTE     byStartHour;        //��ʼʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE     byStartMinute;        //��ʼʱ��-��,ȡֵ��Χ0-59
    BYTE     byEndHour;        //����ʱ��-Сʱ,ȡֵ��Χ0-23
    BYTE     byEndMinute;        //����ʱ��-��,ȡֵ��Χ0-59
    BYTE     byAutoPlateBrightness;// ���������Զ�ʹ������� 0-������ 1-����
    BYTE     byIncrBrightEnable;//�Ƿ���������ģʽ��������ģʽ�£�
    BYTE     byIncrBrightPercent;//�����ٷֱȣ�0~100%����������ģʽ����Ч��
    WORD     wIncrBrightTime;//����ʱ��,��λΪ���루��������ģʽ����Ч��
    BYTE     byBrightness;//����ֵ��0~100��������ģʽ�£�
    BYTE     byEnvironBright;//�����ն�ֵ��0~100�������ģʽ����Ч���ò���ֻ���������ն�ֵ�������������������������ֵ���ͻ������ø�ֵ��Ϊ�ο���ȥ������Ӧ��������ֵ��
    WORD     wDelayCaptureTime;//��ʱץ��ʱ��1~1000ms����������ģʽ����Ч��
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;

typedef enum _ITC_TRIGGERMODE_TYPE_
{
    ITC_POST_IOSPEED_TYPE              = 0x1,  //IO���٣����ڣ�
        ITC_POST_SINGLEIO_TYPE             = 0x2,  //��IO���������ڣ�
        ITC_POST_RS485_TYPE                = 0x4,  //RS485���������������ڣ�
        ITC_POST_RS485_RADAR_TYPE          = 0x8,  //RS485�״ﴥ�������ڣ�
        ITC_POST_VIRTUALCOIL_TYPE          = 0x10,   //������Ȧ���������ڣ�
        ITC_POST_HVT_TYPE_V50               = 0x20,    //���п�����Ƶ����V50
        ITC_POST_MPR_TYPE                  = 0x40,   //��֡ʶ��(����)(Ver3.7)
        ITC_POST_PRS_TYPE                  = 0x80,   //��Ƶ��ⴥ������
        ITC_EPOLICE_IO_TRAFFICLIGHTS_TYPE  = 0x100,  //IO���̵ƣ��羯��
        ITC_EPOLICE_RS485_TYPE             = 0x200,  //RS485�������羯�������羯��
        ITC_POST_HVT_TYPE                   = 0x400,    //���п�����Ƶ���������ڣ�
        ITC_PE_RS485_TYPE                  = 0x10000,  //RS485��������ʽ�羯��������ʽ�羯��
        ITC_VIDEO_EPOLICE_TYPE             = 0x20000, //��Ƶ�羯��������ʽ�羯��
        ITC_VIA_VIRTUALCOIL_TYPE           = 0x40000,  //VIA��������
        ITC_POST_IMT_TYPE                   = 0x80000,   //�ǻۼ������
        IPC_POST_HVT_TYPE                   = 0x100000,    //IPC֧�ֵ�HVT
        ITC_POST_MOBILE_TYPE               = 0x200000, //�ƶ���ͨ����ģʽ
        ITC_REDLIGHT_PEDESTRIAN_TYPE       = 0x400000,    //���˴���ƴ���
        ITC_NOCOMITY_PEDESTRIAN_TYPE       = 0x800000    //���������˴���
}ITC_TRIGGERMODE_TYPE;

//�������ӿڵ������������ӦpOutBuf����
typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //�������ͣ���λ��ʾ������ITC_TRIGGERMODE_ABILITY���壬����������������Ͳ�ͬ���˴����صĴ�������Ҳ��ͬ
    BYTE byRes[16]; 
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM    
{
    BYTE byIntervalType;    //������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

//��ʶ����
typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д*/
    BYTE byEnable; //�Ƿ����ø�������ʶ��0-��1-��
    DWORD dwRecogMode;  
    /*ʶ������ͣ�
       bit0-����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) �� 
       bit1-����ʶ���С����ʶ��0-С����ʶ��1-����ʶ�� ��
       bit2-������ɫʶ��0-�����ó�����ɫʶ���ڱ���ʶ���С����ʶ��ʱ��ֹ���ã�1-������ɫʶ��
       bit3-ũ�ó�ʶ��0-������ũ�ó�ʶ��1-ũ�ó�ʶ�� 
       bit4-ģ��ʶ��0-������ģ��ʶ��1-ģ��ʶ��
       bit5-֡��λ�򳡶�λ��0-֡��λ��1-����λ��
       bit6-֡ʶ���ʶ��0-֡ʶ��1-��ʶ�� 
       bit7-���ϻ���죺0-���죬1-���� 
       bit8-Ħ�г�ʶ��0-������Ħ�г�ʶ��1-Ħ�г�ʶ��;
       bit9-����ģʽ��0-�羯/��֡��1-���ڣ�
       bit10-΢С���ƣ�0-�����ã�1-����΢С����ʶ��(����60��80)
       bit11-��ȫ����⣺0-�����ã�1-���ð�ȫ�����
       bit12-�񺽳���ʶ��: 0-�����ã�1-�����񺽳���ʶ��
       bit13-���ƹ�����б����: 0-�����ã�1-����������б����PRS��
       bit14-������ʶ��: 0-�����ã�1-����������ʶ��PRS��
       bit15-�������⣺0-�����ã�1-������������
       bit16-�Ʊ공��⣺0-�����ã�1-���ûƱ공���
       bit17-Σ��Ʒ������⣺0-�����ã�1-����Σ��Ʒ�������
       bit18-ʹ�ݳ���ʶ��0-�����ã�1-����ʹ�ݳ���ʶ�� 
       bit19-������Ʒ��ʶ��0-�����ã�1-���ó�����Ʒ��ʶ��
       bit20-��绰ʶ��0-�����ã�1-����
       bit21-����������ʶ��0-�����ã�1-����
    */
    BYTE byVehicleLogoRecog;//����ʶ�� 0-�����ã�1-����  
   /*
       0-������1-�ģ�2-����3-�壬4-����5-�ʣ�6-����7-��8-��9-��10-����11-ԥ��
       12-�ڣ�13-����14-�棬15-����16-�գ�17-�ӣ�18-�ɣ�19-�ɣ�20-����21-�࣬22-³��
       23-����24-�£�25-����26-����27-̨��28-��29-�أ�30-�ۣ�31-�£�32-�ƣ�33-�㣬
       34-�0xff-ȫ��
    */
    BYTE byProvince;//ʡ������ֵ
    BYTE byRegion;// ��������ֵ 0-������1-ŷ�ޣ�2-��������, 3-ŷ��&����˹(EU&CIS),4-�ж�(Middle East)
    BYTE byCountry;//��������������ö��COUNTRY_INDEX(��֧�֡�COUNTRY_ALL = 0xff,//ALL ȫ����)
    WORD wPlatePixelWidthMin;//��������ʶ������Сֵ����λ�����أ���ǰ�Ƽ���Χ[130,500]
    WORD wPlatePixelWidthMax;//��������ʶ�������ֵ����λ�����أ���ǰ�Ƽ���Χ[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

//����ͽṹ��
typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //��Ч�� ���ڵ���3������3����һ��������Ϊ����Ч�����߽�����Ϊ����Ч���� 
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //����α߽��,���20�� 
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM    
{
    BYTE byMode; //�������ͣ�0-���Σ�1-�����
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //��������
        NET_ITC_POLYGON struPolygon; //���������
    }uRegion;
    BYTE  byRes[16];    //����
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

//����IO���ٲ���
typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE byTrigCoil1; //��һ��Ȧ����IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil1IOStatus;//��һ��ȦIO�����״̬��0-�½��أ�Ĭ�ϣ���1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byTrigCoil2; //�ڶ���Ȧ����IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil2IOStatus;//�ڶ���ȦIO�����״̬��0-�½��أ�Ĭ�ϣ���1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE byTimeOut;//��ʱʱ�䣨Ĭ��10������λs
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    DWORD dwDistance;//��Ȧ���루Ĭ��1000��,��λ������
    BYTE byCapSpeed;//�����ٶȣ�Ĭ��30������λkm/h
    BYTE bySpeedLimit;//����ֵ��Ĭ��60������λkm/h
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySnapTimes1; //��Ȧ1ץ�Ĵ�����Ĭ�ϲ�ץ�ģ���0-��ץ�ģ���0-���Ĵ��������5�� 
    BYTE bySnapTimes2; //��Ȧ2ץ�Ĵ�����Ĭ��1����0-��ץ�ģ���0-���Ĵ��������5��
    BYTE byBigCarSpeedLimit; //�󳵳�������ֵ
    BYTE byBigCarSignSpeed;//��־����(��)����λkm/h(3.7Ver)
    BYTE byIntervalType;    //������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wInterval1[MAX_INTERVAL_NUM];//��Ȧ1���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    WORD wInterval2[MAX_INTERVAL_NUM];//��Ȧ2���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO�����(����ͬʱ�������)������0��ʾIO�����1������1��ʾIO�����2���Դ����ƣ�0-��������1-����
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-������·
    BYTE byCarSignSpeed;//��־���٣���λkm/h(3.7Ver)
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ����(������ʶ����1��������һ��)
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                        //С���޵���ֵ����λkm/h
    BYTE byBigCarLowSpeedLimit;                //���޵���ֵ����λkm/h
    BYTE byLowSpeedCapEn;                 //�Ƿ����õ���ץ�ģ�0-��1-��
    BYTE byEmergencyCapEn;                //�Ƿ�����Ӧ������ץ�ģ�0-��1-��
    BYTE byRes[27];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

//����IO���ٲ���
typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //����IO���������
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

//��IO����
typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO����Ĭ��״̬��0-�͵�ƽ��1-�ߵ�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE bySnapTimes; //ץ�Ĵ�����Ĭ��1����0-��ץ�ģ���0-���Ĵ��������5
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byEnable;//��IOʹ�ܱ�־0-�����ã�1-���� (Remark:����������֧�� bySupport&0x20����ʾ�Ƿ�֧�ֵ�IO��������IOʹ������ ʱ��Ч)
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    BYTE byEmergencyCapEn;  //�Ƿ�����Ӧ������ץ�ģ�0-��1-��
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ����
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

//��IO��������
typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //����IO��������
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //�Ƿ����øó�����0-�����ã�1-����
    BYTE byRelatedDriveWay;//�����ĳ�����
    WORD wDistance; //��Ȧ���룬�����ٶ�
    WORD wTrigDelayTime; //�����ӳ�ʱ�䣨Ĭ��200������λ������
    BYTE byTrigDelayDistance; //�����ӳپ��루Ĭ��0������λ������
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySignSpeed;//��־���٣���λkm/h
    BYTE bySpeedLimit;//����ֵ����λkm/h
    BYTE bySnapTimes; //ץ�Ĵ�����Ĭ��1����0-��ץ�ģ���0-���Ĵ��������5
    BYTE byOverlayDriveWay; //OSD���ӵĳ�����
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byCartSignSpeed;//��־����(��)����λkm/h
    BYTE byCartSpeedLimit;//����ֵ���󳵣�����λkm/h
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-������·
    BYTE byUseageType; //������;���ͣ����ITC_LANE_USEAGE_TYPE
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                    //С���޵���ֵ����λkm/h
    BYTE byBigCarLowSpeedLimit;                //���޵���ֵ����λkm/h
    BYTE byLowSpeedCapEn;                   //�Ƿ����õ���ץ�ģ�0-��1-��
    BYTE byEmergencyCapEn;                 //�Ƿ�����Ӧ������ץ�ģ�0-��1-��
    BYTE byRes[9];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

//����RS485��������������
typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byTriggerSpareMode; //��������ģʽ��0-Ĭ�ϣ�1-����������Ȧģʽ,2-���ڻ�ϳ���ģʽ
    BYTE byFaultToleranceTime;//�ݴ�ʱ��(��λ:����)�����ڼ�⳵�����Ƿ����������ʱ��
    BYTE byRes1; 
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;    //�״����ͣ�0-���״�,1-�������״2-����ά�ǣ�3-����΢��4,�״��IO��չ��(�˲����ڿ���������Ȧ�����п��ڽ�����ʹ�ã�����RS485�״ﲻʹ��),0xff-��������
    BYTE    byLevelAngle;   //��ˮƽ�����ɽǶ�,Ĭ��Ϊ25��(0��90��)
    WORD    wRadarSensitivity; //�״������� 
    WORD    wRadarSpeedValidTime;//�״��ٶ���Чʱ��(0~2000] ,0��ʾ��֧��
    BYTE    byRes1[2];
    float      fLineCorrectParam;//���Խ�������[0.0~2.0]
    int      iConstCorrectParam;//������������[-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND  //�����ṹ
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;//������RS485�� 1��5 (Ψһֵ)
    //    BYTE  byModeType; //0��Ԥ����1���״2����������3���źŵƼ����
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND,*LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;//24
    BYTE  byAssociateLaneNo;//�����ĳ�����1��99 (���ֵ�����ڲ�ͬRS485���ظ�)
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;

typedef union tagNET_ITC_ACCESS_DEVINFO_PARAM_UNION
{
    BYTE uLen[128];
    NET_ITC_RADAR_INFO_PARAM struRadarInfoParam;//�״��������
}NET_ITC_ACCESS_DEVINFO_PARAM_UNION, *LPNET_ITC_ACCESS_DEVINFO_PARAM_UNION;

typedef struct tagNET_ITC_RS485_ACCESS_CFG //144  ���ýṹ
{
    DWORD dwSize;
    BYTE  byModeType;//0��Ԥ����bit1���״bit2����������bit3���źŵƼ����
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam; //64
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG,*LPNET_ITC_RS485_ACCESS_CFG;

//2013-07-09 �״����������չ
typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];//�೵���״���Ϣ
    //����������������ʾ����֧�ֵ�Ĭ��Ϊ0������ʾ  ���м�������֧�ּ�����
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;


//����RS485�״ﴥ������
typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    NET_ITC_RADAR_PARAM struRadar;  //�״����
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE bySignSpeed;//��־���٣���λkm/h
    BYTE bySpeedLimit;//����ֵ����λkm/h
    BYTE bySnapTimes; //ץ�Ĵ�����Ĭ��1����0-��ץ�ģ���0-���Ĵ��������5
    BYTE byBigCarSignSpeed;///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLowSpeedLimit;/*�޵��٣���λkm/h*/
    BYTE byBigCarLowSpeedLimit; /*���޵��٣���λkm/h*/
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    NET_VCA_LINE struLine; //������
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  /*������Ȧ����*/
    BYTE byTrigFlag; //������־��0-��ͷ������1-��β������2-��ͷ/��β������
    BYTE byTrigSensitive;  //���������ȣ�1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO�����(����ͬʱ�������)������0��ʾIO�����1������1��ʾIO�����2���Դ����ƣ�0-��������1-����
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-������·
    BYTE byEnableRadar; //�Ƿ������״���٣�0-��1-��
    NET_ITC_VTLANE_PARAM struLane; //�����ĳ�������
    //������;���ͣ����ITC_LANE_USEAGE_TYPE��ʹ��1��8��������(3.7Ver)
    BYTE byUseageType; 
    //������ʻ�������ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

//����������Ȧ��������
typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE    byRelatedLaneNum;//�����ĳ�������
    BYTE    byIsDisplay; //��Ƶ���Ƿ���ʾ������Ȧ��0-����ʾ��1-��ʾ
    BYTE    byLoopPos; //��䴥����Ȧ��ƫ��Ĭ��10��
    BYTE    byPolarLenType; /*ƫ�����ͣ�0������ƫ�񾵣�1����ʩ�͵�ƫ�񾵡�*/
    BYTE    byDayAuxLightMode; /*���츨������ģʽ��0���޸���������1��LED��������2�����������*/
    BYTE    byVideoLaneNO; //��Ƶ�ο����ȵĲο�������
    BYTE    byVideoLowTh; /*��Ƶ�ο����ȵ���ֵ��ʼ��ֵ��Ĭ��40��*/
    BYTE    byVideoHighTh; /*��Ƶ�ο����ȸ���ֵ��ʼ��ֵ��Ĭ��55��*/
    BYTE    byRecordMode; //¼���־��0-��¼��1-¼��
    BYTE     bySnapMode;//ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    /*���ٷ�ʽ��0-�����٣�0x1-�״���٣�0x2-��Ƶ����*/
    BYTE    bySpeedDetector;
    BYTE    byRes2;
    WORD    wResolutionX;/* �豸��ǰ�ֱ��ʿ�*/
    WORD    wResolutionY;/* �豸��ǰ�ֱ��ʸ�*/
    DWORD   dwDayInitExp; /*��Ƶ�����ع�ʱ��ĳ�ʼֵ2000*/
    DWORD   dwDayMaxExp; /*��Ƶ�����ع�ʱ������ֵ20000*/
    DWORD   dwNightExp; /*�����Ƶ�ع�ʱ�������ֵ3000*/
    DWORD   dwSnapExp; /*ץ���ع�ʱ��*/
    BYTE    byDayInitGain; /*��Ƶ��������ĳ�ʼֵ200*/
    BYTE    byDayMaxGain; /*��Ƶ������������ֵ400*/
    BYTE    byNightGain; /*�����Ƶ����*/
    BYTE    bySnapGain; /*ץ������*/
    DWORD   dwSceneMode; //����ģʽ�� ���SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //��ַλ��(Ĭ���㽭)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //������Ȧ����
    NET_ITC_RADAR_PARAM struRadar;  //�״����
    NET_VCA_LINE struLine; //�ҳ�����
    //Υ�������ͣ���λ��ʾ�����ITC_VIOLATION_DETECT_TYPE��0-�����ã�1-����(3.7Ver)
    DWORD dwVioDetectType;    
    BYTE  byDebugMode; /*����ģʽ��0-�����ã�1-����*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

//����IO���̵Ʋ���
typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE byLightIO; //���̵�IO��0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrafficLight; //���̵���Ч״̬0-�ߵ�ƽ��ƣ��͵�ƽ�̵ƣ�1-�ߵ�ƽ�̵ƣ��͵�ƽ���
    BYTE byTrigIO;//������IO�ţ�0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrigIOStatus;//����IO�ڵ�״̬��Ĭ��0����0-�½��أ�1-�����أ�2-�����غ��½��أ�3-�ߵ�ƽ��4-�͵�ƽ
    BYTE byRelatedDriveWay;//�����ĳ�����
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE byRedSnapTimes; //���ץ�Ĵ�����0-��ץ�ģ���0-���Ĵ��������5�� 
    BYTE byGreenSnapTimes; //�̵�ץ�Ĵ�����0-��ץ�ģ���0-���Ĵ��������5��
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    BYTE byRes1;
    BYTE byIntervalType;    //������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wRedInterval[MAX_INTERVAL_NUM];//������ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    WORD wGreenInterval[MAX_INTERVAL_NUM];//�̵����ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //��ʶ�������
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

//�羯IO���̵Ʋ���
typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //����IO���̵Ʋ���
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;

typedef enum _ITC_SERIAL_PROTOCOL_
{
    ITC_PROTOCOL_UNKNOW = 0, /*δ֪*/
        ITC_SINGLE_COIL_PROTOCOL_MODE1 = 1, /*����Ȧ������Э��ģʽ1����ʾΪ����_��1_��1_��1_1��������뿪���뿪��ʱץ�ģ��뿪��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE1 = 2, /*˫��Ȧ������Э��ģʽ1����ʾΪ��˫_��1_��1_��2_1��������1���뿪1���뿪2ץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ����Ĭ�ϣ�*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE2 = 3, /*˫��Ȧ������Э��ģʽ2����ʾΪ��˫_��1_��2_��2_1�����뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE3 = 4, /*˫��Ȧ������Э��ģʽ3����ʾΪ��˫_��2_��1_��2_1��������2���뿪1���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE4 = 5, /*˫��Ȧ������Э��ģʽ4����ʾΪ��˫/��_��2_��2_��2_1��������2���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�3�ų���ͼƬ�ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE5 = 6, /*˫��Ȧ������Э��ģʽ5����ʾΪ��˫/��_��2_��2_��2_2��������2���뿪2���뿪2��ʱץ�ģ�����2���뿪1����ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ����Ĭ�ϣ�*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE6 = 7, /*˫��Ȧ������Э��ģʽ6����ʾΪ��˫/��_��1_��2_��2_2��������1���뿪2���뿪2��ʱץ�ģ�����1���뿪1����ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE7 = 8, /*˫��Ȧ������Э��ģʽ7����ʾΪ��˫_��1_��1_��2_1��������1���뿪1���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1������Ƶ���1���뿪1���뿪2��ʱ���ͳ��ƽ��*/
        ITC_DOUBLE_COIL_PROTOCOL_MODE8 = 9, /*˫��Ȧ������Э��ģʽ8����ʾΪ��˫_��1_��1_��2_2��������1���뿪1���뿪2��ʱץ�ģ�����1���뿪1����ʶ���ϴ�����ͼƬ�������뿪1������Ƶ���1���뿪1���뿪2��ʱ�������Ŷȸߵĳ��ƽ����Ĭ�ϣ�*/
        ITC_SINGLE_COIL_PROTOCOL_MODE2 = 10, /*����Ȧ������Э��ģʽ2����ʾΪ����_��1_��1_��1_2��������뿪���뿪��ʱץ�ģ�����뿪����ʶ���ϴ�����ͼƬ�������뿪������Ƶ���뿪���뿪��ʱ�������Ŷȸߵĳ��ƽ����Ĭ�ϣ�*/
        ITC_OTHER_PROTOCOL = 0xff /*����������Э��(������demo�������ã�3.3֮��汾������demo�Ϳؼ�����֧�ִ�ֵ)*/
}ITC_SERIAL_PROTOCOL;

//���������߼�ץ������
typedef enum _ITC_NORMAL_PASS_SERIAL_PROTOCOL_
{
    ITC_NORMAL_PASS_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_NORMAL_PASS_PROTOCOL_MODE1  = 1,  //����Ȧ���뿪ץ�ģ���ʶ�ϴ���Ĭ�ϣ�
        ITC_NORMAL_PASS_PROTOCOL_MODE2 =2,  //����Ȧ������뿪ץ�ģ�����ʶ�����ϴ��뿪����ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_NORMAL_PASS_PROTOCOL_MODE3 =3,  //˫��Ȧ���뿪1ץ�ģ���ʶ�ϴ���Ĭ�ϣ�
        ITC_NORMAL_PASS_PROTOCOL_MODE4 =4, //˫��Ȧ������1���뿪1ץ�ģ�����ʶ�����ϴ��뿪1����ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_NORMAL_PASS_PROTOCOL_MODE5 =5, //˫��Ȧ������2���뿪1ץ�ģ�����ʶ�����ϴ��뿪1����ͼƬ�����Ŷȸߵĳ��ƽ��
}ITC_NORMAL_PASS_SERIAL_PROTOCOL;

//����Υ���߼�ץ������
typedef enum _ITC_INVERSE_SERIAL_PROTOCOL_
{
    ITC_INVERSE_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_INVERSE_PROTOCOL_MODE1  = 1,  //��ץ��
        ITC_INVERSE_PROTOCOL_MODE2 =2,  //����1��ץ2�š��뿪2ץ�ģ�����1���ž���ʶ���ϴ�3�ų���ͼƬ�����Ŷȸߵĳ��ƽ��
        ITC_INVERSE_PROTOCOL_MODE3 =3,  //����1���뿪2ץ�ģ�����1��ʶ���ϴ�2�ų���ͼƬ�ͳ��ƽ��
}ITC_INVERSE_SERIAL_PROTOCOL;

//����Υ���߼�ץ������
typedef enum _ITC_SPEED_SERIAL_PROTOCOL_
{
    ITC_SPEED_SERIAL_UNKNOW     =  0,   //δ֪
        ITC_SPEED_PROTOCOL_MODE1  = 1,  //��ץ��
        ITC_SPEED_PROTOCOL_MODE2 =2,  //˫/����Ȧ���뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1�������뿪1���뿪2���뿪2��ʱ���ͳ��ƽ��
        ITC_SPEED_PROTOCOL_MODE3 =3,  //˫/����Ȧ���뿪1���뿪2���뿪2��ʱץ�ģ��뿪1��ʶ���ϴ�����ͼƬ�������뿪1�������뿪1���뿪2���ͳ��ƽ��
}ITC_SPEED_SERIAL_PROTOCOL;

//����������
typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //������Э�����ͣ����ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;    //������ͣ�Ĭ�ϰ�ʱ�䣩��0-ʱ����Ч,1-������Ч
    WORD wInterval;//���ļ��ʱ�䣨��λms�������ļ�����루��λ���ף�����byIntervalTypeΪ0ʱ����ʾ���ʱ�䣬��byIntervalTypeΪ1ʱ����ʾ����
    BYTE byNormalPassProtocol; //��������ץ��Э�����ͣ����ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //����ץ��Э�����ͣ����ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //����ץ��Э�����ͣ����ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //�Ƿ����øó�����0-�����ã�1-����
    BYTE byRelatedDriveWay;//�����ĳ�����
    WORD wDistance; //��Ȧ���룬��λ����
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE bySignSpeed;//��־����(��ʽ�羯ģʽ��Ч)����λkm/h
    BYTE bySpeedLimit;//����ֵ(��ʽ�羯ģʽ��Ч)����λkm/h
    BYTE byOverlayDriveWay; //OSD���ӵĳ�����
    NET_ITC_SERIAL_INFO struSerialInfo; //����������
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //������IO����ڣ�����ͬʱ�������
    BYTE byFlashMode;   //�������˸ģʽ��0-ͬʱ����1-������
    BYTE bySerialType; //���������ͣ�0-˽�г�������1-˽��OEM��������2-����������
    BYTE byRelatedIOOutEx;//��0λ��ʾIO�����1���Դ����ƣ�0-��������1-���� ֧�ֹ�����8��(����byRelatedIOOut�ֶ�)
    BYTE bySnapPicPreRecord; //ץ��ͼƬԤ¼ʱ��㣻0-Ĭ��ֵ���ڶ���ͼƬ����1-��һ��ͼƬ��2-�ڶ���ͼƬ��3-������ͼƬ
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //������ʶ����
    BYTE byBigCarSignSpeed;    ///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/    
    BYTE byRedTrafficLightChan;//���ͨ���ţ�1��16�����̵Ƽ������
    BYTE byYellowTrafficLightChan;//�Ƶ�ͨ���ţ�1��16�����̵Ƽ������
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

//�羯/��ʽ�羯RS485��������������
typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//�����ĳ�������
    BYTE byTrafficLightSignalSrc;//��ͨ���ź���Դ 0�������� 1�����̵Ƽ����
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //�����ĳ�������
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

//�������Բ����ṹ
typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType;     //������;���ͣ����ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType;  //�����������ͣ����ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //������ʻ�������ITC_LANE_CAR_DRIVE_DIRECT 
    BYTE byRes[33];        //����
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

//��Ƶ�羯�߽ṹ
typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //�߲���
    BYTE byLineType; //�����ͣ����ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE     byVehicleCapMode;//������ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE     byNoVehicleCapMode;//�ǻ�����ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE     byPasserCapMode;//����ץ��ģʽ��0-Ƶ��ģʽ��1-����ģʽ
    BYTE     byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

//size = 128
typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD         dwCapShutter;            //ץ�Ŀ���0~65535
    WORD         wCapGain;            //ץ������0��100
    BYTE          byRes[2];
    DWORD         dwDayTimeVideoShutter;    //�����ع�ʱ�����ֵ
    WORD         wDayTimeVideoGain;        //�����������ֵ
    WORD         wNightVideoGain;            //�����������ֵ
    DWORD         wNightVideoShutter;        //�����ع�ʱ�����ֵ
    BYTE          byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //�����ĳ����� 1~255�����ڵ��Ӻ��ϴ���
    BYTE bySignSpeed;    //��־���٣���λkm/h 0��255  70
    BYTE bySpeedLimit;    //����ֵ����λkm/h 0��255    80 ʵ����Ч
    BYTE byBigCarSignSpeed;///*�󳵱�־���٣���λkm/h*/
    BYTE byBigCarSpeedLimit;/*������ֵ����λkm/h*/
    BYTE bySpeedCapEn; //�Ƿ����ó���ץ�ģ�0-��1-��
    BYTE byCaptureCount;//ץ������1��5(����)
    BYTE byRelatedIOOut;    /*������IO�����(����ͬʱ�������)����λ��ʾIO����ڣ���0λ��ʾIO�����1���Դ����ƣ�0-��������1-����*/
    BYTE byFlashMode;        /*�������˸ģʽ��0-ͬʱ����1-������*/
    BYTE byEnableRadar; //�Ƿ������״���٣�0-��1-��
    BYTE byChangeLaneEnable;   //Υ�±��ץ��ʹ�ܣ�0-�رգ�1-����
    BYTE byChangeLaneCapNo;    //Υ�±��ץ������2-3
    DWORD dwCapTarget;    //ץ������ bit0 ��ʾ������ bit1 ��ʾ�ǻ����� bit2 ��ʾ���� 0����ʾ��ѡ�� 1����ʾѡ��
    NET_ITC_INTERVAL_PARAM struInterval; //ץ�ļ������
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //�������ԣ���byUseageType��byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;          //�󳵵��ߣ�������Ϊ���ߡ�ʵ�ߡ������ߺ�˫����
    NET_ITC_LINE struRightLaneLine;          //�ҳ����ߣ�������Ϊ���ߡ�ʵ�ߡ������ߺ�˫����
    NET_ITC_POLYGON struPlateRecog;         //��ʶ�������
    NET_ITC_POLYGON struTraceArea;          //��Ƶ������������
    NET_VCA_LINE  struForwardTrigLine;      //���򴥷��ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧��ˮƽ���ã��ӿڰ��߶ε������˵㱣�档��һ������Ϊ����������Ѵ���λ�ã�     
    NET_VCA_LINE  struBackwardTrigLine;     //���򴥷��ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧��ˮƽ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ����������Ѵ���λ�ã�
    NET_VCA_LINE  struLeftTrigLine;          //��ߴ����ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧�ִ�ֱ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ����߽��복������Ѵ���λ�ã�
    NET_VCA_LINE  struRightTrigLine;          //�ұߴ����ߣ�һ���߶Σ����Ķ˵�λ�ã�Ŀǰֻ֧�ִ�ֱ���ã��ӿڰ��߶ε������˵㱣�棨һ������Ϊ���ұ߽��복������Ѵ���λ�ã�
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//ʶ��ĳ���������1-6 
    BYTE bySceneMode;//0-δ֪1-������·��2-С�������
    BYTE byRoadExpBright;//·���������ȣ���Ƶ�ع��������������֮һ�����޻�����ʱ�����ݴ���������ֵ��������Ƶ�ع������
    BYTE byPlateExpBright;//�����������ȣ���Ƶ�ع��������������֮һ�����л�����ͨ����ʶ�𵽳���ʱ�����ݴ���������ֵ������Ƶ�ع����������
    NET_ITC_POLYGON struDetectArea;                    //��Ƶ�������  
    NET_ITC_SNAPMODE_PARAM  struCapMode;//ץ��ģʽ  
    NET_ITC_HVT_EC_PARAM struEcParam;    //�ع���Ʋ���  
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //����������
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;    //��ʶ����
    NET_DVR_GEOGLOCATION struGeogLocation;    //��ַλ�ã�Ĭ���㽭��
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

/*************************MPR����ģʽ begin 2013-12-07****************/
typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO��[1, byIoInNum+1] ��С��1��ʼ�����ֵ���ݽӿ���������NET_DVR_SNAP_ABILITY���ֶ�byIoInNum
            BYTE  byTriggerType;//0-�½��أ�1-������
            BYTE  byRes1[2];
        }struIO;//IOģʽ����Ч
        struct
        {
            BYTE  byRelateChan;//����������ͨ����[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; //������ʻ���� ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPEtypedef struct tagNET_ITS_PICTURE_INFO
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_MPR_PARAM,*LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR��������Ƶ������,1-����IO�������ظ���Ȧ��,2-����RS485�Ĵ����ź�
    BYTE byPicUploadType;//ͼƬ�ϴ����ͣ�0~ȫ���ϴ���1-�����ϴ���2-�����ϴ�
    BYTE byRoadType;//ģʽѡ�� 0-����ڣ�1-���е�·��2-�Զ��壬3-�������룬4-����, 5-�ΰ����(��ģʽ�¿��Լ�⳵���Ƚϻ�����û�г����ߵĳ���)
    BYTE byRes2;
    WORD wCustomDelayTime;//�Զ���ץ����ʱʱ�䣨��byRoadTypeΪ "�Զ���"��ʱ����Ч������Χ��[0,15000]ms
    BYTE byRes[56];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char szSceneName[NAME_LEN/*32*/]; //��������
    NET_VCA_LINE struSnapLine;//ץ���ߣ�������ļ��跽ʽΪ��װ���������������Ч����4.5��NET_DVR_CAMERA_SETUPCFG�ṹ����byErectMethod�ֶ�Ϊ1ʱ ��
    BYTE byRes1[392];
}NET_ITC_POST_MPR_PARAM,*LPNET_ITC_POST_MPR_PARAM;
/*************************MPR����ģʽ end 2013-12-07****************/

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //����������
    BYTE byRes[63]; //���� 
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //�������Բ���
    NET_ITC_LINE  struLaneLine;//������  
    NET_ITC_POLYGON  struPlateRecog;//��ʶ����  
    BYTE byRes1[300]; //���� 
} NET_DVR_VIA_LANE_PARAM,*LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;    //ʹ�� 0-������ 1-����
    BYTE byLaneNum; //������
    BYTE byRes[62]; //����     
    NET_ITC_LINE  struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ� 
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//��ʶ����      
    BYTE byRes1[624];//����
}NET_DVR_VIA_VTCOIL_PARAM,*LPNET_DVR_VIA_VTCOIL_PARAM;

//���������ӿ�
typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //�ṹ���С
    DWORD  dwChannel;    //ͨ����
    DWORD  dwTriggerMode;//������ʽ���ο� ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    BYTE   byRes[63];    //������
}NET_DVR_TRIGGER_COND,*LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;//���ӳ�����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;//������
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM,*LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySnapMode; //ץ�����ͣ�0~��������1~������
    BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//��ʶ���� 
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ����ұ߳����ı߽��ߣ�
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM,*LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO��[1,4]
            BYTE  byTriggerType;//0-�½��أ�1-������
            BYTE  byRes1[2];
        }struIO;//IOģʽ����Ч
        struct
        {
            BYTE  byRelateChan;//����������ͨ����[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byRes2[3];
    NET_ITC_LINE struTrigLine;//������
    BYTE byRes1[228];
}NET_ITC_LANE_PRS_PARAM,*LPNET_ITC_LANE_PRS_PARAM;


typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-��Ƶ���,1-����IO�������ظ���Ȧ��,2-����RS485�Ĵ����ź�
    BYTE bySnapMode;//0-ȫ��ͼ��1-ȫ��ͼ+��д
    BYTE byCapMode;//bySourceTypeΪ0��Ƶ���ʱʹ�ã�0-Ƶ��ģʽ��1-����ģʽ
    BYTE byNoPlatCarCap;//�Ƿ������޳���ץ�� 0-������ 1-����
    BYTE bySceneMode;//����ģʽ:0-��ͨ����ڳ�����1-�շ�վģʽ����(����ͣ��ʱ��ϳ�)��2-����ͣ��������ڳ���(�����ҹ���ϰ�)
    BYTE byRes[57];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM,*LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //������ʻ���� ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_POLYGON struPlateRecog;//��ʶ����
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM,*LPNET_IPC_LANE_HVT_PARAM;

typedef struct _NET_ITC_PARKING_DETECTION_
{
    BYTE        byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE        byRes; //�����ֽ�
    WORD       wDuration;//���ʱ��������λ��s
    WORD       wAlarmIntervalTime;//�ϴ�ʱ��������λ��s
    BYTE        byRes1[58]; //�����ֽ�
}NET_ITC_PARKING_DETECTION, *LPNET_ITC_PARKING_DETECTION;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;    
    BYTE  byLaneNum;
    BYTE byEnhancedMode;    //��ǿģʽ��0-�����ã�1-����    
    BYTE byPicRecognition;  //��������ͼƬ����ʶ��0-�����ã�1-����
    BYTE  byRes[60];
    NET_ITC_LINE struLaneBoundaryLine;//�����߽��ߣ�����߳�������߽��ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//��ʶ����  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char    szSceneName[NAME_LEN/*32*/]; //��������
    NET_VCA_LINE struSnapLine;//ץ���ߣ�ץ������ļ��跽ʽΪ��װ���������������Ч����4.5��NET_DVR_CAMERA_SETUPCFG�ṹ����byErectMethod�ֶ�Ϊ1ʱ ��
    NET_ITC_PARKING_DETECTION struParkingDetection;    //ͣ��������
    BYTE byRes1[328];
} NET_IPC_POST_HVT_PARAM,*LPNET_IPC_POST_HVT_PARAM;

//ץ�Ļ�4.0����
typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE  byLaneNO;        //�����ĳ�����1��255(���ڵ��Ӻ��ϴ�)
    BYTE  byFlashMode;    //�������˸ģʽ��0-ͬʱ����1-������
    BYTE  bySignSpeed;    //С����־�޸��٣���λkm/h
    BYTE  bySpeedLimit;    //С���޸���ֵ����λkm/h
    BYTE  bySignLowSpeed;    //С����־�޵��٣���λkm/h
    BYTE  byLowSpeedLimit;    //С���޵���ֵ����λkm/h
    BYTE  byBigCarSignSpeed;    //�󳵱�־�޸��٣���λkm/h���½��棩
    BYTE  byBigCarSpeedLimit;    //���޸���ֵ����λkm/h���½��棩
    BYTE  byBigCarSignLowSpeed;    //�󳵱�־�޵��٣���λkm/h
    BYTE  byBigCarLowSpeedLimit;    //���޵���ֵ����λkm/h
    BYTE  bySnapTimes;    //����ץ��������1~3
    BYTE  byDriveLineSnapTime;// ѹ��ץ������ 1~3
    BYTE  byHighSpeedSnapTime;// ������ץ������1~3
    BYTE  byLowSpeedSnapTime;// ������ץ������1~3
    BYTE  byBanSnapTime;// Υ������ץ������  1~3
    BYTE  byReverseSnapTime;//����ץ������  1~3
    BYTE  byRelatedDriveWay;                //���������ţ�����ƥ�䳵����
    BYTE  byLaneType;   //�������ͣ�0-δ���á�1-���ٹ�·��2-���п���·��0xff-������·
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ������������������������byRelatedDriveWay��Ӧ��ȷ������Ψһ�ԡ�
    BYTE  byRelaLaneDirectionType;
    BYTE  byRes1[27];
    BYTE  byChangeLaneEnable;   //Υ�±��ץ��ʹ�ܣ�0-�رգ�1-����
    BYTE  byChangeLaneCapNo;    //Υ�±��ץ������2-3
    //Ŀǰ��ʹ�õ�һ�������ģ��Ժ���ܻ���չΪ�೵���ֱ�����
    //����, ��λ��ʾ,0-������,1-���òο� ITC_VIOLATION_DETECT_TYPE
    DWORD  dwVioDetectType;
    DWORD  dwRelatedIOOut;  //������IO�����(����ͬʱ�������)����λ��ʾIO����ڣ���0λ��ʾIO�����1���Դ����ƣ�0-��������1-����
    NET_ITC_LINE struTrigLine; //�����ߣ�Ŀǰ��ʹ�õ�һ�������ģ��Ժ���ܻ���չΪ�೵���ֱ�����
    NET_ITC_LINE struLineLeft;                //�󳵵���
    NET_ITC_POLYGON struPlateRecog;       //��ʶ����
    NET_ITC_LANE_LOGIC_PARAM struLane;   //�������ԣ���byUseageType��byCarDriveDirect
    NET_ITC_INTERVAL_PARAM struInterval;//ץ�ļ��������20byte��
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;

typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;    //ʶ��ĳ���������1-6
    BYTE byCapType;        //ץ�����ͣ�0-�����ǡ��ˣ�Ĭ�ϣ���1-������
    BYTE byCapMode;    //ץ�ķ�ʽ��0-��Ƶ��֡��1-���ץ�ģ�2-���ģʽ�� 
    BYTE bySecneMode;    //����ģʽ��0-������·��Ĭ�ϣ���1-С������ڣ�2-���ٹ�·    
    BYTE bySpeedMode;  //����ģʽ��0-�޲��٣�1-�״���٣�2-��Ƶ����
    BYTE byLineRuleEffect; //������������Ч��,ÿһλ����һ��������,0-��Ч;1-��Ч��bit0-�󴥷���;bit1-�Ҵ�����;bit2-��Ƶ�������
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;    //�󴥷���(һ����ֱ��)
    NET_ITC_LINE struRigtTrigLine;    //�Ҵ�����(һ����ֱ��)
    NET_ITC_LINE struLaneBoundaryLine;        //�����߽��ߣ����ұ߳������ҳ����ߣ�
    NET_ITC_POLYGON struDetectArea;    //��Ƶ�������
    NET_DVR_GEOGLOCATION struGeogLocation; //����λ�ã�Ĭ���㽭ʡ������ʱ��
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //����������
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;    //��ʶ����
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;


//��������
typedef struct tagNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byRelatedDriveWay;//�����ĳ�����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    BYTE byPedestriansNum;//����������ֵ����Χ1-100��Ĭ��ֵ1
    BYTE byVehicleSpeed;//�����ٶ���ֵ����Χ0-100��Ĭ��ֵ0
    DWORD dwVehicleInterval; //���������ֵ����Χ0-65536��Ĭ��ֵ0
    BYTE byPedesDetRule; //���˼����򣻴������˼��������������ʻ���� 0~���� 1~���ҡ�
    BYTE byRes[3];
    NET_ITC_LINE struLaneLine;//������
    NET_ITC_LINE struStopLine;//ֹͣ��
    NET_ITC_POLYGON struPlateRecog;       //��ʶ���� 
    BYTE byRes1[280];
} NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM;

//���������˲���
typedef struct tagNET_ITC_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //ʹ��
    BYTE byLaneNum;// ����������������Χ1-3��Ĭ��ֵ3
    BYTE byRes[74];
    NET_ITC_LINE struLaneBoundaryLine;//�����ұ߽���
    NET_ITC_LINE struTriggerLine;//���������˴�����
    NET_ITC_POLYGON struPedesDetRecog;//���˼������
    NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    //��������
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    BYTE byRes1[400];
}NET_ITC_NOCOMITY_PEDESTRIAN_PARAM,
*LPNET_ITC_NOCOMITY_PEDESTRIAN_PARAM;

//����IO�����źŵƲ���
typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //��ͨ�Ƶ�������,0-��ת��,1-ֱ�е�,2-��ת��
    BYTE byRelatedIO; //������IO�ں�
    BYTE byRedLightState; //��Ƶ�ƽ״̬��0-�ߵ�ƽ��ƣ�1-�͵�ƽ���
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

//IO�����źŵƲ���
typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //����IO�����źŵƲ���
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

//����485�����źŵƲ���
typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //��ͨ�Ƶ������ͣ�0-��ת�ƣ�1-ֱ�еƣ�2-��ת��
    BYTE byRelatedLightChan; //�����ĺ��̵Ƽ����ͨ����
    BYTE byInputLight;    //������źŵ����ͣ�0-�Ӻ�ƣ�1-���̵�
    BYTE byRelatedYLightChan; //�����ĻƵƼ����ͨ����
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

//485�����źŵƲ���
typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //����485�����źŵƲ���
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

//������Ƶ��⽻ͨ�źŵƲ����ṹ
typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //��ͨ�Ƹ���
    BYTE byStraightLight; //�Ƿ���ֱ�б�־�ƣ�0-�� ��1-��
    BYTE byLeftLight; //�Ƿ�����ת��־�ƣ�0-��1-��
    BYTE byRightLight; //�Ƿ�����ת��־�ƣ�0-��1-��
    BYTE byRedLight;//�Ƿ��к�ƣ�0-��1-��
    BYTE byGreenLight; //�Ƿ����̵ƣ�0-��1-��
    BYTE byYellowLight; //�Ƿ��лƵƣ�0-��1-��
    BYTE byYellowLightTime;//ȡֵ��Χ��0��10s����ITC3.7Ver��
    NET_POS_PARAM struLightRect; //��ͨ������
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;


//��Ƶ��⽻ͨ�źŵƲ����ṹ(������12�������⣬488�ֽ�)
typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //������Ƶ����źŵƲ���
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;

//��ͨ�źŵƽ������
typedef union tagNET_ITC_LIGHT_ACCESSPARAM_UNION
{
    DWORD uLen[122];
    NET_ITC_IO_LIGHT_PARAM struIOLight; //IO�����źŵƲ���
    NET_ITC_RS485_LIGHT_PARAM struRS485Light; //485�����źŵƲ���
    NET_ITC_VIDEO_DETECT_LIGHT_PARAM struVideoDelectLight; //��Ƶ����źŵƲ���
}NET_ITC_LIGHT_ACCESSPARAM_UNION, *LPNET_ITC_LIGHT_ACCESSPARAM_UNION;

//��ͨ�źŵƲ����ṹ
typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //��ͨ�źŵƽ���Դ��0-IO���룬1-RS485����
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//�źŵƽ������
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

//Υ�����߲����ṹ
typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //�����߲���
    NET_ITC_LINE  struStopLine; //ֹͣ�߲���
    NET_ITC_LINE  struRedLightLine; //����ƴ����߲���
    NET_ITC_LINE  struCancelLine; //ֱ�д���λ��ȡ����
    NET_ITC_LINE struWaitLine; //������ֹͣ�߲���
    NET_ITC_LINE struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

//���˴���Ʋ���
typedef struct tagNET_ITC_REDLIGHT_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //ʹ��
    BYTE bySnapNumTimes; //ץ��������1-3��Ĭ��3��
    BYTE byPedesDir; //���˷���0~����1~����2~˫��
    BYTE byDelayTime; //��ʱʱ��1-5s
    BYTE byStackTargetEnble;//����Ŀ��򣨼�ץ�ĵ�һ��ͼƬ�Ͽ�ס����Ƶ����ˣ���0~�����ӣ�1~����
    BYTE byCalibRecogCtrl;//�궨������ƣ�0~�Ƴ��궨����1~��ӱ궨����
    BYTE byRes1[2];
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //��ͨ�źŵƲ���
    NET_ITC_LINE struStopLine;//ֹͣ��
    NET_ITC_POLYGON struCalibRecog[MAX_CALIB_RECOG_NUM/*2*/];//�궨����
    BYTE byRes[440];
}NET_ITC_REDLIGHT_PEDESTRIAN_PARAM,
*LPNET_ITC_REDLIGHT_PEDESTRIAN_PARAM;

typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;    
    BYTE  bySceneMode;//����ģʽ 0-���ٹ�· 1-���е�·
    /*ץ������
    bit0-����,bit1-��ռ��,bit2-ѹӲ·��
    */
    WORD  wExpressWayCapType;//���ٹ�·
    /*ץ������
    bit0-����,bit1-��ռ��,bit2-ռ��ר�ó���
    */
    WORD  wUrbanRoadCapType;//���е�·
    BYTE  byCapNum;//ץ������ [2,3]
    BYTE  byRecordEnable;//Υ��¼��ʹ�� 0-�رգ�1-����
    DWORD dwPreRecordTime;//¼��Ԥ¼ʱ��(s)
    DWORD dwOverRecordTime;//¼��ʱʱ��(s)
    NET_ITC_LANE_LOGIC_PARAM struLane;   //��������
    NET_ITC_POLYGON struPolygon[MAX_MOBILE_POLYGON_NUM/*3*/]; //��ʶ�������
    NET_ITC_VIOLATION_DETECT_LINE struLine[MAX_MOBILE_DETECTLINE_NUM/*3*/]; //Υ������
    NET_ITC_LINE struLaneBoundaryLine;        //�����߽��ߣ����ұ߳������ҳ����ߣ�
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_INTERVAL_PARAM struInterval;//ץ�ļ��������20byte��
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM,*LPNET_ITC_POST_MOBILE_PARAM;

typedef union tagNET_ITC_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1070];            //����
    NET_ITC_POST_IOSPEED_PARAM      struIOSpeed;    //�����ڣ�IO���ٲ��� 
    NET_ITC_POST_SINGLEIO_PARAM     struSingleIO;   //�����ڣ���IO����
    NET_ITC_POST_RS485_PARAM        struPostRs485;  //�����ڣ�RS485����������
    NET_ITC_POST_RS485_RADAR_PARAM  struPostRadar;  //�����ڣ�RS485�״����
    NET_ITC_POST_VTCOIL_PARAM       struVtCoil;     //�����ڣ�������Ȧ����
    NET_ITC_POST_HVT_PARAM          struHvt;        //�����ڣ����п��ڲ���
    NET_ITC_EPOLICE_IOTL_PARAM      struIOTL;        //���羯��IO���̵Ʋ���
    NET_ITC_EPOLICE_RS485_PARAM     struEpoliceRs485; //���羯��RS485��������������
    NET_ITC_EPOLICE_RS485_PARAM     struPERs485;    //����ʽ�羯��RS485��������������
    NET_ITC_POST_MPR_PARAM          struPostMpr;    //��֡��ⴥ����MPR��
    NET_DVR_VIA_VTCOIL_PARAM        struViaVtCoil;  //(VIA)��Ƶ������
    NET_ITC_POST_IMT_PARAM          struPostImt;//�ǻۼ�ش���
    NET_ITC_POST_PRS_PARAM          struPostPrs;//��Ƶ��ⴥ��
    NET_IPC_POST_HVT_PARAM          struIpcHvt;//(IPC) ���п��ڲ���
    NET_ITC_POST_HVT_PARAM_V50      struHvtV50;  /*�����ڣ����п��ڲ���V50*/
    NET_ITC_POST_MOBILE_PARAM       struPostMobile;// �ƶ���ͨ����ģʽ
    NET_ITC_NOCOMITY_PEDESTRIAN_PARAM struNoComityPed;//���������˲���
    NET_ITC_REDLIGHT_PEDESTRIAN_PARAM struRedLightPed;//���˴���Ʋ���
}NET_ITC_TRIGGER_PARAM_UNION, *LPNET_ITC_TRIGGER_PARAM_UNION;

//�������������ṹ
typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;    //�Ƿ����øô���ģʽ��0-��1-��
    BYTE  byRes1[3];
    DWORD dwTriggerType; //�������ͣ����ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //��������
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

//���������ṹ
typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;            //�ṹ����
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //������������
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;


//Υ�������ͺ궨��
typedef enum _ITC_VIOLATION_DETECT_TYPE_
{
    ITC_VIOLATION_POST = 0x01, //����ץ��
        ITC_VIOLATION_DRIVELINE = 0x02,//ѹ������ץ��
        ITC_VIOLATION_REVERSE = 0x04,//����ץ��
        ITC_VIOLATION_REDLIGHT = 0x08,//�����ץ��
        ITC_VIOLATION_DIRECTION = 0x10,//����������ʻץ��
        ITC_VIOLATION_INTERSECTION_CONGEST = 0x20,//·������ץ��
        ITC_VIOLATION_NONDRIVEWAY = 0x40,  //��ռ��ץ��
        ITC_VIOLATION_CHANGELANE = 0x80, //Υ�����
        ITC_VIOLATION_BAN = 0x100, //Υ������
        ITC_VIOLATION_INTERSECTION_PARK=0x200,//���Խ��
        ITC_VIOLATION_GREEN_PARK=0x400,//�̵�ͣ��
        ITC_VIOLATION_HIGH_SPEED = 0x800, /*����*/
        ITC_VIOLATION_LOW_SPEED = 0x1000, /*����*/
        ITC_VIOLATION_EMERGENCY = 0x2000, /*ռ��Ӧ������*/
        ITC_VIOLATION_TURN_AROUND = 0x8000,/*Υ����ͷ*/
        ITC_VIOLATION_CONGESTION = 0x10000 /*ӵ��*/
}ITC_VIOLATION_DETECT_TYPE;


//Υ��������ṹ
typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //Υ��������, ��λ��ʾ, ���ITC_VIOLATION_DETECT_TYPE ,0-������,1-����
    BYTE byDriveLineSnapTimes; //ѹ������ץ������,2-3
    BYTE byReverseSnapTimes; //����ץ��,2-3
    WORD wStayTime; //��ռ��ͣ��ʱ�䣨��ʱ���ץ�ģ�����λs
    BYTE byNonDriveSnapTimes;//��ռ��ץ������2-3
    BYTE byChangeLaneTimes;//Υ�����ץ������ 2-3
    BYTE bybanTimes;//Υ������ץ������2-3
    BYTE byDriveLineSnapSen;// ѹ��������(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //��2,3��ץ��λ����Сƫ��(Υ���źŵ�ʱ��Ч)����λ�����أ� ������Ľ�
    BYTE bySpeedTimes;//Υ������ץ������2-3(3.8Ver)
    BYTE byTurnAroundEnable;//Υ�µ�ͷʹ�� 0~�ر� 1~����
    BYTE byThirdPlateRecogTime;//��������ʶʱ�� 0~180s
    BYTE byPostSnapTimes;//����ץ������,1-2��
    BYTE byRes1[18];
    WORD wStopLineDis;  //�羯��2��Υ��ͼƬ��ֹͣ�ߵ���̾��룬[0,300]��λ(����)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;

//���������������Ͷ���
typedef enum _ITC_RELA_LANE_DIRECTION_TYPE_
{
    ITC_RELA_LANE_DIRECTION_UNKNOW      = 0,   //����
        ITC_RELA_LANE_EAST_WEST               = 1,    //�Ӷ�����
        ITC_RELA_LANE_WEST_EAST               = 2,    //������
        ITC_RELA_LANE_SOUTH_NORTH            = 3,    //������
        ITC_RELA_LANE_NORTH_SOUTH            = 4,    //�ӱ�����
        ITC_RELA_LANE_EASTSOUTH_WESTNORTH  = 5,    //�Ӷ���������
        ITC_RELA_LANE_WESTNORTH_EASTSOUTH  = 6,    //����������
        ITC_RELA_LANE_EASTNORTH_WESTSOUTH  = 7,    //�Ӷ���������
        ITC_RELA_LANE_WESTSOUTH_EASTNORTH  = 8     //�������򶫱�
} ITC_RELA_LANE_DIRECTION_TYPE;


//������;���Ͷ���
typedef enum _ITC_LANE_USEAGE_TYPE_
{
    ITC_LANE_USEAGE_UNKNOW     =  0,   //δ֪
        ITC_LANE_CARRIAGEWAY  = 1,  //��������
        ITC_LANE_BUS      = 2,  //������ר�õ�
        ITC_LANE_FAST  = 3,  //�쳵��
        ITC_LANE_SLOW  = 4,  //������
        ITC_LANE_MOTOR     = 5,   //Ħ�г���
        ITC_LANE_NONMOTOR  = 6,  //�ǻ�������
        ITC_LANE_REVERSE_LANE = 7, //���򳵵�
        ITC_LANE_BAN_TRUCKS  = 8, // ��ֹ��������
        ITC_LANE_MIX = 9, //��ϳ���
        ITC_LANE_EMERGENCY = 10, //Ӧ������
        ITC_LANE_BAN_LEFT  = 11, // ���󳵵�
        ITC_LANE_BAN_RIGHT  = 12 // ���ҳ���
}ITC_LANE_USEAGE_TYPE;

//�����������Ͷ���
typedef enum _ITC_LANE_DIRECTION_TYPE_
{
    ITC_LANE_DIRECTION_UNKNOW     =  0,   //δ֪
        ITC_LANE_LEFT      = 1,  //��ת
        ITC_LANE_STRAIGHT  = 2,  //ֱ��
        ITC_LANE_LEFT_STRAIGHT = 3, //��ת+ֱ��
        ITC_LANE_RIGHT  = 4,  //��ת
        ITC_LANE_LEFT_RIGHT = 5, //��ת+��ת
        ITC_LANE_RIGHT_STRAIGHT = 6, //��ת+ֱ��
        ITC_LANE_LEFT_RIGHT_STRAIGHT = 7, //��ת+��ת+ֱ��
        ITC_LANE_LEFT_WAIT  =  9,  //��ת����
        ITC_LANE_STRAIGHT_WAIT = 10, //ֱ�д���
        ITC_LANE_FORWARD = 11, //������ʻ
        ITC_LANE_BACKWARD = 12, //������ʻ
        ITC_LANE_BOTHWAY = 13, //˫����ʻ
        ITC_LANE_STRAIGHT_WAIT_RIGHT = 14 //ֱ�д��� + ��ת
}ITC_LANE_DIRECTION_TYPE; 

//������ʻ�������Ͷ��� 
typedef enum _ITC_LANE_CAR_DRIVE_DIRECT_
{
    ITC_LANE_DRIVE_UNKNOW        = 0, //δ֪
        ITC_LANE_DRIVE_UP_TO_DOWN    = 1, //����������ʻ(����)
        ITC_LANE_DRIVE_DOWN_TO_UP    = 2  //����������ʻ(����)        
}ITC_LANE_CAR_DRIVE_DIRECT;

//�����Ͷ���
typedef enum _ITC_LINE_TYPE_
{
    ITC_LINT_UNKNOW     =  0,   //δ֪
        ITC_LINE_WHITE      = 1,  //������İ�ʵ��
        ITC_LINE_STOP       = 2, //����ֹͣ��
        ITC_LINE_SINGLE_YELLOW = 3, //������
        ITC_LINE_DOUBLE_YELLOW = 4, //˫����
        ITC_LINE_GUARD_RAIL = 5, //���������л���
        ITC_LINE_NO_CROSS = 6, //�����޷���Խ�ĳ�����
        ITC_LINE_DOTTED = 7 //����
}ITC_LINE_TYPE;


//����������Ƶ�羯���������ṹ
typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //�����ĳ�����
    BYTE bySensitivity; //��Ȧ�����ȣ�[1,100]
    BYTE byEnableRadar;//�����״����0-�����ã�1-����
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //��������
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //Υ�������
    NET_ITC_VIOLATION_DETECT_LINE struLine; //Υ������
    NET_ITC_POLYGON struPlateRecog; //��ʶ�������
    BYTE byRecordEnable;//���������¼���־��0-��¼��1-¼��
    BYTE byRecordType;//�����¼�����ͣ�0-Ԥ¼��1-��ʱ¼��
    BYTE byPreRecordTime;//�����¼��Ƭ��Ԥ¼ʱ�䣨Ĭ��0������λ����
    BYTE byRecordDelayTime;//�����¼��Ƭ����ʱʱ�䣨Ĭ��0������λ����
    BYTE byRecordTimeOut;//���������¼��ʱʱ�䣨�룩
    BYTE byCarSpeedLimit; //��������ֵ����λkm/h
    BYTE byCarSignSpeed;//��־���٣���λkm/h
    BYTE bySnapPicPreRecord; //ץ��ͼƬԤ¼ʱ��㣻0-Ĭ��ֵ���ڶ���ͼƬ����1-��һ��ͼƬ��2-�ڶ���ͼƬ��3-������ͼƬ
    NET_ITC_INTERVAL_PARAM struInterval;//ץ�ļ��������20byte��
    BYTE byRes[36];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

//��Ƶ�羯���������ṹ
typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;    //�Ƿ����ã�0-�����ã�1-����
    BYTE byLaneNum; //ʶ��ĳ�������
    BYTE byLogicJudge;//�����Υ���ж��߼�������ֵΪ��0-������1-������
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //��ʶ����
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //��ͨ�źŵƲ���
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //����������
    NET_ITC_LINE  struLaneBoundaryLine; //�����߽��ߣ����ұ߳����ı߽��ߣ�
    NET_ITC_LINE  struLeftLine; //��ת��ֽ���
    NET_ITC_LINE  struRightLine; //��ת��ֽ���
    NET_ITC_LINE  struTopZebraLine; //�ϲ�������
    NET_ITC_LINE  struBotZebraLine; //�²�������
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;

typedef union tagNET_ITC_VIDEO_TRIGGER_PARAM_UNION
{
    DWORD  uLen[1150];            
    NET_ITC_VIDEO_EPOLICE_PARAM struVideoEP; //��Ƶ�羯����
}NET_ITC_VIDEO_TRIGGER_PARAM_UNION, *LPNET_ITC_VIDEO_TRIGGER_PARAM_UNION;

typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //����ģʽ�����ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //����ģʽ����
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;            //�ṹ����
    BYTE   byEnableTrigIODetect; //��������IO״̬��⣬1-�ǣ�0-��
    BYTE   byEnableFlashOutDetect; //����ͬ�����״̬��⣬1-�ǣ�0-��
    BYTE   byEnableRS485Detect; //����RS485����״̬��⣬1-�ǣ�0-��
    BYTE   byEnableTrafficLightDetect;//������ͨ��״̬��⣬1-�ǣ�0-��
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;

typedef enum _ITC_STATUS_DETECT_TYPE_
{
    ITC_STATUS_DETECT_NULL = 0,        //δ֪
        ITC_STATUS_DETECT_TRIGGERIO,    //����IO
        ITC_STATUS_DETECT_FLASHOUT,     //ͬ�����
        ITC_STATUS_DETECT_RS485, //RS485
        ITC_STATUS_DETECT_TRIGGERTYPE, //�������ͣ�������
        ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR,  //��ͨ�ƣ�������ɫ��
        ITC_STATUS_DETECT_TRAFFICLIGHT_TURN  //��ͨ�ƣ�����ת��
}ITC_STATUS_DETECT_TYPE;

typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //����IO��
    BYTE byRes[40]; 
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //ͬ�������
    BYTE byRes[40]; 
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //485����У������0-��Ч,1-��Ч, bySerialIndex[0]��ʾ��ȷ��ͷ, bySerialIndex[1]��ʾ��ȷ��β
    BYTE byRes[40]; 
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //��������ֵ
    BYTE byRes[47]; 
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

//��Ƶ�羯
typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//��ת�ƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byRightLight; //��ת�ƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byStraightLight; //ֱ�еƣ�0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

//����Ƶ�羯
typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 ��ʾ��Ч��1Ϊ��� 2Ϊ�̵� 3 �Ƶ� 4�ƶ�����
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;

typedef union tagNET_ITC_STATUS_UNION
{
    BYTE   uLen[48];            //����
    NET_ITC_TRIGGERIO_INFO struTrigIO; //����IO�ں�
    NET_ITC_FLASHOUT_INFO struFlashOut; //ͬ�����
    NET_ITC_SERIAL_CHECKINFO struSerial;  //����
    NET_ITC_TRIGGERTYPE_INFO struTrigType; //�������ͣ�������
    NET_ITC_TRAFFIC_LIGHT_COLOR struTrafficLightColor; //��ͨ�ƣ�������ɫ����Ӧ����ITC_STATUS_DETECT_TRAFFICLIGHT_COLOR
    NET_ITC_TRAFFIC_LIGHT_TURN struTrafficLightTurn;//��ͨ�ƣ�����ת�򣩶�Ӧ����ITC_STATUS_DETECT_TRAFFICLIGHT_TURN
}NET_ITC_STATUS_UNION, *LPNET_ITC_STATUS_UNION;

typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//״̬������ͣ����ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //״̬�����
    DWORD dwHoldTime; //��������ʱ�䣨����������λ��ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //�������ȼ���0-һ�ȼ����ߣ���1-���ȼ����У���2-���ȼ����ͣ�
    BYTE  byAlarmInfoType; //�ϴ�������Ϣ���ͣ�ץ�Ļ�֧�֣���0-�ϱ�����Ϣ��NET_DVR_PLATE_RESULT����1-�±�����Ϣ(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--����NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO, 1--�豸֧��NET_DVR_ALARMINFO_V40�򷵻�NET_DVR_ALARMINFO_V40����֧���򷵻�NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR�ϴ�������Ϣ�ص��ṹ��汾�� 0-COMM_ALARM_DEVICE�� 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD�����ϴ����ͣ�0-�ϴ�������NET_DVR_VQD_DIAGNOSE_INFO��1-�ϴ�����NET_DVR_VQD_ALARM
    //1-��ʾ������ⱨ����չ(INTER_FACE_DETECTION),0-��ʾԭ��֧�ֽṹ(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0- ��ʾ���������Ƿ��ϴ�ͼƬ: 0-�ϴ���1-���ϴ�
    //Bit1- ��ʾ���������ϴ�ȷ�ϻ��ƣ�0-��������1-����
    //Bit6- ��ʾ�״��ⱨ��(eventType:radarDetection)�Ƿ���ʵʱ�ϴ���0-��������1-����������web���ʵʱ��ʾ�״�Ŀ��켣��
    BYTE  bySupport; 
    //������������ 
    //bit0-���Ƽ�⣨IPC�� ��0-��������1-������
    //bit1-����ͳ�ƣ�IPC��  ��0-��������1-������
    //bit2-�ȶ�ͼͳ�ƣ�IPC�� ��0-��������1-������
    //bit3-����ץ�ģ�IPC�� ��0-��������1-������
    //bit4-�����Աȣ�IPC�� ��0-��������1-������
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;    //������� �� (�ϴ�����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�dwTaskNo��Ӧ ͬʱ �·�����ṹ NET_DVR_VEHICLE_RECOG_COND�е��ֶ�dwTaskNo��Ӧ)
    BYTE  byDeployType;    //�������ͣ�0-�ͻ��˲�����1-ʵʱ����
    BYTE  bySubScription;	//���ģ���λ��ʾ��δ�������Ĳ��ϱ�  //ռλ
    //Bit7-�ƶ�����˳������Ƿ�ͼ��0-����ͼ(V30�ϱ�)��1-��ͼ(V40�ϱ�)
    BYTE  byRes1[2];
    BYTE  byAlarmTypeURL;//bit0-��ʾ����ץ�ı����ϴ���INTER_FACESNAP_RESULT����0-��ʾ�����ƴ��䣬1-��ʾURL���䣨�豸֧�ֵ�����£��豸֧���������ݾ��屨���������ж�,ͬʱ�豸��Ҫ֧��URL����ط��񣬵�ǰ�ǡ��ƴ洢����
    //bit1-��ʾEVENT_JSON��ͼƬ���ݳ������ͣ�0-��ʾ�����ƴ��䣬1-��ʾURL���䣨�豸֧�ֵ�����£��豸֧���������ݾ��屨���������жϣ�
    //bit2 - �����ȶ�(��������ΪCOMM_SNAP_MATCH_ALARM)��ͼƬ�����ϴ����ͣ�0 - �����ƴ��䣬1 - URL����
    //bit3 - ��Ϊ����(��������ΪCOMM_ALARM_RULE)��ͼƬ�����ϴ����ͣ�0 - �����ƴ��䣬1 - URL���䣬���ֶ��豸�Ƿ�֧�֣���Ӧ��Ӳ����������<isSupportBehaviorUploadByCloudStorageURL>�ڵ��Ƿ񷵻���Ϊtrue
    BYTE  byCustomCtrl;//Bit0- ��ʾ֧�ָ���ʻ������ͼ�ϴ�: 0-���ϴ�,1-�ϴ�
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_DVR_SETUPALARM_PARAM_V50
{
    DWORD dwSize;
    BYTE  byLevel; //�������ȼ���0-һ�ȼ����ߣ���1-���ȼ����У���2-���ȼ����ͣ�
    BYTE  byAlarmInfoType; //�ϴ�������Ϣ���ͣ�ץ�Ļ�֧�֣���0-�ϱ�����Ϣ��NET_DVR_PLATE_RESULT����1-�±�����Ϣ(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--����NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO, 1--�豸֧��NET_DVR_ALARMINFO_V40�򷵻�NET_DVR_ALARMINFO_V40����֧���򷵻�NET_DVR_ALARMINFO_V30��NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR�ϴ�������Ϣ�ص��ṹ��汾�� 0-COMM_ALARM_DEVICE�� 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD�����ϴ����ͣ�0-�ϴ�������NET_DVR_VQD_DIAGNOSE_INFO��1-�ϴ�����NET_DVR_VQD_ALARM
    //1-��ʾ������ⱨ����չ(INTER_FACE_DETECTION),0-��ʾԭ��֧�ֽṹ(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0- ��ʾ���������Ƿ��ϴ�ͼƬ: 0-�ϴ���1-���ϴ�
    //Bit1- ��ʾ���������ϴ�ȷ�ϻ��ƣ�0-��������1-����
    //Bit6- ��ʾ�״��ⱨ��(eventType:radarDetection)�Ƿ���ʵʱ�ϴ���0-��������1-����������web���ʵʱ��ʾ�״�Ŀ��켣��
    BYTE  bySupport;
    //������������ 
    //bit0-���Ƽ�⣨IPC�� ��0-��������1-������
    //bit1-����ͳ�ƣ�IPC��  ��0-��������1-������
    //bit2-�ȶ�ͼͳ�ƣ�IPC�� ��0-��������1-������
    //bit3-����ץ�ģ�IPC�� ��0-��������1-������
    //bit4-�����Աȣ�IPC�� ��0-��������1-������
    //bit5-JSON����͸����IPC�� ��0-��������1-������
    //bit6-�ȶ�ͼ����Աͣ��ʱ��ͳ�������ϴ��¼���0-��������1-������
    //bit7-�ȶ�ͼ������ͳ�������ϴ��¼���ȷ�ϻ��ƣ�0-��������1-������
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;    //������� �� (�ϴ�����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�dwTaskNo��Ӧ ͬʱ �·�����ṹ NET_DVR_VEHICLE_RECOG_COND�е��ֶ�dwTaskNo��Ӧ)
    BYTE  byDeployType;    //�������ͣ�0-�ͻ��˲�����1-ʵʱ����
    BYTE  bySubScription;	//���ģ���λ��ʾ��δ�������Ĳ��ϱ�  //ռλ
    //Bit7-�ƶ�����˳������Ƿ�ͼ��0-����ͼ(V30�ϱ�)��1-��ͼ(V40�ϱ�)
    BYTE  byRes1[2];
    BYTE  byAlarmTypeURL;//bit0-��ʾ����ץ�ı����ϴ���INTER_FACESNAP_RESULT����0-��ʾ�����ƴ��䣬1-��ʾURL���䣨�豸֧�ֵ�����£��豸֧���������ݾ��屨���������ж�,ͬʱ�豸��Ҫ֧��URL����ط��񣬵�ǰ�ǡ��ƴ洢����
    //bit1-��ʾEVENT_JSON��ͼƬ���ݳ������ͣ�0-��ʾ�����ƴ��䣬1-��ʾURL���䣨�豸֧�ֵ�����£��豸֧���������ݾ��屨���������жϣ�
    //bit2 - �����ȶ�(��������ΪCOMM_SNAP_MATCH_ALARM)��ͼƬ�����ϴ����ͣ�0 - �����ƴ��䣬1 - URL����
    //bit3 - ��Ϊ����(��������ΪCOMM_ALARM_RULE)��ͼƬ�����ϴ����ͣ�0 - �����ƴ��䣬1 - URL���䣬���ֶ��豸�Ƿ�֧�֣���Ӧ��Ӳ����������<isSupportBehaviorUploadByCloudStorageURL>�ڵ��Ƿ񷵻���Ϊtrue
    BYTE  byCustomCtrl;//Bit0- ��ʾ֧�ָ���ʻ������ͼ�ϴ�: 0-���ϴ�,1-�ϴ�
    BYTE  byRes4[128];
}NET_DVR_SETUPALARM_PARAM_V50, *LPNET_DVR_SETUPALARM_PARAM_V50;

typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //��Ƶ����ģʽ���ͣ����ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

//�����ṹ
typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;//ͨ����
    BYTE    byWorkMode;  // 0-FTP1(��FTP)��1-FTP2(��FTP)
    BYTE    byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;

//���ýṹ
typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE                byEnable;            /*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE                 byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    WORD                wFTPPort;            /*�˿�*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];//��������ַ������ 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP��ַ*/        //IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64    
    BYTE                szUserName[NAME_LEN];        /*�û���*/
    BYTE                szPassWORD[PASSWD_LEN];        /*����*/
    BYTE                byRes4;  // 0-FTP1(��FTP)��1-FTP2(��FTP)
                                 BYTE                byDirLevel;    /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,
                                                                1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼,
                                 3 = ʹ��3��Ŀ¼,4=ʹ��4��Ŀ¼*/                    
                                 BYTE                 byIsFilterCarPic;/*����Сͼ�Ƿ��ϴ���0-�ϴ�,1-���ϴ�*/
                                 BYTE                    byUploadDataType;//0-ȫ����1-���ڣ�2-Υ�� (��FTPʱĬ��ѡ��ȫ����˫FTPʱ֧�ֿ��ڣ�Υ�µ�ѡ��)
                                 NET_DVR_PICTURE_NAME     struPicNameRule;/* ͼƬ�������� */
                                                                        BYTE                byTopDirMode; /*һ��Ŀ¼, 0x1 = ʹ���豸��,
                                                                                                          0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                          0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),  
                                                                                                          0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE                bySubDirMode; /*����Ŀ¼, 0x1 =ʹ���豸��,
                                                                                                          0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                          0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),  
                                                                                                          0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE                byThreeDirMode; /*����Ŀ¼, 0x1 = ʹ���豸��,
                                                                                                            0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                            0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),  
                                                                                                            0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        BYTE                byFourDirMode; /*�ļ�Ŀ¼, 0x1 =ʹ���豸��,
                                                                                                           0x2 = ʹ���豸��,0x3 =ʹ���豸ip��ַ��
                                                                                                           0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),  
                                                                                                           0x6=ʹ��ʱ��(������),0x7=Υ������,0x8=����,0x9=�ص�,
                                                                        0xa=ͨ����,0xb=ͨ����,0xc=������0xff=�Զ���*/
                                                                        /*ͼƬ�����Զ��� ��PICNAME_ITEM_CUSTOM ʱ ��Ч*/
                                                                        BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver ��Ч)
                                                                        BYTE                szTopCustomDir[MAX_CUSTOMDIR_LEN]; /*�Զ���һ��Ŀ¼*/  
                                                                        BYTE                szSubCustomDir[MAX_CUSTOMDIR_LEN];/*�Զ������Ŀ¼*/
                                                                        BYTE                szThreeCustomDir[MAX_CUSTOMDIR_LEN];    /*�Զ�������Ŀ¼*/
                                                                        BYTE                szFourCustomDir[MAX_CUSTOMDIR_LEN];    /*�Զ����ļ�Ŀ¼*/
                                                                        BYTE                 byRes3[900]; //����12����չԤ�� ֧��͸��
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//��[0,179]
    BYTE byMinute;//��[0,59]
    BYTE bySec;//��[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//��[0,179]
    BYTE byMinute;//��[0,59]
    BYTE bySec;//��[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD     dwSize;
    BYTE byGpsDataMode;//GPS���ݻ�ȡ 0-�Զ���1-�ֶ�
    BYTE byLongitudeType;//���� 0-������1-����
    BYTE byLatitudeType;//γ�� 0-��γ��1-��γ
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM    struLatitude;     /*γ��*/
    NET_DVR_LONGITUDE_PARAM    struLongitude; /*����*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG,*LPNET_DVR_GPS_DATACFG;

typedef enum _VCA_DATABASE_TYPE_
{
    DATABASE_NULL = 0, //δ֪
        DATABASE_SNAP,    //ץ�����ݿ�
        DATABASE_FACE    //�������ݿ�
}VCA_DATABASE_TYPE;

typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //���ݿ�ID���豸���ɣ����ʱ��Ч���޸ĺ�ɾ��ʱ��Ч��
    DWORD dwDataBaseType; //���ݿ����ͣ���VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //���ݿ�����
    BYTE byAttribute[64]; //���ݿ�����
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //���ݿ����ͣ����VCA_DATABASE_TYPE
    BYTE byRes[12]; //����
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //���ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //���ݿ�ID
    BYTE byRes[64]; //����
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//ͨ����
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    BYTE byRes[12]; //����
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_DVR_TIME struSnapTime;  //ץ��ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ���ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ����
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;

typedef union tagNET_VCA_DELETE_SNAPRECORD_COND_UNION
{ 
    NET_VCA_INQUIRE_SNAPDB_COND struAttribute;  //��Ա��Ϣ������ɾ����
    DWORD dwRecordID; //��¼ID������ɾ����
}NET_VCA_DELETE_SNAPRECORD_COND_UNION, *LPNET_VCA_DELETE_SNAPRECORD_COND_UNION;

typedef enum _VCA_DELETE_RECORD_TYPE_
{
    DELETE_RECORD_SINGLE = 0, //����ɾ��
        DELETE_RECORD_BATCH    //����ɾ��
}VCA_DELETE_RECORD_TYPE;

typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //ɾ����¼����
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //ɾ������
    BYTE  byRes[40]; //����
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;

typedef enum _VCA_SEARCH_DATABASE_TYPE_
{
    VCA_NORMAL_SEARCH_DATABASE  = 0x00000000,   //��ͨ����
        VCA_ADVANCE_SEARCH_DATABASE  = 0x00000001  //�߼�����
}VCA_SEARCH_DATABASE_TYPE;

typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //���ݿ����ͣ����VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //���ݿ�ID
    DWORD dwFacePicID; //����ͼƬID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;

typedef union tagNET_VCA_SEARCH_DATABASE_COND_UNION
{
    DWORD uLen[25];
    NET_VCA_REGISTER_PIC struNormalFind; //��ͨ����
    NET_VCA_ADVANCE_SEARCH_DATABASE_COND struAdvanceFind; //�߼�����
}NET_VCA_SEARCH_DATABASE_COND_UNION, *LPNET_VCA_SEARCH_DATABASE_COND_UNION;

typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //�������ͣ����VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //��������
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{ 
    DWORD dwChannel; //ͨ��
    DWORD dwDataBaseID; //���ݿ�ID
    NET_DVR_TIME struStartTime;//��ʼʱ��
    NET_DVR_TIME struStopTime;//����ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //��������
    DWORD dwMaxSearchNum; //����������
    WORD wThreshold;  //��ֵ��0-100
    BYTE  byRes[78]; //����
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_DVR_TIME struSnapTime;//ץ��ʱ��
    BYTE bySex; //�Ա�0-�����ã�1-�У�2-Ů
    BYTE byRes1[3]; //����
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ʼ�������£��磺201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //��ֹ�������£���201106
    BYTE byAttribute1[NAME_LEN]; //����1
    BYTE byAttribute2[NAME_LEN]; //����2
    float fSimilarity; //���ƶȣ�[0.001,1]
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ���ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ����
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{ 
    DWORD dwSize; //�ṹ���С
    DWORD dwRecordID; //��¼ID�����ʱ��Ч���޸�ʱ��Ч
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    NET_VCA_REGISTER_PIC struRegisterPic;  //��ԱͼƬ��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    BYTE  byRes[32]; //����
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{ 
    DWORD dwSize; //�ṹ���С
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    DWORD dwImageLen;  //ͼ�����ݳ���
    BYTE  byRes[80];  //����
    BYTE *pImage;    //ͼ������
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{ 
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ���ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ����
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{ 
    DWORD dwSize; //�ṹ���С
    DWORD dwDataBaseID;  //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //��Ա��Ϣ
    BYTE  byRemark1[NAME_LEN]; //��ע��Ϣ1
    BYTE  byRemark2[64]; //��ע��Ϣ2
    float fSimilarity; //���ƶȣ�[0.001,1]
    DWORD dwFacePicID; //����ͼID
    DWORD dwFacePicLen;  //����ͼ���ݳ���
    BYTE byRes[80];  //����
    BYTE *pFacePic;    //����ͼ����
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{ 
    DWORD dwDataBaseID; //���ݿ�ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ
    BYTE byRes[80];  //����
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;

typedef union tagNET_VCA_DELETE_RECORD_COND_UNION
{ 
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ������ɾ����
    DWORD dwRecordID; //��¼ID������ɾ����
}NET_VCA_DELETE_RECORD_COND_UNION, *LPNET_VCA_DELETE_RECORD_COND_UNION;

typedef struct tagNET_VCA_DELETE_RECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //ɾ����¼����
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //ɾ������
    BYTE  byRes[40]; //����
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{ 
    DWORD dwDataBaseID; //���ݿ�ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //��Ա��Ϣ
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //��������
    DWORD dwMaxSearchNum; //����������
    WORD wThreshold;  //��ֵ��0-100
    BYTE  byRes[78]; //����
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //���ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    BYTE byRes[64]; //����
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //���ݿ����ͣ���VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //���ݿ�ID
    DWORD dwRecordID; //��¼ID
    DWORD dwPicLen; //ͼƬ����
    BYTE byRes[64]; //����
    BYTE *pPicBuffer; //ͼƬ����ָ��
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    WORD wDealyTime; //�ӳ�ʱ�䣬��λs
    BYTE  byRes[30]; 
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byRes[16]; 
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byIndex;  //���߱�����ţ�1-8
    BYTE  byRes[15]; 
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;

#define MAX_AUX_ALARM_NUM 8 //�������������
#define MAX_WIRELESS_ALARM_NUM 8 //������߱�������
typedef enum _IPC_AUX_ALARM_TYPE_
{
    IPC_AUXALARM_UNKNOW = 0, //δ֪
        IPC_AUXALARM_PIR = 1, //PIR����
        IPC_AUXALARM_WIRELESS = 2,   //���߱���
        IPC_AUXALARM_CALLHELP = 3  //���ȱ���
}IPC_AUX_ALARM_TYPE;

typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//ʹ��
    BYTE    byRes1[3];
    DWORD    dwDecibelLimit; //�ֱ��澯��ֵ
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //�쳣����ʽ
    BYTE    byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG,*LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//ʹ��
    BYTE    byRes1[3]; 
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //�쳣����ʽ
    BYTE    byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG,*LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* �������� */
    BYTE byAlarmHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];    /* �������� */
    BYTE byAlarmHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

//���ȱ���
typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* �������� */
    BYTE byAlarmHandle;            /* �Ƿ��� 0-������ 1-����*/
    BYTE byID; //���߱���ID��1-8
    BYTE byRes1[2];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* ����ʽ */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //����������¼��ͨ��,Ϊ1��ʾ������ͨ��    
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //�������߱�������
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;

typedef union tagNET_IPC_AUX_ALARMCFG_UNION
{
    DWORD uLen[472];
    NET_IPC_PIR_ALARMCFG_EX struPIRAlarm; //PIR��������
    NET_IPC_WIRELESS_ALARMCFG struWirelessAlarm; //���߱�������
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //���ȱ�������
}NET_IPC_AUX_ALARMCFG_UNION, *LPNET_IPC_AUX_ALARMCFG_UNION;

typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;       //���������ͣ����IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];            
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //��������
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //��������
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;

typedef union tagNET_IPC_AUXALARM_UPLOAD_UNION
{
    DWORD uLen[66];
    NET_IPC_PIR_ALARMCFG struPIRAlarm; //PIR��������
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm; //���߱�������
    NET_IPC_CALLHELP_ALARMCFG struCallHelpAlarm; //���ȱ�������
}NET_IPC_AUXALARM_UPLOAD_UNION, *LPNET_IPC_AUXALARM_UPLOAD_UNION;

typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE byAlarmType;       //���������ͣ����IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //�����������
    BYTE byDeviceID[NAME_LEN];/*�豸��ID��*/
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;         // �ṹ���С 
    BYTE   byCorrectMode;   //У��ģʽ��0-���У����1-оƬУ��
    BYTE   byMountType;     //��װ���ͣ�0-������1-���棬2-ǽ��
    /*
    0-ģʽ1������+ȫ��+3PTZ (��ԭ�з�ʵʱģʽһ��)��
    1-ģʽ2������+4PTZ(��ԭ��ʵʱģʽһ��)��
    2-ģʽ3������(��)+����(��)+3PTZ��
    3-ģʽ4��ȫ��չ��(������+������)��
    4-ģʽ5��4PTZ��
    5-ģʽ6�����ۣ�
    6-ģʽ7: ��γ��ȫ��չ��ģʽ��
    7-ģʽ8: 4PTZ�ں�ģʽ��
    */
    BYTE   byRealTimeOutput;  //ʵʱ�����0 -�����ã�1- ����
    BYTE   byRes[61];
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZCommand; //PTZ�������� 
    NET_VCA_POINT struVcaPoint; //Ԥ�����������
    DWORD dwSpeed; //���Ƶ��ٶȣ�ȡֵ��Χ[0,7]
    DWORD dwStop; //ֹͣ������ʼ������0-��ʼ��1-ֹͣ
    BYTE  byRes[32]; 
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZPresetCmd; //Ԥ�õ�������� 
    NET_VCA_POINT struVcaPoint; //Ԥ�����������
    DWORD dwPresetIndex; //Ԥ�õ����ţ���1��ʼ�������֧��255��Ԥ�õ�
    WORD  wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    DWORD dwPTZCruiseCmd; //Ѳ���������� 
    NET_VCA_POINT struVcaPoint; //Ԥ�����������
    WORD wCruiseRoute; //Ѳ��·�������֧��32��·������Ŵ�1��ʼ��
    WORD wCruisePoint; //Ѳ���㣬���֧��32���㣨��Ŵ�1��ʼ��
    WORD wInput; //��ͬѲ������ʱ��ֵ��ͬ��Ԥ�õ�(���255)��ʱ��(���255)���ٶ�(���40)
    WORD wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //����WPS��0-��1-��
    BYTE byRes[31]; 
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN��
    BYTE byRes[32]; 
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS���ӷ�ʽ��0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN��(WPS���ӷ�ʽΪAP PINʱ��Ч)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS���ӷ�ʽΪAP PINʱ��Ч)
    BYTE byRes[32]; 
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD    dwSize;        // �ṹ���С
    BYTE    byJointed;        //  0 û�й��� 1 �Ѿ�����
    BYTE    byRes1[3];        // �����ֽ�
    NET_DVR_IPADDR    struIP;    // ��������������IP��ַ
    WORD    wPort;            // �������������Ķ˿ں�
    WORD    wChannel;        // �������������Ľ���ͨ����
    BYTE    sDeviceName[NAME_LEN];    //���������������豸����
    BYTE    sChanName[NAME_LEN];    //�������������Ľ���ͨ������
    BYTE    byRes2[32];        // �����ֽ�
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struCuIp; //CU��IP��ַ
    WORD    wPort;/*CU�˿�*/
    BYTE    bySourceIndex;    //�ź�Դͨ����
    BYTE    byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

#define DVCS_DEVICEID_LEN   16
//2012-03-13ͼƬ����ע����Ϣ�ص�
typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD    dwUserID;
    BYTE    sDeviceID[DVCS_DEVICEID_LEN];
    LONG    nPicViewHandle; //���Ծ��
    WORD    wSignalIndex;    //�ź�Դ����
    WORD    wHeadLen;        //�ļ�ͷ���� ˽�е������ļ�ͷ����40
    BYTE    byHeadBuf[100]; //�ļ�ͷ
    BYTE    byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

#define DEVICEID_LEN      32

typedef struct tagNET_DVR_DEVICEID_INFO
{
    DWORD        dwSize;
    DWORD        dwDeviceIndex;    //�豸���
    BYTE        byWallNo;     //ǽ�ţ���1��ʼ
    BYTE        byRes1[27];
    DWORD        dwChan;        //ͨ����
    DWORD        dwInputSignalIndex; //�ź�Դ����������ʽ����������ʹ��
    BYTE        byRes2[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;


typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;                 //�Ƿ�����DHCP 0xff-��Ч 0-������ 1-����
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // �豸IP��ַ
    NET_DVR_IPADDR  struSubnetMask;  // �豸��������
    NET_DVR_IPADDR  struGateway;     // �豸����
    WORD    wDevPort;                 // �豸�˿ں�
    BYTE    byMACAddr[MACADDR_LEN];   // MAC ��ַ(ֻ�ܻ�ȡ)
    BYTE    byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD    dwSize;
    BYTE    byValid;                //0-��Ч 1-��Ч
    BYTE    byRes1[3];
    BYTE    sChanName[NAME_LEN];    //ͨ������
    NET_DVR_COLOR struVideoColor;   //�ź�Դ��ɫ
    WORD    wResolutionX;        //��ǰ�ֱ���---�� 
    WORD    wResolutionY;        //��ǰ�ֱ���---��
    BYTE   byRes2[40];
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

//�������豸��Ϣ
typedef struct tagNET_DVR_CODEDEV_INFO 
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];/*�豸ͨ����Ϣ*/ 
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

//�������豸��Ϣ
typedef struct tagNET_DVR_DECODEDEV_INFO 
{
    BYTE    byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

//�����ź�Դ��Ϣ
typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD    dwSize;
    BYTE    byDevName[NAME_LEN/*32*/];//�����ź�Դ����
    NET_DVR_PU_STREAM_CFG struPuStream;  
    BYTE    byValid;            //�Ƿ���Ч��0-��Ч��ɾ��ʱ��Ϊ0  1-��Ч����Ӻ��޸�ʱ��Ϊ1/
    BYTE     byRes1[3];    //����
    BYTE    sGroupName[NAME_LEN/*32*/];//�����ź�Դ������������������ź�Դ�����������������
    WORD    wResolutionX;        //��ǰ�ֱ���---�� 
    WORD    wResolutionY;        //��ǰ�ֱ���---��
    BYTE    byRes2[24];        
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE    byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;

typedef union tagNET_DVR_DIFFDEV_INFO 
{
    NET_DVR_CODEDEV_INFO struCodeDevInfo;        //�����豸��Ϣ
    NET_DVR_DECODEDEV_INFO struDecodeDevInfo;    //�����豸��Ϣ
    NET_DVR_NETSIGNALDEV_INFO struNetSignalInfo;    //�����ź�Դ��Ϣ
} NET_DVR_DIFFDEV_INFO, *LPNET_DVR_DIFFDEV_INFO;

/*ע���豸��Ϣ*/
typedef enum tagNET_DVCS_DEVICE_TYPE
{
    NET_DVR_BNC_PROC = 1,                   /* BNC������ */
    NET_DVR_RGB_PROC,                       /* RGB������ */
    NET_DVR_STP_PROC,                       /* ת�봦���� */
    NET_DVR_DISP_PROC,                      /* ��ʾ������ */
    NET_DVR_NETSIGNAL,                      //�����ź�Դ
    NET_DVR_SDI_PROC,                       //SDI������
    NET_DVR_BIW_PROC,                       //8·BNC������
    NET_DVR_DON_PROC,                       //��ʾ������
    NET_DVR_TVI_PROC,                       //TVI������
    NET_DVR_DI2_PROC,                       //2·DVI���봦����
    NET_DVR_DO2_PROC,                       //2·DVI����豸
    NET_DVR_UHDI_PROC,                      //DP/HDMI 1·4K�����������豸
    NET_DVR_YI2_PROC,                        //��·YPbPr�����
	NET_DVR_HI2_PROC,                        // HDMI����ڵ�(2·)
	NET_DVR_VI2_PROC,                        // VGA����ڵ�(2·)
	NET_DVR_SI2_PROC,                        // SDI����ڵ�(2·)
	NET_DVR_HO2_PROC,                        // HDMI����ڵ�(2·)
	NET_DVR_S24G_PROC,                        // C20Nר��ǧ�׽�����(24·)
	NET_DVR_S24X_PROC                        // C20Nר�����׽�����(24·)
}NET_DVCS_DEVICE_TYPE;

typedef struct  tagNET_DVR_SINGLE_DEV_INFO 
{
    DWORD    dwSize;
    DWORD    dwSoftVersion;            /*�豸����汾��(ֻ�ܻ�ȡ) ���8λΪ���汾�ţ��θ�8λΪ�ΰ汾�ţ���16λΪ�޸��汾��*/
    DWORD    dwSoftwareBuildDate;         //�汾��������Build, 0xYYYYMMDD
    BYTE    byUseInSys;                /*�Ƿ���ϵͳ��ʹ��*/
    BYTE    byDevStatus;            /*�豸��ǰ״̬��0-���ߣ�1-����(ֻ�ܻ�ȡ)*/ 
    BYTE    byDeviceType;            /*�豸����(ֻ�ܻ�ȡ)  ��DEVICE_TYPE*/ 
    BYTE    byRes1[17];
    BYTE    sDevName[NAME_LEN];     /*�豸����*/
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; /*�豸�������*/
    BYTE    sSerialNumber[SERIALNO_LEN];    /*�豸���к�*/
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;        /*�豸��Ϣ*/ 
    DWORD   dwDeviceIndex; //�豸��ţ������C20N��Y10���豸��ȫ�ֱ��
    DWORD   dwSubBoardNo; //�ֲ�ʽ�豸�������Ӱ��ţ������C20N��Y10���豸��ȫ�ֱ�ţ���1��ʼ��Ϊ0ʱ���ֶ���Ч���Ӱ���Ĭ��Ϊ1
    BYTE    bySubSysNo; //�ֲ�ʽ�豸�������Ӱ��ϵ���ϵͳ��ţ�������Ӱ�ȫ�֣���1��ʼ��Ϊ0ʱ���ֶ���Ч����ϵͳ��Ĭ��Ϊ1
    BYTE    byRes3[3];
    WORD    wStartAudioTalkChanNo; //�ֲ�ʽ�豸�������Խ�����ʼͨ����
    WORD    wAudioTalkChanNum; //�ֲ�ʽ�豸�������Խ�ͨ���ŵ�����
    BYTE    byRes2[36];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD        dwSize;
    DWORD        dwDevNums;//�豸���صķֲ�ʽ���豸����
    BYTE          *pBuffer;
    BYTE        byRes1[3];
    DWORD         dwBufLen;//������ָ�볤�ȣ��������
    BYTE        byRes2[64];
} NET_DVR_DEVLIST,*LPNET_DVR_DEVLIST;

typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;          /*�Ƿ���ϵͳ��ʹ��*/
    BYTE   byDeviceType;      /*�豸����(ֻ�ܻ�ȡ)*/ 
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN]; /*�豸����*/ 
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO,*LPNET_DVR_DEV_BASE_INFO;

/*����������Ϣ*/
typedef  struct tagNET_DVR_NETPARAM
{    
    DWORD dwSize;
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET];//��̫����    
    BYTE   byRes[64];
} NET_DVR_NETPARAM, *LPNET_DVR_NETPARAM;

// ����Ļ���豸��ϵ(16���ֽ�)
typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD    dwSize;
    WORD    wScreenID;        // ��ĻID��, ID�Ŵ�1��ʼ
    BYTE    byWallNo;        // ����ǽ��
    BYTE    byRes1;            // ����1
    DWORD    dwDeviceIndex;    // ����豸���
    BYTE    byRes2[16];        // ����2
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

// ��Ļ����
typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//�Ƿ���ʾ���֣�1-��ʾ���֣�0-����ʾ����
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD        dwSize;
    BYTE        byWallNo;    //����ǽ�ţ���1��ʼ
    BYTE        byRes[11];
    DWORD        dwScreenNums;//�豸���ص�ӳ����ʾ������
    BYTE          *pBuffer;
    DWORD         dwBufLen;//������ָ�볤�ȣ��������
} NET_DVR_SCREENLIST,*LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD    dwSize;
    DWORD    dwSubCommand;    //�����豸�����1-�豸��ʼ������2-ֹͣ����
    DWORD    dwDeviceIndex;//�豸���
    BYTE    byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

//�豸����
typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD    dwProgress; // 0-100
    BYTE     byState;  //�������ȣ�1-������� 2-�������� 3-����ʧ��
    BYTE    byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;
typedef void (CALLBACK *DVCS_UPGRADESTATE_CB)(LONG nUpgradeHandle, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

typedef enum
{
    NET_DVR_DATA_BMP = 0,
        NET_DVR_START_CALLBACK, 
        NET_DVR_STREAM_SYSHEAD,
        NET_DVR_STREAM_DATA
}PIC_PREVIEW_DATATYPE;

typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD    dwSize;
    DWORD    dwSignalIndex;    //�ź�Դ��ţ��ò������ڴ����������������豸��ֵ��Ϊ0
    DWORD    dwDeviceIndex;//�豸���
    BYTE    byRes1[12];
    BYTE    byChanIndex;    //ͨ����
    BYTE    byRes2[3];
    //��Ƶ�ۺ�ƽ̨���Բ���
    DWORD   dwScreenNum; //������ţ����㿪ʼ
    DWORD   dwLayer;     //ͼ��ţ����㿪ʼ
    DWORD   dwResolution;//���Էֱ���,1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//֡�ʣ���λ��֡/��
    BYTE    bySupportStreamView; //�ͻ����Ƿ�֧���������ԣ�0-��֧�֣�1-֧��
    BYTE    byRes3[14];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD    dwSize;
    BYTE    byAlarmType;        // ��������,1-�豸���ߣ�2-�豸���� 3-���������� 4-���������� 5-����Ա��½ 6-Ԥ����ʼ,7-Ԥ��������8-�ֱ��ʱ仯��9-ͼ���и�ʧ�ܣ�10-�豸��Դ���㣬11-�¶��쳣  12-���ڴ�С���ź�Դ�ֱ��ʲ�����*/
    BYTE    byDeviceType;        // �豸���� ������NET_DVCS_DEVICE_TYPE */ 
    BYTE    byWallNo;            // ǽ�ţ���1��ʼ�� 0��ʾ��Ч
    BYTE    byDeviceChanIndex;     // �豸ͨ���ţ�0��ʾ��Ч������ֵ��ʾͨ����
    DWORD    dwDeviceIndex;        // �豸��ţ� 0��ʾ��Ч
    WORD    wResolutionX;        // �ֱ���-��  0��ʾ��Ч
    WORD    wResolutionY;        // �ֱ���-��  0��ʾ��Ч
    WORD    wTemperature;       // �豸�¶� ��λ�����϶�, 0��ʾ��Ч 
    BYTE    byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD        dwSize;
    BYTE        bySubCommand;        //���궨��DECODEPIC_LEFTADJUST��
    BYTE        byScale;            //��������ֵ
    BYTE        byPictureProportion;    //ͼ�����ű��� 0-��Ч 1-4:3, 2-16:9
    BYTE        byRes[29];            
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD    dwSize;        
    BYTE    byControlCommand;    //�л����1-��ʾ��2-���أ�3-ȫ��ɾ�������GIFͼƬ    ��
    BYTE    byUseType;            //ͼƬ���ͣ�1-OSD 2-��ͼ��3-GIF
    BYTE    byWallNo;            //����ǽǽ�ţ���1��ʼ
    BYTE    byPictureNo;        //ͼƬ���
    BYTE    byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;

// 76SP�豸POEͨ����ӷ�ʽ����
typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD        dwSize;                  //�ṹ���С
    BYTE         byAddMode;                 //��ӷ�ʽ 0: ���弴�� 1: �ֶ����    
    BYTE          byRes1[127];              //����
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

#define MAX_ESATA_NUM 16
#define MAX_MINISAS_NUM 96

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD        dwSize;
    BYTE        byESATAUsage[MAX_ESATA_NUM];        // ����������ʾ�ڼ���eSATA��0��Ĭ�ϱ��� 1��Ĭ��¼��
    BYTE        byMiniSASUsage[MAX_MINISAS_NUM];    // ����������ʾ�ڼ���miniSAS��0��Ĭ�ϱ��� 1��Ĭ��¼��
    BYTE         byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

#define MAX_DISK_NUM 128

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD        dwSize;
    BYTE        byDiskDesc[DESC_LEN_32];        //���ݴ�������
    BYTE        byHardDisk[MAX_DISK_NUM];        //�豸�ݵ�Ӳ�̺ţ����ݼ���ȡǰ���� 
    BYTE        byBackupHardDiskNum;              //�豸�ݵ�Ӳ�̸���
    BYTE        byContinue;                        //�Ƿ�������ݣ�0-��������1-����
    BYTE        byAllLogBackUp ;        /*�Ƿ�ȫ�����ݣ�0-�����̺ű��ݣ�1-����������־����Ϊ1ʱ���豸�ݵĴ��̺ź�Ӳ�̸�����Ч*/
    BYTE         byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD    dwSize;
    BYTE    byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //��ʾ��������ͨ���ĶԽ�״̬ 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE    byDigitalChanState[MAX_CHANNUM_V30];  /*����ͨ��������״̬ byDigitalChanErrState[0] 
                                               ��ʾ��һ������ͨ��������ֵ��ʾ״̬�룬���NET_SDK_DIGITAL_CHANNEL_STATUS���Դ����ƣ�0��ʾ��Ч*/
    BYTE    byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30*3];  //��ʾ��������ͨ���ĶԽ�״̬���ӵ�MAX_CHANNUM_V30+1 ����MAX_CHANNUM_V30*4���� 0-δʹ�ã�1-ʹ����, 0xff��Ч
    BYTE    byDigitalChanStateEx[MAX_CHANNUM_V30*3];  /*����ͨ��������״̬ byDigitalChanErrStateEx[0]��ʾ�ڴӵ�MAX_CHANNUM_V30+1��������ͨ��������ֵ��ʾ״̬�룬���NET_SDK_DIGITAL_CHANNEL_STATUS���Դ����ƣ�0��ʾ��Ч*/
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];//��ʾģ��ͨ���Ƿ�����,0-����,1-����
    BYTE    byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;

//����ͨ��״̬
typedef enum
{
    NET_SDK_DC_STATUS_CONNECTED = 1,                //������
        NET_SDK_DC_STATUS_CONNECTING,                    //��������
        NET_SDK_DC_STATUS_BAND_WIDTH_EXCEED,        //����ϵͳ����
        NET_SDK_DC_STATUS_DOMAIN_ERROR,                //��������
        NET_SDK_DC_STATUS_CHANNEL_ERROR,                //ͨ���Ŵ���
        NET_SDK_DC_STATUS_ACCOUNT_ERROR,                //�û������������
        NET_SDK_DC_STATUS_STREAM_TYPE_NOT_SUPPORT,    //�����Ͳ�֧��
        NET_SDK_DC_STATUS_CONFLICT_WITH_DVR,            //���豸IP��ַ��ͻ
        NET_SDK_DC_STATUS_CONFLICT_WITH_IPC,            //��IPC IP��ַ��ͻ
        NET_SDK_DC_STATUS_NETWORK_UNREACHBALE,    //���粻�ɴ�
        NET_SDK_DC_STATUS_IPC_NOT_EXIST,                //IPͨ��δ����
        NET_SDK_DC_STATUS_IPC_EXCEPTION,                //IPͨ���쳣
        NET_SDK_DC_STATUS_OTHER_ERROR,                //��������
        NET_SDK_DC_STATUS_RESOLUTION_NOT_SUPPORT,    //IPC�ֱ��ʲ�֧��
        NET_SDK_DC_STATUS_IPC_LAN_ERR = 15,         //IPC������NVR���Բ�ƥ��
        NET_SDK_DC_STATUS_USER_LOCKED = 16,         //�û�������
        NET_SDK_DC_STATUS_NOT_ACTIVATED = 17,        //�豸δ����
        NET_SDK_DC_STATUS_USER_NOT_EXIST = 18,      //�û�������
        NET_SDK_DC_STATUS_IPC_UNREGISTERED = 19,     //IPͨ����Ӧ�豸δע��(GB28181Э�����)
        NET_SDK_DC_STATUS_POE_PORT_DETECTING = 20,   //POEͨ�������
		NET_SDK_DC_STATUS_RESOURCE_EXCEED = 21,      /* IPC�ֱ��ʣ����ʳ�������*/
		NET_SDK_DC_STATUS_NEED_TO_REPAIR = 22,       /* ��������������Ҫ����*/
		NET_SDK_DC_STATUS_ACTIVATING = 23,            /* IPC���ڼ��� */
        NET_SDK_DC_STATUS_TOKEN_AUTHENTCATE_FAILED = 24            /* token��֤ʧ�� */
}NET_SDK_DIGITAL_CHANNEL_STATUS;

/*************************************ITS****************************/
#define VERSION_LEN                 32 //�汾����
#define    MAX_OVERLAP_ITEM_NUM        50 //����ַ���������
#define    ITS_MAX_DEVICE_NUM            32 //����豸����

//�ն˻�����Ϣ
typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;    
    BYTE    byMainVer[VERSION_LEN];    // �㷨�����̰汾
    BYTE    byMprVer[VERSION_LEN];    // ��֡ʶ���汾
    BYTE    byBvtVer[VERSION_LEN];    // ������Ƶ��汾
    BYTE    byLptVer[VERSION_LEN];    // ��Ƶ���ٿ�汾
    BYTE    byTvdVer[VERSION_LEN];    // Υ�¼���汾
    BYTE    byTldVer[VERSION_LEN];    // �źŵƼ���汾
    BYTE    byRes[252];        // Ԥ���ֶ�
}NET_ITS_BASEINFO,*LPNET_ITS_BASEINFO;

//ͼƬ�ϳɲ���
typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE   byIsMerge;        //�Ƿ���Ҫ�ϳɣ�0�����ϳɣ�1���ϳɣ�
    BYTE   byCloseupProportion;//��дͼ���� 1-ԭʼ�ֱ��ʴ�С��2-���Ϊԭʼ�ֱ����������Դ�����(1��8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;    //ץ�ĵ���ͼ�ϳɷ�ʽ�����ܻ��ȡ��дͼ��
    /************************************************************************/
    /* 201 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ2��         */
    /* 202 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ1��         */
    /* 203 ���ºϳɣ���д�����ϱ�.                                          */
    /* 204 ���ºϳɣ���д�����±�.                                        */
    /* 205 ���Һϳɣ���д�����ұߡ�                                       */
    /* 206 ���Һϳɣ���д�������                                         */
    /* 207 Ʒ�ֺϳɣ���дͼ���ϱ�                                         */
    /* 208 ��Ʒ�ֺϳɣ���дͼ���±�                                       */
    /* 209 �����Σ����1��Ϊ��д                                          */
    /* 210 �������Σ��ұ�1��Ϊ��д                                        */
    /* 301 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ3��         */
    /* 302 ����ͼƬ�������кϳ�,�ϳɺ�ͼƬ��Ϊ����ͼ��3��,��Ϊ1��          */
    /* 303 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��                      */
    /* 304 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��                      */
    /* 305 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��                      */
    /* 306 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;ѹ��ͼƬ�ֱ���,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��      */
    /* 307 ����ͼƬ"Ʒ"�������кϳ�                                          */
    /* 308 ����ͼƬ��"Ʒ"�������кϳ�                                      */
    /* 309 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��                          */
    /* 310 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��                          */
    /* 311 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;�ϳɺ�ͼƬ��Ϊ����ͼ��2��,��Ϊ2��                          */
    /* 312 ������ͼƬ��ȡһ��������д����,�������ͼƬ;����ͼƬ"��"���ͺϳ�,
    ��д������;ѹ��ͼƬ�ֱ���,�ϳɺ�ͼƬ��Ϊ����ͼ��1��,��Ϊ1��      */
    
    /* 313 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ����дͼ������ͼ������ͼ������ͼ                         */
    /* 314 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ����дͼ������ͼ������ͼ                         */
    /* 315 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ����дͼ������ͼ                         */                   
    /* 316 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"һ"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ������ͼ����дͼ                         */  
    /* 317 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ����дͼ������ͼ������ͼ������ͼ                         */
    /* 318 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ����дͼ������ͼ������ͼ                         */  
    /* 319 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ����дͼ������ͼ                         */ 
    /* 320 ������ͼƬ��ȡһ��������д�����������ͼƬ��
    ����ͼƬ��"1"���ͺϳɣ�
    ˳��Ϊ������ͼ������ͼ������ͼ����дͼ                         */     
    /************************************************************************/
    DWORD  dwTwoMergeType;    //ץ������ͼ�ϳɷ�ʽ
    DWORD  dwThreeMergeType;    //ץ������ͼ�ϳɷ�ʽ
    DWORD  dwJpegQuality;      //ѹ��������0~100��
    DWORD  dwCloseupIndex;     //��дͼץ�ĵڼ���
    DWORD  dwMerageMaxSize;   //�ϳ�ͼƬ��С������,300-10240(��λKB)
    WORD   wCloseupDeviation; // ��дͼƫ����(50~ͼƬ�߶�)����λ:����
    BYTE   byRes[30];
}NET_ITS_IMGMERGE_CFG,*LPNET_ITS_IMGMERGE_CFG;

//��ͨ��������
typedef    struct    tagNET_ITS_TRAFFIC_DATA_HOST
{
    NET_DVR_IPADDR    struHostAddr;    // Զ������IP
    WORD            wHostPort;    // Զ������Port
    BYTE            byRes1[2];
    DWORD            dwDataType;    // �ϴ�Զ���������������ͣ�������£�����λ��ʾ
    BYTE            bySuspendUpload;    // �Ƿ���ͣ�����ϴ���0-�����ϴ���1-��ͣ�ϴ�
    BYTE            byUploadStrategy;    // �ϴ����ԣ�0-�������������ϴ���1-����ͨ��ʱ���ϴ�
    WORD            wUploadInterval;    // �ϴ����ʱ�䣨ms��1~2000�����ò���ֻ����ʷ������Ч
    DWORD            dwUploadTimeOut; //�ϴ���ʱʱ��
    BYTE            byRes[24];
}NET_ITS_TRAFFIC_DATA_HOST,*LPNET_ITS_TRAFFIC_DATA_HOST;

//�����ϴ�����
typedef  struct    tagNET_ITS_UPLOAD_CFG
{
    DWORD                  dwSize;
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost1;       //���ս�ͨ��������1
    NET_ITS_TRAFFIC_DATA_HOST    struRemoteDataHost2;        //���ս�ͨ��������2 
}NET_ITS_UPLOAD_CFG,*LPNET_ITS_UPLOAD_CFG;

typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;           //��
    WORD  wMonth;          //��
    WORD  wDay;            //��
    WORD  wHour;           //ʱ
    WORD  wMinute;      //��
    WORD  wSecond;      //��
    WORD  wMilliSec;    //����
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;

//��ͨ��������״̬��Ϣ
typedef    struct tagNET_ITS_TRAFFIC_DATA_INFO
{
    DWORD    dwDataQuantity;      //��������
    DWORD    dwDataRsendQuantity;     //δ������������Ҫ�ϴ���ͨ���������ģ�
    NET_DVR_SYSTEM_TIME      struStartTime;        //δ�������ݵ�����ʱ��
    NET_DVR_SYSTEM_TIME      struEndTime;        //δ�������ݵ�����ʱ��
    NET_DVR_IPADDR   struDataHost;    //���ս�ͨ��������
}NET_ITS_TRAFFIC_DATA_INFO, *LPNET_ITS_TRAFFIC_DATA_INFO;

//�ն˹���״̬
typedef  struct tagNET_ITS_WORKSTATE
{ 
    DWORD  dwSize ;
    BYTE   byDevName[NAME_LEN];    // �豸����
    DWORD  dwRunTime;        // ϵͳ����ʱ�䣬��λs
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //֧����̨�����������ϴ����õ�������
    DWORD  dwMemoryUsage;    // �ڴ�ռ���ʣ�����ڴ�ռ����Ϊ30%���˴���30��
    DWORD  dwCpuUsage;        // cpuռ���ʣ����cpuռ����Ϊ30%���˴���30��
    DWORD  dwDevTemperature;    // �����¶�
    DWORD  dwDeviceStatic;     // �豸��״̬,0-����,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30]; //ͨ����״̬
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30];  //��������ڵ�״̬,0-û�б���,1-�б���
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD dwLocalDisplay;            //������ʾ״̬,0-����,1-������
    BYTE  byAudioInChanStatus[8];      //��ʾ����ͨ����״̬ 0-δʹ�ã�1-ʹ���У�����0��ʾ��1������ͨ��
    BYTE  byRes[36];             //����
}NET_ITS_WORKSTATE, *LPNET_ITS_WORKSTATE;

//����ڽ�ͨ���û�ȡ����
typedef  struct tagNET_ITS_ECT_WORKSTATE_COMMAND
{ 
    DWORD    dwSize;
    DWORD   dwChannel;
    BYTE    byRes[256];             //����
}NET_ITS_ECT_WORKSTATE_COMMAND, *LPNET_ITS_ECT_WORKSTATE_COMMAND;

typedef struct tagNET_ITS_ECTWORKSTATE
{ 
    DWORD     dwSize ;
    BYTE     byDevName[NAME_LEN];    // �豸����
    DWORD    dwRunTime;        // ϵͳ����ʱ�䣬��λs
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //֧����̨�����������ϴ����õ�������
    DWORD    dwMemoryUsage;    // �ڴ�ռ���ʣ�����ڴ�ռ����Ϊ30%���˴���30��
    DWORD    dwCpuUsage;        // cpuռ���ʣ����cpuռ����Ϊ30%���˴���30��
    DWORD    dwDevTemperature;    // �����¶�
    DWORD    dwDeviceStatic;     // �豸��״̬,0-����,1-CPUռ����̫��,����85%,2-Ӳ������,���紮������
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //Ӳ��״̬
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //��������ڵ�״̬,0-û�б���,1-�б���
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //��������˿ڵ�״̬,0-û�����,1-�б������
    DWORD    dwLocalDisplay;            //������ʾ״̬,0-����,1-������
    BYTE     byRes[256];             //����
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

// ͼƬ��Ϣ�����������������
typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;            //ý�����ݳ���
    // 0:����ͼ;1:����ͼ;2:�ϳ�ͼ; 3:��дͼ;4:��ֱͼ;5:����;6:������ͼ(����ʻ);7:������ͼ(����ʻ)��ͼ;8-�ǻ�����;9-����;10-����ԭʼ������;11-Ŀ��ͼ;12-����ʻ��ͼ ;13-����ʻ��ͼ;14-����ͼ��Сͼ
    //15 - �Զ���ͼƬ(�û��Լ��ϴ�����Υ������ͼƬ)
    BYTE    byType;            
    // 0-����ֱ���ϴ�; 1-�ƴ洢������URL(3.7Ver)ԭ�ȵ�ͼƬ���ݱ��URL���ݣ�ͼƬ���ȱ��URL����
    BYTE    byDataType;
    BYTE    byCloseUpType;//��дͼ���ͣ�0-����,1-�ǻ�����,2-����
    BYTE    byPicRecogMode;  //ͼƬ����ʶ��0-������ʶ��1-����ʶ��(β��ʶ��) ��
    DWORD   dwRedLightTime;        //�����ĺ��ʱ��  ��s��
    BYTE    byAbsTime[32];        //����ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999  �����λΪ������
    NET_VCA_RECT   struPlateRect;    //����λ��,��byTypeΪ8-�ǻ�����;9-����ʱ����ʾ��������
    NET_VCA_RECT  struPlateRecgRect;   //��ʶ�������꣬��ͼƬ����Ϊ12-����ʻ��ͼ13-����ʻ��ͼ�ǣ�������Ϊ��ʻԱ����
    BYTE    *pBuffer;    //����ָ��
    DWORD   dwUTCTime;//UTCʱ�䶨��
    BYTE    byCompatibleAblity; //���������ֶ� 0��ʾ��Ч��1��ʾ��Ч; bit0-��ʾdwUTCTime�ֶ���Ч
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    byRes2[4];           //����
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;


typedef struct tagNET_ITS_ILLEGAL_INFO
{
    BYTE  byIllegalInfo[MAX_ILLEGAL_LEN/*64*/];// Υ��������Ϣ���ַ���ʽ��
    BYTE  byRes[256];
}NET_ITS_ILLEGAL_INFO,*LPNET_ITS_ILLEGAL_INFO;


// �����
typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;        //�ṹ����
    DWORD   dwMatchNo;        //ƥ�����,��(�������,��������,������)���ƥ����
    BYTE    byGroupNum;    //ͼƬ��������һ������������ץ�ĵ�����������һ��ͼƬ��������������ʱƥ�����ݣ�
    BYTE    byPicNo;        //���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������;���ճ�ʱ����ͼƬ������ʱ��������Ҫ������ɾ����
    BYTE    bySecondCam;    //�Ƿ�ڶ����ץ�ģ���Զ����ץ�ĵ�Զ���������ǰ��ץ�ĵĺ������������Ŀ�л��õ���
    BYTE    byFeaturePicNo; //����Ƶ羯��ȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE    byDriveChan;        //����������
    BYTE    byVehicleType;     //�������ͣ��ο�VTR_RESULT
    BYTE    byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    //�������ԣ���λ��ʾ��0- �޸�������(��ͨ��)��bit1- �Ʊ공(�������ı�־)��bit2- Σ��Ʒ������ֵ��0- ��1- ��
    //�ýڵ��Ѳ���ʹ��,ʹ�������byYellowLabelCar��byDangerousVehicles�ж��Ƿ�Ʊ공��Σ��Ʒ��
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //Υ�����Ͳ��ù��궨��
    BYTE    byIllegalSubType[8];   //Υ��������
    BYTE    byPostPicNo;    //Υ��ʱȡ�ڼ���ͼƬ��Ϊ����ͼ,0xff-��ʾ��ȡ
    //ͨ����(��Ч������ͨ���ź������豸�ϴ�����ͨ����һ�£��ں�˺�������� ͨ����һ��)
    BYTE    byChanIndex;        
    WORD    wSpeedLimit;        //�������ޣ�����ʱ��Ч��
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex��ʾ��ʵͨ���š�
    /*������λ���ر�־,0~Ϊ��ͨ����ʶ�𱨾�,
    1~Ϊ����λ�ò��ش�������(��ͨ��PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json����)��
    2~Ϊ�������ܲ��ش�������(������Ԥ�õ㼰GPS��������)(��ͨ��PUT /ISAPI/Traffic/channels/<ID>/vehicleMonitor/<taskID>/startTask����,
    ����unarmedVehicleDetectionEnable����Ŀ�공�����ʹ�ܣ�Ϊtrueʱ��ֻ�ϱ�������ⱨ�����޳������ܲ��ر�������˸��ֶ�ȡֵΪ0��������2)��
    3~Ϊ�ֶ��������ش�������(/ISAPI/Traffic/channels/<ID>/manualVehicleMonitor?format=json)
    4~Ϊ�ճ�����(���ó����������)��ͨ��������������������Ƿ�֧���ճ���������,
        (��ͨ��/ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities��isSupportDailyVehicleMonitor�ж�,�ճ���������ʱ,�豸�������ϱ�ANPR��������ʵʱ�ϱ�vehicleMonitor�������ر���)
        �������ظ��ֶ������Ϊ��ͨ�������
    */
    BYTE    byVehiclePositionControl;  
    NET_DVR_PLATE_INFO  struPlateInfo;     //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //������Ϣ
    BYTE    byMonitoringSiteID[48];        //������
    BYTE    byDeviceID[48];                //�豸���
    BYTE    byDir;            //��ⷽ��1-���У����򣩣�2-����(����)��3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE    byDetectType;    //��ⷽʽ,1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //����������ʻ�ķ���0��ʾ�������£�1��ʾ�������ϣ�����ʵ�ʳ�������ʻ�����������֣�,2��ʾδ֪
    //��wIllegalType����Ϊ��ʱ��ʹ�øò�������wIllegalType����Ϊ��ֵʱ����wIllegalType����Ϊ׼���ò�����Ч��
    DWORD   dwCustomIllegalType; //Υ�����Ͷ���(�û��Զ���)
    /*Ϊ0~���ָ�ʽʱ��Ϊ�ϵ�Υ�����ͣ�wIllegalType��dwCustomIllegalType������Ч����ֵ����Υ�����롣
      Ϊ1~�ַ���ʽʱ��pIllegalInfoBuf������Ч���ϵ�Υ�����ͣ�wIllegalType��dwCustomIllegalType������Ȼ��ֵ����Υ������*/
    BYTE*   pIllegalInfoBuf;    //Υ�������ַ���Ϣ�ṹ��ָ�룻ָ��NET_ITS_ILLEGAL_INFO 
    BYTE    byIllegalFromatType; //Υ����Ϣ��ʽ���ͣ� 0~���ָ�ʽ�� 1~�ַ���ʽ
    BYTE    byPendant;// 0-��ʾδ֪,1-�����������2-������������
    BYTE    byDataAnalysis;            //0-����δ����, 1-�����ѷ���
    BYTE    byYellowLabelCar;        //0-��ʾδ֪, 1-�ǻƱ공,2-�Ʊ공
    BYTE    byDangerousVehicles;    //0-��ʾδ֪, 1-��Σ��Ʒ��,2-Σ��Ʒ��
    //�����ֶΰ���Pilot�ַ���Ϊ����ʻ����Copilot�ַ���Ϊ����ʻ
    BYTE    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    //0-��բ��1-δ��բ (ר������ʷ������������ݺڰ�����ƥ����Ƿ�բ�ɹ��ı�־)����byAlarmDataTypeΪ0-ʵʱ����ʱ 0-δ��բ 1-��բ
    BYTE    byBarrierGateCtrlType; 
    BYTE    byAlarmDataType;//0-ʵʱ���ݣ�1-��ʷ����
    NET_DVR_TIME_V30  struSnapFirstPicTime;//�˵�ʱ��(ms)��ץ�ĵ�һ��ͼƬ��ʱ�䣩
    DWORD   dwIllegalTime;//Υ������ʱ�䣨ms�� = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    DWORD   dwPicNum;        //ͼƬ��������picGroupNum��ͬ����������Ϣ������ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //ͼƬ��Ϣ,���Żص������6��ͼ�����������
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

//����ڳ���ץ�������ϴ�
typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;        //�ṹ����
    DWORD   dwMatchNo;        //ƥ�����,��(�������,��������,������)���ƥ���� Ĭ��0
    BYTE    byGroupNum;    //ͼƬ��������һ������������ץ�ĵ�����������һ��ͼƬ��������������ʱƥ�����ݣ�Ĭ�� 1 ץ��������ͼƬ���� ���ƺ���������ʱ����
    BYTE    byPicNo;        //���ĵ�ͼƬ���ϴ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ������ɡ�
    //���ճ�ʱ����ͼƬ������ʱ��������Ҫ������ɾ����
    BYTE    bySecondCam;    //�Ƿ�ڶ����ץ�ģ���Զ����ץ�ĵ�Զ���������ǰ��ץ�ĵĺ������������Ŀ�л��õ�����ʾǰ�����ץ��ͼƬ
    BYTE    byRes; //���ΪԤ��
    WORD    wLaneid;            //������1��32�����������ţ�������Ծ��
    BYTE    byCamLaneId;    //��Ӧ���������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byRes1;            //����
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //�Զ��屨������ Ĭ��Ϊ����
    WORD    wBackList;    //���Ϊ�Ƿ񱨾����� 0 ��ʾΪ������������ 1 ��ʾ������
    WORD    wSpeedLimit;        //�������ޣ�����ʱ��Ч��km/h
    DWORD   dwChanIndex;        //ͨ����
    NET_DVR_PLATE_INFO    struPlateInfo;     //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO  struVehicleInfo;    //������Ϣ  ���ٶ�
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //������
    BYTE    byDeviceID[MAX_ID_LEN];                //�豸��� 
    BYTE    byDir;            //��ⷽ��0-���� 1 �볡��2 ����
    BYTE    byDetectType;    //��ⷽʽ, 0-���� 1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN]; // ����
    DWORD   dwPicNum;        //ͼƬ��������picGroupNum��ͬ����������Ϣ������ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����    
    NET_ITS_PICTURE_INFO struPicInfo[4];         //ͼƬ��Ϣ,���Żص������4��ͼ�����������
    //2013-11-19 ����ڳ���ץ�������ϴ���������ʽ����������
    BYTE    bySwipeTime[MAX_TIME_LEN];//����ˢ��ʱ��  ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;

//���������ʶ��
typedef  struct  tagNET_ITS_GATE_FACE
{
    DWORD   dwSize;            //�ṹ�峤��
    BYTE    byGroupNum;    //ͼƬ��������һ������������ץ�ĵ�����������һ��ͼƬ��������������ʱƥ�����ݣ�
    BYTE    byPicNo;        //���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ������ɡ�
    //���ճ�ʱ����ͼƬ������ʱ��������Ҫ������ɾ����
    BYTE    byFeaturePicNo; //��ץʱȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE    byRes;   //����
    WORD    wLaneid;            //������1��32�����������ţ�������Ծ��
    BYTE    byCamLaneId;    //��Ӧ���������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byDir;        //��ⷽ��0-���� 1 �볡�� 2 ����
    DWORD   dwChanIndex;        //ͨ���� 
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //������
    BYTE    byDeviceID[MAX_ID_LEN];                //�豸���
    NET_VCA_FACESNAP_RESULT     struFaceInfo;   //����ץ������    
    BYTE    byRes2[256];   //Ԥ��
}NET_ITS_GATE_FACE, *LPNET_ITS_GATE_FACE;

//ͣ���������ϴ�
typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize; //�ṹ����
    BYTE    byGroupNum; //ͼƬ��������������ѯץ�ĵ�ͼƬ������
    BYTE    byPicNo; //���ĵ�ͼƬ���ϴ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������
    //���ճ�ʱ����ͼƬ������ʱ��������Ҫ������ɾ����
    BYTE    byLocationNum; //����ͼƬ������ĳ�λ��
    BYTE    byParkError; //ͣ���쳣��0-���� 1 �쳣
    BYTE    byParkingNo[MAX_PARKNO_LEN];//��λ���
    BYTE    byLocationStatus; //��λ����״̬��0-�޳���1�г�
    BYTE    bylogicalLaneNum;//�߼���λ�ţ�0-3��һ���������ܹ�4����λ ��0��������ߣ�3�������ұߣ�
    WORD    wUpLoadType;//����λ��ʾ��0~��Ѳ�ϴ���1~�仯�ϴ�
    BYTE    byRes1[4]; //�����ֽ�
    DWORD   dwChanIndex; //ͨ��������ͨ��
    NET_DVR_PLATE_INFO   struPlateInfo;  //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE    byMonitoringSiteID[MAX_ID_LEN]; //������
    BYTE    byDeviceID[MAX_ID_LEN]; //�豸��� 
    DWORD   dwPicNum; //ͼƬ��������picGroupNum��ͬ����������Ϣ������ͼƬ����
    //��ͼƬ��Ϣ��struVehicleInfoEx���� 
    NET_ITS_PICTURE_INFO struPicInfo[2];  //ͼƬ��Ϣ,���Żص������2��ͼ�����������
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

//��ͨȡ֤����
typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //�ṹ���С
    DWORD                   dwRelativeTime;        //���ʱ��
    DWORD                   dwAbsTime;               //����ʱ��
    DWORD                   dwIllegalType;         //Υ�����ͣ����ù��궨�壬��dwIllegalTypeֵΪ0xffffffffʱʹ��byIllegalCode
    DWORD                   dwIllegalDuration;     //Υ������ʱ�䣨��λ���룩 = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//�����ţ�·�ڱ�š��ڲ���ţ�
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //�豸���
    NET_VCA_DEV_INFO        struDevInfo;           //ǰ���豸��Ϣ
    NET_DVR_SCENE_INFO      struSceneInfo;         //������Ϣ
    NET_DVR_TIME_EX         struBeginRecTime;      //¼��ʼʱ�� 
    NET_DVR_TIME_EX         struEndRecTime;        //¼�����ʱ�� 
    NET_DVR_AID_INFO        struAIDInfo;           //��ͨ�¼���Ϣ
    NET_DVR_PLATE_INFO      struPlateInfo;         //������Ϣ
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //������Ϣ
    DWORD                   dwPicNum;              //ͼƬ����
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //ͼƬ��Ϣ�����8�� 
    BYTE                    bySpecificVehicleType;     //���峵������  �ο�ʶ��������VTR_RESULT
    BYTE                    byLaneNo;  //����������
    BYTE                    byRes1[2]; //����
    NET_DVR_TIME_V30        struTime;//�ֶ����ٶ�λ����ǰʱ�䡣
    DWORD                   dwSerialNo;//��ţ�
    BYTE                    byVehicleAttribute;//�������ԣ���λ��ʾ��0- �޸�������(��ͨ��)��bit1- �Ʊ공(�������ı�־)��bit2- Σ��Ʒ������ֵ��0- ��1- ��
    BYTE                    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE                    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE                    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE                    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE                    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    BYTE                    byRes2[2]; //����
    BYTE                    byIllegalCode[ILLEGAL_LEN/*32*/];//Υ��������չ����dwIllegalTypeֵΪ0xffffffff��ʹ�����ֵ
    WORD                    wCountry; // ��������ֵ,����ö��COUNTRY_INDEX
    BYTE                    byRegion; //��������ֵ,0-������1-ŷ��(Europe Region)��2-��������(Russian Region)��3-ŷ��&����˹(EU&CIS) , 4-�ж���Middle East����0xff-����
    BYTE                    byCrossLine;//�Ƿ�ѹ��ͣ�����෽ͣ������0-��ʾδ֪��1-��ѹ�ߣ�2-ѹ��
    BYTE                    byParkingSerialNO[SERIAL_NO_LEN/*16*/];//����λ���
    BYTE                    byCrossSpaces;//�Ƿ�粴��λͣ�����෽ͣ������0-��ʾδ֪��1-δ�粴��λͣ����2-�粴��λͣ��
    BYTE                    byAngledParking;//�Ƿ���бͣ�����෽ͣ����, 0-��ʾδ֪��1-δ��бͣ����2-��бͣ��
    BYTE                    byAlarmValidity;//�������Ŷȣ��������ʻ��ʻ�������Ŷȣ���Χ0-100�����Ŷ�Խ�ߣ��¼���ʵ��Խ��
    BYTE                    byDoorsStatus;//����״̬ 0-���Źر� 1-���ſ���
    DWORD               dwXmlLen;//XML������Ϣ����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    char*                   pXmlBuf; // XML������Ϣָ��,��XML��Ӧ��EventNotificationAlert XML Block
#else
    char*                   pXmlBuf; // XML������Ϣָ��,��XML��Ӧ��EventNotificationAlert XML Block
    BYTE                   byRes3[4];
#endif  
    BYTE                   byVehicleHeadTailStatus;//��ͷ��β״̬ 0-���� 1-��ͷ 2-��β
    BYTE                   byRes[31]; //����
}NET_DVR_TFS_ALARM,*LPNET_DVR_TFS_ALARM;

typedef struct tagNET_DVR_SOFTWARE_SERVICE_CFG
{
    DWORD       dwSize;//�ṹ���С
    BYTE        byThirdStreamEnabled;  //�Ƿ������������ã�0-��1-��
    BYTE        bySubStreamEnabled;  //�Ƿ������������ã�0-��1-��
    BYTE        byRes[254];
}NET_DVR_SOFTWARE_SERVICE_CFG, *LPNET_DVR_SOFTWARE_SERVICE_CFG;

typedef struct _tagNET_ITS_ECT_BLACKLIST_
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  bylogicalLaneNo;//�߼�������
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];//�������� 32
    NET_DVR_PLATE_INFO  struPlateInfo;  //������Ϣ�ṹ  
    BYTE  byRes2[256];       // �����ֽ�    
}NET_ITS_ECT_BLACKLIST, *LPNET_ITS_ECT_BLACKLIST;

//IPCͨ����������
typedef    struct     tagNET_ITS_IPC_CHAN_CFG
{
    DWORD        dwSize; 
    BYTE        byCameraType;        //������࣬0-����������1-��Ȧ���������2-��Ƶ���������,3-һ���
    BYTE        byRes1[3];           //����
    BYTE        byMonitoringSiteID[48];        //������
    BYTE        byDeviceID[48];                //�豸���
    BYTE        byDirectionNo;         //��ⷽ����,0-��,1-����,2-����,3-˫��,4-�ɶ�����,5-������,6-������,7-�ɱ�����,8-����
    BYTE        byMonitorInfo[48];      //������Ϣ����
    BYTE        byRes2[15];        //����
}NET_ITS_IPC_CHAN_CFG, *LPNET_ITS_IPC_CHAN_CFG;

//�����豸��Ϣ
typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;  //�豸���ͣ�0-�նˣ�1-�����2-����ƣ�3-��������4-��Ȧ1��5-��Ȧ2��6-��Ȧ3��7-���̵Ƽ������8-����
    //9-�״10-��բ��11-����ڿ��ƻ�(Ʊ��)��12-LED��ʾ����13-Զ�����������14-�������������15-����ɨ��ǹ��
    //16-Ʊ�ݴ�ӡ����17-�ڵ������(�յ����������) , 18-��������
    DWORD  dwDirID;               //������
    DWORD  dwLaneID;             //�������
    DWORD  dwDeviceState;         //�豸״̬  0���� ��0 �쳣���ο��豸�쳣�����
    BYTE   byDeviceName[32];     //�豸����
    BYTE   byDeviceID[48];           //�豸��ţ�һ�������кţ��������õ�ַ
    NET_DVR_TIME_V30  struTriggerTime;//����ʱ��
    BYTE   byRelateChan; //����ͨ���ţ���������1~8  AC����1~4  AC����1~2��
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO,*LPNET_ITS_SINGLE_DEVICE_INFO;

//·����Ϣ
typedef struct tagNET_ITS_ROADINFO
{    
    DWORD     dwSize;
    DWORD     dwChannel;          //ͨ����,0xffffffff��ʾ�նˣ�������ʾ��Ӧ�����
    BYTE     byTriggerMode;    //  0:��Ȧ����;  1:��Ƶ����
    BYTE     byRes1[3];
    DWORD    dwDeviceNum;       //ʵ���豸���� 
    BYTE     byMonitoringSiteID[48];    //������
    BYTE       byRoadInfo[48];       //������Ϣ
    NET_ITS_SINGLE_DEVICE_INFO        struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE     byRes[16];
}NET_ITS_ROADINFO,*LPNET_ITS_ROADINFO;

//��������·����Ϣ
typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;        //������
    BYTE   byRes1[3];            // Ԥ��
    WORD   wCarFlux;            //����������
    WORD   wPasserbyFlux;        //����������
    WORD   wShayFlux;        //���ֳ�������
    float  fAverOccpancy;       //ƽ������ռ���ʰٷֱ�
    WORD   wAverSpeed;         //ƽ������(km/h)
    WORD   wAverCarDis;        //ƽ������(��λ����)
    BYTE   byRes2[16];            // Ԥ��
}NET_ITS_TRAFFIC_DRIVE_CHAN,*LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;        //�ṹ��С
    BYTE   byMonitoringSiteID[48];        //������
    BYTE   byDeviceID[48];                //�豸���
    BYTE   byLaneNum;    //��������
    BYTE   byDir;        //��ⷽ��
    BYTE   byDetectType;    //��ⷽʽ1-�ظ���Ȧ��2-��Ƶ������3����֡ʶ��4�״ﴥ��
    BYTE   byRes1;           //Ԥ��     
    DWORD  dwChannel; //ͨ����
    NET_DVR_SYSTEM_TIME     struStartTime;        //ͳ�ƿ�ʼʱ��
    DWORD  dwSamplePeriod;    //ͳ��ʱ��,��λ��
    NET_ITS_TRAFFIC_DRIVE_CHAN    struDriveChan[6];         //��ͨ��������,ÿ�����֧��6������
    BYTE   byRes2[24];     //Ԥ��
}NET_ITS_TRAFFIC_COLLECT,*LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //����ģʽ��0-�նˣ�1-ǰ��(ֱ��ǰ�˻��ն˽�ǰ��)
    BYTE  byPicModeType;//0-��ʾСͼ(����ͼ)��1-��ʾ��ͼ(�ϳ�ͼ)
                        /*
                        0��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
                        1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE  byRelateType; 
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;

typedef enum ITS_OVERLAP_ITEM_TYPE
{
    OVERLAP_ITEM_NULL = 0,          //0-δ֪
        OVERLAP_ITEM_SITE,                //1-�ص�
        OVERLAP_ITEM_ROADNUM,             //2-·�ڱ��
        OVERLAP_ITEM_INSTRUMENTNUM,       //3-�豸���
        OVERLAP_ITEM_DIRECTION,           //4-������
        OVERLAP_ITEM_DIRECTIONDESC,       //5-����
        OVERLAP_ITEM_LANENUM,             //6-������
        OVERLAP_ITEM_LANEDES,             //7-����
        OVERLAP_ITEM_CAPTIME,             //8-ץ��ʱ��(��������)
        OVERLAP_ITEM_CAPTIME_MILLSECOND,  //9-ץ��ʱ��(������)
        OVERLAP_ITEM_PLATENUM,            //10-���ƺ�
        OVERLAP_ITEM_CARCOLOR,            //11-������ɫ
        OVERLAP_ITEM_CARTYPE,             //12-��������
        OVERLAP_ITEM_CARBRAND,            //13-����Ʒ��
        OVERLAP_ITEM_CARSPEED,            //14-�����ٶ�
        OVERLAP_ITEM_SPEEDLIMIT,          //15-���ٱ�־
        OVERLAP_ITEM_CARLENGTH,           //16-��������1~99m
        OVERLAP_ITEM_ILLEGALNUM,          //17-Υ������(Υ���������Ӧ��û�õģ�Ӧ��ֱ�ӵ���Υ����Ϣ���������������١����١����С�����ơ�ռ����ѹ���ߵ�)
        OVERLAP_ITEM_MONITOR_INFO,      //18-������Ϣ
        OVERLAP_ITEM_ILLEGALDES,          //19-Υ����Ϊ
        OVERLAP_ITEM_OVERSPEED_PERCENT,    //20-���ٱ�
        OVERLAP_ITEM_RED_STARTTIME,           //21-��ƿ�ʼʱ��
        OVERLAP_ITEM_RED_STOPTIME,        //22-��ƽ���ʱ��
        OVERLAP_ITEM_RED_DURATION,        //23-�������ʱ��
        OVERLAP_ITEM_SECUNITY_CODE,        //24-��α��
        OVERLAP_ITEM_CAP_CODE,        //25-ץ�ı��
        OVERLAP_ITEM_SEATBELT,      //26-��ȫ��  
        OVERLAP_ITEM_MONITOR_ID,    //27-������
        OVERLAP_ITEM_SUN_VISOR,     //28-������ 
        OVERLAP_ITEM_LANE_DIRECTION,  //29-������ʻ���� 
        OVERLAP_ITEM_LICENSE_PLATE_COLOR,  // 30-������ɫ
        OVERLAP_ITEM_SCENE_NUMBER,  //31-�������
        OVERLAP_ITEM_SCENE_NAME,   //32-��������
        OVERLAP_ITEM_YELLOW_SIGN_CAR,  //33-�Ʊ공
        OVERLAP_ITEM_DANGEROUS_CAR,    //34-Σ��Ʒ��
        OVERLAP_ITEM_CAR_SUBBRAND,  //35-������Ʒ��
        OVERLAP_ITEM_CAR_DIRECTION,  //36-��������
        OVERLAP_ITEM_PENDANT,  //37-����������
        OVERLAP_ITEM_CALL,  //38-��绰
        OVERLAP_ITEM_CAR_VALIDITY,  //39-���Ŷ�
        OVERLAP_ITEM_CAR_COUNTRY,       //40-����
        OVERLAP_ITEM_CAR_PLATE_TYPE,    //41-�������ͣ��ο���������ö��
        OVERLAP_ITEM_CAR_PLATE_SIZE,		//42-���Ƴߴ�
        OVERLAP_ITEM_CAR_PLATE_COLOR,		//43-������ɫ
        OVERLAP_ITEM_CAR_PLATE_CATEGORY,		//44-���Ƹ�����Ϣ
        OVERLAP_ITEM_ACCIDENT,  //45-��ͨ�¹�
        OVERLAP_ITEM_SMOKING,  //46-����
        OVERLAP_ITEM_HELMET, //47-��ͷ��
        OVERLAP_ITEM_MANNED, //48-����
        OVERLAP_ITEM_HUMAN, //49-��������
        OVERLAP_ITEM_PLAYMOBILEPHONE, //50-���ֻ�

}ITS_OVERLAP_ITEM_TYPE;

//�ַ�����ÿһ����Ϣ�ṹ��
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                   // ����
    BYTE byItemType;   //���ͣ����OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //�������Ļ�����[0-10](Ĭ��0)
    BYTE bySpaceNum;                   //�������Ŀո���[0-255](Ĭ��0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //�Ƿ�����������ʾ
    WORD wStartPosTop;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD wStartPosLeft;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //�����ַ�����
    DWORD dwLinePercent;  //�����аٷֱ�(0-100),(Ĭ��100)
    DWORD dwItemsStlye;   //���ӷ�ʽ��0-����,1-����(Ĭ�Ϻ���)
    WORD  wStartPosTop;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartPosLeft;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wCharStyle;    //��������,0-����1-κ��(Ĭ��)
    WORD  wCharSize;    //�ַ���С,0--16x16,1--32x32,2-48x48,3--64x64 (Ĭ��),8x128(Ver3.7)
    WORD  wCharInterval;    //�ַ���࣬[0��16]�����赥λ������(Ĭ��)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //ǰ��ɫ��RGBֵbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00FFFFFF-��)
    DWORD dwBackClorRGB; //����ɫ��RGBֵ,ֻ��ͼƬ�������Чbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00000000-��)
    BYTE  byColorAdapt;    //��ɫ�Ƿ�����Ӧ0-��1-��
    //(Ver3.7 ����)
    // ��������ʹ�� 0-����, 1-�����㣨��ϸע�ͣ��ٶ�,����ֵ ����3λ��0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// ����Сͼ�������Ͻ�ʹ�� 0-������, 1-����
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0) 
    WORD  wStartSPicPosLeft; //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0) 
    //OSD����λ��  0-ͼƬ��,1-ͼƬ�ϱ�Ե,2-ͼƬ�±�Ե���ϳ�ͼר�õ����ϱ�Ե�⣩��V3.7��
    BYTE       byOsdLocate;
    BYTE         byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

//�����������Ϣ
typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //�ص�����
    BYTE byRoadNum[32];  //·�ڱ��
    BYTE byInstrumentNum[32];                //�豸���
    BYTE byDirection[32];        //������
    BYTE byDirectionDesc[32];    //��������
    BYTE byLaneDes[32];        //��������
    BYTE byRes1[32];     //����
    BYTE byMonitoringSite1[44];        //����1��Ϣ
    BYTE byMonitoringSite2[32];        //����2��Ϣ
    BYTE byRes[64];        //����
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;    
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM        struOverLapItem; //�ַ�������
    NET_ITS_OVERLAP_INFO_PARAM     struOverLapInfo;  //�ַ���������Ϣ
    BYTE  byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

//�ַ�����ÿһ����Ϣ�ṹ��
typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                   // ����
    BYTE byItemType;   //���ͣ����OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //�������Ļ�����[0-10](Ĭ��0)
    BYTE bySpaceNum;                   //�������Ŀո���[0-255](Ĭ��0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //�Ƿ�����������ʾ
    WORD wStartPosTop;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD wStartPosLeft;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    //�Զ������ͣ���byItemType������Ӧ���ɽ�byItemType���������Զ������ơ����Զ�������Ϊ�գ���Ĭ����byItemType�����е�����������
    BYTE byItemTypeCustom[32]; 
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //�����ַ�����
    DWORD dwLinePercent;  //�����аٷֱ�(0-100),(Ĭ��100)
    DWORD dwItemsStlye;   //���ӷ�ʽ��0-����,1-����(Ĭ�Ϻ���)
    WORD  wStartPosTop;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wStartPosLeft;    //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0)
    WORD  wCharStyle;    //��������,0-����1-κ��(Ĭ��)
    WORD  wCharSize;    //�ַ���С,0--16x16,1--32x32,2-48x48,3--64x64 (Ĭ��),8x128(Ver3.7)
    WORD  wCharInterval;    //�ַ���࣬[0��16]�����赥λ������(Ĭ��)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //ǰ��ɫ��RGBֵbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00FFFFFF-��)
    DWORD dwBackClorRGB; //����ɫ��RGBֵ,ֻ��ͼƬ�������Чbit0-1:(B) bit2-3:(G) bit4-5:(G) (Ĭ��x00000000-��)
    BYTE  byColorAdapt;    //��ɫ�Ƿ�����Ӧ0-��1-��
    //(Ver3.7 ����)
    // ��������ʹ�� 0-����, 1-�����㣨��ϸע�ͣ��ٶ�,����ֵ ����3λ��0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// ����Сͼ�������Ͻ�ʹ�� 0-������, 1-����
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0) 
    WORD  wStartSPicPosLeft; //��ʼ������,ֻ��ͼƬ�ڲ�������Ч[0~2448](Ĭ��0) 
    //OSD����λ��  0-ͼƬ��,1-ͼƬ�ϱ�Ե,2-ͼƬ�±�Ե���ϳ�ͼר�õ����ϱ�Ե�⣩��V3.7��
    BYTE  byOsdLocate;
    BYTE  byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;    
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM_V50        struOverLapItemV50; //�ַ�������
    NET_ITS_OVERLAP_INFO_PARAM             struOverLapInfo;  //�ַ���������Ϣ
    BYTE  byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;

#define  MAX_PTZCRUISE_POINT_NUM   32   //���֧��32��Ѳ����


//Ԥ�õ���Ϣ
typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum; //Ԥ�õ����
    DWORD dwGroupNum;  //����
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;

//�������
typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //���
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;

//�������
typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //Ԥ�õ����
    NET_VCA_POINT struVcaPoint; //Ԥ�õ�����
    WORD wZoomCoordinate; ///<Ԥ�õ㴰��Zoomֵ
    BYTE  byRes[30]; 
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

//��ȡѲ��·������Ŀ
typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum; //·������
    DWORD dwGroupNum; //����
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

//���������
typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //���
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;

//�������
typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //Ԥ�õ����
    NET_VCA_POINT struVcaPoint; //Ԥ�õ�����
    BYTE    byDwell;        //ͣ��ʱ��
    BYTE    bySpeed;        //�ٶ�
    WORD  wZoomCoordinate;///<Ԥ�õ㴰��Zoomֵ
    BYTE   byRes[28]; 
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute; //Ѳ��·�����
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM]; //���֧��32��Ѳ����
    BYTE  byRes[32]; 
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;

//����ģʽ�ṹ
typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize; 
    BYTE byEnableTrack;   //���ø��٣�0-��1-��
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;

//һ��Ķ�ʱ�ƻ�
typedef struct tagNET_DVR_DAY_SCHEDULE
{   
    BYTE byWorkMode ;            //0-ȫ�쿪��1-ȫ��أ�2-��ʱ
    BYTE byRes1[3] ;
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];  //ʱ���
    BYTE byRes2[8];                  //����
}NET_DVR_DAY_SCHEDULE ,*LPNET_DVR_DAY_SCHEDULE;

//��ʱ���ܸ��ٲ����ṹ
typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD    dwSize;    //�ṹ����
    BYTE     byEnableTrack;            //���ø��٣�0- ��1- ��
    BYTE    byRes1[3] ;
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];    //��ʱ���ܸ���ʱ��Σ�������8��ʱ����ڵ�ʱ�䣬Ĭ�϶�ʱ���ܸ��ٹر�
    BYTE    byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG,*LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD    dwSize;                    //�ṹ����
    BYTE    sStreamID[STREAM_ID_LEN/*32*/] ; //��ID
    DWORD    dwChan;                     //����ͨ����
    BYTE    byStreamType;             //0-��������1-��������2-����3��3-����4��4-����5     
    BYTE    byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //���ڼ���1-7��������һ��������
    BYTE byHour;   //ʱ
    BYTE byMinute; //��    
    BYTE byRes1;
    BYTE byRebootMode; //0-����������1-�����������˲���ֻ�ܻ�ȡ���������ã�
    BYTE byDisabled; // 0-���� 1-����
    BYTE byRes[10]; //����
}NET_DVR_REBOOT_TIME,*LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG,*LPNET_DVR_AUTO_REBOOT_CFG;

#define NET_DVR_GPS_FINDING       0   //���ڲ���
#define NET_DVR_GPS_RECV          1   //��������
#define NET_DVR_GPS_OVER          2   //���ҽ���
#define NET_DVR_GPS_EXCEPTION     3   //�����쳣
typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD        dwSize;
    BYTE        byMenuOutputMode; //��ͬԴ�豸��0-Auto 1-��CVBS 2-HDMI 3-VGA ͬԴ�豸��0-Auto 1-��CVBS 2-HDMI/VGA
    BYTE        byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP��ַ
    WORD        wPort;   //�˿ں�
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR,*LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //�豸id
    BYTE byPassword[PASSWD_LEN];  //����
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //�豸id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{   
    DWORD dwSize;
    BYTE byNetEnvironment;/*���绷��,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*< ��ǰƽ̨0 - WVS, 1 - E��, 2 - ��ģʽ */
    BYTE byRes1[2];    
    NET_DVR_MB_WVSPARA  struWVSPara; /*����ƽ̨(ƽ̨����)*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E��ƽ̨����ƽ̨�������豸�������� */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE        byGPSModule;      /*gpsģ��, 0: ������, 1: ����*/
    BYTE        byPositionStatus;      /*gps��λ״̬, 0: ��λʧ��, 1: ��λ�ɹ�*/
    BYTE        bySignalStrength;    /*�ź�ǿ��, 0: ��, 1: ����, 2: ǿ*/
    BYTE        byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE        byGsensorModule;    /*g-sensorģ��, 0: not exist, 1: ����, 2: ����*/
    BYTE        byCurAccX[10];     /*��ǰX����ٶ�*/
    BYTE        byCurAccY[10];    /*��ǰY����ٶ�*/
    BYTE        byCurAccZ[10];    /*��ǰZ����ٶ�*/
    BYTE        byRefAccX[10];    /* X����ٶȱ궨ֵ*/
    BYTE        byRefAccY[10];    /* Y����ٶȱ궨ֵ*/
    BYTE        byRefAccZ[10];    /* Z����ٶȱ궨ֵ*/
    BYTE        byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

#define IP_ADDR_LEN         16
#define IW_ESSID_MAX_SIZE    32

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE        byEnableWiFi; /* ����, 0 ��, 1 �� */
    BYTE         byWiFiConnectStatus;  /* WIFI״̬, 0: ����ʧ��, 1: ���ӳɹ� 2: ��ģ��*/
    BYTE        bySignalStrength;             /* �ź�ǿ��, 0 ��, 1 ����, 2 ǿ */
    BYTE        byIPaddress[IP_ADDR_LEN];   /*WIFI �豸 ip*/
    BYTE        byEssid[IW_ESSID_MAX_SIZE];  /*���߽����essid*/
    BYTE        byres[5];
}NET_DVR_MB_WIFI_STATUS,*LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE        byCurPlat;      /*��ǰƽ̨, 0: wvs, 1: ivms, 2: ��ģʽ(net_3g_sdk)*/
    BYTE        byLoginStatus;     /*login ״̬, 0: login failed, 1: login success*/
    BYTE        byExceptionInfo;      /*�쳣��Ϣ*/
    /*
    WVS :exception info:
    0: ���ӷ�����ʧ��
    1: ע����
    2: �û����������
    3: ע�ᳬʱ
    4: ������ʱ
    5: ע��ɹ�
    iVMS :exception info:
    0δע��    
    1ע����    
    2ע�����ӳ���
    3ע�ᳬʱ
    4��ʱ��û�������������ж�
    5����ע��
    6 CMS��ע���豸�����Ѿ������޶���̨��
    7 CMS��ע��ͨ�������Ѿ������޶�ͨ����
    8�豸��WEB����������û������
    9CMS��WEB��������ͨ��ʧ��
    10��¼δ֪����
    11ע��ɹ�
    ��ģʽ :exception info:    
    0δע��
    1: ע����
    2: �ظ�ע��
    3: ע������ʧ��
    4: ������IP�仯
    5: ע��ɹ�
    6: �û�ע��
    7: ������ʱ
    */                        
    BYTE        byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;


typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD        dwSize;      /*�ṹ��С*/
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

#define NET_DVR_GPS_STATUS       0
#define NET_DVR_GSENSOR_STATUS   1
#define NET_DVR_WIFI_STATUS      2
#define NET_DVR_PLATFORM_STATUS  3

//GPS����Ϣ�ṹ
typedef struct tagNET_DVR_GPS_INFO
{
    /* ��γ��ΪS*100 */
    BYTE    byDirection[2];        /*direction[0]0or1(����/����), direction[1]:0or1(��γ/��γ)  */
    BYTE    bySvs;         /* satellite vehicles(��ֵ0)����Ч��λ���� */
    BYTE    byLocateMode;  /* ��λģʽ(��ֵ0)����NMEA0183 3.00�汾�����0=������λ��1=��֣�2=���㣬3=������Ч */
    WORD    wHDOP;  /* ˮƽ�������ӣ�����GPS��ȷ�ȣ�0.5-99.9��6���ڶ�λ���ȸߣ�20�����趪��������洢���ǳ���10�Ժ������ */     
    WORD    wHeight;             /* �߶� */
    DWORD   dwLatitude;     /*γ��latitude = ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD   dwLongitude; /*����longitude =ʵ�ʶ�*3600*100+ʵ�ʷ�*60*100+ʵ����*100 */
    DWORD   dwVehicleSpeed;        /* mobile speed =ʵ���ٶ�*100000 ʵ�ʵ�λkph*/
    DWORD    dwVehicleDirection;    /* mobile direction= ʵ�ʷ���*100��ʵ����ֵ�Ƿ���ǣ�����Ϊ0�ȣ�˳ʱ�� */
    BYTE    byRes[8];            // ����
}NET_DVR_GPS_INFO,*LPNET_DVR_GPS_INFO; //32�ֽ�

//GPS״̬�ϴ�
typedef  struct _NET_DVR_GPS_STATUS_ALARM_
{
    DWORD       dwSize;
    NET_DVR_TIME_V30   struGPSTime;      //GPS ����ʱ�䣬���ñ���ʱ��
    NET_DVR_GPS_INFO   struGPSInfo;      //GPS�����
    BYTE         byRetransFlag; //0-���� GPS Ϊʵʱ����1-���� GPS Ϊ�ش���
    BYTE         byNeedsResponse; //��Ӧ��ǣ�0�������Ӧ����1�����Ӧ��
    BYTE         byType;//�ϱ����� 0-���˻�
    BYTE         byBatteryRemaining;//ʣ�������-1--100; -1��ʾ����
    int        iRollAngle;//�����Ƕ�,��Χ-pi - +pi,ʵ��ֵ*100
    int        iPitchAngle;//��ͷ����Ƕ�,��Χ-pi - +pi,ʵ��ֵ*100
    WORD        wRelativeHeight;//��Ը߶ȣ���λ������  
    WORD        wVerticalSpeed;//��ֱ�ٶȣ���λ������/Сʱ
    BYTE         byRes2[160];         //����
}NET_DVR_GPS_STATUS_ALARM, *LPNET_DVR_GPS_STATUS_ALARM;

//GPS����ʱ��
typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS�����
    NET_DVR_TIME      struTime;            //GPS�����Ӧ��ʱ��㣬UTCʱ��
    BYTE        byRes[12];             // ����
}NET_DVR_GPS_DATA,*LPNET_DVR_GPS_DATA;

//GPS���������ṹ
typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{    
    DWORD dwCmdType;              //0-��ʱ��β���GPS����,1-��ʱ������GPS����    
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //GPS���ݲ�����ʼʱ��       
            NET_DVR_TIME struEndTime;                 //GPS���ݲ��ҽ���ʱ��
            DWORD dwInterval;                  //GPS��ʱ��������λ��
            BYTE  byRes[76];                    // ����
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //GPS���ݲ�����ʼʱ�䵥λ��
            BYTE  byRes[104];              // ����
        }TimePoint;    
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM,*LPNET_DVR_GET_GPS_DATA_PARAM;

#define NET_SDK_MAX_CARD_LEN 32 //��󿨺ų���

//��ǩ��Ϣ�ϴ�
typedef  struct _NET_DVR_TAG_INFO_ALARM_
{
    DWORD        dwSize;
    BYTE         byCardNo[NET_SDK_MAX_CARD_LEN/*32*/]; //����
    int          iRssi;//�����ź�ǿ��,��Χ-100 - +100
    BYTE         byIndexCode[64];//ƽ̨index code,�൱���豸���
    NET_DVR_TIME_V30  struAcquisitionTime;//��ȡʱ��
    BYTE         byRFIDInfo[32]; //��ƬID
    BYTE         byRFIDInfoLen;  //��ƬID����
    BYTE         byVoltageLow; //1��ʾ�͵�ѹ��0��ʾ����
    BYTE         byAlarmFlag; ///(֪ͨƽ̨������)�Ƿ���Ҫ������1��Ҫ��0����Ҫ
    BYTE         byRes[49];         //����
}NET_DVR_TAG_INFO_ALARM, *LPNET_DVR_TAG_INFO_ALARM;


typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE    byEnableAbilityParse;    //ʹ��������������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE    byVoiceComMode;          //�Խ�ģʽ��0-ʹ�öԽ��⣨Ĭ�ϣ���1-ʹ��windows apiģʽ    
    BYTE    byLoginWithSimXml;  //��¼ʱʹ��ģ������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE    byProtectKey[128];    //Ĭ������Ϊ0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;

typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE    byEnableAbilityParse;    //ʹ��������������,0-��ʹ��,1-ʹ��,Ĭ�ϲ�ʹ��
    BYTE    byRes[127];                
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE    byTalkMode;                //�Խ�ģʽ��0-ʹ�öԽ��⣨Ĭ�ϣ���1-ʹ��windows apiģʽ
    BYTE    byRes[127];                
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;


typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE    byProtectKey[128];        //Ĭ������Ϊ0
    BYTE    byRes[128];            
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //��¼ʱʹ��ģ������У���ṹ�������ֶ�,0-��ʹ��,1-ʹ��
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;

//�����ص����ò���
typedef struct
{   /*����JSON͸����������COMM_VCA_ALARM����JSON��ʽ��
    0~��JSON��ʽ���ο�4.1.4;
    1~��JSON��ʽ���ο�4.1.5
    */
    BYTE byVcaAlarmJsonType;
    BYTE byRes[63];
}NET_DVR_MESSAGE_CALLBACK_PARAM_V51,*LPNET_DVR_MESSAGE_CALLBACK_PARAM_V51;

typedef enum tagNET_SDK_LOCAL_CFG_TYPE
{
    NET_SDK_LOCAL_CFG_TYPE_TCP_PORT_BIND = 0,        //����TCP�˿ڰ����ã���Ӧ�ṹ��NET_DVR_LOCAL_TCP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_UDP_PORT_BIND,            //����UDP�˿ڰ����ã���Ӧ�ṹ��NET_DVR_LOCAL_UDP_PORT_BIND_CFG
    NET_SDK_LOCAL_CFG_TYPE_MEM_POOL,                //�ڴ�ر������ã���Ӧ�ṹ��NET_DVR_LOCAL_MEM_POOL_CFG
    NET_SDK_LOCAL_CFG_TYPE_MODULE_RECV_TIMEOUT,        //��ģ�����ó�ʱʱ�䣬��Ӧ�ṹ��NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
    NET_SDK_LOCAL_CFG_TYPE_ABILITY_PARSE,            //�Ƿ�ʹ�������������⣬��Ӧ�ṹ��NET_DVR_LOCAL_ABILITY_PARSE_CFG
    NET_SDK_LOCAL_CFG_TYPE_TALK_MODE,                //�Խ�ģʽ����Ӧ�ṹ��NET_DVR_LOCAL_TALK_MODE_CFG
    NET_SDK_LOCAL_CFG_TYPE_PROTECT_KEY,                //��Կ���ã���Ӧ�ṹ��NET_DVR_LOCAL_PROTECT_KEY_CFG
    NET_SDK_LOCAL_CFG_TYPE_CFG_VERSION,             //���ڲ��԰汾ͷ���豸�˼�����NET_DVR_LOCAL_MEM_POOL_CFG��, ֻ�������ò���ʱ�������á�
    NET_SDK_LOCAL_CFG_TYPE_RTSP_PARAMS,                //rtsp�������ã����ڽṹ��NET_DVR_RTSP_PARAMS_CFG
    NET_SDK_LOCAL_CFG_TYPE_SIMXML_LOGIN,            //�ڵ�¼ʱʹ��ģ����������support�ֶ�, ��Ӧ�ṹNET_DVR_SIMXML_LOGIN
    NET_SDK_LOCAL_CFG_TYPE_CHECK_DEV,                //�����������ʱ��
    NET_SDK_LOCAL_CFG_TYPE_SECURITY,                  //SDK���ΰ�ȫ���ã�
    NET_SDK_LOCAL_CFG_TYPE_EZVIZLIB_PATH,            //����өʯ��ͨ�ſ��ַ��
    NET_SDK_LOCAL_CFG_TYPE_CHAR_ENCODE,               //13.�����ַ�������ش���ص�
    NET_SDK_LOCAL_CFG_TYPE_PROXYS,                     //���û�ȡ��
    NET_DVR_LOCAL_CFG_TYPE_LOG,                       //��־��������  NET_DVR_LOCAL_LOG_CFG
    NET_DVR_LOCAL_CFG_TYPE_STREAM_CALLBACK,           //�����ص��������� NET_DVR_LOCAL_STREAM_CALLBACK_CFG
    NET_DVR_LOCAL_CFG_TYPE_GENERAL,                   //ͨ�ò������� NET_DVR_LOCAL_GENERAL_CFG
    NET_DVR_LOCAL_CFG_TYPE_PTZ,                       //PTZ�Ƿ�����豸��������
    NET_DVR_LOCAL_CFG_MESSAGE_CALLBACK_V51,           //����V51�ص���ر�������,��Ӧ�ṹ��ΪNET_DVR_MESSAGE_CALLBACK_PARAM_V51 ��(����NET_DVR_SetDVRMessageCallBack_V51���ϰ汾��Ч)
    NET_SDK_LOCAL_CFG_CERTIFICATION,                  //���ú�֤����صĲ�������Ӧ�ṹ��ṹ��NET_DVR_LOCAL_CERTIFICATION
    NET_SDK_LOCAL_CFG_PORT_MULTIPLEX,                 //�˿ڸ��ã���Ӧ�ṹ��NET_DVR_LOCAL_PORT_MULTI_CFG
    NET_SDK_LOCAL_CFG_ASYNC,                 //�첽���ã���Ӧ�ṹ��NET_DVR_LOCAL_ASYNC_CFG
}NET_SDK_LOCAL_CFG_TYPE;

typedef enum tagNET_SDK_EXCEPTION_CALLBACK_TYPE
{
    NET_SDK_EXCEPTION_CALLBACK_BY_POOL = 0,         //ͨ���̳߳��쳣�ص�
    NET_SDK_EXCEPTION_CALLBACK_DIRECTLY = 1,        //ֱ���쳣�ص����ϲ�
}NET_SDK_EXCEPTION_CALLBACK_TYPE;

typedef struct tagNET_DVR_LOCAL_GENERAL_CFG
{
    BYTE     byExceptionCbDirectly;    //0-ͨ���̳߳��쳣�ص���1-ֱ���쳣�ص����ϲ�
    BYTE     byNotSplitRecordFile;     //�طź�Ԥ���б��浽����¼���ļ�����Ƭ 0-Ĭ����Ƭ��1-����Ƭ
    BYTE     byResumeUpgradeEnable;    //������������ʹ�ܣ�0-�رգ�Ĭ�ϣ���1-����
    BYTE     byAlarmJsonPictureSeparate;   //����JSON͸���������ݺ�ͼƬ�Ƿ���룬0-�����룬1-���루�������COMM_ISAPI_ALARM�ص����أ�
    BYTE     byRes[4];                 //����
    UINT64   i64FileSize;              //��λ��Byte
    DWORD    dwResumeUpgradeTimeout;   //��������������ʱʱ�䣬��λ����
	BYTE     byAlarmReconnectMode;     //0-�����߳�������Ĭ�ϣ� 1-�̳߳�����
    BYTE     byStdXmlBufferSize;       //����ISAPI͸�����ջ�������С��1-1M ����-Ĭ��
    BYTE     byMultiplexing;           //0-��ͨ���ӣ���TLS���ӣ��رն�·���ã�1-��ͨ���ӣ���TLS���ӣ�������·����
    BYTE     byRes1[233];              //Ԥ��
}NET_DVR_LOCAL_GENERAL_CFG, *LPNET_DVR_LOCAL_GENERAL_CFG;

typedef struct tagNET_DVR_LOCAL_ASYNC_CFG
{
    BOOL    bEnable;                //�첽����ʹ�ܣ�true-����
    BYTE    byRes[60];
}NET_DVR_LOCAL_ASYNC_CFG, *LPNET_DVR_LOCAL_ASYNC_CFG;

typedef struct tagNET_DVR_LOCAL_STREAM_CALLBACK_CFG
{
    BYTE     byPlayBackEndFlag;      //0-���ص��طŽ�����ǣ�1-�ص��طŽ������
    BYTE     byRes[255];      //����
}NET_DVR_LOCAL_STREAM_CALLBACK_CFG, *LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG;

typedef struct tagNET_DVR_LOCAL_LOG_CFG
{
    WORD    wSDKLogNum;      //sdk�ڸ���ģʽ�£���־���ɵĸ��� 0ΪĬ��ֵ��10����
    BYTE     byRes[254];      //����
}NET_DVR_LOCAL_LOG_CFG, *LPNET_DVR_LOCAL_LOG_CFG;

typedef int(CALLBACK * CHAR_ENCODE_CONVERT)(char * pInput, DWORD dwInputLen, DWORD dwInEncodeType, char *pOutput, DWORD dwOutputLen, DWORD dwOutEncodeType);

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;//˽��Э��ͨ��ģʽ�� //0-����ģʽ��Ĭ�ϣ����������е�SDK��¼Э��ͨ����1-��ȫģʽ��MD5��, ����RSA��MD5��¼������У��2-��ȫģʽ��RSA��RSA��¼������У��
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //Ѳ��ʱ��������λms  ��СֵΪ30s�����ֵ120s��Ϊ0ʱ����ʾ��Ĭ��ֵ(120s)
    DWORD   dwCheckOnlineNetFailMax;  //��������ԭ��ʧ�ܵ�����ۼӴ�����������ֵSDK�Żص��û��쳣��Ϊ0ʱ����ʾʹ��Ĭ��ֵ1
    BYTE    byRes[256];
}NET_DVR_LOCAL_CHECK_DEV,*LPNET_DVR_LOCAL_CHECK_DEV;

typedef struct tagNET_DVR_LOCAL_PTZ_CFG
{
    BYTE   byWithoutRecv;     //0-�����豸���أ�1-�������豸����
    BYTE   byRes[63];
}NET_DVR_LOCAL_PTZ_CFG, *LPNET_DVR_LOCAL_PTZ_CFG;

typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE    byVersion;                        //�汾��Ϣ
    BYTE    byRes[63];                        //����
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD    wLocalBindTcpMinPort;            //���ذ�Tcp��С�˿�
    WORD    wLocalBindTcpMaxPort;            //���ذ�Tcp���˿�
    BYTE    byRes[60];                        //����
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD    wLocalBindUdpMinPort;            //���ذ�Udp��С�˿�
    WORD    wLocalBindUdpMaxPort;            //���ذ�Udp���˿�
    BYTE    byRes[60];                        //����
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;


typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD    dwAlarmMaxBlockNum;        //����ģ���ڴ�������ϵͳ������ڴ�飨block��������ÿ��blockΪ64MB, ���������������ϵͳ���룬0��ʾ������
    DWORD    dwAlarmReleaseInterval;                //����ģ������ڴ��ͷŵļ������λ�룬Ϊ0��ʾ���ͷ�
    DWORD   dwObjectReleaseInterval;   //��������ģ������ڴ��ͷŵļ������λ�룬Ϊ0��ʾ���ͷ�
    BYTE    byRes[508];                //����
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD        dwPreviewTime;        //Ԥ��ģ�鳬ʱʱ��
    DWORD        dwAlarmTime;        //����ģ�鳬ʱʱ��
    DWORD        dwVodTime;            //�ط�ģ�鳬ʱʱ��
    DWORD        dwElse;                //����ģ��
    BYTE        byRes[512];                            //����
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

#define MAX_CERTIFICATE_ISSUER_LEN      64      //֤��䷢�߳���
#define MAX_CERTIFICATE_VALIDITY_LEN    128     //֤����Чʱ�䳤��
#define MAX_CERTIFICATE_SUBJECT_LEN     64      //֤������߳���
typedef struct  tagNET_DVR_CETTIFICATE_INFO
{
    DWORD dwSize;
    char szIssuer[MAX_CERTIFICATE_ISSUER_LEN];               //֤��䷢��
    char szSubject[MAX_CERTIFICATE_SUBJECT_LEN];             //֤�������
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byRes1[1024];
}NET_DVR_CETTIFICATE_INFO, *LPNET_DVR_CETTIFICATE_INFO;

typedef BOOL(CALLBACK *fnCertVerifyResultCallBack) (DWORD uiResult, LPNET_DVR_CETTIFICATE_INFO lpCertificateInfo, char *pUserData);

#define MAX_FILE_PATH_LEN       256     //�ļ�·������
typedef struct tagNET_DVR_LOCAL_CERTIFICATION
{
    char szLoadPath[MAX_FILE_PATH_LEN];
    fnCertVerifyResultCallBack fnCB;
    void* pUserData;
    BYTE byRes[64];
}NET_DVR_LOCAL_CERTIFICATION, *LPNET_DVR_LOCAL_CERTIFICATION;

typedef struct tagNET_DVR_LOCAL_PORT_MULTI_CFG
{
    BOOL    bEnable;                //�˿ڸ���ʹ�ܣ�true-����
    BYTE    byRes[60];
}NET_DVR_LOCAL_PORT_MULTI_CFG, *LPNET_DVR_LOCAL_PORT_MULTI_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD    dwMaxBuffRoomNum;    //rtp over udp���򿪱ٵ���󻺳���������0Ϊ��Ч��ʹ��Ĭ��ֵ20
    //һ�������������ڴ�Ϊ10K��һ�㣬����������Խ�࣬���������������Խǿ��������Խ�ã���ʱҲԽ��
    BYTE    byUseSort;    //�Ƿ���rtp over udp���� 0-������  1-����
    BYTE    byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;

typedef  struct  tagNET_DVR_OPTICAL_CHANNEL_BIND
{
    WORD wChannelIndex;    //��ں�(0-7)
    WORD wSubChannel;      //�����ͨ���ţ�ȡֵ��Χ����������ȡ
    BYTE  byBind;      //0-���󶨻�����󶨣�1-��
    BYTE  byRes[3];
}NET_DVR_OPTICAL_CHANNEL_BIND,*LPNET_DVR_OPTICAL_CHANNEL_BIND;

typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//��Ƶ��
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//��Ƶ��
    BYTE  byRes[16];           //����   
}NET_DVR_OPTICAL_CHANNEL_CFG,*LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//������ϵͳ��λ��
    BYTE  byChannel; //����ͨ����
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO,*LPNET_DVR_OPTICAL_INFO;

//��Ƶ�л�
typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //��Ƶ�Ƿ�����1-����0-��
    BYTE  byRes1[3];
    //���²�����byStatus == 1ʱ��Ч
    DWORD dwSubWinNum; //�������Ӵ��ں�
    DWORD dwSurChanNum;             /*���ͨ����  */   
    NET_DVR_IPADDR struIpaddr;            /*���ͨ����ַ */
    WORD   wPort;                          /*���ͨ���˿� */     
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

//�˿ھۺ�
#define MAX_ETHERNET_PORT_NUM       8//ÿ����·���˿���
typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j��ʾ����i���˿ڼ��뵽��j����·��j��ȡֵΪ1-8,j=0��ʾ�Ƴ�
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO,*LPNET_DVR_ETHERNET_CHANNEL_INFO;

//����
typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-���Թأ�1-���Կ�
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO,*LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //����IP��ַ���ˣ�0-��1-��
    BYTE byFilterType; //�������ͣ�0-���ã�1-����
    BYTE byRes[18];
    BYTE byIPAddr[1024];    //IP��ַ��Ϣ����ʽ192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-��1-��
    BYTE  byRes1[3];
    DWORD dwCoordinateX;    //ͼƬ��ʾ����X����
    DWORD dwCoordinateY;    //ͼƬ��ʾ����Y����
    WORD  wPicWidth; //ͼƬ��
    WORD  wPicHeight; //ͼƬ��
    BYTE  byLogoName[16];//Logo����
}NET_DVR_LOGO_OVERLAYCFG,*LPNET_DVR_LOGO_OVERLAYCFG;


typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // ���̺�
    BYTE                byDelAll;            // 0-ɾ��dwDiskNo  1-ɾ��ȫ����Ч����
    BYTE                 byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;


typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // ���̺�
    BYTE                 byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;

// �����ӻص�����
typedef enum
{
    NET_SDK_CALLBACK_TYPE_STATUS = 0,        // �ص�״ֵ̬
        NET_SDK_CALLBACK_TYPE_PROGRESS,            // �ص�����ֵ
        NET_SDK_CALLBACK_TYPE_DATA                // �ص���������
}NET_SDK_CALLBACK_TYPE;


// �ص�����ΪNET_SDK_CALLBACK_TYPE_STATUSʱ��״ֵ̬
typedef enum
{
    NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,        // �ɹ�
        NET_SDK_CALLBACK_STATUS_PROCESSING,            // ������
        NET_SDK_CALLBACK_STATUS_FAILED,                // ʧ��
        NET_SDK_CALLBACK_STATUS_EXCEPTION,            // �쳣
        NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,    //��IPC�����ļ����룩���Բ�ƥ��
        NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,    //��IPC�����ļ����룩�豸���Ͳ�ƥ��
        NET_DVR_CALLBACK_STATUS_SEND_WAIT,           // ���͵ȴ�
}NET_SDK_CALLBACK_STATUS_NORMAL;


//һ������ͨ��״̬
#define NET_SDK_OKC_STATUS_SUCCESS                1000  //һ�����óɹ�
#define NET_SDK_OKC_STATUS_FAILED                1002  //һ������ʧ��

//һ������CVR״̬
#define NET_SDK_OKC_STATUS_START_CONFIG            1003  //��ʼ����
#define NET_SDK_OKC_CHECK_HD                    1004  //������
#define NET_SDK_OKC_INIT_HD                        1005  //��ʼ������
#define NET_SDK_OKC_CREATE_RAID_OR_SINGLE_DISK    1006  //�������л��ߵ���ģʽ
#define NET_SDK_OKC_INIT_CVR_SERVICE            1007  //��ʼ��CVR����
#define NET_SDK_OKC_CREATE_RECORD_VOLUME        1008  //����¼���

//����Ϊһ������ʧ�ܵ�״̬�롪��part1
#define NET_SDK_OKC_ERR_LOAD_CONF_FAILED              1009 //���������ļ�ʧ��
#define NET_SDK_OKC_ERR_NOT_SUPPORT_RAID_LEVLE        1010 //��֧�ִ������͵�raid 
#define NET_SDK_OKC_ERR_CONFIGURATION_CONFLICT          1011 //ϵͳ�Ѿ�����raid��洢��
#define NET_SDK_OKC_ERR_GET_DISK_INFO_FAILED          1012 //��ȡ������Ϣʧ��
#define NET_SDK_OKC_ERR_CHECK_DISK_FAILED             1013 //������ʧ��
#define NET_SDK_OKC_ERR_INIT_DISK_FAILED              1014 //��ʼ������ʧ��
#define NET_SDK_OKC_ERR_DISK_CAPACITY_SMALL           1015 //��������������
#define NET_SDK_OKC_ERR_BOTH_SV_NS                    1016 //ͬʱ����SV�̺�NS��
#define NET_SDK_OKC_ERR_CREATE_RAID_FAILED            1017 //����raidʧ��
#define NET_SDK_OKC_ERR_GET_RAID_FAILED               1018 //��ȡraidʧ��
#define NET_SDK_OKC_ERR_CREATE_SPARE_FAILED           1019 //�����ȱ���ʧ��
#define NET_SDK_OKC_ERR_CREATE_STORAGE_POOL_FAILED    1020 //�����洢��ʧ��
#define NET_SDK_OKC_ERR_GET_POOL_INFO_FAILED          1021 //��ȡ�洢����Ϣʧ��
#define NET_SDK_OKC_ERR_CREATE_LUN_FAILED             1022 //����lun��ʧ��
#define NET_SDK_OKC_ERR_GET_LUN_INFO_FAILED           1023 //��ȡlun��Ϣʧ��
#define NET_SDK_OKC_ERR_CREATE_BACKUP_FAILED          1024 //����Ԥ����ʧ��
#define NET_SDK_OKC_ERR_GET_BACKUP_FAILED                1025 //��ȡԤ����ʧ��
#define NET_SDK_OKC_ERR_CREATE_PRIVATE_LUN_FAILED        1026 //����˽�о�ʧ��
#define NET_SDK_OKC_ERR_CREATE_RV_FAILED              1027 //����¼���ʧ��
#define NET_SDK_OKC_ERR_CREATE_ARCH_RV_FAILED         1028 //�����浵��ʧ��
#define NET_SDK_OKC_ERR_START_CVR_SERVICE_FAILED      1029 //����CVR����ʧ��

//һ������SAN״̬
#define NET_SDK_OKC_CREATING_ARRAY                    1030  //�������н׶�
#define NET_SDK_OKC_CREATING_STORAGE_POOL            1031  //�����洢�ؽ׶�
#define NET_SDK_OKC_CREATING_LUN_VOL                1032  //�����߼���׶�
#define NET_SDK_OKC_CREATING_ISCSI                    1033  //����ISCSI�׶�
#define NET_SDK_OKC_ERR_HOT_SPARE_CONFICT            1034  //�Ѵ����ȱ���
#define NET_SDK_OKC_ERR_STORAGE_POOL_CONFICT        1035  //�Ѵ��ڴ洢��
#define NET_SDK_OKC_ERR_RAID_CONFLICT               1036 //ϵͳ�Ѿ��������� 
#define NET_SDK_OKC_ERR_OPEN_ISCSI_FAILED           1037 //����ISCSIʧ��
#define NET_SDK_OKC_ERR_DEVICE_NOSUPPORT_SAN        1038 //�豸��֧��san

//����Ϊһ������ʧ�ܵ�״̬�롪��part2
#define NET_SDK_OKC_ERR_SAPRE_NUM_EXCEED            1101    //�ȱ��̸�������
#define NET_SDK_OKC_ERR_CREATE_PIC_VOLUME_FAILED    1102    //����ͼƬ��ʧ��

typedef enum
{
    NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000,    // �ɹ���ȡ�����ݣ��ͻ��˴����걾�����ݺ���Ҫ�ٴε���NET_DVR_RemoteConfigGetNext��ȡ��һ������
        NET_SDK_GET_NETX_STATUS_NEED_WAIT,        // ��ȴ��豸�������ݣ���������NET_DVR_RemoteConfigGetNext����
        NET_SDK_GET_NEXT_STATUS_FINISH,            // ����ȫ��ȡ�꣬��ʱ�ͻ��˿ɵ���NET_DVR_StopRemoteConfig����������
        NET_SDK_GET_NEXT_STATUS_FAILED,            // �����쳣���ͻ��˿ɵ���NET_DVR_StopRemoteConfig����������
}NET_SDK_GET_NEXT_STATUS;

// �û�����SendwithRecv�ӿ�ʱ���ӿڷ��ص�״̬
typedef enum
{
    NET_SDK_CONFIG_STATUS_SUCCESS = 1000,    // �ɹ���ȡ�����ݣ��ͻ��˴����걾�����ݺ���Ҫ�ٴε���NET_DVR_SendWithRecvRemoteConfig��ȡ��һ������
    NET_SDK_CONFIG_STATUS_NEEDWAIT,          // ���õȴ����ͻ��˿�����NET_DVR_SendWithRecvRemoteConfig
    NET_SDK_CONFIG_STATUS_FINISH,            // ����ȫ��ȡ�꣬��ʱ�ͻ��˿ɵ���NET_DVR_StopRemoteConfig����
    NET_SDK_CONFIG_STATUS_FAILED,            // ����ʧ�ܣ��ͻ��˿�����NET_DVR_SendWithRecvRemoteConfig�·���һ��
    NET_SDK_CONFIG_STATUS_EXCEPTION,         // �����쳣����ʱ�ͻ��˿ɵ���NET_DVR_StopRemoteConfig����
}NET_SDK_SENDWITHRECV_STATUS;

//���������ļ�������
typedef enum tagNET_SDK_IPC_CFG_FILE_ERR_CODE
{
    NET_SDK_IPC_CFG_FILE_NO_ERR = 0,                                /* û���� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_INVALID = 1,       /* ͨ��ID�Ƿ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_CHANNEL_DUPLICATE,         /* ͨ��ID�ظ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_INVALID,              /* ͨ��IP�������Ƿ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_DUPLICATE,           /* ͨ��IP�������ظ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_IP_CONFLICT_WITH_LOCAL, /* ͨ��IP�뱾��IP��ͻ */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PROTOCOL_INVALID,         /* Э����� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PORT_INVALID,             /* ����˿ڴ��� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_DEVICE_CHANNEL_ERR,   /* �豸ͨ���Ŵ��� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_USER_NAME_ERR,       /* �û������Ƿ��ַ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_PASSWD_ERR,             /* ���뺬�Ƿ��ַ� */
        NET_SDK_IPC_CFG_FILE_ERR_CODE_TRANSPORT_PROTOCOL_INVALID /*����Э�����*/
}NET_SDK_IPC_CFG_FILE_ERR_CODE;

//IPC����������
typedef enum
{
    NET_SDK_UPGRADE_IPC_INVALID = 0,                //��Чͨ����δѡ���ͨ������
        NET_SDK_UPGRADE_IPC_SUCCESS,                    //�����ɹ�
        NET_SDK_UPGRADE_IPC_OFFLINE,                    //IPC������
        NET_SDK_UPGRADE_IPC_NOT_SUPPORT,                //IPC��֧����������
        NET_SDK_UPGRADE_IPC_LANGUAGE_MISMATCH,            //���Բ�ƥ��
        NET_SDK_UPGRADE_IPC_WRITE_FLASH_FAILED,            //дflshʧ��
        NET_SDK_UPGRADE_IPC_OTHER_ERROR                    //��������
}NET_SDK_UPGRADE_IPC_ERR_CODE;

typedef enum
{
    NET_SDK_REMOTE_CONFIG_STATUS_SUCCESS = 1001,//¼������һ�������ɹ�
        NET_SDK_REMOTE_CONFIG_STATUS_FAILED,    //¼������һ������ʧ��
        NET_SDK_REMOTE_CONFIG_STATUS_PROCESSING    //¼������һ���������ڻ�ȡ
}NET_SDK_REMOTE_CONFIG_STATUS;

#define MAX_CODE_CARD_SUPPORTDISPNUMS 8//ÿ�����뿨���֧�ֵ���ʾͨ����
#define MAX_SUPPORT_RES 32

typedef enum _BOARD_TYPE
{
    DS4004HC_BOARD        =2,  //4004HC
        DS4008HC_BOARD        =3,  //4008HC
        DS4016HC_BOARD        =4,  //4016HC
        DS4001HF_BOARD        =5,  //4001HF
        DS4004HF_BOARD        =6,  //4004HF
        DS4002MD_BOARD        =7,  //4002MD
        DS4004MD_BOARD        =8,  //4004MD
        DS4016HCS_BOARD        =9,  //4016HCS
        DS4004HC_PLUS_BOARD    =13, //4004HC+
        DS4008HC_PLUS_BOARD    =14, //4008HC+
        DS4016HC_PLUS_BOARD    =15, //4016HC+
        DS4008HF_BOARD        =16, //4008HF
        DS4008MD_BOARD        =17, //4008MD
        DS4008HS_BOARD        =18, //4008HS
        DS4016HS_BOARD        =19, //4016HS
        
        DS4108HCV_BOARD        =20, //4108HCV
        DS4116HCV_BOARD        =21, //4116HCV
        DS5016HC_BOARD        =22, //5016HC
        
        DS4208HFV_BOARD        =23, //4208HFV
        DS4216HC_BOARD        =24, //4216HC
        DS4216HFV_BOARD        =25, //4216HFV
        
        DS5008HF_BOARD        =26, //5008HF
        DS5116HF_BOARD        =27, //5116HF
        
        DS5216HC_BOARD        =28, //5216HC
        DS5208HF_BOARD        =29, //5208HF
        DS5216HF_BOARD        =30, //5216HF
        
        DS4101HD_BOARD        =31, //4101HD
        DS4102HD_BOARD        =32, //4102HD
        DS4104HD_BOARD        =33, //4104HD
        
        DS4002MD_PLUS_BOARD =34, //4002MD+  
        DS4004MD_PLUS_BOARD =35, //4004MD+
        
        DS4204HFV_BOARD        =36, //4204HFV
        DS4308HCV_BOARD        =37, //4308HCV
        DS4308HFV_BOARD        =38, //4308HFV
        DS4316HCV_BOARD        =39, //4316HCV
        DS4316HFV_BOARD        =40, //4316HFV
        DS4304HD_BOARD        =41, //4304HD
        DS4304HFH_BOARD     =42, //4304HFH
        DS4304HFV_BOARD     =43, //4304HFV
        DS4302HFH_BOARD     =44, //4302HFH
        DS5316HF_BOARD      =45, //5316HF
        DS4308HW_BOARD      =46, //4308HW
        DS4316HW_BOARD      =47, //4316HW
        DS4308MD_BOARD      =48, //4308MD
        UNKNOWN_BOARD_TYPE  =0xffffffff,
}BOARD_TYPE;

typedef struct tagNET_DVR_CODECARD_ABILITY /*������뿨������*/
{
    BYTE byCardType;      //���뿨����(��BOARD_TYPE�е�ö��)
    BYTE byCodeNums;      //����ͨ���� 
    BYTE byDispNums;      //��ʾͨ���� 
    BYTE byCodeStartIdx;     //�׸�����ͨ�������б���ͨ���е����� 
    BYTE byDispStartIdx;     //�׸���ʾͨ����������ʾͨ���е�����
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//֧�ֵķֱ���
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //֧�ֵ����ģʽ(��HD_DISPLAY_FORMAT�е�ö��) 
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //֧�ֵĴ���ģʽ(����1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY,*LPNET_DVR_CODECARD_ABILITY;

#define        MAX_CODE_CARD_NUM            8   //��������뿨��
typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;      /* �ṹ���С */
    BYTE byCardNums;      /* ���뿨�� */
    BYTE byStartChan;     /* ��ʼͨ���� */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;        /*��ʾͨ�����ͣ�0-BNC��1-VGA��2-HDMI��3-DVI*/ //�˲���ֻ�ܻ�ȡ
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL��0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //�ֱ���
    DWORD  dwWindowMode;        /*����ģʽ��֧��ģʽ����������ȡ*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG,*LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO 
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //��ʾͨ����
    DWORD  dwCodeChan; //����ͨ����
    DWORD  dwWinNum;   //���ںţ���1��
    BYTE   byEnableAudio; //������Ƶ��0-�أ�1-��
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO,*LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//��ʾͨ����
    DWORD dwWinNum;     //���ںţ���1��ʼ
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO,*LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;         //�ṹ��С
    DWORD  dwCodeChan;      /*����ͨ����*/
    BYTE   byDisplay;              /*�Ƿ������0-��1-��*/
    BYTE   byAudio;            /*��Ƶ�Ƿ���,0-��1-��*/   
    BYTE   byRes[30];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_WINDOW_STATUS,*LPNET_DVR_WINDOW_STATUS;

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD     dwSize;              //�ṹ���С
    BYTE     byPercentage;        //�ٷֱȣ�ȡֵ��Χ[0,100]
    BYTE      byRes[31];          //����
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD             dwSize;             //�ṹ���С
    NET_DVR_STREAM_INFO struStreasmInfo;     //��ID
    DWORD              dwBeginTime;    //¼���ܵĿ�ʼʱ��
    DWORD             dwEndTime;        //¼���ܵĽ���ʱ��
    BYTE              byRes[32];       //����
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO        struStreamInfo; 
    DWORD                    dwCmdType;                         //�ⲿ�������� 
    DWORD                    dwRecordTimeLen;                //¼�����ʱ�䣬��λ����
    BYTE                    byEventID[MAX_EVENTID_LEN];        //�¼�ID����Ϊ������Ϣ
    DWORD                    dwLockDuration;                //��������ʱ�䣬��λ���룬0xffffffff- ����������0- ����
    BYTE                    byBackUp;                       //�Ƿ�浵��0-���浵��1-�浵
    BYTE                    byPreRecord;                    //�Ƿ�Ԥ¼��0-��Ԥ¼��1-Ԥ¼
    BYTE                    byRes[122];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE                byFileName[NAME_LEN];     // ¼���ļ�������Э��ֻ��32���ļ���
    DWORD                dwLockDuration;            // ��������ʱ��,��λ�룬0xffffffff��ʾ��������
    BYTE                byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD                    dwSize;
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwStreamType; //�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3���������Զ�������������ͨ��GET /ISAPI/Streaming/channels/<ID>/customStream��ȡ��ǰͨ���Ѿ���ӵ������Զ�������ID���Զ�������Ϊ6~10��������ֵ����6~10��
    BYTE                    byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;


typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD                            dwSize;
    DWORD                            dwStreamType;        //�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    NET_DVR_COMPRESSION_INFO_V30    struStreamPara;        //����ѹ������
    DWORD    dwResolution;        //���ֱ�������С��255ʱ��byResolution����һ�£�����255ʱ�Ը��ֶη�������ֵ�жϡ�
    BYTE byRes[76];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0-�ź�������,1-Ӳ����,2-�źŶ�ʧ,3���ƶ����,4��Ӳ��δ��ʽ��,5-��дӲ�̳���,6-�ڵ�����,7-��ʽ��ƥ��, 8-�Ƿ�����, 9-��Ƶ�ź��쳣��10-¼���쳣 11- ���ܳ����仯  12-�����쳣 */
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;    /*��λ,��0λ��Ӧ��0������˿�,dwAlarmTypeΪ0ʱ��Ҫ����*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*��λ,��0λ��Ӧ��0������˿�, */
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*��λ,��0λ��Ӧ��0��ͨ��*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; // ID��Ϣ
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*��λ,0x2��ʾ��1ͨ������1λ��Ӧ��1��ͨ��(��ͨ��1��ʼ)��dwAlarmTypeΪ2��3, 6��9��10ʱ��Ҫ����, */
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*��λ,��0λ��Ӧ��0��Ӳ��,dwAlarmTypeΪ1,4,5ʱ��Ҫ����*/
            BYTE byDeviceID[NAME_LEN]; /*�豸��ID��*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;

typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    DWORD             dwPackageInterval;    // ���ʱ���� ��ʱ�䵥λ������
    BYTE              byRes[32];               // ����
}NET_DVR_RECORD_PACK,*LPNET_DVR_RECORD_PACK;

#define NET_DVR_FIND_NAS_DIRECTORY     6161        //����NASĿ¼
#define NET_DVR_NAS_FINDING       0   //���ڲ���
#define NET_DVR_NAS_RECV          1   //��������
#define NET_DVR_NAS_OVER          2   //���ҽ���
#define NET_DVR_NAS_EXCEPTION     3   //�����쳣
typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR              struIP;         // IP��ַ
    WORD              wPort;      // IP�˿�
    BYTE                byRes[10];  // �����ֽ�
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;


typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // ���ص��ļ�Ŀ¼
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE              byWD1Enable;         //WD1ʹ�ܿ��� 0 �ر� 1 ����    
    BYTE                 byRes[31];      //����
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;

typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE                byEnableFTP;            /*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE                byProtocolType;             /*Э������ 0-FTP��1-SFTP*/
    WORD                wFTPPort;                /*�˿�*/
    union 
    {
        struct
        {
            BYTE            szDomain[64];        //��������ַ������ʹIPv4 IPv6��������
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP��ַ:IPv4 IPv6��ַ, 144�ֽ�*/
        }struAddrIP;
    }unionServer;  //ʹ��������ṹ����ֹ����IP��ַ�������������
    BYTE                szUserName[32];            /*�û���*/
    BYTE                szPassWORD[16];            /*����*/
    BYTE                szTopCustomDir[64];        /*�Զ���һ��Ŀ¼*/
    BYTE                szSubCustomDir[64];        /*�Զ������Ŀ¼*/
    BYTE                byDirLevel;                /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,    1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    BYTE                 byTopDirMode;            /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��
                                                0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x6-ʹ���Զ��� ,0x7=Υ������,0x8=����,0x9=�ص�*/
    BYTE                 bySubDirMode;           /*����Ŀ¼��0x1=ʹ��ͨ����,0x2=ʹ��ͨ���� 0x3=ʹ��ʱ��(������),
                                                0x4=ʹ�ó�����,0x5-ʹ���Զ���, 0x6=Υ������,0x7=����,0x8=�ص�,0x9 = ��λ���*/
    BYTE                byType;                    /* 0-����������1-��������*/
    BYTE                byEnableAnony;          /*�������� 0-�� 1��*/
    BYTE                byAddresType;           /*0 ʹ��IPV4��IPV6  1- ʹ������*/
    BYTE                byFTPPicType;           //0-������1-ͣ����ץ��ͼƬ��������
    BYTE                 byPicArchivingInterval; //ͼƬ�鵵���[1~30],0��ʾ�ر�
    NET_DVR_PICTURE_NAME_EX     struPicNameRule;   /* ͼƬ��������:     
    byFTPPicType ==1��ʱ��,�������ڵ�����������ͣ����ץ��ͼƬ��������*/
    BYTE                byPicNameRuleType;      //ͼƬ����������ͣ�0~Ĭ�����ͣ�1~ͼƬǰ׺������(����struPicNameRule�е�byPicNamePrefix�ֶ�)
    BYTE                 byRes[203];             /*����*/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE    byType;  // 0-����������1-��������
    BYTE    byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

//FTP���������Բ����ṹ��
typedef struct 
{
    DWORD     dwSize;
    BYTE    byEnableFTP;            /*�Ƿ�����ftp�ϴ����ܣ�0-��1-��*/
    BYTE    byProtocolType;             /*Э������ 0-FTP��1-SFTP*/
    WORD    wFTPPort;                /*�˿�*/
    union 
    {
        BYTE    byRes[144];
        struct
        {
            BYTE    szDomain[MAX_DOMAIN_NAME];        //��������ַ������ʹIPv4 IPv6��������
            BYTE    byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP��ַ:IPv4 IPv6��ַ, 144�ֽ�*/
        }struAddrIP;
    }unionServer;  //ʹ��������ṹ����ֹ����IP��ַ�������������
    
    BYTE    szUserName[NAME_LEN];            /*�û���*/
    BYTE    szPassWORD[PASSWD_LEN];            /*����*/
    BYTE    szTopCustomDir[MAX_CUSTOM_DIR];        /*�Զ���һ��Ŀ¼*/
    BYTE    szSubCustomDir[MAX_CUSTOM_DIR];        /*�Զ������Ŀ¼*/
    BYTE    byDirLevel;                /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,    1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
                                    BYTE    byTopDirMode;            /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ��
                                                                    0x4=ʹ�ü���,0x5=ʹ��ʱ��(����),0x6-ʹ���Զ��� ,0x7=Υ������,
                                    0x8=����,0x9=�ص�*/
                                    BYTE    bySubDirMode;           /*����Ŀ¼��0x1=ʹ��ͨ����,0x2=ʹ��ͨ���� 0x3=ʹ��ʱ��(������),
                                                                    0x4=ʹ�ó�����,0x5-ʹ���Զ���, 0x6=Υ������,0x7=����,0x8=�ص�,
                                    0x9 = ��λ���*/
                                    BYTE    byType;                    /* 0-����������1-��������*/
                                    BYTE    byEnableAnony;          /*�������� 0-�� 1��*/
                                    BYTE    byAddresType;           /*0 ʹ��IPV4��IPV6  1- ʹ������*/
                                    
                                    BYTE    byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

#define NET_SDK_ACCESS_KEY_LEN 64   //�������볤��
#define NET_SDK_SECRET_KEY_LEN 64  //�������볤��

//���������Խṹ��
typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD    dwSize;
    union 
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA    struNtpPara;                    /*NTP���������Բ���80�ֽ�*/           
            BYTE    byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40    struNasPara;   /*NAS���������Բ���480�ֽ�*/         
            BYTE    byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA    struFtpPara;   /*FTP���������Բ���528�ֽ�*/          
            BYTE    byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30    struEmailPara;            /*Email���������Բ���660�ֽ�*/        
            BYTE    byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR    struIp;                            /*IP��ͻ���Բ���24�ֽ�*/
            BYTE    byRes1[716];
        }struIpPara;
        struct  
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //�˿ں�
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //�û���
            char  szPassword[CLOUD_PASSWD_LEN/*48*/];     // ����
            NET_DVR_POOLPARAM  struPoolInfo[16];// ����0��ʾ����ͼƬ���ݳأ�����1��ʾΥ��ͼƬ���ݳأ�����2��ʾ����������ݳأ�IPC/D��
            BYTE   byProtocolType;//�ƴ洢Э��汾��0- 1.0�汾��1- 2.0�汾
            BYTE   byRes3[3];
            char  szAccessKey[NET_SDK_ACCESS_KEY_LEN/*64*/]; //��������
            char  szSecretKey[NET_SDK_SECRET_KEY_LEN/*64*/]; //��������
            BYTE byRes1[354];
        }struCloudStoragePara;
        struct 
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];
            BYTE byRes1[708];
        }struPhoneNumPara;//���Ų���
    }unionServerPara; 
    BYTE byRes2[800]; 
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO  //��ȡGOP������Ϣ�ṹ��,��������ʱʹ��
{
    DWORD      dwSize;          //�ṹ���С
    LONG      lChannel;       //ͨ����
    NET_DVR_TIME_EX   struStartTime;    //��ʼʱ��
    NET_DVR_TIME_EX   struEndTime;     //����ʱ��
    BYTE                 byRes[256];      // �����ֽ�  
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;    //Gop��Ϣʱ���
    DWORD         dwDuration;    //��Ϣ����ʱ��
    DWORD         dwDataSize;     //ָ��pBuf��С
    BYTE          byRes[128];
    char* pBuf;//Gop��Ϣ��
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK   //����������Ϣ����
{
    DWORD       dwSize;                 //�ṹ���С
    NET_DVR_TIME_V30  struTime;         //��ʼʱ��,����������Ϊ����Ԫ����ʱ����ʾ�Ŀ�ʼʱ�䣬��Ϊ����ͼʱ����ʾ����ͼƬʱ��
    DWORD       dwDuration;             //��Ϣ����ʱ�䣬������������Ϊ����Ԫ����ʱ��Ч
    DWORD       dwMetaDataSize;         //����Դ�Ĵ�С
    DWORD       dwPicDataSize;          //ͼƬ���ݴ�С
    char*        pMetaDataBuffer;        //����Ԫ���ݻ�����
    char*       pPicDataBuf;            //ͼƬ������
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;    
    BYTE   byRes1[3];
    DWORD  dwWallNum;//����ǽ�����
    //������Ϊ��׼�������������128��128������Ⱥ͸߶�ֵ�������ã���Ϊ��׼ֵ
    NET_DVR_RECTCFG struRectCfg;
    BYTE    byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

/*������Ϣ*/
typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//���ں�
    DWORD dwLayerIndex;//�������Ӧ��ͼ���
    NET_DVR_RECTCFG struWinPosition;//Ŀ�Ĵ���(�����ʾǽ)
    DWORD dwDeviceIndex;//�ֲ�ʽ�����������豸���
    WORD wInputIndex;//�����ź�Դ
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD    dwSize;
    BYTE    byWallNo;    //����ǽ��ţ���1��ʼ
    BYTE    bySceneNo;    //�������
    BYTE    byRes1[2];
    DWORD    dwDeviceID;    //�ֲ�ʽ���豸ID
    DWORD    dwWindowNo;    //�������/�ź�Դ���
    BYTE    byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //ʹ��͸���ȣ�0-�أ���0-��    
    BYTE  byWinMode;//���ڷ���ģʽ����������ȡ
    BYTE  byEnableSpartan;//����ʹ�ܣ�0-�أ�1-��
    BYTE  byDecResource;  //Ϊ���ڷ���Ľ�����Դ��1-D1,2-720P,3-1080P
    BYTE  byWndShowMode; //������ʾģʽ��0-���ֶβ��ã�1-�Ӵ���ģʽ��2-�Ӵ���ȫ��ģʽ
    BYTE    byEnabledFeature; //�Ƿ����ó�����д��0-�����ã�!0-����
    BYTE    byFeatureMode; //��дģʽ�����ó�����дʱ��Ч��0-��Ч��1-��1+5��ģʽ
    BYTE  byRes1;
    DWORD dwAmplifyingSubWndNo; //ȫ���Ӵ��ںţ�1�ֽ�ǽ��+1�ֽ��Ӵ��ں�+2�ֽڴ��ںţ�
                                                                  //��byWndShowModeΪ2ʱ��Ч����ʾ��ǰȫ����ʾ���Ӵ���
    BYTE  byWndTopKeep; //�����ö����֣�0-�����֣�1-����
    BYTE  byWndOpenKeep; //���ڴ򿪱��֣�0-�����֣�1-����
    BYTE  byRes[22];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD    dwSize;
    BYTE    sSceneName[NAME_LEN];    //��������
    BYTE    byEnable;                //�����Ƿ���Ч��0-��Ч��1-��Ч
    BYTE    bySceneIndex;            //�����ţ�ֻ�ܻ�ȡ����ȡ���г���ʱʹ�øò���
    BYTE    byRes [78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //���ں�
    DWORD dwSubWinNum;//�Ӵ��ں�
    DWORD dwWallNo; //ǽ��
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO,*LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize ;
    BYTE  byDecodeStatus; /*��ǰ����״̬:0:δ����,1 :������*/
    BYTE  byStreamType;    /*��������*/
    BYTE  byPacketType;    /*�����ʽ*/
    BYTE  byFpsDecV; /*��Ƶ����֡��*/
    BYTE  byFpsDecA; /*��Ƶ����֡��*/
    BYTE  byRes1[7];    
    DWORD dwDecodedV; /*�������Ƶ֡*/
    DWORD dwDecodedA; /*�������Ƶ֡*/
    WORD  wImgW; /*��ǰ����Դ��ͼ���С*/
    WORD  wImgH; 
    BYTE  byStreamMode ; //����Դ(�˲�������Ƶ�ۺ�ƽ̨��Ч)��1-���磬2-�ۺ�ƽ̨�ڲ�������ϵͳ��3-��Ļ��������0xff-��Ч
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //���ں�
    DWORD dwSubWinIndex;//�Ӵ��ں�
    BYTE  byType ;//��Դ���ͣ�1-���룬2-����
    BYTE  byWallNo ; //ǽ��
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize ;
    BYTE   sAddress[MAX_DOMAIN_NAME];//ip��ַ����������
    WORD   wDVRPort;                 /* �˿ں� */
    WORD   wChannel;                /* ͨ���� */
    BYTE   sUserName[NAME_LEN];    /* ���������½�ʺ� */
    BYTE   sPassword[PASSWD_LEN];    /* ����������� */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO,*LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //�ֱ���    
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat; //��Ƶ��ʽ����VIDEO_STANDARD
    BYTE  byDisplayMode;/*�������ģʽ,1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��0xff-��Ч*/
    BYTE  byBackgroundColor; //����ɫ��0-��Ч����֧�ֱ���ɫ��1-�죬2-�̣�3-����4-�ƣ�5-�ϣ�6-�࣬7-�ڣ�8-�ף�0xff-�Զ���
    BYTE  byUseEDIDResolution; //�Ƿ�ʹ��EDID�ֱ��ʣ�0-��ʹ�ã�1-ʹ��
    WORD  wLEDWidth;     //LED������ֱ��ʿ�
    WORD  wLEDHeight;    //LED������ֱ��ʸ�
    NET_DVR_RGB_COLOR struBackColor;//����ɫ��byBackgroundColorΪ0xffʱ��Ч
    BYTE    byLinkStatus;//���������״̬��0-��Ч,1-������ʾ��,2-δ������ʾ��
    BYTE    byRes2[51];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

#define     MAX_UNITEDMATRIX_NUM        8  //�����������Ƶ�ۺ�ƽ̨����

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    //ƽ̨�ţ�0��ʾ�޴�ƽ̨
    DWORD        dwSequence;
    BYTE        sAddress[MAX_DOMAIN_NAME];//ip��ַ����������
    WORD        wSubMatrixPort;        /*��ϵͳ�˿ں�*/
    BYTE        byRes1[6];   
    BYTE        sUserName[NAME_LEN];    /*�û���*/
    BYTE        sPassword[PASSWD_LEN];    /*���� */   
    BYTE        byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO,*LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //��Ƶ�ۺ�ƽ̨��Ϣ
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM]; 
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO,*LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_SUBSTREAM_SWITCH_CFG
{
    BYTE  byAutoSwitchEnable; //�������Զ��л���0 - �����ã�1 - ����
    BYTE     byRes1[3];
    WORD  wSubWndWidth; //�Ӵ��ڿ���趨ֵ��byAutoSwitchEnableΪ1ʱ��Ч
    WORD  wSubWndHeight; //�Ӵ��ڸ߶��趨ֵ��byAutoSwitchEnableΪ1ʱ��Ч
}NET_DVR_SUBSTREAM_SWITCH_CFG, *LPNET_DVR_SUBSTREAM_SWITCH_CFG;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD  dwSize;
    BYTE  byTransparency;//͸����,0-100,0Ϊ��͸��
    BYTE  byWinStaticMode; //���ڽ���ֹͣ��ʾģʽ��1-����(֮ǰ���������Ǻ�ɫ)��2-��ʾ���һ֡ͼ��
    BYTE  byStreamFailedMode; //ȡ��ʧ����ʾģʽ��1-����������Ƶ�źš���2-��ʾ���һ֡ͼ��3-�����쳣��4-����
    BYTE    byEnabledOverlayLogo; //������������ʱ�Ƿ����LOGO����ʾ�û���0-�����ӣ�!0-����
    NET_DVR_SUBSTREAM_SWITCH_CFG  struSubStreamSwitch; //�������л�
    BYTE  byLEDShowMode; //LED������ʾģʽ��0-��ͨģʽ��1-ƽ��ģʽ
    BYTE  byLowLatencyMode; //����ʱģʽ��0-��ͨģʽ��1-����ʱģʽ
    BYTE  byRes[50];
}NET_DVR_WALL_CFG, *LPNET_DVR_WALL_CFG;

typedef    struct tagNET_DVR_LEDDISPLAYINFO
{
    DWORD            dwSize;
    BYTE              byAddressType;   //0-ʵ��ipv4 ipv6��ַ 1-����
    BYTE        byRes1[3];
    // ����unionServer��ʹ��ʵ�ʵ�ַ��������
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];//��������ַ������ 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP��ַ*/        //IPv4 IPv6��ַ, 144�ֽ�
        } struAddrIP;
    }unionServer;  //ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ�������� 64    
    char        szDisplayInfo[MAX_LEDDISPLAYINFO_LEN/*1024*/];
    BYTE        byRes[128];
}NET_DVR_LEDDISPLAYINFO,*LPNET_DVR_LEDDISPLAYINFO;


typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD dwSize;
    BYTE  byLowLightLimt; /* ���նȵ��ӿ���: 0-�أ�1-�� */
    BYTE  byLowLightLimtLevel; 
    /*���0-�أ�1-������*2��2-������*3��3-������*4��4-������*6��5-������*8��6-������*12��7-������*16��
    8-������*24��9-������*32��10-������*48��11-������*64��12-������*96��13-������*128��14-������*256��
    15-������*512, 16-������*1.25, 17-������*1.5 */
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD dwSize;
    BYTE  byFocusMode;  /* �۽�ģʽ��0-�Զ���1-�ֶ���2-���Զ� */
    BYTE  byAutoFocusMode; /* �Զ��۽�ģʽ��0-�أ�1-ģʽA��2-ģʽB��3-ģʽAB��4-ģʽC �Զ��۽�ģʽ����Ҫ�ھ۽�ģʽΪ�Զ�ʱ����ʾ*/
    WORD  wMinFocusDistance; /* ��С�۽����룬��λCM,  0-�Զ���0xffff-����Զ */
    BYTE  byZoomSpeedLevel;  /* �䱶�ٶȣ�Ϊʵ��ȡֵ��1-3 */
    BYTE  byFocusSpeedLevel; /* �۽��ٶȣ�Ϊʵ��ȡֵ��1-3 */
    BYTE  byOpticalZoom;        /* ��ѧ�䱶��0-255 */
    BYTE  byDigtitalZoom;        /* ���ֱ䱶��0-255 */
    float fOpticalZoomLevel; /* ��ѧ�䱶(����ֵ) [1,32], ��С���0.5 ���ڲ��豸������ʱ��*1000 */
    DWORD dwFocusPos;/* dwFocusPos ��focusֵ���۽�ֵ������ΧΪ[0x1000,0xC000]�����ֵ��sony����ֵ��ʹ�����ֵ��Ϊ�˶���ͳһ����֤��ͬ�ľ�ͷ����focusֵ��ת���������Χ�� (�ֶ��۽�ģʽ����Ӧ��)*/
    BYTE   byFocusDefinitionDisplay;// �۽���������ʾ��0~����ʾ��1~��ʾ, ����������������ʾ��ǰ��ͷĿ���������ֵ�����ڰ����ͻ�����ʹ���ץ���ܹ��ﵽ��������Ч������������Խ�������Խ�����������ȷ�ΧΪ��0~100.0000
    BYTE   byFocusSensitivity; //�۽������ȣ���Χ[0,2]���۽�ģʽΪ�Զ������Զ�ʱ��Ч
    BYTE   byRes1[2];
    DWORD  dwRelativeFocusPos;//���focusֵ�����16λ��ʾ�۽�ֵ��0~4000����16λ����ǰ�۽�ֵ��ȡʱ���¶�ֵ
    BYTE   byRes[48];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;  /* �����������-����ģʽ��0-�Զ���1-�ֶ� */
    BYTE  byIrBrightness;    /* �����������-�������ȣ�0-100 */
    BYTE  byIrSensitivity;    /* �����������-����������ȣ�0-100 */
    BYTE  byIrTrigMode; /* ����ģʽ 0-��о������1-�������� �Զ�ģʽ����Ч*/
    BYTE  byIrBrightnessLimit;/* �������� �����ֵΪ80����ʾ�������ǵ�ǰ����Ƶ�����Ϊԭ�ȸ����Զ����Լ����������ֵ��80% �Զ�ģʽ����Ч*/   
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int   iIrisSet;    /* ��Ȧ��Ϊʵ��ȡֵ*100��ֵ��0-�� */
    int   iGainSet;    /* �������棬�عⲹ����Ϊʵ��ȡֵ*100��ֵ���п����Ǹ�ֵ */
    int   iGainLimit;/* �������ƣ��عⲹ����Ϊʵ��ȡֵ*100��ֵ���п����Ǹ�ֵ */
    int   iExposureCompensate; /* �عⲹ����Ϊʵ��ȡֵ*100��ֵ������1050����10.5dB, -750����-7.5dB */
    BYTE  byExposureModeSet;    /* ������ع�ģʽ,0-�ֶ�ģʽ��1-�Զ��ع⣬2-��Ȧ���ȣ�3-�������ȣ�4-�������� */
    BYTE  byShutterSet;         /* ���ţ�0-�أ�1-�Զ�x1��2-�Զ�x2��3-�Զ�x4��4-�Զ�x8��5-�Զ�x16��6-�Զ�x32��7-�Զ�x64��8-�Զ�x128��9-1/1��10-1/2��
    11-1/3��12-1/4��13-1/6��14-1/8��15-1/12��16-1/15��17-1/25��18-1/30��19-1/50��20-1/60��21-1/75��
    22-1/90��23-1/100��24-1/120��25-1/125��26-1/150��27-1/180��28-1/200��29-1/215��30-1/250��31-1/300��
    32-1/350��33-1/425��34-1/500��35-1/600��36-1/725��37-1/1000��38-1/1250��39-1500,40-1/1750��41-1/2000��
    42-1/2500��43-3000,44-1/3500��45-1/4000��46-1/6000��47-1/10000��48-1/30000��49-1/100000,50-1/175��
    51-1/195��52-1/225��53-1/230 */
    BYTE  byImageStabilizeLevel;  /* �������ȼ�: 0-3 */
    BYTE  byCameraIrCorrect; /* ����У��: 0-�Զ���1-����2,�� */
    BYTE  byHighSensitivity; /* ������������: 0-�أ�1-�� */
    BYTE  byInitializeLens;  /* ��ʼ����ͷ: 0-�أ�1-�� */
    BYTE  byChromaSuppress; /* ɫ������ :0-255*/
    BYTE  byMaxShutterSet;     //������ֵ;����ֵ��byShutterSet��ͬ(���Զ��ع⡢��Ȧ����ģʽ����Ч)
    BYTE  byMinShutterSet;     //��С����ֵ;����ֵ��byShutterSet��ͬ(���Զ��ع⡢��Ȧ����ģʽ����Ч)
    BYTE  byMaxIrisSet; //����Ȧ����ֵ(�Զ��ع⡢��������ģʽ) [0,100] ;
    BYTE  byMinIrisSet;    //��С��Ȧ����ֵ(�Զ��ع⡢��������ģʽ) [0,100] ;
    BYTE  byExposureLevel;//�ع�ȼ����ع�ģʽΪ�Զ�����Ȧ���ȡ��������������Ч�����ȼ�1-5 Ĭ��4�������ϰ汾SDK�������豸ʱ�������ֽ�Ϊ0���������������ֽ�Ϊ0ʱ��ҲĬ��Ϊ�ع�ȼ�Ϊ1
    BYTE  byRes[60];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;

typedef struct tagNET_DVR_FLASH_CFG
{
    DWORD      dwSize;
    DWORD    dwChan;//ͨ����
    DWORD    dwInNumbers;//��������
    DWORD    dwOutNumbers;//�뿪����
    DWORD    dwStartTime;//��ʼʱ������
    DWORD    dwEndTime;//����ʱ������
    DWORD    dwEhomeFlag;//
    DWORD    dwAlarmFlag;//
    BYTE       byRes[1024];
}NET_DVR_FLASH_CFG, *LPNET_DVR_FLASH_CFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD        dwSize;
    BYTE        byValid;            // ��ЧʱΪ���ã���ЧʱΪɾ��
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // ���������
    DWORD          dwMatrixID;        // �����ID�ţ�ֻ�ܻ�ȡ
    WORD        wMatrixInputChanNum;                // ���������ͨ����Ŀ
    WORD        wMatrixOutputChanNum;            // ��������ͨ����Ŀ
    WORD           wMatrixOutputChanRef[MAX_CAM_COUNT];   //// �豸����;�������İ󶨹�ϵ�������±��ʾ�������豸����ͨ���ţ�Ԫ�ص�ֵ��ʾ��������ͨ���ţ�
    //Ԫ��ֵ����0 ��ʾ�󶨾������ͨ����Ԫ��ֵΪ0ʱ��ʾ���󶨣���Ļ������Ϊ��Ļ�����ź;�������İ󶨹�ϵ
    BYTE        byMatrixChanType;// �����ͨ������1-BNC��2-VGA��3-RGB��4-DVI
    BYTE        byMatrixProtocol;    // ��������Э��1��ZT1.0��2.ZT2.0��3.Extron��4.Creator
    BYTE        byMatrixType;        //1-ģ�����2-���־���
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;    
    BYTE        byRes3[128];        
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG_V50
{
    DWORD       dwSize;
    BYTE        byValid;            // ��ЧʱΪ���ã���ЧʱΪɾ��
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // ���������
    DWORD       dwMatrixID;        // �����ID�ţ�ֻ�ܻ�ȡ
    WORD        wMatrixInputChanNum;                // ���������ͨ����Ŀ
    WORD        wMatrixOutputChanNum;            // ��������ͨ����Ŀ
    WORD        wMatrixOutputChanRef[MAX_CAM_COUNT_V50];   //// �豸����;�������İ󶨹�ϵ�������±��ʾ�������豸����ͨ���ţ�Ԫ�ص�ֵ��ʾ��������ͨ���ţ�
    //Ԫ��ֵ����0 ��ʾ�󶨾������ͨ����Ԫ��ֵΪ0ʱ��ʾ���󶨣���Ļ������Ϊ��Ļ�����ź;�������İ󶨹�ϵ
    BYTE        byMatrixChanType;// �����ͨ������1-BNC��2-VGA��3-RGB��4-DVI
    BYTE        byMatrixProtocol;    // ��������Э��1��ZT1.0��2.ZT2.0��3.Extron��4.Creator
    BYTE        byMatrixType;        //1-ģ�����2-���־���
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE        byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG_V50, *LPNET_DVR_EXTERNAL_MATRIX_CFG_V50;


#define MAX_INPUTNUMS 1024
#define MAX_OUTPUTNUMS 256
typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE byEnable;
    BYTE byRes1[3];
    DWORD dwDeviceIndex;//�ֲ�ʽ�����������豸���
    WORD wInputIndex;//�����ź�Դ
    BYTE  byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byWallNo;        //ǽ�ţ���1��ʼ
    BYTE    byRes1[2];
    DWORD    dwOutputIndex;    //�����ʾ�������    
    BYTE    byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM,*LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD   dwSize;
    BYTE    sUserName[NAME_LEN];            // �û��������16�ֽ�
    BYTE    sPassWord[PASSWD_LEN];        // ����
    NET_DVR_IPADDR    struUserIP;    // �û�IP��ַ(Ϊ0ʱ��ʾ�����κε�ַ)
    BYTE    byMacAddr[MACADDR_LEN];            // �����ַ
    BYTE    byPriority;        // ���ȼ���1-����Ա��2-����Ա ������Ա�����κ�Ȩ�ޣ�����Աû��"�����û�"��Ȩ��
    BYTE    byRes1;
    DWORD    dwRight;/*Զ�̲���Ȩ�ޣ���λ��ʾ��0-��֧�֣�1-֧�֣���32λ�����Ȩ������*/    
    //bit0-��ȡ���û�������
    //bit1-��ʾ������
    //bit2-���ڹ���
    //bit3-�ź�Դ����
    //bit4-���ֹ���
    //bit5-Ԥ������
    //bit6-��ͼ����
    //bit7-OSD����
    //bit8-����Ȩ��
    //bit9-��������
    //bit10-Զ������
    //bit11-�ָ�Ĭ������
    //bit12-���뵼�����������ļ�
    //bit13-��־��ѯ
    //bit14-Զ������
    //bit15-��Ļ�������
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //��Ļ��������
    BYTE   byWallNo;    //������Ļ���������ǽ�ţ���ֻ֧�ֵ�ǽ���豸�����ֶ���Ч
	BYTE   byRes2[3];
	BYTE   sLoginPassword[PASSWD_LEN/*16*/];		/* ��½����*/
	BYTE   byRes[88];} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{    
    BYTE    byValid; //�Ƿ����ã�0-��1-��
    BYTE    byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP��������   
    WORD    wDevPort;            /*��ý��������˿�*/    
    BYTE    byTransmitType;        /*����Э������ 0-TCP��1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

//�豸ͨ����Ϣ
typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];    //�豸����
    WORD     wDVRPort;                 //�˿ں�
    BYTE     byChannel;                //ͨ����
    BYTE    byTransProtocol;        //����Э������0-TCP��1-UDP
    BYTE    byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE    byFactoryType;            /*ǰ���豸��������,ͨ���ӿڻ�ȡ*/
    BYTE    byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ������Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE    bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã���������������ݸò������������Դ
    BYTE    byUseZeroChan; //�Ƿ�ʹ����ͨ����0-��1-��
    BYTE    byRes;   
    BYTE    sUserName[NAME_LEN];    //���������½�ʺ�
    BYTE    sPassword[PASSWD_LEN];    //�����������
}NET_DVR_DEV_CHAN_INFO_V41,*LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE   byChanType;              //ͨ�����ͣ�0-��ͨͨ��,1-��ͨ��,2-��ID��3-��������Դ��4-������������ͨ����5-ƴ��ͨ����6-��Ļ��������7-�ֲ�ʽ����Դ��8-������ں�ͨ����9-��������Դ
	BYTE    byStreamId[STREAM_ID_LEN]; //��ID����byChanType=2��9ʱ�����ֶ�����ָ������������ipc��ID��
    BYTE    byRes1[3];
    DWORD   dwChannel;  //ͨ���ţ�ͨ������Ϊ��ͨͨ������ͨ������������Դ��������������ͨ����ƴ��ͨ������Ļ���������ֲ�ʽ����Դʱ����ֶ�
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];    //�豸����
    WORD     wDVRPort;                 //�˿ں�
    BYTE     byChannel;                //ͨ����,dwChannel��Ϊ0ʱ���ֶ���Ч
    BYTE    byTransProtocol;        //����Э������0-TCP��1-UDP
    BYTE    byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE    byFactoryType;            /*ǰ���豸��������,ͨ���ӿڻ�ȡ*/
    BYTE    byDeviceType; //�豸����(��Ƶ�ۺ�ƽ̨���ܰ�ʹ��)��1-����������ʱ������Ƶ�ۺ�ƽ̨��������byVcaSupportChanMode�ֶ���������ʹ�ý���ͨ��������ʾͨ������2-������
    BYTE    byDispChan;//��ʾͨ����,��������ʹ��
    BYTE    bySubDispChan;//��ʾͨ����ͨ���ţ���������ʱʹ��
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w����������ʹ�ã���������������ݸò������������Դ
    BYTE    byRes[2];   
    BYTE    sUserName[NAME_LEN];    //���������½�ʺ�
    BYTE    sPassword[PASSWD_LEN];    //�����������
}NET_DVR_DEV_CHAN_INFO_EX,*LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{    
    BYTE   byValid; //�Ƿ����ã�0-��1-��
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP�������� 
    WORD   wDevPort;            /*��ý��������˿�*/    
    BYTE   byTransmitType;        /*����Э������ 0-TCP��1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER,*LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];    //����(IPServer��hiDDNSʱ�������кŻ��߱���)
    BYTE   byTransProtocol;        //����Э������0-TCP��1-UDP, 2-MCAST
    BYTE   byTransMode;            //��������ģʽ 0�������� 1��������
    BYTE   byDdnsType;         //�������������ͣ�0-IPServer 1��Dyndns 2��PeanutHull(������)��3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS��������ַ
    WORD   wDdnsPort;                 //DDNS�������˿ں�
    BYTE   byChanType;              //0-��ͨͨ��,1-��ͨ��,2-��ID
    BYTE   byFactoryType;            //ǰ���豸��������,ͨ���ӿڻ�ȡ
    DWORD  dwChannel; //ͨ����
    BYTE   byStreamId[STREAM_ID_LEN]; //��ID
    BYTE   sUserName[NAME_LEN];    //���������½�ʺ�
    BYTE   sPassword[PASSWD_LEN];    //�����������
    WORD   wDevPort;                //ǰ���豸ͨ�Ŷ˿�
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO,*LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX,*LPNET_DVR_DEC_STREAM_DEV_EX;


//DDNS��ʽȡ��
typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV,*LPNET_DVR_DEC_DDNS_DEV;

typedef union tagNET_DVR_DEC_STREAM_MODE
{
    NET_DVR_DEC_STREAM_DEV_EX struDecStreamDev;
    NET_DVR_PU_STREAM_URL struUrlInfo;
    NET_DVR_DEC_DDNS_DEV struDdnsDecInfo;
    BYTE byRes[300];    
}NET_DVR_DEC_STREAM_MODE,*LPNET_DVR_DEC_STREAM_MODE;

typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD dwSize;
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ����̬�����������豸ȡ��*/
    BYTE byStreamEncrypt;  //�Ƿ�����������ܴ���,0-��֧��,1-֧��
	BYTE byRes1[2];
	NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
    DWORD  dwDecDelayTime;//������ʱʱ�䣬��λ������
    BYTE   sStreamPassword[STREAM_PASSWD_LEN];  //������������,��������Ϣ����
	BYTE  byRes2[48];
}NET_DVR_PU_STREAM_CFG_V41,*LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE byEnable; //�Ƿ����ã�0-��1-��
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ����̬�����������豸ȡ��*/
    BYTE byRes[2];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
}NET_DVR_MATRIX_CHAN_INFO_V41,*LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*��Ѳ���*/
    NET_DVR_MATRIX_CHAN_INFO_V41    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                            byStreamEncrypt;  //�Ƿ�����������ܴ���,0-��֧��,1-֧��
    BYTE                            byRes[3];
    BYTE                            sStreamPassword[STREAM_PASSWD_LEN];  //������������,��������Ϣ����
}NET_DVR_MATRIX_LOOP_DECINFO_V41, *LPNET_DVR_MATRIX_LOOP_DECINFO_V41;

typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD    dwSize;
    BYTE byStreamMode;/*ȡ��ģʽ��0-��Ч��1-ͨ��IP������ȡ����2-ͨ��URLȡ��,3-ͨ����̬�����������豸ȡ��*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//ȡ����Ϣ
    DWORD    dwPlayMode;        /* 0-��̬���� 1��ѭ������ 2����ʱ��ط� 3�����ļ��ط� */
    NET_DVR_TIME StartTime;        /* ��ʱ��طſ�ʼʱ�� */
    NET_DVR_TIME StopTime;        /* ��ʱ��ط�ֹͣʱ�� */
    BYTE    sFileName[128];        /* ���ļ��ط��ļ��� */
    DWORD   dwGetStreamMode;    /*ȡ��ģʽ:1-������2-����*/
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE    byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE    byDevAddress[MAX_DOMAIN_NAME];    /*�豸IP��ַ*/
    WORD    wDevPort;       //�豸�˿�
    BYTE     byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];    /*DDNS����*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];    /*�豸��ַ*/
    BYTE byDdnsType; //�������������ͣ�0-IPServer 1��Dyndns 2��PeanutHull(������)��//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //�豸�˿�
    WORD wDdnsPort; //�����������˿�
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;

typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD    dwSize;
    DWORD    dwDecChannel;  //����ͨ����
    BYTE    byAddressType;  //�豸��ַ���ͣ�0-IP��1-DDNS
    BYTE    byChannelType;  //ͨ�����ͣ�0-��ͨͨ����1-��ͨ����2-��ID
    BYTE    byres[2];
    BYTE    sUserName[NAME_LEN];        /* �û��� */
    BYTE    sPassword[PASSWD_LEN];        /* ���� */
    DWORD    dwChannel;            /* �豸ͨ���� */
    BYTE    byStreamId[STREAM_ID_LEN];  //��ID,�˲�����ͨ������Ϊ��IDʱ��Ч
    DWORD    dwPlayMode;       /* 0�����ļ� 1����ʱ��*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;
    
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //��ʱ��ط�ʱ�ļ���Ϣ
        char sFileName[128];    //���ļ����ط�ʱ�ļ���Ϣ
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50
{
    DWORD   dwSize;
    DWORD   dwDecChannel;   //����ͨ����
    BYTE    byAddressType;  //�豸��ַ���ͣ�0-IP��1-DDNS��2-URL
    BYTE    byChannelType;  //ͨ�����ͣ�0-��ͨͨ����1-��ͨ����2-��ID
    BYTE    byStreamEncrypt;  //�Ƿ�����������ܴ���,0-��֧��,1-֧��
	BYTE	byRes1[1];
    BYTE    sUserName[NAME_LEN];    /* �û��� */
    BYTE    sPassword[PASSWD_LEN];  /* ���� */
    DWORD   dwChannel;              /* �豸ͨ���� */
    BYTE    byStreamId[STREAM_ID_LEN];  //��ID,�˲�����ͨ������Ϊ��IDʱ��Ч
    DWORD   dwPlayMode;             /* 0�����ļ� 1����ʱ��*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;	 //IP��ַ��byAddressTypeΪ0ʱ��Ч
        NET_DVR_DDNS_ADDRESS struDdnsAddr;	//DDNS��ַ��byAddressTypeΪ1ʱ��Ч
    }unionAddr;
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //��ʱ��ط�ʱ�ļ���Ϣ
        BYTE sFileName[128];    //���ļ����ط�ʱ�ļ���Ϣ
    }unionPlayBackInfo;
    NET_DVR_PU_STREAM_URL struURL;	//ȡ��URL��byAddressTypeΪ2ʱ��Ч
    BYTE    sStreamPassword[STREAM_PASSWD_LEN];  //������������,��������Ϣ����
    BYTE    byRes2[116];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V50, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50;

typedef struct tagNET_DVR_DISPLAY_EFFECT_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR  struColor;      //��ʾ��ز���/
    BYTE byRes[32];
}NET_DVR_DISPLAY_EFFECT_CFG,*LPNET_DVR_DISPLAY_EFFECT_CFG;

//��ȡ����״̬
typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD        dwSize;
    DWORD        dwTrunkID;    //����ID
    WORD        wReserveUserID;    //Ԥ�����û�ID�� 1~256 ��0��ʾ�ͷ�Ԥ��
    BYTE        byStatus;  //1-���У�2-ռ�ã�3-���� */
    BYTE        byRes1;
    BYTE          byUserId[256];  //�����±��ʾ�û�ID�ţ�����Ԫ�ص�ֵ��ʾ�Ƿ�ʹ�ø��ߡ��磺byUserID[0] ��ֵΪ1����ʾ�û�IDΪ0���û�����ʹ�ã�byUserID[0] ��ֵΪ0��ʾ�û�IDΪ0���û�û��ʹ����������
    BYTE           byRes2[64];  
}NET_DVR_TRUNK_USE_STATE,  *LPNET_DVR_TRUNK_USE_STATE;


//PTZ���Ʋ���
typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD    dwSize;
    DWORD    dwCtrlDelayTime;        //PTZ���Ƴ���ʱ�䣬ָPTZ���ƺ���dwCtrlDelayTimeʱ���ڣ�����ͬ�����ͼ����û����������Ч����λ����
    BYTE    byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

//��ʾ·��
#define        MAX_MATRIX_CASCADE        32
typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD        dwSize;
    DWORD           dwCamNo;
    DWORD       dwMonNo;
    DWORD        dwSubWin;
    DWORD        dwUserId;
    DWORD       dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId��Ա��Ӧ����������1��32����CAM�˿�ʼ��trunkId[0]��ʾ��һ��������trunkId[1]��ʾ�ڶ�������, trunkId[i] = 0 ��ʾ�޸���
    BYTE        byRes[64];      /* Ԥ�� */
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;


//��ȡPTZ״̬
typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD        dwSize;
    DWORD        dwUserID;    //1~256��0 ��ʾ���û�
    DWORD       dwStatus;      // PTZ����״̬0-ֹͣ��1-����
    DWORD        dwRestTime;  //ʣ��ʱ��
    BYTE        byRes[64];  
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;

typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //����ģʽ��0-�����ų�����1-�����ų���
    BYTE  byFaintToUnlock; //�ε�����һ��ʱ����ⲿ���Կ�����0-��1-��
    BYTE  byOvertimeToUnlock;  //ʹ�ó�ʱ���ⲿ��ť�Ƿ���Կ�����0-��1-��
    BYTE  byRes[13];
}NET_DVR_SAFETYCABIN_WORK_MODE,*LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //���������ͣ�0-��������ͣ�1-Ļ��������
    BYTE  bySensitivity; //���������жȣ���Χ��0-100%
    BYTE  byDevUseTimeout; //������ʹ�ó�ʱʱ�䣬��λ����,��Χ��5-30��Ĭ�ϳ�ʱ15min,��ʱ��ͨ������ͨ���ϴ�����
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //Ļ��������̽����ʱʱ�䣬��λ���룬��Χ��0-10
    WORD  wCurtainResponseTime; //Ļ����״̬�仯��������Ӧʱ�䣬��λ���룬��Χ��0-300
    WORD  wFaintToEmergencyTime; //�ε��澯��Чʱ�䣬��λ���룬��Χ��10-300
    BYTE  byFollowDetectorSensitivity;  //β���������ȣ���Χ��0-100%
    BYTE  byManyPersonSensitivity;    //���˼�������ȣ���Χ��0-100%
    BYTE  byRes2[28];  //����
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG,*LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;    

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD        dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //�����������ַ
    BYTE  byRes[64];      //����
}NET_DVR_ETHERNET_IPV6_COND,*LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD        dwSize;
    BYTE  byState; //IPv6״̬��0-·�ɷ��䣬1-�Զ�����
    BYTE  byRes1[3]; 
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6��ַ
    BYTE  byRes[64];      //����
}NET_DVR_ETHERNET_IPV6_CFG,*LPNET_DVR_ETHERNET_IPV6_CFG;

typedef struct  
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME,*LPNET_DVR_DAYTIME;

typedef struct
{
    NET_DVR_DAYTIME  struStartTime; //��ʼʱ��
    NET_DVR_DAYTIME  struStopTime; //����ʱ��
}NET_DVR_SCHEDULE_DAYTIME, *LPNET_DVR_SCHEDULE_DAYTIME;

typedef struct
{
    BYTE byObjectSize;//ռ�Ȳ���(0~100)
    BYTE byMotionSensitive; /*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byRes[6];
}NET_DVR_DNMODE, *LPNET_DVR_DNMODE;

typedef struct 
{
    BYTE byAreaNo;//������(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;//���������������Ϣ(����) size = 16;
    NET_DVR_DNMODE  struDayNightDisable;//�ر�ģʽ
    NET_DVR_DNMODE  struDayModeParam;//����ģʽ
    NET_DVR_DNMODE  struNightModeParam;//ҹ��ģʽ
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;

typedef struct
{
    BYTE byDayNightCtrl;//��ҹ���� 0~�ر�,1~�Զ��л�,2~��ʱ�л�(Ĭ�Ϲر�)
    BYTE byAllMotionSensitive; /*�ƶ����������, 0 - 5,Խ��Խ����,0xff�رգ�ȫ������������ȷ�Χ*/ 
    BYTE byRes[2];//
    NET_DVR_SCHEDULE_DAYTIME struScheduleTime;//�л�ʱ��  16
    NET_DVR_MOTION_MULTI_AREAPARAM struMotionMultiAreaParam[MAX_MULTI_AREA_NUM];//���֧��24������
    BYTE byRes1[60];
}NET_DVR_MOTION_MULTI_AREA,*LPNET_DVR_MOTION_MULTI_AREA; //1328

typedef struct
{
    BYTE byMotionScope[64][96];        /*�������,0-96λ,��ʾ64��,����96*64��С���,Ŀǰ��Ч����22*18,Ϊ1��ʾ���ƶ��������,0-��ʾ����*/
    BYTE byMotionSensitive;            /*�ƶ����������, 0 - 5,Խ��Խ����,0xff�ر�*/
    BYTE byRes[3];
}NET_DVR_MOTION_SINGLE_AREA, *LPNET_DVR_MOTION_SINGLE_AREA;

typedef struct 
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //��ͨģʽ�µĵ�������
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //ר��ģʽ�µĶ���������    
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct 
{    
    NET_DVR_MOTION_MODE_PARAM  struMotionMode; //(5.1.0����)
    BYTE byEnableHandleMotion;        /* �Ƿ����ƶ���� 0���� 1����*/ 
    BYTE byEnableDisplay;    /*�����ƶ���������ʾ��0-��1-��*/
    BYTE byConfigurationMode; //0~��ͨ,1~ר��(5.1.0����)
    BYTE byKeyingEnable; //���ü����ƶ���� 0-�����ã�1-����
    /* �쳣����ʽ */
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    /*0x1000: ץͼ�ϴ�����*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //ʵ�ʴ����ı�������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    /*������¼��ͨ��*/
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];     /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0 - dwRelRecordChan -1��Ч������м�����0xffffffff,�������Ч*/  
    BYTE  byDiscardFalseAlarm; //����ȥ�� 0-��Ч��1-�����ã�2-����
    BYTE  byRes[127]; //�����ֽ�
}NET_DVR_MOTION_V40,*LPNET_DVR_MOTION_V40;

typedef struct
{
    DWORD dwEnableHideAlarm;                /* �Ƿ������ڵ�������0-��1-�������ȣ�2-�������ȣ�3-��������*/
    WORD wHideAlarmAreaTopLeftX;            /* �ڵ������x���� */
    WORD wHideAlarmAreaTopLeftY;            /* �ڵ������y���� */
    WORD wHideAlarmAreaWidth;                /* �ڵ�����Ŀ� */
    WORD wHideAlarmAreaHeight;                /*�ڵ�����ĸ�*/ 
    /* �źŶ�ʧ����������� */    
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    /*0x1000:ץͼ�ϴ�����*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*������������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч*/  
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE  byRes[64]; //����
}NET_DVR_HIDEALARM_V40,*LPNET_DVR_HIDEALARM_V40; //�ڵ�����

typedef struct
{
    DWORD dwEnableVILostAlarm;                /* �Ƿ������źŶ�ʧ���� ,0-��,1-��*/
    /* �źŶ�ʧ����������� */    
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    /*0x1000:ץͼ�ϴ�����*/
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; /*������������ţ���ֵ��ʾ,���ý��������У����±�0 - dwRelAlarmOut -1��Ч������м�����0xffffffff,�������Ч*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    BYTE    byVILostAlarmThreshold;    /*�źŶ�ʧ������ֵ����ֵ������ֵ����Ϊ�źŶ�ʧ��ȡֵ0-99*/
    BYTE    byRes[63]; //����
}NET_DVR_VILOST_V40,*LPNET_DVR_VILOST_V40;    //�źŶ�ʧ����

typedef struct
{
    NET_DVR_COLOR      struColor[MAX_TIMESEGMENT_V30];/*ͼ�����(��һ����Ч��������������)*/
    NET_DVR_SCHEDTIME  struHandleTime[MAX_TIMESEGMENT_V30];/*����ʱ���(����)*/
}NET_DVR_VICOLOR, *LPNET_DVR_VICOLOR;

typedef struct
{
    DWORD  dwSize;
    BYTE  sChanName[NAME_LEN]; 
    DWORD  dwVideoFormat;    /* ֻ�� ��Ƶ��ʽ 1-NTSC 2-PAL  */
    NET_DVR_VICOLOR struViColor;//    ͼ�������ʱ�������
    //��ʾͨ����
    DWORD  dwShowChanName; // Ԥ����ͼ�����Ƿ���ʾͨ������,0-����ʾ,1-��ʾ
    WORD    wShowNameTopLeftX;                /* ͨ��������ʾλ�õ�x���� */
    WORD    wShowNameTopLeftY;                /* ͨ��������ʾλ�õ�y���� */
    //��˽�ڵ�
    DWORD  dwEnableHide;        /* �Ƿ������ڵ� ,0-��,1-��*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD  dwShowOsd;// Ԥ����ͼ�����Ƿ���ʾOSD,0-����ʾ,1-��ʾ
    WORD   wOSDTopLeftX;                /* OSD��x���� */
    WORD   wOSDTopLeftY;                /* OSD��y���� */
    BYTE    byOSDType;                    /* OSD����(��Ҫ�������ո�ʽ) */
    /* 0: XXXX-XX-XX ������ */
    /* 1: XX-XX-XXXX ������ */
    /* 2: XXXX��XX��XX�� */
    /* 3: XX��XX��XXXX�� */
    /* 4: XX-XX-XXXX ������*/
    /* 5: XX��XX��XXXX�� */
    /*6: xx/xx/xxxx(��/��/��) */
    /*7: xxxx/xx/xx(��/��/��) */
    /*8: xx/xx/xxxx(��/��/��)*/
    BYTE    byDispWeek;                /* �Ƿ���ʾ���� */
    BYTE    byOSDAttrib;                /* OSD����:͸������˸ */
    /* 0: ����ʾOSD */
    /* 1: ͸������˸ */
    /* 2: ͸��������˸ */
    /* 3: ��͸������˸ */
    /* 4: ��͸��������˸ */    
    BYTE    byHourOSDType;                /* OSDСʱ��:0-24Сʱ��,1-12Сʱ�� */
    BYTE    byFontSize;      //16*16(��)/8*16(Ӣ)��1-32*32(��)/16*32(Ӣ)��2-64*64(��)/32*64(Ӣ)  3-48*48(��)/24*48(Ӣ) 4-24*24(��)/12*24(Ӣ) 5-96*96(��)/48*96(Ӣ) 6-128*128(��)/64*128(Ӣ) 7-80*80(��)/40*80(Ӣ) 8-112*112(��)/56*112(Ӣ) 0xff-����Ӧ(adaptive)
    BYTE    byOSDColorType;     //0-Ĭ�ϣ��ڰף���1-�Զ���
    /*�����뷽ʽѡ�����ģʽʱ�����Էֱ�����½ǡ����½������������ַ����ӡ�
    ���½�����
    ��֧��6���ַ����ӣ�����ͨ��NET_DVR_SET_SHOWSTRING_V30/ NET_DVR_GET_SHOWSTRING_V30�ַ����ӽӿڣ���ӦNET_DVR_SHOWSTRINGINFO�ṹ�������еĵ�0����5���±��ֵ�������ַ��ķ�ʽΪ���µ��ϵķ�ʽ��
    ���½�����
    ��֧��2���ַ����ӣ�����ͨ��NET_DVR_SET_SHOWSTRING_V3/ NET_DVR_GET_SHOWSTRING_V30�ַ����ӽӿڣ���ӦNET_DVR_SHOWSTRINGINFO�ṹ�������еĵ�6�͵�7���±��ֵ�������ַ��ķ�ʽΪ���µ��ϵķ�ʽ��
    */
    BYTE    byAlignment;//���뷽ʽ 0-����Ӧ��1-�Ҷ���, 2-����룬3-����ģʽ��4-ȫ���Ҷ���(���������ַ���ʱ���Լ����������OSD�ַ�)��5-ȫ�������(���������ַ���ʱ���Լ����������OSD�ַ�)
    BYTE    byOSDMilliSecondEnable;//��Ƶ����ʱ��֧�ֺ��룻0~������, 1-����
    NET_DVR_VILOST_V40 struVILost;  //��Ƶ�źŶ�ʧ������֧���飩
    NET_DVR_VILOST_V40 struAULost;  /*��Ƶ�źŶ�ʧ������֧���飩*/
    NET_DVR_MOTION_V40 struMotion;  //�ƶ���ⱨ����֧���飩
    NET_DVR_HIDEALARM_V40 struHideAlarm;  //�ڵ�������֧���飩
    NET_DVR_RGB_COLOR    struOsdColor;//OSD��ɫ
    DWORD dwBoundary; //�߽�ֵ������룬�Ҷ����Լ�����ģʽ�ı߽�ֵ��0-��ʾĬ��ֵ����λ������;�ڹ���ģʽ�£���λ�޸�Ϊ�ַ���������Χ�ǣ�0,1,2��
    NET_DVR_RGB_COLOR struOsdBkColor; //�Զ���OSD����ɫ
    BYTE    byOSDBkColorMode; //OSD����ɫģʽ��0-Ĭ�ϣ�1-�Զ���OSD����ɫ
    BYTE    byUpDownBoundary; //������С�߽�ֵѡ���λΪ�ַ���������Χ�ǣ�0,1,2��,����ģʽ����Ч��byAlignment=3���ֶ���Ч��ͨ��dwBoundary���б߽����ã�.byAlignment������3������£� byUpDownBoundary/byLeftRightBoundary���óɹ���dwBoundaryֵ������Ч
    BYTE    byLeftRightBoundary; //������С�߽�ֵѡ���λΪ�ַ���������Χ�ǣ�0,1,2��, ����ģʽ����Ч��byAlignment=3���ֶ���Ч��ͨ��dwBoundary���б߽����ã�.byAlignment������3������£� byUpDownBoundary/byLeftRightBoundary���óɹ���dwBoundaryֵ������Ч
    BYTE    byAngleEnabled;//OSD�Ƿ���Ӹ�������Ϣ,0~������, 1-����
    WORD    wTiltAngleTopLeftX;    /* ��������Ϣ��ʾλ�õ�x���� */
    WORD    wTiltAngleTopLeftY;  /* ��������Ϣ��ʾλ�õ�y���� */
    BYTE    byRes[108];
}NET_DVR_PICCFG_V40,*LPNET_DVR_PICCFG_V40;

typedef struct  //
{
    DWORD                   dwSize; 
    BYTE   byWorkType;// 0-����Ӧ, 1-��ʱģʽ
    BYTE   byRes[3];
    //��ʱģʽ����
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;//��ҹ��ʱ�л�ģʽ(����ʱ��)
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam; //����Ӧ����
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;//�������
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;//ҹ�����
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG,*LPNET_DVR_ISP_CAMERAPARAMCFG;

typedef struct
{
    DWORD       dwSize; 
    BYTE        byIrLampServer;//��������� 0�����ã�1������
    BYTE        bytelnetServer;//telnet���� 0�����ã�1������
    BYTE        byABFServer;//ABF���� 0�����ã�1������
    BYTE        byEnableLEDStatus;//״ָ̬ʾ�ƿ��� 0�����ã�1������
    BYTE        byEnableAutoDefog;//�Զ�������� 0�����ã�1������
    BYTE        byEnableSupplementLight;//����ƿ���0-���ã�1-����
    BYTE        byEnableDeicing;//�������� 0-�رգ�1-����
    BYTE        byEnableVisibleMovementPower;// �ɼ����о��Դ���� 0-�رգ�1-����
    BYTE        byEnableThermalMovementPower;// �ȳ����о��Դ���� 0-�رգ�1-����
    BYTE        byEnablePtzPower;// ��̨��Դ���� 0-�رգ�1-����
    BYTE        byPowerSavingControl;// �͹��Ĳ��� 0-���� 1-����ģʽ 2-�͹���ģʽ �͹���ģʽ�� �ɼ����о��Դ���ȳ����о��Դ����̨��Դ������Ч
    BYTE        byCaptureWithSupplimentLightEnabled;//����ץ�Ĳ���ʹ�� 0-�رգ�1-����
    BYTE        byRes[244];
}NET_DVR_DEVSERVER_CFG,*LPNET_DVR_DEVSERVER_CFG;

typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD       dwSize;
    BYTE       byEnable;//28181Э��ʹ�� 0-�ر� 1-����
    BYTE       byTransProtocol;//����Э��:0-UDP��1-TCP��Ĭ��0-UDP
    WORD       wLocalSipPort;//1024-65535(IPC�豸��)
    char       szServerID[MAX_SERVERID_LEN];//������ID��64�ֽ��ַ�������������
    char       szServerDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// ��������
    char       szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN] ;// SIP��������ַ֧��������IP��ַ
    WORD       wServerSipPort;//������SIP�˿ڣ�1024-65535
    BYTE       byProtocolVersion;//Э��汾 0-GB/T28181-2011(��֧��UDP),1-GB/T28181-2015(֧��TCP,UDP),2-GB/T28181-2016
    BYTE        byTCPConnectMod; //TCP����ģʽ��ʹ��TCP����Э��ʱ��Ч��0-��Ч��1-����ģʽ��2-����ģʽ
    char       szSipUserName[MAX_SERVERNAME_LEN];//SIP�û����ƣ�64�ֽ��ַ���(������SIP�ն�����IPC����ʱʹ��)
    char       szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];//SIP�û���֤ID��64�ֽ��ַ���
    char       szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];//SIP�û���֤���룺32�ֽ��ַ���(IPC�豸ע�ᵽSIP������ʱʹ��)
    DWORD      dwRegisterValid;//ע����Ч�ڣ���λ�룬Ĭ��3600��
    BYTE       byHeartbeatInterval;//�����������λ�룬Ĭ��10�룻
    BYTE       byMaxHeartbeatTimeOut;//���������ʱ������Ĭ��3�Σ�
    BYTE       byStreamType;// ȡ������0����������1����������2��3����
    BYTE          byDeviceStatus; //�豸�Ƿ�����״̬��0-������1-���ߣ�2-����
    DWORD      dwRegisterInterval;//ע����:ע��ʧ�ܺ��ٴ�ע���ʱ����,��Χ60-600s��Ĭ��60s
    DWORD      dwAutoAllocChannelID ; //�Ƿ��Զ�����ͨ��ID,��λ��ʾ��0Ϊ�ֶ����ã�1Ϊ�Զ����䣬bit1-�Զ��������ͨ��ID,bit2-�Զ����䱨������ͨ��,bit3-�Զ��������ͨ��ID 
    char       szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// �豸��
    BYTE       byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG,*LPNET_DVR_GBT28181_ACCESS_CFG;

//GBT28181Э����豸����ͨ������
typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD                   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];//�豸��Ƶͨ������ID��64�ֽ��ַ�������������
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG,*LPNET_DVR_GBT28181_CHANINFO_CFG;

//GBT28181Э��ı�������ͨ������ �����ṹ
typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;//��������ͨ����
    BYTE  byRes[32]; //����
}NET_DVR_ALARMIN_INFO, *LPNET_DVR_ALARMIN_INFO;

//GBT28181Э��ı�������ͨ������ ���ýṹ
typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD                   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//�豸�����������ID��ÿһ·�������벻ͬ����20�ֽ��ַ�������������
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG,*LPNET_DVR_GBT28181_ALARMINCFG;

typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD  wSetupHeight; //����߶�[0,20]����λ����
    BYTE  byLensType; //��ͷ�������ͣ�0-δ֪,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE  bySetupHeightUnit;// ����߶ȵ�λ0��M,1~CM
    DWORD dwSceneDis; //ͼ���±�Եλ�������֮���ˮƽ���룬��λ������
    float fPitchAngle;//��������Ƕ�[-180��, 180��],
    float fInclineAngle;//�����б�Ƕ�[-180��,180��]
    float fRotateAngle;//�����ת�Ƕ�[-180��,180��]
    WORD  wVideoDetCoefficient; //��Ƶ����ϵ��[0,300](3.6����)
    BYTE  byErectMethod; //���跽ʽ0-��װ��1-��װ(3.6����)
    BYTE  byCameraViewAngle;//�������װ��Ұ�Ƕ�(0-��ֱ��1-��б��Ĭ��0-��ֱ)
    DWORD dwHorizontalDistance;//�����������ˮƽ���룺��Χ1-1000��Ĭ��30����λcm��ע��������Ƕ�Ϊ��бʱ������Ч
    BYTE  byDetailLensType;//��Χ1-100��Ĭ��28����λ0.1mm
    BYTE  byRes[3]; 
    float fHorFieldAngle; //���ˮƽ�ӳ��ǽǶ�[0��, 360��]��ץ�Ļ���
    float fVerFieldAngle; //�����ֱ�ӳ��ǽǶ�[0��, 360��]��ץ�Ļ���,ӥ�۷�Χ-90��-90��
    float fLableSetupHeight; //��ǩ����������ĸ߶�[0,100]����λ����
    float fMaxViewRadius;//�����Ӱ뾶,0~10000.00�ף�Ĭ��5000��.
    BYTE  byRes1[16];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

//��ֹ���ڶβ����ṹ��
typedef struct tagNET_DVR_SCHEDDATE
{   
    BYTE   byStartMonth;   //��ʼ���£�
    BYTE   byStartDay;     //��ʼ���գ�
    BYTE   byStopMonth;    //�������£�
    BYTE   byStopDay;      //�������գ�
}NET_DVR_SCHEDDATE,*LPNET_DVR_SCHEDDATE;

//ʱ���������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{   
    NET_DVR_SCHEDTIME struTime;  //ʱ���
    BYTE byState;                //0�C�ر�, 1�C����
    BYTE byRes[11];              //����
} NET_DVR_OUTPUT_SCHEDULE ,*LPNET_DVR_OUTPUT_SCHEDULE;

//����ʱ������������
typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{   
    BYTE                     byEnable;    //�Ƿ����ù���,0-��,1-��
    BYTE                     byRes1[3];   //����
    NET_DVR_SCHEDDATE        struDate;    //��������
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //���֧��8��ʱ��ε�ʱ�����
    BYTE                     byRes2[16];  //����
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

//ʱ������������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{   
    DWORD  dwSize; //�ṹ���С
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //���֧��8���������εĹ�������
    BYTE   byRes[64];  //����
}NET_DVR_OUTPUT_SCHEDULE_RULECFG,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

//��ͨͳ�Ʊ�������
typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ý�ͨͳ�Ʊ����ϴ�
    BYTE byRes1[3];    //
    DWORD dwInterval;//ͳ�Ƽ��ʱ�䣨��λ�����ӣ�
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;    //����¼��ID(���ڲ�ѯ¼�񣬽���byResultTypeΪ2ʱ��Ч)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;

typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//1-4��0xff�� ����1-4��ʾ�����IOͨ���ţ�0xff��ʾ������
    BYTE  byCabinetState;//0~�͵�ƽ,1~�ߵ�ƽ
    BYTE  byAlarmIntervalTime;//ȡֵ��Χ1-60����λ����
    BYTE  byRes1[25]; 
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0~�����ã�1������
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;

typedef  struct  tagNET_ITS_GATE_LANE_CFG
{ 
    BYTE      byGateSiteID[MAX_ID_LEN];    //����ڱ��
    BYTE      byGateInfo[MAX_ID_LEN];      //�������Ϣ����
    BYTE      byLaneName[NAME_LEN];     //��������
    BYTE      byValid;              //�Ƿ����� 0 ��ʾδ���ã�1��ʾ����
    BYTE      byCamLaneId;     //��Ӧ���������1��16��������õĳ����ţ�������Ծ��������ͬ��
    WORD      wLaneid;            //������1��32�����������ţ�������Ծ �߼�������
    BYTE      byRelativeIoNum;         //�߼������Ź���������ڱ��      
    BYTE      byDirection;          //������;  0 -���� 1 �볡  2 ���� 3 ˫��
    BYTE      byLprMode; //��ʶ��������0 ȫ����1 ����������2 ��������
    BYTE       byCardMode; //��Ƭ��������0 ȫ����1 ����������2 �������� 
    BYTE       byGateLaneMode;//����ڷ�������ģʽ 0-ȫ���� 1-ֻ����ʶƥ�����2 ֻ��ˢ��ƥ���//�� 3-��ʶ��Ƭ��һ��ƥ������� 4-��ʶ�ҿ�Ƭͬʱƥ������� 5-ȫ����
    //2013-11-19 ��������
    BYTE      byCharge;//�Ƿ��շ� 0-���շѣ�1-�շ�
    BYTE      byChargeMode;//�շ����� 0-�����շѣ�1-�����շ�
    BYTE      byRes1;
    BYTE      byLedRelativeIndex[MAX_INDEX_LED];//LED ���� (1~255) �������У�0��ʾ��Ч�����������������
    BYTE      byGateRelativeIndex;//����ڿ��ƻ��������
    BYTE      byFarRrRelativeIndex;// Զ����������������
    BYTE      byRes[82]; //Ԥ��
}NET_ITS_GATE_LANE_CFG, *LPNET_ITS_GATE_LANE_CFG;

typedef    struct  tagNET_ITS_IPC_CHAN_LANE_CFG
{
    DWORD     dwSize; 
    BYTE      byIpcType;  //0-�ޣ�1-����ץ�ģ�2-����ץ�ģ�3-������
    BYTE      byRes[135];
    NET_ITS_GATE_LANE_CFG  struGateLane[4]; //�������ýṹ��
}NET_ITS_IPC_CHAN_LANE_CFG, *LPNET_ITS_IPC_CHAN_LANE_CFG;

//�豸Զ�̿���
typedef    struct    tagNET_ITS_REMOTE_COMMAND
{
    WORD            wLaneid; //������1��32�����������ţ�������Ծ��
    BYTE             byCamLaneId;    //��Ӧ���������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE            byRes;     //Ԥ��
    DWORD           dwCode;       //������ 0x0 ��բ 0x1 ��բ����������չ
    BYTE            byRes1[128];
}NET_ITS_REMOTE_COMMAND,*LPNET_ITS_REMOTE_COMMAND;

typedef  struct    tagNET_ITS_REMOTE_CONTROL_
{
    DWORD          dwSize;
    NET_ITS_REMOTE_COMMAND    struRemoteCommand;   //Զ������ṹ
}NET_ITS_REMOTE_CONTROL,*LPNET_ITS_REMOTE_CONTROL;

//�����ӻ�ȡͨ��״̬
typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //ͨ���Ƿ���¼��,0-��¼��,1-¼��
    BYTE  bySignalStatic; //���ӵ��ź�״̬,0-����,1-�źŶ�ʧ
    BYTE  byHardwareStatic;//ͨ��Ӳ��״̬,0-����,1-�쳣,����DSP����
    BYTE  byChannelArmState; //����IPC�Ĳ���״̬
    DWORD dwChannel; //ͨ����
    DWORD dwBitRate;//ʵ������
    DWORD dwLinkNum;//�ͻ������ӵĸ���
    NET_DVR_IPADDR struClientIP[MAX_LINK];//�ͻ��˵�IP��ַ
    DWORD dwIPLinkNum;//�����ͨ��ΪIP���룬��ô��ʾIP���뵱ǰ��������
    BYTE  byExceedMaxLink;    // �Ƿ񳬳���128·������ 0 - δ����, 1-����     
    BYTE  byRes[139];       // �����ֽ�    
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

//��ӵ�
typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 �� ������ 1 �� ����
    BYTE   byFlicker;//0 �� ����˸ 1 �� ��˸
    BYTE   byIOState;//0 �� �͵�ƽ 1 �� �ߵ�ƽ (���õ���Ч)
    BYTE   byLampColor;// 0- �� 1-��   2-��  3-��  4-�� 5-Ʒ��  6-��  7-��ɫ (���õ���Ч)
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0������˸ 1 ����˸
    BYTE   byLampColor;//0-�� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (���õ���Ч) 
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//�г�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//�޳�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//���⳵λ�г�io��ƽ״̬
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//���⳵λ�޳�io��ƽ״̬
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*��ӵƵ�����³�λ��Ϣ��һ��ͨ�����4����λ (�����ҳ�λ ����0��3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0~����˸ 1 ����˸(��λָʾ����˸)
    BYTE   byLampColor;//0- �� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (��λָʾ����ɫ)
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

//�������õ�ģʽ
typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //��λ״̬ 0�����޳���1�����г���2����ѹ��(���ȼ����), 3���⳵λ
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //������λ�ƣ�0-���õ�, 1-���õ�1, 2-���õ�2, 3-���õ�3��
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable; //0�������� 1 ������
    BYTE   byFlicker;//0~����˸ 1 ����˸
    BYTE   byLampColor;//0- �� 1-��   2-��  3-��  4-�� 5-Ʒ��  6-��  7-��ɫ 
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

//�������õ�ģʽ
typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    //��λ״̬ 0�����޳���1�����г���2����ѹ��(���ȼ����), 3���⳵λ
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    //������λ�ƣ�0-���õ�, 1-���õ�1, 2-���õ�2, 3-���õ�3��
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP; 

/*���õƼ����õ�ģʽ�� ���õƿ��ƽṹ����Ϣ */
typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;     //0�������� 1 ������
    BYTE   byFlicker;    //0~����˸ 1 ����˸
    BYTE   byLampColor;  //0- �� 1-�� 2-�� 3-�� 4-�� 5-Ʒ�� 6-�� 7-��ɫ (���õ���Ч)  
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

/* ��Ͽ���ģʽ�ṹ */ 
typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];//���õ� ���ճ�λ�Ž������֣�һ��ͨ�����4����λ (�����ҳ�λ ����0��3) 
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];//���õ� ���ճ�λ״̬���֣���λ״̬ 0�����޳���1�����г���2����ѹ��(���ȼ����), 3���⳵λ
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

/* ������ӵƿ���ģʽ�ṹ */ 
typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE //�����õ�ģʽ�ǲ����ֳ�λ��Ϣ����ʾ��ǰ��λ״̬�У��ȼ���õ�״̬��ѹ��>���⳵λ>���޳�״̬��
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];//���õ� ���ճ�λ�Ž������֣�һ��ͨ�����4����λ (�����ҳ�λ ����0��3)
    BYTE byLampType; /* 1-���õ�1��2-���õ�2��3-���õ�3*/
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;

typedef union tagNET_DVR_LAMP_CTRL_MODE_UNION
{
    BYTE uLen[288];
    NET_DVR_INLAY_LAMP_CTRL_MODE struInlayLampCtrlMode;/*���õƿ���ģʽ�ṹ*/ 
    NET_DVR_EXTERNAL_LAMP_CTRL_MODE struExternalLampCtrlMode;/*��ӵƿ���ģʽ�ṹ*/
    NET_DVR_PARKLAMP_CTRL_MODE struParkLampCtrlMode[MAX_PARKING_NUM/*4*/];/*�������õ�ģʽ��һ��ͨ�����4����λ (�����ҳ�λ ����0��3)  ��ģʽΪ�����õƵ�ʱ����Ч*/
    //��λ�����������õƣ���Ͽ���ģʽ�����������������õ�ģʽ����ģʽ�����õƲ���Ϊ���õ�ʹ�ã��������õ�ģʽ�£����õ���Ϊ���õ�ʹ�ã�����
    //��Ͽ���ģʽ�£����õ���ʾ��ǰ��⳵λ״̬�У����ȼ���ߵĳ�λ״̬(ѹ��>���⳵λ>���޳�״̬)�����Ƶ�״̬
    NET_DVR_MIXLAMP_CTRL_MODE  struMixLampCtrlMode;
    //�����õ�ģʽ�ǲ����ֳ�λ��Ϣ����ʾ��ǰ��λ״̬�У��ȼ���õ�״̬��ѹ��>���⳵λ>���޳�״̬��
    NET_DVR_SINGLELAMP_CTRL_MODE struSingleExternalLampCtrlMode;
}NET_DVR_LAMP_CTRL_MODE_UNION, *LPNET_DVR_LAMP_CTRL_MODE_UNION;/*�ƿ���ģʽ������*/ 

typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*�ص�ģʽ��1�������õ�,2������ӵ�,3���������õ�,4�����ϵ�ģʽ�����õ�ֻ�������ȼ�ָʾ��),5-�������õ�ģʽ*/
    BYTE      byCtrlChannelIndex;/*�������ͨ����(33~48)*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;/*�ƿ���ģʽ������*/
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

//��λ�������ã�Ĭ�϶���normal��
typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~��ͨ��λ 1�����⳵λ
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//һ��ͨ�����4����λ (�����ҳ�λ ����0��3)
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

//ָʾ�����
typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0~����˸ 1 ����˸
    BYTE      byParkingIndex;//��λ��1��3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //���ʹ�� 0�������� 1������
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;//ָʾ�����
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

//��λǿ��ץͼ һ��ͨ������ĳ�λ
typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE       byParkIndex;/*��λ��Ŵ����� ��0-��ʾ��ǰ�м�����λ�����ϴ�����ͼƬ��1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

//��ر����ṹ
typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD      dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;//ָʾ�����״̬
    NET_DVR_TIME      struExternalBeginTime;/*��ؿ�ʼʱ��*/ 
    BYTE      byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;

/* �豸���� */
typedef enum tagEXTERNAL_DEVICES_TYPE
{
    DEVICES_TYPE_RES1 = 0,                //����1    
    DEVICES_TYPE_FAR_SCR = 1,            //Զ���������
    DEVICES_TYPE_ENTRANCE_CONTROL = 2,    //����ڿ��ƻ�
    DEVICES_TYPE_WJ_LED_DEV = 3,        //���LED
    DEVICES_TYPE_NJ_LED_DEV = 4,        //�ڽ�LED
    DEVICES_TYPE_VEH_DETECT_DEV = 5,    //�������豸
    DEVICES_TYPE_DZ_DEV = 6,            //��բ
    DEVICES_TYPE_PX_SCR_DEV = 7,         //Ʊ�������
    DEVICES_TYPE_KJ_SCR_DEV = 8,         //����������
    DEVICES_TYPE_FKJ_DEV = 9,            //������
    DEVICES_TYPE_SKJ_DEV = 10,            //�տ���
    DEVICES_TYPE_HDD_DEV = 11,            //Ӳ��(���� 1G)
    DEVICES_TYPE_DZ_LOCK = 12,            //��բ��բ״̬��0��ʾδ��բ��1��ʾ��բ
    DEVICES_TYPE_PAPER_PRINTER = 13,    //ֽƱ��ӡ�� 
    DEVICES_TYPE_PAPER_SCANNERS = 14,   //ֽƱɨ����
    DEVICES_TYPE_IPC_ALARM = 15         //IPC����״̬
}EXTERNAL_DEVICES_TYPE;

/* �豸״̬ */
typedef enum tagEXTERNAL_DEVICES_STATUS
{
    /* ͨ���豸״̬�� 0~19*/
    DEVICES_STATUS_NORMAL = 0,            //״̬����
    DEVICES_STATUS_ABNORMAL = 1,        //״̬�쳣
    
    /* �������豸״̬�� 20~39*/
    DEVICES_STATUS_TOO_LESS_CARD = 20,         //�������ٿ�
    DEVICES_STATUS_NO_CARD = 21,             //�������޿�
    DEVICES_STATUS_SENDCARD_ERROR = 22,     //Ԥ��������
    DEVICES_STATUS_CARD_BLOCKED = 23,         //�¿�
    DEVICES_STATUS_CARD_FULL = 24,             //���ղֿ���

    
    /* ��բ�豸״̬�� 40~60*/
    DEVICES_STATUS_OPENING = 40,             //��բ���ڿ�
    DEVICES_STATUS_CLOSING = 41,             //��բ���ڹ�
    DEVICES_STATUS_OPENED  = 42,             //��բ����λ
    DEVICES_STATUS_CLOSED  = 43,             //��բ�ص�λ    
    DEVICES_STATUS_NOSIGNAL = 44,             //��բ���ź�
    DEVICES_STATUS_LOCK= 45,                 //��բ

    /* ֽƱ��ӡ��״̬ 61~90*/
    PP_STATUS_OFFLINE = 61,                   //�ѻ�
    PP_STATUS_PRINT_HEADER_UP,           // ��ӡͷ̧��       
    PP_STATUS_FEED_BUTTON_FEEDING,       //�����ý�ֽ����ֽ                      
    PP_STATUS_ONLINE_WAITING,            //�����ȴ�               
    PP_STATUS_FEED_BUTTON_ENABLE,        //������ֽʹ��Ϊ��           
    PP_STATUS_JAMR_PAPER_ERROR,          //��ֽ����
    PP_STATUS_CUT_PAPER_ERROR,           //�е�����
    PP_STATUS_AUTO_FEED_ERROR,           //�Զ���ֽ����
    PP_STATUS_EXIT_RECOVERY_ERROR,       //�пɻָ�����
    PP_STATUS_EXIT_AUTO_RECOVERY_ERROR,  //�п��Զ��ָ�����
    PP_STATUS_PULL_PAPER_ERROR,          //��ֽ����
    PP_STATUS_LESS_PAPER ,               //ֽ����
    PP_STATUS_NO_PAPER,                  //��ֽ
    PP_STATUS_PRINT_FAIL,                //��ӡʧ��
    PP_STATUS_PRINTING,                  //���ڴ�ӡ  
}EXTERNAL_DEVICES_STATUS;

typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1�����Ƿ����뱨��
    //0x2��բ��ʱδ�ر���
    //0x3����ѹ��Ȧ��ʱ����
    //0x4�����������޿���
    //0x5�����������ٿ���
    //0x6���������������쳣��
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//����豸����(EXTERNAL_DEVICES_TYPE)
    BYTE  byExternalDevStatus;//����豸����(EXTERNAL_DEVICES_STATUS)
    BYTE  byRes;
    NET_DVR_TIME_V30  struAlarmTime;//����ʱ��        
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
            /*��������0-���� 1-�̶�����2-��ʱ����3-Ԥ������4-���쳵��5-��Ȩ��*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//��struAlarmTypeΪ(0x1�����Ƿ����뱨��)
    }uAlarmInfo;
    BYTE  byRes2[64]; //Ԥ��
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;

typedef struct tagNET_DVR_ALARMWIRELESSINFO
{
    BYTE     byDeviceID[NAME_LEN];   //�豸ID
    float       fDataTraffic;    /* ��������,��λ��MB,С�������λ*/
    BYTE      bySignalIntensity;  /* �ź�ǿ�ȣ�0~100*/
    BYTE      byRes[127];
}NET_DVR_ALARMWIRELESSINFO, *LPNET_DVR_ALARMWIRELESSINFO;

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;            //A���ѹ
    int iPhaseBVol;            //B���ѹ
    int iPhaseCVol;            //C���ѹ
    int iAveragePhaseVol;    //���ѹƽ��ֵ
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;            //AB�ߵ�ѹ
    int iLineVolBC;            //BC�ߵ�ѹ
    int iLineVolCA;            //CA�ߵ�ѹ
    int iAverageLineVol;    //�ߵ�ѹƽ��ֵ
} NET_DVR_LINE_VOLTAGE,*LPNET_DVR_LINE_VOLTAGE;


//����
typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;            //A�����
    int iPhaseBCurrent;            //B�����
    int iPhaseCCurrent;            //C�����
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

//����
typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;            //A�๦��
    int iPhaseBPower;            //B�๦��
    int iPhaseCPower;            //C�๦��
    int iSysTotalPower;            //ϵͳ�ܹ���
}NET_DVR_POWER, *LPNET_DVR_POWER;

//��������
typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;     //A�๦������
    int iPhaseBPowerFactor;     //B�๦������
    int iPhaseCPowerFactor;     //C�๦������
    int iTotalPowerFactor;      //�ܹ�������
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

//Ƶ��
typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;        //A��Ƶ��
    int iPhaseBFrequency;        //B��Ƶ��
    int iPhaseCFrequency;        //C��Ƶ��
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

//������
typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;        //A�ฺ����
    int iPhaseBLoadFactor;        //B�ฺ����
    int iPhaseCLoadFactor;        //C�ฺ����
    BYTE    byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

//UPS״̬
typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE        struInputVoltage;    //�����ѹ
    NET_DVR_VOLTAGE        struBypassVoltage;    //��·��ѹ
    NET_DVR_VOLTAGE        struOutputVoltage;    //�����ѹ
    int iRectifierVol;            //��������ѹ
    int iInverterVol;            //�������ѹ
    
    NET_DVR_CURRENT    struInputCurrent;    //�������
    NET_DVR_CURRENT    struBypassCurrent;    //��·����
    NET_DVR_CURRENT    struOutputCurrent;    //�������
    int iInverterCurrent;        //���������
    
    NET_DVR_FREQUENCY    struInputFrequency;    //����Ƶ��
    NET_DVR_FREQUENCY    struBypassFrequency;    //��·Ƶ��
    NET_DVR_FREQUENCY    struOutputFrequency;    //���Ƶ��
    int iInverterFre;            //�����Ƶ��
    
    NET_DVR_POWER         struInputPower;    //���빦��
    NET_DVR_POWER        struBypassPower;    //��·����
    NET_DVR_POWER        struOutputPower;    //�������
    NET_DVR_POWER        struComplexPower;    //������
    
    int iNormalPower;            //��ƹ���
    int iPowerFacter;            //��������
    
    NET_DVR_LOAD_FACTOR    struBatteryLoadFactor;    //��ظ�����
    int iBatteryEstimated;        //��ر���ʱ��(min)
    int iBatteryTemperature;        //����¶�
    int iBatteryVoltage;            //��ص�ѹ
    
    
    BYTE    byRectifierState;        //����������״̬/*1���� 2�쳣*/
    BYTE    byInverterState;        //���������״̬/*1���� 2�쳣*/
    BYTE    byChargeState;        //���������״̬/*1���� 2�쳣*/
    BYTE    byBatteryState;        //�������״̬/*1���� 2�쳣*/
    BYTE    byAutoBypassState;    //�Զ���·״̬/*1���� 2�쳣*/
    BYTE    byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE; 

//���ص�Դ״̬
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE        struACVoltage;    //������ѹ
    int     iDCConvertVoltage;    //DCת������ѹ
    NET_DVR_CURRENT        struACCurrent;    //��������
    int     iTotalCurrent;            //�����ܵ���
    int     iBattery1Temperature;    //���1�¶�
    int     iBattery2Temperature;    //���2�¶�
    int     iBattery1Current;        //���1����
    int     iBattery2Current;        //���2����
    int     iBattery3Current;        //���3����
    int     iBattery4Current;        //���4����
    int     iBatteryTestVoltage;    //��ز��Ե�ѹ
    int     iRectifierOutputVoltage;    //����ģ�������ѹ
    int     iRectifierOutputCurrent;    //����ģ���������
    int     iDCOutputVoltage;        //ֱ�������ѹ
    BYTE    byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE, 
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE;

//����̽����״̬
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int        iSF6;            //SF6����λppm
    int      iFlow;           //������ml/min       
    int        iTemperature;        //�¶ȣ���λ���϶�
    int        iO2;            //��������λ%
    int        iHumidity;        //ʪ�ȣ���λ%
    BYTE    byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,
*LPNET_DVR_ALARMHOST_GAS_DETECTOR_STATE;

//��ʪ�ȴ�����״̬
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int        iTemperature;    //�¶ȣ���λ���϶�
    int        iHumidity;        //ʪ�ȣ���λ%
    BYTE    byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

//�յ�״̬
typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int        iTemperature;    //�¶ȣ���λ���϶�
    int        iHumidity;        //ʪ�ȣ���λ%
    BYTE   byRunState;        //����״̬ 1-������2-ͣ��
    BYTE    byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;


//������״̬
typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int        iDCVoltage;        //ֱ����ѹ
    int        iDCCurrent;        //ֱ������
    NET_DVR_VOLTAGE        struPhaseVoltage;    //���ѹ
    NET_DVR_LINE_VOLTAGE struLineVoltage;    //�ߵ�ѹ
    NET_DVR_CURRENT    struCurrent[4];        //������struCurrent[0]��ʾ��1·, �Դ����� 
    int iAverageCurrent;    //ƽ������
    int iNeutralCurrent;        //���ߵ���
    NET_DVR_POWER    struActivePower[4];    //�й����� struActivePower[0]��ʾ��һ·�й����ʣ��Դ�����
    NET_DVR_POWER    struReactivePower[4];    //�޹����� struReactivePower[0]��ʾ��һ·�޹����ʣ��Դ�����
    NET_DVR_POWER    struApparentPower[4];    //���ڹ��� struApprentPower[0]��ʾ��һ·���ڹ��ʣ��Դ�����
    NET_DVR_POWER_FACTOR    struPowerFactor[4];    //����������struPowerFactor[0]��ʾ��һ·�����������Դ�����
    NET_DVR_FREQUENCY        struFrequency;            //Ƶ��
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

//��������Ա�״̬
typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int        iPhaseATemperature;        //A���¶�
    int        iPhaseBTemperature;        //B���¶�
    int        iPhaseCTemperature;        //C���¶�
    int        iPhaseDTemperature;        //D���¶�
    BYTE     byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;

//ˮλ������
typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG        iWaterLevel;        //ˮλ
    BYTE        byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

//�ﳾ����������
typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG        iDust;        //�ﳾ
    LONG        iNoise;       //����
    LONG        iPM25;        //PM2.5
    BYTE        byRes[500];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

//�����ɼ���
typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG        iAmmoniaNitrogen;    //����
    LONG        iCOD;                //COD
    LONG        iPH;                //PH
    LONG        iOxygen;            //����
    LONG        iSulfurDioxide;    //��������
    LONG        iSoot;            //�̳�
    LONG        iFluoride;        //������
    LONG        iPollutedWater;    //��ˮ
    LONG        iTotalPhosphorus;    //����
    LONG        iExhaust;            //����
    LONG        iNitrogenOxides;    //��������
    LONG        iFlueGasTemperature;//�����¶�
    LONG        iFlueGasPressure;    //����ѹ��
    LONG 		iDustThickness; /*�۳�Ũ��*/
    LONG 		iAirCleanLevel; /*�����ྻ�ȵȼ�*/
    LONG 		iPm10Thickness; /*PM10Ũ��*/
    BYTE	    byRes[448];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;

//���ٴ�����״̬
typedef struct
{
    int  iWindSpeed; /*����*/
    BYTE   byRes[508];
}NET_DVR_WIND_SPEED_STATE, *LPNET_DVR_WIND_SPEED_STATE;

//ͨ����չ���ģ��״̬��48·��ÿλ��ʾ1·��0��ʾ�أ�1��ʾ����
typedef struct
{
    BYTE byOutPutState1; /*output1-8*/
    BYTE byOutPutState2; /*output9-16*/
    BYTE byOutPutState3; /*output17-24*/
    BYTE byOutPutState4; /*output25-32*/
    BYTE byOutPutState5; /*output33-40*/
    BYTE byOutPutState6; /*output41-48*/
    BYTE Res[506];
}NET_DVR_GENERATE_OUTPUT_STATE, *LPNET_DVR_GENERATE_OUTPUT_STATE;

//��ˮ������״̬
typedef struct
{
    int  iWaterLogVal;      /* й¶λ�ã�100��*/
    int  iLeakResist1;      /*��һ·©ˮ����*/
    int  iTotolResist1;     /*��һ·�ܵ���*/
    int  iLeakResist2;      /*�ڶ�·©ˮ����*/
    int  iTotolResist2;     /*�ڶ�·�ܵ���*/
    BYTE   byWaterLogAlarm;    /* й©����1��������2���澯*/
    BYTE   byLeakAlarm1;       /*��һ·©ˮ�澯1��������2���澯*/
    BYTE   byFaultAlarm1;      /*��һ·���ϸ澯1��������2���澯*/
    BYTE   byLeakAlarm2;       /*�ڶ�·©ˮ�澯1��������2���澯*/
    BYTE   byFaultAlarm2;      /*�ڶ�·���ϸ澯1��������2���澯*/
    BYTE   byRes[487];
}NET_DVR_SOAK_STATE, *LPNET_DVR_SOAK_STATE;

//̫���ܿ�����״̬
typedef struct
{
    int  iChangerVolInput;          /*����豸�����ѹ*/
    int  iChangerCurInput;          /*����豸�������*/
    int  iChangerPwInput;           /*����豸���빦��*/
    int  iChangerVolOutput;         /*����豸�����ѹ*/
    int  iChangerCurOutput;         /*����豸�������*/
    int  iChangerPwOutput;          /*����豸�������*/
    int  iDischangerVolOutput;      /*�ŵ��豸�����ѹ*/
    int  iDischangerCurOutput;      /*�ŵ��豸�������*/
    int  iDischangerPwOutput;       /*�ŵ��豸�������*/
    int  iDevTemperatrue;           /*�豸���¶�*/
    BYTE   byBatteryVolState;          /*���ص�ѹ״̬1��������2���쳣*/
    BYTE   byBatteryTmpState;          /*�����¶�״̬1��������2���쳣*/
    BYTE   byChangerVolInputState;     /*����豸�����ѹ״̬1��������2���쳣*/
    BYTE   byChangerRunState;          /*����豸����״̬1��������2������*/
    BYTE   byChangerChgState;          /*����豸���״̬1��������2���쳣*/
    BYTE   byBatteryVolFlt;            /*���ص�ѹ����1��������2���澯*/
    BYTE   byBatteryTmpFlt;            /*�����¶��쳣1��������2���澯*/
    BYTE   byBatteryResistanceFlt;     /*���������쳣1��������2���澯*/
    BYTE   byVolRcgFlt;                /*���ѹʶ�����1��������2���澯*/
    BYTE   byChangerVolInputFlt;       /*����豸�����ѹ�쳣1��������2���澯*/
    BYTE   byChangerMosShort;          /*���MOS�ܶ�·1��������2���澯*/
    BYTE   byChangerAntiOrMosShort;    /*�������MOS�ܶ�·1��������2���澯*/
    BYTE   byChangerAntiShort;         /*����MOS�ܶ�·1��������2���澯*/
    BYTE   byInputOverCur;             /*�������1��������2���澯*/
    BYTE   byLoadOverCur;              /*���ع���1��������2���澯*/
    BYTE   byLoadShort;                /*���ض�·1��������2���澯*/
    BYTE   byLoadMosShort;             /*����MOS�ܶ�·1��������2���澯*/
    BYTE   byChangerFlt;               /*����豸����1��������2���澯*/
    BYTE   byRes[454];
}NET_DVR_SOLAR_POWER_STATE, *LPNET_DVR_SOLAR_POWER_STATE;

//SF6��������״̬
typedef struct
{
    int  iSf6Thick1;    /*��һ��SF6Ũ��*/
    int  iO2Thick1;     /*��һ������Ũ��*/
    int  iTemprature1;  /*��һ���¶�*/
    int  iHumidity1;    /*��һ��ʪ��*/
    int  iSf6Thick2;    /*�ڶ���SF6Ũ��*/
    int  iO2Thick2;     /*�ڶ�������Ũ��*/
    int  iTemprature2;  /*�ڶ����¶�*/
    int  iHumidity2;    /*������ʪ��*/
    int  iSf6Thick3;    /*������SF6Ũ��*/
    int  iO2Thick3;     /*����������Ũ��*/
    int  iTemprature3;  /*�������¶�*/
    int  iHumidity3;    /*������ʪ��*/
    int  iSf6Thick4;    /*���ĵ�SF6Ũ��*/
    int  iO2Thick4;     /*���ĵ�����Ũ��*/
    int  iTemprature4;  /*���ĵ��¶�*/
    int  iHumidity4;    /*���ĵ�ʪ��*/
    int  iSf6Thick5;    /*�����SF6Ũ��*/
    int  iO2Thick5;     /*���������Ũ��*/
    int  iTemprature5;  /*������¶�*/
    int  iHumidity5;    /*�����ʪ��*/
    int  iSf6Thick6;    /*������SF6Ũ��*/
    int  iO2Thick6;     /*����������Ũ��*/
    int  iTemprature6;  /*�������¶�*/
    int  iHumidity6;    /*������ʪ��*/
    int  iSf6Thick7;    /*���ߵ�SF6Ũ��*/
    int  iO2Thick7;     /*���ߵ�����Ũ��*/
    int  iTemprature7;  /*���ߵ��¶�*/
    int  iHumidity7;    /*���ߵ�ʪ��*/
    int  iSf6Thick8;    /*�ڰ˵�SF6Ũ��*/
    int  iO2Thick8;     /*�ڰ˵�����Ũ��*/
    int  iTemprature8;  /*�ڰ˵��¶�*/
    int  iHumidity8;    /*�ڰ˵�ʪ��*/
    int  iSf6Thick9;    /*�ھŵ�SF6Ũ��*/
    int  iO2Thick9;     /*�ھŵ�����Ũ��*/
    int  iTemprature9;  /*�ھŵ��¶�*/
    int  iHumidity9;    /*�ھŵ�ʪ��*/
    int  iSf6Thick10;   /*��ʮ��SF6Ũ��*/
    int  iO2Thick10;    /*��ʮ������Ũ��*/
    int  iTemprature10; /*��ʮ���¶�*/
    int  iHumidity10;   /*��ʮ��ʪ��*/
    int  iSf6Thick11;   /*��ʮһ��SF6Ũ��*/
    int  iO2Thick11;    /*��ʮһ������Ũ��*/
    int  iTemprature11; /*��ʮһ���¶�*/
    int  iHumidity11;   /*��ʮһ��ʪ��*/
    int  iSf6Thick12;   /*��ʮ����SF6Ũ��*/
    int  iO2Thick12;    /*��ʮ��������Ũ��*/
    int  iTemprature12; /*��ʮ�����¶�*/
    int  iHumidity12;   /*��ʮ����ʪ��*/
    BYTE   byFanState1;    /*���״̬1 1�����У�2��ֹͣ*/
    BYTE   byFanState2;    /*���״̬2 1�����У�2��ֹͣ*/
    BYTE   byFanState3;    /*���״̬3 1�����У�2��ֹͣ*/
    BYTE   byFanState4;    /*���״̬4 1�����У�2��ֹͣ*/
    BYTE   byFanState5;    /*���״̬5 1�����У�2��ֹͣ*/
    BYTE   byFanState6;    /*���״̬6 1�����У�2��ֹͣ*/
    BYTE   byFanState7;    /*���״̬7 1�����У�2��ֹͣ*/
    BYTE   byFanState8;    /*���״̬8 1�����У�2��ֹͣ*/
    BYTE   byFanState9;    /*���״̬9 1�����У�2��ֹͣ*/
    BYTE   byFanState10;   /*���״̬10 1�����У�2��ֹͣ*/
    BYTE   byFanState11;   /*���״̬11 1�����У�2��ֹͣ*/
    BYTE   byFanState12;   /*���״̬12 1�����У�2��ֹͣ*/
    BYTE   byRes[308];
}NET_DVR_SF6_ALARMHOST_STATE, *LPNET_DVR_SF6_ALARMHOST_STATE;

//������״̬
typedef struct
{
    int  iWeight;   /*����ֵ,1000��*/
    BYTE   byRes[508];
}NET_DVR_WEIGHT_STATE, *LPNET_DVR_WEIGHT_STATE;

//����ɼ�ϵͳ״̬
typedef struct
{
    int  iAirTemperature;              /* �����¶�*/
    DWORD  dwAirHumidity;              /* ����ʪ��*/
    DWORD  dwWindSpeed;                /* ����*/
    DWORD  dwWindDirection;            /* ����*/
    DWORD  dwIlluminationIntensity;    /* ����ǿ��*/
    DWORD  dwCO2;                      /* co2Ũ��*/
    DWORD  dwPM25;                     /* PM2.5Ũ��*/
    DWORD  dwAirPressure;              /* ����ѹ��*/
    int  iSoilTemperature;             /* �����¶�*/
    DWORD  dwSoilHumidity;             /* ����ʪ��*/
    DWORD  dwRainFall;                 /*������*/
    BYTE   byIsRainSnow;               /* ��ѩ�����1-����ѩ��2-����ѩ*/
    BYTE   byRes[467];
}NET_DVR_WEATHER_STATION_STATE, *LPNET_DVR_WEATHER_STATION_STATE;

//ˮ�ʼ����״̬
typedef struct
{
    DWORD  dwTurbidity;    /* �Ƕ�ֵ*/
    DWORD  dwChlorine;     /* ����ֵ*/
    DWORD  dwPH;           /* PH ֵ*/
    BYTE   byRes[500];
}NET_DVR_WATER_QLT_STATE, *LPNET_DVR_WATER_QLT_STATE;

//ȼ�����ϵͳ״̬
typedef struct
{
    int  iNatrualGasThick;  /* ��Ȼ��Ũ��*/
    BYTE   byRes[508];
}NET_DVR_FUEL_GAS_DETE_STATE, *LPNET_DVR_FUEL_GAS_DETE_STATE;

//���������豸
typedef struct tagNET_DVR_FIRE_ALARM_STATUS
{
    BYTE  byFireAlarm[MAX_FIRE_ALARM_ZONE][MAX_FIRE_ALARM_POINT_ZONE];           //���״̬����λ��1-������2-�澯
    BYTE  byRes[128];   //����λ
}NET_DVR_FIRE_ALARM_STATUS, *LPNET_DVR_FIRE_ALARM_STATUS;

typedef union tagNET_DVR_EXTERNAL_DEVICE_STATE_UNION
{
    NET_DVR_ALARMHOST_UPS_STATE struUpsState;        //UPS״̬
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE struSwitchPowerState;//���ص�Դ״̬
    NET_DVR_ALARMHOST_GAS_DETECTOR_STATE struGasDetectorState;//������ϵͳ״̬
    NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE struTempHumiSensorState;//��ʪ�ȴ�����״̬
    NET_DVR_ALARMHOST_AIRCONDITION_STATE struAirConditionState;//�յ�״̬
    NET_DVR_ALARMHOST_ELECTRICITY_STATE struElectricityState;//������״̬
    NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE struTransformerTempState;    //�����״̬
    NET_DVR_ALARMHOST_WATERLEVEL_SENSOR struWaterLevelSensor;//ˮλ������
    NET_DVR_ALARMHOST_DUSTNOISE_SENSOR struDustNoiseSensor;//�ﳾ����������
    NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER struEnvironmentLogger;//�����ɼ���
    NET_DVR_WIND_SPEED_STATE struWindSpeedState; //���ٴ�����״̬
    NET_DVR_GENERATE_OUTPUT_STATE struGenerateOutputState; //ͨ����չ���ģ��״̬��48·��ÿλ��ʾ1·��
    NET_DVR_SOAK_STATE struSoakState; //��ˮ������״̬
    NET_DVR_SOLAR_POWER_STATE struSolarPowerState; //̫���ܿ�����״̬
    NET_DVR_SF6_ALARMHOST_STATE struSF6AlarmHostState; //SF6��������״̬
    NET_DVR_WEIGHT_STATE struWeightState; //������״̬
    NET_DVR_WEATHER_STATION_STATE struWeatherStationState; //����ɼ�ϵͳ״̬
    NET_DVR_WATER_QLT_STATE struWaterQltState; //ˮ�ʼ����״̬
    NET_DVR_FUEL_GAS_DETE_STATE struFuelGasDeteState; //ȼ�����ϵͳ״̬
    NET_DVR_FIRE_ALARM_STATUS struFireAlarmStatus; //���������豸״̬
    BYTE    byRes[512];
} NET_DVR_EXTERNAL_DEVICE_STATE_UNION, *LPNET_DVR_EXTERNAL_DEVICE_STATE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS��2-���ص�Դ��3-������ϵͳ��4-��ʪ�ȴ�������5-�յ���6-������7-�����״̬, 8-ˮλ��������9-�ﳾ������������10-�����ɼ��ǡ�11-���ٴ�����״̬��12-ͨ����չ���ģ��״̬��13-��ˮ������״̬��14-̫���ܿ�����״̬��15-SF6��������״̬��16-������״̬��17-����ɼ�ϵͳ״̬��18-ˮ�ʼ����״̬��19-ȼ�����ϵͳ״̬��20-��������״̬
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE    byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;

//ͨ����չ���ģ����ƣ�48·��ÿλ��ʾ1·��
typedef struct
{
    DWORD dwSize;
    BYTE byOutPutState1; /*output1-8*/
    BYTE byOutPutState2; /*output9-16*/
    BYTE byOutPutState3; /*output17-24*/
    BYTE byOutPutState4; /*output25-32*/
    BYTE byOutPutState5; /*output33-40*/
    BYTE byOutPutState6; /*output41-48*/
    BYTE byOperateType; //�������ͣ�0-��Ч��1-����2-��
    BYTE Res[65];
}NET_DVR_GENERATE_OUTPUT_CTRL, *LPNET_DVR_GENERATE_OUTPUT_CTRL;

//UPS������ֵ
typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;        //Խ�������ѹֵ(��ֵ)
    int iInputVolLow;        //Խ�������ѹֵ(��ֵ)
    int iInputFreHigh;        //Խ������Ƶ��ֵ(��ֵ)
    int iInputFreLow;        //Խ������Ƶ��ֵ(��ֵ)
    int iOutputVolHigh;    //Խ�������ѹֵ(��ֵ)
    int iOutputVolLow;        //Խ�������ѹֵ(��ֵ)
    int iBatteryVoltageLow;    //��ص͵�ѹ��ֵ
    int iBatterySurplus;        //��غ�ʱ��� ��ֵ
    int iBatteryTemperatureHigh;//����¶ȸ���ֵ
    BYTE    byRes[64];            //����
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

//��ʪ�ȴ�������ֵ
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;    //�¶ȸ���ֵ����λ���϶�
    int iTemperatureLowLimit;    //�¶ȵ���ֵ����λ���϶�
    int iHumidityHighLimit;        //ʪ�ȸ���ֵ����λ%
    int iHumidityLowLimit;        //ʪ�ȵ���ֵ����λ%
    BYTE    byRes[84];        
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;

typedef union tagNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION
{
    NET_DVR_ALARMHOST_UPS_LIMIT_VALUE struUpsLimitValue;
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE struTempHumidityLimitValue;
}NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION,*LPNET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION;

typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS��2-��ʪ�ȴ�����
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE    byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

#define    ALARMHOST_ALARMOUT_NUM    64  //����������
#define  MAX_OSD_UNIT_LEN   8    //OSD��λ����
typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD         dwSize;
    BYTE        bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];//ģ����������������0-��������1-����
    BYTE        bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];//ģ������������
    BYTE        bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//ģ�������������������������ֶ���bySensorJointAlarmOut����չ�������±��ʾ�������ţ�����Ԫ�ص�ֵ��λ��ʾ�������ͣ��������ͼ���"��"�Ĺ�ϵ������ֵ���壺1bit0-��1��bit1-��2��bit2-��3��bit3-��4��bit4-����
    BYTE        bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //ģ�����������������ţ����ֶ���bySensorJointSiren����չ�������±��ʾ������ţ�����Ԫ�ص�ֵ��λ��ʾ�������ͣ��������ͼ���"��"�Ĺ�ϵ������ֵ���壺bit0-��1��bit1-��2��bit2-��3��bit3-��4��bit4-����
    BYTE        byChan;        //ͨ����
    BYTE        byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

//UPS������Ϣ�ϴ�
typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE    byAlarmType;/*�������ͣ�1.A�������ѹԽ�� 2.B�������ѹԽ�� 3.C�������ѹԽ�� 4.A�������ѹԽ��5.B�������ѹԽ�� 6.C�������ѹԽ��7.A������Ƶ��Խ�� 8.B������Ƶ��Խ��9.C������Ƶ��Խ��10.��������ѹԽ�ޱ��� 11.���ر��� 12.��ص�ѹ�ͱ��� 13.��غ�ʱ�䳬�ͱ��� 14.����¶ȳ��߱��� 15.������رձ��� 16.�Զ���·������ 17.���������ϱ��� 18.��������ϱ��� 19.��������ϱ���    20.��ع��ϱ���     21.�Զ���·���ϱ��� */    
    BYTE    byChanNo;    //485ͨ���ţ���1��ʼ
    BYTE    bySlotNo;    //485�����λ��
    BYTE    byRes1;        //����
    int        iAlarmValue;//����ֵ
    BYTE    byRes2[64];        //����
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

//���ص�Դ�����ϴ�
typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE    byAlarmType;    /*�������ͣ�1-��ز���ʧ�� 2-AC-DCת�������ϣ�3-������/���ѹAB/AԽ�ޣ�4-������/���ѹBC/BԽ�ޣ�5-������/���ѹCA/CԽ�ޣ�6-�������AԽ�ޣ�7-�������BԽ�ޣ�8-�������CԽ�ޣ�9����ģ����ϣ�10-���ȹ��ϣ�11-ֱ����ѹԽ��*/
    BYTE    byChanNo;        //485ͨ���ţ���1��ʼ
    BYTE    bySlotNo;        //485�����λ��
    BYTE    byRes1;
    int     iAlarmValue;        //����ֵ
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO, 
*LPNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO;

//������ϵͳ����
typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE    byAlarmType;    /*�������ͣ�1- SF6���庬���쳣��2-���������쳣��3-�¶�ֵ�쳣��4-ʪ��ֵ�쳣��5-����*/
    BYTE    byChanNo;    //485ͨ���ţ���1��ʼ
    BYTE    bySlotNo;    //485�����λ��
    BYTE    byRes1;
    int     iAlarmValue;        //����ֵ
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO, 
*LPNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO;


//��ʪ�ȴ���������
typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE    byAlarmType;    //1-�¶��쳣��2-ʪ���쳣
    BYTE    byChanNo;        //485ͨ����
    BYTE    bySlotNo;        //485��λ��
    BYTE    byRes1;
    int         iAlarmValue;    //����ֵ
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;

typedef union  tagNET_DVR_485_DEVICE_ALARM_UNION
{
    NET_DVR_ALARMHOST_UPS_ALARMINFO struUPSAlarm; //UPS����
    NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO struSwitchPowerAlarm; //���ص�Դ����
    NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO struGasDetectSystemAlarm; //������ϵͳ����
    NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO struTempHumiditySensorAlarm; //��ʪ�ȴ���������
    BYTE    byRes[72];
} NET_DVR_485_DEVICE_ALARM_UNION, *LPNET_DVR_485_DEVICE_ALARM_UNION;

//485����豸������Ϣ
typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE    byAlarmType;    //1-UPS������2-���ص�Դ������3-������ϵͳ������4-��ʪ�ȴ���������
    BYTE    byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE    byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD       dwSize;              // �ṹ���С
    BYTE        sDeviceName[NAME_LEN];      // ǰ���豸���� 
    WORD        wDeviceType;            // ǰ���豸����ALARM_FRONT_DEVICE _TYPE
    WORD        wDeviceProtocol;     // ǰ���豸Э�� ͨ����ȡЭ���б��ȡ
    WORD        wAddress;            //�豸��ַ    
    BYTE        byChannel;          //485ͨ����
    BYTE        bySlotChan;         //��λ��
    BYTE        byRes[60];          // �����ֽ�
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

//����ģʽ
typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD        dwSize;
    BYTE        byEnableCorridorMode; //�Ƿ���������ģʽ 0�������ã� 1������
    BYTE        byMirrorMode;            //����ʽ��0 �ر�;1 ����;2 ����;3 �м� 
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

//�������
typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD     dwSize;
    BYTE     byEnableDetectFace; //�Ƿ����� 0�������ã� 1������
    BYTE     byDetectSensitive; //������ 10���ȼ� 1��10
    BYTE     byEnableDisplay;    /*�����ƶ���������ʾ��0-��1-��*/
    BYTE     byRes;
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*����ʽ*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ�� */
    DWORD    dwMaxRelRecordChanNum;     //����������¼��ͨ�� ����ֻ�������֧������
    DWORD    dwRelRecordChanNum;     //����������¼��ͨ���� ʵ��֧����
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];    /* ����������¼��ͨ��*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    WORD     wDuration;  //��������ʱ�� 5s ������
    BYTE     byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD        dwSize;                 // �ṹ���С
    DWORD       dwGroup ;             //���
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //����������
    BYTE         byRes[64] ;        
}NET_DVR_MUL_STREAM_CHANNEL_GROUP,*LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD        dwSize;       // �ṹ���С
    DWORD       dwChannel; //ͨ����
    DWORD       dwGroup;   //��� 
    BYTE        byID;      //�豸��������ID
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //����λ��������,IPC��0��IPD�Ǵ�1��ʼ
    BYTE        byRes[56];              
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;


typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //ʱ��
    BYTE   byDetSceneID;//��ⳡ����[1,4],IPCĬ����0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION,*LPNET_DVR_TIME_DETECTION;

//ץ�Ĵ���ģʽ֧�ֹ�������ʱ��κ��ϴ���������
typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    /*
    0��ʾ��Ч�� 
    1��ʾ���� ץ��VIAģʽ����Ƶ����ץ�� IPCʹ�ã�;
    2 ��ʾ���� ץ�� HVT ģʽ ���쿨IPCʹ�ã�
    */
    BYTE   byRelateType; 
    BYTE   byGroupNo;  //���
    BYTE   byRes[62];
}NET_DVR_GUARD_COND,*LPNET_DVR_GUARD_COND;

//ץ�Ĵ���ģʽ֧�ֹ�������ʱ��κ��ϴ�����
typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //����ʱ��
    NET_DVR_TIME_DETECTION    struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //������ʵ�ʴ�����¼��ͨ����
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];    //����������¼��ͨ��(0xffff ffff��ʾ������Ч��
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ�� 
    BYTE   byDirection;//��������0-������1-ȫ����2-����3-����
    BYTE   byRes[87];
}NET_DVR_GUARD_CFG,*LPNET_DVR_GUARD_CFG;

//ץ��ͼƬ����������չ�����ṹ
typedef    struct  tagNET_DVR_SNAPINFO_COND_
{
    DWORD    dwSize; 
    DWORD    dwChan;
    /*
    0 ��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
    1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE     byRelateType;
    BYTE     byRes[63];        //����
}NET_DVR_SNAPINFO_COND, *LPNET_DVR_SNAPINFO_COND;


//ץ��ͼƬ��������
typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0-��ʾ��ͼƬ������1-��ʾͼƬ��С
    BYTE  byPicQuality;//ͼƬ����[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//ͼƬ��С[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG,*LPNET_DVR_SNAPINFOCFG;

//ptz���ٷ�ʽ
typedef enum _PTZ_TRACK_MODE_
{
    PTZ_TRACK_MODE_ALWAYS  = 1,   //һֱ����
        PTZ_TRACK_MODE_BYTIME  = 2,   //����ָ��ʱ��
        PTZ_TRACK_MODE_NEXT    = 3,   //������һĿ��
}PTZ_TRACK_MODE;

//ptz���ٲ���
typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //�ṹ���С
    BYTE  byTrackMode; //���ٷ�ʽ,�ο�PTZ_TRACK_MODE
    BYTE  byLinkageTarget; //����Ŀ��0-Ĭ��,1-���1,2-���2��..��������
    BYTE  byAutoTrackEnable;//����ʹ�� 0-�Զ����ٿ�����1-�Զ����ٹرգ�ǹ���豸��֧���Զ����ٹرչ��ܣ����ڴ�������չ��
    BYTE  byRes1; //����
    DWORD dwTrackTime; //����ʱ�䣬
    //������ģʽΪPTZ_TRACK_MODE_ALWAYS�����ֶ���Ч
    //������ģʽΪPTZ_TRACK MODE_BYTIMEʱ����Χ[1,60]��Ĭ��10��
    //������ģʽΪPTZ_TRACK MODE_NEXTʱ����Χ[1,10]��Ĭ��2��
    BYTE  byRes2[256]; //����
}NET_DVR_PTZ_TRACK_PARAM,*LPNET_DVR_PTZ_TRACK_PARAM;

typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD dwSize;
    BYTE    byEnable;//ʹ��
    BYTE    byEnableDualVca;// ����֧�����ܺ���� 0-�����ã�1-����
    BYTE    byEnableHumanMisinfoFilter;// ��������ȥ�� 0-�����ã�1-����
    BYTE    byEnableVehicleMisinfoFilter;// ���ó���ȥ�� 0-�����ã�1-����
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];  //�����߲���
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//����¼���ͨ����
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;


typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable; //ʹ�ܣ��Ƿ���
    BYTE byEnableDualVca;// ����֧�����ܺ���� 0-�����ã�1-����
    BYTE byEnableHumanMisinfoFilter;// ��������ȥ�� 0-�����ã�1-����
    BYTE byEnableVehicleMisinfoFilter;// ���ó���ȥ�� 0-�����ã�1-����
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];//ÿ������Ĳ�������
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //����ʱ��
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    DWORD  dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD  dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //���ղ���ʱ��
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;    //�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    DWORD   dwRoiFixNum; //�̶�����������ȷ�������ٴλ�ȡ�����
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC����֧��4�����������֧��24��
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//�̶�ROI��������
    DWORD   dwRoiTrackNum; //�Զ���������������ȷ�������ٴλ�ȡ�����
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC����֧��4�����������֧��24��
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;

typedef  enum  _DETECT_ROI_TYPE_
{
    DETECT_FIX_ROI  =  0, //���ROI�̶�����
        DETECT_TRACK_ROI = 1 //���ROI �Զ���������
}DETECT_ROI_TYPE;
//��������
typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //������� һ��PTZ֧��4�� 
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //����������
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE ��ֵ
    BYTE    byRoiDetectTrackType;//�̶�����ʱ�����ֶ���Ч����������ʱ��1��������⣨IPC��,2���ƶ��������,3-���Ƹ���
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND,*LPNET_DVR_ROI_DETECT_COND;

//���ò���
//ROI�̶�����ģʽ ������빦��
typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI�̶�����ģʽ �Ƿ����� 0�������ã� 1������
    BYTE  byImageQualityLevel; //ͼ�����������ȼ� 1��6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;  //ROI����
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;

//ROI�Զ�����ģʽ ������빦��  
typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI�Զ�����ģʽ �Ƿ����� 0�������ã� 1������
    BYTE  byImageQualityLevel; //ͼ�����������ȼ� 1��6
    BYTE  byModeType;// 0 ~ ��, 1������ģʽ(�ƶ��;�ֹ������), 2~�ƶ��������(�ƶ�������), 3-���Ƹ���
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;

typedef union tagNET_DVR_ROI_DETECT_UNION
{
    DWORD                        uLen[128];   
    NET_DVR_ROI_FIX_RECT_CFG    strRoiFixRectCfg;//�̶�����ģʽ
    NET_DVR_ROI_TRACK_RECT_CFG  strRoiTrackRectCfg;//�Զ�����ģʽ
}NET_DVR_ROI_DETECT_UNION,*LPNET_DVR_ROI_DETECT_UNION;

typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;  //560
    DWORD       dwStreamType;    //�������ͣ�0-��������1-��������2-�¼����ͣ�3-����3������
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE ��ֵ 
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo; //ROI�������
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

//�齹���
typedef struct tagNET_VCA_DEFOCUSPARAM
{    
    DWORD dwSize;
    BYTE byEnable;//ʹ��
    BYTE  bySensitiveLevel;// 1-100��Ĭ��50��������Խ�ߣ�Խ���ױ���
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM,*LPNET_VCA_DEFOCUSPARAM;

typedef struct tagNET_PTZ_INFO_EX
{
    float fPan;//Pֵ ��ȷ��С�����3λ ��Χ[0,360.000]
    float fTilt; //Zֵ ��ȷ��С�����3λ ��Χ[-90.000,90.000]
    float fVisibleZoom;//�ɼ���zoom ��ȷ��С�����1λ ���ᳬ��[0��10000.0]
    DWORD dwVisibleFocus;//�ɼ���focus[0,65535]
    float fThermalZoom;//�ȳ���zoom ��ȷ��С�����1λ ���ᳬ��[0��10000.0]
    DWORD dwThermalFocus;//�ȳ���focus[0,65535]
}NET_PTZ_INFO_EX, *LPNET_PTZ_INFO_EX;

//IPC5.1.0  
typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD wPresetNum; //Ԥ�õ���
    BYTE byRes1[2]; //�ֽڶ��� 
    char byName[NAME_LEN];
    WORD wPanPos;//ˮƽ���� �����ȡ�������ݴ���360Ĭ�ϼ�ȥ360
    WORD wTiltPos;//��ֱ���� �����ȡ�������ݴ���360Ĭ�ϼ�ȥ360
    WORD wZoomPos;//�䱶���������ȡ�������ݴ���360Ĭ�ϼ�ȥ360
    BYTE byRes2;
    BYTE byPTZPosExEnable; /*�Ƿ�����PTZ������չ��0~�����ã�PTZ����ֵ��wPanPos��wTiltPos��wZoomPosΪ׼��1~���ã�PTZ����ֵ��struPtzPosExΪ׼*/
    NET_PTZ_INFO_EX struPtzPosEx;// ptz������չ(֧�ָ߾���PTZֵ)
    BYTE byRes[32];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;

typedef struct
{
    NET_DVR_SCHEDTIME struSchedTime; //ʱ��
    WORD  wAction;  ///< ��ʱ�������嶯��
    WORD  wActionNum; ///< ���⶯���ӱ�ţ���Ԥ�õ㣬Ѳ���������������������ҹ�л���
    BYTE byres[12];
}NET_DVR_SCHEDTASK,* LPNET_DVR_SCHEDTASK;

//��ʱ����
typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///< ʹ�� 1-����0-��
    BYTE byRes[3];    ///< �ֽڶ���
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];    ///< 7�죬ÿ��10ʱ���
    DWORD dwParkTime;   ///< ����ʱ�� 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK,*LPNET_DVR_TIME_TASK;

//�����ṹ��
typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;                 // �ṹ���С
    DWORD dwChannel ;           //ͨ����
    DWORD dwIndex ;             //������
    BYTE  byRes[64] ;        
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;                 // �ṹ���С
    char  cName[NAME_LEN] ;          //����
    BYTE  byRes[64];          
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

//��¼�豸����
typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{    
    DWORD  dwSize;       //�ṹ���С
    BYTE   byMobileDev;  //�豸����, 0- ���ƶ��豸, 1 - �ƶ��豸
    BYTE   byRes[63];    //����                    
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;

typedef enum RECV_DATA_TYPE
{ 
    ENUM_RECV_ERRCODE = 0x0, //���ش�����
} RECV_DATA_TYPE;

//�������ģʽ
typedef enum tagFISHEYE_STREAM_OUTPUT_MODE_
{
    FISHEYE_STREAM_MODE_FISHEYE    = 1,   //����ģʽ
        FISHEYE_STREAM_MODE_PTZ        = 2,   //PTZģʽ
        FISHEYE_STREAM_MODE_PANORAMA   = 3    //ȫ��ģʽ
}FISHEYE_STREAM_OUTPUT_MODE;

//�ص���������ö��
typedef enum _CALLBACK_TYPE_DATA_ENUM_
{
    ENUM_FISHEYE_STREAM_STATUS   = 1,  //�����������״̬
        ENUM_FISHEYE_PTZPOS          = 2,  //ptzͨ����ǰ��������ģʽ�µ�����
        ENUM_FISHEYE_REALTIME_OUTPUT = 3   //ʵʱ���ģʽ
}CALLBACK_TYPE_DATA_ENUM;

//��������״̬
typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{   
    DWORD  dwSize;        //�ṹ���С 
    BYTE   byStreamMode;  //�������ģʽ���μ�FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //����
}NET_DVR_FISHEYE_STREAM_STATUS,*LPNET_DVR_FISHEYE_STREAM_STATUS;

//�����ӻص����ݽṹ��
typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{   
    DWORD  dwChannel;      //ͨ����
    DWORD  dwDataType;     //�μ�CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //���ݳ���
    BYTE*  pData;          //���ݣ���dwTypeDataΪ ENUM_FISHEYE_STREAM_STATUS�����ӦΪNET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //����    
}NET_DVR_CALLBACK_TYPE_DATA,*LPNET_DVR_CALLBACK_TYPE_DATA;

//����ptz�϶�����
typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD          dwChannel;      //ͨ����
    DWORD          dwPtzChannel;   //��dwChannel��ָͨ��ģʽΪFISHEYE_STREAM_MODE_FISHEYE������ģʽʱ������ֵΪ���϶���������ptzͨ������dwChannelͨ��ģʽΪ������ʱ����Ϊ0����
    NET_VCA_POINT  struToPoint;    //�϶�����Ҫ��ת����Ŀ��㣬Ŀ���λ�������Ԥ����������Ͻ�
    NET_VCA_POINT  struOriPoint;   //�϶�������ʼ��,�˵�Ϊ�����϶�������ʼʱ�����ָ�������Ԥ���������Ͻǵ�λ��
    BYTE           byRes[56];      //����
}NET_DVR_DRAG_POS_PARAM,*LPNET_DVR_DRAG_POS_PARAM;

//ƽ̨��ѯ��Ϸ�������״̬
typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad;       //CPU��Դռ�����, ȡֵ��Χ��0-100
    BYTE       byMemLoad;      //Memory��Դռ�������ȡֵ��Χ��0-100
    WORD       wAbility;      //��Ϸ�����������������0
    WORD       wRemainAbility;//��Ϸ�����ʣ��������ȡֵ��Χ������ 0  ʣ���ص�ĸ���
    WORD       wTotalPlanNum; //���64���ƻ�>
    WORD       wCurPlanNum;   //��ǰ�ƻ���  ���64���ƻ�>
    BYTE       byRes[62];     //����
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;            //�Ƿ�����     
    BYTE   byDevType;             //�豸���ͣ�0-����̨�豸��1-����̨�豸
    BYTE   bySignalPoint;       //�źŶ�ʧ��ֵ��0-100
    BYTE   byBlurPoint;         //ͼ��ģ����ֵ��0-100
    BYTE   byLumaPoint;         //ͼ�������ֵ��0-100
    BYTE   byChromaPoint;       //ͼ��ƫɫ��ֵ��0-100
    BYTE   bySnowPoint;         //�������ŷ�ֵ��0-100
    BYTE   byStreakPoint;       //���Ƹ��ŷ�ֵ��0-100
    BYTE   byFreezePoint;       //���涳�ֵᷧ��0-100
    BYTE   byPTZPoint;          //��̨ʧ�ط�ֵ��0-100
    BYTE   byMonitorDel;        //��ص�ɾ�� 0-��ɾ���� 1-ɾ��
    BYTE   byContrastThreshold; //�Աȶ��쳣��ֵ��0-100
    BYTE   byMonoThreshold;     //�ڰ�ͼ����ֵ��0-100
    BYTE   byShakeThreshold;    //��Ƶ������ֵ��0-100
    BYTE   byFlashThreshold;    //��Ƶ�����ֵ��0-100
    BYTE   byCoverThreshold;    //��Ƶ�ڵ���ֵ��0-100
    BYTE   bySceneThreshold;    //���������ֵ��0-100
    BYTE   byDarkThreshold;     //ͼ�������ֵ��0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

//��Ͻ��
typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];    ///< ��ID������С��32���ֽ�
       char  sMonitorIP[64];  ///< ��ص�ip
       DWORD  dwChanIndex;  ///< ��ص�ͨ����  
    DWORD  dwWidth;  ///< ͼ����
    DWORD  dwHeight;  ///< ͼ��߶�
    NET_DVR_TIME  struCheckTime;  ///< ���ʱ��(�ϲ����ں�ʱ���ֶ�)����ʽ��2012-08-06 13:00:00
    BYTE  byResult;  ///0-δ��� 1-���� 2-�쳣 3-��¼ʧ�� 4-ȡ���쳣
    BYTE  bySignalResult; ///< ��Ƶ��ʧ����� 0-δ��� 1-���� 2-�쳣
       BYTE  byBlurResult;  ///< ͼ��ģ���������0-δ��� 1-���� 2-�쳣
       BYTE  byLumaResult;  ///< ͼ������������0-δ��� 1-���� 2-�쳣
       BYTE  byChromaResult;  ///< ƫɫ�������0-δ��� 1-���� 2-�쳣
       BYTE  bySnowResult;  ///< �������ż������0-δ��� 1-���� 2-�쳣
    BYTE  byStreakResult;  ///< ���Ƹ��ż������0-δ��� 1-���� 2-�쳣
       BYTE  byFreezeResult;  ///< ���涳��������0-δ��� 1-���� 2-�쳣
       BYTE  byPTZResult;  ///< ��̨�������0-δ��� 1-���� 2-�쳣
    BYTE  byContrastResult;     //�Աȶ��쳣�������0-δ��⣬1-������2-�쳣
    BYTE  byMonoResult;         //�ڰ�ͼ��������0-δ��⣬1-������2-�쳣
    BYTE  byShakeResult;        //��Ƶ�����������0-δ��⣬1-������2-�쳣
    char  sSNapShotURL[256];    ///<ͼƬURL��ַ
    BYTE  byFlashResult;        //��Ƶ���������0-δ��⣬1-������2-�쳣
    BYTE  byCoverResult;        //��Ƶ�ڵ��������0-δ��⣬1-������2-�쳣
    BYTE  bySceneResult;        //��������������0-δ��⣬1-������2-�쳣
    BYTE  byDarkResult;         //ͼ������������0-δ��⣬1-������2-�쳣
    BYTE  byStreamType;        //�������ͣ�0-��Ч��1-δ֪��2-�������ͣ�3-�ǹ�������
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST   ///< ������ݽṹ��ƽ̨���͵���Ϸ�������
{
    NET_DVR_STREAM_INFO  struStreamInfo;
       char   sSnapShotURL[256];  ///< ���ץͼURL������С��256���ֽ�    
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO  ///< ������ݽṹ����Ϸ��������ظ�ƽ̨��
{
    DWORD  dwSize;
    char   sStreamID[32];     ///<��ID(��ص�ID)������С��32���ֽ�
    DWORD  dwPicLength;  ///ͼƬ����
    BYTE   byStatus;     ///< ���ý��:0-�ɹ�,1-��������2-ͼƬ�����ڣ�3-��ȡͼƬʧ��
    BYTE   byRes[31];
       char   *pSnapShot;      ///< ���ץͼ����һ��ͼƬ��������(700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];    ///< �ƻ�id������С��32���ֽ�
       NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];    ///< ���ʱ�� 
    BYTE    byPlanMode;  ///0:��ʱ�ƻ���1:���ڼƻ�
    BYTE    byRes1;//     
    BYTE    byCheckFlag;  ///< �Ƿ��⣬0-����⣬1-���
    BYTE    bySignal;  ///<��Ƶ��ʧ �Ƿ��⣬0-����⣬1-���
       BYTE    byBlur;  ///< ͼ��ģ�� �Ƿ��⣬0-����⣬1-���
       BYTE    byLuma;  ///< ͼ������Ƿ��⣬0-����⣬1-���
       BYTE    byChroma;  ///< ƫɫ��� �Ƿ��⣬0-����⣬1-���
       BYTE    bySnow;  ///<�������� �Ƿ��⣬0-����⣬1-���
    BYTE    byStreak;  ///<���Ƹ��� �Ƿ��⣬0-����⣬1-���
       BYTE    byFreeze;  ///<���涳���Ƿ��⣬0-����⣬1-���
       BYTE    byPTZ;  ///<��̨�Ƿ��⣬0-����⣬1-���
    BYTE    byEnablePlanRound;  ///�ƻ�ѭ���Ƿ���
    BYTE    byContrast;  //�Աȶ��쳣�Ƿ��⣬0-����⣬1-���
    BYTE    byMono;      //�ڰ�ͼ���Ƿ��⣬0-����⣬1-���
    BYTE    byShake;     //��Ƶ�����Ƿ��⣬0-����⣬1-���
    BYTE    byFlash;     //��Ƶ����Ƿ��⣬0-����⣬1-���
    BYTE    byCover;     //��Ƶ�ڵ��Ƿ��⣬0-����⣬1-���
    BYTE    byScene;     //��������Ƿ��⣬0-����⣬1-���
    BYTE    byDark;      //ͼ������Ƿ��⣬0-����⣬1-���
    BYTE    byRes[13];     
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;


typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;                //�ܲ���
    BYTE  byStepIndex;                //��ǰ�ڼ���
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;

//������IPC�б�
typedef enum tagNET_DVR_IPC_ENUM
{
    ENUM_BUSINESS_INVALID = -1,
        
        ENUM_BUSINESS_HIKVISION = 0,
        ENUM_BUSINESS_PANASONIC,
        ENUM_BUSINESS_SONY,
        ENUM_BUSINESS_AXIS,
        ENUM_BUSINESS_SANYO,
        ENUM_BUSINESS_BOSCH,
        ENUM_BUSINESS_ZAVIO,
        ENUM_BUSINESS_GRANDEYE,
        ENUM_BUSINESS_PROVIDEO,
        ENUM_BUSINESS_ARECONT, // 9 
        ENUM_BUSINESS_ACTI,
        ENUM_BUSINESS_PELCO,
        ENUM_BUSINESS_VIVOTEK,
        ENUM_BUSINESS_INFINOVA,  
        ENUM_BUSINESS_DAHUA,    //14
        
        ENUM_BUSINESS_HIK_STD_H264 = 0x20,
        ENUM_BUSINESS_HIK_STD_MPEG4,
        ENUM_BUSINESS_SUNELL ,    //����
        ENUM_BUSINESS_ATEME ,    
        ENUM_BUSINESS_LAUNCH,    //�ʳ�
        ENUM_BUSINESS_YAAN,    //�Ű�
        ENUM_BUSINESS_BLUESKY,    //��ɫ�Ǽ�
        ENUM_BUSINESS_BLUESKYLIMIT,//��ɫ�Ǽ�LIMIT
        ENUM_BUSINESS_TDWY,            //���ΰҵ
        ENUM_BUSINESS_HBGK,            //����߿�
        ENUM_BUSINESS_SANTACHI,        //������
        ENUM_BUSINESS_HIGHEASY,        //����
        ENUM_BUSINESS_SAMSUNG,          
        
        ENUM_BUSINESS_URL_RTSP = 0x40,    /* url����ȡ�� */
        ENUM_BUSINESS_ONVIF,            
        
        ENUM_MAX_BUSINESS_TYPE,    //���������
} NET_DVR_IPC_ENUM, *LPNET_DVR_IPC_ENUM;

//��˴���ͳһ�������IPC�б�
typedef enum tagNET_DVR_IPC_ENUM_UNIFY
{
    ENUM_IPC_PROTOCOL_INVALID = -1,
        ENUM_IPC_PROTOCOL_HIKVISION = 0,  //��������
        ENUM_IPC_PROTOCOL_PANASONIC ,     //����
        ENUM_IPC_PROTOCOL_SONY ,          //����
        
        ENUM_IPC_PROTOCOL_AXIS = 4,       //��Ѷʿ
        ENUM_IPC_PROTOCOL_SANYO ,         //����
        ENUM_IPC_PROTOCOL_BOSCH ,         //����  
        ENUM_IPC_PROTOCOL_ZAVIO ,         //ZAVIO  
        ENUM_IPC_PROTOCOL_GRANDEYE ,      //GRANDEYE
        ENUM_IPC_PROTOCOL_PROVIDEO ,      //����
        ENUM_IPC_PROTOCOL_ARECONT ,       //������
        ENUM_IPC_PROTOCOL_ACTI ,          //����ͨ
        ENUM_IPC_PROTOCOL_PELCO ,         //������ 
        ENUM_IPC_PROTOCOL_VIVOTEK ,       //���ͨѶ
        ENUM_IPC_PROTOCOL_DAHUA ,         //��
        ENUM_IPC_PROTOCOL_SAMSUNG ,       //����
        
        ENUM_IPC_PROTOCOL_PSIA = 17,      //PSIA
        ENUM_IPC_PROTOCOL_ONVIF ,         //ONVIF
        ENUM_IPC_PROTOCOL_BRICKCOM ,      //��שͨ��
        ENUM_IPC_PROTOCOL_GB28181 ,       //GB28181
        
        ENUM_IPC_PROTOCOL_CANON = 23 ,    //����
        
        ENUM_IPC_PROTOCOL_HUINT = 32,      //HUINT
        ENUM_IPC_PROTOCOL_INFINOVA ,       //Ӣ����
        ENUM_IPC_PROTOCOL_HIK_STD_H264,    //������׼264
        ENUM_IPC_PROTOCOL_HIK_STD_MPEG4 ,  //������׼MPEG4
        ENUM_IPC_PROTOCOL_SUNELL ,         //����
        ENUM_IPC_PROTOCOL_ATEME ,          //����ķ
        ENUM_IPC_PROTOCOL_LAUNCH ,         //�ɳ�
        ENUM_IPC_PROTOCOL_YAAN,                //�ǰ�
        ENUM_IPC_PROTOCOL_BLUESKY ,            //��ɫ�Ǽ�
        ENUM_IPC_PROTOCOL_BLUESKYLIMIT ,    //��ɫ�Ǽ�LIMIT
        ENUM_IPC_PROTOCOL_TDWY ,           //���ΰҵ
        ENUM_IPC_PROTOCOL_HBGK ,            //����߿�
        ENUM_IPC_PROTOCOL_SANTACHI,            //������
        ENUM_IPC_PROTOCOL_HIGHEASY,            //����
        ENUM_IPC_PROTOCOL_HANBANG ,         //����߿�
        ENUM_IPC_PROTOCOL_SAMSUNG_3120 ,    //����3120
        ENUM_IPC_PROTOCOL_SAMSUNG_3080 ,    //����3080
        ENUM_IPC_PROTOCOL_SAMSUNG_2000,     //����2000
        ENUM_IPC_PROTOCOL_SAMSUNG_5200 ,    //����5200
        ENUM_IPC_PROTOCOL_JINGYUAN ,        //��Ժ
        ENUM_IPC_PROTOCOL_VIDEOTREC ,       //����ӯ��
        ENUM_IPC_PROTOCOL_CHENOVA ,            //�Ϻ��Ϸ�
        ENUM_IPC_PROTOCOL_FENGHUO ,         //���
        ENUM_IPC_PROTOCOL_ZB_5301 ,         //�㽭����5301
        ENUM_IPC_PROTOCOL_ZB_5401 ,         //�㽭����5401
        ENUM_IPC_PROTOCOL_HAIXIN,            //����
        ENUM_IPC_PROTOCOL_ZHONGYINGXIN ,    //�����
        ENUM_IPC_PROTOCOL_AVUN ,            //��ŵ����
        ENUM_IPC_PROTOCOL_GOVTY ,           //���ݼ���
        ENUM_IPC_PROTOCOL_SAE ,                //�����
        ENUM_IPC_PROTOCOL_DONGFANGWANGLI,   //��������
        ENUM_IPC_PROTOCOL_CHANGHONG,        //����
        ENUM_IPC_PROTOCOL_H3C ,                //����
        ENUM_IPC_PROTOCOL_BAIAN ,           //�ٰ�
        ENUM_IPC_PROTOCOL_HAT ,                //����̩
        ENUM_IPC_PROTOCOL_YUANYE,            //Զҵ
        ENUM_IPC_PROTOCOL_HIKCARD ,            //�����忨
        ENUM_IPC_PROTOCOL_HAIXINCAP ,       //����ץ�Ļ�
        ENUM_IPC_PROTOCOL_WENANCAP ,        //�İ�ץ�Ļ�
        ENUM_IPC_PROTOCOL_XUNMEI ,            //Ѷ��
        ENUM_IPC_PROTOCOL_BAIWO ,            //����
        ENUM_IPC_PROTOCOL_APD ,                //���մ�
        ENUM_IPC_PROTOCOL_REACHDEV ,        //��ȡ
        ENUM_IPC_PROTOCOL_XUNMEI_DAHUA ,    //Ѷ����OEM
        ENUM_IPC_PROTOCOL_HUANGHE,            //�ƺ��豸
        ENUM_IPC_PROTOCOL_LIANCHEN ,        //���
        ENUM_IPC_PROTOCOL_CHENGYE,            //��ҵ
        ENUM_IPC_PROTOCOL_VISIONDIGI ,      //��Ǭ
        ENUM_IPC_PROTOCOL_HENGHE ,          //���
        ENUM_IPC_PROTOCOL_KODAK ,           //�ƴ�
        ENUM_IPC_PROTOCOL_AIRONIX,          //�����˹
        ENUM_IPC_PROTOCOL_LG,               //�ֽ�
        ENUM_IPC_PROTOCOL_HASEE ,          //����
        ENUM_IPC_PROTOCOL_8000ME ,          //8000ME
        ENUM_IPC_PROTOCOL_POVITEL ,         //���첩��
        ENUM_IPC_PROTOCOL_YIVIEW,           //��ά
        ENUM_IPC_PROTOCOL_TIANYUE ,         //��Ծ
        ENUM_IPC_PROTOCOL_HOWELL ,          //��ά
        ENUM_IPC_PROTOCOL_WAPA,             //����
        ENUM_IPC_PROTOCOL_SANLE ,           //����
        ENUM_IPC_PROTOCOL_HIKCARD_ENCRYPTION,      //���ܺ����忨
        ENUM_IPC_PROTOCOL_JUNSDA ,          //���Ӵ�
        ENUM_IPC_PROTOCOL_LIYUAN ,          //��Ԫ
        ENUM_IPC_PROTOCOL_XINCHAN ,         //�Ų�
        ENUM_IPC_PROTOCOL_BITE ,            //����
        ENUM_IPC_PROTOCOL_MEIAN,            //����
        ENUM_IPC_PROTOCOL_ROSEEK,           //����
        ENUM_IPC_PROTOCOL_AEBELL ,          //���籴��
        ENUM_IPC_PROTOCOL_JSL_ST ,          //������ST
        ENUM_IPC_PROTOCOL_VIMICRO,          //����΢����
        ENUM_IPC_PROTOCOL_UNIVIEW,          //����
        
        ENUM_IPC_PROTOCOL_TYPE,    //���������
}NET_DVR_IPC_ENUM_UNIFY, *LPNET_DVR_IPC_ENUM_UNIFY;



typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD                dwSize;            // �ṹ���С
    NET_DVR_STREAM_INFO    struStreamInfo;    // ��ص�
    WORD                 wYear;              // �� 
    BYTE                 byMonth;            // ��
    BYTE                byDrawFrame;    // 0-����֡ 1-��֡
    BYTE                byStreamType;   //0-������ 1-������
    BYTE				byLocalOrUTC;  	//0-�豸����ʱ��  1-UTC
    BYTE                byRes[30];  
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{    
    DWORD            dwSize;            // �ṹ���С
    BYTE            byRecordDistribution[LEN_32];   // ¼��ֲ���byRecordDistribution[0]=1��ʾ1�մ���¼��byRecordDistribution[0]=0��ʾû��¼��
    //byRecordDistribution[1]��ʾ2�գ��Դ�����
    BYTE            byHasEventRecode[LEN_31];            //�¼�¼�� 0-���¼�¼��1-���¼�¼��
    BYTE            byRes;                        //����
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;


typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD    dwSize;                        // �ṹ���С
    BYTE     byGroup;                    // ��ţ�ÿ��ɻ�ȡ 64��ͨ������0��ʼ, 0��ʾ��1�飬�Դ�����
    BYTE    byProType;                    //Э�����ͣ�0-˽��Э�飬1-����Э�飬2-����
    BYTE    byAccessMode;                //����ģʽ��0-IP��ַ��1-����
    BYTE    byRes1;                        //�����ֶΣ���0
    char    szUserName[NAME_LEN];        //�û���
    char    szPassword[PASSWD_LEN];        //����
    char    szDomain[MAX_DOMAIN_NAME];    //�豸����
    NET_DVR_IPADDR struIP;                //IP��ַ
    WORD    wPort;                         // �˿ں�
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181Э�����ʱ���豸������ID
    BYTE    byRes2[2];                    //�����ֶΣ���0
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD    dwSize;    // �ṹ���С
    DWORD    dwTotalChannelNum;      //�豸��ͨ���������豸������ʱ����0��byChannel��Ч
    BYTE     byChannel[MAX_CHANNUM_V30];    /*byChannel[i]Ϊ0��ʾ�ڣ�byGroup+1��*��i-1��ͨ��δ���뵽NVR��
                                    Ϊ1��ʾ��ͨ���ѽ��뵽NVR byGroup��NET_DVR_ACCESS_DEVICE_INFO��*/
    BYTE  byRes[32];           //����
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD    dwSize; //���
    BYTE    byGroup; //��ţ�ÿ�������64������
    BYTE    byVideoOutType; /*��Ƶ����ӿ�����,0-��CVBS,1-HDMI 2-VGA 3-�������һ
                     4-��������� 5-��������� 6-���������, 7-����HDMI, 8-��չHDMI1,
                     9-��չHDMI2, 10-��չHDMI3, 11-��չHDMI4, 12-��ͬԴVGA1��
                     13-��ͬԴVGA2��14-��ͬԴVGA3��15-��ͬԴVGA4��16-ͬԴVGA, 17-��LCD,18-����VGA,19-����LCD*/
    BYTE    byGetDefaultPreviewSet;//�Ƿ��ȡԤ�裬0-��1-�ǣ���Ϊ��ʱ��byPreviewNumber�ֶ���Ч
    BYTE    byPreviewNumber;//Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16����, 4-6����, 5-8����6-25����,7-32����, 8-36���� 0xfb-�Զ������4, 0xfc-�Զ������3, 0xfd-�Զ������2, 0xfe-�Զ������1,0xff:�����
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD    dwSize;    // �汾�����ṹ���С
                    WORD    wSwitchSeq[MAX_WINDOW_V40];/*bySwitchSeq [i]=6����ʾ�ڣ����*64+i+1��������
                    ��ʾ����ͨ����Ϊ0xff��ʾ�ô��ڲ���ʾ*/
                    BYTE    byPreviewNumber;/*Ԥ����Ŀ,0-1����,1-4����,2-9����,3-16����, 4-6����, 5-8���棬6-25����,7-32����, 8-36����, 9-64����
                    0xff:�����*/
                    BYTE    byEnableAudio;//�Ƿ�����Ԥ��,0-��Ԥ��,1-Ԥ��
                    BYTE    bySwitchTime;//�л�ʱ��,0-���л�,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
                    BYTE    bySameSource ; //�Ƿ�ͬԴ������Ƶ���������Ϊ��ͬԴVGA1-��ͬԴVGA4ʱ��Ч 
                    BYTE    byRes[32];        //����
}NET_DVR_PREVIEW_SWITCH_CFG,* LPNET_DVR_PREVIEW_SWITCH_CFG;

typedef struct tagNET_DVR_USER_COND
{    
    char        szUserName[NAME_LEN];
    BYTE        byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{    
    DWORD            dwSize;
    BYTE            byAddMonitoringPointRight; // ��Ӽ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE            byModMonitoringPointRight; // �޸ļ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE            byDelMonitoringPointRight; // ��Ӽ�ص㣨ǰ���豸��Ȩ��0-�� 1-��
    BYTE            bySetRecordPlanRight; // �ƶ�¼�����Ȩ��0-�� 1-��
    BYTE            byDelRecordPlanRight; // ɾ��¼�����Ȩ��0-�� 1-��
    BYTE            byEnableOrDisableRecordPlanRight; // ���úͽ���¼��ƻ�Ȩ��0-�� 1-��
    BYTE            byManualRecordRight; // ������ֹͣ�ֶ�¼��Ȩ��0-�� 1-��
    BYTE            bySetAlarmRecordRight; // ����¼���趨Ȩ��0-�� 1-��
    BYTE            byRecordBackupRight; // ¼��浵Ȩ��0-�� 1-��
    BYTE            byRecordDownloadRight; // ¼������Ȩ��0-�� 1-��
    BYTE            byRecordDeleteRight; // ¼��ɾ��Ȩ��0-�� 1-�У�������
    BYTE            byDelBackupRecordRight; // ɾ���浵¼��Ȩ��0-�� 1-�У�������
    BYTE            bySetBackupVolumeRight; // ���ô浵��Ȩ��0-�� 1-��
    BYTE            byRecordPlayBackRight; // ¼��ط�Ȩ��0-�� 1-�� DWORD dwZoneIndex
    BYTE            byLogDeleteRight; // ��־���Ȩ��0-�� 1-�У�������
    BYTE            byLogDownloadRight; // ��־����Ȩ��0-�� 1-�У�������
    BYTE            byAddUserRight; // ����û�Ȩ��0-�� 1-��
    BYTE            byDelUserRight; // ɾ���û�Ȩ��0-�� 1-��
    BYTE            byModUserRight; // �޸��û�Ȩ��0-�� 1-��
    BYTE            byAllocUserRight; // �û�Ȩ�޷���Ȩ��0-�� 1-��
    BYTE            byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD                dwSize;
    DWORD               dwMaxNum;         // ��󱸻���Ŀ
    BYTE                   byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;

//����N+1�豸������ģʽ��NVR��Ҫ�ⲽ��CVR����Ҫ
typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD    dwSize ;
    BYTE    byWorkMode;        //0-������ 1-����
    BYTE    byRes[127];       //����
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR    struIP;        // �豸IP
    char            szPassword[PASSWD_LEN];    //�������룬����׼���
    BYTE             byAddType;         // 0-���������ϣ���ӱ�����1-�������ϣ���ӹ�����
    BYTE             byDisableBackup; //���ݹ���ʹ�ܿ��� 0-����1-�ر� CVRĬ�Ͽ���
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR    struIP;        // �豸IP
    BYTE             byDelType;     // 0-ɾ��ָ���Ļ�����������������1-ȫɾ
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;

typedef union tagNET_DVR_NPO_PARAM_UNION
{
    NET_DVR_ADD_PARAM    struAddParam;        //�����Ϣ
    NET_DVR_DEL_PARAM     struDelParam;        //ɾ����Ϣ
}NET_DVR_NPO_PARAM_UNION, *LPNET_DVR_NPO_PARAM_UNION;

// N+1ģʽ�豸����
typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD                    dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam;
    BYTE                     byType;     /* 0-��ӣ���ӦunionParam�е�struAddParam 1-ɾ������ӦunionParam�е�struDelParam  2-������û�����Ч����ӦunionParam�е�struAddParam ��szUserName*/
    BYTE                      byRes[3];
    char                        szUserName[NAME_LEN];    //�û���
    BYTE                      byRes2[220];          // ����
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

// ���ݻ�Ǩ
typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD                dwSize;
    BYTE                   byEnable;     // 0-���������ݻ�Ǩ 1-�������ݻ�Ǩ
    BYTE                   byDelData;     // ��byEnableΪ1����Ч 0-��ɾ������¼������ 1-ɾ������¼������
    BYTE                   byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD     dwSize;
    BYTE     bySleepStatus;/*����״̬0-������ 1-����*/
    BYTE      byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD     dwSize;
    BYTE     bySpeed;    /*0-���� 1-���� 2-����*/
    BYTE      byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD                dwSize;
    DWORD                dwSrcLunID;        // ԴLUN ID
    DWORD               dwDstLunID;     // Ŀ��LUN ID
    BYTE                   byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD                dwSize;
    DWORD                dwLunID;                    // LUN ID
    DWORD                dwHSize;                    // ��չ�Ĵ�С��32λ
    DWORD                dwLSize;                    // ��չ�Ĵ�С��32λ
    char                szArrayIDGroup[NAME_LEN];    // ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ΪĬ��
    char                   szNewLunName[MAX_NAMELEN];     // ��LUN��
    BYTE                   byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;


typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD                dwSize;
    char                szOldDvrNetDiskName[MAX_NAMELEN];        // ԭDVR���̹�����
    char                   szNewDvrNetDiskName[MAX_NAMELEN];     // ��DVR���̹�����
    NET_DVR_IPADDR        struWarrantIP;                        // ����Ȩ��DVR����IP
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;


typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD                dwSize;
    DWORD                dwLunID;        // LUN ID
    BYTE                   byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD                dwSize;
    DWORD                dwTargetID;        // iSCSI�����Target ID
    DWORD                dwLunID;        // LUN ID
    DWORD                dwAccessMode;    //��д��ʽ 0-��д 1-ͬ����д 2-ֻ�� 3-����ֻ��;
    NET_DVR_IPADDR        struClientIP;        // �ͻ���IP��0.0.0.0Ϊ����IP
    BYTE                   byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD                dwSize;
    DWORD                dwStoreLunID;                    // �洢LUN ID
    DWORD                dwLogicLunID;                    // �߼�LUN ID��-1��ʾ�Զ�����
    DWORD                dwHbaID;                        // ����ͨ����
    DWORD                dwAccessMode;                    //��д��ʽ 0-��д 1-ͬ����д 2-ֻ�� 3-����ֻ��;
    char                szClientWWWPN[NAME_LEN];         // �ͻ����˿�
    BYTE                   byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;


// �߼��� 60�ֽ�
typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD        dwHCapacity;    // �߼����С��32λ
    DWORD        dwLCapacity;    // �߼����С��32λ
    char        szName[MAX_NAMELEN];     // �߼�������
    DWORD        dwBlockSize;        // �߼������С�洢��Ԫ���С
    char        szArrayIDGroup[NAME_LEN];     //ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;

typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD            dwHCapacity;    // DVR���̴�С��32λ
    DWORD            dwLCapacity;    // DVR���̴�С��32λ
    char                szName[MAX_NAMELEN];     // DVR��������
    DWORD            dwBlockSize;        // �߼������С�洢��Ԫ���С
    NET_DVR_IPADDR    struWarrantIP;        // ��Ȩ��DVR����IP
    char            szArrayIDGroup[NAME_LEN];     //ʹ�õ�����ID�飬�Զ��Ÿ�����Ϊ����ʹ��Ĭ������
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;

typedef union tagNET_DVR_VD_UNION
{
    BYTE                        byUnionLen[256];      // �������С
    NET_DVR_OPERATE_VD_PARAM    struHikVDParam;        // �������
    NET_DVR_LUN_PARAM            struLunParam;            // �߼���
    NET_DVR_DVR_PARAM            struDvrParam;            // DVR����
}NET_DVR_VD_UNION, *LPNET_DVR_VD_UNION;

typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE                byVDType;    //����������ͣ�0-˽��������� 1-�߼��� 2-DVR����
    BYTE                byRes1[3];
    NET_DVR_VD_UNION     uVDParam;
    BYTE                byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;

typedef struct tagNET_DVR_CVR_ALARM
{
    char            szFirstType[NAME_LEN];  //�����ͣ�����Ϊ��
    char            szFirstIndex[NAME_LEN];    //�����ͱ��
    char            szSecondType[NAME_LEN];    //�����ͣ�����Ϊ��
    NET_DVR_TIME    struTime;        //����ʱ��
    BYTE             byStatus;       //״̬ 0-���� ��0-����������ͬ����ֵ��ʾ���岻ͬ�����±�
    BYTE            byAlarmLevel;         //��������
    BYTE            byRes1[2];
    char               szSecondIndex[NAME_LEN];  //�����ͱ�ţ�����Ϊ��
    char            szThirdType[NAME_LEN];  //�������ͣ�����Ϊ��
    char            szThirdIndex[NAME_LEN];    //�������ͱ��
    char            szFourthType[NAME_LEN];  //�������ͣ�����Ϊ��
    char            szFourthIndex[NAME_LEN];    //�������ͱ��
    BYTE              byRes2[92];  //����
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM; 

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //�豸IP
    BYTE             byLinkStatus; //����״̬ 0-����ʧ��1-���ӳɹ�
    BYTE             byWorkStatus; //����״̬ 0-����1-�쳣
    BYTE             byBacupStatus; //����״̬0-���ڱ���1-���ڱ���
    BYTE             bySyncProgress; //¼��ͬ�����ȣ�0��ʾδ��ʼ��100��ʾͬ�����
    NET_DVR_TIME_EX    struSyncBeginTime;    //ͬ����ʼʱ��
    NET_DVR_TIME_EX    struSyncEndTime;        //ͬ������ʱ
    char            szSerialNumber[SERIALNO_LEN] ; //�豸���к�
    DWORD            dwSoftwareVersion ;        //�豸����汾
    BYTE              byWorkingDeviceGUID[GUID_LEN]; //������GUID�����ַ��������ڱ���������������¼��
    char            szDevTypeName[DEV_TYPE_NAME_LEN];        //�豸��������
    WORD            wDevType;        //�豸����ֵ
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //�豸IP
    BYTE             byWorkStatus;     //����״̬ 0-����1-�쳣
    BYTE             byBackupStatus; //����״̬0-���ڼ�� 1-���ڼ��2-���ڱ�����2-����ͬ��
    WORD            wBackupPort;    //���ݶ˿�
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO_V50
{
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;        //��������Ϣ
    char            szUserName[NAME_LEN];    //�û���
    BYTE           byRes[32];
}NET_DVR_WORKING_DEVICE_INFO_V50, *LPNET_DVR_WORKING_DEVICE_INFO_V50;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO_V50
{
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;     //������Ϣ
    char            szUserName[NAME_LEN];    //�û���
    BYTE           byRes[32];
}NET_DVR_REDUNDANT_DEVICE_INFO_V50, *LPNET_DVR_REDUNDANT_DEVICE_INFO_V50;

typedef union tagNET_DVR_NPO_DEV_INFO_UNION
{
    BYTE                             byUnionLen[512];            //�����峤��
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;        //��������Ϣ
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;     //������Ϣ
    NET_DVR_WORKING_DEVICE_INFO_V50      struWorkingDeviceInfoV50;        //��������ϢV50
    NET_DVR_REDUNDANT_DEVICE_INFO_V50    struRedundantDeviceInfoV50;     //������ϢV50
}NET_DVR_NPO_DEV_INFO_UNION, *LPNET_DVR_NPO_DEV_INFO_UNION;


typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD                        dwSize;
    NET_DVR_NPO_DEV_INFO_UNION    unionDevInfo;
    BYTE                        byType;    /*���� 0-����������ӦunionDevInfo�е�struWorkingDeviceInfo     1-��������ӦunionDevInfo�е�struRedundantDeviceInfo
                                           2-������V50����ӦunionDevInfo�е�struWorkingDeviceInfoV50     3-����V50����ӦunionDevInfo�е�struRedundantDeviceInfoV50*/
    BYTE                           byRes[127];    
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;

//ipc��������
typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO    struStreamInfo[MAX_CHANNUM_V30];    // 64����ص�
    char                  szFileName[260];                    // �����ļ���
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;


typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO    struStreamInfo;     //��ص�
    WORD                wErrCode;            //��Ӧ������
    BYTE                byRes[30];          //����
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

//IPC�����ļ�����
typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char          szFileName[260];                    // �����ļ���
    BYTE        byRes[32];                        
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD     wRow;       //������У�0��ʾû����1��ʾ��1�г����Դ�����
    WORD    wErrCode;    //������
    BYTE    byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE     struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_TRANSFER_SWITCH
{
    DWORD dwEnable;
    BYTE  byRes[64];
}NET_DVR_TRANSFER_SWITCH, *LPNET_DVR_TRANSFER_SWITCH;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize; 
    DWORD dwChannel; //ͨ����
    DWORD dwPatternCmd; //��̨�켣����������,������涨��
    DWORD dwPatternID; //��̨�켣ID��ɾ�����й켣ʱ��Ч��
    BYTE  byRes[64]; 
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ����ã�0-�����ã�1-����
    BYTE  byOneTouchSwitch;//һ������, 0-�����ã�1-���� (��wActionType���ʹ��)
    BYTE  byRes1[2];
    DWORD dwParkTime; //�����ȴ�ʱ�䣬��λs 
    WORD  wActionType; //�����������ͣ�0-�Զ�ɨ�裬1-֡ɨ�裬2-���ɨ�裬3-Ѳ��ɨ�裬4-����ɨ�裬5-Ԥ�õ㣬6-ȫ��ɨ�裬7-��ֱɨ��, 8-����ɨ��
    WORD  wID; //ID�ţ�Ѳ��ɨ�衢Ԥ�õ㡢����ɨ���ID��
    BYTE  byRes[128]; 
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD  dwSize; 
    DWORD  dwChannel; //ͨ����
    NET_VCA_POINT struPoint; //��λ����
    BYTE byTrackType; //��������0�����Զ�ȡ֤(��ͨȡ֤) 1�����ٵ�·���� 2�����е�·���٣��ֶ�����ȡ֤��3����̬ȡ֤
    BYTE byLinkageType;//��������: 0-�ֶ����� 1-����������
    BYTE byRes[2];
    NET_VCA_POINT struPointEnd;/*��λ�����յ�*/
    NET_DVR_TIME_V30 struTime;//�ֶ����ٶ�λ����ǰʱ�䡣
    DWORD  dwSerialNo;//��ţ�
    BYTE   byRes1[36];  
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;

typedef enum tagVQD_TYPE
{
    VQD_BLUR_FLAG     = 0x00000001,    //ͼ��ģ��
        VQD_LUMA_FLAG     = 0x00000002,//�����쳣
        VQD_CHROMA_FLAG   = 0x00000004,//ͼ��ƫɫ
        VQD_SNOW_FLAG     = 0x00000008,//ѩ������
        VQD_STREAK_FLAG   = 0x00000010,//���Ƹ���
        VQD_FREEZE_FLAG   = 0x00000020,//���涳��
        VQD_SIGLOSE_FLAG  = 0x00000040,//�źŶ�ʧ
        VQD_PTZ_FLAG      = 0x00000080//��̨ʧ��
}VQD_TYPE;

typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD  dwSize ;        //�ṹ���С
    BYTE    byEnable;        // ���ʹ�� 0 :�رգ����� 1:����
    BYTE     byRes1[3] ;     //����
    BYTE    byVQDTypeEnable[32];     //VQD���ģʽ��0 --������ 1--����  ÿ��������Ͷ�Ӧ�������ȣ������ȵ��±���������͵��±�һ��
    /*����0 ͼ��ģ��     ����1 �����쳣 ����2 ͼ��ƫɫ*/
    /*����3 ѩ������     ����4 ���Ƹ��� ����5 ���涳��*/
    /*����6 �źŶ�ʧ     ����7 ��̨ʧ��*/    
    BYTE byThresholdValue[32] ;       //��ֵ0~100����ͬ���ģʽ�и��Զ�Ӧ����ֵ
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //��������ʽ
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //���ղ���ʱ��� 
    BYTE    byRes[324];      //����
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;


typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;   //ͨ����
    DWORD  dwVQDType;     // VQD�������    
    NET_DVR_TIME struDiagnoseTime;    //���ʱ��
    BYTE     byScoreValue;       //����ֵ ���ٷ���
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO,*LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;


typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize ;        //�ṹ���С
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo ; //����쳣��Ϣ�ṹ��
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/]; 
    //������Դ״̬�б�byDecStatus[i]��ʾ��λ��i����ϵͳ״̬��0-��Ч��1-���У�2-��ͨ����(������ͨ������ǽ�ʹ���������)��3-���ܽ���
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST,*LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource; /*����Ľ�����Դ���Էֱ��ʺ�����0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5��������,
                         6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA��640*480��, 17-UXGA��1600*1200��, 18-SVGA ��800*600��,
                         19-HD720p��1280*720��,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 
                         31-2448*2048,32-2448*1200,33-2448*800,34-XGA��1024*768����35-SXGA��1280*1024��,36-WD1(960*576/960*480),
    37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)*/
    DWORD  dwChannel; //����ͨ����
    NET_DVR_IPADDR  struIP;   //������IP
    WORD  wPort;         //�����߶˿ں�(���ܷ�����ͨѶ�˿�)
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO,*LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;  //��λ�ţ��˲������ͷŽ�����Դ�͵�½������ϵͳУ����
    NET_DVR_IPADDR struIP; //������ϵͳIP��ַ
    WORD  wPort;      //�˿ں�
    BYTE  byRes1[2];
    DWORD dwDecChan;  //����ͨ����
    BYTE  sUserName[NAME_LEN];    /* ������ϵͳ��½�ʺ� */
    BYTE  sPassword[PASSWD_LEN];    /* ������ϵͳ��½���� */
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO,*LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum; //��λ��,�����������Դʱ���صĲ�λ��
    DWORD dwDecChan; //����ͨ����
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND,*LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;     //����ʹ�ܣ�0-�޹�����1-����
    BYTE  byRes1[3];
    //byEnable = 1ʱ���²�����Ч
    DWORD dwYUVAddress[3]; //YUV�����ַ
    WORD  wWidth;       //YUV�����
    WORD  wHeight;      //YUV�����
    BYTE  byEnableAudio;  //ʹ����Ƶ��0-�����ã�1-����
    BYTE  byRes2[3];
    DWORD dwAudioAddr;  //��Ƶ�����ַ
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG,*LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD        dwSize;
    BYTE        byChanType;        //�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //ͨ���ţ��豸ͨ���ţ�֧��byChanType��������
    DWORD        dwSubChanNo;    //��λ�ţ�485��λ�ţ���byChanTypeΪ3-485ͨ��ʱ��Ч����ʾͨ�����µ���ͨ����
    DWORD        dwVariableNo;    //������ţ���byChanTypeΪ2-���ؿ�����ͨ��ʱ(1-���룬2-���)
    BYTE        byRemoteType;    //��ȡ�������ͣ�0-ȫ�����ͣ�1-ң�ţ�2-ң��
    BYTE        byLinkageIPCType;   //����IPC�������ͣ�0-Ĭ�ϣ�1-�����������ã�2-��ͨ��������
    BYTE        byLinkageTriggerType;   //�����������������ͣ�0-Ĭ�ϣ�1-�����������ã�2-��ͨ��������
    BYTE        byRes2[57];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD        dwSize; 
    WORD        wVariableIndex;        //������ţ�ֻ�ܻ�ȡ
    WORD        wVariableType;        //�������� 1-ģ���� 2-��������ֻ�ܻ�ȡ
    BYTE        sDescribe[NAME_LEN];//��������
    BYTE        byLimitLineType;    //������ֵ�������ͣ�0-��֧�ֱ�����ֵ���ã�1-����ֵ���ã������ޡ����ޣ���2-����ֵ����
    BYTE        byRemoteType;       //����Զ��ϵͳ���ͣ�0-ȫ�����ͣ�1-ң�ţ�2ң��
    BYTE        byOsdEnabled;       //�����Ƿ�֧��OSD����:0-Ĭ�ϣ�1-֧�֣�2-��֧��
    BYTE        byRes[29];            //����
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;


//ģ���������ز���
typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int           nMeasureHigh;            // �������� �ⲿֵ*1000���� ����Ϊ����
    int           nMeasureLow;            // �������� �ⲿֵ*1000����
    BYTE        byAlarmMode;            // ����ģʽ�����֣�-HHHH��-HHHL��-HHLL��HLLL��-LLLL��
    // ����1111���������ϣ���1110���������£���1100���������£���1000(��������)��0000(��������)
    BYTE         byRes1[3];
    int            nAlarmValue[4];            // ������
    DWORD          dwOsdCfg;                // ģ�����ַ����ӣ���λ��ʾ0-15��Ӧ��Ƶͨ��1-16
    DWORD        dwSensitive;            // �����ȷ�Χ10~1000���ⲿ float*1000�� �����ȱ�ʾ��ʵʱֵ�ı仯���������ȵķ�Χʱ�����ʾʵʱֵ�����˱仯��������Ϊû�з����仯���磺������Ϊ0.1�����ʾǰ���������ֵ֮�����0.1ʱ������Ϊ���ݷ����仯����Ҫ�ϴ������Ϊ1�����ʾ�仯����1ʱ�ϱ���
    DWORD        dwIPChanOsd;            // ����ͨ������ģ�����ַ�����λ��ʾ��0~31��Ӧ����ͨ��1-32
    char         szOSDUnit[MAX_OSD_UNIT_LEN];   //OSD���ӵ�λ
    BYTE        byRes[16];
}NET_DVR_ALARM_SENSOR_POINT_CFG,*LPNET_DVR_ALARM_SENSOR_POINT_CFG;

//�����������ز�����485ң���ź�
typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
	DWORD     dwIPCChanOsd;//֧��osd���������ӵ�IPCͨ����Ϣ����λ��ʾ��0~31��Ӧ����ͨ��1-32
    BYTE        byRes[60];
}NET_DVR_ALARM_SWITCH_POINT_CFG,*LPNET_DVR_ALARM_SWITCH_POINT_CFG;

//ģ���������ز�����485ң���ź�
typedef union tagNET_DVR_ALARM_POINT_PARAM_UNION
{
    BYTE    byLength[64]; //�����峤��Ϊ64
    NET_DVR_ALARM_SENSOR_POINT_CFG struSensor;    //ģ��������485ң���źţ���ز���
    NET_DVR_ALARM_SWITCH_POINT_CFG struSwitch;    //����������485ң���źţ���ز���
}NET_DVR_ALARM_POINT_PARAM_UNION,*LPNET_DVR_ALARM_POINT_PARAM_UNION;

//�����Ϣ
typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD        dwSize;
    DWORD        dwPointNo;            //���
    BYTE        sPointDescribe[NAME_LEN];        //�������
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam; //����������Ϊģ������485ң���ź�ʱ��ʹ�ýṹ��struSensor������������Ϊ��������485ң���ź�ʱ��ʹ�ýṹ��struSwitch
    BYTE        byPointType;        //������ͣ�1-ģ������2-������
    BYTE        byChanType;        //�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE        byRes1[2];
    DWORD        dwChanNo;        //ͨ����
    DWORD        dwSubChanNo;    //��λ��
    DWORD        dwVariableNo;    //������ţ���byChanTypeΪ������ʱ(1-�����źţ�2-����ź�)
    BYTE        byRes[16];            //����
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

//��ʷ���ݲ�ѯ
typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD        dwSize;
    BYTE        byMajorType;    //��ѯ��ʽ��1-ȫ����2-��ʱ�䣬 3-�����ͣ�4-ʱ��+����
    BYTE        byMinorType;    //1-��ţ�2-ͨ��+��λ+������
    BYTE        byRes1[2];
    NET_DVR_TIME struStartTime;    //��ʼʱ��
    NET_DVR_TIME struStopTime;    //����ʱ��
    BYTE        byChanType;        //ͨ�����ͣ�1-ģ������2-��������3-485ͨ����0xff��ʾ��Ч
    BYTE        byRes2[3];
    DWORD        dwChanNo;        //ͨ���ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwSubChanNo;    //��λ�ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwVariableNo;    //�����ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwPointNo;    //��ţ�0xffffffff��ʾ��Ч
    BYTE          byRes3[32];        //����
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD        dwSize;
    NET_DVR_TIME struTime;    //ʱ���
    BYTE        byChanType;        //ͨ�����ͣ�1-ģ������2-��������3-485ͨ����0xff��ʾ��Ч
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //ͨ���ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwSubChanNo;    //��λ�ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwVariableNo;    //�����ţ���1��ʼ��0xffffffff��ʾ��Ч
    DWORD        dwPointNo;        //��ţ�0xffffffff��ʾ��Ч
    int            iData;            //��ʷ����
    BYTE        byDataType;        //0-�������ݣ�1-Խ�������ݣ�2-Խ��������
    BYTE        byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD    dwSize;
    BYTE    byDataUploadMode;    //1-��ͨ���ϴ���2-�������ϴ�
    BYTE    byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG,*LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;


typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE    byChanType;        //�������ͣ�1-����ģ����ͨ����2-���ؿ�����ͨ����3-485ͨ����4-����ͨ��
    BYTE    byPointType;    //�����ͣ�1-ң�⣨ģ��������2-ң�ţ���������
    BYTE    byRes1[2];        //����
    DWORD     dwChanNo;        //485ͨ���ţ�0xffffffff��ʾ��Ч��ͨ������Ϊ1ʱ����ʾ����ģ����ͨ���ţ�ͨ������Ϊ2ʱ��ʾ���ؿ�����ͨ���ţ�ͨ������Ϊ3ʱ��ʾ485ͨ���š�
    DWORD    dwSubChanNo;    //��λ�ţ� 0xffffffff��ʾ��Ч��ͨ������Ϊ3ʱʹ��
    DWORD    dwVariableNo;    //������ţ�0xffffffff��ʾ��Ч
    DWORD     dwPointNo;        //104��ţ�0xffffffff��ʾ��Ч
    int        iValue;            //�����ֵ
    BYTE    byRes[16];
}NET_DVR_ALARMHOST_POINT_VALUE,*LPNET_DVR_ALARMHOST_POINT_VALUE;

typedef union tagNET_DVR_ALARMHOST_DATA_UNION
{
    BYTE    byLength[40];
    NET_DVR_ALARMHOST_POINT_VALUE struPointValue;    //����ʵʱ����
}NET_DVR_ALARMHOST_DATA_UNION,*LPNET_DVR_ALARMHOST_DATA_UNION;

typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD        dwSize;
    BYTE        byDataType;        //�������ͣ�1-����ʵʱ�����ϴ�
    BYTE        byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE        byRes2[32];
}NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;     /*�ṹ����*/
    BYTE   byAudioInputChan;//��Ƶ����ͨ���� 
    BYTE   byRes[63];        // �����ֽ�
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE byAudioOutVolume;// ��������ȼ�����һ��Ϊ0-100��
    BYTE byRes[63];
}NET_DVR_AUDIOOUT_VOLUME,*LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE,*LPNET_DVR_FUZZY_UPGRADE;

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //����ģʽ��0-����̨��1-˽��͸��ͨ����2-͸��ͨ��
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //ʹ��͸��ͨ����0-��ʹ�ܣ�1-ʹ��
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //Զ���豸IP��ַ
    WORD wPort; //Զ���豸�˿�
    BYTE byRes2[18];    
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //ʹ��͸��ͨ����0-��ʹ�ܣ�1-ʹ��
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //��������Զ���豸IP    
    BYTE byRes2[16];    
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //���ؼ����Ķ˿ںţ���RS485��һһ��Ӧ
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];    
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;

typedef union tagNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION
{
    BYTE byRes[512];
    NET_DVR_TRANSPARENT_CLIENT_MODE struClientMode;  //�ͻ���ģʽ����
    NET_DVR_TRANSPARENT_SERVER_MODE struServerMode; //������ģʽ����
}NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION, *LPNET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION;

typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;    
    BYTE  byWorkMode; //����ģʽ��1-�ͻ���ģʽ��2-������ģʽ
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;

typedef enum tagNAKED_DATA_TYPE
{
    NAKED_DATA_TYPE_NOT_DEFINED = 0, //δ����
        NAKED_DATA_TYPE_POS_INFO    //���յ���Pos��Ϣ
}NAKED_DATA_TYPE;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP�˿ںţ�����Pos��Ϣ���գ���ֵΪ0����ʹ��Ĭ�϶˿�7050
    BYTE  byRes[130];      //�����ֽ�
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

#define UPLOAD_POS_INFO     1001  //�ϴ�Pos��Ϣ

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD     struVerHead;  //�汾ͷ
    DWORD dwChannelNum;          //ͨ����
    BYTE  byRes[60]; 
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;


#define MAX_IGNORE_STRING_NUM        4
#define FILTERRULE_NUM              4
#define MAX_POS_FILTER_DATA_LEN     128

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //�������
    NET_VCA_POINT   struEnd;    //�յ�����
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;


typedef struct 
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*���׿�ʼ��־��Ŀǰ���Ϊ32��ֻ��anyCharacterΪ��ʱ����Ч*/
    BYTE byExclusive;    //�Ƿ������־���� 0-���� 1-������
    BYTE byFlagType;    //��־���ͣ�0-�ַ�����1-ʮ������
    BYTE byRes[2];        /*����*/
}NET_DVR_GENERIC_START, *LPNET_DVR_GENERIC_START;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*���׽�����־��Ŀǰ���Ϊ32*/
    BYTE  byExclusive;    //�Ƿ������־���� 0-���� 1-������
    BYTE  byFlagType;    //��־���ͣ�0-�ַ�����1-ʮ������
    BYTE  byRes[6];
} NET_DVR_GENERIC_END, *LPNET_DVR_GENERIC_END;

typedef struct
{
    BYTE  sData[MAX_POS_FILTER_DATA_LEN];/*���ݱ�־��Ŀǰ���Ϊ32*/
    BYTE  byFlagType;    //��־���ͣ�0-�ַ�����1-ʮ������
    BYTE  byRes[3];
}NET_DVR_GENERIC_DATA_CFG, *LPNET_DVR_GENERIC_DATA_CFG;

typedef struct
{
    BYTE sData[MAX_POS_FILTER_DATA_LEN];/*���Ե��ַ���Ŀǰ���Ϊ32*/
}NET_DVR_IGNORE_STRING, *LPNET_DVR_IGNORE_STRING;

typedef struct
{
    BYTE  byCaseSensitive;/*�Ƿ����ִ�Сд��0->�����֣�1->����*/
    BYTE  byRes1[7];   
    NET_DVR_GENERIC_START struTransactionStart;/*���׿�ʼ*/
    NET_DVR_GENERIC_END struTransactionEnd;/*���׽���*/
    NET_DVR_GENERIC_DATA_CFG struLineDeli;/*�м����*/
    NET_DVR_IGNORE_STRING struIgnoreString[MAX_IGNORE_STRING_NUM];/*�����ַ�����ĿǰΪ4��*/
    BYTE byRes[40];    //����
}NET_DVR_POS_GENERIC, *LPNET_DVR_GENERIC;

typedef struct
{
    DWORD    dwPosAddr;        //pos��ַ���
    BYTE    byRes[948];
}NET_DVR_POS_AVE, *LPNET_DVR_AVE;

#define SERIAL_NUM_LEN 8
typedef struct tagNET_DVR_POS_NUCLEUS/*size 952byte*/
{
    char   szEmployeeNo[SERIAL_NUM_LEN];//Ա����ţ���1����ע������e<employee#>��
    char   szTerminalNo[SERIAL_NUM_LEN];// Pos����ţ���1����ע������t<terminal#>��
    char   szShiftNo[SERIAL_NUM_LEN]; //�ְࣨ��ע������s<shift#>��
    BYTE      byRes[928];
}NET_DVR_POS_NUCLEUS, *LPNET_DVR_POS_NUCLEUS;
typedef  union _NET_DVR_POS_PROTOCOL_UNION
{
    BYTE byLenth[952];   //���ڱ�ʾ�����峤�ȣ���ʵ������
    NET_DVR_POS_GENERIC struGeneric;
    NET_DVR_POS_AVE struAve;
    NET_DVR_POS_NUCLEUS struNUCLEUS;
}NET_DVR_POS_PROTOCOL_UNION,*LPNET_DVR_POS_PROTOCOL_UNION;

typedef enum tagNET_DVR_CHARSET_ENUM  //���뷽ʽ
{
    ENUM_UTF8 =0,
        ENUM_GB2312,
        ENUM_LATIN1,
        ENUM_LATIN2,
        ENUM_LATIN3,
        ENUM_LATIN4,
        ENUM_CYRILLIC,
        ENUM_ARABIC,
        ENUM_GREEK,
        ENUM_HEBREW,
        ENUM_TURKISH,
        ENUM_NORDIC,
        ENUM_THAI,
        ENUM_LATIN7,
        ENUM_LATIN8,
        ENUM_LATIN9,
        ENUM_LATIN10,
        ENUM_CENTRAL_EUROPEAN,
        ENUM_CYRILLIC_SCRIPT,
        ENUM_HEBREW_DOS862
}NET_DVR_CHARSET_ENUM, *LPNET_DVR_CHARSET_ENUM;


typedef struct
{
    DWORD   dwSize;
    BYTE     byEnable;            //����ʹ��
    BYTE     byCharSetType;      //���뷽ʽ0-UTF-8,1-GB2312
    BYTE    byRes1;   //����
    BYTE    byProtocolType;//Э�����ͣ�1->generic textЭ��(universal Protocol), 2->AVE VSI-ADD     3->AVE Vnet,4-EPSON(���������账��posЭ�����), 5-NUCLEUS
    //6- Gilbarco�����ö�Ӧ�ṹ��NET_DVR_POS_GENERIC��,7- NCR�����ö�Ӧ�ṹ��NET_DVR_POS_GENERIC��
    NET_DVR_POS_PROTOCOL_UNION uPosProtocol;   //POSЭ�� 
    BYTE    byRes[32];    //����
}NET_DVR_POS_FILTER_CFG, *LPNET_DVR_POS_FILTER_CFG;

typedef struct  tagNET_DVR_NET_SNIFF /*���������ṹ�� 312byte*/
{
    BYTE       byEnableSourcePort;       //�Ƿ����ö�����Դ�˿ڹ���  0-�����ã�1-����
    BYTE       byEnableDestAddr;        //�Ƿ����ö�Ŀ��IP��ַ���й��� 0-�����ã�1-����
    BYTE       byEnableDestPort;         //�Ƿ����ö�Ŀ���ַ�Ķ˿ںŽ��й���
    BYTE       byRes1;                 //����
    BYTE       bySourceIpAddr[MAX_DOMAIN_NAME];                //����Դ��ַ 
    BYTE       byDestinationIpAddr[MAX_DOMAIN_NAME];        //���ݷ���Ŀ���ַ 
    WORD          wSourcePort;               //����Դ�˿ں�
    WORD          wDestinationPort;           //���ݷ���Ŀ��˿ں�
    BYTE       byRes[16];                 //����
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;

typedef struct
{
    WORD  wNetPort;  /*device net port*/
    BYTE  byRes[2];
}NET_DVR_NET_RECEIVE, *LPNET_DVR_NET_RECEIVE;

typedef struct tagNET_DVR_MONITOR_INFO  /*����*/
{
    WORD  wPort;       //�����˿ں�
    BYTE   byRes1[2];
    NET_DVR_IPADDR  struRestrictRemoteIP;//��������Զ�̷���IP
    BYTE   byRes[164];     
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;

typedef union tagNET_DVR_POS_CONNECTMODE_UNION
{
    BYTE                       byLen[312];      //�����峤�ȣ���ʵ������
    NET_DVR_NET_RECEIVE     struNetRecv;     //�������ģʽ
    NET_DVR_MONITOR_INFO     struTcpMonitor;    //�������ģʽ
    NET_DVR_SINGLE_RS232     struRS232;        //���ڷ�ʽ
    NET_DVR_MONITOR_INFO     struUdpMonitor;     //�������-UDPģʽ
    NET_DVR_NET_SNIFF          struSniff;          //��������ģʽ
    NET_DVR_ADDRESS            struMcast;          //�ಥģʽ
    NET_DVR_USB_RS232         struUSBRS232;    //USBת���ڷ�ʽ
}NET_DVR_POS_CONNECTMODE_UNION, *LPNET_DVR_POS_CONNECTMODE_UNION;


//DVR��POS���ӷ�ʽ���ýṹ��
typedef struct tagNET_DVR_CONNECT_POS_CFG
{
    DWORD   dwSize;               //�ṹ���С
    BYTE     byConnectMode;    //����ģʽ:0->�������(TCP),1->�������,2->���ڽ���3-���������UDP��,4-��������,5-�ಥ
    BYTE     byRes1[3];         //����
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;    //����ģʽ����
    BYTE  byRes[64];
}NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD                  dwSize;              //�ṹ���С
    BYTE                  byFilterID;           //POS���˹���ID
    BYTE                 byFontSize;         //�ֺŴ�С��0-- 8*16  1--16*32  2--32*64 
    BYTE                  byShowPosInfo;        //�������Ƿ����pos��Ϣ
    BYTE                byOverlayMode;      //���ӷ�ʽ��0-������1-��ҳ
    DWORD                 dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR        struOsdColor;           //OSD��ɫ
    NET_DVR_SCHEDTIME        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    //�쳣����ʽ�б������������Ű󶨣������Ϊ0ʱ����ʾ�����ı�������ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ�����ı�������ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ���� ��ǰ�ļ����ں����ı���������Ч
    DWORD                  dwMaxRelRecordChanNum ;  //����������¼��ͨ������ֻ�������֧������
    DWORD                  dwRelRecordChanNum ;     //�����ڹ�����¼��ͨ���� 
    DWORD                  dwRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    //������¼��ͨ��������Ű󶨣������Ϊ0ʱ����ʾ������ͨ���ŷ�ΧΪ1-64�������Ϊ1ʱ����ʾ������ͨ���ŷ�ΧΪ65-128�� �������ڽ������У��������0xffffffff��ʾ�����ں����Ĺ���ͨ������Ч
    DWORD                 dwTimeOut;        /*time Out(5-3600s)*/ //���ݳ�ʱָ�ڶ೤ʱ����ղ���POS���ݼ��ж�һ�����ݰ��Ľ�����
    BYTE              byRes[60];    //����
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG; 

#define        MAX_LAN_ENCODE_LEN        32    //���Ա����ʽ��󳤶�
typedef struct    tagNET_DVR_DEVICE_LAN_ENCODE
{    
    DWORD        dwSize;        
    BYTE        byLanEncode[MAX_LAN_ENCODE_LEN];    //�豸���Ա����ʽ
    BYTE        byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byEnable; //ʹ�ܣ��Ƿ��� 0~������,1~����
    BYTE    bySensitiveLevel;// 1-100��Ĭ��50��������Խ�ߣ�Խ���ױ���
    BYTE    byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    DWORD    dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD    dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];//����¼��ͨ��
    //����������¼��ͨ�������ֽڵ�ͨ���ţ���ʼֵ�� 0xffffffff��
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION,*LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD            dwSize;          // �ṹ��С
    NET_VCA_DEV_INFO struDevInfo;    //ǰ���豸��Ϣ
    WORD      wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE             byRes[126];      // �����ֽ�
}NET_DVR_SCENECHANGE_DETECTION_RESULT,*LPNET_DVR_SCENECHANGE_DETECTION_RESULT;

typedef enum
{
    PREVIEW_MOD = 0,
        ALARM_MOD,
        PLAYBACK_MOD,
        MAX_TYPE
}MODULE_TYPE;

//��λ��Ϣ
typedef struct tagNET_DVR_PARK_INFO
{ 
    char          sPlateNo[MAX_PlATE_NO_LEN];             //���ƺ��� 
    char          sParkIndex[MAX_PlATE_NO_LEN];        //��λ���
    BYTE          byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;


typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD                 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*����ʱ��*/
    NET_DVR_PARK_INFO    struParkInfo; //��λ��Ϣ
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //����Ϣ
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //��Դ��Ϣ
}NET_DVR_STREAM_SRC_CFG,*LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP, 9-RTP+PS�����꣺GB28181����0xff-��Ч
    BYTE  byVideoEncType;//��Ƶ�������ͣ�0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��0xff-��Ч
    WORD  wWidth; //ͼ����
    WORD  wHeight; //ͼ��߶�
    BYTE  byRes1[2];
    DWORD dwVideoBitrate;     //��Ƶ����,��λKbps
    DWORD dwVideoFrameRate;    //֡�ʣ�200���ʾС��1֡/���״̬������ֵ��ʾʵ��֡��ֵ,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//��Ƶ�������ͣ�0-G722��1-G711_U��2-G711_A��5-MPEG2,6-G726��7-AAC,0xff-��Ч    
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;


typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//��ID��ת��ͨ����Ϣ    
    BYTE  byMode;//ת��ģʽ��1-����ת�룬2-����ת��
    BYTE  byLinkNums;//������
    BYTE  byPassiveTransMode; //����ת��ģʽ��0-��Ч��1-ʵʱ����2-�ļ���
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//Ŀ��ת��ip��ַ
    BYTE  byTransResource;//��ʹ�õ�ת����Դ������D1����
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//Դ������Ϣ
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//Ŀ�������Ϣ
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//ȫ��ת����Դ����D1Ϊ��λ����
    DWORD dwIdleResource;//ʣ��ת����Դ����D1Ϊ��λ����
    BYTE  byCpuLoad;//CPU������
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-ͨ��ģʽ��2-��IDģʽ
    BYTE  byDisplayMode; //0-��ͨ��1-����
    BYTE  byEnableVcaDec; //�Ƿ��������ܽ��룬0-�����ã���0-����
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE,*LPNET_DVR_DEV_WORK_MODE;


typedef struct tagNET_DVR_PASSIVETRANSINFO 
{
    DWORD dwSize;
    BYTE byStreamType;// �������ͣ�0-��������1-������
    BYTE byLinkMode;// 0��TCP��ʽ,1��UDP��ʽ��������
    BYTE byPassiveTransMode; //����ת��ģʽ��1-ʵʱ����2-�ļ���
    BYTE byRes1[5];    
    BYTE byDataType;//���������ͣ�1-SDP��2-����ͷ
    BYTE byRes2;
    WORD wDataLength;//���ݳ���
    char *pBuffer;//������
    BYTE byRes3[32]; // ����
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;          //�Ƿ���ʾ��1-��ʾ��0-����    
    BYTE  byBaseMapType;     //��ͼ���ͣ�1-ͼƬ��ͼ��2-�����������ͼ��3-��ͼ��ѵ
    BYTE  byBaseMapCircleNo; //��ͼ��ѵ������ţ�byBaseMapTypeΪ3ʱ��Ч
    BYTE  byRes1;
    DWORD dwBaseMapNo;     //��ͼ�ţ���ͼ����Ϊ1ʱ���˲���ΪͼƬ��ţ���ͼ����Ϊ2ʱ�˲���Ϊ������������ϵͳ����ںţ�1�ֽھ����+1�ֽ��Ӱ��+1�ֽ�����ں�+1�ֽڱ�����
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG,*LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //�ֱ��ʣ�MAKE_RESOLUTION�궨���ֵ���ӵ���ǽ������ȡ֧�ֵķֱ���ֵ
    BYTE byRes[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byWndOperateMode;  //���ڲ���ģʽ��0-ͳһ���꣬1-�ֱ�������
    BYTE  byRes1[6];
    NET_DVR_RECTCFG_EX struWinPosition;//Ŀ�Ĵ���(�����ʾǽ),��ͼ���ڵ���ʼ����ʹ�С�����ǻ�׼�����������
    NET_DVR_RECTCFG_EX struResolution; //Ŀ�Ĵ��ڷֱ������꣬��ȡ�򰴷ֱ�������������Ч
    DWORD dwXCoordinate; //LED�������Ͻ�X���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
    DWORD dwYCoordinate; //LED�������Ͻ�Y���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
    BYTE  byRes2[36];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//ͼƬ����
    BYTE   byUsed; //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-����
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO,*LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO��С������BMP���ļ�ͷ��ͼƬ��С���ޣ���100K���ߺͿ�����32�ı���
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO,*LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo�Ƿ���ڣ�0-�����ڣ�1-���ڣ��˲���ֻ�ܻ�ȡ��
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO��С������BMP���ļ�ͷ(�˲���ֻ�ܻ�ȡ)
    BYTE   byLogoName[NAME_LEN];  //logo����
    DWORD  dwLogoNo;    //logo��ţ���ȡ����logo��Ϣʱ��Ч��
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG,*LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo��
    BYTE   byEnable; //logo�Ƿ���ʾ��1-��ʾ��0-����
    BYTE   byRes1[3];    
    DWORD  dwCoordinateX;    //ͼƬ��ʾ����X����
    DWORD  dwCoordinateY;    //ͼƬ��ʾ����Y����    
    BYTE   byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE   byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE   byRes2[34];                //����    
}NET_DVR_WIN_LOGO_CFG,*LPNET_DVR_WIN_LOGO_CFG;    


typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //���ںţ���1��ʼ��0��ʾ��ͼ
    BYTE  byEnable; //�Ƿ����Ƶ��1-����Ƶ��0-�ر���Ƶ
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //0-����״̬��1-�Ŵ�״̬
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //�Ŵ����򣬵�byZoomStatusΪ1ʱ��Ч
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS,NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;          // �ṹ��С
    DWORD           dwChannel;;     // ͨ����
    BYTE            byRes[16];      // �����ֽ�
}NET_DVR_RESUME_INITRACKPOS_CFG,*LPNET_DVR_RESUME_INITRACKPOS_CFG;

typedef  struct tagNet_DVR_TEST_SELFCHECK_RESULT   
{
    DWORD   dwSize;     
    DWORD   dwChannel;      //ͨ����            
    BYTE    bySelfCheckStatus;   //�Լ�״ֵ̬ 0-δ��ʼ��1-�ɹ���2-ʧ�ܣ�3-�Լ���
    BYTE    byRes[23];   //�����ֽ�
}NET_DVR_TEST_SELFCHECK_RESULT, *LPNET_DVR_TEST_SELECHECK_RESULT;


typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;     
    DWORD   dwChannel;       //ͨ����
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM]; 
    //0-��ʾ���������ԣ� 1-��ʾ��������
    //�����±�0 �����ϻ����Գ���                               
    //�����±�1 ����ƽ������ģʽ
    //�����±�2 ICR�ϻ����ԣ�0��ʾ�رգ�1��ʾ������������bit0 ��ϣ���0000_0001(ֻ����Ѳ���ϻ�)��0000_0101��ͬʱ����Ѳ����ICR�ϻ�����0000_0100��ֻ����ICR�ϻ��� 
    //�����±�3 -���pt�Խ�������״̬��0��ʾ����Խ�������δ�����1��ʾ����Խ������������
    //�����±�4 ����ɨ����Գ���0��ʾ�رգ�1��ʾ����
    //�����±�5 ��������У������0��ʾ�رգ�1��ʾ����
    WORD    wICRIntervalTime;//icr���ʱ�䣨byTestCommand �����±�2�ڵ�ֵΪ1ʱ��ICR���ؼ��ʱ�䣬��λ�룩
    BYTE    byElectronicCompassState;//����״̬���أ� 0-������ 1-������
    BYTE    byRes1[1];
    float   fDeviceTem; //�豸��о�¶ȣ���ȷ��0.001
    BYTE    byTemp[9];  //���ڶ�������豸�� �±�0-ȫ���������� ��1-4��ȫ��1��4��sensor�������� ��5-8��ȫ��2��4��sensor������,Ŀǰ����ӥ��ȫ��
    BYTE    byRes[3];      //�����ֽ� 
}NET_DVR_TEST_COMMAND, *LPNET_DVR_TEST_COMMAND;

typedef struct  tagNET_DVR_AGING_TRICK_SCAN
{
    DWORD   dwSize;
    DWORD   dwChannel;       //ͨ����
    BYTE     byAging; // ��ʾ���õĲ��� Ϊ�ϻ�ǰ���߻����ϻ��󹤾ߣ� 0-�ϻ�ǰ��1-�ϻ��� 
    BYTE     byWriteReadEnalbe; //��дָ��ʹ�ܣ�0-���ö�ָ� 1-����дָ��
    BYTE     byRes[126];      //�����ֽ�
}NET_DVR_AGING_TRICK_SCAN, *LPNET_DVR_AGING_TRICK_SCAN;

#define IPC_PARAM_AGING_TRICK_SCAN        0x00000001 //�������ɨ���������
typedef struct tagNET_DVR_IPC_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //�������ͣ���λ��ʾ    
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //�������ɨ���������
    BYTE byRes[32];
}NET_DVR_IPC_PARAM_TYPE, *LPNET_DVR_IPC_PARAM_TYPE;

typedef struct  tagNET_DVR_ECCENTRIC_CORRECT_STATE
{
    DWORD   dwSize;
    DWORD   dwChannel;       //ͨ����
    BYTE     byEccentricCorrectState; // ƫ�Ľ���״̬��0-У��ʧ�ܡ�1-У���ɹ���2-У����
    BYTE     byRes[127];      //�����ֽ�
}NET_DVR_ECCENTRIC_CORRECT_STATE, *LPNET_DVR_ECCENTRIC_CORRECT_STATE;



#define MAX_DEVMODULE_NUM 8
typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //ͨ����
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //���Ե��豸����
    // 0-����������,1-��������
    // bit0-���Է���1
    // bit1-���Է���2
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //���Ե��豸����
    // 0-����������,1-��������
    // bit0-���Լ�����1
    // bit1-���Լ�����2
    BYTE    byRes[22];      //�����ֽ�
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;

//���������
typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE  byLaneNo;//�����ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-����1��
    BYTE  byRes[3];
}NET_DVR_BARRIERGATE_COND,*LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-�޲���,1-����բ
    BYTE   byRes1 ;
    WORD   wAlarmOperateType;//0-�޲���,bit0-�̵���������� bit1-�����ϴ����� bit3-�澯�����ϴ����ɸ�ѡ��(0-��ʾ�أ�1-��ʾ��)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL,*LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-�������豸��1-����բ��2-�ص�բ��3-ͣ��բ��4-�����źš�5-������
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM,*LPNET_DVR_RELAY_PARAM;

//���������
typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable ;// ʹ��0-��ʾ�رգ�1-��ʾ��
    BYTE    byBarrierGateCtrlMode;//0-����Զ����ƣ�1-ƽ̨�ⲿ����
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//��������ģʽ �ο�ITC_TRIGGERMODE_TYPE
    /*0x00: ����ƥ��*/
    /*0x01: ����ƥ�䣨��������ɫ��*/
    /*0x02: ����ƥ�䣨����������ɫ��*/
    /*0x04: ����ƥ��*/
    DWORD  dwMatchContent;  //�쳣����,�쳣����ʽ��"��"���
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//�̵�������������Ϣ(һ���̵���ֻ�ܿ���һ�������豸) ����0��ʾ�̵���1 ����1��ʾ�̵���2 �������� 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //����IO��������������IO��������������0��ʾIO1������1��ʾIO2���������� ; ��������ֵ�ĺ��壨0-�ޣ�1-��բ����λ��2-��բ�ص�λ��3-����������
    //������Ϣ�ܿ�  
    //����0��ʾ��ʱ�������õ�ģʽ
    //����1-������������ģʽ, 
    //����2-������������ģʽ
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//������Ϣ�ܿ�  
    BYTE    byNotCloseCarFollow;//���ø�������բʹ�ܣ�0~Ϊ�����ã�1~����
    BYTE  byParkingDetectEnabled;//����פ�����ʹ�ܣ�0~Ϊ�����ã�1~����
    BYTE  byParkingDetectJudgeTime;//פ������ж�ʱ�䣬��λ��
    BYTE    byRes2[61];
}NET_DVR_ENTRANCE_CFG,*LPNET_DVR_ENTRANCE_CFG;
////////////////////////////����ڲ������� end///////////////////////////////

// ��բ����
typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byLaneNo;  //��բ�ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-��բ1��
    /*
    ���ϵ�ƽ̨��֧��byUnlock�ֶΣ����ֶν���ֵΪ0��ͨ����0-�رյ�բ,1-������բ,2-ֹͣ��բ���е��κ�һ�ֲ����Կɽ��н�����
    ����ƽ̨֧��byUnlock�ֶΣ���byUnlock�ֶθ�ֵΪ1�������4~������բ�����н�����byUnlock�ֶθ�ֵΪ1�󣬡�0-�رյ�բ,1-������բ,2-ֹͣ��բ���������������ڽ�����
    */
    BYTE  byBarrierGateCtrl;//0-�رյ�բ,1-������բ,2-ֹͣ��բ 3-������բ,4~������բ
    BYTE  byEntranceNo;//����ڱ�� [1,8]
    BYTE  byUnlock;//���ý���ʹ�ܣ�0~Ϊ�����ã�1~����
    BYTE  byRes[12];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;

//����ںڰ�����������ͬ��
typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//ͨ����0xff - ȫ��ͨ����ITC Ĭ����1��
    DWORD  dwDataIndex;//������ˮ�ţ�ƽ̨ά��������Ψһֵ���ͻ��˲�����ʱ�򣬸�ֵ������Ч����ֵ��Ҫ������������ͬ����
    char   sLicense[MAX_LICENSE_LEN]; //���ƺ���
    BYTE   byListType;//�������ԣ��ڰ�������0-��������1-������
    BYTE   byPlateType;    //��������
    BYTE   byPlateColor;    //������ɫ
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // ����
    NET_DVR_TIME_V30  struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30  struStopTime;//��Ч����ʱ��
    //��������ƽ̨ͬ������ˮ�Ų����ظ��������������£�����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0��2014-03-03
    char        sOperateIndex[MAX_OPERATE_INDEX_LEN]; 
    BYTE  byRes1[224]; // �����ֽ�
} NET_DVR_VEHICLE_CONTROL_LIST_INFO,*LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;

//����ȫ����ȡ�ӿ� �������ӻ�ȡ��
typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//ͨ����0xffffffff - ȫ��ͨ����ITC Ĭ����1��
    DWORD  dwOperateType;//�������ͣ�����VCA_OPERATE _TYPE�����ɸ�ѡ��
    char   sLicense[MAX_LICENSE_LEN];//���ƺ���
    char   sCardNo[MAX_CARDNO_LEN]; // ����
    BYTE   byListType;//�������ԣ��ڰ�������0-��������1-��������0xff-ȫ��
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//������ˮ��     
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND,*LPNET_DVR_VEHICLE_CONTROL_COND;

//�ڰ�����������Ҫͬ������
typedef struct
{
    DWORD    dwSize; 
    DWORD    dwDataIndex;//������ˮ�ţ����ֵ�����豸��ǰ���յ������ݵ����һ��������ˮ��,ƽ̨ͬ����ʱ�����һ����ˮ�ſ�ʼͬ����
    char     sOperateIndex[MAX_OPERATE_INDEX_LEN];  //��������ƽ̨ͬ������ˮ�Ų����ظ��������������£�����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0�� 2014-03-03
    BYTE     byRes[32];
}NET_DVR_VEHICLE_CONTROL_LIST_DSALARM, *LPNET_DVR_VEHICLE_CONTROL_LIST_DSALARM;

//�����������ڰ�������
typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //�������ԣ��ڰ�������0-��������1-��������2-��ʱ����
    BYTE  byPlateType;  //��������
    BYTE  byPlateColor;    //������ɫ
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//���ƺ���
    char  sCardNo[MAX_CARDNO_LEN];  // ����
    NET_DVR_TIME_V30 struAlarmTime; //����ʱ��
    DWORD dwChannel;          //�豸ͨ���ţ����ֱ������IPC����Ϊipcͨ���ţ��������DVR\nvr,��ΪDVR\NVR��ͨ����
    DWORD dwPicDataLen;   //ͼƬ���ݴ�С��0��ʾ��ͼƬ����Ϊ0�Ǳ�ʾ�����ͼƬ����
    BYTE  byPicType;    //ͼƬ���ͣ�0-JPEG
    BYTE  byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE  byRes3[2];
    char    *pPicData;
    BYTE  byRes2[48];
}NET_DVR_VEHICLE_CONTROL_ALARM,*LPNET_DVR_VEHICLE_CONTROL_ALARM;

//��������
typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//����ʱ��
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM,*LPNET_DVR_FIRE_ALARM;

//����豸���ƺ��������ݿ���Ϣ
typedef struct
{
    DWORD dwSize;
    DWORD dwDelType;//ɾ���������ͣ�ɾ���������ͣ�����VCA_OPERATE _TYPE�����ɸ�ѡ��
    char  sLicense[16]; //���ƺ���
    char  sCardNo[48]; // ���� 
    BYTE  byPlateType;    //��������
    BYTE  byPlateColor;    //������ɫ
    BYTE  byOperateType;    //ɾ����������(0-����ɾ��,0xff-ɾ��ȫ��)
    //2014-02-25
    BYTE  byListType;//�������ԣ��ڰ�������0-��������1-������ 2014-03-03
    DWORD dwDataIndex;//������ˮ��     
    //��������ƽ̨ͬ������ˮ�Ų����ظ��������������£�����ͬ����ͬ�����ĳһ����¼�ˣ���������ڴ棬���������0��2014-03-03
    char  sOperateIndex[MAX_OPERATE_INDEX_LEN]; 
    BYTE  byRes[24];        
} NET_DVR_VEHICLE_CONTROL_DELINFO, *LPNET_DVR_VEHICLE_CONTROL_DELINFO;

//�����ƹ���
typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //ͨ����
    BYTE  byLaneNo; //��բ�ţ�0-��ʾ��Чֵ(�豸��Ҫ����Чֵ�ж�),1-��բ1��
    BYTE  byBrightlampCtrl;//0-�رճ����ƣ�1-����������
    BYTE  byRes[14]; 
}NET_DVR_GATELAMP_INFO,*LPNET_DVR_GATELAMP_INFO;


//SDI����1.0
#define  MATRIX_MAX_OUTPUT_NUM      256              //����������ͨ������
typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize; 
    DWORD dwValidInputNum;     //��Ч������ͨ����
    DWORD dwValidOutputNum;    //��Ч�����ͨ����
    BYTE  byRes[64]; 
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize; 
    DWORD   dwInputChan;        //����ͨ���ţ�Ϊ0��ʾȡ����ָ������Ĺ�����ϵ
    DWORD   dwOutputChan;       //Ҫ�л��������ͨ����, (��Ļ������Ϊ��Ļ������(1�ֽ��豸��+1�ֽڱ���+2�ֽ���Ļ������)), 0xffffffff��ʾ�л����������
    DWORD   dwMatrixID; //����ID��
    BYTE    byRes[28]; 
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize; 
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //���ͨ������������ͨ��, dwIORelation[i] = j��ʾ���ͨ��(i + 1)������ͨ��j����,
    //dwIORelation[i] = 0��ʾ���ͨ��i + 1δ��������ͨ��                                                                
    BYTE    byRes[256]; 
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;


//�����ӿ�����
typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-����(����)��1-Զ�����ͷ�豸��2-����ڿ��ƻ���3-led��  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byRelativeIndex;//0-����(����)������(����ڽ�������) ��Χ 1~8 Led�����������Χ�ǣ�1��255��   0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    //    BYTE   byLaneID;// �߼�������    
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND,*LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//0-������1-Զ�����ͷ�豸��2-����ڿ��ƻ���3-led�� 
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE    byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//DEV IP��ַ 144
            WORD     wDevPort;//�豸�˿�
            BYTE     byRes[510];
        }struRrReader;//Զ�����ͷ�豸
        struct
        {
            BYTE byRs485No; //RS485���(����豸����һ�����ñ�ſ����ظ������Ͳ�һ�����ñ�Ż���)
            BYTE byDevCtrlCode;//�����ַ�����������豸(1-255)
            BYTE byAutoIssuedData;//�Ƿ��Զ��·���Ƭ���� 0-���Զ��·���1-�Զ��·�
            BYTE byOfflineDetEnable;//���߼�� 0-�رգ�1-����
            BYTE byDetCycle;//������ڣ�0��60 ��λ s��
            BYTE byRes[651];
        }struGateway;//����ڿ��ƻ�
        struct
        {
            BYTE byExternalMode;//0-RS485,1-����
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP��ַ 144 (��byExternalMode == 1 ʱ��Ч)
            WORD wDevPort;//�豸�˿�(��byExternalMode == 1 ʱ��Ч)
            BYTE byRs485No; //RS485���(����豸����һ�����ñ�ſ����ظ������Ͳ�һ�����ñ�Ż���)
            BYTE byDevCtrlCode;//�����ַ�����������豸(1-255)
            //led��ͨ�����ƿ�������ʾ�ģ���ͬ�Ŀ��ƿ�����֧�ֵ���ʾ��ʽ��ͬ
            BYTE byCtrlCardType;//���ƿ����� 0-����(��Чֵ) 1- EQ2013
            BYTE byLedScreenType;//������ 0-��ɫ�� 1-˫ɫ��
            BYTE byLedScreenUse;//����;0-���� 1-��λ�� 2-��ʾ�� 3-�շ���
            BYTE byLedDisplayMode;//��Ļ������ʾ��ʽ: 1 "������ʾ",    2 "����" ,3 "����" ,4 "����",     5 "����"
            char sLedCustomInfo[MAX_LED_INFO];//��Ļ������ʾ��Ϣ
            //led�����ɿ��ƿ����Ƶģ�led�����Ը�����Ŀʵ��ʹ�ø�����С����ʱ��Ҫ�ն�֪ͨ���ƿ�Ŀǰʹ�õ����������
            DWORD dwLedScreenH;//��ʾ����ɸ߶�����Ҫ��LED����
            DWORD dwLedScreenW;//��ʾ����ɿ������Ҫ��LED����
            BYTE byRes1[236];
        }struLed;//led��
    }uExternalDevInfo; //��byExternalMode ֵ�������ĸ���Ч
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;

//�����ӻ�ȡ����
typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS//Զ�����ͷ�豸
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//�豸����
    BYTE   byExternalDevTpye;//0-����(����)��1-Զ�����ͷ�豸��2-����ڿ��ƻ���3-led��  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byRelativeIndex;//0-����(����)���������(����ڽ���������) ��Χ 1~8  0xff-ȫ����Ϣ�������ӻ�ȡʱʹ�ã�
    BYTE   byOnline;//0-�����ߣ�1-����
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS,*LPNET_DVR_EXTERNAL_DEVSTATUS;

//�ն˳���ڼ������
typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;        //�ṹ����
    //���߼�⿪��ʱ�������⵽�豸���ߣ������ն�ƥ�俨Ƭ��Ϣ�������͵�բ����ָ�������ڿ��ƻ��������ɳ���ڿ��ƻ�����ƥ����Ƶ�բ
    BYTE   byOfflineDetEnable;//���߼�� 0-�رգ�1-����
    BYTE   byDetCycle;//������ڣ�0��60 ��λ s��
    BYTE   byDevCtrlCode;//����ڿ��ƻ������ַ�����������豸(1-255)
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG,*LPNET_DVR_ENTRANCEDET_CFG;

//�ն˳���ڿ���(���ƽӿ� �·���Ƭ��Ϣ)
typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD  dwSize; //�ṹ����
    BYTE   byDevCtrlCode;//����ڿ��ƻ������ַ�����������豸(1-255)
    BYTE   byManualIssuedData;//�ֶ������·� 0-�رգ�1-���� 
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND,*LPNET_DVR_ENTRANCEDEV_COMMAND;

//�ն˳���ڿ���(���ƽӿ� ����·���Ƭ��Ϣ)
typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize; //�ṹ����
    BYTE   byDevCtrlCode;//����ڿ��ƻ������ַ�����������豸(1-255)
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL,*LPNET_DVR_ENISSUED_DATADEL;

//����ڹ����շ���ϸ��������ʽ��
typedef  struct  _tagNET_ITS_PASSVEHICLE_COST_ITEM
{
    DWORD   dwSize;        //�ṹ����
    DWORD   dwPassVehicleID; //����������������ݵĹ�����������
    BYTE    byIntime[MAX_TIME_LEN]; //�볡ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byOuttime[MAX_TIME_LEN]; //����ʱ���ʽΪyyyymmddhh24missfff
    BYTE    byCardNo[MAX_CARD_LEN];   //����
    BYTE    byPlateInfo[MAX_LICENSE_LEN]; //���ƺ���
    float   fPayCost;       //�շѽ��(��λԪ)
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //������Ա����
    BYTE    byVehicleType; //��������  0-С�ͳ� 2 ���ͳ�
    BYTE    byRes1[3]; //Ԥ���ֶ�1
    DWORD   dwPayRuleID; // �շѹ�����ˮ��
    DWORD   dwFreeRuleID; // ���������ˮ��
    BYTE    byRes2[256]; // Ԥ���ֶ�2
}NET_ITS_PASSVEHICLE_COST_ITEM, *LPNET_ITS_PASSVEHICLE_COST_ITEM;

//����ڽ��Ӱ����ݣ�������ʽ��
typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;        //�ṹ����
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //������Ա����
    BYTE    byOperatorCard[MAX_CARD_LEN]; //������Ա����
    BYTE    byStartTime[MAX_TIME_LEN];//�ϰ�ʱ���ʽ����yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //�°�ʱ���ʽ����yyyymmddhh24miss
    float   fTotal_Pay;    //�����ϰ��ڼ��ܵ��շѽ��(��λԪ)
    DWORD   dwTotal_Records;   //�����ϰ��ڼ��ܵĹ����շѵļ�¼����
    BYTE    byRes[64]; //Ԥ��
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;


typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //�������ͣ����ITC_TRIGGERMODE_TYPE 
    BYTE   byRes[24]; 
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;



typedef struct tagNET_DVR_TEMP_HUMI
{ 
    DWORD    dwSize;            // ���ݳ��� && �汾�����ں�����չ��
    DWORD       dwChannel;         // ͨ���ţ�Ĭ��1
    int      iHumidity;         // ʪ�ȣ��������֣�val/1000��С�����֣�val%1000
    int      iTemp;             // �¶ȣ��������֣�val/1000��С�����֣�val%100
    BYTE     byRes[8];          // �����ֽ�    
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;


typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;      // ���ݳ��� && �汾�����ں�����չ��
    DWORD    dwChannel;     // ͨ���ţ�Ĭ��1
    DWORD    dwSoundMode;   // ����ģʽ: 0����ģʽ��1����ģʽ��2����ģʽ
    BYTE     byRes[12];     // �����ֽ�
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{ 
       DWORD    dwSize;// ���ݳ��� && �汾�����ں�����չ��
    DWORD    dwChannel;         // ͨ���ţ�Ĭ��1
    DWORD    dwMode;        // ��ȫģʽ: 1���ã��������ܣ�2�����ã�����������
    char     szRandCode[6];   //�豸������"�����֤��"
    BYTE     byRes[6];         // �����ֽ�
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD dwSize;
    BYTE  byPreviewFpsAdjMode;   /* Ԥ��֡�ʵ���ģʽ:0-�����ڣ���׼֡��Ԥ��,1-��׼��֡��Ԥ��,2-����GPS�ٶȽ���֡�ʵ��� */
    BYTE  bySelPeccType;           /* �Ƿ�ѡ��Υ������ */    
    BYTE  byOptHabit;             /* ȡ֤����ϰ��, 0:����ȡ֤;1:�̰�����ȡ֤ */    
    BYTE  byEnablePeccRec;      /* 1: ʹ��Υ��¼��ץȡ, 0: ��ֹΥ��¼��ץȡ */
    BYTE  byPicSize;                /*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA��7-XVGA��8-HD900p��9-HD1080��10-2560*1920��11-1600*304��12-2048*1536��13-2448*2048,14-2448*1200��15-2448*800��16-XGA(1024*768)��17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;            /* ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ�� */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG,*LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD         dwSize;
    NET_DVR_IPADDR    struAddr;                    // ƽ̨������IP
    WORD            wServerPort;                   // ƽ̨�����������˿ڣ�
    BYTE         bySeverProtocolType;            //ƽ̨Э������ 1-˽�У�2-Ehome
    BYTE            byStatus;                         //�豸ע�ᵽ��ƽ̨��״̬��1-δע�ᣬ2-��ע��
    BYTE         sDeviceId[NAME_LEN/*32*/];     //�豸ID����ƽ̨�ṩ
    char         sPassWord[PASSWD_LEN];  //����
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE         sPlatformEhomeVersion[NAME_LEN];//ƽ̨EHOMEЭ��汾
    /********* IPC5.1.7 �������� end 2014-03-21***********/
    BYTE         byNetWork;                //�������ͣ�0- �����壬1-�Զ���2-�����������ȣ�3-�������磬4-3G���磨�������磩��5-��������1��6-��������2
    BYTE         byAddressType;            //0 - ������, 1 - ipv4/ipv6��ַ��2 - ����
    BYTE         byProtocolVersion;            //Э��汾 0 - ������, 1 �C v2.0��2 �C v4.0,3-v2.6
    BYTE            byRes1;
    BYTE         sDomainName[MAX_DOMAIN_NAME/*64*/]; //ƽ̨������������byAddressTypeΪ2ʱ��Ч
    BYTE        byEnable;      //0-�رգ�1-����
    BYTE            byRes[139];          // �����ֽ�
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;

//�����ṹ
typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //ͨ����
    BYTE    byDetSceneID;//��ⳡ����[1],�����ǰ֧��1������, IPCĬ����0
    BYTE    byRes[63]; 
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//Ŀ����٣�0-�رգ�1-������Ĭ��0-�ر�
    BYTE bySensitivity;  //�����Ȳ�������Χ1-100��Ĭ��50
    BYTE byBackgroundUpdateRate;//���������ٶȣ���Χ1-100��Ĭ��50
    BYTE bySceneChangeLevel;//�����仯�ȼ�����Χ1-100��Ĭ��50
    BYTE byMinTargetSize;//��СĿ��ߴ磺��Χ1-100��Ĭ��50
    /*
    0-	Ĭ���ϴ����ͣ�COMM_UPLOAD_HEATMAP_RESULT��
    1-	�ϴ����ͣ�COMM_UPLOAD_HEATMAP_RESULT_PDC �� COMM_UPLOAD_HEATMAP_RESULT_DURATION��
    */
    BYTE byUploadHeatMapResultType;
    BYTE byDayReport;
    BYTE byWeekReport;
    float fConfidence;//���Ŷ�[0.00,100.00]
    BYTE byMonthReport;
    BYTE byYearReport;
    BYTE byRes[6];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

#define MAX_HEATMAPREGION_NUM 8

//�ȶ�ͼ������ýṹ
typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //ʹ�ܣ��Ƿ���
    BYTE  byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//����Χ
    NET_DVR_HEATMAP_PARAM  struHeatMap ; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    //����ʱ��
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

//�ȶ�ͼ�����ϴ�
typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*�豸��Ϣ*/
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    DWORD  dwMaxHeatMapValue;//����ȶ�ֵ
    DWORD  dwMinHeatMapValue;//��С�ȶ�ֵ
    DWORD  dwTimeHeatMapValue;// (ʱ���ȶ�ֵ)ƽ���ȶ�ֵ
    WORD   wArrayLine;//ͼƬ���ص���ֵ 
    WORD   wArrayColumn;//ͼƬ���ص���ֵ ��������ֵΪ0��ʱ�����ص�ֵ�ڴ���Ϣ�����ڣ�
    BYTE*  pBuffer;  //�ȶ�ͼƬ���ص�������Ϣ
    BYTE   byDetSceneID;//��ⳡ����[1],�����ǰ֧��1������, IPCĬ����0
    BYTE   byBrokenNetHttp;     //����������־λ��0-�����ش����ݣ�1-�ش�����
    WORD   wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE   byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char   cStartTimeDifferenceH;      /*��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14��+��ʾ����*/
    char   cStartTimeDifferenceM;      /*��ʼʱ����UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����*/
    char   cStopTimeDifferenceH;        /*����ʱ����UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����*/
    char   cStopTimeDifferenceM;       /*����ʱ����UTC��ʱ����ӣ���-30, 30, 45��+��ʾ����*/
    BYTE   byArrayUnitType; //����Ԫ�������ͣ�������Ϣ��ÿ�����ص����ݵ��������ͣ���1-byte��2-short,4-int
    BYTE   byRes1[2];
    DWORD  dwTotalTime;//ͣ��ʱ���ܺͣ���λ�룬����Աͣ��ʱ�䱨��ʱ�ϴ�
    BYTE   byRes[112];
}NET_DVR_HEATMAP_RESULT,*LPNET_DVR_HEATMAP_RESULT;

//�ȶ�ͼ�������� �����ṹ��
typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//ͨ����
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    BYTE    byReportType;//0-��Чֵ��1-�ձ���2-�ܱ���3-�±���4-�걨��
    BYTE    byDetSceneID;//��ⳡ����[1],�����ǰ֧��1������, IPCĬ����0
    BYTE    byHeatMapInfoType;//0~��ȡ�ռ��ȶ�ͼƬ��ʽ��1~��ȡ�ռ��ȶȾ�����Ϣ��ʽ��2~��ȡ�ռ��ȶ�ͼƬ�Ϳռ��ȶȾ�����Ϣ
    BYTE    byStatisticalModel;//ͳ��ģʽ  0s-������Ĭ�ϣ���1-ͣ��ʱ�䣬2-������ͳ�ƣ�
    BYTE    byRes[124];
}NET_DVR_HEATMAP_QUERY_COND,*LPNET_DVR_HEATMAP_QUERY_COND;

//�ȶ�ͼ�������� 
typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*�����ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;  /*�������ʱ��*/
    DWORD  dwHeatMapPicLen;         /*�ռ��ȶ�ͼƬ����(������ͼƬ��ʱ�򣬸��ֶ�Ϊ��0��û��ͼƬ��ʱ�򣬸��ֶ�Ϊ0)*/
    BYTE*  pBuffer;                 //�ȶ�ͼƬ������Ϣ
    DWORD  dwTimeHeatMapValue ;     //ʱ���ȶ�ֵ(���п��ȶ�ͼ��ʱ��,���ֶβ���Ҫ��ֵ)
    DWORD  dwHeatMapMaxValue;//�����������ȶȵ���Ա�ʱ��(s)(�ռ��ȶ�ͼʱ��Ч)
    DWORD  dwHeatMapMinValue;//�����������ȶȵ���Ա�ʱ��(s) (�ռ��ȶ�ͼʱ��Ч)
    WORD   wArrayLine;//ͼƬ���ص���ֵ ���ϴ��ȶȾ�����Ϣʱ��Ч��
    WORD   wArrayColumn;//ͼƬ���ص���ֵ ��������ֵΪ0��ʱ�����ص�ֵ�ڴ���Ϣ�����ڣ����ϴ��ȶȾ�����Ϣʱ��Ч��
    BYTE*  pArrayBuffer;//�ȶȾ���������Ϣ���������ݵ�͸������Ϣ����ΪwArrayLine* wArrayColumn*��Ԫ�������ͳ��ȣ�����byArrayUnitTypeΪ1��ʾΪint�ͣ������Ҫ����4���ֽڣ���
    BYTE   byArrayUnitType;//����Ԫ�������ͣ�������Ϣ��ÿ�����ص����ݵ��������ͣ���0~byte��1~int��(���豸�з��ؾ�����Ϣʱ��Ч)
    BYTE   byRes[107];
}NET_DVR_HEATMAP_INFO,*LPNET_DVR_HEATMAP_INFO;


typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //ͨ����
    NET_DVR_TIME_EX   struStartTime; //��ʼʱ��
    NET_DVR_TIME_EX   struEndTime; //����ʱ��
    BYTE    byReportType; //0-��Чֵ��1-�ձ���2-�ܱ���3-�±���4-�걨��
    BYTE    byEnableProgramStatistics; //�Ƿ񰴽�Ŀͳ�ƣ�0-��1-��
    BYTE    byTriggerPeopleCountingData;//��������ͳ�����ݵ�ʹ��, 0-��1-��
    BYTE    byMultiChannelSearch;//��ͨ����ѯʹ��, 0-��1-�ǣ�pSearchChannel ��dwSearchChannelNum��Ч��
    DWORD   dwPlayScheduleNo; //����Ŀͳ��ʱ�������ճ̺�
    BYTE    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE    byRes1[3];
    DWORD dwSearchChannelNum; //��ѯͨ����Ŀ
    char*    pSearchChannel;     //��ѯͨ���ţ���СΪsizeof(DWORD)* dwSearchChannelNum
    BYTE    byChild;//ֻ����ͯ, 0-��1-��
    BYTE    byMinTimeInterva;// ��Сʱ����,0-��Ч��1-15����, 2-30����, 3һСʱ, 4-��, 5-��, 6-��
    BYTE	byStatisticType;//ͳ�����ͣ�0-��Чֵ��1-����������2-�뿪������3-ȫ��,4-�����뿪�ظ�����,5-��������(��Ҫ�·�����֧�ֵ���������),0-��Чֵ��ʾ������ͳ�����͵�������ѯ���൱�ڱ����ֽڡ�ȫ����ʾͳ������Ϊ������뿪����������������
    BYTE    byFaceExpression;
    BYTE    byGender;
    BYTE    byMask;
    BYTE    byAgeGroup;
    BYTE    byGlasses;  /*�Ƿ���۾���0-δ֪��1-�ǣ�2-��3-��ī��,  4 - ȫ��,  0xff-�㷨֧�֣�����û��ʶ�����*/
    BYTE    byRes[96];
}NET_DVR_PDC_QUERY_COND,*LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PROGRAM_INFO
{
    DWORD   dwProgramNo; //��Ŀ���
    BYTE    sProgramName[NAME_LEN]; //��Ŀ����
    BYTE    byRes[16];
}NET_DVR_PROGRAM_INFO, *LPNET_DVR_PROGRAM_INFO;
typedef struct tagNET_DVR_POSINFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byEnable;// Pos��Ϣ���ӣ�0-�����ӣ�1-����
    BYTE    byBackpackEnanble;//�Ƿ���ӱ�����Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    bySexEnanble;//�Ƿ�����Ա���Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byCarryEnanble;//�Ƿ�����ණ����Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byRideEnanble;//�Ƿ�����ﳵ��Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byMaskEnanble;//�Ƿ���Ӵ�������Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byHatEnanble;//�Ƿ���Ӵ�ñ����Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    bySleeveEnanble;//�Ƿ���ӳ����������0-�����ӣ�1-����
    BYTE    byPantsTypeEnanble;//�Ƿ���ӿ���������Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byHairEnanble;//�Ƿ���ӳ��̷���Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byGlassesEnanble;//�Ƿ���Ӵ��۾���Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byAgeEnanble;//�Ƿ����������Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byHeightEnanble;//�Ƿ���������Ϣ�Ƿ���ӣ�0-�����ӣ�1-����
    BYTE    byRes[511];
}NET_DVR_POSINFO_OVERLAY, *LPNET_DVR_POSINFO_OVERLAY;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    DWORD   dwEnterNum;   //��������
    DWORD   dwLeaveNum;  //�뿪����
    NET_DVR_PROGRAM_INFO struProgramInfo;        //��Ŀ��Ϣ
    DWORD   dwPeoplePassing;        //��������
    BYTE    byRes1[8];    //�����ֽ�
    BYTE    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE     byRes3[3];    //�����ֽ�
    DWORD    dwDuplicatePeople;        // �ظ�����
    DWORD    dwExpressionUnknown;  //����δ֪
    DWORD    dwPokerFace;  //��������
    DWORD    dwHappy; //�������
    DWORD    dwSurprised; //���龪��
    DWORD    dwDisgusted; //�������
    DWORD    dwSad; //�����ѹ�
    DWORD    dwAngry; //�����ŭ
    DWORD    dwContemptuous; //��������
    DWORD    dwPanic; //���麦��
    DWORD    dwGenderUnknown; //�Ա�δ֪
    DWORD    dwFemale; //�Ա�Ů
    DWORD    dwMale; //�Ա���
    DWORD    dwMaskUnknown; //���δ֪
    DWORD    dwMaskYes; //�����
    DWORD    dwMaskNo; //�������
    DWORD    dwGlassUnknown; //�۾�δ֪
    DWORD    dwGlassYes; //���۾�
    DWORD    dwGlassNo; //�����۾�
    DWORD    dwSunglasses; //ī��
    DWORD    dwAgeGroupUnknown; //�����δ֪
    DWORD    dwChild;  //���������
    DWORD    dwYoung; //���������
    DWORD    dwMiddle; //���������
    DWORD    dwOld; //���������
    DWORD    dwInfant; //�����Ӥ�׶�
    DWORD    dwKid; //����ζ�ͯ
    DWORD    dwTeenager; //�����������
    DWORD    dwPrime; //�����׳��
    DWORD    dwMiddleAged; //�����������
    BYTE     byRes[64];
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;


typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*�豸����ʡ�ݵĺ��ּ�д  3 */ 
    BYTE  byTimeOsd;// ʱ����Ϣ���� 0 - �����ӣ� 1- ����
    BYTE  byRecogResultOsd;//ʶ��������  0 - �����ӣ� 1- ����
    BYTE  byRecogHint;//ʶ��ɹ���ʾ 0 - ����ʾ�� 1- ��ʾ
    BYTE  byRecogDir;//ʶ���� 0: ����, 1: ����
    BYTE  byRecogEnv;//ʶ�𻷾� 0: ����, 1: ����
    BYTE  byRecogPlateType;//0-С����ʶ��1-����ʶ��
    BYTE  byUploadPlate;//�Ƿ��ϴ����� 0 -���ϴ��� 1-�ϴ�
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG,*LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{    
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:�������״�  1:�����״� */    
    BYTE   byEnableAlarm;   /* 0:����������  1:�������� */    
    WORD   wOverSpeed;    /* ��ΧΪ20~250 */    
    BYTE   bySpeedUnits;  /* 0:����/Сʱ   1:Ӣ��/Сʱ */    
    BYTE   bydirection;     /* 0:�����״��복���� 1:�����״��복���� */    
    BYTE   byMeasureMode;   /* 0:��̬ (�״�״̬)       1:��̬ (�״�״̬)*/    
    BYTE   byTargetType;    /* 0:���(�״���ٳ������)  1:���(�״���ٳ������)*/    
    BYTE   bySensitivity;  /* ������[0,100] */                          
    BYTE   byCaptureNum;   /* ץ������[0,255] */                                
    BYTE   byUploadPlate;  /*�Ƿ��ϴ�����ץ��ͼƬ 0-���ϴ���1-�ϴ�*/    
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG,*LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* ���������Ƿ���к��������� 0-���飬1-������*/    
    BYTE  byCheckAlarm;/* ����ɹ����� 0-��������1-����*/    
    BYTE  byCheckHint; /* ����ɹ���ʾ (�����ʾ) 0-����ʾ��1-��ʾ*/    
    BYTE  byUploadBlackCar; /*�Ƿ��ϴ��ڳ���Ϣ 0-���ϴ���1-�ϴ�*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG,*LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//ͨ����0xff - ȫ��ͨ����Ĭ����1,����һ��ͨ����
    NET_DVR_PLATE_INFO  struPlateInfo; //������Ϣ
    WORD  wIllegalType; //Υ�����Ͳ��ù��궨�� ���ο�������
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// Υ��������Ϣ��128��
    NET_DVR_TIME_V30  struIllegalTime;//Υ��ʱ��
    BYTE  byIllegalVehicleNum;//����Υ������
    BYTE  byRes1[3];
    char sCustomInfo[64];//�Զ�����Ϣ
    BYTE  byRes2[128]; // �����ֽ�
}NET_DVR_VEHICLE_CHECK,*LPNET_DVR_VEHICLE_CHECK;

typedef enum _LONG_CFG_SEND_DATA_TYPE_ENUM_
{
    ENUM_DVR_VEHICLE_CHECK = 1, //�������������ݻ�������
    ENUM_MSC_SEND_DATA = 2, //��Ļ��������������
    ENUM_ACS_SEND_DATA = 3, //�Ž�������������
    ENUM_TME_CARD_SEND_DATA = 4, //ͣ����(����ڿ��ƻ�)��Ƭ��������
    ENUM_TME_VEHICLE_SEND_DATA = 5, //ͣ����(����ڿ��ƻ�)������������
    ENUM_DVR_DEBUG_CMD = 6, //����������Ϣ
    ENUM_DVR_SCREEN_CTRL_CMD =7, //��Ļ������������
    ENUM_CVR_PASSBACK_SEND_DATA = 8, //CVR��ȡ��ص�ش������ִ����
    ENUM_ACS_INTELLIGENT_IDENTITY_DATA = 9,  //�������ʶ���ն���������
    ENUM_VIDEO_INTERCOM_SEND_DATA = 10,  //���ӶԽ���������
    ENUM_SEND_JSON_DATA = 11    //͸��JSON����
}LONG_CFG_SEND_DATA_TYPE_ENUM;

typedef enum _LONG_CFG_RECV_DATA_TYPE_ENUM_
{
    ENUM_DVR_ERROR_CODE = 1, //������
    ENUM_MSC_RECV_DATA=2, //��Ļ��������������
    ENUM_ACS_RECV_DATA=3 //�Ž�������������
}LONG_CFG_RECV_DATA_TYPE_ENUM;

typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//����ʱ��������λ���룩[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//��������ʱ�䣨��λ���룩[2min~24h]������ʾ�����ӵ�λ
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM,*LPNET_DVR_WIPER_CONTINUEWORK_PARAM;

typedef union tagNET_DVR_WIPERMODE_PARAM_UNION
{
    BYTE uLen[16];
    //��byWiperWorkMode = 1ʱ��Ч
    NET_DVR_WIPER_CONTINUEWORK_PARAM struWiperContinueWorkParam; 
}NET_DVR_WIPERMODE_PARAM_UNION,*LPNET_DVR_WIPERMODE_PARAM_UNION;

typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //��ˢ����ģʽ
    //0-����ģʽ��1-����ģʽ��������ýṹNET_DVR_ROTATE_OPERATE_PARAM����2-����ģʽ��0xff-�ر�
    BYTE  byWiperWorkMode;
    BYTE  byRes1;
    WORD  wSensitivity;//����������
    BYTE  byRes[20];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG,*LPNET_DVR_WIPERINFO_CFG;

//�����Զ��Խ����� 
typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{ 
       DWORD     dwSize;
    DWORD     dwChannel;            //ͨ����
    BYTE      byRes[24];            // �����ֽ�
}NET_DVR_AUTOFOCUS_TESTCFG,*LPNET_DVR_AUTOFOCUS_TESTCFG;


typedef struct tagNET_DVR_VIDEO_OUT_CFG
{    
    BYTE    byDisplayMode;        //��ʾģʽ��1-��׼��2-��ɫ��3-ůɫ��0xff-�Զ���
    BYTE     byBrightnessLevel;     // ����ֵ0-100
    BYTE    byContrastLevel;     // �Աȶ�0-100
    BYTE     bySharpnessLevel;     // ���0-100
    BYTE     bySaturationLevel;     // ���Ͷ�0-100
    BYTE     byHueLevel;         // ɫ��0-100
    BYTE    byImageMode;        // ͼ��ģʽ��0-����ģʽ��1-ҹģʽ1��2-ҹģʽ2��3-ҹģʽ3��4-����ģʽ1��5-����ģʽ2��6-����ģʽ3
    BYTE    byRes[5];            // ����
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;
//ɫ��
typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{    
    BYTE    byRed;                //��ɫ�� 0-100
    BYTE    byGreen;            //��ɫ�� 0-100
    BYTE    byBlue;                //��ɫ��0-100
    BYTE    byRedOffset;        //��ɫƫ�ƣ�0-100
    BYTE    byGreenOffset;        //��ɫƫ�ƣ�0-100
    BYTE    byBlueOffset;        //��ɫƫ�ƣ�0-100
    BYTE    byRes[6];        
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{    
    BYTE    byGainR;            //����R�� 0-100
    BYTE    byGainG;            //����G��0-100
    BYTE    byGainB;            //����B��0-100
    BYTE    byOffsetR;            //ƫ����R��0-100
    BYTE    byOffsetG;            //ƫ����G��0-100
    BYTE    byOffsetB;            //ƫ����B��0-100
    BYTE    byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{        
    BYTE    byEnable;            //�Ƿ�������Ļ��Ե 0-������ 1-����
    BYTE    byLeftEdge;            //���Ե��0-100
    BYTE    byRightEdge;        //�ұ�Ե��0-100
    BYTE    byTopEdge;            //�ϱ�Ե��0-100
    BYTE    byLowerEdge;        //�±�Ե��0-100
    BYTE    byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;    
    BYTE    byCfgType;       /*���õĲ������ͣ���ȡʱ�˲�����Ч��0-��Ч��1-���������2-��Ƶ������3-ɫ�²�����4-ADC������5-��Ļ��Ե����*/
    BYTE    byBackLight;    //���� 0~100
    BYTE    byRes1[2];
    NET_DVR_VIDEO_OUT_CFG           struVideoOutCfg;     //��Ƶ����������ģʽ��
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //ɫ�²���
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC����
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //��Ļ��Ե����
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;
//ģ��ң������
typedef enum tagNET_DVR_SCREEN_REMOTE_CTRL_TYPE
{
    REMOTE_CTRL_POWERSUPPLY_OPEN = 1,//1-��Դ��
        REMOTE_CTRL_POWERSUPPLY_CLOSE = 2,//2-��Դ��
        REMOTE_CTRL_SIGNALSOURCE,//3-�ź�Դ
        REMOTE_CTRL_MENU,//4-�˵�
        REMOTE_CTRL_DETERMINATION,//5-ȷ��
        REMOTE_CTRL_ON,//6-��
        REMOTE_CTRL_UNDER,//7-��
        REMOTE_CTRL_LEFT,//8-��
        REMOTE_CTRL_RIGHT,//9-��
        REMOTE_CTRL_INFO,//10-INFO
        REMOTE_CTRL_RETURN,// 11-������һ��    
        REMOTE_CTRL_NUM, //12-���ּ���
}SCREEN_REMOTE_CTRL_TYPE;

//ģ��ң�ذ���
typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;    
    BYTE        byControlType;    //1-��Դ����2-��Դ�أ�3-�ź�Դ��4-�˵���5-ȷ����6-�ϣ�7-�£�8-��9-��,  10-INFO, 11-������һ��,12-���ְ���,13-����һ�尴��
    BYTE       byControlParam; //������������������Ϊ12ʱ����ʾ����ֵ��0-9������������ʱ�˲�����Ч
    BYTE        byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL,*LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

//��Ļ�ź�Դ����
typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;    
    BYTE     bySignalSourceType;    //����Դ��������ö�� NET_DVR_CAM_MODE
    BYTE     byNoSignalPic;            //���źŻ���ģʽ��1-������2-������3-LOGO����
    BYTE     byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

//��Ļƴ������
typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;    
    BYTE    bySpliceIndex;            //��ƴ�����ţ�0����û��ƴ�ӣ�����ֵ��ʾ��ƴ���������š�����ƴ��0101~0202��4����������4������bySpliceIndex������ͬ���ҷ�0.
    BYTE    bySpliceX;                //��Ļ����ƴ�����е���λ��
    BYTE    bySpliceY;                //��Ļ����ƴ�����е���λ��
    BYTE    byWidth;                //ƴ�ӹ�ģ������ĻΪ��λ
    BYTE    byHeight;               //ƴ�ӹ�ģ�ߣ�����ĻΪ��λ
    BYTE    byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

//���ȹ�����ʽ����
typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;    
    BYTE        byWorkMode;                 //1-������2-�Զ�
    BYTE        byTemperatureLimitValue; //���ȿ������¶ȷ�ֵ������ģʽΪ�Զ�ʱ�ò�����Ч��
    BYTE        byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

//VGA�ź�����
typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;    
    BYTE        byEnableAutoAdjust;      //�Ƿ��Զ�������0-��1-�ǣ����Զ���������ʱ���²�����Ч
    BYTE        byHorizontalPosition;   //ˮƽλ�� 0-100
    BYTE        byVerticalPosition;      //��ֱλ�� 0-100
    BYTE        byClock;                //ʱ�� ��0-100
    BYTE        byPhase;                //��λ��0-100
    BYTE        byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

//��Ļ�˵�����
typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;    
    BYTE        byMenuLanguage; //���ԣ�1-���ģ�2-Ӣ��
    BYTE        byTransparency; //͸���� 0-��͸����1-�ͣ�2-�У�3-��
    BYTE        byDuration;        //����ʱ�䣬0-������1-5�룬2-15�룬3-30��
    BYTE        byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

//���л�
typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;    
    BYTE    byEnable;    //�Ƿ����û��л� 0-������ 1-����
    BYTE    bySubWindowSource;    //�ӻ����ź�Դ���ο�ö��NET_DVR_CAM_MODE
    BYTE    bySubWindowBorderColor;    //�ӻ���߿���ɫ�� 1-��ɫ��2-��ɫ
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;    //�ӻ���λ�ã���Ļ�ܴ�СΪ100*100
    BYTE    byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

//͸������
typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;    
    BYTE    byDefogEnable;    //����͸���أ�0~�رգ�1~����
    BYTE    byDefogModel;     //͸��ģʽ��0~�Զ�ȥ��1~�ֶ�ȥ��
    BYTE    byDefogLevel;     //͸��ǿ�ȵȼ���1-7���ȼ���Ĭ�ϵȼ�Ϊ4���ȼ�1Ϊ0.5���ȼ�2Ϊ0.55���ȼ�3Ϊ0.60���ȼ�4Ϊ0.65���ȼ�5Ϊ0.70���ȼ�6Ϊ0.75���ȼ�7Ϊ0.80����ȥ��ģʽΪ�ֶ�ȥ��ʱ��������ȥ��ǿ�ȵȼ���
    BYTE    byRes[33];
}NET_DVR_DEFOG_LCD,*LPNET_DVR_DEFOG_LCD;

//��Ļάǽ
typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD    dwSize;
    BYTE    byEnable; //״̬���ء�0-Ϊ�رգ�1-Ϊ����
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

//��Ļλ��
typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD     dwSize;
    BYTE     byScreenRowNum;//��Ļ�кš�
    BYTE     byScreenColNum;//��Ļ�кš�
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;

typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize;     //�ṹ��ĳ���
    DWORD     dwChanNo;   //����Ƶͨ���ţ� �������ú󣬱��󶨵������Խ�ͨ������Ϊ��ͨ������ƵԴ
    BYTE      byEnable;   //�Ƿ����������Խ���Ϊ��Ƶ����Դ 0-������ 1-����
    BYTE      byRes[31];          //����
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{    
    DWORD   dwSize; 
    BYTE    byEnable;//ʹ��
    BYTE    byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //�쳣����ʽ
    DWORD    dwMaxRelRecordChanNum ;  //����������¼��ͨ�� ����ֻ�������֧������
    DWORD    dwRelRecordChanNum ;     //����������¼��ͨ�� �� ʵ��֧�ֵ�����
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30/*64*/];//����¼��ͨ����
    BYTE    byEnablePreset[MAX_CHANNUM_V30];
    BYTE    byPresetNo[MAX_CHANNUM_V30];
    BYTE    byEnableCruise[MAX_CHANNUM_V30];
    BYTE    byCruiseNo[MAX_CHANNUM_V30];
    BYTE    byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE    byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //���ղ���ʱ��
    BYTE  byRes[224];;
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{    
    DWORD dwSize;  //�ṹ���С
    BYTE    byEnable;//ʹ��
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;        //�쳣����,�쳣����ʽ��"��"���   
    /*0x00: ����Ӧ*/
    /*0x01: �������Ͼ���*/
    /*0x02: ��������*/
    /*0x04: �ϴ�����*/
    /*0x08: �����������*/
    /*0x10: ����JPRGץͼ���ϴ�Email*/
    /*0x20: �������ⱨ��������*/
    /*0x40: �������ӵ�ͼ(Ŀǰֻ��PCNVR֧��)*/
    /*0x200: ץͼ���ϴ�FTP*/ 
    DWORD   dwMaxRelAlarmOutChanNum ; //�����ı������ͨ������ֻ�������֧������
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/]; //* ʵ�ʴ����ı�������ţ���ֵ��ʾ,���ý��������У����±�0��ʼ˳���ȡ���������0xffffffff�������Ч*/ 
    /*������¼��ͨ��*/
    DWORD     dwMaxRecordChanNum;   //�豸֧�ֵ�������¼��ͨ����-ֻ��
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];     /* ʵ�ʴ���¼��ͨ������ֵ��ʾ,���ý��������У����±�0��ʼ˳���ȡ���������0xffffffff,�������Ч*/ 
    DWORD dwEnablePresetChanNum;  //��ǰ������Ԥ�õ����Ŀ
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/]; //���õ�Ԥ�õ���Ϣ����dwEnablePresetChanNum��Ϊ0ʱ�������±�0-(dwEnablePresetChanNum -1)��Ч����Ϊ0ʱ����ʾδ����Ԥ�õ�
    BYTE byRes2[516];                    /*����*/
    DWORD dwEnableCruiseChanNum;  //��ǰ������Ѳ����ͨ����Ŀ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/]; //����Ѳ������ͨ������Ϣ����dwEnableCruiseChanNum��Ϊ0ʱ�������±�0-( dwEnableCruiseChanNum -1)��Ч����Ϊ0ʱ����ʾδ����Ѳ��
    DWORD dwEnablePtzTrackChanNum;  //��ǰ������̨�켣ͨ����Ŀ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/]; //������̨�켣��ͨ����Ϣ����dwEnablePtzTrackChanNum��Ϊ0ʱ�������±�0-(dwEnablePresetChanNum -1)��Ч����Ϊ0ʱ����ʾδ������̨�켣
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //���ղ���ʱ��
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;  //�ṹ���С;
    BYTE     byEnableCS;  //�����ƴ洢����  0-�ر� 1-����
    BYTE     byRes[511];     //����
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;


typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize ; //�ṹ���С
    BYTE    byValid;       //�Ƿ���Ч
                           /*(ֻ��)¼�����ͣ�0: ����¼��1����¼�� 2-���� 
                           3-������ 4-��������Ƶ 5-δ���� 6-�浵�� 7-�ش��� 
    8-�û���������� 9-δ��֤,10-�浵�к�¼���� 11-¼��ش��к�¼����*/
    BYTE    byRecord;     
    DWORD   dwRelatedHD;  //��������
    BYTE    byOffLineRecord;  //����¼���� 0-�ر� 1-����
    BYTE     byRes[63];        //�����ֽ�
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

#define  MAX_CAMERAID_LEN    64
typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;   
    DWORD             dwRecordType; //¼������  0- ��ʱ¼��1- �ƶ����¼��2- ����¼��3- �������ƶ����¼��4- �������ƶ����¼�� 5- �������6- �ֶ�¼��7- �𶯱�����8- ��������������9- ���ܱ�����10- �ش�¼��
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //¼��ʼʱ��
    NET_DVR_TIME_EX   struStopTime;  //¼�����ʱ�� 
    DWORD             dwStoragePoolID; //�洢��ID
    BYTE              byFormatType ;     //��װ���ͣ�1-������2-RTP��װ��3-PS��װ��4-TS��װ��5-˽�У�6-FLV��7-ASF��8-3GP��9-RTP+PS�����꣺GB28181����0xff-��Ч
    BYTE              byVideoEncType ;       //��Ƶ�������ͣ�0-˽��264��1-��׼h264��2-��׼mpeg4��7-M-JPEG��8-MPEG2��0xfe- �Զ�����Դһ�£���0xff-��Ч 
    BYTE              byAudioEncType;  //��Ƶ�������ͣ�0-G722��1-G711_U��2-G711_A��5-MP2L2��6-G726��7-AAC��0xfe- �Զ�����Դһ�£���0xff-��Ч 
    BYTE   	          byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char       cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char       cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char       cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char       cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE              byRes[120];
}NET_DVR_UPLOAD_RECORD_INFO,*LPNET_DVR_UPLOAD_RECORD_INFO;

//����Ʋ�������  �����ṹ��
typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//ͬ�������(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND,*LPNET_DVR_IOOUT_COND;

//����Ʋ�������
typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD  dwSize;
    BYTE   byWorkMode;// 0-�������,1-Ƶ����(Ĭ��)
    BYTE   byRes1[3];
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//Ĭ��״̬ 0-�͵�ƽ(Ĭ��)��1-�ߵ�ƽ
            BYTE   byWorkState;//��Ч״̬ 0-�͵�ƽ(Ĭ��),1-�ߵ�ƽ,2-����
            BYTE   byFreqMulti;//��Ƶ����ֵ��Χ[1,15]
            BYTE   byDutyRatio;//ռ�ձȣ�[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;    //���������ʱ��ʹ��:0-��;1-��
            NET_DVR_SCHEDTIME  struFlashLightTime;//���������ʱ��
            BYTE   byRes1[116];
        }struStrobeLamp;    // Ƶ���� ʱ��Ч
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG,*LPNET_DVR_IOOUT_CFG;

//�źŵ�ͬ������
typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//��λ(0~360)
    BYTE   byLineLock;//��Դͬ�� 0-��1-��
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG,*LPNET_DVR_SIGNAL_SYNCCFG;

// өʯEZVIZ��������ṹ��
typedef struct
{
    DWORD    dwSize; 
    BYTE    byEnable;// ����EZVIZ���� 0�����ã�1������
    /********* IPC5.1.7 �������� Begin 2014-03-21***********/
    BYTE    byDeviceStatus; //�豸�Ƿ�����״̬��0-������1-���ߣ�2-����
    BYTE    byAllowRedirect;    //�Ƿ������ض���,0-����,1-��,2-��,0��ʾ���ֲ���,������SDK�����豸�����
    BYTE    byDomainName[MAX_DOMAIN_NAME];    //������������ַ
    BYTE    byRes1;
    BYTE    byVerificationCode[NET_SDK_MAX_VERIFICATION_CODE_LEN/*32*/];//өʯ����֤��
    BYTE    byNetMode;  //����ģʽ��0-�����壬1-�Զ���2-�����������ȣ�3-��������(Ĭ��)��4-��������
    BYTE    byOfflineStatus;    //�豸���߾���״̬: 0-������1-өʯע����֤����Ч�����ֶ�Ϊֻ�����ҵ�DeviceStatusΪ2ʱ��Ч��
    BYTE    byEnableTiming;// ����EZVIZУʱ 0�����ã�1������
    BYTE    byRes2;
    BYTE    byOperateCode[NET_SDK_MAX_OPERATE_CODE_LEN];  //�����룬�û����豸ʱʹ��
    BYTE    byRes[344];
}NET_DVR_EZVIZ_ACCESS_CFG,*LPNET_DVR_EZVIZ_ACCESS_CFG;

typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0��ʾ�ƶ���⣬ 
    1��ʾ��Ƶ�ڵ��� 
    2��ʾ��Ƶ��ʧ�� 
    3��ʾPIR������ 
    4��ʾ���߱����� 
    5��ʾ���ȱ����� 
    6��ʾ����ץͼ�� 
    7��ʾ������⣬ 
    8��ʾԽ�������⣬ 
    9��ʾ����������⣬ 
    10��ʾ���������⣬
    11 ��ʾ�쳣��⣬
    0xff ��ʾ��������
    */
    BYTE  byAlarmType; 
    //�������� 0-��Ч,1-ץͼ�ϴ�FTP,2-Jpegץͼ�ϴ�Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    //��������Ż���ͨ���Ż������߱��
    //(��byAlarmType ==0xffʱ,dwChannel��ʾ���Ǳ��������)
    //(��byAlarmType ==4ʱ,dwChannel��ʾ�������߱��)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND,*LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum ; //�����ı�������ͨ������ֻ�������֧������
    //dwRelateChan�ĳ�ʼֵ��0xffffffff;��������д��ʵ�ʵ�ͨ����;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG,*LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //���ñ����䱶���� 0-��1-��
    BYTE   byPresetFreezing; //����Ԥ�õ���Ƶ���� 0-��1-��
    BYTE   byPresetSpeed;//Ԥ�õ��ٶȵȼ� 1--8��Ĭ��4
    BYTE   byKeyboardCtrlSpeed;//�ֿ��ٶȵȼ�0-��,1-��,2-��
    BYTE   byAutoScanSpeed;//ɨ���ٶȵȼ���1--40��Ĭ��28
    BYTE   byZoomingSpeed;//�䱶�ٶȣ�1--3��Ĭ��3
    BYTE   byManualControlSpeed;//�ֿ��ٶ�ģʽ��0-���ݣ�1-���ˣ�2-�ǻ�������3-��������4-����Ӧ
    BYTE   byPTZMotionTrack;//�����˶����٣�������̨������ 0-Ĭ�ϣ���������1-�ر�
    BYTE   byRes[124]; 
}NET_DVR_PTZ_BASICPARAMCFG,*LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //��ͷ������ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPtStatus;    //��λ����ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPresetStatus;//Ԥ�õ������ʾ��1-2�롢2-5�롢3-10�롢0xff-���ء�0-������Ĭ��2��
    BYTE   byPositionDisplayFormat;//��λ����ʾ��ʽ 0-����PT��ʾ(�� P179|T-02)��1-���շ�λ��ʾ(SE123|T-02)
    BYTE   byRes[124]; 
}NET_DVR_PTZ_OSDCFG,*LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //�������ģʽ��Oxff-���á�1-30�롢2-60�롢3-300�롢4-600�룬Ĭ��30��
    BYTE   byRes[127]; 
}NET_DVR_PTZ_POWEROFFMEMCFG,*LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan; //ͨ����
    BYTE   byLimitMode; //��λģʽ 0-������1-������λ��2-ɨ����λ
    BYTE   byRes[63]; 
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//����ʹ�ܣ�0-��1-��
    BYTE   byLimitStatus; //��λ״̬ 0-δ��λ��1-����λ�����ɱ༭�� 
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCFG,*LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byLimitMode; //��λģʽ 0-������1-������λ��2-ɨ����λ
    BYTE   byWorkMode ;//0-���ã�1-���
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCTRL,*LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode ;//��̨�������� 0-������1-����
    BYTE   byRes[123]; 
}NET_DVR_PTZ_LOCKCFG,*LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//ͨ����
    BYTE    byRes[64];
}NET_DVR_PTZLOCKINFO_COND,*LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec ;//ʣ������
    BYTE    byRes[128];    //�����ֽ�
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    WORD   wRouteNo;//Ѳ��·����
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND,*LPNET_DVR_CRUISEPOINT_COND;

typedef struct
{
    WORD    wPresetNo;    //Ԥ�õ�
    WORD    wDwell;    //ͣ��ʱ��
    BYTE    bySpeed;    //�ٶ�
    BYTE    bySupport256PresetNo;//����֮ǰ�� ��256��Ԥ�õ��Ƿ���Ч
    BYTE    byRes[6];
}NET_DVR_CRUISEPOINT_PARAM,*LPNET_DVR_CRUISEPOINT_PARAM;

typedef struct
{
    DWORD  dwSize;
    // ���֧��128��Ѳ����
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISE_POINT_NUM];
    BYTE     Res[64]; //����
}NET_DVR_CRUISEPOINT_V40, *LPNET_DVR_CRUISEPOINT_V40;

typedef struct
{
    DWORD  dwSize;
    // ���֧��256��Ѳ����
    NET_DVR_CRUISEPOINT_PARAM struCruisePoint[MAX_CRUISEPOINT_NUM_V50];
    BYTE     Res[64]; //����
}NET_DVR_CRUISEPOINT_V50, *LPNET_DVR_CRUISEPOINT_V50;


typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;

#define MAX_DISPLAY_NUM         512  //�����ʾ�������
#define MAX_LEDCONTENT_NUM      512  //����LED�ַ�����󳤶�
#define MAX_PPT_CHAN            128     //PPT����

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//ʹ��
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//���귶Χ�����ݻ�׼��������֧�ֵ�ƴ��ģʽ
    BYTE  sName[NAME_LEN]; //����ǽ����
    BYTE  byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//��ʾ�����
    BYTE  byDispChanType;/*�������ģʽ,1-BNC��2-VGA��3-HDMI��4-DVI��5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI����Ӧ��10-3GSDI,11-VGA/DVI����Ӧ��12-HDBaseT,13-HDTVI, 14-TVI��0xff-��Ч*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM,*LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/] ;
    BYTE  byRes[128];
}NET_DVR_DISPLAYCFG,*LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byCoordinateType;//�������͡�0-��׼���꣬1-ʵ������
    BYTE    byRes1[2];
    //ǽ��,1�ֽ�ǽ��+3�ֽڱ���
    DWORD    dwVideoWallNo; 
    DWORD   dwDisplayNo;//��ʾ�����
    //������Ϊ��׼�������������1920*1920������Ⱥ͸߶�ֵ�������ã���Ϊ��׼ֵ
    NET_DVR_RECTCFG_EX struRectCfg;
    BYTE    byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION,*LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

/*������Ϣ*/
typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //����ʹ��,0-��ʹ�ܣ�1-ʹ�� 
    BYTE  byWndOperateMode;  //���ڲ���ģʽ��0-ͳһ���꣬1-�ֱ�������
    BYTE  byRes1[6];
    DWORD dwWindowNo;//���ں�
    DWORD dwLayerIndex;//�������Ӧ��ͼ��ţ�ͼ��ŵ�����ö����ö�����
    NET_DVR_RECTCFG_EX struRect; //Ŀ�Ĵ���ͳһ����(�����ʾǽ)����ȡ��ͳһ��������ʱ��Ч
    NET_DVR_RECTCFG_EX struResolution; //Ŀ�Ĵ��ڷֱ������꣬��ȡ�򰴷ֱ�������������Ч
   DWORD dwXCoordinate; //LED�������Ͻ�X���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
   DWORD dwYCoordinate; //LED�������Ͻ�Y���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
   BYTE  byRes2[36];
}NET_DVR_VIDEOWALLWINDOWPOSITION,*LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    //���ںţ�1�ֽ�ǽ��+1�ֽڱ���+2�ֽڴ��ں�
    DWORD    dwWindowNo; 
    DWORD   dwSceneNo;//������
    DWORD   dwDestWallNo; //Ŀ��ǽ��
    DWORD   dwDestSceneNo;//Ŀ�ĳ�����
    BYTE    byRes[12];
}NET_DVR_VIDEO_WALL_INFO,*LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM 
{
    DWORD   dwSize;
    BYTE    byEnable; //ʹ��
    BYTE    byDispMode; //��ʾģʽ��1-͸����2-��͸����3-����
    BYTE    byWndOperateMode; //���ڲ���ģʽ��0-ͳһ���꣬1-�ֱ�������
    BYTE    byType; //����LED���ͣ�0-�ı���1-ʱ��
    BYTE    byDirection; //����LED����0-ˮƽ����1-��ֱ����
    BYTE    byTimeType; //ʱ�����ͣ�byTypeΪ1ʱ��Ч��0-��Ч��1-ֻ��ʾʱ�䣬2-��ʾ���ں�ʱ��
    BYTE    byDateFormat; //������ʾ��ʽ��byTimeTypeΪ2ʱ��Ч
    //0-��Ч��1-XXXX-XX-XX(������)��2-XX-XX-XXXX(������)��3-XX-XX-XXXX(������)��4-XXXX��XX��XX�գ�5-XX��XX��XXXX�꣬6-XX��XX��XXXX��
    BYTE    byTimeFormat; //ʱ����ʾ��ʽ��byTimeType��Ϊ��ʱ��Ч
    //0-��Ч��1-H:MM:SS��2-HH:MM:SS
    NET_DVR_RGB_COLOR   struContentColor; //������ɫ
    NET_DVR_RGB_COLOR   struBackColor; //������ɫ
    NET_DVR_RECTCFG_EX  struRect;
    DWORD   dwContentNum; //�ı����ݳ��ȣ�byTypeΪ0ʱ��Ч
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; //�ı����ݣ�byTypeΪ0ʱ��Ч
    BYTE    byMoveMode; //�ƶ�ģʽ��1-��ͨ��2-ƽ����3-��ֹ
    BYTE    byFontSize; //�����С��1-1����2-2����3-4��
    BYTE    byMoveDirection; //�ƶ�����0-Ĭ�ϣ������ң���1-�����ң�2-���ҵ���3-���ϵ��£�4-���µ��ϣ���̬����LEDʱ��Ч
    BYTE    byMoveSpeed; //�ƶ��ٶȣ�1-�ٶ�1��2-�ٶ�2����̬����LEDʱ��Ч
    NET_DVR_RECTCFG_EX struResolution; //Ŀ�Ĵ��ڷֱ������꣬��ȡ�򰴷ֱ�������������Ч
    DWORD   dwXCoordinate; //LED�������Ͻ�X���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
    DWORD   dwYCoordinate; //LED�������Ͻ�Y���꣨ͳһ���꣩����ȡ�򰴷ֱ�������������Ч
    BYTE    byHourFormat; //ʱ����ʽ��byTimeType��Ϊ��ʱ��Ч��0-��Ч��1-12Сʱ�ƣ�2-24Сʱ��
    BYTE    byAMFormat; //AM��ʽ��byHourFormatΪ1ʱ��Ч��0-��Ч��1-AM��2-����
    BYTE    byPMFormat; //PM��ʽ��byHourFormatΪ1ʱ��Ч��0-��Ч��1-PM��2-����
    BYTE    byAlignmentX; //ˮƽ���뷽ʽ��byDirectionΪ0ʱ��Ч��0-��Ч��1-����룬2-���ж��룬3-�Ҷ���
    BYTE    byAlignmentY; //��ֱ���뷽ʽ��byDirectionΪ1ʱ��Ч��0-��Ч��1-���˶��룬2-���ж��룬3-�׶˶���
    BYTE    byFontType; //�������ͣ�0-Ĭ�ϣ�1-���壬2-���壬3-����
    BYTE    byRes2[90];
}NET_DVR_VIRTUALLED_PARAM,*LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //ͼ���и�ģʽ��1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE,*LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{ 
    DWORD  dwSize ;
    DWORD  dwSerialPort; //��ǰʹ�ô��ں�
    BYTE byProtocolType; //����Э�����ͣ�1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 �� 4-LCD-DLP�� 5-LCD-S3 , 6-LCD-D20��7-LCD-L2,8-LCD-Z1��9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+ 
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT,*LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//��������
    BYTE  byEnable;//�����Ƿ���Ч 1-��Ч��0-��Ч
    BYTE  bySceneIndex;     //�����ţ�ֻ�ܻ�ȡ����ȡ���г���ʱʹ�øò���
    BYTE  byRes [78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //����ǽ��Ϣ
    DWORD dwCmd; //�����������1-����ģʽ�л������Ҫ�л����ǵ�ǰ�������򲻽����л�����2-��ʼ�����������˳�����������գ�����ǵ�ǰ��������ͬʱ�Ե�ǰ��������������������3-ǿ���л��������Ƿ��ǵ�ǰ������ǿ���л�����4-���浱ǰģʽ��ĳ���� 5-ɾ������ ,6-��������
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{ 
    DWORD dwSize;
    DWORD dwDisplayNo;  //��ʾ����ںţ�0xffffffff��ʾ����������ڽ��в���
    BYTE  byEnable;     //ʹ����ʾ��0-����ʾ��1-��ʾ
    BYTE  byChanType;   //��ʾ��ͨ�����ͣ�1-��ʾͨ���ţ�2-��������
    BYTE  byRes1[2];
    DWORD dwWallNo; //ǽ�ţ�1�ֽ�ǽ�ţ���λ��+3�ֽڱ�������ʾ��Ļ���ʱ��Ч
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO,*LPNET_DVR_SHOW_CONTROL_INFO;

typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;    //������ָ��
    DWORD   nLen;    //����������
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //����������
    NET_DVR_BUF_INFO struInParamBuf;         //����������
    DWORD  dwRecvTimeout;      //�������ݳ�ʱʱ�䣬��λ��ms,��0���ýӿ�Ĭ�ϳ�ʱ
    BYTE   byRes[32];
}NET_DVR_IN_PARAM,LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf;            //�������������
    void*  lpStatusList;       //״̬������    
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM,LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;    
    DWORD dwChannel;   //��Ƶͨ������ϣ�1�ֽ��豸��+1�ֽ��Ӱ��+2�ֽ���Ƶͨ���ţ�
    BYTE  byRes[48];   
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO; 

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //��Ƶͨ������
    BYTE          byEnable; //��Ƶ�Ƿ����� 0-�أ� 1-��
    BYTE          byAudioSwitchType; //��Ƶ�л���ʽ��1-��ǰ��Դ��ʽ��2-�����ڽ���Դ��ʽ 
    BYTE          byRes[2]; 
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //��ƵԴ��Ϣ byAudioSwitchTypeΪ1ʱ��Ч
    DWORD         dwWindowNo; //�Ӵ��ںţ�1�ֽ�ǽ��+1�ֽ��Ӵ��ں�+2�ֽڴ��ںţ���byAudioSwitchTypeΪ2ʱ��Ч
    BYTE          byRes2[28]; 
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

#define MAX_SUBBOARD_NUM        42        //����ʽ�����豸����Ŀ
#define MAX_SINGLE_BOARD_EXCEPTION_NUM 16 //������󲢷��쳣��
typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //���ڹ���ģʽ��1-RS484,2-RS232
    BYTE byFunType; //���ڹ��ܣ�1-���̿��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PTZ����  5-������� 6-����̨
    BYTE byDataBit;// �����м�λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    DWORD dwBaudRate;//������0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    WORD wProtocol;//����Э�飬��ͬ���ڹ��ܶ�Ӧ����Э�鲻һ��
    BYTE byVariable ;  //�����Ƿ�ɱ䣬1-���ɱ�  2-�ɱ� ��ֻ��ȡ��
    BYTE byGateWayEnable; //�Ƿ��������أ�0-���������أ�!0��������
    BYTE byRes[30];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;   
    BYTE       byBoardType;    //���ͣ�0-���壬1-DVI-I���룬2-YPbPr���룬3-BNC���룬4-SDI���룬 5-DVI˫��·���룬 6-��ͨ��������룬 7-DVI-I����� 8-SDI���, 9-��ǿ�ͽ�������룬10-DP���룬11-HDTVI���룬12-HDBaseT�����13-HDMI���룬14-HDBaseT��15-DVI-T���룬16-HDMI�����17-HDMI-HD���� ,18-HDMI-UHD���� , 19-DP_UHD����,0xff-δ֪���� //���ͣ�0-���壬1-DVI-I���룬2-YPbPr���룬3-BNC���룬4-SDI���룬 5-DVI˫��·���룬 6-��ͨ��������룬 7-DVI-I����� 8-SDI���, 9-��ǿ�ͽ�������룬10-DP���룬11-HDTVI���룬12-HDBaseT�����13-HDMI���룬14-HDBaseT��15-DVI-T���룬16-HDMI�����17-HDMI-HD���� ,18-HDMI-UHD���� , 19-DP_UHD����,0xff-δ֪���� 
    BYTE       byInterfaceNum;  //�ӿ���
    BYTE       byStatus;        //״̬��0-�쳣�� 1-����
	BYTE       bySyncStatus;   // �������ͬ��״̬��0-δ����ͬ���� 1-����ͬ��  
    DWORD      dwSlotNo;       //���ڲ�λ�� 
    BYTE       byRes2[32];  
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //�������ͣ� 1-4U�� 2-8U�� 3-13U, 0xff-δ֪����
    BYTE      bySoltNum;        //��λ��Ŀ
    BYTE      byBoardNum;   //��Ч��Ŀ
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //ǰbyBoardNum����Ч 
    BYTE       byRes2[32]; 
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE         byExceptNum;         //�쳣����
    BYTE        byRes1[3];               
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //������
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //������
    BYTE        byRes2[32]; 
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;


typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //ͨ����
    BYTE    byLinearScanType; //��λ���ͣ�0-����,1-��߽�����,2-�ұ߽�����
    BYTE    byRes[63]; 
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

//����������Ϣ
typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //�ṹ���С
    BYTE  byStreamWithVca; //�����е���������Ϣ���ɹ����к������0-������,1-����
    BYTE  byRes[127];      //����
}NET_DVR_STREAM_ATTACHINFO_CFG,*LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;    
    BYTE   byDefaultRoute;  //Ĭ��·�ɣ�0��ʾstruEtherNet[0]��1��ʾstruEtherNet[1]
    BYTE   byNetworkCardNum;      //�豸ʵ�ʿ����õ�������Ŀ
    BYTE   byRes1[2]; //����
    NET_DVR_ETHERNET_MULTI struEtherNet [MAX_NETWORK_CARD]; //��̫����
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

//�������
typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byAllPreset; //������е�Ԥ�õ㣺0-��,1-��
    BYTE   byAllPatrols; //������е�Ѳ��·����0-��,1-��
    BYTE   byAllPatterms; //������еĻ���ɨ�裺0-��,1-��
    BYTE   byAllPrivacyMasks; //������е���˽�飺0-��,1-��
    BYTE   byAllPTZLimited; //������е���λ���ã�0-��,1-��
    BYTE   byAllScheduledTasks; //������еĶ�ʱ����0-��,1-��
    BYTE   byAllParkAction; //������е�������0-��,1-��
    BYTE   byRes[125]; 
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

//��̨����������Ϣ
typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //��̨���ȣ�0-Rs485��1-���磬Ĭ������
    BYTE   byRes[3];
    DWORD   dwDelay; //��ʱ��2---200��
    BYTE   byRes1[124]; 
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

//�㷽λ�ǿ���
typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byWorkMode ;//0-���ã�1-���
    BYTE   byRes[127]; 
}NET_DVR_INITIALPOSITIONCTRL,*LPNET_DVR_INITIALPOSITIONCTRL;

//��˽�ڱβ���
typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan; //ͨ����
    BYTE   byRegionalID; //����ID�� 1��24
    //ɾ����ǰID��Ӧ����˽�ڱ���Ϣ 0-������1-ɾ�� ��WriteOnly��
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62]; 
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//�Ƿ����� 0-��1-��
    //��˽�ڱ��������ò����Ƿ���ʾ  0-��1-�� ��ReadOnly��
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0-����,1-�ҡ�2-�졢3-�̡�4-����5-�ȡ�6-�ơ�0xff-������
    BYTE   byActiveZoomRatio;//���α��ʣ�1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];//�ڵ��������ƣ�ֻʹ��16���ֽ�
    NET_VCA_POLYGON  struRegion;//����Χ
    //��ǰ���������Ƿ���Ч 0-��1-�� ����Ե���������������������Ϣ���͵������µĶ�������������������Ϣ��
    BYTE   byCurrentRegionEnable;
    //��ǰ����ʹ���ֶ� 0- byActiveZoomRatio ;1- fActiveZoomRatio(֧�������ڵ�curActiveZoomRatioType)
    BYTE   byCurZoomRatio ;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //���α���(��ȷ��С����1λ)��[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

//ȫ��ʹ��    
typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//����ʹ�ܣ�0-��1-��
    BYTE   byRes[127]; 
}NET_DVR_PRIVACY_MASKS_ENABLECFG,*LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

//�����˶�����������Ϣ
typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//����ʹ�� 0-��1-��
    BYTE  byRes[3];
    DWORD dwDuration;//����ʱ�䣺0--300�룬Ĭ��300��
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG,*LPNET_DVR_SMARTTRACKCFG;

//���ٱ���
typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//ͨ����
    BYTE   byRes[128]; 
}NET_DVR_ZOOMRATIOCTRL,*LPNET_DVR_ZOOMRATIOCTRL;


//���뿪����Ϣ
typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//���ſ���״̬
    BYTE   byRes[28]; 
}NET_DVR_DIAL_SWITCH_CFG,*LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS //¼��ʧ�����ӽṹ 
{
    NET_DVR_TIME_EX struInspectStart; //Ѳ�쿪ʼʱ��
    NET_DVR_TIME_EX struInspectEnd;   //Ѳ�����ʱ��
    NET_DVR_IPADDR  struIP;           //¼��ʧ��Ӧͨ����IP��ַ 
    DWORD  dwChanNo;                //ͨ����
    DWORD  dwIDIndex;                //������ID
    BYTE   sName[STREAM_ID_LEN];       //���������� 
    NET_DVR_TIME_EX struLossStartTime; //¼��ʧ��ʼʱ��
    NET_DVR_TIME_EX struLossEndTime;   //¼��ʧ����ʱ��
    DWORD  dwLostNum;                 //¼��ʧ���� 0xffffffff��ʾȫ����ʧ
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION //ȡ���쳣����  �ӽṹ 
{
    NET_DVR_IPADDR  struIP;           //������Ƶ�쳣ͨ����IP��ַ 
    DWORD  dwChanNo;                //ͨ����
    DWORD  dwIDIndex;                //������ID
    BYTE   sName[STREAM_ID_LEN];       //���������� 
    BYTE   byExceptionCase;           //�쳣ԭ��0-����д���쳣 1-��������쳣
    BYTE   byRes[307];                //����
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;


typedef struct tagNET_ALARM_RESOURCE_USAGE  //��Դʹ�ñ��� �ӽṹ
{ 
    BYTE   byLevel;    //ʹ����������س̶ȵ����� 0-������1-һ���澯���� 2-�����澯���� 3-�����澯����  
    BYTE   byRes[491]; //����
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION //¼���쳣���� �ӽṹ
{ 
    BYTE    byReason;    //�쳣ԭ�� 0-¼����� 1-¼����쳣 2-�޿���lun��
    BYTE    byRes1[3];   //����
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //¼���ID��Ӳ�̺ţ�
    BYTE    byRes[452];  //����
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;

typedef union tagNET_ALARM_CVR_SUBINFO_UNION  //CVR�����ӽṹ
{
    BYTE byLen[492];   //�����峤��
    NET_ALARM_RECORDFILE_LOSS     struRecordLost; //¼��ʧ
    NET_ALARM_STREAM_EXCEPTION     struStreamException; //ȡ���쳣
    NET_ALARM_RESOURCE_USAGE     struResourceUsage;  //��Դʹ��
    NET_ALARM_RECORD_EXCEPTION   struRecordException; //¼���쳣
}NET_ALARM_CVR_SUBINFO_UNION, *LPNET_ALARM_CVR_SUBINFO_UNION;

#define  MAX_VARIABLE_DATA_NUM    65535  //���ɱ����ݸ���

typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //���������� 0-������(ͨ��)�ź���������1-˽�о���𻵣�2- NVR�����˳���3-������״̬�쳣��4-ϵͳʱ���쳣��5-¼���ʣ���������ͣ�6-������(ͨ��)�ƶ���ⱨ����
    //7-������(ͨ��)�ڵ�����; 8-¼��ʧ����; 9-��Ƶʵʱ��ⱨ��; 10-��Դʹ���ʸ澯; 11- CVR�Զ��޸��쳣�� 12-¼���쳣
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //������Ϣ�ӽṹ ��������Ϊ8,9,10,11,12ʱ����������Ч
    BYTE             byRes[256];
    DWORD            dwNumber; //�ɱ����ݸ���
    WORD             *pNO; //������Ϊ0��3��6��7ʱ�����ܻ���ͨ���ţ�������Ϊ5ʱ�����ܻ��д��̺š��ɱ�ʾ��ֵ��ΧΪ0~65535    
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

typedef struct tagNET_DVR_CONTROL_START_CFG //һ����ʼ������Ϣ
{
    BYTE    byUseDefine; //ʹ���Զ��壬 0-ʹ��Ĭ�ϣ�1-ʹ���Զ���
    BYTE    byRes1;
    WORD    wCourseIndex; //�γ�����
    BYTE    byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//һ���ӳ�¼�������Ϣ
{
    BYTE    byUseDefine; //ʹ���Զ��壬 0-ʹ��Ĭ�ϣ�1-ʹ���Զ���
    BYTE    byRes1;
    WORD    wDelayTime; //¼���ӳ�ʱ��<����¼��ʱ���Դ�Ϊ׼>����λs
    BYTE    byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;

typedef union tagNET_DVR_CONTROL_INFO_UNION  //������Ϣ������
{
    BYTE    byLen[132]; //�����峤��
    NET_DVR_CONTROL_START_CFG  struStartCfg;   //һ����ʼ
    NET_DVR_CONTROL_DELAY_CFG  struDelayCfg;  //һ���ӳ�
}NET_DVR_CONTROL_INFO_UNION, *LPNET_DVR_CONTROL_INFO_UNION;

typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD    dwSize;        //�ṹ���С
    WORD    wCmdType;    //�����������ͣ�0-һ����ʼ��1-һ��������2-һ����ͣ��3-һ���ָ���4-һ���ӳ�,5-һ����ʼ���� 6-һ��ֹͣ����
    BYTE    byRes1 [2]; //����
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //������Ϣ������ʹ�ý�Ͽ�����������
    BYTE    byRes[256]; //����
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD     dwSize;  //�ṹ���С
    DWORD    dwOneKeyDelayTime; //һ�������ӳ�ʱ��  ¼�����¼��ʱ�� ��λ S
    BYTE     byDirectedMode; //����ģʽ��0-�Զ�������1�ֶ�������2-���Զ�����
    BYTE     byClassroomType;    //�������ͣ�0-��Ч��1-�����ң�2-�ӽ���
    BYTE     byCourseDataStorageEnabled;//��������ͳ���Ƿ�洢��Ӳ��, 0-���洢��1-�洢
    BYTE     byElectronicEnlargeMode;//�Ƿ�ʹ�õ��ӷŴ󵼲�, 0-��ʹ�ã�1-ʹ��
    BYTE     byRes[124];     //����
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_STATISTIC_DATA_COND
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //ͳ�ƶ������ͣ����TARGET_TYPE
    NET_DVR_TIME   struStartTime;//��ʼͳ��ʱ��
    NET_DVR_TIME   struStopTime;//����ͳ��ʱ��
    BYTE        byRes[280];
}NET_DVR_STATISTIC_DATA_COND, *LPNET_DVR_STATISTIC_DATA_COND;

typedef struct tagNET_DVR_STATISTIC_DATA_CFG
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //ͳ�ƶ������ͣ����TARGET_TYPE
    NET_DVR_TIME   struStartTime;//�¼���ʼʱ��
    NET_DVR_TIME   struStopTime;//�¼�����ʱ��
    BYTE        byRes[300];
}NET_DVR_STATISTIC_DATA_CFG, *LPNET_DVR_STATISTIC_DATA_CFG;

//typedef enum
//{
//    NET_SDK_ALL_TARGET = 0,          //ͳ�����ж���
//    NET_SDK_PPT_TARGET_ALARM,     //PPT����
//    NET_SDK_PPT_TARGET_VIEW,       //PPT��ͼ
//    NET_SDK_STU_SINGLE_ALARM,     //����ѧ������
//    NET_SDK_STU_SINGLE_VIEW,       //����ѧ����ͼ
//    NET_SDK_SUT_MULT_ALARM,       //���ѧ������
//    NET_SDK_STU_MULT_VIEW,         //���ѧ����ͼ
//    NET_SDK_STU_TEACHER_VIEW,     //ʦ��������ͼ
//    NET_SDK_TEA_UP_DOWN_ALARM,  //��ʦ���½�̨
//    NET_SDK_TEA_START_VIEW,        //��ʦ�ڿ���ͼ
//    NET_SDK_BLA_WRITE_ALARM,      //��д���鱨��
//    NET_SDK_BLA_WRITE_VIEW,       //��д������ͼ
//    NET_SDK_TEA_FULL_VIEW,         //��ʦȫ����ͼ
//    NET_SDK_TEA_START_ALARM,      //��ʦ��ʼ�ڿα���
//    NET_SDK_TEA_WALK_ALARM,      //��ʦ�߶�����
//    NET_SDK_TEA_LEFT_ALARM,       //��ʦ�뿪����
//    NET_SDK_TEA_RUN_ALARM,        //��ʦ���ܱ���
//    NET_SDK_TEA_MULT_ALARM       //��ʦ���˱���
//}TARGET_TYPE;

typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;   //�ṹ���С
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30] ; 
    //SDIͨ�����豸��ʵ�ʵ���������ʽ��ģ��ͨ����������ǰ��ʹ��IPͨ����
    BYTE   byCameraType[MAX_CHANNUM_V30];     //ͨ�������������ͣ�ֵΪ 0-�����壬1-��ʦ���٣�2-ѧ�����٣�3-��ʦȫ����4-ѧ��ȫ����5-��ý�壬6-��ʦ��λ,7-ѧ����λ,8-���鶨λ,9-�������, 0xff-δ����
    BYTE   byRes[64];     //����
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG; 

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE                byProtocolType;    //Э������ 0-FTP��1-SFTP
    BYTE                byRes1;     //����
    WORD                wFTPPort;  //�˿�
    BYTE                   byAddress[MAX_DOMAIN_NAME];  //IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    BYTE                szUserName[NAME_LEN/*32*/];        //�û���<����>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //����<����>
    BYTE                szCustomDir[128];    //����Ŀ¼,֧��Ŀ¼�ṹ
    BYTE                byRes[12]; //����
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //������URL��ַ��Ϣ
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE                byProtocolType;    //Э������ 0-FTP��1-SFTP
    BYTE                byRes1;     //����
    WORD                wFTPPort;  //�˿�
    BYTE               byAddress[MAX_DOMAIN_NAME];  //IP��������,��Ҫ�豸����
    //������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ
    BYTE                szUserName[NAME_LEN/*32*/];        //�û���<����>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //����<����>
    BYTE                  byDirLevel;                     /*0 = ��ʹ��Ŀ¼�ṹ��ֱ�ӱ����ڸ�Ŀ¼,1 = ʹ��1��Ŀ¼,2=ʹ��2��Ŀ¼*/
    BYTE                byTopDirMode;         /* һ��Ŀ¼��0x1 = ʹ���豸��,0x2 = ʹ���豸��,0x3 = ʹ���豸ip��ַ                     0xff=ʹ���Զ���*/
    BYTE                bySubDirMode;         /*����Ŀ¼��0x1=ʹ��ͨ������,0x2=ʹ��ͨ���ţ�0x3=ʹ�ÿγ����ƣ�0x4-ʹ���ڿ����ڣ�0xff-ʹ���Զ���*/
    BYTE              byRes2;
    BYTE               byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*�Զ���һ��Ŀ¼*/
    BYTE               bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*�Զ������Ŀ¼*/   
    BYTE                byRes[72]; //����
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;


typedef  union tagNET_DVR_PUBLISH_ADD_UNION
{
    BYTE    byLen[256]; //�����峤��
    NET_DVR_PUBLISH_HTTP_CFG struHttpCfg; //http��ַ��Ϣ
    NET_DVR_PUBLISH_FTP_CFG  struFtpCfg;  //ftp��ַ��Ϣ
    NET_DVR_PUBLISH_FTP_CFG_DIR struDirFtpCfg;  //��Ŀ¼��ʽ��FTP
}NET_DVR_PUBLISH_ADD_UNION, *LPNET_DVR_PUBLISH_ADD_UNION;

typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO //ͨ��¼�񷢲���Ϣ
{
    BYTE    byPublish; //�Ƿ񷢲���0-�������� 1-����
    BYTE    byRes1[3];
    DWORD  dwStreamType;   //һ�������������ͣ���λ��ʾ
    //&0x1-��ʾ������ 
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    BYTE    byRes[12];     //����
}NET_DVR_RECORD_PUBLISH_INFO,*LPNET_DVR_RECORD_PUBLISH_INFO;


typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byPublishType;    //������ʽ��0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3]; //����
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //һ��������ַ��Ϣ
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30]; //ͨ��¼�񷢲���Ϣ struChanPublis[0]��ʾͨ��1��Ӧ¼�񷢲���Ϣ
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //����ͨ��¼�񷢲���Ϣ
    BYTE                  byUploadTime;      //�Ƿ�������ʱftp�ϴ����� 0-�����壬1-��������2-����
    BYTE                byTimerMode;      //0-�����壬1-���α�ʱ�ϴ����һ�ڿε�¼��2-��ʱ��㷽ʽ�ϴ�ǰ24Сʱ¼��
    BYTE                  byUploadStartHour;    //��ʱ�䶨ʱ�ϴ���ʼʱ��  ʱ
    BYTE                byUoploadStartMin;    //��ʱ�䶨ʱ�ϴ� ��ʼʱ�� ��
    BYTE                byRes[1020]; //����
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;  //�ṹ���С
    BYTE  byUseDefine;  //ʹ���Զ���  0-ʹ��Ĭ�Ϸ���������Ϣ��1-ʹ���Զ��巢��������Ϣ
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //ͨ��¼�񷢲���Ϣ struChanPublis[0]��ʾͨ��1��Ӧ¼�񷢲���Ϣ
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //����ͨ��¼�񷢲���Ϣ
    NET_DVR_TIME_EX  struStartTime;  //�γ̿�ʼʱ��
    NET_DVR_TIME_EX  struEndTime;   //�γ̽���ʱ��
    BYTE    bySchedulePublish;  //�Ƿ񰴿α�����0�����α���1���α���
    BYTE    sFileName[COURSE_NAME_LEN/*32*/];  //�����ļ�����
    BYTE    byRes[31];
}NET_DVR_ONEKEY_PUBLISH_CFG,*LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD    dwSize;  
    char    sCourseName[COURSE_NAME_LEN/*32*/];  
    char    sInstructorName[INSTRUCTOR_NAME_LEN/*16*/]; 
    char    sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE    byIndex;        //�γ�����
    BYTE    byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime ;   //�γ���ֹʱ��
    WORD  wCourseIndex ;        //�γ�����
    WORD  wSessionIndex ;        //�ڴ�
    BYTE   byRes[4] ;            //����
}NET_DVR_EACH_LESSON_INFO,*LPNET_DVR_EACH_LESSON_INFO ;
// ��¼��״̬
typedef struct tagNET_DVR_CURRICULUM_CFG  //�α�ƻ� ������������
{ 
    DWORD  dwSize ;         //�ṹ���С
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/] ; //ÿ�ڿ���Ϣ
    BYTE   byRes[256] ; //����
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;

typedef  struct  tagNET_DVR_DATE_
{
    WORD         wYear;        //��
    BYTE        byMonth;        //��    
    BYTE         byDay;        //��                        
}NET_DVR_DATE,*LPNET_DVR_DATE;

typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD    dwSize ;
    BYTE    byEnablePPTDetect; //�Ƿ�����PPT���
    BYTE    byPptDetLevel; //������
    BYTE    byEnablePartScreen; //�Ƿ����ò�������
    BYTE    byRes1;
    WORD    wX; //��������
    WORD    wY;
    WORD    wWidth;
    WORD    wHeight;
    DWORD   dwChangePixelNum;//���ص�����ֵ[0,1000](ps : һ��ͼ���ж��������ڱ仯)
    BYTE    byRes[28];
}NET_DVR_PPT_DETECT_CFG,*LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_SCREEN_SWITCH_
{
    DWORD dwSize;
    BYTE  byRes[64];     //����
}NET_DVR_SCREEN_SWITCH, *LPNET_DVR_SCREEN_SWITCH;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD    dwSize ;
    BYTE    byChan[MAX_PPT_CHAN]; 
    BYTE    byRes[32];
}NET_DVR_PPT_CHANNEL_CFG,*LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;   //�Ƿ�����
    BYTE   byRes[11];
    //�����������ͣ���λ��ʾ
    //&0x1-��ʾ������ 
    //&0x2-��ʾ������
    //&0x4-��ʾ������
    DWORD  dwStreamType;  
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD     dwSize ;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];  //��Ҫ���ݵ�ͨ��,�����±��Ӧ��Ӧ��ͨ����
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //����ͨ��������Ϣ
    BYTE    byRes[256];      // �����ֽ� 
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

//���ڻ����
typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //���
    WORD  wRoomNumber;    //�����
    WORD  wDevIndex;      //���ڻ���ţ�0-10
    BYTE  byRes[122];     //����
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

//�ſڻ����
typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //�ں�, ��Χ[0,9]
    WORD wBuildingNumber; //¥��
    WORD wUnitNumber;  //��Ԫ��
    SHORT wFloorNumber;  //���
    WORD wDevIndex;  //�ſڻ���ţ�ÿһ�����ſڻ������Ψһ����0��ʼ
    BYTE byRes[118]; //����
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

//Χǽ�����
typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //�ں�, ��Χ[0,9]
    WORD wDevIndex;  //Χǽ����ţ�ÿһ�����ſڻ������Ψһ����0��ʼ
    BYTE byRes[124]; //����
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

//��������
typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //�ںţ���Χ[0,9]
    WORD wDevIndex;  //�������ţ�ÿһ���й���������Ψһ,��0��ʼ
    BYTE byRes[124]; //����
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;

//���ӶԽ��豸���������
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION
{   
    BYTE byLen[128] ; //�������С
    NET_DVR_INDOOR_UNIT_DEVICEID struIndoorUnit;   //���ڻ�
    NET_DVR_OUTDOOR_UNIT_DEVICEID struOutdoorUnit; //�ſڻ�/�Ž������豸
    NET_DVR_MANAGE_UNIT_DEVICEID struManageUnit; //�����
    NET_DVR_OUTDOOR_FENCE_DEVICEID struFenceUnit; //Χǽ��
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struVillaOutdoorUnit;  //�����ſڻ�
    NET_DVR_OUTDOOR_UNIT_DEVICEID  struAgainConfirmUnit;  //����ȷ�ϻ�
}NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION;

//�豸��Ų����ṹ��
typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{   
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType;   //�豸���ͣ�1-�ſڻ���2-����� 4-Χǽ��,5-�����ſڻ���6-����ȷ�ϻ���7-�Ž������豸
    BYTE byIsAutoReg;  //�Ƿ��Զ�ע�ᣬ0-��1-��
    BYTE byRes1[2];  //����
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;

//Ȩ����������
typedef enum tagPRIVILEGE_PASSWORD_TYPE_ENUM
{    
    ENUM_PRIVILEGE_PASSWORD_ENGINEERING = 1, //��������
        ENUM_PRIVILEGE_PASSWORD_SETUPALARM = 2, //��/��������
        ENUM_PRIVILEGE_PASSWORD_HOUSEHOLDER_UNLOCK  = 3, //������������
        ENUM_PRIVILEGE_PASSWORD_ANTI_HIJACKING  = 4, //���ٳ�����
        ENUM_PRIVILEGE_PASSWORD_PUBLIC1 = 5, //��������1
        ENUM_PRIVILEGE_PASSWORD_PUBLIC2 = 6, //��������2
        ENUM_PRIVILEGE_PASSWORD_PUBLIC3 = 7, //��������3
        ENUM_PRIVILEGE_PASSWORD_SENDCARD = 8//��������
}PRIVILEGE_PASSWORD_TYPE_ENUM;

//Ȩ��������Ϣ
typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{   
    DWORD  dwSize; //�ṹ���С
    BYTE   byPwdType; //�������ͣ��ο�PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];  //����
    BYTE   byOldPassword[PASSWD_LEN];  //������
    BYTE   byNewPassword[PASSWD_LEN]; //������
    BYTE   byRes2[128]; //����
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;


//���ڻ�����ʱ������
typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime; //������ʱ�䣬��Χ[10,60]��
    DWORD dwMaxRingTime; //�������ʱ�䣬��Χ[15,60]��
    DWORD dwCallForwardingTime; //����ת�Ƴ�ʱʱ�䣬��Χ[0,20]��
    DWORD dwRingDurationTime; //���峬ʱʱ�䣬��Χ[30,60]�룬Ĭ��30��
    BYTE  byRes[112];//����
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

//���������ʱ������
typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime; //�������ʱ�䣬��Χ[30,60]��
    DWORD dwMaxTalkTime; //���ͨ��ʱ�䣬��Χ[90,120]��
    BYTE   byRes[120]; //����
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;

//���������ʱ������
typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //������ʱ�䣬��Χ[10,60]��
    DWORD dwMaxRingTime;        //�������ʱ�䣬��Χ[15,60]��
    DWORD dwMaxTalkTime;        //���ͨ��ʱ�䣬��λs
    BYTE  byRes[116];           //����
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;

//���ӶԽ�����ʱ��������
typedef union tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION
{   
    BYTE byLen[128]; //�������С
    NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG struIndoorUnit; //���ڻ�
    NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG struOutdoorUnit; //�ſڻ�/Χǽ��/�����ſڻ�/����ȷ�ϻ�
    NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG struManageUnit; //�����
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION;

//���ӶԽ�����ʱ������
typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{   
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType; //�豸���ͣ�1-�ſڻ���2-�������3-���ڻ���4-Χǽ����5-�����ſڻ���6-����ȷ�ϻ�
    BYTE byRes1[3];  //����
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;

//���ڻ������������豸
typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit; //���ſڻ�IP
    NET_DVR_IPADDR struManageUnit;  //�����IP
    NET_DVR_IPADDR struSIPServer;    //SIP������IP
    NET_DVR_IPADDR struAgainUnit;   //����ȷ�ϻ�IP
    BYTE             byOutDoorType;  //���ſڻ����ͣ�0������1-����Ԫ�ſڻ���2-�������ſڻ�
    BYTE             byOutInConnectMode;  //�ſڻ������ڷֻ�����ģʽ��1-�ſڻ������ڷֻ�ͬһ������,2-�ſڻ������ڷֻ���ͬ��������
    BYTE             byIndoorConnectMode;  //�������������ڷֻ�����ģʽ��1-ͨ������������2-ͨ������������
    BYTE           byRes1;
    NET_DVR_IPADDR struIndoorUnit; //��������IP
    BYTE  byManageCenterID[32];  //��׼sipģʽ��ʹ�ã���������ID��֧�����֣���ĸ��@��.
    BYTE           byRes[268];       //����
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;

//�ſڻ�������������豸
typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{   
    NET_DVR_IPADDR struMainOutdoorUnit; //���ſڻ�IP�����ſڻ�ʱ��Ч
    NET_DVR_IPADDR struManageUnit;   //�����IP
    NET_DVR_IPADDR struSIPServer;     //SIP������IP�����ſڻ�ʱ��Ч
    BYTE           byManageCenterID[32];   //��׼sipģʽ��ʹ�ã���������ID��֧�����֣���ĸ��@��.
    BYTE           byRes[560];       //����
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;

//����ȷ�ϻ�������������豸
typedef struct tagNET_DVR_AGAIN_RELATEDEV
{   
    NET_DVR_IPADDR   struSIPServer;       //SIP������IP
    NET_DVR_IPADDR   struCenterAddr;      //����ƽ̨IP
    WORD             wCenterPort;         //����ƽ̨�˿�
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //��������IP
    NET_DVR_IPADDR struAgainAddr; //������ȷ�ϻ�IP��������ȷ�ϻ����ø��ֶΣ�
    BYTE             byRes[444];//����
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;


//�����������������豸
typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP������IP
    BYTE   byRes[880];       //����
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;


//���ӶԽ����������豸�����ṹ��
typedef union tagNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION
{   
    DWORD dwRes[256] ; //�������С
    NET_DVR_INDOOR_UNIT_RELATEDEV struIndoorUnit;   //���ڻ�
    NET_DVR_OUTDOOR_UNIT_RELATEDEV struMainOutdoorUnit; //�ſڻ�/Χǽ��/�Ž������豸
    NET_DVR_MANAGE_UNIT_RELATEDEV struManageUnit; //�����
    NET_DVR_OUTDOOR_UNIT_RELATEDEV  struVillaUnit;      //�����ſڻ�
    NET_DVR_AGAIN_RELATEDEV           struAgainUnit;      //����ȷ�ϻ�
}NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION,*LPNET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION;

//���������豸�����ṹ��
typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{   
    DWORD dwSize; //�ṹ���С
    BYTE byUnitType; //�豸���ͣ�1-�ſڻ���2-�������3-���ڻ���4-Χǽ����5-�����ſڻ���6-����ȷ�ϻ���7-�Ž������豸
    BYTE byRes1[3];  //����
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit; //ȡֵ�ο�byUnitType
    BYTE byRes2[128]; //����
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize; //�ṹ���С
    DWORD dwGatewayIndex; //�Ž���ţ���1��ʼ
    BYTE   byCommand; //�������0-�رգ�1-�򿪣�2-������ͨ��״̬����3-�ָ�����ͨ״̬��
    BYTE   byLockType; //�����ͣ�0-��ͨ����ǰĬ�϶�Ϊ0��,1-������
    WORD    wLockID; //��ID����1��ʼ��Զ�̿��ſڻ���ʱ��0��ʾ�ſڻ������������Ͻӵ�����1��ʾ��ӿ������Ͻӵ�����
    BYTE   byControlSrc[NAME_LEN]; //��������Դ��Ϣ
    BYTE   byControlType; //�������ͣ�1-���ӣ�2-ͨ��
    BYTE  byRes3[3];
    BYTE  byPassword[PASSWD_LEN];       //�����룬��byLockTypeΪ������ʱ��Ч
    BYTE  byRes2[108]; //����
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;


//����ͼƬ��Ϣ�ṹ��
typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData; //ͼƬָ��
    DWORD dwPicDataLen; //ͼƬ���ݳ���
    BYTE   byRes[32]; //����
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;

//��������
typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_TIME_EX struTime; //����ʱ��
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //������
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];//��������
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN]; //��������
    BYTE   byLevel; //����ȼ���1-�������Ϣ��2-��ҵ��Ϣ��3-��������Ϣ;4-֪ͨ����Ϣ
    BYTE   byPicNum; //����ͼƬ����
    BYTE   byRes1[2]; //����    
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM]; //����ͼƬ
    BYTE   byRes2[128]; //����
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;

//����Ȩ����֤����
typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize; //�ṹ���С
    BYTE   byPassword[PASSWD_LEN]; //��֤����
    BYTE   byRes[128]; //����
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;

//��������
typedef enum tagUNLOCK_TYPE_ENUM
{    
    ENUM_UNLOCK_PASSWORD = 1, //���뿪��
        ENUM_UNLOCK_HIJACKING  = 2, //�ٳֿ���
        ENUM_UNLOCK_CARD = 3, //ˢ������
        ENUM_UNLOCK_HOUSEHOLDER  = 4, //��������
        ENUM_UNLOCK_CENTER_PLATFORM = 5, //����ƽ̨����
        ENUM_UNLOCK_BLUETOOTH = 6, //��������
        ENUM_UNLOCK_QR_CODE = 7,   //��ά�뿪��
        ENUM_UNLOCK_FACE = 8,           //��������
        ENUM_UNLOCK_FINGERPRINT = 9,     //ָ�ƿ���
        ENUM_UNLOCK_DYNAMIC_CODE = 10      //��̬Ȩ���뿪��
}UNLOCK_TYPE_ENUM;


//�������ͣ��Ͳ�Ʒ��ȷ�ϣ��˶���û��ʹ�ã�ʹ�õ���DETECTOR_TYPE
// typedef enum tagALARM_ZONE_TYPE_ENUM
// {    
//     ENUM_ALARM_ZONE_SMOKE = 1, //�̸�
//         ENUM_ALARM_ZONE_GAS  = 2,  //ú��
//         ENUM_ALARM_ZONE_INFRARED = 3, //����
//         ENUM_ALARM_ZONE_MAGNETIC  = 4, //�Ŵ�
//         ENUM_ALARM_ZONE_MANUAL = 5 //�ֶ�
// }ALARM_ZONE_TYPE_ENUM;

//������¼
typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType; //������ʽ���ο�UNLOCK_TYPE_ENUM
    BYTE   byRes1[3]; //����
    BYTE   byControlSrc[NAME_LEN]; //��������Դ��Ϣ��ˢ������ʱΪ���ţ���������ʱΪөʯ��APP�˺ţ���ά�뿪��ʱΪ�ÿ͵��ֻ��ţ����������Ϊ�豸���
    DWORD  dwPicDataLen; //ͼƬ���ݳ���
    BYTE*  pImage; //ͼƬָ��
    DWORD  dwCardUserID; //�ֿ���ID
    SHORT  nFloorNumber;//ˢ������ʱ��Ч��Ϊ¥���
    WORD   wRoomNumber; //��������Դ������Ϣ��ˢ������ʱ��Ч��Ϊ����ţ�
    WORD   wLockID; //�������ſڻ���0-��ʾ�����������Ͻӵ�����1-��ʾ��ӿ������Ͻӵ�����
    BYTE   byRes2[2];
    BYTE   byLockName[LOCK_NAME_LEN]; //ˢ������ʱ��Ч�������ƣ���Ӧ�Ų���������������
    BYTE   byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE   byRes[136]; //����
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;

//������Ϣ�Ķ���ִ
typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //������
    BYTE   byRes[224];  //����
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;

//��֤��¼���豸δʵ�֣�
typedef struct tagNET_DVR_AUTH_INFO
{
    BYTE   byAuthResult; //��֤�����0-��Ч��1-��֤�ɹ���2-��֤ʧ��
    BYTE   byAuthType; //��֤��ʽ��0-��Ч��1-ָ�ƣ�2-����
    BYTE   byRes1[2]; //����
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //����
    DWORD dwPicDataLen; //ͼƬ���ݳ��ȣ�����֤��ʽbyAuthTypeΪ����ʱ��Ч��
    BYTE*  pImage; //ͼƬָ�루����֤��ʽbyAuthTypeΪ����ʱ��Ч��
    BYTE   byRes[212];  //����
}NET_DVR_AUTH_INFO, *LPNET_DVR_AUTH_INFO;

//������Ϣ�ϴ�
typedef struct tagNET_DVR_UPLOAD_PLATE_INFO
{
    char sLicense[MAX_LICENSE_LEN];        //���ƺ���
    BYTE   byColor;                      //������ɫ���ο��ṹVCA_PLATE_COLOR
    BYTE   byRes[239];  //����
}NET_DVR_UPLOAD_PLATE_INFO, *LPNET_DVR_UPLOAD_PLATE_INFO;

typedef struct tagNET_DVR_SEND_CARD_INFO
{
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //����
    BYTE   byRes[224];  //����
}NET_DVR_SEND_CARD_INFO, *LPNET_DVR_SEND_CARD_INFO;

//���ӶԽ��¼���¼��Ϣ������
typedef union tagNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
{
    BYTE byLen[256]; //�������С
    NET_DVR_UNLOCK_RECORD_INFO struUnlockRecord; //������¼
    NET_DVR_NOTICEDATA_RECEIPT_INFO struNoticedataReceipt; //������Ϣ�Ķ���ִ
    NET_DVR_AUTH_INFO struAuthInfo; //��֤��¼���豸δʵ�֣�
    NET_DVR_UPLOAD_PLATE_INFO struUploadPlateInfo; //������Ϣ�ϴ�
    NET_DVR_SEND_CARD_INFO struSendCardInfo; //�ſڻ�����,��Ӧ�豸���ڷ���״̬��ˢ��ʱ�ϴ����¼�
}NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON,*LPNET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON;


//���ӶԽ��¼���¼
typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize; //�ṹ���С
    NET_DVR_TIME_EX struTime; //ʱ��
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //�豸���
    BYTE   byEventType; //�¼���Ϣ���ͣ�1-������¼��2-������Ϣ�Ķ���ִ��3-��֤��¼��4-������Ϣ�ϴ���5�Ƿ���ˢ���¼���6-�ſڻ�������¼(��Ҫ�����ſڻ��������ܣ�ˢ��ʱ�Ż��ϴ����¼�)
    BYTE   byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE   byRes1[2]; //����
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo; //�¼���Ϣ���������ݲο�byEventTypeȡֵ
    DWORD dwIOTChannelNo;    //IOTͨ����
    BYTE  byRes2[252]; //����
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;


//����������Ϣ
typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN]; //��������
    DWORD  dwZonendex; //������
    BYTE   byZoneType; //�������ͣ��ο�DETECTOR_TYPE
    BYTE   byRes[219];  //����
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

//��������Ϣ
typedef struct tagNET_DVR_LOCK_ALARM_INFO
{
    DWORD   dwLockID;   //��ID����0��ʼ
    BYTE    byRes[252]; //�����ֽ�
}NET_DVR_LOCK_ALARM_INFO, *LPNET_DVR_LOCK_ALARM_INFO;

typedef union tagNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION
{
    BYTE byLen[256]; //�������С
    NET_DVR_ZONE_ALARM_INFO struZoneAlarm; //��������
    NET_DVR_LOCK_ALARM_INFO struLockAlarm;  //��������Ϣ
}NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION,*LPNET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION;


//���ӶԽ�������Ϣ������
typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;  //�ṹ���С
    NET_DVR_TIME_EX struTime; //����ʱ��
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN]; //�豸���
    BYTE  byAlarmType; //�������ͣ�1-����������2-���𱨾���3-�ٳֱ�����4-������뿪��ʧ�ܱ���,5-��û����6-��û�� 7-SOS ��8-ͨ���Խ���9-�������ٳ�ָ�Ʊ����� 10-�������ٳ����뱨����11-���������ű�����12-��������������������13-�������������㱨�� ,14-����������,15-����������
    //��16-�Ž���ȫģ����𱨾���17-�豸��ʼ�Խ���18-�豸ֹͣ�Խ�
    BYTE  byRes1[3]; //����
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo; //������Ϣ���������ݲο��ֶ�byAlarmTypeȡֵ
    WORD  wLockID; //��0-��ʾ�ſڻ������������Ͻӵ�����1-��ʾ��ӿ������Ͻӵ���������������Ϊ5��6ʱ��Ч��
    BYTE  byRes3[2]; //����
    DWORD dwIOTChannelNo;    //IOTͨ����
    BYTE  byRes2[248]; //����
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;

typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;//����ID
    BYTE byNumber;//�����е���Ա���� 0-��ʾ������û����Ա
    BYTE byDressType;//��װ���� 0-δ֪��1-���ۡ�2-���¡�3-�Ʒ�
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;//���ͼƬ���� (0��ʾû�г���)
    char*  pPicBuffer;//�����ͼƬ����
    BYTE byRes1[24];//����(Ԥ��������չ��������)
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD     dwSize;
    DWORD     dwRelativeTime; //���ʱ��
    DWORD    dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO  struDevInfo;//ǰ���豸��Ϣ
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    /*��Ա��ⱨ������
    ��0-    δ֪��
    ��1-    ��Ѷ���ڴ�ܶ�Ź����
    ��2-    ��Ѷ��Ա�˯��ⱨ��
    ��3-    ����Ѷ��Ա�����ⱨ��
    ��4-    ������Ա��⣩
    */
    BYTE  byPeopleAlarmType; 
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;

typedef    struct tagNET_DVR_SUPPLEMENTLIGHT
{
    BYTE        byEnable;//ʹ�� 0-�أ�1-��
    BYTE          byMode;//�����ģʽ 0-�Զ���1-��ʱ
    BYTE        byHighBeamBrightness;//Զ�������[0,10]
    BYTE        byLowBeamBrightness;//���������[0,10]
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���    
    WORD        wFilteringTime;//����ʱ��(s)[0,120]
    BYTE        byBrightness;//���������[0,10]����֧�ָò���ʱ�� byHighBeamBrightness��byLowBeamBrightness����Ч��
    BYTE        bySensitivity;//�����������[0,7],Ĭ��4����byModeΪ�Զ�ʱ��Ч��
    BYTE        byBrightnessRegulatMode;// ���ȵ���ģʽ��0-�ֶ���1-�Զ�����Ϊ�Զ�ʱbyBrightness����Ч��
    BYTE        byMaxBrightness;//�����������ȣ������ȵ���ģʽΪ�Զ�ʱ��Ч����[0,100]��Ĭ��50
    BYTE        byRes[58];
}NET_DVR_SUPPLEMENTLIGHT,*LPNET_DVR_SUPPLEMENTLIGHT;

typedef    struct tagNET_DVR_EXTERNALDEVICE
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_SUPPLEMENTLIGHT struSupplementLight;//����ƽṹ��Ϣ        
    BYTE        byRes[512];
}NET_DVR_EXTERNALDEVICE,*LPNET_DVR_EXTERNALDEVICE;
typedef    struct tagNET_DVR_TEMPERATURE_TRIGGER_COND
{
    DWORD     dwSize;//�ṹ���С
    DWORD     dwChan;//ͨ����
    DWORD     dwPreset;//Ԥ�õ��
    BYTE      byRes[256];
}NET_DVR_TEMPERATURE_TRIGGER_COND, *LPNET_DVR_TEMPERATURE_TRIGGER_COND;
//(���֧�֣����ʵ�֣��������������豸�ڲ���)
typedef    struct tagNET_DVR_BUILTIN_SUPPLEMENTLIGHT
{
    DWORD        dwSize;//�ṹ���С
    BYTE          byMode;//�����ģʽ 0-��ʱ��1-������2-�رգ�3-�Զ����ǹ������㷨����ʶ��
    BYTE        byBrightnessLimit;//��������[0,100]
    BYTE        bySupplementLightMode;//���������,0~�׹�ģʽ,1~���ģʽ
    BYTE        byMixedLightRegulatMode;//��ϲ�������ȵ���ģʽ,0~�Զ�,1~�ֶ�,��bySupplementLightMode = 1ʱ��Ч
    BYTE        byLrLightBrightness;//�������ȿ���[0,100],��byMixedLightRegulatMode = 1ʱ��Ч��
    BYTE        byHighLrLightBrightness;// Զ��������������[0,100],��byMixedLightRegulatMode = 1ʱ��Ч
    BYTE        byHighBrightnessLimit;// Զ��׹���������[0,100],��byMixedLightRegulatMode = 1ʱ��Ч
    BYTE        byLowLrLightBrightness;// ����������������[0,100],��byMixedLightRegulatMode = 1ʱ��Ч
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���    
    BYTE        byLowBrightnessLimit;//����׹���������[0,100],��byMixedLightRegulatMode = 1ʱ��Ч
    BYTE        byWhiteLightBrightness;// �׹������
    BYTE        byIrLightbrightnessLimit;//������,������������
    BYTE        byWhiteLightbrightnessLimit;//������,�׹���������
    BYTE        byRes1[252];
}NET_DVR_BUILTIN_SUPPLEMENTLIGHT,*LPNET_DVR_BUILTIN_SUPPLEMENTLIGHT;
typedef struct tagNET_DVR_OIS_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byMode;  //�Ƿ��ѧ������0-�رգ�1-��ͨ��2-ר�� 
    BYTE      byOISLevel; //��ѧ�����ȼ���0-�ͣ�1-�У�2-��
    BYTE      byOISSensitivity;//��ѧ���������ȣ�0-�ͣ�1-�У�2-��
    BYTE        byRes[125];
}NET_DVR_OIS_CFG, *LPNET_DVR_OIS_CFG;

typedef struct tagNET_DVR_MACFILTER_CFG
{
    DWORD    dwSize;//�ṹ���С
    BYTE     byEnabled;  //�Ƿ���MAC��ַ���ˣ�0-��1-��
    BYTE     byPermissionType; //MAC��ַ�������ͣ�0-��ֹ��1-����
    BYTE     byRes1[2];
    BYTE     szMacAddress[MAC_ADDRESS_NUM][MACADDR_LEN];
    BYTE     byRes[128];
}NET_DVR_MACFILTER_CFG, *LPNET_DVR_MACFILTER_CFG;

typedef    struct tagNET_DVR_EAGLEFOCUSING_SENCE
{
    BYTE    byRuleType;//�������ͣ�0-��
    BYTE    bySceneID;//����ID��0-������ 1�Ǳ�ʾ����1,2��ʾ����2�������������� 
    WORD    wRate;//���ʣ�50-100  
    NET_VCA_POLYGON struRegion;// ����Χ
    BYTE    bySpotNum;//�ڱ궨����ȡ���ٸ�����б궨��3-5��Ĭ��3
    BYTE    byRes[127];
}NET_DVR_EAGLEFOCUSING_SENCE, *LPNET_DVR_EAGLEFOCUSING_SENCE;

typedef struct tagNET_DVR_EAGLEFOCUSING_CALCFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//�Ƿ����궨��0-��ֹ�궨��1-��ʼ�궨���ýڵ�����ʱ��Ч����ȡʱ��Ч��
    BYTE    byRes1[3];
    NET_DVR_EAGLEFOCUSING_SENCE struEagleFoucsing[MAX_SENCE_NUM/*16*/];
    BYTE   byRes[512];
}NET_DVR_EAGLEFOCUSING_CALCFG, *LPNET_DVR_EAGLEFOCUSING_CALCFG;

typedef struct tagNET_DVR_EAGLEFOCUSING_CTRL
{
    DWORD    dwSize;
    BYTE     byEnable;//ʹ�ܣ�0-�ر�ӥ�Ӿ۽���1-����ӥ�Ӿ۽�
    BYTE     byHeightCompensationEnable;//�߶Ȳ���ʹ��
    BYTE     byHeightCompensationValue;//�߶Ȳ���ֵ, ��Χ1-5,Ĭ��3,һ��ֵ����0.5��
    BYTE     byRes[509];
}NET_DVR_EAGLEFOCUSING_CTRL, *LPNET_DVR_EAGLEFOCUSING_CTRL;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION
{
    BYTE        byRuleID;//������
    BYTE        byMode;//0-default Mode,1-pix Mode,2-actual Mode
    BYTE        byStrategy;//���˲��� 0-area(���),1-widthHeight(���) (<!---,if mode == pix Mode -->)
    BYTE        byPriority;//���ȼ� 0-Ĭ��ֵ, 1-�ͣ�2-�У�3-��
    NET_VCA_POLYGON struMaxTargetSize;//���Ŀ��ߴ�
    NET_VCA_POLYGON struMinTargetSize;//��СĿ��ߴ�
}NET_DVR_SMARTCALIBRATION_REGION, *LPNET_DVR_SMARTCALIBRATION_REGION;

#define RULE_REGION_MAX 128
typedef struct tagNET_DVR_SMARTCALIBRATION_CFG
{
    DWORD        dwSize;//�ṹ���С
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//��������
    BYTE        byRes[3];
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_CFG, *LPNET_DVR_SMARTCALIBRATION_CFG;

typedef struct tagNET_DVR_SMARTCALIBRATION_COND
{
    DWORD        dwSize;//�ṹ���С
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//��������
    BYTE        byRes[3];
    DWORD        dwChannel;//ͨ����
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_COND, *LPNET_DVR_SMARTCALIBRATION_COND;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION_CFG
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_REGION_CFG, *LPNET_DVR_SMARTCALIBRATION_REGION_CFG;


typedef    struct tagNET_DVR_OSD_BATTERY_POWER_CFG
{
    DWORD dwSize;
    NET_VCA_POINT  struOSDBatteryPower;//����ͳ����ʾOSD��ʾ���Ͻ�����
    BYTE   byOSDBatteryPower;//��ص���OSD������ʾʹ��,  0-��1-��
    BYTE    byRes[63];
}NET_DVR_OSD_BATTERY_POWER_CFG, *LPNET_DVR_OSD_BATTERY_POWER_CFG;

#define CARD_PARAM_CARD_VALID       0x00000001  //���Ƿ���Ч����
#define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
#define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
#define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
#define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ����������
#define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
#define CARD_PARAM_PASSWORD         0x00000080  //���������
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
#define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������

typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //ʹ����Ч�ڣ�0-��ʹ�ܣ�1ʹ��
    BYTE byBeginTimeFlag;      //�Ƿ�������ʼʱ��ı�־��0-�����ƣ�1-����
    BYTE byEnableTimeFlag;     //�Ƿ�������ֹʱ��ı�־��0-�����ƣ�1-����
    BYTE byTimeDurationNo;     //��Ч������,��0��ʼ��ʱ���ͨ��SDK���ø������������ƿ�ʱ��ֻ��Ҫ������Ч���������ɣ��Լ�����������
    NET_DVR_TIME_EX struBeginTime; //��Ч����ʼʱ��
    NET_DVR_TIME_EX struEndTime; //��Ч�ڽ���ʱ��
    BYTE byTimeType; //ʱ�����ͣ�0-�豸����ʱ�䣨Ĭ�ϣ���1-UTCʱ�䣨����struBeginTime��struEndTime�ֶ���Ч��
    BYTE byRes2[31];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType; 
    // ��Ҫ�޸ĵĿ����������ÿ�����ʱ��Ч����λ��ʾ��ÿλ����һ�ֲ�����1Ϊ��Ҫ�޸ģ�0Ϊ���޸�
    // #define CARD_PARAM_CARD_VALID       0x00000001 //���Ƿ���Ч����
    // #define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ����������
    // #define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
    // #define CARD_PARAM_PASSWORD         0x00000080  //���������
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byCardValid; //���Ƿ���Ч��0-��Ч��1-��Ч������ɾ����������ʱ��Ϊ0����ɾ������ȡʱ���ֶ�ʼ��Ϊ1��
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������Ĭ����ͨ��
    BYTE byLeaderCard; //�Ƿ�Ϊ�׿���1-�ǣ�0-��
    BYTE byRes1;
    DWORD dwDoorRight; //��Ȩ�ޣ���λ��ʾ��1Ϊ��Ȩ�ޣ�0Ϊ��Ȩ�ޣ��ӵ�λ����λ��ʾ����1-N�Ƿ���Ȩ��
    NET_DVR_VALID_PERIOD_CFG struValid; //��Ч�ڲ���
    DWORD dwBelongGroup; //����Ⱥ�飬��λ��ʾ��1-���ڣ�0-�����ڣ��ӵ�λ����λ��ʾ�Ƿ����Ⱥ��1-N
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //������
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //��Ȩ�޼ƻ���ȡֵΪ�ƻ�ģ���ţ�ͬ���Ų�ͬ�ƻ�ģ�����Ȩ�޻�ķ�ʽ����
    DWORD dwMaxSwipeTime; //���ˢ��������0Ϊ�޴�������
    DWORD dwSwipeTime; //��ˢ������
    WORD wRoomNumber;  //�����
    SHORT wFloorNumber;   //���
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //���û��ȡ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ���п���Ϣ
    BYTE  byCheckCardNo; //�豸�Ƿ���п���У�飬0-��У�飬1-У��
    BYTE           byRes1[3];
    WORD wLocalControllerID; //�͵ؿ�������ţ���ʾ���͵ؿ������·����߿�������0�������Ž�����
    BYTE  byRes2[2];
    DWORD dwLockID;  //��ID
    BYTE  byRes3[20];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    DWORD dwCardUserId;    //�ֿ���ID
    BYTE byRes[12];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;

typedef struct tagNET_DVR_CARD_USER_INFO_CFG  /*��Ӧ���ýṹ��*/
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN];                /* �û���*/
    BYTE byRes2[256];                       //byRes2[0]--���籨�����������û���
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //��״̬�ܼƻ�����
#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //�������ܼƻ�����
#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //��Ȩ���ܼƻ�����
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //��״̬���ռƻ�����
#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //���������ռƻ�����
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //��Ȩ�޼��ռƻ�����
#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //��״̬���������
#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //��������֤��ʽ���������
#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //��Ȩ�޼��������
#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //��״̬�ƻ�ģ�����
#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //��������֤��ʽ�ƻ�ģ�����
#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //��Ȩ�޼ƻ�ģ�����
#define ACS_PARAM_CARD                         0x00001000 //������
#define ACS_PARAM_GROUP                        0x00002000 //Ⱥ�����
#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //��Ǳ�ز���
#define ACS_PAPAM_EVENT_CARD_LINKAGE           0x00008000 //�¼���������������
#define ACS_PAPAM_CARD_PASSWD_CFG              0x00010000 //���뿪��ʹ�ܲ���
#define ACS_PARAM_PERSON_STATISTICS_CFG        0x00020000 //����ͳ�Ʋ���
#define ACS_PARAM_BLACK_LIST_PICTURE           0x00040000 //������ͼƬ����
#define ACS_PARAM_ID_BLACK_LIST                0x00080000 //���֤����������
#define ACS_PARAM_EXAM_INFO                    0x00100000 //������Ϣ����
#define ACS_PARAM_EXAMINEE_INFO                0x00200000 //������Ϣ����
#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //�����豸������ģʧ�ܼ�¼

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //�������ͣ���λ��ʾ    
    //#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //��״̬�ܼƻ�����
    //#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //�������ܼƻ�����
    //#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //��Ȩ���ܼƻ�����
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //��״̬���ռƻ�����
    //#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //���������ռƻ�����
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //��Ȩ�޼��ռƻ�����
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //��״̬���������
    //#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //��������֤��ʽ���������
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //��Ȩ�޼��������
    //#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //��״̬�ƻ�ģ�����
    //#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //��������֤��ʽ�ƻ�ģ�����
    //#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //��Ȩ�޼ƻ�ģ�����
    //#define ACS_PARAM_CARD                         0x00001000 //������
    //#define ACS_PARAM_GROUP                        0x00002000 //Ⱥ�����
    //#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //��Ǳ�ز���
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE          0x00008000 //�¼���������������
    //#define ACS_PAPAM_CARD_PASSWD_CFG             0x00010000 //���뿪��ʹ�ܲ���
    //#define ACS_PARAM_PERSON_STATISTICS_CFG       0x00020000 //����ͳ�Ʋ���
    //#define ACS_PARAM_BLACK_LIST_PICTURE          0x00040000 //������ͼƬ����
    //#define ACS_PARAM_ID_BLACK_LIST               0x00080000 //���֤����������
    //#define ACS_PARAM_EXAM_INFO                   0x00100000 //������Ϣ����
    //#define ACS_PARAM_EXAMINEE_INFO               0x00200000 //������Ϣ����
    //#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //�����豸������ģʧ�ܼ�¼
    WORD wLocalControllerID; //�͵ؿ��������[1,64],0�����Ž�����
    BYTE byRes[30];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byIOUseType;     //��;��0-���ã�1-���Ű�ť��2-��״̬��0xff-�Զ���
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byIOUseType;     //��;��0-���ã�1-������0xff-�Զ���
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byEnable;   //�Ƿ������ݿأ�0-��1-��
    BYTE    byRes1;     //����
    BYTE    byInterfaceType; //�ӿ����ͣ�0-�ޣ�1-RS485,2-����
    BYTE    byRS485Protocol; //RS485Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ1ʱ��Ч
    BYTE    byNetworkType;  //����Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ2ʱ��Ч
    BYTE    byRes[63];              // �����ֽ�
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;                 // �ṹ���С
    BYTE    byEnable;               //�Ƿ������ݿأ�0-��1-��
    BYTE    byRes1;                 //����
    BYTE    byInterfaceType;        //�ӿ����ͣ�0-�ޣ�1-RS485,2-����
    BYTE    byRS485Protocol;        //RS485Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ1ʱ��Ч
    BYTE    byNetworkType;          //����Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ2ʱ��Ч
    BYTE    byRes2;                 //����
    WORD    wServerPort;            //�ݿط������˿ںţ�������Э������Ϊ1-˽�� ʱ��Ч
    NET_DVR_IPADDR    struServerIP; //�ݿط�����IP��������Э������Ϊ1-˽�� ʱ��Ч
    BYTE    byRes[256];              // �����ֽ�
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V50
{
    DWORD   dwSize;                 //�ṹ���С
    BYTE    byEnable;                 //�Ƿ������ݿأ�0-��1-��
    BYTE    byNegativeFloor;           //��¥�����
    BYTE    byInterfaceType;           //�ӿ����ͣ�0-�ޣ�1-RS485,2-����
    BYTE    byRS485Protocol;        //RS485Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ1ʱ��Ч
    BYTE    byNetworkType;         //����Э�����ͣ�0-δ֪��1-˽�У�0xff-�Զ��壬��byInterfaceTypeȡֵΪ2ʱ��Ч
    BYTE    byElevatorControlType;      //�ݿ������ͣ�0-��Ч��1-DS-K2201��2-DS-K2210
    WORD    wServerPort;            //�ݿط������˿ںţ�������Э������Ϊ1-˽�� ʱ��Ч
    NET_DVR_IPADDR    struServerIP; //�ݿط�����IP��������Э������Ϊ1-˽�� ʱ��Ч
    BYTE    sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN]; //�û�����������Э������Ϊ1-˽�� ʱ��Ч��ֻ�����ã����ܻ�ȡ��
    BYTE    sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN]; //���룬������Э������Ϊ1-˽�� ʱ��Ч��ֻ�����ã����ܻ�ȡ��
    BYTE    byRes[256];              //�����ֽ�
}NET_DVR_ELEVATORCONTROL_CFG_V50, *LPNET_DVR_ELEVATORCONTROL_CFG_V50;

typedef struct tagNET_DVR_ROOM_CUSTOM_COND
{
    DWORD   dwSize;
    DWORD   dwRoomNumber; //������Ŀ������ʱ��Ч��
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_COND, *LPNET_DVR_ROOM_CUSTOM_COND;

typedef struct tagNET_DVR_ROOM_CUSTOM_CFG
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //ԭ�����
    DWORD   dwCustomRoomNo; //�Զ������
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_CFG, *LPNET_DVR_ROOM_CUSTOM_CFG;

typedef struct tagNET_DVR_ROOM_CUSTOM_STATUS
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //ԭ�����
    BYTE    byStatus;  //�·�״̬��0-��Ч��1-ʧ�ܣ�2-�����У�3-�ɹ�
    BYTE    byRes[127];
}NET_DVR_ROOM_CUSTOM_STATUS, *LPNET_DVR_ROOM_CUSTOM_STATUS;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN]; // ���ӶԽ��豸��ţ������ţ��豸����ΪIPCʱȫ��Ϊ0
    BYTE  byDeviceName[NAME_LEN];  //�豸����
    BYTE  bySourceType;            //��ƵԴ���ͣ�0�����壬1-IPC��2-DVR/DVS/NVR��3-�ſڻ���4-Χǽ����5-����ȷ�ϻ�
    BYTE  byRes[255];              //����
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;

#define UNLOCK_PASSWORD_LEN                        8 //������볤��
#define LOCAL_CONTROLLER_NAME_LEN                  32//�͵ؿ��������Ƴ���
typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //������
    BYTE byMagneticType; //�Ŵ����ͣ�0-���գ�1-����
    BYTE byOpenButtonType; //���Ű�ť���ͣ�0-���գ�1-����
    BYTE byOpenDuration; //���ų���ʱ�䣬1-255s��¥��̵�������ʱ�䣩
    BYTE byDisabledOpenDuration; //�м��˿����ų���ʱ�䣬1-255s
    BYTE byMagneticAlarmTimeout; //�Ŵż�ⳬʱ����ʱ�䣬0-255s��0��ʾ������
    BYTE byEnableDoorLock; //�Ƿ����ñ��Ż�����0-��1-��
    BYTE byEnableLeaderCard; //�Ƿ������׿��������ܣ�0-��1-��
    BYTE byLeaderCardMode; //�׿�ģʽ��0-�������׿����ܣ�1-�׿�����ģʽ��2-�׿���Ȩģʽ��ʹ���˴��ֶΣ���byEnableLeaderCard��Ч��
    DWORD dwLeaderCardOpenDuration; //�׿���������ʱ�䣬1-1440min
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //в������
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //��������
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN];         //�����NET_DVR_LOCAL_CONTROLLER_STATUS
    BYTE byUseLocalController; //ֻ�����Ƿ������ھ͵ؿ������ϣ�0-��1-��
    BYTE byRes1;
    WORD wLocalControllerID; //ֻ�����͵ؿ�������ţ�1-64,0����δע��
    WORD wLocalControllerDoorNumber; //ֻ�����͵ؿ��������ű�ţ�1-4,0����δע��
    WORD wLocalControllerStatus; //ֻ�����͵ؿ���������״̬��0-���ߣ�1-�������ߣ�2-��·1�ϵ�RS485����1��3-��·1�ϵ�RS485����2��4-��·2�ϵ�RS485����1��5-��·2�ϵ�RS485����2��6-��·3�ϵ�RS485����1��7-��·3�ϵ�RS485����2��8-��·4�ϵ�RS485����1��9-��·4�ϵ�RS485����2��ֻ����
    BYTE byLockInputCheck; //�Ƿ���������������(1�ֽڣ�0�����ã�1���ã�Ĭ�ϲ�����)
    BYTE byLockInputType; //������������(1�ֽڣ�0���գ�1������Ĭ�ϳ���)
    BYTE byDoorTerminalMode; //����ض��ӹ���ģʽ(1�ֽڣ�0�������̣�1��ͨ��Ĭ�Ϸ�������)
    BYTE byOpenButton; //�Ƿ����ÿ��Ű�ť(1�ֽڣ�0�ǣ�1��Ĭ����)
    BYTE byLadderControlDelayTime; //�ݿطÿ��ӳ�ʱ�䣬1-255min
    BYTE byRes2[43];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];    //�豸���
    BYTE    byRes[64];                          //����
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;                                  //ID
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //�豸���
    BYTE        byMACAddr[MACADDR_LEN];             //mac��ַ
    BYTE        byRes1[2];                           //����
    BYTE        sSerialNumber[SERIALNO_LEN];        //�豸���к�
    NET_DVR_IPADDR   struDevIP;                     //�豸IP��ַ
    NET_DVR_TIME_EX struRegisterTime;                 //ע��ʱ��
    BYTE        byRegisterType;                     //ע�����ͣ�0-������1-�ſڻ���2-�������3-���ڻ���4-Χǽ����5-�����ſڻ���6-����ȷ�ϻ���7-8700�ͻ��ˡ�8-4200�ͻ���
    BYTE        byRes[127];                         //����
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;

typedef struct tagNET_DVR_CALLER_INFO
{
    DWORD dwSize;          //�ṹ���С
    WORD   wBuildingNo;    //¥��
    SHORT   wFloorNo;    //���
    BYTE   byZoneNo;        //�ں�
    BYTE   byUnitNo;    //��Ԫ��
    BYTE   byDevNo;    //�豸���
    BYTE    byDevType;   //�豸���ͣ�1-�ſڻ���2-�������3-���ڻ���4-Χǽ����5-�����ſڻ���6-����ȷ�ϻ���7-8700�ͻ��ˣ�8-4200�ͻ��ˣ�9-APP, 10- �������11-VOIP�ͻ��ˣ�12-��ص�IPC�豸
    BYTE    byLockNum;//������0-�����ϵ��߼��ߣ�����ֵ-����ʵ����������
    BYTE   byHighDevNo;    // �豸��Ÿ�8λ,����֧��1-9999�ķ�Χ
    BYTE   byRes1[2];     // ����
    BYTE   byVoipNo[16];   // VOIP�ͻ��˺��� byDevType��Ϊ11ʱ��Ч
    BYTE   byRes[80];     // ����
}NET_DVR_CALLER_INFO,*LPNET_DVR_CALLER_INFO;

typedef struct tagNET_DVR_CALL_STATUS
{
    DWORD dwSize;          //�ṹ���С
    BYTE   byCallStatus; //��ȡͨ��״̬��1-�޺��С�2-���塢3-����ͨ��
    BYTE   byRes[127];
}NET_DVR_CALL_STATUS, *LPNET_DVR_CALL_STATUS;

#define MAX_SERVER_DEVICE_NUMBER                  16  //����豸����

typedef struct tagNET_DVR_SERVER_DEVICE_CFG
{
    BYTE    byDeviceName[NAME_LEN];   //�豸����
    BYTE       byDeviceType; ////�豸���ͣ�1-�ſڻ���2-�������3-���ڻ�
    BYTE       byDeviceID; //�ſڻ����
    BYTE    byLockNum; //������0-�����ϵ��߼��ߣ�����ֵ-����ʵ����������
    BYTE    byRes[5]; 	   //����
}NET_DVR_SERVER_DEVICE_CFG,*LPNET_DVR_SERVER_DEVICE_CFG;

typedef struct tagNET_DVR_SERVER_DEVICE_INFO
{
    DWORD   dwSize;  //�ṹ���С
    DWORD     dwDeviceNum; //�豸��
    NET_DVR_SERVER_DEVICE_CFG    struDeviceCfg[MAX_SERVER_DEVICE_NUMBER];   //�豸��Ϣ
    BYTE    byRes[200];        //����
}NET_DVR_SERVER_DEVICE_INFO,*LPNET_DVR_SERVER_DEVICE_INFO;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD    dwSize;
    DWORD   dwCmdType;      //��������  0-������У�1-ȡ�����κ��У�2-�������κ��� 3-�ܾ������������ 4-�������峬ʱ 5-��������ͨ����6-�豸����ͨ���У�7-�ͻ�������ͨ���У�8���ڻ�������
    WORD wPeriod;  //�ں�, ��Χ[0,9]
    WORD wBuildingNumber; //¥��
    WORD wUnitNumber;  //��Ԫ��
    SHORT wFloorNumber;  //���
    WORD  wRoomNumber;    //�����
    WORD  wDevIndex; //�豸���
    BYTE    byUnitType; //�豸���ͣ�1-�ſڻ���2-�������3-���ڻ���4-Χǽ����5-�����ſڻ���6-����ȷ�ϻ���7-8700�ͻ��ˣ�8-4200�ͻ��ˣ�9-APP
    BYTE    byRes[115];     //����
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;

#define MAX_SCREEN_ADDRESS_LEN 16 //��������󳤶�
#define MAX_DAY_TIME_POINT 8   //ÿ�����ʱ������
#define MAX_TIME_POINT     16  //ÿ�����ʱ������

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //�û���
    BYTE byPassWord[PASSWD_LEN]; //����
    NET_DVR_IPADDR struIPAddr; //IP��ַ
    WORD wPort; //�˿ں�
    BYTE byRes[24];    
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;

typedef union tagNET_DVR_SCREEN_BASE_INFO
{
    BYTE byScreenAddress[MAX_SCREEN_ADDRESS_LEN]; //��Ļ�����룬�豸��ӷ�ʽΪ0ʱ��Ч
    NET_DVR_DEV_IP_INFO struIPInfo; //��Ļip��ַ��Ϣ
    BYTE byRes[100];
}NET_DVR_SCREEN_BASE_INFO,*LPNET_DVR_SCREEN_BASE_INFO;

typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE byDevAddType; //�豸��ӷ�ʽ��0-��������(����������Ļʹ�ô���ͨ��)��1-��IP��ַ(����������Ļʹ������ͨ��)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //��Ļ�豸������Ϣ
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG,*LPNET_DVR_SCREEN_INDEX_CFG;

//ģ��ң��������
typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE        byControlType;    //1-��Դ����2-��Դ�أ�3-�ź�Դ��4-�˵���5-ȷ����6-�ϣ�7-�£�8-��9-��,  10-INFO, 11-������һ��,12-���ְ���
    BYTE        byControlParam; //������������������Ϊ12ʱ����ʾ����ֵ(0-9)����������ʱ�˲�����Ч
    BYTE        byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

//��Ļάǽ����
typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //״̬���ء�0-Ϊ�رգ�1-Ϊ����
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

//����Ŵ�ԭ����
typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;    //����Ŵ�ԭָ�1-�Ŵ�2-��ԭ
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //��Ҫ�Ŵ��������1920*1920��Ϊ��Ļ�ܴ�С����ԭʱ�˲�����Ч
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;

typedef  union tagNET_DVR_SCREEN_CONTROL_PARAM
{
    NET_DVR_INPUT_INTERFACE_CTRL    struInputCtrl;
    NET_DVR_DISPLAY_COLOR_CTRL         struDisplayCtrl;
    NET_DVR_DISPLAY_POSITION_CTRL     struPositionCtrl;
    NET_DVR_SIMULATE_REMOTE_CTRL struSimulateRemoteCrtl; //ģ��ң�ذ���
    NET_DVR_SCREEN_WALL_CTRL struScreenWallCtrl; //��Ļάǽ����  
    NET_DVR_AREA_ZOOM_CFG struZoomArea;  //����Ŵ�ԭ����
    BYTE        byRes[16];
}NET_DVR_SCREEN_CONTROL_PARAM, *LPNET_DVR_SCREEN_CONTROL_PARAM;

typedef struct tagNET_DVR_SCREEN_CONTROL
{     
    DWORD     dwSize;             
    DWORD      dwCommand ;      /* ���Ʒ��� 1-�� 2-�� 3-��Ļ����Դѡ�� 4-��ʾ��Ԫ��ɫ���� 5-��ʾ��Ԫλ�ÿ���*/
    BYTE       byProtocol;      //����Э������,1:LCD-S1,2:LCD-S2
    BYTE    byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE       byRes2[52];    
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{     
    DWORD   dwSize;
    BYTE    bySerialNo;        //���ں�
    BYTE    byRes[2];
    BYTE       byProtocol;    // ����Э������ 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20��7-LCD-L2,8-LCD-Z1��
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-��Ч��ʹ��Ԥ�Ȱ󶨵�Э������ 
    DWORD      dwCommand ;      /* ���Ʒ��� 1-�� 2-�� 3-��Ļ����Դѡ�� 4-��ʾ��Ԫ��ɫ���� 5-��ʾ��Ԫλ�ÿ��ƣ�6-ģ��ң�ذ���,7-��ʾ��Ļ״̬,
    8-��ʾ��Ļ�����루���������������ʼ������Ϊ��0,0������߾���Ϊ0xffffffff��, 9-��Ļάǽ,10-�ָ���ĻĬ�ϲ�����11-��ʾIP�����������������ʼ������Ϊ��0,0������߾���Ϊ0xffffffff��,12-��ĻUSB���� 13-����Ŵ�ԭ*/
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE    byWallNo;        // ����ǽ��
    BYTE    byDevNo;         //�豸��
    BYTE    bySubboardNo;    //�Ӱ��
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX struRect;//����������м��㣬��׼����
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo; //ƴ������
    BYTE byWallNo; //����ǽ��
    BYTE byEnable; //�Ƿ�ʹ�ܣ�0-��1-��
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ҫ����ƴ�ӵ����򣬻�ȡ��ʱ��˲�����0
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG,*LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;    //����Դ��������ö�� INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;        //���źŻ���ģʽ��1-������2-������3-LOGO����
    BYTE  byRes[30];       
}NET_DVR_MSC_SCREEN_INTERFACE_CFG,*LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

//�������
typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //���⣬0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG,*LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

//���л�����
typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE    byEnable;    //�Ƿ����û��л� 0-������ 1-����
    BYTE    bySubWindowSource;    //�ӻ����ź�Դ���ο�ö��INPUT_INTERFACE_TYPE
    BYTE    bySubWindowBorderColor;    //�ӻ���߿���ɫ�� 1-��ɫ��2-��ɫ
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //�ӻ���λ�ã���Ļ�ܴ�СΪ1920*1920
    BYTE    byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG,*LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//����״̬��0-�أ�1-��
    BYTE           byFanExceptionStatus;    //�����쳣״̬��0-��֧�֣�1-������2-�쳣
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //�ۻ�����ʱ������λ��Сʱ
    BYTE           byVersion[VERSION_LEN];//����汾��
    int            iTemperature; //�忨�¶ȣ���ȷ����λ����λ�����϶�
    BYTE             byTempState;     //�忨�¶�״̬��0-��֧�֣�1-������2-�쳣
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE,*LPNET_DVR_SCREEN_WORK_STATE;

//����logo����
typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�����Ƿ���ʾlogo,0-����ʾ��1-��ʾ
    BYTE byRes[31];    
}NET_DVR_BOOT_LOGO_CFG,*LPNET_DVR_BOOT_LOGO_CFG;
//��Ƶ����
typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //�Ƿ�����0-��1-��
    BYTE    byVolume; //������С��0-100
    char    byBalance; //����ƽ�⣬-50-+50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;

//��Ļ����������
typedef union tagNET_DVR_MSC_SCREEN_PARAM
{
    NET_DVR_MSC_SCREEN_INTERFACE_CFG struInterfaceCfg; //����Դ����
    NET_DVR_SCREEN_FAN_WORK_MODE_CFG struFanWorkMode; //���ȹ���ģʽ����
    NET_DVR_SCREEN_VGA_CFG struVgaCfg; //VGA�źŲ���
    NET_DVR_SCREEN_MENU_CFG struMenuCfg; //��Ļ�˵�����
    NET_DVR_VIDEO_OUT_CFG struOutEffectCfg; //��ʾЧ������
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemperatureCfg; //ɫ�²���
    NET_DVR_ADC_CFG struAdcCfg; //ADC����
    NET_DVR_SCREEN_EDGE_CFG struScreenEdgeCfg; //��Ļ��Ե����
    NET_DVR_MSC_SCREEN_BACKLIGHT_CFG struBacklight; //�������
    NET_DVR_MSC_SCREEN_PIP_CFG struPicInPicCfg; //���л�����
    NET_DVR_DEFOG_LCD struDefog; //ȥ�����
    NET_DVR_SCREEN_WORK_STATE struWorkState; //��Ļ����״̬
    NET_DVR_BOOT_LOGO_CFG struBootLogoCfg; //��ʼ��ʾlogo����
    NET_DVR_LCD_AUDIO_CFG struAudioCfg; //��Ƶ����
    BYTE byRes[256];
}NET_DVR_MSC_SCREEN_PARAM,*LPNET_DVR_MSC_SCREEN_PARAM;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //�������ͣ�1-����Դ������2-���ȹ���ģʽ������3-VGA�źŲ�����4-��Ļ�˵�������5-��ʾЧ��������6-ɫ�²�����7-ADC������8-��Ļ��Ե������9-���������10-���л�������11-͸�������12-��Ļ����״̬��ֻ�ܻ�ȡ����13-����LOGO�Ƿ���ʾ����  14-��Ƶ����
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //��Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG,*LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ļ����
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //���õ���Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG,*LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byParamType; //�������ͣ�1-����Դ������2-���ȹ���ģʽ������3-VGA�źŲ�����4-��Ļ�˵�������5-��ʾЧ��������6-ɫ�²�����7-ADC������8-��Ļ��Ե������9-���������10-���л�������11-͸�������12-��Ļ����״̬��ֻ�ܻ�ȡ����13-����LOGO�Ƿ���ʾ���� 14-��Ƶ����
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //��Ļ����
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND,*LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //�Ƿ����ø�ʱ���,0-�����ã�1-����
    BYTE bySwitchType; //���ػ����ͣ�0-�ػ���1-����
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //���ػ�ʱ���
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME,*LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //�Ƿ����ø�ʱ���,0-�����ã�1-����
    BYTE bySwitchType; //���ػ����ͣ�0-�ػ���1-����
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //���ػ�ʱ���
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT,*LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //�ܿ��ػ��ƻ�
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //��ʱ��㿪�ػ�����
	BYTE byRes1[3];
	BYTE byEnable;//�Ƿ����ö�ʱ���ػ�,0-�����ã�1-����
	BYTE byRes[60];
}NET_DVR_TIME_SWITCH_CFG,*LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //����ǽ��
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //��Ļ��Χ
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //��ʱʱ�䣬0-3000����λ��ms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME,*LPNET_DVR_DELAY_TIME;

//˫Ŀ�궨����
typedef enum _BV_CALIBRATION_TYPE_ENUM_
{
    ENUM_BV_CALIBRATION_NONE    = 0, //δ�궨
        ENUM_BV_CALIBRATION_DIRECT  = 1, //˫Ŀֱ�ӱ궨
        ENUM_BV_CALIBRATION_SAMPLE = 2, //˫Ŀ�����궨
} BV_CALIBRATION_TYPE_ENUM;


//�����궨��
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{   
    BYTE  byCalibPtID;   //�궨��ID����Χ[1,5]����ʾ�˵���˫Ŀ�궨�����е����
    BYTE  byRes1[3];     //����
    NET_VCA_POINT struPoint;  //�궨������
    BYTE  byRes2[16];    //����
}NET_DVR_BV_SAMPLE_CALIB_POINT,*LPET_DVR_BV_SAMPLE_CALIB_POINT;

//��ʼ�����궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //������߶ȣ���λcm
    DWORD  dwHumanHeight;  //������ߣ���λcm
    BYTE    byRes[248];      //����
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

//���������궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //�궨�㡣������Ա����ֱ�����ߣ������������ض�����������ʱ���˵��ʾ�����������ߵ��е㡣
    BYTE byRes[228]; //����
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

//���������궨�������
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256]; //����
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;

//�����궨�������������
typedef union tagNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION
{   
    BYTE byRes[256]; //����
    NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM struCalibBegin; //��ʼ�궨�������
    NET_DVR_BV_SAMPLE_CALIB_SET_PARAM struCalibSet; //���ñ궨�������
    NET_DVR_BV_SAMPLE_CALIB_END_PARAM struCalibEnd; //�����궨�������
}NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION,*LPNET_DVR_BV_SAMPLE_CALIB_PARAM_UNION;

//�����궨����ö��
typedef enum _BV_SAMPLE_CALIB_CMD_ENUM
{
    ENUM_BV_SAMPLE_CALIB_BEGIN    = 1,   //��ʼ�궨
        ENUM_BV_SAMPLE_CALIB_SETTING  = 2,   //���ò���
        ENUM_BV_SAMPLE_CALIB_END      = 3    //�����궨
}BV_SAMPLE_CALIB_CMD_ENUM;

//�����궨�ṹ��
typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{   
    DWORD   dwSize;     //�ṹ���С
    DWORD   dwChannel;  //ͨ����
    BYTE    byCommand; //�궨����μ�BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];    //����
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //�궨���������ȡֵ�������ֶ�byCommand
    BYTE    byRes2[256] ;  //����
}NET_DVR_BV_SAMPLE_CALIBRATION,*LPNET_DVR_BV_SAMPLE_CALIBRATION;


//˫Ŀ�����궨��Ϣ
typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;             //�ṹ���С
    DWORD  dwCameraHeight;    //������߶ȣ���λcm
    float  fPitchAngle;   //��������ӽǶ�[0��, 60��],
    float  fInclineAngle; //�������б�Ƕ�[-20��,20��]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //�궨����
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPointEx[MAX_SAMPLE_NUM_EX/*7*/]; //�궨������չ
    BYTE  byRes[60]; //����
}NET_DVR_BV_SAMPLE_CALIB_CFG,*LPNET_DVR_BV_SAMPLE_CALIB_CFG;

//˫Ŀͼ��У�������ṹ��
typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{   
    float   fCamInternalMatrix[3][3];  //����ڲξ��󣬰������༰��������
    float   fDistCoeffs[8];            //��ͷ����ϵ��
    float   fRotateMatrix[3][3];       //У�������ת����
    float   fProjectMatrix[3][4];      //У�����ͶӰ����
    BYTE    byRes[64];              //����
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

//�������У������
typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;                       //�ṹ��С
    float      fReprojectMatrix[4][4];   //��ͶӰ����
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //�����У������
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //�����У������
    BYTE    byLensType;             //��ͷ�������ͣ�0-δ֪,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm,9-2.0mm,10-2.8mm,11-4.3mm
    BYTE    byRes1[3]; //����
    /*RotateMatrix ��˫Ŀ�궨���������������������ת����,
    TransMatrix��ƽ�ƾ���,
    RotateMatrix��TransMatrix���������������������������������λ�ù�ϵ*/
    float   fRotateMatrix[3][3]; //��ת����
    float   fTransMatrix[3]; //ƽ�ƾ���
    DWORD dwOriImgWidth; //ԭʼ�궨ͼ��Ŀ������1920*1080�ֱ��ʵ�ͼ����Ϊ1920��
    DWORD dwOriImgHeight; //ԭʼ�궨ͼ��ĸߣ������1920*1080�ֱ��ʵ�ͼ����Ϊ1080��
    BYTE    byRes[196]; //����
} NET_DVR_BV_CORRECT_PARAM,*LPNET_DVR_BV_CORRECT_PARAM;

//�����Ƶ����
typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;     //�ṹ��С
    BYTE   byType;     //�����Ƶ���ͣ�1-ƴ��ͼ��2-���ͼ
    BYTE   byRes[63];  //����
}NET_DVR_OUTPUT_VIDEO_TYPE,*LPNET_DVR_OUTPUT_VIDEO_TYPE;

#define MAX_CHECK_485CHAN        64    //485�Լ��豸ͨ���Ÿ���

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD        dwSize;  
    DWORD        dwRS485Chan[MAX_CHECK_485CHAN];//RS485ͨ������������ͨ���ţ�ֵ��ʾͨ���ţ�λ��ʾ��λ��
    DWORD        dwSensorChan[4];//ģ������Ч��ͨ���ţ���λ��ʾ
       BYTE         byRes[32];      // �����ֽ� 
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

//������ȫ��ȡ����ֵ
typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize ; //�ṹ�峤��
    DWORD   dwChannel; //ͨ����
    BYTE    byRes[64]; 
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;   
    DWORD        dwChannel;   //ͼƬ��Ӧ��ͨ����
    BYTE        byPictureType;//ͼƬ��ʽ,0-bmp��1-jpeg��2-PNG 3-SWF 4-GIF 
    BYTE    byRes1[3];
    NET_DVR_TIME_V30 struTime;  //ͼƬ����ʱ��
    char*        sPictureBuffer;//ͼƬ������
    DWORD        dwPictureLength;//ͼƬ����
    DWORD        dwPicMangeNo;  //ͼƬ�����
    BYTE        sPicName[NAME_LEN];  //ͼƬ����
    BYTE        byUseType;    //ͼƬʹ�����ͣ�0-����ͼƬ 1-����logoͼƬ
    BYTE        byRes[91];
}NET_DVR_UPLOAD_PICTURE_INFO,*LPNET_DVR_UPLOAD_PICTURE_INFO;

#define  MAX_UPLOADFILE_URL_LEN      240

typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN] ;   //url
    BYTE byRes[260];
} NET_DVR_UPLOAD_FILE_RET,*LPNET_DVR_UPLOAD_FILE_RET;

typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];  //������ͼ������Ϣ
    BYTE     byRes[64];        
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;
typedef union tagNET_DVR_PIC_EXTRA_INFO_UNION
{
    BYTE   byUnionLen[544];   //�����峤�ȣ���ʵ������
    NET_DVR_FACE_EXTRA_INFO struFaceExtraInfo;   //���������Ϣ
}NET_DVR_PIC_EXTRA_INFO_UNION, *LPNET_DVR_PIC_EXTRA_INFO_UNION;

typedef struct    tagNET_DVR_FIND_PICTURE_V40   //���ҽ���ṹ��
{
    char    sFileName[PICTURE_NAME_LEN];//ͼƬ��
    NET_DVR_TIME struTime;//ͼƬ��ʱ��
    DWORD dwFileSize;//ͼƬ�Ĵ�С
    char    sCardNum[CARDNUM_LEN_V30];    //����
    BYTE   byPlateColor ;//�ο��ṹ VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//�ο��ṹ VLR_VEHICLE_CLASS
    BYTE   byFileType ;  //�ļ����ͣ� :0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ3  ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ     6 �ֶ�ץͼ ,9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���,    0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������, 0x32-��������, 0x33-��������, 0x34-ҵ����ѯ
    BYTE   byRecogResult ;//ʶ�����ο��ṹVTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //���ƺ���
    BYTE   byEventSearchStatus; //����ͼƬ��ʾͬһ���ҽ����ʱ��0-��ʾ����û��ͼƬ��Ϣ��1-��ʾ���滹��ͼƬ��Ϣ���ܹ�ͼƬ��Ϣ�������һ��״̬Ϊ0��ͼƬ��
    BYTE   byRes1[2];        //  �����ֽ�
    BYTE   byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    float  fFaceSnapTemperature; // ����ץ���¶���Ϣ����ȷ��С�����1λ ��(������ + 100�� * 10 ȡ�������䣩����λ�̶�Ϊ���϶ȣ��棩����byFileTypeΪ0x25-����ץ��ʱ��Ч����������¸��ֶ�Ϊ0ֵ
    BYTE   byRes[68];        //  �����ֽ�
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //ͼƬ������Ϣ
}NET_DVR_FIND_PICTURE_V40,*LPNET_DVR_FIND_PICTURE_V40;

typedef struct    tagNET_DVR_FIND_PICTURE_V50   //���ҽ���ṹ��
{
    char        sFileName[PICTURE_NAME_LEN];//ͼƬ��
    NET_DVR_TIME struTime;//ͼƬ��ʱ��
    DWORD    dwFileSize;//ͼƬ�Ĵ�С
    char        sCardNum[CARDNUM_LEN_V30];    //����
    BYTE   byPlateColor;//�ο��ṹ VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//�ο��ṹ VLR_VEHICLE_CLASS
    BYTE   byFileType;  //�ļ����ͣ� :0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ3  ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ     6 �ֶ�ץͼ ,9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���,    0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������
    BYTE   byRecogResult;//ʶ�����ο��ṹVTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //���ƺ���
    BYTE   byEventSearchStatus; //����ͼƬ��ʾͬһ���ҽ����ʱ��0-��ʾ����û��ͼƬ��Ϣ��1-��ʾ���滹��ͼƬ��Ϣ���ܹ�ͼƬ��Ϣ�������һ��״̬Ϊ0��ͼƬ��
    NET_DVR_ADDRESS	struAddr;		//ͼƬ���ڵĵ�ַ��Ϣ��ͼƬ����ʱ�õ�
    BYTE   	        byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char     cTimeDifferenceH;   //��UTC��ʱ�Сʱ����-12 ... +14
    char     cTimeDifferenceM;   //��UTC��ʱ����ӣ���-30,0, 30, 45
    BYTE            byRes[253];        //  �����ֽ�
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //ͼƬ������Ϣ
}NET_DVR_FIND_PICTURE_V50, *LPNET_DVR_FIND_PICTURE_V50;


typedef struct tagNET_DVR_THUMBNAILS_COND
{
    DWORD  dwSize;             // �ṹ���С 
    NET_DVR_STREAM_INFO   struStreamInfo;     //����Ϣ
    BYTE   bySearchDataType;   // ������������ 0-I֡���ݣ�CVR һ·������£�1s���28��I֡����1-ͼƬ����
    BYTE   byRes[3];          // �����ֽ�
    NET_DVR_TIME_V30  struStartTime;      //���ҿ�ʼʱ��
    NET_DVR_TIME_V30  struStopTime;       // ���ҽ���ʱ��
    DWORD  dwIntervalTime;  //���ʱ�䣬��λ�룬��Χ��0~24*60*60�������ҽ���ʱ����ڲ��ҿ�ʼʱ�䣬����0��������ֵ��Ч
    BYTE   byRes1[512];        // �����ֽ�
}NET_DVR_THUMBNAILS_COND, *LPNET_DVR_THUMBNAILS_COND;

typedef struct    tagNET_DVR_THUMBNAILS_RESULT   //���ҽ���ṹ��
{
    BYTE     byResultDataType;      // ���ҽ����������0-I֡���ݣ�CVR һ·������£�1s���28��I֡����1-ϵͳͷ���ݣ� 2-ͼƬ����
    BYTE     byIFrameType;          // I֡���ͣ�0-����֡��1-�ο�֡��������ֻ�����벥�ſ⣬���ǲ���ҪתΪͼƬ��ʾ��
    BYTE     byRes1[2];                // �����ֽ�
    NET_DVR_TIME_SEARCH struTime;        //����ʱ��
    BYTE     byRes[252];            // �����ֽ�
    DWORD   dwFileSize;            //���ݴ�С
    char*     pBuffer;                //������Ϣ(�������ͺ������ṹ����NET_DVR_THUMBNAILS_RESULT ���ֶ� byResultDataType ֵ���)
}NET_DVR_THUMBNAILS_RESULT, *LPNET_DVR_THUMBNAILS_RESULT;

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes[62];             //����
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;

typedef    struct tagNET_DVR_REGION_ENTRANCE_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byEnableHumanMisinfoFilter;// ��������ȥ�� 0-�����ã�1-����
    BYTE        byEnableVehicleMisinfoFilter;// ���ó���ȥ�� 0-�����ã�1-����
    BYTE        byRes1[1];
    NET_DVR_REGIONENTRANCE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_ENTRANCE_DETECTION,*LPNET_DVR_REGION_ENTRANCE_DETECTION;

typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //ͨ���� 
    DWORD dwRegion;         //����ID��
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byRes[63];             //����
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef struct tagNET_DVR_DENSEFOGDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//ʹ��
    BYTE   bySensitivity;  //�����Ȳ�������Χ[0,100]
    BYTE   byRes[258];
}NET_DVR_DENSEFOGDETECTION_CFG, *LPNET_DVR_DENSEFOGDETECTION_CFG;

typedef    struct tagNET_DVR_EVENT_TRIGGER
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_HANDLEEXCEPTION_V41 struHandleException;     //�쳣����ʽ
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40]; //ʵ�ʴ���¼��ͨ������ֵ��ʾ�����ý��������У����±�0��ʼ˳���ȡ���м�����0xffffffff�������Ч�� 
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //���õ�Ԥ�õ���Ϣ
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //����Ѳ������ͨ������Ϣ
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //������̨�켣��ͨ����Ϣ
    BYTE        byDirection;//��������0-������1-ȫ����2-����3-����
    BYTE        byRes2[255];
}NET_DVR_EVENT_TRIGGER,*LPNET_DVR_EVENT_TRIGGER;

typedef    struct tagNET_DVR_EVENT_SCHEDULE
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    NET_DVR_SCHEDTIME struHolidayAlarmTime[MAX_TIMESEGMENT_V30]; /*���ղ���ʱ��*/
    BYTE         bySceneID[MAX_DAYS][MAX_TIMESEGMENT_V30];//������,Ŀǰ֧��1~4������0Ϊ��Ч���ó������벼��ʱ����ÿ��ʱ���һһ��Ӧ��
    BYTE         byRes[72];
}NET_DVR_EVENT_SCHEDULE,*LPNET_DVR_EVENT_SCHEDULE;

typedef struct  tagNET_DVR_ANR_ARMING_HOST
{
    DWORD   dwSize;//sizeof(NET_DVR_ANR_ ARMING_HOST)
    NET_DVR_IPADDR struANRArmingHostIpAddr; //��������������IP��ַ
    WORD    wANRAlarmHostPort; //�������������������˿ں�
    BYTE     byANRAlarmType;//���������������ͣ� 0-SDK˽�ж����������ӣ�1-ehome������������
    BYTE     byConfirmMechanismEnabled;// �Ƿ���ȷ�ϻ��Ʒ�ʽ�������ӣ�0-������1-û�п��� 2-����
    BYTE     byRes[512];      //�����ֽ�
}NET_DVR_ANR_ARMING_HOST, *LPNET_DVR_ANR_ARMING_HOST;

typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes[62];             //����
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;

typedef    struct tagNET_DVR_REGION_EXITING_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byEnableHumanMisinfoFilter;// ��������ȥ�� 0-�����ã�1-����
    BYTE        byEnableVehicleMisinfoFilter;// ���ó���ȥ�� 0-�����ã�1-����
    BYTE        byRes1[1];
    NET_DVR_REGIONEXITING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_REGION_EXITING_DETECTION,*LPNET_DVR_REGION_EXITING_DETECTION;

typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    BYTE byRes[62];             //����
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;

typedef    struct tagNET_DVR_LOITERING_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_LOITERING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_LOITERING_DETECTION,*LPNET_DVR_LOITERING_DETECTION;

typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE byObjectOccup; //ռ�ȣ���Χ[1-100]
    BYTE bySensitivityLevel; //�����ȣ���Χ1-100��Ĭ��65
    BYTE byDurationTime; //����ʱ�䣬��Χ1-600�룬Ĭ��3��
    BYTE byFilterTime; //����ʱ�䣬��Χ1-10���ӣ���ʾ�������������ڴ�ʱ���ڲ��ٴ���������
    BYTE byMinTriggerNumber; //��ʹ�����������Χ2-50�ˣ�Ĭ��5��
    BYTE byLinkageTime; //����������ʱ�䣬��Χ5-30�룬Ĭ��5�루ǹ���������������ת������������λ�ú�ͣ����ʱ�䣬�����ò�����ǹ������Ƿ�ͬһ���˻���¼�����Բ�ͬ��
    BYTE byRes[58];             //����
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;
typedef struct tagNET_DVR_POS_HIDDEN_INFORMATION
{
    char szKeyWord[KEY_WORD_NUM/*3*/][KEY_WORD_LEN/*128*/];
    BYTE    byRes[128];
}NET_DVR_POS_HIDDEN_INFORMATION, *LPNET_DVR_POS_HIDDEN_INFORMATION;

typedef struct tagNET_DVR_HIDDEN_INFORMATION_CFG
{
    DWORD  dwSize;
    BYTE   byFuncType;//0-Pos����
    BYTE   Res1[3];
    NET_DVR_POS_HIDDEN_INFORMATION struPosInfo;
    BYTE    byRes[1024];
}NET_DVR_HIDDEN_INFORMATION_CFG, *LPNET_DVR_HIDDEN_INFORMATION_CFG;

typedef    struct tagNET_DVR_GROUP_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_GROUPDETECTION_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_GROUP_DETECTION,*LPNET_DVR_GROUP_DETECTION;

typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    /*
    ���Ŀ�꣬��֧�ֶ�ѡ�����嶨��Ϊ��
    0~����Ŀ�꣨��ʾ���������Ŀ�꣬����Ŀ�궼�����м�⣩
    0x01 ~ �ˣ�
    0x02 ~ ����
    0x04 ~ ������
    ���ֶ�֧�ֶ�ѡ����λȡֵ������3��ʾ1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes[62];             //����
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;

typedef    struct tagNET_DVR_RAPIDMOVE_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_RAPIDMOVE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_RAPIDMOVE_DETECTION,*LPNET_DVR_RAPIDMOVE_DETECTION;

typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    BYTE byRes[62];             //����
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;

typedef    struct tagNET_DVR_PARKING_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_PARKING_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_PARKING_DETECTION,*LPNET_DVR_PARKING_DETECTION;

typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    WORD wTimeThreshold;//ʱ����ֵ����Χ[5-3600], ��λ��s
    BYTE byTimeThresholdMode;//(ֻд�ֶΣ����ڼ�������)0-�ֶ�byTimeThreshold��Ч��1-�ֶ�wTimeThreshold��Ч
    BYTE byRes[59];             //������
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_UNATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_UNATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_UNATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_UNATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE bySensitivity;        //�����Ȳ�������Χ[1-100]
    BYTE byTimeThreshold; //ʱ����ֵ����Χ[0-10]����λ��s
    WORD wTimeThreshold;//ʱ����ֵ����Χ[5-3600], ��λ��s
    BYTE byTimeThresholdMode;//(ֻд�ֶΣ����ڼ�������)0-�ֶ�byTimeThreshold��Ч��1-�ֶ�wTimeThreshold��Ч
    BYTE byRes[59];             //����
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;

typedef    struct tagNET_DVR_ATTENDED_BAGGAGE_DETECTION
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    NET_DVR_ATTENDED_BAGGAGE_REGION    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[128];
}NET_DVR_ATTENDED_BAGGAGE_DETECTION,*LPNET_DVR_ATTENDED_BAGGAGE_DETECTION;

typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //ͨ���� 
    DWORD dwStreamType;     //�������ͣ�0- ��������1- ��������2- ��������
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byRes1[3];
    WORD      wResolutionWidth; //�ֱ��ʵĳ�
    WORD      wResolutionHeight; //�ֱ��ʵĿ�
    NET_VCA_POLYGON    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

#define MAX_DIALNUM_LENGTH  32
typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ��������߲��ţ�0-��1- ��
    BYTE       byDialMode; // 0-�Զ���Auto����1-�ֶ���Manual����Ĭ���Զ����ֶ�ģʽ�¿����ò��żƻ�������ʱ�䡢�ֶ�����
    BYTE       byNetworkMode; //0-�Զ���1-4G���ȣ�2-3G���ȣ�3-�ֶ��л�2G��4-�ֶ��л�3G��5-�ֶ��л�4G��6-��������
    BYTE        byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //���ź���
    BYTE       byUserName[NAME_LEN]; //�û���
    BYTE       byPassword[NAME_LEN]; //����
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //�ֻ�����
    BYTE       byVerifProtocol;  // 0-�Զ���Auto����1-CHAP��2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //����ʱ�䣬30-65535����λ�룬�ֶ�ģʽ����Ч
    BYTE       byNetAPN[NAME_LEN];  //˽��ר��APN�ֶ�����
    BYTE       byEnabled4G;  //�Ƿ���4G���ܣ�0-��1- ��
    BYTE       byEnabledDNS;  //�Ƿ���DNS���ܣ�0-��1- ��
    BYTE       byRes3[30];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;

typedef    struct tagNET_DVR_WIRELESSDIAL_SCHEDULE
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*����ʱ��*/
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //���ղ���ʱ���
    BYTE        byRes[128];
}NET_DVR_WIRELESSDIAL_SCHEDULE,*LPNET_DVR_WIRELESSDIAL_SCHEDULE;

#define MAX_LENGTH_32   32
typedef    struct tagNET_DVR_WIRELESSDIAL_STATUS
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byRealtimeMode[MAX_LENGTH_32]; //ʵʱģʽ(CDMA 1x��EVDO��HYBRID��GSM��GPRS��EDGE��WCDMA��HSDPA��HSUPA��HSPA��TDSCDMA��TD-LTE��FDD-LTE)
    BYTE        byUIMStatus[MAX_LENGTH_32]; /*UIM״̬(UNKNOWN-δ֪,VALID-��Ч,NOVALID-��Ч,ROAM-����,NOEXIST-������,
                                                WRONGPINCODE-PIN�����,NONETWORKSERVICE-���������, 
                                                ONLYSUPPORTEMERGENCYCALL-�����֧�ֽ������У�PINCODELOCKED��PIN������*/
    DWORD       dwSignalQuality; //�ź�������1-5
    BYTE        byDialStatus[MAX_LENGTH_32]; /*����״̬��(disconnect-���ŶϿ�,dialing-���ڲ���,success-���ųɹ�,shmError-�����쳣,
                                                 certificationFailure-��֤ʧ��,invalidDialingCharacters-�����ַ���Ч,
                                                 networkTimeout �C���糬ʱ,wirelessModemError������ģ�����,SIMError---SIM������,,networkError-�������unknown �Cδ֪����)*/
    NET_DVR_IPADDR    struIpAddr;  //IP��ַ
    NET_DVR_IPADDR    struIPMask;  //�����ַ
    NET_DVR_IPADDR    struGatewayIPMask;  //���ص�ַ
    NET_DVR_IPADDR    struDnsServerIpAddr; //DNS��ַ
    BYTE        byRes[256];    
}NET_DVR_WIRELESSDIAL_STATUS,*LPNET_DVR_WIRELESSDIAL_STATUS;

typedef    struct tagNET_DVR_WIRELESSDIAL_CONNECT
{
    DWORD        dwSize;//�ṹ���С
    DWORD       dwInterface; //������ţ�1,2����
    BYTE        byEnableConnect; //�Ƿ�������0-������1-����
    BYTE        byRes[255];
}NET_DVR_WIRELESSDIAL_CONNECT_PARAM,*LPNET_DVR_WIRELESSDIAL_CONNECT_PARAM;


typedef    struct tagNET_DVR_LITESTORAGE
{
    DWORD        dwSize;//�ṹ���С
    BYTE       byEnable; /*ʹ�� 0-������,1-����*/
    BYTE       byStorageTime;/*�洢ʱ�� 1-30 Ĭ��7��*/
    BYTE       byLevel; //�ȼ�������0-��Чֵ����������1-�ͣ�2-��(Ĭ��)��3-�ߣ�
    BYTE        byRes;
    float           fCapacity;//����SD��¼��ռ䣬ֻ��
    BYTE        byDefLowStorageTime;// ��ģʽ���Ƽ����� ֻ��
    BYTE        byDefMediumStorageTime; // ��ģʽ���Ƽ����� ֻ��
    BYTE        byDefHighStorageTime; // ��ģʽ���Ƽ����� ֻ��
    BYTE       byRes1[61];
}NET_DVR_LITESTORAGE,*LPNET_DVR_LITESTORAGE;

typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;//�ṹ���С
    NET_VCA_POLYGON  struRegion;//�궨����
    BYTE        byRes[64];
}NET_DVR_CALIBRATION,*LPNET_DVR_CALIBRATION;

typedef    struct    tagNET_DVR_STD_CONFIG
{
    void*        lpCondBuffer;        //[in]��������(�ṹ���ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD        dwCondSize;            //[in] lpCondBufferָ����ڴ��С
    void*        lpInBuffer;            //[in]�������(�ṹ���ʽ),����ʱ��ΪNULL����ȡʱΪNULL
    DWORD        dwInSize;            //[in] lpInBufferָ����ڴ��С
    void*        lpOutBuffer;        //[out]�������(�ṹ���ʽ),��ȡʱ��ΪNULL,����ʱΪNULL
    DWORD        dwOutSize;            //[in] lpOutBufferָ����ڴ��С
    void*        lpStatusBuffer;        //[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�������Ҫ,������NULL
    DWORD        dwStatusSize;        //[in] lpStatusBufferָ����ڴ��С
    void*       lpXmlBuffer;    //[in/out]byDataType = 1ʱ��Ч,xml��ʽ����
    DWORD       dwXmlSize;      //[in/out]lpXmlBufferָ����ڴ��С,��ȡʱͬʱ��Ϊ����������������ȡ�ɹ�����޸Ļ�ʵ�ʳ��ȣ�����ʱ��ʾʵ�ʳ��ȣ������������ڴ��С
    BYTE        byDataType;     //[in]����/�����������,0-ʹ�ýṹ������lpInBuffer/lpOutBuffer��Ч,1-ʹ��XML����lpXmlBuffer��Ч
    BYTE        byRes[23];
}NET_DVR_STD_CONFIG,*LPNET_DVR_STD_CONFIG;

typedef    struct    DWORDtagNET_DVR_STD_ABILITY
{
    void*        lpCondBuffer;    //[in]��������(���ָ�ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD        dwCondSize;        //[in] dwCondSizeָ����ڴ��С
    void*        lpOutBuffer;    //[out]�������(XML��ʽ),��ΪNULL
    DWORD        dwOutSize;        //[in] lpOutBufferָ����ڴ��С
    void*        lpStatusBuffer;    //[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�������Ҫ,������NULL
    DWORD        dwStatusSize;    //[in] lpStatusBufferָ����ڴ��С
    DWORD        dwRetSize;        //[out]��ȡ�������ݳ���(lpOutBuffer����lpStatusBufferָ���ʵ�����ݳ���)
    BYTE        byRes[32];        //�����ֽ�
}NET_DVR_STD_ABILITY,*LPNET_DVR_STD_ABILITY;

typedef struct tagNET_DVR_STD_CONTROL
{
    void*        lpCondBuffer;    //[in]��������(���ָ�ʽ),����ͨ���ŵ�.����ΪNULL
    DWORD        dwCondSize;        //[in] dwCondSizeָ����ڴ��С
    void*        lpStatusBuffer;    //[out]���ص�״̬����(XML��ʽ),��ȡ�ɹ�ʱ���ḳֵ,�������Ҫ,������NULL
    DWORD        dwStatusSize;    //[in] lpStatusBufferָ����ڴ��С
    void*       lpXmlBuffer;    //[in/out]byDataType = 1ʱ��Ч,xml��ʽ����
    DWORD       dwXmlSize;      //[in/out]lpXmlBufferָ����ڴ��С,��ȡʱͬʱ��Ϊ����������������ȡ�ɹ�����޸Ļ�ʵ�ʳ��ȣ�����ʱ��ʾʵ�ʳ��ȣ������������ڴ��С
    BYTE        byDataType;     //[in]����/�����������,0-ʹ�ýṹ������lpCondBuffer��Ч,1-ʹ��XML����lpXmlBuffer��Ч
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;

#define MAX_FILE_PATH_LEN       256     //�ļ�·������
typedef struct tagNET_DVR_MIME_UNIT
{
    //��ʽ����
    //Content-Disposition: form-data; name="upload"; filename="C:\Users\test\Desktop\11.txt"
    //Content-Type: text/plain
    char szContentType[32];               //��ӦContent-Type
    char szName[MAX_FILE_PATH_LEN];       //��Ӧname�ֶ�
    char szFilename[MAX_FILE_PATH_LEN];   //��Ӧfilename�ֶ�
    DWORD dwContentLen;                   //Content�ĳ���
    char* pContent;                       //����ָ��
    BYTE bySelfRead;                 // 0-��紫���ļ� 1-�ڲ���ȡ���ݣ�ͨ��szFilename��������·����
    BYTE byRes[15];
}NET_DVR_MIME_UNIT, *LPNET_DVR_MIME_UNIT;

typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
    DWORD   dwSize;                     //�ṹ���С
    void*   lpRequestUrl;               //��������ַ�����ʽ
    DWORD   dwRequestUrlLen;            //��������ȣ��ַ�������
    void*   lpInBuffer;                 //���������������XML��ʽ
    DWORD   dwInBufferSize;             //���������������С
    DWORD   dwRecvTimeOut;              //���ճ�ʱʱ�䣬��λ��ms����0��ʹ��Ĭ�ϳ�ʱ5s
    BYTE    byForceEncrpt;              //�Ƿ�ǿ�Ƽ��ܣ�0-��1-��
    BYTE    byNumOfMultiPart;           //0-��Ч������ֵ��ʾ���ķֶθ���������ʱlpInBuffer�������NET_DVR_MIME_UNIT�ṹ�������ָ�룬��ֵ������ṹ�����
    BYTE    byRes[30];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
    DWORD   dwSize;                        //�ṹ���С
    void*    lpOutBuffer;                //���������������XML��ʽ
    DWORD    dwOutBufferSize;            //���������������С(�ڴ��С)
    DWORD   dwReturnedXMLSize;            //ʵ�������XML���ݴ�С
    void*    lpStatusBuffer;                //���ص�״̬����(XML��ʽ),��ȡ����ɹ�ʱ���ḳֵ,�������Ҫ,������NULL
    DWORD    dwStatusSize;                //״̬��������С(�ڴ��С)
    BYTE    byRes[32];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;

typedef struct tagNET_DVR_JSON_DATA_CFG
{
    DWORD  dwSize;  //�ṹ���С
    void  *lpJsonData;  //JSON����
    DWORD  dwJsonDataSize;  //JSON���Ĵ�С
    void  *lpPicData;  //ͼƬ����
    DWORD  dwPicDataSize;  //ͼƬ���ݴ�С
    DWORD   dwInfraredFacePicSize;   //��������ͼƬ���ݴ�С������0ʱ������������ͼƬ����(��JSON����Ϊ��ResponseStatus��JSON������ʱ�����ֶ������壻��Inbound Data��JSON��������û��infraredFaceURLʱ�����ֶ���Ҫ���϶�����ͼƬ���ݣ�
    void*  lpInfraredFacePicBuffer;      //��������ͼƬ���ݻ���
    BYTE   byRes[248];  //����
}NET_DVR_JSON_DATA_CFG, *LPNET_DVR_JSON_DATA_CFG;

typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //ʱ
    BYTE byMinute; //��
    BYTE bySecond; //��
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //��ʼʱ���
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //����ʱ���
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byDoorStatus; //��״̬ģʽ���ݿ�ģʽ����0-��Ч��1-���ߣ�2-����״̬�����ɣ���3-����״̬�����ã���4-��ͨ״̬����״̬�ƻ�ʹ�ã�
    BYTE byVerifyMode; //��֤��ʽ��0-��Ч��1-ˢ����2-ˢ��+����(��������֤��ʽ�ƻ�ʹ��)��3-ˢ��,4-ˢ��������(��������֤��ʽ�ƻ�ʹ��), 5-ָ�ƣ�6-ָ��+���룬7-ָ�ƻ�ˢ����8-ָ��+ˢ����9-ָ��+ˢ��+���루���Ⱥ�˳�򣩣�10-������ָ�ƻ�ˢ�������룬11-����+ָ�ƣ�12-����+���룬
                       //13-����+ˢ����14-������15-����+���룬16-ָ�ƻ����룬17-����+ָ�ƣ�18-����+ָ��+���룬19-����+ָ��+ˢ����20-����+����+ָ�ƣ�21-����+������22-����������+ˢ��,23-ָ�ƻ�������24-ˢ�������������룬25-ˢ����������26-ˢ����������ָ�ƣ�27-ˢ����ָ�ƻ�����
                       //,28-����������,29-����+����+����,30-ˢ��������������+ˢ��
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //ʱ��β���
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //�ܼƻ�����
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];    
    NET_DVR_DATE struBeginDate; //���տ�ʼ����
    NET_DVR_DATE struEndDate; //���ս�������
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //ʱ��β���
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_COND
{
    DWORD dwSize;
    DWORD dwHolidayPlanNumber; //���ռƻ����
    WORD wLocalControllerID; //�͵ؿ��������[1,64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_PLAN_COND, *LPNET_DVR_HOLIDAY_PLAN_COND;

typedef struct tagNET_DVR_WEEK_PLAN_COND
{
    DWORD dwSize;
    DWORD dwWeekPlanNumber; //�ܼƻ����
    WORD wLocalControllerID; //�͵ؿ��������[1,64]
    BYTE byRes[106];
}NET_DVR_WEEK_PLAN_COND, *LPNET_DVR_WEEK_PLAN_COND;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�1-���ã�0-������
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //����������
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //���ռƻ���ţ���ǰ��䣬��0��Ч
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_COND
{
    DWORD dwSize;
    DWORD dwHolidayGroupNumber; //��������
    WORD wLocalControllerID; //�͵ؿ��������[1,64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_GROUP_COND, *LPNET_DVR_HOLIDAY_GROUP_COND;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�1-���ã�0-������
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //ģ������
    DWORD dwWeekPlanNo; //�ܼƻ���ţ�0Ϊ��Ч
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //�������ţ���ǰ��䣬��0��Ч
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;

typedef struct tagNET_DVR_PLAN_TEMPLATE_COND
{
    DWORD dwSize;
    DWORD dwPlanTemplateNumber; //�ƻ�ģ���ţ���1��ʼ�����ֵ���Ž���������ȡ
    WORD wLocalControllerID; //�͵ؿ��������[1,64]��0��Ч
    BYTE byRes[106];
}NET_DVR_PLAN_TEMPLATE_COND, *LPNET_DVR_PLAN_TEMPLATE_COND;

typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //�ƻ�ģ���ţ�Ϊ0��ʾȡ���������ָ�Ĭ��״̬����ͨ״̬��
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //�ƻ�ģ���ţ�Ϊ0��ʾȡ���������ָ�Ĭ��״̬��ˢ�����ţ�
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ã�0-�����ã�1-����    
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //Ⱥ����Ч�ڲ���
    BYTE byGroupName[GROUP_NAME_LEN]; //Ⱥ������
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //�Ƿ����ø�Ⱥ�����    
    BYTE byMemberNum; //ˢ����Ա����
    BYTE bySequenceNo; //Ⱥ��ˢ�������
    BYTE byRes;
    DWORD dwGroupNo;  //Ⱥ����,0xffffffff��ʾԶ�̿��ţ�0xfffffffe��ʾ��������
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //�Ƿ����øö��ؿ��������0-�����ã�1-����
    BYTE byEnableOfflineVerifyMode; //�Ƿ�������������ʱ��֤��ʽ�������������Զ�̿��ţ�
    BYTE byRes1[2];
    DWORD dwTemplateNo; //���ö��ؿ����ܵļƻ�ģ����
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //Ⱥ����ϲ���
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ö��ؿ����ܣ�0-�����ã�1-����
    BYTE bySwipeIntervalTimeout; //ˢ�������ʱʱ�䣬1-255s��Ĭ��10s    
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //Ⱥ��ˢ������
    BYTE byRes2[32];    
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO_V50
{
    BYTE byEnable; //�Ƿ����ø�Ⱥ�����
    BYTE byMemberNum; //ˢ����Ա����
    BYTE bySequenceNo; //Ⱥ��ˢ�������
    BYTE byRes;
    DWORD dwGroupNo;  //Ⱥ����,0xffffffff��ʾԶ�̿��ţ�0xfffffffe��ʾ��������
}NET_DVR_GROUP_COMBINATION_INFO_V50, *LPNET_DVR_GROUP_COMBINATION_INFO_V50;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG_V50
{
    BYTE byEnable; //�Ƿ����øö��ؿ��������0-�����ã�1-����
    BYTE byEnableOfflineVerifyMode; //�Ƿ�������������ʱ��֤��ʽ�������������Զ�̿��ţ���1-���ã�0-������
    BYTE byRes1[2];
    DWORD dwTemplateNo; //���ö��ؿ����ܵļƻ�ģ����
    NET_DVR_GROUP_COMBINATION_INFO_V50 struGroupCombination[GROUP_COMBINATION_NUM]; //Ⱥ����ϲ���
}NET_DVR_MULTI_CARD_GROUP_CFG_V50, *LPNET_DVR_MULTI_CARD_GROUP_CFG_V50;

typedef struct tagNET_DVR_MULTI_CARD_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ö��ؿ����ܣ�0-�����ã�1-����
    BYTE bySwipeIntervalTimeout; //ˢ�������ʱʱ�䣬1-255s��Ĭ��10s
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG_V50 struGroupCfg[NET_SDK_MULTI_CARD_GROUP_NUM_20]; //Ⱥ��ˢ������
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG_V50, *LPNET_DVR_MULTI_CARD_CFG_V50;

//2014-12-03  T1����״̬�ṹ��
typedef struct 
{
    DWORD  dwSize;//�ṹ���С
    WORD   wPort;  //�˿ں�
    //(�豸ͨ���˿ڿ��ƣ��˿ں��豸�˹̶����ϲ㲻�����ã�����ʼ����socket���ӣ���������T1�������ݣ���XML��ʽ)
    //0- �ر�(�ر��豸�������̣߳��ͷŶ˿�)��1- ����(�豸�ڲ������������߳�)
    BYTE   byPortState;  
    BYTE   byRes[61];     //����
}NET_DVR_T1TEST_PARAMCFG,*LPNET_DVR_T1TEST_PARAMCFG;

#define CARD_PARAM_CARD_VALID       0x00000001 //���Ƿ���Ч����
#define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
#define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
#define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
#define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
#define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ����������
#define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
#define CARD_PARAM_PASSWORD         0x00000080  //���������
#define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
#define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������
#define CARD_PARAM_EMPLOYEE_NO      0x00000400  //����
#define CARD_PARAM_NAME             0x00000800  //����
#define CARD_PARAM_DEPARTMENT_NO    0x00001000  //���ű��
#define CARD_SCHEDULE_PLAN_NO       0x00002000  //�Ű�ƻ����
#define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //�Ű�ƻ�����
#define CARD_ROOM_NUMBER            0x00008000  //�����
#define CARD_SIM_NO                 0x00010000  //SIM���ţ��ֻ��ţ�
#define CARD_FLOOR_NUMBER           0x00020000  //¥���
#define CARD_USER_TYPE              0x00040000  //�û�����

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //ʹ�ܷ�Ǳ�ع��ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //��Ǳ����ʼ���������    
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //������������ţ�Ϊ0��ʾ����ע��ʼ���������
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //�������ʾ,�Ƿ��п���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //�������ʾ,�Ƿ��й���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM]; //�������ʾ,�Ƿ��в���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];  //�������ʾ,�Ƿ��г���Ȩ�ޣ�-��Ȩ�ޣ�-��Ȩ��
    BYTE    byRes[256];                              //����
}NET_DVR_PHONE_DOOR_RIGHT_CFG,*LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ����ö��Ż������ܣ�1-���ã�0-������
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //���Ż����������ȡֵΪ�ű��
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byCardReaderType; //���������ͣ�1-DS-K110XM/MK/C/CK��2-DS-K192AM/AMP��3-DS-K192BM/BMP��4-DS-K182AM/AMP��5-DS-K182BM/BMP��6-DS-K182AMF/ACF��7-Τ����485������,8- DS-K1101M/MK��9- DS-K1101C/CK��10- DS-K1102M/MK/M-A
                            //11- DS-K1102C/CK��12- DS-K1103M/MK��13- DS-K1103C/CK��14- DS-K1104M/MK��15- DS-K1104C/CK��16- DS-K1102S/SK/S-A��17- DS-K1102G/GK��18- DS-K1100S-B��19- DS-K1102EM/EMK��20- DS-K1102E/EK��
                            //21- DS-K1200EF��22- DS-K1200MF��23- DS-K1200CF��24- DS-K1300EF��25- DS-K1300MF��26- DS-K1300CF��27- DS-K1105E��28- DS-K1105M��29- DS-K1105C��30- DS-K182AMF��31- DS-K196AMF��32-DS-K194AMP
                            //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C��35-DS-K1T105E/E-C/M/M-C/C/C-C��36-DS-K1T803F/MF/SF/EF��37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
                            //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED���ԣ�0-������1-����
    BYTE byErrorLedPolarity; //Error LED���ԣ�0-������1-����
    BYTE byBuzzerPolarity; //���������ԣ�0-������1-����
    BYTE bySwipeInterval; //�ظ�ˢ�����ʱ�䣬��λ����
    BYTE byPressTimeout;  //������ʱʱ�䣬��λ����
    BYTE byEnableFailAlarm; //�Ƿ����ö���ʧ�ܳ��α�����0-�����ã�1-����
    BYTE byMaxReadCardFailNum; //������ʧ�ܴ���
    BYTE byEnableTamperCheck;  //�Ƿ�֧�ַ����⣬0-disable ��1-enable
    BYTE byOfflineCheckTime;  //���߼��ʱ�� ��λ��
    BYTE byFingerPrintCheckLevel;   //ָ��ʶ��ȼ���1-1/10�����ʣ�2-1/100�����ʣ�3-1/1000�����ʣ�4-1/10000�����ʣ�5-1/100000�����ʣ�6-1/1000000�����ʣ�7-1/10000000�����ʣ�8-1/100000000�����ʣ�9-3/100�����ʣ�10-3/1000�����ʣ�11-3/10000�����ʣ�12-3/100000�����ʣ�13-3/1000000�����ʣ�14-3/10000000�����ʣ�15-3/100000000�����ʣ�16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byUseLocalController; //ֻ�����Ƿ������ھ͵ؿ������ϣ�0-��1-��
    BYTE byRes1;
    WORD wLocalControllerID; //ֻ�����͵ؿ�������ţ�1-64,0����δע��
    WORD wLocalControllerReaderID; //ֻ�����͵ؿ������Ķ�����ID��0����δע��
    WORD wCardReaderChannel; //ֻ����������ͨ��ͨ���ţ�0Τ�������ߣ�1-RS485A,2-RS485B
    BYTE byRes[16];
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //�Ƿ�ʹ�ܣ�1-ʹ�ܣ�0-��ʹ��
    BYTE byCardReaderType; //���������ͣ�1-DS-K110XM/MK/C/CK��2-DS-K192AM/AMP��3-DS-K192BM/BMP��4-DS-K182AM/AMP��5-DS-K182BM/BMP��6-DS-K182AMF/ACF��7-Τ����485�����ߣ�8- DS-K1101M/MK��9- DS-K1101C/CK��10- DS-K1102M/MK/M-A��11- DS-K1102C/CK��12- DS-K1103M/MK��13- DS-K1103C/CK��14- DS-K1104M/MK��15- DS-K1104C/CK��16- DS-K1102S/SK/S-A��17- DS-K1102G/GK��18- DS-K1100S-B��19- DS-K1102EM/EMK��20- DS-K1102E/EK��21- DS-K1200EF��22- DS-K1200MF��23- DS-K1200CF��24- DS-K1300EF��25- DS-K1300MF��26- DS-K1300CF��27- DS-K1105E��28- DS-K1105M��29- DS-K1105C��30- DS-K182AMF��31- DS-K196AMF��32-DS-K194AMP��33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C��35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/F-M/F-S/F-E,37-DS-K1A801F/F-M/F-S/F-E,38-DS-K1107M/MK,39-DS-K1107E/EK,40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED���ԣ�0-������1-����
    BYTE byErrorLedPolarity; //Error LED���ԣ�0-������1-����
    BYTE byBuzzerPolarity; //���������ԣ�0-������1-����
    BYTE bySwipeInterval; //�ظ�ˢ�����ʱ�䣬��λ����
    BYTE byPressTimeout;  //������ʱʱ�䣬��λ����
    BYTE byEnableFailAlarm; //�Ƿ����ö���ʧ�ܳ��α�����0-�����ã�1-����
    BYTE byMaxReadCardFailNum; //������ʧ�ܴ���
    BYTE byEnableTamperCheck;  //�Ƿ�֧�ַ����⣬0-disable ��1-enable
    BYTE byOfflineCheckTime;  //���߼��ʱ�� ��λ��
    BYTE byFingerPrintCheckLevel; //ָ��ʶ��ȼ���1-1/10�����ʣ�2-1/100�����ʣ�3-1/1000�����ʣ�4-1/10000�����ʣ�5-1/100000�����ʣ�6-1/1000000�����ʣ�7-1/10000000�����ʣ�8-1/100000000�����ʣ�9-3/100�����ʣ�10-3/1000�����ʣ�11-3/10000�����ʣ�12-3/100000�����ʣ�13-3/1000000�����ʣ�14-3/10000000�����ʣ�15-3/100000000�����ʣ�16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure��Ŀǰ�Ž���֧�֣�
    BYTE byUseLocalController; //ֻ�����Ƿ������ھ͵ؿ������ϣ�0-��1-��
    BYTE  byRes1;
    WORD wLocalControllerID; //ֻ�����͵ؿ��������, byUseLocalController=1ʱ��Ч��1-64,0����δע��
    WORD wLocalControllerReaderID; //ֻ�����͵ؿ������Ķ�����ID��byUseLocalController=1ʱ��Ч��0����δע��
    WORD wCardReaderChannel; //ֻ����������ͨ��ͨ���ţ�byUseLocalController=1ʱ��Ч��0Τ�������ߣ�1-RS485A,2-RS485B
    BYTE byFingerPrintImageQuality; //ָ��ͼ��������0-��Ч��1-������(V1)��2-�е�����(V1)��3-������(V1)��4-�������(V1)��5-������(V2)��6-�е�����(V2)��7-������(V2)��8-�������(V2)
    BYTE byFingerPrintContrastTimeOut; //ָ�ƶԱȳ�ʱʱ�䣬0-��Ч����Χ1-20����:1s-20s��0xff-���޴�
    BYTE byFingerPrintRecogizeInterval; //ָ������ʶ������0-��Ч����Χ1-10����:1s-10s��0xff-���ӳ�
    BYTE byFingerPrintMatchFastMode; //ָ��ƥ�����ģʽ��0-��Ч����Χ1-5����:����ģʽ1-����ģʽ5��0xff-�Զ�
    BYTE byFingerPrintModuleSensitive; //ָ��ģ�������ȣ�0-��Ч����Χ1-8���������ȼ���1-�����ȼ���8
    BYTE byFingerPrintModuleLightCondition; //ָ��ģ�����������0-��Ч��1-���⣬2-����
    BYTE byFaceMatchThresholdN; //�����ȶԷ�ֵ����Χ0-100
    BYTE byFaceQuality; //������������Χ0-100
    BYTE byFaceRecogizeTimeOut; //����ʶ��ʱʱ�䣬��Χ1-20����1s-20s��0xff-���޴�
    BYTE byFaceRecogizeInterval; //��������ʶ������0-��Ч����Χ1-10����1s-10s��0xff-���ӳ�
    WORD wCardReaderFunction; //ֻ�������������࣬��λ��ʾ����1λ-ָ�ƣ��ڶ�λ-����������λ-ָ����
    BYTE byCardReaderDescription[CARD_READER_DESCRIPTION]; //����������
    WORD wFaceImageSensitometry; //ֻ��������ͼ���ع�ȣ���Χ0-65535
    BYTE byLivingBodyDetect; //���˼�⣬0-��Ч��1-�����ã�2-����
    BYTE byFaceMatchThreshold1; //����1:1ƥ�䷧ֵ����Χ0-100
    WORD wBuzzerTime; //����ʱ�䣬��Χ0s-5999s��0-��������
    BYTE byFaceMatch1SecurityLevel; //����1:1ʶ��ȫ�ȼ���0-��Ч��1-һ�㣬2-��ǿ��3-��ǿ
    BYTE byFaceMatchNSecurityLevel; //����1:Nʶ��ȫ�ȼ���0-��Ч��1-һ�㣬2-��ǿ��3-��ǿ
    BYTE byEnvirMode;//����ʶ�𻷾�ģʽ��0-��Ч��1-���ڣ�2-������
    BYTE byLiveDetLevelSet;//��������ֵ�ȼ����ã�0-��Ч��1-�ͣ�2-�У�3-�ߣ�
    BYTE byLiveDetAntiAttackCntLimit;//����������������� 0-��Ч��1-255�Σ��ͻ��ˡ��豸ͳһ�������ƣ��������������ƣ���
    BYTE byEnableLiveDetAntiAttack;//�����������ʹ�ܣ�0-��Ч��1-�����ã�2-����
    BYTE bySupportDelFPByID;//ֻ�����������Ƿ�֧�ְ���ָIDɾ��ָ�ƣ�0-��Ч��1-��֧�֣�2-֧��
    BYTE byFaceContrastMotionDetLevel;//�����ȶ�ʱ�ƶ���⼶��0-��Ч��1-�ͣ�2-�У�3-�ߣ�0xff-����
    BYTE byDayFaceMatchThresholdN; //��������1:Nƥ�䷧ֵ����Χ0-100
    BYTE byNightFaceMatchThresholdN; //ҹ������1:Nƥ�䷧ֵ����Χ0-100
    BYTE byFaceRecogizeEnable; //����ʶ��ʹ�ܣ�0-��Ч��1-������2-�ر�
    BYTE byBlackFaceMatchThreshold; //������ƥ�䷧ֵ����Χ0-100
    BYTE byRes3;
    BYTE byDefaultVerifyMode; //ֻ����������Ĭ����֤��ʽ������Ĭ�ϣ���1-���ߣ�2-ˢ��+���룬3-ˢ����4-ˢ�������룬5-ָ�ƣ�6-ָ��+���룬7-ָ�ƻ�ˢ����8-ָ��+ˢ����9-ָ��+ˢ��+���룬10-������ָ�ƻ�ˢ�������룬11-����+ָ�ƣ�12-����+���룬13-����+ˢ����14-������15-����+���룬16-ָ�ƻ����룬17-����+ָ�ƣ�18-����+ָ��+���룬19-����+ָ��+ˢ����20-����+����+ָ�ƣ�21-����+������22-����������+ˢ����23-ָ�ƻ�������24-ˢ�������������룬25-ˢ����������26-ˢ����������ָ�ƣ�27-ˢ����ָ�ƻ�����
    DWORD dwFingerPrintCapacity;//ֻ����ָ������
    DWORD dwFingerPrintNum;//ֻ�����Ѵ���ָ������
    BYTE byEnableFingerPrintNum;//ֻ����ָ������ʹ�ܣ�0-��ʹ�ܣ�1-ʹ�ܣ�ֻ�е����ֶ�Ϊ1-ʹ��ʱ��dwFingerPrintCapacity��dwFingerPrintNum����Ч��
    BYTE byRes[231];
}NET_DVR_CARD_READER_CFG_V50, *LPNET_DVR_CARD_READER_CFG_V50;

typedef struct tagNET_DVR_FAILED_FACE_COND
{
    DWORD       dwSize;
    BYTE  byRes[128];          //����
}NET_DVR_FAILED_FACE_COND, *LPNET_DVR_FAILED_FACE_COND;

typedef struct tagNET_DVR_FAILED_FACE_INFO
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ��� 
    BYTE  byErrorCode;  //��ģʧ����ϸ����,0-��Ч��1-��ȡ�ļ�ʧ�ܣ�2-���ļ�ʧ�ܣ�3-�ڴ治�㣬4-ע������ʧ�ܣ�5-�ۼ��̫С��6-��Ȩ�޲�����
    BYTE byRes1[3];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE byRes[92];
}NET_DVR_FAILED_FACE_INFO, *LPNET_DVR_FAILED_FACE_INFO;

typedef struct tagNET_DVR_FACE_PARAM_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //���������Ŀ��ţ�����ʱ�ò����ɲ����ã�
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //�����Ķ������Ƿ���Ч��0-��Ч��1-��Ч������ʱ�ò����ɲ����ã�
    DWORD dwFaceNum;    //���û��ȡ������������ȡʱ��Ϊ0xffffffff��ʾ��ȡ����������Ϣ
    BYTE  byFaceID;     //������ţ���Чֵ��ΧΪ1-2   0xff��ʾ�ÿ���������������ʱ�ò����ɲ����ã�
    BYTE  byRes[127];   //����
}NET_DVR_FACE_PARAM_COND, *LPNET_DVR_FACE_PARAM_COND;

typedef struct tagNET_DVR_FACE_PARAM_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //���������Ŀ��� 
    DWORD dwFaceLen;    //�������ݳ���<DES���ܴ���>���豸�˷��صļ����ܺ������
    char* pFaceBuffer;  //��������ָ��
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //��Ҫ�·������Ķ��������������ʾ���ӵ�λ����λ��ʾ��0-���·��ö�������1-�·����ö�����
    BYTE  byFaceID;     //������ţ���Чֵ��ΧΪ1-2
    BYTE  byFaceDataType;   //�����������ͣ�0-ģ�壨Ĭ�ϣ���1-ͼƬ
    BYTE  byRes[126];
}NET_DVR_FACE_PARAM_CFG, *LPNET_DVR_FACE_PARAM_CFG;

typedef struct tagNET_DVR_FACE_PARAM_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ���
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //����������״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-���Ի����������3-�ڴ�����(����������)��4-�Ѵ��ڸ�������5-�Ƿ�����ID
    //,6-�㷨��ģʧ�ܣ�7-δ�·���Ȩ�ޣ�8-δ���壨��������9-���ۼ��С��С��10-ͼƬ���ݳ���С��1KB��11-ͼƬ��ʽ������png/jpg/bmp��,12-ͼƬ���������������ޣ�13-ͼƬ���������������ޣ�14-ͼƬ��ϢУ��ʧ�ܣ�15-ͼƬ����ʧ�ܣ�16-�������ʧ�ܣ�17-��������ʧ��
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ4ʱ����ʾ�Ѵ���������Ӧ�Ŀ���
    DWORD dwCardReaderNo;  //�ƶ�������ţ��������·����󷵻�
    BYTE  byTotalStatus;  //�·��ܵ�״̬��0-��ǰ����δ�������ж�������1-���������ж�����(���������ָ�����Ž����������еĶ������·��ˣ����ܳɹ����)
    BYTE  byFaceID;     //������ţ���Чֵ��ΧΪ1-2
    BYTE  byRes[130];
}NET_DVR_FACE_PARAM_STATUS, *LPNET_DVR_FACE_PARAM_STATUS;

typedef struct tagNET_DVR_FACE_PARAM_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ��� 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //�����Ķ�������Ϣ���������ʾ
    BYTE  byFaceID[MAX_FACE_NUM];        //��Ҫɾ����������ţ��������±ֵ꣬��ʾ0-��ɾ����1-ɾ��������
    BYTE  byRes1[42];          //����
}NET_DVR_FACE_PARAM_BYCARD, *LPNET_DVR_FACE_PARAM_BYCARD;

typedef struct tagNET_DVR_FACE_PARAM_BYREADER
{
    DWORD dwCardReaderNo;  //��ֵ��ʾ���������������
    BYTE  byClearAllCard;  //�Ƿ�ɾ�����п���������Ϣ��0-������ɾ��������Ϣ��1-ɾ�����п���������Ϣ
    BYTE  byRes1[3];       //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ��� 
    BYTE  byRes[548];          //����
}NET_DVR_FACE_PARAM_BYREADER, *LPNET_DVR_FACE_PARAM_BYREADER;

typedef union tagNET_DVR_DEL_FACE_PARAM_MODE
{
    BYTE   uLen[588];   //�����峤��
    NET_DVR_FACE_PARAM_BYCARD       struByCard;     //�����ŵķ�ʽɾ��
    NET_DVR_FACE_PARAM_BYREADER     struByReader;   //���������ķ�ʽɾ��
}NET_DVR_DEL_FACE_PARAM_MODE, *LPNET_DVR_DEL_FACE_PARAM_MODE;

typedef struct tagNET_DVR_FACE_PARAM_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //ɾ����ʽ��0-�����ŷ�ʽɾ����1-��������ɾ��
    BYTE  byRes1[3];        //����
    NET_DVR_DEL_FACE_PARAM_MODE struProcessMode;  //����ʽ
    BYTE  byRes[64];          //����
}NET_DVR_FACE_PARAM_CTRL, *LPNET_DVR_FACE_PARAM_CTRL;

typedef    struct tagNET_DVR_LOCAL_CONTROLLER_STATUS_COND
{
    DWORD            dwSize;
    WORD wLocalControllerID; //�͵ؿ��������(�ֿ������),Ϊ0��ʾ����
    BYTE                    byRes[306];
}NET_DVR_LOCAL_CONTROLLER_STATUS_COND, *LPNET_DVR_LOCAL_CONTROLLER_STATUS_COND;

typedef struct tagNET_DVR_LOCAL_CONTROLLER_STATUS
{
    DWORD            dwSize;
    WORD wLocalControllerID; //�͵ؿ��������(�ֿ������)
    BYTE byLocalAntiDismantleStatus; //�͵ؿ���������״̬��0-�رգ�1-����
    BYTE byPowerSupplyStatus; //�豸����״̬��1-�����繩�磬2-���ع���
    WORD wBatteryVoltage; //���ص�ѹֵ��ʵ��ֵ��10����λ������
    BYTE byBatteryLowVoltage; //�����Ƿ��ڵ�ѹ״̬��0-��1-��
    BYTE byFireAlarm; //����������0-������1-�̽ӱ�����2-�Ͽ�����
    BYTE bySerialNumber[SERIALNO_LEN];  //�豸���к�
    BYTE byMagneticStatus[MAX_DOOR_NUM];// �Ŵ�״̬��0�����رգ�1����������2�ƻ���·������3�ƻ���·������4�쳣����
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //����״̬��0�����رգ�1����������2�ƻ���·������3�ƻ���·������4�쳣����  
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //����������״̬��0-�����ߣ�1-����
    WORD wLocalControllerStatus; //ֻ�����͵ؿ���������״̬(�ֿ�������״̬)��0-���ߣ�1-�������ߣ�2-��·1�ϵ�RS485����1��3-��·1�ϵ�RS485����2��4-��·2�ϵ�RS485����1��5-��·2�ϵ�RS485����2��6-��·3�ϵ�RS485����1��7-��·3�ϵ�RS485����2��8-��·4�ϵ�RS485����1��9-��·4�ϵ�RS485����2��ֻ����
    BYTE byRes2[122];
}NET_DVR_LOCAL_CONTROLLER_STATUS, *LPNET_DVR_LOCAL_CONTROLLER_STATUS;

typedef struct tagNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG
{
    DWORD            dwSize;
    BYTE byLocalControllerName[LOCAL_CONTROLLER_NAME_LEN]; //�͵ؿ���������
    WORD wLocalControllerID; //�͵ؿ��������
    WORD    wDevPort;                 // �豸�˿ں�
    NET_DVR_IPADDR    struDevIP;       // �豸IP��ַ
    NET_DVR_IPADDR    struSubnetMask;  // �豸��������
    NET_DVR_IPADDR    struGateway;     // �豸����
    BYTE         bySearchProgress; //�������ȣ�0��ʾδ��ʼ��100��ʾͬ�����
    BYTE         byEffectData;//�Ƿ�Ϊ��Ч����,0��ʾ��Ч��1��ʾ�豸ֻ�����������ȣ���Ϊ������
    BYTE byRes[302];
}NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG, *LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //����״̬��0-�أ�1-��
    BYTE byDoorStatus[MAX_DOOR_NUM]; //��״̬��1-���ߣ�2-����״̬��3-����״̬��4-��ͨ״̬
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //�Ŵ�״̬��0-�պϣ�1-����
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; ////�¼�������״̬��0-�����룬1-������
    WORD wBatteryVoltage; //���ص�ѹֵ��ʵ��ֵ��10����λ������
    BYTE byBatteryLowVoltage; //�����Ƿ��ڵ�ѹ״̬��0-��1-��
    BYTE byPowerSupplyStatus; //�豸����״̬��1-�����繩�磬2-���ع���
    BYTE byMultiDoorInterlockStatus; //���Ż���״̬��0-�رգ�1-����
    BYTE byAntiSneakStatus; //��Ǳ��״̬��0-�رգ�1-����
    BYTE byHostAntiDismantleStatus; //��������״̬��0-�رգ�1-����
    BYTE byIndicatorLightStatus; //ָʾ��״̬��0-���ߣ�1-����
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //����������״̬��0-�����ߣ�1-����
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //����������״̬��0-�رգ�1-����
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //��������ǰ��֤��ʽ��1-ˢ����2-ˢ��+���룬3-ˢ����4-ˢ��������
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڲ���״̬��0-��Ӧ��������ڴ��ڳ���״̬��1-��Ӧ��������ڴ��ڲ���״̬
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��������ڱ���״̬��0-��Ӧ��������ڵ�ǰ�ޱ�����1-��Ӧ��������ڵ�ǰ�б���
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //���������״̬��0-��Ӧ����������ޱ�����1-��Ӧ����������б���
    DWORD dwCardNum; //����ӵĿ�����
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_ACS_WORK_STATUS_V50
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM_256]; //����״̬(�̵�������״̬)��0-�����أ�1-��������2-��·������3-��·������4-�쳣����
    BYTE byDoorStatus[MAX_DOOR_NUM_256]; //��״̬(¥��״̬)��1-���ߣ�2-����״̬(����)��3-����״̬(����)��4-��ͨ״̬(�ܿ�)
    BYTE byMagneticStatus[MAX_DOOR_NUM_256]; //�Ŵ�״̬��0-�����أ�1-��������2-��·������3-��·������4-�쳣����
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //�¼�������״̬��0-�����룬1-������    
    WORD wBatteryVoltage; //���ص�ѹֵ��ʵ��ֵ��10����λ������
    BYTE byBatteryLowVoltage; //�����Ƿ��ڵ�ѹ״̬��0-��1-��
    BYTE byPowerSupplyStatus; //�豸����״̬��1-�����繩�磬2-���ع���
    BYTE byMultiDoorInterlockStatus; //���Ż���״̬��0-�رգ�1-����
    BYTE byAntiSneakStatus; //��Ǳ��״̬��0-�رգ�1-����
    BYTE byHostAntiDismantleStatus; //��������״̬��0-�رգ�1-����
    BYTE byIndicatorLightStatus; //ָʾ��״̬��0-���ߣ�1-����
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM_512]; //����������״̬��0-�����ߣ�1-����
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM_512]; //����������״̬��0-�رգ�1-����
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM_512]; //��������ǰ��֤��ʽ��1-���ߣ�2-ˢ��+���룬3-ˢ����4-ˢ��������
    BYTE  bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//��������ڲ���״̬��0-��Ӧ��������ڴ��ڳ���״̬��1-��Ӧ��������ڴ��ڲ���״̬
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //��λ��ʾ��������ڱ���״̬��0-��Ӧ��������ڵ�ǰ�ޱ�����1-��Ӧ��������ڵ�ǰ�б���
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //��λ��ʾ���������״̬��0-��Ӧ����������ޱ�����1-��Ӧ����������б���
    DWORD dwCardNum; //����ӵĿ�����
    BYTE byFireAlarmStatus; //��������״̬��ʾ��0-������1-��·������2-�Ͽ�����
    BYTE byBatteryChargeStatus; //��س��״̬��0-��Ч��1-����У�2-δ���
    BYTE byMasterChannelControllerStatus; //��ͨ������������״̬��0-��Ч��1-�����ߣ�2-����
    BYTE bySlaveChannelControllerStatus; //��ͨ������������״̬��0-��Ч��1-�����ߣ�2-����
    BYTE byAntiSneakServerStatus; //��Ǳ�ط�����״̬��0-��Ч��1-δ���ã�2-������3-�Ͽ�
    BYTE byRes3[3];
    DWORD dwWhiteFaceNum; //����ӵİ���������������ͨ���������жϣ�
    DWORD dwBlackFaceNum; //����ӵĺ���������������ͨ���������жϣ�
    BYTE byRes2[108];
}NET_DVR_ACS_WORK_STATUS_V50, *LPNET_DVR_ACS_WORK_STATUS_V50;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //����������������0-��������1-����
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //������������������1-������0-������
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //���������ı��������1-������0-������
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //����1-N�����Ŵ򿪣�0-��������1-���������򿪣�
    BYTE  byDoorClose[MAX_DOOR_NUM]; //����1-N�����Źرգ�0-��������1-���������رգ�
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;

typedef enum _ENUM_UPGRADE_TYPE
{
    ENUM_UPGRADE_DVR = 0, //��ͨ�豸����
    ENUM_UPGRADE_ADAPTER = 1, //DVR����������
    ENUM_UPGRADE_VCALIB = 2,  //���ܿ�����
    ENUM_UPGRADE_OPTICAL = 3, //��˻�����
    ENUM_UPGRADE_ACS = 4, //�Ž�ϵͳ����
    ENUM_UPGRADE_AUXILIARY_DEV = 5,//�����豸����
    ENUM_UPGRADE_LED = 6, //LED���Ϳ��ͽ��տ�����
    ENUM_UPGRADE_INTELLIGENT = 7 //���������豸����
}ENUM_UPGRADE_TYPE;

typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //���ţ�Ϊ0��Ч
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������Ϊ0��Ч
    BYTE byWhiteListNo; //����������,1-8��Ϊ0��Ч
    BYTE byReportChannel; //�����ϴ�ͨ����1-�����ϴ���2-������1�ϴ���3-������2�ϴ���Ϊ0��Ч
    BYTE byCardReaderKind; //������������һ�࣬0-��Ч��1-IC��������2-���֤��������3-��ά�������,4-ָ��ͷ
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    DWORD dwDoorNo; //�ű��(¥����)��Ϊ0��Ч�����ӵ��豸Ϊ��Աͨ���豸ʱ����1Ϊ��������2Ϊ������
    DWORD dwVerifyNo; //���ؿ���֤��ţ�Ϊ0��Ч
    DWORD dwAlarmInNo;  //��������ţ�Ϊ0��Ч
    DWORD dwAlarmOutNo; //��������ţ�Ϊ0��Ч
    DWORD dwCaseSensorNo; //�¼����������
    DWORD dwRs485No;    //RS485ͨ���ţ�Ϊ0��Ч
    DWORD dwMultiCardGroupNo; //Ⱥ����
    WORD wAccessChannel;    //��Աͨ����
    BYTE  byDeviceNo;    //�豸��ţ�Ϊ0��Ч
    BYTE  byDistractControlNo;//�ֿ�����ţ�Ϊ0��Ч
    DWORD dwEmployeeNo; //���ţ�Ϊ0��Ч
    WORD wLocalControllerID; //�͵ؿ�������ţ�0-�Ž�������1-64����͵ؿ�����
    BYTE  byInternetAccess; //����ID����1-��������1,2-��������2,3-��������1��
    BYTE    byType;     //�������ͣ�0:��ʱ����,1-24Сʱ����,2-��ʱ���� ,3-�ڲ�������4-Կ�׷��� 5-�𾯷��� 6-�ܽ���� 7-24Сʱ��������  8-24Сʱ����������9-24Сʱ�𶯷���,10-�Ž��������ŷ�����11-�Ž��������ŷ��� 0xff-��
    BYTE  byMACAddr[MACADDR_LEN]; //�����ַ��Ϊ0��Ч
    BYTE  bySwipeCardType;//ˢ�����ͣ�0-��Ч��1-��ά��
    BYTE  byRes2;
    DWORD dwSerialNo; //�¼���ˮ�ţ�Ϊ0��Ч
    BYTE  byChannelControllerID; //ͨ��������ID��Ϊ0��Ч��1-��ͨ����������2-��ͨ��������
    BYTE  byChannelControllerLampID; //ͨ���������ư�ID��Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byChannelControllerIRAdaptorID; //ͨ������������ת�Ӱ�ID��Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byChannelControllerIREmitterID; //ͨ���������������ID��Ϊ0��Ч����Ч��Χ1-255��
    BYTE  byRes[4];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_EVENT_INFO_EXTEND
{
    DWORD dwFrontSerialNo; //�¼���ˮ�ţ�Ϊ0��Ч�������ֶ�Ϊ0��ƽ̨����dwSerialNo�ж��Ƿ�ʧ�¼��������ֶβ�Ϊ0��ƽ̨���ݸ��ֶκ�dwSerialNo�ֶι�ͬ�ж��Ƿ�ʧ�¼�������Ҫ���ڽ���������ĺ���dwSerialNo�������������
    BYTE  byUserType; //��Ա���ͣ�0-��Ч��1-��ͨ�ˣ����ˣ���2-�������ÿͣ���3-�������ˣ�4-����Ա
    BYTE  byCurrentVerifyMode; //��������ǰ��֤��ʽ��0-��Ч��1-���ߣ�2-ˢ��+���룬3-ˢ����4-ˢ�������룬5-ָ�ƣ�6-ָ��+���룬7-ָ�ƻ�ˢ����8-ָ��+ˢ����9-ָ��+ˢ��+���룬10-������ָ�ƻ�ˢ�������룬11-����+ָ�ƣ�12-����+���룬13-����+ˢ����14-������15-����+���룬16-ָ�ƻ����룬17-����+ָ�ƣ�18-����+ָ��+���룬19-����+ָ��+ˢ����20-����+����+ָ�ƣ�21-����+������22-����������+ˢ����23-ָ�ƻ�������24-ˢ�������������룬25-ˢ����������26-ˢ����������ָ�ƣ�27-ˢ����ָ�ƻ�����
    BYTE  byCurrentEvent; //�Ƿ�Ϊʵʱ�¼���0-��Ч��1-�ǣ�ʵʱ�¼�����2-�������¼���
    BYTE  byPurePwdVerifyEnable; //�豸�Ƿ�֧�ִ�������֤�� 0-��֧�֣�1-֧��
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID���������豸��˵�����ʹ���˹��ţ���ԱID���ֶΣ�byEmployeeNoһ��Ҫ���ݣ����byEmployeeNo��ת��ΪdwEmployeeNo����ô���ֶ�ҲҪ���ݣ������ϲ�ƽ̨��ͻ�����˵�����Ƚ���byEmployeeNo�ֶΣ�����ֶ�Ϊ�գ��ٿ��ǽ���dwEmployeeNo�ֶΣ�
    BYTE  byAttendanceStatus; //����״̬��0-δ����,1-�ϰ࣬2-�°࣬3-��ʼ��Ϣ��4-������Ϣ��5-��ʼ�Ӱ࣬6-�����Ӱ�
    BYTE  byStatusValue; //����״ֵ̬
    BYTE  byRes2[2];
    BYTE  byUUID[NET_SDK_UUID_LEN/*36*/]; //UUID�����ֶν��ڶԽ�өʯƽ̨�����вŻ�ʹ�ã�
    BYTE  byDeviceName[NET_DEV_NAME_LEN];   //�豸���к�
    BYTE  byRes[24];
}NET_DVR_ACS_EVENT_INFO_EXTEND, *LPNET_DVR_ACS_EVENT_INFO_EXTEND;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME struTime; //ʱ��
    BYTE    sNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR    struRemoteHostAddr ;//Զ��������ַ
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo; //��ϸ����
    DWORD dwPicDataLen;   //ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pPicData;
    WORD  wInductiveEventType; //�����¼����ͣ�0-��Ч���ͻ����жϸ�ֵΪ��0ֵ�󣬱�������ͨ�������¼��������֣�����ͨ��ԭ�б����������ͣ�dwMajor��dwMinor������
    BYTE    byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE    byRes1;             //�����ֽ�
    DWORD dwIOTChannelNo;    //IOTͨ����
    char    *pAcsEventInfoExtend;    //byAcsEventInfoExtendΪ1ʱ����ʾָ��һ��NET_DVR_ACS_EVENT_INFO_EXTEND�ṹ��
    BYTE    byAcsEventInfoExtend;    //pAcsEventInfoExtend�Ƿ���Ч��0-��Ч��1-��Ч
    BYTE    byTimeType; //ʱ�����ͣ�0-�豸����ʱ�䣬1-UTCʱ�䣨struTime��ʱ�䣩
    BYTE byRes[10];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;

#define JUDGE_MAX_VIDEOOUT_NUM 9

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG 
{
    DWORD   dwSize;
    BYTE    byEnable;    //�Ƿ�����
    BYTE    byRes1[3];
    DWORD   dwChanNo;    //������������Ƶͨ���� 
    BYTE    bySensitivity; //������ 1-100��������Խ�ߣ���ʾ�ϵ͵���������ʹ�ܸ���Ƶ���뼤�����ܣ�������Խ�ͣ���ʾ��Ҫ�ϸߵ���������ʹ�ܸ���Ƶ����ļ�������
    BYTE    byPriority;     //���ȼ�  0-���ȼ�0��1-���ȼ�1�� ֵԽ�󼶱�Խ��
    WORD    wDelayTime;  //�����������������л��ӳ�ʱ�䣬��λs, ��ʱ���Զ��ص�Ԥ�õ�1��Ӧ�Ļ���
    BYTE    byRes2;      //����
    BYTE    byEnablePreset; //�Ƿ�����Ԥ�õ�
    WORD    wPreset;    //Ԥ�õ�
    WORD    wBase;           /*��׼����*/
    BYTE    byRes3[2];
       BYTE    byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];          //���������Ƿ��������Ƶ����ڡ�ֵ0��ʾ�������1-��ʾ������±��ʾͨ��˳�����£�0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
    BYTE    byRes[255]; //����
}NET_DVR_AUDIO_ACTIVATION_CFG,*LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   byIROutPort;   //�������������1-���������1��2-���������2
    BYTE   byIRCmdIndex; //����ѧ�������Ӧ��������
    BYTE   byRes[254]; //����
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

#define  MAX_IR_CMD_NAME_LEN    32   //��������������Ƴ���
#define  MAX_IR_CMD_NUM         32   //�����������

typedef struct tagNET_DVR_INFRARED_CMD_INFO   //��������������Ϣ
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];  //������������
    BYTE   byRes[8];         //����
} NET_DVR_INFRARED_CMD_INFO,*LPNET_DVR_INFRARED_CMD_INFO;


typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;  //�ṹ���С
    BYTE      sIROutName[MAX_IR_CMD_NAME_LEN];  //�������������
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];  //������������Ϣ
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG,*LPNET_DVR_INFRARED_CMD_NAME_CFG;

typedef enum tagIR_LEARN_SEND_DATA_TYPE_ENUM
{ 
    ENUM_SENDDATA = 0x0, //��������
        ENUM_SEND_LEARN_IR_CMD_START,  //���ͺ���ѧ��
        ENUM_SEND_LEARN_IR_CMD_END   = 0x2  //����ѧ����� 
}IR_LEARN_SEND_DATA_TYPE_ENUM;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;       //�ṹ���С
    BYTE  byIROutPort;  //�������������1-���������1��2-���������2
    BYTE  byIRCmdIndex; //����ѧ�������Ӧ������ 
    BYTE  byRes[30];    //����   
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;       //�ṹ���С
    BYTE   bySaveLearnInfo;      //����ѧ����Ϣ��0-���棬1-������
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END,*LPNET_DVR_INFRARED_LEARN_END;

#define MAX_VIDEOIN_TYPE_NUM  10    //���֧�ֵ���Ƶ����Դ����

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;   //����Դ����  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
    WORD  wInNum;  //֧�ֵ��������
    WORD  wStartNo;  //�����Ӧ����ʼ�� 
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;

typedef  struct tagNET_DVR_TRIAL_SYSTEM_INFO
{
    DWORD dwSize ;    //�ṹ���С
    BYTE   byVideoInTypeNum ;   //��Ƶ����Դ���͸���
    BYTE   byRes1[3];
    NET_DVR_VIDEOIN_TYPE_INFO struVideoIn[MAX_VIDEOIN_TYPE_NUM] ;  //��Ƶ����Դ
    BYTE   byRes[512 ] ;  //����
} NET_DVR_TRIAL_SYSTEM_INFO, *LPNET_DVR_TRIAL_SYSTEM_INFO;

typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;       //�ṹ���С
    BYTE    byCaseNo[CASE_NO_LEN];  //�������
    BYTE    byCaseName[CASE_NAME_LEN]; //�������ƣ�
    BYTE    byLitigant1[LITIGANT_LEN]; //������1��
    BYTE    byLitigant2[LITIGANT_LEN]; //������2��
    BYTE    byChiefJudge[CHIEF_JUDGE_LEN];//���г�
    BYTE    byCaseType; //�������ͣ�1-���°�����2-���°�����3- sCaseTypeCustom��Ч
    BYTE    byShowCaseInfoTime; /* ������Ϣ��ʾʱ��,��λ��, ȡֵ��Χ1~30*/ 
    BYTE    byRes1[2]; //����
    char    sCaseTypeCustom[NET_SDK_CASETYPE_LEN/*32*/];//�Զ��尸������
    BYTE    byRes[220]; //����
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;

#define     MICROPHONE_NUM            16
#define     FAN_NUM                8
#define     FPGA_NUM                8
#define     MAIN_BOARD                8
#define  LOCAL_INPUT_NUM        24
#define  LAMP_STATE_NAME        32
#define  LAMP_NAME                32
#define FILE_NAME_LEN            32
typedef  struct _NET_DVR_REMOTE_PLAY_
{
    DWORD    dwSize;            
    BYTE    byFileName[FILE_NAME_LEN];   //��Ҫ���ŵ��ļ�����
    BYTE    byVideoOut[7];    //���������
    BYTE    byRes1[5];
    BYTE    byType;  // 0-�����壬1-��ʼ���ţ�2-ֹͣ����
    BYTE      byRes[31];  //����
}NET_DVR_REMOTE_PLAY, *LPNET_DVR_REMOTE_PLAY;

typedef  struct _NET_DVR_TRIAL_MICROPHONE_STATUS
{
    DWORD     dwSize ;
    BYTE    byMicrophoneStatus [MICROPHONE_NUM];//��˷�״̬�±��ʾ��˷��0-���磬1-������
    BYTE    byRes[32] ;  //����
}NET_DVR_TRIAL_MICROPHONE_STATUS, *LPNET_DVR_TRIAL_MICROPHONE_STATUS;

typedef  struct _NET_DVR_TRIAL_HOST_STATUS
{
    DWORD  dwSize ;
    DWORD  dwFanSpeed [FAN_NUM];//����ת��
    WORD   wMainBoardTemp[MAIN_BOARD]; //�����¶�
    BYTE   byFpgaTempWarn [FPGA_NUM];     //����0-�����¶����ޱ���״̬������1-FPGA�¶ȱ���״̬λ��1-���ڱ���״̬   0-�����ޱ���״̬
    BYTE   byRes[32] ;  //����
}NET_DVR_TRIAL_HOST_STATUS, *LPNET_DVR_TRIAL_HOST_STATUS;

typedef  struct _NET_DVR_LOCAL_INPUT_INFO_
{
    DWORD      dwSize;
    BYTE      byChannelName[NAME_LEN] ;        //ͨ������
    BYTE      byRes[32] ;  //����
}NET_DVR_LOCAL_INPUT_INFO, *LPNET_DVR_LOCAL_INPUT_INFO;

typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE     byEnable;  //�Ƿ�����
    BYTE     byRes1[3];
    BYTE     byLampName[LAMP_NAME];   //Lamp ���ƣ��������3��4��ΪLamp1������5��6�����Ϊlamp2��
    BYTE     byLampState1[LAMP_STATE_NAME];   //״̬1��Ӧ���ƣ� 
    BYTE     byLampState2[LAMP_STATE_NAME];   //״̬2��Ӧ����
    BYTE     byLampState3[LAMP_STATE_NAME];   //״̬3��Ӧ����
    BYTE     byRes[32];
}NET_DVR_LAMP_STATUS,*LPNET_DVR_LAMP_STATUS;

typedef  struct _NET_DVR_LAMP_OUT
{
    DWORD        dwSize;
    NET_DVR_LAMP_STATUS  struLampInfo[2]; //����0-��ʾlamp1,����1����lamp2
    BYTE  byRes[256];  //����
}NET_DVR_LAMP_OUT, *LPNET_DVR_LAMP_OUT;

typedef  struct _NET_DVR_LAMP_CONTROL
{
    DWORD     dwSize ;
    BYTE  byLampNo ; //Lamp��ţ���Ӧ����Lamp�����±�
    BYTE  byLampStateNo ; //Lamp״̬��� 0-�����壬1-״̬1, 2-״̬2�� 3-״̬3  ��ӦLAMP���������״̬
    BYTE  byRes[14] ;  //����
}NET_DVR_LAMP_CONTROL, *LPNET_DVR_LAMP_CONTROL;


//ʵʱ��Ϣ
typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE                byStart;          // ��ʼ��
    BYTE                byCMD;         // ����ţ�01-����ָ�02-�뿪ָ�03-ӵ��״ָ̬��(Ϊ03ʱ��ֻ��byLaneState��byQueueLen��Ч)��04-����Ȧ״̬��Ϊ04ʱ��wLoopState��wStateMask��Ч����ʾbyLane�����϶����Ȧ�Ĺ���״̬��
    WORD                wSpaceHeadway;        //��ͷ��࣬����������
    WORD                wDeviceID;      // �豸ID
    WORD                wDataLen;       // ���ݳ���
    BYTE                byLane;         // ��Ӧ������
    BYTE                bySpeed;        // ��Ӧ���٣�KM/H��
    BYTE                  byLaneState;     // ����״̬��0-��״̬��1-��ͨ��2-ӵ����3-����
    BYTE                  byQueueLen;       // ����״̬���Ŷӳ��ȣ�����50�ף�
    WORD                wLoopState;         //��Ȧ״̬���ڼ�λ��ʾ������Ȧ״̬��״̬1-���0-�뿪����Ȧ��ŴӾ�ͷ�ɽ���Զ���������û��ڽ���ʱ���Ƚ��������ţ��ٽ�����Ȧ�ţ�������������Ȧ����Ψһ�ġ�
    WORD                wStateMask;         //��Ȧ״̬���룬����λΪ1��ӦwLoopState״̬λ��Ч��Ϊ0��ʾ��Ч
    DWORD               dwDownwardFlow;     //��ǰ���� ���ϵ��³�����
    DWORD               dwUpwardFlow;       //��ǰ���� ���µ��ϳ�����
    BYTE                byJamLevel;         //ӵ�µȼ�����byLaneStateΪ3ʱ��Ч��1-��ȣ�2-�жȣ�3-�ض�
    BYTE               byVehicleDirection; //0-δ֪��1-���϶��£�2-���¶���
    BYTE               byJamFlow;          //ӵ������������ÿ����һ�������ϱ�һ���ۼƳ�������Ϣ
    BYTE                byChannelizationLane;         //���������ţ�������ʾ�����������仯�������һ��Ϊ·�ڳ�������Ŀ��
    BYTE                byVehicleType; //����ʶ��0- δ֪��1- �ͳ�(����)��2- ����(����)��3- �γ�(С��)��4- �ǻ�����
    BYTE               byRes1[5];        //����
    WORD                wTimeHeadway;        // ��ͷʱ�࣬�������
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

//TPSʵʱ���������ϴ�
typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwChan;//ͨ����
    NET_DVR_TIME_V30      struTime;    //���ʱ��
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// ��ͨ����ͳ����Ϣ
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    BYTE*                 pAddInfoBuffer;
#else
    /*������Ϣָ��,ָ��NET_DVR_TPS_ADDINFO�ṹ��*/
    BYTE*                 pAddInfoBuffer;
    BYTE                  byRes2[4];
#endif  
    /*������Ϣ��ʶ�����Ƿ���NET_DVR_TPS_ADDINFO�ṹ�壩,0-�޸�����Ϣ, 1-�и�����Ϣ��*/
    BYTE                  byAddInfoFlag;
    BYTE                  byRes[15];      // ����
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

//ͳ����Ϣ
typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE                  byLane;             // ��Ӧ������
    BYTE                  bySpeed;             // ��������ƽ���ٶ�
    WORD                  wArrivalFlow;        //��������
    DWORD               dwLightVehicle;      // С�ͳ�����
    DWORD               dwMidVehicle;        // ���ͳ�����
    DWORD               dwHeavyVehicle;      // ���ͳ�����
    DWORD               dwTimeHeadway;      // ��ͷʱ�࣬�������
    DWORD               dwSpaceHeadway;     // ��ͷ��࣬����������
    float               fSpaceOccupyRation; // �ռ�ռ���ʣ��ٷֱȼ���,������*1000
    float               fTimeOccupyRation;  // ʱ��ռ���ʣ��ٷֱȼ���,������*1000
    BYTE                  byStoppingTimes; //ƽ��ͣ������
    BYTE               byQueueLen;       // ����״̬���Ŷӳ��ȣ�����50�ף�
    BYTE                byFlag;          //�ϴ���ʶ��0-��ʾT1ʱ���ͳ�ƽ��,1-��ʾT2ʱ���ͳ��
    BYTE                  byVehicelNum;         //��������
    WORD                  wDelay;         //ƽ������
    BYTE                byRes1[6];               // ����
    DWORD               dwNonMotor;      // �ǻ���������
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

typedef struct tagNET_DVR_PANORAMA_LINKAGE
{
    DWORD            dwSize;
    BYTE             byEnable;//0-�رգ�1-����
    BYTE             byRes[127];
}NET_DVR_PANORAMA_LINKAGE, *LPNET_DVR_PANORAMA_LINKAGE;

// ��ͨ����ͳ����Ϣ
typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE                byStart;          // ��ʼ��
    BYTE                byCMD;         // ����ţ� 08-��ʱ��������ָ��
    BYTE                byRes[2];        // Ԥ���ֽ�
    WORD                wDeviceID;      // �豸ID
    WORD                wDataLen;       // ���ݳ���
    BYTE                byTotalLaneNum;  // ��Ч��������
    BYTE                byRes1[15];
    NET_DVR_TIME_V30    struStartTime;    //ͳ�ƿ�ʼʱ��
    DWORD                dwSamplePeriod;    //ͳ��ʱ��,��λ��
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

//TPSͳ�ƹ��������ϴ�
typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;          // �ṹ���С
    DWORD                 dwChan ;//ͨ����
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// ��ͨ����ͳ����Ϣ
    DWORD           dwJsonLen;//Json������Ϣ����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64��linux64��ָ��Ϊ8�ֽ�
    BYTE*                 pJsonBuf;
#else
    // Json������Ϣָ��,��JSON��Ӧ��EventNotificationAlert Json Block
    BYTE*                 pJsonBuf;
    BYTE                  byRes2[4];
#endif  
    BYTE                byJsonInfoFlag;          // �Ƿ���Json͸�����ݣ�0-�ޣ�1-��
    BYTE                  byRes[115];      // ����
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;

#define     DPC_CORRECT                1    //У��
#define     DPC_CORRECT_CANCEL         2    //ȡ��У��
#define     DPC_CROSS_DISPALY_OPEN     3    //������ʮ�ֲ���ʾ����
#define     DPC_CROSS_DISPALY_CLOSE    4    //������ʮ�ֲ���ʾ�ر�
#define     DPC_POINT                  5    //����У������
#define     DPC_UP                     6    //����У�����������ƫ��
#define     DPC_DOWN                   7    //����У�����������ƫ��
#define     DPC_RIGHT                  8    //����У�����������ƫ��
#define     DPC_LEFT                   9    //����У�����������ƫ��
#define     DPC_ALL_CORRECT            10   //���л���У��
#define     DPC_SAVE                   11   //���㱣��

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //ͨ����
    WORD    wCtrlType ;//�ο��궨��
    /*
    �ֶ�У����Ĭ��Ϊ�ֶ�У��ģʽ��ʹ��wCtrlType�������ͽ����ֶ�У����
    �Զ�У�����豸���Զ�����У���������ٽ����ֶ�У������ʱwCtrlType��struPoint������Ч��
    */
    BYTE    byDPCMode;//����У��ģʽ��0-�ֶ�У����1-�Զ�У��
    BYTE    byRes;
    NET_VCA_POINT struPoint; /*�����ͼ��ƽ�����꣬��һ����0-1*/
    BYTE    byRes1[64]; 
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

//�Ǿ�����У��(FFC)�ֶ�ģʽ
typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE   byRes[64]; 
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

//�Ǿ�����У��(FFC)��������
typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE   byRes[64]; 
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

//�洢����������״̬
typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    /*�洢ͼƬ���أ���λ��ʾ��0-�رգ�1-����
    ����0-�ƶ����ץͼ(�ݲ�֧��)
    ����1-����ץͼ(�ݲ�֧��)
    ����
    */
    BYTE  byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER]; 
    /*�洢������Ϣ���أ���λ��ʾ��0-�رգ�1-����
    ����0-�ȶ�ͼ(�ݲ�֧��)
    ����1-������(�ݲ�֧��)
    ����
    */       
    BYTE  byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER]; 
    BYTE  byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,
*LPNET_DVR_STORAGE_SERVER_SWITCH_CFG;

//ǿ��ֹͣȡ֤
typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE    byRes[64]; 
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //�������ܱ�������ʾͨ����
    BYTE  bySubWinNo;  //�������ܱ������Ӵ��ں�
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //��������ʱ��
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //����Դ��Ϣ
    BYTE  *byAlarmPic; //����ͼƬ������
    DWORD dwAlarmPicSize; //����ͼƬ��С����λ���ֽ�
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //�Ƿ�������ܱ���logo��0-�����ӣ���0-����
    BYTE byFlash;   //�Ƿ���˸��0-����˸����0-��˸
    WORD wFlashTime; //��˸ʱ�䣬��λ���룬ȡֵ��Χ�ӽ�������������ȡ 
    DWORD dwLogoX;  //logo X���꣬���봰���ܴ�С��1920*1920
    DWORD dwLogoY;  //logo Y����
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //���ܱ���ʱ�Ƿ��ϴ�����ͼƬ��0-���ϴ�����0-�ϴ�
    BYTE byOverlayTargetInfo; //����ͼƬ�Ƿ����Ŀ����Ϣ��0-�����ӣ���0-����
    BYTE byOverlayRuleInfo; //����ͼƬ�Ƿ�������ܹ�����Ϣ��0-�����ӣ���0-����
    BYTE byPicQuality;            //ͼƬ����ϵ�� 0-��� 1-�Ϻ� 2-һ��
    /*ͼƬ��С ����ͨ����������ȡ
    0-CIF��           1-QCIF��           2-D1��         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)��
    6-VGA��           7-XVGA��           8-HD900p��     9-HD1080��     10-2560*1920��
    11-1600*304��     12-2048*1536��     13-2448*2048,  14-2448*1200�� 15-2448*800��
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576��     
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(ʹ�õ�ǰ�����ֱ���)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //���ܱ���logo���Ӳ���    
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //���ܱ���ͼƬ����
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

#define MAX_OSD_LEN                 64   //�����OSD����
typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//ͼƬ����
    BYTE   byUsed; //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-����
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO,*LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD dwSize;
    DWORD  dwOutputPicNo;  //ͼƬ���
    BYTE   byEnable; //logo�Ƿ���ʾ��1-��ʾ��0-����
    BYTE   byRes1[3];    
    NET_DVR_RECTCFG_EX struRect;//logoλ�ã�����ڷ�Χ�ܴ�СΪ1920*1920
    BYTE   byFlash;  //�Ƿ���˸1-��˸��0-����˸
    BYTE   byTranslucent; //�Ƿ��͸��1-��͸����0-����͸��
    BYTE   byRes2[2];                //����
    DWORD  dwOutputPicWinNo; //�����ͼƬ���ںţ�1�ֽ��豸��+1�ֽ�����ں�+2�ֽ������ͼƬ���ںţ�,��ȡȫ��ʱ��Ч
    BYTE   byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG,*LPNET_DVR_OUTPUT_PIC_CFG;

typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //OSD�Ƿ���ʾ��0-����ʾ��1-��ʾ
    BYTE     byFontSize; //�����С��1-��2-�У�3-С
    BYTE     byOSDColor; //OSD��ɫ���ã�0-Ĭ�ϣ� 1-�ڣ�2-�ף�3-�죬4-�̣�5-��
    BYTE     byRes1[1];    
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD����
    NET_DVR_RECTCFG_EX struRect;//OSDλ�ã�����ڷ�Χ�ܴ�СΪ1920*1920
    DWORD dwOsdWinNo; //�����OSD���ںţ�1�ֽ��豸��+1�ֽ�����ں�+2�ֽ�OSD���ںţ�����ȡ����ʱ��Ч
    BYTE     byRes2[32];                //����
}NET_DVR_OUTPUT_OSD_CFG,*LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //��ʾͨ���ţ�1�ֽ��豸��+1�ֽڱ���+2�ֽ���ʾͨ���ţ�
    BYTE  byRelateAudio; //�Ƿ�����Ӵ�����Ƶ
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //������Ƶ���Ӵ��ںţ�1�ֽڵ���ǽ��+1�ֽ��Ӵ��ں�+2�ֽڴ��ںţ�
    DWORD dwChannel; //����ͨ���ţ���ȡȫ��ʱ��Ч
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD    dwSize;
    BYTE    bySensorChan[64];//ģ����ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE    byAlarmInChan[64];//��������ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE    byAlarmOutChan[64];//�������ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE    by485Chan[64];//485ͨ�� �±��ʾͨ���� 0-��ʾ��֧�֣�1-��ʾ֧��
    BYTE    byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;

typedef struct
{
    DWORD    dwSize;
    BYTE    byOutScale[8];//�±��ʾ�����ںţ�0-��ʾ��֧�֣�1-��ʾ12V��2-��ʾ24V
    BYTE    byRes[16];
}NET_DVR_OUT_SCALE_CFG, *LPNET_DVR_OUT_SCALE_CFG;

typedef    struct     tagNET_DVR_MONITOR_LOCATION_COND
{
    DWORD   dwSize; 
    DWORD   dwChan;
    /*
    0 ��ʾ���� ץ��MPRģʽ����֡����ץ�� IPCʹ�ã�
    1 ��ʾ���� ץ�� HVT ģʽ���쿨IPCʹ�ã�
    */
    BYTE    byRelateType;
    BYTE    byRes[63];        //����
}NET_DVR_MONITOR_LOCATION_COND, *LPNET_DVR_MONITOR_LOCATION_COND;

typedef    struct     tagNET_DVR_MONITOR_LOCATION_CFG
{
    DWORD   dwSize; 
    BYTE    byMonitoringSiteID[MAX_ID_LEN/*48*/];        //������
    BYTE    byDeviceID[MAX_ID_LEN/*48*/];                //�豸���
    BYTE    byDirectionNo;        //��ⷽ����,0-��,1-����,2-����,3-˫��,4-�ɶ�����,5-������,6-������,7-�ɱ�����,8-����
    BYTE    byRes1[3];        //����
    BYTE    byMonitorInfo[MONITORSITE_ID_LEN/*48*/];      //������Ϣ����
    BYTE    byRes[128];        //����
}NET_DVR_MONITOR_LOCATION_CFG, *LPNET_DVR_MONITOR_LOCATION_CFG;

typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;    //�ṹ��С
    DWORD   dwChannel; //ͨ����
    BYTE    byRes[64]; 
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;               //�ṹ��С
    BYTE    byAlarmStatus;//����״̬��0-����,1-����,2-����
    BYTE    byRes[3]; 
    WORD    wAlarmDealyTime;//�����ӳ�ʱ�䣬��λs
    WORD    wDisAlarmDealyTime;//�����ӳ�ʱ�䣬��λs
    BYTE    byRes1[64]; 
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{ 
    DWORD    dwSize;
    BYTE    byCommuMode;//˽��Э��ͨ��ģʽ��0-����ģʽ��1-��ȫģʽ
    BYTE    byRes1[2];
    BYTE    byWebAuthentication;    //web��֤���� 0-digest��1-basic��2-digest/basic;Ĭ��basic��֤
    BYTE    byRtspAuthentication;   //rtsp��֤���� 0-disable��1-basic��2-digest��3-digest/basic;Ĭ��basic��֤
    BYTE    byTelnetServer;         //telnet���� 0�����ã�1������
    BYTE    bySSHServer;            //SSH���� 0������(Ĭ��)��1������
    BYTE    byIllegalLoginLock;     //������½����, 0-���ã�Ĭ�ϣ���1-����
    BYTE    byStreamEncryption;     //�������� 0-�����ܣ�1-����
    BYTE    byAntiAttack;          //�Ƿ������������ܣ�0- �����ã�1-����(socket��ʱ5s�ر�)
    BYTE    byRes[26];
}NET_DVR_SECURITY_CFG,*LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD    dwSize;
    BYTE     byRes[3];
    BYTE     byLockCount;      //��Ӧ�û�����IP�����������Ĵ��������¼�󣬶Ը��û�����������0-������������ֵΪ�����Ĵ����� Ĭ��Ϊ0������1��ʾ�����¼1���Ժ���������û�����
    DWORD  dwLockTime;       //����ʱ�䣬��ʾ�����������ʱ�䣬��λ���롣����Ϊ0��byLockCount��Ϊ0ʱ��dwLockTime����Ч
    BYTE     byRes1[128];        //4�ֽڶ���
} NET_DVR_PASSWORD_MANAGE_CFG,*LPNET_DVR_PASSWORD_MANAGE_CFG;


typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD    dwSize;
    BYTE    byUnlockType;    //0-��Ч�� 1-��IP������2-��������IP
    BYTE    byIPVersion;    //1-IPV4��2-IPV6����byUnlockTypeΪ1ʱ���ò�����Ч
    BYTE    byRes1[2];
    NET_DVR_IPADDR struIPAddr;        //IP��ַ
    BYTE     byRes[64];
} NET_DVR_UNLOCK_INFO,*LPNET_DVR_UNLOCK_INFO;

typedef  struct  tagNET_DVR_LOCKED_INFO
{
    DWORD    dwSize;
    BYTE    byIPType;    //IP���� 0-��Ч��1-IPV4��2-IPV6
    BYTE    byRes1[3];
    NET_DVR_IPADDR struIPAddress;
    BYTE    byRes[20];    
} NET_DVR_LOCKED_INFO,*LPNET_DVR_LOCKED_INFO;


typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];
                            /*��������ֵ
                            0-�㷨�ⲻ֧����ʶ���ң�1-�ݿ˹��͹�(CZ - Czech Republic)��2-����(FRA - France)��
                            3-�¹�(DE - Germany),4-������(E - Spain), 5-�����(IT - Italy)��6-����(NL - Netherlands)��7-����(PL - Poland)��8-˹�工��(SVK - Slovakia), 9-�׶���˹(BY - Belorussia), 10-Ħ������(MDA - Moldova)��11-����˹(RU - Russia)��12-�ڿ���(UA - Ukraine),
                            169-���ô�(Canada), 172-����(US), 227-�Ĵ�����(Australia), 0xfe-�޷�ʶ��    
    */
    BYTE  byCountry;                   // ��������ֵ

    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;   //ͼƬ��С
    NET_VCA_RECT       struVcaRect;  //��ͼ�ڴ�ͼ�е�����λ�ã���һ������
    DWORD              dwFaceScore;  //���ƶȣ�ȡֵ��Χ0-100
    BYTE               byVcaRectOnly;   //�Ƿ�ֻ�ϴ����꣺0-��1-��
    BYTE               byRes1[3];
    DWORD              dwPID;   //ͼƬID
    DWORD              dwFaceSearchNum;// ���������������
    NET_VCA_RECT       struMultiVcaRect[NET_DVR_MAX_FACE_SEARCH_NUM];//���������ͼ�ڴ�ͼ�е�����λ�ã���һ������, byVcaRectOnly=1ʱ���ã���������
    BYTE                byRes[136];
    BYTE               *pImage;  //����ͼƬҪ��Ϊjpg��ʽ
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD dwSearchType;   //��������
    //&0x1 - ��Խ������
    //&0x2 - ��������
    //&0x4 - ��Ʒ����
    //&0x8 - ��Ʒ��ȡ
    //&0x10 - ��������
    //&0x20 - �뿪����
    //&0x40 - �Ƿ�ͣ��
    //&0x80 - �ǻ�
    //&0x100 -��Ա�ۼ�
    //&0x200 - �����ƶ�  
    //&0x400 - ��ڼ��  
    //&0x800 - �����仯  
    //&0x1000 - �����˶�  
    //&0x2000 - ��Ա���� 
    //&0x4000 - ��Ա����
    //&0x8000 - ��Ա����
    //&0x10000 �C̬�Ʒ���
    //&0x20000 �C ���ֻ�
    BYTE byHumanMisinfo;// ֻ��ȡ��������Ϣ 0-��1-�� 
    BYTE byRes[251];  //����
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef union tagNET_DVR_SMARTSEARCH_PIC_UNION
{  
    BYTE                byLen[256];  //�����峤��
    NET_DVR_VEHICLE_PARA     struVehiclePara; //���������Ϣ
    NET_VCA_HUMAN_FEATURE    struHumaFeature; //��������
    NET_DVR_FACE_PIC_DATA_INFO   struHumaPic;     //����������ͼ��Ϣ��ѯ������Զ��ͼƬ����ͼ��ͼ���ܣ�  
    NET_DVR_BEHAVIOUR_COND   struBehaviourCond;  //��Ϊ������������      
}NET_DVR_SMARTSEARCH_PIC_UNION,*LPNET_DVR_SMARTSEARCH_PIC_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA  //����ͼƬ�����ṹ�� size 344
{
    DWORD                dwChanNo;               //ͨ����
    DWORD                byStreamID[STREAM_ID_LEN] ;   //��ID��Ϣ����dwChanNo��ȣ����ȼ��ϸߣ�����byStreamID��Ϊ��ʱ����ʹ����ID��Ϊ�յ������ʹ��dwChanNo�ֶ�
    NET_DVR_TIME_EX         struStartTime;               //¼��ʼ��ʱ��
    NET_DVR_TIME_EX         struEndTime;            //¼��ֹͣ��ʱ��
    WORD                wSearchType;            //���ܲ�������  0-�������� ��1-�������ԣ� 2-��ͼ��ͼ ��3-��Ϊ����
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;  //���ܲ�������
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cStartTimeDifferenceH;   //��ʼʱ����UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cStartTimeDifferenceM;   //��ʼʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    char cStopTimeDifferenceH;    //����ʱ����UTC��ʱ�Сʱ����-12 ... +14��������ʾ��ʱ��
    char cStopTimeDifferenceM;    //����ʱ����UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE        byRes[59];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

//��������ʶ����
typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;   //���ƶ� 0-100
    NET_VCA_RECT   struVcaRect;    //�������򣬹�һ������
    BYTE           byRes2[236];   //����
}NET_DVR_FACE_SUB_PIC_INFO ,*LPNET_DVR_FACE_SUB_PIC_INFO;


typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT struVcaRect;
    WORD         wPeopleNum;       //������������ͼƬ���ͣ�NET_DVR_SMART_SEARCH_PIC_RET ��wPicType��Ϊ̬�Ʒ���ʱ��Ч
    BYTE         byRes2[238];   //����
}NET_DVR_BEHAVIOR_INFO ,*LPNET_DVR_BEHAVIOR_INFO;

typedef union tagNET_DVR_PIC_FEATURE_UNION
{  
    BYTE                         byLen[256];         //�����峤��
    NET_DVR_PLATE_INFO              struPlateInfo;      //����������Ϣ
    NET_DVR_FACE_SUB_PIC_INFO       struFaceSubInfo;    //������ͼ��Ϣ
    NET_DVR_BEHAVIOR_INFO           struBehavior;       //��Ϊ������Ӧ����ͼ��Ϣ
}NET_DVR_PIC_FEATURE_UNION,*LPNET_DVR_PIC_FEATURE_UNION;

typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];//�ļ���
    NET_DVR_TIME_EX     struTime;                      //ͼƬ��ץͼʱ��
    DWORD   dwFileSize;                 //�ļ��Ĵ�С
    WORD    wPicType;                  //ͼƬ����  0-�������� ��1-�������ԣ� 2-��ͼ��ͼ ��3-��Խ�����ߣ�4-�������֣� 5-��Ʒ������ 6-��Ʒ��ȡ�� 7-�������� 8-�뿪���� 9-�Ƿ�ͣ����10-�ǻ���11-��Ա�ۼ���12-�����ƶ�,13-��Ա���ܣ�14-�����˶���15-��Ա���أ�16-�����쳣��17-��ڼ�⣬18-��Ա������19-̬�Ʒ���  20-���ֻ�
    BYTE    byRes1[2];                  //����
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;  //ͼƬ����
    BYTE   	    byISO8601;  //�Ƿ���8601��ʱ���ʽ����ʱ���ֶ��Ƿ���Ч0-ʱ����Ч��������ʱ����Ϊ�豸����ʱ�� 1-ʱ����Ч 
    char cTimeDifferenceH;   //��UTC��ʱ�Сʱ����-12 ... +14�� ������ʾ��ʱ��
    char cTimeDifferenceM;   //��UTC��ʱ����ӣ���-30, 0, 30, 45��������ʾ��ʱ��
    BYTE    byRes[29];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET; 

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;   //�Ƿ��������� 0-δ������1-����
    BYTE  byRes[31];     //����
}NET_DVR_T1TEST_SEND_DATA_BUZZER,*LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef union NET_DVR_T1TEST_DATA_UNION
{
    BYTE  byUnionLen[32];
    NET_DVR_T1TEST_SEND_DATA_BUZZER struBuzzer;  //������
    NET_DVR_TIME_V30  struCurTime;   //��ǰPC��ʱ��
}NET_DVR_T1TEST_DATA_UNION,*LPNET_DVR_T1TEST_DATA_UNION;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;     //�ṹ���С
    BYTE  byDataType;  //�������� 0-��������1-pc����ʱ��
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;  //���͵���������
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA,*LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG  //ͼ��ģ��������
{
    DWORD       dwSize;    //�ṹ���С
    BYTE         byEnable;     //�Ƿ�����
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM  //�����Ϣ����
{
    DWORD           dwSize;   //�ṹ���С
    BYTE            byMouseEvent;  //����¼����ͣ� 0-������������1-������˫����2-����Ҽ���3-�����Ϲ���4-�����¹�
    BYTE            byRes1[3];    //����
    NET_VCA_POINT   struPoint;    //����λ�����꣬��һ������
    BYTE            byRes[64];    //����
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC���� 0-��������1-����
    BYTE  byMode;              //ģʽ, 0-����, 1-��ͨ,2-����
    BYTE  byFilterQValue;      //����Ӧ�˲���Qֵ����λOct, 0-1/40,1-1/10, Ĭ��ֵΪ1/40 Oct
    BYTE  byStaticFilterNum;   //��̬�˲���������ȡֵ��Χ0-12  
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG,*LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct _NET_DVR_DSP_PARAMETER_CFG
{
    BYTE  byFBCEnable;         //FBC���� 0-��������1-����
    BYTE  byVolume;            //�������� ȡֵ��Χ0~255
    BYTE  byRes[22];
}NET_DVR_DSP_PARAMETER_CFG, *LPNET_DVR_DSP_PARAMETER_CFG;


typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;  //�ṹ���С
    DWORD  dwHighPassFilter;         //��ͨ�˲��� ȡֵ��Χ 0-127, ����������������������Ϊ׼
    DWORD  dwNoiseMargin;            //�������ޣ�ȡֵ��Χ 0-127, ����������������������Ϊ׼
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //�Զ��޲����Ʋ���������Ƶ����ԴΪmacInʱ��Ч
    NET_DVR_DSP_PARAMETER_CFG  struDSPParameter;  //�����źŴ���оƬ����
    BYTE   byRes[40];
}NET_DVR_MIX_AUDIOIN_CFG,*LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;  //�ṹ���С
    BYTE    byModulatorEnbale;  //�Ƿ�������λ������
    BYTE    byPostFilter;       //Post Filter���أ�0-�رգ�1-������Ĭ�Ͽ���
    BYTE    byLimitPressure;    //���ѹ�޿��� 0-�رգ�1-������Ĭ�Ͽ���
    BYTE    byRes1;             //���� 
    WORD    wModulatorValue;    //��λ������ ȡֵ��Χ 0-127, ����������������������Ϊ׼��Ĭ��10
    WORD    wTriggerTime;       //ѹ�޴���ʱ�䣬ȡֵ��Χ 0-127, ����������������������Ϊ׼
    WORD    wFreeTime;          //ѹ���ͷ�ʱ�䣬ȡֵ��Χ 0-127, ����������������������Ϊ׼
    BYTE    byCompressThreshold; //ѹ������ 0-1X,1-2X,2-4X,3-8X  X��ʾ��������2X��ʾ2��
    BYTE    byCompressMode;     //ѹ����ʽ��0-Ӳѹ����1-��ѹ����Ĭ��ΪӲѹ��
    BYTE    byCompressRate;    //ѹ���� 
    BYTE    byRecoveryGain;    //�ظ����� 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //������� 0 ~100����ֵ��
    BYTE    byOutputMute;      //���������0-�رգ�1-����
    int     iOutputGainEx;      //���������չ��������ֵΪ�Ŵ󣬸�ֵΪ��С
    BYTE    bySoundQualityHanding;      //���ʴ���0-�رգ�1-����
    BYTE    byRes[55];
}NET_DVR_MIX_AUDIOOUT_CFG,*LPNET_DVR_MIX_AUDIOOUT_CFG;

#define MAX_AUDIOOUT_PRO_TYPE                8    //��Ƶ�������ʽ
typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD    dwSize;  //�ṹ���С
    WORD    wVolume[MAX_AUDIOOUT_PRO_TYPE];      //������С ȡֵ��Χ 0-127, ����������������������Ϊ׼
    BYTE    byPhantomPowerSupply;    //�Ƿ�ʹ�û����Դ����(��Ƶ����ͨ��ΪMICʱ��Ч)��0-�����壬1-�����磬2-����
    BYTE    byEnableAEC;    //�Ƿ�����ȫ�ֵĻ�������,0-�����ã�1-����
    WORD    wTalkVolume;   //֧�ֶԽ����豸���Խ�ʱ������С
    BYTE    byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];    //�Ƿ�����FBC(Х������),0-�����ã�1-����
    WORD    wVolumeEx[MAX_AUDIOOUT_PRO_TYPE];      //������С��չ ȡֵ��Χ 0-127, ����������������������Ϊ׼
    BYTE    byRes[4];     //����
}NET_DVR_VOLUME_CFG,*LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG  //��Ƶ����ڷֱ�������
{
    DWORD       dwSize;    //�ṹ���С
    BYTE         byResolution;     //�ֱ��� 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080, 5-3840*2160
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];  /* ����IP��ַ��������,��Ҫ�豸����,������ʽΪ����ĸ��������'.'����Ϊ������,����ΪIP��ַ  */
    WORD   wPort;
    BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO,*LPNET_DVR_ADDR_DOMAIN_INFO;

#define MAX_CENTERNUM_V40     6    //�������ĵ�ַ����

//����������������
typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD    dwSize;
    BYTE    byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];  /* ����������IP��ַ��������,��Ҫ�豸����,������ʽΪ����ĸ�������С�.������Ϊ������,����ΪIP��ַ */
    WORD    wAuxiliaryAlarmPort;     /* �����������˿ں� */
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40]; //�������ĵ�ַ��Ϣ
    BYTE    byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

//�������������ṹ
typedef struct tagNET_DVR_ALARM_LINKAGE_PARAM
{
    DWORD    dwSize;
    WORD     wChanRec;  //����¼���NVRͨ������λ��ʾ���������λ��ʾͨ��1�����λ��ʾͨ��16��������λ��ֵ��0-��¼��1-¼��
    BYTE     byRes1[2];
    WORD     wRecTime[MAX_LINKAGE_CHAN_NUM];    //¼���ʱ�䣬���ֽڱ�ʾ������byRecTime[0]��ʾͨ��1��¼��ʱ�䣬byRecTime[15]��ʾͨ��16��¼��ʱ��
    WORD     wChanPic;                          //����ץͼ��NVRͨ������λ��ʾ���������λ��ʾͨ��1�����λ��ʾͨ��16��������λ��ֵ��0-��ץͼ��1-ץͼ
    BYTE     byRes2[2];
    BYTE     byPicNum[MAX_LINKAGE_CHAN_NUM];    //ץͼ�ĸ��������ֽڱ�ʾ������byPicNum[0]��ʾͨ��1��ץͼ������byPicNum[15]��ʾͨ��16��ץͼ����
    BYTE     byTriggerEnabled[ALARMHOST_ALARMOUT_NUM];//����������������0-��������1-����     
    BYTE	 bySensorJointAlarmOut[ALARMHOST_ALARMOUT_NUM];//ң��ֵ��������������������ֵΪbyTriggerEnabled�����䡣�����±��ʾ�������ţ�����Ԫ�ص�ֵ��λ��ʾ�������ͣ��������ͼ���"��"�Ĺ�ϵ������ֵ���壺1bit0-��1��bit1-��2��bit2-��3��bit3-��4��bit4-����
    BYTE   	 byRes3[128];     	//����
}NET_DVR_ALARM_LINKAGE_PARAM, *LPNET_DVR_ALARM_LINKAGE_PARAM;


//�״���Ա����ϴ� ץ�Ļ�4.0����
typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD             dwSize;
    DWORD             dwRadarTriggerTimeSecond;//�״ﴥ��ʱ�䣬��
    DWORD             dwRadarTriggerTimeMSecond;//�״ﴥ��ʱ�䣬����
    DWORD             dwVedioTriggerTimeSecond;//��Ƶ����ʱ�䣬��
    DWORD             dwVedioTriggerTimeMSecond;//��Ƶ����ʱ�䣬����
    DWORD             dwVedioRadarDiffTimeMSecond;//�״���Ƶ����ʱ������
    DWORD             dwRadarSpeed;//�״��ٶ�
    BYTE              byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

#define MAX_FINGER_PRINT_LEN            768  //���ָ�Ƴ���
typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    DWORD dwFingerPrintLen;     //ָ�����ݳ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //��Ҫ�·�ָ�ƵĶ��������������ʾ��0-���·��ö�������1-�·����ö�����
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //ָ����������
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG,*LPNET_DVR_FINGER_PRINT_CFG;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //ָ�ƶ�����״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-��ָ��ģ�鲻���ߣ�3-���Ի�ָ�������4-�ڴ�������5-�Ѵ��ڸ�ָ�ƣ�6-�Ѵ��ڸ�ָ��ID��7-�Ƿ�ָ��ID��8-��ָ��ģ����������
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byTotalStatus;  //�·��ܵ�״̬��0-��ǰָ��δ�������ж�������1-���������ж�����(���������ָ�����Ž����������еĶ������·��ˣ����ܳɹ����)
    BYTE  byRes1;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ�Ŀ���
    DWORD dwCardReaderNo;  //��0��ʾ������ϢbyErrMsg��Ч����ֵ����byErrMsg��Ӧ�Ķ�������ţ�����ʲô����鿴byCardReaderRecvStatus��Ӧ��ŵ�ֵ����0ʱ��ʾ�޴�����Ϣ
    BYTE  byRes[24];
}NET_DVR_FINGER_PRINT_STATUS,*LPNET_DVR_FINGER_PRINT_STATUS;


typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ�������Ϣ���������ʾ
    DWORD dwFingerPrintNum; //���û��ȡ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ���п���Ϣ
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ-10   0xff��ʾ�ÿ�����ָ��
    BYTE  byCallbackMode;     //�豸�ص���ʽ��0-�豸���ж����������˷�Χ��1-��ʱ��������˲���Ҳ����
    BYTE  byRes1[26];          //����
}NET_DVR_FINGER_PRINT_INFO_COND,*LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_CFG_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    DWORD dwFingerPrintLen; 	//ָ�����ݳ���
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //��Ҫ�·�ָ�ƵĶ��������������ʾ���ӵ�λ����λ��ʾ��0-���·��ö�������1-�·����ö�����
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ�ƣ�2-Ѳ��ָ�ƣ�3-����ָ�ƣ�4-���ָ��
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //ָ����������
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE  byLeaderFP[MAX_DOOR_NUM_256]; //�����Ƿ����״���֤���ܣ����ֽڱ�ʾ����0-���״���֤���ܣ�1-���״���֤����
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_CFG_V50, *LPNET_DVR_FINGER_PRINT_CFG_V50;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //ָ�ƶ�����״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-��ָ��ģ�鲻���ߣ�3-���Ի�ָ�������4-�ڴ�������5-�Ѵ��ڸ�ָ�ƣ�6-�Ѵ��ڸ�ָ��ID��7-�Ƿ�ָ��ID��8-��ָ��ģ���������ã�10-ָ�ƶ������汾���ͣ��޷�֧�ֹ��ţ�
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ�ƣ�2-Ѳ��ָ�ƣ�3-����ָ�ƣ�4-���ָ��
    BYTE  byTotalStatus;  //�·��ܵ�״̬��0-��ǰָ��δ�������ж�������1-���������ж�����(���������ָ�����Ž����������еĶ������·��ˣ����ܳɹ����)
    BYTE  byRecvStatus;    //��������״̬��0-�ɹ���1-��ָ��Ŵ���2-ָ�����ʹ���3-���Ŵ��󣨿��Ź�񲻷����豸Ҫ�󣩣�4-ָ��δ�������Ż򿨺ţ����Ż򿨺��ֶ�Ϊ�գ���5-���Ų����ڣ�6-ָ�����ݳ���Ϊ0��7-��������Ŵ���8-���Ŵ���
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ�Ŀ���
    DWORD dwCardReaderNo;  //��byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ��ָ�ƶ�������ţ��������·����󷵻ء�0ʱ��ʾ�޴�����Ϣ
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE byErrorEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ�Ĺ��ţ���ԱID��
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_STATUS_V50, *LPNET_DVR_FINGER_PRINT_STATUS_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��ţ����ֶλ�ȡʱ��Ч������ʱ��Ч��
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ������Ƿ���Ч��0-��Ч��1-��Ч
    DWORD dwFingerPrintNum; //���û��ָ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ����ָ����Ϣ
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10   0xff��ʾ�ÿ�����ָ��
    BYTE  byCallbackMode;     //�豸�ص���ʽ��0-�豸���ж����������˷��أ�1-��ʱ��������˲���Ҳ����
    BYTE  byRes2[2];          //����
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE  byRes1[128];          //����
}NET_DVR_FINGER_PRINT_INFO_COND_V50, *LPNET_DVR_FINGER_PRINT_INFO_COND_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ�������Ϣ���������ʾ
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];        //��Ҫ��ȡ��ָ����Ϣ���������±ֵ꣬��ʾ0-��ɾ����1-ɾ����ָ��
    BYTE  byRes1[34];          //����
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;  //��ֵ��ʾ��ָ�ƶ��������
    BYTE  byClearAllCard;  //�Ƿ�ɾ�����п���ָ����Ϣ��0-������ɾ��ָ����Ϣ��1-ɾ�����п���ָ����Ϣ
    BYTE  byRes1[3];       //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    BYTE  byRes[548];          //����
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE
{
    BYTE   uLen[588];   //�����峤��
    NET_DVR_FINGER_PRINT_BYCARD       struByCard;     //�����ŵķ�ʽɾ��
    NET_DVR_FINGER_PRINT_BYREADER     struByReader;   //���������ķ�ʽɾ��
}NET_DVR_DEL_FINGER_PRINT_MODE,*LPNET_DVR_DEL_FINGER_PRINT_MODE;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //ɾ����ʽ��0-�����ŷ�ʽɾ����1-��������ɾ��
    BYTE  byRes1[3];       //����
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //����ʽ
    BYTE  byRes[64];          //����
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD_V50
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //ָ�ƵĶ�������Ϣ����λ��ʾ
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];	    //��Ҫɾ������ָ��ţ��������±ֵ꣬��ʾ0-��ɾ����1-ɾ����ָ��
    BYTE  byRes1[2];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
}NET_DVR_FINGER_PRINT_BYCARD_V50, *LPNET_DVR_FINGER_PRINT_BYCARD_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER_V50
{
    DWORD dwCardReaderNo;  //��ֵ��ʾ��ָ�ƶ��������
    BYTE  byClearAllCard;  //�Ƿ�ɾ�����п���ָ����Ϣ��0-�����ţ���ԱID��ɾ��ָ����Ϣ��1-ɾ�����п�����ԱID����ָ����Ϣ
    BYTE  byRes1[3];       //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
    BYTE  byRes[516];          //����
}NET_DVR_FINGER_PRINT_BYREADER_V50, *LPNET_DVR_FINGER_PRINT_BYREADER_V50;

typedef union tagNET_DVR_DEL_FINGER_PRINT_MODE_V50
{
    BYTE   uLen[588];   //�����峤��
    NET_DVR_FINGER_PRINT_BYCARD_V50       struByCard;     //�����ţ���ԱID���ķ�ʽɾ��
    NET_DVR_FINGER_PRINT_BYREADER_V50     struByReader;   //���������ķ�ʽɾ��
}NET_DVR_DEL_FINGER_PRINT_MODE_V50, *LPNET_DVR_DEL_FINGER_PRINT_MODE_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL_V50
{
    DWORD dwSize;
    BYTE  byMode;          //ɾ����ʽ��0-�����ţ���ԱID����ʽɾ����1-��������ɾ��
    BYTE  byRes1[3];       //����
    NET_DVR_DEL_FINGER_PRINT_MODE_V50 struProcessMode;  //����ʽ
    BYTE  byRes[64];          //����
}NET_DVR_FINGER_PRINT_INFO_CTRL_V50, *LPNET_DVR_FINGER_PRINT_INFO_CTRL_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_STATUS_V50
{
    DWORD dwSize;
    DWORD dwCardReaderNo;  //��ֵ��ʾ��ָ�ƶ��������
    BYTE  byStatus;         //״̬��0-��Ч��1-�����У�2-ɾ��ʧ�ܣ�3-�ɹ�
    BYTE  byRes[63];          //����
}NET_DVR_FINGER_PRINT_INFO_STATUS_V50, *LPNET_DVR_FINGER_PRINT_INFO_STATUS_V50;

typedef enum _ACS_DEV_SUBEVENT_ENUM_
{
    EVENT_ACS_HOST_ANTI_DISMANTLE = 0,      //�������𱨾�
    EVENT_ACS_OFFLINE_ECENT_NEARLY_FULL,    //�����¼���90%����
    EVENT_ACS_NET_BROKEN,                   //����Ͽ�
    EVENT_ACS_NET_RESUME ,                  //����ָ�
    EVENT_ACS_LOW_BATTERY,                  //���ص�ѹ��
    EVENT_ACS_BATTERY_RESUME,               //���ص�ѹ�ָ�����
    EVENT_ACS_AC_OFF,                       //������ϵ�
    EVENT_ACS_AC_RESUME,                    //������ָ�
    EVENT_ACS_SD_CARD_FULL,                 //SD���洢������
    EVENT_ACS_LINKAGE_CAPTURE_PIC,          //����ץ���¼�����
    EVENT_ACS_IMAGE_QUALITY_LOW,            //����ͼ���ʵ�
    EVENT_ACS_FINGER_PRINT_QUALITY_LOW,     //ָ��ͼ���ʵ�
    EVENT_ACS_BATTERY_ELECTRIC_LOW,         //��ص�ѹ��(�������豸ʹ��)
    EVENT_ACS_BATTERY_ELECTRIC_RESUME,       //��ص�ѹ�ָ�����(�������豸ʹ��)
    EVENT_ACS_FIRE_IMPORT_SHORT_CIRCUIT,           //���������·����
    EVENT_ACS_FIRE_IMPORT_BROKEN_CIRCUIT,         //���������·����
    EVENT_ACS_FIRE_IMPORT_RESUME,                   //��������ָ�
    EVENT_ACS_MASTER_RS485_LOOPNODE_BROKEN,    //����RS485��·�ڵ�Ͽ�
    EVENT_ACS_MASTER_RS485_LOOPNODE_RESUME,    //����RS485��·�ڵ�ָ�
    EVENT_ACS_LOCAL_CONTROL_OFFLINE,            //�͵ؿ���������
    EVENT_ACS_LOCAL_CONTROL_RESUME,            //�͵ؿ��������߻ָ�
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN,    //�͵�����RS485��·�Ͽ�
    EVENT_ACS_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME,   //�͵�����RS485��·�ָ�
    EVENT_ACS_DISTRACT_CONTROLLER_ONLINE,       //�ֿ�������
    EVENT_ACS_DISTRACT_CONTROLLER_OFFLINE,      //�ֿ�������
    EVENT_ACS_FIRE_BUTTON_TRIGGER,              //������ť����
    EVENT_ACS_FIRE_BUTTON_RESUME,               //������ť�ָ�
    EVENT_ACS_MAINTENANCE_BUTTON_TRIGGER,       //ά����ť����
    EVENT_ACS_MAINTENANCE_BUTTON_RESUME,        //ά����ť�ָ�
    EVENT_ACS_EMERGENCY_BUTTON_TRIGGER,         //������ť����
    EVENT_ACS_EMERGENCY_BUTTON_RESUME,          //������ť�ָ�
    EVENT_ACS_RES,
    EVENT_ACS_SUBMARINEBACK_COMM_BREAK,         //�뷴Ǳ�ط�����ͨ�ŶϿ�
    EVENT_ACS_SUBMARINEBACK_COMM_RESUME,        //�뷴Ǳ�ط�����ͨ�Żָ�
    EVENT_ACS_REMOTE_ACTUAL_GUARD,              //Զ��ʵʱ����
    EVENT_ACS_REMOTE_ACTUAL_UNGUARD,            //Զ��ʵʱ����
    EVENT_ACS_MOTOR_SENSOR_EXCEPTION,           //����򴫸����쳣
    EVENT_ACS_CAN_BUS_EXCEPTION,                //CAN�����쳣
    EVENT_ACS_CAN_BUS_RESUME,                   //CAN���߻ָ�
    EVENT_ACS_GATE_TEMPERATURE_OVERRUN,         //բ��ǻ���¶ȳ���
    EVENT_ACS_IR_EMITTER_EXCEPTION,             //��������쳣
    EVENT_ACS_IR_EMITTER_RESUME,                //�������ָ�
    EVENT_ACS_LAMP_BOARD_COMM_EXCEPTION,        //�ư�ͨ���쳣
    EVENT_ACS_LAMP_BOARD_COMM_RESUME,           //�ư�ͨ�Żָ�
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_EXCEPTION,  //����ת�Ӱ�ͨ���쳣
    EVENT_ACS_IR_ADAPTOR_BOARD_COMM_RESUME,     //����ת�Ӱ�ͨ�Żָ�
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_ALARM,        //ͨ�����������𱨾�
    EVENT_ACS_CHANNEL_CONTROLLER_DESMANTLE_RESUME,       //ͨ�����������𱨾��ָ�
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM,      //ͨ���������������뱨��
    EVENT_ACS_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME,     //ͨ���������������뱨���ָ�
    EVENT_ACS_STAY_EVENT,                                //�����¼�
    EVENT_ACS_LEGAL_EVENT_NEARLY_FULL                    //���ߺϷ��¼���90%����
}ACS_DEV_SUBEVENT_ENUM;

typedef enum _ACS_ALARM_SUBEVENT_ENUM_
{
    EVENT_ACS_ALARMIN_SHORT_CIRCUIT = 0,    //������·����
    EVENT_ACS_ALARMIN_BROKEN_CIRCUIT,       //������·����
    EVENT_ACS_ALARMIN_EXCEPTION,            //�����쳣����
    EVENT_ACS_ALARMIN_RESUME,               //���������ָ�
    EVENT_ACS_CASE_SENSOR_ALARM,            //�¼����뱨��
    EVENT_ACS_CASE_SENSOR_RESUME            //�¼�����ָ�
}ACS_ALARM_SUBEVENT_ENUM;

typedef enum _ACS_DOOR_SUBEVENT_ENUM_
{
    EVENT_ACS_LEADER_CARD_OPEN_BEGIN  = 0,        //�׿����ſ�ʼ
    EVENT_ACS_LEADER_CARD_OPEN_END,             //�׿����Ž���
    EVENT_ACS_ALWAYS_OPEN_BEGIN ,               //����״̬��ʼ
    EVENT_ACS_ALWAYS_OPEN_END,                  //����״̬����
    EVENT_ACS_ALWAYS_CLOSE_BEGIN,               //����״̬��ʼ
    EVENT_ACS_ALWAYS_CLOSE_END,                 //����״̬����
    EVENT_ACS_LOCK_OPEN,                        //������
    EVENT_ACS_LOCK_CLOSE,                       //�����ر�
    EVENT_ACS_DOOR_BUTTON_PRESS,                //���Ű�ť����
    EVENT_ACS_DOOR_BUTTON_RELEASE,              //���Ű�ť�ſ�
    EVENT_ACS_DOOR_OPEN_NORMAL,                 //�������ţ��Ŵţ�
    EVENT_ACS_DOOR_CLOSE_NORMAL ,               //�������ţ��Ŵţ�
    EVENT_ACS_DOOR_OPEN_ABNORMAL,               //���쳣�򿪣��Ŵţ�
    EVENT_ACS_DOOR_OPEN_TIMEOUT,                //�Ŵ򿪳�ʱ���Ŵţ�
    EVENT_ACS_REMOTE_OPEN_DOOR,                 //Զ�̿���
    EVENT_ACS_REMOTE_CLOSE_DOOR,                //Զ�̹���
    EVENT_ACS_REMOTE_ALWAYS_OPEN,               //Զ�̳���
    EVENT_ACS_REMOTE_ALWAYS_CLOSE,              //Զ�̳���
    EVENT_ACS_NOT_BELONG_MULTI_GROUP,                   //�������ڶ�����֤Ⱥ��
    EVENT_ACS_INVALID_MULTI_VERIFY_PERIOD,              //�����ڶ�����֤ʱ�����
    EVENT_ACS_MULTI_VERIFY_SUPER_RIGHT_FAIL,            //������֤ģʽ����������֤ʧ��
    EVENT_ACS_MULTI_VERIFY_REMOTE_RIGHT_FAIL,           //������֤ģʽԶ����֤ʧ��
    EVENT_ACS_MULTI_VERIFY_SUCCESS,                     //������֤�ɹ�
    EVENT_ACS_MULTI_VERIFY_NEED_REMOTE_OPEN,            //���ض�����֤��ҪԶ�̿���
    EVENT_ACS_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS,  //������֤����������֤�ɹ��¼�
    EVENT_ACS_MULTI_VERIFY_REPEAT_VERIFY_FAIL,          //������֤�ظ���֤ʧ��
    EVENT_ACS_MULTI_VERIFY_TIMEOUT,                     //������֤��ʱʧ��
    EVENT_ACS_REMOTE_CAPTURE_PIC,                       //Զ��ץ��
    EVENT_ACS_DOORBELL_RINGING,                          //������
    EVENT_ACS_SECURITY_MODULE_DESMANTLE_ALARM,       //�ſذ�ȫģ����𱨾�
    EVENT_ACS_CALL_CENTER,                            //���������¼�
    EVENT_ACS_FIRSTCARD_AUTHORIZE_BEGIN,               //�׿���Ȩ��ʼ
    EVENT_ACS_FIRSTCARD_AUTHORIZE_END,                 //�׿���Ȩ����
    EVENT_ACS_DOORLOCK_INPUT_SHORT_CIRCUIT,           //���������·����
    EVENT_ACS_DOORLOCK_INPUT_BROKEN_CIRCUIT,         //���������·����
    EVENT_ACS_DOORLOCK_INPUT_EXCEPTION,               //���������쳣����
    EVENT_ACS_DOORCONTACT_INPUT_SHORT_CIRCUIT,       //�Ŵ������·����
    EVENT_ACS_DOORCONTACT_INPUT_BROKEN_CIRCUIT,     //�Ŵ������·����
    EVENT_ACS_DOORCONTACT_INPUT_EXCEPTION,           //�Ŵ������쳣����
    EVENT_ACS_OPENBUTTON_INPUT_SHORT_CIRCUIT,       //���Ű�ť�����·����
    EVENT_ACS_OPENBUTTON_INPUT_BROKEN_CIRCUIT,      //���Ű�ť�����·����
    EVENT_ACS_OPENBUTTON_INPUT_EXCEPTION,            //���Ű�ť�����쳣����
    EVENT_ACS_DOORLOCK_OPEN_EXCEPTION,                  //�����쳣��
    EVENT_ACS_DOORLOCK_OPEN_TIMEOUT,                   //�����򿪳�ʱ
    EVENT_ACS_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE,     //�׿�δ��Ȩ����ʧ��
    EVENT_ACS_CALL_LADDER_RELAY_BREAK,          //���ݼ̵����Ͽ�
    EVENT_ACS_CALL_LADDER_RELAY_CLOSE,          //���ݼ̵����պ�
    EVENT_ACS_AUTO_KEY_RELAY_BREAK,             //�Զ������̵����Ͽ�
    EVENT_ACS_AUTO_KEY_RELAY_CLOSE,             //�Զ������̵����պ�
    EVENT_ACS_KEY_CONTROL_RELAY_BREAK,          //�����ݿؼ̵����Ͽ�
    EVENT_ACS_KEY_CONTROL_RELAY_CLOSE,          //�����ݿؼ̵����պ�
    EVENT_ACS_REMOTE_VISITOR_CALL_LADDER,       //�ÿͺ���
    EVENT_ACS_REMOTE_HOUSEHOLD_CALL_LADDER,     //ס������
    EVENT_ACS_LEGAL_MESSAGE,                    //�Ϸ�����
    EVENT_ACS_ILLEGAL_MESSAGE,                  //�Ƿ�����
    EVENT_ACS_TRAILING,                         //β��ͨ��
    EVENT_ACS_REVERSE_ACCESS,                   //������
    EVENT_ACS_FORCE_ACCESS,                     //������ײ
    EVENT_ACS_CLIMBING_OVER_GATE,               //��Խ
    EVENT_ACS_PASSING_TIMEOUT,                  //ͨ�г�ʱ
    EVENT_ACS_INTRUSION_ALARM,                  //�󴳱���
    EVENT_ACS_FREE_GATE_PASS_NOT_AUTH,          //բ������ͨ��ʱδ��֤ͨ��
    EVENT_ACS_DROP_ARM_BLOCK,                   //�ڱ۱��赲
    EVENT_ACS_DROP_ARM_BLOCK_RESUME,            //�ڱ��赲����
    EVENT_ACS_REMOTE_CONTROL_CLOSE_DOOR,        //ң��������
    EVENT_ACS_REMOTE_CONTROL_OPEN_DOOR,         //ң��������
    EVENT_ACS_REMOTE_CONTROL_ALWAYS_OPEN_DOOR   //ң����������
}ACS_DOOR_SUBEVENT_ENUM;

typedef enum _ACS_CARD_READER_SUBEVENT_ENUM_
{
    EVENT_ACS_STRESS_ALARM = 0,                            //в�ȱ���
    EVENT_ACS_CARD_READER_DESMANTLE_ALARM,              //���������𱨾�
    EVENT_ACS_LEGAL_CARD_PASS,                          //�Ϸ�����֤ͨ��
    EVENT_ACS_CARD_AND_PSW_PASS,                        //ˢ����������֤ͨ��
    EVENT_ACS_CARD_AND_PSW_FAIL,                        //ˢ����������֤ʧ��
    EVENT_ACS_CARD_AND_PSW_TIMEOUT,                     //ˢ����������֤��ʱ
    EVENT_ACS_CARD_MAX_AUTHENTICATE_FAIL,               //��������֤ʧ�ܳ���
    EVENT_ACS_CARD_NO_RIGHT,                            //��δ����Ȩ��
    EVENT_ACS_CARD_INVALID_PERIOD,                      //����ǰʱ����Ч
    EVENT_ACS_CARD_OUT_OF_DATE,                         //���Ź���
    EVENT_ACS_INVALID_CARD,                             //�޴˿���
    EVENT_ACS_ANTI_SNEAK_FAIL,                          //��Ǳ����֤ʧ��
    EVENT_ACS_INTERLOCK_DOOR_NOT_CLOSE,                 //������δ�ر�
    EVENT_ACS_FINGERPRINT_COMPARE_PASS,                 //ָ�Ʊȶ�ͨ��
    EVENT_ACS_FINGERPRINT_COMPARE_FAIL,                 //ָ�Ʊȶ�ʧ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_PASS,             //ˢ����ָ����֤ͨ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_FAIL,             //ˢ����ָ����֤ʧ��
    EVENT_ACS_CARD_FINGERPRINT_VERIFY_TIMEOUT,          //ˢ����ָ����֤��ʱ
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_PASS,      //ˢ����ָ�Ƽ�������֤ͨ��
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL,      //ˢ����ָ�Ƽ�������֤ʧ��
    EVENT_ACS_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,   //ˢ����ָ�Ƽ�������֤��ʱ
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_PASS,           //ָ�Ƽ�������֤ͨ��
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_FAIL,           //ָ�Ƽ�������֤ʧ��
    EVENT_ACS_FINGERPRINT_PASSWD_VERIFY_TIMEOUT,        //ָ�Ƽ�������֤��ʱ
    EVENT_ACS_FINGERPRINT_INEXISTENCE,                  //ָ�Ʋ�����
    EVENT_ACS_FACE_VERIFY_PASS,                         //������֤ͨ��
    EVENT_ACS_FACE_VERIFY_FAIL,                         //������֤ʧ��
    EVENT_ACS_FACE_AND_FP_VERIFY_PASS,                  //������ָ����֤ͨ��
    EVENT_ACS_FACE_AND_FP_VERIFY_FAIL,                  //������ָ����֤ʧ��
    EVENT_ACS_FACE_AND_FP_VERIFY_TIMEOUT,               //������ָ����֤��ʱ
    EVENT_ACS_FACE_AND_PW_VERIFY_PASS,                  //������������֤ͨ��
    EVENT_ACS_FACE_AND_PW_VERIFY_FAIL,                  //������������֤ʧ��
    EVENT_ACS_FACE_AND_PW_VERIFY_TIMEOUT,               //������������֤��ʱ
    EVENT_ACS_FACE_AND_CARD_VERIFY_PASS,                //������ˢ����֤ͨ��
    EVENT_ACS_FACE_AND_CARD_VERIFY_FAIL,                //������ˢ����֤ʧ��
    EVENT_ACS_FACE_AND_CARD_VERIFY_TIMEOUT,             //������ˢ����֤��ʱ
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_PASS,           //�����������ָ����֤ͨ��
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_FAIL,           //�����������ָ����֤ʧ��
    EVENT_ACS_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT,        //�����������ָ����֤��ʱ
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_PASS,         //������ˢ����ָ����֤ͨ��
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_FAIL,         //������ˢ����ָ����֤ʧ��
    EVENT_ACS_FACE_AND_CARD_AND_FP_VERIFY_TIMEOUT,      //������ˢ����ָ����֤��ʱ
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_PASS,            //���ż�ָ����֤ͨ��
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_FAIL,            //���ż�ָ����֤ʧ��
    EVENT_ACS_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT,         //���ż�ָ����֤��ʱ
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS,     //���ż�ָ�Ƽ�������֤ͨ��
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL,     //���ż�ָ�Ƽ�������֤ʧ��
    EVENT_ACS_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT,   //���ż�ָ�Ƽ�������֤��ʱ
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_PASS,          //���ż�������֤ͨ��
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_FAIL,          //���ż�������֤ʧ��
    EVENT_ACS_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT,       //���ż�������֤��ʱ
    EVENT_ACS_FACE_RECOGNIZE_FAIL,                      //����ʶ��ʧ��
    EVENT_ACS_EMPLOYEENO_AND_PW_PASS,                   //���ż�������֤ͨ��
    EVENT_ACS_EMPLOYEENO_AND_PW_FAIL,                   //���ż�������֤ʧ��
    EVENT_ACS_EMPLOYEENO_AND_PW_TIMEOUT,                //���ż�������֤��ʱ
    EVENT_ACS_HUMAN_DETECT_FAIL,                        //���˼��ʧ��
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_PASS,          //��֤�ȶ�ͨ��
    EVENT_ACS_PEOPLE_AND_ID_CARD_COMPARE_FAIL,          //��֤�ȶ�ʧ��
    EVENT_ACS_DOOR_OPEN_OR_DORMANT_FAIL,                //��״̬���ջ�����״̬��֤ʧ��
    EVENT_ACS_AUTH_PLAN_DORMANT_FAIL,                   //��֤�ƻ�����ģʽ��֤ʧ��
    EVENT_ACS_CARD_ENCRYPT_VERIFY_FAIL,                 //������У��ʧ��
    EVENT_ACS_SUBMARINEBACK_REPLY_FAIL,                 //��Ǳ�ط�����Ӧ��ʧ��
    EVENT_ACS_PASSWORD_MISMATCH,                        //���벻ƥ��
    EVENT_ACS_EMPLOYEE_NO_NOT_EXIST,                    //���Ų�����
    EVENT_ACS_COMBINED_VERIFY_PASS,                     //�����֤ͨ��
    EVENT_ACS_COMBINED_VERIFY_TIMEOUT,                  //�����֤��ʱ
    EVENT_ACS_VERIFY_MODE_MISMATCH,                     //��֤��ʽ��ƥ��
    EVENT_ACS_PSW_ERROR_OVER_TIMES,                     //������֤����  67
    EVENT_ACS_PSW_VERIFY_PASS,                          //������֤ͨ��
    EVENT_ACS_PSW_VERIFY_FAIL,                          //������֤ʧ��
    EVENT_ACS_ORCODE_VERIFY_PASS,                       //��ά����֤ͨ��
    EVENT_ACS_ORCODE_VERIFY_FAIL,                       //��ά����֤ʧ��
    EVENT_ACS_HOUSEHOLDER_AUTHORIZE_PASS,               //������Ȩ��֤ͨ��
    EVENT_ACS_BLUETOOTH_VERIFY_PASS,                    //������֤ͨ��
    EVENT_ACS_BLUETOOTH_VERIFY_FAIL,                    //������֤ʧ�� 74
    EVENT_ACS_INFORMAL_MIFARE_CARD_VERIFY_FAIL,         //������Mifare����֤ʧ��
    EVENT_ACS_CPU_CARD_ENCRYPT_VERIFY_FAIL,             //CPU������У��ʧ��
    EVENT_ACS_NFC_DISABLE_VERIFY_FAIL,                  //NFC���ܹر���֤ʧ��
    EVENT_ACS_EM_CARD_RECOGNIZE_NOT_ENABLED,            //EM��ʶ��δ����
    EVENT_ACS_M1_CARD_RECOGNIZE_NOT_ENABLED,            //M1��ʶ��δ����
    EVENT_ACS_CPU_CARD_RECOGNIZE_NOT_ENABLED,           //CPU��ʶ��δ����
    EVENT_ACS_ID_CARD_RECOGNIZE_NOT_ENABLED,            //���֤ʶ��δ����
    EVENT_ACS_CARD_SET_SECRET_KEY_FAIL                  //����װ��Կʧ��
}ACS_CARD_READER_SUBEVENT_ENUM;

typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //�¼������ͣ�0-�豸�¼���1-���������¼���2-���¼���3-�������¼�
    WORD          wSubEventType;                      //�¼�������
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;

typedef  union tagNET_DVR_EVETN_CARD_LINKAGE_UNION
{
    BYTE                           byCardNo[ACS_CARD_NO_LEN];          //����
    NET_DVR_EVENT_LINKAGE_INFO  struEventLinkage;                   //�¼�����ʱ����
    BYTE                           byMACAddr[MACADDR_LEN];          //����MAC��ַ
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //���ţ���ԱID��
}NET_DVR_EVETN_CARD_LINKAGE_UNION,*LPNET_DVR_EVETN_CARD_LINKAGE_UNION;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD            dwSize;    //�ṹ���С
    BYTE              byProMode;                          //������ʽ��0-�¼���1-����   
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //�¼�ԴID����������Ϊ�豸�¼�ʱ��Ч�� �������������¼�ʱΪ�ű��;��������Ϊ�������¼�ʱ��Ϊ������ID;��Ϊ���������¼�ʱΪ������������ID���¼���������ID
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //������ʽ����
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //�����ı�������ţ��������ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byRes2[32];                         //����
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //�������ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //�������ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //�������ʾ,�Ƿ�����������0-��������1-����
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //�������ʾ,�Ƿ��������أ�0-��������1-����
    BYTE           byMainDevBuzzer;                    //����������   0-��������1-�������
    BYTE           byCapturePic;                           //�Ƿ�����ץ�ģ�0-������ץ�ģ�1-����ץ��
    BYTE           byRecordVideo;                          //�Ƿ�����¼��0-������¼��1-����¼��
    BYTE           byRes3[29];                         //����
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //�������������������������ʾ��0-��������1-����
    BYTE           byRes[128];                           //����
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V50
{
    DWORD            dwSize;    //�ṹ���С
    BYTE              byProMode;                          //������ʽ��0-�¼���1-����, 2-MAC��ַ   
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //�¼�ԴID����������Ϊ�豸�¼�ʱ��Ч�� �������������¼�ʱΪ�ű��;��������Ϊ�������¼�ʱ��Ϊ������ID;��Ϊ���������¼�ʱΪ������������ID���¼���������ID��0xffffffff��ʾ����ȫ��
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //������ʽ����
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //�����ı�������ţ���λ��ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byRes2[32];                         //����
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //��λ��ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //��λ��ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //��λ��ʾ,�Ƿ�����������0-��������1-����
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //��λ��ʾ,�Ƿ��������أ�0-��������1-����
    BYTE           byMainDevBuzzer;                    //����������   0-��������1-�������
    BYTE           byCapturePic;                           //�Ƿ�����ץ�ģ�0-������ץ�ģ�1-����ץ��
    BYTE           byRecordVideo;                          //�Ƿ�����¼��0-������¼��1-����¼��
    BYTE           byRes3[29];                         //����
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //��������������������λ��ʾ��0-��������1-����
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //������������رգ����ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //�����������������ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //�����������������ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byRes[500];                           //����
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V50, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V51
{
    DWORD          dwSize;    //�ṹ���С
    BYTE           byProMode;                          //������ʽ��0-�¼���1-���ţ�2-MAC��ַ��3-���ţ���ԱID��
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //�¼�ԴID����������Ϊ�豸�¼�ʱ��Ч�� �������������¼�ʱΪ�ű��;��������Ϊ�������¼�ʱ��Ϊ������ID;��Ϊ���������¼�ʱΪ������������ID���¼���������ID��0xffffffff��ʾ����ȫ��
    NET_DVR_EVETN_CARD_LINKAGE_UNION    uLinkageInfo;  //������ʽ����
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //�����ı�������ţ���λ��ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byRes2[32];                         //����
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //��λ��ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //��λ��ʾ,�Ƿ��������ţ�0-��������1-����
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //��λ��ʾ,�Ƿ�����������0-��������1-����
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //��λ��ʾ,�Ƿ��������أ�0-��������1-����
    BYTE           byMainDevBuzzer;                    //����������   0-��������1-�������
    BYTE           byCapturePic;                           //�Ƿ�����ץ�ģ�0-������ץ�ģ�1-����ץ��
    BYTE           byRecordVideo;                          //�Ƿ�����¼��0-������¼��1-����¼��
    BYTE           byMainDevStopBuzzer;               //����ֹͣ����   0-��������1-�������
    WORD           wAudioDisplayID;                    //������������ID��0-��������Ŀǰ��Χ1-32
    BYTE           byAudioDisplayMode;                 //������������ģʽ��0-�رգ�1-���β��ţ�2-ѭ������
    BYTE           byRes3[25];                         //����
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //��������������������λ��ʾ��0-��������1-����
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //������������رգ����ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //�����������������ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //�����������������ֽڱ�ʾ��Ϊ0��ʾ��������Ϊ1��ʾ����
    BYTE           byReaderStopBuzzer[MAX_CARD_READER_NUM_512]; //����������ֹͣ���������ֽڱ�ʾ��0-��������1-����
    BYTE           byRes[512];                   //����
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V51, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V51;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_COND
{
    DWORD dwSize;
    DWORD dwEventID; //�¼�ID
    WORD wLocalControllerID; //�͵ؿ��������[1,64]
    BYTE byRes[106];
}NET_DVR_EVENT_CARD_LINKAGE_COND, *LPNET_DVR_EVENT_CARD_LINKAGE_COND;

typedef struct tagNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;     //�ļ���С����λ���ֽڣ��ϴ���Ƶ�ļ�ʱ��Ч��������Ƶ�ļ�ʱ��Ч��
    DWORD dwAudioID;      //��ƵID��0xffffffff�����ϴ�/����ȫ����Ƶ�ļ���Ŀǰ�豸��֧��ȫ���ϴ�/���أ���֧�ֵ�����ƵID�ϴ�/���أ�
    BYTE  byRes[256];
}NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM, *LPNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM;

//�ͻ��궨�ļ��ṹ��
typedef struct tagNET_DVR_CLIENT_CALIBFILE_PARAM
{
    DWORD dwSize;
    DWORD dwFileLen;   //�ļ���С
    BYTE byChannel;     //ͨ����
    BYTE byRes[23];
}NET_DVR_CLIENT_CALIBFILE_PARAM, *LPNET_DVR_CLIENT_CALIBFILE_PARAM;

//3200W������ṹ��
typedef struct tagNET_DVR_CORRECT_TABLE_3200W_PARAM
{
    DWORD dwSize;
    DWORD dwFileLen;   //�ļ���С
    BYTE byChannel;     //ͨ����
    BYTE byRes[23];
}NET_DVR_CORRECT_TABLE_3200W_PARAM, *LPNET_DVR_CORRECT_TABLE_3200W_PARAM;

//��ͨ��ץͼ�ļ��ṹ��
typedef struct tagNET_DVR_FOUR_CAMERAS_PICTURES
{
    DWORD dwSize;
    DWORD dwFileLen;   //�ļ���С
    BYTE byChannel;     //ͨ����
    BYTE byRes[23];
}NET_DVR_FOUR_CAMERAS_PICTURES, *LPNET_DVR_FOUR_CAMERAS_PICTURES;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;     //����IP��ַ
    BYTE   byIsStartAddr; //�Ƿ�Ϊ��ʼ��ַ��0-��1-��
    BYTE   byHostNo;      //������ţ�1-8����Ҫ���ڶ�����˳������
    BYTE   byRes[34];     //����
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;   //��Ǳ���������
    BYTE  byRes[5];           //����
    WORD wFollowUpCardReader; //�÷�Ǳ�������µĶ��������
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //����������ַ��Ϣ
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //��ʼ��������� ��������ȫΪ0ʱ����ʾ����ע���ĸ���������ʼ
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE         byEnable;             //�Ƿ���뷴Ǳ��·����1-���룬0-������
    BYTE          byAntiSnealHostNo;   //��Ǳ���������
    WORD         wReaderID;              //������ID
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //�����������������
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD           dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];  //��������Ϣ
    BYTE            byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD           dwSize;            //�ṹ���С
    BYTE            byRS485Backup;  //�Ƿ���������RS485ͨ�ű��ݹ��ܣ�0-�����ã�1-����
    BYTE            byShowCapPic;    //�Ƿ���ʾץ��ͼƬ�� 0-����ʾ��1-��ʾ
    BYTE            byShowCardNo;    //�Ƿ���ʾ���ţ�0-����ʾ��1-��ʾ
    BYTE            byShowUserInfo;  //�Ƿ���ʾ�û���Ϣ��0-����ʾ��1-��ʾ
    BYTE            byOverlayUserInfo;//�Ƿ�����û���Ϣ��0-�����ӣ�1-����
    BYTE            byVoicePrompt;  //�Ƿ�����������ʾ��0-�����ã�1-����
    BYTE             byUploadCapPic;     //����ץ���Ƿ��ϴ�ͼƬ��0-���ϴ���1-�ϴ�
    BYTE             bySaveCapPic;    //�Ƿ񱣴�ץ��ͼƬ��0-�����棬1-����
    BYTE            byInputCardNo;  //�Ƿ��Ƿ����������뿨�ţ�0-������1-����
    BYTE            byEnableWifiDetect;  //�Ƿ�����wifi̽�룬0-��������1-����
    BYTE            byEnable3G4G;  //3G4Gʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE            byProtocol;//������ͨ��Э�����ͣ�0-˽��Э�飨Ĭ�ϣ���1-OSDPЭ��
    BYTE byRes[500];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_PLATFORM_VERIFY_CFG
{
    DWORD       dwSize;
    DWORD        dwDoorNo; //�ű��
    BYTE        byResultType; //��֤������ͣ�0���Ƿ���1���Ϸ�
    BYTE        byRes1[3];
    BYTE        byScreenDisplay[MAX_SCREEN_DISPLAY_LEN]; //LED��Ļ��ʾ��������ʾ��֤�����Ϣ
    BYTE        byRes[300];                  // �����ֽ�
}NET_DVR_PLATFORM_VERIFY_CFG, *LPNET_DVR_PLATFORM_VERIFY_CFG;

typedef struct tagNET_DVR_PERSON_STATISTICS_CFG
{
    DWORD dwSize;
    BYTE byEnableStatistics;  //�Ƿ�������ͳ�ƣ�0����������1��������
    BYTE byEnableOfflineStatistics;  //�Ƿ�����������ͳ�ƣ�0����������1��������
    BYTE byCountSignalStatisticalStandard;  //�����ź�ͳ�Ʊ�׼��0����Ч��1��������ͨ��ͳ�ƣ�2����֤����ͳ��
    BYTE byRes[605];
}NET_DVR_PERSON_STATISTICS_CFG, *LPNET_DVR_PERSON_STATISTICS_CFG;

typedef struct tagNET_DVR_ACS_SCREEN_DISPLAY_CFG
{
    DWORD dwSize;
    DWORD dwFontSize;  //�����С��[1,10]��
    DWORD dwRowSpacing;  //�м�࣬��λ�����ص㣻
    DWORD dwColumnSpacing;  //�м�࣬��λ�����ص㣻
    DWORD dwFirstRowPosition;  //��ʼ��λ������Ļ��һ���ֿ飬0��0�� 1��1/8:�� 2��2/8�� 3��3/8�� 4��4/8�� 5��5/8�� 6��6/8:�� 7��7/8��
    BYTE byDegree;  //�ַ���ʾ����Ƕȣ�0-0�ȣ���������1-90�ȣ����ţ���
    BYTE byScreenType;  //��Ļ���ͣ�0-DC48270RS043_01T��1-DC80480B070_03T��
    BYTE byRes[306];
}NET_DVR_ACS_SCREEN_DISPLAY_CFG, *LPNET_DVR_ACS_SCREEN_DISPLAY_CFG;

typedef struct tagNET_DVR_GATE_TIME_CFG
{
    DWORD dwSize;
    DWORD dwHoldOnALarmTime;  //��������������ʱ�䣬��λms
    DWORD dwHoldOnGateOpenTime;  //բ���յ��ر�����ǰ�������ִ�״̬ʱ�䣬��λms
    DWORD dwPostponeIntrusionAlarmTime;  //�Ƴٴ���������ƭ��Ϊ����ʱ�䣬��λms
    DWORD dwNoLaneAccessTimeLimitTime;  //ͨ���յ���Чͨ����֤�źţ�������ͨ�г�ʱ����ʱ�䣬��λs
    DWORD dwSafetyZoneStayTime;  //ͨ���յ���Чͨ����֤�źţ��˿͵��ﰲȫ��������ͨ����ʱ����ʱ�䣬��λs
    BYTE byIRTriggerTimeoutTime;  //���ⴥ����ʱʱ�䣬��λ���루0-255��
    BYTE byRes[299];
}NET_DVR_GATE_TIME_CFG, *LPNET_DVR_GATE_TIME_CFG;


typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //������
    DWORD dwErrorCode; //��ȡ�����뿪��ʹ�����÷��صĴ����룬�ɹ�Ϊ0��ʧ�ܷ��ش�����
    BYTE byCardValid; //���Ƿ���Ч��0-��Ч��1-��Ч������ɾ����������ʱ��Ϊ0����ɾ������ȡʱ���ֶ�ʼ��Ϊ1��
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    DWORD dwErrorCode; //���Ϳ����뿪��ʹ�����÷��صĴ����룬�ɹ�Ϊ0��ʧ�ܷ��ش����� 
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    //������ˮ�� �ͣ��ϴ�����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�sDataIndex��Ӧ��
    char   sDataIndex[DATA_INDEX_LEN];
    //������� �� (�ϴ�����NET_DVR_VEHICLE_RECOG_RESULT�е��ֶ�dwTaskNo��Ӧ)
    WORD  wTaskNo;
    BYTE  byRes1[2];
    NET_VCA_RECT  struPlateRect;//����λ��
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    /*
    ����ͼƬ����ʶ�����
    bit0-����ʶ��0-������ʶ��1-����ʶ�� 
    bit1-��������ʶ��0-������ʶ��1-����ʶ��
    bit2-������ɫʶ��0-������ʶ��1-����ʶ��
    bit3-����Ʒ��ʶ��0-������ʶ��1-����ʶ��
    bit4-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit5-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit6-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit7-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit8-����ͼƬ����ʹ�ܣ�0-������ʶ��1-����ʶ��
    bit9-�ϴ�����ͼƬʹ��(ͨ��SDK)��0-������ʶ��1-����ʶ��
    bit10-�ϴ�����ͼƬʹ��(ͨ��URL)��0-������ʶ��1-����ʶ��
    bit11-�Ʊ공��0-������ʶ��1-����ʶ��
    bit12-���ֻ���0-������ʶ��1-����ʶ��
    bit13-�Ҽ���0-������ʶ��1-����ʶ��
    bit14-Σ��Ʒ��: 0-������ʶ��1-����ʶ��
    bit15-�����촰վ�˼��: 0-������ʶ��1-����ʶ��
    */
    DWORD  dwRecogOperate;
    /*
    ����ͼƬ�����ϴ�
    bit0-����ͼƬ��0-���ϴ���1-�ϴ��� 
    bit1-����ͼƬ��0-���ϴ���1-�ϴ���
    bit2-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit3-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit4-��ȫ����ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit5-��ȫ����ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    */
    DWORD  dwDataUploadType;
    DWORD  dwPostID;//����ID��
    NET_DVR_TIME_V30 struPostTime;//����ʱ��
    DWORD  dwJsonLen; //Json͸�����ݳ���
    BYTE	*pJsonBuffer;//Json����ָ��,�ο�4.2.4Json���ݸ�ʽ
    BYTE   byRes[107];
    BYTE   byPicDataType;//ͼƬ�������ͣ�0-ͼƬ���ݣ�1-URL
    //ͼƬ����
    //��byPicDataType == 0��ʱ�򣬸��ֶ��ڵ�������Ч��ͼƬ�����ڽṹ�����
    //��byPicDataType == 1��ʱ����ָ����ͼƬ��URL��Ϣ
    char  sPicDataPath[256];
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;

typedef struct tagNET_DVR_VEHICLERECOG_TASK_RESULT
{
    DWORD  dwSize;
    //�豸������ˮ��,ÿ���ύ�����豸����������Ψһ����ˮ�ŷ��ظ��ϲ㡣
    char     sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[256];
}NET_DVR_VEHICLERECOG_TASK_RESULT, *LPNET_DVR_VEHICLERECOG_TASK_RESULT;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    char   sDataIndex[DATA_INDEX_LEN];//������ˮ��    ȫ0��ʱ���ʾ��ȡȫ�� 
    WORD  wTaskNo;//�������         ֵΪ0��ʱ���ʾȫ������
                  /*
                  ����״̬
                  bit0-���״̬������0-����ѯ��1-��ѯ��
                  bit1-ִ���е�����0-����ѯ��1-��ѯ��
                  bit2-�ȴ��е�����0-����ѯ��1-��ѯ��
    */
    BYTE   byTask;
    BYTE   byRes1;
    //�豸������ˮ�Ų�ѯ,ÿ���ύ�����豸����������Ψһ����ˮ�š�
    char   sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[60];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

//�����ṹ
typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    char   sDataIndex[DATA_INDEX_LEN];//������ˮ��
    WORD  wTaskNo;//�������
    WORD  wTaskProgress;//����ִ�н��ȣ�ʵ�ʽ���*1000��
    BYTE   byTaskState;//����״̬��0-�ȴ��У�1-ִ���У�2-���
    BYTE   byRes1[3];
    /*
    ����ͼƬ����ʶ�����
    bit0-����ʶ��0-������ʶ��1-����ʶ�� 
    bit1-��������ʶ��0-������ʶ��1-����ʶ��
    bit2-������ɫʶ��0-������ʶ��1-����ʶ��
    bit3-����Ʒ��ʶ��0-������ʶ��1-����ʶ��
    bit4-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit5-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit6-�ڵ���ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit7-��ȫ��ʶ��(����ʻ)��0-������ʶ��1-����ʶ��
    bit8-����ͼƬ����ʹ�ܣ�0-������ʶ��1-����ʶ��
    bit9-�ϴ�����ͼƬʹ��(ͨ��SDK)��0-������ʶ��1-����ʶ��
    bit10-�ϴ�����ͼƬʹ��(ͨ��URL)��0-������ʶ��1-����ʶ��
    bit11-�Ʊ공��0-������ʶ��1-����ʶ��
    bit12-���ֻ���0-������ʶ��1-����ʶ��
    bit13-�Ҽ���0-������ʶ��1-����ʶ��
    bit14-Σ��Ʒ��: 0-������ʶ��1-����ʶ��
    bit15-�����촰վ�˼��: 0-������ʶ��1-����ʶ��
    */
    DWORD  dwRecogOperate;
    DWORD  dwPostID;//����ID��
    NET_DVR_TIME_V30 struPostTime;//����ʱ��
    DWORD  dwJsonLen; //Json͸�����ݳ��ȣ�Ԥ����JSON�����ݲ�ʵ�֣�
    BYTE   *pJsonBuffer;//Json����ָ��, ��Ԥ����JSON�����ݲ�ʵ�֣�
    BYTE   byRes[104];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;

typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //�ṹ
    //������ˮ�� �ͣ������ύNET_DVR_VEHICLE_RECOG_CFG�е��ֶ�sDataIndex��Ӧ��
    char   sDataIndex[DATA_INDEX_LEN];
    //������� �� (�����ύNET_DVR_VEHICLE_RECOG_CFG�е��ֶ�wTaskNo��Ӧ)
    WORD  wTaskNo; 
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;//����λ��
    char  sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    BYTE  byVehicleType;    //�������ͣ��ο�VTR_RESULT
    BYTE  byColorDepth;     //������ɫ��ǳ���ο� 0-��ɫ��1-ǳɫ
    BYTE  byColor;         //������ɫ,  �ο�VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //������Ʒ��
    BYTE  byVehicleSubLogoRecog; //������Ʒ��
    BYTE  byPilotSafebelt;//0-��ʾδ֪,1-��ϵ��ȫ��,2-ϵ��ȫ��
    BYTE  byCopilotSafebelt;//0-��ʾδ֪,1-��ϵ��ȫ��,2-ϵ��ȫ��
    BYTE  byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE  byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE  byVehicleModel;// �ο��ĵ�  ������Ʒ�����
    WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" 
    BYTE  byRes1[251];
    // 0-����ֱ���ϴ�; 1-�ƴ洢������URLԭ�ȵ�ͼƬ���ݱ��URL���ݣ�ͼƬ���ȱ��URL����
    BYTE  byDataType;
    /*
    �ϴ�ͼƬ������Ϣ:
    bit0-����ͼ��0-���ϴ���1-�ϴ��� 
    bit1-����ͼ��0-���ϴ���1-�ϴ���
    bit2-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit3-������ͼ(����ʻ)��0-���ϴ���1-�ϴ���
    bit4-��ȫ��ʶ��(����ʻ)��0-���ϴ���1-�ϴ���
    bit5-��ȫ��ʶ��(����ʻ)��0-���ϴ���1-�ϴ���
    */
    DWORD  dwPicType; //0:��ͼƬ��Ϣ;: ����ͼ;:����ͼ;
    BYTE    *pVehicleBuffer;    //����ͼƬ����ָ��
    DWORD  dwVehicleBufferLen ;// ����ͼƬ���ݳ���
    BYTE    *pPlateBuffer;    //����ͼƬ����ָ��
    DWORD  dwPlateBufferLen ;// ����ͼƬ���ݳ���
    BYTE    *pPilotFaceBuffer;    //������ͼ(����ʻ)ͼƬ����ָ��
    DWORD  dwPilotFaceBufferLen ;// ������ͼ(����ʻ)ͼƬ���ݳ���
    BYTE    *pCopilotFaceBuffer;    //������ͼ(����ʻ)ͼƬ����ָ��
    DWORD  dwCopilotFaceBufferLen ;// ������ͼ(����ʻ)ͼƬ���ݳ���
    BYTE    *pPilotSafebeltBuffer;    //��ȫ��ʶ��(����ʻ)ͼƬ����ָ��
    DWORD  dwPilotSafebeltBufferLen ;// ��ȫ��ʶ��(����ʻ)ͼƬ���ݳ���
    BYTE    *pCopilotSafebeltBuffer;// ��ȫ��ʶ��(����ʻ)ͼƬ����ָ��
    DWORD  dwCopilotSafebeltBufferLen ;// ��ȫ��ʶ��(����ʻ)ͼƬ���ݳ���
    NET_VCA_RECT  struVehicleRect ;//�����������
    NET_VCA_RECT  struPilotRect ;//����ʻ��������
    NET_VCA_RECT  struCopilotRect ;//����ʻ��������
    BYTE    *pJsonBuffer;//Json����ָ��,�ο�JSON���ݸ�ʽ
    DWORD   dwJsonBufferLen;// Json���ݳ���
    DWORD   dwPostID;//����ID
    NET_DVR_TIME_V30 struPostTime;//����ʱ��
    BYTE    Res2[56];
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

#define MAX_ZONE_LINKAGE_CHAN_NUM    4    /* �����������ͨ����*/

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD                    dwSize;
    BYTE    byAddressType;    //0 - ipv4/ipv6��ַ��1 - ����
    BYTE    byRes1;
    WORD    wServerPort;                //�������˿�
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                    //����������
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                    //IP��ַ
    }unionServer;//ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ��������
    WORD                    wInterval;    //�������ʱ��,0-30s
    BYTE                    byRes3[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE    byDDNSType;        //�������������ͣ�0 - ��Ч��1 - IPServer(˽��DNS)��2 - hiDDNS
    BYTE    byRes1;
    WORD    wDDNSPort;                        //�����������˿ں�
    BYTE    byServerAddr[MAX_DOMAIN_NAME];    //������������ַ
    BYTE    byDevName[MAX_DOMAIN_NAME];            //�豸����
    BYTE    byDevSerialNum[SERIALNO_LEN];    //�豸���к�
    BYTE    byAddressType;    //0 - ipv4/ipv6��ַ��1 - ����
    BYTE    byRes2;
    WORD    wDevPort;        //�豸�˿ں�    
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                                    //����
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                                    //IP��ַ
    }unionDevAddr;//ʹ��������ṹ��ͨ��byAddressType�ֶα�ʾ��IP��ַ��������
    BYTE    sUserName[NAME_LEN/*32*/];    //�û���
    BYTE    sPassword[PASSWD_LEN/*16*/];//����
    DWORD    dwChannel;                    //����ͨ����
    BYTE    byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD    dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];    // ÿ���������Թ����ĸ���Ƶͨ��
    BYTE    byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG
{
    BYTE    byDevSerialNo[SERIALNO_LEN];    //�豸���к�
    DWORD    dwChannel;                        //����ͨ����
    BYTE    byRes[64];
}NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG, *LPNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG
{
    WORD    wZoneNo;
    BYTE    byRes1[2];
    NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG struSingleChanCfg[MAX_ZONE_LINKAGE_CHAN_NUM];
    BYTE    byRes2[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST_
{
    DWORD    dwSize;
    NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG struAssociatedChanCfg[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;    //��Ļ������
    BYTE byOnOffLine;    //��Ļ�Ƿ����ߣ�0-���ߣ�1-���ߣ�����Ļ����ʱ�����ṹ����������Ч
    BYTE byTempState;    //�忨�¶�״̬��0-������1-�쳣
    BYTE byFanState;        //����״̬��0-�أ�1-��
    BYTE byFanException;    //�����쳣״̬��0-��֧�� 1-������2-�쳣
    BYTE byTemperature;    //��Ļ�忨�¶ȣ���λ�����϶�
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

//�������ϴ���Ϣ
typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD   dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //����������
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //������ͨ��
    BYTE    byReboot; //֮ǰ�Ƿ���������һ���������ĺ�ĵ�һ�����ݴ��������־��0-��ʾû��������1-�й�����
    BYTE    byPowerSupply;//�Ƿ��������� 0-���ڹ��磬1-���ڹ���
    BYTE    byStatusType;//�豸״̬:0:������1���쳣��2������
    BYTE    bySensorType;//�ο�������ö������SENSOR_TYPE
    float      fVoltageValue;//��ѹֵ�� ��ȷ��0.001
    float    fCurrentValue;//����ֵ����ȷ��0.001
    float   fActualValue;//ģ���ź�ת�������ֵ����ȷ��0.001
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //������Ϣ;���豸״̬��byStatusType��Ϊ��0ʱ��Ч��
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

//ץ��ͼƬ�ϴ�
typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize; 
    NET_DVR_TIME_V30  struTime;
    DWORD    dwChannel;//ͨ����
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//ͼƬ����
    BYTE    *pBuffer;    //ͼƬ����ָ��
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;

//ȫ��������λ�ϴ�
typedef struct tagNET_DVR_PANORAMIC_LINKAGE
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    BYTE  byType;//ͼƬ���ͣ�0-�����壬1-ȫ��������λͼƬ
    BYTE  byRes1[3];
    BYTE        byMACAddr[MACADDR_LEN];             //mac��ַ
    BYTE      byRes2[2];
    NET_DVR_IPADDR   struDevIP;                     //�豸IP��ַ
    DWORD    dwPicLen;//ȫ��������λץ��ͼƬ����
    char      *pPicBuff; //ȫ��������λץ��ͼƬָ��
    BYTE       byRes[128];
}NET_DVR_PANORAMIC_LINKAGE, *LPNET_DVR_PANORAMIC_LINKAGE;

#define MAX_MASK_AREA_NUM                   8   //�������������

typedef struct tagNET_DVR_AREA_MASK_CFG  //����������
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byEnable;//�Ƿ�����������   0-��1-��
    BYTE   byMaskThick;  //�����˺�� 0-���룬1-���룬2-���룬����������СΪ8*8������16*16������32*32��Ĭ��Ϊ����
    BYTE   byAutoMask;//�Ƿ������Զ�������   0-��1-��
    BYTE   byRes1;
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM];//����������Χ
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG  //��Ƶ����
{
    DWORD  dwSize;  //�ṹ���С
    BYTE   byEnable;  //�Ƿ����ñ��� 0-�����ã�1-����
    char    byBassValue;   //�ߵ���ֵ����ΧΪ-12-12 ֵԽ������Խϸ����֮ԽС��0-��ʾ������
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_RESOLUTION_SWITCH
{
    DWORD            dwSize;
    BYTE             byResolutionType;//0-all,1-20:9,2-20:6,3-ԭʼ����ģʽ
    BYTE             byRes[127];
}NET_DVR_RESOLUTION_SWITCH, *LPNET_DVR_RESOLUTION_SWITCH;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //wifiģʽ��DHCP��Χ����
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;   //��ʼIP��ַ
    NET_DVR_IPADDR   struEndAddr;     //����IP��ַ
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;


typedef struct tagNET_DVR_WIFI_CLIENT_INFO  //��Ƶ����
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;  //IP��ַ
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //�����ٶ� ��λKB
    BYTE        byRSSIValue;         //���յ����ź�ǿ�ȣ�ȡֵΪ��ֵ������ʱ������ֵ����ΧΪ0~-110dbm,ֵԽ�󣬴����ź�Խǿ
    BYTE        byRes1;         //����
    WORD        wBandwidth;     //�������  ��λKB 
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG  //����������ͨ��
{
    DWORD       dwSize;              //�ṹ���С
    DWORD       dwChannel;           //�����ı���ͨ����
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;

typedef struct  
{
    BYTE byPort;   //�˿�
    BYTE byMasterSlaveProperty;   //�˿���������  1-��  2-��
    BYTE byPortEthernetType;  //�˿����ͣ�1-���׶˿ڣ�2-ǧ�׶˿�
    BYTE byRes[9]; 
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;
typedef struct  
{
    DWORD   dwSize; 
    BYTE     byEnable;     //�Ƿ����ã� 0-�����ã� !0-����
    BYTE     byProtoType;  //Э�����ͣ� 1-��˻�����Э��(˽��)��2-�ۺ�ƽ̨����Э�飨˽�У���3-G8032Э�飨���У�
    BYTE   byBandWidth;   //�����������ͣ�1-���ף�2-ǧ��
    BYTE     byRes1;        //�����ֶ�
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //�����˿�
    BYTE      byRes2[60];    //�����ֶ�
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;
typedef struct  //
{
    DWORD   dwSize;   //�ṹ���С
    BYTE     byStatus;              //����״̬��1-���� 2-�Ͽ�
    BYTE     byMasterSlaveProperty ; //���˰��������� 1-��  2-��
    BYTE     byRes[62];            //�����ֶ�
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

//����ⱨ��
typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize; //�ṹ��С
    DWORD     dwRelativeTime; //���ʱ��
    DWORD    dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE    byRes1;
    DWORD   dwPicDataLen;//����ץ��ͼƬ����
    BYTE    *pBuffer;    //����ָ��
    NET_VCA_RECT struRect;//���� 
    NET_VCA_POINT struPoint ;//����������¶ȵ�����
    WORD    wFireMaxTemperature ;//�������¶�[300��~4000��]
    WORD    wTargetDistance ;//Ŀ�����[100m ~ 10000m]
    BYTE    byStrategyType;//�������ͣ�0~���ⱨ����1~Эͬ������2~��ϵͳ������3~ָ����㱨����4~ָ��������
    BYTE    byAlarmSubType;//���������͡�0~����ⱨ����1~�����ⱨ����2~�̻𱨾�
    /*�Ƿ�����PTZ������չ��
    0~�����ã�PTZ����ֵ��wPanPos��wTiltPos��wZoomPosΪ׼��
    1~���ã�PTZ����ֵ��struPtzPosExΪ׼����������PTZ���践�ء�struPtzPosEx��ֵ��ת��ΪwPanPos��wTiltPos��wZoomPosֵ��
    */
    BYTE    byPTZPosExEnable;
    BYTE    byRes2;
    NET_PTZ_INFO struPtzPosEx;// ptz������չ(֧�ָ߾���PTZֵ����ȷ��С�������λ)
    DWORD   dwVisiblePicLen;//�ɼ���ͼƬ����
    BYTE    *pVisiblePicBuf;    //�ɼ���ͼƬ����ָ��
    // pSmokeBuf������byAlarmSubType����������Ϊ1�������ⱨ������2���̻𱨾���ʱ��Ч��
    BYTE    *pSmokeBuf;    //�����ⱨ������ָ�룬ָ��һ��NET_DVR_SMOKEDETECTION_ALARM�ṹ��
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE    byRes3;
    BYTE    byFireScanWaitMode; //���ɨ��ȴ�ģʽ 0-�Զ�   1-�ֶ�
    DWORD   dwVisibleChannel; //�ɼ���ͨ��ͨ����
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    byRes[49];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

//���������
typedef struct tagNET_DVR_SMOKEDETECTION_CFG
{
    BYTE    byEnable;//ʹ��
    BYTE    bySensitivity; //���������: 1~100Ĭ��50
    BYTE    byPatrolSensitivity; //Ѳ�����������: 1~100Ĭ��50
    BYTE    byDoubleCheckSensitivity; //���ι���������: 1~100Ĭ��50
    BYTE    byRes[56];
}NET_DVR_SMOKEDETECTION_CFG, *LPNET_DVR_SMOKEDETECTION_CFG;

typedef    struct tagNET_DVR_ALARMSTRATEGY_PARAM
{
    BYTE   byStrategyType;//�������ͣ�0~���ⱨ����1~Эͬ������2~��ϵͳ����, 3~ָ����㱨����4~ָ��������
    BYTE   byRes[15];
}NET_DVR_ALARMSTRATEGY_PARAM, *LPNET_DVR_ALARMSTRATEGY_PARAM;

typedef    struct tagNET_DVR_FIREDETECTION_CFG
{
    DWORD    dwSize;//�ṹ���С
    BYTE    byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE    bySensitivity; //���������: 1~100Ĭ��5s
    BYTE    byFireComfirmTime;//���ֻ��ȴ�ʱ��: 0-120�� Ĭ��5s
    BYTE    byFireRegionOverlay;//�������ӻ���: 0- ��1- ��
    BYTE    byDetectionMode;// �����ģʽ��0~�����б�1~��֡��⡣
    BYTE    byFireFocusMode;//���۽�ģʽ��0~�Զ�ģʽ,1~ Ѳ��ģʽ��
    BYTE    byFireZoomMode;//����ѧ�䱶ģʽ��0~Ϊ�Զ�ģʽ��1~Ϊ�ֶ�ģʽ��
    BYTE    byFirezoomLevel;//����ѧ�䱶���ʣ�1~100������ѧ�䱶ģʽΪ�ֶ�ģʽʱ��Ч
    BYTE    bySmokeFireEnabled; //�̻�����ʹ�ܣ�0�������ã�1-����
    /*
    ����ֶ��ȴ�ʹ�ܣ�Ϊ1ʱ�������������󣬻��ȴ�ʱ�����byFireComfirmTime��Ч��
    �����󣬵��豸���ֻ��ʱ����̨һֱͣ���ڷ��ֻ��λ�ã���ͨ���������ɨ���������õȴ�ģʽ���������ɨ�衣
    ������ֶ��ȴ�ʹ��Ϊ0ʱ���豸Ϊ�Զ��ȴ�ģʽ����ģʽ�¿ɸ���byFireComfirmTime�ֶ������õĵȴ�ʱ����л��ȴ��������õȴ�ʱ����豸�Զ����л��ɨ�衣
    */
    BYTE    byFireManualWaitEnabled;// ����ֶ��ȴ�ʹ�ܣ�0~Ϊ�Զ��ȴ�ģʽ��1~�ֶ��ȴ�ģʽ
    BYTE    byCancelRepeatedAlarmEnabled;// ȡ���ظ�����ʹ�� 0-�ر� 1-����
    BYTE    byApplicationSceneMode;//Ӧ�ó���ģʽ��0-������1-ɭ�ַ���, 2-�ո�ȼ��,3-�����Ƹߵ�, 4-���ڻ��ܽ�
    DWORD   dwInstallationHeight;// ��װ�߶�
    BYTE    byFireSourceDetection;// �������ģʽ 0-��̬��� 1-����ģʽ
	BYTE    bySmokeAuxiliaryDetectionEnabled;// �������ж�����ʹ��,���ģʽ�Ƕ����б�ʱ��Ч 0-�� 1-��
    BYTE    byverificationSensitivity;  //����ȷ�������ȣ���Χ1~100s��Ĭ��50s
    BYTE	byFireAlgorithmMode; //����㷨ģʽ��0����Ч��1��ģʽʶ��-patternRecognition,:2������ѧϰ-machineLearning
    BYTE    byAgriculturalMachineryFilterEnabled;  //ũ������ģ��ʹ�ܣ�0�������ã�1������
    BYTE    byWaterReflectionEnabled;  //ˮ�����ⷴ��ģ��ʹ��, 0�������ã�1������
    BYTE    byPatrolSensitivity;  //Ѳ����������� ����Ի���⣩, ��Χ1~100s��Ĭ��50s
    BYTE    byRes[33];
    NET_DVR_ALARMSTRATEGY_PARAM struAlarmStrategy;//��������
    NET_DVR_SMOKEDETECTION_CFG struSmokeCfg;//����������
}NET_DVR_FIREDETECTION_CFG,*LPNET_DVR_FIREDETECTION_CFG;

typedef  struct tagNET_DVR_THERMALPOWER_PARAM
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byPowerSwitch;//����ʹ�ܣ�1Ϊ������0Ϊ�ر�
    BYTE    byRes[123];
}NET_DVR_THERMALPOWER_PARAM, *LPNET_DVR_THERMALPOWER_PARAM;

typedef  struct tagNET_DVR_PTZABSOLUTEEX_CFG
{
    DWORD            dwSize;//�ṹ���С
    NET_PTZ_INFO     struPTZCtrl;//�豸PTZF��Ϣ
    DWORD            dwFocalLen;//���෶Χ��0-100000MM
    float            fHorizontalSpeed;//ˮƽת���ٶȣ�0.01-1000.00��/S
    float            fVerticalSpeed;//��ֱת���ٶȣ�0.01-1000.00��/S
    /*��ͷ�䱶�������ͣ�absoluteZoom:ͨ���䱶�����������ã�ѡ��Ϊ������ʱstruPTZCtrl�е�fZoom������Ч��focalLen:ͨ����������������ã�ѡ��Ϊ������ʱ��dwFocalLen������Ч��*/
    BYTE             byZoomType;// ��ͷ�䱶��������0~ absoluteZoom��1~ focalLen
    BYTE             byRes[123];
}NET_DVR_PTZABSOLUTEEX_CFG, *LPNET_DVR_PTZABSOLUTEEX_CFG;

#define MAX_PLAYLIST_NUM        50          //��󲥷��б���Ŀ 
#define MAX_PLAYPLAN_NUM        50          //��󲥷żƻ���Ŀ 

#define MAX_LEN_256                     256 
#define MAX_GROUP_RECORD_NUM            10      //����¼����
typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize; 
    DWORD  dwAreaID;   //����ID
    DWORD  dwMonitorID;  //��ǰ��ʼ��ȡ�ļ�ص��ţ���1��ʼ
    BYTE   byIsNeedGroup;  //�Ƿ��ѯ����������Ϣ
    BYTE   byRes [127];
}NET_DVR_AREA_MONITOR_COND,*LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;  
    BYTE  byDelType;     //ɾ�����ͣ�0-ɾ��ָ����������м�ص㣬1-ɾ��ָ�������ָ����ص�
    DWORD  dwAreaID;   //����ID
    DWORD  dwMonitorID;   //��ص�ID����byDelTypeΪ0ʱ��Ч����byDelTypeΪ1ʱ��Ч������1��ʼ
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND,*LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_COND
{
    DWORD       dwSize;         //�ṹ���С
    BYTE        byType;         //�ڰ�������־��- ȫ����- ��������- ������
    BYTE        byRes1[3];      //����
    DWORD       dwFaceID;       //��������ID
    DWORD       dwMaxSnapNum;   //���ץ��������0-��ʾ������
    BYTE        byRes[256];
}NET_DVR_BLACKLIST_ALARM_COND, *LPNET_DVR_BLACKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;         //�ṹ���С
    DWORD        dwStorageID;    //�ӵ�ǰ��ſ�ʼ��ȡʣ����Դ����1��ʼ
    BYTE        byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLACKLIST_ALARM_RECORD
{
    DWORD          dwSize;   //�ṹ���С
    DWORD            dwSnapFacePicID;    //ץ������ID
    DWORD            dwRegisterID;        //����ע��ID�ţ�ֻ����
    DWORD            dwGroupNo;            //�����
    BYTE            byRes[128];
}NET_DVR_BLACKLIST_ALARM_RECORD, *LPNET_DVR_BLACKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_INFO  //����������Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD          dwGroupID; //�����ţ���ȡʱ��Ч�����ʱ��Ч������1��ʼ
    DWORD            dwGroupNo;            //���������
    BYTE            byGroupType;        //�������ͣ�0-���������飬1-����������
    BYTE            byRes1;
    WORD            wThreshold;            //������ֵ��ȡֵ��ΧΪ0-1000
    DWORD            dwListNum;            //����������
    BYTE            szGroupName[NAME_LEN];  //��������
    BYTE            szRemark[MAX_LEN_256];
    BYTE            byStorageAddr[MAX_DOMAIN_NAME];  //�洢IP��ַ��Ϣ
    WORD            wStoragePort;            //�洢IP��Ӧ�Ķ˿ں�
    BYTE            byRes[126];
}NET_DVR_BLACKLIST_GROUP_INFO, *LPNET_DVR_BLACKLIST_GROUP_INFO;


typedef struct tagNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD  
{
    DWORD          dwSize;   //�ṹ���С
    DWORD            dwGroupRecordID;            //�����¼ID���޸ĺͲ�ѯʱ��Ч������ʱ��Ч����1��ʼ
    DWORD            dwGroupNo;            //���������
    DWORD            dwFaceDBID;            //������ID
    DWORD            dwFaceRecordID;        //������¼ID
    BYTE            byAlarmLevel;        //�����ȼ���0-high,1-medium,2-low
    BYTE            byRes1[3];            //����
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;   //�洢IP��ַ��Ϣ
    BYTE            byRes[256];
}NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD,*LPNET_DVR_SINGLE_BLACKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;   //�ṹ���С
    DWORD            dwRecordID;                //�ӵ�ǰ��ſ�ʼ��ȡ����1��ʼ
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLACKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLACKLIST_GROUP_RECORD_CFG  //���������¼��Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD            dwRecordNum;            //��¼�ܸ���
    NET_DVR_SINGLE_BLACKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM]; //��¼����
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_RECORD_CFG,*LPNET_DVR_BLACKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_CFG  //���������¼��Ϣ
{
    DWORD          dwSize;   //�ṹ���С
    DWORD            dwGroupNum;            //�����ܸ���
    NET_DVR_BLACKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM]; //��¼����
    BYTE            byRes[256];
}NET_DVR_BLACKLIST_GROUP_CFG,*LPNET_DVR_BLACKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLACKLIST_GROUP_COND
{
    DWORD        dwSize;   //�ṹ���С
    DWORD            dwGroupID;                //�ӵ�ǰ��ſ�ʼ��ȡ����1��ʼ
    BYTE            byRes[64];
}NET_DVR_BLACKLIST_GROUP_COND, *LPNET_DVR_BLACKLIST_GROUP_COND;



typedef  struct  tagNET_DVR_SENSOR_VALUE
{
    float   fMinValue; //��Сֵ����ȷ��0.001����Ϊ0xfffffffff��ʾ��ѯ����
    float   fMaxValue; //���ֵ����ȷ��0.001����Ϊ0xfffffffff��ʾ��ѯ����
    BYTE    byRes[8];
}NET_DVR_SENSOR_VALUE, *LPNET_DVR_SENSOR_VALUE;

typedef  struct  tagNET_DVR_HISTORICAL_QUERY_PARAM //��ʷ���ݲ�ѯ�����ӽṹ
{
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��  
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    NET_DVR_SENSOR_VALUE struVoltageValue; //��ѹ����; ��λ���� 
    NET_DVR_SENSOR_VALUE struCurrentValue; //��������; ��λ����
    NET_DVR_SENSOR_VALUE struTemperatureValue;//�¶Ȳ�������λ���϶�
    NET_DVR_SENSOR_VALUE struHumidityValue;//ʪ�Ȳ���
    BYTE   bySwitchStatus;//ͨ��״̬�� 0~δͨ�磬1~ͨ�磬0xff��ѯ����
    BYTE   bySensorStatus; //������״̬�� 0-������1-�쳣��2-������0xff��ѯ����
    BYTE   byRes[66];
}NET_DVR_HISTORICAL_QUERY_PARAM, *LPNET_DVR_HISTORICAL_QUERY_PARAM;

typedef  struct  tagNET_DVR_SENSOR_COND //�����ṹ
{
    DWORD  dwSize; 
    BYTE   byQueryType; //��ѯ��ʽ��0~ʵʱ���ݲ�ѯ��1~��ʷ���ݲ�ѯ
    BYTE   byDeviceType; //�豸����;0~δ֪,1~ģ����������, 2~�ϵ����,3~�ϵ������0xff��ʾ��ѯ����
    BYTE   byDeviceID; //�豸ID��Analog(ģ����������)��Χ��1-8��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2��0xff��ʾ��ѯ����
    BYTE   byRes1;
    // INTER_HISTORICAL_QUERY_PARAM�ӽṹ����byQueryTypeΪ1ʱ��Ч
    NET_DVR_HISTORICAL_QUERY_PARAM struHistoricalQueryParam; //��ʷ���ݲ�ѯ����
    BYTE   byRes[64];
}NET_DVR_SENSOR_COND,*LPNET_DVR_SENSOR_COND;

typedef  struct  tagNET_DVR_SENSOR_CFG//���ýṹ
{
    DWORD  dwSize; 
    BYTE   byEnable; //��ǰ��ѯ�Ĵ������Ƿ�ʹ�ܣ�0-��ʹ�ܣ�1-ʹ�ܣ�
    BYTE   byDeviceType; //�豸����;0~δ֪,1~ģ����������, 2~�ϵ����,3~�ϵ����
    BYTE   byDeviceID; //�豸ID��Analog(ģ����������)��Χ��1-8��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2
    BYTE   byRes1;
    NET_DVR_TIME_V30 struTime;//ʱ�� 
    BYTE   byIsFirst; //�Ƿ����������һ������(����Ƿ�������)��0-��, 1-�ǣ�
    BYTE   byIsSwitchOn; //�Ƿ�ͨ�磬0-��, 1-�ǣ�
    BYTE   bySensorStatus; //������״̬�� 0-������1-�쳣��2-������
    BYTE   bySensorType; //���������ͣ����� SENSOR_TYPE
    float  fVoltage; //��ѹ����λ���أ���ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fCurrent; //��������λ��������ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fTemperatureValue;//�¶�ֵ����λ���϶ȣ���ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    float  fHumidityValue;//ʪ��ֵ����ȷ��0.001����Ϊ0xff��ʾ��Чֵ
    BYTE   bySensorName[SENSORNAME_LEN/*32*/]; //����������
    BYTE   byDescription[MAX_SENSORDESCR_LEN/*64*/]; //���������ݵ�������Ϣ��statusTypeΪ����ʱ��description����Ϊ��
    float  fActualValue;  //ģ���ź�ת�������ֵ����ȷ��0.0001
    BYTE   byUnit[SENSORUNIT_LEN/*32*/];   //��λ�ַ���
    BYTE   byRes[220];
}NET_DVR_SENSOR_CFG,*LPNET_DVR_SENSOR_CFG;

typedef    struct tagNET_DVR_SENSOR_SWITCH_COND
{
    DWORD     dwSize;//�ṹ���С
    BYTE     byDeviceType; //�豸����;0~δ֪, 1~�ϵ����Terminal,2~�ϵ����Socket
    BYTE     byDeviceID; //�豸ID��Terminal(�ϵ����)��Χ��1-4��Socket(�ϵ����)��Χ��1-2
    BYTE     bySwitch; //���أ�0-�ϵ�, 1-�ϵ磬2-����
    BYTE     byRes[125];
}NET_DVR_SENSOR_SWITCH_COND,*LPNET_DVR_SENSOR_SWITCH_COND;

typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;     //�ṹ���С
    BYTE   byServerID[DEV_ID_LEN];  //SIP������ID��
    WORD   wPort;      //SIP�������˿ں�
    BYTE   byRes1[2];  //����
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;           //��������ڣ���λ���룬Ĭ�ϣ�3600 
    BYTE   byMaxHeartbeatTimeOut;    //���������ʱ������Ĭ�ϣ�3��
    BYTE   byAutoAddIpc;            //�Ƿ������Զ����ipc,0-�����ã�1-����
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];   //������չΪ64λ������ʱ��byAuthPasswdExΪ�ǿգ��˲�����Ч��byAuthPasswd��Ч����ȡʱ��byAuthPasswdEx��byAuthPasswd������
    BYTE   byRes[190];                //����
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;
typedef    struct    tagNET_DVR_ACTIVATECFG
{
    DWORD   dwSize;    //�ṹ���С
    BYTE    sPassword[PASSWD_LEN];    //��ʼ����
    BYTE    byRes[108];
}NET_DVR_ACTIVATECFG,*LPNET_DVR_ACTIVATECFG;

typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;    //�ṹ���С
    BYTE        byMode;    //0-��ͨ�����1-����ַ����
    BYTE        bySelfDefinePassword;//�Ƿ��Զ�������,0-��,1-��,2-��,��ΪIPC���Զ�������
    BYTE        sPassword[PASSWD_LEN];//�Զ�������
    BYTE        sUserName[NAME_LEN];//�û���
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union��С
        struct
        {
            DWORD       dwChannelNo;//ͨ����
            BYTE        byRes[508];
        }struChannelInfo;//ͨ����Ϣ
        struct
        {
            NET_DVR_IPADDR   struIp;//IP��ַ
            WORD    wPort;//�˿ں�
            BYTE    sProtocolDesc[DESC_LEN];//Э������
            BYTE    byMacAddr[MACADDR_LEN];//mac��ַ
            BYTE    byRes[344];
        }struAddrInfo;//IP��ַ������NET_DVR_SADPINFO
    }unActivateDeviceInfo;//ʹ��������ṹ��ͨ��byMode�ֶα�ʾ�ǰ�ͨ�����ǰ���ַ
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-����,1-IPCδ���2-�������룬3-����ǿ������4-����ǿ���У�5-����ǿ��ǿ;byDigitalChanPasswordStatus[0]��ʾ��һ������ͨ��
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_CAMERACHAN_SERIALCFG
{  
    DWORD    dwSize;
    DWORD   dwBaudRate;  //������(bps)��0-50��1-75��2-110��3-150��4-300��5-600��6-1200��7-2400��8-4800��9-9600��10-19200��11-38400��12-57600��13-76800��14-115.2k
    BYTE    byDataBit; //�����м�λ��0-5λ��1-6λ��2-7λ��3-8λ
    BYTE    byStopBit;  //ֹͣλ��0-1λ��1-2λ
    BYTE    byParity;  //�Ƿ�У�飺0-��У�飬1-��У�飬2-żУ��
    BYTE    byFlowcontrol;// �Ƿ����أ�0-�ޣ�1-������,2-Ӳ����
    WORD    wPTZProtocol;  //����Э�����ͣ�����ֵ
    BYTE    byRes1[6];
    DWORD   dwSerialPort; //���ں�,���λΪ0����ʾǰ��崮�ڣ����λΪ1����ʾ����崮��
    BYTE    bySerialAddress; //���ڵ�ַ0~255
    BYTE    byRes[15];
}NET_DVR_CAMERACHAN_SERIALCFG, *LPNET_DVR_CAMERACHAN_SERIALCFG;

#define MAX_MATRIX_SUBBOARD_NUM      16   //�ۺ�ƽ̨����Ӱ���
#define MAX_MATRIX_SUBBOARD_NUM_V51  32     //�ۺ�ƽ̨����Ӱ���
#define MAX_BOARD_SUBSYSTEM_NUM      12   //ÿ���Ӱ����ϵͳ��
typedef  struct  tagNET_DVR_SUBSYSTEM_STATUS
{
    /*��ϵͳ���ͣ�1-��������ϵͳ��2-��������ϵͳ��3-���������ϵͳ��4-����������ϵͳ��5-�������ϵͳ��6-����������ϵͳ��7-������ϵͳ��8-Fpga������ϵͳ��9-Fpga��ϵͳ��10-ת����ϵͳ��
    11-X86��������ϵͳ��12-������������ϵͳ��13-X86���ķ���壬 14- X86ҵ������ ��15-�����ƴ����ϵͳ��16-������˽�����ϵͳ��17-X86ƴ����ϵͳ��18-��ͨƴ����ϵͳ��19-��Ƶ��ϵͳ��0-NULL*/
    BYTE    bySubSystemType;
    BYTE    bySubSystemNo;   //��ϵͳ�ţ��������Ӱ��ϵı�� 
    BYTE    byOnlineStatus;  //��������״̬�� 1-���� 2-������
    BYTE    byRes[49]; 
}NET_DVR_SUBSYSTEM_STATUS, *LPNET_DVR_SUBSYSTEM_STATUS;


typedef  struct  tagNET_DVR_MATRIX_SUBBOARD
{
    BYTE  byBoardNo;                //�Ӱ��
    BYTE  byPcieConnectStatus;        //pcie����״̬�� 1-���� 2-�Ͽ�
    BYTE  byRes[2];
    DWORD dwHardwareVersion;       //�Ӱ�Ӳ���汾
    DWORD dwPcieBandwidth;        //pcie Link ����  
    DWORD dwTemperature;          //�Ӱ��¶�  ��λ�����϶�
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //��ϵͳ״̬
    BYTE  byRes2[16];
}NET_DVR_MATRIX_SUBBOARD, *LPNET_DVR_MATRIX_SUBBOARD;
typedef struct  tagNET_DVR_MATRIX_STATUS
{
    DWORD dwSize;
    BYTE  byMainFrameType;   //��������  1-18U����(V1.0) 2-18U���� 3-14U���� 4-11U���� 5-8U���� 6-7U����  7-5U����
    BYTE  bySoltNum;   //��λ��
    BYTE  byBoardNum;   //�Ӱ���
    BYTE  byRes;
    NET_DVR_MATRIX_SUBBOARD struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    BYTE  byRes2[48];
}NET_DVR_MATRIX_STATUS, *LPNET_DVR_MATRIX_STATUS;


typedef  struct  tagNET_DVR_MATRIX_SUBBOARD_V50
{
    BYTE  byBoardNo;            //�Ӱ��
    BYTE  byPcieConnectStatus;  //pcie����״̬�� 1-���� 2-�Ͽ�
    BYTE  byRes;
    BYTE  byTemperatureAlarm;   //�¶ȱ�����0-���ֶ���Ч��1-�¶�������2-�¶ȳ����ޱ�����3-�¶ȳ����ޱ���
    DWORD dwHardwareVersion;    //�Ӱ�Ӳ���汾
    DWORD dwPcieBandwidth;      //pcie Link ����  
    DWORD dwTemperature;        //�Ӱ��¶�  ��λ�����϶�
    NET_DVR_SUBSYSTEM_STATUS struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //��ϵͳ״̬
    BYTE  bySubboardModel[32]; //�Ӱ��ͺ�
    BYTE  byRes1[32];
}NET_DVR_MATRIX_SUBBOARD_V50, *LPNET_DVR_MATRIX_SUBBOARD_V50;

typedef struct  tagNET_DVR_MATRIX_STATUS_V50
{
    DWORD dwSize;
    BYTE  byMainFrameType; //��������  1-18U����(V1.0) 2-18U���� 3-14U���� 4-11U���� 5-8U���� 6-7U����  7-5U����
    BYTE  bySoltNum; //��λ��
    BYTE  byBoardNum; //�Ӱ���
    BYTE  byLCDPanelStatus; //Һ���������״̬��1-������2-�쳣
    NET_DVR_MATRIX_SUBBOARD_V50 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    DWORD dwFanSequence; //���ȱ�ţ���λ��ʾ�����λ��ʹ�ã�����0xffffff04��ʾ���Ϊ1�ķ��ȣ�����Ӧ���ȱ���λʱ��dwFanConnectStatus��dwFanOperationStatus�Ķ�Ӧλ����Ч��������Ϊ�޴˱�ŵķ���
    DWORD dwFanConnectStatus; //��������״̬����λ��ʾ�����λ��ʹ�ã�����0xffffff00��ʾ���Ϊ1�ķ�������������0xffffff04��ʾ���Ϊ1�ķ��������쳣
    DWORD dwFanOperationStatus; //��������״̬����λ��ʾ�����λ��ʹ�ã�����0xffffff00��ʾ���Ϊ1�ķ�������״̬������0xffffff04��ʾ���Ϊ1�ķ��������쳣
    BYTE  byDeviceModel[32]; //�豸�ͺ�
    BYTE  byPowerNums; //��Դ����
    BYTE  byMainBoardNums; //��������
    BYTE  byHotStandbyMode; // byMainBoardNumsΪ2ʱ��0-������M1��λ��1-������M2��λ
    BYTE  byRes[29];
}NET_DVR_MATRIX_STATUS_V50, *LPNET_DVR_MATRIX_STATUS_V50;

typedef struct tagNET_DVR_MATRIX_SUBBOARD_V51
{
    BYTE    byBoardNo; //�Ӱ��
    BYTE    byPcieConnectStatus; //pcie����״̬��1-���ӣ�2-�Ͽ�
    BYTE    byRes1;
    BYTE    byTemperatureAlarm; //�¶ȱ�����0-���ֶ���Ч��1-�¶�������2-�¶ȳ����ޱ�����3-�¶ȳ����ޱ���
    DWORD   dwHardwareVersion; //�Ӱ�Ӳ���汾
    DWORD dwPcieBandwidth; //pcie Link����
    DWORD dwTemperature; //�Ӱ��¶ȣ���λ�����϶�
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //��ϵͳ״̬
    BYTE    bySubboardModel[32]; //�Ӱ��ͺ�
    BYTE    byRes2[128];
}NET_DVR_MATRIX_SUBBOARD_V51, *LPNET_DVR_MATRIX_SUBBOARD_V51;

typedef struct tagNET_DVR_MATRIX_STATUS_V51
{
    DWORD   dwSize;
    BYTE    byMainFrameType; //�������� 1-18U���䣨V1.0����2-18U���䣬3-14U���䣬4-11U���䣬5-8U���䣬6-7U����
    BYTE    bySoltNum; //��λ��
    BYTE    byBoardNum; //�Ӱ���
    BYTE    byLCDPanelStatus; //Һ���������״̬��1-������2-�쳣
    NET_DVR_MATRIX_SUBBOARD_V51 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM_V51];
    DWORD  dwFanSequence; //���ȱ�ţ���λ��ʾ������0x00000001��ʾ�豸ֻ��һ�����ȣ����Ϊ1��0x00000101��ʾ�豸���������ȣ���ŷֱ�Ϊ1��9������Ӧ���ȱ�ű���λʱ��dwFanConnectStatus��dwFanOperationStatus�Ķ�Ӧλ����Ч��������Ϊ�޴˱�ŵķ���
    DWORD dwFanConnectStatus; //��������״̬����λ��ʾ������0x00000001��ʾ���Ϊ1�ķ�������״̬�쳣��0x00000101��ʾ���Ϊ1��9�ķ�������״̬���쳣
    DWORD dwFanOperationStatus; //��������״̬����λ��ʾ������0x00000001��ʾ���Ϊ1�ķ�������״̬�쳣��0x00000101��ʾ���Ϊ1��9�ķ�������״̬���쳣
    BYTE   byDeviceModel[32]; //�豸�ͺ�
    BYTE    byFanSpeed[32]; //����ת�٣����ֽڱ�ʾ������byFanSpeed[0]��ʾ���Ϊ1�ķ��ȵ�ת�٣�ת�ٵȼ���ΧΪ[1,3]
    BYTE   byMainMemUsed; //�����ڴ�ʹ���ʣ���λ���ٷֱ�
    BYTE    byMainCpuUsed; //����CPUʹ���ʣ���λ���ٷֱ�
    BYTE    byNetwordUsed; //����������ʹ���ʣ���λ���ٷֱ�
    BYTE   byRes1;
    DWORD   dwMainSoftwareVer; //��������汾
    BYTE  byPowerNums; //��Դ����
    BYTE  byMainBoardNums; //��������
    BYTE  byHotStandbyMode; // byMainBoardNumsΪ2ʱ��0-������M1��λ��1-������M2��λ
    BYTE     byRes2[125];
}NET_DVR_MATRIX_STATUS_V51, *LPNET_DVR_MATRIX_STATUS_V51;

typedef struct _NET_DVR_SUBWIND_INFO
{
	DWORD dwSize;
    DWORD dwSubWndNo; //�Ӵ��ں�
	BYTE	byRes[8];
} NET_DVR_SUBWIND_INFO, *LPNET_DVR_SUBWIND_INFO;


typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;  //ͼ���ںϿ�(����ͼ����Ŀ)
    WORD wHeight; //ͼ���ںϸ�(����ͼ����Ŀ)
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;  //�Ƿ��ںϣ�0-δ�ںϻ�ȡ���ںϣ���0-�ں�
    BYTE byUseHistoryMap; //�Ƿ�ʹ����ʷ�ں�ӳ���0-��ʹ�ã���0-ʹ��
    BYTE byRes[30]; 
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_MULTIFUNCTION_SERIALCFG
{
    DWORD dwSize ;
    BYTE  byVariable ;  //�����Ƿ�ɱ䣬1-���ɱ�  2-�ɱ� ��ֻ��ȡ��
    BYTE  bySerialWorkMode;   //����ģʽ��1-RS485, 2-RS232��ֻ�ڿɱ�����£��޸Ĺ���ģʽ��
    BYTE  byFunType;   //���ڹ��ܣ� 1-���̿��ƣ�2-��Ļ���ƣ�3-͸��ͨ��ģʽ 4-PTZ����  5-������� 6-����̨
    BYTE byDataBit;// ����λ 0��5λ��1��6λ��2��7λ��3��8λ;
    BYTE byStopBit;// ֹͣλ 0��1λ��1��2λ;
    BYTE byParity;// У�� 0����У�飬1����У�飬2��żУ��;
    BYTE byFlowcontrol;// 0���ޣ�1��������,2-Ӳ����
    BYTE byRes1 ;   
    DWORD dwBaudRate;//������0��50��1��75��2��110��3��150��4��300��5��600��6��1200��7��2400��8��4800��9��9600��10��19200�� 11��38400��12��57600��13��76800��14��115.2k;   
    WORD wProtocol;   //����Э��  ��ͬ���ڹ��ܶ�Ӧ����Э�鲻һ��
    BYTE byRes[34];
}NET_DVR_MULTIFUNCTION_SERIALCFG, *LPNET_DVR_MULTIFUNCTION_SERIALCFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //ͨ����
    BYTE    byPSpeed;  // X������ٶ�  ��ȡֵ1��64��
    BYTE    byTSpeed;  // Y������ٶ�   ��ȡֵ1��64��
    BYTE    byZSpeed;  // Z�ٶ�
    BYTE    byPDirect; // P���� 1-�� 2-��
    BYTE    byTDirect; // T���� 1-�ϣ� 2-��
    BYTE    byZDirect;  //Z����  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];  //�����ֽ�
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL; 

//Sensor��Ϣ
typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE        bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//ˮƽ��� ��ȷ��С�������λ *10000
    float       fVerWidth;//��ֱ��� ��ȷ��С�������λ *10000
    float       fFold;//zoom=1û��ʱ�Ľ��� ��ȷ��С�������λ *100
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//��[0.000000,60.000000]
    BYTE byDegree;//��:γ��[0,90] ����[0,180]
    BYTE byMinute;//��[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

typedef struct tagNET_DVR_LLPOS_PARAM
{
    BYTE   byLatitudeType;//γ�����ͣ�0-��γ��1-��γ
    BYTE   byLongitudeType;//�������ͣ�0-������1-����
    BYTE   byRes1[2];
    NET_DVR_LLI_PARAM    struLatitude;    /*γ��*/
    NET_DVR_LLI_PARAM    struLongitude; /*����*/
    BYTE   byRes[16];
}NET_DVR_LLPOS_PARAM, *LPNET_DVR_LLPOS_PARAM;

//ת��������Ϣ
typedef struct tagNET_DVR_TURN_DIRECTION_PARAM
{
    BYTE   byLine;//ת���߱��
    BYTE   byStatus;//ת����״̬��0-δ֪��1-���룬2-�뿪
    BYTE   byRes[38];
}NET_DVR_TURN_DIRECTION_PARAM, *LPNET_DVR_TURN_DIRECTION_PARAM;
//ֹͣ����Ϣ
typedef struct tagNET_DVR_STOP_LINE_PARAM
{
    BYTE   byStatus;//ֹͣ��״̬��0-δ֪��1-���룬2-�뿪
    BYTE   byRes[39];
}NET_DVR_STOP_LINE_PARAM, *LPNET_DVR_STOP_LINE_PARAM;

//TPS������Ϣ
typedef struct tagNET_DVR_TPS_ADDINFO
{
    NET_DVR_LLPOS_PARAM struFirstLLPos;//��������һ�����ľ�γ��λ����Ϣ(byLaneState=3��byQueueLen>0ʱ�ŷ���)
    NET_DVR_LLPOS_PARAM struLastLLPos;//���������һ�����ľ�γ��λ����Ϣ(byLaneState=3��byQueueLen>0ʱ�ŷ���)
    char            sLicense[MAX_LICENSE_LEN/*16*/];//���ƺ�
    NET_DVR_TURN_DIRECTION_PARAM    struTurnDirection;//ת��������Ϣ
    NET_DVR_STOP_LINE_PARAM  struStopLine;//ֹͣ����Ϣ    
    BYTE   byRes[884];
}NET_DVR_TPS_ADDINFO, *LPNET_DVR_TPS_ADDINFO;

//����������Ϣ
typedef struct tagNET_DVR_VEHICLE_ADDINFO
{
    NET_DVR_LLPOS_PARAM struLLPos;//������ǰ��γ��λ����Ϣ
    char   sVehicleNo[LEN_64]; /*�ϴ��ĳ���Ψһ��ʶ,��󳤶�Ϊ64*/
    BYTE   byVehicleMonitorTaskID[64];//�������ܲ�������ID,64λ�ַ���,��������ʱ���ϲ��·����豸,�ϲ�ȷ��IDΨһ��
    BYTE   byUUID[LEN_64]; //ͨ��Ψһʶ����,64λ�ַ���,�豸ȷ��Ψһ�ԣ����ڿ����������ͬһ��ץ��,vehicleMonitor��manualVehicleMonitor��dailyVehicleMonitor�����е�linkageANPRUUID�й�
    BYTE   byRes[832];
}NET_DVR_VEHICLE_ADDINFO, *LPNET_DVR_VEHICLE_ADDINFO;

//������
typedef struct tagNET_DVR_SMOKEDETECTION_ALARM
{
    NET_PTZ_INFO struPTZPos;//�ɼ����豸PTZFλ��
    NET_PTZ_INFO struThermalPTZPos;//�ȳ����豸PTZFλ��
    NET_DVR_LLPOS_PARAM struLLPos;//�豸��γ��λ��
    NET_VCA_RECT  struSmokePos;//��������������λ��
    BYTE   byRes[256];
}NET_DVR_SMOKEDETECTION_ALARM, *LPNET_DVR_SMOKEDETECTION_ALARM;

//���λ����Ϣ
typedef struct
{
    float   fPanPos;//ˮƽ��������ȷ��С�����1λ
    float   fTiltPos;//��ֱ��������ȷ��С�����1λ
    float   fZoomPos;//�䱶��������ȷ��С�����1λ
    BYTE    byRes[16] ;
}NET_DVR_PTZPOS_PARAM, *LPNET_DVR_PTZPOS_PARAM;

//GIS��Ϣ�ϴ�
typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;//�ṹ���С
    DWORD     dwRelativeTime; //���ʱ��
    DWORD    dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO    struDevInfo;//ǰ���豸
    float   fAzimuth;//�������̵ķ�λ��Ϣ����λ��[0.00��,360.00��)
    BYTE    byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE    byLongitudeType ;// �������ͣ�0-���ȣ�1-����
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM    struLatitude;     /*γ��*/
    NET_DVR_LLI_PARAM    struLongitude;   /*����*/
    float   fHorizontalValue;//ˮƽ�ӳ��ǣ���ȷ��С���������λ
    float   fVerticalValue;//��ֱ�ӳ��ǣ���ȷ��С���������λ
    float   fVisibleRadius;//��ǰ���Ӱ뾶����ȷ��С���������λ
    float   fMaxViewRadius;//�����Ӱ뾶����ȷ��С�������0λ��Ԥ������
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor��Ϣ
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz����
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

//���ƻ�������Ϣ�ϴ�
typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD        dwSize;//�ṹ���С
    DWORD         dwRelativeTime; //���ʱ��
    DWORD        dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO    struDevInfo;//ǰ���豸
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;

//���в��ز�������
typedef    struct tagNET_DVR_CENTRALIZEDCTRL_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnable;//0-������1-��ʼ
    BYTE        byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE        byLongitudeType ;// �������ͣ�0-������1-����
    BYTE        byRes1;
    NET_DVR_LLI_PARAM    struLatitude;     /*γ��*/
    NET_DVR_LLI_PARAM    struLongitude; /*����*/
    DWORD       dwTimeOut;//��ʱʱ�� [60s, 6*60*60s]
    BYTE        byControlType;//���в��ط�ʽ 0-ǿ�Ʋ��أ�1-��ǿ�Ʋ���
    BYTE        byRes[127];
}NET_DVR_CENTRALIZEDCTRL_CFG,*LPNET_DVR_CENTRALIZEDCTRL_CFG;

//�����GIS��Ϣ����
typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;//�ṹ���С
    float  fAzimuth;//�������̵ķ�λ��Ϣ����λ��[0.00��,360.00��)
    float  fHorizontalValue;//ˮƽ�ӳ��ǣ���ȷ��С���������λ
    float  fVerticalValue;//��ֱ�ӳ��ǣ���ȷ��С���������λ
    float  fVisibleRadius;//��ǰ���Ӱ뾶����ȷ��С���������λ
    float  fMaxViewRadius;//�����Ӱ뾶����ȷ��С�������0λ��Ԥ������
    BYTE   byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
    BYTE   byLongitudeType ;// �������ͣ�0-������1-����
    BYTE byPTZPosExEnable;//�Ƿ�����PTZ������չ��0~�����ã�PTZ����ֵ��struPtzPos Ϊ׼��1~���ã�PTZ����ֵ��struPtzPosExΪ׼��
    BYTE byRes1;
    NET_DVR_LLI_PARAM     struLatitude;     /*γ��*/
    NET_DVR_LLI_PARAM    struLongitude; /*����*/
    NET_DVR_PTZPOS_PARAM struPtzPos; //ptz����
    NET_DVR_SENSOR_PARAM struSensorParam;//Sensor��Ϣ
    NET_PTZ_INFO struPtzPosEx;// ptz������չ(֧�ָ߾���PTZֵ����ȷ��С�������λ)
    float   fMinHorizontalValue;//��Сˮƽ�ӳ��ǣ���ȷ��С���������λ��0.0-360.00
    float   fMaxHorizontalValue;//���ˮƽ�ӳ��ǣ���ȷ��С���������λ��0.0-360.00
    float   fMinVerticalValue;//��С��ֱ�ӳ��ǣ���ȷ��С���������λ��0.0-360.00
    float   fMaxVerticalValue;//���ֱ�ӳ��ǣ���ȷ��С���������λ��0.0-360.00
    BYTE  byRes[220];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;

//�豸Ѳ��ģʽ
typedef    struct tagNET_DVR_CRUISE_PARAM
{
    DWORD    dwSize;//�ṹ���С
    BYTE    byCruiseMode;// Ѳ��ģʽ��0~������1~Ԥ�õ�
    BYTE    byRes[123];
}NET_DVR_CRUISE_PARAM, *LPNET_DVR_CRUISE_PARAM;

//��ȡ�豸������ʪ����Ϣ�ṹ��
typedef struct tagNET_DVR_TEMP_HUMI_INFO
{
    DWORD    dwSize;
    NET_DVR_TIME_V30      struCurrentTime; // ��ǰʱ��
    float        fTemperature;//�豸�����¶ȣ���ȷ��С�������λ����-273 �C 1000���϶ȣ�
    float        fHumidity;// �豸����ʪ�ȣ���ȷ��С�������λ����λΪ��%
    BYTE       byRes[256];
}NET_DVR_TEMP_HUMI_INFO, *LPNET_DVR_TEMP_HUMI_INFO;

typedef struct tagNET_SDK_POINT_THERMOMETRY
{
    float        fPointTemperature;/*����µ�ǰ�¶�, ���궨Ϊ0-��ʱ��Ч����ȷ��С�����һλ(-40-1000),��������+100��*10 */
    NET_VCA_POINT  struPoint;//��������꣨������궨����Ϊ���㡱��ʱ����Ч��
    BYTE       byRes[20];
}NET_SDK_POINT_THERMOMETRY, *LPNET_SDK_POINT_THERMOMETRY;


typedef struct tagNET_SDK_REGION_THERMOMETRY
{
    float            fMaxTemperature;//����¶�,��ȷ��С�����һλ(-40-1000),��������+100��*10 */
    float            fMinTemperature;//����¶�,��ȷ��С�����һλ(-40-1000),��������+100��*10 */
    float            fAverageTemperature;//ƽ���¶�,��ȷ��С�����һλ(-40-1000),��������+100��*10 */
    float            fTemperatureDiff;//�²�,��ȷ��С�����һλ(-40-1000),��������+100��*10 */
    NET_VCA_POLYGON struRegion;//�����ߣ�������궨����Ϊ���򡱻��ߡ��ߡ���ʱ����Ч��
    BYTE       byRes[20];
}NET_SDK_REGION_THERMOMETRY, *LPNET_SDK_REGION_THERMOMETRY;

typedef    struct tagNET_SDK_MANUALTHERM_RULE
{
    BYTE       byRuleID;//����ID 0-��ʾ��Ч����1��ʼ ��list�ڲ��ж�������Ч�ԣ�
    BYTE       byEnable;//�Ƿ�����
    BYTE       byRes1[2];
    char         szRuleName[NAME_LEN/*32*/];//��������
    BYTE       byRuleCalibType;//����궨���� 0-�㣬1-��2-��
    BYTE       byRes2[3];
    NET_SDK_POINT_THERMOMETRY struPointTherm;//����£����궨Ϊ0-��ʱ��Ч
    NET_SDK_REGION_THERMOMETRY struRegionTherm; //������£����궨Ϊ1-��2-��ʱ��Ч��
    BYTE      byRes[512];
}NET_SDK_MANUALTHERM_RULE, *LPNET_SDK_MANUALTHERM_RULE;

typedef    struct tagNET_SDK_MANUAL_THERMOMETRY
{
    DWORD        dwSize;//�ṹ���С
    DWORD        dwChannel;//ͨ����
    DWORD      dwRelativeTime; // ���ʱ�ֻ꣨����
    DWORD    dwAbsTime;      // ����ʱ�ֻ꣨����
    BYTE       byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    BYTE       byDataType;//����״̬����:0-����У�1-��ʼ��2-������ֻ����
    BYTE      byRes1[6];
    NET_SDK_MANUALTHERM_RULE struRuleInfo;
    BYTE      byRes[512];
}NET_SDK_MANUAL_THERMOMETRY, *LPNET_SDK_MANUAL_THERMOMETRY;

typedef struct tagNET_SDK_MANUALTHERM_BASICPARAM
{
    DWORD        dwSize;
    WORD         wDistance;//����(m)[0, 10000]
    BYTE         byDistanceUnit;//���뵥λ: 0-�ף�m����1-Ӣ�ߣ�feet��,2-����(centimeter)
    BYTE         byRes1[1]; //����
    float        fEmissivity;//������(������ ��ȷ��С�������λ)[0.01, 1.00](��������������������ı���)
    BYTE         byRes[64]; //����
}NET_SDK_MANUALTHERM_BASICPARAM, *LPNET_SDK_MANUALTHERM_BASICPARAM;

typedef struct tagNET_SDK_FIRESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;//����ID��1~24
    BYTE      byEnabled;// ���������������ʹ�ܣ�0~�����ã�1~����
    BYTE      byShieldZoom;//���α��ʣ�0~32�������δ��ڵ��ڸ�ֵ�Ĺ�ѧ�䱶��
    BYTE      byMaskType;//����������ɫ���ͣ�0-��ɫ��1-��ɫ��2-��ɫ��3-��ɫ��4-��ɫ��5-��ɫ��6-͸����7-��͸����8-������
    BYTE      byRegionType;//�������ͣ�Ԥ����0-�ı���
    BYTE      byShowEnabled; //������ʾʹ�ܣ��ò���Ϊֻ��������ʹ��Ϊfalse���ϲ㲻��ʾ�����������Ϣ��TrueΪ��ʾ�����������Ϣ
    BYTE         byRes1[2]; //����
    char           szMaskName[NAME_LEN/*32*/];//���α���
    NET_VCA_POLYGON struRegion;//��������
    BYTE         byRes[32]; //����
}NET_SDK_FIRESHIELDMASK_REGION, *LPNET_SDK_FIRESHIELDMASK_REGION;

#define MAX_FIRESHIELDMASK_REGION 24
typedef struct tagNET_SDK_FIRESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;// �����������ʹ�ܣ�0~�����ã�1~����
    BYTE         byShieldAreaTransparency;//��������͸���� 0-��͸�� 1-͸�� 2-��͸��
    BYTE         byDisplayShieldAreaEnabled;//����������������ʹ��
    BYTE         byRes1[1]; //����
    NET_SDK_FIRESHIELDMASK_REGION struMaskRegion[MAX_FIRESHIELDMASK_REGION/*24*/];//�����������
    BYTE         byRes[256]; //����
}NET_SDK_FIRESHIELDMASK_CFG, *LPNET_SDK_FIRESHIELDMASK_CFG;

typedef struct tagNET_SDK_SMOKESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;//����ID��1~24
    BYTE      byEnabled;// ����������������ʹ�ܣ�0~�����ã�1~����
    BYTE      byShieldZoom;//���α��ʣ�0~32�������δ��ڵ��ڸ�ֵ�Ĺ�ѧ�䱶��
    BYTE      byMaskType;//����������ɫ���ͣ�0-��ɫ��1-��ɫ��2-��ɫ��3-��ɫ��4-��ɫ��5-��ɫ��6-͸����7-��͸����8-������
    BYTE      byRegionType;//�������ͣ�Ԥ����0-�ı���
    BYTE      byShowEnabled;// ������ʾʹ�ܣ��ò���Ϊֻ��������ʹ��Ϊfalse���ϲ㲻��ʾ�����������Ϣ��TrueΪ��ʾ�����������Ϣ
    BYTE       byRes1[2]; //����
    char           szMaskName[NAME_LEN/*32*/];//���α���
    NET_VCA_POLYGON struRegion;//��������
    BYTE         byRes[32]; //����
}NET_SDK_SMOKESHIELDMASK_REGION, *LPNET_SDK_SMOKESHIELDMASK_REGION;

#define MAX_SMOKESHIELDMASK_REGION 24
typedef struct tagNET_SDK_SMOKESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;// ������������ʹ�ܣ�0~�����ã�1~����
    BYTE         byShieldAreaTransparency;//��������͸���� 0-��͸�� 1-͸�� 2-��͸��
    BYTE         byDisplayShieldAreaEnabled;//����������������ʹ��
    BYTE         byRes1[1]; //����
    NET_SDK_SMOKESHIELDMASK_REGION struMaskRegion[MAX_SMOKESHIELDMASK_REGION/*24*/];//������������
    BYTE         byRes[256]; //����
}NET_SDK_SMOKESHIELDMASK_CFG, *LPNET_SDK_SMOKESHIELDMASK_CFG;

typedef struct tagNET_SDK_AREASCAN_CFG
{
    DWORD        dwSize;
    BYTE      byScanState;//����ɨ�赱ǰ����״̬��0Ϊδ���ã�1Ϊ�����ã��ò���Ϊֻ����
    BYTE         byRes[259]; //����
}NET_SDK_AREASCAN_CFG, *LPNET_SDK_AREASCAN_CFG;

typedef struct tagNET_SDK_FIRESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//ͨ����
    BYTE        byRegionID;//����ID��1~24.
    BYTE         byRes[127]; //����
}NET_SDK_FIRESHIELDMASK_COND, *LPNET_SDK_FIRESHIELDMASK_COND;

typedef struct tagNET_SDK_SMOKESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//ͨ����
    BYTE        byRegionID;//����ID��1~24.
    BYTE         byRes[127]; //����
}NET_SDK_SMOKESHIELDMASK_COND, *LPNET_SDK_SMOKESHIELDMASK_COND;

//�����̹������ƻ�����
typedef    struct tagNET_DVR_VANDALPROOFALARM_CFG
{
    DWORD    dwSize;//�ṹ���С
    BYTE    bySensitivity;//������[1,100] (֧�����������ã�������ֵ��Խ���״�����ֵԽС��Խ�Ѵ���)
    BYTE    byUploadEnabled;//���÷��ƻ������ϴ�ʹ�� 0-�����ã�1-����
    BYTE    byVoiceWarningEnabled;//���÷��ƻ�����������ʾʹ�� 0-�����ã�1-���� 
    BYTE    byEnable;// ���ü����ƻ����� 0-�رգ�1-��ʼ
    BYTE    byRes[124];
}NET_DVR_VANDALPROOFALARM_CFG,*LPNET_DVR_VANDALPROOFALARM_CFG;

typedef    struct tagNET_DVR_AZIMUTHINFO
{
    DWORD        dwSize;//�ṹ���С
    float       fDegree;//��λ�Ƕ���(��ȷ��С�������λ)
    BYTE        byAzimuth; //��λ����Ϣ 0-����,1-����,2-����,3-����,4-��,5-��,6-��,7-��
    BYTE        byRes[127];
}NET_DVR_AZIMUTHINFO,*LPNET_DVR_AZIMUTHINFO;

//�������̽�����ָ���������������ṹ
typedef    struct tagNET_DVR_COMPASS_COND
{
    DWORD        dwSize;//�ṹ���С
    DWORD        dwChannel;//ͨ����
    BYTE        byRes[128];
}NET_DVR_COMPASS_COND,*LPNET_DVR_COMPASS_COND;

typedef    struct tagNET_DVR_POSITION_CFG
{
    DWORD     dwSize;//�ṹ���С
    BYTE     bySoftWorkMode;//����ģʽ 0-�Զ���1-�ֶ�
    BYTE     byRes[127];
}NET_DVR_POSITION_CFG,*LPNET_DVR_POSITION_CFG;

typedef    struct tagNET_DVR_STREAMING_COND
{
    DWORD        dwSize;//�ṹ���С
    DWORD        dwChannel;//ͨ����
    BYTE        byStreamType;//��������0-��������1-��������2-����3
    BYTE        byRes[127];
}NET_DVR_STREAMING_COND,*LPNET_DVR_STREAMING_COND;

//���Ƕ�λ��������
typedef    struct tagNET_DVR_SATELLITETIME_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnable;//���Ƕ�λУʱʹ�� 0-��������1-����
    BYTE        byRes;
    WORD        wTimeInterval;//Уʱʱ����(s)
    BYTE        byRes1[124];
}NET_DVR_SATELLITETIME_CFG,*LPNET_DVR_SATELLITETIME_CFG;

#define MAX_SIGNAL_JOINT_NUM       64  //����ƴ�ӹ�ģ
typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
    DWORD    dwSize;
    BYTE  sCamName[NAME_LEN] ;  //ƴ�Ӻ��ź�Դ����
    BYTE  byEnable;               //ʹ�ܣ�0-��ʹ��  !0-ʹ��
    BYTE  byCamMode ;            //ƴ�Ӻ��ź�Դ���ͣ�NET_DVR_CAM_JOINT
    BYTE  byRows ;               //ƴ������
    BYTE  byColumns ;            //ƴ������
    DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //�ź�Դ��,ǰbyRows* byColumns����Ч
    DWORD dwJointNo;           //ƴ�ӱ�ţ���ȡ��Ч��
    DWORD dwSignalNoJoint;      //ƴ�Ӻ���ź�Դ�ţ���ȡ��Ч��
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
    DWORD    dwSize;
    DWORD    dwSignalNo;     //�ź�Դ�� 
    DWORD     dwCutTop;      //�Ϸ��ü�����ֵ,0����ԭ
    DWORD      dwCutBottom;   //�·��ü�����ֵ,0����ԭ
    DWORD      dwCutLeft;     //��߲ü�����ֵ,0����ԭ
    DWORD      dwCutRight;    //�ұ߲ü�����ֵ,0����ԭ
    BYTE     byRes2[32];  
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM; 

typedef struct tagNET_DVR_WALL_RELATION_CFG 
{
    DWORD dwSize; 
    BYTE  byEnable;           //������ 0-������ !0-����
    BYTE  byRealWallNo ;      //����ǽ��
    BYTE  byRes[14] ; 
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;


typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
    DWORD        dwSize ;
    BYTE        byValid ;     //
    BYTE        byCamMode ;//��NET_DVR_CAM_MODE
    WORD        wInputNo ; //�ź�Դ���
    BYTE        sCamName[NAME_LEN] ;
    NET_DVR_VIDEOEFFECT     struVideoEffect ;//��Ƶ����
    NET_DVR_PU_STREAM_CFG    struPuStream ;    //ip����ʱʹ��
    WORD        wBoardNum ;      //�ź�Դ���ڵİ忨�ţ�ֻ�ܻ�ȡ
    WORD        wInputIdxOnBoard ; //�ź�Դ�ڰ忨�ϵ�λ�ã�ֻ�ܻ�ȡ
    DWORD    dwResolution ;//�ֱ���
    BYTE    byVideoFormat ;//��Ƶ��ʽ����VIDEO_STANDARD
    BYTE    byStatus;    //�ź�Դ״̬��0-�ֶ���Ч 1-���ź� 2-���ź� 3-�쳣 
    BYTE    sGroupName[NAME_LEN/*32*/];    //�����ź�Դ���� ����
    BYTE    byJointMatrix ;            //��������0-������  1-�������������ź�ԴΪNET_DVR_CAM_BNC��NET_DVR_CAM_VGA��NET_DVR_CAM_DVI��NET_DVR_CAM_HDMI,�е�һ��ʱ���ò�����Ч��
    BYTE    byJointNo ;         //ƴ���ź�Դ��ƴ�ӱ��(ֻ�ܻ�ȡ)
    BYTE    byColorMode;      //ɫ��ģʽ�� 0-�Զ��� 1-���� 2-��ͨ 3-��ͣ���Ϊ�Զ���ʱ��ʹ��struVideoEffect����
    BYTE    byScreenServer; //������Ļ��������0-������1-����
    BYTE    byDevNo; //�豸��
    BYTE    byRes1;
    DWORD    dwInputSignalNo; //�����ź�Դ��ţ��£�
    BYTE    byVideoEnctype; //��Ƶ�������ͣ�0-Ĭ�ϣ�1-Smart264
    BYTE    byAudioEnctype; //��Ƶ�����࣬0-Ĭ�ϣ�1-AUDIO_G711_A��2-AUDIO_G711_U��3- AUDIO_G722_1
    BYTE    byWallStatus;    //�ź�Դ��ǽ״̬��0-��Ч 1-����ǽ 2- ����ǽ
    BYTE    byRes[117];
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct tagNET_DVR_AUDIO_CONTROL_INFO
{
    DWORD   dwSize;
    DWORD   dwMonId;//������ȫ�ֱ��
    BYTE    bySubWindowNum;//��������Ӧ�Ӵ��ں�
    BYTE    byWallNo; //ǽ��
    BYTE    byEnable; //��Ƶ���أ�0-�أ�1-��
    BYTE    byRes[13];
}NET_DVR_AUDIO_CONTROL_INFO,*LPNET_DVR_AUDIO_CONTROL_INFO;



typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM 
{
    DWORD    dwSize;
    WORD     wPTZProtocol;  //����Э�����ͣ�����ֵ 
    BYTE     byRes[34];    
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM; 

//��·�������Ͷ��� ���ա�2016�γ�����1133.xlsx��
typedef enum
{
    AXLE_TYPE_UNKNOWN = 0x0000,         //δ֪
    //2��
    AXLE_TYPE_2AXLE_12 = 0x0200,        //2���ػ�����
    //3��
    AXLE_TYPE_3AXLE_122_1 = 0x0300,     //3��������ҳ��г�
    AXLE_TYPE_3AXLE_122_2,              //3��½��г�
    AXLE_TYPE_3AXLE_15,                 //3���ػ�����
    AXLE_TYPE_3AXLE_112,                //3���ػ�����
    //4��
    AXLE_TYPE_4AXLE_125_1 = 0x0400,     //4��������ҳ��г�
    AXLE_TYPE_4AXLE_152,                //4��������ҳ��г�
    AXLE_TYPE_4AXLE_125_2,              //4��½��г�
    AXLE_TYPE_4AXLE_1222,               //4��ȫ�������г�
    AXLE_TYPE_4AXLE_115,                //4���ػ�����
    //5��
    AXLE_TYPE_5AXLE_155_1 = 0x0500,     //5��������ҳ��г�
    AXLE_TYPE_5AXLE_1125_1,             //5��������ҳ��г�
    AXLE_TYPE_5AXLE_155_2,              //5������г�
    AXLE_TYPE_5AXLE_1125_2,             //5������г�
    AXLE_TYPE_5AXLE_129,                //5������г�
    AXLE_TYPE_5AXLE_1522,               //5��ȫ�������г�
    AXLE_TYPE_5AXLE_11222,              //5��ȫ�������г�
    //6��
    AXLE_TYPE_6AXLE_159_1 = 0x0600,     //6��������ҳ��г�
    AXLE_TYPE_6AXLE_159_2,              //6��������ҳ��г�
    AXLE_TYPE_6AXLE_1155_1,             //6��������ҳ��г�
    AXLE_TYPE_6AXLE_1155_2,             //6��������ҳ��г�
    AXLE_TYPE_6AXLE_159_3,              //6������г�
    AXLE_TYPE_6AXLE_159_4,              //6������г�
    AXLE_TYPE_6AXLE_1129,               //6������г�
    AXLE_TYPE_6AXLE_11522_1,            //6��ȫ�ҳ�
    AXLE_TYPE_6AXLE_11522_2,            //6��ȫ�ҳ�
}TRUCK_AXLE_MODEL;

//��������
typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //�Ƿ���
    BYTE      byAxleNum;            //����
    WORD      wAxleModel;           //�ο� enum TRUCK_AXLE_MODEL,���Ը������ͽ�������ĸ���
    float     fOverWeight;          //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С�������λ��
    float     fWeight;              //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С�������λ��
    float     fLimitWeight;         //��������(��)��ʵ��ֵ����1000�����䣨ʵ��ֵ��ȷ��С�������λ��
    float     fAxleLen;             //���(��)��ʵ��ֵ����100�����䣨ʵ��ֵ��ȷ��С�������λ��
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/];      //�豸������Ϣ
    WORD      wAxleWeight[MAX_TRUCK_AXLE_NUM/*10*/];    //������������λǧ�ˣ�kg����i��Ԫ�ر�ʾ��i������
    WORD      wAxleDistance[MAX_TRUCK_AXLE_NUM/*10*/];  //�����࣬��λ����(mm).��i��Ԫ�ر�ʾ��i��͵�i+1��ļ��
    BYTE      byRes2[24];            //Ԥ��
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

// ���Ƽ����
typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;        //�ṹ����
    DWORD   dwMatchNo;        //ƥ�����,��(�������,��������,������)���ƥ����
    BYTE    byGroupNum;    //ͼƬ��������һ������������ץ�ĵ�����������һ��ͼƬ��������������ʱƥ�����ݣ�
    BYTE    byPicNo;        //���ĵ�ͼƬ��ţ����յ�ͼƬ�������󣬱�ʾ�������;���ճ�ʱ����ͼƬ������ʱ��������Ҫ������ɾ����
    BYTE    bySecondCam;    //�Ƿ�ڶ����ץ�ģ���Զ����ץ�ĵ�Զ���������ǰ��ץ�ĵĺ������������Ŀ�л��õ���
    BYTE    byFeaturePicNo; //����Ƶ羯��ȡ�ڼ���ͼ��Ϊ��дͼ,0xff-��ʾ��ȡ
    BYTE    byDriveChan;        //����������
    BYTE    byVehicleType;     //�������ͣ��ο�VTR_RESULT
    BYTE    byDetSceneID;//��ⳡ����[1,4], IPCĬ����0
    //�������ԣ���λ��ʾ��0- �޸�������(��ͨ��)��bit1- �Ʊ공(�������ı�־)��bit2- Σ��Ʒ������ֵ��0- ��1- ��
    //�ýڵ��Ѳ���ʹ��,ʹ�������byYellowLabelCar��byDangerousVehicles�ж��Ƿ�Ʊ공��Σ��Ʒ��
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //Υ�����Ͳ��ù��궨��
    BYTE    byIllegalSubType[8];   //Υ��������
    BYTE    byPostPicNo;    //Υ��ʱȡ�ڼ���ͼƬ��Ϊ����ͼ,0xff-��ʾ��ȡ
    BYTE    byChanIndex;        //ͨ���ţ�������
    WORD    wSpeedLimit;        //�������ޣ�����ʱ��Ч��
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex��ʾ��ʵͨ���š�
    BYTE    byVehiclePositionControl;  /*����λ�ò��ر�־,0~Ϊ��ͨ����ʶ�𱨾�,1~Ϊ����λ�ò��ش�������
                                       (��ͨ��PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json����)*/
    NET_DVR_PLATE_INFO  struPlateInfo;     //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //������Ϣ
    BYTE    byMonitoringSiteID[48];        //������
    BYTE    byDeviceID[48];                //�豸���
    BYTE    byDir;            //��ⷽ��1-���У����򣩣�2-����(����)��3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ����ϣ�8-����
    BYTE    byDetectType;    //��ⷽʽ,1-�ظд�����2-��Ƶ������3-��֡ʶ��4-�״ﴥ��
    //���������������ͣ��ο�ITC_RELA_LANE_DIRECTION_TYPE
    //�ò���Ϊ�����������������������Ŷ�Ӧ��ȷ������Ψһ�ԡ�
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //����������ʻ�ķ���0��ʾ�������£�1��ʾ�������ϣ�����ʵ�ʳ�������ʻ�����������֣�,2��ʾδ֪
    //��wIllegalType����Ϊ��ʱ��ʹ�øò�������wIllegalType����Ϊ��ֵʱ����wIllegalType����Ϊ׼���ò�����Ч��
    DWORD   dwCustomIllegalType; //Υ�����Ͷ���(�û��Զ���)
    /*Ϊ0~���ָ�ʽʱ��Ϊ�ϵ�Υ�����ͣ�wIllegalType��dwCustomIllegalType������Ч����ֵ����Υ�����롣
    Ϊ1~�ַ���ʽʱ��pIllegalInfoBuf������Ч���ϵ�Υ�����ͣ�wIllegalType��dwCustomIllegalType������Ȼ��ֵ����Υ������*/
    BYTE*   pIllegalInfoBuf;    //Υ�������ַ���Ϣ�ṹ��ָ�룻ָ��NET_ITS_ILLEGAL_INFO 
    BYTE    byIllegalFromatType; //Υ����Ϣ��ʽ���ͣ� 0~���ָ�ʽ�� 1~�ַ���ʽ
    BYTE    byPendant;// 0-��ʾδ֪,1-�����������2-������������
    BYTE    byDataAnalysis;            //0-����δ����, 1-�����ѷ���
    BYTE    byYellowLabelCar;        //0-��ʾδ֪, 1-�ǻƱ공,2-�Ʊ공
    BYTE    byDangerousVehicles;    //0-��ʾδ֪, 1-��Σ��Ʒ��,2-Σ��Ʒ��
    //�����ֶΰ���Pilot�ַ���Ϊ����ʻ����Copilot�ַ���Ϊ����ʻ
    BYTE    byPilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byCopilotSafebelt;//0-��ʾδ֪,1-ϵ��ȫ��,2-��ϵ��ȫ��
    BYTE    byPilotSunVisor;//0-��ʾδ֪,1-����������,2-��������
    BYTE    byCopilotSunVisor;//0-��ʾδ֪, 1-����������,2-��������
    BYTE    byPilotCall;// 0-��ʾδ֪, 1-����绰,2-��绰
    //0-��բ��1-δ��բ (ר������ʷ������������ݺڰ�����ƥ����Ƿ�բ�ɹ��ı�־)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-ʵʱ���ݣ�1-��ʷ����
    NET_DVR_TIME_V30  struSnapFirstPicTime;//�˵�ʱ��(ms)��ץ�ĵ�һ��ͼƬ��ʱ�䣩
    DWORD   dwIllegalTime;//Υ������ʱ�䣨ms�� = ץ�����һ��ͼƬ��ʱ�� - ץ�ĵ�һ��ͼƬ��ʱ��
    DWORD   dwPicNum;        //ͼƬ��������picGroupNum��ͬ����������Ϣ������ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx����    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //ͼƬ��Ϣ,���Żص������6��ͼ�����������
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //��������
    BYTE     byRes[256]; //Ԥ��
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;


typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-���������1-���ز�����2-��ʱ����
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;

typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    //�ճ��ƻ�����ʱ���
    BYTE byNormalSchedTimeOn; //�ճ��ƻ��Ƿ�����
    BYTE byMandatoryAlarm;//0-��ǿ�Ʋ�����1-ǿ�Ʋ��� ָ���������������Ƿ�Ϊ��·����
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;


#define MAX_WHITELIST_PHONE_NUM      16

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD    dwSize; 
    BYTE    byEnable;//�Ƿ����� 0-�����ã�1-����
    BYTE    byRes1[3];
    BYTE    byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD    dwArmRight; //����Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1�в���Ȩ�ޣ���������
    DWORD    dwDisArmRight; //����Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1�г���Ȩ�ޣ���������
    DWORD    dwClearAlarmRight; //����Ȩ�ޣ���λ��bit0Ϊ1��ʾ����ϵͳ1������Ȩ�ޣ���������
    BYTE    byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/]; //�����������ͣ�0-���ϴ���1-�ϴ� 
    DWORD    dwNonZoneReport; //�Ƿ����������� bit0-��������� bit1-ϵͳ״̬���� bit2-ȡ������ bit3-���Ա���,bit4-�������� bit5-�������� bit6-Ю�ֱ��� bit7-�����ָ����� bit8-��·���� bit9-��·�ָ�����,bit10-̽��������״̬���棨���ߡ����ߣ�,bit11-̽��������״̬���棨��ѹ������Ƿѹ��,bit12-��Ƶ��������
    BYTE    byIntervalTime; //0-0s,1-10s,2-30s,3-1min,4-5min,5-10min,6-�Զ��壨1~5999s��
    BYTE    byRes2;
    WORD    wDefineIntervalTime; //��byIntervalTimeΪ6ʱ��Ч���Զ���ʱ�䣨1~5999s��
    BYTE    byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD    dwSize;
    BYTE    byModuleType;            //��Ӵ��������ͣ�1-���̣�2-��������3-���� ��4-����ģ��
    BYTE    byKeyBoardType;            //1-LCD,2-LED
    BYTE    byTriggerType;            // 1-���ش������� 2-4·��������3-8·��������4-��������������5-32·������
    BYTE    byZoneType;                //�������ͣ�1-���ط�����2-��������3-˫������4-8������5-8·ģ��������, 6-������������
    WORD    wModuleAddress;            //��Ӵ�������ַ����չģ���0~255��0xFFFF��ʾ��Ч
    BYTE    byRes2[2];                //����
    char    sModelInfo[32];            //ģ����Ϣ
    char    sDeviceVersionInfo[32];    //�汾��Ϣ
    BYTE    byRes[128];                //����
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ALARMHOST_DETECTOR_INFO
{
    DWORD		dwSize;
    BYTE     byDetectorSerialNo[16];   //̽�������к�
    DWORD   dwAlarmIn;   //������
    WORD    wDetectorType;   // ̽�������ͣ�DETECTOR_TYPE
    BYTE   	byRes[126];      //����
}NET_DVR_ALARMHOST_DETECTOR_INFO, *LPNET_DVR_ALARMHOST_DETECTOR_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;// 0- ��1- ��
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE                       byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];//�±��ʾ�������ţ�ֵ0-�����ã�1-����
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;
//ʱ������������
typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{   
    DWORD  dwSize; //�ṹ���С
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/]; //���֧��8���������εĹ������ã����ڶ�ʱ��/�ش�����ֻ��Ҫʹ��һ���������ξͿ�����
    BYTE   byRes[64];  //����
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

//����ʱ�������������
typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD        dwSize; 
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE        byRes[256];  //����
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD        dwSize;
    BYTE        byBeforeAlarmPic;    //��Ӧ�ֱ����¿����ñ���ǰͼƬ�����4CIF��10�ţ�2CIF��20�ţ�CIF��40�ţ�QCIF��80�ţ�WD1:10��,XVGA:10��,720P:10��,1080P:10��
    BYTE        byAfterAlarmPic;    //��Ӧ�ֱ����¿����ñ�����ͼƬ����� 4CIF��10�ţ�2CIF��20�ţ�CIF��40�ţ�QCIF��80�ţ�WD1:10��,XVGA:10��,720P:10��,1080P:10��
    WORD          wInterval; //���ʱ�� ��λs
    BYTE        byResolution;    //ͼƬ�ֱ���1-CIF��2-2CIF��3-4CIF��4-QCIF��5-WD1��6-VGA,7-XVGA��8-720P��9-1080P
    BYTE           byRes[63];          // �����ֽ�
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

#define PRIOR_SCHEDTIME            30

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE    byEnable; //�Ƿ����� 0-�����ã�1-����
    BYTE byRes1[3];
    BYTE bySubSystem[32];//��ϵͳ���±��ʾ��ϵͳ�� 0-��֧�֣�1-֧��
    BYTE byMandatoryAlarm;//0-��ǿ�Ʋ�����1-ǿ�Ʋ��� ָ���������������Ƿ�Ϊ��·����
    BYTE byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType;     // 0-��,1-������2-����
    BYTE    byUploadAlarmRecoveryReport;    //�Ƿ��ϴ����������ָ����棬0-���ϴ���1-�ϴ� 
    BYTE    byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //��������������    BYTE            byAssociateSirenOut[8];        //������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ����� 
    BYTE    byAssociateSirenOut[8];        //������� ����0 ��ʾ����1 ֵΪ1��ʾ��� 0 ��ʾ����� 
    BYTE    byTamperResistor;    //������裬��λǧŷ �� 0-��Ч 1-2.2 ��2--3.3, 3-4.7 ��4-5.6 �� 5-8.2 ��0xff-�Զ���
    BYTE    byRes2[3];
    float    fTamperResistorManual;/*�����ֶ����裬1.0-10.0����ȷ��С�����һλ����λǧŷ��byTamperResistorΪ0xffʱ��Ч*/
    BYTE    byRes3[36];            // �����ֽ�
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;


typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byRes1;
    WORD    wRemoteCtrllerID;//ң������ ��1��ʼ
    BYTE    sDevSn[16];/*��Ʒ���к�*/
    BYTE    byArmRight;            /*0-�޲���Ȩ�ޣ�1-�в���Ȩ��*/
    BYTE    byDisArmRight;        /*0-�޳���Ȩ�ޣ�1-�г���Ȩ��*/
    BYTE    byArmReportRight;    /*0-�޴���������Ȩ�ޣ�1-�д���������Ȩ��*/
    BYTE    byDisArmReportRight;/*0-���ϴ���������Ȩ�ޣ�1-���ϴ���������Ȩ��*/
    BYTE    byClearAlarmRight;    /*0-������Ȩ�ޣ�1-������Ȩ��*/
    BYTE    bySubSystemID;       /* �豸(ң����)��ϵͳ��,1~8 */
    BYTE    byKeyboardAddr;      /* ���ռ��̵ĵ�ַ,�����ʱ���� */    
    BYTE    byEnableDel;   //ɾ��ң�����û���0-����ɾ����1-����ɾ��
    BYTE    byAlwaysOpenRight;   /*�Ƿ���������0-��Ч��1-������2-����*/
    BYTE    byOpeningDirection;   /*���ŷ���0-��Ч��1-���ŷ���2-���ŷ���*/
    BYTE    byRes3[2];
    BYTE    byName[NAME_LEN];    //ң��������
    BYTE    byRes2[28];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;


typedef struct tagNET_DVR_KEYBOARD_CFG
{
    DWORD    dwSize;
    BYTE    byEnableLock;        //�Ƿ����ü�������,0--������, 1--����
    BYTE    byErrorTimes;        //��������û��������������������̣�
    WORD    wLockTime;            //��������ʱ�䣬��λ��
    BYTE    byRes[128];
}NET_DVR_KEYBOARD_CFG, *LPNET_DVR_KEYBOARD_CFG;


typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD    dwSize;
    BYTE    byCommOperatorNum[NAME_LEN/*32*/];//ͨ����Ӫ�̺���
    BYTE    byQueryCode[16];//ҵ���ѯ����
    BYTE    byBusinessType;//ҵ������ 0-���ѣ�1-����
    BYTE    byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD    dwSize;
    BYTE    by3GBusiness[1024];//3Gҵ��ͨ�����Ų�ѯ
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD    dwSize;
    WORD    wdelayTime;//�ӳ�Ԥ��ʱ�䣬��λ����
    BYTE    byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD    dwSize;
    DWORD    dwDevNo;    //�豸��
    BYTE    byDevType;    //�����豸���� 0-����,1-��о,2-����ģ��,3-·���� ��4-������5-RS485������չģ�飬6-�¿�ģ�飬7-����ģ��,8-���ڹ���ģ��
    BYTE    byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD    dwSize;
    SHORT   nFloorNumber;    //���
    WORD    wRoomNumber;    //�����
    BYTE    byManageCenter;    //�Ƿ���й�������
    BYTE  byRes1[3];
    BYTE  byCalledName[64];    //��׼sipģʽ����Ч�������û���, ֧�����֡���ĸ����@���͡�.��
    BYTE  byRes[60];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD    dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

//��Ѷ������Ϣ
typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD    dwSize;
    BYTE    sCaseNo[INQUEST_CASE_NO_LEN];        //�������
    BYTE    sCaseName[INQUEST_CASE_NAME_LEN];    //�������ƣ�
    BYTE    sCustomInfo1[CUSTOM_INFO_LEN];        //�Զ�����Ϣ1��
    BYTE    sCustomInfo2[CUSTOM_INFO_LEN];        //�Զ�����Ϣ2��
    BYTE    sCustomInfo3[CUSTOM_INFO_LEN];        //�Զ�����Ϣ3
    BYTE    byShowCaseInfoTime; /* ������Ϣ��ʾʱ��,��λ��, ȡֵ��Χ1~60��*/
    BYTE    byShowCaseInfo;    //������ʼ�Ƿ���ʾ������Ϣ��0-����ʾ��1-��ʾ
    BYTE    byPosition;        //������ʾλ�ã�0-���ϣ�1-����
    BYTE    byRes1; //����
    BYTE    byCustomInfo4[CUSTOM_INFO_LEN];     //�Զ�����Ϣ4���������������ʱ���ֶ���Ч
    BYTE    byCustomInfo5[CUSTOM_INFO_LEN];     //�Զ�����Ϣ5����������������ʱ���ֶ���Ч
    BYTE    byRes[128]; //����
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD    dwSize;
    DWORD    dwChannel;//��Ѷͨ����
    BYTE    byShowCaseInfoTime;    //��ʾ����ʱ��
    BYTE    byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD    dwSize;
    /*����0: ��Ѷ��¼ɾ��Ȩ��*/
    BYTE    byLocalRight[MAX_RIGHT];    /* ����Ȩ�� */
    /*����0: Զ����ƵԤ��Ȩ��*/
    BYTE    byRemoteRight[MAX_RIGHT];/* Զ��Ȩ�� */ 
    BYTE    byNetAudioRight[MAX_CHANNUM_V40];    /* Զ����ƵԤ��Ȩ�ޣ������±��ʾͨ����ֵ��ʾ����Ȩ�ޣ�0-��Ȩ�ޣ�1-��Ȩ��*/
    BYTE    byRes[512*9];         //����9��Ȩ�޿���չ
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //�Ƿ����û�����0-�����ã�1-����
    BYTE    byRes1[3];    //����
    DWORD    dwMixCnt;  /*������ͨ����*/
    BYTE    bySrcChan[MAX_MIX_CHAN_NUM];    /*�����±��ʾ����ͨ���ţ�ģ��ͨ����IPͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
    BYTE    byLineIn[MAX_LINE_IN_CHAN_NUM];    /*�����±��ʾ����Line Inͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
    BYTE    byMic[MAX_MIC_CHAN_NUM];        /*�����±��ʾ����Micͨ����,��ֵ0��ʾ���죬��ֵ1��ʾ����*/
    BYTE    byMixAudioDelay;    //�����ӳ٣���λ��֡����Χ0-63
    BYTE    byRes2[127];    //����
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    NET_DVR_TIME_EX struStartTime; //��ʼʱ��
    BYTE   byReportType; //ͳ�Ʊ������ͣ�1-�ձ���2-�ܱ���3-�±���4-�걨��
    BYTE   byStatType; //��������ͳ�ƣ�Bit0-����Σ�Bit1-�Ա�Bit2-����
    BYTE   byEnableProgramStatistics; //�Ƿ񰴽�Ŀͳ�ƣ�0-��1-��
    BYTE   byRes1;
    DWORD  dwPlayScheduleNo; //����Ŀͳ��ʱ�������ճ̺�
    BYTE   byRes[120];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;//���꣨������
    DWORD    dwYouth;//���꣨������
    DWORD    dwMidLife;//���꣨������
    DWORD    dwElderly;//���꣨������
    DWORD    dwChild;//��ͯ��������
    DWORD    dwAdolescent;//�����꣨������
    DWORD    dwPrime;//׳�꣨������
    DWORD    dwMidage;//�����꣨������
    BYTE   byRes[48];
}NET_DVR_AGEGROUP_PARAM, *LPNET_DVR_AGEGROUP_PARAM;    

typedef struct tagNET_DVR_FILECOND_MEDICAL
{
    LONG lChannel;//ͨ����
    DWORD dwFileType;//¼���ļ�����
    //�������ţ�0xff��ȫ����0����ʱ¼��,1-�ƶ���� ��2������������3-����|�ƶ���� 4-����&�ƶ���� 5-����� 6-�ֶ�¼��,7-����¼��10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    //�����ţ�0xff��ȫ����0����ʱ¼��1-�ƶ���⣬2���ӽ�������3������������4������������5-�������6���ֶ�¼��7���𶯱�����8-����������9-���ܱ�����10-PIR������11-���߱�����12-���ȱ�����13-ȫ���¼���14-���ܽ�ͨ�¼�
    DWORD dwIsLocked;//�Ƿ����� 0-�����ļ�,1-�����ļ�, 0xff��ʾ�����ļ�
    DWORD dwUseCardNo;//�Ƿ�ʹ�ÿ���
    BYTE sCardNumber[32];//����
    NET_DVR_TIME_SEARCH_COND struStartTime;//��ʼʱ��
    NET_DVR_TIME_SEARCH_COND struStopTime;//����ʱ��
    char            szPatientID[64];
    DWORD        dwBigFileType;  // 0Ϊ��ͨƬ��������1Ϊ���ļ�����          
    BYTE          byRes[252];
}NET_DVR_FILECOND_MEDICAL, *LPNET_DVR_FILECOND_MEDICAL;

typedef struct tagNET_DVR_FIND_PICTURE_MEDICAL_PARAM
{
    DWORD  dwSize;         // �ṹ���С 
    LONG   lChannel;       // ͨ����
    /* ���ҵ�ͼƬ����:0��ʱץͼ1 �ƶ����ץͼ 2 ����ץͼ��
    3 ���� | �ƶ����ץͼ 4 ���� & �ƶ����ץͼ 6 �ֶ�ץͼ ,
    9-����ͼƬ,10- PIR������11- ���߱�����12- ���ȱ���,
    0xa Ԥ��ʱ��ͼ��0xd �������, 0xe Խ����⣬0xf ����������⣬
    0x10 ����������, 0x11-�豸���ػط�ʱ��ͼ, 0x12-�������,
    0x13-�����������,0x14-�뿪�������,0x15-�ǻ����,
    0x16-��Ա�ۼ����,0x17-�����˶����,0x18-ͣ�����,
    0x19-��Ʒ�������,0x1a-��Ʒ��ȡ���, 0x1b-�������,
    0x1c-���м��,0x1d-ȡ֤�¼�,0x1e-�����,0x1f-���ƻ����,
    0x20-��ֻ��⣬0x21-����Ԥ����0x22-���±���, 0x23����, 0x24Υͣ���,0x25-����ץ��,0x26-���߲��±���,0x2a-������,0x2b-�����ʸ�,0x2c-��޳�ʱ,0x2d-��ȫñ���,0x2e-�ܽ�ץ��,0x2f-����Ŀ��ץ��,0x30-����ץ�Ľ�ģ, 0x31-���Ŀ����,0x32-��������, 0x33-��������, 0x34-ҵ����ѯ,0x35-�Ƿ���̯,0xff- ȫ������*/
    BYTE   byFileType;
    BYTE   byNeedCard;     // �Ƿ���Ҫ����
    /*
    0-������1-�ģ�2-����3-�壬4-����5-�ʣ�6-����7-��
    8-��9-��10-����11-ԥ��12-�ڣ�13-����14-�棬
    15-����16-�գ�17-�ӣ�18-�ɣ�19-�ɣ�20-����21-�࣬
    22-³��23-����24-�£�25-����26-����27-̨��28-��
    29-�أ�30-�ۣ�31-�£�32-�ƣ�33-�㣬34-�0xff-ȫ��
    */
    BYTE   byProvince;     //ʡ������ֵ
    BYTE   byRes1;  //���ҽ�����Ƿ�Ҫ�󷵻�����������Ϣ��0-�����أ�1-����
    NET_DVR_TIME  struStartTime;//����ͼƬ�Ŀ�ʼʱ��
    NET_DVR_TIME  struStopTime;// ����ͼƬ�Ľ���ʱ��
    char     szPatientID[64];
    BYTE     byRes[256];
}NET_DVR_FIND_PICTURE_MEDICAL_PARAM, *LPNET_DVR_FIND_PICTURE_MEDICAL_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;//�У�������
    DWORD    dwFemale;//Ů��������
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;/*�����ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*�������ʱ��*/
    BYTE   byStatType;//��������ͳ�ƣ�Bit0-�������Ч��Bit1-�Ա���Ч��Bit2-������Ч
    BYTE   byRes[7];
    DWORD  dwPeopleNum;//����ͳ��
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;//���������ͳ��
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;//�Ա�����ͳ��
    NET_DVR_PROGRAM_INFO struProgramInfo;        //��Ŀ��Ϣ
    BYTE   byRes1[76];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

//��ȡ��ͨ���������ṹ 
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
    DWORD  dwSize;
    /*
    Bit0-ͨ����Ч 
    Bit1-ʱ����Ч
    Bit2-���ƺ���Ч
    Bit3-����������Ч
    Bit4-������ɫ��Ч
    Bit5-������ɫ��Ч
    Bit6-����������Ч
    Bit7-����Ʒ����Ч
    Bit8-��������Ч
    Bit9-��ⷽ����Ч
    Bit10-����ٶ���Ч
    Bit11-����ٶ���Ч
    Bit12-����������Ч
    Bit13-���ط�ʽ������Ч
    Bit14-Υ��ȡ֤��Ч
    Bit15-�¼�������Ч
    Bit16-ȡ֤������Ч
    */
    DWORD  dwQueryCond;//��ѯ���� 0��ʾ��Ч��1��ʾ��Ч
    DWORD  dwChannel;//Ĭ����1��[1~32]��bit0��ʾͨ��1����������bit31��ʾͨ��32��
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    char  sLicense[MAX_LICENSE_LEN/*16*/];//(�豸֧��ģ����ѯ, GB2312����)
    /*
    Bit0-δ֪��������
    Bit1-��׼���ó������ 
    Bit2-02ʽ���ó���     
    Bit3-�侯��           
    Bit4-����             
    Bit5-���ó�˫��β��   
    Bit6-ʹ�ݳ���         
    Bit7-ũ�ó�           
    Bit8-Ħ�г�    
    */
    DWORD  dwPlateType;//�������ͣ�֧�ְ�λ��ʾ�����Ը�ѡ��
    /*
    Bit0-δ֪��������
    Bit1-��ɫ
    Bit2-��ɫ
    Bit3-��ɫ
    Bit4-��ɫ
    Bit5-��ɫ    
    */
    DWORD  dwPlateColor;//������ɫ��֧�ְ�λ��ʾ�����Ը�ѡ��
    /*
    Bit0-δ֪��������
    Bit1-��ɫ
    Bit2-��ɫ
    Bit3-��ɫ
    Bit4-��ɫ
    Bit5-��ɫ
    Bit6-����ɫ    
    Bit7-��ɫ
    Bit8-��ɫ
    Bit9-��ɫ
    Bit10-��ɫ
    Bit11-��ɫ
    Bit12-��ɫ    
    Bit13-���ɫ    
    */
    DWORD  dwVehicleColor;//������ɫ��֧�ְ�λ��ʾ�����Ը�ѡ��
    /*
    Bit0-δ֪��������
    Bit1-�ͳ�
    Bit2-�����
    Bit3-�γ�
    Bit4-�����
    Bit5-С����
    Bit6-����
    Bit7-���ֳ�
    Bit8-���ֳ�
    Bit9-SUV/MPV
    Bit10-���Ϳͳ�
    */
    DWORD  dwVehicleType;//�������ͣ�֧�ְ�λ��ʾ�����Ը�ѡ��
     /**
    Bit0-������������
    Bit1-����
    Bit2-����
    Bit3-����
    Bit4-�����
    Bit5-ѹ������
    Bit6-��������
    Bit7-·������
    Bit8-��ռ��
    Bit9-Υ�����
    Bit10-��������
    Bit11-Υ������
    Bit12-·��ͣ��
    Bit13-�̵�ͣ��
    Bit14-δ��������
    Bit15-Υ��ͣ��
    Bit16-Υ�µ�ͷ
    Bit17-ռ��Ӧ������
    Bit18-δϵ��ȫ�� 
    */
    DWORD dwIllegalType;
    /**
    Bit0-������������
    Bit1-ӵ��
    Bit2-ͣ��
    Bit3-����
    Bit4-����
    Bit5-������
    Bit6-����
    Bit7-ѹ��
    Bit8-������
    Bit9-����
    Bit10-���
    Bit11-��ͷ
    Bit12-��ռ��
    Bit13-���� 
    */
    DWORD dwEventType;
    /**
    Bit0-������������
    Bit1-���й�·Υ��ͣ��
    Bit2-���ٹ�·Υ��ͣ��
    Bit3-ѹ��
    Bit4-����
    Bit5-Υ�����
    Bit6-��ռ��
    */
    DWORD  dwForensiceType;
    WORD   wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" ������ѡ��
    BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
    BYTE   byDirection;//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ�����    
    WORD   wMinSpeed;//����ٶȣ�0~999����λkm/h
    WORD   wMaxSpeed;//����ٶȣ�0~999����λkm/h
    BYTE   byDataType;//�������� 0-�������ݣ�1-Υ�����ݣ�2-��ͨ�¼���3-ȡ֤���� ������ѡ��
    BYTE   byExecuteCtrl;//���� 0-��������1-��������0xff-����
    BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

//��ͨͼƬ�����ӽṹ
typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30     struRelativeTime; //ץ�����ʱ��
    NET_DVR_TIME_V30    struAbsTime;  //ץ�ľ���ʱ��
    char szPicName[PICTURE_NAME_LEN/*64*/];
    BYTE  byPicType;//ͼƬ���� 0-����ͼ��1-ץ��ԭͼ��2-�ϳ�ͼ��3-��дͼ
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

//��ͨ���ݽṹ��
typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
    DWORD  dwSize;
    DWORD  dwChannel;//Ĭ����1��[1~32]��
    char  sLicense[MAX_LICENSE_LEN/*16*/];
    /*
    Bit0-δ֪��������
    Bit1-��׼���ó������ 
    Bit2-02ʽ���ó���     
    Bit3-�侯��           
    Bit4-����             
    Bit5-���ó�˫��β��   
    Bit6-ʹ�ݳ���         
    Bit7-ũ�ó�           
    Bit8-Ħ�г�    
    */
    DWORD  dwPlateType;//��������
    /*
    Bit0-δ֪��������
    Bit1-��ɫ
    Bit2-��ɫ
    Bit3-��ɫ
    Bit4-��ɫ
    Bit5-��ɫ    
    */
    DWORD  dwPlateColor;//������ɫ
    /*
    Bit0-δ֪��������
    Bit1-��ɫ
    Bit2-��ɫ
    Bit3-��ɫ
    Bit4-��ɫ
    Bit5-��ɫ
    Bit6-����ɫ    
    Bit7-��ɫ
    Bit8-��ɫ
    Bit9-��ɫ
    Bit10-��ɫ
    Bit11-��ɫ
    Bit12-��ɫ    
    Bit13-���ɫ    
    */
    DWORD  dwVehicleColor;//������ɫ
    /*
    Bit0-δ֪��������
    Bit1-�ͳ�
    Bit2-�����
    Bit3-�γ�
    Bit4-�����
    Bit5-С����
    Bit6-����
    Bit7-���ֳ�
    Bit8-���ֳ�
    Bit9-SUV/MPV
    Bit10-���Ϳͳ�
    Bit11-������
    Bit12-�ǻ�����
    Bit13-С�ͽγ�
    Bit14-΢�ͽγ�
    Bit15-Ƥ����
    Bit16-��װ�俨��
    Bit17-΢�������忨
    Bit18-������
    Bit19-���������̳�
    Bit20-�͹޳�
    Bit21-���������賵
    Bit22-ƽ���ϳ�
    Bit23-����γ�
    Bit24-����γ�
    Bit25-����
    Bit26-С�Ϳͳ�
    */
    DWORD  dwVehicleType;//��������
    /**
    Bit0-������������
    Bit1-����
    Bit2-����
    Bit3-����
    Bit4-�����
    Bit5-ѹ������
    Bit6-��������
    Bit7-·������
    Bit8-��ռ��
    Bit9-Υ�����
    Bit10-��������
    Bit11-Υ������
    Bit12-·��ͣ��
    Bit13-�̵�ͣ��
    Bit14-δ��������
    Bit15-Υ��ͣ��
    Bit16-Υ�µ�ͷ
    Bit17-ռ��Ӧ������
    Bit18-δϵ��ȫ�� 
    */
    DWORD dwIllegalType;
    /**
    Bit0-������������
    Bit1-ӵ��
    Bit2-ͣ��
    Bit3-����
    Bit4-����
    Bit5-������
    Bit6-����
    Bit7-ѹ��
    Bit8-������
    Bit9-����
    Bit10-���
    Bit11-��ͷ
    Bit12-��ռ��
    Bit13-���� 
    */
    DWORD dwEventType;
    /**
    Bit0-������������
    Bit1-���й�·Υ��ͣ��
    Bit2-���ٹ�·Υ��ͣ��
    Bit3-ѹ��
    Bit4-����
    Bit5-Υ�����
    Bit6-��ռ��
    */
    DWORD dwForensiceType;
    WORD  wVehicleLogoRecog;  //������Ʒ�ƣ��ο�"������Ʒ��.xlsx" 
    BYTE  byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
    BYTE  byDirection;//��ⷽ��1-���У�2-���У�3-˫��4-�ɶ�������5-������,6-�����򶫣�7-�ɱ�����    
    WORD  wSpeed;//�ٶȣ�0~999����λkm/h
    BYTE  byDataType;//��������: 0-���� 1-Υ�� 2-�¼� 3-ȡ֤
    BYTE  byRes[253];
    NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

//�����ӻ�ȡ��ͨ���������ṹ
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
    DWORD  dwSize;
    /**
    Bit0-ͨ����Ч
    Bit1-ʱ����Ч
    Bit2-��������Ч
    */
    DWORD  dwQueryCond;//��ѯ���� 0-������
    DWORD  dwChannel;//Ĭ����1��[1~32]��bit0��ʾͨ��1����������bit31��ʾͨ��32��
    DWORD  dwResChan[10];//Ԥ������չ��ͨ����
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��
    BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

//�����ӻ�ȡ��ͨ�����ṹ
typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
    DWORD  dwSize;
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    DWORD  dwChannel;//Ĭ����1��[1~32]��
    DWORD  dwFlow;//������
    BYTE   byLaneNo;//�����ţ�0~255,0�ų��� ��ʾ ������δ֪��    
    BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

//ͼƬ����
typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //ͼƬ���ͣ�0-jpg
    BYTE   byRes1[3];        //����
    DWORD  dwPicWidth;       //ͼƬ���
    DWORD  dwPicHeight;      //ͼƬ�߶�
    DWORD  dwPicDataLen;     //ͼƬ���ݴ�С
    char*  byPicDataBuff;    //ͼƬ���ݻ�����
    BYTE   byRes2[32];       //����
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD       dwSize;//�ṹ���С
    BYTE       byEnable;       //�����Ƿ����ã� 0-�����ã�1-����
    BYTE       byRuleID;       //�����Ĺ���ID
    BYTE       byColorBlockNo;  //��ɫ����ţ���1��ʼ
    BYTE       byRes1;      //����
    NET_DVR_PIC_INFO  struPicInfo;  //ͼƬ��ɫ��Ϣ
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD        dwSize;//�ṹ���С
    DWORD     dwChannel;     //ͨ����
    BYTE        byRuleID;       //�����Ĺ���ID  0��ʾ������
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

//LLDP����
typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //����
    BYTE byPortNo;      //�˿ں�
    BYTE byEnabledTx;   //ʹ�ܷ���lldp����0-��ʹ�ܣ�1-ʹ��
    BYTE byEnabledRx;   //ʹ�ܽ���lldp����0-��ʹ�ܣ�1-ʹ��
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //ʹ��LLDP���ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //����ʱ�䣬��λ����
    DWORD dwReiniTime;  //���³�ʼ��ʱ�䣬��λ����
    DWORD dwPacketTime; //���ʱ�䣬��λ����
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //���˿�LLDP����
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

//�����շ���������Ϣ
typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //�˿ںţ�0-��Ч
    BYTE  byPortName[NAME_LEN];  //�˿���
    BYTE  byWorkMode;            //����ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byBandWidth;           //����1-100M��2-1G��3-10G
    BYTE  byPortType;            //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];      //�ͺ�����
    BYTE  bySerialNo[SERIALNO_LEN];  //���к�
    BYTE  bySoftwareVersion[VERSION_LEN]; //����汾
    NET_DVR_IPADDR struIPAddr;           //IP��ַ
    DWORD dwSlotNo;    //���ܿ���λ�ţ�����λ��
    BYTE  byStructureType;           //�ṹ���ͣ�1-2U��2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //��������Ϣ
    BYTE  byRes2[32];    
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                 //���ţ���1��ʼ
    BYTE  byTypeName[NAME_LEN];     //�ͺ�����
    BYTE  bySerialNo[SERIALNO_LEN]; //���к�
    BYTE  bySoftwareVersion[VERSION_LEN]; //����汾
    DWORD dwMainSlot;               //����λ����1��ʼ
    BYTE  byStructureType;          //�ṹ���ͣ�1-2U��2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //���˿ڲ���
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType;                                       //��Դ���ͣ�1-����Դ��2-˫��Դ
    BYTE  byRes1[3];
    DWORD dwSlotNum;                                             //���ܿ���λ�ţ�����λ��
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //���ܿ���Ϣ
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //���ܿ���Ϣ
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

//�����շ�������״̬��Ϣ
typedef struct tagNET_DVR_CARD_PORT_STATE
{
    BYTE  byValid;                 //�Ƿ���Ч��0-��Ч��1-��Ч
    BYTE  byPortType;            //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byLinkState;           //����״̬��0-δ���ӣ�1-������
    BYTE  byRes1;
    DWORD dwSendBytes;           //���͵��ֽ���
    DWORD dwRecvBytes;           //�������ݰ���
    DWORD dwRecvLostPackets;     //���ն�����
    DWORD dwRecvCrcErrPackets;   //����CRCУ��������
    DWORD dwRecvFragmentPackets; //������Ƭ����ͻ�������ֽڰ����������Ⱦ�С��64�ֽڣ�
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
    NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];    //���˿�״̬    
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
    BYTE  byEnabled;    //�˽ṹ�Ƿ���Ч��0-��Ч��1-��Ч
    BYTE  byRes1[3];
    DWORD dwCardNo; //����
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];    
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //���ܿ�״̬
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //���ܿ�״̬
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

//Զ�������շ���1.0 ������Ϣ
typedef struct tagNET_DVR_NETMGR_CARD_INFO_V50
{
    BYTE byMainSlotNo;                        //���ܿ���λ�ţ�����λ��
    BYTE byRes1[3];
    BYTE byTypeName[NAME_LEN];            //�ͺ�����
    BYTE bySerialNo[SERIALNO_LEN];            //���к�
    BYTE bySoftwareVersion[VERSION_LEN];    //����汾
    BYTE byHardwareVersion[VERSION_LEN];    //Ӳ���汾
    NET_DVR_IPADDR struIPAddr;                //IP��ַ
    NET_DVR_IPADDR struMask;                //��������
    NET_DVR_IPADDR struGateway;                //Ĭ������
    BYTE byMacAddr[6];                        //MAC��ַ
    BYTE bySlotNums;                        //��λ��
    BYTE byStructureType;                       //�ṹ���ͣ�1-2U��2-4U
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //���˿���Ϣ
    BYTE byRes2[64];
}NET_DVR_NETMGR_CARD_INFO_V50, *LPNET_DVR_NETMGR_CARD_INFO_V50;

typedef struct tagNET_DVR_FUNC_CARD_INFO_V50
{
    BYTE byCardNo;                          //���տ�����
    BYTE byMainSlotNo;						//���տ���λ�ţ�����λ��
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            //�ͺ�����
    BYTE bySerialNo[SERIALNO_LEN];            //���к�
    BYTE bySoftwareVersion[VERSION_LEN];    //����汾
    BYTE byIsVerMismatch;                    //����汾�����ܿ��б��ش洢������汾�Ƿ�һ�£�0-ƥ�䣬!0-��ƥ��
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    //���µ�����汾���汾��ƥ��ʱ��Ч
    BYTE byHardwareVersion[VERSION_LEN];    //Ӳ���汾
    BYTE bySlotNums;                        //��λ��
    BYTE byStructureType;                       //�ṹ���ͣ�1-2U��2-4U
    BYTE byRes3[2];
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //���˿���Ϣ
    BYTE byRes4[64];
}NET_DVR_FUNC_CARD_INFO_V50, *LPNET_DVR_FUNC_CARD_INFO_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_INFO_V50
{
    BYTE byCardNo;                              //���ţ����ͻ����ӵĽ��տ��Ŀ���
    BYTE byMainSlotNo; 							//��λ�ţ����ͻ����ӵĽ��տ�������λ��
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            //�ͺ�����
    BYTE bySoftwareVersion[VERSION_LEN];    //����汾
    BYTE byIsVerMismatch;                    //����汾�����ܿ��б��ش洢������汾�Ƿ�һ�£�0-ƥ�䣬!0-��ƥ��
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    //���µ�����汾���汾��ƥ��ʱ��Ч
    BYTE byHardwareVersion[VERSION_LEN];    //Ӳ���汾
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //���˿���Ϣ
    BYTE byRes3[64];
}NET_DVR_REMOTE_SEND_CARD_INFO_V50, *LPNET_DVR_REMOTE_SEND_CARD_INFO_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC_V50
{
    DWORD dwSize;
    BYTE byPowerType;    //��Դ���ͣ�1-����Դ��2-˫��Դ
    BYTE byRes1[3];
    DWORD dwSlotNum;    //�����ܲ�λ��
    NET_DVR_NETMGR_CARD_INFO_V50 struNetCardInfo;    //���ܿ���Ϣ
    NET_DVR_FUNC_CARD_INFO_V50 struFuncCardInfo[MAX_FUNC_CARD_NUM];    //���տ���Ϣ
    NET_DVR_REMOTE_SEND_CARD_INFO_V50 struRemoteSendCardInfo[MAX_FUNC_CARD_NUM];    //���ͻ���Ϣ
    BYTE byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC_V50, *LPNET_DVR_FIBER_CONVERT_BASIC_V50;

//Զ�������շ���1.0 ״̬��Ϣ
typedef struct tagNET_DVR_CARD_PORT_STATE_V50
{
    BYTE byPortNo;                    //�˿ںţ���1��ʼ
    BYTE byPortType;                //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE byLinkState;               //����״̬��0-δ���ӣ�1-������
    BYTE byPortSpeed;                 //����0-��Ч��1-�Զ���2-100M��3-1000M��4-10G
    BYTE byPortDuplexMode;             //�˿�˫��ģʽ��0-��Ч��1-�Զ���2-ȫ˫����3-��˫��
    BYTE byRes1[3];
    BYTE byPortName[NAME_LEN];         //�˿�����
    DWORD dwSendBytes;              //���͵��ֽ���
    DWORD dwSendByteSpeed;            //�����ֽ����ʣ���λ��bps
    DWORD dwSendPackets;             //���͵��ֽ���
    DWORD dwSendPacketSpeed;        //�������ʣ���λ����/��
    DWORD dwRecvBytes;              //���յ��ֽ���
    DWORD dwRecvByteSpeed;            //�����ֽ����ʣ���λ��bps
    DWORD dwRecvPackets;             //���յİ���
    DWORD dwRecvPacketSpeed;        //�հ����ʣ���λ����/��
    DWORD dwRecvLostPackets;        //���ն�����
    DWORD dwRecvCrcErrPackets;         //����CRCУ��������
    DWORD dwRecvFragmentPackets;    //������Ƭ����ͻ�������ֽڰ����������Ⱦ�С��64�ֽڣ�
    BYTE byRes2[48];
}NET_DVR_CARD_PORT_STATE_V50, *LPNET_DVR_CARD_PORT_STATE_V50;

typedef struct tagNET_DVR_NET_CARD_STATE_V50
{
    BYTE byMainSlotNo;     //���ܿ�����λ��
    BYTE byRes1[3];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO]; //���ܿ��˿�״̬
    BYTE byRes2[344];
}NET_DVR_NET_CARD_STATE_V50, *LPNET_DVR_NET_CARD_STATE_V50;

typedef struct tagNET_DVR_FUNC_CARD_STATE_V50
{
    BYTE byCardNo;      //���տ�����
    BYTE byMainSlotNo; 	//���տ�����λ��
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    //���տ��˿�״̬
    BYTE byRes2[64];
}NET_DVR_FUNC_CARD_STATE_V50, *LPNET_DVR_FUNC_CARD_STATE_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_STATE_V50
{
    BYTE byCardNo;	    //���ͻ����ӵĽ��տ��Ŀ���
    BYTE byMainSlotNo; 	//���ͻ����ӵĽ��տ�������λ��
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    //���տ��˿�״̬
    BYTE byRes[64];
}NET_DVR_REMOTE_SEND_CARD_STATE_V50, *LPNET_DVR_REMOTE_SEND_CARD_STATE_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE_V50
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE_V50 struNetCardState;    //���ܿ�״̬
    NET_DVR_FUNC_CARD_STATE_V50 struFuncCardState[MAX_FUNC_CARD_NUM];    //���տ�״̬  
    NET_DVR_REMOTE_SEND_CARD_STATE_V50 struRemoteSendCardState[MAX_FUNC_CARD_NUM];    //���ͻ�״̬
    BYTE  byRes[64];
}NET_DVR_FIBER_CONVERT_STATE_V50, *LPNET_DVR_FIBER_CONVERT_STATE_V50;

//�����շ���������Ϣ
typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //�˿ںţ�0-��Ч����0Ϊ���ܿ��˿ں�
    BYTE  byPortType;               //�˿����ͣ�1-��ڣ�2-��ڣ�3-��縴�ÿ�
    BYTE  byLocalWorkMode;          //���ع���ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byLocalBandWidth;         //���ش���1-100M��2-1G��3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //�Զ��豸��������
    BYTE  byPeerMac[MACADDR_LEN];   //�Զ�MAC��ַ
    DWORD dwPeerPortNo;             //�Զ˶˿ں�
    BYTE  byPeerWorkMode;           //�Զ˹���ģʽ��1-ACCESS��2-TRUNK��3-HYPRID
    BYTE  byPeerBandWidth;          //�Զ˴���1-100M��2-1G��3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;                    //�˽ṹ���Ƿ���Ч��0-��Ч����0-��Ч
    BYTE  byRes1[3];
    DWORD dwCardNo;                 //���ţ�0-���ܿ�������0-���ܿ�
    DWORD dwSlotNum;                //��ռ�õĲ�λ��
    BYTE  byTypeName[NAME_LEN];        //����������
    BYTE  byLocalMac[MACADDR_LEN];  //����MAC��ַ
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //���˿�������Ϣ
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM]; //����������Ϣ
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

//�����շ����˿�ע����Ϣ
typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //��λ��
    DWORD dwPortNo; //�˿ں�
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
    DWORD dwSize;
    BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //���ض˿�ע����Ϣ
    BYTE  byPeerRemarks[MAX_REMARKS_LEN]; //�Զ˶˿�ע����Ϣ
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;

typedef enum _EN_FIBER_CONVERT_ALARM
{
    FC_OPTICAL_PORT_LOST = 1,
    FC_ELECTRICAL_PORT_LOST,
    FC_FUNC_CARD_LOST,
    FC_CARD_DISCONNECTED, //�����߸澯
    FC_MAX_TEMP_LIMITED, //�¶ȳ����޸澯
    FC_MIN_TEMP_LIMITED, //�¶ȳ����޸澯
    FC_MAX_VOLTAGE_LIMITED, //��ѹ�����޸澯
    FC_MIN_VOLTAGE_LIMITED, //��ѹ�����޸澯
}EN_FIBER_CONVERT_ALARM;

typedef enum _EN_FIBER_CONVERT_NOTIFICATION
{
    FC_OPTICAL_PORT_CONNECTED = 1,
    FC_ELECTRICAL_PORT_CONNECTED,
    FC_FUNC_CARD_INSERT,
    FC_CARD_CONNECTED, //������֪ͨ
    FC_TEMP_RECOVERY, //�¶Ȼָ�֪ͨ
    FC_VOLTAGE_RECOVERY, //��ѹ�ָ�֪ͨ
}EN_FIBER_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;        //�¼����ͣ�1-�澯��2-֪ͨ
    DWORD dwEvent;          //�����¼����澯ʱ�ο�ö��FIBER_CONVERT_ALARM��֪ͨʱ�ο�ö��FIBER_CONVERT_NOTIFICATION
    BYTE bySlotNum;         //��λ�ţ���������Ϊ���ͻ�ʱ����λ��Ϊ�÷��ͻ����ӵĽ��տ��Ĳ�λ�ţ�����澯��֪ͨʱ��Ч
    BYTE byCardType;        //�����ͣ�0-��Ч��1-���ܿ���2-���տ���3-���ͻ���4-����
    BYTE byPortNo;          //�˿ںţ���1��ʼ������澯��֪ͨʱ��Ч
    BYTE byCurTemperature;  //�����¼����¶ȣ��¶ȸ澯��֪ͨʱ��Ч����λ�����϶�
    WORD wCurVoltage;      //�����¼��ĵ�ѹ��ʵ�ʵ�ѹ*10������ѹ�澯��֪ͨʱ��Ч����λ������
    BYTE byRes1[30];
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;

//�������澯�¼��ϴ�
typedef enum _EN_SWITCH_CONVERT_ALARM
{
    SC_OPTICAL_PORT_LOST = 1,
    SC_NETWORK_PORT_LOST,
	SC_WIRELESS_SPEED_UP_EXCEPTION,//�������������쳣
	SC_WIRELESS_SHUTDOWN,  //�������ӶϿ��¼�
	SC_DEVICE_POE_MAX,  //POE-MAX�澯
	SC_PORT_POE_POWER_OFF,  //�˿�POE����澯
}EN_SWITCH_CONVERT_ALARM;

typedef enum _EN_SWICH_CONVERT_NOTIFICATION
{
    SC_OPTICAL_PORT_CONNECTED = 1,
    SC_NETWORK_PORT_CONNECTED,
	SC_DEVICE_POE_MAX_RECOVERY,   //POE-MAX�澯�ָ�
	SC_PORT_POE_POWER_ON,    //�˿�POE�ϵ�֪ͨ
	SC_WIRELESS_CONNECTED,  //���������¼�
}EN_SWITCH_CONVERT_NOTIFICATION;

typedef struct tagNET_DVR_SWITCH_CONVERT_ALARM
{
    DWORD dwSize;
    BYTE  byPortNo;    //�ӿ���������1��ʼ
    BYTE  byRes1[3];
    DWORD dwEventType; //�¼����ͣ�1-�澯��2-֪ͨ
    DWORD dwEvent;     //�����¼����澯ʱ�ο�ö��EN_SWITCH_CONVERT_ALARM��֪ͨʱ�ο�ö��EN_SWITCH_CONVERT_NOTIFICATION
    BYTE  byRes2[32];
}NET_DVR_SWITCH_CONVERT_ALARM, *LPNET_DVR_SWITCH_CONVERT_ALARM;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE       byEnable;       //�����Ƿ����ã� 0-�����ã�1-����
    BYTE       byTriggerMode; // 1-����������2-���δ���
    BYTE       byUploadPic;   //0-���ϴ�ͼƬ��1-�ϴ�ͼƬ
    BYTE       byRes1;        //����
    DWORD      dwTimeInterval; //������������ʱ��������Χ[0,3600]����λ����
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;//����ʽ
    BYTE       byRelRecordChan[MAX_IVMS_IP_CHANNEL];    //����������¼��ͨ����1��ʾ������ͨ����0��ʾ������
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//���ʱ��
    BYTE       byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD        dwSize;//�ṹ���С
    NET_VCA_DEV_INFO    struDevInfo;        //�豸��Ϣ
    NET_DVR_TIME_EX     struTime;           //����ʱ��
    BYTE                byLampStatus;       //���ص�״̬��0-�ѹر�  1-�Ѵ�
    BYTE                byRes1[3];          //����
    DWORD               dwPicDataLen;       //ͼƬ���ݳ��ȣ���0��ʾ��ͼƬ�ϴ�
    char*               pPicData;           //ͼƬ����
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

//�����ռ�������
typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
    DWORD    dwSize; 
    BYTE    byDevAddr;    //�豸��ַ��0-������1-15Ϊ�ӻ�
    BYTE    byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

//˽�йؼ���Ϣ�ϴ�����
typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD          dwSize;   
    NET_DVR_IPADDR     struIP; //��Ϣ�ϴ���IP��ַ
    WORD          wPort;//��Ϣ�ϴ��Ķ˿ں�
    BYTE          byEnable;//ʹ��,  0-������1-�����ã�2-����
    BYTE        byRes;
    DWORD        dwInterval;//��Ϣ�ϴ����(0-��ʱ�������ƣ����豸Ϊ׼; >=0,����Ϊ��λ��ʱ����)
    BYTE         byServerType;//�������� 0-�ޣ�1-����
    BYTE         byEcryptedSMSEnable;//0-�����ܣ�1-����
    BYTE         byAlgorithm;//�����㷨��0-�ޣ�1-RSA
    BYTE         byAcauisitionMode;//�ɼ�ģʽ��0-������Ϣ��1-���������Ϣ��2-������Ϣ+���������Ϣ
    DWORD        dwDistanceLimit;//�������ƣ���λ��m
    BYTE         byPKModeEnable;//PKģʽʹ��,  0-������1-�����ã�2-����
    BYTE         byMACAddrReductionEnable;//MAC��ַ��ԭʹ��,  0-������1-�����ã�2-����
    BYTE         byRes1[214];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//��Կ����
    char         szSecretKey[MAX_SECRETKEY_LEN/*512*/];//��Կ
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

//��������
typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD     dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

//������Ϣ
typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD     dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;



#define MAX_SSID_LEN    32   //SSID�ų���
#define MAX_WS_PASSWD_LEN    64   //���볤��
typedef    struct tagNET_DVR_WIRELESSSERVER
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byWLanShare;//WLan�ȵ�ʹ�� 0-�رգ�1-ʹ��
    BYTE        byBroadcastSSID;//SSID�㲥ʹ�� 0-�رգ�1-ʹ��
    BYTE        bySecurityMode;//��ȫģʽ 0- not-encrypted��1-WPA��2-WPA2(��ʱֻ֧��2)
    BYTE        byAlgorithmType; //����ģʽ 1-TKIP��2-AES
    char        szSSID[MAX_SSID_LEN/*32*/];//SSID����Ϣ
    char        szPassWord[MAX_WS_PASSWD_LEN/*64*/];
    BYTE        byDefaultPassword;//�Ƿ���Ĭ������ 0-��1-��
    BYTE      	byWifiApModeType;//����WlanAP�ȵ�ģʽ��0-�رգ�1-������2-�Զ�
    BYTE        byRes[254];
}NET_DVR_WIRELESSSERVER,*LPNET_DVR_WIRELESSSERVER;

typedef    struct tagNET_DVR_CONNECTDEV_COND
{
    DWORD       dwSize;
    DWORD        dwChannel;
    BYTE        byRes[128];
}NET_DVR_CONNECTDEV_COND,*LPNET_DVR_CONNECTDEV_COND;

typedef    struct tagNET_DVR_CONNECTDEV_CFG
{
    DWORD       dwSize;
    BYTE        byID;//���к�
    BYTE        byRes[1];
    BYTE        byMACAddr[MACADDR_LEN/*6*/];    // �����ַ
    NET_DVR_IPADDR    struDVRIP;//�豸IP
    NET_DVR_TIME  struConnectTime;//����ʱ��
    BYTE        byRes1[256];
}NET_DVR_CONNECTDEV_CFG,*LPNET_DVR_CONNECTDEV_CFG;

typedef struct tagNET_DVR_GIS_SERVER_INFO
{
    BYTE  byUserName[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struServerIP;     //GIS������IP��ַ
    WORD  wPort;    //GIS�������˿�
    BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
    DWORD dwSize;
    BYTE  byEnable;        //�Ƿ���ʾ��1-��ʾ��0-����    
    BYTE  byBaseMapType;    //��ͼ���ͣ�1-ͼƬ��ͼ��2-�����������ͼ��3-GIS��ͼ
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     //��ͼ�ţ���ͼ����Ϊ1ʱ���˲���ΪͼƬ��ţ���ͼ����Ϊ2ʱ�˲���Ϊ������������ϵͳ����ںţ�1�ֽھ����+1�ֽ��Ӱ��+1�ֽ�����ں�+1�ֽڱ�����
    NET_DVR_GIS_SERVER_INFO struGisServer;    //GIS��������Ϣ,����ͼ����ΪGIS��ͼʱ��Ч
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{    
    DWORD        dwSize;                   //NET_DVR_VIDEO_IMG_DB_CFG�ṹ���С
    INT64       i64Capacity;             //��ͼ������������λ����λ��MB
    INT64        i64UsedSpace;            //ֻ�������ÿռ䣬��λ����λ��MB
    INT64        i64AvailableSpace;        //ֻ�������ÿռ䣬��λ����λ��MB
    BYTE          byRes[256];                //����
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{    
    DWORD        dwSize;                   //NET_DVR_FILE_QUERY_INFO�ṹ���С
    INT64       i64FileLen;             //�ļ���С
    BYTE          byRes[256];                //����
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char        szFileID[MAX_FILE_ID_LEN];        //�ϴ�֮���豸������ļ�ID
    BYTE        byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD     dwType;            //����, 0-������Ϣ,1-����ͼƬ��Ϣ(�ƴ洢��������),2-ͼƬ������Ϣ(�ƴ洢��������)
    BYTE    *pData;            //����ָ��
    DWORD   dwDataLen;        //���ݳ���
    void*   pFileInfo;        //�ļ���Ϣ�ṹ��(�ƴ洢��������ʱ��Ч)
    DWORD   dwFileInfoLen;    //�ļ���Ϣ�ṹ�峤��(�ƴ洢��������ʱ��Ч)
    BYTE    byRes[120];        //����
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef BOOL (*DOWNLOAD_DATA_CB)( LONG lHandle, NET_DOWNLOAD_CB_INFO *pCBInfo, void *pUserData);

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //�������ݻص�����
    void                 *pUserData;            //�û�����, ��fnPreviewDataCB�ص�����
    INT64                i64Offset;        //�����ļ���ƫ���������ڶϵ�����
    BYTE                   byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64    i64FileLen;             //�ϴ����ļ�����Ҫ�����ļ����ȣ��ļ��������Բ���
    BYTE    byContinueUpload;     //0-���ļ��ϴ���1-���ļ��������ļ����������
    BYTE       byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;


typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char    szFileID[MAX_FILE_ID_LEN];        //�ϴ�֮���豸������ļ�ID
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;

typedef struct tagNET_DVR_SEND_PARAM_IN
{
    BYTE    *pSendData;             //���͵Ļ�����,PicURL == 1 ��ʱ���ڴ��д洢���� URL �ַ���,byUploadModeling == 1 ��ʱ���ڴ��д洢���� ��ģbase64��������
    DWORD    dwSendDataLen;         //�������ݳ���,PicURL == 1 ��ʱ�򣬱�ʾ�� URL �ַ����ĳ���,byUploadModeling == 1 ��ʱ�򣬱�ʾΪ��ģ����base64��ļ��ܳ���
    NET_DVR_TIME_V30    struTime;   //ͼƬʱ��
    BYTE    byPicType;              //ͼƬ��ʽ,1-jpg,2-bmp,3-png,4-SWF,5-GIF
    BYTE    byPicURL;               //ͼƬ���ݲ���URL��ʽ 0-������ͼƬ���ݣ�1-ͼƬ������URL��ʽ
    /*�Ƿ��ϴ���ģ���ݣ�
    0-	������ͼƬ���ݷ�ʽ(pSendDataָ�������ͼƬ����, dwPicDataLenΪͼƬ���������ݳ���)��
    1-	ֱ���ϴ���ģ����(pSendDataָ��ģbase64��������, dwPicDataLenΪ��ģ����base64��ļ��ܳ���)��
    ע����ģ���ݲ���base64���ܷ�ʽ,ѡ��Ϊ��ģ�����ϴ���byPicURL ���衣
    ����/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities�������з���isSupportUploadModeling�����ڵ�ʱ��֧���ϴ���ģ����. */
    BYTE    byUploadModeling;
    BYTE    byRes1;
    DWORD   dwPicMangeNo;           //ͼƬ�����
    BYTE    sPicName[NAME_LEN];     //ͼƬ����
    DWORD   dwPicDisplayTime;       //ͼƬ����ʱ������λ��
    BYTE    *pSendAppendData;       //����ͼƬ�ĸ�����Ϣ����������ӦFaceAppendData ��XML������
    DWORD   dwSendAppendDataLen;    //����ͼƬ�ĸ�����Ϣ���ݳ���  FaceAppendData  XML�ĳ��ȣ�
    BYTE    byRes[192];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;


typedef struct tagNET_DVR_DOWNLOAD_QOS
{
    DWORD    dwMaxSpeed;            //��������ٶȣ���λkbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;


#define  NET_SDK_MAX_FILE_NAME 100  //����ļ�����

typedef struct tagNET_DVR_UPLOAD_FILEVOLUME_PRARAM_
{
    DWORD   dwSize;
    BYTE    byFileType;  //�ļ����� 0-¼��1-��Ƶ
    BYTE    byFileVolnumeID;   //�ļ���ID������ͨ��NET_DVR_GET_HDVOLUME_CFG ��ȡ��
    BYTE    byArchive;  //0-���鵵��1-�鵵
    BYTE    byRes1;
    DWORD   dwFileSize;    //�ļ���С
    char    szFileName[NET_SDK_MAX_FILE_NAME/*100*/];   //�ļ�����
    BYTE    byRes[300];
}NET_DVR_UPLOAD_FILEVOLUME_PRARAM, *LPNET_DVR_UPLOAD_FILEVOLUME_PRARAM;

typedef struct tagNET_DVR_DOWNLOAD_FILEVOLUME_PARAM_
{
    DWORD     dwSize;
    BYTE      sUrl[MAX_UPLOADFILE_URL_LEN/*240*/];   //url
    BYTE      byRes[248];
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //�������ݻص�����
    void      *pUserData;            //�û�����, ��fnPreviewDataCB�ص�����
}NET_DVR_DOWNLOAD_FILEVOLUME_PARAM, *LPNET_DVR_DOWNLOAD_FILEVOLUME_PARAM;


//��Ӱģʽ����
typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD    dwSize;          //�ṹ���С
    BYTE     byScreenType;     //�������ͣ�0-�����棬1-�����棬2-���л�
    BYTE     byRes[255];    //����
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

//������������
typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;  //�ṹ���С
    BYTE     byDirectedStrategyType; //�����������ͣ�0-��̬�������ԣ�1-��Ʒ��������,2-��Ʒ����1��2,3-��Ʒ��������1��3
    BYTE     byRes[255];     //����
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

//�߿��ӽṹ
typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; /*�߿��ȺϷ�ȡֵ��ΧΪ[0,14]������ֻ��ȡż��ֵ*/
    BYTE     byRed;  /*�߿���ɫΪRGB ģʽ��R��G��B���ֱ��Ӧλ������*/
    BYTE     byGreen;
    BYTE     byBlue;
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

//���û���߿�
typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;          //�ṹ���С
    NET_DVR_FRAME    struTopFrame;    //�ϱ߿�
    NET_DVR_FRAME    struBottomFrame;//�±߿�
    NET_DVR_FRAME    struLeftFrame;    //��߿�
    NET_DVR_FRAME    struRightFrame;    //�ұ߿�
    BYTE            byFrameEnable;  //���ӱ߿�0-������1-���ӱ߿�
    BYTE            byRes[256];     //����
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

//���û���߿�����
typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//������
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

//��Ƶ�Ż�����
typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;          //�ṹ���С
    DWORD       dwCheckDelay;    //���ʱ�ӣ���λs��0��ʾ���Զ��Ż�
    BYTE        byThreshold;     //��ֵ[0,100]
    BYTE        byVolumePercent;//���� [0,100]
    BYTE        byPriority;     //�ȼ���[0��100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

//¼����Ƶ����
typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;              //�ṹ���С
    BYTE        byExportType;         //��ֵ0-MP4 1-AVI
    BYTE        byRes[255];          //�����ֽ� 
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

//RTMP Cond
typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byStreamType;  //�������ͣ�1-��������2-��������3-������
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

//RTMP Cfg
typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD       dwSize;                          //�ṹ���С
    BYTE        byEnable;                        //�Ƿ�����RTMP��0-�����ã�1-����
    BYTE         byRes1[3];
    DWORD       dwPacketLen;                     //RTMP����
    char        szURL[RTMP_URL_LEN];            //RTMP URL
    BYTE         byRes[256];                      //�����ֽ� 
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;

//�ļ�����
typedef  struct  tagNET_DVR_RECORDING_PUBLISH_FILE_CFG
{
    DWORD   dwSize;                         //�ṹ���С
    BYTE    byFileID[MAX_ID_LEN_128/*128*/];  //�����ļ�ID
    NET_DVR_TIME_EX  struStartTime;  //�γ̿�ʼʱ��
    NET_DVR_TIME_EX  struEndTime;   //�γ̽���ʱ��
    BYTE    byCmdType;  //������������  1--��ʼ���� 2--ȡ������
    BYTE    byFileType;  //�����ļ�����  0������ 1����ʱ�γ� 2���ֶ��γ�
    BYTE   byRes[254];
}NET_DVR_RECORDING_PUBLISH_FILE_CFG, *LPNET_DVR_RECORDING_PUBLISH_FILE_CFG;

//�ļ�������������
typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //�����ļ�ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

//�ļ��������Ȳ���
typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;          //�ṹ���С
    BYTE     byPublishPercent;     //�����ٷֱ� 0-100
    BYTE     byPublishStatus;     //����״̬  0-�����ɹ� 1--���ڷ��� 2--�ȴ����� 3-������FTP  4--û���ҵ����ļ� 5--����ʧ�ܣ���������
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;

//ɾ����ͼ���е��ļ�
typedef  struct  tagNET_DVR_BACKGROUND_PIC_COND
{
    DWORD    dwSize;  
    char     szFileID[MAX_ID_LEN_128/*128*/];        //�ϴ�֮���豸������ļ�ID, ָ����ͼƬ��
    BYTE     byRes[256];
}NET_DVR_BACKGROUND_PIC_COND, *LPNET_DVR_BACKGROUND_PIC_COND;

//��ѯ����ͼƬ�ļ�
typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
    DWORD    dwSize;                         //�ṹ���С
    DWORD     dwPicSize;  //����ͼƬ��С
    DWORD     dwPicType;   //ͼƬ���ͣ�YUV:0 JPEG:1
    WORD     wPicWidth;   //ͼƬ��
    WORD     wPicHeight;    //ͼƬ��
    BYTE          byPicName[MAX_PIC_NAME_LEN/*128*/];   //ͼƬ����
    BYTE         byRes[128];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;                              //�ṹ���С
    BYTE    byEnable;             //�Ƿ����ñ���ͼƬ���ӣ�0-��1-��
    BYTE    byRes1[3];
    BYTE    byPicID[MAX_ID_LEN_128/*128*/];
    BYTE    byRes[300];         //����
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;


//�ϴ�����ͼƬ�ļ�
typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
    DWORD       dwSize;
    DWORD        dwChannel; //����ͨ��
    DWORD        dwPicSize;  //����ͼƬ��С
    WORD        wPicWidth;   //ͼƬ��
    WORD           wPicHeight;    //ͼƬ��
    char          szPicName[MAX_PIC_NAME_LEN/*128*/];   //ͼƬ����
    BYTE        byPicType;   //ͼƬ���ͣ�YUV:0 JPEG:1
    BYTE        byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;

//�͹�������
typedef    struct tagNET_DVR_LOWPOWER
{
    DWORD        dwSize;//�ṹ���С
    BYTE          byMode;//�����ģʽ 0-�ֶ���1-��ʱ
    BYTE        byEnabled;//�ֶ�ģʽ�µ�ʹ�ܿ��� 0-�رգ�1-����
    BYTE        byRes[6];
    NET_DVR_SCHEDULE_DAYTIME  struSchedTime;//��ʱʱ���    
    BYTE        byRes1[256];
}NET_DVR_LOWPOWER,*LPNET_DVR_LOWPOWER;

typedef struct tagNET_DVR_POINT
{
    DWORD dwX;    //X������
    DWORD dwY;    //Y����
}NET_DVR_POINT, *LPNET_DVR_POINT;

//�䱶��������
typedef    struct tagNET_DVR_ZOOMLINKAGE
{
    DWORD        dwSize;//�ṹ���С
    BYTE          byEnable;//ʹ�� 0-�أ�1-��
    BYTE       byRes[255];
}NET_DVR_ZOOMLINKAGE,*LPNET_DVR_ZOOMLINKAGE;

typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-δ��ʼ����,1-��������,2-�����ɹ�,3-�����Բ�ƥ��,4-дfalshʧ��,5-�����Ͳ�ƥ��,6-���汾��ƥ��,7-���粻�ɴ�,8-��������������,
                            //9-��ȡ�������ļ�����,10-û���ҵ������ļ�,11-�����ļ��д�,12-�豸�ڴ治��,0xff-δ֪����
    BYTE    byProgress; //��������,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;

typedef    struct tagNET_DVR_FIRMWARECODE_COND
{
    DWORD  dwSize;
    DWORD  dwStartIndex;    //��ʼ������
    DWORD  dwMaxNum;    //������������32
    BYTE   byRes[52];
}NET_DVR_FIRMWARECODE_COND,*LPNET_DVR_FIRMWARECODE_COND;

typedef    struct    tagNET_DVR_FIRMWARECODE
{
    WORD  wIndex;
    WORD  wCodeLen;    //ʶ���볤�ȣ��ϲ�Ӧ�ÿ�����ʱ����һ���жϣ�������ֶδ���128���뱨����ʾ�û����¹���/�ͻ��˰汾
    BYTE  byCode[MAX_IDCODE_LEN];//ʶ����
    BYTE  byVersion[MAX_VERSIIN_LEN];//�汾
    BYTE  byRes[12];
}NET_DVR_FIRMWARECODE,*LPNET_DVR_FIRMWARECODE;

typedef    struct    tagNET_DVR_FIRMWARECODE_LIST
{
    DWORD  dwSize;
    DWORD  dwValidCodeNum;    //��Ч����
    NET_DVR_FIRMWARECODE  struCode[MAX_IDCODE_NUM];
    BYTE   byRes[64];
}NET_DVR_FIRMWARECODE_LIST,*LPNET_DVR_FIRMWARECODE_LIST;

typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER 
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-δ����,1-������
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //�Ƿ���Ҫ�ӷ�������⣬0-����Ҫ���������豸�����Լ��Ľ��;1-��Ҫ���豸�ἴʱ���ӷ���������Ƿ����°汾
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //�Ƿ����°汾,0-��,1-��
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //�°汾�İ汾��
    BYTE   byChangeLog[SDK_LEN_2048];  //�°汾���µ�����
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN]; 
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //�Ƽ�����,0-��,1-��
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;

//��ʪ������
typedef    struct tagNET_DVR_THSCREEN
{
    DWORD  dwSize;//�ṹ���С
    BYTE   byEnable;//���ö�ʱʹ��
    BYTE   byTHOSDDisplay;//��ʪ����ʾOSD��ʾ�Ƿ�����,  0-��1-��
    BYTE   byRes[2]; // �����ֽ�
    NET_VCA_POINT   struTHOSDPoint;//��ʪ����ʾOSD��ʾ���Ͻ�����
    BYTE   byTimingMode;//Уʱģʽ 0-�ֶ���1-�Զ�
    BYTE   byRes1;
    WORD   wInterval;//Уʱ��ʱģʽ�£����ʱ������[1,10080]m
    BYTE   byRes2[254];
}NET_DVR_THSCREEN,*LPNET_DVR_THSCREEN;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT
{
    DWORD        dwSize;//�ṹ���С
    BYTE     byType;//����ģʽ��0-���£�1-���ң�2-��ת��3-ͼ���ӳ��ǣ�4-RGB����, 5-����, 6-RGB_Ex����
    BYTE     bySensorNo;//Sensor ��[1,8]
    BYTE     byRes[2];
    int     iAdjustMentRange;//�������� [-100,100] ��ת��ʱ��[-30,30] ͼ���ӳ���[-10,10]
    BYTE     byR;//RGB������R����ɫ������Χ0-100
    BYTE     byG;//RGB������G����ɫ������Χ0-100
    BYTE     byB;//RGB������B����ɫ������Χ0-100
    BYTE     byRgbType;//RGB���ͣ�0-������1-����ģʽ��2-�ֶ�ģʽ
    BYTE     byBrightness;//���ȣ���Χ0-100,Ĭ��ֵ50
    BYTE     byRes1[3];
    WORD    wRex;//RGB����(��չ)��R����ɫ������Χ0-2048
    WORD    wGex;//RGB����(��չ)��G����ɫ������Χ0-2048
    WORD    wBex;//RGB����(��չ)��B����ɫ������Χ0-2048
    BYTE     byRes2[114];
}NET_DVR_SENSOR_ADJUSTMENT,*LPNET_DVR_SENSOR_ADJUSTMENT;

typedef    struct tagNET_DVR_SENSOR_ADJUSTMENT_INFO
{
    DWORD        dwSize;//�ṹ���С
    int      iPan;//����ֵ
    int      iTilt;//����ֵ
    int      iRotation;//��תֵ
    int      iFieldAngle;//ͼ���ӳ���ֵ
    BYTE     byR;//RGB������R����ɫ������Χ0-100
    BYTE     byG;//RGB������G����ɫ������Χ0-100
    BYTE     byB;//RGB������B����ɫ������Χ0-100
    BYTE     byRgbType;//RGB���ͣ�0-������1-����ģʽ��2-�ֶ�ģʽ
    BYTE     byBrightness;//���ȣ���Χ0-100,Ĭ��ֵ50
    BYTE     byRes[3];
    WORD    wRex;//RGB����(��չ)��R����ɫ������Χ0-2048
    WORD    wGex;//RGB����(��չ)��G����ɫ������Χ0-2048
    WORD    wBex;//RGB����(��չ)��B����ɫ������Χ0-2048
    BYTE     byRes1[114];
}NET_DVR_SENSOR_ADJUSTMENT_INFO,*LPNET_DVR_SENSOR_ADJUSTMENT_INFO;

typedef    struct tagNET_DVR_SENSOR_RESET
{
    DWORD        dwSize;//�ṹ���С
    BYTE     bySensorNo;//Sensor��[1,8];��Sensor NoΪ0��ʱ�򣬱�ʾȫ���������������±�ʾ�������
    BYTE     byRes[127];
}NET_DVR_SENSOR_RESET,*LPNET_DVR_SENSOR_RESET;

typedef    struct tagNET_DVR_PANORAMAIMAGE
{
    DWORD        dwSize;//�ṹ���С
    BYTE     byFusionMode;//ģʽ��0-ԭʼͼ��1-ȫ��ͼ��
    BYTE     byPreviewMode;//ģʽ��1-Ŀ����٣�2-�̶���ʾ
    BYTE     byRes[126];
}NET_DVR_PANORAMAIMAGE,*LPNET_DVR_PANORAMAIMAGE;

typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];     //�ӹ��豸�ĵ�ַ 
    WORD        wPort ;                 //�豸�˿ں�
    BYTE        byRes[254] ;            //����
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
    DWORD dwSize;
    BYTE byEnabled;        //�Ƿ����û�������0-��1-��
    BYTE byRes1[3];
    NET_DVR_POINT struRegion[RECT_POINT_NUM];    //�������򣬾��Σ���ʼ��Ϊ���½ǣ�˳ʱ�뷽��
    DWORD dwOutputWidth;    //������ڻ�׼��ֻ�ܻ�ȡ
    DWORD dwOutputHeight;    //������ڻ�׼�ߣ�ֻ�ܻ�ȡ
    BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
    DWORD dwSize;
    BYTE  byAnswerType; //���������Ӧ��ʽ��1-�Զ�������2-�Զ��ܽӣ�3-�ֶ�����
    BYTE  byProtocolType;    //ʹ�õ�Э�����ͣ�1-SIP��2-H232
    BYTE byTransmissionProtocol; //����Э�����ͣ�0-��Ч��1-TCP��2-UDP
    BYTE byRes[29];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    DWORD dwCallRate;//�������ʣ���ΧΪ��32~6144����λKbps  (��������)
    BYTE  byRes[124];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;     //�Ƿ�����0-��1-��
    BYTE byVolume;   //�������Ǿ���ʱ��Ч��1-100
    BYTE byAudioInputDisabled;  //��ֹ��Ƶ���룬0-������Ƶ���룬1-��ֹ��Ƶ����
    BYTE byAudioInputVolume;    //��Ƶ����������������Ƶ����ʱ��Ч��1-100
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef struct tagNET_DVR_HOWLING_SUPPRESSION
{
    BYTE    byEnabled;  //�Ƿ�ʹ��Х������
    BYTE    byHsSensibility;    //Х������������
    BYTE    byHsMode;   //Х������ģʽ��0-Ĭ�ϣ�1-���٣�2-����
    BYTE    byRes1;
    DWORD dwHsTime; //Х������ʱ�䣬��λ��ms
    BYTE    byRes2[16];
}NET_DVR_HOWLING_SUPPRESSION, *LPNET_DVR_HOWLING_SUPPRESSION;

typedef struct tagNET_DVR_TERMINAL_INPUT_AUDIO
{
    DWORD dwChannel; //ͨ����
    BYTE   byGainType; //�������ͣ�1-�������棬2-ģ������,3-����
    BYTE   byEnableSimulate; //�Ƿ�����ģ�����棬0-��1-��
    BYTE   byVolumeSimulate;  //ģ������������ʱ��Ч��1-100
    BYTE   byEnableDigital; //�Ƿ������������棬0-��1-��
    BYTE   byVolumeDigital;  //��������������ʱ��Ч��1-100
    BYTE   byRes1[3];
    NET_DVR_HOWLING_SUPPRESSION struHsParam;    //Х�����Ʋ���
    BYTE   byRes[604];
}NET_DVR_TERMINAL_INPUT_AUDIO, *LPNET_DVR_TERMINAL_INPUT_AUDIO;


typedef union tagNET_DVR_TERMINAL_DETAIL_CTRL_PARAM
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struCallInfo;
    NET_DVR_TERMINAL_AUDIO_CTRL struAudioCtrl;
    NET_DVR_TERMINAL_INPUT_AUDIO struInputAudio;
}NET_DVR_TERMINAL_DETAIL_CTRL_PARAM, *LPNET_DVR_TERMINAL_DETAIL_CTRL_PARAM;

typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;    //�������ͣ�1-������2-�ܽӣ�3-���У�4-��Ƶ���ڣ�5-�Ҷϣ�6-˫������7-˫����
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;   //������Ʋ���
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;

typedef struct tagNET_DVR_POS_INFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byPosInfoOverlayEnable;// Pos��Ϣ�������ӿ��ƣ�0-�����ӣ�1-����
    BYTE    byOverlayType;//0-���ӽ�����뿪��1-���ӽ��롢�뿪��PASS��ID���߶�
    BYTE    byRes[126];
}NET_DVR_POS_INFO_OVERLAY, *LPNET_DVR_POS_INFO_OVERLAY;


typedef struct tagNET_DVR_CAMERA_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode;//����ģʽ��0-����ģʽ��1-�����궨ģʽ
    BYTE  byPreviewImageMode;//Ԥ��ͼ��ģʽ��0-����ͼ��1-����ͼ��2-���ҵ���ͼ��
    BYTE byRes[126];
}NET_DVR_CAMERA_WORK_MODE, *LPNET_DVR_CAMERA_WORK_MODE;

typedef struct tagNET_DVR_VCA_VERSION_LIST
{
    DWORD    dwSize;        //�ṹ�峤��
    NET_DVR_VCA_VERSION  struVcaVersion[NET_SDK_VERSION_LIST_LEN/*64*/];//�㷨��汾��Ϣ
    BYTE    byRes[128];
}NET_DVR_VCA_VERSION_LIST, *LPNET_DVR_VCA_VERSION_LIST;

typedef struct tagNET_DVR_SETUP_CALIB_COND
{
    DWORD dwSize;
    BYTE  byCalibrateType;//�궨���ͣ�0-δ���б궨��1-�Զ��궨��2-�ֶ��궨,3-���ܱ궨
    BYTE  byRes1[3];
    float fTiltAngle;//������,��λ���ȣ�������Ĭ��ֵ��0�������Ƿ�Χ��0-180��,��byCalibrateTypeΪ2ʱ��Ч
    float fHeelAngle;//��б��,��λ���ȣ���б��Ĭ��ֵ��0����б�Ƿ�Χ��-90-90��,��byCalibrateTypeΪ2ʱ��Ч
    float fHeight;//�߶ȣ��߶ȵ�λ�����ף��߶�Ĭ��ֵ300���ף��߶ȷ�Χ��200-500����,��byCalibrateTypeΪ2ʱ��Ч
    NET_VCA_POLYGON struAutoCalibPolygon;//�Զ��궨���򣬵�byCalibrateTypeΪ1ʱ��Ч
    BYTE byIntelligentType;//�궨���������ͣ�0-������ 1-������2-�������ԣ�3-��Ϊ������ֻ���ڱ궨����ʱNET_DVR_SETUP_CALIB_RESULT���ص����ݲ���Ч
    BYTE byRes[127];
}NET_DVR_SETUP_CALIB_COND, *LPNET_DVR_SETUP_CALIB_COND;

typedef struct tagNET_DVR_SETUP_CALIB_RESULT
{
    DWORD dwSize;
    BYTE  byCalibrateType;//�궨���ͣ�0-δ���б궨��1-�Զ��궨��2-�ֶ��궨,3-���ܱ궨
    BYTE  byRes1[3];
    float fTiltAngle;//������,��λ���ȣ�������Ĭ��ֵ��0�������Ƿ�Χ��0-180��,��byCalibrateTypeΪ2ʱ��Ч
    float fHeelAngle;//��б��,��λ���ȣ���б��Ĭ��ֵ��0����б�Ƿ�Χ��-90-90��,��byCalibrateTypeΪ2ʱ��Ч
    float fHeight;//�߶ȣ��߶ȵ�λ�����ף��߶�Ĭ��ֵ300���ף��߶ȷ�Χ��200-500����,��byCalibrateTypeΪ2ʱ��Ч
    NET_VCA_POLYGON struCountPolygon;//��������
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // �������뷽��
    NET_VCA_LINE  struLine;//�����
    BYTE byRes[128];
}NET_DVR_SETUP_CALIB_RESULT, *LPNET_DVR_SETUP_CALIB_RESULT;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //������ʶ��
    NET_DVR_TIME struStartTime; //������ʼʱ��
    NET_DVR_TIME struEndTime;   //��������ʱ��
    BYTE byCallType;    //�������ͣ�1-�ѽӣ�2-δ�ӣ�3-�Ѳ���4-��������
    BYTE byRes1[3];
    DWORD dwMaxResults; //���β�����෵�ظ���
    DWORD dwSearchPos;  //������ʼ����
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;    //�������ͣ�1-�ѽӣ�2-δ�ӣ�3-�Ѳ�
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN]; //�ն���
    BYTE byAddressURL[MAX_URL_LEN]; //�Զ�URL��ַ
    NET_DVR_TIME struStartTime; //���п�ʼʱ��
    NET_DVR_TIME struEndTime;   //���н���ʱ��
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef enum tagCALL_QUERY_RESULT_STATUS
{
    CALL_QUERY_RESULT_OK = 0,     //�ɹ���ѯ����
    CALL_QUERY_RESULT_FAIL,       //��ѯʧ�ܣ�δ֪����
    CALL_QUERY_RESULT_MORE,     //�ɹ���ѯ ���и���û�з���
    CALL_QUERY_RESULT_NOMATCH,  //û�в�ѯ��ƥ���
    CALL_QUERY_RESULT_PARAMERROR,  //��ѯ������������
    CALL_QUERY_RESULT_INVALIDTIME,   //��ѯ����ʱ����Ч
    CALL_QUERY_RESULT_TIMEOUT,   //��ѯ��ʱ
}CALL_QUERY_RESULT_STATUS;

typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //������ʶ��
    BYTE   byStatus;  //��ѯ״̬  �ο�CALL_QUERY_RESULT_STATUS�ṹ��
    BYTE   byRes[3];  //���� 
    DWORD dwCount; //ʵ�ʲ�ѯ���Ľ������
    BYTE *pResults; //������ݣ�dwCount��NET_DVR_CALL_QUERY_SINGLE,��Ҫ������Ԥ�ȷ������ڴ�
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN]; //����ID
    BYTE byConferenceName[NAME_LEN];    //��������     
    NET_DVR_TIME struStartTime;        //���鿪ʼʱ��
    NET_DVR_TIME struEndTime;        //�������ʱ��
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;

typedef union tagNET_DVR_CALL_INFO
{
    BYTE byRes[640];
    NET_DVR_TERMINAL_CALL_INFO struTerminalCallInfo;  //�ն˵�Ե������Ϣ
    NET_DVR_CONFERENCE_CALL_INFO struConferenceCallInfo;  //���������Ϣ
}NET_DVR_CALL_INFO, *LPNET_DVR_CALL_INFO;

typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
    DWORD dwSize;
    BYTE  byAlarmType;              //�������ͣ�1-������У� 2-����״̬�л���3-�ն�����
    BYTE  byCallType;               //�������ͣ���������Ϊ1ʱ��Ч��1-�ն˵�Ե���У�2-�������
    BYTE  byAutoAnswer;                //�Ƿ����Զ�������0-��1-��
    BYTE  byCallStatusSwitch;       //����״̬�л����ͣ�����������Ϊ2ʱ��Ч��1-��ʼ���У�2-���гɹ���3-���н�����4-�Զ˹Ҷ�
    NET_DVR_CALL_INFO struCallInfo; //������Ϣ
    BYTE  byRes2[32];    
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;    //��Ϊ��Ƶ�������������ڱ��
    BYTE  byStreamType;//�������ͣ�0-��������1-��������2-������
    BYTE  byRes[31];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;    //�Ƿ�����0-��1-��
    BYTE byVolume;  //����������1-100���Ǿ���ʱ��Ч
    BYTE byAudioInputDisabled;  //������Ƶ���룬0-��1-��
    BYTE byAudioInputVolume; //��Ƶ����������1-100��������Ƶ����ʱ��Ч
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState; //����״̬��0-���У�1-æµ�������У���2-�����У�3-��������
    BYTE byConferenceType;  //�������ͣ�1-��Ե㣬2-MCU�������
    BYTE byDualStreamEnabled;    //�Ƿ���˫����0-δ������1-����
    BYTE byMicPowerEnabled;    //��˷��Դ�Ƿ�����0-δ������1-����
    DWORD dwInputNo;   //ʹ�õ���Ƶ����ں�
    NET_DVR_CALL_INFO struCallInfo; //������Ϣ
    NET_DVR_AUDIO_STATUS struAudioStatus;   //��Ƶ���״̬
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

//�ն�ע��GK��Ϣ
typedef struct tagNET_DVR_TERMINAL_GK_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //�Ƿ�����
    BYTE  byRegisterState;    //ע��״̬��0-δע�ᣬ1-��ע�ᣬֻ��
    BYTE  byRes1[2];
    NET_DVR_IPADDR struGKIP; //GK IP
    WORD wGKPort; //GK�˿ں�
    BYTE byRes2[2];
    BYTE byRegisterName[REGISTER_NAME_LEN]; //�ն�ע�ᵽGK������
    BYTE byPassword[PASSWD_LEN];    //�ն�ע�ᵽGK������
    BYTE byRes3[16];
}NET_DVR_TERMINAL_GK_CFG, *LPNET_DVR_TERMINAL_GK_CFG;

//���������ο��ز���
typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
    DWORD dwSize;
    BYTE  byEnableRoam;    //�Ƿ����������Σ�0-�񣬷�0-��
    BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE byEnableZoom;  //�Ƿ����ţ�0-��1-��
    BYTE byAutoCutBlackEdge;  //�Ƿ��Զ��ü��ڱߣ�0-��1-��
    BYTE byRes1[2];
    WORD wLEDWidth;     //�ֱ��ʿ�
    WORD wLEDHeight;    //�ֱ��ʸ�
    DWORD dwRefreshRate;    //ˢ��Ƶ��
    DWORD dwInputNO;    //����������ͨ����
    BYTE byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //�Ƿ�ʹ�ܣ�0-��1-��
    BYTE  byRes1[3];
    DWORD dwPortNum;    //�����Ķ˿ڸ���
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM];     //�����Ķ˿ں�
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //�к�
    WORD wColumn; //�к�
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo;  //��ʾ�������ʼλ��(���տ����к�)
    WORD    wWidth;     //������տ���
    WORD    wHeight;    //������տ���
    WORD     wRecvCardWidth;   //���տ���ȴ�С��Ϊ0��ʹ�ö˿ڲ����н��տ���С����
    WORD    wRecvCardHeigt;   //���տ��߶ȴ�С��Ϊ0��ʹ�ö˿ڲ����н��տ���С����
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //���տ�λ��
    WORD wRecvCardWidth;   //���տ���ȴ�С
    WORD wRecvCardHeigt;   //���տ��߶ȴ�С
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;    //�Ƿ����ö˿ڱ��ݣ�0-��1-��
    BYTE byPortMode; //�˿�ģʽ��1-���ڣ�2-���ݿ�
    BYTE byRes1[2];
    DWORD dwPairPort; //��Զ˿ںţ����˿�Ϊ����ʱ���˲���Ϊ���ݿڶ˿ںţ����˿�Ϊ���ݿ�ʱ���˲���Ϊ���ڶ˿ں�
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //�Ƿ����øö˿ڣ�0-��1-��
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup;    //�˿ڱ��ݲ���
    DWORD dwRecvCardNum;   //���˿����ӵĽ��տ���
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM];   //�����տ�����Ϣ
    DWORD dwPortNo; //�˿ںţ���ȡ���ж˿ڲ���ʱ��Ч
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp;    //ɫ�²���
    NET_DVR_VIDEO_OUT_CFG struVoutCfg;        //��ʾЧ������
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;        //�Ƿ����ò����źţ�0-�����ã�1-����
    BYTE bySignalType;    //�����ź����ͣ�1-������2-���ƣ�3-��״������4-����5-ˮƽ�ʹ�ֱ�ҽ������壬6-���̣�0xff-�Զ�����ɫ
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor;    //�����ź���ɫ�������ź�����Ϊ0xffʱ��Ч
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode;    //���ź���ʾģʽ��1-������2-��ʾ����LOGO��3-��ʾ�Զ���ͼƬ
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;    //����ֱ��ʿ�ֻ��
    DWORD dwResolutionHeight;    //����ֱ��ʸߣ�ֻ��
    DWORD dwRefreshRate;        //�����ź�ˢ��Ƶ�ʣ�ֻ��
    NET_DVR_SCREEN_VGA_CFG struVgaCfg;    //VGA�źŵ���������VGA����ʱ�ɵ�
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;    //������
    NET_DVR_LINE_COLUMN_INFO struPosStart; //���տ���ʼλ��
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //���տ�����λ��
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;    //������;
    NET_DVR_LINE_COLUMN_INFO struPosStart; //���տ���ʼλ��
    NET_DVR_LINE_COLUMN_INFO struPosEnd; //���տ�����λ��
    BYTE byGammaType; //Gamma�����ͣ�Gamma������ʱ��Ч��0-RGB���Gamma��1-��ɫGamma��2-��ɫGamma��3-��ɫGamma��
    BYTE byRes[31];
}NET_DVR_LED_GAMMA_CFG_COND, *LPNET_DVR_LED_GAMMA_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];    //GAMMA��Yȡֵ��ÿ��Ԫ��ȡֵ0-65535���Զ���ģʽʱ��Ч
    BYTE byGammaModel; //GAMMA��ģʽ��0-�Զ���ģʽ��1-ҹģʽ1��2-ҹģʽ2��3-����ģʽ��4-����ģʽ1��5-����ģʽ2
    BYTE byRes[127];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;    //����ʱ��dclkƵ�ʣ�ʵ��ֵ��10����λ��MHz��ʵ��ֵ��Χ1.0-31.3
    DWORD dwGclkRate;    //ˢ��ʱ��gclkƵ�ʣ�ʵ��ֵ��10����λ��MHz��ʵ��ֵ��Χ1.0-31.3
    DWORD dwGclkCountNum;    //300ns gclk����ֵ
    BYTE  byDclkDutyRatio;    //dclkʱ��ռ�ձȣ�ȡֵ��25��50��75
    BYTE  byDclkPhase;    //dclk��λ��ȡֵ��0,1,2,3
    BYTE  byGclkNum;    //ˢ��1����Ҫ����Чgclk������0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;    //ʱ����ز���
    BYTE byGrayLevel;    //�Ҷȵȼ���ȡֵ13��14
    BYTE byRefreshRate;    //ˢ�±��ʣ�ȡֵ1-6
    BYTE byLineScanNum;    //��ɨ����0-255
    BYTE byRefreshCompleteGrayNum; //ˢ�������ҽ�����0-255
    DWORD dwHBlank;        //������ʱ�䣬��λ��gclkʱ�Ӹ�����ȡֵ1-65535
    DWORD dwAfterglowCtrl;    //���Ϳ��ƽ���ʱ�䣬��λ��gclkʱ�Ӹ�����ȡֵ1-65535
    DWORD dwLineFeedTime;    //����ʱ�䣬��λ��gclkʱ�Ӹ�����ȡֵ1-65535
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;        //оƬ1���ֽ�
    BYTE byChip1Low;        //оƬ1���ֽ�
    BYTE byChip2High;        //оƬ2���ֽ�
    BYTE byChip2Low;        //оƬ2���ֽ�
    BYTE byChip3High;        //оƬ3���ֽ�
    BYTE byChip3Low;        //оƬ3���ֽ�
    BYTE byChip4High;       //оƬ4���ֽ�
    BYTE byChip4Low;        //оƬ4���ֽ�
    BYTE byChip5High;       //оƬ5���ֽ�
    BYTE byChip5Low;        //оƬ5���ֽ�
    BYTE byChip6High;       //оƬ6���ֽ�
    BYTE byChip6Low;        //оƬ6���ֽ�
    BYTE byRes[4];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;    //�¹�Ӱ�����ȼ���0-5
    BYTE byEliminateShadowy;            //��һɨƫ�������ȼ���0-15
    BYTE byGrayEqualize1;                //�ͻ�ƫɫ����1��0-3
    BYTE byGrayEqualize2;                //�ͻ�ƫɫ����2��0-15
    BYTE byEnableGrayUniformity;        //�ͻҾ����������Ƿ�����0-�أ�1-��
    BYTE byDisableHGrayStripes;            //�ͻҺ����������Ƿ�����0-�أ�1-��
    BYTE byGhostShadowEnhancedMode1;    //�¹�Ӱ������ǿģʽ1�Ƿ�����0-�أ�1-��
    BYTE byGhostShadowEnhancedMode2;    //�¹�Ӱ������ǿģʽ2�Ƿ�����0-�أ�1-��
    BYTE byClearBadPoint;                //ȥ������ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE byEnableSelfDefineRegistor;    //�Ƿ������Զ���Ĵ���ֵ��0-��1-��
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue;    //�Զ���Ĵ�������    
    BYTE    byEnabledExGradientOptimition;	//��������Ż����أ�0-�رգ�!0-����
    BYTE    byDummyGClockCycle;     //Dummy GClock���ڣ�������������Ż�ʱ��Ч����λ����gclk
    BYTE    byDummyGClockHighTime;      //Dummy GClock�ߵ�ƽʱ�䣬������������Ż�ʱ��Ч����λ��8ns
    BYTE    byFirstGClockExtendedTime;  //��һ��GClockչ��ʱ�䣬������������Ż�ʱ��Ч����λ��8ns
    BYTE byRes[28];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
    DWORD dwSize;
    NET_DVR_LED_RECV_REGISTOR struFirstRegistor;    //��һ����տ��߼��������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
    NET_DVR_LED_RECV_REGISTOR struSecondRegistor;    //�ڶ�����տ��߼��������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
    NET_DVR_LED_RECV_REGISTOR struThirdRegistor;    //��������տ��߼��������Զ���Ĵ���ֵΪ��оƬ�Ĵ���ֵ
    BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

typedef struct tagNET_DVR_LED_CHECK_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;   //������
    NET_DVR_LINE_COLUMN_INFO struPosStart; //���տ���ʼλ��
    BYTE byStartPosType; //��ʼλ�����ͣ�0-ʹ�ý��տ���ʼλ�ã�1-ʹ������λ��
    BYTE byRes1[3];
    DWORD dwXCoordinate;    /*�������Ͻ���ʼ��X����*/
    DWORD dwYCoordinate;    /*�������Ͻ�Y����*/
    DWORD dwWidth;          /*������*/
    DWORD dwHeight;          /*����߶�*/
    BYTE  byRes[8];
}NET_DVR_LED_CHECK_COND, *LPNET_DVR_LED_CHECK_COND;

//��ѯ��ʽ
enum  ADDR_QUERY_TYPE
{
    QUERYSVR_BY_COUNTRYID = 0,    //�����ұ�Ų�ѯ��������ַ
    QUERYSVR_BY_SERVERTYPE = 1, //����
    QUERYDEV_BY_NICKNAME_DDNS = 2, //���ǳƴ�hiDDNS�ϲ�ѯ�豸��Ϣ
    QUERYDEV_BY_SERIAL_DDNS = 3,    //�����кŴ�hiDDNS�ϲ�ѯ�豸��Ϣ
    CHECKDEV_BY_NICKNAME_DDNS = 4,//���ǳƴ�hiDDNS����豸��Ϣ
    CHECKDEV_BY_SERIAL_DDNS = 5,    //�����кŴ�hiDDNS����豸��Ϣ
    QUERYDEV_BY_NICKNAME_IPSERVER = 6, //���ǳƴ�IPServer�ϲ�ѯ�豸��Ϣ
    QUERYDEV_BY_SERIAL_IPSERVER = 7    //���ǳƴ�IPServer�ϲ�ѯ�豸��Ϣ
};
#define    CLIENT_VERSION_LEN    64
//�����ұ�Ų�ѯ�������ṹ��
typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD    wCountryID;    //���ұ��,ȡֵ�������һ
    char    szSvrAddr[MAX_DOMAIN_NAME];//��������ַ,��ʾȥ�ĸ��������ϲ�ѯĿ�����������Ϣ
    char    szClientVersion[CLIENT_VERSION_LEN];//�ͻ��˰汾��Ϣ,����:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;

//�����ұ�Ų�ѯ�ķ��ؽṹ��
typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ(���豸ע�������)
    char    szAlarmSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    BYTE    byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

//�����������Ͳ�ѯ�������ṹ��
typedef struct tagNET_DVR_QUERY_SERVERTYPE_COND
{
    WORD    wSvrType;    //����������, 6-�ֻ����ͷ�����
    char    szSvrAddr[MAX_DOMAIN_NAME];//��������ַ,��ʾȥ�ĸ��������ϲ�ѯĿ�����������Ϣ
    char    szClientVersion[CLIENT_VERSION_LEN];//�ͻ��˰汾��Ϣ
    BYTE    byRes[382];
}NET_DVR_QUERY_SERVERTYPE_COND, *LPNET_DVR_QUERY_SERVERTYPE_COND;

//�����������Ͳ�ѯ�ķ��ؽṹ��
typedef struct tagNET_DVR_QUERY_SERVERTYPE_RET
{
    char    szSvrAddr[MAX_DOMAIN_NAME];    //��������ַ
    WORD    wSvrPort;    //�������˿�
    BYTE    byRes[446];
}NET_DVR_QUERY_SERVERTYPE_RET, *LPNET_DVR_QUERY_SERVERTYPE_RET;

//��hiDDNS�ϲ�ѯ����ϵ������ṹ��
typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    char    szDevNickName[MAX_DOMAIN_NAME];    //�豸�ڽ����������ϵı���
    char    szDevSerial[SERIALNO_LEN];    //�豸���к�
    char    szClientVersion[CLIENT_VERSION_LEN];//�ͻ��˰汾��Ϣ,����:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[272];        //����
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;

//��hiDDNS�ϲ�ѯ���صĽṹ��
typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //�豸IP��ַ
    WORD    wCmdPort;        //���ƶ˿ڣ�SDK���Ӷ˿ڣ�
    WORD    wHttpPort;        //http�˿�
    BYTE    byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;

//��hiDDNS����Ϸ��صĽṹ��
typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE    byDevStatus;        //�豸״̬,0-����,1-�Ҳ���,2-�豸������,3-�豸���ڵ�ǰ����
    BYTE    byRes1;
    NET_DVR_QUERY_DDNS_RET    struQueryRet;    //��ַ��Ϣ
    WORD    wRegionID;        //��ǰ�豸ע��������[1����,2����,3��̫,4�й�,5ŷ��,6����] 
    BYTE    byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

//��IPServer�ϲ�ѯ�������ṹ��
typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//������������ַ
    WORD    wResolveSvrPort;    //�����������˿�
    char    szDevNickName[MAX_DOMAIN_NAME];    //�豸�ڽ����������ϵı���
    char    szDevSerial[SERIALNO_LEN];    //�豸���к�
    BYTE    byRes[334];        //����
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

//��IPServer�ϲ�ѯ���صĽṹ��
typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //�豸IP��ַ
    WORD    wCmdPort;        //���ƶ˿ڣ�SDK���Ӷ˿ڣ�
    BYTE    byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //ͨ����
    BYTE   byres[32];                    //����
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;

//�������������ṹ
typedef    struct tagNET_DVR_STREAMENCRYPTION_COND
{
    DWORD    dwSize;  //�ṹ���С
    DWORD   dwChan;  //Ԥ��ͨ����
    BYTE    byRes[128];
}NET_DVR_STREAMENCRYPTION_COND, *LPNET_DVR_STREAMENCRYPTION_COND;

//����������Ϣ�ṹ
typedef    struct tagNET_DVR_STREAMENCRYPTION_CFG
{
    DWORD    dwSize;    //�ṹ���С
    BYTE    byEnable;  //�����������ܣ�0~�رգ�1~����
    BYTE    byRes[255];
}NET_DVR_STREAMENCRYPTION_CFG, *LPNET_DVR_STREAMENCRYPTION_CFG;

//У׼��GPS��γ�Ȳ���
typedef    struct tagNET_DVR_REVISE_GPS_CFG
{
     DWORD    dwSize;    //�ṹ���С
     BYTE   byLatitudeType ;//γ�����ͣ�0-��γ��1-��γ
     BYTE   byLongitudeType ;// �������ͣ�0-���ȣ�1-����
     BYTE   byMode ;//ģʽ 0-Ĭ�ϣ�1-�Զ���2-�ֶ�
     BYTE    byRes;
     NET_DVR_LLI_PARAM    struLatitude;     /*γ��*/
     NET_DVR_LLI_PARAM    struLongitude; /*����*/
     BYTE    byRes1[300];
}NET_DVR_REVISE_GPS_CFG, *LPNET_DVR_REVISE_GPS_CFG;

typedef    struct tagNET_DVR_PDC_RECOMMEND
{
    DWORD         dwSize;
    WORD        wWidth;//�Ƽ����ֵ[0, 1000]
    BYTE        byRes[126];
}NET_DVR_PDC_RECOMMEND,*LPNET_DVR_PDC_RECOMMEND;

typedef    struct tagNET_DVR_FLASHSTORAGE_REMOVE
{
    DWORD         dwSize;
    DWORD       dwChannel;
    BYTE        byPDCRemoveEnable;//�����������ʹ�� 0-�������1-���
    BYTE        byRes[127];
}NET_DVR_FLASHSTORAGE_REMOVE,*LPNET_DVR_FLASHSTORAGE_REMOVE;

/********************************DS-TME4XX���ƻ����� Begin****************************/
typedef struct tagNET_DVR_PARKING_CARD
{
    DWORD  dwSize;
    DWORD  dwChannel;//Ĭ����1���������ݶ�ͨ���豸��
    char  szCardNo[MAX_CARDNO_LEN/*48*/];//����
    BYTE  byCardType;//��Ƭ���� 0-��ʱ����1-�̶���
    BYTE  byCardStatus;//��Ƭ״̬ 0-������1-��ʧ��2-ע��
    BYTE  byChargeRuleID;//�շѹ���ID
    BYTE  byDelete;//�Ƿ�ɾ�� 0-��ɾ����1-ɾ��
    NET_DVR_TIME_V30 struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//��Ч����ʱ��
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

//����ڿ�Ƭ��Ϣ�ϴ�
typedef struct tagNET_DVR_GATE_CARDINFO
{
    DWORD     dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //���ʱ��
    DWORD dwAbsTime; //����ʱ��
    char    szCardNo[MAX_CARDNO_LEN/*48*/];//����
    char    szPassVehicleID[MAX_VEHICLE_ID_LEN];//Ψһ��ʶ
    char    szInVehicleID[MAX_VEHICLE_ID_LEN];//����ʱ�����Ψһ��ʶ
    NET_DVR_TIME_V30  struSwipeTime;//ˢ��ʱ��
    NET_DVR_TIME_V30  struCardTime;//��Ƭ���ʱ�䣬���볡ʱд���ʱ�䣬ֻ�Գ���Ʊ�����ã�0��ʾ���볡ʱ��
    BYTE    byLetPass;//����ڷ��з�ʽ 0-������(��CardType == ֽƱ)��Ҫ�շѣ�1-���У�2-�����շѷ���
    BYTE     byCardType;//������ 0-�̶�����1-��ʱ����2-ֽƱ
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

//��̨��ҵ�����ϴ�
typedef struct _tagNET_LOADING_DOCK_OPERATEINFO_
{
    DWORD   dwSize; //�ṹ����
    BYTE    byAbsTime[32];        //����ʱ���,yyyymmddhhmmssxxx,e.g.20090810235959999  �����λΪ������
    BYTE    byParkingNo[MAX_PARKNO_LEN/*16*/];//��λ���
    DWORD   dwIndex;          //�������
    char    sLicense[MAX_LICENSE_LEN/*16*/];        //���ƺ���,ע���ж����������С��Ҳ���복�ƺ��룬С�ֺͳ��ƺ��м��ÿո�ָ�
    BYTE    byCurrentWorkerNumber;//��ǰ��ҵ����
    BYTE    byCurrentGoodsLoadingRate;//��ǰ����װ���� 0-�� 1-�� 2-�� 3-�� 4-��
    BYTE    byDoorsStatus;//����״̬ 0-���Źر� 1-���ſ���
    BYTE    byRes1;    //�����ֽ�
    DWORD   dwBackPicDataLength;//����ͼƬ����
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64)) //win64��linux64��ָ��Ϊ8�ֽ�
    BYTE    *pBackPicDataBuffer; //����ͼƬ����ָ��
#else
    BYTE*   pBackPicDataBuffer; // ����ͼƬ����ָ��
    BYTE  byRes2[4];
#endif 
    DWORD   dwChannel;          //ͨ���ţ�0-��֧�֣������ϵ��豸��֧��ͨ���ŷ��أ�
    BYTE    byRes[508];
}NET_LOADING_DOCK_OPERATEINFO, *LPNET_LOADING_DOCK_OPERATEINFO;

//����ڸ�����Ϣ�ϴ�(COMM_GATE_CHARGEINFO_UPLOAD)
typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //���ʱ��
    DWORD dwAbsTime; //����ʱ��
    char  sLicense[MAX_LICENSE_LEN];        //����
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //����Ψһ������ʾ
    char  szEntranceID[32];  //�볡Ψһ������ʾ
    DWORD dwTotalCost;   //ʵ���շѽ��*100
    char  szOperateName[32]; //�ѻ���Ϊ"offline"
    BYTE  byChargeRuleId; //�շѹ���centerId
    BYTE  byVehicleType;//�������ͣ�0-����������1-С�ͳ���2-���ͳ�
    BYTE  byRes[127];//Ԥ��
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

//ͣ����ͣ�������ƽṹ��
typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
    DWORD  dwSize;
    DWORD  dwChannel; //ͨ����
    BYTE  byCardType;//��Ƭ���� 0-��ʱ��
    BYTE  byDeleteALL;//�Ƿ�ȫ��ɾ�� 0-��ɾ����1-ɾ��
    BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;


//TME����ץͼ�ϴ�
typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //������1��32�����������ţ�������Ծ��
    BYTE    byCamLaneId; //��Ӧ���������1��16��������õĳ����ţ�������Ծ��������ͬ��
    BYTE    byRes1; //����
    DWORD   dwChanIndex; //ͨ����
    NET_DVR_PLATE_INFO  struPlateInfo; //������Ϣ�ṹ
    NET_DVR_VEHICLE_INFO struVehicleInfo; //������Ϣ
    BYTE    byMonitoringSiteID[48]; //������
    BYTE    byDeviceID[48]; //�豸���
    BYTE    byDir;     //��ⷽ��0-���� 1 �볡��2 ���� 
    BYTE    byRes2; 
    WORD    wBackList; //���Ϊ�Ƿ񱨾����� 0 ��ʾΪ������������  1 ��ʾ������
    DWORD   dwPicNum; //ͼƬ��������picGroupNum��ͬ����������Ϣ������ͼƬ������ͼƬ��Ϣ��struVehicleInfoEx���� 
    NET_ITS_PICTURE_INFO struPicInfo[4];  //ͼƬ��Ϣ,�ݶ����4��ͼ
    BYTE    byPassVehicleID[32];    //����ΨһID 
    BYTE    byCardNo[48]; // ����
    BYTE    bySwipeTime[32];//����ˢ��ʱ��  ʱ���ʽΪyyyymmddhh24missfff
    DWORD   dwCharge;      //�շѽ�� ���֣�
    BYTE    byHistory;     //�Ƿ�����ʷ����  0-��  1-��
    BYTE    byLetPass;     //�Ƿ��ѷ��У�0-δ���У�1-����  2-δ֪
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

//�شŹ�����ע����Ϣ
typedef struct tagNET_DVR_MVMRegisterInfo_
{
    DWORD  dwSize;         //�ṹ���С
    char   sDetectorID[16];   //�����ID
    char   sManagerID[16];    //������ID
    char   sSim[20];       //������Ϣ
    DWORD  dwLocalIP;      //����IPv4��ַ������dwLocalIP=0x01020304,��IP��ַΪ1.2.3.4
    DWORD  dwLocalIPMask;  //���������������룬��ʽͬdwLocalIP
    DWORD  dwLocalGateway; //�������أ���ʽͬdwLocalIP
    DWORD  dwDstIP;        //Ŀ��IP����ʽͬdwLocalIP
    BYTE   byMACAddr[6];   //����mac��ַ
    WORD  wLocalPort;     //���ض˿�
    WORD  wFirmwareYear;  //����汾���
    BYTE   byFirmwareMonth;    //����汾�·�
    BYTE   byFirmwareDay;  //����汾��
    BYTE   byMajorVersion; //�汾С����ǰ
    BYTE   byMinorVersion; //�汾С�����
    BYTE   byRes[170];
}NET_DVR_MVMRegisterInfo, *LPNET_DVR_MVMRegisterInfo;

//�ش�״̬��Ϣ
typedef struct tagNET_DVR_SingleMagneticStatus_
{
    DWORD  dwSize;             //�ṹ���С
    char   sDetectorID[16];       //�����ID
    char   sManagerID[16];        //������ID
    char   sParkNum[16];       //��λ���
    NET_DVR_TIME_V30 struDetectorTime;  //���ʱ��
    DWORD  dwRssi;             //�����ź�ǿ�ȣ�ʵ��ֵ��Χ-137~0dbm���˴�û�з��ţ�Ϊʵ��ֵ�ľ���ֵ
    BYTE   byParkinglotState;  //��λ״̬��0-�޳���1-�г�
    BYTE   byBatteryState;     //���״̬��0-100%��1-75%��2-50%��3-25%��4-С��5%
    BYTE   byDeviceState;      //�豸״̬	0-������1-����
    BYTE   byCMD;              //0-��λ�仯������1-�������������
    BYTE   byRes[184];
}NET_DVR_SingleMagneticStatus, *LPNET_DVR_SingleMagneticStatus;

//������Ϣͬ��
typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//Ĭ����1���������ݶ�ͨ���豸��
    char    szLicense[MAX_LICENSE_LEN/*16*/];//���ƺ���
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//��������
    NET_DVR_TIME_V30 struStartTime;//��Ч��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//��Ч����ʱ��
    BYTE    byVehicleType;//�������ͣ�0-����������1-С�ͳ���2-���ͳ�
    BYTE    byPlateColor;//������ɫ���ο� VCA_PLATE_COLOR
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;

//�ɷѽ����Ϣ
typedef    struct tagNET_DVR_CHARGEACCOUNT_CFG
{
    DWORD   dwSize;//�ṹ���С
    float   fAccount;//ʵ���շѽ��
    BYTE    byRes[128];
}NET_DVR_CHARGEACCOUNT_CFG,*LPNET_DVR_CHARGEACCOUNT_CFG;

//ͣ����Ʊ������豸��ǶȲ�������
typedef    struct tagNET_DVR_PXMULTICTRL_CFG
{
    DWORD        dwSize;//�ṹ���С
    DWORD        dwMultiChansWaitTime;//��Ƕ�ץ��ƥ��ʱ�䣨1~300s��
    BYTE         byMultiChansCapEnabled;//�Ƿ����ö�Ƕ�ץ�� 0-��1-��
    BYTE        byRes[127];
}NET_DVR_PXMULTICTRL_CFG,*LPNET_DVR_PXMULTICTRL_CFG;

//ͣ����Ʊ���ѻ��²�������
typedef    struct tagNET_DVR_PXOFFLINE_CFG
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byEnabled;//�Ƿ�����Ʊ���ѻ�ģʽ��0-������ 1-����
    BYTE    byChargeEnabled;//�Ƿ��ѻ��շ� 0-��1-��
    BYTE    byAlarmEnabled;//�Ƿ������ѻ����� 0-��1-��
    BYTE    byRecordSource;//��¼�������� 0-��ʶ 1-����
    DWORD   dwTimeWait;//Ʊ������ѻ�ģʽǰ�ĵȴ�ʱ�䣨1-300�룩
    /**
     realeaseMode&(0x1<<0) �̶�������
     realeaseMode&(0x1<<1) �̶�������
     realeaseMode&(0x1<<2) ��ʱ������
     realeaseMode&(0x1<<3) ��ʱ������
     realeaseMode&(0x1<<4) �޳��Ʒ���
     realeaseMode&(0x1<<5) �̶�����������Զ�����
     realeaseMode&(0x1<<6) ��ʱ����������Զ����� 
    */
    DWORD   dwRealeaseMode; //���з�ʽ����λ��ʾ
    BYTE    byVehCardmatch;//����һ��  0-��1-��
    BYTE    bySingleInSingleOut;//�������� 0-��1-��
    BYTE    byRes[126];
}NET_DVR_PXOFFLINE_CFG,*LPNET_DVR_PXOFFLINE_CFG;

typedef    struct tagNET_DVR_PARKINGSAPCE_CFG
{
    DWORD    dwSize;//�ṹ���С
    DWORD     dwTotalParkingLot;//��ͣ��λ��
    DWORD    dwCurrParkingLot;//��ǰʣ��ͣ��λ��
    BYTE    byRes[128];
}NET_DVR_PARKINGSAPCE_CFG,*LPNET_DVR_PARKINGSAPCE_CFG;

typedef    struct tagNET_DVR_PAPERCHARGEINFO_CFG
{
    DWORD   dwSize;//�ṹ���С
    char    szBarCode[LEN_16];//�����루16λ�ַ�����
    char    szLicense[MAX_LICENSE_LEN]; //���ƺ���
    char    szVehicleInTime[LEN_32];//�볡ʱ�䣨32λ�ַ��� YYYY-MM-DD HH:MM:SS��
    char    szPaymentTime[LEN_32];//�ɷ�ʱ�䣨32λ�ַ��� YYYY-MM-DD HH:MM:SS��
    float   fPaymentAmount;//�ɷѽ��
    DWORD   dwPaymentOutFailureTime;//�ɷѳ���ʧЧʱ�䣨DWORD��
    BYTE    byVehicleOutEnabled; //�Ƿ����: 0- ��1- ��
    BYTE    byRes[128];
}NET_DVR_PAPERCHARGEINFO_CFG,*LPNET_DVR_PAPERCHARGEINFO_CFG;

//ͣ����Ʊ�����
typedef    struct tagNET_DVR_ILLEGALCARDFILTERING_CFG
{
    DWORD   dwSize;//�ṹ���С
    char    sLEDDefaultInfo[MAX_LED_INFO_LEN/*512*/]; // LEDĬ����ʾ����
    BYTE    byillegalCardFilteringEnabled;//���÷Ƿ�������,0~�����ã�1~����
    BYTE    bySendCardSensingCoilEnabled;//�������Ƿ�����ظ���Ȧ
    BYTE    byWiegendSensingCoilEnabled;//Զ���뿨�Ƿ�����ظ���Ȧ
    BYTE    byGateSwitchEnabled; //�Ƿ��е�բ������Ϣ
    BYTE    byVerifyKeyWriteCardEnabled;//�Ƿ���֤��Կ��д��
    BYTE    byNoplateTakeCardEnabled;// �Ƿ������޳���ȡƾ�ݷ���
    BYTE    byRes[126];
}NET_DVR_ILLEGALCARDFILTERING_CFG,*LPNET_DVR_ILLEGALCARDFILTERING_CFG;


//ͣ��������ڳ����շѹ�����������ṹ
typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize; 
    DWORD   dwChannel;  //ͨ���� 
    char    szCardNo[32];//����
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;

//LED��Ļ��ʾ����
typedef    struct tagNET_DVR_LEDDISPLAY_CFG
{
    DWORD   dwSize;//�ṹ���С
    char    sDisplayInfo[MAX_LED_INFO_LEN/*512*/]; // LED��ʾ����
    BYTE    byDisplayMode;//��ʾ��ʽ:0~����,1~����,2~������ʾ
    BYTE    bySpeedType;//�ٶ�����:0~��,1~��,2~��
    BYTE    byShowPlateEnable;//��ʾ����ʹ�ܣ�0~�رգ�1~����
    BYTE    byRes1;
    DWORD   dwShowTime;//��ʾʱ����1~60��
    BYTE    byRes[128];
}NET_DVR_LEDDISPLAY_CFG,*LPNET_DVR_LEDDISPLAY_CFG;

//�����������Ʋ���
typedef    struct tagNET_DVR_VOICEBROADCAST_CFG
{
    DWORD        dwSize;//�ṹ���С
    char        sInfo[MAX_VOICE_INFO_LEN/*128*/]; //������������
    BYTE       byBroadcastNum;// �������������� 1~10��
    BYTE       byIntervalTime;// �����������ʱ��,1~5s
    BYTE        byRes[126];
}NET_DVR_VOICEBROADCAST_CFG,*LPNET_DVR_VOICEBROADCAST_CFG;

//ֽƱ��ӡ��ʽ����
typedef    struct tagNET_DVR_PAPERPRINTFORMAT_CFG
{
    DWORD        dwSize;//�ṹ���С
    char        sTitleInfo[MAX_LITLE_INFO_LEN/*64*/]; //ֽƱ��������
    char        sCustomInfo[MAX_CUSTOM_INFO_LEN/*64*/]; //ֽƱ�Զ�����Ϣ����
    char        sPhoneNum[MAX_PHONE_NUM_LEN/*16*/];//��ϵ�绰
    BYTE        byPrintInTimeEnabled; //�Ƿ��ӡ�볡ʱ��
    BYTE        byRes[127];
}NET_DVR_PAPERPRINTFORMAT_CFG,*LPNET_DVR_PAPERPRINTFORMAT_CFG;


//������բʱ���
typedef    struct tagNET_DVR_LOCKGATE_TIME_CFG
{
    char        sBeginTime[LEN_32];//��ʼʱ�䣨32λ�ַ��� HH:MM:SS��    
    char        sEndTime[LEN_32];//����ʱ�䣨32λ�ַ��� HH:MM:SS��
    BYTE        byRes[64];
}NET_DVR_LOCKGATE_TIME_CFG,*LPNET_DVR_LOCKGATE_TIME_CFG;

//������բ����
typedef    struct tagNET_DVR_LOCKGATE_CFG
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_LOCKGATE_TIME_CFG struTime[LOCKGATE_TIME_NUM]; //������բʱ���
    BYTE        byRes[128];
}NET_DVR_LOCKGATE_CFG,*LPNET_DVR_LOCKGATE_CFG;

//����ͬ��״̬
typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//Ӧ�����к�, ����ǰ�����ӵ�Ӧ��
    DWORD   dwParkingNum; //��ǰͣ������
    DWORD   dwUpdataSerialNum; //�������к�; ���������µ����кš�
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;

//����EPTZ����
typedef    struct tagNET_DVR_EPTZ_CFG
{
    DWORD dwSize;
    BYTE    byEnableEPTZ;        //�Ƿ�����EPTZ, 0-�����ã�1 -����
    BYTE    byRes[503];
}NET_DVR_EPTZ_CFG, *LPNET_DVR_EPTZ_CFG;

//���ĵ����
typedef    struct tagNET_DVR_CENTER_POINT_CFG
{
    DWORD dwSize;
    NET_VCA_POLYGON struRegion;//����Χ
    BYTE    byRes[512];
}NET_DVR_CENTER_POINT_CFG, *LPNET_DVR_CENTER_POINT_CFG;

/********************************DS-TME4XX���ƻ����� End****************************/

/********************************IPC FF���� Start****************************/
typedef struct tagNET_DVR_FTPUPLOAD_PARAM
{
    char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
    char szCameraName[MAX_CAMNAME_LEN/*32*/];
    BYTE byRes[64];
}NET_DVR_FTPUPLOAD_PARAM, *LPNET_DVR_FTPUPLOAD_PARAM;

//char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
//���������ǹ̶��ַ���  capture_time,plate_No,alarm_type,camera_name
//�����±��ʾ�Ⱥ�˳��

//char szCameraName[MAX_CAMNAME_LEN/*32*/];
//������szRuleTypeItem���ֶα�ʾ����Ϊ camera_name �����

typedef struct tagNET_DVR_FTPUPLOADCFG
{
    DWORD dwSize;
    BYTE byEventType; //�¼����ͣ�0-Ĭ�ϣ�1-�������
    BYTE byMode; //ͼƬ����ģʽ��0-Ĭ�ϣ�1-�Զ���
    BYTE byRes[62];
    NET_DVR_FTPUPLOAD_PARAM  struCustomVehicle[MAX_FTPNAME_NUM/*12*/];
    BYTE byRes1[1024] ;
}NET_DVR_FTPUPLOADCFG, *LPNET_DVR_FTPUPLOADCFG;

/********************************IPC FF���� End****************************/

//��Ϣ�����ն�����
typedef struct tagNET_DVR_PUBLISH_UPGRADE_COND
{
    DWORD dwSize;
    DWORD dwUpgradeType;    //�������ͣ�1-���ն�������2-���ն�������
    DWORD dwTerminalNum;    //�������ն˸�ʽ�����ն�����ʱ��Ч
    DWORD *pTerminalNo;     //��Ҫ�������ն˺ţ����ն�����ʱ��Ч
    DWORD dwGroupNo;        //�ն���ţ����ն�������ʱ��Ч
    BYTE  byRes[32];
}NET_DVR_PUBLISH_UPGRADE_COND, *LPNET_DVR_PUBLISH_UPGRADE_COND;
//WEP������Կ
typedef struct tagNET_DVR_WEP_KEY_CFG
{
    char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//������Կ�� 
    BYTE    byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;

typedef struct tagNET_DVR_SUB_UPGRADE_PROGRESS
{
    DWORD dwTerminalNo; //�ն˺�
    DWORD dwProgress;   //�ն��������ȣ�0-100��101��ʾ���ն����������쳣,,102-�ն˽�ѹʧ�ܣ�103-�������汾��ƥ�䣬104-�������ļ���105-�Ƿ�ǩ��������
}NET_DVR_SUB_UPGRADE_PROGRESS, *LPNET_DVR_SUB_UPGRADE_PROGRESS;

typedef struct tagNET_DVR_UPGRADE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //�����ȣ�0-100
    DWORD  dwSubProgressNum;    //�ӽ��ȸ���
    LPNET_DVR_SUB_UPGRADE_PROGRESS  lpStruSubProgress; //���ն��������ӽ��ȣ�dwSubProgressNum��NET_DVR_SUB_UPGRADE_PROGRESS����
    BYTE   byRes[32];
}NET_DVR_UPGRADE_PROGRESS_RESULT, *LPNET_DVR_UPGRADE_PROGRESS_RESULT;

//��Ϣ�����������ճ̷�������
typedef struct tagNET_DVR_SCHEDULE_PROGRESS_COND
{
    DWORD dwSize;
    DWORD dwScheduleNo;     //�ճ̺�
    BYTE  byProgressType;   //��ȡ�Ľ������ͣ�1-�����ȡ���ȣ�2-���ն˻�ȡ���ȣ�3-����֯��ȡ����
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //�ն���Ż���֯����������Ϊ1��3ʱ��Ч
    DWORD dwTerminalNo;     //�ն˺ţ���������Ϊ2ʱ��Ч
    BYTE  byRes2[32];
}NET_DVR_SCHEDULE_PROGRESS_COND, *LPNET_DVR_SCHEDULE_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_SCHEDULE_PROGRESS
{
    DWORD dwTerminalNo; //�ն˺�
    DWORD dwProgress;   //�ն��ճ̷������ȣ�0-100��101��ʾ���ն��ճ̷��������쳣,102��ʾ���ն˴洢�ռ䲻��,103-�ն˲����ߣ�104-�ն˾ܾ���105-���������ն������ж�
}NET_DVR_SUB_SCHEDULE_PROGRESS, *LPNET_DVR_SUB_SCHEDULE_PROGRESS;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //�����ȣ�0-100�������ȡ����ʱΪ�����ճ̷������ȣ����ն˻�ȡ����ʱΪ�����ն��ճ̷�������
    DWORD  dwSubProgressNum;    //�ӽ��ȸ����������ȡʱ��Ч����ʾ���¸��ն˽��ȸ���
    LPNET_DVR_SUB_SCHEDULE_PROGRESS  lpStruSubProgress; //���ն��ճ̷������ӽ��ȣ������ȡʱ��Ч��dwSubProgressNum��NET_DVR_SUB_SCHEDULE_PROGRESS����
    BYTE   byRes[32];
}NET_DVR_SCHEDULE_PROGRESS_RESULT, *LPNET_DVR_SCHEDULE_PROGRESS_RESULT;

//��Ϣ�����岥����
typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_COND
{
    DWORD dwSize;
    BYTE   byInsertType;    //�岥���ͣ�1-�زģ�2-��Ŀ
    BYTE   byRes3[3];
    DWORD dwInsertNo;        //����岥�������زģ�Ϊ�زı�ţ�����岥�����ǽ�Ŀ��Ϊ��Ŀ���
    BYTE  byProgressType;   //��ȡ�Ľ������ͣ�1-�����ȡ���ȣ�2-���ն˻�ȡ����
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //�ն���ţ���������Ϊ1ʱ��Ч
    DWORD dwTerminalNo;     //�ն˺ţ���������Ϊ2ʱ��Ч
    BYTE  byRes2[32];
}NET_DVR_INSERTPLAY_PROGRESS_COND, *LPNET_DVR_INSERTPLAY_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_INSERTPLAY_PROGRESS
{
    DWORD dwTerminalNo; //�ն˺�
    DWORD dwProgress;   //�ն˲岥���ȣ�0-100��101��ʾ���ն˲岥�����쳣,102��ʾ���ն˴洢�ռ䲻��,103��ʾȡ���岥,104�岥�زı��滻
}NET_DVR_SUB_INSERTPLAY_PROGRESS, *LPNET_DVR_SUB_INSERTPLAY_PROGRESS;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //�����ȣ�0-100�������ȡ����ʱΪ����岥���ȣ����ն˻�ȡ����ʱΪ�����ն˲岥����
    DWORD  dwSubProgressNum;    //�ӽ��ȸ����������ȡʱ��Ч����ʾ���¸��ն˽��ȸ���
    LPNET_DVR_SUB_INSERTPLAY_PROGRESS  lpStruSubProgress; //���ն˲岥���ӽ��ȣ������ȡʱ��Ч��dwSubProgressNum��NET_DVR_SUB_INSERTPLAY_PROGRESS����
    BYTE   byRes[32];
}NET_DVR_INSERTPLAY_PROGRESS_RESULT, *LPNET_DVR_INSERTPLAY_PROGRESS_RESULT;




//WEP����
typedef struct tagNET_DVR_WEP_CFG
{
    BYTE   byAuthenticationType;//�����֤���ͣ�0~������֤��1~������Կ��2~�Զ���֤
    BYTE   byDefaultTransmitKeyIndex;//Ĭ�ϴ�����Կ������1~4������Ӧ��struEncryptionKeyCfg������Կ�ĸ�����
    /*
    ��Ϊ64λ��Կʱ��ASCII����Կ�ַ�����Ϊ5����
    ��Ϊ128λ��Կʱ��ASCII����Կ�ַ�����Ϊ13����
    */
    BYTE   byWepKeyLenType;//��Կ���ͣ�0~   64λ��Կ��1~  128λ��Կ��
    BYTE   byKeyType;// ��Կ���ͣ�0~   ASCII�룬1~  16���ơ�
    NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP������Կ�����֧��4����
    BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

//WPA����
typedef struct tagNET_DVR_WPA_CFG
{
    BYTE   byAlgorithmType; //�㷨���ͣ�0~TKIP, 1~AES, 2~TKIP/AES
    BYTE   byWPAKeyLen;// WPA������Կ���ȣ�����Ϊ8~63����Ӧ��csSharedKey�������ַ�����
    BYTE   byDefaultPassword;//�Ƿ�����Ĭ��WPA��Կ
    BYTE   byRes1;
    char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//WPA������Կ,Ϊ8-63��ASCII�ַ�
    BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;


typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
    BYTE   bySecurityMode; //��ȫģʽ��0~����,1~WEP,2~WPA-personal, 3~WPA2-personal
    NET_DVR_WEP_CFG  struWEPCfg; //����ȫģʽѡ��ΪWEPʱ��Ч��
    NET_DVR_WPA_CFG  struWPACfg; //����ȫģʽѡ��ΪWPA-personal��WPA2-personalʱ��Ч��
    BYTE    byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

//wifi�ȵ��������(������)
typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD    dwSize;//�ṹ���С
    BYTE    byWifiAPEnabled;  //�Ƿ���������AP��0-��1- ��
    BYTE    byBroadcastEnabled; // �Ƿ����ù㲥��0-��1-��
    BYTE    byWlanShareEnabled; //�Ƿ����ù���0-��1-��
    BYTE    byDHCPEnabled; //�Ƿ�����DHCP��0-��1-��
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType; //IP��ַ���ͣ�0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr;  //IP��ַ
    NET_DVR_IPADDR    struIPMask;  //�����ַ
    NET_DVR_IPADDR    struGatewayIPMask;  //���ص�ַ
    NET_DVR_IPADDR    struStartIPAddrPool;  //IP����ʼ��ַ
    NET_DVR_IPADDR    struEndIPAddrPool;  // IP�ν�����ַ
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS��ַ
    NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg;//���߰�ȫ���ܲ���
    BYTE    byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;    //ͨ���ţ�0Ϊ��Ч
    BYTE byChannelName[NAME_LEN];
    BYTE bySignal;  //�Ƿ����źţ�0-�ޣ�1-�У�ֻ��
    BYTE bySignalType;  //�ź�Դ���ͣ�1-���壬2-���壬���ź�ʱ��Ч��ֻ��
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;    //�Ƿ���Ч��0-��Ч��1-��Ч
    BYTE  byRes1[3];
    DWORD dwDevNo;    //��˻���
    BYTE  byDevName[NAME_LEN];   //�ڵ��˻�����
    BYTE  byDevID[MAX_ID_LEN];   //��˻�����ID���豸Ψһ��ʶ��ֻ��
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM];
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

#define MAX_OPTICAL_DEV_NODE 32     //���ڵ��˻���

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //�Ƿ����źŽ��룬0-�ޣ�1-�У�ֻ��
    BYTE  byLinkType;    //��·���ͣ�1-������2-������ֻ��
    BYTE  byPortWorkMode;    //�˿ڹ���ģʽ��0-��Ч��1-���ڣ�2-���ڣ�����·����Ϊ����ʱ��Ч��ֻ��
    BYTE  byRes1[1];
    DWORD dwPairPort;    //��Թ�ںţ���·����Ϊ����ʱ��Ч������ʱ�˲���Ϊ���ںţ�����ʱ���˲���Ϊ���ں�
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //�ڵ��˻��豸��Ϣ
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
    DWORD dwSize;
    BYTE  byEnable;    //�Ƿ������˻����룬0-�񣬷�0-��
    BYTE  byRes1[3];
    DWORD dwDevNo;    //��˻���
    DWORD dwOpticalPort;  //��ں�
    BYTE  byDevID[MAX_ID_LEN];   //��˻�����ID
    DWORD dwInputChanNo;  //��˻�����ͨ����
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;

typedef  struct tagNET_DVR_START_FILE_TO_CLOUD_COND
{
    DWORD    dwSize; 
    BYTE    aCameraID[MAX_CAMERAID_LEN];    //������ID
    DWORD      dwPoolID;    //�洢��ID
    DWORD      dwRepPoolID;    //�����ID
    WORD      wReplication;    //�������
    BYTE       byRes [178];
}NET_DVR_START_FILE_TO_CLOUD_COND,*LPNET_DVR_START_FILE_TO_CLOUD_COND;

typedef  struct     tagNET_DVR_START_PICTURE_FROM_CLOUD_COND
{
    DWORD       dwSize;
    BYTE        aCameraID[MAX_CAMERAID_LEN];    //������ID
    NET_DVR_TIME_V30    struBeginTime;    //��ʼʱ��
    NET_DVR_TIME_V30    struEndTime;        //����ʱ��
    DWORD   dwPicType;        //ͼƬ���ͣ���λ��ʾ
    //bit0-JPG
    //bit1-BMP
    //bit2-PNG
    BYTE    byRes1[3];
    BYTE    byZoomType;    //0-������,1-������,2-����С,3-���ֱ���
    union
    {
        BYTE    uLen[32];
        struct
        {
            BYTE        byScale;         //1~99
        }struScale;
        struct
        {
            BYTE        byQuality;    //1~99
        }struQuality;
        struct
        {
            DWORD       dwWidth;    
            DWORD       dwHeight;
        }struResolution; //Ŀ��ֱ���
    }uZoomParam;
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //���ݻص�����
    void*   pUser;    //�û�����ָ��
    BYTE    byRes [372];
}NET_DVR_START_PICTURE_FROM_CLOUD_COND,*LPNET_DVR_START_PICTURE_FROM_CLOUD_COND;

typedef     struct    tagNET_DVR_START_PICTURE_FROM_CLOUD_RET
{
    DWORD       dwSize;
    DWORD       dwFileCount;    //�ļ�����
    BYTE        byRes[120];
}NET_DVR_START_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_START_PICTURE_FROM_CLOUD_RET;

typedef  struct 
{
    DWORD       dwSize;
    NET_DVR_TIME_V30    struTime;    //ͼƬʱ��
    DWORD       dwPicLen;    //ͼƬ����
    BYTE        byPicType;    //ͼƬ��ʽ,1-jpg,2-bmp,3-png
    BYTE        byRes[107];
}NET_DVR_PICTURE_FROM_CLOUD_RET,*LPNET_DVR_PICTURE_FROM_CLOUD_RET;

typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //���֤��Ϣ�ϱ���0���ϴ�18λ���֤�ţ�1���ϴ�ȫ����Ϣ
    BYTE byRes1;
    BYTE byCardVerifyMode; //ˢ����֤ģʽ��0��Զ��������֤��1���ͻ���ƽ̨��֤��2��ˢ������
    BYTE byACSDevType; //�豸�ͺţ�1�����֤��������2��IC��������3����ά���������4��ָ�ƶ�������5���ַ���+��ά���������6���տ�����7���ַ�����8��ָ��ͷ��9������ģ�飻10����֤�豸
    BYTE byDoorMode; //�ų������ͣ�0�����ţ�1�����ţ�
    BYTE byRes2;
    WORD wDevDetailType; //����ľ����豸�ͺţ�0-iDR210��1-IDM10��2-�������֤�Ķ���
    BYTE byRes[300];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;            //����ģʽ��0�ܿأ�1��ֹ��2���ɣ�
    BYTE byOutMode;         //����ģʽ��0�ܿأ�1��ֹ��2���ɣ�
    BYTE byWorkMode;        //����ģʽ��0������1ά����2���գ�3������ 
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

#define MAX_ID_NUM_LEN                  32  //������֤�ų���
#define MAX_ID_NAME_LEN                 128   //�����������
#define MAX_ID_ADDR_LEN                 280   //���סַ����
#define MAX_ID_ISSUING_AUTHORITY_LEN    128 //���ǩ�����س���

//���֤��Ϣ
typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;        //�ṹ����
    BYTE  byName[MAX_ID_NAME_LEN];   //����
    NET_DVR_DATE struBirth; //��������
    BYTE byAddr[MAX_ID_ADDR_LEN];  //סַ
    BYTE byIDNum[MAX_ID_NUM_LEN];   //���֤����
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];  //ǩ������
    NET_DVR_DATE struStartDate;  //��Ч��ʼ����
    NET_DVR_DATE struEndDate;  //��Ч��ֹ����
    BYTE byTermOfValidity;  //�Ƿ�����Ч�� 0-��1-�ǣ���Ч��ֹ������Ч��
    BYTE   bySex;  //�Ա�1-�У�2-Ů
    BYTE  byNation;
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

//���֤��Ϣ����
typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;        //�ṹ����
    NET_DVR_ID_CARD_INFO    struIDCardCfg ;//���֤��Ϣ
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME_V30  struSwipeTime; //ʱ��
    BYTE    byNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR    struRemoteHostAddr ;//Զ��������ַ
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    DWORD dwDoorNo; //�ű�ţ�Ϊ0��Ч
    DWORD dwPicDataLen;   //ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pPicData;
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������Ϊ0��Ч
    BYTE byDeviceNo;                             // �豸��ţ�Ϊ0ʱ��Ч����Ч��Χ1-255��
    BYTE byRes2[2];
    DWORD dwFingerPrintDataLen;                  // ָ�����ݴ�С����Ϊ0�Ǳ�ʾ���������
    char *pFingerPrintData;
    DWORD dwCapturePicDataLen;                   // ץ��ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char *pCapturePicData;
    DWORD dwCertificatePicDataLen;   //֤��ץ��ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pCertificatePicData;
    BYTE byCardReaderKind; //������������һ�࣬0-��Ч��1-IC��������2-���֤��������3-��ά�������,4-ָ��ͷ
    BYTE byRes[179];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

//���֤��Ϣ�����������ṹ
typedef struct tagNET_DVR_ID_CARD_BLACK_LIST_COND
{
    DWORD       dwSize;
    BYTE        byRes[256];          //����
}NET_DVR_ID_CARD_BLACK_LIST_COND, *LPNET_DVR_ID_CARD_BLACK_LIST_COND;

//���֤��Ϣ����������
typedef struct tagNET_DVR_ID_CARD_BLACK_LIST_CFG
{
    DWORD                     dwSize;
    NET_DVR_ID_CARD_INFO      struIDCardCfg;          // ���֤��Ϣ
    DWORD                     dwFingerPrintDataLen;   // ���ָ֤�����ݴ�С����Ϊ0�Ǳ�ʾ���������
    char                      *pFingerPrintData;
    DWORD                     dwPicDataLen;           // ���֤ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char                      *pPicData;
    BYTE                      byRes[128];
}NET_DVR_ID_CARD_BLACK_LIST_CFG, *LPNET_DVR_ID_CARD_BLACK_LIST_CFG;

//A =��ĸ�ַ� [a..z, A..Z]��N = �����ַ� [0..9]��S = �����ַ� [��<��]��B=����������
typedef struct tagNET_DVR_PASSPORT_INFO
{
    DWORD  dwSize;           //�ṹ����
    BYTE    byOCR;             //0-���ӻ������ݣ�1- OCRʶ�����ݣ�
    BYTE    byRes1[3];           //����
    BYTE    byType[MAX_PASSPORT_TYPE_LEN];         //֤�����ͣ���������A��S
    BYTE    byCountryIssue[MAX_PASSPORT_INFO_LEN];  //ǩ������ǩ����������������A��S
    BYTE    byName[MAX_PASSPORT_NAME_LEN];       //��������������A��S
    BYTE    byPassportNo[MAX_PASSPORT_NUM_LEN];    //֤�����룬��������A��N��S
    BYTE    byNationality[MAX_NATIONALITY_LEN];    //���� ����������A��S
    NET_DVR_DATE struBirth;       //��������
    NET_DVR_DATE struExpireDate;  //��Ч��ֹ����
    BYTE  bySex;                  //�Ա�1-�У�2-Ů
    BYTE  byRes2[35];              //����
    BYTE  byLocalName[MAX_PASSPORT_INFO_LEN];      //������������������B
    BYTE  byNumber[MAX_PASSPORT_INFO_LEN];         //���˺��룬��������A��N��S
    BYTE  byPlaceOfBirth[MAX_PASSPORT_INFO_LEN];     //�����أ���������B
    BYTE  byAddr[MAX_PASSPORT_INFO_LEN];           //��ַ����������A��N��S��B
    BYTE  byPhone[MAX_PASSPORT_INFO_LEN];          //�绰����������N��S
    BYTE  byJob[MAX_PASSPORT_INFO_LEN];             //ְҵ����������B
    BYTE  byTitle[MAX_PASSPORT_INFO_LEN];            //ְ�Σ���������B
    BYTE  byResume[MAX_PASSPORT_INFO_LEN];         //��������������B
    BYTE  byOtherNumber[MAX_PASSPORT_INFO_LEN];         //��������֤�����룬��������A��N��S��B
    BYTE  byMonitoring[MAX_PASSPORT_MONITOR_LEN];         //�໤��Ϣ����������B
    BYTE  byRes[128];
}NET_DVR_PASSPORT_INFO, *LPNET_DVR_PASSPORT_INFO;

//������Ϣ�ϴ�
typedef struct tagNET_DVR_PASSPORT_ALARM
{
    DWORD  dwSize;        //�ṹ����
    DWORD dwMajor; //���������ͣ��ο��궨��
    DWORD dwMinor; //���������ͣ��ο��궨��
    NET_DVR_TIME_V30  struSwipeTime; //ʱ��
    BYTE	byNetUser[MAX_NAMELEN];//����������û���
    NET_DVR_IPADDR	struRemoteHostAddr;//Զ��������ַ
    DWORD dwCardReaderNo; //��������ţ�Ϊ0��Ч
    BYTE  byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������Ϊ0��Ч
    BYTE byRes2[11];
    NET_DVR_PASSPORT_INFO struPassportInfo;//������Ϣ
    DWORD dwFaceDataLen;     //�������ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pFaceData;
    DWORD dwPicDataLen;      //����֤��ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pPicData;          //���� [ISO/IEC 10918-1] ��ʽ���Ĺ���֤��ͼ��
    DWORD dwCapturePicDataLen;   //ץ��ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char    *pCapturePicData;
    BYTE byRes[128];
}NET_DVR_PASSPORT_ALARM, *LPNET_DVR_PASSPORT_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;        //�ṹ����
    DWORD  dwAccessChannel;    //��Աͨ����
    NET_DVR_TIME_V30  struSwipeTime; //ʱ��
    BYTE    byNetUser[MAX_NAMELEN] ;//����������û���
    NET_DVR_IPADDR    struRemoteHostAddr ;//Զ��������ַ
    DWORD    dwEntryTimes;    //��Ա�������
    DWORD    dwExitTimes;        //��Ա��������
    DWORD    dwTotalTimes;        //��Ա�����ܴ����� 
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;
typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
    DWORD   dwSize;
    DWORD   dwVideoMangeNo;  //��Ƶ�����
    BYTE    byVideoType;  //��Ƶ��ʽ 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB 
    BYTE    byRes1[3];  //����
    BYTE    sVideoName[NAME_LEN];  //��Ƶ���� 
    NET_DVR_TIME_V30 struTime;  //ͼƬ�ϴ�ʱ��
    BYTE     byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
    DWORD   dwSize;
    BYTE    sFileName[NAME_LEN];  //�ļ�����
    DWORD    dwManageNo;     //(ֻ�ܻ�ȡ)
    NET_DVR_TIME_EX  struTime;    //�ĵ��ϴ�ʱ�� 
    BYTE    byUsed;          //�Ƿ��Ѵ��ڣ�0-�����ڣ�1-���� ��ֻ�ܻ�ȡ��
    BYTE    byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
    DWORD    dwSize;
    BYTE    byItemType;  //���������ͣ�1-ͼƬ 2-��Ƶ 3-�����б� 
    BYTE    byRes[3];    //����
    DWORD    dwPlayManageNo;   //���Ź����
    DWORD    dwPlayPicTime; //����ͼƬʱ�䣬��λ��, (����ΪͼƬ��Ч) 
    BYTE    byRes2[64]; 
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM; 

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
    DWORD    dwSize;
    BYTE    byEnable;  //�Ƿ���Ч�� 0-��Ч  !0-��Ч
    BYTE    byPlayType;  //����ģʽ��1-ѭ������
    BYTE    byVaildItemNum;    //��Ч����������
    BYTE    byRes[1]; 
    NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM]; //�����ǰbyVaildItemNum��Ч
    BYTE     byPlaylistName[PLAYLIST_NAME_LEN];  //�����б�����   
    DWORD   dwPlaylistNo;    //�����б�ţ���ȡ��Ч��
    BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;
typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
    DWORD    dwSize;   
    BYTE    byCtrlType;  //�������ͣ� 1-��Ӳ�����  2-ɾ��������  3-�ƶ�������λ��
    BYTE    byPlayIndex;  //������ţ� ��1��ʼ
    NET_DVR_PLAY_ITEM struPlayItem;    //������
    BYTE   byNewPlayIndex;   //�²�����ţ�0��Ч
    BYTE   byRes[63]; 
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL; 
typedef struct tagNET_DVR_PLAN_ITEM
{
    NET_DVR_PLAY_ITEM struPlanPlayItem;       //������    
    NET_DVR_TIME_SEGMENT struTimeSegment;     //ʱ��β���
    BYTE  byRes[16]; 
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD    dwSize;   
    BYTE    byEnable;  //�Ƿ�ʹ��,  0-��ʹ�� !0-ʹ��
    BYTE    byPlanMode;   //�ƻ�ģʽ��1-�ܼƻ�  2-�ռƻ�
    BYTE    byRes[2];
    NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwPlayPlanNo;   //���żƻ��ţ���ȡʱ��Ч��
    BYTE    byPlayPlanName[NAME_LEN]; //���żƻ�����
    BYTE    byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;
typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;    //�Ƿ����ò��żƻ��� 0-������ !0-����
    BYTE byRes[3];
    DWORD dwPlayPlanNo;   //���żƻ���
    BYTE byRes2[32]; 
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG; 
typedef struct tagNET_DVR_DEV_PLAYCTRL
{
    DWORD   dwSize;
    BYTE    byControlType;  //�������ͣ�1-��Ƶ����2-��Ƶ�أ�3-ֹͣ���ţ�4-��ͣ���ţ��ָ����� 
    BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;

typedef union tagNET_DVR_PLAYITEM_INFO
{
    struct   //��������
    {
        DWORD  dwPlayItem;   //������
        BYTE    byPlayItemName[NAME_LEN]; //����������
        BYTE    byRes2[8]; 
    } struPlayItem;    
    struct  //�����б�
    {
        DWORD  dwPlaylistNo;  //�����б��
        BYTE    byPlaylistName[NAME_LEN]; //�����б�����
        WORD   wPlayIndex;    //����λ��
        BYTE    byPlayType;    //�����б������ڲ������� 1-ͼƬ 2-��Ƶ  
        BYTE    byRes[3];      
        DWORD  dwPlayItem;   //������    
        BYTE    byPlayItemName[NAME_LEN]; //����������
        BYTE    byRes2[16];
    } struPlaylistItem;
    struct  //���żƻ���
    {
        DWORD  dwPlayPlanNo;  //���żƻ��� 
        NET_DVR_TIME_SEGMENT struTime;      //���ڲ���ʱ���
        BYTE    byPlayType;  //���żƻ����ڲ�������  1-ͼƬ 2-��Ƶ 3-�����б�
        BYTE    byRes[3]; 
        DWORD  dwPlaylistNo;  //�����б��
        BYTE    byPlaylistName[NAME_LEN]; //�����б�����
        DWORD  dwPlayItem;   //������
        BYTE    byPlayItemName[NAME_LEN]; //����������
        WORD   wPlayIndex;    //����λ��
        BYTE    byRes2[18];       
    } struPlayPlanItem;
}NET_DVR_PLAYITEM_INFO, *LPNET_DVR_PLAYITEM_INFO; 
typedef struct tagNET_DVR_PLAYING_INFO
{
    DWORD    dwSize;
    BYTE    byPlayWay;   //���ŷ�ʽ�� 1-�����  2-�����б�  3-���żƻ� 4-��̬���� 5-�����岥
    BYTE    byCurPlayType; //���ڲ����ز����ͣ� 1-ͼƬ 2-��Ƶ����̬����ͽ����岥ʱ��Ч
    BYTE    byPlayState;    //����״̬��1-���ڲ��ţ�2-����ֹͣ��3-������ͣ
    BYTE    byAudioState;    //��Ƶ����״̬��0-�أ�1-��
    NET_DVR_PLAYITEM_INFO  struPlayItemInfo;  //��������Ϣ
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_ONLINEUSER_COND //�����ṹ
{
    DWORD   dwSize; 
    DWORD  dwChannel;//ͨ���ţ�ǰ��Ĭ����1��
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG //���ýṹ
{
    DWORD   dwSize; 
    BYTE   byID;//�û����к�
    BYTE   byUserType;//�û����� 0-��ͨ�û���1-����Ա��2-�����û�
    BYTE   byDataType;//����״̬����:0-����У�1-��ʼ��2-����
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;//IP��ַ    
    NET_DVR_TIME_V30  struLoginTime;//��½ʱ��
    char   szUserName[NAME_LEN/*32*/];//�û���
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;

//�洢����״̬
typedef    struct tagNET_DVR_STORAGE_DETECTION
{
    DWORD    dwSize;//�ṹ���С
    BYTE    byHealthState;//����״̬0-���ã�1-�2-�𻵣�3-δ֪
    BYTE    bySDCardState;//SDcard״̬ 0-���ߣ�1-����,2-δ֪,3-������
    WORD    wAbnormalPowerLoss;//�쳣������
    WORD    wBadBlocks;//������
    BYTE    byRemainingLife; //SD��ʣ������; 0~100%
    BYTE    byRes[125];
}NET_DVR_STORAGE_DETECTION,*LPNET_DVR_STORAGE_DETECTION;

//�洢���ܼ�ⱨ���ϴ�
typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //���ʱ��
    DWORD    dwAbsTime; //����ʱ��
    NET_VCA_DEV_INFO  struDevInfo;   //ǰ���豸��Ϣ
    DWORD   dwCardID;   //��ID
    WORD    wAbnormalPowerLoss;//�쳣������
    WORD    wBadBlocks;//������
    BYTE    byHealthState;//����״̬0-���ã�1-�2-�𻵣�3-δ֪
    BYTE    byRes1[3];
    float   fResidualLife; //SD�� Ԥ��ʣ������
    BYTE    byRes[118];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;


//�洢���Ķ�д������
typedef    struct tagNET_DVR_STORAGE_RWLOCK
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byEnabled;//ʹ�� 0-�رգ�1-����
    BYTE    byRes[3];
    char    szPassWD[PASSWD_LEN/*16*/]; //��д��������
    char    szOriginalPassWD[PASSWD_LEN/*16*/]; //ԭʼ����
    BYTE    byRes1[128];
}NET_DVR_STORAGE_RWLOCK,*LPNET_DVR_STORAGE_RWLOCK;

//�洢���Ľ�������
typedef    struct tagNET_DVR_STORAGE_UNLOCK
{
    DWORD   dwSize;//�ṹ���С
    char    szPassWD[PASSWD_LEN/*16*/]; //����
    BYTE    byRes1[128];
}NET_DVR_STORAGE_UNLOCK,*LPNET_DVR_STORAGE_UNLOCK;


typedef    struct tagNET_DVR_PTZTRACKSTATUS
{
    DWORD        dwSize;//�ṹ���С
    BYTE          byID;//�����豸��ID (�ֶ�byLinkageType��0��ʱ����Ч)
    BYTE      byLinkageType;//��������0-��������1-��������豸����
    BYTE      byRes[254];
}NET_DVR_PTZTRACKSTATUS,*LPNET_DVR_PTZTRACKSTATUS;

#define MAX_PROXY_COUNT 32

typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129];  //�����������ַ
    BYTE  byAuthType; //��֤��ʽ����ʱ�Ȳ�ʹ�ø��ֶ� 
    WORD  wPort;      //����������˿�
    BYTE  byRes2[64]; //���Ҫʹ����֤��ʽ����Ȼ��ҪһЩ�����ֽڣ�����һЩ
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD                     dwLength;         //�ṹ����
    DWORD                    dwChannel;         //ͨ��
    NET_DVR_TIME_V30        struTimePoint;    //ʱ���
    BYTE  byID[STREAM_ID_LEN/*32*/];      //ID����
    BYTE                      byRes[32];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen;     //ͼƬ����
    char     *pPicBuf;     //ͼƬ����
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;

//�ֶ�������
typedef    struct tagNET_DVR_MANUALRANGING_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ����ֶ���ࣺ0- ��1- ��
    BYTE        byRes[127];
}NET_DVR_MANUALRANGING_CFG,*LPNET_DVR_MANUALRANGING_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD           dwSize;            //�ṹ���С
    BYTE           byDoorNotCloseAlarm;   //�Ƿ��ϴ���δ�ر�����0-���ϴ���1-�ϴ�
    BYTE            byRes[603];         //����
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp 
    DWORD    dwYear;            //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate,��֡��С��0ʱ��0x80000002:��ʾ1/2֡�ʣ�ͬ�����0x80000010Ϊ1/16֡��
    DWORD    dwFlag;         //flag E֡���
    DWORD    dwFilePos;      //file pos
    DWORD     dwPacketType;    //Packet type:0 -file head��1 -video I frame��2- video B frame�� 3- video P frame�� 10- audio packet�� 11- private packet
    DWORD     dwPacketSize;   //packet size
    unsigned char*    pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   //�����ʽ:0-������1-FU_A�����ʽ
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] ��ʾ˽���������� 
    //reserved[1] ��ʾ˽�������ݵ�ַ��λ
    //reserved[2] ��ʾ˽�������ݵ�ַ��λ
    //reserved[3] ��ʾ˽�������ݳ���
    //reserved[4] ˽��֡/����ʱ����\ʱ���
    //reserved[5].һbitλ����Ƿ�Ϊ��P֡����P��1����Ϊ��P��0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef BOOL (* DEV_WORK_STATE_CB)(void* pUserdata, int iUserID, LPNET_DVR_WORKSTATE_V40 lpWorkState);

typedef struct tagNetDVRCheckDevState
{
    DWORD                dwTimeout;      //��ʱ����豸����״̬����λms��Ϊ0ʱ����ʾʹ��Ĭ��ֵ(30000)����СֵΪ1000
    DEV_WORK_STATE_CB    fnStateCB;
    void*                pUserData;
    BYTE                byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;

#define COURSE_NAME_LEN_128                128    //�γ�����
#define INSTRUCTOR_NAME_LEN_64            64    //�ڿν�ʦ
#define MAX_UUID_LEN            64    //�ֶ��γ�UUID

//��ȡ�����ṹ��
typedef    struct tagNET_DVR_COURSE_LIST_COND
{
    DWORD                    dwSize;
    NET_DVR_TIME_V30        struStartTime;   //�γ̿�ʼʱ��
    NET_DVR_TIME_V30        struEndTime;   //�γ̽���ʱ��
    BYTE                       byCourseName[COURSE_NAME_LEN_128];  //�γ�����
    BYTE                       byInstructorName[INSTRUCTOR_NAME_LEN_64]; //�ڿ���ʦ
    BYTE                   byCourseType; //�α����ͣ�0-ȫ����1-�ֶ�
    BYTE                    byRes[603];
}NET_DVR_COURSE_LIST_COND,*LPNET_DVR_COURSE_LIST_COND;

typedef struct  tagNET_DVR_COURSE_CFG
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //�γ̿�ʼʱ��
    NET_DVR_TIME_V30        struEndTime;   //�γ̿�ʼʱ��
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE            byRecUUID[MAX_UUID_LEN/*64*/];  //�ֶ��α�UUID
    BYTE           byCourseType;//�α����ͣ�0-ȫ����1-�ֶ��α�
    BYTE            byRes[303];
}NET_DVR_COURSE_CFG, *LPNET_DVR_COURSE_CFG;

typedef struct tagNET_DVR_RECORD_STATUS
{
    DWORD       dwSize;              //�ṹ���С
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //�ֶ��α�UUID
    BYTE        byRecordStatus;         //¼��״̬��0-��ͣ��1-����,2-����¼��3-����
    BYTE        byRes1[3];              //�����ֽ�
    DWORD       dwRecordingTime;      //��¼��ʱ������λ���룬���Ϊ12*60*60
    BYTE        byRes[596];              //�����ֽ� 
}NET_DVR_RECORD_STATUS, *LPNET_DVR_RECORD_STATUS;

typedef struct tagNET_DVR_MANUAL_CURRICULUM_CFG
{
    DWORD       dwSize;              //�ṹ���С
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //�ֶ��α�UUID
    BYTE           byCourseName[COURSE_NAME_LEN_128];  //�γ�����
    BYTE           byInstructorName[INSTRUCTOR_NAME_LEN_64]; //�ڿ���ʦ
    BYTE        byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE        byCmdType;            //���0-��ʼ¼�� 1-���� 2-��ͣ 3-����,4-��ʼ���Σ�5-��������
    BYTE         byRes[303];              //�����ֽ�
}NET_DVR_MANUAL_CURRICULUM_CFG, *LPNET_DVR_MANUAL_CURRICULUM_CFG;

typedef struct tagNET_DVR_IMAGE_DIFF_DETECTION_CFG
{
    DWORD       dwSize;              //�ṹ���С
    NET_VCA_POLYGON struRegion;    //����Χ
    BYTE       byEnabled;    //�Ƿ����ã�0-�����ã�1-����
    BYTE        byThreshold;             //��ֵ[0,100]
    BYTE         bySensitivity;        //������ [0,100]
    BYTE        byVideoInputType;  //��Ƶ��������ͣ�0-�Զ���1-HDMI��2-VGA
    BYTE     byRes[300];              //�����ֽ� 
}NET_DVR_IMAGE_DIFF_DETECTION_CFG, *LPNET_DVR_IMAGE_DIFF_DETECTION_CFG;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //�����ļ�ID
    BYTE             byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_COND, *LPNET_DVR_RECORDING_PUBLISH_FILE_COND;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_INFO
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //�γ̿�ʼʱ��
    NET_DVR_TIME_V30        struEndTime;   //�γ̿�ʼʱ��
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE     byRes[300];              //�����ֽ� 
}NET_DVR_RECORDING_PUBLISH_FILE_INFO, *LPNET_DVR_RECORDING_PUBLISH_FILE_INFO;

//��Ļ����
typedef struct tagNET_DVR_SCREEN_POINT
{
    WORD wX; //X����
    WORD wY; //Y����
}NET_DVR_SCREEN_POINT,*LPNET_DVR_SCREEN_POINT;

typedef struct tagNET_DVR_MOUSE_PARAM
{
    BYTE byMouseEvent;                   //����¼���1-���������£�2-�������ɿ���3-����Ҽ����£�4-����Ҽ��ɿ���
                                         //5-����ƶ���6-������������7-������˫����8-����Ҽ�������9-���ְ��£�
                                         //10-�����ɿ���11-�������£�12-��������
    BYTE byRes1[3];
    NET_DVR_SCREEN_POINT struMousePoint; //���������Ϣ
    BYTE byRes2[8];
}NET_DVR_MOUSE_PARAM, *LPNET_DVR_MOUSE_PARAM;

typedef struct tagNET_DVR_MARK_PARAM
{
    BYTE byMarkEvent;           //��ע�¼���1-������ע��2-��ע������3-���±�ע����״̬
    BYTE byMarkTool;           //��ע���ߣ�0-��Ч��1-���ʣ�2-��Ƥ������ע�¼�Ϊ1ʱ��Ч
    BYTE byLineWidth;          //������ϸ��0-��Ч��1-ϸ��2-�У�3-�֣���ע�¼�Ϊ1ʱ��Ч
    BYTE byMouseEvent;         //����¼�����ע�¼�Ϊ1ʱ��Ч��0-��Ч��1-���������£�2-�������ɿ���3-����ƶ�
    NET_DVR_RGB_COLOR struColor;    //��ע��ɫ����ע����Ϊ����ʱ��Ч
    NET_DVR_SCREEN_POINT struPoint; //��ע������Ϣ
    BYTE byRes[4];
}NET_DVR_MARK_PARAM, *LPNET_DVR_MARK_PARAM;

typedef struct tagNET_DVR_KEYBOARD_PARM
{
    DWORD dwKeyValue; //����ʹ��ASCII���е�ֵ�����ⰴ����ȷ��
    BYTE  byRes[12];
}NET_DVR_KEYBOARD_PARAM, *LPNET_DVR_KEYBOARD_PARAM;

typedef struct tagNET_DVR_PPT_PARAM
{
    BYTE  byPPTAction;              //PPT������1-�򿪷�ӳ��2-ֹͣ��ӳ��3-��һ��������4-��һ��������
                                    //5-��һҳ��6-��һҳ��7-����Xҳ��8-����ʿ���9-����ʹأ�10-������ƶ�
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //�����������Ϣ��PPT����Ϊ10ʱ��Ч
    DWORD dwPPTNo;                  //PPTҳ������PPT����Ϊ7ʱ��Ч
    BYTE  byRes2[4];
}NET_DVR_PPT_PARAM, *LPNET_DVR_PPT_PARAM;

typedef struct tagNET_DVR_REMOTE_CTRL_PARAM
{
    BYTE byRemoteCtrlCmd;   //Զ�̿������1-�л��ö����ڣ�2-�ر���Ļ��ǰ���ڣ�3-���ļ���4-�ر��ļ���5-ɾ���ļ���6-�ػ���7-��ʾ���棬8-����
    BYTE byRes1[3];
    DWORD dwCtrlParam;    //������������byRemoteCtrlCmdΪ3��4��5ʱ����ʾ�������ļ���������byRemoteCtrlCmdΪ8ʱ��ʾ�������ͣ�0-��Ч��1-����
    BYTE byRes2[8];
}NET_DVR_REMOTE_CTRL_PARAM, *LPNET_DVR_REMOTE_CTRL_PARAM;

typedef struct tagNET_DVR_SPOTLIGHT_PARAM
{
    BYTE  byCmd;                    //�۹�����0-�رվ۹�ƣ�1-�����۹�ƣ�2-�۹��λ���ƶ�
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //�۹�����ĵ����꣬�۹��λ���ƶ�ʱ��Ч
    DWORD dwRadius;                 //�۹�ư뾶
    BYTE  byRes2[4];
} NET_DVR_SPOTLIGHT_PARAM, *LPNET_DVR_SPOTLIGHT_PARAM;

typedef struct tagNET_DVR_TOUCHPAD_PARAM
{
    BYTE byMouseEvent;  //����¼���1-���������£�2-�������ɿ���3-����Ҽ����£�4-����Ҽ��ɿ���
                        //5-����ƶ���6-������������7-������˫����8-����Ҽ�������9-���ְ��£�
                        //10-�����ɿ���11-�������£�12-��������
    BYTE byRes1[3];
    int iXDisplacement; //X��λ�ƣ�������ʾ�����ƶ���������ʾ�����ƶ�������ƶ�ʱ��Ч
    int iYDisplacement; //Y��λ�ƣ�������ʾ�����ƶ���������ʾ�����ƶ�������ƶ�ʱ��Ч
    BYTE byRes2[4];
}NET_DVR_TOUCHPAD_PARAM, *LPNET_DVR_TOUCHPAD_PARAM;

typedef struct tagNET_DVR_MEDIA_LIST_PARAM
{
    BYTE byOperateCmd;     //�������1-��ʾͼƬ�زģ�2-��ʾ��Ƶ�زģ�3-��ʾppt�زģ�4-�رն�ý���ļ���
    BYTE byRes[15];
}NET_DVR_MEDIA_LIST_PARAM, *LPNET_DVR_MEDIA_LIST_PARAM;

typedef union tagNET_DVR_SCREEN_CTRL_PARAM
{
    NET_DVR_MOUSE_PARAM struMouseParam;             //����������������Ϊ1ʱ��Ч
    NET_DVR_MARK_PARAM struMarkParam;               //��ע��������������Ϊ2ʱ��Ч
    NET_DVR_KEYBOARD_PARAM struKeyboardInfo;        //���̲�������������Ϊ3ʱ��Ч
    NET_DVR_PPT_PARAM struPPTParam;                 //PPT��������������Ϊ4ʱ��Ч
    NET_DVR_REMOTE_CTRL_PARAM struRemoteCtrlParam;  //Զ�̲�����������������Ϊ5ʱ��Ч
    NET_DVR_SPOTLIGHT_PARAM struSpotLight;          //�۹�Ʋ�������������Ϊ6ʱ��Ч
    NET_DVR_TOUCHPAD_PARAM struTouchPadParam;        //������������������Ϊ7ʱ��Ч
    NET_DVR_MEDIA_LIST_PARAM struMediaListParam;    //��ý���������������Ϊ8ʱ��Ч
    BYTE byRes[16];
}NET_DVR_SCREEN_CTRL_PARAM, *LPNET_DVR_SCREEN_CTRL_PARAM;

typedef struct tagNET_DVR_SCREEN_CTRL_CMD
{
    DWORD dwSize;
    BYTE  byCmdType;                               //�������ͣ�1-��꣬2-��ע��3-���̣�4-PPT��5-Զ�̲�����6-�۹�ƣ�7-���ذ壬8-��ʾ��ý�����
    BYTE  byRes1[3];
    NET_DVR_SCREEN_CTRL_PARAM struScreenCtrlParam; //��Ļ���Ʋ���
}NET_DVR_SCREEN_CTRL_CMD, *LPNET_DVR_SCREEN_CTRL_CMD;

typedef struct tagNET_DVR_FILE_RESPONSE_PARAM
{
    BYTE byFileState;       //�ļ�����״̬��1-�ļ������ڣ�2-���ļ�ʧ�ܣ�3-���ļ��ɹ�
    BYTE byRes1[3];
    DWORD dwErrorFileIndex; //�ļ��������ļ�����ֵ
    BYTE byRes2[24];
} NET_DVR_FILE_RESPONSE_PARAM, *LPNET_DVR_FILE_RESPONSE_PARAM;

typedef struct tagNET_DVR_PPT_RESPONSE_PARAM
{
    BYTE  byCurrentState;   //��ǰPPT״̬��1 - ���ڷ�ӳ��2 - ��ӳֹͣ��3 - PPT�ѹرգ�4 - ppt�ܱ���������Ԥ��ͼʧ�ܣ�5 - �򿪷�ӳ�ɹ���6 - �򿪷�ӳʧ�ܣ�7 - ppt����Ϊ�գ�8 - ����ͼ����ʧ�ܣ�9 - ����ͼ���ɳɹ�
    BYTE  byRes1[3];
    DWORD dwCurrentPage;    //PPT��ҳ����PPT״̬Ϊ1,7,8ʱ��Ч
    DWORD dwFileIndex;        //PPT�ļ�����ֵ
    DWORD dwTotalPageNum;    //PPT��ҳ����PPT״̬Ϊ5ʱ��Ч
    BYTE  byRes2[16];
}NET_DVR_PPT_RESPONSE_PARAM, *LPNET_DVR_PPT_RESPONSE_PARAM;

typedef union tagNET_DVR_SCREEN_RESPONSE_PARAM
{
    BYTE byRes[32];
    NET_DVR_PPT_RESPONSE_PARAM  struPPTParam;  //PPT����
    NET_DVR_FILE_RESPONSE_PARAM    struFileParam; //�ļ�������Ӧ����
}NET_DVR_SCREEN_RESPONSE_PARAM,*LPNET_DVR_SCREEN_RESPONSE_PARAM;

typedef struct tagNET_DVR_SCREEN_RESPONSE_CMD
{
    DWORD dwSize;
    BYTE  byResponseCmd; //��Ļ��Ӧ�������ͣ�1-PPT��2-�ļ�����
    BYTE  byRes1[3];
    NET_DVR_SCREEN_RESPONSE_PARAM struResonseParam; //��Ļ��Ӧ����
    BYTE  byRes2[16];
}NET_DVR_SCREEN_RESPONSE_CMD, *LPNET_DVR_SCREEN_RESPONSE_CMD;

typedef struct tagNET_DVR_SCREEN_FILE_COND
{
    DWORD dwSize;
    BYTE  byFileType; //�ļ����ͣ�1-ͼƬ��2-��Ƶ��3-�ĵ���0xff-�����ļ�����
    BYTE  byRes[127];
}NET_DVR_SCREEN_FILE_COND, *LPNET_DVR_SCREEN_FILE_COND;

typedef struct tagNET_DVR_SCREEN_FILE_INFO
{
    DWORD dwSize;
    DWORD dwFileIndex;     //�ļ�������ȫ��Ψһ
    BYTE  byFileType;      //�ļ����ͣ�1-ͼƬ��2-��Ƶ��3-�ĵ���4-����
    BYTE  byPictureFormat; //ͼƬ��ʽ���ļ�����ΪͼƬʱ��Ч��1-bmp,2-jpeg,3-png,4-swf,5-gif 
    BYTE  byVideoFormat;   //��Ƶ��ʽ���ļ�����Ϊ��Ƶʱ��Ч��1-avi,2-wmv,3-mp4,4-flv,5-vod,6-mkv,7-rmvb
    BYTE  byDocumentFormat; //�ĵ���ʽ��0-ppt��1-txt��2-doc��3-xls���ļ�����Ϊ3ʱ��Ч
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH]; //��Ļ�ļ���
    DWORD dwFileSize;     //�ļ���С����λ���ֽ�
    DWORD dwPPTPage;      //pptҳ��ֵ��������ȡ�Ѵ򿪵�PPT�ļ���Ϣʱ��Ч
    BYTE byOtherFileFormat[8]; //�������͵��ļ��ĸ�ʽ������.dat��.dll�ȣ����ļ�����Ϊ4ʱ��Ч
    BYTE byRes1[56];
}NET_DVR_SCREEN_FILE_INFO, *LPNET_DVR_SCREEN_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_CONFIG
{
    DWORD dwSize;
    BYTE  byVolume;             //������0-100
    BYTE  byContrast;           //�Աȶȣ�0-100
    BYTE  byBrightness;         //���ȣ�0-100
    BYTE  byScreenShowEnabled;  //������Ļ��ʾ��0-�أ���0-��
    BYTE  byScreenLocked;       //������Ļ��0-��������0-����
    BYTE  byBlackScreenEnabled; //��Ļ������0-ȡ����������0-����
    BYTE  byRes[30];
}NET_DVR_SCREEN_CONFIG, *LPNET_DVR_SCREEN_CONFIG;

typedef struct tagNET_DVR_SCREEM_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    BYTE  byFileType;      //�ļ����ͣ�1-ͼƬ��2-��Ƶ��3-�ĵ���4-����
    BYTE  byPictureFormat; //ͼƬ��ʽ��1-BMP��2-JPEG��3-PNG��4-SWF��5-GIF���ļ�����Ϊ1ʱ��Ч
    BYTE  byVideoFormat;   //��Ƶ��ʽ��1-AVI��2-WMV��3-MP4��4-FLV��5-VOD��6-MKV��7-RMVB���ļ�����Ϊ2ʱ��Ч
    BYTE  byDocumentFormat; //�ĵ���ʽ��0-ppt��1-txt��2-doc��3-xls���ļ�����Ϊ3ʱ��Ч
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH]; //�ļ�����
    BYTE  byOtherFileFormat[8]; //�������͵��ļ��ĸ�ʽ������.dat��.dll�ȣ����ļ�����Ϊ4ʱ��Ч
    BYTE  byRes1[56];
}NET_DVR_SCREEM_FILE_UPLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileIndex;  //�ļ�����
    DWORD dwPPTPageNo;  //����PPTҳ��ͼƬʱ��Ч��Ϊ0��ʾ����PPT��������ֵ��ʾPPTҳ��ֵ
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;

typedef struct tagNET_DVR_TV_SCREEN_COND
{
    DWORD  dwSize;//�ṹ����
    DWORD    dwChannel;//ͨ����
    WORD    wTVScreenNo;//��������� 0-ȫ��������
    BYTE     byRes[62];     //����
}NET_DVR_TV_SCREEN_COND, *LPNET_DVR_TV_SCREEN_COND;

typedef struct tagNET_DVR_TV_SCREEN_CFG
{
    DWORD    dwSize;//�ṹ����
    DWORD    dwPicStayTime;//����ͣ��ʱ�� ��0~255s��
    BYTE     byRes[256];     //����
}NET_DVR_TV_SCREEN_CFG, *LPNET_DVR_TV_SCREEN_CFG;

//��ȡ�豸ץȡͼƬ�͸�����Ϣ�ṹ��
typedef struct tagNET_DVR_BV_CALIB_COND
{
    DWORD  dwSize;  //�ṹ����
    DWORD dwChannels;  //ͨ����
    BYTE  byRes[300]; //����
}NET_DVR_BV_CALIB_COND, *LPNET_DVR_BV_CALIB_COND;

typedef struct tagNET_DVR_BV_CALIB_PIC
{
    DWORD  dwSize;  //�ṹ����
    DWORD  dwPicID;
    DWORD dwPicLen1;//ͼƬ1����
    DWORD dwPicLen2;//ͼƬ2����
    char*   pPicBuffer1;//ͼƬ����
    char*   pPicBuffer2;//ͼƬ����
    BYTE  byRes[600]; //����
}NET_DVR_BV_CALIB_PIC, *LPNET_DVR_BV_CALIB_PIC;


//��ȡ˫Ŀ��α궨���
typedef struct tagNET_DVR_BV_CALIB_PARAM
{
    DWORD  dwPicID;
    NET_VCA_POINT struPoint;//ü������
    BYTE  byRes[32]; //����
}NET_DVR_BV_CALIB_PARAM, *LPNET_DVR_BV_CALIB_PARAM;

typedef struct tagNET_DVR_BV_CALIB_INFO
{
    DWORD  dwSize;  //�ṹ����
    DWORD  dwBVCalibNumber; //��������
    NET_DVR_BV_CALIB_PARAM struBVCalibParam[12];
    DWORD  dwHumanHeight;  //������ʵ��ߣ���λcm
    DWORD  dwChannel;  //ͨ����
    BYTE  byRes[300]; //����
}NET_DVR_BV_CALIB_INFO, *LPNET_DVR_BV_CALIB_INFO;

typedef struct tagNET_DVR_BV_CALIB_RESULT
{
    DWORD  dwSize;  //�ṹ����
    DWORD dwCameraHeight;  //������߶ȣ���λcm
    float fPitchAngle;    //��������ӽǶ�[0��, 60��], �������� + 360��* 1000
    float fInclineAngle;   //�����б�Ƕ�[-20��,20��]���������� + 360�� * 1000
    BYTE  byRes[300]; //����
}NET_DVR_BV_CALIB_RESULT, *LPNET_DVR_BV_CALIB_RESULT;

//��ȡ˫Ŀ�߶Ƚ�������
typedef struct tagNET_DVR_BV_HCORRECTION_COND
{
    DWORD  dwSize;  //�ṹ����
    DWORD dwChannels;  //ͨ����
    DWORD  dwPicID;
    BYTE  byRes[300]; //����
}NET_DVR_BV_HCORRECTION_COND, *LPNET_DVR_BV_HCORRECTION_COND;

typedef struct tagNET_DVR_BV_HCORRECTION_CFG
{
    DWORD  dwSize;  //�ṹ����
    DWORD  dwHumanHeight;  //������ʵ��ߣ���λcm
    BYTE  byRes[300]; //����
}NET_DVR_BV_HCORRECTION_CFG, *LPNET_DVR_BV_HCORRECTION_CFG;


//������������
typedef    struct tagNET_DVR_TMEVOICE_CFG
{
    DWORD      dwSize;//�ṹ���С
    BYTE       byVoiceSpeed;//���� 0~100
    BYTE       byVoicePitch; //��� 0~100
    BYTE       byVoiceVolum; //����0~100
    BYTE       byVoicePlateEnable;//������������ʹ�� ,0~�رգ�1~����
    /*�������ࣻ
    3  = Xiaoyan (female, Chinese) 
    51 = Jiu Xu (male, Chinese) 
    52 = Duo Xu (male, Chinese) 
    53 = Xiaoping (female, Chinese)
    54 = Donald Duck (male, Chinese)
    55 = Baby Xu (child, Chinese)
    */
    DWORD     dwVoiceRole; //��������
    char      sInfo[MAX_TMEVOICE_LEN/*64*/]; //�����������ݣ������ѹ��Ȧ�������������ݣ�
    char      sFileName[MAX_TMEVOICE_LEN/*64*/]; //�����ļ���
    BYTE      byRes[64];
}NET_DVR_TMEVOICE_CFG,*LPNET_DVR_TMEVOICE_CFG;

//������������
typedef struct tagNET_DVR_INPUT_BOARD_CFG
{
    DWORD    dwSize;
    DWORD    dwSlotNo;           //������λ��
    BYTE    byFullFrameEnable;  //�Ƿ���ȫ֡�ʳ��ԣ�0-��������1-����
    BYTE    byRes[3];           //���ֽڶ���
    BYTE    byRes1[64];         //����
}NET_DVR_INPUT_BOARD_CFG, *LPNET_DVR_INPUT_BOARD_CFG;

typedef struct tagNET_DVR_INPUT_BOARD_CFG_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_BOARD_CFG struBoardList[MAX_NUM_INPUT_BOARD]; //�����������Ϣ�б�
}NET_DVR_INPUT_BOARD_CFG_LIST, *LPNET_DVR_INPUT_BOARD_CFG_LIST;

/******************************��ȫ������Ƶ���������Ϣ��ȫ begin******************************************/
//��ȡ�����豸��Ϣ�����ṹ��
typedef struct _NET_DVR_ENCRYPT_DEVICE_COND
{
    DWORD  dwSize;     //�ṹ���С
    DWORD  dwChannel;     //ͨ����
    BYTE   byAlgorithm; //�����㷨��0-������1-RSA,2-SM2
    BYTE   byModelLen; //ģ����0-������1-1024λ,2-2048λ,3-256λ
    BYTE   byCERTSaveLocation; //֤�鱣��λ�ã������豸���ص���������ѡ��0-������1-����оƬ��(ͨ��USB�����豸),2-�豸��
    BYTE   byRes[29];
}NET_DVR_ENCRYPT_DEVICE_COND, *LPNET_DVR_ENCRYPT_DEVICE_COND;
//��ȡ�����豸��Ϣ�ṹ��
typedef struct _NET_DVR_ENCRYPT_DEVICE_INFO
{
    DWORD  dwSize;     //�ṹ���С
    BYTE   byAlgorithm; //�����㷨��0-������1-RSA,2-SM2
    BYTE   byModelLen; //ģ����0-������1-1024λ,2-2048λ,3-256λ
    BYTE   byRes1[30];  //����
    DWORD  dwPublicKeyLen;        //��Կ����
    char   szPublicKey[MAX_PUBLIC_KEY_LEN];       //��Կ 
    char   szChipSerialNumber[CHIP_SERIALNO_LEN];   //оƬ���к�
    char   szDeviceID[ENCRYPT_DEV_ID_LEN];     //�豸ID
    BYTE   byRes2[128];
}NET_DVR_ENCRYPT_DEVICE_INFO, *LPNET_DVR_ENCRYPT_DEVICE_INFO;
//����֤������ṹ��
typedef struct _NET_DVR_ENCRYPT_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertType; //֤�����ͣ�0-CA��֤�飬1-ǩ��֤��,2-����֤�飬3- SM2������Կ��
    BYTE byRes1[2]; //����
    DWORD dwCertLen; //֤�鳤��
    BYTE  byRes2[32]; 
    char* pCertBuf;  //֤�黺����
}NET_DVR_ENCRYPT_CERT_PARAM, *LPNET_DVR_ENCRYPT_CERT_PARAM;
/******************************��ȫ������Ƶ���������Ϣ��ȫ end******************************************/
#define MAX_RING_NAME_LEN_128                128    //�������Ƴ���
typedef struct tagNET_DVR_RING_UPLOAD_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //������ţ�[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //��������
    DWORD     dwRingSize;   //�ļ���С
    BYTE        byRingType;   //�������ͣ�0-wav
    BYTE        byRes[363];
}NET_DVR_RING_UPLOAD_CFG,*LPNET_DVR_RING_UPLOAD_CFG;

typedef struct tagNET_DVR_RING_SEARCH_COND
{
    DWORD        dwSize;
    DWORD        dwRingID; //������ţ�ɵ��ʽ���ң������ô˲�������Ϊ0����ʾ������Ų���
    BYTE        byRes[300];
}NET_DVR_RING_SEARCH_COND,*LPNET_DVR_RING_SEARCH_COND;

typedef struct tagNET_DVR_RING_SEARCH_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //������ţ�[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //��������
    DWORD     dwRingSize;   //�ļ���С
    BYTE        byRingType;   //�������ͣ�0-wav
    BYTE        byRes[303];
}NET_DVR_RING_SEARCH_CFG,*LPNET_DVR_RING_SEARCH_CFG;

//��������
typedef struct tagNET_DVR_ALARMCTRL_CFG
{
    DWORD   dwSize;
    BYTE    byListenPicUploadEnabled;//����ͼƬ�ϴ�ʹ��
    BYTE    byRes [259];
}NET_DVR_ALARMCTRL_CFG,*LPNET_DVR_ALARMCTRL_CFG;

typedef struct tagNET_DVR_VEHICLEFLOW_COND
{
    DWORD dwSize;
    DWORD dwChannel;//ͨ����
    BYTE   byLane;//�����ţ�1~6����,0Ϊ���г�����
    BYTE   byRes1[3];
    NET_DVR_TIME_V30 struStartTime;//��ʼʱ��
    NET_DVR_TIME_V30 struEndTime;//����ʱ��
    BYTE   byRes[256];
}NET_DVR_VEHICLEFLOW_COND, *LPNET_DVR_VEHICLEFLOW_COND;

typedef struct tagNET_DVR_VEHICLEFLOW_INFO
{
    DWORD dwVehicleFlowValue;//Ϊһ��ʱ����ڵ�����
    BYTE   byRes[64];
}NET_DVR_VEHICLEFLOW_INFO, *LPNET_DVR_VEHICLEFLOW_INFO;

typedef struct tagNET_DVR_VEHICLEFLOW_CFG
{
    DWORD dwSize;
    NET_DVR_VEHICLEFLOW_INFO struVehFlow[MAX_VEHICLEFLOW_INFO/*24*/];
    BYTE   byRes[512];
}NET_DVR_VEHICLEFLOW_CFG, *LPNET_DVR_VEHICLEFLOW_CFG;

//�����ṹ��
typedef struct tagNET_DVR_IPADDR_FILTER_COND
{
    DWORD dwSize;
    DWORD dwChannel;//ͨ����
    BYTE  byRes[64];
}NET_DVR_IPADDR_FILTER_COND, *LPNET_DVR_IPADDR_FILTER_COND;

typedef    struct tagNET_DVR_TEMPHUMSENSOR
{
    DWORD      dwSize;//�ṹ�峤��
    BYTE        byEnable;//ʹ�� 0-�أ�1-��
    BYTE          byCtrlMode;//����ģʽ 0-�¶���ֵ���ƣ�1-ʪ����ֵ���ƣ�2-��ʪ����ֵ����
    BYTE        byTemperatureValue;//�¶���ֵ��0~100���϶�,������ģʽΪ0����2ʱ��Ч
    BYTE        byHumidityValue;//ʪ����ֵ��0~100��������ģʽΪ1����2ʱ��Ч
    BYTE        byFanSwitch;//���ȿ��أ�0-�أ�1-��
    BYTE        byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)��
    BYTE        byRes[62];
}NET_DVR_TEMPHUMSENSOR, *LPNET_DVR_TEMPHUMSENSOR;

//�״��������
typedef struct tagNET_DVR_POSTRADARSPEED_CFG
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byLaneType; //��·���ͣ�0~δ����,1~���ٹ�·,2~���п���·,0xff~������·
    BYTE    byRes1[3];
    DWORD   dwInterval; //����ץ�ļ������λ��ms
    DWORD   dwSignSpeed;//��־����(С��)����λkm/h
    DWORD   dwSpeedLimit;//����ֵ(С��)����λkm/h
    DWORD   dwBigCarSignSpeed;//��־����(��)����λkm/h
    DWORD   dwBigCarSpeedLimit;//����ֵ���󳵣�����λkm/h
    DWORD   dwLowSpeedLimit;// С���޵��٣���λkm/h
    DWORD   dwBigCarLowSpeedLimit;// ���޵��٣���λkm/h
    BYTE    byCheckPostEnabled; //���ÿ���ץ��
    BYTE    byOverSpeedEnabled; //���ó���ץ��
    BYTE    byRes[246];
}NET_DVR_POSTRADARSPEED_CFG, *LPNET_DVR_POSTRADARSPEED_CFG;

//�״��������
typedef struct tagNET_DVR_POSTRADARPARAM_CFG
{
    DWORD   dwSize;//�ṹ���С
    BYTE    bySoftWareVersion[32];//����汾�� ֻ������
    BYTE    byID; //���ں�
    BYTE    byWorkMode; //����ģʽ��0~����,1~��ͷ,2~��β,3~Ѳ�߳���β,4~˫��,0xff~����
    BYTE    bySpeedType; //�ٶȸ�ʽ��0~���ֽ�,1~˫�ֽ�,2~���ֽ�,0xff~����
    BYTE    byDirectionFilter; //������ˣ�0~������,1~�������,2~���ȥ��
    DWORD   dwAngleCorrect;//�Ƕ�����[0,70]
    DWORD   dwSensitivity;// ������[11,240]
    DWORD   dwSpeedLowLimit;// ��������[1,150km/h]
    DWORD   dwTrigDistance;// ��������[0,40m]
    BYTE    byRes[256];
}NET_DVR_POSTRADARPARAM_CFG, *LPNET_DVR_POSTRADARPARAM_CFG;

typedef struct tagNET_DVR_CLOUD_URL_COND
{
    DWORD   dwSize;
    BYTE    byType;     //������0-������1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byRes[63];
}NET_DVR_CLOUD_URL_COND, *LPNET_DVR_CLOUD_URL_COND;

typedef struct tagNET_DVR_CLOUD_URL
{
    DWORD   dwSize;
    char    szURL[256]; //�ƴ洢URL
    BYTE    byRes[256];
}NET_DVR_CLOUD_URL, *LPNET_DVR_CLOUD_URL;

typedef struct tagNET_DVR_CLOUD_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //0-��������1-����
    BYTE    byType;        //������0-������1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byStatus;    //״̬��ֻ�� 0-���� 1-���� 2-������
    BYTE    byRes1;
    char    szAuthCode[CODE_LEN]; //��Ȩ��
    char    szAlias[ALIAS_LEN];    //������ֻ��
    INT64    i64TotalCapability;            //��������ֻ������λ��MB
    INT64    i64UsedSpace;                //����������ֻ������λ��MB
    BYTE    byRes2[256];
}NET_DVR_CLOUD_CFG, *LPNET_DVR_CLOUD_CFG;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;    //ͨ����
    BYTE    byRes[254];    //Ϊ����ʹ����ID������
}NET_DVR_CLOUD_UPLOADSTRATEGY_COND, *LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY
{
    DWORD      dwSize;
    BYTE    byStrategyType;    //��������0-�����壬1-¼��2-ͼƬ
    BYTE    byRes1[3];
    DWORD    dwRecordType;    //��������byStrategyType Ϊ1ʱ��Ч����λ��ʾ
    /*0x00: ������*/
    /*0x01: ȫ���¼�*/
    /*0x02: �ƶ����*/
    /*0x04: �ź�����������*/
    /*0x08: ��������*/
    BYTE    byRes[256];
}NET_DVR_CLOUD_UPLOADSTRATEGY, *LPNET_DVR_CLOUD_UPLOADSTRATEGY;

//¼�������Լ����������
typedef  struct tagNET_DVR_RECORD_CHECK_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byCheckType;        //��ⷽʽ,0--¼���Ƿ�����,1--¼���Ƿ�����&ȱʧ¼�����ֹʱ��
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //���¼��Ŀ�ʼʱ��
    NET_DVR_TIME_EX struEndTime;    //���¼��Ľ���ʱ��
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_COND, *LPNET_DVR_RECORD_CHECK_COND;

//¼�������Լ����
typedef  struct tagNET_DVR_RECORD_CHECK_RET
{
    DWORD    dwSize; 
    BYTE   byRecordNotComplete;    //¼���Ƿ�������0--����,1--������
    BYTE   byRes1[3];
    NET_DVR_TIME_EX struBeginTime;    //ȱʧ¼��Ŀ�ʼʱ�䣬byCheckType��byRecordNotCompleteֵ��Ϊ1ʱ��Ч
    NET_DVR_TIME_EX struEndTime;    //ȱʧ¼��Ľ���ʱ�䣬byCheckType��byRecordNotCompleteֵ��Ϊ1ʱ��Ч
    BYTE   byRes[128];
}NET_DVR_RECORD_CHECK_RET, *LPNET_DVR_RECORD_CHECK_RET;

//����ֶ��ش���������
typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_COND;

//����ֶ��ش��������
typedef  struct tagNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    NET_DVR_TIME_EX struBeginTime;    //�ش���¼��ʼʱ��
    NET_DVR_TIME_EX struEndTime;    //�ش���¼�����ʱ��
    BYTE   byRes[128];
}NET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_ADD_RECORD_PASSBACK_MANUAL_CFG;

//�ش��������
typedef  struct tagNET_DVR_RECORD_PASSBACK_TASK_CFG
{
    DWORD    dwSize;
    DWORD dwTaskID;        //����ID
    BYTE   byRes[160];
}NET_DVR_RECORD_PASSBACK_TASK_CFG, *LPNET_DVR_RECORD_PASSBACK_TASK_CFG;

//��ȡ�����ֶ��ش�������������
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byType;     //��ȡ��ʽ,0--��ȡȫ��ʣ������1--������ID��ȡʣ������, 2--��ȡȫ������3--������ID��ȡ����4����������ID��ȡ����
    BYTE    byTimeSegmentQuety; //�Ƿ�����ʱ�䷶Χ��ѯ��0-�����ã�1-����
    BYTE    byRes1[2];  //����
    NET_DVR_STREAM_INFO    struStreamInfo; //��id��Ϣ��72�ֽڣ���������ID��ȡʣ������ʱ��Ч
    NET_DVR_TIME_EX struBeginTime;      //��ѯ��ʼʱ�䣬byTimeSegmentQuety����ʱ��Ч
    NET_DVR_TIME_EX struEndTime;        //��ѯ����ʱ�䣬byTimeSegmentQuety����ʱ��Ч
    DWORD dwTaskID;        //����ID, byType����4ʱ��Ч
    BYTE    byRes[108];                //����
}NET_DVR_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_RECORD_PASSBACK_MANUAL_COND;

//��ȡ�����ֶ��ش��������
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;    //��id��Ϣ��72�ֽڣ���������ID��ȡʣ������ʱ��Ч
    DWORD        dwTaskID;        //����ID
    NET_DVR_TIME_EX    struStartTime;  //�ش���¼��ʼʱ��
    NET_DVR_TIME_EX    struStopTime;   //�ش���¼�����ʱ��
    BYTE        byTaskStatus;    //����״̬��0--δִ�У�1--��ͣ�У�2--��ִ��, 3--�ش���, 4--�ش�ʧ��
    BYTE        byRes1[3];
    NET_DVR_TIME_EX    struExecuteStartTime;//����ʵ��ִ�п�ʼʱ�䣬byTaskStatusΪ1��2��Ч
    NET_DVR_TIME_EX    struExecuteStopTime;//����ʵ��ִ�н���ʱ�䣬byTaskStatusΪ2��Ч
    BYTE        byRes[128];        //����
}NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET, *LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

//�����ֶ��ش��������
typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_CTRL
{
    DWORD    dwSize;
    BYTE    byControlType;    //���Ʒ�ʽ,0--��ͣ�����ֶ�����1--�ָ������ֶ�����
    BYTE    byRes[131];        //����
}NET_DVR_RECORD_PASSBACK_MANUAL_CTRL, *LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

//ɾ���ֶ��ش���������
typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byDelType;    //ɾ����ʽ,0--��������IDɾ����1--������IDɾ������2--ɾ��ȫ������
    BYTE    byRes[131];    //����
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

//ɾ���ֶ��ش��������
typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    DWORD    dwTaskID;    //�ֶ��ش�����ID����������IDɾ������ʱ��Ч
    NET_DVR_STREAM_INFO    struStreamInfo;    //��id��Ϣ��72�ֽڣ���������IDɾ������ʱ��Ч
    BYTE    byRes[128];    //����
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

typedef struct tagNET_DVR_PASSBACK_DAY
{
    BYTE    byAllDay;    //�Ƿ�����ȫ��ش�
    BYTE    byRes[3];    //����
}NET_DVR_PASSBACK_DAY, *LPNET_DVR_PASSBACK_DAY;

typedef struct tagNET_DVR_PASSBACK_SCHED
{
    NET_DVR_SCHEDTIME    struPassBackTime;    //�ش�����ʱ��Σ���ʼʱ��-����ʱ��
    BYTE        byRes[4];        //����
}NET_DVR_PASSBACK_SCHED, *LPNET_DVR_PASSBACK_SCHED;

//¼��ش��ƻ�����
typedef struct tagNET_DVR_RECORD_PASSBACK_SCH_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //�Ƿ����ã�0--�����ã�1--����
    BYTE    byPassBackWeek;    //�Ƿ��ܻش���0--��1--�ǣ�ֵΪ1ʱstruPassBackDay��struPassBackSched��Ч
    BYTE    byRes1[2];            //����
    NET_DVR_PASSBACK_DAY    struPassBackDay[MAX_DAYS];  //ȫ��ش��ƻ�
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //ʱ��λش��ƻ�
    BYTE   byRes[128];        //����
}NET_DVR_RECORD_PASSBACK_SCH_CFG, *LPNET_DVR_RECORD_PASSBACK_SCH_CFG;

//�ش���ʷ¼��ƻ�����
typedef struct tagNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG_
{
    DWORD    dwSize;    //�汾ͷ
    BYTE    byEnable;        //�Ƿ����ã�0--�����ã�1--����
    BYTE    byRes1[3];            //����
    NET_DVR_PASSBACK_DAY        struPassBackDay[MAX_DAYS];  //ȫ��ش��ƻ�
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //ʱ��λش��ƻ�
    BYTE   byRes[256];        //����
}NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG, *LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG;

//¼������
typedef struct tagNET_DVR_DEV_STORAGE_CFG
{
    DWORD    dwSize;
    DWORD    dwCapacityTotal;        //�豸�洢(CVR��ʾ¼���)������(ֻ��)����λMB
    DWORD    dwFreeSpaceTotal;        //�豸�洢(CVR��ʾ¼���)ʣ���ܿռ�(ֻ��)����λMB
    DWORD    dwLockedRecordSpace;    //�豸�Ѽ���¼��洢(CVR��ʾ¼���)������(ֻ��)����λMB
    DWORD    dwUnLockedSpace;        //�豸δ�����洢(CVR��ʾ¼���)������(ֻ��),����δ����¼���ʣ��洢�ռ䣬��λMB
    BYTE    byRes[512];                //����
}NET_DVR_DEV_STORAGE_CFG, *LPNET_DVR_DEV_STORAGE_CFG;

//һ������CVR��V50��
typedef struct tagNET_DVR_ONE_KEY_CFG_V50
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byRaidType;   //RAID���ͣ�0-raid5,1-raid6,2-raid95��Vraid��,3-����ģʽ����������raid
    BYTE    bySpareRaidProportion;   //�ȱ��̣�raid�����У��ı���,0--��0:1��,1--��1:1��,2--��1:2��,3--��1:3��,4--��1:4��,5--��1:5��,6--��1:6��,7--��6:1��,8--��5:1��,9--��4:1��,10--��3:1��,11--��2:1��
    BYTE    byPicQuota;   //ͼƬ���������Χ0~100
    BYTE    byRes[257];
}NET_DVR_ONE_KEY_CFG_V50, *LPNET_DVR_ONE_KEY_CFG_V50;

typedef struct tagNET_DVR_ONE_KEY_RESULT_V51
{
    DWORD   dwState;    //״ֵ̬�������ע��״ֵ̬
    BYTE    byProgress;   //�������ȣ�0~100
    BYTE    byRes[259];
}NET_DVR_ONE_KEY_RESULT_V51, *LPNET_DVR_ONE_KEY_RESULT_V51;

typedef struct tagNET_DVR_ONE_KEY_CFG_SAN_V50
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byRaidType;   //RAID���ͣ�0-raid5,1-raid6
    BYTE    bySpareRaidProportion;   //�ȱ��̣�raid�����У��ı���,0--��0:1��,1--��1:1��,2--��1:2��,3--��1:3��,4--��1:4��,5--��1:5��,6--��1:6��,7--��6:1��,8--��5:1��,9--��4:1��,10--��3:1��,11--��2:1��    
    BYTE    byRes[254];
}NET_DVR_ONE_KEY_CFG_SAN_V50, *LPNET_DVR_ONE_KEY_CFG_SAN_V50;

typedef    struct tagNET_DVR_REC_PASSBACK_BASIC_CFG
{
    DWORD        dwSize;//�ṹ���С
    DWORD     dwStartTime;  //��ⴰ�ڿ�ʼʱ�䣨��λ�����ӣ�
    DWORD     dwStopTime;  //��ⴰ�ڽ���ʱ�䣨��λ�����ӣ�
    WORD    wMaxTotalConcurrenceNum;   //�����ش�·������,��Ե��Ǳ�����·�������ǻش���������
    WORD    wMaxDvrConcurrenceNum;     //��̨DVR�����ش�ͨ��������
    BYTE    byRes[256];
}NET_DVR_REC_PASSBACK_BASIC_CFG, *LPNET_DVR_REC_PASSBACK_BASIC_CFG;

//�豸���ӵ��û�����
typedef struct tagNET_DVR_ONLINE_USER_INFO_
{
    DWORD    dwSize;
    WORD    wOnlineUserCount;    //��¼�豸���û���
    BYTE   byRes[514];    //����
}NET_DVR_ONLINE_USER_INFO, *LPNET_DVR_ONLINE_USER_INFO;

//��ѯ¼���ܴ�С��������
typedef struct tagNET_DVR_RECORD_SEGMENT_COND_
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreanInfo;
    NET_DVR_TIME_EX    struStartTime;  //��ʼʱ��
    NET_DVR_TIME_EX    struStopTime;    //����ʱ��
    BYTE        byRes[256];        //����
}NET_DVR_RECORD_SEGMENT_COND, *LPNET_DVR_RECORD_SEGMENT_COND;

//��ѯ¼���ܴ�С���ز���
typedef struct tagNET_DVR_RECORD_SEGMENT_RET_
{
    DWORD    dwSize;
    DWORD    dwRecordTotalSize;    //¼���ܴ�С����λMB
    BYTE    byRes[256];        //����
}NET_DVR_RECORD_SEGMENT_RET, *LPNET_DVR_RECORD_SEGMENT_RET;
typedef struct tagNET_DVR_ACCESSORY_CARD_INFO
{
    DWORD   dwSize;
    BYTE    szAccessoryCardInfo[MAX_ACCESSORY_CARD/*256*/];//�����(���ܰ��ƴ�ذ�)�ͺ���Ϣ
    BYTE    byRes[512];
}NET_DVR_ACCESSORY_CARD_INFO, *LPNET_DVR_ACCESSORY_CARD_INFO;
//��ѯ��Ϣ�����ṹ��
typedef struct tagNET_DVR_SEARCH_INFO_COND
{
    DWORD                   dwSize;
    BYTE                    byCommand;    //��ѯ������0-���ˣ�1-����
    BYTE                    byRes1[3];
    DWORD                   dwEmployeeNo; //���ţ���ѯ��������Ϊ0-����ʱ��Ч��
    BYTE                    byName[NAME_LEN];   //��������ѯ��������Ϊ0-����ʱ��Ч��
    NET_DVR_TIME_V30        struStartTime;      //��ʼʱ��
    NET_DVR_TIME_V30        struEndTime;        //����ʱ��
    BYTE                    byRes[128];            //����
}NET_DVR_SEARCH_INFO_COND, *LPNET_DVR_SEARCH_INFO_COND;

//��ȡ�Ű���Ϣ
typedef struct tagNET_DVR_SCHEDULE_CHOICE
{
    BYTE                    byScheduleType;        //������ͣ�0-���Űࡢ1-��ͨ�ࡢ2-��ʱ��
    BYTE                    byScheduleNo;       //��α��
    BYTE                    byRes[14];          //����
}NET_DVR_SCHEDULE_CHOICE, *LPNET_DVR_SCHEDULE_CHOICE;
//  B20 V1.5
typedef struct tagNET_DVR_DISPINPUT_CFG
{
    DWORD  dwSize;
    DWORD  dwDispInputNo; //��ʾ�����
    DWORD  dwEDIDFileNo; //������EDID�ļ����
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG, *LPNET_DVR_DISPINPUT_CFG;

//�Ű�ƻ��ṹ��
typedef struct tagNET_DVR_SCHEDULE_PLAN
{
    DWORD                   dwSize;
    BYTE                    bySchedulePlanNo;   //�Ű�ƻ����,��ʼ��Χ��������������
    BYTE                    bySchedulePlanType; //�Ű�ƻ����ͣ�0-���ˡ�1-����
    BYTE                    byEnable;           //ʹ��
    BYTE                    byRes1;
    NET_DVR_SCHEDULE_CHOICE struScheduleChoice[DAYS_A_WEEK];  //���ѡ��
    NET_DVR_TIME_V30        struStartTime;      //��ʼʱ��
    NET_DVR_TIME_V30        struEndTime;        //����ʱ��
    BYTE                    byHolidayNo;        //��������
    BYTE                    byRes[63];          //����
}NET_DVR_SCHEDULE_PLAN, *LPNET_DVR_SCHEDULE_PLAN;
typedef struct tagNET_DVR_DISPINPUT_CFG_LIST
{
    DWORD  dwSize;
    DWORD  dwDispInputNum; //���ص�NET_DVR_DISPINPUT_CFG�ṹ�ĸ���
    LPNET_DVR_DISPINPUT_CFG lpstruBuffer; //������ָ��
    DWORD  dwBufferSize; //��������С
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG_LIST, *LPNET_DVR_DISPINPUT_CFG_LIST;

//��ȡ�Ű���Ϣ
typedef struct tagNET_DVR_SCHEDULE_INFO_CFG
{
    DWORD                  dwSize;
    DWORD                  dwEmployeeNo;        //����
    BYTE                   byName[NAME_LEN];    //����
    BYTE                   byDepartmentName[NAME_LEN];   //��������
    NET_DVR_SCHEDULE_PLAN  struSchedulePlan;    //�Ű�ƻ�
    BYTE                   byRes[128];          //����
}NET_DVR_SCHEDULE_INFO_CFG, *LPNET_DVR_SCHEDULE_INFO_CFG;

//��ȡ���ڻ�����Ϣ
typedef struct tagNET_DVR_ATTENDANCE_SUMMARY_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //����
    BYTE                  byName[NAME_LEN];  //����
    BYTE                  byDepartmentName[NAME_LEN];  //��������
    DWORD                 dwWorkStandard;    //��׼����ʱ�䣨���ӣ�
    DWORD                 dwWorkActual; //ʵ�ʹ���ʱ�䣨���ӣ�
    DWORD                 dwLateTimes;  //�ٵ�����
    DWORD                 dwLateMinutes;//�ٵ��ۼ�ʱ�䣨���ӣ�
    DWORD                 dwLeaveEarlyTimes;    //���˴���
    DWORD                 dwLeaveEarlyMinutes;  //�����ۼ�ʱ�䣨���ӣ�
    DWORD                 dwOvertimeStandard;   //��׼�Ӱ�ʱ�䣨���ӣ�
    DWORD                 dwOvertimeActual;     //ʵ�ʼӰ�ʱ�䣨���ӣ�
    DWORD                 dwAttendanceStandard; //��׼�����������죩
    DWORD                 dwAttendanceActual;   //ʵ�ʳ����������죩
    DWORD                 dwAbsentDays;         //�����������죩
    BYTE                  byRes[128];           //����
}NET_DVR_ATTENDANCE_SUMMARY_CFG, *LPNET_DVR_ATTENDANCE_SUMMARY_CFG;

//��ȡ���ڼ�¼��Ϣ
typedef struct tagNET_DVR_ATTENDANCE_RECORD_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //����
    BYTE                  byName[NAME_LEN];     //����
    BYTE                  byDepartmentName[NAME_LEN];  //��������
    NET_DVR_TIME_V30      struAttendanceTime;   //����ʱ��
    BYTE                  byRes[128];   //����
}NET_DVR_ATTENDANCE_RECORD_CFG, *LPNET_DVR_ATTENDANCE_RECORD_CFG;

//����ʱ�����Ϣ
typedef struct tagNET_DVR_ATTENDANCE_TIME
{
    NET_DVR_TIME_V30      struOnDutyTime;   //�ϰ�ʱ��
    NET_DVR_TIME_V30      struOffDutyTime;  //�°�ʱ��
}NET_DVR_ATTENDANCE_TIME, *LPNET_DVR_ATTENDANCE_TIME;

//��ȡ�쳣ͳ����Ϣ
typedef struct tagNET_DVR_ABNORMAL_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo;     //����
    BYTE                  byName[NAME_LEN]; //����
    BYTE                  byDepartmentName[NAME_LEN];  //��������
    NET_DVR_ATTENDANCE_TIME struAttendanceTime[ABNORMAL_INFO_NUM]; //�쳣ʱ���
    DWORD                 dwLateMinutes;    //�ٵ�ʱ�䣨���ӣ�
    DWORD                 dwLeaveEarlyMinutes; //����ʱ�䣨���ӣ�
    DWORD                 dwAbsenceMinutes; //ȱ��ʱ�䣨���ӣ�
    DWORD                 dwTotalMinutes;   //�ϼ�ʱ�䣨���ӣ�
    BYTE                  byRes[128];     //����
}NET_DVR_ABNORMAL_CFG, *LPNET_DVR_ABNORMAL_CFG;

typedef struct tagNET_DVR_CARD_CFG_V50
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // ��Ҫ�޸ĵĿ����������ÿ�����ʱ��Ч����λ��ʾ��ÿλ����һ�ֲ�����1Ϊ��Ҫ�޸ģ�0Ϊ���޸�
    // #define CARD_PARAM_CARD_VALID       0x00000001 //���Ƿ���Ч����
    // #define CARD_PARAM_VALID            0x00000002  //��Ч�ڲ���
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //�����Ͳ���
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //��Ȩ�޲���
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //�׿�����
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //���ˢ����������
    // #define CARD_PARAM_GROUP            0x00000040  //����Ⱥ�����
    // #define CARD_PARAM_PASSWORD         0x00000080  //���������
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //��Ȩ�޼ƻ�����
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //��ˢ������
    // #define CARD_PARAM_EMPLOYEE_NO      0x00000400  //����
    // #define CARD_PARAM_NAME             0x00000800  //����
    // #define CARD_PARAM_DEPARTMENT_NO    0x00001000  //���ű��
    // #define CARD_SCHEDULE_PLAN_NO       0x00002000  //�Ű�ƻ����
    // #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //�Ű�ƻ�����
    // #define CARD_ROOM_NUMBER            0x00008000  //�����
    // #define CARD_SIM_NO                 0x00010000  //SIM���ţ��ֻ��ţ�
    // #define CARD_FLOOR_NUMBER           0x00020000  //¥���
    // #define CARD_USER_TYPE              0x00040000  //�û�����
    BYTE byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE byCardValid; //���Ƿ���Ч��0-��Ч��1-��Ч������ɾ����������ʱ��Ϊ0����ɾ������ȡʱ���ֶ�ʼ��Ϊ1��
    BYTE byCardType; //�����ͣ�1-��ͨ����2-�м��˿���3-����������4-Ѳ������5-в�ȿ���6-��������7-��������8-�������9-Ա������10-Ӧ������11-Ӧ��������������Ȩ��ʱ��Ȩ�ޣ������ܿ��ţ���Ĭ����ͨ��
    BYTE byLeaderCard; //�Ƿ�Ϊ�׿���1-�ǣ�0-��
    BYTE byUserType; // 0 �C ��ͨ�û�1 - ����Ա�û�;
    BYTE byDoorRight[MAX_DOOR_NUM_256]; //��Ȩ��(¥��Ȩ�ޡ���Ȩ��)����λ��ʾ��1Ϊ��Ȩ�ޣ�0Ϊ��Ȩ�ޣ��ӵ�λ����λ��ʾ���ţ�����1-N�Ƿ���Ȩ��
    NET_DVR_VALID_PERIOD_CFG struValid; //��Ч�ڲ���
    BYTE  byBelongGroup[MAX_GROUP_NUM_128]; //����Ⱥ�飬���ֽڱ�ʾ��1-���ڣ�0-������
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //������
    WORD wCardRightPlan[MAX_DOOR_NUM_256][MAX_CARD_RIGHT_PLAN_NUM]; //��Ȩ�޼ƻ���ȡֵΪ�ƻ�ģ���ţ�ͬ���ţ�������ͬ�ƻ�ģ�����Ȩ�޻�ķ�ʽ����
    DWORD dwMaxSwipeTime; //���ˢ��������0Ϊ�޴������ƣ�����������
    DWORD dwSwipeTime; //��ˢ������
    WORD wRoomNumber;  //�����
    SHORT wFloorNumber;   //���
    DWORD dwEmployeeNo;   //���ţ��û�ID��
    BYTE byName[NAME_LEN];   //����
    WORD wDepartmentNo;   //���ű��
    WORD wSchedulePlanNo;   //�Ű�ƻ����
    BYTE bySchedulePlanType;  //�Ű�ƻ����ͣ�0-�����塢1-���ˡ�2-����
    BYTE byRightType;  //�·�Ȩ�����ͣ�0-��ͨ����Ȩ�ޡ�1-��ά��Ȩ�ޡ�2-����Ȩ�ޣ����ӶԽ��豸��ά��Ȩ�����������š����ţ����⿨�ţ������ˢ����������������������Ч�ڲ���������Ȩ�ޣ����ţ�өʯAPP�˺ţ�������������������ͨ����Ȩ��һ�£�
    BYTE byRes2[2];
    DWORD dwLockID;  //��ID
    BYTE byLockCode[MAX_LOCK_CODE_LEN];    //������
    BYTE byRoomCode[MAX_DOOR_CODE_LEN];  //�������
    //��λ��ʾ��0-��Ȩ�ޣ�1-��Ȩ��
    //��0λ��ʾ�����籨��
    //��1λ��ʾ��������ʾ��
    //��2λ��ʾ�����ƿͿ�
    //��3λ��ʾ��ͨ��
    //��4λ��ʾ����������
    //��5λ��ʾ��Ѳ������
    DWORD dwCardRight;      //��Ȩ��
    DWORD dwPlanTemplate;   //�ƻ�ģ��(ÿ��)��ʱ����Ƿ����ã���λ��ʾ��0--�����ã�1-����
    DWORD dwCardUserId;    //�ֿ���ID
    BYTE byCardModelType;  //0-�գ�1- MIFARE S50��2- MIFARE S70��3- FM1208 CPU����4- FM1216 CPU����5-����CPU����6-���֤��7- NFC
    BYTE byRes3[51];
    BYTE bySIMNum[NAME_LEN/*32*/]; //SIM���ţ��ֻ��ţ�
}NET_DVR_CARD_CFG_V50, *LPNET_DVR_CARD_CFG_V50;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_COND
{
    DWORD  dwSize;
    BYTE   byFingerPrintPicType;    //ͼƬ���ͣ�0-������
    BYTE   byFingerNo;              //��ָ��ţ���Χ1-10
    BYTE   byRes[126];
}NET_DVR_CAPTURE_FINGERPRINT_COND, *LPNET_DVR_CAPTURE_FINGERPRINT_COND;

typedef  struct tagNET_DVR_CAPTURE_FINGERPRINT_CFG
{
    DWORD dwSize;
    DWORD dwFingerPrintDataSize;    //ָ�����ݴ�С
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //ָ����������
    DWORD dwFingerPrintPicSize;    //ָ��ͼƬ��С������0ʱ��������ָ��ͼƬ����
    char* pFingerPrintPicBuffer;       //ָ��ͼƬ����
    BYTE  byFingerNo;              //��ָ��ţ���Χ1-10
    BYTE  byFingerPrintQuality;    //ָ����������Χ1-100
    BYTE  byRes[62];
}NET_DVR_CAPTURE_FINGERPRINT_CFG, *LPNET_DVR_CAPTURE_FINGERPRINT_CFG;

typedef  struct tagNET_DVR_CAPTURE_FACE_COND
{
    DWORD  dwSize;
    BYTE   byRes[128];
}NET_DVR_CAPTURE_FACE_COND, *LPNET_DVR_CAPTURE_FACE_COND;

typedef struct tagNET_DVR_FACE_FEATURE
{
    NET_VCA_RECT struFace; //������ͼ����
    NET_VCA_POINT    struLeftEye;    // ��������
    NET_VCA_POINT    struRightEye;   // ��������
    NET_VCA_POINT    struLeftMouth;  // ���������
    NET_VCA_POINT    struRightMouth; // ���ұ�����
    NET_VCA_POINT    struNoseTip;   // ��������
}NET_DVR_FACE_FEATURE, *LPNET_DVR_FACE_FEATURE;


typedef  struct tagNET_DVR_CAPTURE_FACE_CFG
{
    DWORD  dwSize;
    DWORD  dwFaceTemplate1Size;  //����ģ��1���ݴ�С������0ʱ������������ģ��1����
    char*  pFaceTemplate1Buffer; //����ģ��1���ݻ��棨������2.5k��
    DWORD  dwFaceTemplate2Size;  //����ģ��2���ݴ�С������0ʱ������������ģ��2����
    char*  pFaceTemplate2Buffer; //����ģ��2���ݻ��棨������2.5K��
    DWORD  dwFacePicSize;        //����ͼƬ���ݴ�С������0ʱ������������ͼƬ����
    char*  pFacePicBuffer;       //����ͼƬ���ݻ���
    BYTE   byFaceQuality1;        //������������Χ1-100
    BYTE   byFaceQuality2;        //������������Χ1-100
    BYTE   byCaptureProgress;    //�ɼ����ȣ�Ŀǰֻ�����ֽ���ֵ��0-δ�ɼ���������100-�ɼ���������ֻ���ڽ���Ϊ100ʱ���Ž���������Ϣ��
    BYTE   byFacePicQuality;  //����ͼƬ����������
    DWORD  dwInfraredFacePicSize;   //��������ͼƬ���ݴ�С������0ʱ������������ͼƬ����
    char*  pInfraredFacePicBuffer;      //��������ͼƬ���ݻ���
    BYTE   byInfraredFacePicQuality;  //��������ͼƬ����������
    BYTE   byRes1[3];
    NET_DVR_FACE_FEATURE struFeature; //������ͼ������Ϣ
    BYTE   byRes[56];
}NET_DVR_CAPTURE_FACE_CFG, *LPNET_DVR_CAPTURE_FACE_CFG;

//��ѯ�ֶ��ش������ִ������������
typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //��id��Ϣ��72�ֽڣ�
    BYTE    byRes[128];                 //����
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND;

//��ѯ�ֶ��ش������ִ������������
typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //��id��Ϣ��72�ֽڣ�
    BYTE    byExecutable;           //0-���������ش���1-������ִ�лش�
    BYTE    byUnexecutableReason;   //���������ش�ԭ��, 0-��Ҫ�Ŷӣ�1-�����������ӣ�2-��ID�����ڣ�3-CVR�쳣��4-��������Ƶ, 5-�������û����������, 6-ǰ���豸������, 7-����ԭ��
    BYTE    byRes[254];             //����
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET;

typedef struct tagNET_DVR_STREAM_MEDIA_CFG
{
    DWORD   dwSize;
    BYTE    sUrl[MAX_URL_LEN];
    NET_DVR_IPADDR   struDMSIP; /* dms IP��ַ */
    WORD    wDMSPort;  /*dms �˿ں� */
    BYTE    byRes[366]; //����
}NET_DVR_STREAM_MEDIA_CFG, *LPNET_DVR_STREAM_MEDIA_CFG;

//��ֻ��ⵥ����������
typedef struct tagNET_DVR_SHIPSDETECTION_REGION_CFG
{

    BYTE    byRuleID;
    BYTE    byEnable;     //ʹ��
    BYTE    bySensitivity;  //�����Ȳ�������Χ[1,100]
    BYTE    byFrameOverlayEnabled;//��Ƶ�Ƿ���Ӽ���
    BYTE   byRes[36];
    NET_ITC_POLYGON struPolygon; //��������
    NET_VCA_LINE struTriggerLine;  //������
}NET_DVR_SHIPSDETECTION_REGION_CFG, *LPNET_DVR_SHIPSDETECTION_REGION_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//ʹ��
    BYTE   byRes1[3];
    float    fLookDownUpAngle;//�豸�����Ƕȣ���ȷ��С�����һλ
    float    fHorizontalHeight;//�豸ˮƽ�߶ȣ���ȷ��С�����һλ
    NET_DVR_SHIPSDETECTION_REGION_CFG struShipsDetectionRegion[MAX_SHIPSDETE_REGION_NUM];//��ֻ��ⵥ����������
    BYTE   byRes[256];
}NET_DVR_SHIPSDETECTION_CFG, *LPNET_DVR_SHIPSDETECTION_CFG;

typedef    struct tagNET_DVR_TEMPERATURE_COLOR
{
    /*
    ѡ��0~���±�������ʱ��<highTemperature>�ֶ���Ч,�����ڸ��¶�ֵʱ�����н�����ɫ��ע��
    ѡ��1~���±�������ʱ, <lowTemperature>�ֶ���Ч,�����ڸ��¶�ֵʱ�����н�����ɫ��ע��
    ѡ��2~���䱨������ʱ��<highTemperature>��<lowTemperature>�ֶ���Ч�������¶��ڸ��¶�����ʱ�����н�����ɫ��ע��
    ѡ��3~���±�������ʱ��<highTemperature>��<lowTemperature>�ֶ���Ч�����¶Ȳ��ڸ��¶�����ʱ�����н�����ɫ��ע��
    ѡ��4~Ϊ�ޱ������ͣ�<nullAlarm>�ֶ���Ч���رձ�����*/
    BYTE     byType;//���±�����ɫ�������ͣ�0~�ޱ������ͣ��رգ���1~���±������ͣ�2~���±������ͣ�3~���䱨�����ͣ�4~���±�������
    BYTE     byRes1[3];
    int        iHighTemperature;//����ֵ��-273~10000
    int        iLowTemperature;//����ֵ��-273~10000
    BYTE     byRes[8];
}NET_DVR_TEMPERATURE_COLOR, *LPNET_DVR_TEMPERATURE_COLOR;

typedef    struct tagNET_DVR_THERMOMETRY_BASICPARAM
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE        byStreamOverlay; //���������¶���Ϣ��0- ��1- ��
    BYTE         byPictureOverlay;//ץͼ�����¶���Ϣ��0- ��1- ��
    BYTE        byThermometryRange;//���·�Χ: 0-Ĭ��ֵ,1-(-20~150),2-(0~550)�����������϶�Ϊ��λ���㣩,3-(���϶�:0-650�棻�����¶�:32-1200�H),4-�����϶�: -40-150�棩,5-(���϶�: 0~1200��)�����������϶�Ϊ��λ���㣬���ݲ��µ�λ�趨��ͬ���·�Χ����ʾ����6-(���϶�: -20-120��,7-(���϶�:20~350��), 8-(���϶�:20~45),9-(���϶�:30~45),0xff-�Զ�
    BYTE        byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)��
    BYTE        byThermometryCurve;//��������ģʽ��ʾ��ʽ��0-�رգ�1-ģʽ1�������¶�������ģʽ����2-ģʽ2�������¶�������ģʽ��
    BYTE        byFireImageModea;//����ͼ��ģʽ��0-������1-�ڰ�ģʽ��2-��̽��ģʽ��3-��ģʽ(�ֶ�0Ŀǰ������������֮ǰ�ӿڲ�����)    
    BYTE        byShowTempStripEnable;//��ʾ�¶���ʹ�ܣ�0- ��1- ��
    float       fEmissivity;//������(������ ��ȷ��С�������λ)[0.01, 1.00](��������������������ı���)
    BYTE         byDistanceUnit;//���뵥λ: 0-�ף�m����1-Ӣ�ߣ�feet��,2-����(centimeter)
    BYTE         byEnviroHumidity;//�������ʪ�ȣ�ȡֵ��Χ��0~100%
    BYTE        byRes2[2];
    NET_DVR_TEMPERATURE_COLOR struTempColor;//���±�����ɫ
    int            iEnviroTemperature;//�����¶ȣ�ȡֵ��Χ��-273~10000���϶�
    int          iCorrectionVolume;//������������ȡֵ��Χ��-100~100
    /* bit0-���ĵ���£�0-����ʾ��1-��ʾ��
    bit1-��ߵ���£�0-����ʾ��1-��ʾ��
    bit2-��͵���£�0-����ʾ��1-��ʾ��
    */
    BYTE       bySpecialPointThermType;// ������µ���ʾ
    BYTE       byReflectiveEnabled;//�����¶�ʹ�ܣ�0- ��1- ��
    WORD       wDistance;//����(m)[0, 10000]
    float      fReflectiveTemperature;//�����¶� ��ȷ��С����һλ
    float      fAlert;//Ԥ���¶���ֵ��-100.0-1000.0�ȣ���ȷ��С�����һλ��
    float      fAlarm;//�����¶���ֵ��-100.0-1000.0�ȣ���ȷ��С�����һλ��
    float      fThermalOpticalTransmittance;// ��ѧ͸����, ��ȷ��С�����3λ����Χ0.001-1.000��Ĭ��1.000
    float      fExternalOpticsWindowCorrection;//�ⲿ��ѧ�¶ȣ�Ĭ��ֵ20�棬��ΧΪ-40.0~80.0�棬ʵ����ʾ��λ�Խ�����ʾΪ׼
    BYTE       byDisplayMaxTemperatureEnabled;// ��ʾ����� 0-����ʾ 1-��ʾ
    BYTE       byDisplayMinTemperatureEnabled;// ��ʾ����� 0-����ʾ 1-��ʾ
    BYTE       byDisplayAverageTemperatureEnabled;// ��ʾƽ���� 0-����ʾ 1-��ʾ
    BYTE       byThermometryInfoDisplayposition;// ������Ϣ��ʾλ�� 0-���� 1-������� 2-��Ļ���Ͻ�
    DWORD        dwAlertFilteringTime;//�¶�Ԥ���ȴ�ʱ��,��λ��
    DWORD        dwAlarmFilteringTime;//�¶ȱ����ȴ�ʱ��,��λ��
    BYTE        byemissivityMode; //�������������� 1-�ֲڣ�2-�ϴֲڣ�3-�Ϲ⻬, 4-�⻬, 0xff-�Զ���
    BYTE        bydisplayTemperatureInOpticalChannelEnabled;//�ɼ�����ʾ�¶���Ϣʹ�ܣ�0-�����ã�1����
    BYTE       byDisplayCentreTemperatureEnabled;// ��ʾ���ĵ��¶� 0-����ʾ 1-��ʾ
    BYTE       byRes[49];
}NET_DVR_THERMOMETRY_BASICPARAM, *LPNET_DVR_THERMOMETRY_BASICPARAM;

typedef    struct tagNET_DVR_THERMOMETRY_COND
{
    DWORD        dwSize;//�ṹ���С
    DWORD        dwChannel;
    WORD        wPresetNo;//0-����
    BYTE        byRes[62];
}NET_DVR_THERMOMETRY_COND, *LPNET_DVR_THERMOMETRY_COND;

typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO_PARAM
{
    BYTE    byEnabled;  //�Ƿ�ʹ�ܣ�0- ��1- ��
    BYTE    byRuleID;//����ID 0-��ʾ��Ч����1��ʼ ��list�ڲ��ж�������Ч�ԣ�
    WORD    wDistance;//����(m)[0, 10000]
    float   fEmissivity;//������(������ ��ȷ��С�������λ)[0.01, 1.00](��������������������ı���)
    BYTE    byDistanceUnit;//���뵥λ: 0-�ף�m����1-Ӣ�ߣ�feet��,2-����(centimeter)
    BYTE    byRes[2];
    BYTE    byReflectiveEnabled;//�����¶�ʹ�ܣ�0- ��1- ��
    float   fReflectiveTemperature;//�����¶� ��ȷ��С����2λ
    char    szRuleName[NAME_LEN/*32*/];//��������    
    BYTE    byemissivityMode; //�������������� 1-�ֲڣ�2-�ϴֲڣ�3-�Ϲ⻬, 4-�⻬, 0xff-�Զ���
    BYTE    byRes1[62];
    BYTE    byRuleCalibType;//����궨���� 0-�㣬1-��2-��
    NET_VCA_POINT struPoint;//��������꣨������궨����Ϊ"��"��ʱ����Ч��
    NET_VCA_POLYGON struRegion;//�����ߣ�������궨����Ϊ"��"����"��"��ʱ����Ч��
}NET_DVR_THERMOMETRY_PRESETINFO_PARAM, *LPNET_DVR_THERMOMETRY_PRESETINFO_PARAM;


typedef    struct tagNET_DVR_THERMOMETRY_PRESETINFO
{
    DWORD        dwSize;//�ṹ���С
    WORD        wPresetNo;//0-����
    BYTE        byRes[2];
    NET_DVR_THERMOMETRY_PRESETINFO_PARAM struPresetInfo[MAX_THERMOMETRY_REGION_NUM/*40*/];
}NET_DVR_THERMOMETRY_PRESETINFO, *LPNET_DVR_THERMOMETRY_PRESETINFO;


typedef struct tagNET_DVR_BASE_STATION_INFO_ALARM
{
    DWORD        dwSize;
    DWORD        dwChannel;//ͨ����
    char         sNetBarWaCode[16];//�������
    char         sCollectionEquipmentID[24];//�ɼ��豸���
    char         sMCC[4];//�ƶ�������
    char         sMNC[4];//�ƶ�������
    char         sLAC[36];//λ������
    char         sCI[36];//С��ʶ����
    char         sBSCI[36];//��վʶ����
    char         sBCCH[36];//�����㲥�ŵ�
    char         sLEV[36];//���ձ����ƽ
    char         sCollectionEquipmentLongitude[12];//�ɼ��豸����
    char         sCollectionEquipmentLatitude[12];//�ɼ��豸γ��
    char         sCaptureTime[20];//�ɼ�ʱ�� ʱ���ʽyyyy-MM-dd hh:mm:ss
    BYTE         byRes[256];
}NET_DVR_BASE_STATION_INFO_ALARM, *LPNET_DVR_BASE_STATION_INFO_ALARM;


typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE_PARAM
{
    BYTE      byEnable;
    BYTE      byRuleID;//����ID
    BYTE      byRule;//�����¶ȱȽϷ�ʽ 0-���´���,1-����С��,2-���´���,3-����С��,4-ƽ���´���,5-ƽ����С��,6-�²����,7-�²�С��    
    BYTE      byRes;
    char      szRuleName[NAME_LEN];//��������
    float      fAlert;//Ԥ���¶�
    float      fAlarm;//�����¶�
    float      fThreshold;//�����¶�
    DWORD        dwAlertFilteringTime;//�¶�Ԥ���ȴ�ʱ��,��λ��
    DWORD        dwAlarmFilteringTime;//�¶ȱ����ȴ�ʱ��,��λ��
    BYTE      byRes1[56];
}NET_DVR_THERMOMETRY_ALARMRULE_PARAM, *LPNET_DVR_THERMOMETRY_ALARMRULE_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_ALARMRULE
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_THERMOMETRY_ALARMRULE_PARAM  struThermometryAlarmRuleParam[THERMOMETRY_ALARMRULE_NUM];
    BYTE        byRes[128];
}NET_DVR_THERMOMETRY_ALARMRULE, *LPNET_DVR_THERMOMETRY_ALARMRULE;


typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM
{
    BYTE       byEnable;
    BYTE       byRuleID;//����ID,0-��ʾ��Ч����Χֵ��1��ʼ
    BYTE       byAlarmID1;
    BYTE       byAlarmID2;
    BYTE       byRule;//�����¶ȱȽϷ�ʽ0-���´���,1-����С��,2-���´���,3-����С��,4-ƽ���´���,5-ƽ����С��,6-�²����,7-�²�С��
    BYTE       byRes[3];
    float      fTemperatureDiff;//�²�ֵ
    DWORD      dwAlarmFilteringTime;//�¶ȱ����ȴ�ʱ��,��λ��
    BYTE       byRes1[28];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM;

typedef    struct tagNET_DVR_THERMOMETRY_DIFFCOMPARISON
{
    DWORD        dwSize;//�ṹ���С
    NET_DVR_THERMOMETRY_DIFFCOMPARISON_PARAM  struDiffComparison[MAX_THERMOMETRY_DIFFCOMPARISON_NUM/*8*/];
    BYTE        byRes[64];
}NET_DVR_THERMOMETRY_DIFFCOMPARISON, *LPNET_DVR_THERMOMETRY_DIFFCOMPARISON;


//ʵʱ�¶ȼ�������ṹ
typedef struct tagNET_DVR_REALTIME_THERMOMETRY_COND
{
    DWORD       dwSize;
    DWORD       dwChan;//ͨ���ţ���1��ʼ��0xffffffff�����ȡȫ��ͨ��
    BYTE        byRuleID; //����ID 0-�����ȡȫ�����򣬾������ID��1��ʼ 
    /*
    1-��ʱģʽ���豸ÿ��һ���ϴ���������������ݵ�����¡�����º�ƽ���¶�ֵ���²�
    2-�²�ģʽ������һ������һ�������»�������»���ƽ���»����²�ֵ���²���ڵ���2���϶ȣ����ϴ�����¡�����º�ƽ���¶�ֵ�������ڵ���һ��Сʱ�²�ֵ��С��2���϶ȣ����ϴ�����¡�����¡�ƽ���º��²�ֵ
    */
    BYTE        byMode; //������ģʽ�� 0-������Ϊ�������豸����1-��ʱģʽ��2-�²�ģʽ
    WORD        wInterval; //�ϴ���������²�ģʽ֧�֣�1~3600S����0��Ĭ��3600S�ϴ�һ��
    BYTE        byRes[60]; //����
}NET_DVR_REALTIME_THERMOMETRY_COND, *LPNET_DVR_REALTIME_THERMOMETRY_COND;

typedef struct tagNET_DVR_POINT_THERM_CFG
{
    float        fTemperature;//��ǰ�¶�
    NET_VCA_POINT struPoint;//��������꣨������궨����Ϊ���ʱ����Ч��
    BYTE    byRes[120];
}NET_DVR_POINT_THERM_CFG, *LPNET_DVR_POINT_THERM_CFG;

typedef struct tagNET_DVR_LINEPOLYGON_THERM_CFG
{
    float       fMaxTemperature;//�����
    float        fMinTemperature;//�����
    float       fAverageTemperature;//ƽ����
    float        fTemperatureDiff;//�²�
    NET_VCA_POLYGON struRegion;//���򣨵�����궨����Ϊ��/�ߵ�ʱ����Ч��
    BYTE    byRes[32];
}NET_DVR_LINEPOLYGON_THERM_CFG, *LPNET_DVR_LINEPOLYGON_THERM_CFG;

typedef struct tagNET_DVR_THERMOMETRY_UPLOAD
{
    DWORD       dwSize;
    DWORD       dwRelativeTime;     // ���ʱ��
    DWORD       dwAbsTime;            // ����ʱ��
    char        szRuleName[NAME_LEN/*32*/];//��������
    BYTE        byRuleID;//����ID��
    BYTE        byRuleCalibType;//����궨���� 0-�㣬1-��2-��
    WORD        wPresetNo; //Ԥ�õ��
    NET_DVR_POINT_THERM_CFG struPointThermCfg;
    NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
    BYTE        byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    BYTE        byDataType;//����״̬����:0-����У�1-��ʼ��2-����
    BYTE		byRes1;
    /*
    bit0-���ĵ���£�0-��֧�֣�1-֧�֣�
    bit1-��ߵ���£�0-��֧�֣�1-֧�֣�
    bit2-��͵���£�0-��֧�֣�1-֧�֣�
    */
    BYTE      bySpecialPointThermType;// �Ƿ�֧����������
    float	   fCenterPointTemperature;//���ĵ��¶�,��ȷ��С�����һλ(-40-1500),��������+100��*10 ����bySpecialPointThermType�ж��Ƿ�֧�����ĵ㣩
    float	   fHighestPointTemperature;//��ߵ��¶�,��ȷ��С�����һλ(-40-1500),��������+100��*10����bySpecialPointThermType�ж��Ƿ�֧����ߵ㣩
    float	   fLowestPointTemperature;//��͵��¶�,��ȷ��С�����һλ(-40-1500),��������+100��*10����bySpecialPointThermType�ж��Ƿ�֧����͵㣩
    NET_VCA_POINT struHighestPoint;//�ߡ����������¶�λ�����꣨������궨����Ϊ�ߡ����ʱ����Ч��
    NET_VCA_POINT struLowestPoint;//�ߡ����������¶�λ�����꣨������궨����Ϊ�ߡ����ʱ����Ч��
	BYTE       byIsFreezedata;//�Ƿ����ݶ��� 0-�� 1-��
    BYTE        byRes2[3];
    DWORD       dwChan; //ͨ���ţ���ѯ������ͨ����Ϊ0xffffffffʱ���ֶ���Ч
    BYTE          byRes[88];
}NET_DVR_THERMOMETRY_UPLOAD, *LPNET_DVR_THERMOMETRY_UPLOAD;

//�¶ȱ���������¶Ⱥ������¶ȱȽϱ�����
typedef struct tagNET_DVR_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    BYTE    byRuleID;//����ID
    BYTE    byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    WORD    wPresetNo; //Ԥ�õ��
    NET_PTZ_INFO  struPtzInfo;//ptz������Ϣ
    BYTE    byAlarmLevel;//0-Ԥ�� 1-����
    BYTE    byAlarmType;/*�������� 0-����¶� 1-����¶� 2-ƽ���¶� 3-�²� 4-�¶�ͻ�� 5-�¶�ͻ��*/
    BYTE    byAlarmRule;//0-���ڣ�1-С��
    BYTE    byRuleCalibType;//����궨���� 0-�㣬1-��2��
    NET_VCA_POINT struPoint;//��������꣨������궨����Ϊ���ʱ����Ч��
    NET_VCA_POLYGON struRegion;//���򣨵�����궨����Ϊ���ʱ����Ч��
    float   fRuleTemperature;/*���ù����¶�,��ȷ��С�����һλ(-40-1000),��������+100�� */
    float   fCurrTemperature;/*��ǰ�¶�,��ȷ��С�����һλ(-40-1000),��������+100�� */
    DWORD   dwPicLen;//�ɼ���ͼƬ����
    DWORD   dwThermalPicLen;//�ȳ���ͼƬ����
    DWORD   dwThermalInfoLen;//�ȳ��񸽼���Ϣ����
    char*   pPicBuff; ///�ɼ���ͼƬָ��
    char*   pThermalPicBuff;// �ȳ���ͼƬָ��
    char*   pThermalInfoBuff; //�ȳ��񸽼���Ϣָ��
    NET_VCA_POINT struHighestPoint;//�ߡ����������¶�λ�����꣨������궨����Ϊ�ߡ����ʱ����Ч��
    float   fToleranceTemperature;/* �ݲ��¶�,��ȷ��С�����һλ(-40-1000),��������+100�� */
    DWORD   dwAlertFilteringTime;//�¶�Ԥ���ȴ�ʱ�� ��λ�� ��ΧΪ0-200�룬Ĭ��Ϊ0��
    DWORD   dwAlarmFilteringTime;//�¶ȱ����ȴ�ʱ�� ��λ�� ��ΧΪ0-200�룬Ĭ��Ϊ0��
    DWORD   dwTemperatureSuddenChangeCycle;//�¶�ͻ���¼���ڣ���λ��
    float   fTemperatureSuddenChangeValue;//�¶�ͻ��ֵ,��ȷ��С�����һλ(����0)
    BYTE    byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE    byRes[39];
}NET_DVR_THERMOMETRY_ALARM, *LPNET_DVR_THERMOMETRY_ALARM;


//�²��
typedef struct tagNET_DVR_THERMOMETRY_DIFF_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    BYTE    byAlarmID1;//����AlarmID1
    BYTE    byAlarmID2;//����AlarmID2
    WORD    wPresetNo; //Ԥ�õ��
    BYTE    byAlarmLevel;//0-Ԥ�� 1-����
    BYTE    byAlarmType;/*�������� 0-����¶� 1-����¶� 2-ƽ���¶�*/
    BYTE    byAlarmRule;//0-���ڣ�1-С��
    BYTE    byRuleCalibType;//����궨���� 0-�㣬1-��2��
    NET_VCA_POINT struPoint[2];//��������꣨������궨����Ϊ���ʱ����Ч�������±�0������AlarmID1�������±�1������AlarmID2.
    NET_VCA_POLYGON struRegion[2];//���򣨵�����궨����Ϊ���ʱ����Ч�������±�0������AlarmID1�������±�1������AlarmID2.
    float   fRuleTemperatureDiff;/*���ù����²�,��ȷ��С�����һλ(-40-1000)��*/
    float   fCurTemperatureDiff;/*��ǰ�²�,��ȷ��С�����һλ(-40-1000),��������+100�� */
    NET_PTZ_INFO  struPtzInfo;//ptz������Ϣ
    DWORD   dwPicLen;//�ɼ���ͼƬ����
    DWORD   dwThermalPicLen;//�ȳ���ͼƬ����
    DWORD   dwThermalInfoLen;//�ȳ��񸽼���Ϣ����
    char*   pPicBuff; ///�ɼ���ͼƬָ��
    char*   pThermalPicBuff;// �ȳ���ͼƬָ��
    char*   pThermalInfoBuff; //�ȳ��񸽼���Ϣָ��
    BYTE    byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    BYTE    byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    BYTE    byRes1[2];
    float   fToleranceTemperature;/*�ݲ��¶�,��ȷ��С�����һλ(-40-1000),��������+100�� */
    DWORD   dwAlarmFilteringTime;//�¶ȱ����ȴ�ʱ�� ��λ�� ��ΧΪ0-200�룬Ĭ��Ϊ0��
    BYTE    byRes[52];
}NET_DVR_THERMOMETRY_DIFF_ALARM, *LPNET_DVR_THERMOMETRY_DIFF_ALARM;

typedef  struct  //�����ṹ
{
    DWORD   dwSize;
    DWORD  dwChannel;//ͨ���ţ�ǰ��Ĭ����1��
    BYTE   byRes[128];
}NET_DVR_SHIPSCOUNT_COND, *LPNET_DVR_SHIPSCOUNT_COND;


//��ȡ��ֻ������Ϣ�ṹ
typedef struct tagNET_DVR_SHIPSCOUNT_CFG
{
    DWORD dwSize;
    DWORD dwUpShipsCount; //���д�ֻ��
    DWORD dwDownShipsCount; //���д�ֻ��
    DWORD dwLeftShipsCount; //���д�ֻ��
    DWORD dwRightShipsCount; //���д�ֻ��
    DWORD dwTotalCount;//��ֻ�ܼ���
    DWORD dwRelativeTime; //�豸�������ʼ���������ʱ��
    DWORD dwAbsTime; //�豸�������ʼ�����ľ���ʱ��
    BYTE   byDataType;//����״̬����:0-����У�1-��ʼ��2-����
    BYTE   byRes[255];
}NET_DVR_SHIPSCOUNT_CFG, *LPNET_DVR_SHIPSCOUNT_CFG;

//��ֻ��Ϣ
typedef struct tagNET_DVR_SHIPSINFO
{
    float     fShipsLength; //��ֻ���ȣ�1~1000.0m����ȷ��С�����һλ
    float     fShipsHeight; //��ֻ�߶ȣ�1~1000.0m����ȷ��С�����һλ
    float     fShipsWidth;  //��ֻ��ȣ�1~1000.0m����ȷ��С�����һλ
    float     fShipsSpeed;  //��ֻ�ٶȣ�1~1000.0m/s����ȷ��С�����һλ
    BYTE      byShipsDirection;//��ֻ����0~up,1~down,2~left,3~right
    BYTE      byShipsDetState;//��ֻ���״̬��0~����Խ����ߣ�1~��ͷ��⣬2~��β���
    BYTE      byTriggerLineID;//�����ID
    BYTE      byRes[61];
    NET_VCA_POLYGON  struShipsRect; //��ֻ���򣬹�һ��ֵ������ڴ�ͼ���ɼ���ͼ���ȳ���ͼ)�ķֱ���
} NET_DVR_SHIPSINFO, *LPNET_DVR_SHIPSINFO;

//��ֻ��ⱨ���ϴ�
typedef struct tagNET_DVR_SHIPSDETECTION_ALARM
{
    DWORD   dwSize;
    NET_VCA_DEV_INFO  struDevInfo;   //�豸��Ϣ
    DWORD   dwRelativeTime; //���ʱ��
    DWORD   dwAbsTime; //����ʱ��
    BYTE    byShipsNum; //��ֻ����(����Խ����ߵĴ�ֻ��)
    BYTE    byShipsNumHead;//��ֻ����(��ͷ��⴬ֻ��)
    BYTE    byShipsNumEnd; //��ֻ����(��β��⴬ֻ��)
    BYTE    byPicTransType;        //ͼƬ���ݴ��䷽ʽ: 0-�����ƣ�1-url
    NET_DVR_SHIPSINFO struShipInfo[MAX_SHIPS_NUM/*20*/];//��ֻ��Ϣ�����֧��20��
    DWORD   dwPicLen;//�ɼ���ͼƬ����
    DWORD   dwThermalPicLen;//�ȳ���ͼƬ����
    BYTE*   pPicBuffer;    //�ɼ���ͼƬ����ָ��
    BYTE*   pThermalPicBuffer;    //�ȳ���ͼƬ����ָ��
    WORD    wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE    byTimeDiffFlag;      /*ʱ���ֶ��Ƿ���Ч  0-ʱ����Ч�� 1-ʱ����Ч */
    char    cTimeDifferenceH;         /*��UTC��ʱ�Сʱ����-12 ... +14�� +��ʾ����,��byTimeDiffFlagΪ1ʱ��Ч*/
    char    cTimeDifferenceM;      	/*��UTC��ʱ����ӣ���-30, 30, 45�� +��ʾ������byTimeDiffFlagΪ1ʱ��Ч*/
    BYTE    bySID;//����ID
    BYTE    byRes1[2];
    char    szSceneName[NAME_LEN];//�������ƣ�������32�ַ�
    BYTE    byRes[216];
}NET_DVR_SHIPSDETECTION_ALARM, *LPNET_DVR_SHIPSDETECTION_ALARM;

typedef    struct tagNET_DVR_THERMAL_PIP
{
    DWORD     dwSize;//�ṹ���С
    BYTE      byEnable;//�Ƿ�����
    BYTE      byPipMode;// ���л�ģʽ��0~����ģʽ��1~�ں�ģʽ��2-��ͨģʽ
    BYTE      byOverlapType;//�������ͣ�ѡ���л�����ģʽ����Ч��0~�ɼ�������ȳ���ͼƬ��1~�ȳ�����ӿɼ���ͼƬ
    BYTE      byTransparency;//͸���� 0~100
    NET_VCA_POLYGON struPipRegion;//���л�����λ��
    BYTE      byImageFusionRatio;//ͼ���ںϱ���,�ں�ģʽ����Ч 0-100 Ĭ��75
    BYTE      byBorderFusionRatio;//��Ե�ںϱ���,�ں�ģʽ����Ч 0-100 Ĭ��100
    BYTE      byRes1[2];
    float     fDistance;//�ںϾ���,�ں�ģʽ����Ч,��Χ0.1-4.0��
    BYTE      byRes[632];
}NET_DVR_THERMAL_PIP, *LPNET_DVR_THERMAL_PIP;

typedef    struct tagNET_DVR_RULESLINE_CFG
{
    NET_DVR_RGB_COLOR struRGB;// RGB������R����ɫ����G����ɫ����B����ɫ�� ��Χ0-255
    BYTE      byRes[128];
}NET_DVR_RULESLINE_CFG, *LPNET_DVR_RULESLINE_CFG;

typedef    struct tagNET_DVR_THERMAL_INTELRULE_DISPLAY
{
    DWORD       dwSize;//�ṹ���С
    /*
    fontSizeType:Ϊ�����С�������������ſ����ݸñ����Լ�Ԥ�����ڵĿ�ȶ�̬�ı�����Ĵ�С����ʽΪ�����屶��ֵ/8*(0.01*Ԥ�����ڿ��)
    ����������Ӧ���£�
    0~8���ʣ�С��
    1~12���ʣ���׼��
    2~16���ʣ���
    3~20���ʣ�����
    4~24���ʣ��ش�
    */
    BYTE      byFontSizeType;
    BYTE      byRes1[3];
    NET_DVR_RULESLINE_CFG struNormalRulesLineCfg;//����������������Բ���
    NET_DVR_RULESLINE_CFG struAlertRulesLineCfg;//Ԥ��������������Բ���
    NET_DVR_RULESLINE_CFG struAlarmRulesLineCfg;//����������������Բ���
    BYTE      byRes[640];
}NET_DVR_THERMAL_INTELRULE_DISPLAY, *LPNET_DVR_THERMAL_INTELRULE_DISPLAY;

typedef struct tagNET_DVR_BAREDATAOVERLAY_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//ʹ��
    BYTE    byIntervalTime;// �ϴ���ʱ���������ã�1 2 3 4 5.��λΪ�룬Ĭ��Ϊ3��
    BYTE    byRes[258];
}NET_DVR_BAREDATAOVERLAY_CFG, *LPNET_DVR_BAREDATAOVERLAY_CFG;

//�������������ṹ
typedef    struct tagNET_DVR_THERMOMETRY_TRIGGER_COND
{
    DWORD    dwSize;//�ṹ���С
    DWORD    dwChan;//ͨ����
    DWORD    dwPreset;//Ԥ�õ�ţ�Ŀǰ��֧��,���踳ֵ��
    BYTE     byRes[256];
}NET_DVR_THERMOMETRY_TRIGGER_COND, *LPNET_DVR_THERMOMETRY_TRIGGER_COND;

//�ֶ�����
typedef    struct tagNET_DVR_MANUALDEICING_CFG
{
    DWORD        dwSize;//�ṹ���С
    BYTE        byEnabled; //�Ƿ������ֶ����� ��0~�رգ�1~����
    BYTE        byRes[127];
}NET_DVR_MANUALDEICING_CFG, *LPNET_DVR_MANUALDEICING_CFG;

//С���LED������
typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_COND
{
    DWORD    dwSize;
    DWORD    dwInputSourceNo;    //����Դ���
    DWORD    dwTextNo;        //�ı����
    BYTE    byRes[32];
}NET_DVR_INPUT_SOURCE_TEXT_COND, *LPNET_DVR_INPUT_SOURCE_TEXT_COND;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT
{
    DWORD        dwSize;
    DWORD        dwTextNo;            //�ı����
    BYTE        byEnable;            //�Ƿ�ʹ�ܣ�0-��ʹ�ܣ�1-ʹ��
    BYTE        byFontSize;            //�����С
    BYTE        byBkGroudMode;        //����ģʽ��1-͸����2-����
    BYTE        byRes[1];
    DWORD        dwXPosition;            //�ַ���ʾλ�õ����Ͻ�X���꣬����Դ�������
    DWORD        dwYPosition;            //�ַ���ʾλ�õ����Ͻ�Y���꣬����Դ�������
    NET_DVR_RGB_COLOR struForegroudColor;    //�ַ�ǰ��ɫ
    NET_DVR_RGB_COLOR struBackgroudColor; //�ַ�����ɫ
    BYTE        byTextContent[MAX_LEN_TEXT_CONTENT];    //�ַ�����
    BYTE        byRes1[64];
}NET_DVR_INPUT_SOURCE_TEXT, *LPNET_DVR_INPUT_SOURCE_TEXT;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_SOURCE_TEXT struTextList[MAX_NUM_INPUT_SOURCE_TEXT]; //�ı��б�
    BYTE    byRes[64];
}NET_DVR_INPUT_SOURCE_TEXT_LIST, *LPNET_DVR_INPUT_SOURCE_TEXT_LIST;

typedef struct  tagNET_DVR_INPUT_SOURCE_RESOLUTION
{
    DWORD  dwSize;
    DWORD  dwInputSignalNo;  //����Դ���
    BYTE  byEnabled;  //�Զ���ֱ����Ƿ�ʹ��
    BYTE  byRes;
    WORD  wImageWidth;     //ͼ����
    WORD  wImageHeight;  //ͼ��߶�
    WORD  wRefreshRate;     //ˢ��Ƶ��
    BYTE    byColorDepth;  //��ɫ��ȣ�32λ��16λ��8λ���ֿ�ѡ
    BYTE    byScanType;  //ɨ�����ͣ�1-����ɨ�裬2-���ɨ��
    BYTE    byRes1[62];
}NET_DVR_INPUT_SOURCE_RESOLUTION, *LPNET_DVR_INPUT_SOURCE_RESOLUTION;

typedef struct tagNET_DVR_INPUT_SOURCE_RESOLUTION_LIST
{
    DWORD dwSize;
    DWORD dwInputSignalCnt; //�豸�����ź�Դ����
    LPNET_DVR_INPUT_SOURCE_RESOLUTION lpstruBuffer; //������ָ��
    DWORD dwBufferSize; //��������С
    BYTE  byRes[32];
}NET_DVR_INPUT_SOURCE_RESOLUTION_LIST, *LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

typedef struct tagNET_DVR_LED_AREA_COND
{
    DWORD dwSize;
    DWORD dwVideoWallNo; //����ǽ���
    DWORD dwLEDAreaNo; //LED������
    BYTE   byRes[32];
}NET_DVR_LED_AREA_COND, *LPNET_DVR_LED_AREA_COND;

typedef struct tagNET_DVR_LED_AREA_INFO
{
    DWORD dwSize;
    DWORD dwLEDAreaNo; //LED������
    NET_DVR_RECTCFG_EX struRect; //��������
    DWORD dwaOutputNo[MAX_NUM_OUTPUT_CHANNEL]; //������б�
    BYTE  byAreaType; //�������ͣ�0-LED����1-LCD����
    BYTE  byRes[31];
}NET_DVR_LED_AREA_INFO, *LPNET_DVR_LED_AREA_INFO;

typedef struct tagNET_DVR_LED_AREA_INFO_LIST
{
    DWORD dwSize;
    DWORD dwLEDAreaNum; //LED��������
    LPNET_DVR_LED_AREA_INFO lpstruBuffer; //������ָ��
    DWORD dwBufferSize; //��������С
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO_LIST, *LPNET_DVR_LED_AREA_INFO_LIST;

//���еȴ�����
typedef struct tagNET_DVR_CALL_WAITTING_CFG
{
    DWORD   dwSize;    //�ṹ���С
    BYTE    byEnable;    //�Ƿ����ú��еȴ�, 0--�����ã�1--����
    BYTE    byRes1;
    WORD    wWaitTime;//���еȴ�ʱ�䣬��λ��
    BYTE    byRes[512];
}NET_DVR_CALL_WAITTING_CFG, *LPNET_DVR_CALL_WAITTING_CFG;

//���Ʋ���
typedef struct tagNET_DVR_ALARM_LAMP_CFG
{
    DWORD   dwSize;    //�ṹ���С
    BYTE    byEnable;    //�Ƿ����þ��ƶ�ʱ��˸, 0--�����ã�1--����
    BYTE    byRes1;
    WORD   wFlashDuration;//���ƶ�ʱ��˸����ʱ�䣬��λ��
    WORD   wFlashIntervalTime;//������˸���ʱ�䣬��λ��
    BYTE    byRes[510];
}NET_DVR_ALARM_LAMP_CFG, *LPNET_DVR_ALARM_LAMP_CFG;

//������ʾ����
typedef struct tagNET_DVR_VOICE_PROMPTION_CFG
{
    DWORD   dwSize;    //�ṹ���С
    BYTE    byEnable;    //�Ƿ�����������ʾ, 0--�����ã�1--����
    BYTE    byRes1[3];
    BYTE    byCenterBusyFile[NAME_LEN];//���ķ�æ��ʾ�����ļ���
    BYTE    byRefusedFile[NAME_LEN];//�ܾ���ʾ�����ļ���
    BYTE    byHangUpFile[NAME_LEN];//�Խ�������ʾ�����ļ���
    BYTE    byCallWaittingFile[NAME_LEN];//���еȺ����ļ���
    BYTE    byConsultWaittingFile[NAME_LEN];//ҵ����ѯ�Ⱥ����ļ���
    BYTE    byRes[480];
}NET_DVR_VOICE_PROMPTION_CFG, *LPNET_DVR_VOICE_PROMPTION_CFG;

//������������
typedef struct tagNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG
{
    DWORD   dwSize;        //�ṹ���С
    BYTE    byCommand;    //�������0--centerbusy��1--refuse
    BYTE    byType;        //�������ͣ�0������������1��ҵ����ѯ
    BYTE    byRes[510];
}NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG, *LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

///////////*�����������_V50/////////////
typedef struct _tagNET_DVR_ALARMHOST_NETPARAM_V50
{
    DWORD     dwSize;
    NET_DVR_IPADDR  struIP;
    WORD     wPort;
    BYTE    byAddressType;    //0 - ������, 1 - ipv4/ipv6��ַ��2 - ����
    BYTE    byEnable; //ʹ�ܣ�0-�����ã�1-����
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //������GPRS�������á������������ʱ���ֶξ���Ч
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //Э��ΪNAL2300ʱ��Ч
    BYTE    byProtocolVersion;            //EHomeЭ��汾��0-������,1�Cv2.0��2�Cv4.0��3-v5.0
    BYTE    byRes1[3];
    BYTE    byEHomeKey[NET_SDK_EHOME_KEY_LEN];            //EHome Key������EHome 5.0�汾��
    BYTE    byRes2[28]; //GPRS�������������ڹ̶��ķ������Ͻ��еģ����Բ���Ҫ����������������ϢԤ��һЩ�ֶ�
} NET_DVR_ALARMHOST_NETPARAM_V50, *LPNET_DVR_ALARMHOST_NETPARAM_V50;

typedef struct _tagNET_DVR_ALARMHOST_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM_V50   struNetCenter[MAX_CENTERNUM];
    BYTE        byRes1[128];
} NET_DVR_ALARMHOST_NETCFG_V50, *LPNET_DVR_ALARMHOST_NETCFG_V50;
//Ŀ���װ��ʽ����
typedef enum tagSTREAM_TYPE{
    STREAM_PS = 0x1,   //PS�ļ��㣬��Ҫ���ڴ洢��Ҳ�����ڴ���
    STREAM_3GPP = 0x2,   //3GPP�ļ��㣬���ڴ洢
}STREAM_TYPE;
typedef enum tagNET_SDK_INIT_CFG_TYPE
{
    NET_SDK_INIT_CFG_TYPE_CHECK_MODULE_COM = 0, //���ӶԱ����ļ��
    NET_SDK_INIT_CFG_ABILITY = 1,   //sdk֧�ֵ�ҵ���������
    NET_SDK_INIT_CFG_SDK_PATH = 2,  //������������·��
	NET_SDK_INIT_CFG_LIBEAY_PATH = 3, //����OpenSSL��libeay32.dll/libcrypto.so/libcrypto.dylib����·��
    NET_SDK_INIT_CFG_SSLEAY_PATH = 4  //����OpenSSL��ssleay32.dll/libssl.so/libssl.dylib����·��
}NET_SDK_INIT_CFG_TYPE;

typedef struct tagNET_DVR_INIT_CHECK_MODULE_COM
{
    BYTE byEnable; //���ñ��������� 0-�����ã�1-����
    BYTE byRes[255];
}NET_DVR_INIT_CHECK_MODULE_COM, *LPNET_DVR_INIT_CHECK_MODULE_COM;
//SDK֧�ֵ����·��������
typedef enum _INIT_CFG_MAX_NUM
{
    INIT_CFG_NUM_2048 = 2048,   // 2048·
    INIT_CFG_NUM_5120 = 5120,   //5120·
    INIT_CFG_NUM_10240 = 10240,   // 10240·
    INIT_CFG_NUM_15360 = 15360,   // 15360·
    INIT_CFG_NUM_20480 = 20480,   // 20480·
}INIT_CFG_MAX_NUM;

typedef struct tagNET_DVR_INIT_CFG_ABILITY
{
    INIT_CFG_MAX_NUM    enumMaxLoginUsersNum;                //��������ע���û�������
    INIT_CFG_MAX_NUM   enumMaxAlarmNum;                      //���ĸ澯·��
    BYTE    byRes[64];
}NET_DVR_INIT_CFG_ABILITY, *LPNET_DVR_INIT_CFG_ABILITY;

typedef struct tagNET_DVR_LOCAL_SDK_PATH
{
    char sPath[NET_SDK_MAX_FILE_PATH];//������ַ
    BYTE byRes[128];
}NET_DVR_LOCAL_SDK_PATH, *LPNET_DVR_LOCAL_SDK_PATH;

typedef struct tagNET_DVR_SDKMEMPOOL_CFG
{
    BYTE byRes[256];
}NET_DVR_SDKMEMPOOL_CFG, *LPNET_DVR_SDKMEMPOOL_CFG;


typedef struct tagNET_DVR_RES_INFO
{
    DWORD dwImageWidth; //ͼ����
    DWORD dwImageHeight; //ͼ��߶�
}NET_DVR_RES_INFO, *LPNET_DVR_RES_INFO;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT
{
    DWORD dwSize;
    DWORD dwVSInputChan; //����������ͨ����
    DWORD dwResNums; //�ֱ��ʵĸ���
    NET_DVR_RES_INFO struResList[MAX_RES_NUM_ONE_VS_INPUT_CHAN]; //�ֱ����б�
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT, *LPNET_DVR_VS_INPUT_CHAN_INIT;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT_LIST
{
    DWORD dwSize;
    NET_DVR_VS_INPUT_CHAN_INIT struChanList[MAX_VS_INPUT_CHAN_NUM]; //ͨ���б�
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT_LIST, *LPNET_DVR_VS_INPUT_CHAN_INIT_LIST;

typedef struct tagNET_DVR_VS_INPUT_CHAN_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan; //����������ͨ����
    NET_DVR_RES_INFO struResolutin; //�ֱ���
    BYTE byRes[64];
}NET_DVR_VS_INPUT_CHAN_CFG, *LPNET_DVR_VS_INPUT_CHAN_CFG;

typedef struct tagNET_DVR_VS_NETSRC_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan; //����������ͨ����
    BYTE byDispUrl[MAX_URL_LEN]; //��ʾURL
    BYTE byEnabled; //�Ƿ�����URL
    BYTE byRes[127];
}NET_DVR_VS_NETSRC_CFG, *LPNET_DVR_VS_NETSRC_CFG;

typedef struct tagNET_DVR_EDID_FILE_INFO
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNo; //EDID�ļ���ţ���1��ʼ
    BYTE    byFileName[FILE_NAME_LEN]; //EDID�ļ�����
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO, *LPNET_DVR_EDID_FILE_INFO;

typedef struct tagNET_DVR_EDID_FILE_INFO_LIST
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNum; //���ص�NET_DVR_EDID_FILE_INFO����
    LPNET_DVR_EDID_FILE_INFO lpstruBuffer; //������ָ��
    DWORD   dwBufferSize; //��������С
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO_LIST, *LPNET_DVR_EDID_FILE_INFO_LIST;

//�Ӵ��ڽ���OSD
typedef struct tagNET_DVR_OSD_INFO
{
    BYTE byEnabled;  //�Ƿ�ʹ�ܣ���-��ʹ�ܣ�����-ʹ��
    BYTE byEnabledFlash;  //�Ƿ���˸����-����˸������-��˸
    BYTE byFontSize;  //�����С��1-��2-�У�3-С
    BYTE byTransparent;  //͸���ȣ�ȡֵ��Χ0-100
    NET_DVR_RGB_COLOR struColor;  //������ɫ
    WORD wCoordinateX;  //OSD���Ͻ�X����
    WORD wCoordinateY;  //OSD���Ͻ�Y����
    BYTE byContent[MAX_LEN_OSD_CONTENT];  //OSD��Ϣ
    BYTE byRes[32];
}NET_DVR_OSD_INFO, *LPNET_DVR_OSD_INFO;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD
{
    DWORD dwSize;
    DWORD dwSubWndNo;  //�Ӵ��ںţ�4�ֽ���Ϸ�ʽ��
    DWORD dwOSDNums;  //���Ӵ������õ�OSD��Ϣ�ĸ���
    NET_DVR_OSD_INFO struOSDList[MAX_NUM_OSD_ONE_SUBWND];  //OSD��Ϣ�б�
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD, *LPNET_DVR_SUBWND_DECODE_OSD;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD_LIST
{
    DWORD dwSize;
    NET_DVR_SUBWND_DECODE_OSD struSubWndList[MAX_NUM_SPLIT_WND];  //�����Ӵ��ڵĽ���OSD
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD_LIST, *LPNET_DVR_SUBWND_DECODE_OSD_LIST;

typedef struct tagNET_DVR_DECODE_CHANNEL_OSD
{
    DWORD dwSize;
    NET_DVR_OSD_INFO struOSDInfo[MAX_NUM_OSD];  //OSD��Ϣ�б�
    BYTE byRes[32];
}NET_DVR_DECODE_CHANNEL_OSD, *LPNET_DVR_DECODE_CHANNEL_OSD;

//�ȳ������ܻ������ò���
typedef    struct tagNET_DVR_THERMINTELL_PARAM
{
    DWORD   dwSize;//�ṹ���С
    BYTE    byIntellType;  //���ܹ�����Դ��������,0~����+��Ϊ����(Ĭ��)��1~��ֻ��⣬2~�����,3~���л�����, 4~�������£�5-����+�̻��⣬6-����+����� 7-��Ϊ���� 8-����
    BYTE    byRes[127];
}NET_DVR_THERMINTELL_PARAM, *LPNET_DVR_THERMINTELL_PARAM;

typedef struct tagNET_DVR_FACE_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//ͨ����
    BYTE    byRuleID;                //�������¹���ID:1-40
    BYTE    byRes1[3];
    BYTE    byRuleName[NAME_LEN];    //��������
    DWORD   dwRelativeTime; //���ʱ��
    DWORD   dwAbsTime; //����ʱ��
    BYTE    byFaceDetectionState;//�������״̬��0~δ��⵽������1~�Ѽ�⵽����
    BYTE    byThermometryUnit;//���µ�λ: 0-���϶ȣ��棩��1-���϶ȣ��H����2-������(K)
    BYTE    byAlarmRule;//��������0-����´��ڣ�1-�����С��
    BYTE    byRes2[1];
    float   fAlarmTemperature;//���������¶ȣ�-20.0~120.0�棬��ȷ��С�����1λ��
    float   fRuleTemperature;// �������ñ����¶ȣ�-20.0~60.0�棬��ȷ��С�����1λ��
    DWORD   dwVisibleLightImageLen;// �ɼ���ͼƬ����
    BYTE    *pVisibleLightImage;  //�ɼ���ͼƬָ��
    DWORD   dwFaceImageLen;// ������ͼ����
    BYTE     *pFaceImage;  //������ͼָ��
    NET_VCA_RECT  struFaceRegion;//����Ŀ��߽���豸ʶ��ץ��ͼƬ�У�������ͼ����
    float         fMinTemperature;// ����¶ȣ�-20.0~120.0�棬��ȷ��С�����1λ��
    float         fAverageTemperature;//ƽ���£�-20.0~120.0�棬��ȷ��С�����1λ��
    NET_VCA_POINT struMinTemperaturePoint; //����¶�λ������
    NET_VCA_POINT struMaxTemperaturePoint;//����¶�λ������
    BYTE     byRes[720];
}NET_DVR_FACE_THERMOMETRY_ALARM, *LPNET_DVR_FACE_THERMOMETRY_ALARM;

//����GUID�ļ�
typedef struct tagNET_DVR_GUID_FILE_EXPORT
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //�û���¼����
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_EXPORT, *LPNET_DVR_GUID_FILE_EXPORT;

//�û���¼����У��
typedef struct tagNET_DVR_LOGIN_PASSWORDCFG
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //�û���¼����
    BYTE    byRes[256];
}NET_DVR_LOGIN_PASSWORDCFG, *LPNET_DVR_LOGIN_PASSWORDCFG;

//������ȫ��������
typedef struct tagNET_DVR_SINGLE_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    DWORD   dwId;//��ţ���ȫ������ţ�ֻ����
    char    sAnswer[NET_SDK_MAX_ANSWER_LEN/*256*/];//�𰸣���ȡʱֻ����
    BYTE    byMark;//���  0-δ���� 1-������
    BYTE    byRes[127];
}NET_DVR_SINGLE_SECURITY_QUESTION_CFG, *LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG;

//��ȫ��������
typedef struct tagNET_DVR_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    NET_DVR_SINGLE_SECURITY_QUESTION_CFG  struSecurityQuestion[NET_SDK_MAX_QUESTION_LIST_LEN/*32*/];//��ȫ�����б�
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];//admin�û���¼����
    BYTE    byRes[512];
}NET_DVR_SECURITY_QUESTION_CFG, *LPNET_DVR_SECURITY_QUESTION_CFG;

typedef    struct tagNET_DVR_ALARMIN_TRIGGER_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //ͨ���ţ���1��ʼ
    DWORD   dwAlarmInNo;//�����ţ���0��ʼ
    BYTE    byRes[256];
}NET_DVR_ALARMIN_TRIGGER_COND, *LPNET_DVR_ALARMIN_TRIGGER_COND;

typedef    struct tagNET_DVR_FACELIB_GUARD_COND
{
    DWORD   dwSize;
    DWORD   dwChannel;  //ͨ����
    char    szFDID[68];//�������ID
    BYTE    byRes[128];
}NET_DVR_FACELIB_GUARD_COND, *LPNET_DVR_FACELIB_GUARD_COND;

typedef struct tagNET_DVR_GUID_FILE_STATUS_INFO
{
    DWORD   dwSize;
    BYTE    byLockStatus; //0��δ������1������
    BYTE    byPasswd;     //0:�������1��������ȷ��ע:��ֵδ����ʱ��Ч��
    BYTE    byRetryNum;   //ʣ�ೢ�Դ�����ע:��ֵδ����ʱ��Ч
    BYTE    byRes1;
    DWORD   dwLockTime;   //ʣ������ʱ�䣺��λ�롣ע:��ֵ����ʱ��Ч
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_STATUS_INFO, *LPNET_DVR_GUID_FILE_STATUS_INFO;


//����ģʽ����
typedef    struct tagNET_DVR_THERMOMETRY_MODE
{
    DWORD     dwSize;//�ṹ���С
    BYTE      byMode;//����ģʽ��0~��ͨģʽ��1~ר��ģʽ
    BYTE      byThermometryROIEnabled; //����ROIʹ�� 0-���� 1-������ 2-���������ڻ�����ݿ��ǣ�
    BYTE      byRes[62];
}NET_DVR_THERMOMETRY_MODE, *LPNET_DVR_THERMOMETRY_MODE;

//�ȳ�������㷨��汾��ȡ
typedef    struct tagNET_DVR_THERMAL_ALGINFO
{
    DWORD     dwSize;//�ṹ���С
    char      sThermometryAlgName[NET_SDK_MAX_THERMOMETRYALGNAME/*128*/];//�����㷨��汾����
    char      sShipsAlgName[NET_SDK_MAX_SHIPSALGNAME /*128*/];//��ֻ�㷨��汾����
    char      sFireAlgName[NET_SDK_MAX_FIRESALGNAME /*128*/];//������㷨��汾����
    BYTE      byRes[768];
}NET_DVR_THERMAL_ALGINFO, *LPNET_DVR_THERMAL_ALGINFO;

//������������
typedef    struct tagNET_DVR_CURRENT_LOCK
{
    DWORD     dwSize;//�ṹ���С
    BYTE      byCurrentLock;//��̨��ֱ�������������0~��������1~ȫ��������2~3/4��������3~��������
    BYTE      byRes[255];
}NET_DVR_CURRENT_LOCK, *LPNET_DVR_CURRENT_LOCK;

//���ȶԱ���������͸����ʽ��
typedef struct tagNET_VCA_FACESNAP_RAWDATA_ALARM_
{
    DWORD  dwSize;   //�ṹ��С
    DWORD  dwRelativeTime;       // ���ʱ��
    DWORD  dwAbsTime;            // ����ʱ��
    NET_VCA_DEV_INFO struDevInfo;  //ǰ���豸��Ϣ
    DWORD  dwJsonDataLen;        //json���ݶ�����Ϣ��0-û�����ݣ���0��ʾ�����ݣ����ṹ�����ŵ�json���ݳ��ȣ�
    BYTE*  pJsonBuff;// json����ָ��
    BYTE   byRes[256];           // �����ֽ�
}NET_VCA_FACESNAP_RAWDATA_ALARM, *LPNET_VCA_FACESNAP_RAWDATA_ALARM;

//LED��ĻУ������
typedef struct tagNET_SDK_LED_SCREEN_CHECK_PARAM
{
    DWORD dwSize;
    BYTE byOperateType; //�������ͣ�1-д��У�����ݣ�2-У��Ԥ����3-ɾ��У������
    BYTE byIsRGBSynChk;	//RGB�Ƿ�ͬ��������0-��֧�֣�!0-֧�֣�byOperateTypeΪ1��2ʱ��Ч
    BYTE byRes1[2];
    WORD wRgbPermil;    //RGBͬ��������ǧ�ֱȣ�byOperateTypeΪ1��2��byIsRGBSynChk����ʱ��Ч
    WORD wRedPermil;    //��ɫ������ǧ�ֱȣ�byOperateTypeΪ1��2��byIsRGBSynChkΪ��ʱ��Ч
    WORD wGreenPermil;  //��ɫ������ǧ�ֱȣ�byOperateTypeΪ1��2��byIsRGBSynChkΪ��ʱ��Ч
    WORD wBluePermil;   //��ɫ������ǧ�ֱȣ�byOperateTypeΪ1��2��byIsRGBSynChkΪ��ʱ��Ч
    DWORD dwRectCount;  //�������������
    NET_DVR_RECTCFG_EX struRectList[MAX_SCREEN_AREA_NUM];   //���������б�˳����
    BYTE byRes2[64];
}NET_SDK_LED_SCREEN_CHECK_PARAM, *LPNET_SDK_LED_SCREEN_CHECK_PARAM;

//LED��ĻУ����Ӧ����
typedef struct tagNET_SDK_SCREEN_CHECK_RESPONSE_DATA
{
    DWORD dwSize;
    BYTE byDataType;                //�������ͣ�1-���ȣ�������ȣ���2-״̬
    BYTE byOperateType;             //�������ͣ�1-д��У�����ݣ�2-У��Ԥ����3-ɾ��У������
    BYTE byProgress;                //���ȣ�byDataTypeΪ1ʱ��Ч��0-100
    BYTE byStatus;                  //״̬��byDataTypeΪ2ʱ��Ч��1-LED��Ļ����У��ʧ�ܣ�2-LED��Ļ�����Ӧ�Ľ��տ������ڣ�3-����У������ʧ�ܣ�ԭʼ�����쳣��
    //4-����Ļ�ͺŲ�֧��У����5-�豸æ������У������6-�豸�ڴ治��
    NET_DVR_RECTCFG_EX struRect;    //LED��Ļ����byDataTypeΪ2ʱ��Ч
    BYTE byRes[64];
}NET_SDK_SCREEN_CHECK_RESPONSE_DATA, *LPNET_SDK_SCREEN_CHECK_RESPONSE_DATA;

typedef struct tagNET_DVR_PLAY_BY_NAME_PARA
{
    char szFileName[100]; //�ط��ļ���
    BYTE byDownload;    //�Ƿ����� 0-��1-��
    BYTE byRes1[127];
    HWND hWnd;  //�طŵĴ��ھ��������Ϊ�գ�SDK�����յ��������ݣ�����������ʾ
    NET_DVR_ADDRESS struAddr; //�ļ����ڼ�Ⱥ��CS��ַ��Ϣ������Ϣ�ļ�����ʱ�᷵��
    //���Ϊ�ձ�ʾ����¼��ַ
    BYTE byRes2[256];
}NET_DVR_PLAY_BY_NAME_PARA, *LPNET_DVR_PLAY_BY_NAME_PARA;

typedef struct tagNET_DVR_PLAYBCK_BYTIME_COND_PCNVR
{
    DWORD           dwSize;   
    NET_DVR_IPADDR  struIpAddr;
    WORD            wIpPort;
    BYTE            byRes[2];
    char            sDomainName[MAX_DOMAIN_NAME];
    char            sSerial[SERIALNO_LEN];  
    LONG            iChannel;
    NET_DVR_TIME    struStartTime;
    NET_DVR_TIME    struStopTime;
    HWND            hWnd;
}NET_DVR_PLAYBCK_BYTIME_COND_PCNVR, *LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR;

//���ļ������ؼ�Ⱥ¼���ļ�
typedef struct tagNET_DVR_DOWNLOAD_BY_NAME_COND
{
    char *pFileName; //�ط��ļ���������\0�����100�ֽ�
    char *pSavedFileName;//�ļ�����λ��
    NET_DVR_ADDRESS struAddr; //�ļ����ڼ�Ⱥ��CS��ַ��Ϣ������Ϣ�ļ�����ʱ�᷵��
    //���Ϊ�ձ�ʾ����¼��ַ
    BYTE byRes[256];
}NET_DVR_DOWNLOAD_BY_NAME_COND, *LPNET_DVR_DOWNLOAD_BY_NAME_COND;

typedef struct tagNET_DVR_PIC_PARAM   //���ҽ���ṹ��
{
    char *pDVRFileName;  //ͼƬ��������\0�����64�ֽ�
    char *pSavedFileBuf; //����ͼƬ�Ļ��������ڴ��ⲿ�����ͷ�
    DWORD dwBufLen; //��������С
    DWORD *lpdwRetLen; //ʵ���յ������ݳ���ָ�룬����ΪNULL
    NET_DVR_ADDRESS struAddr; //ͼƬ���ڵĵ�ַ��Ϣ��ͼƬ����ʱ�᷵��
    BYTE byRes[256];   //�����ֽ�
}NET_DVR_PIC_PARAM, *LPNET_DVR_PIC_PARAM;

#define NET_SDK_MAX_INDENTITY_KEY_LEN 64 //�������������

//����������������
typedef struct tagNET_DVR_FACELIB_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];//������ID
    BYTE        byConcurrent;//�豸�������� 0-��������1-��ʼ
    BYTE        byCover;//�Ƿ񸲸�ʽ���� 0-��1-��
    BYTE        byCustomFaceLibID;//FDID�Ƿ����Զ��壬0-���ǣ�1-�ǣ�
    /*����/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities�������з���isSupportNoSaveUploadPicture�����ڵ�ʱ��
    ����ǲ�������ģʽ�£�֧�ֲ������ϴ�ԭͼ�Ĳ���:���ϴ��ɹ�ͼƬ���豸��ģ�ɹ��󣬻Ὣ�ϴ���ԭͼ����ɾ����
    ע���ò����޷��벢������ͬʱ���С�*/
    BYTE        byPictureSaveMode;//�ϴ�ԭͼ����ģʽ��0-���棬1-������;
    BYTE        byIdentityKey[NET_SDK_MAX_INDENTITY_KEY_LEN/*64*/];//������������
    BYTE        byRes[60];
}NET_DVR_FACELIB_COND, *LPNET_DVR_FACELIB_COND;

typedef  struct  tagNET_DVR_EXPORT_PUBLISH_SCHEDULE
{
    DWORD       dwScheduleID;// �ճ�����
    DOWNLOAD_DATA_CB    fnDownloadFileCallBack;    //���ݻص�����
    void*   pUser;    //�û�����ָ��
    BYTE    byRes[32];
}NET_DVR_EXPORT_PUBLISH_SCHEDULE, *LPNET_DVR_EXPORT_PUBLISH_SCHEDULE;

typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_COND
{
    DWORD dwSize;
    DWORD  dwAudioChannel;//�����Խ�ͨ����
    BYTE   byRes[128];
}NET_DVR_GBT28181_AUDIO_OUTPUT_COND, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_COND;

//GBT28181Э����������ͨ������ ���ýṹ
typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_CFG
{
    DWORD                   dwSize;
    char    szAudioOutNumID[MAX_COMPRESSIONID_LEN];//�豸�����������ID
    BYTE             byRes[256];
}NET_DVR_GBT28181_AUDIO_OUTPUT_CFG, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_CFG;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA
{
    DWORD dwSize;
    DWORD dwFileSize;     //�ļ���С����λ���ֽ�
    BYTE  byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //������
    BYTE  byRes[2016];
}NET_DVR_NOTICE_VIDEO_DATA, *LPNET_DVR_NOTICE_VIDEO_DATA;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_COND
{
    DWORD       dwSize;
    BYTE  byRes[256];          //����
}NET_DVR_NOTICE_VIDEO_DATA_COND, *LPNET_DVR_NOTICE_VIDEO_DATA_COND;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_CFG
{
    DWORD    dwSize;
    DWORD dwDataLen;     //���ݳ���
    char*  pDataBuffer;     //����ָ��
    BYTE  byDataType;      //�������ͣ�0-��Ч��1-�ṹ�����ݣ�NET_DVR_NOTICE_VIDEO_DATA����2-��Ƶ����
    BYTE  byRes[63];
}NET_DVR_NOTICE_VIDEO_DATA_CFG, *LPNET_DVR_NOTICE_VIDEO_DATA_CFG;

typedef struct tagNET_DVR_UPGRADE_FIRMWARE_INFO
{
    DWORD dwMagicNumber;    /* ħ���ֶΣ��̶�ֵ0x484b5753 */
    DWORD dwCheckSum;       /* �ļ�ͷУ��� */
    DWORD dwHeadLen;        /* �ļ�ͷ���� */
    DWORD dwFileNums;       /* �ļ����� */
    DWORD dwLanguage;       /* ���ԣ�1-Ӣ�Ļ�����ԣ�2-���� */
    DWORD dwDeviceClassID;  /* 1 �C DS9000 DVR */
    DWORD dwOemCode;        /* 1 �C hikvision  */
    BYTE  byUpgradeVersion; /* �����汾: 0xFE - ���ж�flash, ram, DSP ram ������*/
    BYTE  byResFeature[15]; /* �����ֶ� */
    BYTE  byFlashSize;      /* 0 - do not need check; 1 - 16M; 2 - 32M; 3 - 64M  */
    BYTE  byRamSize;        /* 0 - do not need check; 1 - 128M; 2 - 256M; 3 - 512M; 4 - 1024M*/
    BYTE  byDspRamSize;     /* 0 - do not need check; 1 - 64M; 2 - 128M; 3 - 256M */
    BYTE  byRes[17];        /* ���� */
}NET_DVR_UPGRADE_FIRMWARE_INFO, *LPNET_DVR_UPGRADE_FIRMWARE_INFO;


typedef struct tagNET_DVR_SCHEDULE_FILE_RET
{
    DWORD   dwSize;
    char   szFileName[32];    //�ļ���
    DWORD   dwFileLen;  //�ļ�����
    BYTE    byRes[64];
}NET_DVR_SCHEDULE_FILE_RET, *LPNET_DVR_SCHEDULE_FILE_RET;

#define NET_SDK_MAX_EXAM_ROUND_NO       64  //���Գ��α����󳤶�
#define NET_SDK_MAX_EXAM_NO             64  //���Ա����󳤶�
#define NET_SDK_MAX_EXAM_SUBJECT        64  //���Կ�Ŀ��󳤶�
#define NET_SDK_MAX_TEACHER_NO          64  //�࿼��ʦ�����󳤶�
#define NET_SDK_MAX_TEACHER_NAME        64  //�࿼��ʦ������󳤶�
#define NET_SDK_MAX_EXAMINEE_NO         64  //���������󳤶�
#define NET_SDK_MAX_ADMISSION_TICKET    64  //׼��֤����󳤶�

typedef struct tagNET_DVR_EXAM_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamNumber; //������Ϣ��Ŀ
    BYTE  byRes[128];
}NET_DVR_EXAM_INFO_COND, *LPNET_DVR_EXAM_INFO_COND;

typedef struct tagNET_DVR_EXAM_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //���Ա�ţ�ĳ�ο��ԣ������ೡ���ԣ�
    BYTE  byExamSubject[NET_SDK_MAX_EXAM_SUBJECT/*64*/]; //���Կ�Ŀ
    BYTE  byTeacherNo[NET_SDK_MAX_TEACHER_NO/*64*/]; //�࿼��ʦ���
    BYTE  byTeacherName[NET_SDK_MAX_TEACHER_NAME/*64*/]; //�࿼��ʦ����
    NET_DVR_TIME    struStartTime; //���Կ�ʼʱ��
    NET_DVR_TIME    struEndTime; //���Խ���ʱ��
    BYTE  byExamInfoValid; //������Ϣ�Ƿ���Ч��0-��Ч��1-��Ч�����ڿ��Գ��α��ɾ��������Ϣ�����ֶ�Ϊ0ʱ����ɾ����
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_CFG, *LPNET_DVR_EXAM_INFO_CFG;

typedef struct tagNET_DVR_EXAM_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byStatus;  //�·�״̬��0-��Ч��1-ʧ�ܣ�2-�ɹ�������ÿ��Գ����·��Ƿ�ɹ���
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_STATUS, *LPNET_DVR_EXAM_INFO_STATUS;

typedef struct tagNET_DVR_EXAMINEE_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamineeNumber; //������Ϣ��Ŀ
    BYTE  byRes[128];
}NET_DVR_EXAMINEE_INFO_COND, *LPNET_DVR_EXAMINEE_INFO_COND;

typedef struct tagNET_DVR_EXAMINEE_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //�������
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //׼��֤��
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byName[NAME_LEN/*32*/]; //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ���
    BYTE  bySex; //�Ա�0-��Ч��1-�У�2-Ů
    BYTE  byExamineeInfoValid; //������Ϣ�Ƿ���Ч��0-��Ч��1-��Ч�����ڿ�����źͿ��Գ��α��ɾ��������Ϣ�����ֶ�Ϊ0ʱ����ɾ����
    BYTE  byRes[126];
}NET_DVR_EXAMINEE_INFO_CFG, *LPNET_DVR_EXAMINEE_INFO_CFG;

typedef struct tagNET_DVR_EXAMINEE_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //�������
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byStatus;  //�·�״̬��0-��Ч��1-ʧ�ܣ�2-�ɹ�������ÿ�����Ϣ�·��Ƿ�ɹ���
    BYTE  byRes[127];
}NET_DVR_EXAMINEE_INFO_STATUS, *LPNET_DVR_EXAMINEE_INFO_STATUS;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_COND
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //���Ա�ţ�ĳ�ο��ԣ������ೡ���ԣ�
    NET_DVR_TIME    struStartTime; //��ʼʱ��
    NET_DVR_TIME    struEndTime; //����ʱ��
    BYTE  byRes[512];
}NET_DVR_EXAM_COMPARE_RESULT_COND, *LPNET_DVR_EXAM_COMPARE_RESULT_COND;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_CFG
{
    DWORD dwSize;
    NET_DVR_TIME    struTime; //ʱ��
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //�������
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //׼��֤��
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //���Ա�ţ�ĳ�ο��ԣ������ೡ���ԣ�
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //���Գ��α�ţ�ĳ�þ��忼�ԣ�
    BYTE  byName[NAME_LEN/*32*/]; //����
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ���
    DWORD dwPicDataLen; //�ȶ�ץ��ͼƬ���ݴ�С����Ϊ0�Ǳ�ʾ���������
    char  *pPicData; //�ȶ�ץ��ͼƬָ��
    BYTE  byRes[256];
}NET_DVR_EXAM_COMPARE_RESULT_CFG, *LPNET_DVR_EXAM_COMPARE_RESULT_CFG;

typedef struct tagNET_DVR_BLACK_LIST_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //ͼƬ����
    BYTE  byRes[128];
}NET_DVR_BLACK_LIST_PICTURE_COND, *LPNET_DVR_BLACK_LIST_PICTURE_COND;

typedef struct tagNET_DVR_BLACK_LIST_PICTURE_STATUS
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //����
    BYTE  byStatus; //״̬��0-��Ч����1-�����У�2-�ϴ�ʧ�ܣ�3-�ɹ�
    BYTE  byRes[63];
}NET_DVR_BLACK_LIST_PICTURE_STATUS, *LPNET_DVR_BLACK_LIST_PICTURE_STATUS;

typedef struct tagNET_DVR_BLACK_LIST_PICTURE_CFG
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //����
    BYTE  byName[NAME_LEN/*32*/]; //����
    BYTE  bySex; //�Ա�0-��Ч��1-�У�2-Ů
    BYTE  byPictureValid; //������ͼƬ�Ƿ���Ч��0-��Ч��1-��Ч�����ڰ�����ɾ��������ͼƬ�����ֶ�Ϊ0ʱ����ɾ����ɾ��ʱ�����ݺ�����ͼƬ��
    BYTE  byRes1[2];
    DWORD dwPictureLen; //������ͼƬ���ȣ�ͼƬ��С������1M��
    char*  pPictureBuffer; //������ͼƬָ��
    BYTE  byRes[128];
}NET_DVR_BLACK_LIST_PICTURE_CFG, *LPNET_DVR_BLACK_LIST_PICTURE_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLACK_LIST_COND
{
    DWORD       dwSize;
    DWORD       dwBlackListNum; //����������
    BYTE  byRes[128];
}NET_DVR_UPLOAD_ID_BLACK_LIST_COND, *LPNET_DVR_UPLOAD_ID_BLACK_LIST_COND;

typedef struct tagNET_DVR_UPLOAD_ID_BLACK_LIST_CFG
{
    DWORD       dwSize;
    NET_DVR_ID_CARD_INFO  struIDCardCfg;//���֤��Ϣ���ýṹ�������������֤����Ϊ����������ֶ�Ϊѡ���
    BYTE  byBlackListValid; //���֤�������Ƿ���Ч��0-��Ч��1-��Ч�����ڰ����֤����ɾ�����֤�����������ֶ�Ϊ0ʱ����ɾ����
    BYTE  byRes[127];
}NET_DVR_UPLOAD_ID_BLACK_LIST_CFG, *LPNET_DVR_UPLOAD_ID_BLACK_LIST_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLACK_LIST_STATUS
{
    DWORD       dwSize;
    BYTE  byIDNum[MAX_ID_NUM_LEN];   //���֤����
    BYTE  byStatus; //״̬��0-��Ч��1-�����У�2-�ϴ�ʧ�ܣ�3-�ɹ�
    BYTE  byRes[63];
}NET_DVR_UPLOAD_ID_BLACK_LIST_STATUS, *LPNET_DVR_UPLOAD_ID_BLACK_LIST_STATUS;

typedef struct tagNET_DVR_ALARM_ISAPI_INFO
{
    char * pAlarmData;           // ��������
    DWORD dwAlarmDataLen;   // �������ݳ���
    BYTE byDataType;        // 0-invalid,1-xml,2-json
    BYTE byPicturesNumber;  // ͼƬ����
    BYTE byRes[2];
    void * pPicPackData;         // ͼƬ�䳤����
    BYTE byRes1[32];
}NET_DVR_ALARM_ISAPI_INFO, *LPNET_DVR_ALARM_ISAPI_INFO;

typedef struct tagNET_DVR_ALARM_ISAPI_PICDATA
{
    DWORD dwPicLen;
    BYTE byPicType;  //ͼƬ��ʽ: 1- jpg
    BYTE byRes[3];
    char szFilename[MAX_FILE_PATH_LEN];
    BYTE *pPicData;
}NET_DVR_ALARM_ISAPI_PICDATA, *LPNET_DVR_ALARM_ISAPI_PICDATA;

typedef struct tagNET_DVR_FORMAT_HDD
{
    DWORD dwSize;//�ṹ�峤��
    DWORD dwDiskNo;//Ӳ�̺ţ���0��ʼ��0xff��ʾ������Ӳ����Ч��������ֻ��Ӳ�̣�
    NET_DVR_IPADDR struLocateIP;//��Ӳ�������豸��IP����ӦӲ�̹������V50�л�ȡ����szHDLocateIP��Ϣ��
    BYTE byRes[16];
}NET_DVR_FORMAT_HDD, *LPNET_DVR_FORMAT_HDD;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //ͼƬ����
    BYTE  byCheckTemplate; //0-У��ͼƬ�Ƿ�Ϸ���Ĭ�ϣ���1-У��ͼƬ�ͽ�ģ�����Ƿ�ƥ��
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_COND, *LPNET_DVR_CHECK_FACE_PICTURE_COND;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_CFG
{
    DWORD       dwSize;
    DWORD dwPictureNo; //ͼƬ���
    DWORD dwPictureLen; //ͼƬ���ȣ�ͼƬ��С������200k��
    char*  pPictureBuffer; //ͼƬָ��
    DWORD dwFaceTemplateLen;  //������ģ���ݳ���
    char*  pFaceTemplateBuffer;   //������ģ����ָ��
    BYTE  byRes[248];
}NET_DVR_CHECK_FACE_PICTURE_CFG, *LPNET_DVR_CHECK_FACE_PICTURE_CFG;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_STATUS
{
    DWORD       dwSize;
    DWORD dwPictureNo; //ͼƬ���
    BYTE  byCheckStatus; //У������0-��Ч��1-��ģ�ɹ���2-��ģʧ�ܣ�3-����ģ��ͨѶ�쳣��4-ͼ����������5-�������ϣ�6-�������£�7-����ƫ��8-����ƫ�ң�9-����˳ʱ��ת��
    //10 - ������ʱ��ת��11-���ۼ��С��12-������ģ��ƥ�䣬13-������ģ�岻ƥ��,14-������������
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_STATUS, *LPNET_DVR_CHECK_FACE_PICTURE_STATUS;

typedef struct tagNET_SDK_NPQ_STATE_SINGLE
{
    DWORD  dwRttUs;			//rtt����λus
    DWORD  dwRealRttUs;		//ʵʱrtt����λus
    DWORD  dwBitRate;        //���ʣ���λbps
    BYTE   byLossFraction;	//�����ʣ���λ1/256
    BYTE   byLossFraction2;	//�����ָ�֮��Ķ����ʣ�ֻ���ڽ��ն˻�ȡ����λ1/256
    BYTE   byRes[126];
}NET_SDK_NPQ_STATE_SINGLE, *LPNET_SDK_NPQ_STATE_SINGLE;


typedef struct tagNET_SDK_NPQ_STATE
{
    DWORD                       dwSize;
    NET_SDK_NPQ_STATE_SINGLE    struAudioState;  //��Ƶ����״̬
    NET_SDK_NPQ_STATE_SINGLE    struVideoState;  //��Ƶ����״̬
    BYTE                        byRes[256];
}NET_SDK_NPQ_STATE, *LPNET_SDK_NPQ_STATE;

typedef struct tagNET_SDK_NPQ_NOTIFY_PARAM
{
    LONG   iVersion;				//�ṹ��汾�������Ժ����
    DWORD dwBitRate;		//���� ��λbps
    BOOL   bHaveBitrate;			//�����ֶ��Ƿ���Ч��־
    BOOL   bHaveForceIframe;		//ǿ��I֡�ֶ��Ƿ���Ч��־
    BOOL   bForceIframe;			//ǿ��I֡
    BOOL   bHaveScale;			    //scale�ֶ��Ƿ���Ч��־,�ط�ʱ���ֶ���Ч,��ͨ��SDK��Žӿ�ʵ��
    float  fScale;				    //scale��Ϣ  1��2��4��8,�ط�ʱ���ֶ���Ч,��ͨ��SDK��Žӿ�ʵ��
    BYTE   res[240];
}NET_SDK_NPQ_NOTIFY_PARAM, *LPNET_SDK_NPQ_NOTIFY_PARAM;

//������Ϣ��ѯ�����ṹ��
typedef	struct tagNET_DVR_ALARM_SEARCH_COND
{
    DWORD                       dwSize;
    NET_DVR_TIME_SEARCH_COND    strStartTime; //��ʼʱ��,ʱ��Ϊ�������ͨ��ʱ��ɸѡ��
    NET_DVR_TIME_SEARCH_COND    strStopTime;  //����ʱ��, ʱ��Ϊ�������ͨ��ʱ��ɸѡ��
    /*
    ����������ֶ�ֵ�뱨������������ͬ��Ŀǰ֧�֣�
    COMM_VCA_ALARM 	0x4993  ���ܼ�ⱨ��
    COMM_UPLOAD_FACESNAP_RESULT    0x1112  ����ʶ�����ϴ�
    COMM_SNAP_MATCH_ALAR    0x2902  �����ȶԽ���ϴ�
    */
    DWORD                      dwAlarmComm;   //��������Ϊ����������б���������ˡ�
    char                       sAlarmUID[64];   //UID��ʶ���ϴ�����ʱ�豸���ص�UID��ʶ��64�ֽڵĳ��ȣ�����ʹ��ʱ�䣨��ȷ�����룩�����漴���ķ�ʽ��ɣ�,Ϊ�����������UID
    WORD                       wEventType;//�¼����ͣ���dwAlarmCommΪCOMM_VCA_ALARM 	0x4993  ���ܼ�ⱨ����Ч��0-��ʾ�����¼�,1-���Ŀ���⣨mixedTargetDetection��,2-����Ŀ���⣨radarVideoDetection��
    WORD                       wSubEventType;//���¼����ͣ�0-��ʾ�������¼�������ֵ����wEventType��ȡֵ�仯���仯������μ���������
    BYTE                       bySupport; //����
    BYTE                       byRes[123];
}NET_DVR_ALARM_SEARCH_COND, *LPNET_DVR_ALARM_SEARCH_COND;
//������Ϣ��ѯ����ṹ��
typedef	struct tagNET_DVR_ALARM_SEARCH_RESULT
{
    DWORD                   dwSize;
    /*
    ����������ֶ�ֵ�뱨������������ͬ��Ŀǰ֧�֣�
    COMM_VCA_ALARM 	0x4993    ���ܼ�ⱨ��
    COMM_UPLOAD_FACESNAP_RESULT    0x1112  ����ʶ�����ϴ�
    COMM_SNAP_MATCH_ALARM   0x2902 �����ȶԽ���ϴ�
    */
    DWORD                   dwAlarmComm;
    /*
    ������Ϣ�����ֶ�ֵ�뱨����Ϣ��ͬ��Ŀǰ֧�֣�
    ��COMM_VCA_ALARMʱ���ñ�����ϢΪJSON����
    ��COMM_UPLOAD_FACESNAP_RESULTʱ���ñ�����ϢΪNET_VCA_FACESNAP_RESULT
    ��COMM_SNAP_MATCH_ALARMʱ���ñ�����ϢΪNET_VCA_FACESNAP_MATCH_ALARM
    */
    DWORD                   dwAlarmLen;//������Ϣ����pAlarmInfoָ��ָ������ݳ���
    char                    *pAlarmInfo;
    NET_DVR_ALARMER         struAlarmer;
    BYTE                    byRes[128];
}NET_DVR_ALARM_SEARCH_RESULT, *LPNET_DVR_ALARM_SEARCH_RESULT;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ��ţ�����ʱ�ò��������ã�
    DWORD dwFaceNum; //���û��ȡ������������ȡʱ��Ϊ0xffffffff��ʾ��ȡ����������Ϣ
    BYTE  byRes[128];          //����
}NET_DVR_FACE_AND_TEMPLATE_COND, *LPNET_DVR_FACE_AND_TEMPLATE_COND;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ��� 
    DWORD dwFaceLen;  //����ͼƬ���ȣ�ͼƬ��С������200k��
    char*  pFaceBuffer;   //����ͼƬָ��
    DWORD dwFaceTemplateLen;  //������ģ���ݳ���
    char*  pFaceTemplateBuffer;   //������ģ����ָ��
    BYTE  byRes[116];
}NET_DVR_FACE_AND_TEMPLATE_CFG, *LPNET_DVR_FACE_AND_TEMPLATE_CFG;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ���
    BYTE  byRecvStatus;//�����·�״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-�ڴ�������������������
    BYTE  byRes[131];
}NET_DVR_FACE_AND_TEMPLATE_STATUS, *LPNET_DVR_FACE_AND_TEMPLATE_STATUS;

typedef struct tagNET_DVR_SINGLE_HEATMAP_RESULT_PDC
{
    DWORD  dwMaxHeatMapValue;//����ȶ�ֵ
    DWORD  dwMinHeatMapValue;//��С�ȶ�ֵ
    DWORD  dwTimeHeatMapValue;// (ʱ���ȶ�ֵ)ƽ���ȶ�ֵ
    WORD   wArrayLine;//ͼƬ���ص���ֵ 
    WORD   wArrayColumn;//ͼƬ���ص���ֵ ��������ֵΪ0��ʱ�����ص�ֵ�ڴ���Ϣ�����ڣ�
    BYTE*  pBuffer;  //�ȶ�ͼƬ���ص�������Ϣ
    BYTE   byRes[32];
}NET_DVR_SINGLE_HEATMAP_RESULT_PDC, *LPNET_DVR_SINGLE_HEATMAP_RESULT_PDC;

//�ȶ�ͼ�����ϴ�
typedef struct tagNET_DVR_HEATMAP_RESULT_PDC
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*��ʼʱ��*/
    NET_DVR_TIME_EX   struEndTime;/*����ʱ��*/
    NET_VCA_DEV_INFO  struDevInfo;/*�豸��Ϣ*/
    WORD   wDevInfoIvmsChannelEx;     //��NET_VCA_DEV_INFO���byIvmsChannel������ͬ���ܱ�ʾ�����ֵ���Ͽͻ�����byIvmsChannel�ܼ������ݣ��������255���¿ͻ��˰汾��ʹ��wDevInfoIvmsChannelEx��
    BYTE   byBrokenNetHttp;     //����������־λ��0-�����ش����ݣ�1-�ش�����
    BYTE   byArrayUnitType;//����Ԫ�������ͣ�������Ϣ��ÿ�����ص����ݵ��������ͣ�,1-byte, 2-short,4- int
    /*
    struSingleHeatMap[0]:��ʾ������ͳ���еĻ�����ͣ���������ȶ�ֵ��
    struSingleHeatMap[1]:��ʾ������ͳ���еĻ������뿪�������ȶ�ֵ��
    */
    NET_DVR_SINGLE_HEATMAP_RESULT_PDC struSingleHeatMap[2];
    WORD   wCurNumber;//��ǰ����
    WORD   wLeaveNumber;//�뿪����
    BYTE   byRes1[60];
}NET_DVR_HEATMAP_RESULT_PDC, *LPNET_DVR_HEATMAP_RESULT_PDC;

//�豸֧��AI����ƽ̨���룬�ϴ���Ƶ�������
typedef struct _NET_AIOP_VIDEO_HEAD_
{
    DWORD dwSize;      //dwSize = sizeof(NET_AIOP_VIDEO_HEAD)
    DWORD dwChannel;    //�豸����ͨ����ͨ���ţ�
    NET_DVR_SYSTEM_TIME     struTime; 	//ʱ��
    char  szTaskID[64];     //��Ƶ����ID����������Ƶ�����ɷ�
    DWORD dwAIOPDataSize;   //��ӦAIOPDdata���ݳ���
    DWORD dwPictureSize;    //��Ӧ����ͼƬ����
    char  szMPID[64];        //���ģ�Ͱ�ID������ƥ��AIOP�ļ�����ݽ���������ͨ��URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)��ȡ��ǰ�豸���ص�ģ�Ͱ���label description��Ϣ��
    BYTE  *pBufferAIOPData;  //AIOPDdata����
    BYTE  *pBufferPicture;//��Ӧ����ͼƬ����
    BYTE  byPictureMode;//ͼƬ���ݴ���ģʽ 0-�����ƣ�1-�人���ƴ洢����byPictureModeΪ0ʱpBufferPictureΪ���������ݣ���byPictureModeΪ1ʱpBufferPictureΪ�人��URL
    BYTE  byRes2[3];//�����ֽ�
    DWORD dwPresetIndex; //Ԥ�õ����
    BYTE  byRes[176];
}NET_AIOP_VIDEO_HEAD, *LPNET_AIOP_VIDEO_HEAD;

//�豸֧��AI����ƽ̨���룬�ϴ�ͼƬ�������
typedef struct _NET_AIOP_PICTURE_HEAD_
{
    DWORD dwSize;           //dwSize = sizeof(NET_AIOP_PICTURE_HEAD)
    NET_DVR_SYSTEM_TIME    struTime; 	//ʱ��
    char  szPID[64];        //͸���·���ͼƬID��������ͼƬ�����ɷ�
    DWORD dwAIOPDataSize;   //��ӦAIOPDdata���ݳ���
    BYTE  byStatus;         //״ֵ̬��0-�ɹ���1-ͼƬ��С����
    BYTE byRes1[3];
    char szMPID[64]; //���ģ�Ͱ�ID������ƥ��AIOP�ļ�����ݽ�����
    BYTE *pBufferAIOPData;//AIOPDdata����
    DWORD dwPresetIndex; //Ԥ�õ����
    BYTE byRes[180];
}NET_AIOP_PICTURE_HEAD, *LPNET_AIOP_PICTURE_HEAD;

#define MAX_FILE_NAME_LEN		100     //����ļ�����
typedef struct tagNET_DVR_DOOR_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;     //�ļ���С����λ���ֽ�
    BYTE  byFileName[MAX_FILE_NAME_LEN]; //�ļ�����
    BYTE  byRes1[256];
}NET_DVR_DOOR_FILE_UPLOAD_PARAM, *LPNET_DVR_DOOR_FILE_UPLOAD_PARAM;

#define AUDIO_FILE_NAME_LEN  32  //��Ƶ�ļ����Ƴ���
//�ϴ���Ƶ�����ļ�
typedef struct tagNET_DVR_TRANS_AUDIO_INFO
{
    DWORD  dwSize;                        //�ṹ���С
    char   sAudioName[AUDIO_FILE_NAME_LEN];  //��Ƶ�ļ�����
    BYTE   byAudioFormat;	               //��Ƶ���ݸ�ʽ��0-wav
    BYTE   byRes[127];
}NET_DVR_TRANS_AUDIO_INFO,*LPNET_DVR_TRANS_AUDIO_INFO;

typedef struct _NET_AIOP_POLLING_VIDEO_HEAD_
{
    DWORD dwSize;			//dwSize = sizeof(NET_AIOP_POLLING_VIDEO_HEAD)		
    DWORD dwChannel;      //�豸����ͨ����ͨ����(��SDKЭ��)��
    NET_DVR_SYSTEM_TIME     struTime; 	//ʱ��
    char  szTaskID[64];    //��ѯץͼ����ID����������ѯץͼ�����ɷ�
    DWORD dwAIOPDataSize;	//��ӦAIOPDdata���ݳ���
    DWORD dwPictureSize;	//��Ӧ����ͼƬ����
    char  szMPID[64]; //���ģ�Ͱ�ID������ƥ��AIOP�ļ�����ݽ�����
    BYTE  *pBufferAIOPData;//AIOPDdata����
    BYTE  *pBufferPicture;//��Ӧ����ͼƬ����
    BYTE  byPictureMode;//ͼƬ���ݴ���ģʽ 0-�����ƣ�1-�人���ƴ洢����byPictureModeΪ0ʱpBufferPictureΪ���������ݣ���byPictureModeΪ1ʱpBufferPictureΪ�人��URL
    BYTE  byRes2[3];//�����ֽ�
    DWORD dwPresetIndex; //Ԥ�õ����
    BYTE  byRes[176];
} NET_AIOP_POLLING_VIDEO_HEAD, *LPNET_AIOP_POLLING_VIDEO_HEAD;

typedef struct _NET_AIOP_POLLING_SNAP_HEAD_
{
    DWORD dwSize;			//dwSize = sizeof(NET_AIOP_POLLING_SNAP_HEAD)		
    DWORD dwChannel;      //�豸����ͨ����ͨ����(��SDKЭ��)��
    NET_DVR_SYSTEM_TIME     struTime; 	//ʱ��
    char  szTaskID[64];    //��ѯץͼ����ID����������ѯץͼ�����ɷ�
    DWORD dwAIOPDataSize;	//��ӦAIOPDdata���ݳ���
    DWORD dwPictureSize;	//��Ӧ����ͼƬ����
    char  szMPID[64];       //���ģ�Ͱ�ID������ƥ��AIOP�ļ�����ݽ�����
    BYTE  *pBufferAIOPData;//AIOPDdata����
    BYTE  *pBufferPicture;//����ͼƬ����
    BYTE  byPictureMode;//ͼƬ���ݴ���ģʽ 0-�����ƣ�1-�人���ƴ洢����byPictureModeΪ0ʱpBufferPictureΪ���������ݣ���byPictureModeΪ1ʱpBufferPictureΪ�人��URL
    BYTE  byRes2[3];//�����ֽ�
    DWORD dwPresetIndex; //Ԥ�õ����
    BYTE  byRes[176];
} NET_AIOP_POLLING_SNAP_HEAD, *LPNET_AIOP_POLLING_SNAP_HEAD;

typedef struct tagNET_DVR_AI_ALGORITHM_MODEL
{
    DWORD dwSize;
    DWORD dwDescribeLength;  //{AlgorithmModel} �ļ�����
    char* pDescribeBuffer; //{AlgorithmModel}�ļ�
    BYTE byRes1[3];//�����ֽڣ�ʹ���ֽڶ���
    DWORD dwLicenseKeyLength; //licenseKey�ļ�����
    char* pLicenseKeyBuffer;  //licenseKey�ļ�
    BYTE byRes[120];
}NET_DVR_AI_ALGORITHM_MODEL, *LPNET_DVR_AI_ALGORITHM_MODEL;

typedef struct tagNET_DVR_AI_PICTUR_UPLOAD
{
    DWORD       dwSize;
    char         szTaskID[64];   //����id��strlen.max = 64,ҵ��ƽ̨ͳһά������
    char         szPID[64];   //ͼƬid��strlen.max = 64��ҵ��ƽ̨ͳһά������
    BYTE        byRes[128];
}NET_DVR_AI_PICTUR_UPLOAD, *LPNET_DVR_AI_PICTUR_UPLOAD;


typedef struct _NET_DVR_CARD_RECORD
{
    DWORD                      dwSize;
    BYTE                        byCardNo[ACS_CARD_NO_LEN];
    BYTE                        byCardType;
    BYTE                        byLeaderCard;
    BYTE                        byUserType;
    BYTE                        byRes1;
    BYTE                        byDoorRight[MAX_DOOR_NUM_256];
    NET_DVR_VALID_PERIOD_CFG    struValid;
    BYTE                        byBelongGroup[MAX_GROUP_NUM_128];
    BYTE                        byCardPassword[CARD_PASSWORD_LEN];
    WORD                        wCardRightPlan[MAX_DOOR_NUM_256];
    DWORD                       dwMaxSwipeTimes;
    DWORD                       dwSwipeTimes;
    DWORD                       dwEmployeeNo;
    BYTE                        byName[NAME_LEN];
    //��λ��ʾ��0-��Ȩ�ޣ�1-��Ȩ��
    //��0λ��ʾ�����籨��
    //��1λ��ʾ��������ʾ��
    //��2λ��ʾ�����ƿͿ�
    //��3λ��ʾ��ͨ��
    //��4λ��ʾ����������
    //��5λ��ʾ��Ѳ������
    DWORD                      dwCardRight;
    BYTE                       byRes[256];
}NET_DVR_CARD_RECORD, *LPNET_DVR_CARD_RECORD;

typedef struct _NET_DVR_CARD_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //���û��ȡ����������ȡʱ��Ϊ0xffffffff��ʾ��ȡ���п���Ϣ
    BYTE  byRes[64];
}NET_DVR_CARD_COND, *LPNET_DVR_CARD_COND;

typedef struct _NET_DVR_CARD_SEND_DATA
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //����
    BYTE  byRes[16];
}NET_DVR_CARD_SEND_DATA, *LPNET_DVR_CARD_SEND_DATA;

typedef struct _NET_DVR_CARD_STATUS
{
    DWORD   dwSize;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwErrorCode;
    BYTE    byStatus; // ״̬��0-ʧ�ܣ�1-�ɹ�
    BYTE    byRes[23];
}NET_DVR_CARD_STATUS, *LPNET_DVR_CARD_STATUS;

typedef struct  _NET_DVR_FACE_RECORD
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //���������Ŀ��� 
    DWORD dwFaceLen;    //�������ݳ���
    BYTE* pFaceBuffer;  //��������ָ��
    BYTE  byRes[128];
}NET_DVR_FACE_RECORD, *LPNET_DVR_FACE_RECORD;

typedef struct _NET_DVR_FACE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //���������Ŀ���
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ4ʱ����ʾ�Ѵ���������Ӧ�Ŀ���
    DWORD  dwReaderNo;  //������������ţ��������·����󷵻�
    BYTE  byRecvStatus;  //����������״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-���Ի����������3-�ڴ�����(����������)��4-�Ѵ��ڸ�������5-�Ƿ�����ID
    //,6-�㷨��ģʧ�ܣ�7-δ�·���Ȩ�ޣ�8-δ���壨��������9-���ۼ��С��С��10-ͼƬ���ݳ���С��1KB��11-ͼƬ��ʽ������png/jpg/bmp��,12-ͼƬ���������������ޣ�13-ͼƬ���������������ޣ�14-ͼƬ��ϢУ��ʧ�ܣ�15-ͼƬ����ʧ�ܣ�16-�������ʧ�ܣ�17-��������ʧ��
    BYTE  byRes[131];
}NET_DVR_FACE_STATUS, *LPNET_DVR_FACE_STATUS;

typedef struct _NET_DVR_FACE_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //���������Ŀ��ţ�����ʱ�ò����ɲ����ã�
    DWORD dwFaceNum;    // ���û��ȡ������������ȡʱ��Ϊ0xffffffff��ʾ��ȡ����������Ϣ
    DWORD dwEnableReaderNo;   // �������������
    BYTE  byRes[124];   // ����
}NET_DVR_FACE_COND, *LPNET_DVR_FACE_COND;

typedef struct _NET_DVR_FINGERPRINT_RECORD
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ��� 
    DWORD dwFingerPrintLen;     //ָ�����ݳ���
    DWORD  dwEnableReaderNo;     //��Ҫ�·�ָ�ƵĶ��������
    BYTE  byFingerPrintID;      //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;         //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //ָ����������
    BYTE  byRes[96];
}NET_DVR_FINGERPRINT_RECORD, *LPNET_DVR_FINGERPRINT_RECORD;

typedef struct _NET_DVR_FINGERPRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //ָ�ƹ����Ŀ���
    BYTE  byCardReaderRecvStatus;  //ָ�ƶ�����״̬�����ֽڱ�ʾ��0-ʧ�ܣ�1-�ɹ���2-��ָ��ģ�鲻���ߣ�3-���Ի�ָ�������4-�ڴ�������5-�Ѵ��ڸ�ָ�ƣ�6-�Ѵ��ڸ�ָ��ID��7-�Ƿ�ָ��ID��8-��ָ��ģ����������
    BYTE  byFingerPrintID;     //��ָ��ţ���Чֵ��ΧΪ1-10
    BYTE  byFingerType;       //ָ������  0-��ָͨ�ƣ�1-в��ָ��
    BYTE  byRecvStatus;    //��������״̬��0-�ɹ���1-��ָ��Ŵ���2-ָ�����ʹ���3-���Ŵ��󣨿��Ź�񲻷����豸Ҫ�󣩣�4-ָ��δ�������Ż򿨺ţ����Ż򿨺��ֶ�Ϊ�գ���5-���Ų����ڣ�6-ָ�����ݳ���Ϊ0��7-��������Ŵ���8-���Ŵ���
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //�·�������Ϣ����byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ�Ŀ���
    DWORD dwCardReaderNo;   //��byCardReaderRecvStatusΪ5ʱ����ʾ�Ѵ���ָ�ƶ�Ӧ��ָ�ƶ�������ţ��������·����󷵻ء�0ʱ��ʾ�޴�����Ϣ
    BYTE  byRes[20];
}NET_DVR_FINGERPRINT_STATUS, *LPNET_DVR_FINGERPRINT_STATUS;

typedef struct tagNET_DVR_FINGERPRINT_COND
{
    DWORD   dwSize;
    DWORD   dwFingerprintNum;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwEnableReaderNo;
    BYTE    byFingerPrintID;
    BYTE    byRes[131];
}NET_DVR_FINGERPRINT_COND, *LPNET_DVR_FINGERPRINT_COND;

typedef struct tagNET_DVR_CAPTURE_DATA_COND
{
    DWORD  dwSize;
    char   szPassword[128];   //��Կ���ַ���
    BYTE   byRes[128];
}NET_DVR_CAPTURE_DATA_COND, *LPNET_DVR_CAPTURE_DATA_COND;

#define EZVIZ_CLASSSESSION_LEN  64
#define EZVIZ_DEVICEID_LEN      32
typedef struct  tagNET_DVR_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN]; //�Ʒ�������ַ 
    WORD wPort;       //�Ʒ������˿�
    BYTE byLogin;
    BYTE byRes1[1];
    char sClassSession[EZVIZ_CLASSSESSION_LEN];  //ClassSession, �����������һ���ַ�����ÿ��ͨ��ʱ��Ҫ���͸�������
    char sDeviceID[EZVIZ_DEVICEID_LEN];          //�豸ID�� �ɷ����������     
    BYTE byRes2[128];
}NET_DVR_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_EZVIZ_USER_LOGIN_INFO;

#define EZVIZ_REQURL_LEN        64
#define EZVIZ_ACCESSTOKEN_LEN   128
#define EZVIZ_CLIENTTYPE_LEN    32
#define EZVIZ_FEATURECODE_LEN   64
#define EZVIZ_OSVERSION_LEN     32
#define EZVIZ_NETTYPE_LEN       32
#define EZVIZ_SDKVERSION_LEN    32
#define EZVIZ_APPID_LEN         64
typedef struct  tagNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN]; //�Ʒ�������ַ
    BYTE byRes1[3];
    WORD wPort;       //�Ʒ������˿�
    BYTE byRes2[2];
    char sUrl[EZVIZ_REQURL_LEN];
    char sAccessToken[EZVIZ_ACCESSTOKEN_LEN];    //accessToken, �����������һ���ַ�����ÿ��ͨ��ʱ��Ҫ���͸�������
    char sDeviceID[EZVIZ_DEVICEID_LEN];            //�豸ID�� �ɷ����������
    char sClientType[EZVIZ_CLIENTTYPE_LEN];        //�ͻ�������: 0: PC-�ؼ� 1: ios 2: android
    char sFeatureCode[EZVIZ_FEATURECODE_LEN];    //Ӳ��������
    char sOsVersion[EZVIZ_OSVERSION_LEN];        //�ն�ϵͳ�汾, ����: IOS 7.0.4, Android 2.3.
    char sNetType[EZVIZ_NETTYPE_LEN];            //��������, UNKNOWN GPRS EDGE UMTS HSDPA HSUPA HSPA CDMAEVDO_0 EVDO_A EVDO_B 1xRTT IDEN WIFI
    char sSdkVersion[EZVIZ_SDKVERSION_LEN];        //Sdk�汾��, v.1.0.20140720.45xx
    char sAppID[EZVIZ_APPID_LEN];                //AppID��ios�ϱ�BundleID��Android�ϱ�����
    BYTE byRes3[512];
}NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO;

enum ADDITIONAL_LIB 
{
    PLAYCTRL = 0,  
    DSSDK,        
    STREAMCONVERT,  
    STREAMTRANS,   
    QOSSDK,     
    DLL_PATH_AUDIO,  
    EZVIZ_SSL_SDK, 
    ANALYZE_DATA_LIB,
    DLL_LIBICONV,   
    SSLEAY32_SDK, 
    LIBEAY32_SDK,
    HCNETUTILS_SDK, 
    NPQ_LIB,  
    LOAD_DLL_COUNT,  
};

#if ((defined __linux__) || (defined _WIN64))
typedef struct _NET_DVR_AUDIOENCInfo                     /* ��Ϣ */
{
    DWORD            in_frame_size;                /* ����һ֡���ݴ�С(BYTES)����GetInfoParam��������         */
    int            reserved[16];                 /* ���� */
} NET_DVR_AUDIOENC_INFO;
/* ����ģʽ */
typedef enum _ENUM_AUDIO_ENC_MODE
{
    AMR_MR475_ = 0,        /* 4.75 kb/s */
    AMR_MR515_,          /* 5.15 kb/s */
    AMR_MR59_,            /* 5.90 kb/s */
    AMR_MR67_,            /* 6.70 kb/s */
    AMR_MR74_,            /* 7.40 kb/s */
    AMR_MR795_,            /* 7.95 kb/s */
    AMR_MR102_,            /* 10.2 kb/s */
    AMR_MR122_,          /* 12.2 kb/s */

    AMR_MRDTX_,            /* ����֡    */
    AMR_N_MODES_
}ENUM_AUDIO_ENC_MODE;
// ��Ƶ����
typedef struct _NET_DVR_AUDIOENC_PROCESS_PARAM_
{
    unsigned char		*in_buf;                      /* ����buf */
    unsigned char		*out_buf;                     /* ���buf */
    DWORD			out_frame_size;               /* ����һ֡���BYTE�� */

    int				g726enc_reset;                /* ���ÿ��� */
    int				g711_type;                    /* g711��������,0 - U law, 1- A law */
    ENUM_AUDIO_ENC_MODE	enc_mode;                     /* ��Ƶ����ģʽ��AMR�������� */
    int				reserved[16];                 /* ���� */
}NET_DVR_AUDIOENC_PROCESS_PARAM;

typedef struct _NET_DVR_AUDIODECInfo                     /* ��Ϣ */
{
    int            nchans;                         /* ������ */
    int            sample_rate;                  /* ������ */
    int            aacdec_profile;               /* �����õĿ�� */
    int            reserved[16];                 /* ���� */
} NET_DVR_AUDIODEC_INFO;


// ��Ƶ����
typedef struct _NET_DVR_AUDIODEC_PROCESS_PARAM
{
    unsigned char		*in_buf;                      /* ��������buf */
    unsigned char		*out_buf;                     /* �������buf */
    DWORD			in_data_size;                 /* ����in_buf������byte�� */
    DWORD			proc_data_size;               /* �������⴦��in_buf�����ݴ�Сbytes */
    DWORD			out_frame_size;               /* ����һ֡������BYTE�� */
    NET_DVR_AUDIODEC_INFO		dec_info;                     /* ���������Ϣ */

    int				g726dec_reset;                /* ���ÿ��� */
    int				g711_type;                    /* g711��������,0 - U law, 1- A law */
    int				reserved[16];                 /* ���� */
} NET_DVR_AUDIODEC_PROCESS_PARAM;
const unsigned int G726_EBCIN_DECOUT_SIZE = 640; // G726���������һ֡���������һ֡�Ĵ�С��������
#if (defined __x86_64__)
const unsigned int G726_ENC_OUT_SIZE = 160; // G726������һ֡���������С��������
const unsigned int G726_DEC_IN_SIZE = 200; // G726������һ֡�����볤�ȣ�������
#else // if (defined __i386__)
const unsigned int G726_ENC_OUT_SIZE = 80; // G726������һ֡���������С��������
const unsigned int G726_DEC_IN_SIZE = 80; // G726������һ֡�����볤�ȣ�������
#endif // (defined __x86_64__)
#endif // (defined __linux__)

/********************************SDK�ӿں�������*********************************/
NET_DVR_API BOOL __stdcall NET_DVR_Init();
NET_DVR_API BOOL __stdcall NET_DVR_Cleanup();

//NET_DVR_SetDVRMessage����չ
#ifdef _WIN32
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessage(UINT nMessage,HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT nMessage, HWND hWnd, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
#elif defined(__linux__) || defined(__APPLE__)
NET_DVR_API BOOL __stdcall NET_DVR_SetExceptionCallBack_V30(UINT reserved1, void* reserved2, void (CALLBACK* fExceptionCallBack)(DWORD dwType, LONG lUserID, LONG lHandle, void *pUser), void *pUser);
/*Linuxר�� */
#if defined(__linux__)
NET_DVR_API BOOL NET_DVR_DrawAreaInit(INITINFO InitInfo, DWORD iUseSDL = 1);
NET_DVR_API BOOL NET_DVR_DrawAreaRelease();
#endif
#endif

NET_DVR_API BOOL __stdcall NET_DVR_LoadAllCom();
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack(BOOL (CALLBACK *fMessCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_EX(BOOL (CALLBACK *fMessCallBack_EX)(LONG lCommand,LONG lUserID,char *pBuf,DWORD dwBufLen));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessCallBack_NEW(BOOL (CALLBACK *fMessCallBack_NEW)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, WORD dwLinkDVRPort));
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack(BOOL (CALLBACK *fMessageCallBack)(LONG lCommand,char *sDVRIP,char *pBuf,DWORD dwBufLen, DWORD dwUser), DWORD dwUser);
typedef void (CALLBACK *MSGCallBack)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V30(MSGCallBack fMessageCallBack, void* pUser);
typedef BOOL (CALLBACK *MSGCallBack_V31)(LONG lCommand, NET_DVR_ALARMER *pAlarmer, char *pAlarmInfo, DWORD dwBufLen, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V31(MSGCallBack_V31 fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V50(int iIndex, MSGCallBack fMessageCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRMessageCallBack_V51(int iIndex, MSGCallBack fMsgCallBack, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetConnectTime(DWORD dwWaitTime = 3000, DWORD dwTryTimes = 3);
NET_DVR_API BOOL __stdcall NET_DVR_SetReconnect(DWORD dwInterval = 30000, BOOL bEnableRecon = TRUE);
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKVersion();
NET_DVR_API DWORD __stdcall NET_DVR_GetSDKBuildVersion();
NET_DVR_API int __stdcall NET_DVR_IsSupport();
NET_DVR_API BOOL __stdcall NET_DVR_StartListen(char *sLocalIP,WORD wLocalPort);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen();

NET_DVR_API LONG __stdcall NET_DVR_StartListen_V30(char *sLocalIP, WORD wLocalPort, MSGCallBack DataCallback, void* pUserData = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_StopListen_V30(LONG lListenHandle);
NET_DVR_API LONG __stdcall NET_DVR_Login(char *sDVRIP,WORD wDVRPort,char *sUserName,char *sPassword,LPNET_DVR_DEVICEINFO lpDeviceInfo);
NET_DVR_API LONG __stdcall NET_DVR_Login_V30(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);

NET_DVR_API LONG __stdcall NET_DVR_Login_V40(LPNET_DVR_USER_LOGIN_INFO pLoginInfo,LPNET_DVR_DEVICEINFO_V40 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Login_Check(char *sDVRIP, WORD wDVRPort, char *sUserName, char *sPassword, LPNET_DVR_DEVICEINFO_V30 lpDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_Logout(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Logout_V30(LONG lUserID);
NET_DVR_API DWORD __stdcall NET_DVR_GetLastError();
NET_DVR_API char* __stdcall NET_DVR_GetErrorMsg(LONG *pErrorNo = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_SetShowMode(DWORD dwShowType,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRIPByResolveSvr(char *sServerIP, WORD wServerPort, BYTE *sDVRName,WORD wDVRNameLen,BYTE *sDVRSerialNumber,WORD wDVRSerialLen,char* sGetIP);
NET_DVR_API BOOL  __stdcall NET_DVR_GetDVRIPByResolveSvr_EX(char *sServerIP, WORD wServerPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP, DWORD *dwPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRNAMEByResolveSvr(char const *sServerIP, WORD wServerPort, char const *sIP, char *sDVRName);

//Ԥ����ؽӿ�
NET_DVR_API LONG __stdcall NET_DVR_PlayDirect(char *sDVRIP, char *sUserName, char *sPassword, \
                                              LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay(LONG lUserID,LPNET_DVR_CLIENTINFO lpClientInfo);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V30(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, void(CALLBACK *fRealDataCallBack_V30) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL, BOOL bBlocked = FALSE);
NET_DVR_API BOOL __stdcall NET_DVR_StopRealPlay(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayDirect(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RigisterDrawFun(LONG lRealHandle,void (CALLBACK* fDrawFun)(LONG lRealHandle,HDC hDc,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayerBufNumber(LONG lRealHandle,DWORD dwBufNum);
NET_DVR_API BOOL __stdcall NET_DVR_ThrowBFrame(LONG lRealHandle,DWORD dwNum);
NET_DVR_API BOOL __stdcall NET_DVR_SetAudioMode(DWORD dwMode);
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSoundShare(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_Volume(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData(LONG lRealHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopSaveRealData(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBack(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRealDataCallBackEx(LONG lRealHandle,void(CALLBACK *fRealDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBack(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetStandardDataCallBackEx(LONG lRealHandle,void(CALLBACK *fStdDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentDataCallBack(LONG lRealHandle, void(CALLBACK *fTpDataCallBack) (LONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture(LONG lRealHandle,char *sPicFileName);//bmp
NET_DVR_API BOOL __stdcall NET_DVR_SetCapturePictureMode(DWORD dwCaptureMode);

//��̬����I֡
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrame(LONG lUserID, LONG lChannel);//������
NET_DVR_API BOOL __stdcall NET_DVR_MakeKeyFrameSub(LONG lUserID, LONG lChannel);//������

//��̨������ؽӿ�
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_Other(LONG lUserID,LONG lChannel,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_Other(LONG lUserID,LONG lChannel,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_TransPTZ_EX(LONG lRealHandle,char *pPTZCodeBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControl_EX(LONG lRealHandle,DWORD dwPTZCommand,DWORD dwStop);
NET_DVR_API BOOL __stdcall NET_DVR_PTZPreset_EX(LONG lRealHandle,DWORD dwPTZPresetCmd,DWORD dwPresetIndex);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_Other(LONG lUserID,LONG lChannel,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZCruise_EX(LONG lRealHandle,DWORD dwPTZCruiseCmd,BYTE byCruiseRoute, BYTE byCruisePoint, WORD wInput);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_Other(LONG lUserID, LONG lChannel, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZTrack_EX(LONG lRealHandle, DWORD dwPTZTrackCmd);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_Other(LONG lUserID, LONG lChannel, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_PTZControlWithSpeed_EX(LONG lRealHandle, DWORD dwPTZCommand, DWORD dwStop, DWORD dwSpeed);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCruise(LONG lUserID,LONG lChannel,LONG lCruiseRoute, LPNET_DVR_CRUISE_RET lpCruiseRet);


//�ļ�������ط�
NET_DVR_API LONG __stdcall NET_DVR_FindFile(LONG lUserID,LONG lChannel,DWORD dwFileType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile(LONG lFindHandle,LPNET_DVR_FIND_DATA lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_Card(LONG lFindHandle, LPNET_DVR_FINDDATA_CARD lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V30(LONG lFindHandle, LPNET_DVR_FINDDATA_V30 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V40(LONG lFindHandle, LPNET_DVR_FINDDATA_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_V50(LONG lFindHandle, LPNET_DVR_FINDDATA_V50 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V30(LONG lUserID, LPNET_DVR_FILECOND pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V50(LONG lUserID, LPNET_DVR_FILECOND_V50 pFindCond);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_V30(LONG lFindHandle);

NET_DVR_API BOOL __stdcall NET_DVR_LockFileByName(LONG lUserID, char *sLockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByName(LONG lUserID, char *sUnlockFileName);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByNameV40(LONG lUserID, BOOL bLock, const NET_DVR_LOCK_FILE_BY_NAME_PARA *lpLockFilePara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName(LONG lUserID,char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByName_V50(LONG lUserID, LPNET_DVR_PLAY_BY_NAME_PARA pParam);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName_V50(LONG lUserID, LPNET_DVR_PLAY_BY_NAME_PARA pParam);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_PCNVR(LONG lUserID, NET_DVR_PLAYBCK_BYTIME_COND_PCNVR const *pPlaybackParams);

NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl(LONG lPlayHandle,DWORD dwControlCode,DWORD dwInValue,DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBack(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayBackESCallBack(LONG lPlayHandle, void (CALLBACK *fPlayESCallBack)(LONG lPlayHandle, NET_DVR_PACKET_INFO_EX *struPackInfo,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPlayDataCallBack_V40(LONG lPlayHandle,void(CALLBACK *fPlayDataCallBack_V40) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer,DWORD dwBufSize,void *pUser),void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackSaveData(LONG lPlayHandle,char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopPlayBackSave(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlayBackOsdTime(LONG lPlayHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackCaptureFile(LONG lPlayHandle,char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName(LONG lUserID,char *sDVRFileName,char *sSavedFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByName_V50(LONG lUserID, LPNET_DVR_DOWNLOAD_BY_NAME_COND pParam);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime(LONG lUserID,LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetFile(LONG lFileHandle);
NET_DVR_API int __stdcall NET_DVR_GetDownloadPos(LONG lFileHandle);
NET_DVR_API int    __stdcall NET_DVR_GetPlayBackPos(LONG lPlayHandle);

//����
NET_DVR_API LONG __stdcall NET_DVR_AdapterUpgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade(LONG lUserID, char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_VcalibUpgrade(LONG lUserID, LONG lChannel, char const *sFileName);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeState(LONG lUpgradeHandle);
NET_DVR_API int __stdcall NET_DVR_GetUpgradeProgress(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseUpgradeHandle(LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetNetworkEnvironment(DWORD dwEnvironmentLevel);
//Զ�̸�ʽ��Ӳ��
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk(LONG lUserID,LONG lDiskNumber);
NET_DVR_API LONG __stdcall NET_DVR_FormatDisk_V50(LONG lUserID, NET_DVR_FORMAT_HDD *lpStruHddFormatCond);
NET_DVR_API BOOL __stdcall NET_DVR_GetFormatProgress(LONG lFormatHandle, LONG *pCurrentFormatDisk,LONG *pCurrentDiskPos,LONG *pFormatStatic);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFormatHandle(LONG lFormatHandle);
//����
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan(LONG lAlarmHandle);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V30(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CloseAlarmChan_V30(LONG lAlarmHandle);
//�����Խ�
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_V30(LONG lUserID, DWORD dwVoiceChan, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceComClientVolume(LONG lVoiceComHandle, WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_StopVoiceCom(LONG lVoiceComHandle);
//����ת��
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR(LONG lUserID, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, DWORD dwUser), DWORD dwUser);
NET_DVR_API LONG __stdcall NET_DVR_StartVoiceCom_MR_V30(LONG lUserID, DWORD dwVoiceChan, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceComSendData(LONG lVoiceComHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress(LONG lUserID, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
NET_DVR_API BOOL __stdcall NET_DVR_GetCurrentAudioCompress_V50(LONG lUserID, LPNET_DVR_AUDIO_CHANNEL lpAudioChannel, LPNET_DVR_COMPRESSION_AUDIO lpCompressAudio);
//�����㲥
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart();
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStart_V30(void(CALLBACK *fVoiceDataCallBack)(char *pRecvDataBuffer, DWORD dwBufSize, void * pUser), void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ClientAudioStop();
NET_DVR_API BOOL __stdcall NET_DVR_AddDVR(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_AddDVR_V30(LONG lUserID, DWORD dwVoiceChan);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_DelDVR_V30(LONG lVoiceHandle);
//͸��ͨ������
NET_DVR_API LONG __stdcall NET_DVR_SerialStart(LONG lUserID,LONG lSerialPort,void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle,char *pRecvDataBuffer,DWORD dwBufSize,DWORD dwUser),DWORD dwUser);
//485��Ϊ͸��ͨ��ʱ����Ҫָ��ͨ���ţ���Ϊ��ͬͨ����485�����ÿ��Բ�ͬ(���粨����)
NET_DVR_API LONG __stdcall NET_DVR_SerialStart_V40(LONG lUserID,void* lpInBuffer, LONG dwInBufferSize, void(CALLBACK *fSerialDataCallBack)(LONG lSerialHandle, LONG lCHannel, char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SerialSend(LONG lSerialHandle, LONG lChannel, char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SerialStop(LONG lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SendTo232Port(LONG lUserID, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_SendToSerialPort(LONG lUserID, DWORD dwSerialPort, DWORD dwSerialIndex, char *pSendBuf, DWORD dwBufSize);

#if (!defined __linux__) && (!defined _WIN64)
//Decoding nBitrate = 16000
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder(int nBitrate = 16000);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *pDecHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder();
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *pEncodeHandle, BYTE* pInBuffer, BYTE* pOutBuffer);
#elif ((defined __linux__) || (defined _WIN64))
NET_DVR_API void* __stdcall NET_DVR_InitG722Decoder();
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG722Frame(void *handle, NET_DVR_AUDIODEC_PROCESS_PARAM * param);
//Encoding
NET_DVR_API void* __stdcall NET_DVR_InitG722Encoder(NET_DVR_AUDIOENC_INFO* enc_info);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG722Frame(void *handle, NET_DVR_AUDIOENC_PROCESS_PARAM* param);
#endif // _WIN32
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Decoder(void *pDecHandle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG722Encoder(void *pEncodeHandle);

//����
NET_DVR_API void* __stdcall NET_DVR_InitG726Decoder(void** pDecMoudle);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Decoder(void *pDecHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG726Frame(void *pDecMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);

//����
NET_DVR_API void* __stdcall NET_DVR_InitG726Encoder(void** pEncMoudle);
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG726Frame(void *pEncMoudle, BYTE* pInBuffer, BYTE* pOutBuffer, BYTE byReset);
NET_DVR_API void __stdcall NET_DVR_ReleaseG726Encoder(void *pEncHandle);

//Զ�̿��Ʊ�����ʾ
NET_DVR_API BOOL __stdcall NET_DVR_ClickKey(LONG lUserID, LONG lKeyIndex);

NET_DVR_API BOOL __stdcall NET_DVR_DoorBellControl(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_Preview(LONG lUserID, LONG lPicNum);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewOne(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackByNameLocDisplay(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackByTimeLocDisplay(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpStartTime, NET_DVR_TIME const *lpStopTime);
NET_DVR_API BOOL __stdcall NET_DVR_StopLocDisplayPlay(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_PlayControlLocDisplay(LONG lUserID, DWORD dwControlCode);
//Զ�̿����豸���ֶ�¼��
NET_DVR_API BOOL __stdcall NET_DVR_StartDVRRecord(LONG lUserID,LONG lChannel,LONG lRecordType);
NET_DVR_API BOOL __stdcall NET_DVR_StopDVRRecord(LONG lUserID,LONG lChannel);
//���뿨
NET_DVR_API BOOL __stdcall NET_DVR_InitDevice_Card(long *pDeviceTotalChan);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDevice_Card();
NET_DVR_API BOOL __stdcall NET_DVR_InitDDraw_Card(HWND hParent,COLORREF colorKey);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDraw_Card();
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card(LONG lUserID,LPNET_DVR_CARDINFO lpCardInfo,long lChannelNum);
NET_DVR_API BOOL __stdcall NET_DVR_ResetPara_Card(LONG lRealHandle,LPNET_DVR_DISPLAY_PARA lpDisplayPara);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_ClearSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_RestoreSurface_Card();
NET_DVR_API BOOL __stdcall NET_DVR_OpenSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSound_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetVolume_Card(LONG lRealHandle,WORD wVolume);
NET_DVR_API BOOL __stdcall NET_DVR_AudioPreview_Card(LONG lRealHandle,BOOL bEnable);
NET_DVR_API LONG __stdcall NET_DVR_GetCardLastError_Card();
NET_DVR_API BOOL __stdcall NET_DVR_SetDspErrMsg_Card(DWORD dwMessage, HANDLE hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_ResetDSP_Card(LONG iChannelNum);
NET_DVR_API HANDLE __stdcall NET_DVR_GetChanHandle_Card(LONG lRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_Card(LONG lRealHandle, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetSerialNum_Card(long lChannelNum,DWORD *pDeviceSerialNo);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog(LONG lLogHandle, LPNET_DVR_LOG lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V30(LONG lUserID, LONG lSelectMode, DWORD dwMajorType,DWORD dwMinorType, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime, BOOL bOnlySmart = FALSE);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V30(LONG lLogHandle, LPNET_DVR_LOG_V30 lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_V50(LONG lUserID, LPNET_DVR_FIND_LOG_COND pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_V50(LONG lLogHandle, LPNET_DVR_LOG_V50 lpLogData);
NET_DVR_API BOOL __stdcall NET_DVR_FindLogClose_V30(LONG lLogHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindAlarmHostLog(LONG lUserID, LONG lSelectMode, NET_DVR_ALARMHOST_SEARCH_LOG_PARAM *lpSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextAlarmHostLog(LONG lFindHandle, NET_DVR_ALARMHOST_LOG_RET *lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindAlarmHostLogClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_PCNVR(LONG lUserID, LPNET_DVR_FILE_COND_PCNVR const pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFile_PCNVR(LONG lFindHandle, LPNET_DVR_FINDDATA_PCNVR lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindClose_PCNVR(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByCard(LONG lUserID,LONG lChannel,DWORD dwFileType, int nFindType, BYTE *sCardNumber, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sPicFileName);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_NEW(LONG lUserID, LONG lChannel, LPNET_DVR_JPEGPARA lpJpegPara, char *sJpegPicBuffer, DWORD dwPicSize,  LPDWORD lpSizeReturned);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePicture_V50(LONG lUserID, LONG lChannel, LPNET_DVR_PICPARAM_V50  lpPicParam, char *sPicBuffer, DWORD dwPicSize, LPDWORD lpSizeReturned);
NET_DVR_API BOOL __stdcall NET_DVR_CaptureJPEGPicture_WithAppendData(LONG lUserID, LONG lChannel, NET_DVR_JPEGPICTURE_WITH_APPENDDATA *lpJpegWithAppend);
NET_DVR_API BOOL __stdcall NET_DVR_GetRealPlayOsdTime(LONG iRealHandle, LPNET_DVR_TIME lpOsdTime);
NET_DVR_API BOOL __stdcall NET_DVR_RealPlayPause(LONG iRealHandle);
NET_DVR_API BOOL __stdcall NET_DVR_RealPlayRestart(LONG iRealHandle, HWND hPlayWnd);
NET_DVR_API int __stdcall NET_DVR_GetRealPlayerIndex(LONG lRealHandle);
NET_DVR_API int __stdcall NET_DVR_GetPlayBackPlayerIndex(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG(LONG lUserID, DWORD dwScale);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG(LONG lUserID, DWORD *lpOutScale);
NET_DVR_API BOOL __stdcall NET_DVR_SetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetScaleCFG_V30(LONG lUserID, LPNET_DVR_SCALECFG pScalecfg);
NET_DVR_API BOOL __stdcall NET_DVR_SetATMPortCFG(LONG lUserID, WORD wATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetATMPortCFG(LONG lUserID, WORD *LPOutATMPort);
NET_DVR_API BOOL __stdcall NET_DVR_InitDDrawDevice();
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseDDrawDevice();
NET_DVR_API LONG __stdcall NET_DVR_GetDDrawDeviceTotalNums();
NET_DVR_API BOOL __stdcall NET_DVR_SetDDrawDevice(LONG lPlayPort, DWORD nDeviceNum);

NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn(LONG lRealHandle, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_PTZSelZoomIn_EX(LONG lUserID, LONG lChannel, LPNET_DVR_POINT_FRAME pStruPointFrame);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecode(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERINFO lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecode(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecoderState(LONG lUserID, LONG lChannel, LPNET_DVR_DECODERSTATE lpDecoderState);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecInfo(LONG lUserID, LONG lChannel, LPNET_DVR_DECCFG lpDecoderinfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecTransPort(LONG lUserID, LPNET_DVR_PORTCFG lpTransPort);
NET_DVR_API BOOL __stdcall NET_DVR_DecPlayBackCtrl(LONG lUserID, LONG lChannel, DWORD dwControlCode, DWORD dwInValue,DWORD *LPOutValue, LPNET_DVR_PLAYREMOTEFILE lpRemoteFileInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StartDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDecSpecialCon(LONG lUserID, LONG lChannel, LPNET_DVR_DECCHANINFO lpDecChanInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlDec(LONG lUserID, LONG lChannel, DWORD dwControlCode);
NET_DVR_API BOOL __stdcall NET_DVR_DecCtrlScreen(LONG lUserID, LONG lChannel, DWORD dwControl);
NET_DVR_API BOOL __stdcall NET_DVR_GetDecCurLinkStatus(LONG lUserID, LONG lChannel, LPNET_DVR_DECSTATUS lpDecStatus);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DYNAMIC_DEC lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopDynamic(LONG lUserID, DWORD dwDecChanNum); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecEnable(LONG lUserID, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, DWORD dwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanEnable(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwEnable);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_STATUS lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetVideoStandard(LONG lUserID, DWORD dwDecChanNum, LPDWORD lpdwVideoStandard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetVideoStandard(LONG lUserID, DWORD dwDecChanNum, DWORD dwVideoStandard);

//2007-12-22 ����֧�ֽӿ� 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlayControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwControlCode, DWORD dwInValue, DWORD *LPOutValue);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetRemotePlayStatus(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS lpOuter);
//2009-4-13 ����
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V30(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTranInfo_V30(LONG lUserID, LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30 lpTranInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG lpDisplayCfg);

NET_DVR_API LONG __stdcall NET_DVR_MatrixStartPassiveDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_PASSIVEMODE lpPassiveMode /*, void(CALLBACK *fPassiveDataCallBack)(LONG lPassiveHandle, char * pSendBuf, DWORD dwBufSize, DWORD dwStatus, DWORD dwUser), DWORD dwUser*/);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSendData(LONG lPassiveHandle, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStopPassiveDecode(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_DISP_LOGOCFG lpDispLogoCfg, char *sLogoBuffer);
#define    NET_DVR_SHOWLOGO            1        /*��ʾLOGO*/
#define    NET_DVR_HIDELOGO            2        /*����LOGO*/  
NET_DVR_API BOOL __stdcall NET_DVR_LogoSwitch(LONG lUserID, DWORD dwDecChan, DWORD dwLogoSwitch);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus(LONG lUserID,  LPNET_DVR_DECODER_WORK_STATUS lpDecoderCfg);

#define    DISP_CMD_ENLARGE_WINDOW                1    /*��ʾͨ���Ŵ�ĳ������*/
#define    DISP_CMD_RENEW_WINDOW                2    /*��ʾͨ�����ڻ�ԭ*/
#define    DISP_CMD_OPENAUDIO                    3    /*��ʾͨ������Ƶ*/
#define    DISP_CMD_CLOSEAUDIO                    4    /*��ʾͨ���ر���Ƶ*/

NET_DVR_API BOOL __stdcall NET_DVR_MatrixDiaplayControl(LONG lUserID, DWORD dwDispChanNum, DWORD dwDispChanCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPassiveDecodeControl(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PASSIVEDECODE_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_MatrixGetPassiveDecodeStatus(LONG lPassiveHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDecChanCfg(LONG lUserID, DWORD dwDecChan, LPNET_DVR_MATRIX_DECCHAN_CONTROL lpInter);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_NEW(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpStartTime, NET_DVR_TIME const *lpStopTime, LONG lLongitude, LONG lLatitude, HWND hWnd);
NET_DVR_API BOOL __stdcall NET_DVR_RefreshPlay(LONG lPlayHandle);

//�ָ�Ĭ��ֵ
NET_DVR_API BOOL __stdcall NET_DVR_RestoreConfig(LONG lUserID);
//�������
NET_DVR_API BOOL __stdcall NET_DVR_SaveConfig(LONG lUserID);
//����
NET_DVR_API BOOL __stdcall NET_DVR_RebootDVR(LONG lUserID);
//�ر�DVR
NET_DVR_API BOOL __stdcall NET_DVR_ShutDownDVR(LONG lUserID);

//�������� begin
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_SetDVRConfig(LONG lUserID, DWORD dwCommand,LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState_V30(LONG lUserID, LPNET_DVR_WORKSTATE_V30 lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_GetDVRWorkState(LONG lUserID, LPNET_DVR_WORKSTATE lpWorkState);
NET_DVR_API BOOL __stdcall NET_DVR_SetVideoEffect(LONG lUserID, LONG lChannel, DWORD dwBrightValue, DWORD dwContrastValue, DWORD dwSaturationValue, DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetVideoEffect(LONG lUserID, LONG lChannel, DWORD *pBrightValue, DWORD *pContrastValue, DWORD *pSaturationValue, DWORD *pHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat(LONG lUserID, LPNET_DVR_FRAMEFORMAT lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetframeformat_V30(LONG lUserID, LPNET_DVR_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetframeformat_V30(LONG lUserID, LPNET_DVR_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_SetAtmFrameFormat_V30(LONG lUserID, LONG lAtmChannel, LPNET_DVR_ATM_FRAMEFORMAT_V30 lpFrameFormat);
NET_DVR_API BOOL __stdcall NET_DVR_GetAtmProtocol(LONG lUserID, LPNET_DVR_ATM_PROTOCOL lpAtmProtocol);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut_V30(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS_V30 lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmOut(LONG lUserID, LPNET_DVR_ALARMOUTSTATUS lpAlarmOutState);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmOut(LONG lUserID, LONG lAlarmOutPort,LONG lAlarmOutStatic);

//��Ƶ��������
NET_DVR_API BOOL __stdcall NET_DVR_ClientSetVideoEffect(LONG lRealHandle,DWORD dwBrightValue,DWORD dwContrastValue, DWORD dwSaturationValue,DWORD dwHueValue);
NET_DVR_API BOOL __stdcall NET_DVR_ClientGetVideoEffect(LONG lRealHandle,DWORD *pBrightValue,DWORD *pContrastValue, DWORD *pSaturationValue,DWORD *pHueValue);

//�����ļ�
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_V30(LONG lUserID, char *sOutBuffer, DWORD dwOutSize, DWORD *pReturnSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetConfigFile_EX(LONG lUserID, char *sOutBuffer, DWORD dwOutSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetConfigFile_EX(LONG lUserID, char *sInBuffer, DWORD dwInSize);

//������־�ļ�д��ӿ�
NET_DVR_API BOOL __stdcall NET_DVR_SetLogToFile(DWORD nLogLevel = 0, char * strLogDir = NULL, BOOL bAutoDel = TRUE);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKState(LPNET_DVR_SDKSTATE pSDKState);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKAbility(LPNET_DVR_SDKABL pSDKAbl);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol(LONG lUserID, NET_DVR_PTZCFG *pPtzcfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCtrl_Other(LONG iUserID, LONG iChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetPTZCtrl(LONG iRealHandle);
//ǰ�������
NET_DVR_API BOOL __stdcall NET_DVR_LockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_UnLockPanel(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StartPanelKey(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopPanelKey(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_SetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRtspConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_RTSPCFG lpOutBuffer, DWORD dwOutBufferSize);

//��������ȡ
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceAbility(LONG lUserID, DWORD dwAbilityType, char* pInBuf, DWORD dwInLength, char* pOutBuf, DWORD dwOutLength);
NET_DVR_API BOOL __stdcall NET_DVR_SetSimAbilityPath(char * szSimAbilityPath, char *szSDCard);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetCodeSplitter(LONG lUserID, DWORD dwCodeChan, LPNET_DVR_CODESPLITTERINFO lpInter);

//����
//����/��ȡ�����ؼ���
NET_DVR_API BOOL __stdcall NET_DVR_SetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int nValue);
NET_DVR_API BOOL __stdcall NET_DVR_GetBehaviorParamKey(LONG lUserID, LONG lChannel, DWORD dwParameterKey,int *pValue);

//��ȡ/������Ϊ����Ŀ����ӽӿ�
NET_DVR_API BOOL __stdcall NET_DVR_GetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);



NET_DVR_API BOOL __stdcall NET_DVR_SetVCADrawMode(LONG lUserID, LONG lChannel, LPNET_VCA_DRAW_MODE lpDrawMode);

//�������ģʽ���ýӿ�
NET_DVR_API BOOL __stdcall NET_DVR_SetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrackMode(LONG lUserID, LONG lChannel, LPNET_DVR_TRACK_MODE lpTrackMode);

//�������ܿ�
NET_DVR_API BOOL __stdcall NET_VCA_RestartLib(LONG lUserID, LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_SaveRealData_V30(LONG lRealHandle, DWORD dwTransType, char *sFileName);

#if ((!defined __linux__) && (!defined _WIN64))
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(DWORD iType, BYTE *pInBuffer, BYTE *pOutBuffer);
#elif ((defined __linux__) || (defined _WIN64))
NET_DVR_API BOOL __stdcall NET_DVR_EncodeG711Frame(LPVOID handle, NET_DVR_AUDIOENC_PROCESS_PARAM *p_enc_proc_param);
NET_DVR_API BOOL __stdcall NET_DVR_DecodeG711Frame(LPVOID handle, NET_DVR_AUDIODEC_PROCESS_PARAM *p_dec_proc_param);
NET_DVR_API LPVOID __stdcall NET_DVR_InitG711Decoder();
NET_DVR_API LPVOID __stdcall NET_DVR_InitG711Encoder(NET_DVR_AUDIOENC_INFO *enc_info);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseG711Encoder(LPVOID pEncodeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseG711Decoder(LPVOID pDecHandle);
#endif //(defined _WIN32)

NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V40(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V40  lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFileByEvent_V50(LONG lUserID, LPNET_DVR_SEARCH_EVENT_PARAM_V50 lpSearchEventParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V40(LONG lSearchHandle, LPNET_DVR_SEARCH_EVENT_RET_V40 lpSearchEventRet);
NET_DVR_API LONG __stdcall NET_DVR_FindNextEvent_V50(LONG lFindHandle, LPNET_DVR_SEARCH_EVENT_RET_V50 lpSearchEventRet);
//ֹͣ���� NET_DVR_FindClose

NET_DVR_API LONG __stdcall NET_DVR_FindPDCInfo(LONG lUserID, LONG lChannel, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPDCInfo(LONG lFindHandle,LPNET_DVR_PDC_QUERY lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindPDCClose(LONG lFindHandle);

// �궨У�� 
#define NET_DVR_PDC_VERIFY_CALIBRATION          1    //��ֵΪ1��ΪPDC�궨У�� pdc����ֵΪNET_VCA_POINT   ����ֵΪ NET_VCA_RECT�ṹ
#define NET_DVR_VERIFY_BEHAVIOR_CALIBRATION     2    // ��Ϊ�����궨��У�� 
#define NET_DVR_VERIFY_ITS_CALIBRATION            3    // ���ܽ�ͨ�궨У�� 
#define NET_DVR_VERIFY_BV_CALIBRATION            5    //˫Ŀ�궨У��

NET_DVR_API BOOL __stdcall  NET_DVR_VerifyCalibration(LONG lUserID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOuterBuffer, DWORD dwOuterBufferSize);
NET_DVR_API BOOL __stdcall  NET_DVR_ResetCounter(LONG lUserID,LONG lChannel);

NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLog_MATRIX(LONG lLogHandle, LPNET_DVR_LOG_MATRIX lpLogData);
NET_DVR_API LONG __stdcall NET_DVR_FindDVRLog_Matrix(LONG lUserID, LONG lSelectMode, DWORD dwMajorType, DWORD dwMinorType, LPNET_DVR_VEDIOPLATLOG lpVedioPlatLog, LPNET_DVR_TIME lpStartTime, LPNET_DVR_TIME lpStopTime);

NET_DVR_API BOOL __stdcall NET_DVR_ManualSnap(LONG lUserID, NET_DVR_MANUALSNAP const* lpInter, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_GetPTZProtocol_Ex(LONG lUserID, LONG lChannel, NET_DVR_PTZCFG *pPtzcfg);

NET_DVR_API LONG __stdcall NET_DVR_StartEmailTest(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_StopEmailTest(LONG lEmailTestHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetEmailTestProgress(LONG lEmailTestHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST lpProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetIPCProtoList_V41(LONG lUserID, LPNET_DVR_IPC_PROTO_LIST_V41 lpProtoList);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SmartSearch_V40(LONG lUserID,  LPNET_DVR_SMART_SEARCH_PARAM_V40 lpSmartSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_SearchNextInfo(LONG lSearchHandle, LPNET_DVR_SMART_SEARCH_RET lpSmartSearchRet);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearch(LONG lSearchHandle);

// IP San �ļ�Ŀ¼����
NET_DVR_API LONG __stdcall NET_DVR_FindIpSanDirectory(LONG lUserID, LPNET_DVR_IPSAN_SERACH_PARAM lpIpsanSearchParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDirectory(LONG lFindHandle, LPNET_DVR_IPSAN_SERACH_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindDirectoryClose(LONG lFindHandle);

typedef void (CALLBACK *REALDATACALLBACK) (LONG lPlayHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser);

NET_DVR_API LONG __stdcall NET_DVR_ZeroStartPlay(LONG lUserID, LPNET_DVR_CLIENTINFO lpClientInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL, BOOL bBlocked = TRUE);

NET_DVR_API BOOL __stdcall NET_DVR_ZeroStopPlay(LONG lPlayHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroMakeKeyFrame(LONG lUserID, LONG lZeroChan);
NET_DVR_API BOOL __stdcall NET_DVR_PlayBackControl_V40(LONG lPlayHandle,DWORD dwControlCode, LPVOID lpInBuffer = NULL, DWORD dwInLen = 0, LPVOID lpOutBuffer = NULL, DWORD *lpOutLen = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_ZeroTurnOver(LONG lUserID, LONG lChannel, BOOL bNextPreview);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_Card_V30(LONG lUserID, NET_DVR_CARDINFO const *lpCardInfo, LONG lChannelNum, DWORD dwMode, BOOL bBlock, REALDATACALLBACK fRealDataCallBack_V30, void* pUser);


NET_DVR_API BOOL __stdcall NET_DVR_GetDiskList(LONG lUserID, LPNET_DVR_DISKABILITY_LIST lpDiskList);
NET_DVR_API LONG __stdcall NET_DVR_Backup(LONG lUserID, DWORD dwBackupType, LPVOID lpBackupBuff, DWORD dwBackupBuffSize);
NET_DVR_API LONG __stdcall NET_DVR_BackupByName(LONG lUserID, LPNET_DVR_BACKUP_NAME_PARAM lpBackupByName);
NET_DVR_API LONG __stdcall NET_DVR_BackupByTime(LONG lUserID, LPNET_DVR_BACKUP_TIME_PARAM lpBackupBytime);
NET_DVR_API BOOL __stdcall NET_DVR_GetBackupProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopBackup(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_GetSadpInfoList(LONG lUserID, LPNET_DVR_SADPINFO_LIST lpSadpInfoList);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateSadpInfo(LONG lUserID, LPNET_DVR_SADP_VERIFY lpSadpVerify, LPNET_DVR_SADPINFO lpSadpInfo);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_SetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetCodeSplitterAssociate(LONG lUserID, DWORD dwDecoderChan, DWORD dwSlotNum, LPNET_DVR_CODESPLITTERASSOCIATE lpInter);

NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetCDRWScheme(LONG lUserID, LPNET_DVR_INQUEST_CDRW_CFG lpCDRWCfg);
NET_DVR_API BOOL __stdcall NET_DVR_InquestDeleteFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCDWByFile(LONG lUserID, LPNET_DVR_INQUEST_FILES lpCdrwFile);
NET_DVR_API LONG __stdcall NET_DVR_InquestUploadFile(LONG lUserID, char *sFileName);
NET_DVR_API BOOL __stdcall NET_DVR_InquestUploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_InquestGetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStartCDW( LONG lUserID, BOOL bPause);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStopCDW(LONG lUserID, BOOL bCancelWrite);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetCDWState(LONG lUserID, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus(LONG lUserID, LPNET_DVR_INQUEST_PIP_STATUS pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestCheckSecretKey(LONG lUserID, BOOL *bSecretSet);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetSecretKey(LONG lUserID, LPNET_DVR_INQUEST_SECRET_INFO pSecretInfo);
NET_DVR_API BOOL __stdcall NET_DVR_InquestStreamEncrypt(LONG lUserID, LONG lChannel, BOOL bEncrypt);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetEncryptState(LONG  lUserID, LONG lChannel, BOOL *bEncrypt);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindFile(LONG lUserID);
NET_DVR_API LONG __stdcall NET_DVR_InquestFindNextFile(LONG lFindHandle, LPNET_DVR_INQUEST_FILEINFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_InquestFindClose(LONG lFindHandle);

// 9000RH
NET_DVR_API LONG __stdcall NET_DVR_RaidFastConfig(LONG lUserID, char *sName);
NET_DVR_API BOOL __stdcall NET_DVR_FastConfigProcess(LONG lHandle, DWORD *pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFastConfig(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetArraySpaceAlloc(LONG lUserID, DWORD dwSlot, LPNET_DVR_ARRAY_SPACE_ALLOC_INFO lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DelArray(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_CreateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CalcArraySize(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam, UINT64* lpArraySize);
NET_DVR_API BOOL __stdcall NET_DVR_MigrateArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_RebuildArray(LONG lUserID, LPNET_DVR_OPERATE_ARRAY_PARAM lpArrayParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVD(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM lpVDParam);
NET_DVR_API BOOL __stdcall NET_DVR_CreateVDEx(LONG lUserID, LPNET_DVR_OPERATE_VD_PARAM_EX lpVDParamEx);
NET_DVR_API BOOL __stdcall NET_DVR_DelVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_RepairVD(LONG lUserID, DWORD dwID);
NET_DVR_API BOOL __stdcall NET_DVR_SetSpareDisk(LONG lUserID, LPNET_DVR_SPARE_DISK_PARAM lpSpareDisk);
NET_DVR_API BOOL __stdcall NET_DVR_GetPDList(LONG lUserID, LPNET_DVR_PHY_DISK_LIST lpPDList);
NET_DVR_API BOOL __stdcall NET_DVR_GetArrayList(LONG lUserID, LPNET_DVR_ARRAY_LIST lpArrayList);
NET_DVR_API BOOL __stdcall NET_DVR_GetVDList(LONG lUserID, LPNET_DVR_VD_LIST lpVDList);
NET_DVR_API LONG __stdcall NET_DVR_ExpandDisk(LONG lUserID,DWORD dwVDSLot);
NET_DVR_API BOOL __stdcall NET_DVR_GetExpandProgress(LONG lExpandHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_CloseExpandHandle(LONG lExpandHandle);
NET_DVR_API LONG __stdcall NET_DVR_AlgoDebugStart(LONG lUserID, LONG lCHannel, void(CALLBACK *fAlgoLibInfoCallBack)(LONG lHandle, LONG lChannel,char *pRecvDataBuffer, DWORD dwBufSize, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugSend(LONG lHandle, LONG lChannel, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlgoDebugStop(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrint(BOOL bLogPrint);
NET_DVR_API BOOL __stdcall NET_DVR_SetLogPrintAction(DWORD nLogLevel, DWORD nToDevice, BOOL bEnable, int Reserve1, int Reserve2);

NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionRule_V41(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_POSITION_RULE_CFG_V41 lpPositionRule);
NET_DVR_API BOOL __stdcall NET_DVR_SetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPositionLimitAngle(LONG lUserID, LONG lChannel, LONG lPositionIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPtzPosition(LONG lUserID, LONG lChannel, LONG lPositionID, LPNET_DVR_PTZ_POSITION lpPtzPosition);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolTrack(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_PATROL_TRACKCFG lpPatrolTrack);
NET_DVR_API BOOL __stdcall NET_DVR_SetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPatrolLimitAngle(LONG lUserID, LONG lChannel, LONG lPatrolIndex, LPNET_DVR_LIMIT_ANGLE lpLimitAngle);
NET_DVR_API BOOL __stdcall NET_DVR_SetSceneMode(LONG  lUserID, LONG lChannel, DWORD dwSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetSceneMode(LONG lUserID, LONG lChannel, DWORD  *pSceneMode);
NET_DVR_API BOOL __stdcall NET_DVR_GetVCAVersion(LONG lUserID, LONG lChannel, LPNET_DVR_VCA_VERSION lpVersion);

NET_DVR_API BOOL __stdcall NET_DVR_ContinuousShoot(LONG lUserID, LPNET_DVR_SNAPCFG lpInter);     
NET_DVR_API BOOL __stdcall NET_DVR_MatrixPicAdjust(LONG lUserID, DWORD dwDispChan, DWORD dwPicAdjust, DWORD dwCmdParam); 
NET_DVR_API BOOL __stdcall NET_DVR_AlarmJoinedRecord(LONG lUserID, DWORD dwChan, DWORD dwAlarmSeq, DWORD dwRecordTime, DWORD dwRes);
NET_DVR_API BOOL __stdcall NET_DVR_GetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_UNITEDMATRIXINFO lpInter);
typedef LONG(CALLBACK * REGCallBack)(LONG lUserID, LPNET_DVR_REGCALLBACKPARAM pRegCallbackParam, LPNET_DVR_LOGONREPONSEPARAM pInterParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetRegisterCallBack(REGCallBack fRegCallBack, void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PreviewRequest(LONG lUserID, LONG lChannel, LPNET_DVR_PREVIEWPARAM lpPreviewParam, LPNET_DVR_DEVICENATINFO lpOuter);
typedef LONG(CALLBACK * PREVIEWRESPONSECallBack)(LONG lUserID, LONG lStreamHandle, LPNET_DVR_PREVIEWCALLBACKPARAM pPewviewCallbackParam,void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPreviewResponseCallBack(PREVIEWRESPONSECallBack fPreviewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_PlaybackRequest(LONG lUserID, LPNET_DVR_PLAYBACKREQUESTPARAM lpPlayBackRequestParam);
typedef LONG(CALLBACK * PLAYBACKRESPONSECallBack)(LONG lUserID, LONG lPlaybackHandle, LPNET_DVR_PLAYBACKCALLBACKPARAM lpPlaybackParam,void *pUser);     
NET_DVR_API BOOL __stdcall NET_DVR_SetPlaybackResponseCallBack(PLAYBACKRESPONSECallBack fPlaybackResponseCallBack, void *pUser);          
typedef LONG(CALLBACK * VOICERESPONSECallBack)(LONG lUserID, LONG lVoiceHandle, LONG lVoiceChannel, BYTE nAudioType, void *pUser);     
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceResponseCallBack(VOICERESPONSECallBack fVoiceResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_VoiceRequest(LONG lUserID, LPNET_DVR_VOICEREQUESTPARAM lpVoiceParam);           
NET_DVR_API BOOL __stdcall NET_DVR_AlarmSetupRequest(LONG lUserID, LPNET_DVR_ALARMSETUPREQUESTPARAM lpAlarmSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);                      
NET_DVR_API BOOL __stdcall NET_DVR_SetDialParam(LONG lUserID, LPNET_DVR_DIALREQUEST lpDialRequest, LPNET_DVR_DIALPARAM lpDialParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsListInfo(LONG lUserID, LPNET_DVR_TIME_EX lpStartTime, LPNET_DVR_TIME_EX lpStopTime, LPNET_DVR_SMSLISTINFO lpSmsListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSmsContent(LONG lUserID, DWORD dwSmsIndex, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API BOOL __stdcall NET_DVR_SendSms(LONG lUserID, LPNET_DVR_SMSCONTENT lpSmsContent);
NET_DVR_API LONG __stdcall NET_DVR_StartServer(char *sLocalIP, WORD wLocalPort, BYTE byMode);
NET_DVR_API BOOL __stdcall NET_DVR_StopServer(LONG lServerHandle); 
NET_DVR_API LONG __stdcall NET_DVR_StartRecvNakedDataListen(NAKED_DATA_TYPE type, LPNET_DVR_NAKED_DATA_PARAM pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopRecvNakedDataListen(LONG lNakedDataRecvHandle);          
typedef void(CALLBACK * NAKEDDAtACALLBACK)(DWORD typeInfo, char *pInfo, DWORD dwInfoLen,DWORD dwIPLen, void* pUser);
NET_DVR_API BOOL __stdcall  NET_DVR_SetNakedDataRecvCallBack(LONG lNakedDataRecvHandle, void(CALLBACK *fNakedDataCallBack)(DWORD dwTypeInfo, NET_DVR_NAKED_DATA_INFO *pStruNakedDataInfo, char *pInfo, DWORD dwInfoLen, void* pUser), void* pUser);

typedef LONG(CALLBACK * ALARMSETUPRESPONSECallBack)(LONG lUserID, LONG lAlarmHandle, void * pUser);         
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSetupResponseCallBack(ALARMSETUPRESPONSECallBack fAlarmSetupResponseCallBack, void * pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SpringJPEGPicture(LONG lUserID, LONG lChannel, NET_DVR_PUSHJPEGPARA const *lpJpegPara);
NET_DVR_API BOOL __stdcall NET_DVR_SetPushModeParam(LPNET_DVR_PUSHMODEPARAM pPushParam);

NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetupAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostCloseAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_BypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_UnBypassAlarmChan(LONG lUserID, NET_DVR_ALARMIN_SETUP *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostAssistantControl(LONG lUserID, DWORD dwType, DWORD dwNumber, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetAirCondition(LONG lUserID, LONG l485Index, NET_DVR_AIR_CONDITION_PARAM* lpAirConditionParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceTypeList(LONG lUserID, NET_DVR_DEVICE_TYPE_LIST *lpDeviceTypeList);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceProtoList(LONG lUserID, LONG lDeviceType, NET_DVR_DEVICE_PROTO_LIST *lpDeviceProtoList);
NET_DVR_API BOOL __stdcall NET_DVR_GetBatteryVoltage(LONG lUserID, float *pVoltage);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmDeviceUser(LONG lUserID, LONG lUserIndex, NET_DVR_ALARM_DEVICE_USER* lpDeviceUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetKeyboardUser(LONG lUserID, LONG lUserIndex, NET_DVR_KEYBOARD_USER* lpKeyboardUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetOperateUser(LONG lUserID, LONG lUserIndex, NET_DVR_OPERATE_USER* lpOperateUser);
NET_DVR_API BOOL __stdcall NET_DVR_ControlGateway(LONG lUserID, LONG lGatewayIndex, DWORD dwStaic);
NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmHostOut(LONG lUserID, LONG lAlarmOutPort, LONG lAlarmOutStatic);
typedef void(CALLBACK *fAlarmHostSerialDataCallBack)
(LONG lSerialHandle, LONG lPort, LONG lDateType, char *pRecvDataBuffer, DWORD  dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_AlarmHostSerialStart(LONG lUserID, LONG lSerialType, fAlarmHostSerialDataCallBack cbSerialDataCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialSend(LONG lSerialHandle,LONG lPort,char *pSendBuf,DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSerialStop(LONG  lSerialHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetMatrixPuChan(LONG lUserID, LONG lChanType, NET_DVR_PU_CHAN_LIST* lpChanList);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmOffMonitor(LONG lUserID, DWORD dwMonID, DWORD dwCamID);
NET_DVR_API BOOL __stdcall NET_DVR_GetCameraListInfo(LONG lUserID, DWORD dwCamNum, DWORD dwStartCam, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetMonitorListInfo(LONG lUserID, DWORD dwMonNum, DWORD dwStartMon, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetGlobalNum(LONG lUserID, DWORD *dwCamNum, DWORD *dwMonNum); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUnitedMatrixInfo(LONG lUserID, LPNET_DVR_ALLUNITEDMATRIXINFO lpInter); 
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);         
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetGatewayInfo(LONG lUserID, LPNET_DVR_MATRIXGATEWAYINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSpanSwitch(LONG lUserID, BYTE nSwitchMode, LPNET_DVR_MATRIXSWITCH lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartSwitch(LONG lUserID, LPNET_DVR_MATRIXSWITCHCTRL lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char *sInBuffer,  DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetConfigFile(LONG lUserID, LPNET_DVR_MATRIXDATABASE lpInter, char  *sOutBuffer,  DWORD   dwOutSize,  DWORD   *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSubSystemInfo_V40(LONG lUserID, LPNET_DVR_ALLSUBSYSTEMINFO_V40 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V40(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40 lpInter);
typedef void (CALLBACK *FLOWTESTCALLBACK)(LONG lFlowHandle, LPNET_DVR_FLOW_INFO pFlowInfo, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartNetworkFlowTest(LONG lUserID, NET_DVR_FLOW_TEST_PARAM* pFlowTest,  FLOWTESTCALLBACK fFlowTestCallback, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_StopNetworkFlowTest(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_FindRecordLabel(LONG lUserID, LPNET_DVR_FIND_LABEL lpFindLabel);
NET_DVR_API LONG __stdcall NET_DVR_FindNextLabel(LONG lFindHandle, LPNET_DVR_FINDLABEL_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_StopFindLabel(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_InsertRecordLabel(LONG lPlayHandle, NET_DVR_RECORD_LABEL* lpRecordLabel, NET_DVR_LABEL_IDENTIFY *lpLableIdentify);
NET_DVR_API BOOL __stdcall NET_DVR_DelRecordLabel(LONG lUserID, NET_DVR_DEL_LABEL_PARAM* lpDelLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_ModifyRecordLabel(LONG lUserID, NET_DVR_MOD_LABEL_PARAM * lpModLabelParam);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock(LONG lPlayHandle, char *sPicFileName, DWORD dwTimeOut);
NET_DVR_API BOOL __stdcall NET_DVR_CapturePlaybackPictureBlock_New(LONG lPlayHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);
NET_DVR_API LONG __stdcall NET_DVR_FindPicture(LONG lUserID, NET_DVR_FIND_PICTURE_PARAM* pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture(LONG lFindHandle,LPNET_DVR_FIND_PICTURE lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V40(LONG lFindHandle,LPNET_DVR_FIND_PICTURE_V40 lpFindData);
NET_DVR_API LONG __stdcall NET_DVR_FindNextPicture_V50(LONG lFindHandle, LPNET_DVR_FIND_PICTURE_V50 lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseFindPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture(LONG lUserID,char *sDVRFileName,const char *sSavedFileName);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V30(LONG lUserID, char *sDVRFileName, char *sSavedFileBuf, DWORD dwBufLen, DWORD *lpdwRetLen);
NET_DVR_API BOOL __stdcall NET_DVR_GetPicture_V50(LONG lUserID, LPNET_DVR_PIC_PARAM lpPicParam);
NET_DVR_API LONG __stdcall NET_DVR_BackupPicture(LONG lUserID, NET_DVR_BACKUP_PICTURE_PARAM *lpBackupPicture);
NET_DVR_API LONG __stdcall NET_DVR_GetUpgradeStep(LONG lUpgradeHandle, LONG *pSubProgress);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetEncodeJoint(LONG lUserID, LONG lChannel, LPNET_DVR_ENCODE_JOINT_PARAM lpEncodeJoint);
NET_DVR_API BOOL  __stdcall NET_DVR_GetLocalIP(char strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL  __stdcall NET_DVR_SetValidIP(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetLocalIPv6(BYTE strIP[16][16], DWORD *pValidNum, BOOL *pEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_SetValidIPv6(DWORD dwIPIndex, BOOL bEnableBind);
NET_DVR_API BOOL __stdcall NET_DVR_GetVcaDevWorkState(LONG lUserID, LPNET_DVR_VCA_DEV_WORKSTATUS lpWorkState);
NET_DVR_API BOOL  __stdcall NET_DVR_SetRecvTimeOut(DWORD nRecvTimeOut = 5000); //��С3000����
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);              
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V40(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_VGA_DISP_CHAN_CFG_V40 lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_ShutterCompensation(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_CorrectDeadPixel(LONG lUserID, LONG lChannel, LPNET_DVR_CORRECT_DEADPIXEL_PARAM lpInParam);
NET_DVR_API BOOL __stdcall NET_DVR_CustomConfig(LONG lUserID, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricDataInfo(LONG lUserID, LONG lChannel, LPNET_DVR_HISTORICDATACFG lpHisData);
NET_DVR_API BOOL __stdcall NET_DVR_GetHistoricData(LONG lUserID, LONG lChannel, LPNET_DVR_PLATE_RESULT lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_ClearHistoricData(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_VPD_SetShutter(LONG lUserID, LONG lChannel, LPNET_VPD_SHUTTER lpShutter);
NET_DVR_API BOOL __stdcall NET_VPD_SendPicture(LONG lUserID, DWORD dwFields, BYTE const *sImageBuffer, DWORD dwWidth, DWORD dwHeight);
NET_DVR_API LONG  __stdcall NET_DVR_InquestUploadFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom,  char *sFileName);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestDeleteFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_FILES lpDeleteFile);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetPIPStatus_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestGetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL __stdcall NET_DVR_InquestSetPIPStatus_V40(LONG lUserID, NET_DVR_INQUEST_ROOM const *lpInquestRoom, LPNET_DVR_INQUEST_PIP_STATUS_V40 lpStatus);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSetSystemInfo(LONG lUserID, LPNET_DVR_INQUEST_SYSTEM_INFO lpSystemInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestSendMessage(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_MESSAGE lpInquestMessage);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStartCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bNotBurn);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopCDW_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, BOOL bCancelWrite);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetCDWState_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM lpInquestRoom, LPNET_DVR_INQUEST_CDRW_STATUS pStatus);
NET_DVR_API LONG  __stdcall NET_DVR_InquestResumeEvent(LONG lUserID, LPNET_DVR_INQUEST_RESUME_EVENT lpResumeEvent);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetResumeProgress(LONG lHandle, DWORD* pState);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestStopResume(LONG lHandle);
NET_DVR_API LONG  __stdcall NET_DVR_InquestFindFile_V30(LONG lUserID, LPNET_DVR_INQUEST_ROOM pInquestRoom);
NET_DVR_API BOOL  __stdcall NET_DVR_InquestGetDeviceVersion(LONG lUserID, LPNET_DVR_INQUEST_DEVICE_VERSION lpVersionInfo);
NET_DVR_API BOOL  __stdcall NET_DVR_SetSDKSecretKey(LONG lUserID, char *sSecretKey);
NET_DVR_API BOOL __stdcall NET_DVR_LockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockFileByTime(LONG lUserID, LPNET_DVR_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenZoomIn(LONG lUserID, LPNET_DVR_SCREENZOOM pStruScreen);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllCameraInfo(LONG lUserID, LPNET_DVR_MATRIX_CAMERALIST lpCamListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleCameraInfo(LONG lUserID, DWORD dwCameraId, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddCamera(LONG lUserID, DWORD dwCameraNum, BYTE *pBuffer, DWORD dwBufLength);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModCameraInfo(LONG lUserID, LPNET_MATRIX_CAMERAINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelCamera(LONG lUserID, DWORD dwCameraId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMonitorInfo(LONG lUserID, LPNET_DVR_MATRIX_MONITORLIST lpMonListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSingleMonitorInfo(LONG lUserID, DWORD dwMonitorId, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddMonitor(LONG lUserID, DWORD dwMonitorNum, BYTE *pBuffer, DWORD dwBufLength);            
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModMonitorInfo(LONG lUserID, LPNET_MATRIX_MONITORINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelMonitor(LONG lUserID, DWORD dwMonitorId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllMatrixInfo(LONG lUserID, LPNET_DVR_MATRIXLIST lpMatrixListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetSingleMatrixInfo(LONG lUserID, DWORD dwMatrixId, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AddMatrix(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_ModMatrixInfo(LONG lUserID, LPNET_MATRIX_MATRIXINFO lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelMatrix(LONG lUserID, DWORD dwMatrixId);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUartParam(LONG lUserID, DWORD dwSerialChan, LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetUartParam(LONG lUserID, DWORD dwSerialChan , LPNET_MATRIX_UARTPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUser(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserInfo(LONG lUserID, DWORD dwUserNum, LPNET_MATRIX_USERPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUser(LONG lUserID, DWORD dwUserNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModResourceInfo(LONG lUserID, DWORD dwResourceNum, LPNET_MATRIX_RESOURSEGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelResourceInfo(LONG lUserID, DWORD dwResourceNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModUserGroupInfo(LONG lUserID, DWORD dwUserGroupNum, LPNET_MATRIX_USERGROUPPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixDelUserGroup (LONG lUserID, DWORD dwUserGroupNum);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAllTrunkInfo(LONG lUserID, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetTrunkInfo(LONG lUserID, DWORD dwTrunkNum, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAddTrunk(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixModTrunkInfo(LONG lUserID, LPNET_MATRIX_TRUNKPARAM lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkCtrl(LONG lUserID, DWORD dwTrunkNum, BYTE byCtrlMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixTrunkStatusQuery(LONG lUserID, DWORD dwTrunkNum, BYTE *byTrunkStatus);

NET_DVR_API BOOL __stdcall NET_DVR_FindBackgroundPic(LONG lUserID, DWORD dwPicID, BYTE *pPicBuffer, DWORD *lpPicLen);
NET_DVR_API BOOL __stdcall NET_DVR_DetectImage(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_GetPictureModel(LONG lUserID, LPNET_VCA_REGISTER_PIC lpInBuf, LPNET_VCA_PICMODEL_RESULT lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_AddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API LONG __stdcall NET_DVR_FindBlackList(LONG lUserID, LPNET_VCA_BLACKLIST_COND lpBlackListCond);
NET_DVR_API LONG __stdcall NET_DVR_FindNextBlackList(LONG lFindHandle,LPNET_VCA_BLACKLIST_INFO lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindBlackListClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetBlackListPicture(LONG lUserID, DWORD dwRegisterID, LPNET_VCA_BLACKLIST_PIC lpOutBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateBlackList(LONG lUserID,LONG lChannel, LPNET_VCA_BLACKLIST_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_DelBlackList(LONG lUserID,LONG lChannel, DWORD dwRegisterID);
NET_DVR_API LONG __stdcall NET_DVR_FindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSnapPic(LONG lFindHandle,LPNET_VCA_SUB_SNAPPIC_DATA lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_FindSnapPicClose(LONG lFindHandle);
NET_DVR_API LONG __stdcall NET_DVR_AdvanceFindSnapPicture(LONG lUserID, LPNET_VCA_FIND_PICTURECOND_ADVANCE lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindFaceMatchAlarm(LONG lUserID, LPNET_VCA_FIND_PICTURECOND lpFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextFaceMatchAlarm(LONG lFindHandle, LPNET_VCA_FACESNAP_MATCH_ALARM_LOG lpFaceMatchAlarmLog);
NET_DVR_API BOOL __stdcall NET_DVR_FindFaceMatchAlarmClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetFaceMatchPic(LONG lUserID, LPNET_VCA_FACEMATCH_PICCOND lpMatchCond, LPNET_VCA_FACEMATCH_PICTURE lpMatchPic);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddBlackList(LONG lUserID,LONG lChannel,LPNET_VCA_BLACKLIST_FASTREGISTER_PARA lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetRemotePlay_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpVoutCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetDisplayCfg_V41(LONG lUserID, DWORD dwDispChanNum, LPNET_DVR_MATRIX_VOUTCFG lpDisplayCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDeviceStatus_V41(LONG lUserID, LPNET_DVR_DECODER_WORK_STATUS_V41 lpDecoderCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetSceneCfg(LONG lUserID, DWORD dwSceneNum, LPNET_DVR_MATRIX_SCENECFG lpSceneCfg);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSceneControl(LONG lUserID, DWORD dwSceneNum, DWORD dwCmd, DWORD dwCmdParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetCurrentSceneMode(LONG lUserID, DWORD *dwSceneNum);
NET_DVR_API BOOL __stdcall NET_DVR_GetAllValidWinInfo(LONG lUserID, LPNET_DVR_WINLIST lpWinListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenWinCtrl(LONG lUserID, DWORD dwWinIndex, DWORD dwCommand, LPNET_DVR_SCREEN_WINCFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenInputStatus(LONG lUserID, LPNET_DVR_SCREENINPUTSTATUS lpStatus);
NET_DVR_API LONG __stdcall NET_DVR_PicUpload(LONG lUserID, char const *sFileName, LPNET_DVR_PICTURECFG lpPictureCfg);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadProgress(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall  NET_DVR_CloseUploadHandle(LONG lUploadHandle);        
NET_DVR_API BOOL __stdcall NET_DVR_PicControl(LONG lUserID, BYTE byUseType, BYTE byPicIndex, BYTE byCtrlCmd);
NET_DVR_API LONG __stdcall NET_DVR_GetPicUploadState(LONG lUploadHandle);
NET_DVR_API BOOL __stdcall NET_DVR_ScreenCtrl(LONG lUserID, DWORD dwDeviceNum, LPNET_DVR_SCREEN_CONTROL lpStruScreenCtrl);
typedef void (CALLBACK *SCREENPICDATACB)(LONG nScreenPicHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_StartScreenPic(LONG nUserID, DWORD nInputNum, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopScreenPic(LONG nScreenPicHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FocusOnePush(LONG lUserID, LONG lChannel);
NET_DVR_API BOOL __stdcall NET_DVR_ResetLens(LONG lUserID, LONG lChannel);

typedef void(CALLBACK *fRemoteConfigCallback)(DWORD dwType, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_StartRemoteConfig(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferLen, fRemoteConfigCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopRemoteConfig(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetNextRemoteConfig(LONG lHandle, void* lpOutBuff, DWORD dwOutBuffSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetRemoteConfigState(LONG lHandle, void *pState);
NET_DVR_API BOOL __stdcall NET_DVR_SendRemoteConfig(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwBufSize);
NET_DVR_API LONG __stdcall NET_DVR_SendWithRecvRemoteConfig(LONG lHandle, void* lpInBuff, DWORD dwInBuffSize, void* lpOutBuff, DWORD dwOutBuffSize, DWORD *dwOutDataLen);

typedef void(CALLBACK *fLongCfgStateCallback)(LONG lHandle,  DWORD dwState, LPVOID pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseLongCfgHandle(LONG lHandle);
NET_DVR_API LONG __stdcall NET_DVR_RaidPullDiskStart(LONG lUserID, LONG lRaidID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_ScanRaidStart(LONG lUserID, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);
NET_DVR_API LONG __stdcall NET_DVR_SetAccessCameraInfo(LONG lUserID, DWORD dwChannel, LPNET_DVR_ACCESS_CAMERA_INFO lpCameraInfo, fLongCfgStateCallback cbStateCallback, LPVOID pUserData);

NET_DVR_API BOOL __stdcall NET_DVR_InquiryRecordTimeSpan(LONG lUserID, DWORD dwChannel,  NET_DVR_RECORD_TIME_SPAN_INQUIRY const *lpInquiry, LPNET_DVR_RECORD_TIME_SPAN lpResult);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateRecordIndex(LONG lUserID, DWORD dwChannel);
NET_DVR_API BOOL __stdcall NET_DVR_GetUpnpNatState(LONG lUserID, LPNET_DVR_UPNP_NAT_STATE lpState);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopPlanArray(LONG lUserID, DWORD dwArrayNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V30 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopPlanArray(LONG lUserID, DWORD dwArrayNum, NET_DVR_MATRIX_LOOP_DECINFO_V30 const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetAlarmShowMode(LONG lUserID, LPNET_DVR_ALARMMODECFG lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetAlarmShowMode(LONG lUserID, NET_DVR_ALARMMODECFG const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamicAssociateDecode(LONG lUserID, DWORD dwDecChanNum, NET_DVR_DYNAMICDECODE const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmTurn(LONG lUserID, DWORD dwDecChanNum, DWORD dwTurnParam);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixAlarmShowControl(LONG lUserID, DWORD dwDecChanNum, DWORD dwShowMode);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetPlanDecode(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PLANDECODE lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetPlanDecode(LONG lUserID, DWORD dwDecChanNum, NET_DVR_PLANDECODE const *lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_EX lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_EX(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_EX lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetTrunkListInfo(LONG lUserID, DWORD dwTrunkNum, DWORD dwStartTrunk, LPNET_DVR_MATRIX_TRUNKLIST lpTrunkListInfo, DWORD *pReturnSize);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetSubDecSystemJoinInfo_V41(LONG lUserID, LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemSetupAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSubSystemCloseAlarmChan(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostClearAlarm(LONG lUserID, DWORD dwSubSystemNum);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypass(LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostArrayBypassResume (LONG lUserID);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostSetReportMode(LONG lUserID, LONG lCenterNum, LPVOID lpInputBuf, DWORD dwInputBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_AlarmHostGetReportMode(LONG lUserID, LPVOID lpOutputBuf, DWORD dwOutputBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadAudio(LONG lUserID, DWORD dwAudioNum, DWORD dwAudioType, char const *sAudioFileName);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadAudio(LONG lUserID, DWORD dwAudioNum, char const *sAudioFileName);
NET_DVR_API BOOL __stdcall NET_DVR_StopAudioOperate(LONG lAudioHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetAudioProgress(LONG lAudioHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AudioCtrl(LONG lUserID, DWORD dwAudioNum, DWORD dwCtrlParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfig(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpInParamBuffer, DWORD dwInParamBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_LockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_UnlockStreamFileByTime(LONG lUserID, LPNET_DVR_STREAM_TIME_LOCK lpLockPara, LPNET_DVR_LOCK_RETURN lpLockReturn);
NET_DVR_API BOOL __stdcall NET_DVR_StartManualRecord(LONG lUserID, LPNET_DVR_MANUAL_RECORD_PARA lpManualRecPara);
NET_DVR_API BOOL __stdcall NET_DVR_StopManualRecord(LONG lUserID, LPNET_DVR_STREAM_INFO pIDInfo);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByName(LONG lUserID, char *sPlayBackFileName, HWND hWnd);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V40(LONG lUserID, NET_DVR_VOD_PARA const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackByTime_V50(LONG lUserID, NET_DVR_VOD_PARA_V50 const* pVodPara);
NET_DVR_API LONG __stdcall NET_DVR_PlayBackReverseByTime_V40(LONG lUserID, HWND hWnd, LPNET_DVR_PLAYCOND pPlayCond);
NET_DVR_API LONG __stdcall NET_DVR_GetFileByTime_V40(LONG lUserID, char *sSavedFileName, LPNET_DVR_PLAYCOND  pDownloadCond);
NET_DVR_API LONG __stdcall NET_DVR_FindFile_V40(LONG lUserID, LPNET_DVR_FILECOND_V40 pFindCond);
NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V41(LONG lUserID, LPNET_DVR_SETUPALARM_PARAM lpSetupParam);
NET_DVR_API BOOL __stdcall NET_DVR_AddDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindDataBase(LONG lUserID, LPNET_VCA_FIND_DATABASE_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_FindNextDataBase(LONG lFindHandle, LPNET_VCA_DATABASE_PARAM lpOutBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FindDataBaseClose(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateDataBase(LONG lUserID, LPNET_VCA_DATABASE_PARAM lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteDataBase(LONG lUserID, LPNET_VCA_DELETE_DATABASE_COND lpCond);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_InquireSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_INQUIRE_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireSnapDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteSnapDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_SNAPRECORD_COND lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_SearchSnapDB(LONG lUserID, LPNET_VCA_SEARCH_SNAPDB_COND lpInBuf, fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchSnapDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_AddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_FastAddFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_FAST_DATARECORD_INFO lpInBuf);
NET_DVR_API LONG __stdcall NET_DVR_InquireFaceDBRecord(LONG lUserID, LPNET_VCA_DATARECORD_COND lpInBuf,fSearchDBCallBack cbInquireDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetInquireFaceDBProgress(LONG lInquireHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_UpdateFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DATARECORD_INFO lpInBuf);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteFaceDBRecord(LONG lUserID, DWORD dwDataBaseID, LPNET_VCA_DELETE_RECORD_COND lpInBuf);
typedef void(CALLBACK *fSearchDBCallBack)(LONG lSearchHandle, DWORD dwType, DWORD dwResultNum, BYTE* pBuffer, DWORD dwBufSize,void *pUser);
NET_DVR_API LONG __stdcall NET_DVR_SearchFaceDB(LONG lUserID, LPNET_VCA_SEARCH_FACEDB_COND lpInBuf,fSearchDBCallBack cbSearchDBCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_GetSearchFaceDBProgress(LONG lSearchHandle, DWORD* pState);
NET_DVR_API BOOL __stdcall NET_DVR_StopSearchDB(LONG lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_FindMatchPicture(LONG lUserID, LPNET_VCA_FIND_MATCHPIC_COND lpFindCond, LPNET_VCA_FIND_MATCHPIC_RESULT lpFindResult);
NET_DVR_API BOOL __stdcall NET_DVR_RemoteControl(LONG lUserID, DWORD dwCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetBMPByTime(LONG lUserID, LONG lChannel, NET_DVR_TIME const *lpTime, char const *sFilename);
NET_DVR_API BOOL __stdcall NET_DVR_CommandDevice(LONG lUserID, DWORD dwOutCommand, LPVOID lpInBuffer, DWORD dwInBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_TestDVRAlive(LONG lUserID);

NET_DVR_API BOOL __stdcall NET_DVR_PicViewRequest(LONG lUserID, NET_DVR_PIC_VIEW_PARAM *lpPicViewParam);
typedef LONG (CALLBACK *PicViewCallBack)(LPNET_DVR_PICVIEW_CALLBACKPARAM pStruPicViewParam, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewResponseCallBack(PicViewCallBack fPicViewResponseCallBack, void *pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetPicViewDataCallBack(LONG lPicViewHandle, SCREENPICDATACB fPicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDevList(LONG lUserID, LPNET_DVR_DEVLIST lpDevListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_GetScreenList(LONG lUserID, LPNET_DVR_SCREENLIST lpScreenListInfo);
NET_DVR_API BOOL __stdcall NET_DVR_SetScreenRelation(LONG lUserID, NET_DVR_DISP_SCREEN const* lpScreenInfo);
NET_DVR_API BOOL __stdcall NET_DVR_TextShowCtrl(LONG lUserID, DWORD dwDeviceIndex, LPNET_DVR_TEXTSHOW lpText);
NET_DVR_API LONG __stdcall NET_DVR_StartUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, DVCS_UPGRADESTATE_CB UpgradeStateCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_StopUpgrade(LONG lUserID, LPNET_DVR_OPERATE_DEVICE lpStruOperate, LONG lUpgradeHandle);
NET_DVR_API BOOL __stdcall NET_DVR_AddNetSignal(LONG lUserID, LPNET_DVR_NETSIGNAL_INFO lpStruSignal, void* lpOutBuf , DWORD dwBufLen);
NET_DVR_API LONG __stdcall NET_DVR_StartPicPreview(LONG lUserID, NET_DVR_START_PIC_VIEW_INFO const* lpStruStartPicView, SCREENPICDATACB PicDataCallback, void *pUserData);
NET_DVR_API BOOL __stdcall NET_DVR_GetDeviceStatus(LONG lUserID, DWORD dwCommand, DWORD dwCount, LPVOID lpInBuffer, DWORD dwInBufferSize, LPVOID lpStatusList, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetPlanList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_PLAN_LIST lpPlanList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);
NET_DVR_API BOOL __stdcall NET_DVR_GetInputSignalList_V40(LONG lUserID, DWORD dwDevNum, LPNET_DVR_INPUT_SIGNAL_LIST lpInputSignalList);

NET_DVR_API LONG __stdcall NET_DVR_UploadFile(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char* sFileName);
NET_DVR_API LONG __stdcall NET_DVR_UploadFile_V40(LONG lUserID, DWORD dwUploadType, LPVOID lpInBuffer, DWORD dwInBufferSize, char const * sFileName, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadState(LONG lUploadHandle, LPDWORD pProgress);
NET_DVR_API BOOL __stdcall NET_DVR_GetUploadResult(LONG lUploadHandle, LPVOID lpOutBuffer, DWORD dwOutBufferSize);
NET_DVR_API BOOL __stdcall NET_DVR_UploadClose(LONG lUploadHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartUploadFile(LONG lUserID, LPNET_DVR_UPLOAD_PARAM  lpStruUploadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetUploadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopUploadFile (LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_StartDownloadFile(LONG lUserID, LPNET_DVR_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileProgress(LONG lFileHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadFileState(LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownloadFile (LONG lFileHandle);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadControl(LONG lDownloadHandle, NET_SDK_DOWNLOAD_CONTROL_TYPE_ENUM enumDownloadType, void* lpInBuffer, DWORD dwInBufferLen, void* lpOutBuffer, DWORD dwOutBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_UploadSend(LONG lUploadHandle, const NET_DVR_SEND_PARAM_IN *pstruSendParamIN, void* lpOutBuffer);


NET_DVR_API BOOL __stdcall NET_DVR_GetMobileDevStatus(LONG lUserID, DWORD dwStatusType, LPNET_DVR_MB_MOBILEDEV_STATUS lpstruMobileDevStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SetVoiceDataCallBack(LONG lVoiceComHandle, BOOL bNeedCBNoEncData, void(CALLBACK *fVoiceDataCallBack)(LONG lVoiceComHandle, char *pRecvDataBuffer, DWORD dwBufSize, BYTE byAudioFlag, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize);
NET_DVR_API BOOL __stdcall NET_DVR_GetTransparentParam(LONG lUserID, char *sInBuffer, DWORD dwInSize, char *sOutBuffer, DWORD dwOutSize);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalConfig(LPNET_DVR_SDKLOCAL_CFG lpSdkLocalCfg);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, const void *lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_GetSDKLocalCfg(NET_SDK_LOCAL_CFG_TYPE enumType, void* lpOutBuff);

NET_DVR_API LONG __stdcall NET_DVR_OpticalUpgrade(LONG lUserID, char const *sFileName, LPNET_DVR_OPTICAL_INFO lpOpticalInfo);
typedef void(CALLBACK *fGPSDataCallback)(LONG nHandle, DWORD dwState, void* lpBuffer, DWORD dwBufLen, void* pUserData);
NET_DVR_API LONG __stdcall NET_DVR_GetVehicleGpsInfo(LONG nUserID, LPNET_DVR_GET_GPS_DATA_PARAM lpGPSDataParam, fGPSDataCallback cbGPSDataCallback, void* pUser);

NET_DVR_API BOOL __stdcall NET_DVR_ClosePreview(LONG lUserID, DWORD nSessionID);
NET_DVR_API BOOL __stdcall NET_DVR_ClosePlayBack(LONG lUserID, DWORD nSessionID);
NET_DVR_API LONG __stdcall NET_DVR_RealPlay_V40(LONG lUserID, LPNET_DVR_PREVIEWINFO lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);
NET_DVR_API LONG __stdcall NET_DVR_RealPlaySpecial(LONG lUserID, LPNET_DVR_PREVIEWINFO_SPECIAL lpPreviewInfo, REALDATACALLBACK fRealDataCallBack_V30 = NULL, void* pUser = NULL);

NET_DVR_API LONG __stdcall NET_DVR_StartDownload(LONG lUserID, DWORD dwDownloadType, LPVOID lpInBuffer, DWORD dwInBufferSize, const char *sFileName);
NET_DVR_API LONG __stdcall NET_DVR_GetDownloadState(LONG lDownloadHandle, LPDWORD pProgress);
NET_DVR_API int  __stdcall NET_DVR_GetDownloadStateInfo(LONG lDownloadHandle, void* pStatusInfo);
NET_DVR_API BOOL __stdcall NET_DVR_StopDownload(LONG lHandle);

NET_DVR_API BOOL __stdcall NET_DVR_MatrixStartDynamic_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_PU_STREAM_CFG_V41 lpDynamicInfo);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpOuter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixSetLoopDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_LOOP_DECINFO_V41 lpInter);
NET_DVR_API BOOL __stdcall NET_DVR_MatrixGetDecChanInfo_V41(LONG lUserID, DWORD dwDecChanNum, LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41 lpOuter);

NET_DVR_API LONG __stdcall NET_DVR_StartT1Test(LONG lUserID, LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM lpStruDownloadParam);
NET_DVR_API BOOL __stdcall NET_DVR_StopTT1Test(BOOL lHandle);
NET_DVR_API BOOL __stdcall NET_DVR_GetT1TestStatus(LONG lHandle, LONG *pStatus);
NET_DVR_API BOOL __stdcall NET_DVR_SendT1TestData(LONG lHandle, DWORD dwDataType, char *pSendBuf, DWORD dwSendBufLen);

NET_DVR_API BOOL __stdcall NET_DVR_UploadLogo_NEW(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer);
NET_DVR_API BOOL __stdcall NET_DVR_DownloadLogo(LONG lUserID, DWORD dwLogoNo, LPNET_DVR_MATRIX_LOGO_INFO lpLogoInfo, char *sLogoBuffer, DWORD dwLogoBufferSize);
NET_DVR_API LONG __stdcall NET_DVR_StartPassiveTransCode(LONG lUserID, NET_DVR_STREAM_INFO const *pStreamInfo, NET_DVR_COMPRESSIONCFG_V30 const *pDstTransInfo, NET_DVR_PASSIVETRANSINFO const *pPassiveTransInfo, void(CALLBACK *fTransCodeDataCallBack) (LONG lPassiveHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, void* pUser) = NULL, void* pUser = NULL);
NET_DVR_API BOOL __stdcall NET_DVR_TransCodeInputData(LONG lPassiveHandle, BYTE *pBuffer, DWORD dwBufSize);
NET_DVR_API BOOL __stdcall NET_DVR_StopPassiveTransCode(LONG lPassiveHandle);
NET_DVR_API LONG __stdcall NET_DVR_GetPassiveTransChanNum(LONG lPassiveHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetDeviceConfigEx(LONG lUserID, DWORD dwCommand, DWORD dwCount, NET_DVR_IN_PARAM *lpInParam, NET_DVR_OUT_PARAM *lpOutParam);

NET_DVR_API BOOL __stdcall NET_DVR_GetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_SetSTDConfig(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONFIG lpConfigParam);
NET_DVR_API BOOL __stdcall NET_DVR_GetSTDAbility(LONG lUserID, DWORD dwAbilityType, LPNET_DVR_STD_ABILITY  lpAbilityParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDControl(LONG lUserID, DWORD dwCommand, LPNET_DVR_STD_CONTROL lpControlParam);
NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V40(DWORD lUserID, DWORD dwUpgradeType, char const *sFileName, void *pInbuffer, DWORD dwBufferLen);
NET_DVR_API LONG __stdcall NET_DVR_Upgrade_V50(DWORD lUserID, LPNET_DVR_UPGRADE_PARAM lpUpgradeParam);

NET_DVR_API BOOL __stdcall NET_DVR_DetectImage_V50(LONG lUserID, LPNET_VCA_FD_PROCIMG_CFG lpFDProcImg,LPNET_VCA_FD_PROCIMG_RESULT_V50 lpOutBuf);

NET_DVR_API LONG __stdcall NET_DVR_SmartSearchPicture(LONG lUserID, NET_DVR_SMART_SEARCH_PIC_PARA * pFindParam);
NET_DVR_API LONG __stdcall NET_DVR_FindNextSmartPicture(LONG lFindHandle,LPNET_DVR_SMART_SEARCH_PIC_RET lpFindData);
NET_DVR_API BOOL __stdcall NET_DVR_CloseSmartSearchPicture(LONG lFindHandle);
NET_DVR_API BOOL __stdcall NET_DVR_SetESCallBack(LONG iRealHandle, void (__stdcall *fnESCallback)(LONG lPreviewHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize,  void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_SetESRealPlayCallBack(LONG iRealHandle, void(__stdcall *fPlayESCallBack)(LONG lPreviewHandle, NET_DVR_PACKET_INFO_EX *pstruPackInfo, void* pUser), void* pUser);
NET_DVR_API BOOL __stdcall NET_DVR_ActivateDevice(char* sDVRIP, WORD wDVRPort, LPNET_DVR_ACTIVATECFG    lpActivateCfg);
NET_DVR_API BOOL __stdcall NET_DVR_GetAddrInfoByServer(DWORD     dwQueryType, void* pInBuf, DWORD dwInBufLen, void* pOutBuf, DWORD dwOutBufLen);
NET_DVR_API BOOL __stdcall NET_DVR_StartGetDevState(LPNET_DVR_CHECK_DEV_STATE pParams);
NET_DVR_API BOOL __stdcall NET_DVR_StopGetDevState();
NET_DVR_API BOOL __stdcall NET_DVR_RigisterPlayBackDrawFun(LONG lPlayHandle, void (__stdcall *fDrawFun)(LONG lPlayHandle, HDC hDc, DWORD dwUser), DWORD dwUser);

NET_DVR_API BOOL __stdcall NET_DVR_SetSDKInitCfg(NET_SDK_INIT_CFG_TYPE enumType, void* const lpInBuff);
NET_DVR_API BOOL __stdcall NET_DVR_ReleaseSDKMemPool(LPNET_DVR_SDKMEMPOOL_CFG lpSdkMemPoolCfg);

NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock(LONG iRealHandle, char const *sPicFileName, DWORD dwTimeOut);


NET_DVR_API BOOL __stdcall NET_DVR_CapturePictureBlock_New(LONG iRealHandle, char *pPicBuf, DWORD dwPicSize, DWORD *lpSizeReturned);

NET_DVR_API BOOL __stdcall NET_DVR_ChangeWndResolution(LONG iRealHandle);

NET_DVR_API LONG __stdcall  NET_DVR_SDKChannelToISAPI(LONG lUserID, LONG lInChannel, BOOL bSDKToISAPI);

NET_DVR_API BOOL __stdcall NET_DVR_STDXMLConfig_Conv(LONG lUserID, NET_DVR_XML_CONFIG_INPUT* lpInputParam, NET_DVR_XML_CONFIG_OUTPUT* lpOutputParam);

NET_DVR_API LONG __stdcall NET_DVR_SetupAlarmChan_V50(LONG iUserID, LPNET_DVR_SETUPALARM_PARAM_V50 lpSetupParam, char *pSub, DWORD dwSubSize);

NET_DVR_API BOOL __stdcall NET_DVR_GetAlarmSubscribe(LONG lAlarmHandle, char *pData, DWORD dwDataLen);

NET_DVR_API BOOL __stdcall NET_DVR_SetAlarmSubscribe(LONG lAlarmHandle, char *pData, DWORD dwDataLen);

NET_DVR_API BOOL __stdcall NET_DVR_GetNPQStat(LONG lHandle, NET_SDK_NPQ_STATE* pStruStat);

NET_DVR_API BOOL __stdcall NET_DVR_SetNPQNotifyParam(LONG lHandle, NET_SDK_NPQ_NOTIFY_PARAM* pNotifyParam);

NET_DVR_API BOOL __stdcall NET_DVR_PlaybackGetNPQStat(LONG lHandle, NET_SDK_NPQ_STATE* pStruStat);
NET_DVR_API BOOL __stdcall NET_DVR_RenderPrivateData(LONG lRealHandle, int iIntelType,  BOOL bTrue);
NET_DVR_API BOOL __stdcall NET_DVR_RenderPrivateDataEx(LONG lRealHandle, int iIntelType, int iSubType, BOOL bTrue);

NET_DVR_API BOOL __stdcall NET_DVR_PlaybackSetNPQNotifyParam(LONG lHandle, NET_SDK_NPQ_NOTIFY_PARAM* pNotifyParam);

NET_DVR_API BOOL __stdcall NET_DVR_EnableRelogon(BOOL bEnable, DWORD dwReserved);

NET_DVR_API LONG __stdcall NET_DVR_CreateEzvizUser(LPNET_DVR_EZVIZ_USER_LOGIN_INFO pLoginInfo, LPNET_DVR_DEVICEINFO_V30 pDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteEzvizUser(LONG iUserID);

NET_DVR_API LONG __stdcall NET_DVR_CreateOpenEzvizUser(LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO pLoginInfo, LPNET_DVR_DEVICEINFO_V40 pDeviceInfo);
NET_DVR_API BOOL __stdcall NET_DVR_DeleteOpenEzvizUser(LONG iUserID);

NET_DVR_API BOOL __stdcall NET_DVR_LoadAdditionalLib(ADDITIONAL_LIB libType, char const *sDllName);

#endif //

