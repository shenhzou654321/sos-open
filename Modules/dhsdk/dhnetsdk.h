#ifndef DHNETSDK_H
#define DHNETSDK_H

#if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
    #include <windows.h>
    #ifdef NETSDK_EXPORTS
        #define CLIENT_NET_API  __declspec(dllexport)
    #else
        #define CLIENT_NET_API  __declspec(dllimport)
    #endif

    #define CALLBACK        __stdcall
    #define CALL_METHOD     __stdcall  //__cdecl

    #define INT64           __int64
    #define TP_U64          unsigned __int64

    #ifndef LLONG
        #ifdef _WIN64
            #define LLONG   INT64
        #else 
            #define LLONG   LONG
        #endif
    #endif

    #ifndef LDWORD
        #ifdef _WIN64
            #define LDWORD  INT64
        #else 
            #define LDWORD  DWORD
        #endif
    #endif
#else    //non-windows
    #define CLIENT_NET_API  extern "C"
    #define CALL_METHOD 
    #define CALLBACK

    #ifndef INTERNAL_COMPILE
        #define RELEASE_HEADER
    #endif
 
    #ifdef RELEASE_HEADER
        #define WORD        unsigned short
        #define DWORD       unsigned int
        #define LONG        int
        #define LPDWORD     DWORD*

        #ifdef __OBJC__
            #include "objc/objc.h"
        #else
            #define BOOL    int
        #endif

        #ifndef TRUE
        #define TRUE        1
        #endif

        #ifndef FALSE
        #define FALSE       0
        #endif
        #define BYTE        unsigned char
        #define UINT        unsigned int
        #define HDC         void*
        #define HWND        void*
        #define LPVOID      void*

        #ifndef NULL
        #define NULL        0
        #endif

        #define LLONG       long
        #define INT64       long long
        #define TP_U64      unsigned long long
        #define LDWORD      long 

        #ifndef MAX_PATH
        #define MAX_PATH    260
        #endif

        #ifndef DEF_RECT
        typedef struct  tagRECT
        {
            LONG left;
            LONG top;
            LONG right;
            LONG bottom;
        } RECT;
        #define DEF_RECT
        #endif
    #else    //内部编译
        #include "../Platform/osIndependent.h"
        #define INT64       int64
        #define TP_U64      uint64
    #endif // RELEASE_HEADER
#endif // linux

#ifndef LDWORD
    #if (defined(WIN32) || defined(_WIN32) || defined(_WIN64))
        #ifdef _WIN64
            #define LDWORD  __int64
        #else //WIN32 
            #define LDWORD  DWORD
        #endif
    #else    //linux
        #define LDWORD      long 
    #endif
#endif


#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
 ** 常量定义
 ***********************************************************************/
#define DH_SERIALNO_LEN                   48               // 设备序列号字符长度
#define DH_MAX_DISKNUM                    256              // 最大硬盘个数
#define DH_MAX_SDCARDNUM                  32               // 最大SD卡个数
#define DH_MAX_BURNING_DEV_NUM            32               // 最大刻录设备个数
#define DH_BURNING_DEV_NAMELEN            32               // 刻录设备名字最大长度
#define DH_MAX_LINK                       6                
#define DH_MAX_CHANNUM                    16               // 最大通道个数
#define DH_MAX_DECODER_CHANNUM            64               // 解码器最大通道数
#define DH_MAX_ALARMIN                    128              // 最大报警输入个数
#define DH_MAX_ALARMOUT                   64               // 最大报警输出个数
#define DH_MAX_RIGHT_NUM                  100              // 用户权限个数上限
#define DH_MAX_GROUP_NUM                  20               // 用户组个数上限
#define DH_MAX_USER_NUM                   200              // 用户个数上限
#define DH_RIGHT_NAME_LENGTH              32               // 权限名长度
#define DH_USER_NAME_LENGTH               8                // 用户名长度
#define DH_USER_PSW_LENGTH                8                // 用户密码长度
#define DH_CUSTOM_NAME_LENGTH             32               // 自定义名称长度
#define DH_USER_NAME_LEN_EX               32               // 用户名长度,用于新平台扩展
#define DH_USER_PSW_LEN_EX                32               // 用户密码长度,用于新平台扩展
#define DH_MEMO_LENGTH                    32               // 备注长度
#define DH_MAX_STRING_LEN                 128              
#define MAX_STRING_LINE_LEN               6                // 最多六行
#define MAX_PER_STRING_LEN                20               // 每行最大长度
#define DH_MAX_MAIL_NAME_LEN              64               // 新的邮件结构体支持的用户名长度
#define DH_MAX_MAIL_PSW_LEN               64               // 新的邮件结构体支持的密码长度
#define DH_SPEEDLIMIT_TYPE_LEN            32               // 限速类型字符串长度
#define DH_VEHICLE_TYPE_LEN               32               // 车载自定义信息类型字符串长度
#define DH_VEHICLE_INFO_LEN               32               // 车载自定义信息字符串长度
#define DH_VEHICLE_DRIVERNO_LEN           32               // 车载自定义信息司机工号字符串长度
#define DH_MAX_CROSSING_NUM               128              // 最大点位
#define DH_MAX_CROSSING_ID                32               // 路口序列号最大长度
#define DH_MAX_CARD_INFO_LEN              256              // 卡号信息最大长度
#define DH_MAX_CHANNUM_EX                 32               // 最大通道数扩展  
#define DH_MAX_SAERCH_IP_NUM              256              // 最大搜索IP个数
#define DH_MAX_HARDDISK_TYPE_LEN          32               // 硬盘型号最大长度
#define DH_MAX_HARDDISK_SERIAL_LEN        32               // 硬盘序列号最大长度
#define DH_MAX_SIM_LEN                    16               // SIM卡的值的最大长度
#define DH_MAX_SIM_NUM                    10               // 车载SIM卡最大个数
#define DH_MAX_VERSION_LEN                32               // 软件版本号最大长度
#define DH_MAX_MDN_LEN                    36               // MDN的值的最大长度
#define DH_MAX_NETINTERFACE_NUM           64               // 支持的网卡个数
#define DH_EVENT_NAME_LEN                 128              // 事件名称长度
#define DH_STORAGE_NAME_LEN               128              // 存储设备名称长度
#define DH_MAX_CARPORTLIGHT_NUM           4                // 最大车位灯个数
#define DH_STATION_NAME_LEN               32               // 车站站点名称长度   
#define PTZ_PRESET_NAME_LEN               64               // 云台预置点名称长度
#define DH_MAX_GUARD_DETECT_ID_COUNT      64               // 最大的岗亭检测ID个数
#define DH_MAX_VERSION_STR                64               // 版本字符串最大长度
#define DH_MAX_AUDIO_MATRIX_OUTPUT        8                // 每个音频矩阵支持的最大输出通道数
#define DH_MAX_CHANNEL_COUNT              16               // 支持最大通道数叠加
#define DH_COMMON_STRING_4                4                // 通用字符串长度4
#define DH_COMMON_STRING_8                8                // 通用字符串长度8
#define DH_COMMON_STRING_16               16               // 通用字符串长度16
#define DH_COMMON_STRING_32               32               // 通用字符串长度32
#define DH_COMMON_STRING_36               36               // 通用字符串长度36
#define DH_COMMON_STRING_64               64               // 通用字符串长度64
#define DH_COMMON_STRING_128              128              // 通用字符串长度128
#define DH_COMMON_STRING_256              256              // 通用字符串长度256
#define DH_COMMON_STRING_512              512              // 通用字符串长度512
#define DH_COMMON_STRING_1024             1024             // 通用字符串长度1024
#define DH_COMMON_STRING_2048             2048             // 通用字符串长度2048
#define DH_MAX_ACCESS_NAME_LEN            64               // 门禁名称长度
#define DH_MAX_EXALARMCHANNEL_NAME_LEN    128              // 扩展模块报警通道名称长度
#define DH_MAX_ALARM_SUBSYSTEM_NUM        256              // 最大报警子系统个数
#define DH_MAX_BELL_NUM                   4                // 最大警号个数
#define DH_MAX_KEYBOARD_NUM               256              // 最大键盘数
#define MAX_GOURP_NUM                     128              // 人脸库最大个数
#define MAX_PWD_MODIFIEDTIME_LEN          20               // 密码修改时间最大长度	
#define MAX_ONVIF_USER_NUM                20               // Onvif用户上限个数
#define DH_MAX_POS_EXCHANGE_INFO          64               // 每次查询POS交易信息时,交易信息数组的最大值
#define NET_INTERFACE_DEFAULT_TIMEOUT     3000             // 接口默认超时时间
#define DH_MAX_BUSCARD_NUM                64               // 公交卡号最大长度
#define DH_MAX_POS_MAC_NUM                8                // 刷卡机Mac码最大长度
#define DH_MAX_MARK_FILE_NAME_LEN         124              // 录像控制文件名最大长度
#define NET_MAX_ATTACHMENT_NUM            8                // 最大车辆物件数量
#define NET_MAX_ANNUUALINSPECTION_NUM     8                // 最大年检标识位置
#define NET_MAX_EVENT_PIC_NUM             6                // 最大原始图片张数
#define NET_MAX_MONTH_NUM                 31               // 最大月份个数
#define NET_IPADDRSTR_LEN                 46               // IP地址字符串长度 支持 ipv4-mapped-on-ipv6 
#define NET_MAX_AP_NUM                    3                // 最大AP个数
#define MAX_WEP_KEY_NUM                   4                // 最大WEP密码个数
#define MAX_CARNO_LEN                     20               // 最大车辆号长度
#define MAX_COACHNO_LEN                   12               // 最大车厢号长度
#define MAX_WORKPATTERN_NUM               2                // 最大工作模式个数
#define MAX_NETPORT_NUM                   5                // 最大网口个数
#define MAX_ANTIFLICKERMODE_COUNT         8                // 最大防闪烁模式最大个数
#define MAX_CATEGORY_LEN                  64               // 最大物体类型长度
#define MAX_DANGER_GRADE_NUM			  8				   // 最大包裹危险等级个数
#define MAX_INSIDE_OBJECT_TYPE_NUM		  32			   // 最大包裹中物品类型个数
#define MAX_PATH_LEN					  260			   // 最大路径长度	
#define MAX_XRAY_CHANNEL_NUM			  10			   // 最大X光检各类包裹数量统计信息的通道个数
#define MAX_HISTORY_TEMPERATURE_NUM		  64		       // 最大历史温度值的个数
#define MAX_TEMPERATURE_POINT_NUM		  8				   // 最大监测温度点的个数
#define MAX_GROUP_LEN					  128			   // 最大的组名长度
#define MAX_ILLEGAL_LOGIN_IP_LEN		  40			   // 最大的非法登陆IP长度
#define DH_COMMON_STRING_20    		      20			   // 通用字符串长度20
#define MAX_EVENT_ID_LEN				  52               // 国标事件ID最大长度
#define MAX_HUMANTRAIT_EVENT_LEN          36               // 补充人体特征上报事件最大长度
#define DH_COMMON_STRING_24               24               // 通用字符串长度24
#define MAX_TEMPERATUREEX_POINT_NUM		  12			   // 最大监测温度点的个数
#define MAX_PIRPARAM_NUM                  10               // 最大pir配置的数组个数
#define MAX_ENCRYPT_SYSTEM_INFO_CONTENT_LEN		  8192	   // 加密系统信息内容的最大长度
#define MAX_LOCAL_EXT_ALARM_NAME_LEN	  64			   // 最大报警盒子的报警通道名称长度
#define MAX_TASK_ID_LEN					  64			   // 最大的任务ID长度
#define MAX_FILE_PATH_LEN				  256			   // 最大的图片路径长度
#define MAX_IMAGE_INFO_NUM				  8				   // 最大的图片信息个数
#define MAX_DIAL_RESULT_LEN				  2048			   // 最大的分析结果字符串长度
#define MAX_COUNTRY_CODE_LEN			  4				   // 最大的国家代号长度
#define MAX_PROVINCE_CODE_LEN			  64			   // 最大的省份代号长度
#define MAX_CITY_CODE_LEN				  64			   // 最大的城市代号长度
#define MAX_AREA_CODE_LEN				  64			   // 最大的区域代号长度
#define MAX_REQ_INFO_LEN				  1600			   // 最大的请求文件长度
#define MAX_SIP_SVR_ID_LEN				  24			   // 最大的SIP服务器ID长度
#define MAX_SIP_DOMAIN_LEN				  128			   // 最大的SIP域长度
#define MAX_SIP_SVR_IP_LEN				  128			   // 最大的SIP服务器IP长度
#define MAX_SIP_SERVER_DEVICE_ID_LEN	  24			   // 最大的设备编号长度
#define MAX_REG_PASSWORD_LEN			  24			   // 最大的注册密码长度
#define MAX_CIVIL_CODE_LEN				  24			   // 最大的行政区划代码长度
#define MAX_INTERVIDEO_ID_LEN			  24			   // 最大的接入模块识别码长度
#define	MAX_CHANNEL_ID_LEN				  24			   // 最大的通道编号长度
#define MAX_SIP_SERVER_NUM				  5				   // 最大的SIP服务器信息个数
#define	MAX_GB28181_PROTOCOL_VERSION	  16			   // 最大的GB28181协议版本长度
#define DH_MAX_FACEDETECT_FEATURE_NUM	  32               // 人脸特征最大个数
#define MAX_ATTACHMENT_NUM				  8				   // 最大车内物品个数
#define MAX_ERRORCODE_NUM                 512              // 最大错误码个数
#define MAX_PUSH_STREAM_AUTH_SSID		  80			   // 设备推流鉴权ID最大长度

// 远程配置结构体相关常量                 
#define DH_MAX_MAIL_ADDR_LEN              128              // 邮件发(收)地址最大长度
#define DH_MAX_MAIL_SUBJECT_LEN           64               // 邮件主题最大长度
#define DH_MAX_IPADDR_LEN                 16               // IP地址字符串长度
#define DH_MAX_IPADDR_LEN_EX              40               // 扩展IP地址字符串长度, 支持IPV6
#define DH_MACADDR_LEN                    40               // MAC地址字符串长度
#define DH_MAX_URL_LEN                    128              // URL字符串长度
#define DH_MAX_DEV_ID_LEN                 48               // 机器编号最大长度
#define DH_MAX_HOST_NAMELEN               64               // 主机名长度,
#define DH_MAX_HOST_PSWLEN                32               // 密码长度
#define DH_MAX_NAME_LEN                   16               // 通用名字字符串长度
#define DH_MAX_ETHERNET_NUM               2                // 以太网口最大个数
#define DH_MAX_ETHERNET_NUM_EX            10               // 扩展以太网口最大个数
#define DH_DEV_SERIALNO_LEN               48               // 序列号字符串长度
#define DH_DEV_CLASS_LEN                  16               // 设备类型字符串（如"IPC"）长度
#define DH_DEV_TYPE_LEN                   32               // 设备型号字符串（如"IPC-F725"）长度
#define DH_N_WEEKS                        7                // 一周的天数    
#define DH_N_TSECT                        6                // 通用时间段个数
#define DH_N_REC_TSECT                    6                // 录像时间段个数
#define DH_N_COL_TSECT                    2                // 颜色时间段个数    
#define DH_CHAN_NAME_LEN                  32               // 通道名长度,DVR DSP能力限制,最多32字节        
#define DH_N_ENCODE_AUX                   3                // 扩展码流个数    
#define DH_N_TALK                         1                // 最多对讲通道个数
#define DH_N_COVERS                       1                // 遮挡区域个数    
#define DH_N_CHANNEL                      16               // 最大通道个数    
#define DH_N_ALARM_TSECT                  2                // 报警提示时间段个数
#define DH_MAX_ALARMOUT_NUM               16               // 报警输出口个数上限
#define DH_MAX_AUDIO_IN_NUM               16               // 音频输入口个数上限
#define DH_MAX_VIDEO_IN_NUM               16               // 视频输入口个数上限
#define DH_MAX_ALARM_IN_NUM               16               // 报警输入口个数上限
#define DH_MAX_DISK_NUM                   16               // 硬盘个数上限,暂定为16
#define DH_MAX_DECODER_NUM                16               // 解码器(485)个数上限    
#define DH_MAX_232FUNCS                   10               // 232串口功能个数上限
#define DH_MAX_232_NUM                    2                // 232串口个数上限
#define DH_MAX_232_NUM_EX                 16               // 扩展串口配置个数上限          
#define DH_MAX_DECPRO_LIST_SIZE           100              // 解码器协议列表个数上限
#define DH_FTP_MAXDIRLEN                  240              // FTP文件目录最大长度
#define DH_MATRIX_MAXOUT                  16               // 矩阵输出口最大个数                                             
#define DH_TOUR_GROUP_NUM                 6                // 矩阵输出组最大个数
#define DH_MAX_DDNS_NUM                   10               // 设备支持的ddns服务器最大个数
#define DH_MAX_SERVER_TYPE_LEN            32               // ddns服务器类型,最大字符串长度
#define DH_MAX_DOMAIN_NAME_LEN            256              // ddns域名,最大字符串长度
#define DH_MAX_DDNS_ALIAS_LEN             32               // ddns服务器别名,最大字符串长度
#define DH_MAX_DEFAULT_DOMAIN_LEN         60               // ddns默认域名,最大字符串长度     
#define DH_MOTION_ROW                     32               // 动态检测区域的行数
#define DH_MOTION_COL                     32               // 动态检测区域的列数
#define DH_STATIC_ROW                     32               // 静态检测区域的行数
#define DH_STATIC_COL                     32               // 静态检测区域的列数
#define DH_FTP_USERNAME_LEN               64               // FTP配置,用户名最大长度
#define DH_FTP_PASSWORD_LEN               64               // FTP配置,密码最大长度
#define DH_TIME_SECTION                   2                // FTP配置,每天时间段个数
#define DH_FTP_MAX_PATH                   240              // FTP配置,文件路径名最大长度
#define DH_FTP_MAX_SUB_PATH               128              // FTP配置,文件路径名最大长度
#define DH_INTERVIDEO_UCOM_CHANID         32               // 平台接入配置,U网通通道ID
#define DH_INTERVIDEO_UCOM_DEVID          32               // 平台接入配置,U网通设备ID
#define DH_INTERVIDEO_UCOM_REGPSW         16               // 平台接入配置,U网通注册密码
#define DH_INTERVIDEO_UCOM_USERNAME       32               // 平台接入配置,U网通用户名
#define DH_INTERVIDEO_UCOM_USERPSW        32               // 平台接入配置,U网通密码
#define DH_INTERVIDEO_NSS_IP              32               // 平台接入配置,中兴力维IP
#define DH_INTERVIDEO_NSS_SERIAL          32               // 平台接入配置,中兴力维serial
#define DH_INTERVIDEO_NSS_USER            32               // 平台接入配置,中兴力维user
#define DH_INTERVIDEO_NSS_PWD             50               // 平台接入配置,中兴力维password
#define DH_MAX_VIDEO_COVER_NUM            16               // 遮挡区域最大个数
#define DH_MAX_WATERMAKE_DATA             4096             // 水印图片数据最大长度
#define DH_MAX_WATERMAKE_LETTER           128              // 水印文字最大长度
#define DH_MAX_WLANDEVICE_NUM             10               // 最多搜索出的无线设备个数
#define DH_MAX_WLANDEVICE_NUM_EX          32               // 最多搜索出的无线设备个数
#define MAX_WLAN_DEVICE_NUM				  128              // 最多搜索出的无线设备个数
#define DH_MAX_ALARM_NAME                 64               // 地址长度
#define DH_MAX_REGISTER_SERVER_NUM        10               // 主动注册服务器个数
#define DH_SNIFFER_FRAMEID_NUM            6                // 6个FRAME ID 选项
#define DH_SNIFFER_CONTENT_NUM            4                // 每个FRAME对应的4个抓包内容
#define DH_SNIFFER_CONTENT_NUM_EX         8                // 每个FRAME对应的8个抓包内容
#define DH_SNIFFER_PROTOCOL_SIZE          20               // 协议名字长度
#define DH_MAX_PROTOCOL_NAME_LENGTH       20               
#define DH_SNIFFER_GROUP_NUM              4                // 4组抓包设置
#define MAX_PATH_STOR                     240              // 远程目录的长度
#define DH_ALARM_OCCUR_TIME_LEN           40               // 新的报警上传时间的长度
#define DH_VIDEO_OSD_NAME_NUM             64               // 叠加的名称长度,目前支持32个英文,16个中文
#define DH_VIDEO_CUSTOM_OSD_NUM           8                // 支持的自定义叠加的数目,不包含时间和通道
#define DH_VIDEO_CUSTOM_OSD_NUM_EX        256              // 支持的自定义叠加的数目,不包含时间和通道
#define DH_CONTROL_AUTO_REGISTER_NUM      100              // 支持定向主动注册服务器的个数
#define DH_MMS_RECEIVER_NUM               100              // 支持短信接收者的个数
#define DH_MMS_SMSACTIVATION_NUM          100              // 支持短信发送者的个数
#define DH_MMS_DIALINACTIVATION_NUM       100              // 支持拨号发送者的个数
#define DH_MAX_ALARMOUT_NUM_EX            32               // 报警输出口个数上限扩展
#define DH_MAX_VIDEO_IN_NUM_EX            32               // 视频输入口个数上限扩展
#define DH_MAX_ALARM_IN_NUM_EX            32               // 报警输入口个数上限
#define DH_MAX_IPADDR_OR_DOMAIN_LEN       64               // IP地址字符串长度
#define DH_MAX_CALLID                     32               // 呼叫ID
#define DH_MAX_OBJECT_LIST                16               // 智能分析设备检测到的物体ID个数上限    
#define DH_MAX_OBJECT_NUM				  32			   // 最大object个数
#define DH_MAX_RULE_LIST                  16               // 智能分析设备规则个数上限
#define DH_MAX_POLYGON_NUM                16               // 多边形最大顶点个数
#define DH_MAX_DETECT_LINE_NUM            20               // 规则检测线最大顶点数
#define DH_MAX_DETECT_REGION_NUM          20               // 规则检测区域最大顶点数
#define MAX_CARGO_CHANNEL_NUM			  8				   // 最大货物通道数
#define DH_MAX_TRACK_LINE_NUM             20               // 物体运动轨迹最大顶点数
#define DH_MAX_CANDIDATE_NUM              50               // 人脸识别最大匹配数
#define DH_MAX_PERSON_IMAGE_NUM           48               // 每个人员对应的最大人脸图片数
#define DH_MAX_FENCE_LINE_NUM             2                // 围栏最大曲线数
#define MAX_SMART_VALUE_NUM               30               // 最多的smart信息个数
#define DH_MACHINE_NAME_NUM               64               // 机器名称长度
#define DH_INTERVIDEO_AMP_DEVICESERIAL    48               // 平台接入配置,天地阳光 设备序列号字符串长度
#define DH_INTERVIDEO_AMP_DEVICENAME      16               // 平台接入配置,天地阳光 设备名称字符串长度
#define DH_INTERVIDEO_AMP_USER            32               // 平台接入配置,天地阳光 注册用户名字符串长度
#define DH_INTERVIDEO_AMP_PWD             32               // 平台接入配置,天地阳光 注册密码字符串长度
#define MAX_SUBMODULE_NUM                 32               // 最多子模块信息个数
#define DH_MAX_CARWAY_NUM                 8                // 交通抓拍,最大车道数
#define DH_MAX_SNAP_SIGNAL_NUM            3                // 一个车道的最大抓拍张数
#define DH_MAX_CARD_NUM                   128              // 卡号的最大个数
#define DH_MAX_CARDINFO_LEN               32               // 每条卡号最长字符数
#define MAX_COMPANION_CARD_NUM            6                // 陪同者卡号最大个数
#define DH_MAX_CONTROLER_NUM              64               // 最大支持控制器数目
#define DH_MAX_LIGHT_NUM                  32               // 最多控制灯组数
#define DH_MAX_SNMP_COMMON_LEN            64               // snmp 读写数据长度
#define DH_MAX_DDNS_STATE_LEN             128              // DDNS 状态信息长度
#define DH_MAX_PHONE_NO_LEN               16               // 电话号码长度
#define DH_MAX_MSGTYPE_LEN                32               // 导航类型或短信息类型长度
#define DH_MAX_MSG_LEN                    256              // 导航和短信息长度
#define DH_MAX_DRIVINGDIRECTION           256              // 行驶方向字符串长度
#define DH_MAX_GRAB_INTERVAL_NUM          4                // 多张图片抓拍个数
#define DH_MAX_FLASH_NUM                  5                // 最多支持闪光灯个数
#define DH_MAX_LANE_NUM                   8                // 视频分析设备每个通道对应车道数上限
#define DH_MAX_ISCSI_PATH_NUM             64               // ISCSI远程目录最大数量
#define DH_MAX_WIRELESS_CHN_NUM           256              // 无线路由最大信道数
#define DH_PROTOCOL3_BASE                 100              // 三代协议版本基数
#define DH_PROTOCOL3_SUPPORT              11               // 只支持3代协议
#define DH_MAX_CHANMASK                   64               // 通道掩码最大值
#define DH_MAX_STAFF_NUM                  20               // 浓缩视频配置信息中标尺数上限
#define DH_MAX_CALIBRATEBOX_NUM           10               // 浓缩视频配置信息中标定区域数上限
#define DH_MAX_EXCLUDEREGION_NUM          10               // 浓缩视频配置信息中排除区域数上限
#define DH_MAX_POLYLINE_NUM               20               // 浓缩视频配置信息中标尺线数
#define DH_MAX_COLOR_NUM                  16               // 最大颜色数目
#define MAX_OBJFILTER_NUM                 16               // 最大过滤种类个数
#define DH_MAX_SYNOPSIS_STATE_NAME        64               // 视频浓缩状态字符串长度
#define DH_MAX_SYNOPSIS_QUERY_FILE_COUNT  10               // 视频浓缩相关原始文件按照路径查找时文件个数上限
#define DH_MAX_SSID_LEN                   36               // SSID长度
#define DH_MAX_APPIN_LEN                  16               // PIN码长度
#define DH_NETINTERFACE_NAME_LEN          260              // 网口名称长度
#define DH_NETINTERFACE_TYPE_LEN          260              // 网络类型长度
#define DH_MAX_CONNECT_STATUS_LEN         260              // 连接状态字符串长度
#define DH_MAX_MODE_LEN                   64               // 3G支持的网络模式长度
#define DH_MAX_MODE_NUM                   64               // 3G支持的网络模式个数
#define DH_MAX_COMPRESSION_TYPES_NUM      16               // 视频编码格式最多种类个数
#define DH_MAX_CAPTURE_SIZE_NUM           64               // 视频分辨率个数
#define DH_NODE_NAME_LEN                  64               // 组织结构节点名称长度
#define MAX_CALIBPOINTS_NUM               256              // 支持最大标定点数
#define DH_MAX_ATTR_NUM                   32               // 显示单元属性最大数量
#define DH_MAX_CLOUDCONNECT_STATE_LEN     128              // 云注册连接状态信息长度
#define DH_MAX_IPADDR_EX_LEN              128              // 扩展IP地址最大长度
#define DH_MAX_PLATE_NUMBER_LEN           32               // 车牌字符串长度   
#define DH_MAX_AUTHORITY_LIST_NUM         16               // 权限列表最大个数   
#define DH_MAX_CITY_NAME_LEN              64               // 城市名称最大长度
#define DH_MAX_PROVINCE_NAME_LEN          64               // 省份名称最大长度
#define DH_MAX_PERSON_ID_LEN              32               // 人员id最大长度
#define MAX_FACE_AREA_NUM                 8                // 最大人脸区域个数 
#define MAX_FACE_DB_NUM                   8                // 最大人脸数据库个数
#define MAX_EVENT_NAME                    128              // 最长事件名
#define DH_MAX_ETH_NAME                   64               // 最大网卡名
#define DH_MAX_PERSON_NAME_LEN            64               // 人员名字最大长度
#define DH_N_SCHEDULE_TSECT               8                // 时间表元素个数    
#define DH_MAX_URL_NUM                    8                // URL最大个数
#define DH_MAX_LOWER_MITRIX_NUM           16               // 最大下位矩阵数
#define DH_MAX_BURN_CHANNEL_NUM           32               // 最大刻录通道数
#define DH_MAX_NET_STRORAGE_BLOCK_NUM     64               // 最大远程存储区块数量
#define DH_MAX_CASE_PERSON_NUM            32               // 案件人员最大数量
#define DH_MAX_MULTIPLAYBACK_CHANNEL_NUM  64               // 最大多通道预览回放通道数
#define DH_MAX_MULTIPLAYBACK_SPLIT_NUM    32               // 最大多通道预览回放分割模式数
#define DH_MAX_AUDIO_ENCODE_TYPE          64               // 最大语音编码类型个数
#define MAX_LOG_PATH_LEN                  260              // 日志路径名最大长度
#define MAX_CARD_RECORD_FIELD_NUM         16               // 卡号录像最大域数量
#define DH_BATTERY_NUM_MAX                16               // 最大电池数量    
#define DH_POWER_NUM_MAX                  16               // 最大电源数量        
#define DH_MAX_AUDIO_PATH                 260              // 最大音频文件路长度
#define DH_MAX_DOORNAME_LEN               128              // 最大门禁名称长度    
#define DH_MAX_CARDPWD_LEN                64               // 最大门禁名称长度    
#define NET_MAX_FISHEYE_MOUNTMODE_NUM     4                // 最大鱼眼安装模式个数
#define NET_MAX_FISHEYE_CALIBRATEMODE_NUM 16               // 最大鱼眼矫正模式个数
#define NET_MAX_FISHEYE_EPTZCMD_NUM       64               // 最大鱼眼电子云台操作个数   
#define POINT_NUM_IN_PAIR                 2                // 标定点对中的点数量
#define MAX_POINT_PAIR_NUM                128              // 标定点最大数量
#define CHANNEL_NUM_IN_POINT_GROUP        2                // 标定点中的视频通道数
#define MAX_POINT_GROUP_NUM               32               // 标定点组最大数量, 每两个通道进行拼接需要一组标定点
#define MAX_LANE_INFO_NUM                 32               // 最大车道信息数
#define MAX_LANE_DIRECTION_NUM            8                // 车道方向总数
#define DH_MAX_MONITORWALL_NUM            32               // 电视墙最大数量
#define DH_MAX_OPTIONAL_URL_NUM           8                // 备用url最大数量
#define DH_MAX_CAMERA_CHANNEL_NUM         1024             // 最大摄像机通道数
#define MAX_SIMILARITY_COUNT			  1024			   // 最大人脸对比库阈值个数
#define MAX_FEATURESTATE_NUM		      4				   // 最大人脸组建模状态个数
#define MAX_FILE_SUMMARY_NUM              32               // 最大文件摘要数
#define MAX_AUDIO_ENCODE_NUM              64               // 最大支持音频编码个数
#define MAX_MONITORWALL_NAME_LEN          64               // 电视墙名称最大长度
#define MAX_FLASH_LIGHT_NUM               8                // 最大支持的爆闪灯(闪光灯)个数
#define MAX_STROBOSCOPIC_LIGHT_NUM        8                // 最大支持的频闪灯个数
#define MAX_MOSAIC_NUM                    8                // 最大支持的马赛克数量
#define MAX_MOSAIC_CHANNEL_NUM            256              // 支持马赛克叠加的最多通道数量
#define MAX_FIREWARNING_INFO_NUM          4                // 最大热成像着火点报警信息个数
#define MAX_AXLE_NUM                      8                // 最大车轴数量
#define DH_MAX_BULLET_HOLES               10               // 最大的弹孔数 
#define MAX_PLATE_NUM                     64               // 每张图片中包含的最大车牌个数
#define MAX_PREVIEW_CHANNEL_NUM           64               // 最大导播预览的通道数量 
#define MAX_EVENT_RESTORE_UUID            36               // 事件重传uuid数组大小
#define MAX_EVENT_RESTORE_CODE_NUM        8                // 最大事件重传类型个数
#define MAX_EVENT_RESOTER_CODE_TYPE       32               // 事件重传类型数组大小
#define MAX_SNAP_TYPE                     3                // 抓图类型数量
#define MAX_MAINFORMAT_NUM                4                // 最大支持主码流类型数量
#define CUSTOM_TITLE_LEN                  1024             // 自定义标题名称长度(扩充到1024)
#define MAX_CUSTOM_TITLE_NUM              8                // 编码物件自定义标题最大数量
#define FORMAT_TYPE_LEN                   16               // 编码类型名最大长度
#define MAX_CHANNEL_NAME_LEN              256              // 通道名称最大长度
#define MAX_VIRTUALINFO_DOMAIN_LEN        64               // 虚拟身份上网域名长度
#define MAX_VIRTUALINFO_TITLE_LEN         64               // 虚拟身份上网标题长度
#define MAX_VIRTUALINFO_USERNAME_LEN      32               // 虚拟身份用户名长度
#define MAX_VIRTUALINFO_PASSWORD_LEN      32               // 虚拟身份密码长度
#define MAX_VIRTUALINFO_PHONENUM_LEN      12               // 虚拟身份手机号长度
#define MAX_VIRTUALINFO_IMEI_LEN          16               // 虚拟身份国际移动设备标识长度
#define MAX_VIRTUALINFO_IMSI_LEN          16               // 虚拟身份国际移动用户识别码长度
#define MAX_VIRTUALINFO_LATITUDE_LEN      16               // 虚拟身份经度长度
#define MAX_VIRTUALINFO_LONGITUDE_LEN     16               // 虚拟身份纬度长度
#define MAX_VIRTUALINFO_NUM               1024             // 最大虚拟身份信息个数
#define MAX_CALL_ID_LEN                   64               // 呼叫ID长度
#define MAX_FACE_DATA_LEN                 2048             // 人脸模版数据最大长度
#define MAX_FACE_DATA_NUM                 20               // 人脸模版最大个数
#define MAX_PHOTO_COUNT                   5                // 人脸照片最大个数
#define MAX_FINGERPRINT_NUM               10               // 最大指纹个数
#define MAX_RINGFILE_NUM                  64               // 最大门铃音频文件个数
#define MAX_VIDEOIN_CONFLICT_NUM          128              // 视频输出能力冲突最大组合数
#define MAX_COURSE_LOGIC_CHANNEL          64               // 录播主机最大逻辑通道数
#define MAX_COMMON_STRING_8               8                // 通用字符串长度8
#define MAX_COMMON_STRING_16              16               // 通用字符串长度16
#define MAX_COMMON_STRING_32              32               // 通用字符串长度32
#define MAX_COMMON_STRING_64              64               // 通用字符串长度64
#define MAX_MAN_LIST_COUNT                64               // 人员列表最大数量
#define MAX_COMMON_STRING_128             128              // 通用字符串长度128
#define MAX_STREAM_NUM                    4                // 最大码流个数
#define MAX_CELL_PHONE_NUMBER_LEN         32               // 最大手机号长度
#define MAX_MAIL_LEN                      64               // 邮箱最大长度
#define MAX_USER_NAME_LEN                 128              // 最大用户名长度
#define MAX_PWD_LEN                       128              // 最大密码长度
#define MAX_SECURITY_CODE_LEN             16               // 平台发送到预留手机/邮箱中安全码最大长度    
#define MAX_PWD_SPEC_CHARS_ARRAY_LEN      128              // 密码规范中密码特殊字符列表最大长度
#define MAX_PWD_BASIC_CHARS_ARRAY_LEN     128              // 密码规范中支持的基本字符类型列表最大长度        
#define MAX_COMMON_STRING_512             512              // 通用字符串长度512
#define MAX_RFIDELETAG_CARDID_LEN         16               // RFID 电子车牌标签信息中卡号最大长度
#define MAX_RFIDELETAG_DATE_LEN           16               // RFID 电子车牌标签信息中时间最大长度
#define MAX_LINK_NAME_LEN                 16               // 连接名称长度
#define MAX_SERVER_ADDRESS_LEN            64               // 服务器IP长度
#define LINK_LAYER_VPN_NUM                64               // 链路层VPN配置个数
#define MAX_SERVER_IP_LEN                 32               // 服务器IP长度 
#define MAX_SCENICSPOT_POINTS_NUM         256              // 总共有多少个景物点信息
#define MAX_ACCESSSUBCONTROLLER_NUM       64               // 最大门禁分控器数量
#define MAX_ACCESSDOOR_NUM                128              // 最大门数量                 
#define MAX_ACCESS_READER_NUM             32               // 门禁单个门最大读卡器数量
#define MAX_ACCESS_POINT_NUM              32               // 反潜路径最大节点个数
#define MAX_CONFIG_NAME_LEN               128              // 最大配置名称长度
#define MAX_PLATE_NUMBER_LEN              64               // 最大车牌号码长度
#define MAX_MASTER_OF_CAR_LEN             32               // 最大车主姓名长度
#define MAX_USER_TYPE_LEN                 32               // 最大用户类型长度
#define MAX_SUB_USER_TYPE_LEN			  64			   // 最大用户子类型长度
#define MAX_REMARKS_LEN					  64			   // 最大备注信息长度
#define MAX_PARK_CHARGE_LEN               32               // 最大停车费长度
#define MAX_IN_TIME_LEN                   32               // 最大车辆入场时间长度
#define MAX_OUT_TIME_LEN                  32               // 最大车辆出场时间长度
#define MAX_CUSTOM_LEN                    128              // 最大自定义显示长度
#define MAX_DEAL_NUM_LEN                  32               // 最大小票交易号长度
#define MAX_STORE_NO_LEN                  32               // 最大店号长度
#define MAX_STORE_NAME_LEN                32               // 最大店名长度
#define MAX_STORE_EMPLOYEE_ID_LEN         32               // 最大收银员工号长度
#define MAX_PRODUCT_NO_LEN                32               // 最大商品代码长度
#define MAX_PRODUCT_NAME_LEN              32               // 最大商品名称长度
#define MAX_PRODUCT_CATEGORY_LEN          32               // 最大商品类别长度
#define DH_MAX_FINGER_PRINT               10               // 指纹ID数组最大长度
#define MAX_SUBCHANNEL_NUM                16               // 视频子通道(采集器)最大个数
#define MAX_NAME_LENGTH                   32               // 最大姓名长度
#define MAX_SNAP_URL_LEN                  128              // 最大抓图地址长度
#define MAX_CODE_LEN                      64               // 最大物品编号长度
#define MAX_PERSON_INFO_NUM               4                // 最大人脸信息个数
#define MAX_GOOD_INFO_NUM                 128              // 最大物品信息个数
#define MAX_SUB_TAG_NUM                   20               // 子标签最大个数
#define MAX_MANUFACTURER_LEN              32               // 最大的Mac地址所属制造商长度
#define MAX_MACHISTORY_SSID_LEN           24               // 最大的历史SSID长度
#define MAX_MACHISTORY_SSID_NUM	          5	               // 历史SSID的最大个数
#define MAX_ROUTE_NUM                     16               // 最大路由数量
#define MAX_MCU_NUM                       10               // 最大报警主机单片机个数
#define MAX_ALARM_CHANNEL_NAME_LEN		  64               // 最大报警名称长度
#define MAX_INSIDEOBJECT_NUM			  32			   // 最大包裹内物品个数
#define DH_PRETASK_CHANNEL				  4				   // 视频浓缩预处理任务
#define MAX_AGE_NUM						  2				   // 最大年龄个数
#define MAX_EMOTION_NUM					  8				   // 最大表情条件的个数
#define MAX_CLASS_NUMBER_LEN			  32			   // 最大班级长度
#define MAX_PHONENUMBER_LEN				  16			   // 最大电话长度
#define MAX_NASFILE_NUM                   8                // 最大NAS文件个数
#define MAX_CROWD_DETECTION_NAME_LEN	  128			   // 最大人群密度检测事件名称长度
#define	MAX_CROWD_LIST_NUM				  5				   // 最大全局拥挤人群密度列表个数
#define MAX_REGION_LIST_NUM			      8				   // 最大人数超限的报警区域ID列表个数
#define MAX_RECORD_ENCRYPT_PASSWD_LEN	  128			   // 最大的录像加密密码长度
#define MAX_EVENT_NAME_LEN				  128			   // 最大事件名称长度
#define MAX_ABSTRACT_INFO_NUM			  100			   // 最大人脸特征向量重建结果个数
#define MAX_ACCESS_FLOOR_NUM              64               // 最大楼层数量
#define MAX_TARGET_OBJECT_NUM			  100			   // 最大目标物体信息个数
#define MAX_MACADDR_NUM					  8				   // 最大物理地址个数
#define MAX_ADD_DEVICE_NUM                16               // 最大添加设备个数
#define MAX_LINK_DEVICE_NUM               1024			   // 最大连接设备个数
#define MAX_DEVICE_CHANNEL_NUM            1024			   // 设备最大通道个数
#define MAX_PLATE_TAILNUM			      10			   // 最大限号个数
#define MAX_OBJECT_NUM_EX				  100			   // 对象的最大个数
#define MAX_LOCAL_IP_LEN				  64			   // 最大本地IP长度
#define MAX_LV_NAME_NUM					  64			   // 最大的分区名称个数
#define MAX_LV_NAME_LEN					  128			   // 最大的分区名称长度
#define	MAX_KEY_LEN						  64			   // 最大的关键字长度
#define MAX_FILE_FINDER_PATH_NUM		  10			   // 最大的查询文件路径个数
#define	MAX_FILE_FINDER_PATH_LEN		  256			   // 最大的查询文件路径长度
#define MAX_FILE_LIST_NUM				  16			   // 最大的查询文件列表个数
#define MAX_FILE_LIST_LEN				  256			   // 最大的查询文件列表长度
#define MAX_PARKINGLOCK_STATE_NUM		  6				   // 最大车位锁状态个数
#define MAX_COMMON_STRING_256             256              // 通用字符串长度256
#define MAX_COMMON_STRING_2048            2048             // 通用字符串长度2048
#define MAX_RESOURCE_LEN                  64			   // 最大资源文件长度
#define MAX_COMPANY_NAME_LEN              200              // 单位名称最大长度
#define MAX_CONTACT_LEN                   16               // 接收安全码的联系方式最大长度
#define MAX_RADAR_SD_NUM                  24			   // 单雷达联动的最大球机数
#define MAX_FLEXION_INFO_NUM		  	  512			   // 拐点信息最大个数
#define MAX_CALIBRATE_PLOYGON_AREA_NUM    20               // 标定多边形区域最大顶点个数
#define MAX_CALIBRATE_RECT_NUM            10               // 标定框最大个数
#define MAX_SCENE_NUM                     32               // 最大场景个数
#define MAX_SNAP_SHOT_NUM				  8				   // 最大抓拍张数
#define MAX_AIRPORT_VEHICLE_OBJECT_NUM	  16			   // 最大机场保障车检测个数

// 查询类型,对应CLIENT_QueryDevState接口
#define DH_DEVSTATE_COMM_ALARM            0x0001           // 查询普通报警状态(包括外部报警,视频丢失,动态检测)
#define DH_DEVSTATE_SHELTER_ALARM         0x0002           // 查询遮挡报警状态
#define DH_DEVSTATE_RECORDING             0x0003           // 查询录象状态
#define DH_DEVSTATE_DISK                  0x0004           // 查询硬盘信息
#define DH_DEVSTATE_RESOURCE              0x0005           // 查询系统资源状态
#define DH_DEVSTATE_BITRATE               0x0006           // 查询通道码流
#define DH_DEVSTATE_CONN                  0x0007           // 查询设备连接状态
#define DH_DEVSTATE_PROTOCAL_VER          0x0008           // 查询网络协议版本号,pBuf = int*
#define DH_DEVSTATE_TALK_ECTYPE           0x0009           // 查询设备支持的语音对讲格式列表,见结构体DHDEV_TALKFORMAT_LIST
#define DH_DEVSTATE_SD_CARD               0x000A           // 查询SD卡信息(IPC类产品)
#define DH_DEVSTATE_BURNING_DEV           0x000B           // 查询刻录机信息
#define DH_DEVSTATE_BURNING_PROGRESS      0x000C           // 查询刻录进度
#define DH_DEVSTATE_PLATFORM              0x000D           // 查询设备支持的接入平台
#define DH_DEVSTATE_CAMERA                0x000E           // 查询摄像头属性信息(IPC类产品),pBuf = DHDEV_CAMERA_INFO *,可以有多个结构体
#define DH_DEVSTATE_SOFTWARE              0x000F           // 查询设备软件版本信息
#define DH_DEVSTATE_LANGUAGE              0x0010           // 查询设备支持的语音种类
#define DH_DEVSTATE_DSP                   0x0011           // 查询DSP能力描述(对应结构体DHDEV_DSP_ENCODECAP)
#define DH_DEVSTATE_OEM                   0x0012           // 查询OEM信息
#define DH_DEVSTATE_NET                   0x0013           // 查询网络运行状态信息
#define DH_DEVSTATE_TYPE                  0x0014           // 查询设备类型
#define DH_DEVSTATE_SNAP                  0x0015           // 查询功能属性(IPC类产品)
#define DH_DEVSTATE_RECORD_TIME           0x0016           // 查询最早录像时间和最近录像时间
#define DH_DEVSTATE_NET_RSSI              0x0017           // 查询无线网络信号强度,见结构体DHDEV_WIRELESS_RSS_INFO
#define DH_DEVSTATE_BURNING_ATTACH        0x0018           // 查询附件刻录选项
#define DH_DEVSTATE_BACKUP_DEV            0x0019           // 查询备份设备列表
#define DH_DEVSTATE_BACKUP_DEV_INFO       0x001a           // 查询备份设备详细信息
#define DH_DEVSTATE_BACKUP_FEEDBACK       0x001b           // 备份进度反馈
#define DH_DEVSTATE_ATM_QUERY_TRADE       0x001c           // 查询ATM交易类型
#define DH_DEVSTATE_SIP                   0x001d           // 查询sip状态
#define DH_DEVSTATE_VICHILE_STATE         0x001e           // 查询车载wifi状态
#define DH_DEVSTATE_TEST_EMAIL            0x001f           // 查询邮件配置是否成功
#define DH_DEVSTATE_SMART_HARD_DISK       0x0020           // 查询硬盘smart信息
#define DH_DEVSTATE_TEST_SNAPPICTURE      0x0021           // 查询抓图设置是否成功
#define DH_DEVSTATE_STATIC_ALARM          0x0022           // 查询静态报警状态
#define DH_DEVSTATE_SUBMODULE_INFO        0x0023           // 查询设备子模块信息
#define DH_DEVSTATE_DISKDAMAGE            0x0024           // 查询硬盘坏道能力 
#define DH_DEVSTATE_IPC                   0x0025           // 查询设备支持的IPC能力, 见结构体DH_DEV_IPC_INFO
#define DH_DEVSTATE_ALARM_ARM_DISARM      0x0026           // 查询报警布撤防状态
#define DH_DEVSTATE_ACC_POWEROFF_ALARM    0x0027           // 查询ACC断电报警状态(返回一个DWORD, 1表示断电,0表示通电)
#define DH_DEVSTATE_TEST_FTP_SERVER       0x0028           // 测试FTP服务器连接
#define DH_DEVSTATE_3GFLOW_EXCEED         0x0029           // 查询3G流量超出阈值状态,(见结构体DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_DEVSTATE_3GFLOW_INFO           0x002a           // 查询3G网络流量信息,见结构体DH_DEV_3GFLOW_INFO
#define DH_DEVSTATE_VIHICLE_INFO_UPLOAD   0x002b           // 车载自定义信息上传(见结构体ALARM_VEHICLE_INFO_UPLOAD)
#define DH_DEVSTATE_SPEED_LIMIT           0x002c           // 查询限速报警状态(见结构体 ALARM_SPEED_LIMIT)
#define DH_DEVSTATE_DSP_EX                0x002d           // 查询DSP扩展能力描述(对应结构体DHDEV_DSP_ENCODECAP_EX)
#define DH_DEVSTATE_3GMODULE_INFO         0x002e           // 查询3G模块信息(对应结构体DH_DEV_3GMODULE_INFO)
#define DH_DEVSTATE_MULTI_DDNS            0x002f           // 查询多DDNS状态信息(对应结构体DH_DEV_MULTI_DDNS_INFO)
#define DH_DEVSTATE_CONFIG_URL            0x0030           // 查询设备配置URL信息(对应结构体DH_DEV_URL_INFO)
#define DH_DEVSTATE_HARDKEY               0x0031           // 查询HardKey状态（对应结构体DHDEV_HARDKEY_STATE)
#define DH_DEVSTATE_ISCSI_PATH            0x0032           // 查询ISCSI路径列表(对应结构体DHDEV_ISCSI_PATHLIST)
#define DH_DEVSTATE_DLPREVIEW_SLIPT_CAP   0x0033           // 查询设备本地预览支持的分割模式(对应结构体DEVICE_LOCALPREVIEW_SLIPT_CAP)
#define DH_DEVSTATE_WIFI_ROUTE_CAP        0x0034           // 查询无线路由能力信息(对应结构体DHDEV_WIFI_ROUTE_CAP)
#define DH_DEVSTATE_ONLINE                0x0035           // 查询设备的在线状态(返回一个DWORD, 1表示在线, 0表示断线)
#define DH_DEVSTATE_PTZ_LOCATION          0x0036           // 查询云台状态信息(对应结构体 DH_PTZ_LOCATION_INFO)
#define DH_DEVSTATE_MONITOR_INFO          0x0037           // 画面监控辅助信息(对应结构体DHDEV_MONITOR_INFO)
#define DH_DEVSTATE_SUBDEVICE             0x0300           // 查询子设备(电源, 风扇等)状态(对应结构体CFG_DEVICESTATUS_INFO)
#define DH_DEVSTATE_RAID_INFO             0x0038           // 查询RAID状态(对应结构体ALARM_RAID_INFO)  
#define DH_DEVSTATE_TEST_DDNSDOMAIN       0x0039           // 测试DDNS域名是否可用
#define DH_DEVSTATE_VIRTUALCAMERA         0x003a           // 查询虚拟摄像头状态(对应 DHDEV_VIRTUALCAMERA_STATE_INFO)
#define DH_DEVSTATE_TRAFFICWORKSTATE      0x003b           // 获取设备工作视频/线圈模式状态等(对应DHDEV_TRAFFICWORKSTATE_INFO)
#define DH_DEVSTATE_ALARM_CAMERA_MOVE     0x003c           // 获取摄像机移位报警事件状态(对应ALARM_CAMERA_MOVE_INFO)
#define DH_DEVSTATE_ALARM                 0x003e           // 获取外部报警状态(对应 NET_CLIENT_ALARM_STATE) 
#define DH_DEVSTATE_VIDEOLOST             0x003f           // 获取视频丢失报警状态(对应 NET_CLIENT_VIDEOLOST_STATE) 
#define DH_DEVSTATE_MOTIONDETECT          0x0040           // 获取动态监测报警状态(对应 NET_CLIENT_MOTIONDETECT_STATE)
#define DH_DEVSTATE_DETAILEDMOTION        0x0041           // 获取详细的动态监测报警状态(对应 NET_CLIENT_DETAILEDMOTION_STATE)
#define DH_DEVSTATE_VEHICLE_INFO          0x0042           // 获取车载自身各种硬件信息(对应 DHDEV_VEHICLE_INFO)
#define DH_DEVSTATE_VIDEOBLIND            0x0043           // 获取视频遮挡报警状态(对应 NET_CLIENT_VIDEOBLIND_STATE)
#define DH_DEVSTATE_3GSTATE_INFO          0x0044           // 查询3G模块相关信息(对应结构体DHDEV_VEHICLE_3GMODULE)
#define DH_DEVSTATE_NETINTERFACE          0x0045           // 查询网络接口信息(对应 DHDEV_NETINTERFACE_INFO)
#define DH_DEVSTATE_PICINPIC_CHN          0x0046           // 查询画中画通道号(对应DWORD数组)
#define DH_DEVSTATE_COMPOSITE_CHN         0x0047           // 查询融合屏通道信息(对应DH_COMPOSITE_CHANNEL数组)
#define DH_DEVSTATE_WHOLE_RECORDING       0x0048           // 查询设备整体录像状态(对应BOOL), 只要有一个通道在录像,即为设备整体状态为录像
#define DH_DEVSTATE_WHOLE_ENCODING        0x0049           // 查询设备整体编码状态(对应BOOL), 只要有一个通道在编码,即为设备整体状态为编码
#define DH_DEVSTATE_DISK_RECORDE_TIME     0x004a           // 查询设备硬盘录像时间信息(pBuf = DEV_DISK_RECORD_TIME*,可以有多个结构体)
#define DH_DEVSTATE_BURNER_DOOR           0x004b           // 是否已弹出刻录机光驱门(对应结构体 NET_DEVSTATE_BURNERDOOR)
#define DH_DEVSTATE_GET_DATA_CHECK        0x004c           // 查询光盘数据校验进度(对应 NET_DEVSTATE_DATA_CHECK)
#define DH_DEVSTATE_ALARM_IN_CHANNEL      0x004f           // 查询报警输入通道信息(对应NET_ALARM_IN_CHANNEL数组)
#define DH_DEVSTATE_ALARM_CHN_COUNT       0x0050           // 查询报警通道数(对应NET_ALARM_CHANNEL_COUNT)
#define DH_DEVSTATE_PTZ_VIEW_RANGE        0x0051           // 查询云台可视域状态(对应 DH_OUT_PTZ_VIEW_RANGE_STATUS    )
#define DH_DEVSTATE_DEV_CHN_COUNT         0x0052           // 查询设备通道信息(对应NET_DEV_CHN_COUNT_INFO)
#define DH_DEVSTATE_RTSP_URL              0x0053           // 查询设备支持的RTSP URL列表,见结构体DEV_RTSPURL_LIST
#define DH_DEVSTATE_LIMIT_LOGIN_TIME      0x0054           // 查询设备登录的在线超时时间,返回一个BTYE,（单位：分钟） ,0表示不限制,非零正整数表示限制的分钟数
#define DH_DEVSTATE_GET_COMM_COUNT        0x0055           // 获取串口数 见结构体NET_GET_COMM_COUNT
#define DH_DEVSTATE_RECORDING_DETAIL      0x0056           // 查询录象状态详细信息(pBuf = NET_RECORD_STATE_DETAIL*)
#define DH_DEVSTATE_PTZ_PRESET_LIST       0x0057           // 获取当前云台的预置点列表(对应结构NET_PTZ_PRESET_LIST)
#define DH_DEVSTATE_EXTERNAL_DEVICE       0x0058           // 外接设备信息(pBuf = NET_EXTERNAL_DEVICE*)
#define DH_DEVSTATE_GET_UPGRADE_STATE     0x0059           // 获取设备升级状态(对应结构DHDEV_UPGRADE_STATE_INFO)
#define DH_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP 0x005a         // 获取多通道预览分割能力( 对应结构体 NET_MULTIPLAYBACK_SPLIT_CAP )
#define DH_DEVSTATE_BURN_SESSION_NUM      0x005b           // 获取刻录会话总数(pBuf = int*)
#define DH_DEVSTATE_PROTECTIVE_CAPSULE    0x005c           // 查询防护舱状态(对应结构体ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_DEVSTATE_GET_DOORWORK_MODE     0x005d           // 获取门锁控制模式( 对应 NET_GET_DOORWORK_MODE)
#define DH_DEVSTATE_PTZ_ZOOM_INFO         0x005e           // 查询云台获取光学变倍信息(对应 DH_OUT_PTZ_ZOOM_INFO )
#define DH_DEVSTATE_POWER_STATE           0x0152           // 查询电源状态(对应结构体DH_POWER_STATUS)
#define DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE  0x153        // 查询报警通道状态(对应结构体 NET_CLIENT_ALARM_CHANNELS_STATE)
#define DH_DEVSTATE_ALARMKEYBOARD_COUNT   0x0154           // 查询串口上连接的报警键盘数(对应结构体NET_ALARMKEYBOARD_COUNT)
#define DH_DEVSTATE_EXALARMCHANNELS       0x0155           // 查询扩展报警模块通道映射关系(对应结构体 NET_EXALARMCHANNELS)
#define DH_DEVSTATE_GET_BYPASS            0x0156           // 查询通道旁路状态(对应结构体 NET_DEVSTATE_GET_BYPASS)
#define DH_DEVSTATE_ACTIVATEDDEFENCEAREA  0x0157           // 获取激活的防区信息(对应结构体 NET_ACTIVATEDDEFENCEAREA)
#define DH_DEVSTATE_DEV_RECORDSET         0x0158           // 查询设备记录集信息(对应 NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_DOOR_STATE            0x0159           // 查询门禁状态(对应NET_DOOR_STATUS_INFO)
#define DH_DEVSTATE_ANALOGALARM_CHANNELS  0x1560           // 模拟量报警输入通道映射关系(对应NET_ANALOGALARM_CHANNELS)
#define DH_DEVSTATE_GET_SENSORLIST        0x1561           // 获取设备支持的传感器列表(对应 NET_SENSOR_LIST)
#define DH_DEVSTATE_ALARM_CHANNELS        0x1562           // 查询开关量报警模块通道映射关系(对应结构体 NET_ALARM_CHANNELS)
                                                           // 如果设备不支持查询扩展报警模块通道,可以用该功能查询扩展通道的逻辑通道号,并当做本地报警通道使用
#define DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS  0x1563  // 获取当前子系统启用状态( 对应 NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
#define DH_DEVSTATE_AIRCONDITION_STATE    0x1564           // 获取空调工作状态(对应 NET_GET_AIRCONDITION_STATE)
#define DH_DEVSTATE_ALARMSUBSYSTEM_STATE  0x1565           // 获取子系统状态(对应NET_ALARM_SUBSYSTEM_STATE)
#define DH_DEVSTATE_ALARM_FAULT_STATE     0x1566           // 获取故障状态(对应 NET_ALARM_FAULT_STATE_INFO)
#define DH_DEVSTATE_DEFENCE_STATE         0x1567           // 获取防区状态(对应 NET_DEFENCE_STATE_INFO, 和旁路状态变化事件、本地报警事件、报警信号源事件的状态描述有区别,不能混用,仅个别设备使用)
#define DH_DEVSTATE_CLUSTER_STATE         0x1568           // 获取集群状态(对应 NET_CLUSTER_STATE_INFO)
#define DH_DEVSTATE_SCADA_POINT_LIST      0x1569           // 获取点位表路径信息(对应 NET_SCADA_POINT_LIST_INFO)
#define DH_DEVSTATE_SCADA_INFO            0x156a           // 获取监测点位信息(对应 NET_SCADA_INFO)
#define DH_DEVSTATE_SCADA_CAPS            0x156b           // 获取SCADA能力集(对应 NET_SCADA_CAPS)
#define DH_DEVSTATE_GET_CODEID_COUNT      0x156c           // 获取对码成功的总条数(对应 NET_GET_CODEID_COUNT)
#define DH_DEVSTATE_GET_CODEID_LIST       0x156d           // 查询对码信息(对应 NET_GET_CODEID_LIST)
#define DH_DEVSTATE_ANALOGALARM_DATA      0x156e           // 查询模拟量通道数据(对应 NET_GET_ANALOGALARM_DATA)
#define DH_DEVSTATE_VTP_CALLSTATE         0x156f           // 获取视频电话呼叫状态(对应 NET_GET_VTP_CALLSTATE)
#define DH_DEVSTATE_SCADA_INFO_BY_ID      0x1570           // 通过设备、获取监测点位信息(对应 NET_SCADA_INFO_BY_ID)
#define DH_DEVSTATE_SCADA_DEVICE_LIST     0x1571           // 获取当前主机所接入的外部设备ID(对应 NET_SCADA_DEVICE_LIST)
#define DH_DEVSTATE_DEV_RECORDSET_EX      0x1572           // 查询设备记录集信息(带二进制数据)(对应 NET_CTRL_RECORDSET_PARAM)
#define DH_DEVSTATE_ACCESS_LOCK_VER       0x1573           // 获取门锁软件版本号(对应 NET_ACCESS_LOCK_VER)
#define DH_DEVSTATE_MONITORWALL_TVINFO    0x1574           // 获取电视墙显示信息(对应 NET_CTRL_MONITORWALL_TVINFO)
#define DH_DEVSTATE_GET_ALL_POS           0x1575           // 获取所有用户可用Pos设备配置信息(对应 NET_POS_ALL_INFO)
#define DH_DEVSTATE_GET_ROAD_LIST         0x1576           // 获取城市及路段编码信息,哥伦比亚项目专用(对应 NET_ROAD_LIST_INFO)
#define DH_DEVSTATE_GET_HEAT_MAP          0x1577           // 获取热度统计信息(对应 NET_QUERY_HEAT_MAP)
#define DH_DEVSTATE_GET_WORK_STATE        0x1578           // 获取盒子工作状态信息(对应 NET_QUERY_WORK_STATE)
#define DH_DEVSTATE_GET_WIRESSLESS_STATE  0x1579           // 获取无线设备状态信息(对应 NET_GET_WIRELESS_DEVICE_STATE)
#define DH_DEVSTATE_GET_REDUNDANCE_POWER_INFO  0x157a      // 获取冗余电源信息(对应 NET_GET_REDUNDANCE_POWER_INFO)
#define DH_DEVSTATE_GET_ACCESSORY_STATUS  0x157b           // 获取配件状态(对应 NET_GET_ACCESSORY_STATUS)       

//////////////////////////////////////////////////////////////////////////
// 用于设置结构体 dwSize 成员的宏
#define _setdwSize(stu) ((stu).dwSize = sizeof(stu))

//////////////////////////////////////////////////////////////////////////

#define CFG_MAX_ACCESSCONTROL_NUM				8							// 最大门禁操作的组合数
#define CFG_MAX_SUMMARY_LEN						1024						// 叠加到JPEG图片的摘要信息最大长度
#define CFG_MAX_DBKEY_NUM						64							// 数据库关键字最大值
#define CFG_MAX_CHANNELNAME_LEN					64							// 最大通道名称长度
#define CFG_MAX_VIDEO_CHANNEL_NUM				256							// 最大通道数256
#define CFG_MAX_CHANNEL_COUNT					16
#define CFG_MAX_PSTN_SERVER_NUM                 8							// 最大报警电话服务器数

//三态布尔类型
typedef enum tagNET_THREE_STATUS_BOOL
{
    BOOL_STATUS_FALSE  = 0 , 
    BOOL_STATUS_TRUE       ,
    BOOL_STATUS_UNKNOWN    ,  //未知
}NET_THREE_STATUS_BOOL;

//////////////////////////////////////////////////////////////////////////

// 空调工作模式
typedef enum __EM_AIRCONDITION_MODE
{
    AIRCONDITION_MODE_UNKNOWN = 0,
    AIRCONDITION_MODE_AUTO,             // 自动
    AIRCONDITION_MODE_HOT,              // 制热
    AIRCONDITION_MODE_COLD,             // 制冷
    AIRCONDITION_MODE_WET,              // 除湿
    AIRCONDITION_MODE_WIND,             // 通风
} EM_AIRCONDITION_MODE;

// 空调送风模式
typedef enum __EM_AIRCONDITION_WINDMODE
{
    AIRCONDITION_WINDMODE_UNKNOWN = 0,
    AIRCONDITION_WINDMODE_STOP,          // 停止
    AIRCONDITION_WINDMODE_AUTO,          // 自动
    AIRCONDITION_WINDMODE_HIGH,          // 高速
    AIRCONDITION_WINDMODE_MIDDLE,        // 中速
    AIRCONDITION_WINDMODE_LOW,           // 低速
} EM_AIRCONDITION_WINDMODE;

// 空调工作状态信息烟雾检测
typedef struct tagNET_AIRCONDITION_STATE_INFO
{
    DWORD                       dwSize;
    BOOL                        bIsOnline;                    // 是否在线
    BOOL                        bIsON;                        // 是否开启
    int                         nTemperature;                 // 空调设定温度
    EM_AIRCONDITION_MODE        emAirconditionMode;           // 空调工作模式
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;       // 空调送风模式
    float                       fActualTemperature;           // 环境实际温度
}NET_AIRCONDITION_STATE_INFO;

// 获取空调工作状态(对应DH_DEVSTATE_AIRCONDITION_STATE命令)
typedef struct tagNET_GET_AIRCONDITION_STATE
{
    DWORD                       dwSize;
    char                        szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
    NET_AIRCONDITION_STATE_INFO stuAirConditionState;           // 空调工作状态信息
}NET_GET_AIRCONDITION_STATE;

// 开关量报警通道信息
typedef struct tagNET_ALARM_CHANNEL_INFO 
{
    DWORD                       dwSize;
    int                         nSlot;                          // 根地址, 0表示本地通道, 1表示连接在第一个串口上的扩展通道, 2、3...以此类推
    int                         nChannel;                       // 非本地报警通道在扩展模块上的通道号, 从0开始
    char                        szName[DH_COMMON_STRING_128];   // 通道名称
}NET_ALARM_CHANNEL_INFO;

// 本地(或远程)开关量报警通道和逻辑通道号映射关系
typedef struct tagNET_ALARM_CHANNELS 
{
    DWORD                       dwSize;
    int                         nMaxAlarmChannels;              // 最大通道数
    int                         nRetAlarmChannels;              // 返回的通道数
    NET_ALARM_CHANNEL_INFO*     pstuChannelInfo;                // 通道信息,用户分配内存
}NET_ALARM_CHANNELS;

// 报警子系统状态类型
typedef enum __EM_ALARM_SUBSYSTEM_STATE_TYPE
{
    ALARM_SUBSYSTEM_STATE_UNKNOWN = 0,
    ALARM_SUBSYSTEM_STATE_ACTIVE,               // 已激活
    ALARM_SUBSYSTEM_STATE_INACTIVE,             // 未激活
    ALARM_SUBSYSTEM_STATE_UNDISTRIBUTED,        // 未分配
}EM_ALARM_SUBSYSTEM_STATE_TYPE;

// 报警子系统状态, CLIENT_QueryDevState对应命令DH_DEVSTATE_ALARMSUBSYSTEM_STATE
typedef struct tagNET_ALARM_SUBSYSTEM_STATE
{
    DWORD          dwSize;
    int            nMaxAlarmSubSystem;                                  // 有效子系统个数
    EM_ALARM_SUBSYSTEM_STATE_TYPE  emState[DH_MAX_ALARM_SUBSYSTEM_NUM]; // 子系统状态信息
}NET_ALARM_SUBSYSTEM_STATE;


// 故障类型
typedef enum __EM_ALARM_FAULT_STATE_TYPE
{
    EM_ALARM_FAULT_STATE_ALL = 0,                // 所有类型
    EM_ALARM_FAULT_STATE_CONNECTFAULT,           // 连接故障
    EM_ALARM_FAULT_STATE_BELLFAULT,              // 警号故障
    EM_ALARM_FAULT_STATE_KBFAULT,                // 键盘故障
    EM_ALARM_FAULT_STATE_KBTAMPER,               // 键盘防拆
    EM_ALARM_FAULT_STATE_SENSORSHORTOUT,         // 传感器短路
    EM_ALARM_FAULT_STATE_SENSORTAMPER,           // 传感器防拆
}EM_ALARM_FAULT_STATE_TYPE;

// 报警故障状态, 输入参数
typedef struct tagNET_IN_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    EM_ALARM_FAULT_STATE_TYPE   emType;           // 待查询的类型
}NET_IN_ALARM_FAULT_STATE;

// 报警故障状态, 输出参数
typedef struct tagNET_OUT_ALARM_FAULT_STATE
{
    DWORD           dwSize;
    int             nConnectFaultState;                     // 0: 未知, 1: 正常, 2:故障
    int             nBell;                                  // 警号有效个数 
    int             anBellState[DH_MAX_BELL_NUM];           // 警号故障状态信息 0: 未知, 1: 正常, 2:故障
    int             nFaultKeyboard;                         // 键盘故障有效个数
    int             anFaultKeyboard[DH_MAX_KEYBOARD_NUM];   // 键盘故障信息 0: 未知, 1: 正常, 2:故障
    int             nTamperKeyboard;                        // 键盘有效防拆个数 
    int             anTamperKeyboard[DH_MAX_KEYBOARD_NUM];  // 键盘防拆信息 0: 未知, 1: 正常, 2:故障
    int             nShortOutSensor;                        // 传感器有效短路个数
    int             anShortOutSensor[DH_MAX_ALARMIN];       // 传感器短路信息 0: 未知, 1: 正常, 2:故障
    int             nTamperSensor;                          // 传感器有效防拆个数
    int             anTamperSensor[DH_MAX_ALARMIN];         // 传感器防拆信息 0: 未知, 1: 正常, 2:故障
}NET_OUT_ALARM_FAULT_STATE;

// 报警故障状态, CLIENT_QueryDevState对应命令DH_DEVSTATE_ALARM_FAULT_STATE
typedef struct tagNET_ALARM_FAULT_STATE_INFO
{
    DWORD           dwSize;
    NET_IN_ALARM_FAULT_STATE    stuIn;           // 输入参数
    NET_OUT_ALARM_FAULT_STATE   stuOut;          // 输出参数
}NET_ALARM_FAULT_STATE_INFO;

// 防区状态类型
typedef enum __EM_DEFENCE_STATE_TYPE
{
    EM_DEFENCE_STATE_UNKNOWN = 0,
    EM_DEFENCE_STATE_BYPASS,                     // 旁路
    EM_DEFENCE_STATE_OPEN,                       // 打开, 指撤防情况下发生报警
    EM_DEFENCE_STATE_CLOSE,                      // 关闭
    EM_DEFENCE_STATE_ALARMING,                   // 报警, 指布防情况下发生报警
    EM_DEFENCE_STATE_ISOLATED,					 //隔离
    EM_DEFENCE_STATE_SHORT,						 //短路
    EM_DEFENCE_STATE_BREAK,						 //断路
    EM_DEFENCE_STATE_INTRUDED,					 //防拆
}EM_DEFENCE_STATE_TYPE;

// 防区状态信息的输入参数
typedef struct tagNET_IN_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    int             nDefenceNum;                 // 防区有效个数, -1表示查询所有防区
    int             anDefence[DH_MAX_ALARMIN];   // 待查询的防区号
}NET_IN_DEFENCE_STATE_INFO;

// 防区状态信息的输出参数
typedef struct tagNET_OUT_DEFENCE_STATE_INFO
{
    DWORD           dwSize;
    int             nDefenceNum;                            // 防区有效个数
    EM_DEFENCE_STATE_TYPE  anDefenceState[DH_MAX_ALARMIN];  // 防区状态信息
}NET_OUT_DEFENCE_STATE_INFO;

// 获取防区状态信息的输入参数
typedef struct tagNET_IN_GET_DEFENCE_STATE_INFO 
{
    int             nDefenceNum;                 // 防区有效个数, -1表示查询所有防区
    int             anDefence[512];   			 // 待查询的防区号
    BYTE			byReserved[512];				 //保留字节
}NET_IN_GET_DEFENCE_STATE_INFO;

// 获取防区状态信息的输出参数
typedef struct tagNET_OUT_GET_DEFENCE_STATE_INFO
{
    int             		nDefenceNum;                    // 防区有效个数
    EM_DEFENCE_STATE_TYPE   anDefenceState[512];  			// 防区状态信息
    BYTE					byReserved[512];					//保留字节
}NET_OUT_GET_DEFENCE_STATE_INFO;

// 防区状态信息, CLIENT_QueryDevState对应命令DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;									// 结构体大小
    NET_IN_DEFENCE_STATE_INFO   stuIn;                      // 输入参数
    NET_OUT_DEFENCE_STATE_INFO  stuOut;                     // 输出参数
}NET_DEFENCE_STATE_INFO;

//  防区状态信息, CLIENT_QueryDevState对应命令DH_DEVSTATE_DEFENCE_STATE
typedef struct tagNET_GET_DEFENCE_STATE_INFO 
{
    DWORD           dwSize;
    NET_IN_GET_DEFENCE_STATE_INFO   stuIn;         // 输入参数
    NET_OUT_GET_DEFENCE_STATE_INFO  stuOut;        // 输出参数
}NET_GET_DEFENCE_STATE_INFO;

// 视频电话呼叫类型
typedef enum tagEM_NET_VTP_CALL_TYPE
{
    EM_NET_VTP_CALL_TYPE_SIP = 0,                           // SIP呼叫
    EM_NET_VTP_CALL_TYPE_GSM,                               // GSM呼叫
    EM_NET_VTP_CALL_TYPE_PRIVATE,                           // 私有协议呼叫
}EM_NET_VTP_CALL_TYPE;

// 视频电话呼叫状态类型
typedef enum tagEM_NET_VTP_CALL_STATE_TYPE
{
    EM_NET_VTP_CALL_STATE_UNKNOWN = 0,
    EM_NET_VTP_CALL_STATE_IDLE,                              // 初始状态
    EM_NET_VTP_CALL_STATE_CALLING,                           // 主叫呼叫状态(对方未回应)
    EM_NET_VTP_CALL_STATE_CALLED,                            // 被叫呼叫状态
    EM_NET_VTP_CALL_STATE_RINGING,                           // 主叫回铃状态(对方回应, 但没有接听)
    EM_NET_VTP_CALL_STATE_CONNECTING,                        // 通话中状态
    EM_NET_VTP_CALL_STATE_CONNECTING2,                       // 通话中2状态(通话媒体变更后的通话中状态)
    EM_NET_VTP_CALL_STATE_DISCONNECT,                        // 通话挂断状态
}EM_NET_VTP_CALL_STATE_TYPE;

// 获取视频电话呼叫状态 (对应 DH_DEVSTATE_VTP_CALLSTATE)
typedef struct tagNET_GET_VTP_CALLSTATE 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // 待查询的呼叫类型, 输入参数
    char                        szCallID[DH_COMMON_STRING_128]; // 待查询的对讲唯一标识, 输入参数
    const char*                 szTargetID;                     // 待转发的设备ID, 为NULL表示不转发, 输入参数
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // 呼叫状态
}NET_GET_VTP_CALLSTATE;

// 查询类型,对应CLIENT_QueryRemotDevState接口
#define DH_DEVSTATE_ALARM_REMOTE          0x1000           // 获取远程设备外部报警(对应 ALARM_REMOTE_ALARM_INFO)
#define DH_DEVSTATE_ALARM_FRONTDISCONNECT 0x1001           // 获取前端IPC断网报警(对应结构体ALARM_FRONTDISCONNET_INFO)

// 配置类型,对应CLIENT_GetDevConfig和CLIENT_SetDevConfig接口
#define DH_DEV_DEVICECFG                  0x0001           // 设备属性配置
#define DH_DEV_NETCFG                     0x0002           // 网络配置
#define DH_DEV_CHANNELCFG                 0x0003           // 图象通道配置
#define DH_DEV_PREVIEWCFG                 0x0004           // 预览参数配置
#define DH_DEV_RECORDCFG                  0x0005           // 录像配置
#define DH_DEV_COMMCFG                    0x0006           // 串口属性配置
#define DH_DEV_ALARMCFG                   0x0007           // 报警属性配置
#define DH_DEV_TIMECFG                    0x0008           // DVR时间配置
#define DH_DEV_TALKCFG                    0x0009           // 对讲参数配置
#define DH_DEV_AUTOMTCFG                  0x000A           // 自动维护配置        
#define DH_DEV_VEDIO_MARTIX               0x000B           // 本机矩阵控制策略配置    
#define DH_DEV_MULTI_DDNS                 0x000C           // 多ddns服务器配置
#define DH_DEV_SNAP_CFG                   0x000D           // 抓图相关配置
#define DH_DEV_WEB_URL_CFG                0x000E           // HTTP路径配置
#define DH_DEV_FTP_PROTO_CFG              0x000F           // FTP上传配置
#define DH_DEV_INTERVIDEO_CFG             0x0010           // 平台接入配置,此时channel参数代表平台类型,
                                                           // channel=4： 代表贝尔阿尔卡特；channel=10：代表中兴力维；channel=11：代表U网通；channel=51：代表天地阳光
#define DH_DEV_VIDEO_COVER                0x0011           // 区域遮挡配置
#define DH_DEV_TRANS_STRATEGY             0x0012           // 传输策略配置,画质优先\流畅性优先
#define DH_DEV_DOWNLOAD_STRATEGY          0x0013           // 录象下载策略配置,高速下载\普通下载
#define DH_DEV_WATERMAKE_CFG              0x0014           // 图象水印配置
#define DH_DEV_WLAN_CFG                   0x0015           // 无线网络配置
#define DH_DEV_WLAN_DEVICE_CFG            0x0016           // 搜索无线设备配置
#define DH_DEV_REGISTER_CFG               0x0017           // 主动注册参数配置
#define DH_DEV_CAMERA_CFG                 0x0018           // 摄像头属性配置
#define DH_DEV_INFRARED_CFG               0x0019           // 红外报警配置
#define DH_DEV_SNIFFER_CFG                0x001A           // Sniffer抓包配置
#define DH_DEV_MAIL_CFG                   0x001B           // 邮件配置
#define DH_DEV_DNS_CFG                    0x001C           // DNS服务器配置
#define DH_DEV_NTP_CFG                    0x001D           // NTP配置
#define DH_DEV_AUDIO_DETECT_CFG           0x001E           // 音频检测配置
#define DH_DEV_STORAGE_STATION_CFG        0x001F           // 存储位置配置
#define DH_DEV_PTZ_OPT_CFG                0x0020           // 云台操作属性(已经废除,请使用CLIENT_GetPtzOptAttr获取云台操作属性)
#define DH_DEV_DST_CFG                    0x0021           // 夏令时配置
#define DH_DEV_ALARM_CENTER_CFG           0x0022           // 报警中心配置
#define DH_DEV_VIDEO_OSD_CFG              0x0023           // 视频OSD叠加配置
#define DH_DEV_CDMAGPRS_CFG               0x0024           // CDMA\GPRS网络配置
#define DH_DEV_IPFILTER_CFG               0x0025           // IP过滤配置
#define DH_DEV_TALK_ENCODE_CFG            0x0026           // 语音对讲编码配置
#define DH_DEV_RECORD_PACKET_CFG          0x0027           // 录像打包长度配置
#define DH_DEV_MMS_CFG                    0x0028           // 短信MMS配置 
#define DH_DEV_SMSACTIVATION_CFG          0x0029           // 短信激活无线连接配置
#define DH_DEV_DIALINACTIVATION_CFG       0x002A           // 拨号激活无线连接配置
#define DH_DEV_SNIFFER_CFG_EX             0x0030           // 网络抓包配置
#define DH_DEV_DOWNLOAD_RATE_CFG          0x0031           // 下载速度限制
#define DH_DEV_PANORAMA_SWITCH_CFG        0x0032           // 全景切换报警配置
#define DH_DEV_LOST_FOCUS_CFG             0x0033           // 失去焦点报警配置
#define DH_DEV_ALARM_DECODE_CFG           0x0034           // 报警解码器配置
#define DH_DEV_VIDEOOUT_CFG               0x0035           // 视频输出参数配置
#define DH_DEV_POINT_CFG                  0x0036           // 预制点使能配置
#define DH_DEV_IP_COLLISION_CFG           0x0037           // Ip冲突检测报警配置
#define DH_DEV_OSD_ENABLE_CFG             0x0038           // OSD叠加使能配置
#define DH_DEV_LOCALALARM_CFG             0x0039           // 本地报警配置(结构体DH_ALARMIN_CFG_EX)
#define DH_DEV_NETALARM_CFG               0x003A           // 网络报警配置(结构体DH_ALARMIN_CFG_EX)
#define DH_DEV_MOTIONALARM_CFG            0x003B           // 动检报警配置(结构体DH_MOTION_DETECT_CFG_EX)
#define DH_DEV_VIDEOLOSTALARM_CFG         0x003C           // 视频丢失报警配置(结构体DH_VIDEO_LOST_CFG_EX)
#define DH_DEV_BLINDALARM_CFG             0x003D           // 视频遮挡报警配置(结构体DH_BLIND_CFG_EX)
#define DH_DEV_DISKALARM_CFG              0x003E           // 硬盘报警配置(结构体DH_DISK_ALARM_CFG_EX)
#define DH_DEV_NETBROKENALARM_CFG         0x003F           // 网络中断报警配置(结构体DH_NETBROKEN_ALARM_CFG_EX)
#define DH_DEV_ENCODER_CFG                0x0040           // 数字通道的前端编码器信息（混合DVR使用,结构体DEV_ENCODER_CFG）
#define DH_DEV_TV_ADJUST_CFG              0x0041           // TV调节配置（channel代表TV号(0开始),类型结构体）
#define DH_DEV_ABOUT_VEHICLE_CFG          0x0042           // 车载相关配置,北京公交使用
#define DH_DEV_ATM_OVERLAY_ABILITY        0x0043           // 获取atm叠加支持能力信息
#define DH_DEV_ATM_OVERLAY_CFG            0x0044           // atm叠加配置,新atm特有
#define DH_DEV_DECODER_TOUR_CFG           0x0045           // 解码器解码轮巡配置
#define DH_DEV_SIP_CFG                    0x0046           // SIP配置
#define DH_DEV_VICHILE_WIFI_AP_CFG        0x0047           // wifi ap配置
#define DH_DEV_STATICALARM_CFG            0x0048           // 静态报警配置 
#define DH_DEV_DECODE_POLICY_CFG          0x0049           // 设备的解码策略配置(结构体DHDEV_DECODEPOLICY_CFG,channel为解码通道0开始) 
#define DH_DEV_MACHINE_CFG                0x004A           // 机器相关的配置(结构体DHDEV_MACHINE_CFG)
#define DH_DEV_MAC_COLLISION_CFG          0x004B           // MAC冲突检测配置(结构体 ALARM_MAC_COLLISION_CFG)
#define DH_DEV_RTSP_CFG                   0x004C           // RTSP配置(对应结构体DHDEV_RTSP_CFG)
#define DH_DEV_232_COM_CARD_CFG           0x004E           // 232串口卡号信号事件配置(对应结构体COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_485_COM_CARD_CFG           0x004F           // 485串口卡号信号事件配置(对应结构体COM_CARD_SIGNAL_LINK_CFG)
#define DH_DEV_FTP_PROTO_CFG_EX           0x0050           // FTP上传扩展配置(对应结构体DHDEV_FTP_PROTO_CFG_EX)
#define DH_DEV_SYSLOG_REMOTE_SERVER       0x0051           // SYSLOG 远程服务器配置(对应结构体DHDEV_SYSLOG_REMOTE_SERVER)
#define DH_DEV_COMMCFG_EX                 0x0052           // 扩展串口属性配置(对应结构体DHDEV_COMM_CFG_EX)            
#define DH_DEV_NETCARD_CFG                0x0053           // 卡口信息配置(对应结构体DHDEV_NETCARD_CFG)
#define DH_DEV_BACKUP_VIDEO_FORMAT        0x0054           // 视频备份格式配置(对应结构体DHDEV_BACKUP_VIDEO_FORMAT)
#define DH_DEV_STREAM_ENCRYPT_CFG         0x0055           // 码流加密配置(对应结构体DHEDV_STREAM_ENCRYPT)
#define DH_DEV_IPFILTER_CFG_EX            0x0056           // IP过滤配置扩展(对应结构体DHDEV_IPIFILTER_CFG_EX)
#define DH_DEV_CUSTOM_CFG                 0x0057           // 用户自定义配置(对应结构体DHDEV_CUSTOM_CFG)
#define DH_DEV_WLAN_DEVICE_CFG_EX         0x0058           // 搜索无线设备扩展配置(对应结构体DHDEV_WLAN_DEVICE_LIST_EX)
#define DH_DEV_ACC_POWEROFF_CFG           0x0059           // ACC断线事件配置(对应结构体DHDEV_ACC_POWEROFF_CFG)
#define DH_DEV_EXPLOSION_PROOF_CFG        0x005a           // 防爆盒报警事件配置(对应结构体DHDEV_EXPLOSION_PROOF_CFG)
#define DH_DEV_NETCFG_EX                  0x005b           // 网络扩展配置(对应结构体DHDEV_NET_CFG_EX)
#define DH_DEV_LIGHTCONTROL_CFG           0x005c           // 灯光控制配置(对应结构体DHDEV_LIGHTCONTROL_CFG)
#define DH_DEV_3GFLOW_CFG                 0x005d           // 3G流量信息配置(对应结构体DHDEV_3GFLOW_INFO_CFG)
#define DH_DEV_IPV6_CFG                   0x005e           // IPv6配置(对应结构体DHDEV_IPV6_CFG)
#define DH_DEV_SNMP_CFG                   0x005f           // Snmp配置(对应结构体DHDEV_NET_SNMP_CFG), 设置完成后需要重启设备
#define DH_DEV_SNAP_CONTROL_CFG           0x0060           // 抓图开关配置(对应结构体DHDEV_SNAP_CONTROL_CFG)
#define DH_DEV_GPS_MODE_CFG               0x0061           // GPS定位模式配置(对应结构体DHDEV_GPS_MODE_CFG)
#define DH_DEV_SNAP_UPLOAD_CFG            0x0062           // 图片上传配置信息(对应结构体 DHDEV_SNAP_UPLOAD_CFG)
#define DH_DEV_SPEED_LIMIT_CFG            0x0063           // 限速配置信息(对应结构体DHDEV_SPEED_LIMIT_CFG)
#define DH_DEV_ISCSI_CFG                  0x0064           // iSCSI配置(对应结构体DHDEV_ISCSI_CFG), 设置完成后需要重启设备
#define DH_DEV_WIRELESS_ROUTING_CFG       0x0065           // 无线路由配置(对应结构体DHDEV_WIRELESS_ROUTING_CFG)
#define DH_DEV_ENCLOSURE_CFG              0x0066           // 电子围栏配置(对应结构体DHDEV_ENCLOSURE_CFG)
#define DH_DEV_ENCLOSURE_VERSION_CFG      0x0067           // 电子围栏版本号配置(对应结构体DHDEV_ENCLOSURE_VERSION_CFG)
#define DH_DEV_RIAD_EVENT_CFG             0x0068           // Raid事件配置(对应结构体DHDEV_RAID_EVENT_CFG)
#define DH_DEV_FIRE_ALARM_CFG             0x0069           // 火警报警配置(对应结构体DHDEV_FIRE_ALARM_CFG)
#define DH_DEV_LOCALALARM_NAME_CFG        0x006a           // 本地名称报警配置(对应Name1&&name2&&name3...格式字符串)
#define DH_DEV_URGENCY_RECORD_CFG         0x0070           // 紧急存储配置(对应结构体DHDEV_URGENCY_RECORD_CFG)
#define DH_DEV_ELEVATOR_ATTRI_CFG         0x0071           // 电梯运行参数配置(对应结构体DHDEV_ELEVATOR_ATTRI_CFG)
#define DH_DEV_ATM_OVERLAY_CFG_EX         0x0072           // atm叠加配置,新atm特有,支持大于32通道的设备(对应结构体DHDEV_ATM_OVERLAY_CONFIG_EX)
#define DH_DEV_MACFILTER_CFG              0x0073           // MAC过滤配置(对应结构体DHDEV_MACFILTER_CFG)
#define DH_DEV_MACIPFILTER_CFG            0x0074           // MAC,IP过滤(要求ip,mac是一一对应的)配置(对应结构体DHDEV_MACIPFILTER_CFG)
#define DH_DEV_STREAM_ENCRYPT_TIME_CFG    0x0075           // 码流加密(加密计划)配置(对应结构体DHEDV_STREAM_ENCRYPT)
#define DH_DEV_LIMIT_BIT_RATE_CFG         0x0076           // 限码流配置(对应结构体 DHDEV_LIMIT_BIT_RATE) 
#define DH_DEV_SNAP_CFG_EX                0x0077           // 抓图相关配置扩展(对应结构体 DHDEV_SNAP_CFG_EX)
#define DH_DEV_DECODER_URL_CFG            0x0078           // 解码器url配置(对应结构体DHDEV_DECODER_URL_CFG)
#define DH_DEV_TOUR_ENABLE_CFG            0x0079           // 轮巡使能配置(对应结构体DHDEV_TOUR_ENABLE_CFG)
#define DH_DEV_VICHILE_WIFI_AP_CFG_EX     0x007a           // wifi ap配置扩展(对应结构体DHDEV_VEHICLE_WIFI_AP_CFG_EX)
#define DH_DEV_ENCODER_CFG_EX             0x007b           // 数字通道的前端编码器信息扩展,(对应结构体 DEV_ENCODER_CFG_EX)

// 下面几个是虚点测速仪的几个配置项
#define DH_DEV_ITC_HWS000_RA_CFG          0x007c             // 虚点测速仪雷达角度配置(对应一个int值)
#define DH_DEV_ITC_HWS000_HS_CFG          0x007d             // 虚点测速仪超速触发值配置(对应一个int值)
#define DH_DEV_ITC_HWS000_LS_CFG          0x007e             // 虚点测速仪欠速触发值配置(对应一个int值)
#define DH_DEV_ITC_HWS000_FL_CFG          0x007f             // 虚点测速仪闪光灯亮度配置(对应一个int值)
#define DH_DEV_ITC_HWS000_OC_CFG          0x0080             // 虚点测速仪超速总计数配置(对应一个int值)
#define DH_DEV_ITC_HWS000_LC_CFG          0x0081             // 虚点测速仪欠速总计数配置(对应一个int值)
#define DH_DEV_ITC_HWS000_AC_CFG          0x0082             // 虚点测速仪违章总计数配置(对应一个int值)
#define DH_DEV_ITC_HWS000_FC_CFG          0x0083             // 虚点测速仪闪光灯闪烁次数配置(对应一个int值)
#define DH_DEV_ITC_HWS000_ALL_CFG         0x0084             // 虚点测速仪查询以上全部的数值配置(对应DEV_ITC_HWS000_ALL_CFG)
#define DH_DEV_ITC_HWS000_CLEAR_COUNT_CFG 0x0085             // 虚点测速仪清零4种计数配置(OC,LC,AC,FC 对应一个int值)

#define DH_DEV_IPV4_CFG					  0x0086			 // IPV4配置(对应结构体 DEV_IPV4_CFG)
#define DH_DEV_ENCODER_CFG_EX2			  0x0087		   // 数字通道的前端编码器信息扩展,(对应结构体 DEV_ENCODER_CFG_EX2)
#define DH_DEV_WLAN_DEVICE_CFG_EX2        0x0088           // 搜索无线设备扩展配置(对应结构体DHDEV_WLAN_DEVICE_LIST_EX2)

#define DH_DEV_USER_END_CFG               1000
#define DH_DEV_ITC_HWS000_CFG_ITEM_NUM    8                     // 虚点测速仪的配置项数目
// 虚点测速仪所有配置项
typedef struct tagDEV_ITC_HWS000_ALL_CFG
{
    DWORD dwSize;
    int nValue[DH_DEV_ITC_HWS000_CFG_ITEM_NUM]; // 配置项的值
                                                // 从索引0开始 依次是雷达角度，超速触发值，欠速触发值，闪光灯亮度，超速总计数，欠速总计数，违章总计数，闪光灯闪烁次数
}DEV_ITC_HWS000_ALL_CFG;

// 报警类型,对应CLIENT_StartListen接口
#define DH_COMM_ALARM                     0x1100           // 常规报警(包括外部报警,视频丢失,动态检测)
#define DH_SHELTER_ALARM                  0x1101           // 视频遮挡报警
#define DH_DISK_FULL_ALARM                0x1102           // 硬盘满报警
#define DH_DISK_ERROR_ALARM               0x1103           // 硬盘故障报警
#define DH_SOUND_DETECT_ALARM             0x1104           // 音频检测报警
#define DH_ALARM_DECODER_ALARM            0x1105           // 报警解码器报警

// 扩展报警类型,对应CLIENT_StartListenEx接口
#define DH_ALARM_ALARM_EX                 0x2101           // 外部报警，数据字节数与设备报警通道个数相同，每个字节表示一个报警通道的报警状态，1为有报警，0为无报警。
#define DH_MOTION_ALARM_EX                0x2102           // 动态检测报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的动态检测报警状态，1为有报警，0为无报警。
#define DH_VIDEOLOST_ALARM_EX             0x2103           // 视频丢失报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的视频丢失报警状态，1为有报警，0为无报警。
#define DH_SHELTER_ALARM_EX               0x2104           // 视频遮挡报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的遮挡(黑屏)报警状态，1为有报警，0为无报警。
#define DH_SOUND_DETECT_ALARM_EX          0x2105           // 音频检测报警，数据为16个字节，每个字节表示一个视频通道的音频检测报警状态，1为有报警，0为无报警。
#define DH_DISKFULL_ALARM_EX              0x2106           // 硬盘满报警，数据为1个字节，1为有硬盘满报警，0为无报警。
#define DH_DISKERROR_ALARM_EX             0x2107           // 坏硬盘报警，数据为32个字节，每个字节表示一个硬盘的故障报警状态，1为有报警，0为无报警。
#define DH_ENCODER_ALARM_EX               0x210A           // 编码器报警，数据为16个字节，每个字节表示一个通道编码器状态，1为有报警，0为无报警。
#define DH_URGENCY_ALARM_EX               0x210B           // 紧急报警，数据为16个字节，每个字节表示一个通道编码器状态，1为有报警，0为无报警。
#define DH_WIRELESS_ALARM_EX              0x210C           // 无线报警，数据为16个字节，每个字节表示一个通道编码器状态，1为有报警，0为无报警。
#define DH_NEW_SOUND_DETECT_ALARM_EX      0x210D           // 新音频检测报警,报警信息的结构体见DH_NEW_SOUND_ALARM_STATE；
#define DH_ALARM_DECODER_ALARM_EX         0x210E           // 报警解码器报警，报警信息的结构体见 ALARM_DECODER_ALARM
#define DH_DECODER_DECODE_ABILITY         0x210F           // 解码器：解码能力报警，数据为一个字节，0：能正常解码 1：表示超出解码能力。
#define DH_FDDI_DECODER_ABILITY           0x2110           // 光纤编码器状态报警，报警信息的结构体见 ALARM_FDDI_ALARM
#define DH_PANORAMA_SWITCH_ALARM_EX       0x2111           // 切换场景报警，数据为16个字节，每个字节表示一个通道编码器状态，1为有报警，0为无报警。
#define DH_LOSTFOCUS_ALARM_EX             0x2112           // 失去焦点报警，数据为16个字节，每个字节表示一个通道编码器状态，1为有报警，0为无报警。
#define DH_OEMSTATE_EX                    0x2113           // oem报停状态，数据为 1 BYTE。
#define DH_DSP_ALARM_EX                   0x2114           // DSP报警，报警信息的结构体见 DSP_ALARM
#define DH_ATMPOS_BROKEN_EX               0x2115           // atm和pos机断开报警, 数据为 1 BYTE，0：连接断开 1：连接正常
#define DH_RECORD_CHANGED_EX              0x2116           // 录像状态变化报警，报警信息为 ALARM_RECORDING_CHANGED 数组
#define DH_CONFIG_CHANGED_EX              0x2117           // 配置发生变化报警，数据 无
#define DH_DEVICE_REBOOT_EX               0x2118           // 设备重启报警，数据 无
#define DH_WINGDING_ALARM_EX              0x2119           // 线圈/车检器故障报警(对应结构体 ALARM_WINGDING_INFO)
#define DH_TRAF_CONGESTION_ALARM_EX       0x211A           // 交通阻塞报警(车辆出现异常停止或者排队)(对应结构体 ALARM_TRAF_CONGESTION_INFO)
#define DH_TRAF_EXCEPTION_ALARM_EX        0x211B           // 交通异常报警(交通流量趋于0或异常空闲)(对应结构体 ALARM_TRAF_EXCEPTION_INFO)
#define DH_EQUIPMENT_FILL_ALARM_EX        0x211C           // 补光设备故障报警(对应结构体 ALARM_EQUIPMENT_FILL_INFO)
#define DH_ALARM_ARM_DISARM_STATE         0x211D           // 报警布撤防状态(对应结构体 ALARM_EQUIPMENT_FILL_INFO)
#define DH_ALARM_ACC_POWEROFF             0x211E           // ACC断电报警，数据为 DWORD 0：ACC通电 1：ACC断电 
#define DH_ALARM_3GFLOW_EXCEED            0x211F           // 3G流量超出阈值报警(对应结构体 DHDEV_3GFLOW_EXCEED_STATE_INFO)
#define DH_ALARM_SPEED_LIMIT              0x2120           // 限速报警(对应结构体 ALARM_SPEED_LIMIT)
#define DH_ALARM_VEHICLE_INFO_UPLOAD      0x2121           // 车载自定义信息上传 (对应结构体 ALARM_VEHICLE_INFO_UPLOAD)
#define DH_STATIC_ALARM_EX                0x2122           // 静态检测报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的静态检测报警状态，1为有报警，0为无报警。
#define DH_PTZ_LOCATION_EX                0x2123           // 云台定位信息(对应结构体 DH_PTZ_LOCATION_INFO)
#define DH_ALARM_CARD_RECORD_UPLOAD       0x2124           // 卡号录像信息上传(对应结构体 ALARM_CARD_RECORD_INFO_UPLOAD)
#define DH_ALARM_ATM_INFO_UPLOAD          0x2125           // ATM交易信息上传(对应结构体 ALARM_ATM_INFO_UPLOAD)
#define DH_ALARM_ENCLOSURE                0x2126           // 电子围栏报警(对应结构体 ALARM_ENCLOSURE_INFO)
#define DH_ALARM_SIP_STATE                0x2127           // SIP状态报警(对应结构体 ALARM_SIP_STATE)
#define DH_ALARM_RAID_STATE               0x2128           // RAID异常报警(对应结构体 ALARM_RAID_INFO)
#define DH_ALARM_CROSSING_SPEED_LIMIT     0x2129           // 路口限速报警(对应结构体 ALARM_SPEED_LIMIT)
#define DH_ALARM_OVER_LOADING             0x212A           // 超载报警(对应结构体ALARM_OVER_LOADING)
#define DH_ALARM_HARD_BRAKING             0x212B           // 急刹车报警(对应机构体ALARM_HARD_BRAKING)
#define DH_ALARM_SMOKE_SENSOR             0x212C           // 烟感报警(对应结构体ALARM_SMOKE_SENSOR)
#define DH_ALARM_TRAFFIC_LIGHT_FAULT      0x212D           // 交通灯故障报警(对应结构体ALARM_TRAFFIC_LIGHT_FAULT) 
#define DH_ALARM_TRAFFIC_FLUX_STAT        0x212E           // 交通流量统计报警(对应结构体ALARM_TRAFFIC_FLUX_LANE_INFO)
#define DH_ALARM_CAMERA_MOVE              0x212F           // 摄像机移位报警事件(对应结构体ALARM_CAMERA_MOVE_INFO)
#define DH_ALARM_DETAILEDMOTION           0x2130           // 详细动检报警上报信息(对应结构体ALARM_DETAILEDMOTION_CHNL_INFO)
#define DH_ALARM_STORAGE_FAILURE          0x2131           // 存储异常报警(对应结构体 ALARM_STORAGE_FAILURE 数组)
#define DH_ALARM_FRONTDISCONNECT          0x2132           // 前端IPC断网报警(对应结构体ALARM_FRONTDISCONNET_INFO)
#define DH_ALARM_ALARM_EX_REMOTE          0x2133           // 远程外部报警(对应结构体 ALARM_REMOTE_ALARM_INFO)
#define DH_ALARM_BATTERYLOWPOWER          0x2134           // 电池电量低报警(对应结构体ALARM_BATTERYLOWPOWER_INFO)
#define DH_ALARM_TEMPERATURE              0x2135           // 温度过高报警(对应结构体 ALARM_TEMPERATURE_INFO)
#define DH_ALARM_TIREDDRIVE               0x2136           // 疲劳驾驶报警(对应结构体 ALARM_TIREDDRIVE_INFO)
#define DH_ALARM_LOST_RECORD              0x2137           // 丢录像事件报警(对应结构体ALARM_LOST_RECORD)
#define DH_ALARM_HIGH_CPU                 0x2138           // CPU占用率过高事件报警(对应结构体 ALARM_HIGH_CPU)
#define DH_ALARM_LOST_NETPACKET           0x2139           // 网络发送数据丢包事件报警(对应结构体 ALARM_LOST_NETPACKET)
#define DH_ALARM_HIGH_MEMORY              0x213A           // 内存占用率过高事件报警(对应结构体ALARM_HIGH_MEMORY)
#define DH_LONG_TIME_NO_OPERATION         0x213B           // WEB用户长时间无操作事件（无扩展信息）
#define DH_BLACKLIST_SNAP                 0x213C           // 黑名单车辆抓拍事件(对应结构体DH_BLACKLIST_SNAP_INFO)         
#define DH_ALARM_DISK                     0x213E           // 硬盘报警(对应 ALARM_DISK_INFO 数组)
#define DH_ALARM_FILE_SYSTEM              0x213F           // 文件系统报警(对应ALARM_FILE_SYSTEM_INFO数组)
#define DH_ALARM_IVS                      0x2140           // 智能报警事件(对应结构体ALARM_IVS_INFO)
#define DH_ALARM_GOODS_WEIGHT_UPLOAD      0x2141           // 货重信息上报(对应ALARM_GOODS_WEIGHT_UPLOAD_INFO)
#define DH_ALARM_GOODS_WEIGHT             0x2142           // 货重信息报警(对应ALARM_GOODS_WEIGHT_INFO)
#define DH_GPS_STATUS                     0x2143           // GPS定位信息(对应 NET_GPS_STATUS_INFO)
#define DH_ALARM_DISKBURNED_FULL          0x2144           // 硬盘刻录满报警(对应 ALARM_DISKBURNED_FULL_INFO)
#define DH_ALARM_STORAGE_LOW_SPACE        0x2145           // 存储容量不足事件(对应 ALARM_STORAGE_LOW_SPACE_INFO)
#define DH_ALARM_DISK_FLUX                0x2160           // 硬盘数据异常事件(对应 ALARM_DISK_FLUX)
#define DH_ALARM_NET_FLUX                 0x2161           // 网络数据异常事件(对应 ALARM_NET_FLUX)
#define DH_ALARM_FAN_SPEED                0x2162           // 风扇转速异常事件(对应 ALARM_FAN_SPEED)
#define DH_ALARM_STORAGE_FAILURE_EX       0x2163           // 存储错误报警(对应结构体ALARM_STORAGE_FAILURE_EX)
#define DH_ALARM_RECORD_FAILED            0x2164           // 录像异常报警(对应结构体ALARM_RECORD_FAILED_INFO)
#define DH_ALARM_STORAGE_BREAK_DOWN       0x2165           // 存储崩溃事件(对应结构体 ALARM_STORAGE_BREAK_DOWN_INFO)
#define DH_ALARM_VIDEO_ININVALID          0x2166           // 视频输入通道失效事件（例：配置的视频输入通道码流,超出设备处理能力）ALARM_VIDEO_ININVALID_INFO
#define DH_ALARM_VEHICLE_TURNOVER         0x2167           // 车辆侧翻报警事件(对应结构体ALARM_VEHICEL_TURNOVER_EVENT_INFO)
#define DH_ALARM_VEHICLE_COLLISION        0x2168           // 车辆撞车报警事件(对应结构体ALARM_VEHICEL_COLLISION_EVENT_INFO)
#define DH_ALARM_VEHICLE_CONFIRM          0x2169           // 车辆上传信息事件(对应结构体ALARM_VEHICEL_CONFIRM_INFO)
#define DH_ALARM_VEHICLE_LARGE_ANGLE      0x2170           // 车载摄像头大角度扭转事件(对应结构体ALARM_VEHICEL_LARGE_ANGLE)
#define DH_ALARM_TALKING_INVITE           0x2171           // 设备请求对方发起对讲事件(对应结构体ALARM_TALKING_INVITE_INFO)
#define DH_ALARM_ALARM_EX2                0x2175           // 本地报警事件(对应结构体 ALARM_ALARM_INFO_EX2,对DH_ALARM_ALARM_EX升级)
#define DH_ALARM_VIDEO_TIMING             0x2176           // 视频定时检测事件(对应结构体ALARM_VIDEO_TIMING)
#define DH_ALARM_COMM_PORT                0x2177           // 串口事件(对应结构体ALARM_COMM_PORT_EVENT_INFO)
#define DH_ALARM_AUDIO_ANOMALY            0x2178           // 音频异常事件(对应结构体ALARM_AUDIO_ANOMALY)
#define DH_ALARM_AUDIO_MUTATION           0x2179           // 声强突变事件(对应结构体ALARM_AUDIO_MUTATION)
#define DH_EVENT_TYREINFO                 0x2180           // 轮胎信息上报事件(对应结构体EVENT_TYRE_INFO)
#define DH_ALARM_POWER_ABNORMAL           0x2181           // 冗余电源异常报警(对应结构体ALARM_POWER_ABNORMAL_INFO)
#define DH_EVENT_REGISTER_OFF             0x2182           // 车载设备主动下线事件(对应结构体 EVENT_REGISTER_OFF_INFO)
#define DH_ALARM_NO_DISK                  0x2183           // 无硬盘报警(对应结构体ALARM_NO_DISK_INFO)
#define DH_ALARM_FALLING                  0x2184           // 跌落事件报警(对应结构体ALARM_FALLING_INFO)
#define DH_ALARM_PROTECTIVE_CAPSULE       0x2185           // 防护舱事件(对应结构体ALARM_PROTECTIVE_CAPSULE_INFO)
#define DH_ALARM_NO_RESPONSE              0x2186           // 呼叫未应答警报(对应结构体ALARM_NO_RESPONSE_INFO)
#define DH_ALARM_CONFIG_ENABLE_CHANGE     0x2187           // 配置使能改变上报事件(对应结构体 ALARM_CONFIG_ENABLE_CHANGE_INFO)
#define DH_EVENT_CROSSLINE_DETECTION      0x2188           // 警戒线事件( 对应结构体 ALARM_EVENT_CROSSLINE_INFO )
#define DH_EVENT_CROSSREGION_DETECTION    0x2189           // 警戒区事件( 对应结构体 ALARM_EVENT_CROSSREGION_INFO )
#define DH_EVENT_LEFT_DETECTION           0x218a           // 物品遗留事件( 对应结构体 ALARM_EVENT_LEFT_INFO )
#define DH_EVENT_FACE_DETECTION           0x218b           // 人脸检测事件( 对应结构体 ALARM_EVENT_FACE_INFO ) 
#define DH_ALARM_IPC                      0x218c           // IPC报警,IPC通过DVR或NVR上报的本地报警(对应结构体 ALARM_IPC_INFO)
#define DH_EVENT_TAKENAWAYDETECTION       0x218d           // 物品搬移事件(对应结构体 ALARM_TAKENAWAY_DETECTION_INFO)
#define DH_EVENT_VIDEOABNORMALDETECTION   0x218e           // 视频异常事件(对应结构体 ALARM_VIDEOABNORMAL_DETECTION_INFO)
#define DH_EVENT_MOTIONDETECT             0x218f           // 视频移动侦测事件(对应结构体 ALARM_MOTIONDETECT_INFO)
#define DH_ALARM_PIR                      0x2190           // PIR警报(对应BYTE*, pBuf长度dwBufLen)
#define DH_ALARM_STORAGE_HOT_PLUG         0x2191           // 存储热插拔事件(对应结构体 ALARM_STORAGE_HOT_PLUG_INFO)
#define DH_ALARM_FLOW_RATE                0x2192           // 流量使用情况事件(对应结构体 ALARM_FLOW_RATE_INFO)
#define DH_ALARM_MOVEDETECTION            0x2193           // 移动事件(对应ALARM_MOVE_DETECTION_INFO)
#define DH_ALARM_WANDERDETECTION          0x2194           // 徘徊事件(对应ALARM_WANDERDETECTION_INFO)
#define DH_ALARM_CROSSFENCEDETECTION      0x2195           // 翻越围栏事件(对应ALARM_CROSSFENCEDETECTION_INFO)
#define DH_ALARM_PARKINGDETECTION         0x2196           // 非法停车事件(对应ALARM_PARKINGDETECTION_INFO)
#define DH_ALARM_RIOTERDETECTION          0x2197           // 人员聚集事件(对应ALARM_RIOTERDETECTION_INFO)
#define DH_ALARM_STORAGE_NOT_EXIST        0x3167           // 存储组不存在事件(对应结构体 ALARM_STORAGE_NOT_EXIST_INFO)
#define DH_ALARM_NET_ABORT                0x3169           // 网络故障事件(对应结构体 ALARM_NETABORT_INFO)
#define DH_ALARM_IP_CONFLICT              0x3170           // IP冲突事件(对应结构体 ALARM_IP_CONFLICT_INFO)
#define DH_ALARM_MAC_CONFLICT             0x3171           // MAC冲突事件(对应结构体 ALARM_MAC_CONFLICT_INFO)
#define DH_ALARM_POWERFAULT               0x3172           // 电源故障事件(对应结构体ALARM_POWERFAULT_INFO)
#define DH_ALARM_CHASSISINTRUDED          0x3173           // 机箱入侵(防拆)报警事件(对应结构体ALARM_CHASSISINTRUDED_INFO)
#define DH_ALARM_ALARMEXTENDED            0x3174           // 本地扩展报警事件(对应结构体 ALARM_ALARMEXTENDED_INFO)
#define DH_ALARM_ARMMODE_CHANGE_EVENT     0x3175           // 布撤防状态变化事件(对应结构体ALARM_ARMMODE_CHANGE_INFO)
#define DH_ALARM_BYPASSMODE_CHANGE_EVENT  0x3176           // 旁路状态变化事件(对应结构体ALARM_BYPASSMODE_CHANGE_INFO)
#define DH_ALARM_ACCESS_CTL_NOT_CLOSE     0x3177           // 门禁未关事件(对应结构体ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
#define DH_ALARM_ACCESS_CTL_BREAK_IN      0x3178           // 闯入事件(对应结构体ALARM_ACCESS_CTL_BREAK_IN_INFO)
#define DH_ALARM_ACCESS_CTL_REPEAT_ENTER  0x3179           // 反复进入事件(对应结构体ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
#define DH_ALARM_ACCESS_CTL_DURESS        0x3180           // 胁迫卡刷卡事件(对应结构体ALARM_ACCESS_CTL_DURESS_INFO)
#define DH_ALARM_ACCESS_CTL_EVENT         0x3181           // 门禁事件(对应结构体 ALARM_ACCESS_CTL_EVENT_INFO)
#define DH_URGENCY_ALARM_EX2              0x3182           // 紧急报警EX2(对DH_URGENCY_ALARM_EX的升级,对应结构体ALARM_URGENCY_ALARM_EX2, 人为触发的紧急事件, 一般处理是联动外部通讯功能请求帮助
#define DH_ALARM_INPUT_SOURCE_SIGNAL      0x3183           // 报警输入源信号事件(只要有输入就会产生该事件, 不论防区当前的模式,无法屏蔽, 对应 ALARM_INPUT_SOURCE_SIGNAL_INFO )
#define DH_ALARM_ANALOGALARM_EVENT        0x3184           // 模拟量报警输入通道事件(对应结构体ALARM_ANALOGALARM_EVENT_INFO)
#define DH_ALARM_ACCESS_CTL_STATUS        0x3185           // 门禁状态事件(对应结构体ALARM_ACCESS_CTL_STATUS_INFO)
#define DH_ALARM_ACCESS_SNAP              0x3186           // 门禁抓图事件(对应结构体ALARM_ACCESS_SNAP_INFO)
#define DH_ALARM_ALARMCLEAR               0x3187           // 消警事件(对应结构体ALARM_ALARMCLEAR_INFO)
#define DH_ALARM_CIDEVENT                 0x3188           // CID事件(对应结构体 ALARM_CIDEVENT_INFO)
#define DH_ALARM_TALKING_HANGUP           0x3189           // 设备主动挂断对讲事件(对应结构体ALARM_TALKING_HANGUP_INFO)
#define DH_ALARM_BANKCARDINSERT           0x318a           // 银行卡插卡事件(对应结构体ALARM_BANKCARDINSERT_INFO)
#define DH_ALARM_RCEMERGENCY_CALL         0x318b           // 紧急呼叫报警事件(对应结构体 ALARM_RCEMERGENCY_CALL_INFO)
#define DH_ALARM_OPENDOORGROUP            0x318c           // 多人组合开门事件(对应结构体ALARM_OPEN_DOOR_GROUP_INFO)
#define DH_ALARM_FINGER_PRINT             0x318d           // 获取指纹事件(对应结构体 ALARM_CAPTURE_FINGER_PRINT_INFO)
#define DH_ALARM_CARD_RECORD              0x318e           // 卡号录像事件(对应结构体 ALARM_CARD_RECORD_INFO)
#define DH_ALARM_SUBSYSTEM_STATE_CHANGE   0x318f           // 子系统状态改变事件(对应结构体ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
#define DH_ALARM_BATTERYPOWER_EVENT       0x3190           // 电池电量定时通知事件(对应结构体 ALARM_BATTERYPOWER_INFO )
#define DH_ALARM_BELLSTATUS_EVENT         0x3191           // 警号状态事件(对应结构体ALARM_BELLSTATUS_INFO)
#define DH_ALARM_DEFENCE_STATE_CHANGE_EVENT 0x3192         // 防区状态变化事件(对应结构体ALARM_DEFENCE_STATUS_CHANGE_INFO), 
                                                           // 定制需求,和布防撤防变化事件、旁路状态变化事件中的状态定义不同,
                                                           // 该状态通过CLIENT_QueryDevState()接口的DH_DEVSTATE_DEFENCE_STATE命令获取
#define DH_ALARM_TICKET_STATISTIC         0x3193           // 车票统计信息事件(对应结构体 ALARM_TICKET_STATISTIC)
#define DH_ALARM_LOGIN_FAILIUR            0x3194           // 登陆失败事件(对应结构体ALARM_LOGIN_FAILIUR_INFO)
#define DH_ALARM_MODULE_LOST              0x3195           // 扩展模块掉线事件(对应结构体 ALARM_MODULE_LOST_INFO)
#define DH_ALARM_PSTN_BREAK_LINE          0x3196           // PSTN掉线事件(对应结构体ALARM_PSTN_BREAK_LINE_INFO)
#define DH_ALARM_ANALOG_PULSE             0x3197           // 模拟量报警事件(瞬时型事件), 特定传感器类型时才触发(对应结构体ALARM_ANALOGPULSE_INFO)
#define DH_ALARM_MISSION_CONFIRM          0x3198           // 任务确认事件(对应结构体 ALARM_MISSION_CONFIRM_INFO)
#define DH_ALARM_DEVICE_MSG_NOTIFY        0x3199           // 设备向平台发通知的事件(对应结构体 ALARM_DEVICE_MSG_NOTIFY_INFO)
#define DH_ALARM_VEHICLE_STANDING_OVER_TIME 0x319A         // 停车超时报警(对应结构体 ALARM_VEHICLE_STANDING_OVER_TIME_INFO)
#define DH_ALARM_ENCLOSURE_ALARM          0x319B           // 电子围栏事件(对应结构体 ALARM_ENCLOSURE_ALARM_INFO)
#define DH_ALARM_GUARD_DETECT             0x319C           // 岗亭检测事件,此事件岗亭有第一个人时上报start事件,岗亭最后一个人离开时上报stop 事件(对应结构体ALARM_GUARD_DETECT_INFO)
#define DH_ALARM_GUARD_INFO_UPDATE        0x319D           // 岗亭信息更新事件,只要岗亭有人员出入就上报(对应结构体ALARM_GUARD_UPDATE_INFO)  
#define DH_ALARM_NODE_ACTIVE              0x319E           // 节点激活事件(对应结构体ALARM_NODE_ACTIVE_INFO)
#define DH_ALARM_VIDEO_STATIC             0x319F           // 视频静态检测事件(对应结构体 ALARM_VIDEO_STATIC_INFO)
#define DH_ALARM_REGISTER_REONLINE        0x31a0           // 主动注册设备重新登陆事件(对应结构体ALARM_REGISTER_REONLINE_INFO)
#define DH_ALARM_ISCSI_STATUS             0x31a1           // ISCSI告警事件(对应结构体 ALARM_ISCSI_STATUS_INFO)
#define DH_ALARM_SCADA_DEV_ALARM          0x31a2           // 检测采集设备报警事件(对应结构体 ALARM_SCADA_DEV_INFO)
#define DH_ALARM_AUXILIARY_DEV_STATE      0x31a3           // 辅助设备状态(对应结构体ALARM_AUXILIARY_DEV_STATE)
#define DH_ALARM_PARKING_CARD             0x31a4           // 停车刷卡事件(对应结构体ALARM_PARKING_CARD)
#define DH_ALARM_PROFILE_ALARM_TRANSMIT   0x31a5           // 报警传输事件(对应结构体ALARM_PROFILE_ALARM_TRANSMIT_INFO)
#define DH_ALARM_VEHICLE_ACC              0x31a6           // 车辆ACC报警事件(对应结构体 ALARM_VEHICLE_ACC_INFO)
#define DH_ALARM_TRAFFIC_SUSPICIOUSCAR    0x31a7           // 嫌疑车辆上报事件(对应结构体 ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
#define DH_ALARM_ACCESS_LOCK_STATUS       0x31a8           // 门锁状态事件(对应结构体 ALARM_ACCESS_LOCK_STATUS_INFO)
#define DH_ALARM_FINACE_SCHEME            0x31a9           // 理财经办事件(对应结构体 ALARM_FINACE_SCHEME_INFO)
#define DH_ALARM_HEATIMG_TEMPER           0x31aa           // 热成像测温点温度异常报警事件(对应结构体 ALARM_HEATIMG_TEMPER_INFO)
#define DH_ALARM_TALKING_IGNORE_INVITE    0x31ab           // 设备取消对讲请求事件(对应结构体ALARM_TALKING_IGNORE_INVITE_INFO)
#define DH_ALARM_BUS_SHARP_TURN           0x31ac           // 车辆急转事件(对应结构体ALARM_BUS_SHARP_TURN_INFO)
#define DH_ALARM_BUS_SCRAM                0x31ad           // 车辆急停事件(对应结构体ALARM_BUS_SCRAM_INFO)
#define DH_ALARM_BUS_SHARP_ACCELERATE     0x31ae           // 车辆急加速事件(对应结构体ALARM_BUS_SHARP_ACCELERATE_INFO)
#define DH_ALARM_BUS_SHARP_DECELERATE     0x31af           // 车辆急减速事件(对应结构体ALARM_BUS_SHARP_DECELERATE_INFO)
#define DH_ALARM_ACCESS_CARD_OPERATE      0x31b0           // 门禁卡数据操作事件(对应结构体ALARM_ACCESS_CARD_OPERATE_INFO)
#define DH_ALARM_POLICE_CHECK             0x31b1           // 警员签到事件(对应结构体ALARM_POLICE_CHECK_INFO)
#define DH_ALARM_NET                      0x31b2           // 网络报警事件(对应结构体 ALARM_NET_INFO)
#define DH_ALARM_NEW_FILE                 0x31b3           // 新文件事件(对应结构体ALARM_NEW_FILE_INFO)
#define DH_ALARM_FIREWARNING              0x31b5           // 热成像着火点事件 (对应结构体 ALARM_FIREWARNING_INFO)
#define DH_ALARM_RECORD_LOSS              0x31b6           // 录像丢失事件,指硬盘完好的情况下,发生误删等原因引起(对应结构体ALARM_RECORD_LOSS_INFO)
#define DH_ALARM_VIDEO_FRAME_LOSS         0x31b7           // 视频丢帧事件,比如网络不好或编码能力不足引起的丢帧(对应结构体ALARM_VIDEO_FRAME_LOSS_INFO)
#define DH_ALARM_RECORD_VOLUME_FAILURE    0x31b8           // 由保存录像的磁盘卷发生异常,引起的录像异常(对应结构体 ALARM_RECORD_VOLUME_FAILURE_INFO)
#define DH_EVENT_SNAP_UPLOAD              0x31b9           // 图上传完成事件(对应结构体EVENT_SNAP_UPLOAD_INFO)
#define DH_ALARM_AUDIO_DETECT             0x31ba           // 音频检测事件(对应结构体 ALARM_AUDIO_DETECT )
#define DH_ALARM_UPLOADPIC_FAILCOUNT      0x31bb           // 上传中盟失败数据个数（对应结构体ALARM_UPLOADPIC_FAILCOUNT_INFO）
#define DH_ALARM_POS_MANAGE               0x31bc           // POS管理事件事件(对应结构体 ALARM_POS_MANAGE_INFO )
#define DH_ALARM_REMOTE_CTRL_STATUS       0x31bd           // 无线遥控器状态事件(对应结构体 ALARM_REMOTE_CTRL_STATUS )
#define DH_ALARM_PASSENGER_CARD_CHECK     0x31be           // 废弃, 乘客刷卡事件(对应结构体 ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_SOUND                    0x31bf           // 声音事件(对应结构体 ALARM_SOUND )
#define DH_ALARM_LOCK_BREAK               0x31c0           // 撬锁事件(对应结构体 ALARM_LOCK_BREAK_INFO )
#define DH_ALARM_HUMAN_INSIDE             0x31c1           // 舱内有人事件(对应结构体ALARM_HUMAN_INSIDE_INFO)
#define DH_ALARM_HUMAN_TUMBLE_INSIDE      0x31c2           // 舱内有人摔倒事件(对应结构体ALARM_HUMAN_TUMBLE_INSIDE_INFO)
#define DH_ALARM_DISABLE_LOCKIN           0x31c3           // 闭锁进门按钮触发事件(对应ALARM_DISABLE_LOCKIN_INFO)
#define DH_ALARM_DISABLE_LOCKOUT          0x31c4           // 闭锁出门按钮触发事件(对应结构体ALARM_DISABLE_LOCKOUT_INFO)
#define DH_ALARM_UPLOAD_PIC_FAILED        0x31c5           // 违章数据上传失败事件(对应结构体 ALARM_UPLOAD_PIC_FAILED_INFO )
#define DH_ALARM_FLOW_METER               0x31c6           // 水流量统计信息上报事件(对应结构体 ALARM_FLOW_METER_INFO)
#define DH_ALARM_WIFI_SEARCH              0x31c7           // 获取到周围环境中WIFI设备上报事件(对应结构体 ALARM_WIFI_SEARCH_INFO)
#define DH_ALARM_WIRELESSDEV_LOWPOWER     0x31C8           // 获取无线设备低电量上报事件(对应结构体ALARM_WIRELESSDEV_LOWPOWER_INFO)
#define DH_ALARM_PTZ_DIAGNOSES            0x31c9           // 云台诊断事件(对应结构体ALARM_PTZ_DIAGNOSES_INFO)
#define DH_ALARM_FLASH_LIGHT_FAULT        0x31ca           // 爆闪灯(闪光灯)报警事件 (对应结构体 ALARM_FLASH_LIGHT_FAULT_INFO)
#define DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT   0x31cb        // 频闪灯报警事件 (对应结构体 ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO)
#define DH_ALARM_HUMAM_NUMBER_STATISTIC   0x31cc           // 人数量/客流量统计事件 (对应结构体 ALARM_HUMAN_NUMBER_STATISTIC_INFO)
#define DH_ALARM_VIDEOUNFOCUS             0x31ce           // 视频虚焦报警(对应结构体 ALARM_VIDEOUNFOCUS_INFO)
#define DH_ALARM_BUF_DROP_FRAME           0x31cd           // 录像缓冲区丢帧事件(对应结构体 ALARM_BUF_DROP_FRAME_INFO)
#define DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL 0x31cf        // 双控设备主板与备板之间版本信息不一致异常事件 (对应结构体 ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO)
#define DH_ALARM_DCSSWITCH                 0x31d0          // 主备切换事件 集群切换报警 (对应结构体 ALARM_DCSSWITCH_INFO)
#define DH_ALARM_RADAR_CONNECT_STATE       0x31d1          // 雷达状态事件(对应结构体 ALARM_RADAR_CONNECT_STATE_INFO)
#define DH_ALARM_DEFENCE_ARMMODE_CHANGE    0x31d2          // 防区布撤防状态改变事件(对应结构体 ALARM_DEFENCE_ARMMODECHANGE_INFO)
#define DH_ALARM_SUBSYSTEM_ARMMODE_CHANGE  0x31d3          // 子系统布撤防状态改变事件(对应结构体 ALARM_SUBSYSTEM_ARMMODECHANGE_INFO)
#define DH_ALARM_RFID_INFO                 0x31d4          // 红外线检测信息事件(对应结构体 ALARM_RFID_INFO)
#define DH_ALARM_SMOKE_DETECTION           0x31d5          // 烟雾报警事件(对应结构体 ALARM_SMOKE_DETECTION_INFO)
#define DH_ALARM_BETWEENRULE_TEMP_DIFF     0x31d6          // 热成像规则间温差异常报警(对应结构体 ALARM_BETWEENRULE_DIFFTEMPER_INFO)
#define DH_ALARM_TRAFFIC_PIC_ANALYSE       0x31d7          // 图片二次分析事件(对应 ALARM_PIC_ANALYSE_INFO)
#define DH_ALARM_HOTSPOT_WARNING           0x31d8          // 热成像热点异常报警(对应结构体 ALARM_HOTSPOT_WARNING_INFO)
#define DH_ALARM_COLDSPOT_WARNING          0x31d9          // 热成像冷点异常报警(对应结构体 ALARM_COLDSPOT_WARNING_INFO)
#define DH_ALARM_FIREWARNING_INFO          0x31da          // 热成像火情报警信息上报(对应结构体 ALARM_FIREWARNING_INFO_DETAIL)
#define DH_ALARM_FACE_OVERHEATING          0x31db          // 热成像人体发烧预警(对应结构体 ALARM_FACE_OVERHEATING_INFO)
#define DH_ALARM_SENSOR_ABNORMAL           0x31dc          // 探测器异常报警(对应结构体 ALARM_SENSOR_ABNORMAL_INFO)
#define DH_ALARM_PATIENTDETECTION          0x31de          // 监控病人活动状态报警事件(对应结构体 ALARM_PATIENTDETECTION_INFO)
#define DH_ALARM_RADAR_HIGH_SPEED          0x31df          // 雷达监测超速报警事件 智能楼宇专用 (对应结构体 ALARM_RADAR_HIGH_SPEED_INFO)
#define DH_ALARM_POLLING_ALARM             0x31e0          // 设备巡检报警事件 智能楼宇专用 (对应结构体 ALARM_POLLING_ALARM_INFO)
#define DH_ALARM_ITC_HWS000                0x31e1          // 虚点测速仪设备事件与报警(对应结构体 ALARM_ITC_HWS000)
#define DH_ALARM_TRAFFICSTROBESTATE        0x31e2          // 道闸栏状态事件(对应结构体 ALARM_TRAFFICSTROBESTATE_INFO)
#define DH_ALARM_TELEPHONE_CHECK           0x31e3          // 手机号码上报事件(对应结构体 ALARM_TELEPHONE_CHECK_INFO)
#define DH_ALARM_PASTE_DETECTION           0x31e4          // 贴条事件(对应结构体 ALARM_PASTE_DETECTION_INFO )
#define DH_ALARM_SHOOTINGSCORERECOGNITION  0x31e5          // 打靶像机事件(对应结构体 ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO)
#define DH_ALARM_SWIPEOVERTIME             0x31e6          // 超时未刷卡事件(对应结构体 ALARM_SWIPE_OVERTIME_INFO)
#define DH_ALARM_DRIVING_WITHOUTCARD       0x31e7          // 无卡驾驶事件(对应结构体 ALARM_DRIVING_WITHOUTCARD_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION 0x31e8  //闯红灯事件(对应结构体 ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO ) 
#define DH_ALARM_FIGHTDETECTION            0x31e9          // 斗殴事件(对应结构体 NET_ALARM_FIGHTDETECTION)
#define DH_ALARM_OIL_4G_OVERFLOW           0x31ea          // 福山油田4G流量超过阈值的报警事件(对应结构体 NET_ALARM_OIL_4G_OVERFLOW_INFO)
#define DH_ALARM_ACCESSIDENTIFY            0x31eb          // VTO人脸识别事件(对应结构体 NET_ALARM_ACCESSIDENTIFY)
#define DH_ALARM_POWER_SWITCHER_ALARM      0x31ec          // 供电电源开关状态异常报警事件(对应结构体 DEV_ALRAM_POWERSWITCHER_INFO)
#define DH_ALARM_SCENNE_CHANGE_ALARM       0x31ed          // 场景变更事件(对应结构体 ALARM_PIC_SCENECHANGE_INFO)原来是VideoAbnormalDetection的SceneChange子事件，因需求变更，改为单独事件类型
#define DH_ALARM_WIFI_VIRTUALINFO_SEARCH   0x31ef          // WIFI虚拟身份上报事件(对应结构体 ALARM_WIFI_VIRTUALINFO_SEARCH_INFO)
#define DH_ALARM_TRAFFIC_OVERSPEED         0x31f0          // 超速事件(对应结构体 ALARM_TRAFFIC_OVERSPEED_INFO)
#define DH_ALARM_TRAFFIC_UNDERSPEED        0x31f1          // 欠速事件(对应结构体 ALARM_TRAFFIC_UNDERSPEED_INFO)
#define DH_ALARM_TRAFFIC_PEDESTRAIN        0x31f2          // 交通行人事件(对应结构体 ALARM_TRAFFIC_PEDESTRAIN_INFO)
#define DH_ALARM_TRAFFIC_JAM               0x31f3          // 交通拥堵事件(对应结构体 ALARM_TRAFFIC_JAM)
#define DH_ALARM_TRAFFIC_PARKING           0x31f4          // 违章停车事件(对应结构体 ALARM_TRAFFIC_PARKING_INFO)
#define DH_ALARM_TRAFFIC_THROW             0x31f5          // 交通抛洒物品事件(对应结构体 ALARM_TRAFFIC_THROW_INFO)
#define DH_ALARM_TRAFFIC_RETROGRADE        0x31f6          // 逆行事件(对应结构体 ALARM_TRAFFIC_RETROGRADE_INFO)
#define DH_ALARM_VTSTATE_UPDATE            0x31f7          // VTS状态上报(对应结构体 ALARM_VTSTATE_UPDATE_INFO)
#define DH_ALARM_CALL_NO_ANSWERED          0x31f8          // 直连情况下，呼叫无答应事件(对应结构体 NET_ALARM_CALL_NO_ANSWERED_INFO)
#define DH_ALARM_USER_LOCK_EVENT           0x31f9          // 用户锁定报警事件
#define DH_ALARM_RETROGRADE_DETECTION      0x31fa          // 人员逆行事件(对应结构体 ALARM_RETROGRADE_DETECTION_INFO)
#define DH_ALARM_AIO_APP_CONFIG_EVENT      0x31fb          // AIO报警事件(对应结构体 ALARM_AIO_APP_CONFIG_EVENT)
#define DH_ALARM_RAID_STATE_EX             0x31fc          // RAID异常报警(对应结构体 ALARM_RAID_INFO_EX)
#define DH_ALARM_STORAGE_IPC_FAILURE       0x31fd          // IPC的存储介质故障事件(IPC SD卡异常)(对应结构体 ALARM_STORAGE_IPC_FAILURE_INFO)
#define DH_ALARM_DEVICE_STAY               0x31fe          // 静止报警,如果设备坐标在指定时间内没有变化，触发静止报警信息(对应的结构体 ALARM_DEVICE_STAY_INFO)
#define DH_ALARM_SUB_WAY_DOOR_STATE        0x31ff          // 地铁车厢门状态(对应结构体 ALARM_SUB_WAY_DOOR_STATE_INFO)
#define DH_ALARM_SUB_WAY_PECE_SWITCH       0x3200          // 地铁PECE柜门状态(对应结构体 ALARM_SUB_WAY_PECE_SWITCH_INFO)
#define DH_ALARM_SUB_WAY_FIRE_ALARM        0x3201          // 地铁火警事件(对应结构体 ALARM_SUB_WAY_FIRE_ALARM_INFO)
#define DH_ALARM_SUB_WAY_EMER_HANDLE       0x3202          // 地铁乘客紧急手柄动作(对应结构体 ALARM_SUB_WAY_EMER_HANDLE_INFO)
#define DH_ALARM_SUB_WAY_CAB_COVER         0x3203          // 地铁司机室盖板状态(对应结构体 ALARM_SUB_WAY_CAB_COVER_INFO)
#define DH_ALARM_SUB_WAY_DERA_OBST         0x3204          // 地铁检测到障碍物或脱轨(对应结构体 ALARM_SUB_WAY_DERA_OBST_INFO)
#define DH_ALARM_SUB_WAY_PECU_CALL         0x3205          // 地铁客室报警器状态(对应结构体 ALARM_SUB_WAY_PECU_CALL_INFO)
#define DH_ALARM_BOX                       0x3206          // 报警盒子报警事件 (对应结构体 ALARM_BOX_INFO)
#define DH_ALARM_DOOR_CLOSEDMANUALLY       0x3207          // 人为关门事件(对应结构体 ALARM_DOOR_CLOSEDMANUALLY_INFO)
#define DH_ALARM_DOOR_NOTCLOSED_LONGTIME   0x3208          // 门超长时间未关报警事件(对应结构体 ALARM_DOOR_NOTCLOSED_LONGTIME_INFO)
#define DH_ALARM_UNDER_VOLTAGE             0x3209          // 电压低于9V, 电源欠压报警, 视频流以红色OSD图标叠加形式报警 (对应结构体 ALARM_UNDER_VOLTAGE_INFO ) 
#define DH_ALARM_OVER_VOLTAGE              0x320a          // 电压高于19V, 电源过压报警, 视频流以红色OSD图标叠加形式报警 (对应结构体 ALARM_OVER_VOLTAGE_INFO ) 
#define DH_ALARM_CUT_LINE                  0x320b          // 剪断报警(对应结构体ALARM_CUT_LINE_INFO)
#define DH_ALARM_VIDEOMOTION_EVENT         0x320c          // 动检事件(对应结构体 ALARM_VIDEOMOTION_EVENT_INFO)
#define DH_ALARM_WIDE_VIEW_REGION_EVENT    0x320d          // WideViewRegions事件(对应结构体 ALARM_WIDE_VIEW_REGION_EVENT_INFO) 二监项目定制事件。A平台发该事件到球机，将该事件转发给B平台
#define DH_ALARM_FIBRE_OPTIC_ABORT         0x320e          // 断纤报警(对应结构体 ALARM_FIBRE_OPTIC_ABORT)
#define DH_ALARM_TAIL_DETECTION            0x320f          // 尾随事件(对应结构体 ALARM_TAIL_DETECTION_INFO)
#define DH_ALARM_BITRATES_OVERLIMIT        0x3210          // 相机码流大于通道解码规格报警(对应结构体 ALARM_BITRATES_OVERLIMIT_INFO)
#define DH_ALARM_RECORD_CHANGED_EX         0x3211          // 录像状态变化报警(对应结构体 ALARM_RECORD_CHANGED_INFO_EX)
#define DH_ALARM_HIGH_DECIBEL              0x3212          // 声音高分贝检测报警(对应结构体 ALARM_HIGH_DECIBEL_INFO)
#define DH_ALARM_SHAKE_DETECTION           0x3213          // 摇晃检测报警(对应结构体 ALARM_SHAKE_DETECTION_INFO)
#define DH_ALARM_TUMBLE_DETECTION          0x3214          // 倒地报警事件(对应结构体 ALARM_TUMBLE_DETECTION_INFO)
#define DH_ALARM_ACCESS_CTL_MALICIOUS      0x3215          // 恶意开门事件(对应结构体 ALARM_ACCESS_CTL_MALICIOUS)
#define DH_ALARM_ACCESS_CTL_USERID_REGISTER 0x3216         // 用户已注册事件(对应结构体 ALARM_ACCESS_CTL_USERID_REGISTER)
#define DH_ALARM_ACCESS_CTL_REVERSELOCK    0x3217          // 锁体状态信息变化事件(对应结构体 ALARM_ACCESS_CTL_REVERSELOCK)
#define DH_ALARM_ACCESS_CTL_USERID_DELETE  0x3218          // 删除用户事件(对应结构体 ALARM_ACCESS_CTL_USERID_DELETE)
#define DH_ALARM_ACCESS_DOOR_BELL          0x3219          // 响铃事件(对应结构体 ALARM_ACCESS_DOOR_BELL_INFO)
#define DH_ALARM_ACCESS_FACTORY_RESET      0x321a          // 门锁恢复出厂(对应结构体 ALARM_ACCESS_FACTORY_RESET)
#define DH_ALARM_POLICE_RECORD_PROGRESS    0x321b          // MPT录像导入NVR的进度事件(对应结构体 ALARM_POLICE_RECORD_PROGRESS_INFO)
#define DH_ALARM_POLICE_PLUGIN             0x321c          // MPT接入拔出设备事件(对应结构体 ALARM_POLICE_PLUGIN_INFO)
#define DH_ALARM_GPS_NOT_ALIGNED           0x321d          // GPS未定位报警(对应结构体 ALARM_GPS_NOT_ALIGNED_INFO)
#define DH_ALARM_WIRELESS_NOT_CONNECTED    0x321e          // 网络未连接报警(包括wifi，3G/4G)(对应结构体 ALARM_WIRELESS_NOT_CONNECTED_INFO)
#define DH_ALARM_CABINET                   0x321f          // 云柜设备发送的物品存放单号信息实时上报事件(对应结构体 ALARM_CABINET_INFO)
#define DH_SWITCH_SCREEN                   0x3220          // 切换屏幕事件
#define DH_ALARM_NEAR_DISTANCE_DETECTION   0x3221            // 近距离接触报警(对应结构体ALARM_NEAR_DISTANCE_INFO)
#define DH_ALARM_MAN_STAND_DETECTION       0x3222            // 立体视觉站立报警(对应结构体ALARM_MAN_STAND_INFO)
#define DH_ALARM_MAN_NUM_DETECTION         0x3223            // 立体视觉区域内人数统计报警(对应结构体ALARM_MAN_NUM_INFO)
#define DH_MCS_GENERAL_CAPACITY_LOW        0x3224            // 微云常规容量事件(对应结构体ALARM_MCS_GENERAL_CAPACITY_LOW_INFO)
#define DH_MCS_DATA_NODE_OFFLINE           0x3225            // 微云存储节点下线事件(对应结构体ALARM_MCS_DATA_NODE_OFFLINE_INFO)
#define DH_MCS_DISK_OFFLINE                0x3226            // 微云磁盘下线事件(对应结构体ALARM_MCS_DISK_OFFLINE_INFO)
#define DH_MCS_DISK_SLOW                   0x3227            // 微云磁盘变慢事件(对应结构体ALARM_MCS_DISK_SLOW_INFO)
#define DH_MCS_DISK_BROKEN                 0x3228            // 微云磁盘损坏事件(对应结构体ALARM_MCS_DISK_BROKEN_INFO)
#define DH_MCS_DISK_UNKNOW_ERROR           0x3229            // 微云磁盘未知错误事件(对应结构体ALARM_MCS_DISK_UNKNOW_ERROR_INFO)
#define DH_MCS_METADATA_SERVER_ABNORMAL    0x322a            // 微云元数据服务器异常事件(对应结构体ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO)
#define DH_MCS_CATALOG_SERVER_ABNORMAL     0x322b            // 微云目录服务器异常事件(对应结构体ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO)
#define DH_MCS_GENERAL_CAPACITY_RESUME     0x322c            // 微云常规容量恢复事件(对应结构体ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO)
#define DH_MCS_DATA_NODE_ONLINE            0x322d            // 微云存储节点上线事件(对应结构体ALARM_MCS_DATA_NODE_ONLINE_INFO)
#define DH_MCS_DISK_ONLINE                 0x322e            // 微云磁盘上线事件(对应结构体ALARM_MCS_DISK_ONLINE_INFO)
#define DH_MCS_METADATA_SLAVE_ONLINE       0x322f            // 微云元数据备机上线事件(对应结构体ALARM_MCS_METADATA_SLAVE_ONLINE_INFO)
#define DH_MCS_CATALOG_SERVER_ONLINE       0x3230            // 微云目录服务器上线事件(对应结构体ALARM_MCS_CATALOG_SERVER_ONLINE_INFO)
#define DH_ALARM_OFFLINE_LOGSYNC           0x3231            // 同步离线日志事件(对应结构体 ALARM_OFFLINE_LOGSYNC_INFO)
#define DH_ALARM_UPGRADE_STATE             0x3232            // 设备升级状态事件(对应结构体 ALARM_UPGRADE_STATE)
#define DH_ALARM_LABELINFO                 0x3233            // IPC新增(2017.4),RFID标签信息采集事件(对应结构体 ALARM_LABELINFO)
#define DH_ALARM_TIRED_PHYSIOLOGICAL       0x3234            // 生理疲劳事件(对应结构体 ALARM_TIRED_PHYSIOLOGICAL)
#define DH_ALARM_CALLING_WHEN_DRIVING      0x3235            // 开车打电话事件(对应结构体 ALARM_CALLING_WHEN_DRIVING)
#define DH_ALARM_TRAFFIC_DRIVER_SMOKING    0x3236            // 开车抽烟事件(对应结构体 ALARM_TRAFFIC_DRIVER_SMOKING)
#define DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD 0x3237            // 开车低头报警事件(对应结构体 ALARM_TRAFFIC_DRIVER_LOWER_HEAD)
#define DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND     0x3238       // 开车左顾右盼报警事件(对应结构体 ALARM_TRAFFIC_DRIVER_LOOK_AROUND)
#define DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST      0x3239       // 开车离岗报警事件(对应结构体 ALARM_TRAFFIC_DRIVER_LEAVE_POST)
#define DH_ALARM_TRAFFIC_DRIVER_YAWN            0x323a       // 开车打哈欠报警事件(对应结构体 ALARM_TRAFFIC_DRIVER_YAWN)
#define DH_ALARM_AUTO_INSPECTION                0x323b       // 设备自检事件(对应结构体 ALARM_AUTO_INSPECTION) 
#define DH_ALARM_TRAFFIC_VEHICLE_POSITION       0x323c       // 车辆位置事件(对应的结构体 ALARM_TRAFFIC_VEHICLE_POSITION)
#define DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP  0x323d       // 人脸认证开门抓图信息事件(对应结构体 ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO) 
#define DH_ALARM_VIDEOBLIND                0x323e            // 视频遮挡事件(对应结构体ALARM_VIDEO_BLIND_INFO)
#define DH_ALARM_DRIVER_NOTCONFIRM         0x323f            // 司机未按确认按钮报警事件(对应结构体ALARM_DRIVER_NOTCONFIRM_INFO)
#define DH_ALARM_FACEINFO_COLLECT          0x3240            // 人脸信息录入事件(对应ALARM_FACEINFO_COLLECT_INFO)
#define DH_ALARM_HIGH_SPEED	               0x3241			 // 车辆超速报警事件(对应ALARM_HIGH_SPEED_INFO)
#define DH_ALARM_VIDEO_LOSS                0x3242			 // 视频丢失事件(对应 ALARM_VIDEO_LOSS_INFO)
#define DH_ALARM_MPTBASE_CONNECT           0x3243			 // 设备与底座连接状态事件(对应结构体ALARM_MPTBASE_CONNECT) 
#define DH_ALARM_LATEST_SHUTDOWN           0x3244			 // 设备上次关机状态事件(对应结构体 ALARM_LATEST_SHUTDOWN)

// ------------- 机器人专用事件 ------------------
#define DH_ALARM_ROBOT_COLLISION	        0x3245			// 机器人碰撞事件(对应结构体 ALARM_ROBOT_COLLISION)
#define DH_ALARM_ROBOT_FALLENDOWN		    0x3246			// 机器人跌倒事件(对应结构体 ALARM_ROBOT_FALLENDOWN)
#define DH_ALARM_ROBOT_UNRECOGNIZED2DCODE   0x3247			// 机器人二维码本身码值错误事件(对应结构体 ALARM_ROBOT_UNRECOGNIZED2DCODE) 
#define DH_ALARM_ROBOT_WRONG2DCODE	        0x3248			// 机器人错误二位码事件(对应的结构体 ALARM_ROBOT_WRONG2DCODE)
#define DH_ALARM_ROBOT_ROADBLOCKED	        0x3249		    // 机器人路障事件(对应结构体 ALARM_ROBOT_ROADBLOCKED) 
#define DH_ALARM_ROBOT_FAULT				0x324a			// 机器人故障事件(对应结构体 ALARM_ROBOT_FAULT)
#define DH_ALARM_ROBOT_OVERLOAD			    0x324b			// 机器人超载事件(对应结构体 ALARM_ROBOT_OVERLOAD)
#define DH_ALARM_ROBOT_YAWEXCEPTION		    0x324c			// 机器人意外偏航事件(对应 ALARM_ROBOT_YAWEXCEPTION)
#define DH_ALARM_ROBOT_LOADTIMEOUT		    0x324e			// 机器人上料异常(对应 ALARM_ROBOT_LOADTIMEOUT )
#define DH_ALARM_ROBOT_UNLOADTIMEOUT		0x324f			// 机器人卸料异常事件(对应 ALARM_ROBOT_UNLOADTIMEOUT)
#define DH_ALARM_ROBOT_MAPUPDATE		    0x3250			// 机器人地图更新事件(对应 ALARM_ROBOT_MAPUPDATE)
#define	DH_ALARM_ROBOT_BRAKE				0x3252			// 机器人紧急刹车事件(对应 ALARM_ROBOT_BRAKE)
#define	DH_ALARM_ROBOT_MANUAL_INTERVENTION	0x3253			// 机器人人工干预事件(对应 ALARM_ROBOT_MANUAL_INTERVENTION)


//机器人事件预留至0x3299
// -----------------------------------------------


#define DH_ALARM_VIDEO_TALK_PATH		    0x324d			// 对讲路径事件(对应结构体 ALARM_VIDEO_TALK_PATH_INFO)
#define DH_ALARM_CGIRECORD                  0x3251          // cgi触发手动录像(对应 ALARM_CGIRECORD)
#define DH_ALARM_BATTERY_TEMPERATURE	    0x3254			// 电池温度上报事件(对应 ALARM_BATTERY_TEMPERATURE_INFO)
#define DH_ALARM_TIRE_PRESSURE	            0x3255			// 胎压上报事件(对应 ALARM_TIRE_PRESSURE_INFO )
#define DH_ALARM_VTH_CONFLICT				0x3256			// 房间号冲突冲突上报事件(对应 ALARM_VTH_CONFLICT_INFO)
#define DH_ALARM_ACCESS_CTL_BLACKLIST       0x3257          // 门禁黑名单刷卡事件上报(对应 ALARM_ACCESS_CTL_BLACKLIST)
#define DH_ALARM_ROBOT_EMERGENCY_STOP		0x3258			// 机器人紧急停车按钮事件(对应 ALARM_ROBOT_EMERFEBCY_STOP)
#define	DH_ALARM_ROBOT_PATH_PLAN_FAILED		0x3259			// 机器人路径规划失败事件(对应 ALARM_ROBOT_PATH_PLAN_FAILED)
#define DH_ALARM_ROBOT_LOCAL_MAP_UPLOAD		0x325a			// 机器人本地地图上传事件(对应 ALARM_ROBOT_LOCAL_MAP_UPLOAD)
#define	DH_ALARM_ROBOT_SHELF_ERROR	        0x325b			// 机器人货架异常事件(对应 ALARM_ROBOT_SHELF_ERROR)
#define	DH_ALARM_ROBOT_SENSOR_ERROR	        0x325c			// 机器人传感器异常事件(对应 ALARM_ROBOT_SENSOR_ERROR)
#define DH_ALARM_ROBOT_DERAILMENT           0x325d          // 机器人脱轨事件(对应 ALARM_ROBOT_DERAILMENT)
#define DH_ALARM_ROBOT_MOTOR_UNINIT         0x325e          // 机器人电机抱闸未使能事件(对应 ALARM_ROBOT_MOTOR_UNINIT)
#define DH_ALARM_ROBOT_PREVENT_FALLING      0x325f          // 机器人防跌落事件(对应 ALARM_ROBOT_PREVENT_FALLING)
#define DH_ALARM_ROBOT_LOCATION_EXCEPTION   0x3260			// 机器人定位异常事件(对应 ALARM_ROBOT_LOCATION_EXCEPTION )
#define DH_ALARM_ROBOT_UPGRADER_FAIL        0x3261          // 机器人升级失败反馈(对应 ALARM_ROBOT_UPGRADER_FAIL)
#define DH_ALARM_ROBOT_CHARGING_ERROR       0x3262          // 机器人充电异常事件(对应 ALARM_ROBOT_CHARGING_ERROR)
#define DH_ALARM_ROBOT_STATIONCHARGING_ERROR       0x3263   // 机器人充电桩充电异常事件(对应 ALARM_ROBOT_STATIONCHARGING_ERROR)
#define DH_ALARM_ROBOT_CAMERA_ABNORMAL      0x3264          // 机器人相机异常事件(对应 ALARM_ROBOT_CAMERA_ABNORMAL)
#define DH_ALARM_ROBOT_ERROR_REPORT         0x3265          // 机器人故障信息(对应 ALARM_ROBOT_ERROR_REPORT)
#define DH_ALARM_ROBOT_DOOR_CONTROL_REQUEST 0x3266			// 机器人门控制请求事件(对应 ALARM_ROBOT_DOOR_CONTROL_REQUEST_INFO)
#define DH_ALARM_ROBOT_FAILEDTO_CONTROLROOM 0x3267          // 机器人打开充电房门失败事件(对应 ALARM_ROBOT_FAILEDTO_CONTROLROOM)
#define	DH_ALARM_ROBOT_ABNORMAL2DCODE	    0x3268			// 机器人二维码异常事件(对应 ALARM_ROBOT_ABNORMAL2DCODE)
#define	DH_ALARM_ROBOT_SECURITYDOGINVALID	0x3269			// 机器人加密狗无效事件(对应 ALARM_ROBOT_SECURITYDOGINVALID)
#define	DH_ALARM_ROBOT_LOCKAREA_BLOCKED  	0x326a			// 机器人锁定区域阻塞事件(对应 ALARM_ROBOT_LOCKAREA_BLOCKED)
#define	DH_ALARM_ROBOT_REQUEST_CANCLE_TASK  0x326b			// 机器人通知平台取消当前任务事件(对应 ALARM_ROBOT_REQUEST_CANCLE_TASK)
#define	DH_ALARM_ROBOT_FORK_BLOCK	        0x326c			// 机器人货叉遇障事件(对应 ALARM_ROBOT_FORK_BLOCK)
#define	DH_ALARM_ROBOT_SHUT_DOWN	        0x326d			// 机器人关机事件(对应 ALARM_ROBOT_SHUT_DOWN)
#define	DH_ALARM_ROBOT_LASER_HEAD_DIRTY	    0x326e			// 机器人激光头脏事件(对应 ALARM_ROBOT_LASER_HEAD_DIRTY)
#define	DH_ALARM_ROBOT_UNTRACK	            0x326f			// 机器人不上轨报警事件(对应 ALARM_ROBOT_UNTRACK)
#define	DH_ALARM_ROBOT_IN_ELEVATOR	        0x3270			// 机器人到达电梯事件(对应 ALARM_ROBOT_IN_ELEVATOR)
#define	DH_ALARM_ROBOT_CORRECT_LOACATION	0x3271			// 机器人重定位事件(对应 ALARM_ROBOT_CORRECT_LOACATION)


//新增事件从0x3300开始
#define DH_ALARM_USERLOCK					0x3300			// 用户锁定报警事件(对应 ALARM_USERLOCK_INFO)
#define DH_ALARM_DOWNLOAD_REMOTE_FILE		0x3301			// 下载远程文件事件(对应ALARM_DOWNLOAD_REMOTE_FILE_INFO)
#define DH_ALARM_NASFILE_STATUS             0x3302			// NAS文件状态事件(对应结构体 ALARM_NASFILE_STATUS_INFO) 
#define DH_ALARM_TALKING_CANCELCALL         0x3303          // 设备呼叫中取消呼叫事件(对应结构体 ALARM_TALKING_CANCELCALL_INFO)
#define DH_ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP      0x3304 // 未授权卡恶意刷卡事件(对应结构体 ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP)已废弃，复用DH_ALARM_ACCESS_CTL_MALICIOUS事件
#define DH_ALARM_CROWD_DETECTION			0x3305			// 人群密度检测事件(对应结构体 ALARM_CROWD_DETECTION_INFO)
#define DH_ALARM_FACE_FEATURE_ABSTRACT		0x3306			// 人脸特征向量重建结果事件(对应结构体ALARM_FACE_FEATURE_ABSTRACT_INFO)
#define	DH_ALARM_RECORD_SCHEDULE_CHANGE		0x3307			// 录像计划改变事件(对应结构体 ALARM_RECORD_SCHEDULE_CHANGE_INFO)
#define DH_ALARM_NTP_CHANGE					0x3308			// NTP配置修改事件(对应结构体 ALARM_NTP_CHANGE_INFO)
#define DH_ALARM_HDD_TEMPERATUREALARM		0x3309			// 硬盘温度报警事件(对应结构体 ALARM_HDD_TEMPERATUREALARM_INFO)
#define DH_ALARM_HDD_HEALTHALARM			0x330a			// 硬盘健康状况报警事件(对应结构体 ALARM_HDD_HEALTHALARM_INFO)
#define DH_ALARM_HDD_SHAKEALARM     		0x330b			// 硬盘震动报警事件(对应结构体 ALARM_HDD_SHAKEALARM_INFO)
#define DH_ALARM_PATROL_STATUS				0x330c			// 未巡更报警事件(对应结构体 ALARM_PATROL_STATUS_INFO) 
#define DH_ALARM_CITIZEN_PICTURE_COMPARE    0x330d          // 人证比对事件(对应结构体 ALARM_CITIZEN_PICTURE_COMPARE_INFO)

/*  start  西欧报警主机事件,预留58个事件*/
#define DH_ALARM_AREAARM_MODECHANGE         0x330e          // 区域防区模式改变(对应结构体ALARM_AREAARM_MODECHANGE_INFO)
#define DH_ALARM_ZONEMODULELOST             0x330f          // 防区模块掉线(对应结构提ALARM_ZONEMODULE_LOST_INFO)
#define DH_ALARM_AREAALARM                  0x3310          // 区域报警(对应结构体ALARM_AREAALARM_INFO)
#define DH_ALARM_ZONEOPEN                   0x3311          // 防区打开(对应结构体ALARM_ZONEOPEN_INFO)
#define DH_ALARM_SYSTEMTAMPER               0x3312          // 防拆事件(对应结构体ALARM_SYSTEMTAMPER_INFO)
#define DH_ALARM_ALARMREGION_MAXEVENTID     0x3348          // 西欧报警主机新品事件最大值,这个值不可用
/*  end  西欧报警主机事件,预留58个事件 */

#define DH_ALARM_LAW_ENFORCEMENT_INFO		0x3349			// 实时上报执法终端设备信息事件（对应的结构体 ALARM_LAW_ENFORCEMENT_INFO）
#define DH_ALARM_CONGESTION_DETECTION		0x334A			// 道路场景车辆拥堵报警事件（对应 ALARM_CONGESTION_DETECTION_INFO）
#define DH_ALARM_VEHICLELIMIT_DETECTION		0x334B			// 停车场场景下停车车辆上限报警（对应 ALARM_VEHICLELIMIT_DETECTION_INFO）
#define DH_ALARM_TRAFFIC_PARKING_TIMEOUT	0x334C			// 停车时长超限事件（对应的结构体 ALARM_TRAFFIC_PARKING_TIMEOUT_INFO）

/*  end  西欧报警主机事件,预留64个事件*/
#define DH_ALARM_DISTANCE_DETECTION			0x334e			// 异常间距事件(对应 ALARM_DISTANCE_DETECTION_INFO)
#define DH_ALARM_STAY_DETECTION				0x334f			// 停留事件(对应 ALARM_STAY_DETECTION_INFO)
#define DH_ALARM_DEVBOARDHOTPLUG			0x3350			// 双控设备热插拔事件(对应结构体 ALARM_DEVBOARDHOTPLUG_INFO)
#define DH_ALARM_HOMESCENE_CHANGE			0x3351			// 美的地产场景变化事件(对应结构体ALARM_HOMESCENE_CHANGE_INFO)
#define DH_ALARM_STORAGE_WORKDIRECTORY_SWITCH 0x3352        // 当前工作目录切换事件(对应结构体 ALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO)
#define DH_ALARM_TRAFFIC_LINKAGEALARM		0x3353			// 各种违章事件联动报警输出事件(对应结构体 ALARM_TRAFFIC_LINKAGEALARM_INFO)
#define DH_ALARM_COAXIAL_ALARM_LOCAL		0x3354			// 同轴开关量报警事件(对应结构体 ALARM_COAXIAL_ALARM_LOCAL_INFO)
#define DH_ALARM_NAS_FILE_REMOVE_STATUS	    0x3355			// NAS文件删除状态事件(对应结构体 ALARM_NAS_FILE_REMOVE_STATUS_INFO)
#define DH_ALARM_NAS_APK_INSTALL_REQUEST    0x3356			// 请求设备安装APK事件(对应结构体 ALARM_NAS_APK_INSTALL_REQUEST_INFO)
#define DH_ALARM_NAS_APK_INSTALL_STATUS	    0x3357			// 设备安装APK状态事件(对应结构体 ALARM__APK_INSTALL_STATUS_INFO)
#define DH_ALARM_FILE_COMPRESS_STATUS	    0x3358			// 文件压缩解压状态事件(对应结构体 ALARM_FILE_COMPRESSS_STATUS_INFO)
#define DH_ALARM_STRANGER_ALARM				0x3359			// 陌生人报警事件(对应结构体 ALARM_STRANGER_ALARM_INFO)
#define DH_ALARM_QR_CODE_CHECK              0x335a         // 二维码上报事件(对应结构体 ALARM_QR_CODE_CHECK_INFO)
#define DH_ALARM_ACCESS_CTL_LOCK_MODE		0x335b          // 门锁模式事件(对应结构体 ALARM_ACCESS_CTL_LOCK_MODE_INFO)
#define DH_ALARM_LOCK_ROOM_NUM_BIND			0x335c          // 房间号绑定事件(对应结构体 ALARM_LOCK_ROOM_NUM_BIND_INFO)
#define DH_ALARM_LEAVE_DETECTION			0x335d		   // 离岗检测（对应结构体 ALARM_LEAVE_DETECTION_INFO）
#define DH_ALARM_TRAFFICGZJJ_QUEUE_LEN		0x335e		   // 广州交通排队长度事件(对应结构体 ALARM_TRAFFICGZJJ_QUEUE_LEN_INFO)
#define DH_ALARM_TRAFFIC_XINKONG			0x335f		   // 交通态势报警事件（对接结构体 ALARM_TRAFFIC_XINKONG_INFO）

/*  start  雷球联动事件,预留64个事件*/
#define DH_ALARM_RADAR_REGIONDETECTION		0x3370			// 雷达区域检测事件(对应结构体 ALARM_RADAR_REGIONDETECTION_INFO)
#define DH_ALARM_RADAR_MAXEVENTID		    0x3433			// 雷达新品事件最大值,这个值不可用
/*  end  雷球联动事件,预留64个事件*/

#define DH_ALARM_JABLOTRON_ALARM			0x3434			// 客户报警产品(对应结构体 ALARM_JABLOTRONALARM_INFO)
#define DH_ALARM_FACE_RECOGNITION           0x3435          // 人脸识别事件(对应结构体 ALARM_FACE_RECOGNITION_INFO) 
#define DH_ALARM_VEHICLE_OILLEVEL           0x3436          // 车载燃料液位事件(对应结构体 ALARM_VEHICLE_OILLEVEL_INFO) 
#define DH_ALARM_VEHICLE_LOAD				0x3437          // 车载燃料载重事件(对应结构体 ALARM_VEHICLE_LOAD_INFO) 
#define DH_ALARM_VEHICLE_STATE				0x3438          // 车辆状态事件(对应结构体 ALARM_VEHICLE_STATE_INFO) 
#define DH_ALARM_IMSI_CHECK					0x3439          // IMSI校验事件(对应结构体 ALARM_IMSI_CHECK_INFO) 
#define DH_ALARM_BLIND_ALARM				0x343A          // 进入盲区事件(对应结构体 ALARM_BLIND_ALARM_INFO)
#define DH_ALARM_VEHICLE_MAINTAINCE			0x343B          // 车载人员维护事件(对应结构体 ALARM_VEHICLE_MAINTAINCE_INFO) 
#define DH_ALARM_PARKINGLOCK_STATE			0x343C          // 车位锁状态变化事件(对应结构体 ALARM_PARKINGLOCK_STATE_INFO) 
#define DH_ALARM_FIRE_DETECTION				0x343D			// 火警事件（对于的结构体 ALARM_FIRE_DETECTION_INFO）
#define DH_ALARM_NAS_SERVER_STATE			0x343E			// NAS共享服务器异常报警事件(对应结构体 ALARM_NAS_SERVER_STATE_INFO )
#define DH_ALARM_VOLUME_GROUP_FAULT			0x343F			// 存储池异常报警事件(对应结构体 ALARM_VOLUME_GROUP_FAULT_INFO)
#define DH_ALARM_DISK_CHECK					0x3440			// 磁盘巡检报警事件(对应结构体 ALARM_DISK_CHECK_INFO)
#define DH_ALARM_PHONECALL_DETECT			0x3441			// 打电话检测事件(对应结构体 ALARM_PHONECALL_DETECT_INFO)
#define DH_ALARM_FLOATINGOBJECT_DETECTION   0x3442			// 漂浮物检测事件(对应结构体 ALARM_FLOATINGOBJECT_DETECTION_INFO)
#define DH_ALARM_WATER_LEVEL_DETECTION		0x3443			// 水位检测事件(对应结构体 ALARM_WATER_LEVEL_DETECTION_INFO)
#define DH_ALARM_LOW_SPEED					0x3444		    // 怠速报警即低速报警(对应结构体 ALARM_LOW_SPEED_INFO)
#define DH_ALARM_TRAFFIC_VEHICLEINOUT		0x3445		    // 车辆进出车道报警(对应结构体 ALARM_TRAFFIC_VEHICLEINOUT_INFO)
#define DH_ALARM_TRAFFIC_JUNCTION			0x3446			// 交通路口事件(对应结构体 ALARM_TAFFIC_JUNCTION_INFO)
#define DH_ALARM_DOOR_CONTROL				0x3447			// 报警输出联动开门事件 (对应结构体 ALARM_DOOR_CONTROL_INFO)
#define DH_ALARM_ARMSTATE					0x3448			// 防区状态事件 (对应结构体 ALARM_ARMSTATE_INFO)

#define DH_ALARM_TICKET_INFO_REPORT			0x3449			// 车票信息上报事件 (对应 ALARM_TICKET_INFO_REPORT)
#define DH_ALARM_TRAFFIC_LAMP_WORK_STATE    0x344E          // 交通相机通过串口与补光灯连接获取补光灯的状态信息事件 (对应 ALARM_TRAFFIC_LAMP_WORK_STATE_INFO)

#define DH_ALARM_ENGINE_FAILURE_STATUS		0x344F			// 发动机故障状态上报(对应 ALARM_ENGINE_FAILURE_STATUS_INFO)
#define DH_ALARM_HIGH_TOSS_DETECT           0x3450          // 高空抛物检测事件(对应 ALARM_HIGH_TOSS_DETECT_INFO)

// 事件类型
#define DH_CONFIG_RESULT_EVENT_EX           0x3000           // 修改配置的返回码；返回结构见DEV_SET_RESULT
#define DH_REBOOT_EVENT_EX                  0x3001           // 设备重启事件；如果未发送重启命令,当前修改的配置不会立即生效
#define DH_AUTO_TALK_START_EX               0x3002           // 设备主动邀请开始语音对讲
#define DH_AUTO_TALK_STOP_EX                0x3003           // 设备主动停止语音对讲
#define DH_CONFIG_CHANGE_EX                 0x3004           // 设备配置发生改变
#define DH_IPSEARCH_EVENT_EX                0x3005           // IP搜索事件, 返回字符串格式如下:DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay&&DevName::Manufacturer::MAC::IP::Port::DevType::POEPort::SubMask::GateWay &&…
#define DH_AUTO_RECONNECT_FAILD             0x3006           // 自动重连失败事件
#define DH_REALPLAY_FAILD_EVENT             0x3007           // 监视失败事件,返回结构体DEV_PLAY_RESULT
#define DH_PLAYBACK_FAILD_EVENT             0x3008           // 回放失败事件,返回结构体DEV_PLAY_RESULT   
#define DH_IVS_TRAFFIC_REALFLOWINFO         0x3009           // 交通实时流量信息事件ALARM_IVS_TRAFFIC_REALFLOW_INFO
#define DH_DEVICE_ABORT_EVENT               0x300a           // 客户端被踢出, 对应结构体 DEV_CLIENT_ABORT_INFO
#define DH_TALK_FAILD_EVENT                 0x300b           // 请求语音对讲失败, 对应结构体 DEV_TALK_RESULT
#define DH_START_LISTEN_FINISH_EVENT        0x300c           // 订阅事件接口完成异步通知事件, 信息为NULL
#define DH_YUEQINGLIGHTING_STATE_EVENT      0x300d           // 平台统计灯光开关的时间事件, 对应的结构体 DEV_YUEQINGLIGHTING_STATE_INFO
#define DH_ALARM_VIOLATE_NO_FLY_TIME        0x300e           // 违反禁飞事件, 对应结构体 ALARM_VIOLATE_NO_FLY_TIME_INFO              
#define DH_ALARM_BOX_ALARM			        0x300f		     // 报警盒通道的触发报警事件 (对应结构体 ALARM_BOX_ALARM_INFO )
#define	DH_ALARM_SOSALERT					0x3010			 // SOS求救报警(对应结构体ALARM_SOSALERT_INFO)
#define DH_ALARM_GYROABNORMALATTITUDE		0x3011			 // 车辆的紧急制动、侧翻等状态导致的姿态异常进行报警(对应 ALARM_GYROABNORMALATTITUDE_INFO)
#define DH_ALARM_ALARMOUTPUT				0x3012			 // 输出通道状态改变事件(对应结构体ALARM_ALARMOUTPUT_INFO)
#define DH_ALARM_PSTNREPORTFAILURE			0x3013			 // 电话报警未接警事件(对应结构体ALARM_PSTNREPORTFAILURE_INFO)
#define DH_ALARM_NOGSMFIELD					0x3014			 // 通信模块掉线或者sim卡没插(对应结构体ALARM_NOGSMFIELD_INFO)
#define DH_ALARM_SMARTMOTION_HUMAN 			0x3015			 // 智能视频移动侦测事件(人) (对应结构体 ALARM_SMARTMOTION_HUMAN_INFO)
#define DH_ALARM_SMARTMOTION_VEHICLE		0x3016			 // 智能视频移动侦测事件(车) (对应结构体 ALARM_SMARTMOTION_VEHICLE_INFO)
#define DH_ALARM_MOTION_RECORD_ALARM        0x3017			 // 动检录像报警(对应结构体ALARM_MOTION_RECORD_INFO)
#define DH_ALARM_SMARTHOME_GET_AUTHORIZED	0x3018			 // 室内机告知平台需要获取授权二维码信息 ( 对应结构体 ALARM_SMARTHOME_GET_AUTHORIZED )
#define DH_ALARM_SMARTHOME_UPDATE_SCENE		0x3019			 // 室内机告知平台需要更新智能家居场景列表 ( 对应结构体 ALARM_SMARTHOME_UPDATE_SCENE )
#define DH_ALARM_ASG						0x3020			 //	ASG报警 ( 对应结构体 ALARM_ASG_INFO )		
#define DH_ALARM_ASGSTAY                    0X3021           // 闸机滞留报警事件( 对应结构体 ALARM_ASGSTAY_INFO )
#define DH_ALARM_ASGFOLLOWING               0X3022           // 闸机尾随报警事件( 对应结构体 ALARM_ASGFOLLOWING_INFO )
#define DH_ALARM_ASGCLIMBOVER               0X3023           // 闸机翻越报警事件( 对应结构体 ALARM_ASGCLIMBOVER_INFO )
#define DH_ALARM_ASGBREAKDOWN               0X3024           // 闸机故障事件( 对应结构体 ALARM_ASGBREAKDOWN_INFO )


// 报警上传功能的报警类型,对应CLIENT_StartService接口、NEW_ALARM_UPLOAD结构体.
#define DH_UPLOAD_ALARM                     0x4000           // 外部报警            
#define DH_UPLOAD_MOTION_ALARM              0x4001           // 动态检测报警
#define DH_UPLOAD_VIDEOLOST_ALARM           0x4002           // 视频丢失报警
#define DH_UPLOAD_SHELTER_ALARM             0x4003           // 视频遮挡报警
#define DH_UPLOAD_SOUND_DETECT_ALARM        0x4004           // 音频检测报警
#define DH_UPLOAD_DISKFULL_ALARM            0x4005           // 硬盘满报警
#define DH_UPLOAD_DISKERROR_ALARM           0x4006           // 坏硬盘报警
#define DH_UPLOAD_ENCODER_ALARM             0x4007           // 编码器报警
#define DH_UPLOAD_DECODER_ALARM             0x400B           // 报警解码器报警
#define DH_UPLOAD_EVENT                     0x400C           // 定时上传的
#define DH_UPLOAD_IVS                       0x400D           // 智能报警, 对应结构体ALARM_UPLOAD_IVS_INFO
#define DH_UPLOAD_SMOKESENSOR_ALARM         0x400E           // 烟感报警, 对应结构体ALARM_UPLOAD_SMOKESENSOR_INFO
#define DH_UPLOAD_ALARM_EX                  0x400F           // 外部报警扩展,对应结构体 ALARM_UPLOAD_ALARMEX_INFO 
#define DH_UPLOAD_REMOTE_LOGIN_FAILD_ALARM  0x4010           // 远程登录失败报警, 对应结构体 ALARM_UPLOAD_LOGIN_FAILED_INFO
#define DH_UPLOAD_CUSTOM                    0x4011           // 扩展字段由客户自定义,pParam:扩展数据指针,dwParamLen:扩展数据长度
#define DH_UPLOAD_FRONTDISCONNECT_ALARM     0x4012           // 前端断网报警, 对应结构体 NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_IPC                 0x4013           // IPC外部报警, 对应结构体 NEW_ALARM_UPLOAD
#define DH_UPLOAD_NET_ALARM                 0x4014           // 网络报警输入(网络触发,而非设备本地输入报警有信号), 对应结构体 NEW_ALARM_UPLOAD
#define DH_UPLOAD_ALARM_RAID                0x4015           // Raid异常事件, 对应结构体 NEW_ALARM_UPLOAD
#define DH_UPLOAD_SCENE_CHANGE              0x4016           // 场景变更, 对应结构体 NEW_ALARM_UPLOAD
#define DH_UPLOAD_PIRDETECTION				0x4017			 // pir 设备检测报警, 对应结构体ALARM_UPLOAD_PIRDETECTION_INFO
#define DH_UPLOAD_PIRTAMPER					0x4018			 // pir 设备防拆报警, 对应结构体ALARM_UPLOAD_PIRTAMPER_INFO
#define DH_UPLOAD_PIRCLOAK					0x4019			 // pir 设备光线遮挡报警, 对应结构体 ALARM_UPLOAD_PIRCLOAK_INFO
#define DH_UPLOAD_PIRSHOCK					0x401A			 // pir 设备震动报警, 对应结构体ALARM_UPLOAD_PIRSHOCK_INFO
#define DH_UPLOAD_PIRFAILURE				0x401B			 // pir 设备传感器故障报警, 对应结构体ALARM_UPLOAD_PIRFAILURE_INFO
#define DH_UPLOAD_PIRBATTERYLOW				0x401C			 // pir 设备电池电量低报警, 对应结构体ALARM_UPLOAD_PIRBATTERYLOW_INFO
#define DH_UPLOAD_PIRMISSINGCALL			0x401D			 // pir 设备信号丢失报警, 对应结构体ALARM_UPLOAD_PIRMISSINGCALL_INFO
#define DH_UPLOAD_VIDEO_UNFOCUS				0x401E			 // 视频虚焦事件, 对应结构体ALARM_UPLOAD_VIDEO_UNFOCUS_INFO
#define DH_UPLOAD_ALARMPIR					0x401F			 // PIR报警事件, 对应结构体ALARM_UPLOAD_ALARMPIR_INFO
#define DH_UPLOAD_ALARM_EX2                 0x4020           // 本地报警事件, 对应结构体 ALARM_ALARM_INFO_EX2
#define DH_UPLOAD_BYPASSMODE_CHANGE_EVENT   0x4021           // 旁路状态变化事件, 对应结构体ALARM_BYPASSMODE_CHANGE_INFO
#define DH_UPLOAD_CHASSISINTRUDED           0x4022           // 机箱入侵(防拆)报警事件, 对应结构体ALARM_CHASSISINTRUDED_INFO
#define DH_UPLOAD_RCEMERGENCY_CALL          0x4023           // 紧急呼叫报警事件, 对应结构体 ALARM_RCEMERGENCY_CALL_INFO
#define DH_UPLOAD_ARMMODE_CHANGE_EVENT      0x4024           // 布撤防状态变化事件, 对应结构体ALARM_ARMMODE_CHANGE_INFO
#define DH_UPLOAD_SUBSYSTEM_ARMMODE_CHANGE  0x4025           // 子系统布撤防状态改变事件, 对应结构体 ALARM_SUBSYSTEM_ARMMODECHANGE_INFO
#define DH_UPLOAD_DEFENCE_ARMMODE_CHANGE    0x4026           // 防区布撤防状态改变事件, 对应结构体 ALARM_DEFENCE_ARMMODECHANGE_INFO
#define DH_UPLOAD_POWERFAULT                0x4027           // 电源故障事件, 对应结构体ALARM_POWERFAULT_INFO
#define DH_UPLOAD_HEARTBEAT_ALARM           0x4028           // 心跳报警,对应结构体ALARM_UPLOAD_HEARTBEAT_INFO
#define DH_UPLOAD_ONLINE_ALARM              0x4029           // 在线报警,对应结构体ALARM_UPLOAD_ONLINE_INFO

// 订阅Bus状态对应事件上报(CLIENT_AttachBusState)
#define DH_ALARM_BUS_DRIVER_CHECK         0x0001           // 司机签到事件(对应结构体 ALARM_BUS_DRIVER_CHECK_INFO)
#define DH_ALARM_BUS_IMPORT_SITE          0x0002           // 进站事件(对应结构体 ALARM_BUS_IMPORT_SITE_INFO)
#define DH_ALARM_BUS_EXPORT_SITE          0x0003           // 离站事件(对应结构体 ALARM_BUS_EXPORT_SITE_INFO)
#define DH_ALARM_BUS_ABNORMAL             0x0004           // 车辆异常事件(对应结构体 ALARM_BUS_ABNORMAL_INFO)
#define DH_ALARM_BUS_DOOR_OPEN            0x0005           // 车门打开事件(对应结构体 ALARM_VEHICLE_DOOR_OPEN_INFO)
#define DH_ALARM_BUS_CUR_MILEAGE          0x0006           // 当前里程事件(对应结构体 ALARM_BUS_CUR_MILEAGE_INFO)
#define DH_ALARM_BUS_CUR_OIL              0x0007           // 当前油耗情况事件(对应结构体 ALARM_BUS_CUR_OIL_INFO)
#define DH_ALARM_BUS_LOW_OIL              0x0008           // 低油量报警事件(对应结构体 ALARM_BUS_LOW_OIL_INFO)
#define DH_ALARM_BUS_PASSENGER_CARD_CHECK 0x0009           // 乘客刷卡事件(对应结构体 ALARM_PASSENGER_CARD_CHECK )
#define DH_ALARM_BUS_VEHICLE_STANDING_OVER_TIME 0x000a     // 停车超时事件(对应结构体 ALARM_VEHICLE_STANDING_OVER_TIME_INFO )
#define DH_ALARM_BUS_DRIVE_AFTER_WORK     0x000b           // 非工作时间事件(对应结构体 ALARM_DVRIVE_AFTER_WORK )
#define DH_ALARM_BUS_PAD_SHUTDOWN         0x000c           // PAD关机事件, DVR上报PadShutdown消息, PAD收到后自动延时关机(对应结构体 ALARM_BUS_PAD_SHUTDOWN_INFO)
#define DH_ALARM_BUS_TIRED_DRIVE_CHECK    0x000d           // 疲劳驾驶事件(对应结构体 ALARM_TIRED_DRIVE_CHECK_INFO )
#define DH_ALARM_BUS_STEAL_OIL            0x000e           // 偷油事件(对应结构体 ALARM_BUS_STEAL_OIL_INFO)
#define DH_ALARM_BUS_CIRCUIT_SHIFT		  0x000f		   // 线路偏移事件(对应结构体 ALARM_BUS_CIRCUIT_SHIFT_INFO)
#define DH_ALARM_BUS_ROUTE_OVERTIME		  0x0010		   // 线路超时事件(对应结构体 ALARM_BUS_ROUTE_OVERTIME_INFO)
#define DH_ALARM_BUS_VEHICLE_CARRY_ALARM  0x0011		   // 载重报警事件(对应结构体 ALARM_BUS_VEHICLE_CARRY_ALARM_INFO)
#define DH_ALARM_BUS_VEHICLE_PAULIN_ALARM 0x0012		   // 篷布报警事件(对应结构体 ALARM_BUS_VEHICLE_PAULIN_ALARM_INFO)
#define DH_ALARM_BUS_VEHICLE_LIFT_ALARM   0x0013		   // 举升报警事件(对应结构体 ALARM_BUS_VEHICLE_LIFT_ALARM_INFO)


// 异步接口回调类型
#define RESPONSE_DECODER_CTRL_TV          0x00000001       // 对应CLIENT_CtrlDecTVScreen接口
#define RESPONSE_DECODER_SWITCH_TV        0x00000002       // 对应CLIENT_SwitchDecTVEncoder接口
#define RESPONSE_DECODER_PLAYBACK         0x00000003       // 对应CLIENT_DecTVPlayback接口
#define RESPONSE_EXCHANGE_DATA            0x00000004       // 对应CLIENT_ExchangeData接口
#define RESPONSE_ASYN_QUERY_RECORDFILE    0x00000005       // 对应CLIENT_StartQueryRecordFile接口

// CLIENT_FileTransmit接口传输文件类型
#define DH_DEV_UPGRADEFILETRANS_START     0x0000           // 开始升级文件上传(对应结构体 DHDEV_UPGRADE_FILE_INFO)
#define DH_DEV_UPGRADEFILETRANS_SEND      0x0001           // 发送升级文件  
#define DH_DEV_UPGRADEFILETRANS_STOP      0x0002           // 停止发送升级文件
#define DH_DEV_BLACKWHITETRANS_START      0x0003           // 开始发送黑白名单(对应结构体 DHDEV_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITETRANS_SEND       0x0004           // 发送黑白名单
#define DH_DEV_BLACKWHITETRANS_STOP       0x0005           // 停止发送黑白名单 
#define DH_DEV_BLACKWHITE_LOAD            0x0006           // 下载黑白名单(对应结构体DHDEV_LOAD_BLACKWHITE_LIST_INFO)
#define DH_DEV_BLACKWHITE_LOAD_STOP       0x0007           // 停止下载黑白名单
#define DH_DEV_FILETRANS_STOP             0x002B           // 停止文件上传
#define DH_DEV_FILETRANS_BURN             0x002C           // 刻录文件上传

// 分辨率列表,用于与分辨率掩码进行与、或操作
#define DH_CAPTURE_SIZE_D1                0x00000001
#define DH_CAPTURE_SIZE_HD1               0x00000002
#define DH_CAPTURE_SIZE_BCIF              0x00000004
#define DH_CAPTURE_SIZE_CIF               0x00000008
#define DH_CAPTURE_SIZE_QCIF              0x00000010    
#define DH_CAPTURE_SIZE_VGA               0x00000020    
#define DH_CAPTURE_SIZE_QVGA              0x00000040
#define DH_CAPTURE_SIZE_SVCD              0x00000080
#define DH_CAPTURE_SIZE_QQVGA             0x00000100
#define DH_CAPTURE_SIZE_SVGA              0x00000200
#define DH_CAPTURE_SIZE_XVGA              0x00000400
#define DH_CAPTURE_SIZE_WXGA              0x00000800
#define DH_CAPTURE_SIZE_SXGA              0x00001000
#define DH_CAPTURE_SIZE_WSXGA             0x00002000   
#define DH_CAPTURE_SIZE_UXGA              0x00004000
#define DH_CAPTURE_SIZE_WUXGA             0x00008000
#define DH_CAPTURE_SIZE_LFT               0x00010000
#define DH_CAPTURE_SIZE_720               0x00020000
#define DH_CAPTURE_SIZE_1080              0x00040000
#define DH_CAPTURE_SIZE_1_3M              0x00080000
#define DH_CAPTURE_SIZE_2M                0x00100000
#define DH_CAPTURE_SIZE_5M                0x00200000
#define DH_CAPTURE_SIZE_3M                0x00400000                
#define DH_CAPTURE_SIZE_5_0M              0x00800000
#define DH_CPTRUTE_SIZE_1_2M              0x01000000    
#define DH_CPTRUTE_SIZE_1408_1024         0x02000000    
#define DH_CPTRUTE_SIZE_8M                0x04000000    
#define DH_CPTRUTE_SIZE_2560_1920         0x08000000
#define DH_CAPTURE_SIZE_960H              0x10000000
#define DH_CAPTURE_SIZE_960_720           0x20000000

// 编码模式列表,用于与编码模式掩码进行与、或操作
#define DH_CAPTURE_COMP_DIVX_MPEG4        0x00000001
#define DH_CAPTURE_COMP_MS_MPEG4          0x00000002
#define DH_CAPTURE_COMP_MPEG2             0x00000004
#define DH_CAPTURE_COMP_MPEG1             0x00000008
#define DH_CAPTURE_COMP_H263              0x00000010
#define DH_CAPTURE_COMP_MJPG              0x00000020
#define DH_CAPTURE_COMP_FCC_MPEG4         0x00000040
#define DH_CAPTURE_COMP_H264              0x00000080
#define DH_CAPTURE_COMP_H265              0x00000100
#define DH_CAPTURE_COMP_SVAC              0x00000200

// 报警联动动作,用于与报警联动动作掩码进行与、或操作
#define DH_ALARM_UPLOAD                   0x00000001
#define DH_ALARM_RECORD                   0x00000002
#define DH_ALARM_PTZ                      0x00000004
#define DH_ALARM_MAIL                     0x00000008
#define DH_ALARM_TOUR                     0x00000010
#define DH_ALARM_TIP                      0x00000020
#define DH_ALARM_OUT                      0x00000040
#define DH_ALARM_FTP_UL                   0x00000080
#define DH_ALARM_BEEP                     0x00000100
#define DH_ALARM_VOICE                    0x00000200
#define DH_ALARM_SNAP                     0x00000400

// "恢复默认配置"掩码,可进行与、或操作, 接口CLIENT_ControlDevice类型DH_CTRL_RESTOREDEFAULT
#define DH_RESTORE_COMMON                 0x00000001       // 普通设置
#define DH_RESTORE_CODING                 0x00000002       // 编码设置
#define DH_RESTORE_VIDEO                  0x00000004       // 录像设置
#define DH_RESTORE_COMM                   0x00000008       // 串口设置
#define DH_RESTORE_NETWORK                0x00000010       // 网络设置
#define DH_RESTORE_ALARM                  0x00000020       // 报警设置
#define DH_RESTORE_VIDEODETECT            0x00000040       // 视频检测
#define DH_RESTORE_PTZ                    0x00000080       // 云台控制
#define DH_RESTORE_OUTPUTMODE             0x00000100       // 输出模式
#define DH_RESTORE_CHANNELNAME            0x00000200       // 通道名称
#define DH_RESTORE_VIDEOINOPTIONS         0x00000400       // 摄像头属性
#define DH_RESTORE_CPS                    0x00000800       // 智能交通
#define DH_RESTORE_INTELLIGENT            0x00001000       // 视频分析
#define DH_RESTORE_REMOTEDEVICE           0x00002000       // 远程设备配置
#define DH_RESTORE_DECODERVIDEOOUT        0x00004000       // 解码轮巡
#define DH_RESTORE_LINKMODE               0x00008000       // 连接模式
#define DH_RESTORE_COMPOSITE              0x00010000       // 融合屏    
#define DH_RESTORE_ALL                    0x80000000       // 全部重置

// 云台属性列表--低四个字节掩码
#define PTZ_DIRECTION                     0x00000001       // 方向
#define PTZ_ZOOM                          0x00000002       // 变倍
#define PTZ_FOCUS                         0x00000004       // 聚焦
#define PTZ_IRIS                          0x00000008       // 光圈
#define PTZ_ALARM                         0x00000010       // 报警功能
#define PTZ_LIGHT                         0x00000020       // 灯光
#define PTZ_SETPRESET                     0x00000040       // 设置预置点
#define PTZ_CLEARPRESET                   0x00000080       // 清除预置点
#define PTZ_GOTOPRESET                    0x00000100       // 转至预置点
#define PTZ_AUTOPANON                     0x00000200       // 水平开始
#define PTZ_AUTOPANOFF                    0x00000400       // 水平结束
#define PTZ_SETLIMIT                      0x00000800       // 设置边界
#define PTZ_AUTOSCANON                    0x00001000       // 自动扫描开始
#define PTZ_AUTOSCANOFF                   0x00002000       // 自动扫描开停止
#define PTZ_ADDTOUR                       0x00004000       // 增加巡航点
#define PTZ_DELETETOUR                    0x00008000       // 删除巡航点
#define PTZ_STARTTOUR                     0x00010000       // 开始巡航
#define PTZ_STOPTOUR                      0x00020000       // 结束巡航
#define PTZ_CLEARTOUR                     0x00040000       // 删除巡航
#define PTZ_SETPATTERN                    0x00080000       // 设置模式
#define PTZ_STARTPATTERN                  0x00100000       // 开始模式
#define PTZ_STOPPATTERN                   0x00200000       // 停止模式
#define PTZ_CLEARPATTERN                  0x00400000       // 清除模式
#define PTZ_POSITION                      0x00800000       // 快速定位
#define PTZ_AUX                           0x01000000       // 辅助开关
#define PTZ_MENU                          0x02000000       // 球机菜单
#define PTZ_EXIT                          0x04000000       // 退出球机菜单
#define PTZ_ENTER                         0x08000000       // 确认
#define PTZ_ESC                           0x10000000       // 取消
#define PTZ_MENUUPDOWN                    0x20000000       // 菜单上下操作
#define PTZ_MENULEFTRIGHT                 0x40000000       // 菜单左右操作
#define PTZ_OPT_NUM                       0x80000000       // 操作的个数

// 高四个字节掩码
#define PTZ_DEV                           0x00000001       // 云台控制
#define PTZ_MATRIX                        0x00000002       // 矩阵控制

// 抓图视频编码类型
#define CODETYPE_MPEG4                    0
#define CODETYPE_H264                     1
#define CODETYPE_JPG                      2

// 码流控制列表
#define DH_CAPTURE_BRC_CBR                0
#define DH_CAPTURE_BRC_VBR                1
//#define DH_CAPTURE_BRC_MBR              2

// 帧类型掩码定义
#define FRAME_TYPE_MOTION                       0x00000001       // 动检帧
#define FRAME_TYPE_HUMAN						0x00000002	   // 动检帧(人)
#define FRAME_TYPE_VEHICLE						0x00000004	   // 动检帧(车)

// 智能分析事件类型
#define EVENT_IVS_ALL                           0x00000001        // 订阅所有事件
#define EVENT_IVS_CROSSLINEDETECTION            0x00000002        // 警戒线事件(对应 DEV_EVENT_CROSSLINE_INFO)
#define EVENT_IVS_CROSSREGIONDETECTION          0x00000003        // 警戒区事件(对应 DEV_EVENT_CROSSREGION_INFO)
#define EVENT_IVS_PASTEDETECTION                0x00000004        // 贴条事件(对应 DEV_EVENT_PASTE_INFO)
#define EVENT_IVS_LEFTDETECTION                 0x00000005        // 物品遗留事件(对应 DEV_EVENT_LEFT_INFO)
#define EVENT_IVS_STAYDETECTION                 0x00000006        // 停留事件(对应 DEV_EVENT_STAY_INFO)
#define EVENT_IVS_WANDERDETECTION               0x00000007        // 徘徊事件(对应 DEV_EVENT_WANDER_INFO)
#define EVENT_IVS_PRESERVATION                  0x00000008        // 物品保全事件(对应 DEV_EVENT_PRESERVATION_INFO)
#define EVENT_IVS_MOVEDETECTION                 0x00000009        // 移动事件(对应 DEV_EVENT_MOVE_INFO)
#define EVENT_IVS_TAILDETECTION                 0x0000000A        // 尾随事件(对应 DEV_EVENT_TAIL_INFO)
#define EVENT_IVS_RIOTERDETECTION               0x0000000B        // 聚众事件(对应 DEV_EVENT_RIOTERL_INFO)
#define EVENT_IVS_FIREDETECTION                 0x0000000C        // 火警事件(对应 DEV_EVENT_FIRE_INFO)
#define EVENT_IVS_SMOKEDETECTION                0x0000000D        // 烟雾报警事件(对应 DEV_EVENT_SMOKE_INFO)
#define EVENT_IVS_FIGHTDETECTION                0x0000000E        // 斗殴事件(对应 DEV_EVENT_FIGHT_INFO)
#define EVENT_IVS_FLOWSTAT                      0x0000000F        // 流量统计事件(对应 DEV_EVENT_FLOWSTAT_INFO)
#define EVENT_IVS_NUMBERSTAT                    0x00000010        // 数量统计事件(对应 DEV_EVENT_NUMBERSTAT_INFO)
#define EVENT_IVS_CAMERACOVERDDETECTION         0x00000011        // 摄像头覆盖事件(保留)
#define EVENT_IVS_CAMERAMOVEDDETECTION          0x00000012        // 摄像头移动事件(保留)
#define EVENT_IVS_VIDEOABNORMALDETECTION        0x00000013        // 视频异常事件(对应 DEV_EVENT_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_VIDEOBADDETECTION             0x00000014        // 视频损坏事件(保留)
#define EVENT_IVS_TRAFFICCONTROL                0x00000015        // 交通管制事件(对应 DEV_EVENT_TRAFFICCONTROL_INFO)
#define EVENT_IVS_TRAFFICACCIDENT               0x00000016        // 交通事故事件(对应 DEV_EVENT_TRAFFICACCIDENT_INFO)
#define EVENT_IVS_TRAFFICJUNCTION               0x00000017        // 交通路口事件----老规则(对应 DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_TRAFFICGATE                   0x00000018        // 交通卡口事件----老规则(对应 DEV_EVENT_TRAFFICGATE_INFO)
#define EVENT_TRAFFICSNAPSHOT                   0x00000019        // 交通抓拍事件(对应 DEV_EVENT_TRAFFICSNAPSHOT_INFO)
#define EVENT_IVS_FACEDETECT                    0x0000001A        // 人脸检测事件 (对应 DEV_EVENT_FACEDETECT_INFO)
#define EVENT_IVS_TRAFFICJAM                    0x0000001B        // 交通拥堵事件(对应 DEV_EVENT_TRAFFICJAM_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTORINMOTORROUTE  0x0000001C        // 非机动车占机动车车道事件(对应 DEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO)
#define EVENT_IVS_TRAFFIC_RUNREDLIGHT           0x00000100        // 交通违章-闯红灯事件(对应 DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_OVERLINE              0x00000101        // 交通违章-压车道线事件(对应 DEV_EVENT_TRAFFIC_OVERLINE_INFO)
#define EVENT_IVS_TRAFFIC_RETROGRADE            0x00000102        // 交通违章-逆行事件(对应 DEV_EVENT_TRAFFIC_RETROGRADE_INFO)
#define EVENT_IVS_TRAFFIC_TURNLEFT              0x00000103        // 交通违章-违章左转(对应 DEV_EVENT_TRAFFIC_TURNLEFT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHT             0x00000104        // 交通违章-违章右转(对应 DEV_EVENT_TRAFFIC_TURNRIGHT_INFO)
#define EVENT_IVS_TRAFFIC_UTURN                 0x00000105        // 交通违章-违章掉头(对应 DEV_EVENT_TRAFFIC_UTURN_INFO)
#define EVENT_IVS_TRAFFIC_OVERSPEED             0x00000106        // 交通违章-超速(对应 DEV_EVENT_TRAFFIC_OVERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_UNDERSPEED            0x00000107        // 交通违章-低速(对应 DEV_EVENT_TRAFFIC_UNDERSPEED_INFO)
#define EVENT_IVS_TRAFFIC_PARKING               0x00000108        // 交通违章-违章停车(对应 DEV_EVENT_TRAFFIC_PARKING_INFO)
#define EVENT_IVS_TRAFFIC_WRONGROUTE            0x00000109        // 交通违章-不按车道行驶(对应 DEV_EVENT_TRAFFIC_WRONGROUTE_INFO)
#define EVENT_IVS_TRAFFIC_CROSSLANE             0x0000010A        // 交通违章-违章变道(对应 DEV_EVENT_TRAFFIC_CROSSLANE_INFO)
#define EVENT_IVS_TRAFFIC_OVERYELLOWLINE        0x0000010B        // 交通违章-压黄线 (对应 DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO)
#define EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER     0x0000010C        // 交通违章-路肩行驶事件(对应 DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO)   
#define EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE     0x0000010E        // 交通违章-黄牌车占道事件(对应 DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO)
#define EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY    0x0000010F        // 交通违章-礼让行人/斑马线行人优先事件(对应 DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO)
#define EVENT_IVS_CROSSFENCEDETECTION           0x0000011F        // 翻越围栏事件(对应 DEV_EVENT_CROSSFENCEDETECTION_INFO)
#define EVENT_IVS_ELECTROSPARKDETECTION         0x00000110        // 电火花事件(对应 DEV_EVENT_ELECTROSPARK_INFO)
#define EVENT_IVS_TRAFFIC_NOPASSING             0x00000111        // 交通违章-禁止通行事件(对应 DEV_EVENT_TRAFFIC_NOPASSING_INFO)
#define EVENT_IVS_ABNORMALRUNDETECTION          0x00000112        // 异常奔跑事件(对应 DEV_EVENT_ABNORMALRUNDETECTION_INFO)
#define EVENT_IVS_RETROGRADEDETECTION           0x00000113        // 人员逆行事件(对应 DEV_EVENT_RETROGRADEDETECTION_INFO)
#define EVENT_IVS_INREGIONDETECTION             0x00000114        // 区域内检测事件(对应 DEV_EVENT_INREGIONDETECTION_INFO)
#define EVENT_IVS_TAKENAWAYDETECTION            0x00000115        // 物品搬移事件(对应 DEV_EVENT_TAKENAWAYDETECTION_INFO)
#define EVENT_IVS_PARKINGDETECTION              0x00000116        // 非法停车事件(对应 DEV_EVENT_PARKINGDETECTION_INFO)
#define EVENT_IVS_FACERECOGNITION               0x00000117        // 人脸识别事件(对应 DEV_EVENT_FACERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_MANUALSNAP            0x00000118        // 交通手动抓拍事件(对应 DEV_EVENT_TRAFFIC_MANUALSNAP_INFO)
#define EVENT_IVS_TRAFFIC_FLOWSTATE             0x00000119        // 交通流量统计事件(对应 DEV_EVENT_TRAFFIC_FLOW_STATE)
#define EVENT_IVS_TRAFFIC_STAY                  0x0000011A        // 交通滞留事件(对应 DEV_EVENT_TRAFFIC_STAY_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINROUTE        0x0000011B        // 有车占道事件(对应 DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO)
#define EVENT_ALARM_MOTIONDETECT                0x0000011C        // 视频移动侦测事件(对应 DEV_EVENT_ALARM_INFO)
#define EVENT_ALARM_LOCALALARM                  0x0000011D        // 外部报警事件(对应 DEV_EVENT_ALARM_INFO)
#define EVENT_IVS_PRISONERRISEDETECTION         0x0000011E        // 看守所囚犯起身事件(对应 DEV_EVENT_PRISONERRISEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_TOLLGATE              0x00000120        // 交通违章-卡口事件----新规则(对应 DEV_EVENT_TRAFFICJUNCTION_INFO)
#define EVENT_IVS_DENSITYDETECTION              0x00000121        // 人员密集度检测(对应 DEV_EVENT_DENSITYDETECTION_INFO)
#define EVENT_IVS_VIDEODIAGNOSIS                0x00000122        // 视频诊断结果事件(对应 NET_VIDEODIAGNOSIS_COMMON_INFO 和 NET_REAL_DIAGNOSIS_RESULT)
#define EVENT_IVS_QUEUEDETECTION                0x00000123        // 排队检测报警事件(对应 DEV_EVENT_QUEUEDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE     0x00000124        // 占用公交车道事件(对应 DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO)
#define EVENT_IVS_TRAFFIC_BACKING               0x00000125        // 违章倒车事件(对应 DEV_EVENT_IVS_TRAFFIC_BACKING_INFO)
#define EVENT_IVS_AUDIO_ABNORMALDETECTION       0x00000126        // 声音异常检测(对应 DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO)
#define EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT        0x00000127        // 交通违章-闯黄灯事件(对应 DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO)
#define EVENT_IVS_CLIMBDETECTION                0x00000128        // 攀高检测事件(对应 DEV_EVENT_IVS_CLIMB_INFO)
#define EVENT_IVS_LEAVEDETECTION                0x00000129        // 离岗检测事件(对应 DEV_EVENT_IVS_LEAVE_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX    0x0000012A        // 黄网格线抓拍事件(对应 DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING   0x0000012B        // 车位有车事件(对应 DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO)
#define EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING 0x0000012C        // 车位无车事件(对应 DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO)    
#define EVENT_IVS_TRAFFIC_PEDESTRAIN            0x0000012D        // 交通行人事件(对应 DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO)
#define EVENT_IVS_TRAFFIC_THROW                 0x0000012E        // 交通抛洒物品事件(对应 DEV_EVENT_TRAFFIC_THROW_INFO)
#define EVENT_IVS_TRAFFIC_IDLE                  0x0000012F        // 交通空闲事件(对应 DEV_EVENT_TRAFFIC_IDLE_INFO)
#define EVENT_ALARM_VEHICLEACC                  0x00000130        // 车载ACC断电报警事件(对应 DEV_EVENT_ALARM_VEHICLEACC_INFO)
#define EVENT_ALARM_VEHICLE_TURNOVER            0x00000131        // 车辆侧翻报警事件(对应 DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_COLLISION           0x00000132        // 车辆撞车报警事件(对应 DEV_EVENT_VEHICEL_ALARM_INFO)
#define EVENT_ALARM_VEHICLE_LARGE_ANGLE         0x00000133        // 车载摄像头大角度扭转事件
#define EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE  0x00000134        // 车位压线事件(对应 DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO)
#define EVENT_IVS_MULTISCENESWITCH              0x00000135        // 多场景切换事件(对应 DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO)
#define EVENT_IVS_TRAFFIC_RESTRICTED_PLATE      0x00000136        // 受限车牌事件(对应 DEV_EVENT_TRAFFIC_RESTRICTED_PLATE)
#define EVENT_IVS_TRAFFIC_OVERSTOPLINE          0x00000137        // 压停止线事件(对应 DEV_EVENT_TRAFFIC_OVERSTOPLINE)
#define EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT      0x00000138        // 交通未系安全带事件(对应 DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT)
#define EVENT_IVS_TRAFFIC_DRIVER_SMOKING        0x00000139        // 驾驶员抽烟事件(对应 DEV_EVENT_TRAFFIC_DRIVER_SMOKING)
#define EVENT_IVS_TRAFFIC_DRIVER_CALLING        0x0000013A        // 驾驶员打电话事件(对应 DEV_EVENT_TRAFFIC_DRIVER_CALLING)
#define EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT 0x0000013B        // 行人闯红灯事件(对应 DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO)
#define EVENT_IVS_TRAFFIC_PASSNOTINORDER        0x0000013C        // 未按规定依次通行(对应 DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO)
#define EVENT_IVS_OBJECT_DETECTION              0x00000141        // 物体特征检测事件
#define EVENT_ALARM_ANALOGALARM                 0x00000150        // 模拟量报警通道的报警事件(对应DEV_EVENT_ALARM_ANALOGALRM_INFO)
#define EVENT_IVS_CROSSLINEDETECTION_EX         0x00000151        // 警戒线扩展事件
#define EVENT_ALARM_COMMON                      0x00000152        // 普通录像
#define EVENT_ALARM_VIDEOBLIND                  0x00000153        // 视频遮挡事件(对应 DEV_EVENT_ALARM_VIDEOBLIND)
#define EVENT_ALARM_VIDEOLOSS                   0x00000154        // 视频丢失事件
#define EVENT_IVS_GETOUTBEDDETECTION            0x00000155        // 看守所下床事件(对应 DEV_EVENT_GETOUTBED_INFO)
#define EVENT_IVS_PATROLDETECTION               0x00000156        // 巡逻检测事件(对应 DEV_EVENT_PATROL_INFO)
#define EVENT_IVS_ONDUTYDETECTION               0x00000157        // 站岗检测事件(对应 DEV_EVENT_ONDUTY_INFO)
#define EVENT_IVS_NOANSWERCALL                  0x00000158        // 门口机呼叫未响应事件
#define EVENT_IVS_STORAGENOTEXIST               0x00000159        // 存储组不存在事件
#define EVENT_IVS_STORAGELOWSPACE               0x0000015A        // 硬盘空间低报警事件
#define EVENT_IVS_STORAGEFAILURE                0x0000015B        // 存储错误事件
#define EVENT_IVS_PROFILEALARMTRANSMIT          0x0000015C        // 报警传输事件(对应 DEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO)
#define EVENT_IVS_VIDEOSTATIC                   0x0000015D        // 视频静态检测事件(对应 DEV_EVENT_ALARM_VIDEOSTATIC_INFO)
#define EVENT_IVS_VIDEOTIMING                   0x0000015E        // 视频定时检测事件(对应 DEV_EVENT_ALARM_VIDEOTIMING_INFO)
#define EVENT_IVS_HEATMAP                       0x0000015F        // 热度图(对应 CFG_IVS_HEATMAP_INFO)
#define EVENT_IVS_CITIZENIDCARD                 0x00000160        // 身份证信息读取事件(对应 DEV_EVENT_ALARM_CITIZENIDCARD_INFO)
#define EVENT_IVS_PICINFO                       0x00000161        // 图片信息事件(对应 DEV_EVENT_ALARM_PIC_INFO)
#define EVENT_IVS_NETPLAYCHECK                  0x00000162        // 上网登记事件(对应 DEV_EVENT_ALARM_NETPLAYCHECK_INFO)
#define EVENT_IVS_TRAFFIC_JAM_FORBID_INTO       0x00000163        // 车辆拥堵禁入事件(对应 DEV_EVENT_ALARM_JAMFORBIDINTO_INFO)
#define EVENT_IVS_SNAPBYTIME                    0x00000164        // 定时抓图事件(对应DEV_EVENT_SNAPBYTIME)
#define EVENT_IVS_PTZ_PRESET                    0x00000165        // 云台转动到预置点事件(对应 DEV_EVENT_ALARM_PTZ_PRESET_INFO)
#define EVENT_IVS_RFID_INFO                     0x00000166        // 红外线检测信息事件(对应 DEV_EVENT_ALARM_RFID_INFO)
#define EVENT_IVS_STANDUPDETECTION              0x00000167        // 人起立检测事件 
#define EVENT_IVS_QSYTRAFFICCARWEIGHT           0x00000168        // 交通卡口称重事件(对应 DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO)
#define EVENT_IVS_TRAFFIC_COMPAREPLATE          0x00000169        // 卡口前后车牌合成事件(对应DEV_EVENT_TRAFFIC_COMPAREPLATE_INFO)
#define EVENT_IVS_SHOOTINGSCORERECOGNITION      0x0000016A        // 打靶像机事件(对应 DEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO,CFG_IVS_SHOOTINGSCORERECOGNITION_INFO)
#define EVENT_IVS_TRAFFIC_FCC                   0x0000016B        // 加油站提枪、挂枪事件(对应 DEV_EVENT_TRAFFIC_FCC_INFO)
#define EVENT_IVS_TRAFFIC_TRANSFINITE           0x0000016C        // 违章超限抓图上报事件,绍兴科技治超(对应 DEV_EVENT_TRAFFIC_TRANSFINITE_INFO)
#define EVENT_IVS_SCENE_CHANGE                  0x0000016D        // 场景变更事件(对应 DEV_ALRAM_SCENECHANGE_INFO,CFG_VIDEOABNORMALDETECTION_INFO)
#define EVENT_IVS_LETRACK                       0x0000016E        // 简单跟踪事件(暂未有具体事件)
#define EVENT_IVS_OBJECT_ACTION                 0x0000016F        // 物体检测事件(暂未有具体事件)
#define EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP       0x00000170        // 预分析抓拍图片事件(对应 DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO)
#define EVENT_ALARM_EQSTATE                     0x00000171        // 智能插座电量状态上报(暂未有具体事件)
#define EVENT_IVS_ALARM_IPC                     0x00000172        // DVR/NVR设备上的IPC报警(对应 DEV_EVENT_ALARM_IPC_INFO)
#define EVENT_IVS_POS_RECORD                    0x00000173        // POS录像查询事件(暂未有具体事件)
#define EVENT_IVS_NEAR_DISTANCE_DETECTION       0x00000174        // 近距离接触事件(对应 DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_PERSON       0x00000175        // 行人特征检测事件(对应 DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO)
#define EVENT_IVS_OBJECTSTRUCTLIZE_NONMOTOR     0x00000176        // 非机动车特征检测事件(对应 DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO)
#define EVENT_IVS_TUMBLE_DETECTION              0x00000177        // 倒地报警事件(对应 DEV_EVENT_TUMBLE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_ALL                   0x000001FF        // 所有以traffic开头的事件,目前指的是
                                                                  // EVENT_IVS_TRAFFICCONTROL -> EVENT_TRAFFICSNAPSHOT
                                                                  // EVENT_IVS_TRAFFIC_RUNREDLIGHT -> EVENT_IVS_TRAFFIC_UNDERSPEED
#define EVENT_IVS_VIDEOANALYSE                  0x00000200      // 所有智能分析事件 
#define EVENT_IVS_LINKSD                        0x00000201      // LinkSD事件(对应 DEV_EVENT_LINK_SD)
#define EVENT_IVS_VEHICLEANALYSE                0x00000202      // 车辆特征检测分析(对应DEV_EVENT_VEHICLEANALYSE)
#define EVENT_IVS_FLOWRATE                      0x00000203      // 流量使用情况事件(对应 DEV_EVENT_FLOWRATE_INFO)
#define EVENT_IVS_ACCESS_CTL                    0x00000204      // 门禁事件 (对应 DEV_EVENT_ACCESS_CTL_INFO)
#define EVENT_IVS_SNAPMANUAL                    0x00000205      // SnapManual事件(对应 DEV_EVENT_SNAPMANUAL)
#define EVENT_IVS_TRAFFIC_ELETAGINFO            0x00000206      // RFID电子车牌标签事件(对应 DEV_EVENT_TRAFFIC_ELETAGINFO_INFO)
#define EVENT_IVS_TRAFFIC_TIREDPHYSIOLOGICAL    0x00000207      // 生理疲劳驾驶事件(对应 DEV_EVENT_TIREDPHYSIOLOGICAL_INFO)
#define EVENT_IVS_TRAFFIC_BUSSHARPTURN          0x00000208      // 车辆急转报警事件(对应DEV_EVENT_BUSSHARPTURN_INFO)
#define EVENT_IVS_CITIZEN_PICTURE_COMPARE       0x00000209      // 人证比对事件(对应 DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO)
#define EVENT_IVS_TRAFFIC_TIREDLOWERHEAD        0x0000020A      // 开车低头报警事件(对应DEV_EVENT_TIREDLOWERHEAD_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND      0x0000020B      // 开车左顾右盼报警事件(对应DEV_EVENT_DRIVERLOOKAROUND_INFO)
#define EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST       0x0000020C      // 开车离岗报警事件(对应DEV_EVENT_DRIVERLEAVEPOST_INFO)
#define EVENT_IVS_MAN_STAND_DETECTION           0x0000020D      // 立体视觉站立事件(对应DEV_EVENT_MANSTAND_DETECTION_INFO)
#define EVENT_IVS_MAN_NUM_DETECTION             0x0000020E      // 立体视觉区域内人数统计事件(对应DEV_EVENT_MANNUM_DETECTION_INFO)
#define EVENT_IVS_STEREO_NUMBERSTAT             0x0000020F      // 客流量统计事件(暂未有具体事件)
#define EVENT_IVS_TRAFFIC_DRIVERYAWN            0x00000210      // 开车打哈欠事件(对应DEV_EVENT_DRIVERYAWN_INFO)
#define EVENT_IVS_NUMBERSTAT_PLAN               0x00000211      // 客流量统计计划(暂未有具体事件,球机使用,对应规则配置结构体 CFG_NUMBERSTAT_INFO)
#define EVENT_IVS_HEATMAP_PLAN                  0x00000212      // 热度图计划(暂未有具体事件,球机使用,对应规则配置结构体 CFG_IVS_HEATMAP_INFO)
#define EVENT_IVS_CALLNOANSWERED                0x00000213      // 呼叫无答应事件
#define EVENT_IVS_IGNOREINVITE                  0x00000214      // 无视邀请事件
#define EVENT_IVS_HUMANTRAIT                    0x00000215      // 人体特征事件(对应 DEV_EVENT_HUMANTRAIT_INFO)
#define EVENT_ALARM_LE_HEADDETECTION            0x00000216      // 乐橙人头检测事件,只用于订阅手机推送
#define EVENT_IVS_FACEANALYSIS                  0x00000217      // 人脸分析事件 (暂未有具体事件)
#define EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT 0x00000218      // 左转不礼让直行事件(对应 DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN      0x00000219      // 大弯小转事件(对应 DEV_EVENT_BIGBENDSMALLTURN_INFO)
#define EVENT_IVS_ROAD_CONSTRUCTION             0x0000021A      // 道路施工监测事件(对应DEV_EVENT_ROAD_CONSTRUCTION_INFO)
#define EVENT_IVS_ROAD_BLOCK                    0x0000021B      // 路障检测事件(对应DEV_EVENT_ROAD_BLOCK_INFO)
#define EVENT_IVS_TRAFFIC_QUEUEJUMP             0x0000021C      // 车辆加塞事件(对应 DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO)
#define EVENT_IVS_VEHICLE_SUSPICIOUSCAR         0x0000021D      // 嫌疑车辆事件(对应 DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT  0x0000021E    // 右转不礼让直行事件(对应 DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO)
#define EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE    0x0000021F    // 右转不礼让直行行人(对应 DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO)
#define EVENT_IVS_INSTALL_CARDREADER            0x00000220      // 安装读卡器事件(对应 DEV_EVENT_INSTALL_CARDREADER_INFO)
#define EVENT_ALARM_YALE_DROPBOX_BADTOKEN       0x00000221      // Yale token失效事件，只用于订阅手机推送
#define EVENT_IVS_ACC_OFF_SNAP                  0x00000222      // 车载设备断电前抓拍上传事件(对应 DEV_EVENT_ACC_OFF_SNAP_INFO)
#define EVENI_IVS_XRAY_DETECTION				0x00000223		// X光检测事件 (对应 DEV_EVENT_XRAY_DETECTION_INFO)
#define EVENT_IVS_NOTCLEARCAR					0x00000224		// 未清车告警(对应 DEV_EVENT_NOTCLEARCAR_INFO)
#define EVENT_IVS_SOSALEART						0x00000225		// sos求救报警(对应 DEV_EVENT_SOSALEART_INFO)
#define EVENT_IVS_OVERLOAD						0x00000226		// 超载抓图(对应 DEV_EVENT_OVERLOAD_INFO)
#define EVENT_IVS_NONWORKINGTIME				0x00000227		// 非工作时间告警(对应 DEV_EVENT_NONWORKINGTIME_INFO)
#define EVENT_IVS_TRAFFIC_HIGH_BEAM				0x00000228		// 远光灯违章事件(对应 DEV_EVENT_TRAFFIC_HIGH_BEAM_INFO)
#define EVENT_IVS_TRAFFIC_TRUCKFORBID			0x00000229		// 禁止货车事件(对应 DEV_EVENT_TRAFFICTRUCKFORBID_INFO)
#define EVENT_IVS_DRIVINGWITHOUTCARD			0x0000022A		// 无卡驾驶报警事件(对应 DEV_EVENT_DRIVINGWITHOUTCARD_INFO)
#define EVENT_IVS_HIGHSPEED						0x0000022B		// 车辆超速报警事件(对应 DEV_EVENT_HIGHSPEED_INFO)
#define EVENT_IVS_CROWDDETECTION				0x0000022C		// 人群密度检测事件(对应结构体 DEV_EVENT_CROWD_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_CARDISTANCESHORT		0x0000022D		// 车间距过小报警事件(对应 DEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO)
#define EVENT_IVS_PEDESTRIAN_JUNCTION			0x00000230		// 行人卡口事件(对应 DEV_EVENT_PEDESTRIAN_JUNCTION_INFO)
#define EVENT_IVS_VEHICLE_RECOGNITION           0x00000231      // 车牌对比事件(中石化智慧加油站项目)(对应 DEV_EVENT_VEHICLE_RECOGNITION_INFO)
#define EVENT_IVS_PASS_CHANGE					0x00000232		// 预置点图片变化事件 (对应 DEV_EVENT_PASS_CHANGE_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_SPACEDETECTION 0x00000233		// 违停相机定制单球车位检测规则事件
#define EVENT_IVS_TRAFFIC_WAITINGAREA           0x00000234		// 违章进入待行区事件(对应 DEV_EVENT_TRAFFIC_WAITINGAREA_INFO)
#define EVENT_IVS_TRAFFIC_BAN					0x00000235		// 机动车违法禁令标识事件(对应 DEV_EVENT_TRAFFIC_BAN_INFO)
#define EVENT_IVS_POS_EXCHANGE					0x00000236		// POS机交易事件(对应 DEV_EVENT_POS_EXCHANGE_INFO)
#define EVENT_IVS_STEREO_FIGHTDETECTION         0x00000237      // 立体行为分析打架/剧烈运动检测规则(仅用于规则配置，对应事件 EVENT_IVS_FIGHTDETECTION)
#define EVENT_IVS_STEREO_DISTANCE_DETECTION		0x00000238		// 立体行为分析间距异常/人员靠近检测(仅用于规则配置，对应事件)
#define EVENT_IVS_STEREO_STEREOFALLDETECTION    0x00000239      // 立体行为分析跌倒检测规则(仅用于规则配置，对应事件 EVENT_IVS_TUMBLE_DETECTION)
#define EVENT_IVS_STEREO_STAYDETECTION    		0x0000023A      // 立体行为分析人员滞留检测规则(仅用于规则配置，对应事件 EVENT_IVS_STAYDETECTION)
#define EVENT_IVS_BANNER_DETECTION				0x0000023B		// 拉横幅事件(对应 DEV_EVENT_BANNER_DETECTION_INFO)
#define EVENT_IVS_NORMAL_FIGHTDETECTION         0x0000023C      // 普通打架事件(只用于普通打架规则, 事件采用EVENT_IVS_FIGHTDETECTION)
#define EVENT_IVS_ELEVATOR_ABNORMAL				0x0000023D		// 电动扶梯运行异常事件 (对应DEV_EVENT_ELEVATOR_ABNORMAL_INFO)
#define EVENT_IVS_NONMOTORDETECT                0x0000023E      // 非机动车检测 (对应结构体 DEV_EVENT_NONMOTORDETECT_INFO)
#define EVENT_IVS_VEHICLEDETECT                 0x0000023F      // 机动车检测 (只用于规则配置，事件采用EVENT_IVS_TRAFFICJUNCTION)
#define EVENT_IVS_TRAFFIC_PARKING_B             0x00000240      // 交通违章-B类违章停车(对应 DEV_EVENT_TRAFFIC_PARKING_B_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_C             0x00000241      // 交通违章-C类违章停车(对应 DEV_EVENT_TRAFFIC_PARKING_C_INFO)
#define EVENT_IVS_TRAFFIC_PARKING_D             0x00000242      // 交通违章-D类违章停车(对应 DEV_EVENT_TRAFFIC_PARKING_D_INFO)
#define EVENT_IVSS_FACEATTRIBUTE                0x00000243      // IVSS人脸检测事件 (暂未有具体事件)
#define EVENT_IVSS_FACECOMPARE                  0x00000244      // IVSS人脸识别事件 (暂未有具体事件)
#define EVENT_IVS_FIREWARNING					0x00000245		// 火警事件(对应 DEV_EVENT_FIREWARNING_INFO)
#define EVENT_IVS_SHOPPRESENCE					0x00000246      // 商铺占道经营事件(对应 DEV_EVENT_SHOPPRESENCE_INFO)
#define EVENT_IVS_WASTEDUMPED					0x00000247      // 垃圾违章倾倒事件(对应 DEV_EVENT_WASTEDUMPED_INFO)
#define EVENT_IVS_SPILLEDMATERIAL_DETECTION		0x00000248      // 抛洒物检测事件(对应 DEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO)
#define EVENT_IVS_STEREO_MANNUM_DETECTION		0x00000249		// 立体行为分析人数异常检测 (仅用于规则配置，对应事件 EVENT_IVS_MAN_NUM_DETECTION)
#define EVENT_IVS_DISTANCE_DETECTION			0x0000024A		// 异常间距事件 (对应 DEV_EVENT_DISTANCE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_OVERLOAD		0x0000024B		// 非机动车超载事件 (对应 DEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT	0x0000024C	// 非机动车未戴安全帽事件 (对应 DEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO)
#define EVENT_IVS_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING 0x0000024D		// 拥堵滞留斑马线事件 (对应 DEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO)
#define EVENT_IVS_FLOWBUSINESS					0x0000024E		// 流动摊贩事件 (对应 DEV_EVENT_FLOWBUSINESS_INFO)
#define EVENT_IVS_CITY_MOTORPARKING				0x0000024F		// 城市机动车违停事件 (对应 DEV_EVENT_CITY_MOTORPARKING_INFO)
#define EVENT_IVS_CITY_NONMOTORPARKING			0x00000250		// 城市机非动车违停事件 (对应 DEV_EVENT_CITY_NONMOTORPARKING_INFO)
#define EVENT_IVS_LANEDEPARTURE_WARNNING		0X00000251		// 车道偏移预警(对应 DEV_EVENT_LANEDEPARTURE_WARNNING_INFO)
#define EVENT_IVS_FORWARDCOLLISION_WARNNING		0x00000252		// 前向碰撞预警(对应 DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO)
#define EVENT_IVS_MATERIALSSTAY					0x00000253		// 物料堆放事件(对应 DEV_EVENT_MATERIALSSTAY_INFO)
#define EVENT_IVS_TRAFFIC_NONMOTOR_HOLDUMBRELLA 0x00000254		// 非机动车装载伞具(对应 DEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO)
#define EVENT_IVS_JABLOTRON_ALARM				0x00000255		// 客户报警产品
#define EVENT_IVS_VIDEOUNFOCUS_ALARM			0x00000256		// 视频虚焦事件(对应DEV_EVENT_VIDEOUNFOCUS_INFO)
#define EVENT_IVS_FLOATINGOBJECT_DETECTION		0x00000257		// 漂浮物检测事件 (对应 DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO)
#define EVENT_IVS_SHIP_DETECTION				0x00000258		// 船舶检测事件 (对应 DEV_EVENT_SHIP_DETECTION_INFO)
#define EVENT_IVS_AIRPLANE_DETECTION			0x00000259		// 飞机行为检测事件(对应 DEV_EVENT_AIRPLANE_DETECTION_INFO)
#define EVENT_IVS_PHONECALL_DETECT				0x0000025A		// 打电话检测事件(对应 DEV_EVENT_PHONECALL_DETECT_INFO)
#define EVENT_IVS_SMOKING_DETECT				0x0000025B		// 吸烟检测事件(对应 DEV_EVENT_SMOKING_DETECT_INFO)
#define EVENT_IVS_RADAR_SPEED_LIMIT_ALARM       0x0000025C      // 雷达限速报警事件(对应 DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO)
#define EVENT_IVS_WATER_LEVEL_DETECTION			0x0000025D		// 水位检测事件 (对应 DEV_EVENT_WATER_LEVEL_DETECTION_INFO)
#define EVENT_IVS_HOLD_UMBRELLA			        0x0000025E		// 违规撑伞检测事件 (对应 DEV_EVENT_HOLD_UMBRELLA_INFO)
#define EVENT_IVS_GARBAGE_EXPOSURE			    0x0000025F		// 垃圾暴露检测事件 (对应 DEV_EVENT_GARBAGE_EXPOSURE_INFO)
#define EVENT_IVS_DUSTBIN_OVER_FLOW			    0x00000260		// 垃圾桶满溢检测事件 (对应 DEV_EVENT_DUSTBIN_OVER_FLOW_INFO)
#define EVENT_IVS_DOOR_FRONT_DIRTY			    0x00000261		// 门前脏乱检测事件 (对应 DEV_EVENT_DOOR_FRONT_DIRTY_INFO)
#define EVENT_IVS_QUEUESTAY_DETECTION			0X00000262		// 排队滞留时间报警事件 (对应 DEV_EVENT_QUEUESTAY_DETECTION_INFO)
#define EVENT_IVS_QUEUENUM_DETECTION			0X00000263		// 排队人数异常报警事件（对应 DEV_EVENT_QUEUENUM_DETECTION_INFO）
#define EVENT_IVS_GENERATEGRAPH_DETECTION		0X00000264		// 生成图规则事件（对应 DEV_EVENT_GENERATEGRAPH_DETECTION_INFO）
#define EVENT_IVS_TRAFFIC_PARKING_MANUAL		0x00000265		// 交通违章-手动取证(对应 DEV_EVENT_TRAFFIC_PARKING_MANUAL_INFO)
#define EVENT_IVS_HELMET_DETECTION      		0x00000266		// 安全帽检测事件(对应 DEV_EVENT_HELMET_DETECTION_INFO)
#define EVENT_IVS_DEPOSIT_DETECTION      		0x00000267		// 包裹堆积程度检测事件(对应 DEV_EVENT_DEPOSIT_DETECTION_INFO)
#define EVENT_IVS_HOTSPOT_WARNING				0x00000268		// 热点异常报警事件(对应 DEV_EVENT_HOTSPOT_WARNING_INFO)
#define EVENT_IVS_WEIGHING_PLATFORM_DETECTION	0x00000269		// 称重平台检测事件(对应 DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO)
#define EVENT_IVS_CLASSROOM_BEHAVIOR			0x0000026A		// 课堂行为分析事件(对应 DEV_EVENT_CLASSROOM_BEHAVIOR_INFO)
#define EVENT_IVS_VEHICLE_DISTANCE_NEAR			0x0000026B		// 安全驾驶车距过近报警事件(对应 DEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO)
#define EVENT_IVS_TRAFFIC_DRIVER_ABNORMAL       0x0000026C		// 驾驶员异常报警事件(对应 DEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO)
#define EVENT_IVS_TRAFFIC_DRIVER_CHANGE         0x0000026D		// 驾驶员变更报警事件(对应 DEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO)
#define EVENT_IVS_WORKCLOTHES_DETECT			0x0000026E		// 工装(安全帽/工作服等)检测事件(对应 DEV_EVENT_WORKCLOTHES_DETECT_INFO)
#define EVENT_IVS_SECURITYGATE_PERSONALARM      0x0000026F      // 安检门人员报警事件(对应 DEV_EVENT_SECURITYGATE_PERSONALARM_INFO)
#define EVENT_IVS_STAY_ALONE_DETECTION          0x00000270		// 单人独处事件(对应 DEV_EVENT_STAY_ALONE_DETECTION_INFO)
#define EVENT_IVS_TRAFFIC_ROAD_BLOCK            0x00000271		// 交通路障检测事件(对应 DEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO)
#define EVENT_IVS_TRAFFIC_ROAD_CONSTRUCTION     0x00000272		// 交通道路施工检测事件(对应 DEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO)
#define EVENT_IVS_XRAY_DETECT_BYOBJECT			0x00000273		// X光按物体检测规则配置, 对应事件 EVENI_IVS_XRAY_DETECTION
#define EVENT_IVS_WORKSTATDETECTION				0x00000274		// 作业统计事件(对应 DEV_EVENT_WORKSTATDETECTION_INFO)
#define EVENT_IVS_INFRAREDBLOCK                 0x00000275        // 红外阻断事件(对应 DEV_EVENT_INFRAREDBLOCK_INFO)
#define EVENT_IVS_FEATURE_ABSTRACT				0x00000276		// 特征提取事件(对应 DEV_EVENT_FEATURE_ABSTRACT_INFO)
#define EVENT_IVS_INTELLI_SHELF				    0x00000277		// 智能补货事件(对应 DEV_EVENT_INTELLI_SHELF_INFO)
#define EVENT_IVS_PANORAMA_SHOT					0x00000278		// 全景抓拍事件(对应 DEV_EVENT_PANORAMA_SHOT_INFO)
#define EVENT_ALARM_SMARTMOTION_HUMAN           0x00000279      // 智能视频移动侦测事件(人)，目前只用于订阅手机推送, 无具体事件
#define EVENT_ALARM_SMARTMOTION_VEHICLE         0x0000027A      // 智能视频移动侦测事件(车),目前只用于订阅手机推送, 无具体事件
#define EVENT_IVS_CAR_DRIVING_IN_OUT			0x0000027B		// 车辆驶入驶出状态事件(对应 DEV_EVENT_CAR_DRIVING_IN_OUT_INFO)
#define EVENT_IVS_PARKINGSPACE_STATUS			0x0000027C		// 停车位状态事件(对应 DEV_EVENT_PARKINGSPACE_STATUS_INFO)
#define EVENT_IVS_VIOLENT_THROW_DETECTION		0x0000027D		// 暴力抛物检测(对应 DEV_EVENT_VIOLENT_THROW_DETECTION_INFO)
#define EVENT_IVS_TRAMCARSECTIONS_DETECTION		0x0000027E		// 矿车超挂报警事件(对应 DEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO)
#define EVENT_IVS_ALARM_BOX_ALARM               0x0000027F      // 报警盒通道的触发报警事件, 目前只用于订阅手机推送
#define EVENT_IVS_FACE_COMPARISION              0x00000280      // 人脸比对事件, 专用于手机推送的人脸识别事件, 目前只用于订阅手机推送
#define EVENT_IVS_FACEBODY_DETECT				0x00000281		// 人像检测事件（对应 DEV_EVENT_FACEBODY_DETECT_INFO）
#define EVENT_IVS_FACEBODY_ANALYSE				0x00000282		// 人像识别事件（对应 DEV_EVENT_FACEBODY_ANALYSE_INFO）
#define EVENT_IVS_GASSTATION_VEHICLE_DETECT     0x00000283      // 加油站车辆检测事件 (对应 DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO)
#define EVENT_IVS_CONGESTION_DETECTION			0x00000284		// 道路场景车辆拥堵报警事件（对应 DEV_EVENT_CONGESTION_DETECTION_INFO）
#define EVENT_IVS_VEHICLELIMIT_DETECTION		0x00000285		// 停车场场景下停车车辆上限报警（对应 DEV_EVENT_VEHICLELIMIT_DETECTION_INFO）
#define EVENT_IVS_ANIMAL_DETECTION              0x00000286      // 动物检测事件,(对应 DEV_EVENT_ANIMAL_DETECTION_INFO) 
#define EVENT_IVS_SHOP_WINDOW_POST              0x00000287      // 橱窗张贴事件 (对应 DEV_EVENT_SHOP_WINDOW_POST_INFO)
#define EVENT_IVS_SHOP_SIGN_ABNORMAL            0x00000288      // 店招异常事件 (对应 DEV_EVENT_SHOP_SIGN_ABNORMAL_INFO)
#define EVENT_IVS_BREED_DETECTION               0x00000289      // 智慧养殖检测事件 (对应 DEV_EVENT_BREED_DETECTION_INFO)
#define EVENT_IVS_AIRPORT_VEHICLE_DETECT		0x0000028A		// 机场智能保障车辆检测事件 (对应 DEV_EVENT_AIRPORT_VEHICLE_DETECT_INFO)
#define EVENT_IVS_PIG_TEMPERATURE_DETECT        0x0000028B      // 智慧养殖猪体温检测 (只用于规则配置)

#define EVENT_IVS_MAN_CAR_COEXISTANCE           0x0000028C      // 人车共存事件 (对应 DEV_EVENT_MAN_CAR_COEXISTANCE_INFO)
#define EVENT_IVS_HIGH_TOSS_DETECT              0x0000028D      // 高空抛物检测(对应DEV_EVENT_HIGH_TOSS_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_GLOVE_DETECT         0x0000028E      // 电力检测手套检测事件(对应DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_LADDER_DETECT        0x0000028F      // 电力检测梯子检测事件(对应DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_CURTAIN_DETECT       0x00000290      // 电力检测布幔检测事件(对应DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_FENCE_DETECT         0x00000291      // 电力检测围栏检测事件(对应DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT     0x00000292      // 电力检测标识牌检测事件(对应DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO)
#define EVENT_IVS_ELECTRIC_BELT_DETECT          0x00000293      // 电力检测安全带检测事件(对应DEV_EVENT_ELECTRIC_BELT_DETECT_INFO)
#define EVENT_IVS_RADAR_LINE_DETECTION          0x00000294      // 雷达警戒线/绊线检测(对应DEV_EVENT_RADAR_LINE_DETECTION_INFO)
#define EVENT_IVS_RADAR_REGION_DETECTION        0x00000295      // 雷达警戒区检测事件(对应 DEV_EVENT_RADAR_REGION_DETECTION_INFO)
#define EVENT_IVS_AUDIO_INTENSITY				0x00000296		// 异常音事件(对应 DEV_EVENT_AUDIO_INTENSITY_INFO)
#define EVENT_IVS_PARKING_LOT_STATUS_DETECTION  0x00000297      // 室外停车位状态检测 (对应 DEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO)
#define EVENT_IVS_VEHICLE_COMPARE               0x00000298      // (只用于规则配置)
#define EVENT_IVS_DREGS_UNCOVERED               0x00000299      // 渣土车未遮盖载货检测事件(对应 DEV_EVENT_DREGS_UNCOVERED_INFO)
#define EVENT_IVS_WALK_DETECTION                0x0000029A      // 走动检测事件(对应 DEV_EVENT_WALK_DETECTION_INFO)
#define EVENT_IVS_BACK_TO_DETECTION             0x0000029B      // 背对检测事件(对应 DEV_EVENT_BACK_TO_DETECTION_INFO)
#define EVENT_IVS_WRITE_ON_THE_BOARD_DETECTION  0x0000029C      // 板书检测事件(对应 DEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO)
#define EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION	0x0000029D	// 智慧厨房穿着检测事件（对不戴口罩、厨师帽以及颜色不符合规定的厨师服进行报警）（对应 DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO ）


//设备存储点类型,设备的盘组概念
#define STOR_POINT_READ_WRITE                   0x00001001      // 读写组,原型为"ReadWrite*","ReadWrite*",代表读写组, 中间的"*"可以为空,可以为一个数字
#define STOR_POINT_READ_ONLY                    0x00001002      // 只读组
#define STOR_POINT_REDUNDANT                    0x00001003      // 冗余组,和"ReadWirte"组一个冗余副本
#define STOR_POINT_BACKUP                       0x00001004      // 备份组,数据写满后停止,不会循环覆盖
#define STOR_POINT_DRAW_FRAME                   0x00001005      // 历史抽帧组,实时录像在指定时间后,抽帧并写入该组
#define STOR_POINT_NAS_FTP                      0x00001006      // 远程网络存储组(协议类型FTP),可能会有多个
#define STOR_POINT_NAS_NFS                      0x00001007      // 远程网络存储组(协议类型NFS),可能会有多个
#define STOR_POINT_NAS_SMB                      0x00001008      // 远程网络存储组(协议类型SMB),可能会有多个
#define STOR_POINT_NAS_ISCSI                    0x00001009      // 远程网络存储组(协议类型ISCSI),可能会有多个
#define STOR_POINT_NAS_CLOUD                    0x0000100A      // 远程网络存储组(协议类型Cloud),可能会有多个

//流量统计事件使用宏
#define FLOWSTAT_ADDR_NAME                      16                //上下行地点名长

//针对接口CLIENT_OperateTrafficList各类字符串长度定义
#define DH_TARFFIC_NAME_LEN                     16                
#define DH_CREATE_TIME_LEN                      32
#define DH_AUTHORITY_NUM                        16

// 错误类型代号,对应CLIENT_GetLastError接口的返回值
#define _EC(x)                                  (0x80000000|x)
#define NET_NOERROR                             0                 // 没有错误
#define NET_ERROR                               -1                // 未知错误
#define NET_SYSTEM_ERROR                        _EC(1)            // 系统出错
#define NET_NETWORK_ERROR                       _EC(2)            // 网络错误,可能是因为网络超时
#define NET_DEV_VER_NOMATCH                     _EC(3)            // 设备协议不匹配
#define NET_INVALID_HANDLE                      _EC(4)            // 句柄无效
#define NET_OPEN_CHANNEL_ERROR                  _EC(5)            // 打开通道失败
#define NET_CLOSE_CHANNEL_ERROR                 _EC(6)            // 关闭通道失败
#define NET_ILLEGAL_PARAM                       _EC(7)            // 用户参数不合法
#define NET_SDK_INIT_ERROR                      _EC(8)            // SDK初始化出错
#define NET_SDK_UNINIT_ERROR                    _EC(9)            // SDK清理出错
#define NET_RENDER_OPEN_ERROR                   _EC(10)           // 申请render资源出错
#define NET_DEC_OPEN_ERROR                      _EC(11)           // 打开解码库出错
#define NET_DEC_CLOSE_ERROR                     _EC(12)           // 关闭解码库出错
#define NET_MULTIPLAY_NOCHANNEL                 _EC(13)           // 多画面预览中检测到通道数为0
#define NET_TALK_INIT_ERROR                     _EC(14)           // 录音库初始化失败
#define NET_TALK_NOT_INIT                       _EC(15)           // 录音库未经初始化
#define NET_TALK_SENDDATA_ERROR                 _EC(16)           // 发送音频数据出错
#define NET_REAL_ALREADY_SAVING                 _EC(17)           // 实时数据已经处于保存状态
#define NET_NOT_SAVING                          _EC(18)           // 未保存实时数据
#define NET_OPEN_FILE_ERROR                     _EC(19)           // 打开文件出错
#define NET_PTZ_SET_TIMER_ERROR                 _EC(20)           // 启动云台控制定时器失败
#define NET_RETURN_DATA_ERROR                   _EC(21)           // 对返回数据的校验出错
#define NET_INSUFFICIENT_BUFFER                 _EC(22)           // 没有足够的缓存
#define NET_NOT_SUPPORTED                       _EC(23)           // 当前SDK未支持该功能
#define NET_NO_RECORD_FOUND                     _EC(24)           // 查询不到录象
#define NET_NOT_AUTHORIZED                      _EC(25)           // 无操作权限
#define NET_NOT_NOW                             _EC(26)           // 暂时无法执行
#define NET_NO_TALK_CHANNEL                     _EC(27)           // 未发现对讲通道
#define NET_NO_AUDIO                            _EC(28)           // 未发现音频
#define NET_NO_INIT                             _EC(29)           // 网络SDK未经初始化
#define NET_DOWNLOAD_END                        _EC(30)           // 下载已结束
#define NET_EMPTY_LIST                          _EC(31)           // 查询结果为空
#define NET_ERROR_GETCFG_SYSATTR                _EC(32)           // 获取系统属性配置失败
#define NET_ERROR_GETCFG_SERIAL                 _EC(33)           // 获取序列号失败
#define NET_ERROR_GETCFG_GENERAL                _EC(34)           // 获取常规属性失败
#define NET_ERROR_GETCFG_DSPCAP                 _EC(35)           // 获取DSP能力描述失败
#define NET_ERROR_GETCFG_NETCFG                 _EC(36)           // 获取网络配置失败
#define NET_ERROR_GETCFG_CHANNAME               _EC(37)           // 获取通道名称失败
#define NET_ERROR_GETCFG_VIDEO                  _EC(38)           // 获取视频属性失败
#define NET_ERROR_GETCFG_RECORD                 _EC(39)           // 获取录象配置失败
#define NET_ERROR_GETCFG_PRONAME                _EC(40)           // 获取解码器协议名称失败
#define NET_ERROR_GETCFG_FUNCNAME               _EC(41)           // 获取232串口功能名称失败
#define NET_ERROR_GETCFG_485DECODER             _EC(42)           // 获取解码器属性失败
#define NET_ERROR_GETCFG_232COM                 _EC(43)           // 获取232串口配置失败
#define NET_ERROR_GETCFG_ALARMIN                _EC(44)           // 获取外部报警输入配置失败
#define NET_ERROR_GETCFG_ALARMDET               _EC(45)           // 获取动态检测报警失败
#define NET_ERROR_GETCFG_SYSTIME                _EC(46)           // 获取设备时间失败
#define NET_ERROR_GETCFG_PREVIEW                _EC(47)           // 获取预览参数失败
#define NET_ERROR_GETCFG_AUTOMT                 _EC(48)           // 获取自动维护配置失败
#define NET_ERROR_GETCFG_VIDEOMTRX              _EC(49)           // 获取视频矩阵配置失败
#define NET_ERROR_GETCFG_COVER                  _EC(50)           // 获取区域遮挡配置失败
#define NET_ERROR_GETCFG_WATERMAKE              _EC(51)           // 获取图象水印配置失败
#define NET_ERROR_GETCFG_MULTICAST              _EC(52)           // 获取配置失败位置：组播端口按通道配置
#define NET_ERROR_SETCFG_GENERAL                _EC(55)           // 修改常规属性失败
#define NET_ERROR_SETCFG_NETCFG                 _EC(56)           // 修改网络配置失败
#define NET_ERROR_SETCFG_CHANNAME               _EC(57)           // 修改通道名称失败
#define NET_ERROR_SETCFG_VIDEO                  _EC(58)           // 修改视频属性失败
#define NET_ERROR_SETCFG_RECORD                 _EC(59)           // 修改录象配置失败
#define NET_ERROR_SETCFG_485DECODER             _EC(60)           // 修改解码器属性失败
#define NET_ERROR_SETCFG_232COM                 _EC(61)           // 修改232串口配置失败
#define NET_ERROR_SETCFG_ALARMIN                _EC(62)           // 修改外部输入报警配置失败
#define NET_ERROR_SETCFG_ALARMDET               _EC(63)           // 修改动态检测报警配置失败
#define NET_ERROR_SETCFG_SYSTIME                _EC(64)           // 修改设备时间失败
#define NET_ERROR_SETCFG_PREVIEW                _EC(65)           // 修改预览参数失败
#define NET_ERROR_SETCFG_AUTOMT                 _EC(66)           // 修改自动维护配置失败
#define NET_ERROR_SETCFG_VIDEOMTRX              _EC(67)           // 修改视频矩阵配置失败
#define NET_ERROR_SETCFG_COVER                  _EC(68)           // 修改区域遮挡配置失败
#define NET_ERROR_SETCFG_WATERMAKE              _EC(69)           // 修改图象水印配置失败
#define NET_ERROR_SETCFG_WLAN                   _EC(70)           // 修改无线网络信息失败
#define NET_ERROR_SETCFG_WLANDEV                _EC(71)           // 选择无线网络设备失败
#define NET_ERROR_SETCFG_REGISTER               _EC(72)           // 修改主动注册参数配置失败
#define NET_ERROR_SETCFG_CAMERA                 _EC(73)           // 修改摄像头属性配置失败
#define NET_ERROR_SETCFG_INFRARED               _EC(74)           // 修改红外报警配置失败
#define NET_ERROR_SETCFG_SOUNDALARM             _EC(75)           // 修改音频报警配置失败
#define NET_ERROR_SETCFG_STORAGE                _EC(76)           // 修改存储位置配置失败
#define NET_AUDIOENCODE_NOTINIT                 _EC(77)           // 音频编码接口没有成功初始化
#define NET_DATA_TOOLONGH                       _EC(78)           // 数据过长
#define NET_UNSUPPORTED                         _EC(79)           // 设备不支持该操作
#define NET_DEVICE_BUSY                         _EC(80)           // 设备资源不足
#define NET_SERVER_STARTED                      _EC(81)           // 服务器已经启动
#define NET_SERVER_STOPPED                      _EC(82)           // 服务器尚未成功启动
#define NET_LISTER_INCORRECT_SERIAL             _EC(83)           // 输入序列号有误
#define NET_QUERY_DISKINFO_FAILED               _EC(84)           // 获取硬盘信息失败
#define NET_ERROR_GETCFG_SESSION                _EC(85)           // 获取连接Session信息
#define NET_USER_FLASEPWD_TRYTIME               _EC(86)           // 输入密码错误超过限制次数
#define NET_LOGIN_ERROR_PASSWORD                _EC(100)          // 密码不正确
#define NET_LOGIN_ERROR_USER                    _EC(101)          // 帐户不存在
#define NET_LOGIN_ERROR_TIMEOUT                 _EC(102)          // 等待登录返回超时
#define NET_LOGIN_ERROR_RELOGGIN                _EC(103)          // 帐号已登录
#define NET_LOGIN_ERROR_LOCKED                  _EC(104)          // 帐号已被锁定
#define NET_LOGIN_ERROR_BLACKLIST               _EC(105)          // 帐号已被列为黑名单
#define NET_LOGIN_ERROR_BUSY                    _EC(106)          // 资源不足,系统忙
#define NET_LOGIN_ERROR_CONNECT                 _EC(107)          // 登录设备超时,请检查网络并重试
#define NET_LOGIN_ERROR_NETWORK                 _EC(108)          // 网络连接失败
#define NET_LOGIN_ERROR_SUBCONNECT              _EC(109)          // 登录设备成功,但无法创建视频通道,请检查网络状况
#define NET_LOGIN_ERROR_MAXCONNECT              _EC(110)          // 超过最大连接数
#define NET_LOGIN_ERROR_PROTOCOL3_ONLY          _EC(111)          // 只支持3代协议
#define NET_LOGIN_ERROR_UKEY_LOST               _EC(112)          // 未插入U盾或U盾信息错误
#define NET_LOGIN_ERROR_NO_AUTHORIZED           _EC(113)          // 客户端IP地址没有登录权限
#define NET_LOGIN_ERROR_USER_OR_PASSOWRD        _EC(117)          // 账号或密码错误
#define NET_LOGIN_ERROR_DEVICE_NOT_INIT			_EC(118)          // 设备尚未初始化，不能登录，请先初始化设备
#define NET_LOGIN_ERROR_LIMITED					_EC(119)          // 登录受限,可能是IP受限、时间段受限、有效期受限
#define NET_RENDER_SOUND_ON_ERROR               _EC(120)          // Render库打开音频出错
#define NET_RENDER_SOUND_OFF_ERROR              _EC(121)          // Render库关闭音频出错
#define NET_RENDER_SET_VOLUME_ERROR             _EC(122)          // Render库控制音量出错
#define NET_RENDER_ADJUST_ERROR                 _EC(123)          // Render库设置画面参数出错
#define NET_RENDER_PAUSE_ERROR                  _EC(124)          // Render库暂停播放出错
#define NET_RENDER_SNAP_ERROR                   _EC(125)          // Render库抓图出错
#define NET_RENDER_STEP_ERROR                   _EC(126)          // Render库步进出错
#define NET_RENDER_FRAMERATE_ERROR              _EC(127)          // Render库设置帧率出错
#define NET_RENDER_DISPLAYREGION_ERROR          _EC(128)          // Render库设置显示区域出错
#define NET_RENDER_GETOSDTIME_ERROR             _EC(129)          // Render库获取当前播放时间出错
#define NET_GROUP_EXIST                         _EC(140)          // 组名已存在
#define NET_GROUP_NOEXIST                       _EC(141)          // 组名不存在
#define NET_GROUP_RIGHTOVER                     _EC(142)          // 组的权限超出权限列表范围
#define NET_GROUP_HAVEUSER                      _EC(143)          // 组下有用户,不能删除
#define NET_GROUP_RIGHTUSE                      _EC(144)          // 组的某个权限被用户使用,不能出除
#define NET_GROUP_SAMENAME                      _EC(145)          // 新组名同已有组名重复
#define NET_USER_EXIST                          _EC(146)          // 用户已存在
#define NET_USER_NOEXIST                        _EC(147)          // 用户不存在
#define NET_USER_RIGHTOVER                      _EC(148)          // 用户权限超出组权限
#define NET_USER_PWD                            _EC(149)          // 保留帐号,不容许修改密码
#define NET_USER_FLASEPWD                       _EC(150)          // 密码不正确
#define NET_USER_NOMATCHING                     _EC(151)          // 密码不匹配
#define NET_USER_INUSE                          _EC(152)          // 账号正在使用中
#define NET_ERROR_GETCFG_ETHERNET               _EC(300)          // 获取网卡配置失败
#define NET_ERROR_GETCFG_WLAN                   _EC(301)          // 获取无线网络信息失败
#define NET_ERROR_GETCFG_WLANDEV                _EC(302)          // 获取无线网络设备失败
#define NET_ERROR_GETCFG_REGISTER               _EC(303)          // 获取主动注册参数失败
#define NET_ERROR_GETCFG_CAMERA                 _EC(304)          // 获取摄像头属性失败
#define NET_ERROR_GETCFG_INFRARED               _EC(305)          // 获取红外报警配置失败
#define NET_ERROR_GETCFG_SOUNDALARM             _EC(306)          // 获取音频报警配置失败
#define NET_ERROR_GETCFG_STORAGE                _EC(307)          // 获取存储位置配置失败
#define NET_ERROR_GETCFG_MAIL                   _EC(308)          // 获取邮件配置失败
#define NET_CONFIG_DEVBUSY                      _EC(309)          // 暂时无法设置
#define NET_CONFIG_DATAILLEGAL                  _EC(310)          // 配置数据不合法
#define NET_ERROR_GETCFG_DST                    _EC(311)          // 获取夏令时配置失败
#define NET_ERROR_SETCFG_DST                    _EC(312)          // 设置夏令时配置失败
#define NET_ERROR_GETCFG_VIDEO_OSD              _EC(313)          // 获取视频OSD叠加配置失败
#define NET_ERROR_SETCFG_VIDEO_OSD              _EC(314)          // 设置视频OSD叠加配置失败
#define NET_ERROR_GETCFG_GPRSCDMA               _EC(315)          // 获取CDMA\GPRS网络配置失败
#define NET_ERROR_SETCFG_GPRSCDMA               _EC(316)          // 设置CDMA\GPRS网络配置失败
#define NET_ERROR_GETCFG_IPFILTER               _EC(317)          // 获取IP过滤配置失败
#define NET_ERROR_SETCFG_IPFILTER               _EC(318)          // 设置IP过滤配置失败
#define NET_ERROR_GETCFG_TALKENCODE             _EC(319)          // 获取语音对讲编码配置失败
#define NET_ERROR_SETCFG_TALKENCODE             _EC(320)          // 设置语音对讲编码配置失败
#define NET_ERROR_GETCFG_RECORDLEN              _EC(321)          // 获取录像打包长度配置失败
#define NET_ERROR_SETCFG_RECORDLEN              _EC(322)          // 设置录像打包长度配置失败
#define NET_DONT_SUPPORT_SUBAREA                _EC(323)          // 不支持网络硬盘分区
#define NET_ERROR_GET_AUTOREGSERVER             _EC(324)          // 获取设备上主动注册服务器信息失败
#define NET_ERROR_CONTROL_AUTOREGISTER          _EC(325)          // 主动注册重定向注册错误
#define NET_ERROR_DISCONNECT_AUTOREGISTER       _EC(326)          // 断开主动注册服务器错误
#define NET_ERROR_GETCFG_MMS                    _EC(327)          // 获取mms配置失败
#define NET_ERROR_SETCFG_MMS                    _EC(328)          // 设置mms配置失败
#define NET_ERROR_GETCFG_SMSACTIVATION          _EC(329)          // 获取短信激活无线连接配置失败
#define NET_ERROR_SETCFG_SMSACTIVATION          _EC(330)          // 设置短信激活无线连接配置失败
#define NET_ERROR_GETCFG_DIALINACTIVATION       _EC(331)          // 获取拨号激活无线连接配置失败
#define NET_ERROR_SETCFG_DIALINACTIVATION       _EC(332)          // 设置拨号激活无线连接配置失败
#define NET_ERROR_GETCFG_VIDEOOUT               _EC(333)          // 查询视频输出参数配置失败
#define NET_ERROR_SETCFG_VIDEOOUT               _EC(334)          // 设置视频输出参数配置失败
#define NET_ERROR_GETCFG_OSDENABLE              _EC(335)          // 获取osd叠加使能配置失败
#define NET_ERROR_SETCFG_OSDENABLE              _EC(336)          // 设置osd叠加使能配置失败
#define NET_ERROR_SETCFG_ENCODERINFO            _EC(337)          // 设置数字通道前端编码接入配置失败
#define NET_ERROR_GETCFG_TVADJUST               _EC(338)          // 获取TV调节配置失败
#define NET_ERROR_SETCFG_TVADJUST               _EC(339)          // 设置TV调节配置失败
#define NET_ERROR_CONNECT_FAILED                _EC(340)          // 请求建立连接失败
#define NET_ERROR_SETCFG_BURNFILE               _EC(341)          // 请求刻录文件上传失败
#define NET_ERROR_SNIFFER_GETCFG                _EC(342)          // 获取抓包配置信息失败
#define NET_ERROR_SNIFFER_SETCFG                _EC(343)          // 设置抓包配置信息失败
#define NET_ERROR_DOWNLOADRATE_GETCFG           _EC(344)          // 查询下载限制信息失败
#define NET_ERROR_DOWNLOADRATE_SETCFG           _EC(345)          // 设置下载限制信息失败
#define NET_ERROR_SEARCH_TRANSCOM               _EC(346)          // 查询串口参数失败
#define NET_ERROR_GETCFG_POINT                  _EC(347)          // 获取预制点信息错误
#define NET_ERROR_SETCFG_POINT                  _EC(348)          // 设置预制点信息错误
#define NET_SDK_LOGOUT_ERROR                    _EC(349)          // SDK没有正常登出设备
#define NET_ERROR_GET_VEHICLE_CFG               _EC(350)          // 获取车载配置失败
#define NET_ERROR_SET_VEHICLE_CFG               _EC(351)          // 设置车载配置失败
#define NET_ERROR_GET_ATM_OVERLAY_CFG           _EC(352)          // 获取atm叠加配置失败
#define NET_ERROR_SET_ATM_OVERLAY_CFG           _EC(353)          // 设置atm叠加配置失败
#define NET_ERROR_GET_ATM_OVERLAY_ABILITY       _EC(354)          // 获取atm叠加能力失败
#define NET_ERROR_GET_DECODER_TOUR_CFG          _EC(355)          // 获取解码器解码轮巡配置失败
#define NET_ERROR_SET_DECODER_TOUR_CFG          _EC(356)          // 设置解码器解码轮巡配置失败
#define NET_ERROR_CTRL_DECODER_TOUR             _EC(357)          // 控制解码器解码轮巡失败
#define NET_GROUP_OVERSUPPORTNUM                _EC(358)          // 超出设备支持最大用户组数目
#define NET_USER_OVERSUPPORTNUM                 _EC(359)          // 超出设备支持最大用户数目
#define NET_ERROR_GET_SIP_CFG                   _EC(368)          // 获取SIP配置失败
#define NET_ERROR_SET_SIP_CFG                   _EC(369)          // 设置SIP配置失败
#define NET_ERROR_GET_SIP_ABILITY               _EC(370)          // 获取SIP能力失败
#define NET_ERROR_GET_WIFI_AP_CFG               _EC(371)          // 获取WIFI ap配置失败
#define NET_ERROR_SET_WIFI_AP_CFG               _EC(372)          // 设置WIFI ap配置失败
#define NET_ERROR_GET_DECODE_POLICY             _EC(373)          // 获取解码策略配置失败
#define NET_ERROR_SET_DECODE_POLICY             _EC(374)          // 设置解码策略配置失败
#define NET_ERROR_TALK_REJECT                   _EC(375)          // 拒绝对讲
#define NET_ERROR_TALK_OPENED                   _EC(376)          // 对讲被其他客户端打开
#define NET_ERROR_TALK_RESOURCE_CONFLICIT       _EC(377)          // 资源冲突
#define NET_ERROR_TALK_UNSUPPORTED_ENCODE       _EC(378)          // 不支持的语音编码格式
#define NET_ERROR_TALK_RIGHTLESS                _EC(379)          // 无权限
#define NET_ERROR_TALK_FAILED                   _EC(380)          // 请求对讲失败
#define NET_ERROR_GET_MACHINE_CFG               _EC(381)          // 获取机器相关配置失败
#define NET_ERROR_SET_MACHINE_CFG               _EC(382)          // 设置机器相关配置失败
#define NET_ERROR_GET_DATA_FAILED               _EC(383)          // 设备无法获取当前请求数据
#define NET_ERROR_MAC_VALIDATE_FAILED           _EC(384)          // MAC地址验证失败 
#define NET_ERROR_GET_INSTANCE                  _EC(385)          // 获取服务器实例失败
#define NET_ERROR_JSON_REQUEST                  _EC(386)          // 生成的json字符串错误
#define NET_ERROR_JSON_RESPONSE                 _EC(387)          // 响应的json字符串错误
#define NET_ERROR_VERSION_HIGHER                _EC(388)          // 协议版本低于当前使用的版本
#define NET_SPARE_NO_CAPACITY                   _EC(389)          // 热备操作失败, 容量不足
#define NET_ERROR_SOURCE_IN_USE                 _EC(390)          // 显示源被其他输出占用
#define NET_ERROR_REAVE                         _EC(391)          // 高级用户抢占低级用户资源
#define NET_ERROR_NETFORBID                     _EC(392)          // 禁止入网 
#define NET_ERROR_GETCFG_MACFILTER              _EC(393)          // 获取MAC过滤配置失败
#define NET_ERROR_SETCFG_MACFILTER              _EC(394)          // 设置MAC过滤配置失败
#define NET_ERROR_GETCFG_IPMACFILTER            _EC(395)          // 获取IP/MAC过滤配置失败
#define NET_ERROR_SETCFG_IPMACFILTER            _EC(396)          // 设置IP/MAC过滤配置失败
#define NET_ERROR_OPERATION_OVERTIME            _EC(397)          // 当前操作超时 
#define NET_ERROR_SENIOR_VALIDATE_FAILED        _EC(398)          // 高级校验失败 
#define NET_ERROR_DEVICE_ID_NOT_EXIST           _EC(399)          // 设备ID不存在
#define NET_ERROR_UNSUPPORTED                   _EC(400)          // 不支持当前操作
#define NET_ERROR_PROXY_DLLLOAD                 _EC(401)          // 代理库加载失败
#define NET_ERROR_PROXY_ILLEGAL_PARAM           _EC(402)          // 代理用户参数不合法
#define NET_ERROR_PROXY_INVALID_HANDLE          _EC(403)          // 代理句柄无效
#define NET_ERROR_PROXY_LOGIN_DEVICE_ERROR      _EC(404)          // 代理登入前端设备失败
#define NET_ERROR_PROXY_START_SERVER_ERROR      _EC(405)          // 启动代理服务失败
#define NET_ERROR_SPEAK_FAILED                  _EC(406)          // 请求喊话失败
#define NET_ERROR_NOT_SUPPORT_F6                _EC(407)          // 设备不支持此F6接口调用
#define NET_ERROR_CD_UNREADY                    _EC(408)          // 光盘未就绪
#define NET_ERROR_DIR_NOT_EXIST                 _EC(409)          // 目录不存在
#define NET_ERROR_UNSUPPORTED_SPLIT_MODE        _EC(410)          // 设备不支持的分割模式
#define NET_ERROR_OPEN_WND_PARAM                _EC(411)          // 开窗参数不合法
#define NET_ERROR_LIMITED_WND_COUNT             _EC(412)          // 开窗数量超过限制
#define NET_ERROR_UNMATCHED_REQUEST             _EC(413)          // 请求命令与当前模式不匹配
#define NET_RENDER_ENABLELARGEPICADJUSTMENT_ERROR   _EC(414)      // Render库启用高清图像内部调整策略出错
#define NET_ERROR_UPGRADE_FAILED                _EC(415)          // 设备升级失败
#define NET_ERROR_NO_TARGET_DEVICE              _EC(416)          // 找不到目标设备
#define NET_ERROR_NO_VERIFY_DEVICE              _EC(417)          // 找不到验证设备
#define NET_ERROR_CASCADE_RIGHTLESS             _EC(418)          // 无级联权限
#define NET_ERROR_LOW_PRIORITY                  _EC(419)          // 低优先级
#define NET_ERROR_REMOTE_REQUEST_TIMEOUT        _EC(420)          // 远程设备请求超时
#define NET_ERROR_LIMITED_INPUT_SOURCE          _EC(421)          // 输入源超出最大路数限制
#define NET_ERROR_SET_LOG_PRINT_INFO            _EC(422)          // 设置日志打印失败
#define NET_ERROR_PARAM_DWSIZE_ERROR            _EC(423)          // 入参的dwsize字段出错
#define NET_ERROR_LIMITED_MONITORWALL_COUNT     _EC(424)          // 电视墙数量超过上限
#define NET_ERROR_PART_PROCESS_FAILED           _EC(425)          // 部分过程执行失败
#define NET_ERROR_TARGET_NOT_SUPPORT            _EC(426)          // 该功能不支持转发
#define NET_ERROR_VISITE_FILE                   _EC(510)          // 访问文件失败
#define NET_ERROR_DEVICE_STATUS_BUSY            _EC(511)          // 设备忙
#define NET_USER_PWD_NOT_AUTHORIZED             _EC(512)          // 修改密码无权限
#define NET_USER_PWD_NOT_STRONG                 _EC(513)          // 密码强度不够
#define NET_ERROR_NO_SUCH_CONFIG                _EC(514)          // 没有对应的配置
#define NET_ERROR_AUDIO_RECORD_FAILED           _EC(515)          // 录音失败
#define NET_ERROR_SEND_DATA_FAILED              _EC(516)          // 数据发送失败
#define NET_ERROR_OBSOLESCENT_INTERFACE         _EC(517)          // 废弃接口
#define NET_ERROR_INSUFFICIENT_INTERAL_BUF      _EC(518)          // 内部缓冲不足
#define NET_ERROR_NEED_ENCRYPTION_PASSWORD      _EC(519)          // 修改设备ip时,需要校验密码
#define NET_ERROR_NOSUPPORT_RECORD              _EC(520)          // 设备不支持此记录集
#define NET_ERROR_SERIALIZE_ERROR               _EC(1010)         // 数据序列化错误
#define NET_ERROR_DESERIALIZE_ERROR             _EC(1011)         // 数据反序列化错误
#define NET_ERROR_LOWRATEWPAN_ID_EXISTED        _EC(1012)         // 该无线ID已存在
#define NET_ERROR_LOWRATEWPAN_ID_LIMIT          _EC(1013)         // 无线ID数量已超限
#define NET_ERROR_LOWRATEWPAN_ID_ABNORMAL       _EC(1014)         // 无线异常添加
#define NET_ERROR_ENCRYPT                       _EC(1015)         // 加密数据失败
#define NET_ERROR_PWD_ILLEGAL                   _EC(1016)         // 新密码不合规范
#define NET_ERROR_DEVICE_ALREADY_INIT           _EC(1017)         // 设备已经初始化
#define NET_ERROR_SECURITY_CODE                 _EC(1018)         // 安全码错误
#define NET_ERROR_SECURITY_CODE_TIMEOUT         _EC(1019)         // 安全码超出有效期
#define NET_ERROR_GET_PWD_SPECI                 _EC(1020)         // 获取密码规范失败
#define NET_ERROR_NO_AUTHORITY_OF_OPERATION     _EC(1021)         // 无权限进行该操作
#define NET_ERROR_DECRYPT                       _EC(1022)         // 解密数据失败
#define NET_ERROR_2D_CODE                       _EC(1023)         // 2D code校验失败
#define NET_ERROR_INVALID_REQUEST               _EC(1024)         // 非法的RPC请求
#define	NET_ERROR_PWD_RESET_DISABLE			    _EC(1025)		  // 密码重置功能已关闭
#define NET_ERROR_PLAY_PRIVATE_DATA             _EC(1026)         // 显示私有数据，比如规则框等失败
#define NET_ERROR_ROBOT_OPERATE_FAILED          _EC(1027)         // 机器人操作失败
#define NET_ERROR_PHOTOSIZE_EXCEEDSLIMIT        _EC(1028)         // 图片大小超限
#define NET_ERROR_USERID_INVALID                _EC(1029)         // 用户ID不存在
#define NET_ERROR_EXTRACTFEATURE_FAILED         _EC(1030)         // 照片特征值提取失败
#define NET_ERROR_PHOTO_EXIST                   _EC(1031)         // 照片已存在
#define NET_ERROR_PHOTO_OVERFLOW                _EC(1032)         // 照片数量超过上限
#define NET_ERROR_CHANNEL_ALREADY_OPENED		_EC(1033)		  // 通道已经打开
#define NET_ERROR_CREATE_SOCKET					_EC(1034)		  // 创建套接字失败
#define NET_ERROR_CHANNEL_NUM					_EC(1035)		  // 通道号错误
#define NET_ERROR_PHOTO_FORMAT					_EC(1036)		  // 图片格式错误
#define NET_ERROR_DIGITAL_CERTIFICATE_INTERNAL_ERROR				_EC(1037)		  // 内部错误(比如：相关硬件问题，获取公钥失败，内部接口调用失败，写文件失败等等)
#define NET_ERROR_DIGITAL_CERTIFICATE_GET_ID_FAILED					_EC(1038)		  // 获取设备ID失败
#define NET_ERROR_DIGITAL_CERTIFICATE_IMPORT_ILLEGAL				_EC(1039)		  // 证书文件非法(格式不支持或者不是证书文件)
#define NET_ERROR_DIGITAL_CERTIFICATE_SN_ERROR						_EC(1040)		  // 证书sn重复或错误或不规范
#define NET_ERROR_DIGITAL_CERTIFICATE_COMMON_NAME_ILLEGAL			_EC(1041)		  // 证书commonName非法(本地设备证书与系统中的不匹配devid_cryptoID,或者对端的不符合规则(devid_crytoID))
#define NET_ERROR_DIGITAL_CERTIFICATE_NO_ROOT_CERT					_EC(1042)		  // 根证书未导入或不存在
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_REVOKED					_EC(1043)		  // 证书被吊销
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_INVALID					_EC(1044)		  // 证书不可用或未生效或已过期
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_ERROR_SIGN				_EC(1045)		  // 证书签名不匹配
#define NET_ERROR_DIGITAL_CERTIFICATE_COUNTS_UPPER_LIMIT			_EC(1046)		  // 超出证书导入上限
#define NET_ERROR_DIGITAL_CERTIFICATE_CERT_NO_EXIST					_EC(1047)		  // 证书文件不存在(导出证书或者获取对应证书的公钥)
#define NET_ERROR_DEFULAT_SEARCH_PORT								_EC(1048)		  // 默认搜索端口无法使用（5050,37810）
#define NET_ERROR_FACE_RECOGNITION_SERVER_MULTI_APPEND_STOUP				_EC(1049)			// 批量添加人脸停止
#define	NET_ERROR_FACE_RECOGNITION_SERVER_MULTI_APPEND_ERROR				_EC(1050)			// 批量添加人脸失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_ID_EXCEED					_EC(1051)			// 组ID超过最大值
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_ID_NOT_IN_REGISTER_GROUP	_EC(1052)			// 组ID不存在或为空
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_NOT_FOUND					_EC(1053)			// 无图片数据
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GENERATE_GROUP_ID_FAILED			_EC(1054)			// 生成组ID超出范围
#define	NET_ERROR_FACE_RECOGNITION_SERVER_SET_CONFIG_FAILED					_EC(1055)			// 设置配置失败
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILE_OPEN_FAILED					_EC(1056)			// 图片文件打开失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FILE_READ_FAILED					_EC(1057)			// 图片文件读取失败
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILE_WRITE_FAILED					_EC(1058)			// 图片文件写入失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_DPI_ERROR					_EC(1059)			// 图片分辨率异常
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_PX_ERROR					_EC(1060)			// 图片像素异常
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PICTURE_SIZE_ERROR				_EC(1061)			// 图片大小不对
#define	NET_ERROR_FACE_RECOGNITION_SERVER_DATA_BASE_ERROR					_EC(1062)			// 数据库操作失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FACE_MAX_NUM						_EC(1063)			// 人员数量超过限制
#define	NET_ERROR_FACE_RECOGNITION_SERVER_BIRTH_DAY_FORMAT_ERROR			_EC(1064)			// 生日日期格式错误
#define	NET_ERROR_FACE_RECOGNITION_SERVER_UID_ERROR							_EC(1065)			// 人员UID不存在或为空
#define	NET_ERROR_FACE_RECOGNITION_SERVER_TOKEN_ERROR						_EC(1066)			// 令牌不存在或为空
#define	NET_ERROR_FACE_RECOGNITION_SERVER_BEGIN_NUM_OVER_RUN				_EC(1067)			// 查询起始数大于总数
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_NUM_ZERO					_EC(1068)			// 需手动建模人数为0
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_INIT_ERROR				_EC(1069)			// 建模分析器启动失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_AUTO_ABSTRACT_STATE				_EC(1070)			// 设备正在自动建模
#define	NET_ERROR_FACE_RECOGNITION_SERVER_ABSTRACT_STATE					_EC(1071)			// 设备正在手动建模
#define	NET_ERROR_FACE_RECOGNITION_SERVER_IM_EX_STATE						_EC(1072)			// 设备正在导入导出 
#define	NET_ERROR_FACE_RECOGNITION_SERVER_PIC_WRITE_FAILED					_EC(1073)			// 图片写入失败
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_SPACE_EXCEED				_EC(1074)			// 超出人脸库空间大小限制
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_PIC_COUNT_EXCEED			_EC(1075)			// 超出人脸库图片数量限制
#define	NET_ERROR_FACE_RECOGNITION_SERVER_GROUP_NOT_FOUND					_EC(1076)			// 人脸库不存在
#define	NET_ERROR_FACE_RECOGNITION_SERVER_FIND_RECORDS_ERROR				_EC(1077)			// 查询原人脸库数据结果无效
#define	NET_ERROR_FACE_RECOGNITION_SERVER_DELETE_PERSON_ERROR				_EC(1078)			// 删除原人脸库数据失败
#define NET_ERROR_FACE_RECOGNITION_SERVER_DELETE_GROUP_ERROR                _EC(1079)           // 删除人脸库失败
#define NET_ERROR_FACE_RECOGNITION_SERVER_NAME_FORMAT_ERROR                 _EC(1080)           // 命名格式错误
#define NET_ERROR_FACE_RECOGNITION_SERVER_FILEPATH_NOT_SET                  _EC(1081)           // 图片保存路径未设置

#define NET_ERROR_DEVICE_PARSE_PROTOCOL			_EC(1079)		  // 设备解析协议错误
#define NET_ERROR_DEVICE_INVALID_REQUEST		_EC(1080)		  // 设备返回无效请求
#define NET_ERROR_DEVICE_INTERNAL_ERROR			_EC(1081)		  // 设备内部错误
#define NET_ERROR_DEVICE_REQUEST_TIMEOUT		_EC(1082)		  // 设备内部请求超时
#define NET_ERROR_DEVICE_KEEPALIVE_FAIL			_EC(1083)		  // 设备保活失败
#define NET_ERROR_DEVICE_NETWORK_ERROR			_EC(1084)		  // 设备网络错误
#define NET_ERROR_DEVICE_UNKNOWN_ERROR			_EC(1085)		  // 设备内部未知错误
#define NET_ERROR_DEVICE_COM_INTERFACE_NOTFOUND	_EC(1086)		  // 设备组件接口没有找到
#define NET_ERROR_DEVICE_COM_IMPLEMENT_NOTFOUND	_EC(1087)		  // 设备组件实现没有找到
#define NET_ERROR_DEVICE_COM_NOTFOUND			_EC(1088)		  // 设备接入组件没有找到
#define NET_ERROR_DEVICE_COM_INSTANCE_NOTEXIST	_EC(1089)		  // 设备接入组件实例不存在
#define NET_ERROR_DEVICE_CREATE_COM_FAIL		_EC(1090)		  // 设备组件工厂创建组件失败
#define NET_ERROR_DEVICE_GET_COM_FAIL			_EC(1091)		  // 设备组件工厂获取组件实例失败
#define NET_ERROR_DEVICE_BAD_REQUEST			_EC(1092)		  // 设备业务请求不被接受
#define NET_ERROR_DEVICE_REQUEST_IN_PROGRESS	_EC(1093)		  // 设备已经在处理请求，不接受重复请求
#define NET_ERROR_DEVICE_LIMITED_RESOURCE		_EC(1094)		  // 设备资源不足
#define NET_ERROR_DEVICE_BUSINESS_TIMEOUT		_EC(1095)		  // 设备业务超时
#define NET_ERROR_DEVICE_TOO_MANY_REQUESTS		_EC(1096)		  // 设备接收过多请求
#define NET_ERROR_DEVICE_NOT_ALREADY			_EC(1097)		  // 设备未准备就绪，不接受业务请求
#define NET_ERROR_DEVICE_SEARCHRECORD_TIMEOUT	_EC(1098)		  // 设备录像查询超时
#define NET_ERROR_DEVICE_SEARCHTIME_INVALID		_EC(1099)		  // 设备录像查询时间无效
#define NET_ERROR_DEVICE_SSID_INVALID			_EC(1100)		  // 设备校验SSID无效
#define NET_ERROR_DEVICE_CHANNEL_STREAMTYPE_ERROR		_EC(1101)	// 设备校验通道号或码流类型无效
#define NET_ERROR_DEVICE_STREAM_PACKINGFORMAT_UNSUPPORT	_EC(1102)	// 设备不支持该码流打包格式
#define NET_ERROR_DEVICE_AUDIO_ENCODINGFORMAT_UNSUPPORT	_EC(1103)	// 设备不支持该语音编码格式
#define NET_ERROR_SECURITY_ERROR_SUPPORT_GUI            _EC(1104)	// 校验请求安全码失败,可使用本地GUI方式重置密码
#define NET_ERROR_SECURITY_ERROR_SUPPORT_MULT           _EC(1105)	// 校验请求安全码失败,可使用大华渠道APP、configtool工具重置密码
#define NET_ERROR_SECURITY_ERROR_SUPPORT_UNIQUE         _EC(1106)	// 校验请求安全码失败,可登陆Web页面重置密码
#define NET_ERROR_STREAMCONVERTOR_DEFECT				_EC(1107)	// 转码库缺失



#define NET_ERROR_SECURITY_GENERATE_SAFE_CODE           _EC(1108)   	// 调用大华加密库产生安全码失败
#define NET_ERROR_SECURITY_GET_CONTACT                  _EC(1109)   	// 获取联系方式失败
#define NET_ERROR_SECURITY_GET_QRCODE                   _EC(1110)   	// 获取重置密码的二维码信息失败
#define NET_ERROR_SECURITY_CANNOT_RESET                 _EC(1111)   	// 设备未初始化,无法重置
#define NET_ERROR_SECURITY_NOT_SUPPORT_CONTACT_MODE     _EC(1112)   	// 不支持设置该种联系方式,如只支持设置手机号，却请求设置邮箱
#define NET_ERROR_SECURITY_RESPONSE_TIMEOUT             _EC(1113)   	// 对端响应超时
#define NET_ERROR_SECURITY_AUTHCODE_FORBIDDEN           _EC(1114)   	// 尝试校验AuthCode次数过多，禁止校验
#define NET_ERROR_TRANCODE_LOGIN_REMOTE_DEV				_EC(1115)		// (虚拟转码)登陆远程设备失败
#define	NET_ERROR_TRANCODE_NOFREE_CHANNEL				_EC(1116)		// (虚拟转码)没有可用的通道资源
#define NET_ERROR_VK_INFO_DECRYPT_FAILED				_EC(1117)		// VK信息解密失败
#define NET_ERROR_VK_INFO_DESERIALIZE_FAILED			_EC(1118)		// VK信息解析失败
#define NET_ERROR_GDPR_ABILITY_NOT_ENABLE				_EC(1119)		// SDK GDPR功能未使能

/*门禁快速导入及复核错误码 start*/
#define NET_ERROR_FAST_CHECK_NO_AUTH					_EC(1120)	// 门禁快速复核:无权限
#define NET_ERROR_FAST_CHECK_NO_FILE					_EC(1121)	// 门禁快速复核:文件不存在
#define NET_ERROR_FAST_CHECK_FILE_FAIL					_EC(1122)	// 门禁快速复核:文件准备失败
#define NET_ERROR_FAST_CHECK_BUSY						_EC(1123)	// 门禁快速复核:系统忙
#define NET_ERROR_FAST_CHECK_NO_PASSWORD				_EC(1124)	// 门禁快速复核:未定义密码, 不允许导出
#define NET_ERROR_IMPORT_ACCESS_SEND_FAILD				_EC(1125)	// 门禁快速导入:发送门禁数据失败
#define NET_ERROR_IMPORT_ACCESS_BUSY					_EC(1126)	// 门禁快速导入:系统忙, 已经有导入任务
#define NET_ERROR_IMPORT_ACCESS_DATAERROR				_EC(1127)	// 门禁快速导入:数据包检验失败
#define NET_ERROR_IMPORT_ACCESS_DATAINVALID				_EC(1128)	// 门禁快速导入:数据包非法
#define NET_ERROR_IMPORT_ACCESS_SYNC_FALID				_EC(1129)	// 门禁快速导入:同步失败,数据库无法生成
#define NET_ERROR_IMPORT_ACCESS_DBFULL					_EC(1130)	// 门禁快速导入:数据库已满, 无法导入
#define NET_ERROR_IMPORT_ACCESS_SDFULL					_EC(1131)	// 门禁快速导入:存储空间已满, 无法导入
#define NET_ERROR_IMPORT_ACCESS_CIPHER_ERROR			_EC(1132)	// 门禁快速导入:导入压缩包密码不对
/*门禁快速导入及复核错误码 end*/

#define NET_ERROR_INVALID_PARAM							_EC(1133)	// 参数无效
#define NET_ERROR_INVALID_PASSWORD						_EC(1134)	// 密码无效
#define NET_ERROR_INVALID_FINGERPRINT					_EC(1135)	// 指纹无效
#define NET_ERROR_INVALID_FACE							_EC(1136)	// 人脸无效
#define NET_ERROR_INVALID_CARD							_EC(1137)	// 卡无效
#define NET_ERROR_INVALID_USER							_EC(1138)	// 用户无效
#define NET_ERROR_GET_SUBSERVICE						_EC(1139)	// 能力集子服务获取失败
#define NET_ERROR_GET_METHOD							_EC(1140)   // 获取组件的方法集失败
#define NET_ERROR_GET_SUBCAPS							_EC(1141) 	// 获取资源实体能力集失败
#define NET_ERROR_UPTO_INSERT_LIMIT						_EC(1142)   // 已达插入上限
#define NET_ERROR_UPTO_MAX_INSERT_RATE					_EC(1143)   // 已达最大插入速度
#define NET_ERROR_ERASE_FINGERPRINT						_EC(1144)   // 清除指纹数据失败
#define NET_ERROR_ERASE_FACE							_EC(1145)   // 清除人脸数据失败
#define NET_ERROR_ERASE_CARD							_EC(1146)   // 清除卡数据失败
#define NET_ERROR_NO_RECORD								_EC(1147)   // 没有记录
#define NET_ERROR_NOMORE_RECORDS						_EC(1148)   // 查找到最后，没有更多记录
#define NET_ERROR_RECORD_ALREADY_EXISTS					_EC(1149)   // 下发卡或指纹时，数据重复
#define NET_ERROR_EXCEED_MAX_FINGERPRINT_PERUSER		_EC(1150)   // 超过个人最大指纹记录数
#define NET_ERROR_EXCEED_MAX_CARD_PERUSER				_EC(1151)   // 超过个人最大卡片记录数	
#define NET_ERROR_EXCEED_ADMINISTRATOR_LIMIT			_EC(1152)   // 超过门禁管理员个数限制

#define NET_LOGIN_ERROR_DEVICE_NOT_SUPPORT_HIGHLEVEL_SECURITY_LOGIN		_EC(1153)   // 设备不支持高安全等级登录
#define NET_LOGIN_ERROR_DEVICE_ONLY_SUPPORT_HIGHLEVEL_SECURITY_LOGIN	_EC(1154)   // 设备只支持高安全等级登录

#define NET_ERROR_VIDEO_CHANNEL_OFFLINE                 _EC(1155)   // 表示此视频通道处于离线，拉流失败
#define NET_ERROR_USERID_FORMAT_INCORRECT				_EC(1156)	// 用户编号不规范
#define NET_ERROR_CANNOT_FIND_CHANNEL_RELATE_TO_SN		_EC(1157)	// 找不到该SN对应的通道
#define NET_ERROR_TASK_QUEUE_OF_CHANNEL_IS_FULL			_EC(1158)	// 该通道的任务队列满
#define NET_ERROR_APPLY_USER_INFO_BLOCK_FAIL			_EC(1159)	// 申请不到新的用户信息(权限)块
#define NET_ERROR_EXCEED_MAX_PASSWD_PERUSER				_EC(1160)	// 用户密码数量超过限制
#define NET_ERROR_PARSE_PROTOCOL						_EC(1161)	// 设备内部异常引起协议解析错误
#define	NET_ERROR_CARD_NUM_EXIST						_EC(1162)	// 卡号已存在
#define	NET_ERROR_FINGERPRINT_EXIST						_EC(1163)	// 指纹已存在

#define NET_ERROR_OPEN_PLAYGROUP_FAIL					_EC(1164)	// 打开播放组失败
#define NET_ERROR_ALREADY_IN_PLAYGROUP					_EC(1165)	// 已位于播放组中
#define NET_ERROR_QUERY_PLAYGROUP_TIME_FAIL				_EC(1166)	// 查询播放组时间失败
#define NET_ERROR_SET_PLAYGROUP_BASECHANNEL_FAIL		_EC(1167)	// 设置播放组基准通道失败
#define NET_ERROR_SET_PLAYGROUP_DIRECTION_FAIL			_EC(1168)	// 设置播放组方向失败
#define NET_ERROR_SET_PLAYGROUP_SPEED_FAIL				_EC(1169)	// 设置播放组速度失败
#define NET_ERROR_ADD_PLAYGROUP_FAIL					_EC(1170)	// 加入播放组失败

#define NET_ERROR_EXPORT_AOL_LOGFILE_NO_AUTH			_EC(1171)	// 导出AOL日志:无权限
#define NET_ERROR_EXPORT_AOL_LOGFILE_NO_FILE			_EC(1172)	// 导出AOL日志:文件不存在
#define NET_ERROR_EXPORT_AOL_LOGFILE_FILE_FAIL			_EC(1173)	// 导出AOL日志:文件准备失败
#define NET_ERROR_EXPORT_AOL_LOGFILE_BUSY				_EC(1174)	// 导出AOL日志:系统忙

// 设备上APP安装相关错误码
#define NET_ERROR_EMPTY_LICENSE                         _EC(1175)   // License为空
#define NET_ERROR_UNSUPPORTED_MODE                      _EC(1176)   // 不支持该模式
#define NET_ERROR_URL_APP_NOT_MATCH                     _EC(1177)   // URL与APP不匹配
#define NET_ERROR_READ_INFO_FAILED                      _EC(1178)   // 读取信息失败
#define NET_ERROR_WRITE_FAILED                          _EC(1179)   // 写入失败
#define NET_ERROR_NO_SUCH_APP                           _EC(1180)   // 未找到APP
#define NET_ERROR_VERIFIF_FAILED                        _EC(1181)   // 校验失败
#define NET_ERROR_LICENSE_OUT_DATE                      _EC(1182)   // License已过期

#define NET_ERROR_UPGRADE_PROGRAM_TOO_OLD				_EC(1183)	// 升级程序版本过低


/************************************************************************
 ** 枚举定义
 ***********************************************************************/

//获取网卡信息类型 CLIENT_QueryNetStat  接口使用
typedef enum tagEM_NET_QUERY_TYPE
{
    NET_APP_DATA_STAT ,     // 获取协议栈统计数据,(输入结构体NET_IN_NETAPP_NET_DATA_STAT,输出结构体NET_OUT_NETAPP_NET_DATA_STAT)
    NET_APP_LINK_STAT ,     // 获取物理链路状态,(输入结构体NET_IN_NETAPP_LINK_STATUS,输出结构体NET_OUT_NETAPP_LINK_STATUS)
}EM_NET_QUERY_TYPE;

// 抓图类型 CLIENT_CapturePictureEx 接口使用
typedef enum tagNET_CAPTURE_FORMATS
{
    NET_CAPTURE_BMP,        // BMP
    NET_CAPTURE_JPEG,       // 100%质量的JPEG
    NET_CAPTURE_JPEG_70,    // 70%质量的JPEG
    NET_CAPTURE_JPEG_50,    // 50%质量的JPEG
    NET_CAPTURE_JPEG_30,    // 30%质量的JPEG
    NET_CAPTURE_JPEG_10     // 10%质量的JPEG
}NET_CAPTURE_FORMATS;

// 设备类型
typedef enum tagNET_DEVICE_TYPE 
{
    NET_PRODUCT_NONE = 0,
    NET_DVR_NONREALTIME_MACE,     // 非实时MACE
    NET_DVR_NONREALTIME,          // 非实时
    NET_NVS_MPEG1,                // 网络视频服务器
    NET_DVR_MPEG1_2,              // MPEG1二路录像机
    NET_DVR_MPEG1_8,              // MPEG1八路录像机
    NET_DVR_MPEG4_8,              // MPEG4八路录像机
    NET_DVR_MPEG4_16,             // MPEG4十六路录像机
    NET_DVR_MPEG4_SX2,            // LB系列录像机
    NET_DVR_MEPG4_ST2,            // GB系列录像机
    NET_DVR_MEPG4_SH2,            // HB系列录像机               10
    NET_DVR_MPEG4_GBE,            // GBE系列录像机
    NET_DVR_MPEG4_NVSII,          // II代网络视频服务器
    NET_DVR_STD_NEW,              // 新标准配置协议
    NET_DVR_DDNS,                 // DDNS服务器
    NET_DVR_ATM,                  // ATM机
    NET_NB_SERIAL,                // 二代非实时NB系列机器
    NET_LN_SERIAL,                // LN系列产品
    NET_BAV_SERIAL,               // BAV系列产品
    NET_SDIP_SERIAL,              // SDIP系列产品
    NET_IPC_SERIAL,               // IPC系列产品                20
    NET_NVS_B,                    // NVS B系列
    NET_NVS_C,                    // NVS H系列
    NET_NVS_S,                    // NVS S系列
    NET_NVS_E,                    // NVS E系列
    NET_DVR_NEW_PROTOCOL,         // 从QueryDevState中查询设备类型,以字符串格式
    NET_NVD_SERIAL,               // 解码器
    NET_DVR_N5,                   // N5
    NET_DVR_MIX_DVR,              // 混合DVR
    NET_SVR_SERIAL,               // SVR系列
    NET_SVR_BS,                   // SVR-BS                     30
    NET_NVR_SERIAL,               // NVR系列
    NET_DVR_N51,                  // N51
    NET_ITSE_SERIAL,              // ITSE 智能分析盒
    NET_ITC_SERIAL,               // 智能交通像机设备
    NET_HWS_SERIAL,               // 雷达测速仪HWS
    NET_PVR_SERIAL,               // 便携式音视频录像机
    NET_IVS_SERIAL,               // IVS（智能视频服务器系列）
    NET_IVS_B,                    // 通用智能视频侦测服务器
    NET_IVS_F,                    // 人脸识别服务器
    NET_IVS_V,                    // 视频质量诊断服务器         40
    NET_MATRIX_SERIAL,            // 矩阵
    NET_DVR_N52,                  // N52
    NET_DVR_N56,                  // N56
    NET_ESS_SERIAL,               // ESS
    NET_IVS_PC,                   // 人数统计服务器
    NET_PC_NVR,                   // pc-nvr
    NET_DSCON,                    // 大屏控制器
    NET_EVS,                      // 网络视频存储服务器
    NET_EIVS,                     // 嵌入式智能分析视频系统
    NET_DVR_N6,                   // DVR-N6                     50
    NET_UDS,                      // 万能解码器
    NET_AF6016,                   // 银行报警主机
    NET_AS5008,                   // 视频网络报警主机
    NET_AH2008,                   // 网络报警主机
    NET_A_SERIAL,                 // 报警主机系列
    NET_BSC_SERIAL,               // 门禁系列产品
    NET_NVS_SERIAL,               // NVS系列产品
    NET_VTO_SERIAL,               // VTO系列产品
    NET_VTNC_SERIAL,              // VTNC系列产品
    NET_TPC_SERIAL,               // TPC系列产品, 即热成像设备  60
    NET_ASM_SERIAL,               // 无线中继设备
    NET_VTS_SERIAL,               // 管理机
    NET_ARC2016C,                 // 报警主机ARC2016C
    NET_ASA,                      // 考勤机
	NET_VTT_SERIAL,				  // 行业对讲终端
	NET_VTA_SERIAL,				  // 报警柱
	NET_VTNS_SERIAL,			  // SIP服务器
	NET_VTH_SERIAL,				  // 室内机
	NET_IVSS,					  // IVSS产品
	NET_ASG,                      // 人脸道闸
	NET_RADAR,					  // 雷达产品
	NET_RADAR_PTZ,				  // 雷达系统
	NET_RADAR_CAM,				  // 摄像雷达
	NET_ASE,					  // 梯控设备
}NET_DEVICE_TYPE ;

// 语言种类
typedef enum __LANGUAGE_TYPE
{
    DH_LANGUAGE_ENGLISH,                // 英文    
    DH_LANGUAGE_CHINESE_SIMPLIFIED,     // 简体中文    
    DH_LANGUAGE_CHINESE_TRADITIONAL,    // 繁体中文    
    DH_LANGUAGE_ITALIAN,                // 意大利文    
    DH_LANGUAGE_SPANISH,                // 西班牙文
    DH_LANGUAGE_JAPANESE,               // 日文版    
    DH_LANGUAGE_RUSSIAN,                // 俄文版        
    DH_LANGUAGE_FRENCH,                 // 法文版        
    DH_LANGUAGE_GERMAN,                 // 德文版        
    DH_LANGUAGE_PORTUGUESE,             // 葡萄牙语    
    DH_LANGUAGE_TURKEY,                 // 土尔其语    
    DH_LANGUAGE_POLISH,                 // 波兰语    
    DH_LANGUAGE_ROMANIAN,               // 罗马尼亚    
    DH_LANGUAGE_HUNGARIAN,              // 匈牙利语    
    DH_LANGUAGE_FINNISH,                // 芬兰语    
    DH_LANGUAGE_ESTONIAN,               // 爱沙尼亚语    
    DH_LANGUAGE_KOREAN,                 // 韩语    
    DH_LANGUAGE_FARSI,                  // 波斯语     
    DH_LANGUAGE_DANSK,                  // 丹麦语
    DH_LANGUAGE_CZECHISH,               // 捷克文
    DH_LANGUAGE_BULGARIA,               // 保加利亚文
    DH_LANGUAGE_SLOVAKIAN,              // 斯洛伐克语
    DH_LANGUAGE_SLOVENIA,               // 斯洛文尼亚文
    DH_LANGUAGE_CROATIAN,               // 克罗地亚语
    DH_LANGUAGE_DUTCH,                  // 荷兰语
    DH_LANGUAGE_GREEK,                  // 希腊语
    DH_LANGUAGE_UKRAINIAN,              // 乌克兰语
    DH_LANGUAGE_SWEDISH,                // 瑞典语
    DH_LANGUAGE_SERBIAN,                // 塞尔维亚语
    DH_LANGUAGE_VIETNAMESE,             // 越南语
    DH_LANGUAGE_LITHUANIAN,             // 立陶宛语
    DH_LANGUAGE_FILIPINO,               // 菲律宾语
    DH_LANGUAGE_ARABIC,                 // 阿拉伯语
    DH_LANGUAGE_CATALAN,                // 加泰罗尼亚语
    DH_LANGUAGE_LATVIAN,                // 拉脱维亚语
    DH_LANGUAGE_THAI,                   // 泰语
    DH_LANGUAGE_HEBREW,                 // 希伯来语
    DH_LANGUAGE_Bosnian,                // 波斯尼亚文
} DH_LANGUAGE_TYPE;

// 升级类型
typedef enum __EM_UPGRADE_TYPE
{
    DH_UPGRADE_BIOS_TYPE = 1,           // BIOS升级
    DH_UPGRADE_WEB_TYPE,                // WEB升级
    DH_UPGRADE_BOOT_YPE,                // BOOT升级
    DH_UPGRADE_CHARACTER_TYPE,          // 汉字库
    DH_UPGRADE_LOGO_TYPE,               // LOGO
    DH_UPGRADE_EXE_TYPE,                // EXE,例如播放器等
    DH_UPGRADE_DEVCONSTINFO_TYPE,       // 设备固有信息设置(如：硬件ID,MAC,序列号)
    DH_UPGRADE_PERIPHERAL_TYPE,         // 外设接入从片(如车载287芯片)
    DH_UPGRADE_GEOINFO_TYPE,            // 地理信息定位芯片
    DH_UPGRADE_MENU,                    // 菜单（设备操作界面的图片）
    DH_UPGRADE_ROUTE,                   // 线路文件（如公交线路）
    DH_UPGRADE_ROUTE_STATE_AUTO,        // 报站音频（与线路配套的报站音频）
    DH_UPGRADE_SCREEN,                  // 调度屏（如公交操作屏）
} EM_UPGRADE_TYPE;

// 录象类型(定时、动态检测、报警)
typedef enum __REC_TYPE
{
    DH_REC_TYPE_TIM = 0,
    DH_REC_TYPE_MTD,
    DH_REC_TYPE_ALM,
    DH_REC_TYPE_NUM,
} REC_TYPE;

// 网络类型 
typedef enum __GPRSCDMA_NETWORK_TYPE
{
    DH_TYPE_AUTOSEL = 0,                        // 自动选择
    DH_TYPE_TD_SCDMA,                           // TD-SCDMA网络 
    DH_TYPE_WCDMA,                              // WCDMA网络
    DH_TYPE_CDMA_1x,                            // CDMA 1.x网络
    DH_TYPE_EDGE,                               // GPRS网络
    DH_TYPE_EVDO,                               // EVDO网络
    DH_TYPE_WIFI,                               // 无线
} EM_GPRSCDMA_NETWORK_TYPE;

// 接口类型,对应CLIENT_SetSubconnCallBack接口
typedef enum __EM_INTERFACE_TYPE
{
    DH_INTERFACE_OTHER = 0x00000000,            // 未知接口
    DH_INTERFACE_REALPLAY,                      // 实时监视接口
    DH_INTERFACE_PREVIEW,                       // 多画面预览接口
    DH_INTERFACE_PLAYBACK,                      // 回放接口
    DH_INTERFACE_DOWNLOAD,                      // 下载接口
    DH_INTERFACE_REALLOADPIC,                   // 下载智能图片接口
} EM_INTERFACE_TYPE;

// 视频监视断开事件类型
typedef enum _EM_REALPLAY_DISCONNECT_EVENT_TYPE
{
    DISCONNECT_EVENT_REAVE,                     // 表示高级用户抢占低级用户资源
    DISCONNECT_EVENT_NETFORBID,                 // 禁止入网
    DISCONNECT_EVENT_SUBCONNECT,                // 动态子链接断开
}EM_REALPLAY_DISCONNECT_EVENT_TYPE;

// 事件文件的文件标签类型
typedef enum __EM_EVENT_FILETAG
{
    DH_ATMBEFOREPASTE = 1,                      // ATM贴条前
    DH_ATMAFTERPASTE,                           // ATM贴条后
}EM_EVENT_FILETAG;

// IPC类型
typedef enum __EM_IPC_TYPE
{
    DH_IPC_PRIVATE,                                 // 私有
    DH_IPC_AEBELL,                                  // 美电贝尔
    DH_IPC_PANASONIC,                               // 松下
    DH_IPC_SONY,                                    // 索尼
    DH_IPC_DYNACOLOR,                               // Dynacolor
    DH_IPC_TCWS = 5,                                // 天城威视
    DH_IPC_SAMSUNG,                                 // 三星
    DH_IPC_YOKO,                                    // YOKO
    DH_IPC_AXIS,                                    // 安讯视
    DH_IPC_SANYO,                                   // 三洋       
    DH_IPC_BOSH = 10,                               // Bosch
    DH_IPC_PECLO,                                   // Peclo
    DH_IPC_PROVIDEO,                                // Provideo
    DH_IPC_ACTI,                                    // ACTi
    DH_IPC_VIVOTEK,                                 // Vivotek
    DH_IPC_ARECONT = 15,                            // Arecont
    DH_IPC_PRIVATEEH,                               // PrivateEH    
    DH_IPC_IMATEK,                                  // IMatek
    DH_IPC_SHANY,                                   // Shany
    DH_IPC_VIDEOTREC,                               // 动力盈科
    DH_IPC_URA = 20,                                // Ura
    DH_IPC_BITICINO,                                // Bticino 
    DH_IPC_ONVIF,                                   // Onvif协议类型
    DH_IPC_SHEPHERD,                                // 视霸
    DH_IPC_YAAN,                                    // 亚安
    DH_IPC_AIRPOINT = 25,                           // Airpop
    DH_IPC_TYCO,                                    // TYCO
    DH_IPC_XUNMEI,                                  // 讯美
    DH_IPC_HIKVISION,                               // 海康
    DH_IPC_LG,                                      // LG
    DH_IPC_AOQIMAN = 30,                            // 奥奇曼
    DH_IPC_BAOKANG,                                 // 宝康    
    DH_IPC_WATCHNET,                                // Watchnet
    DH_IPC_XVISION,                                 // Xvision
    DH_IPC_FUSITSU,                                 // 富士通
    DH_IPC_CANON = 35,                              // Canon
    DH_IPC_GE,                                      // GE
    DH_IPC_Basler,                                  // 巴斯勒
    DH_IPC_Patro,                                   // 帕特罗
    DH_IPC_CPKNC,                                   // CPPLUS K系列
    DH_IPC_CPRNC = 40,                              // CPPLUS R系列
    DH_IPC_CPUNC,                                   // CPPLUS U系列
    DH_IPC_CPPLUS,                                  // CPPLUS IPC
    DH_IPC_XunmeiS,                                 // 讯美s,实际协议为Onvif
    DH_IPC_GDDW,                                    // 广东电网
    DH_IPC_PSIA = 45,                               // PSIA
    DH_IPC_GB2818,                                  // GB2818    
    DH_IPC_GDYX,                                    // GDYX
    DH_IPC_OTHER,                                   // 由用户自定义
    DH_IPC_CPUNR,                                   // CPPLUS NVR
    DH_IPC_CPUAR = 50,                              // CPPLUS DVR
    DH_IPC_AIRLIVE,                                 // Airlive    
    DH_IPC_NPE,                                     // NPE    
    DH_IPC_AXVIEW,                                  // AXVIEW
    DH_IPC_DFWL,                                    // 东方网力
    DH_IPC_HYUNDAI = 56,                            // HYUNDAI DVR
    DH_IPC_APHD,                                    // 爱普华顿
    DH_IPC_WELLTRANS ,                              // 微创
    DH_IPC_CDJF,                                    // 成都佳发
    DH_IPC_JVC = 60,                                // JVC
    DH_IPC_INFINOVA,                                // 英飞拓
    DH_IPC_ADT,                                     // ADT
    DH_IPC_SIVIDI,                                  // 海南创先
    DH_IPC_CPUNP,                                   // CPPLUS 球机
    DH_IPC_HX = 65,                                 // 海信
    DH_IPC_TJGS,                                    // 天津高速
    DH_IPC_MULTICAST = 79,                          // 组播
	DH_IPC_RVI = 84,                                // RVi
	DH_IPC_HONEYWELL = 95,                          // Honeywell
}EM_IPC_TYPE;

// H264 编码级别
typedef enum __EM_H264_PROFILE_RANK
{
    DH_PROFILE_BASELINE = 1,                       // 提供I/P帧,仅支持progressive(逐行扫描)和CAVLC
    DH_PROFILE_MAIN,                               // 提供I/P/B帧,支持progressiv和interlaced,提供CAVLC或CABAC
    DH_PROFILE_EXTENDED,                           // 提供I/P/B/SP/SI帧,仅支持progressive(逐行扫描)和CAVLC
    DH_PROFILE_HIGH,                               // 即FRExt,Main_Profile基础上新增：8x8 intra prediction(8x8 帧内预测), custom 
                                                   // quant(自定义量化), lossless video coding(无损视频编码), 更多的yuv格式
}EM_H264_PROFILE_RANK;

typedef enum __EM_DISK_TYPE
{
    DH_DISK_READ_WRITE,                         // 读写驱动器
    DH_DISK_READ_ONLY,                          // 只读驱动器
    DH_DISK_BACKUP,                             // 备份驱动器或媒体驱动器
    DH_DISK_REDUNDANT,                          // 冗余驱动器
    DH_DISK_SNAPSHOT,                           // 快照驱动器
}EM_DISK_TYPE;

// 码流加密算法工作模式
typedef enum  __EM_ENCRYPT_ALOG_WORKMODE
{
    ENCRYPT_ALOG_WORKMODE_ECB,                  // ECB模式
    ENCRYPT_ALOG_WORKMODE_CBC,                  // CBC模式
    ENCRYPT_ALOG_WORKMODE_CFB,                  // CFB模式
    ENCRYPT_ALOG_WORKMODE_OFB,                  // OFB模式
}EM_ENCRYPT_ALOG_WORKMODE;

typedef enum __EM_MOBILE_PPP_STATE
{
    MOBILE_PPP_UP = 0,                          // 链接已经建立
    MOBILE_PPP_DOWN,                            // ppp连接断开        
    MOBILE_PPP_CONNECTING,                      // 正在创建链接        
    MOBILE_PPP_CLOSEING,                        // 正在关闭PPP链接
} EM_MOBILE_PPP_STATE;

typedef enum __EM_3GMOBILE_STATE
{
    MOBILE_MODULE_OFF,                          // 表示3g网卡模块关闭           
    MOBILE_MODULE_STARTING,                     // 表示3g网卡模块正在启动    
    MOBILE_MODULE_WORKING,                      // 表示3g网卡模块正在工作中
}EM_3GMOBILE_STATE;

typedef enum tagEM_LOGIN_SPAC_CAP_TYPE
{
    EM_LOGIN_SPEC_CAP_TCP               = 0,    // TCP登陆, 默认方式
    EM_LOGIN_SPEC_CAP_ANY               = 1,    // 无条件登陆
    EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2,    // 主动注册的登入
    EM_LOGIN_SPEC_CAP_MULTICAST         = 3,    // 组播登陆
    EM_LOGIN_SPEC_CAP_UDP               = 4,    // UDP方式下的登入
    EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6,    // 只建主连接下的登入
    EM_LOGIN_SPEC_CAP_SSL               = 7,    // SSL加密方式登陆

    EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9,    // 登录智能盒远程设备
    EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10,   // 登录设备后不做取配置操作
    EM_LOGIN_SPEC_CAP_U_LOGIN           = 11,   // 用U盾设备的登入
    EM_LOGIN_SPEC_CAP_LDAP              = 12,   // LDAP方式登录
    EM_LOGIN_SPEC_CAP_AD                = 13,   // AD（ActiveDirectory）登录方式
    EM_LOGIN_SPEC_CAP_RADIUS            = 14,   // Radius 登录方式 
    EM_LOGIN_SPEC_CAP_SOCKET_5          = 15,   // Socks5登陆方式
    EM_LOGIN_SPEC_CAP_CLOUD             = 16,   // 云登陆方式
    EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17,   // 二次鉴权登陆方式
    EM_LOGIN_SPEC_CAP_TS                = 18,   // TS码流客户端登陆方式
    EM_LOGIN_SPEC_CAP_P2P               = 19,   // 为P2P登陆方式
    EM_LOGIN_SPEC_CAP_MOBILE            = 20,   // 手机客户端登陆
    EM_LOGIN_SPEC_CAP_INVALID                   // 无效的登陆方式
}EM_LOGIN_SPAC_CAP_TYPE;

/////////////////////////////////监视相关/////////////////////////////////

// 预览类型,对应CLIENT_RealPlayEx接口
typedef enum _RealPlayType
{
    DH_RType_Realplay = 0,                      // 实时预览
    DH_RType_Multiplay,                         // 多画面预览
    DH_RType_Realplay_0,                        // 实时监视-主码流,等同于DH_RType_Realplay
    DH_RType_Realplay_1,                        // 实时监视-从码流1
    DH_RType_Realplay_2,                        // 实时监视-从码流2
    DH_RType_Realplay_3,                        // 实时监视-从码流3    
    DH_RType_Multiplay_1,                       // 多画面预览－1画面
    DH_RType_Multiplay_4,                       // 多画面预览－4画面
    DH_RType_Multiplay_8,                       // 多画面预览－8画面
    DH_RType_Multiplay_9,                       // 多画面预览－9画面
    DH_RType_Multiplay_16,                      // 多画面预览－16画面
    DH_RType_Multiplay_6,                       // 多画面预览－6画面
    DH_RType_Multiplay_12,                      // 多画面预览－12画面
    DH_RType_Multiplay_25,                      // 多画面预览－25画面
    DH_RType_Multiplay_36,                      // 多画面预览－36画面
	DH_RType_Multiplay_64,						// 多画面预览－64画面
	DH_RType_Multiplay_255,						// 不修改当前预览通道数
    DH_RType_Realplay_Test = 255,               // 带宽测试码流
} DH_RealPlayType;

/////////////////////////////////云台相关/////////////////////////////////

// 通用云台控制命令
typedef enum _PTZ_ControlType
{

    DH_PTZ_UP_CONTROL = 0,                      // 上
    DH_PTZ_DOWN_CONTROL,                        // 下
    DH_PTZ_LEFT_CONTROL,                        // 左
    DH_PTZ_RIGHT_CONTROL,                       // 右
    DH_PTZ_ZOOM_ADD_CONTROL,                    // 变倍+
    DH_PTZ_ZOOM_DEC_CONTROL,                    // 变倍-
    DH_PTZ_FOCUS_ADD_CONTROL,                   // 调焦-
    DH_PTZ_FOCUS_DEC_CONTROL,                   // 调焦+
    DH_PTZ_APERTURE_ADD_CONTROL,                // 光圈+
    DH_PTZ_APERTURE_DEC_CONTROL,                // 光圈-
    DH_PTZ_POINT_MOVE_CONTROL,                  // 转至预置点
    DH_PTZ_POINT_SET_CONTROL,                   // 设置
    DH_PTZ_POINT_DEL_CONTROL,                   // 删除
    DH_PTZ_POINT_LOOP_CONTROL,                  // 点间巡航
    DH_PTZ_LAMP_CONTROL                         // 灯光雨刷
} DH_PTZ_ControlType;

// 云台控制扩展命令
typedef enum _EXTPTZ_ControlType
{
    DH_EXTPTZ_LEFTTOP = 0x20,                   // 左上
    DH_EXTPTZ_RIGHTTOP,                         // 右上
    DH_EXTPTZ_LEFTDOWN,                         // 左下
    DH_EXTPTZ_RIGHTDOWN,                        // 右下
    DH_EXTPTZ_ADDTOLOOP,                        // 加入预置点到巡航 巡航线路 预置点值
    DH_EXTPTZ_DELFROMLOOP,                      // 删除巡航中预置点 巡航线路 预置点值
    DH_EXTPTZ_CLOSELOOP,                        // 清除巡航 巡航线路
    DH_EXTPTZ_STARTPANCRUISE,                   // 开始水平旋转
    DH_EXTPTZ_STOPPANCRUISE,                    // 停止水平旋转
    DH_EXTPTZ_SETLEFTBORDER,                    // 设置左边界
    DH_EXTPTZ_SETRIGHTBORDER,                   // 设置右边界
    DH_EXTPTZ_STARTLINESCAN,                    // 开始线扫
    DH_EXTPTZ_CLOSELINESCAN,                    // 停止线扫
    DH_EXTPTZ_SETMODESTART,                     // 设置模式开始    模式线路
    DH_EXTPTZ_SETMODESTOP,                      // 设置模式结束    模式线路
    DH_EXTPTZ_RUNMODE,                          // 运行模式    模式线路
    DH_EXTPTZ_STOPMODE,                         // 停止模式    模式线路
    DH_EXTPTZ_DELETEMODE,                       // 清除模式    模式线路
    DH_EXTPTZ_REVERSECOMM,                      // 翻转命令
    DH_EXTPTZ_FASTGOTO,                         // 快速定位 水平坐标(8192) 垂直坐标(8192) 变倍(4)
    DH_EXTPTZ_AUXIOPEN,                         // 辅助开关开 辅助点(param4对应 PTZ_CONTROL_AUXILIARY,param1、param2、param3无效,dwStop设置为FALSE)
    DH_EXTPTZ_AUXICLOSE,                        // 辅助开关关 辅助点(param4对应 PTZ_CONTROL_AUXILIARY,param1、param2、param3无效,dwStop设置为FALSE)
    DH_EXTPTZ_OPENMENU = 0x36,                  // 打开球机菜单
    DH_EXTPTZ_CLOSEMENU,                        // 关闭菜单
    DH_EXTPTZ_MENUOK,                           // 菜单确定
    DH_EXTPTZ_MENUCANCEL,                       // 菜单取消
    DH_EXTPTZ_MENUUP,                           // 菜单上
    DH_EXTPTZ_MENUDOWN,                         // 菜单下
    DH_EXTPTZ_MENULEFT,                         // 菜单左
    DH_EXTPTZ_MENURIGHT,                        // 菜单右
    DH_EXTPTZ_ALARMHANDLE = 0x40,               // 报警联动云台 parm1：报警输入通道；parm2：报警联动类型1-预置点2-线扫3-巡航；parm3：联动值,如预置点号
    DH_EXTPTZ_MATRIXSWITCH = 0x41,              // 矩阵切换 parm1：监视器号(视频输出号)；parm2：视频输入号；parm3：矩阵号
    DH_EXTPTZ_LIGHTCONTROL,                     // 灯光控制器
    DH_EXTPTZ_EXACTGOTO,                        // 三维精确定位 parm1：水平角度(0~3600)；parm2：垂直坐标(0~900)；parm3：变倍(1~128),变倍为档位,并非实际变倍倍数
    DH_EXTPTZ_RESETZERO,                        // 三维定位重设零位
    DH_EXTPTZ_MOVE_ABSOLUTELY,                  // 绝对移动控制命令,param4对应结构 PTZ_CONTROL_ABSOLUTELY
    DH_EXTPTZ_MOVE_CONTINUOUSLY,                // 持续移动控制命令,param4对应结构 PTZ_CONTROL_CONTINUOUSLY
    DH_EXTPTZ_GOTOPRESET,                       // 云台控制命令,以一定速度转到预置位点,parm4对应结构PTZ_CONTROL_GOTOPRESET
    DH_EXTPTZ_SET_VIEW_RANGE = 0x49,            // 设置可视域(param4对应结构 PTZ_VIEW_RANGE_INFO)
    DH_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A,          // 绝对聚焦(param4对应结构PTZ_FOCUS_ABSOLUTELY)
    DH_EXTPTZ_HORSECTORSCAN = 0x4B,             // 水平扇扫(param4对应PTZ_CONTROL_SECTORSCAN,param1、param2、param3无效)
    DH_EXTPTZ_VERSECTORSCAN = 0x4C,             // 垂直扇扫(param4对应PTZ_CONTROL_SECTORSCAN,param1、param2、param3无效)
    DH_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D,         // 设定绝对焦距、聚焦值,param1为焦距,范围:[0,255],param2为聚焦,范围:[0,255],param3、param4无效
    DH_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E,          // 控制鱼眼电子云台,param4对应结构 PTZ_CONTROL_SET_FISHEYE_EPTZ  
    DH_EXTPTZ_SET_TRACK_START = 0x4F,           // 轨道机开始控制(param4对应结构体为 PTZ_CONTROL_SET_TRACK_CONTROL,dwStop传FALSE, param1、param2、param3无效)
    DH_EXTPTZ_SET_TRACK_STOP = 0x50,            // 轨道机停止控制(param4对应结构体为 PTZ_CONTROL_SET_TRACK_CONTROL,dwStop传FALSE,param1、param2、param3无效)
    DH_EXTPTZ_RESTART = 0x51,                   // 云台重启命令(param1、param2、param3 param4 均无效,dwStop设置为FALSE)
	DH_EXTPTZ_INTELLI_TRACKMOVE = 0x52,         // 云台连续移动,枪球联动专用,param4对应结构 PTZ_CONTROL_INTELLI_TRACKMOVE
    DH_EXTPTZ_SET_FOCUS_REGION = 0x53,          // 设置区域聚焦参数(param4对应结构体为PTZ_CONTROL_SET_FOCUS_REGION,dwStop传FALSE,param1、param2、param3无效)
	DH_EXTPTZ_PAUSELINESCAN = 0x54,             // 暂停线扫(param1、param2、param3param4均无效，dwStop设置为FALSE)
	DH_EXTPTZ_INTELLI_SETLENSWISDOMSTATE = 0x55,// 目标跟踪时设置聚焦模式(param4对应结构体为PTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE,dwStop传FALSE,param1、param2、param3无效) 
	DH_EXTPTZ_INTELLI_SETFOCUSAREA = 0x56,		// 设置聚焦区域(param4对应结构体为PTZ_CONTROL_INTELLI_SETFOCUSAREA,dwStop传FALSE,param1、param2、param3无效)
												// 注：目标跟踪若不需设置聚焦区域，因聚焦区域会沿袭上次主动设置状态，故需主动调用此接口取消设置聚焦区域

    DH_EXTPTZ_UP_TELE = 0x70,                   // 上 + TELE param1=速度(1-8),下同
    DH_EXTPTZ_DOWN_TELE,                        // 下 + TELE
    DH_EXTPTZ_LEFT_TELE,                        // 左 + TELE
    DH_EXTPTZ_RIGHT_TELE,                       // 右 + TELE
    DH_EXTPTZ_LEFTUP_TELE,                      // 左上 + TELE
    DH_EXTPTZ_LEFTDOWN_TELE,                    // 左下 + TELE
    DH_EXTPTZ_TIGHTUP_TELE,                     // 右上 + TELE
    DH_EXTPTZ_RIGHTDOWN_TELE,                   // 右下 + TELE
    DH_EXTPTZ_UP_WIDE,                          // 上 + WIDE param1=速度(1-8),下同
    DH_EXTPTZ_DOWN_WIDE,                        // 下 + WIDE
    DH_EXTPTZ_LEFT_WIDE,                        // 左 + WIDE
    DH_EXTPTZ_RIGHT_WIDE,                       // 右 + WIDE
    DH_EXTPTZ_LEFTUP_WIDE,                      // 左上 + WIDE
    DH_EXTPTZ_LEFTDOWN_WIDE,                    // 左下 + WIDE
    DH_EXTPTZ_TIGHTUP_WIDE,                     // 右上 + WIDE
    DH_EXTPTZ_RIGHTDOWN_WIDE,                   // 右下 + WIDE
	DH_EXTPTZ_GOTOPRESETSNAP = 0x80,            // 转至预置点并抓图
    DH_EXTPTZ_DIRECTIONCALIBRATION = 0x82,      // 校准云台方向（双方向校准）
    DH_EXTPTZ_SINGLEDIRECTIONCALIBRATION = 0x83, // 校准云台方向（单防线校准）,param4对应结构 NET_IN_CALIBRATE_SINGLEDIRECTION
    DH_EXTPTZ_MOVE_RELATIVELY = 0x84,			// 云台相对定位,param4对应结构 NET_IN_MOVERELATIVELY_INFO
    DH_EXTPTZ_SET_DIRECTION = 0x85,				// 设置云台方向, param4对应结构 NET_IN_SET_DIRECTION_INFO
	DH_EXTPTZ_TOTAL,                            // 最大命令值
} DH_EXTPTZ_ControlType;

// 鱼眼电子云台控制命令
typedef enum tagNET_FISHEYE_EPTZ_CMD
{
    NET_FISHEYE_EPTZ_CMD_UNKOWN,                    // 未知类型
	NET_FISHEYE_EPTZ_CMD_ZOOMIN,                    // 放大,dwParam1表示步长,范围1～8
	NET_FISHEYE_EPTZ_CMD_ZOOMOUT,                   // 缩小,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_UP,                        // 向上移动,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_DOWN,                      // 向下移动,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_LEFT,                      // 向左移动,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_RIGHT,                     // 向右移动,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_ROTATECLOCK,               // 自动顺时针旋转,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_ROTATEANTICLOCK,           // 自动逆时针旋转,dwParam1表示步长,范围1～8
    NET_FISHEYE_EPTZ_CMD_STOP,                      // 终止自动旋转操作
    NET_FISHEYE_EPTZ_CMD_TAPVIEW,                   // 显示指定位置,即点即看,dwParam1表示eptz（电子云台）的焦点横坐标,即焦点在矫正后的图像中的横坐标,取值不超过矫正后输出图像的宽
    // dwParam2表示eptz（电子云台）的焦点纵坐标,即焦点在矫正后的图像中的纵坐标,取值不超过矫正后输出图像的高
    NET_FISHEYE_EPTZ_CMD_SHOEREGION,                // 框选放大,wParam1表示所选矩形中心点的横坐标,
    // dwParam2表示所选矩形中心点的纵坐标,dwParam3表示所选矩形的宽
    // dwParam4表示所选矩形的高
}NET_FISHEYE_EPTZ_CMD;

// 轨道机控制命令
typedef enum tagNET_TRACK_CONTROL_CMD
{
    NET_TRACK_CONTROL_CMD_UP,                       // 向上移动,dwParam1表示步长,范围1～8 
    NET_TRACK_CONTROL_CMD_DOWN,                     // 向下移动,dwParam1表示步长,范围1～8
    NET_TRACK_CONTROL_CMD_LEFT,                     // 向左移动,dwParam1表示步长,范围1～8
    NET_TRACK_CONTROL_CMD_RIGHT,                    // 向右移动,dwParam1表示步长,范围1～8
    NET_TRACK_CONTROL_CMD_SETPRESET,                // 设置预置点,dwParam1表示预置点值
    NET_TRACK_CONTROL_CMD_CLEARPRESET,              // 清除预置点,dwParam1表示预置点值
    NET_TRACK_CONTROL_CMD_GOTOPRESET,               // 转至预置点,dwParam1表示预置点值
} NET_TRACK_CONTROL_CMD;

// 鱼眼矫正模式
typedef enum tagNET_CALIBRATE_MODE
{
    NET_FISHEYE_CALIBRATE_MODE_UNKOWN,                      // 未知模式 
    NET_FISHEYE_CALIBRATE_MODE_ORIGIAL,                     // 原始图像模式
    NET_FISHEYE_CALIBRATE_MODE_CONFIG,                      // 配置模
    NET_FISHEYE_CALIBRATE_MODE_PANORAMA,                    // 全景模式
    NET_FISHEYE_CALIBRATE_MODE_DOUBLEPANORAMA,              // 双全景模式
    NET_FISHEYE_CALIBRATE_MODE_ORIGIALPLUSTHREEEPTZREGION,  // 1+3模式（一个原始鱼眼图像加3个EPtz图像）
    NET_FISHEYE_CALIBRATE_MODE_SINGLE,                      // 单画面EPtz模式（只有一个EPtz画面）
    NET_FISHEYE_CALIBRATE_MODE_FOUREPTZREGION,              // 4画面模式（4个EPtz控制画面）
    NET_FISHEYE_CALIBRATE_MODE_NORMAL,                      // 普通模式
}NET_FISHEYE_CALIBRATE_MODE;

typedef enum tagNET_FISHEYE_TYPE
{
    NET_FISHEYE_UNKOWN =0   ,               //未知
    NET_FISHEYE_CHIP        ,               //仅支持设备端鱼眼矫正
    NET_FISHEYE_PLUGIN      ,               //仅支持控件鱼眼矫正
    NET_FISHEYE_CHIP_PLUGIN ,               //二者都支持
}NET_FISHEYE_TYPE;

// 鱼眼安装模式
typedef enum tagNET_FISHEYE_MOUNT_MODE
{
    NET_FISHEYE_MOUNT_MODE_UNKOWN,                          // 未知模式                  
    NET_FISHEYE_MOUNT_MODE_CEIL,                            // 顶装模式 
    NET_FISHEYE_MOUNT_MODE_WALL,                            // 壁装模式  
    NET_FISHEYE_MOUNT_MODE_FLOOR,                           // 地装模式  
}NET_FISHEYE_MOUNT_MODE;
/////////////////////////////////日志相关/////////////////////////////////

// 日志查询类型
typedef enum _DH_LOG_QUERY_TYPE
{
    DHLOG_ALL = 0,                              // 所有日志
    DHLOG_SYSTEM,                               // 系统日志
    DHLOG_CONFIG,                               // 配置日志
    DHLOG_STORAGE,                              // 存储相关
    DHLOG_ALARM,                                // 报警日志
    DHLOG_RECORD,                               // 录象相关
    DHLOG_ACCOUNT,                              // 帐号相关
    DHLOG_CLEAR,                                // 清除日志
    DHLOG_PLAYBACK,                             // 回放相关
    DHLOG_MANAGER                               // 前端管理运行相关
} DH_LOG_QUERY_TYPE;

// 日志类型
typedef enum _DH_LOG_TYPE
{
    DH_LOG_REBOOT = 0x0000,                     // 设备重启
    DH_LOG_SHUT,                                // 设备关机
    DH_LOG_REPORTSTOP,
    DH_LOG_REPORTSTART,
    DH_LOG_UPGRADE = 0x0004,                    // 设备升级
    DH_LOG_SYSTIME_UPDATE = 0x0005,             // 系统时间更新
    DH_LOG_GPS_TIME_UPDATE = 0x0006,            // GPS时间更新
    DH_LOG_AUDIO_TALKBACK,                      // 语音对讲, true代表开启,false代表关闭    
    DH_LOG_COMM_ADAPTER,                        // 透明传输, true代表开启,false代表关闭    
    DH_LOG_NET_TIMING,                          // 网络校时
    DH_LOG_CONFSAVE = 0x0100,                   // 保存配置
    DH_LOG_CONFLOAD,                            // 读取配置
    DH_LOG_FSERROR = 0x0200,                    // 文件系统错误
    DH_LOG_HDD_WERR,                            // 硬盘写错误
    DH_LOG_HDD_RERR,                            // 硬盘读错误
    DH_LOG_HDD_TYPE,                            // 设置硬盘类型
    DH_LOG_HDD_FORMAT,                          // 格式化硬盘
    DH_LOG_HDD_NOSPACE,                         // 当前工作盘空间不足
    DH_LOG_HDD_TYPE_RW,                         // 设置硬盘类型为读写盘
    DH_LOG_HDD_TYPE_RO,                         // 设置硬盘类型为只读盘    
    DH_LOG_HDD_TYPE_RE,                         // 设置硬盘类型为冗余盘
    DH_LOG_HDD_TYPE_SS,                         // 设置硬盘类型为快照盘
    DH_LOG_HDD_NONE,                            // 无硬盘记录
    DH_LOG_HDD_NOWORKHDD,                       // 无工作盘(没有读写盘)
    DH_LOG_HDD_TYPE_BK,                         // 设置硬盘类型为备份盘
    DH_LOG_HDD_TYPE_REVERSE,                    // 设置硬盘类型为保留分区
    DH_LOG_HDD_START_INFO = 0x20e ,             // 记录开机时的硬盘信息
    DH_LOG_HDD_WORKING_DISK,                    // 记录换盘后的工作盘号
    DH_LOG_HDD_OTHER_ERROR,                     // 记录硬盘其它错误
    DH_LOG_HDD_SLIGHT_ERR,                      // 硬盘存在轻微问题
    DH_LOG_HDD_SERIOUS_ERR,                     // 硬盘存在严重问题
    DH_LOG_HDD_NOSPACE_END,                     // 当前工作盘空间不足报警结束
    DH_LOG_HDD_TYPE_RAID_CONTROL,               // Raid操作
    DH_LOG_HDD_TEMPERATURE_HIGH,                // 温度过高
    DH_LOG_HDD_TEMPERATURE_LOW,                 // 温度过低
    DH_LOG_HDD_ESATA_REMOVE,                    // 移除eSATA
    DH_LOG_ALM_IN = 0x0300,                     // 外部输入报警开始
    DH_LOG_NETALM_IN,                           // 网络报警输入
    DH_LOG_ALM_END = 0x0302,                    // 外部输入报警停止
    DH_LOG_LOSS_IN,                             // 视频丢失报警开始
    DH_LOG_LOSS_END,                            // 视频丢失报警结束
    DH_LOG_MOTION_IN,                           // 动态检测报警开始
    DH_LOG_MOTION_END,                          // 动态检测报警结束
    DH_LOG_ALM_BOSHI,                           // 报警器报警输入
    DH_LOG_NET_ABORT = 0x0308,                  // 网络断开
    DH_LOG_NET_ABORT_RESUME,                    // 网络恢复
    DH_LOG_CODER_BREAKDOWN,                     // 编码器故障
    DH_LOG_CODER_BREAKDOWN_RESUME,              // 编码器故障恢复
    DH_LOG_BLIND_IN,                            // 视频遮挡
    DH_LOG_BLIND_END,                           // 视频遮挡恢复
    DH_LOG_ALM_TEMP_HIGH,                       // 温度过高
    DH_LOG_ALM_VOLTAGE_LOW,                     // 电压过低
    DH_LOG_ALM_BATTERY_LOW,                     // 电池容量不足
    DH_LOG_ALM_ACC_BREAK,                       // ACC断电
    DH_LOG_ALM_ACC_RES,
    DH_LOG_GPS_SIGNAL_LOST,                     // GPS无信号
    DH_LOG_GPS_SIGNAL_RESUME,                   // GPS信号恢复
    DH_LOG_3G_SIGNAL_LOST,                      // 3G无信号
    DH_LOG_3G_SIGNAL_RESUME,                    // 3G信号恢复
    DH_LOG_ALM_IPC_IN,                          // IPC外部报警
    DH_LOG_ALM_IPC_END,                         // IPC外部报警恢复
    DH_LOG_ALM_DIS_IN,                          // 断网报警
    DH_LOG_ALM_DIS_END,                         // 断网报警恢复
    DH_LOG_ALM_UPS_IN, 				            // UPS告警
    DH_LOG_ALM_UPS_END, 				        // UPS告警恢复
    DH_LOG_ALM_NAS_IN,				            // NAS服务器异常报警
    DH_LOG_ALM_NAS_END,				            // NAS服务器异常报警恢复
    DH_LOG_ALM_REDUNDANT_POWER_IN,              // 冗余电源告警
    DH_LOG_ALM_REDUNDANT_POWER_END,             // 冗余电源告警恢复
    DH_LOG_ALM_RECORD_FAILED_IN,				// 录像失败告警
    DH_LOG_ALM_RECORD_FAILED_END,			    // 录像失败告警恢复
    DH_LOG_ALM_VGEXCEPT_IN,				        // 存储池异常报警
    DH_LOG_ALM_VGEXCEPT_END,				    // 存储池异常报警恢复	
    DH_LOG_ALM_FANSPEED_IN,			            // 风扇报警开始
    DH_LOG_ALM_FANSPEED_END,			        // 风扇报警结束
    DH_LOG_ALM_DROP_FRAME_IN,			        // 丢帧报警开始
    DH_LOG_ALM_DROP_FRAME_END,			        // 丢帧报警结束
    DH_LOG_ALM_DISK_STATE_CHECK,		        // 磁盘预检巡检报警事件日志类型
    DH_LOG_ALARM_COAXIAL_SMOKE,		            // 同轴烟感报警事件
    DH_LOG_ALARM_COAXIAL_TEMP_HIGH,	            // 同轴温度报警事件
    DH_LOG_ALARM_COAXIAL_ALM_IN,		        // 同轴外部报警事件
    DH_LOG_INFRAREDALM_IN = 0x03a0,             // 无线报警开始
    DH_LOG_INFRAREDALM_END,                     // 无线报警结束
    DH_LOG_IPCONFLICT,                          // IP冲突
    DH_LOG_IPCONFLICT_RESUME,                   // IP恢复
    DH_LOG_SDPLUG_IN,                           // SD卡插入(DH_LOG_ITEM中的reserved值为3表示U盘插入)
    DH_LOG_SDPLUG_OUT,                          // SD卡拔出(DH_LOG_ITEM中的reserved值为3表示U盘拔出)
    DH_LOG_NET_PORT_BIND_FAILED,                // 网络端口绑定失败
    DH_LOG_HDD_BEEP_RESET,                      // 硬盘错误报警蜂鸣结束
    DH_LOG_MAC_CONFLICT,                        // MAC冲突
    DH_LOG_MAC_CONFLICT_RESUME,                 // MAC冲突恢复
    DH_LOG_ALARM_OUT,                           // 报警输出状态
    DH_LOG_ALM_RAID_STAT_EVENT,                 // RAID状态变化事件 
    DH_LOG_ABLAZE_ON,                           // 火警报警,烟感或温度
    DH_LOG_ABLAZE_OFF,                          // 火警报警 恢复
    DH_LOG_INTELLI_ALARM_PLUSE,                 // 智能脉冲型报警
    DH_LOG_INTELLI_ALARM_IN,                    // 智能报警开始
    DH_LOG_INTELLI_ALARM_END,                   // 智能报警结束
    DH_LOG_3G_SIGNAL_SCAN,                      // 3G信号检测
    DH_LOG_GPS_SIGNAL_SCAN,                     // GPS信号检测
    DH_LOG_AUTOMATIC_RECORD = 0x0400,           // 自动录像
    DH_LOG_MANUAL_RECORD = 0x0401,              // 手动录象
    DH_LOG_CLOSED_RECORD,                       // 停止录象
    DH_LOG_LOGIN = 0x0500,                      // 登录
    DH_LOG_LOGOUT,                              // 注销
    DH_LOG_ADD_USER,                            // 添加用户
    DH_LOG_DELETE_USER,                         // 删除用户
    DH_LOG_MODIFY_USER,                         // 修改用户
    DH_LOG_ADD_GROUP,                           // 添加用户组
    DH_LOG_DELETE_GROUP,                        // 删除用户组
    DH_LOG_MODIFY_GROUP,                        // 修改用户组
    DH_LOG_NET_LOGIN = 0x0508,                  // 网络用户登录
    DH_LOG_MODIFY_PASSWORD,                     // 修改密码
    DH_LOG_CLEAR = 0x0600,                      // 清除日志
    DH_LOG_SEARCHLOG,                           // 查询日志
    DH_LOG_SEARCH = 0x0700,                     // 录像查询
    DH_LOG_DOWNLOAD,                            // 录像下载
    DH_LOG_PLAYBACK,                            // 录像回放
    DH_LOG_BACKUP,                              // 备份录像文件
    DH_LOG_BACKUPERROR,                         // 备份录像文件失败
    DH_LOG_BACK_UPRT,                           // 实时备份,即光盘刻录
    DH_LOG_BACKUPCLONE,                         // 光盘复制。
    DH_LOG_DISK_CHANGED,                        // 手动换盘
    DH_LOG_IMAGEPLAYBACK,                       // 图片回放
    DH_LOG_LOCKFILE,                            // 锁定录像
    DH_LOG_UNLOCKFILE,                          // 解锁录像
    DH_LOG_ATMPOS,                              // ATM卡号叠加添加日志
    DH_PLAY_PAUSE,                              // 暂停回放
    DH_PLAY_START,                              // 正放
    LOG_PLAY_STOP,                              // 停止回放
    LOG_PLAY_BACK,                              // 倒放
    LOG_PLAY_FAST,                              // 快放
    LOG_PLAY_SLOW,                              // 慢放
    LOG_SMART_SEARCH,                           // 智能检索
    LOG_RECORD_SNAP,                            // 录像抓图
    LOG_ADD_TAG,                                // 添加标签
    LOG_DEL_TAG,                                // 删除标签
    LOG_USB_IN,                                 // 发现USB设备
    LOG_USB_OUT,                                // USB设备断开连接
    LOG_BACKUP_FILE,                            // 文件备份
    LOG_BACKUP_LOG,                             // 日志备份
    LOG_BACKUP_CONFIG,                          // 配置备份

    DH_LOG_TIME_UPDATE  = 0x0800,               // 时间同步
    DH_LOG_REMOTE_STATE = 0x0850,               // 远程日志 
    DH_LOG_USER_DEFINE = 0x0900,
    DH_LOG_TYPE_NR = 10,
} DH_LOG_TYPE;

// 扩展日志类型,对应CLIENT_QueryLogEx接口,条件(int nType = 1；参数reserved = &nType)
typedef enum _DH_NEWLOG_TYPE
{
    DH_NEWLOG_REBOOT = 0x0000,                     // 设备重启
    DH_NEWLOG_SHUT,                                // 设备关机
    DH_NEWLOG_REPORTSTOP,
    DH_NEWLOG_REPORTSTART,
    DH_NEWLOG_UPGRADE = 0x0004,                    // 设备升级
    DH_NEWLOG_SYSTIME_UPDATE = 0x0005,             // 系统时间更新
    DH_NEWLOG_GPS_TIME_UPDATE = 0x0006,            // GPS时间更新

    DH_NEWLOG_AUDIO_TALKBACK,                      // 语音对讲, true代表开启,false代表关闭    
    DH_NEWLOG_COMM_ADAPTER,                        // 透明传输, true代表开启,false代表关闭    
    DH_NEWLOG_NET_TIMING,                          // 网络校时

    DH_NEWLOG_CONFSAVE = 0x0100,                   // 保存配置
    DH_NEWLOG_CONFLOAD,                            // 读取配置
    DH_NEWLOG_FSERROR = 0x0200,                    // 文件系统错误
    DH_NEWLOG_HDD_WERR,                            // 硬盘写错误
    DH_NEWLOG_HDD_RERR,                            // 硬盘读错误
    DH_NEWLOG_HDD_TYPE,                            // 设置硬盘类型
    DH_NEWLOG_HDD_FORMAT,                          // 格式化硬盘
    DH_NEWLOG_HDD_NOSPACE,                         // 当前工作盘空间不足
    DH_NEWLOG_HDD_TYPE_RW,                         // 设置硬盘类型为读写盘
    DH_NEWLOG_HDD_TYPE_RO,                         // 设置硬盘类型为只读盘    
    DH_NEWLOG_HDD_TYPE_RE,                         // 设置硬盘类型为冗余盘
    DH_NEWLOG_HDD_TYPE_SS,                         // 设置硬盘类型为快照盘
    DH_NEWLOG_HDD_NONE,                            // 无硬盘记录日志
    DH_NEWLOG_HDD_NOWORKHDD,                       // 无工作盘(没有读写盘)
    DH_NEWLOG_HDD_TYPE_BK,                         // 设置硬盘类型为备份盘
    DH_NEWLOG_HDD_TYPE_REVERSE,                    // 设置硬盘类型为保留分区
    DH_NEWLOG_HDD_START_INFO = 0x20e,              // 记录开机时的硬盘信息
    DH_NEWLOG_HDD_WORKING_DISK,                    // 记录换盘后的工作盘号
    DH_NEWLOG_HDD_OTHER_ERROR,                     // 记录硬盘其它错误
    DH_NEWLOG_HDD_SLIGHT_ERR,                      // 硬盘存在轻微问题
    DH_NEWLOG_HDD_SERIOUS_ERR,                     // 硬盘存在严重问题
    DH_NEWLOG_HDD_NOSPACE_END,                     // 当前工作盘空间不足报警结束

    DH_NEWLOG_HDD_TYPE_RAID_CONTROL,               // Raid操作
    DH_NEWLOG_HDD_TEMPERATURE_HIGH,                // 温度过高
    DH_NEWLOG_HDD_TEMPERATURE_LOW,                 // 温度过低
    DH_NEWLOG_HDD_ESATA_REMOVE,                    // 移除eSATA

    DH_NEWLOG_ALM_IN = 0x0300,                     // 外部输入报警开始
    DH_NEWLOG_NETALM_IN,                           // 网络报警
    DH_NEWLOG_ALM_END = 0x0302,                    // 外部输入报警停止
    DH_NEWLOG_LOSS_IN,                             // 视频丢失报警开始
    DH_NEWLOG_LOSS_END,                            // 视频丢失报警结束
    DH_NEWLOG_MOTION_IN,                           // 动态检测报警开始
    DH_NEWLOG_MOTION_END,                          // 动态检测报警结束
    DH_NEWLOG_ALM_BOSHI,                           // 报警器报警输入
    DH_NEWLOG_NET_ABORT = 0x0308,                  // 网络断开
    DH_NEWLOG_NET_ABORT_RESUME,                    // 网络恢复
    DH_NEWLOG_CODER_BREAKDOWN,                     // 编码器故障
    DH_NEWLOG_CODER_BREAKDOWN_RESUME,              // 编码器故障恢复
    DH_NEWLOG_BLIND_IN,                            // 视频遮挡
    DH_NEWLOG_BLIND_END,                           // 视频遮挡恢复
    DH_NEWLOG_ALM_TEMP_HIGH,                       // 温度过高
    DH_NEWLOG_ALM_VOLTAGE_LOW,                     // 电压过低
    DH_NEWLOG_ALM_BATTERY_LOW,                     // 电池容量不足
    DH_NEWLOG_ALM_ACC_BREAK,                       // ACC断电
    DH_NEWLOG_ALM_ACC_RES,
    DH_NEWLOG_GPS_SIGNAL_LOST,                     // GPS无信号
    DH_NEWLOG_GPS_SIGNAL_RESUME,                   // GPS信号恢复
    DH_NEWLOG_3G_SIGNAL_LOST,                      // 3G无信号
    DH_NEWLOG_3G_SIGNAL_RESUME,                    // 3G信号恢复

    DH_NEWLOG_ALM_IPC_IN,                          // IPC外部报警
    DH_NEWLOG_ALM_IPC_END,                         // IPC外部报警恢复
    DH_NEWLOG_ALM_DIS_IN,                          // 断网报警
    DH_NEWLOG_ALM_DIS_END,                         // 断网报警恢复

    DH_NEWLOG_INFRAREDALM_IN = 0x03a0,             // 无线报警开始
    DH_NEWLOG_INFRAREDALM_END,                     // 无线报警结束
    DH_NEWLOG_IPCONFLICT,                          // IP冲突
    DH_NEWLOG_IPCONFLICT_RESUME,                   // IP恢复
    DH_NEWLOG_SDPLUG_IN,                           // SD卡插入
    DH_NEWLOG_SDPLUG_OUT,                          // SD卡拔出
    DH_NEWLOG_NET_PORT_BIND_FAILED,                // 网络端口绑定失败
    DH_NEWLOG_HDD_BEEP_RESET,                      // 硬盘错误报警蜂鸣结束
    DH_NEWLOG_MAC_CONFLICT,                        // MAC冲突
    DH_NEWLOG_MAC_CONFLICT_RESUME,                 // MAC冲突恢复
    DH_NEWLOG_ALARM_OUT,                           // 报警输出状态
    DH_NEWLOG_ALM_RAID_STAT_EVENT,                 // RAID状态变化事件 
    DH_NEWLOG_ABLAZE_ON,                           // 火警报警,烟感或温度
    DH_NEWLOG_ABLAZE_OFF,                          // 火警报警 恢复
    DH_NEWLOG_INTELLI_ALARM_PLUSE,                 // 智能脉冲型报警
    DH_NEWLOG_INTELLI_ALARM_IN,                    // 智能报警开始
    DH_NEWLOG_INTELLI_ALARM_END,                   // 智能报警结束
    DH_NEWLOG_3G_SIGNAL_SCAN,                      // 3G信号检测
    DH_NEWLOG_GPS_SIGNAL_SCAN,                     // GPS信号检测
    DH_NEWLOG_AUTOMATIC_RECORD = 0x0400,           // 自动录象
    DH_NEWLOG_MANUAL_RECORD,                       // 手动录象开
    DH_NEWLOG_CLOSED_RECORD,                       // 停止录象
    DH_NEWLOG_LOGIN = 0x0500,                      // 登录
    DH_NEWLOG_LOGOUT,                              // 注销
    DH_NEWLOG_ADD_USER,                            // 添加用户
    DH_NEWLOG_DELETE_USER,                         // 删除用户
    DH_NEWLOG_MODIFY_USER,                         // 修改用户
    DH_NEWLOG_ADD_GROUP,                           // 添加用户组
    DH_NEWLOG_DELETE_GROUP,                        // 删除用户组
    DH_NEWLOG_MODIFY_GROUP,                        // 修改用户组
    DH_NEWLOG_NET_LOGIN = 0x0508,                  // 网络用户登录
    DH_NEWLOG_CLEAR = 0x0600,                      // 清除日志
    DH_NEWLOG_SEARCHLOG,                           // 查询日志
    DH_NEWLOG_SEARCH = 0x0700,                     // 录像查询
    DH_NEWLOG_DOWNLOAD,                            // 录像下载
    DH_NEWLOG_PLAYBACK,                            // 录像回放
    DH_NEWLOG_BACKUP,                              // 备份录像文件
    DH_NEWLOG_BACKUPERROR,                         // 备份录像文件失败

    DH_NEWLOG_BACK_UPRT,                           // 实时备份,即光盘刻录
    DH_NEWLOG_BACKUPCLONE,                         // 光盘复制。
    DH_NEWLOG_DISK_CHANGED,                        // 手动换盘
    DH_NEWLOG_IMAGEPLAYBACK,                       // 图片回放
    DH_NEWLOG_LOCKFILE,                            // 锁定录像
    DH_NEWLOG_UNLOCKFILE,                          // 解锁录像
    DH_NEWLOG_ATMPOS,                              // ATM卡号叠加添加日志

    DH_NEWLOG_TIME_UPDATE  = 0x0800,               // 时间更新
    DH_NEWLOG_REMOTE_STATE = 0x0850,               // 远程日志 

    DH_NEWLOG_USER_DEFINE = 0x0900,
    DH_NEWLOG_TYPE_NR = 10,        
} DH_NEWLOG_TYPE;

///////////////////////////////语音对讲相关///////////////////////////////

// 语音编码类型
typedef enum __TALK_CODING_TYPE 
{
    DH_TALK_DEFAULT = 0,                        // 无头PCM
    DH_TALK_PCM = 1,                            // 带头PCM
    DH_TALK_G711a,                              // G711a
    DH_TALK_AMR,                                // AMR
    DH_TALK_G711u,                              // G711u
    DH_TALK_G726,                               // G726
    DH_TALK_G723_53,                            // G723_53
    DH_TALK_G723_63,                            // G723_63
    DH_TALK_AAC,                                // AAC
    DH_TALK_OGG,                                // OGG
    DH_TALK_G729 = 10,                          // G729
    DH_TALK_MPEG2,                               // MPEG2
    DH_TALK_MPEG2_Layer2,                        // MPEG2-Layer2
    DH_TALK_G722_1,                             // G.722.1
    DH_TALK_ADPCM = 21,                         // ADPCM
    DH_TALK_MP3   = 22,                            // MP3
    
} DH_TALK_CODING_TYPE;

// 录像文件类型
typedef enum __NET_RECORD_TYPE
{
    NET_RECORD_TYPE_ALL,                        // 所有录像
    NET_RECORD_TYPE_NORMAL,                     // 普通录像
    NET_RECORD_TYPE_ALARM,                      // 外部报警录像
    NET_RECORD_TYPE_MOTION,                     // 动检报警录像
}NET_RECORD_TYPE;

// 对讲方式
typedef enum __EM_USEDEV_MODE
{
    DH_TALK_CLIENT_MODE,                        // 设置客户端方式进行语音对讲
    DH_TALK_SERVER_MODE,                        // 设置服务器方式进行语音对讲
    DH_TALK_ENCODE_TYPE,                        // 设置语音对讲编码格式(对应DHDEV_TALKDECODE_INFO)
    DH_ALARM_LISTEN_MODE,                       // 设置报警订阅方式
    DH_CONFIG_AUTHORITY_MODE,                   // 设置通过权限进行配置管理
    DH_TALK_TALK_CHANNEL,                       // 设置对讲通道(0~MaxChannel-1)
    DH_RECORD_STREAM_TYPE,                      // 设置待查询及按时间回放的录像码流类型(0-主辅码流,1-主码流,2-辅码流)  
    DH_TALK_SPEAK_PARAM,                        // 设置语音参数,对应结构体 NET_SPEAK_PARAM
    DH_RECORD_TYPE,                             // 设置按时间录像回放及下载的录像文件类型(详见NET_RECORD_TYPE)
    DH_TALK_MODE3,                              // 设置三代设备的语音对讲参数, 对应结构体 NET_TALK_EX
    DH_PLAYBACK_REALTIME_MODE ,                 // 设置实时回放功能(0-关闭,1开启)
    DH_TALK_TRANSFER_MODE,                      // 设置语音对讲是否为转发模式, 对应结构体 NET_TALK_TRANSFER_PARAM
    DH_TALK_VT_PARAM,                           // 设置VT对讲参数, 对应结构体 NET_VT_TALK_PARAM
    DH_TARGET_DEV_ID,                           // 设置目标设备标示符, 用以查询新系统能力(非0-转发系统能力消息)
	DH_AUDIO_RECORD_LENGTH = 15,                // 设置录音缓存, 对应为一个int
} EM_USEDEV_MODE;


typedef enum __EM_TALK_DATA_TYPE
{ 
    NET_TALK_DATA_LOCAL_AUDIO = 0,              // 本地录音库采集的音频数据
    NET_TALK_DATA_RECV_AUDIO,                   // 收到的设备发过来的音频数据
    NET_TALK_DATA_RESPOND,                      // 对讲呼叫响应数据
    NET_TALK_DATA_RECV_VIDEO,                   // 收到的设备发过来的视频数据
}EM_TALK_DATA_TYPE;

typedef struct tagNET_TALK_VIDEO_FORMAT
{
    DWORD               dwSize;
    DWORD               dwCompression;          // 视频压缩格式
    int                 nFrequency;             // 视频采样频率
}NET_TALK_VIDEO_FORMAT;
// 三代设备的语音对讲参数,对应CLIENT_SetDeviceMode()的DH_TALK_MODE3命令
typedef struct tagNET_TALK_EX
{
    DWORD               dwSize;
    int                 nChannel;                               // 通道号
    int                 nAudioPort;                             // 音频传输侦听端口
    int                 nWaitTime;                              // 等待时间, 单位ms,为0则使用默认值
    HWND                hVideoWnd;                              // 可视对讲视频显示窗口
    NET_TALK_VIDEO_FORMAT stuVideoFmt;                          // 视频编码格式
    char                szMulticastAddr[DH_MAX_IPADDR_LEN_EX];  // 组播地址
    WORD                wMulticastLocalPort;                    // 组播本地端口
    WORD                wMulticastRemotePort;                   // 组播远程端口
}NET_TALK_EX;

// AMR编码类型
typedef enum __EM_ARM_ENCODE_MODE
{
    DH_TALK_AMR_AMR475 = 1,                     // AMR475编码
    DH_TALK_AMR_AMR515,                         // AMR515编码
    DH_TALK_AMR_AMR59,                          // AMR59编码
    DH_TALK_AMR_AMR67,                          // AMR67编码
    DH_TALK_AMR_AMR74,                          // AMR74编码
    DH_TALK_AMR_AMR795,                         // AMR795编码
    DH_TALK_AMR_AMR102,                         // AMR102编码
    DH_TALK_AMR_AMR122,                         // AMR122编码
} EM_ARM_ENCODE_MODE;

// 语音参数
typedef struct __NET_SPEAK_PARAM
{
    DWORD           dwSize;                     // 结构体大小
    int             nMode;                      // 0：对讲（默认模式）,1：喊话；从喊话切换到对讲要重新设置
    											// 2: 单向监听，若切换到其他模式要重新设置
    int             nSpeakerChannel;            // 扬声器通道号,喊话时有效
    BOOL            bEnableWait;                // 开启对讲时是否等待设备的响应,默认不等待.TRUE:等待;FALSE:不等待
                                                // 超时时间由CLIENT_SetNetworkParam设置,对应NET_PARAM的nWaittime字段
} NET_SPEAK_PARAM;

// 是否开启语音对讲的转发模式
typedef struct tagNET_TALK_TRANSFER_PARAM
{
    DWORD           dwSize;
    BOOL            bTransfer;                  // 是否开启语音对讲转发模式, TRUE: 开启转发, FALSE: 关闭转发
}NET_TALK_TRANSFER_PARAM;

/////////////////////////////////控制相关/////////////////////////////////

// 控制类型,对应 CLIENT_ControlDevice 接口
typedef enum _CtrlType
{
    DH_CTRL_REBOOT = 0,                            // 重启设备    
    DH_CTRL_SHUTDOWN,                              // 关闭设备
    DH_CTRL_DISK,                                  // 硬盘管理
    DH_KEYBOARD_POWER = 3,                         // 网络键盘
    DH_KEYBOARD_ENTER,
    DH_KEYBOARD_ESC,
    DH_KEYBOARD_UP,
    DH_KEYBOARD_DOWN,
    DH_KEYBOARD_LEFT,
    DH_KEYBOARD_RIGHT,
    DH_KEYBOARD_BTN0,
    DH_KEYBOARD_BTN1,
    DH_KEYBOARD_BTN2,
    DH_KEYBOARD_BTN3,
    DH_KEYBOARD_BTN4,
    DH_KEYBOARD_BTN5,
    DH_KEYBOARD_BTN6,
    DH_KEYBOARD_BTN7,
    DH_KEYBOARD_BTN8,
    DH_KEYBOARD_BTN9,
    DH_KEYBOARD_BTN10,
    DH_KEYBOARD_BTN11,
    DH_KEYBOARD_BTN12,
    DH_KEYBOARD_BTN13,
    DH_KEYBOARD_BTN14,
    DH_KEYBOARD_BTN15,
    DH_KEYBOARD_BTN16,
    DH_KEYBOARD_SPLIT,
    DH_KEYBOARD_ONE,
    DH_KEYBOARD_NINE,
    DH_KEYBOARD_ADDR,
    DH_KEYBOARD_INFO,
    DH_KEYBOARD_REC,
    DH_KEYBOARD_FN1,
    DH_KEYBOARD_FN2,
    DH_KEYBOARD_PLAY,
    DH_KEYBOARD_STOP,
    DH_KEYBOARD_SLOW,
    DH_KEYBOARD_FAST,
    DH_KEYBOARD_PREW,
    DH_KEYBOARD_NEXT,
    DH_KEYBOARD_JMPDOWN,
    DH_KEYBOARD_JMPUP,
    DH_KEYBOARD_10PLUS,
    DH_KEYBOARD_SHIFT,
    DH_KEYBOARD_BACK,               
    DH_KEYBOARD_LOGIN ,                            // 新网络键盘功能
    DH_KEYBOARD_CHNNEL ,                           // 切换视频通道
    DH_TRIGGER_ALARM_IN = 100,                     // 触发报警输入
    DH_TRIGGER_ALARM_OUT,                          // 触发报警输出
    DH_CTRL_MATRIX,                                // 矩阵控制
    DH_CTRL_SDCARD,                                // SD卡控制(IPC产品)参数同硬盘控制
    DH_BURNING_START,                              // 刻录机控制,开始刻录
    DH_BURNING_STOP,                               // 刻录机控制,结束刻录
    DH_BURNING_ADDPWD,                             // 刻录机控制,叠加密码(以'\0'为结尾的字符串,最大长度8位)
    DH_BURNING_ADDHEAD,                            // 刻录机控制,叠加片头(以'\0'为结尾的字符串,最大长度1024字节,支持分行,行分隔符'\n')
    DH_BURNING_ADDSIGN,                            // 刻录机控制,叠加打点到刻录信息(参数无)
    DH_BURNING_ADDCURSTOMINFO,                     // 刻录机控制,自定义叠加(以'\0'为结尾的字符串,最大长度1024字节,支持分行,行分隔符'\n')
    DH_CTRL_RESTOREDEFAULT,                        // 恢复设备的默认设置
    DH_CTRL_CAPTURE_START,                         // 触发设备抓图
    DH_CTRL_CLEARLOG,                              // 清除日志
    DH_TRIGGER_ALARM_WIRELESS = 200,               // 触发无线报警(IPC产品)
    DH_MARK_IMPORTANT_RECORD,                      // 标识重要录像文件
    DH_CTRL_DISK_SUBAREA,                          // 网络硬盘分区    
    DH_BURNING_ATTACH,                             // 刻录机控制,附件刻录.
    DH_BURNING_PAUSE,                              // 刻录暂停
    DH_BURNING_CONTINUE,                           // 刻录继续
    DH_BURNING_POSTPONE,                           // 刻录顺延
    DH_CTRL_OEMCTRL,                               // 报停控制
    DH_BACKUP_START,                               // 设备备份开始
    DH_BACKUP_STOP,                                // 设备备份停止
    DH_VIHICLE_WIFI_ADD,                           // 车载手动增加WIFI配置
    DH_VIHICLE_WIFI_DEC,                           // 车载手动删除WIFI配置
    DH_BUZZER_START,                               // 蜂鸣器控制开始
    DH_BUZZER_STOP,                                // 蜂鸣器控制结束
    DH_REJECT_USER,                                // 剔除用户
    DH_SHIELD_USER,                                // 屏蔽用户
    DH_RAINBRUSH,                                  // 智能交通, 雨刷控制 
    DH_MANUAL_SNAP,                                // 智能交通, 手动抓拍 (对应结构体 MANUAL_SNAP_PARAMETER)
    DH_MANUAL_NTP_TIMEADJUST,                      // 手动NTP校时
    DH_NAVIGATION_SMS,                             // 导航信息和短消息
    DH_CTRL_ROUTE_CROSSING,                        // 路线点位信息
    DH_BACKUP_FORMAT,                              // 格式化备份设备
    DH_DEVICE_LOCALPREVIEW_SLIPT,                  // 控制设备端本地预览分割(对应结构体DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)    
    DH_CTRL_INIT_RAID,                             // RAID初始化
    DH_CTRL_RAID,                                  // RAID操作
    DH_CTRL_SAPREDISK,                             // 热备盘操作
    DH_WIFI_CONNECT,                               // 手动发起WIFI连接(对应结构体WIFI_CONNECT)
    DH_WIFI_DISCONNECT,                            // 手动断开WIFI连接(对应结构体WIFI_CONNECT)
    DH_CTRL_ARMED,                                 // 布撤防操作
    DH_CTRL_IP_MODIFY,                             // 修改前端IP(对应结构体DHCTRL_IPMODIFY_PARAM)                     
    DH_CTRL_WIFI_BY_WPS,                           // wps连接wifi(对应结构体DHCTRL_CONNECT_WIFI_BYWPS)
    DH_CTRL_FORMAT_PATITION,                       // 格式化分区(对应结构体DH_FORMAT_PATITION)
    DH_CTRL_EJECT_STORAGE,                         // 手动卸载设备(对应结构体DH_EJECT_STORAGE_DEVICE)
    DH_CTRL_LOAD_STORAGE,                          // 手动装载设备(对应结构体DH_LOAD_STORAGE_DEVICE)
    DH_CTRL_CLOSE_BURNER,                          // 关闭刻录机光驱门(对应结构体 NET_CTRL_BURNERDOOR) 一般需要等6秒
    DH_CTRL_EJECT_BURNER,                          // 弹出刻录机光驱门(对应结构体 NET_CTRL_BURNERDOOR) 一般需要等4秒
    DH_CTRL_CLEAR_ALARM,                           // 消警(对应结构体 NET_CTRL_CLEAR_ALARM)
    DH_CTRL_MONITORWALL_TVINFO,                    // 电视墙信息显示(对应结构体 NET_CTRL_MONITORWALL_TVINFO)
    DH_CTRL_START_VIDEO_ANALYSE,                   // 开始视频智能分析(对应结构体 NET_CTRL_START_VIDEO_ANALYSE)
    DH_CTRL_STOP_VIDEO_ANALYSE,                    // 停止视频智能分析(对应结构体 NET_CTRL_STOP_VIDEO_ANALYSE)
    DH_CTRL_UPGRADE_DEVICE,                        // 控制启动设备升级,由设备独立完成升级过程,不需要传输升级文件
    DH_CTRL_MULTIPLAYBACK_CHANNALES,               // 切换多通道预览回放的通道(对应结构体 NET_CTRL_MULTIPLAYBACK_CHANNALES)
    DH_CTRL_SEQPOWER_OPEN,                         // 电源时序器打开开关量输出口(对应 NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_CLOSE,                        // 电源时序器关闭开关量输出口(对应 NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_OPEN_ALL,                     // 电源时序器打开开关量输出口组(对应 NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_SEQPOWER_CLOSE_ALL,                    // 电源时序器关闭开关量输出口组(对应 NET_CTRL_SEQPOWER_PARAM)
    DH_CTRL_PROJECTOR_RISE,                        // 投影仪上升(对应 NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_PROJECTOR_FALL,                        // 投影仪下降(对应 NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_PROJECTOR_STOP,                        // 投影仪停止(对应 NET_CTRL_PROJECTOR_PARAM)
    DH_CTRL_INFRARED_KEY,                          // 红外按键(对应 NET_CTRL_INFRARED_KEY_PARAM)
    DH_CTRL_START_PLAYAUDIO,                       // 设备开始播放音频文件(对应结构体 NET_CTRL_START_PLAYAUDIO)
    DH_CTRL_STOP_PLAYAUDIO,                        // 设备停止播放音频文件
    DH_CTRL_START_ALARMBELL,                       // 开启警号(对应结构体 NET_CTRL_ALARMBELL)
    DH_CTRL_STOP_ALARMBELL,                        // 关闭警号(对应结构体 NET_CTRL_ALARMBELL)
    DH_CTRL_ACCESS_OPEN,                           // 门禁控制-开门(对应结构体 NET_CTRL_ACCESS_OPEN)
    DH_CTRL_SET_BYPASS,                            // 设置旁路功能(对应结构体 NET_CTRL_SET_BYPASS)
    DH_CTRL_RECORDSET_INSERT,                      // 添加记录,获得记录集编号(对应 NET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATE,                      // 更新某记录集编号的记录(对应NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_RECORDSET_REMOVE,                      // 根据记录集编号删除某记录(对应NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_RECORDSET_CLEAR,                       // 清除所有记录集信息(对应NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_ACCESS_CLOSE,                          // 门禁控制-关门(对应结构体 NET_CTRL_ACCESS_CLOSE)
    DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET,            // 报警子系统激活设置(对应结构体NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
    DH_CTRL_FORBID_OPEN_STROBE,                    // 禁止设备端开闸(对应结构体 NET_CTRL_FORBID_OPEN_STROBE)
    DH_CTRL_OPEN_STROBE,                           // 开启道闸(对应结构体 NET_CTRL_OPEN_STROBE)
    DH_CTRL_TALKING_REFUSE,                        // 对讲拒绝接听(对应结构体 NET_CTRL_TALKING_REFUSE)
    DH_CTRL_ARMED_EX,                              // 布撤防操作(对应结构体 CTRL_ARM_DISARM_PARAM_EX), 对CTRL_ARM_DISARM_PARAM 升级,建议用这个
    DH_CTRL_REMOTE_TALK,                           // 远程对讲控制(对应结构体NET_CTRL_REMOTETALK_PARAM)
    DH_CTRL_NET_KEYBOARD = 400,                    // 网络键盘控制(对应结构体 DHCTRL_NET_KEYBOARD)
    DH_CTRL_AIRCONDITION_OPEN,                     // 打开空调(对应结构体 NET_CTRL_OPEN_AIRCONDITION)
    DH_CTRL_AIRCONDITION_CLOSE,                    // 关闭空调(对应结构体 NET_CTRL_CLOSE_AIRCONDITION)
    DH_CTRL_AIRCONDITION_SET_TEMPERATURE,          // 设定空调温度(对应结构体 NET_CTRL_SET_TEMPERATURE)
    DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE,       // 调节空调温度(对应结构体 NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETMODE,                  // 设置空调工作模式(对应结构体 NET_CTRL_ADJUST_TEMPERATURE)
    DH_CTRL_AIRCONDITION_SETWINDMODE,              // 设置空调送风模式(对应结构体 NET_CTRL_AIRCONDITION_SETMODE)
    DH_CTRL_RESTOREDEFAULT_EX ,                    // 恢复设备的默认设置新协议(对应结构体NET_CTRL_RESTORE_DEFAULT)
                                                   // 恢复配置优先使用该枚举,如果接口失败,
                                                   // 且CLIENT_GetLastError返回NET_UNSUPPORTED,再尝试使用DH_CTRL_RESTOREDEFAULT恢复配置
    DH_CTRL_NOTIFY_EVENT,                          // 向设备发送事件(对应结构体 NET_NOTIFY_EVENT_DATA)
    DH_CTRL_SILENT_ALARM_SET,                      // 无声报警设置
    DH_CTRL_START_PLAYAUDIOEX,                     // 设备开始语音播报(对应结构体 NET_CTRL_START_PLAYAUDIOEX)
    DH_CTRL_STOP_PLAYAUDIOEX,                      // 设备停止语音播报
    DH_CTRL_CLOSE_STROBE,                          // 关闭道闸(对应结构体 NET_CTRL_CLOSE_STROBE)
    DH_CTRL_SET_ORDER_STATE,                       // 设置车位预定状态(对应结构体 NET_CTRL_SET_ORDER_STATE)
    DH_CTRL_RECORDSET_INSERTEX,                    // 添加指纹记录,获得记录集编号(对应 NET_CTRL_RECORDSET_INSERT_PARAM)
    DH_CTRL_RECORDSET_UPDATEEX,                    // 更新指纹记录集编号的记录(对应NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_CAPTURE_FINGER_PRINT,                  // 指纹采集(对应结构体 NET_CTRL_CAPTURE_FINGER_PRINT)
    DH_CTRL_ECK_LED_SET,                           // 停车场出入口控制器LED设置(对应结构体 NET_CTRL_ECK_LED_SET_PARAM)
    DH_CTRL_ECK_IC_CARD_IMPORT,                    // 智能停车系统出入口机IC卡信息导入(对应结构体 NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
    DH_CTRL_ECK_SYNC_IC_CARD,                      // 智能停车系统出入口机IC卡信息同步指令,收到此指令后,设备删除原有IC卡信息(对应结构体 NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
    DH_CTRL_LOWRATEWPAN_REMOVE,                    // 删除指定无线设备(对应结构体 NET_CTRL_LOWRATEWPAN_REMOVE)
    DH_CTRL_LOWRATEWPAN_MODIFY,                    // 修改无线设备信息(对应结构体 NET_CTRL_LOWRATEWPAN_MODIFY)
	DH_CTRL_ECK_SET_PARK_INFO,                     // 智能停车系统出入口机设置车位信息(对应结构体 NET_CTRL_ECK_SET_PARK_INFO_PARAM)
    DH_CTRL_VTP_DISCONNECT,                        // 挂断视频电话(对应结构体 NET_CTRL_VTP_DISCONNECT)
    DH_CTRL_UPDATE_FILES,                          // 远程投放多媒体文件更新(对应结构体 NET_CTRL_UPDATE_FILES)
    DH_CTRL_MATRIX_SAVE_SWITCH,                    // 保存上下位矩阵输出关系(对应结构体 NET_CTRL_MATRIX_SAVE_SWITCH)
    DH_CTRL_MATRIX_RESTORE_SWITCH,                 // 恢复上下位矩阵输出关系(对应结构体 NET_CTRL_MATRIX_RESTORE_SWITCH)
    DH_CTRL_VTP_DIVERTACK,                         // 呼叫转发响应(对应结构体 NET_CTRL_VTP_DIVERTACK)	
    DH_CTRL_RAINBRUSH_MOVEONCE,                    // 雨刷来回刷一次,雨刷模式配置为手动模式时有效(对应结构体 NET_CTRL_RAINBRUSH_MOVEONCE)
    DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY,            // 雨刷来回循环刷,雨刷模式配置为手动模式时有效(对应结构体 NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    DH_CTRL_RAINBRUSH_STOPMOVE,                    // 雨刷停止刷,雨刷模式配置为手动模式时有效(对应结构体 NET_CTRL_RAINBRUSH_STOPMOVE)
    DH_CTRL_ALARM_ACK,                             // 报警事件确认(对应结构体 NET_CTRL_ALARM_ACK)
                                                   // DH_CTRL_ALARM_ACK 该操作切勿在报警回调接口中调用
    DH_CTRL_RECORDSET_IMPORT,                      // 批量导入记录集信息(对应NET_CTRL_RECORDSET_PARAM)
    DH_CTRL_DELIVERY_FILE,                         // 向视频输出口投放视频和图片文件, 楼宇对讲使用，同一时间投放(对应NET_CTRL_DELIVERY_FILE)
	DH_CTRL_FORCE_BREAKING,                        // 强制产生违章类型(对应 NET_CTRL_FORCE_BREAKING)
	DH_CTRL_RESTORE_EXCEPT,						   // 恢复除指定配置外的其他配置为默认。
	DH_CTRL_SET_PARK_INFO,						   // 设置停车信息，平台设置给相机，内容用于点阵屏显示(对应结构体 NET_CTRL_SET_PARK_INFO)
	DH_CTRL_CLEAR_SECTION_STAT,					   // 清除当前时间段内人数统计信息, 重新从0开始计算(对应结构体NET_CTRL_CLEAR_SECTION_STAT_INFO)
    DH_CTRL_DELIVERY_FILE_BYCAR,                   // 向视频输出口投放视频和图片文件, 车载使用，广告单独时间投放(对应NET_CTRL_DELIVERY_FILE_BYCAR)
	DH_CTRL_ECK_GUIDINGPANEL_CONTENT,              // 设置诱导屏显示内容(对应结构体 NET_CTRL_ECK_GUIDINGPANEL_CONTENT)
	DH_CTRL_SET_SAFE_LEVEL,						   // 设置门禁安全等级(对应结构体，pInBuf= NET_IN_SET_SAFE_LEVEL*, pOutBuf= NET_OUT_SET_SAFE_LEVEL * )
    DH_CTRL_VTP_INVITEACK,                           // 对讲请求回复(对应结构体 NET_CTRL_VTP_INVITEACK)
    DH_CTRL_ACCESS_RESET_PASSWORD,                 // 门禁控制-重置密码(对应结构体 NET_CTRL_ACCESS_RESET_PASSWORD)
    DH_CTRL_ACCESS_CALL_LIFT,                      // 门禁控制-呼梯(对应结构体 NET_CTRL_ACCESS_CALL_LIFT)
                                                   // 以下命令只在 CLIENT_ControlDeviceEx 上有效
    DH_CTRL_THERMO_GRAPHY_ENSHUTTER = 0x10000,     // 设置热成像快门启用/禁用, pInBuf= NET_IN_THERMO_EN_SHUTTER*, pOutBuf= NET_OUT_THERMO_EN_SHUTTER * 
    DH_CTRL_RADIOMETRY_SETOSDMARK,                 // 设置测温项的osd为高亮, pInBuf= NET_IN_RADIOMETRY_SETOSDMARK*, pOutBuf= NET_OUT_RADIOMETRY_SETOSDMARK *    
    DH_CTRL_AUDIO_REC_START_NAME,                  // 开启音频录音并得到录音名, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_AUDIO_REC_STOP_NAME,                   // 关闭音频录音并返回文件名称, pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
    DH_CTRL_SNAP_MNG_SNAP_SHOT,                    // 即时抓图(又名手动抓图), pInBuf = NET_IN_SNAP_MNG_SHOT *, pOutBuf = NET_OUT_SNAP_MNG_SHOT *
    DH_CTRL_LOG_STOP,                              // 强制同步缓存数据到数据库并关闭数据库, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_LOG_RESUME,                            // 恢复数据库, pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
    DH_CTRL_POS_ADD,                               // 增加一个Pos设备, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_POS_REMOVE,                            // 删除一个Pos设备, pInBuf = NET_IN_POS_REMOVE *, pOutBuf = NET_OUT_POS_REMOVE *
    DH_CTRL_POS_REMOVE_MULTI,                      // 批量删除Pos设备, pInBuf = NET_IN_POS_REMOVE_MULTI *, pOutBuf = NET_OUT_POS_REMOVE_MULTI *
    DH_CTRL_POS_MODIFY,                            // 修改一个Pos设备, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
    DH_CTRL_SET_SOUND_ALARM,                       // 触发有声报警, pInBuf = NET_IN_SOUND_ALARM *, pOutBuf = NET_OUT_SOUND_ALARM *
	DH_CTRL_AUDIO_MATRIX_SILENCE,				   // 音频举证一键静音控制(对应pInBuf = NET_IN_AUDIO_MATRIX_SILENCE, pOutBuf =  NET_OUT_AUDIO_MATRIX_SILENCE)
    DH_CTRL_MANUAL_UPLOAD_PICTURE,                 // 设置手动上传, pInBuf = NET_IN_MANUAL_UPLOAD_PICTURE *, pOutBUf = NET_OUT_MANUAL_UPLOAD_PICTURE *
    DH_CTRL_REBOOT_NET_DECODING_DEV,               // 重启网络解码设备, pInBuf = NET_IN_REBOOT_NET_DECODING_DEV *, pOutBuf = NET_OUT_REBOOT_NET_DECODING_DEV *
	DH_CTRL_SET_IC_SENDER,						   // ParkingControl 设置发卡设备, pInBuf = NET_IN_SET_IC_SENDER *, pOutBuf = NET_OUT_SET_IC_SENDER * 
    DH_CTRL_SET_MEDIAKIND,                         // 设置监视码流组成,如仅音频,仅视频,音视频 pInBuf = NET_IN_SET_MEDIAKIND *, pOutBuf = NET_OUT_SET_MEDIAKIND *
                                                   // 配合功能列表能力集使用, EN_ENCODE_CHN,2-监视支持音视频分开获取
	DH_CTRL_LOWRATEWPAN_ADD,                       // 增加无线设备信息(对应结构体 pInBuf = NET_CTRL_LOWRATEWPAN_ADD *, pOutBUf = NULL)
	DH_CTRL_LOWRATEWPAN_REMOVEALL,                 // 删除所有的无线设备信息(对应结构体 pInBuf = NET_CTRL_LOWRATEWPAN_REMOVEALL *, pOutBUf = NULL)
	DH_CTRL_SET_DOOR_WORK_MODE,                    // 设置门锁工作模式(对应结构体 pInBuf = NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE *, pOutBUf = NULL)	
    DH_CTRL_TEST_MAIL,                             // 测试邮件 pInBuf = NET_IN_TEST_MAIL *, pOutBUf = NET_OUT_TEST_MAIL *
    DH_CTRL_CONTROL_SMART_SWITCH,                  // 控制智能开关 pInBuf = NET_IN_CONTROL_SMART_SWITCH *, pOutBUf = NET_OUT_CONTROL_SMART_SWITCH *
	DH_CTRL_LOWRATEWPAN_SETWORKMODE,          	   // 设置探测器的工作模式(对应结构体pInBuf = NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE *, pOutBUf = NULL)
	DH_CTRL_COAXIAL_CONTROL_IO,					   // 发送同轴IO控制命令(对应结构体pInBuf = NET_IN_CONTROL_COAXIAL_CONTROL_IO*, pOutBUf = NET_OUT_CONTROL_COAXIAL_CONTROL_IO*)
	DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL,		// 开启无线警号 (对应结构体pInBuf = NET_IN_START_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL*)
	DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL,		// 关闭无线警号 (对应结构体pInBuf = NET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL*)
	DH_CTRL_THERMO_DO_FFC,							// 热成像FFC校准(对应结构体 pInBuf = NET_IN_THERMO_DO_FFC *,pOutBuf = NET_OUT_THERMO_DO_FFC *)
	DH_CTRL_THERMO_FIX_FOCUS,						// 热成像双目定焦调(对应结构体 pInBuf = NET_IN_THERMO_FIX_FOCUS *,pOutBuf = NET_OUT_THERMO_FIX_FOCUS *)
	DH_CTRL_SET_THIRD_CALLSTATUS,					// 设置对讲状态(对应结构体pInBuf = NET_IN_VTP_THIRDCALL_STATUS*, pOutBuf = NET_OUT_VTP_THIRDCALL_STATUS*)


	/**********LowRateWPAN控制(0x10100-0x10150)**********************************************************************************/
	DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL = 0x10100,      // 获取无线设备信号强度(对应结构体 pInBuf = NET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL *,pOutBuf = NET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL *)
} CtrlType;

#define DH_MAX_WIRELESS_DEV_NUM 80                                    //无线设备最大数量

//获取无线设备信号强度入参(对应DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL)
typedef struct tagNET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL
{
	DWORD                       dwSize;                               //结构体大小
	int                         nStartIndex;                          //开始的索引号，从0开始
	int                         nDevStateNum;                         //本次获取的设备状态条数，此值小于等于能力集中MaxPageSize字段的值
}NET_IN_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL;

//无线设备信号信息
typedef struct tagNET_WIRELESSDEVSIGNAL_INFO
{
	char                        szDevSN[32];                          //设备序列号    
	UINT                        unSignal;                             //无线信号强度百分比
	BYTE                        byReserver[512];                      //保留字节
}NET_WIRELESSDEVSIGNAL_INFO;

//获取无线设备信号强度出参(对应DH_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL)
typedef struct tagNET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL
{
	DWORD                       dwSize;                               //结构体大小
	int                         nWirelessDevNum;                      //获取无线设备数量
	NET_WIRELESSDEVSIGNAL_INFO  stuDevSignal[DH_MAX_WIRELESS_DEV_NUM];//无线设备信号强度
}NET_OUT_CTRL_LOWRATEWPAN_GETWIRELESSDEVSIGNAL;

// 保存上下位矩阵输出关系参数(对应命令DH_CTRL_MATRIX_SAVE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_SAVE_SWITCH 
{
    DWORD           dwSize;
    const char*     pszName;                        // 上下位矩阵输出关系名称
} NET_CTRL_MATRIX_SAVE_SWITCH;

// 恢复上下位矩阵输出关系参数(对应命令DH_CTRL_MATRIX_RESTORE_SWITCH)
typedef struct tagNET_CTRL_MATRIX_RESTORE_SWITCH
{
    DWORD           dwSize;
    const char*     pszName;                        // 上下位矩阵输出关系名称
} NET_CTRL_MATRIX_RESTORE_SWITCH;

// 恢复默认配置新协议输入参数
typedef struct tagNET_CTRL_RESTORE_DEFAULT
{
    DWORD               dwSize;
    const char*         szCfgNames;                     // 配置名称以'&&'为间隔,配置名参见dhconfigsdk.h的CLIENT_GetNewDevConfig和CLIENT_SetNewDevConfig接口的配置命令
}NET_CTRL_RESTORE_DEFAULT;

// 恢复相机默认设置输入参数
typedef struct tagNET_CTRL_RESTORE_EXCEPT
{
	DWORD			dwSize;
	char		 	szCfgName[DH_MAX_STRING_LEN];				// 配置名称；配置名参见dhconfigsdk.h的CLIENT_GetNewDevConfig和CLIENT_SetNewDevConfig接口的配置命令
}NET_CTRL_RESTORE_EXCEPT;

// 打开空调参数(对应命令DH_CTRL_AIRCONDITION_OPEN)
typedef struct tagNET_CTRL_OPEN_AIRCONDITION
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
} NET_CTRL_OPEN_AIRCONDITION;

// 关闭空调参数(对应命令DH_CTRL_AIRCONDITION_CLOSE)
typedef struct tagNET_CTRL_CLOSE_AIRCONDITION
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
} NET_CTRL_CLOSE_AIRCONDITION;

// 设置空调温度参数(对应命令DH_CTRL_AIRCONDITION_SET_TEMPERATURE)
typedef struct tagNET_CTRL_SET_TEMPERATURE
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
    int                 nTemperature;                   // 温度值(单位：摄氏度)
} NET_CTRL_SET_TEMPERATURE;

// 调节空调温度参数(对应命令DH_CTRL_AIRCONDITION_ADJUST_TEMPERATURE)
typedef struct tagNET_CTRL_ADJUST_TEMPERATURE
{
    DWORD               dwSize;
    char                szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
    int                 nTemperatureScale;              // 设置的值, 如-1表示温度下调一度(单位：摄氏度)
} NET_CTRL_ADJUST_TEMPERATURE;

// 设置空调工作模式参数(对应命令DH_CTRL_AIRCONDITION_SETMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETMODE
{
    DWORD                   dwSize;
    char                    szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
    EM_AIRCONDITION_MODE    emAirconditionMode;             // 空调工作模式
    int                     nTemperature;                   // 设置的值(单位：摄氏度)
} NET_CTRL_AIRCONDITION_SETMODE;

// 设置空调送风模式参数(对应命令DH_CTRL_AIRCONDITION_SETWINDMODE)
typedef struct tagNET_CTRL_AIRCONDITION_SETWINDMODE
{
    DWORD                       dwSize;
    char                        szDeviceID[DH_MAX_DEV_ID_LEN];  // 设备惟一标识符
    EM_AIRCONDITION_WINDMODE    emAirconditionWindMode;         // 空调送风模式
} NET_CTRL_AIRCONDITION_SETWINDMODE;

// IO控制命令,对应CLIENT_QueryIOControlState接口
typedef enum _IOTYPE
{
    DH_ALARMINPUT = 1,                             // 控制报警输入,对应结构体为ALARM_CONTROL
    DH_ALARMOUTPUT = 2,                            // 控制报警输出，对应结构体为ALARM_CONTROL
    DH_DECODER_ALARMOUT = 3,                       // 控制报警解码器输出，对应结构体为DECODER_ALARM_CONTROL
    DH_WIRELESS_ALARMOUT = 5,                      // 控制无线报警输出，对应结构体为ALARM_CONTROL
    DH_ALARM_TRIGGER_MODE = 7,                     // 报警触发方式（手动,自动,关闭）,使用TRIGGER_MODE_CONTROL结构体
} DH_IOTYPE;

/////////////////////////////////配置相关/////////////////////////////////

// 分辨率枚举,供DH_DSP_ENCODECAP使用
typedef enum _CAPTURE_SIZE
{
    CAPTURE_SIZE_D1,                               // 704*576(PAL)  704*480(NTSC),兼容WWxHH,下同
    CAPTURE_SIZE_HD1,                              // 352*576(PAL)  352*480(NTSC)
    CAPTURE_SIZE_BCIF,                             // 704*288(PAL)  704*240(NTSC)
    CAPTURE_SIZE_CIF,                              // 352*288(PAL)  352*240(NTSC)
    CAPTURE_SIZE_QCIF,                             // 176*144(PAL)  176*120(NTSC)
    CAPTURE_SIZE_VGA,                              // 640*480
    CAPTURE_SIZE_QVGA,                             // 320*240
    CAPTURE_SIZE_SVCD,                             // 480*480
    CAPTURE_SIZE_QQVGA,                            // 160*128
    CAPTURE_SIZE_SVGA,                             // 800*592
    CAPTURE_SIZE_XVGA,                             // 1024*768
    CAPTURE_SIZE_WXGA,                             // 1280*800
    CAPTURE_SIZE_SXGA,                             // 1280*1024  
    CAPTURE_SIZE_WSXGA,                            // 1600*1024  
    CAPTURE_SIZE_UXGA,                             // 1600*1200
    CAPTURE_SIZE_WUXGA,                            // 1920*1200
    CAPTURE_SIZE_LTF,                              // 240*192,ND1
    CAPTURE_SIZE_720,                              // 1280*720
    CAPTURE_SIZE_1080,                             // 1920*1080
    CAPTURE_SIZE_1_3M,                             // 1280*960
    CAPTURE_SIZE_2M,                               // 1872*1408,2_5M
    CAPTURE_SIZE_5M,                               // 3744*1408
    CAPTURE_SIZE_3M,                               // 2048*1536
    CAPTURE_SIZE_5_0M,                             // 2432*2050
    CPTRUTE_SIZE_1_2M,                             // 1216*1024
    CPTRUTE_SIZE_1408_1024,                        // 1408*1024
    CPTRUTE_SIZE_8M,                               // 3296*2472
    CPTRUTE_SIZE_2560_1920,                        // 2560*1920(5_1M)
    CAPTURE_SIZE_960H,                             // 960*576(PAL) 960*480(NTSC)
    CAPTURE_SIZE_960_720,                          // 960*720
    CAPTURE_SIZE_NHD,                              // 640*360
    CAPTURE_SIZE_QNHD,                             // 320*180
    CAPTURE_SIZE_QQNHD,                            // 160*90
    CAPTURE_SIZE_960_540,                          // 960*540
    CAPTURE_SIZE_640_352,                          // 640*352
    CAPTURE_SIZE_640_400,                          // 640*400
    CAPTURE_SIZE_320_192,                          // 320*192    
    CAPTURE_SIZE_320_176,                          // 320*176
	CAPTURE_SIZE_SVGA1,                            // 800*600
    CAPTURE_SIZE_NR=255  
} CAPTURE_SIZE;

// 配置文件类型,供CLIENT_ExportConfigFile接口使用
typedef enum __DH_CONFIG_FILE_TYPE
{
    DH_CONFIGFILE_ALL = 0,                         // 全部配置文件
    DH_CONFIGFILE_LOCAL,                           // 本地配置文件
    DH_CONFIGFILE_NETWORK,                         // 网络配置文件
    DH_CONFIGFILE_USER,                            // 用户配置文件
} DH_CONFIG_FILE_TYPE;

// NTP
typedef enum __DH_TIME_ZONE_TYPE
{
    DH_TIME_ZONE_0,                                // {0, 0*3600,"GMT+00:00"}
    DH_TIME_ZONE_1,                                // {1, 1*3600,"GMT+01:00"}
    DH_TIME_ZONE_2,                                // {2, 2*3600,"GMT+02:00"}
    DH_TIME_ZONE_3,                                // {3, 3*3600,"GMT+03:00"}
    DH_TIME_ZONE_4,                                // {4, 3*3600+1800,"GMT+03:30"}
    DH_TIME_ZONE_5,                                // {5, 4*3600,"GMT+04:00"}
    DH_TIME_ZONE_6,                                // {6, 4*3600+1800,"GMT+04:30"}
    DH_TIME_ZONE_7,                                // {7, 5*3600,"GMT+05:00"}
    DH_TIME_ZONE_8,                                // {8, 5*3600+1800,"GMT+05:30"}
    DH_TIME_ZONE_9,                                // {9, 5*3600+1800+900,"GMT+05:45"}
    DH_TIME_ZONE_10,                               // {10, 6*3600,"GMT+06:00"}
    DH_TIME_ZONE_11,                               // {11, 6*3600+1800,"GMT+06:30"}
    DH_TIME_ZONE_12,                               // {12, 7*3600,"GMT+07:00"}
    DH_TIME_ZONE_13,                               // {13, 8*3600,"GMT+08:00"}
    DH_TIME_ZONE_14,                               // {14, 9*3600,"GMT+09:00"}
    DH_TIME_ZONE_15,                               // {15, 9*3600+1800,"GMT+09:30"}
    DH_TIME_ZONE_16,                               // {16, 10*3600,"GMT+10:00"}
    DH_TIME_ZONE_17,                               // {17, 11*3600,"GMT+11:00"}
    DH_TIME_ZONE_18,                               // {18, 12*3600,"GMT+12:00"}
    DH_TIME_ZONE_19,                               // {19, 13*3600,"GMT+13:00"}
    DH_TIME_ZONE_20,                               // {20, -1*3600,"GMT-01:00"}
    DH_TIME_ZONE_21,                               // {21, -2*3600,"GMT-02:00"}
    DH_TIME_ZONE_22,                               // {22, -3*3600,"GMT-03:00"}
    DH_TIME_ZONE_23,                               // {23, -3*3600-1800,"GMT-03:30"}
    DH_TIME_ZONE_24,                               // {24, -4*3600,"GMT-04:00"}
    DH_TIME_ZONE_25,                               // {25, -5*3600,"GMT-05:00"}
    DH_TIME_ZONE_26,                               // {26, -6*3600,"GMT-06:00"}
    DH_TIME_ZONE_27,                               // {27, -7*3600,"GMT-07:00"}
    DH_TIME_ZONE_28,                               // {28, -8*3600,"GMT-08:00"}
    DH_TIME_ZONE_29,                               // {29, -9*3600,"GMT-09:00"}
    DH_TIME_ZONE_30,                               // {30, -10*3600,"GMT-10:00"}
    DH_TIME_ZONE_31,                               // {31, -11*3600,"GMT-11:00"}
    DH_TIME_ZONE_32,                               // {32, -12*3600,"GMT-12:00"}
} DH_TIME_ZONE_TYPE;

typedef enum _SNAP_TYPE
{
    SNAP_TYP_TIMING = 0,
    SNAP_TYP_ALARM,
    SNAP_TYP_NUM,
} SNAP_TYPE;

typedef enum _CONNECT_STATE
{
    CONNECT_STATE_UNCONNECT  = 0,	// 未连连接
    CONNECT_STATE_CONNECTING,		// 正在连接
    CONNECT_STATE_CONNECTED,		// 已连接
	CONNECT_STATE_EMPTY,			// 通道未配置，无信息
	CONNECT_STATE_CHANGED,			// 连接的设备信息有改动
    CONNECT_STATE_ERROR = 255,		// 未知设备状态
} CONNECT_STATE;

// 抓拍模式
typedef enum tagDH_TRAFFIC_SNAP_MODE
{    
    DH_TRAFFIC_SNAP_MODE_COIL = 1,                       // 线圈抓拍
    DH_TRAFFIC_SNAP_MODE_COIL_PICANALYSIS,               // 线圈抓拍, 图片分析
    DH_TRAFFIC_SNAP_MODE_STREAM,                         // 视频抓拍
    DH_TRAFFIC_SNAP_MODE_STREAM_IDENTIFY,                // 视频抓拍, 并且识别
} DH_TRAFFIC_SNAP_MODE;

// 车位灯类型
typedef enum 
{
    NET_CARPORTLIGHT_TYPE_RED,                           // 红灯
    NET_CARPORTLIGHT_TYPE_GREEN,                         // 绿灯
}NET_CARPORTLIGHT_TYPE;

// 车位灯亮灯方式
typedef enum
{
    NET_CARPORTLIGHT_MODE_OFF,                           // 灭 
    NET_CARPORTLIGHT_MODE_ON,                            // 亮
    NET_CARPORTLIGHT_MODE_GLINT,                         // 闪烁
}NET_CARPORTLIGHT_MODE;

/////////////////////////////////智能交通相关/////////////////////////////////
//黑白名单操作类型
typedef enum _EM_OPERATE_TYPE
{
    NET_TRAFFIC_LIST_INSERT,                             // 增加记录操作(对应结构体 NET_INSERT_RECORD_INFO)
    NET_TRAFFIC_LIST_UPDATE,                             // 更新记录操作(对应结构体 NET_UPDATE_RECORD_INFO)
    NET_TRAFFIC_LIST_REMOVE,                             // 删除记录操作(对应结构体 NET_REMOVE_RECORD_INFO)
    NET_TRAFFIC_LIST_MAX,
}EM_RECORD_OPERATE_TYPE ;

//车牌类型
typedef enum _EM_NET_PLATE_TYPE
{
    NET_PLATE_TYPE_UNKNOWN,
    NET_PLATE_TYPE_NORMAL,                              // "Normal" 蓝牌黑牌
    NET_PLATE_TYPE_YELLOW,                              // "Yellow" 黄牌
    NET_PLATE_TYPE_DOUBLEYELLOW,                        // "DoubleYellow" 双层黄尾牌
    NET_PLATE_TYPE_POLICE,                              // "Police" 警牌
    NET_PLATE_TYPE_ARMED,                               // "Armed" 武警牌
    NET_PLATE_TYPE_MILITARY,                            // "Military" 部队号牌
    NET_PLATE_TYPE_DOUBLEMILITARY,                      // "DoubleMilitary" 部队双层
    NET_PLATE_TYPE_SAR,                                 // "SAR" 港澳特区号牌    
    NET_PLATE_TYPE_TRAINNING,                           // "Trainning" 教练车号牌
    NET_PLATE_TYPE_PERSONAL,                            // "Personal" 个性号牌
    NET_PLATE_TYPE_AGRI,                                // "Agri" 农用牌
    NET_PLATE_TYPE_EMBASSY,                             // "Embassy" 使馆号牌
    NET_PLATE_TYPE_MOTO,                                // "Moto" 摩托车号牌
    NET_PLATE_TYPE_TRACTOR,                             // "Tractor" 拖拉机号牌
    NET_PLATE_TYPE_OFFICIALCAR,                         // "OfficialCar " 公务车
    NET_PLATE_TYPE_PERSONALCAR,                         // "PersonalCar" 私家车
    NET_PLATE_TYPE_WARCAR,                              // "WarCar"  军用
    NET_PLATE_TYPE_OTHER,                               // "Other" 其他号牌
	NET_PLATE_TYPE_CIVILAVIATION,                       // "Civilaviation" 民航号牌
	NET_PLATE_TYPE_BLACK,                               // "Black" 黑牌
	NET_PLATE_TYPE_PURENEWENERGYMICROCAR,               // "PureNewEnergyMicroCar" 纯电动新能源小车
	NET_PLATE_TYPE_MIXEDNEWENERGYMICROCAR,              // "MixedNewEnergyMicroCar" 混合新能源小车
	NET_PLATE_TYPE_PURENEWENERGYLARGECAR,               // "PureNewEnergyLargeCar" 纯电动新能源大车
	NET_PLATE_TYPE_MIXEDNEWENERGYLARGECAR,              // "MixedNewEnergyLargeCar" 混合新能源大车
}EM_NET_PLATE_TYPE;


//车牌颜色
typedef enum _EM_NET_PLATE_COLOR_TYPE
{
    NET_PLATE_COLOR_OTHER,                              // 其他颜色
    NET_PLATE_COLOR_BLUE,                               // 蓝色 "Blue"
    NET_PLATE_COLOR_YELLOW,                             // 黄色 "Yellow"    
    NET_PLATE_COLOR_WHITE,                              // 白色 "White"
    NET_PLATE_COLOR_BLACK,                              // 黑色 "Black"
    NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT,           // 黄底黑字 "YellowbottomBlackText"
    NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT,             // 蓝底白字 "BluebottomWhiteText" 
    NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT,            // 黑底白字 "BlackBottomWhiteText"
	NET_PLATE_COLOR_SHADOW_GREEN,						// 渐变绿 "ShadowGreen"
	NET_PLATE_COLOR_YELLOW_GREEN,						// 黄绿双拼 "YellowGreen"
}EM_NET_PLATE_COLOR_TYPE;


//车辆类型
typedef enum _EM_NET_VEHICLE_TYPE
{
    NET_VEHICLE_TYPE_UNKNOW,                            // 未知类型
    NET_VEHICLE_TYPE_MOTOR,                             // "Motor" 机动车           
    NET_VEHICLE_TYPE_NON_MOTOR,                         // "Non-Motor"非机动车        
    NET_VEHICLE_TYPE_BUS,                               // "Bus"公交车        
    NET_VEHICLE_TYPE_BICYCLE,                           // "Bicycle" 自行车        
    NET_VEHICLE_TYPE_MOTORCYCLE,                        // "Motorcycle"摩托车        
    NET_VEHICLE_TYPE_UNLICENSEDMOTOR,                   // "UnlicensedMotor": 无牌机动车
    NET_VEHICLE_TYPE_LARGECAR,                          // "LargeCar"  大型汽车
    NET_VEHICLE_TYPE_MICROCAR,                          // "MicroCar" 小型汽车
    NET_VEHICLE_TYPE_EMBASSYCAR,                        // "EmbassyCar" 使馆汽车
    NET_VEHICLE_TYPE_MARGINALCAR,                       // "MarginalCar" 领馆汽车
    NET_VEHICLE_TYPE_AREAOUTCAR,                        // "AreaoutCar" 境外汽车
    NET_VEHICLE_TYPE_FOREIGNCAR,                        // "ForeignCar" 外籍汽车
    NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE,            // "DualTriWheelMotorcycle"两、三轮摩托车
    NET_VEHICLE_TYPE_LIGHTMOTORCYCLE,                   // "LightMotorcycle" 轻便摩托车
    NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE,                 // "EmbassyMotorcycle "使馆摩托车
    NET_VEHICLE_TYPE_MARGINALMOTORCYCLE,                // "MarginalMotorcycle "领馆摩托车
    NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE,                 // "AreaoutMotorcycle "境外摩托车
    NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE,                 // "ForeignMotorcycle "外籍摩托车
    NET_VEHICLE_TYPE_FARMTRANSMITCAR,                   // "FarmTransmitCar" 农用运输车
    NET_VEHICLE_TYPE_TRACTOR,                           // "Tractor" 拖拉机
    NET_VEHICLE_TYPE_TRAILER,                           // "Trailer"  挂车
    NET_VEHICLE_TYPE_COACHCAR,                          // "CoachCar"教练汽车
    NET_VEHICLE_TYPE_COACHMOTORCYCLE,                   // "CoachMotorcycle "教练摩托车
    NET_VEHICLE_TYPE_TRIALCAR,                          // "TrialCar" 试验汽车
    NET_VEHICLE_TYPE_TRIALMOTORCYCLE,                   // "TrialMotorcycle "试验摩托车
    NET_VEHICLE_TYPE_TEMPORARYENTRYCAR,                 // "TemporaryEntryCar"临时入境汽车
    NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE,          // "TemporaryEntryMotorcycle"临时入境摩托车
    NET_VEHICLE_TYPE_TEMPORARYSTEERCAR,                 // "TemporarySteerCar"临时行驶车
    NET_VEHICLE_TYPE_PASSENGERCAR,                      // "PassengerCar" 客车
    NET_VEHICLE_TYPE_LARGETRUCK,                        // "LargeTruck" 大货车
    NET_VEHICLE_TYPE_MIDTRUCK,                          // "MidTruck" 中货车
    NET_VEHICLE_TYPE_SALOONCAR,                         // "SaloonCar" 轿车
    NET_VEHICLE_TYPE_MICROBUS,                          // "Microbus"面包车
    NET_VEHICLE_TYPE_MICROTRUCK,                        // "MicroTruck"小货车
    NET_VEHICLE_TYPE_TRICYCLE,                          // "Tricycle"三轮车
    NET_VEHICLE_TYPE_PASSERBY,                          // "Passerby" 行人
}EM_NET_VEHICLE_TYPE;


//车身颜色
typedef enum _EM_NET_VEHICLE_COLOR_TYPE
{
    NET_VEHICLE_COLOR_OTHER,                            //其他颜色    
    NET_VEHICLE_COLOR_WHITE,                            //白色	"White"
    NET_VEHICLE_COLOR_BLACK,                            //黑色	"Black"
    NET_VEHICLE_COLOR_RED,                              //红色	"Red"
    NET_VEHICLE_COLOR_YELLOW,                           //黄色	"Yellow"
    NET_VEHICLE_COLOR_GRAY,                             //灰色	"Gray"
    NET_VEHICLE_COLOR_BLUE,                             //蓝色	"Blue"
    NET_VEHICLE_COLOR_GREEN,                            //绿色	"Green"
    NET_VEHICLE_COLOR_PINK,                             //粉红色 "Pink"
    NET_VEHICLE_COLOR_PURPLE,                           //紫色	"Purple"
    NET_VEHICLE_COLOR_BROWN,                            //棕色	"Brown"
}EM_NET_VEHICLE_COLOR_TYPE;

//布控类型
typedef enum _EM_NET_TRAFFIC_CAR_CONTROL_TYPE
{
    NET_CAR_CONTROL_OTHER,
    NET_CAR_CONTROL_OVERDUE_NO_CHECK,                   // 过期未检	"OverdueNoCheck"
    NET_CAR_CONTROL_BRIGANDAGE_CAR,                     // 盗抢车辆	"BrigandageCar"
    NET_CAR_CONTROL_BREAKING,                           // 违章		"Breaking"
    NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE,                // 肇事逃逸  "CausetroubleEscape"
}EM_NET_TRAFFIC_CAR_CONTROL_TYPE;

typedef enum _EM_NET_AUTHORITY_TYPE
{
    NET_AUTHORITY_UNKNOW,
    NET_AUTHORITY_OPEN_GATE,                            //开闸权限
}EM_NET_AUTHORITY_TYPE;

typedef enum _EM_NET_RECORD_TYPE
{
    NET_RECORD_UNKNOWN,

    NET_RECORD_TRAFFICREDLIST,                          // 交通白名单账户记录
                                                        // 查询条件对应 FIND_RECORD_TRAFFICREDLIST_CONDITION 结构体
                                                        // 记录信息对应 NET_TRAFFIC_LIST_RECORD 结构体
    NET_RECORD_TRAFFICBLACKLIST,                        // 交通黑名单账号记录
                                                        // 查询条件对应 FIND_RECORD_TRAFFICREDLIST_CONDITION 结构体
                                                        // 记录信息对应 NET_TRAFFIC_LIST_RECORD 结构体
    NET_RECORD_BURN_CASE,                               // 刻录案件记录
                                                        // 查询条件对应 FIND_RECORD_BURN_CASE_CONDITION 结构体
                                                        // 记录信息对应 NET_BURN_CASE_INFO 结构体
    NET_RECORD_ACCESSCTLCARD,                           // 门禁卡
                                                        // 查询条件对应 FIND_RECORD_ACCESSCTLCARD_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORDSET_ACCESS_CTL_CARD 结构体
    NET_RECORD_ACCESSCTLPWD,                            // 门禁密码
                                                        // 查询条件对应 FIND_RECORD_ACCESSCTLPWD_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORDSET_ACCESS_CTL_PWD
    NET_RECORD_ACCESSCTLCARDREC,                        // 门禁出入记录（必须同时按卡号和时间段查询,建议用NET_RECORD_ACCESSCTLCARDREC_EX查询）
                                                        // 查询条件对应 FIND_RECORD_ACCESSCTLCARDREC_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORDSET_ACCESS_CTL_CARDREC 结构体
    NET_RECORD_ACCESSCTLHOLIDAY,                        // 假日记录集
                                                        // 查询条件对应 FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORDSET_HOLIDAY 结构体
    NET_RECORD_TRAFFICFLOW_STATE,                       // 查询交通流量记录
                                                        // 查询条件对应 FIND_RECORD_TRAFFICFLOW_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_TRAFFIC_FLOW_STATE 结构体
    NET_RECORD_VIDEOTALKLOG,                            // 通话记录
                                                        // 查询条件对应 FIND_RECORD_VIDEO_TALK_LOG_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_VIDEO_TALK_LOG 结构体
    NET_RECORD_REGISTERUSERSTATE,                       // 状态记录
                                                        // 查询条件对应 FIND_RECORD_REGISTER_USER_STATE_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_REGISTER_USER_STATE 结构体
    NET_RECORD_VIDEOTALKCONTACT,                        // 联系人记录
                                                        // 查询条件对应 FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_VIDEO_TALK_CONTACT 结构体

	NET_RECORD_ANNOUNCEMENT,							//公告记录
                                                        //查询条件对应 FIND_RECORD_ANNOUNCEMENT_CONDITION 结构体
                                                        //记录信息对应 NET_RECORD_ANNOUNCEMENT_INFO 结构体
														
														
	NET_RECORD_ALARMRECORD,							    //报警记录
                                                        //查询条件对应 FIND_RECORD_ALARMRECORD_CONDITION 结构体
                                                        //记录信息对应 NET_RECORD_ALARMRECORD_INFO 结构体
														

    NET_RECORD_COMMODITYNOTICE,                         // 下发商品记录
                                                        // 查询条件对应 FIND_RECORD_COMMODITY_NOTICE_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_COMMODITY_NOTICE 结构体
                                                        
    NET_RECORD_HEALTHCARENOTICE,                        // 就诊信息记录
                                                        // 查询条件对应 FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_HEALTH_CARE_NOTICE 结构体

    NET_RECORD_ACCESSCTLCARDREC_EX,                     // 门禁出入记录(可选择部分条件查询,建议替代NET_RECORD_ACCESSCTLCARDREC)
                                                        // 查询条件对应 FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX 结构体
                                                        // 记录信息对应 NET_RECORDSET_ACCESS_CTL_CARDREC 结构体

    NET_RECORD_GPS_LOCATION,                            // GPS位置信息记录, 只实现import和clear
                                                        // 记录信息对应 NET_RECORD_GPS_LOCATION_INFO 结构体

	NET_RECORD_RESIDENT,                                // 公租房租户信息
														// 查询条件对应 FIND_RECORD_RESIDENT_CONDTION结构体
                                                        // 记录信息对应 NET_RECORD_RESIDENT_INFO 结构体

	NET_RECORD_SENSORRECORD,                            // 监测量数据记录
														// 查询条件对应 FIND_RECORD_SENSORRECORD_CONDITION 结构体
														// 记录信息对应 NET_RECORD_SENSOR_RECORD 结构体
	
	NET_RECORD_ACCESSQRCODE,							//开门二维码记录集
														//记录信息对应 NET_RECORD_ACCESSQRCODE_INFO 结构体
														
	NET_RECORD_ELECTRONICSTAG,							// 电子车牌查询
														// 查询条件对应FIND_RECORD_ELECTRONICSTAG_CONDITION 结构体
                                                        // 记录信息对应NET_RECORD_ELECTRONICSTAG_INFO 结构体

    NET_RECORD_ACCESS_BLUETOOTH,						// 蓝牙开门记录集
                                                        // 查询条件对应 FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_ACCESS_BLUETOOTH_INFO 结构体

    NET_RECORD_ACCESS_ALARMRECORD,                      // 门禁报警记录集
                                                        // 查询条件对应 FIND_NET_RECORD_ACCESS_ALARMRECORD_INFO_CONDITION 结构体
                                                        // 记录信息对应 NET_RECORD_ACCESS_ALARMRECORD_INFO 结构体
}EM_NET_RECORD_TYPE;

// 时间类型
typedef enum
{
    NET_TIME_TYPE_ABSLUTE,                                  // 绝对时间
    NET_TIME_TYPE_RELATIVE,                                 // 相对时间,相对于视频文件头帧为时间基点,头帧对应于UTC(0000-00-00 00:00:00)
}EM_TIME_TYPE;

// 颜色类型
typedef enum
{
    NET_COLOR_TYPE_RED,                                     // 红色
    NET_COLOR_TYPE_YELLOW,                                  // 黄色
    NET_COLOR_TYPE_GREEN,                                   // 绿色
    NET_COLOR_TYPE_CYAN,                                    // 青色
    NET_COLOR_TYPE_BLUE,                                    // 蓝色
    NET_COLOR_TYPE_PURPLE,                                  // 紫色
    NET_COLOR_TYPE_BLACK,                                   // 黑色
    NET_COLOR_TYPE_WHITE,                                   // 白色
    NET_COLOR_TYPE_MAX,
}EM_COLOR_TYPE;

/////////////////////////////////人脸识别相关/////////////////////////////////
// 人员类型
typedef enum 
{
    PERSON_TYPE_UNKNOWN,
    PERSON_TYPE_NORMAL,                                     // 普通人员
    PERSON_TYPE_SUSPICION,                                  // 嫌疑人员
	PERSON_TYPE_THIEF,                                      // 小偷
	PERSON_TYPE_VIP,                                        // 重要人员
	PERSON_TYPE_FATECHECK,                                  // 打假人员
	PERSON_TYPE_STAFF,                                      // 工作人员
}EM_PERSON_TYPE;

// 证件类型
typedef enum
{
    CERTIFICATE_TYPE_UNKNOWN,
    CERTIFICATE_TYPE_IC,                                    // 身份证
    CERTIFICATE_TYPE_PASSPORT,                              // 护照 
	CERTIFICATE_TYPE_MILITARY,								// 军官证
}EM_CERTIFICATE_TYPE;

// 人脸识别数据库操作
typedef enum
{
    NET_FACERECONGNITIONDB_UNKOWN, 
    NET_FACERECONGNITIONDB_ADD,                         // 添加人员信息和人脸样本,如果人员已经存在,图片数据和原来的数据合并
    NET_FACERECONGNITIONDB_DELETE,                      // 删除人员信息和人脸样本
    NET_FACERECONGNITIONDB_MODIFY,                      // 修改人员信息和人脸样本,人员的UID标识必填 
    NET_FACERECONGNITIONDB_DELETE_BY_UID,               // 通过UID删除人员信息和人脸样本
}EM_OPERATE_FACERECONGNITIONDB_TYPE;

// 人脸对比模式
typedef enum 
{
    NET_FACE_COMPARE_MODE_UNKOWN,
    NET_FACE_COMPARE_MODE_NORMAL,                       // 正常
    NET_FACE_COMPARE_MODE_AREA,                         // 指定人脸区域组合区域
    NET_FACE_COMPARE_MODE_AUTO,                         // 智能模式,算法根据人脸各个区域情况自动选取组合 
}EM_FACE_COMPARE_MODE;

// 人脸区域
typedef enum
{
    NET_FACE_AREA_TYPE_UNKOWN,
    NET_FACE_AREA_TYPE_EYEBROW,                         // 眉毛
    NET_FACE_AREA_TYPE_EYE,                             // 眼睛
    NET_FACE_AREA_TYPE_NOSE,                            // 鼻子
    NET_FACE_AREA_TYPE_MOUTH,                           // 嘴巴
    NET_FACE_AREA_TYPE_CHEEK,                           // 脸颊
}EM_FACE_AREA_TYPE;

// 人脸数据类型
typedef enum
{
    NET_FACE_DB_TYPE_UNKOWN,
    NET_FACE_DB_TYPE_HISTORY,                           // 历史数据库,存放的是检测出的人脸信息,一般没有包含人脸对应人员信息
    NET_FACE_DB_TYPE_BLACKLIST,                         // 黑名单数据库(现在用作注册库)
    NET_FACE_DB_TYPE_WHITELIST,                         // 白名单数据库,废弃
    NET_FACE_DB_TYPE_ALARM  ,                           // 报警库, 废弃
    NET_FACE_DB_TYPE_PASSERBY,							// 路人库
}EM_FACE_DB_TYPE;

// 人脸识别事件类型
typedef enum 
{
    NET_FACERECOGNITION_ALARM_TYPE_UNKOWN,
    NET_FACERECOGNITION_ALARM_TYPE_ALL,                // 黑白名单
    NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST,          // 黑名单
    NET_FACERECOGNITION_ALARM_TYPE_WHITELIST,          // 白名单
}EM_FACERECOGNITION_ALARM_TYPE;

// 人脸识别人脸类型
typedef enum
{
    EM_FACERECOGNITION_FACE_TYPE_UNKOWN,
    EM_FACERECOGNITION_FACE_TYPE_ALL,                  // 所有人脸   
    EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS,          // 识别成功
    EM_FACERECOGNITION_FACE_TYPE_REC_FAIL,             // 识别失败
}EM_FACERECOGNITION_FACE_TYPE;

// 帧类型枚举值  
typedef enum __EM_FRAME_TYPE
{
    EM_FRAME_UNKOWN,                                   // 未知类型 
    EM_FRAME_TYPE_MOTION,                              // 动检帧,对应帧信息结构体 NET_MOTION_FRAME_INFO
}EM_FRAME_TYPE;

/////////////////////////////////淘汰类型/////////////////////////////////

// 配置类型,目前使用该枚举的接口已淘汰,请不要使用
typedef enum _CFG_INDEX
{
    CFG_GENERAL = 0,                                    // 普通
    CFG_COMM,                                           // 串口
    CFG_NET,                                            // 网络
    CFG_RECORD,                                         // 录像
    CFG_CAPTURE,                                        // 图像设置
    CFG_PTZ,                                            // 云台
    CFG_DETECT,                                         // 动态检测
    CFG_ALARM,                                          // 报警
    CFG_DISPLAY,                                        // 显示
    CFG_RESERVED,                                       // 保留,使类型连贯
    CFG_TITLE = 10,                                     // 通道标题
    CFG_MAIL = 11,                                      // 邮件功能
    CFG_EXCAPTURE = 12,                                 // 预览图像设置
    CFG_PPPOE = 13,                                     // pppoe设置
    CFG_DDNS = 14,                                      // DDNS设置
    CFG_SNIFFER    = 15,                                // 网络监视捕获设置
    CFG_DSPINFO    = 16,                                // 编码能力信息
    CFG_COLOR = 126,                                    // 颜色配置信息
    CFG_ALL,                                            // 保留
} CFG_INDEX;

/************************************************************************
 ** 结构体定义
 ***********************************************************************/

//显示区域相对于原显示窗口的坐标
typedef struct
{
    double                dleft;                  //显示区域相对于原显示窗口的左坐标 
    double                dright;                 //显示区域相对于原显示窗口的右坐标
    double                dtop;                   //显示区域相对于原显示窗口的上坐标
    double                dbottom;                //显示区域相对于原显示窗口的下坐标
} DH_DISPLAYRREGION;
// 时间


typedef struct tagNET_TIME
{
    DWORD                dwYear;                  // 年
    DWORD                dwMonth;                 // 月
    DWORD                dwDay;                   // 日
    DWORD                dwHour;                  // 时
    DWORD                dwMinute;                // 分
    DWORD                dwSecond;                // 秒
} NET_TIME,*LPNET_TIME;

typedef struct tagNET_TIME_EX
{
    DWORD                dwYear;                  // 年
    DWORD                dwMonth;                 // 月
    DWORD                dwDay;                   // 日
    DWORD                dwHour;                  // 时
    DWORD                dwMinute;                // 分
    DWORD                dwSecond;                // 秒
    DWORD                dwMillisecond;           // 毫秒
    DWORD                dwUTC;                   // utc时间(获取时0表示无效，非0有效   下发无效)
    DWORD				 dwReserved[1];			  // 预留字段
} NET_TIME_EX,*LPNET_TIME_EX;

typedef struct tagUTCTime
{
	unsigned int		utc;					  // utc时间
	unsigned int		tolerance;				  // 容差，表示容许设置时间和当前差多少秒内不做修改 (下发时用到)
	char				reserved[8];			  // 预留字段
}NET_UTCTIME, *LPNET_UTCTIME;

// 日志信息里的时间定义
typedef struct _DHDEVTIME
{
    DWORD                second:6;                // 秒    1-60        
    DWORD                minute:6;                // 分    1-60        
    DWORD                hour:5;                  // 时    1-24        
    DWORD                day:5;                   // 日    1-31        
    DWORD                month:4;                 // 月    1-12        
    DWORD                year:6;                  // 年    2000-2063    
} DHDEVTIME, *LPDHDEVTIME;

typedef struct tagRANGE
{
    float               fMax;                               // 最大值
    float               fMin;                               // 最小值
    BOOL                abStep;                             // 是否启用步长
    float               fStep;                              // 步长
    BOOL                abDefault;                          // 是否启用默认值
    float               fDefault;                           // 默认值
    char reserved[16];
} RANGE;

//平场自动校正周期范围
typedef struct tagNET_FFCPERIOD_RANGE
{
	int                 nMaxN;                              // 最大值(NTSC制式)
	int                 nMaxP;                              // 最大值(PAL制式)
	int                 nMin;                               // 最小值
	int                 nStep;                              // 步长
	BYTE reserved[16];
} NET_FFCPERIOD_RANGE;


// 回调数据(异步接口)
typedef struct __NET_CALLBACK_DATA 
{
    int                  nResultCode;            // 返回码；0：成功
    char                 *pBuf;                  // 接收数据, 缓冲是由用户开辟的,从接口形参传入，大小为nRetLen
    int                  nRetLen;                // 接收长度
    LLONG                lOperateHandle;         // 操作句柄
    void*                userdata;               // 操作对应用户参数
    char                 reserved[16];
} NET_CALLBACK_DATA, *LPNET_CALLBACK_DATA;

///////////////////////////////监视相关定义///////////////////////////////

// 回调视频数据帧的帧参数结构体
typedef struct _tagVideoFrameParam
{
    BYTE                 encode;                 // 编码类型
    BYTE                 frametype;              // I = 0, P = 1, B = 2...
    BYTE                 format;                 // PAL - 0, NTSC - 1
    BYTE                 size;                   // CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
                                                 // SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15, LFT - 16, 720 - 17, 1080 - 18 ,1_3M-19
												 // 2M-20, 5M-21;当size=255时，成员变量width,height 有效
    DWORD                fourcc;                 // 如果是H264编码则总为0，否则值为*( DWORD*)"DIVX"，即0x58564944
    WORD				 width;					 // 宽，单位是像素，当size=255时有效
	WORD				 height;				 // 高，单位是像素，当size=255时有效
    NET_TIME             struTime;               // 时间信息
} tagVideoFrameParam;

// 回调音频数据帧的帧参数结构体
typedef struct _tagCBPCMDataParam
{
    BYTE                channels;                // 声道数
    BYTE                samples;                 // 采样 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
    BYTE                depth;                   // 采样深度 取值8或者16等。直接表示
    BYTE                param1;                  // 0 - 指示无符号,1-指示有符号
    DWORD               reserved;                // 保留
} tagCBPCMDataParam;

// 转码帧数据类型
typedef enum tagEM_STREAMCONVERT_FRAMEDATA_TYPE
{	
	EM_STREAMCONVERT_FRAMEDATA_UNKNOWN,					// 未知
	EM_STREAMCONVERT_FRAMEDATA_VIDEO,					// 视频帧
	EM_STREAMCONVERT_FRAMEDATA_AUDIO,					// 音频帧	
} EM_STREAMCONVERT_FRAMEDATA_TYPE;

// 转码流数据信息
typedef struct tagNET_STREAMCONVERT_INFO
{
	EM_STREAMCONVERT_FRAMEDATA_TYPE		emDataType;		// 转码帧数据类型
	void*								pFrameInfo;		// 帧信息
														// 当emDataType 为 EM_STREAMCONVERT_FRAMEDATA_VIDEO 时，对应 tagVideoFrameParam 结构体
														// 当emDataType 为 EM_STREAMCONVERT_FRAMEDATA_AUDIO 时，对应 tagCBPCMDataParam 结构体
}NET_STREAMCONVERT_INFO;

// 通道画面字幕叠加的数据结构
typedef struct _DH_CHANNEL_OSDSTRING
{
    BOOL                bEnable;                            // 使能
    DWORD               dwPosition[MAX_STRING_LINE_LEN];    //各行字符的位置　用1-9整数表示,与小键盘位置对应
                                                            // 7左上    8上        9右上
                                                            // 4左      5中        6右
                                                            // 1左下    2下        3右下
    char                szStrings[MAX_STRING_LINE_LEN][MAX_PER_STRING_LEN];    // 最多六行字符,每行最多20个字节
} DH_CHANNEL_OSDSTRING;

//回调YUV数据的参数结构体
typedef struct _tagCBYUVDataParam
{
    long                nWidth;                 // 图象的宽
    long                nHeight;                // 图象的高
    NET_TIME            stNetTime;              // 码流中的时间
    DWORD               reserved[2];            // 保留
} tagCBYUVDataParam;

///////////////////////////////回放相关定义///////////////////////////////
// 录像查询类型
typedef enum tagEmQueryRecordType
{
    EM_RECORD_TYPE_ALL              = 0,            // 所有录像
    EM_RECORD_TYPE_ALARM            = 1,            // 外部报警录像
    EM_RECORD_TYPE_MOTION_DETECT    = 2,            // 动态检测报警录像
    EM_RECORD_TYPE_ALARM_ALL        = 3,            // 所有报警录像
    EM_RECORD_TYPE_CARD             = 4,            // 卡号查询
    EM_RECORD_TYPE_CONDITION        = 5,            // 按条件查询
    EM_RECORD_TYPE_JOIN             = 6,            // 组合查询
    EM_RECORD_TYPE_CARD_PICTURE     = 8,            // 按卡号查询图片,HB-U、NVS等使用
    EM_RECORD_TYPE_PICTURE          = 9,            // 查询图片,HB-U、NVS等使用
    EM_RECORD_TYPE_FIELD            = 10,           // 按字段查询
    EM_RECORD_TYPE_INTELLI_VIDEO   = 11,           // 智能录像查询
    EM_RECORD_TYPE_NET_DATA         = 15,           // 查询网络数据,金桥网吧等使用
    EM_RECORD_TYPE_TRANS_DATA       = 16,           // 查询透明串口数据录像
    EM_RECORD_TYPE_IMPORTANT        = 17,           // 查询重要录像
    EM_RECORD_TYPE_TALK_DATA        = 18,           // 查询录音文件
    EM_RECORD_TYPE_POS				= 19,			// POS录像

    EM_RECORD_TYPE_INVALID          = 256,          // 无效的查询类型
    
}EM_QUERY_RECORD_TYPE;

// 录像文件信息
typedef struct tagNET_RECORDFILE_INFO
{
    unsigned int        ch;                         // 通道号
    char                filename[124];              // 文件名
    unsigned int        framenum;                   // 文件总帧数
    unsigned int        size;                       // 文件长度, 单位为Kbyte
    NET_TIME            starttime;                  // 开始时间
    NET_TIME            endtime;                    // 结束时间
    unsigned int        driveno;                    // 磁盘号(区分网络录像和本地录像的类型,0－127表示本地录像,其中64表示光盘1,128表示网络录像)
    unsigned int        startcluster;               // 起始簇号
    BYTE                nRecordFileType;            // 录象文件类型  0：普通录象；1：报警录象；2：移动检测；3：卡号录象；4：图片, 5: 智能录像, 19: POS录像, 255:所有录像
    BYTE                bImportantRecID;            // 0:普通录像 1:重要录像
    BYTE                bHint;                      // 文件定位索引(nRecordFileType==4<图片>时,bImportantRecID<<8 +bHint ,组成图片定位索引 )
    BYTE                bRecType;                   // 0-主码流录像 1-辅码1流录像 2-辅码流2 3-辅码流3录像	
} NET_RECORDFILE_INFO, *LPNET_RECORDFILE_INFO;

// 浓缩录像文件信息
typedef struct tagNET_SynopsisFileInfo
{
    DWORD               dwSize;                     // 该结构体大小
    char                szFileName[MAX_PATH];       // 文件名,例如C:\a.dav
    NET_TIME            stuStartTime;               // 开始时间
    NET_TIME            stuEndTime;                 // 结束时间
    unsigned int        nTaskID;                    // 在服务器里的标示,与文件名2选1使用
    BYTE                bFileType;                  // 1-视频浓缩录像文件,2-视频浓缩源文件
    BYTE                byMode;                     // 下载模式: 0-按文件下载, 1-按时间下载, 2-按文件偏移下载
    BYTE                bReserved[2];
    unsigned int        nFileLength;                // 文件大小,单位:KB
    unsigned int        nStartFileOffset;           // 起始文件偏移, 单位: KB
    unsigned int        nEndFileOffset;             // 结束文件偏移, 单位: KB
    int                 nChannel;                   // 通道号, NVR回放专用(没有TaskID), 对浓缩服务器无效
    int                 nCluster;                   // 簇号, NVR回放专用(没有TaskID), 对浓缩服务器无效
}NET_SYNOPSISFILE_INFO, *LPNET_SYNOPSISFILE_INFO;

// 回放数据回调函数原形
// pBuffer: 数据缓冲区，内存由SDK内部申请释放
// 若设备传过来的码流是不加密的,dwDataType:0-不加密的录像文件原始数据
// 若设备传过来的码流是加密的,dwDataType: 0-解密后的大华私有码流(帧数据）,2-加密的原始码流   
typedef int (CALLBACK *fDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

typedef struct __NET_MULTI_PLAYBACK_PARAM 
{
    DWORD                      dwSize; 
    int                        nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM]; // 预览通道号
    int                        nChannelNum;                             // 预览通道数 
    int                        nType;                                   // 回放文件类型,0：普通录象；1：报警录象；2：移动检测；3：卡号录象；4：图片
    NET_TIME                   stStartTime;                             // 回放开始时间
    NET_TIME                   stEndTime;                               // 回放结束时间
    int                        nFPS;                                    // 帧率,1~25
    int                        nBitRate;                                // 码流值,192~1024
    char                       szResolution[DH_MAX_CAPTURE_SIZE_NUM];   // 分辨率,"D1"、"HD1"、"2CIF"、"CIF"、"QCIF"   
    int                        nWaitTime;                               // 超时等待时间 
    HWND                       hWnd;                                    // 视频播放窗口句柄
    fDataCallBack              fDownLoadDataCallBack;                   // 视频数据回调
    LDWORD                     dwDataUser;                              // 
}NET_MULTI_PLAYBACK_PARAM;

// 某月的各天是否存在录像的状态信息
typedef struct
{
    BYTE        flag[32];           //某月内的各天是否存在录像的状态掩码,0表示没有,1表示有。
    BYTE        Reserved[64];       //保留
}NET_RECORD_STATUS, *LPNET_RECORD_STATUS;

// 异步查询结果回调函数原形,
// nError = 0 表示查询成功;
// nError = 1 表示内存申请失败;
// nError = 2 表示超时, 即超时时间内未查完指定时间段的情况, pFileinfos,nFileNum返回已查到的录像列表;
// nError = 3 表示设备返回数据校验不通过;
// nError = 4 发送查询请求失败
// nError = 5 参数错误
// nError = 6 打开通道失败
// nError = 7 无权限
typedef void (CALLBACK *fQueryRecordFileCallBack)(LLONG lQueryHandle, LPNET_RECORDFILE_INFO pFileinfos, int nFileNum, int nError, void *pReserved, LDWORD dwUser);

// 是否合并录像
typedef enum tagNET_EM_COMBINATION_MODE
{
	EM_COMBINATION_MODE_DEFAULT = 0,					// 默认为合并
	EM_COMBINATION_MODE_YES,							// 合并
	EM_COMBINATION_MODE_NO,								// 不合并
}NET_EM_COMBINATION_MODE;

// CLIENT_StartQueryRecordFile接口输入参数
typedef struct tagNET_IN_START_QUERY_RECORDFILE
{ 
    DWORD               dwSize;                            // 结构体大小, 调用者必须初始化该字段
    int                 nChannelId;                        // 待查询通道号, 从0开始
    int                 nRecordFileType;                   // 待查询录像类型, 详见 EM_QUERY_RECORD_TYPE 类型
    int                 nStreamType;                       // 查询码流类型,0-主辅码流,1-主码流,2-辅码流
    NET_TIME            stStartTime;                       // 查询起始时间
    NET_TIME            stEndTime;                         // 查询结束时间
    char*               pchCardid;                         // 卡号信息，仅当按照卡号查询时有效，由用户分配内存
														   // 如果nRecordFileType = 4或5或10,内存大小不超过256字节
														   // 如果nRecordFileType = 8,内存大小不超过20字节
    int                 nWaitTime;                         // 超时等待时间,单位ms 
    fQueryRecordFileCallBack cbFunc;                       // 查询结果回调函数 
    LDWORD              dwUser;                            // 用户信息
	BOOL				bByTime;						   // 是否根据时间查询
	NET_EM_COMBINATION_MODE	emCombination;				   // 查询结果是否合并录像文件
}NET_IN_START_QUERY_RECORDFILE;

typedef struct tagNET_OUT_START_QUERY_RECORDFILE
{
    DWORD                dwSize;                           // 结构体大小
    LLONG                lQueryHandle;                     // 返回句柄    
}NET_OUT_START_QUERY_RECORDFILE;

// 回放进度回调函数原形
// dwDownLoadSize == -1 表示用户回放或者下载进度完成
// dwDownLoadSize ==- 2 表示用户没有回放或者下载操作权限
typedef void (CALLBACK *fDownLoadPosCallBack)(LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, LDWORD dwUser);

// 对象目标类型
typedef enum tagEM_OBJECT_TYPE
{
	EM_OBJECT_TYPE_UNKNOWN    = -1,         // 未知
	EM_OBJECT_TYPE_FACE,                    // 人脸
	EM_OBJECT_TYPE_HUMAN,                   // 人体
	EM_OBJECT_TYPE_VECHILE,                 // 机动车
	EM_OBJECT_TYPE_NOMOTOR,                 // 非机动车
	EM_OBJECT_TYPE_ALL,                     // 所有类型
} EM_OBJECT_TYPE;


// 事件信息
typedef struct tagEVENT_INFO
{
	int                 nEvent;								// 事件类型,参见智能事件类型，如 EVENT_IVS_ALL
	EM_OBJECT_TYPE		arrayObejctType[16];				// 支持的物体类型，当前支持 EM_OBJECT_TYPE_HUMAN, EM_OBJECT_TYPE_VECHILE, EM_OBJECT_TYPE_NOMOTOR, EM_OBJECT_TYPE_ALL
	int					nObjectCount;						// szObejctType 数量
	BYTE				byReserved[512];					// 预留字段
}EVENT_INFO;


// 录像回放入参信息
typedef struct tagNET_IN_PLAY_BACK_BY_TIME_INFO
{
    NET_TIME            stStartTime;                       // 开始时间
    NET_TIME            stStopTime;                        // 结束时间
    HWND                hWnd;                              // 播放窗格, 可为NULL
    fDownLoadPosCallBack cbDownLoadPos;                    // 进度回调
    LDWORD              dwPosUser;                         // 进度回调用户信息
    fDataCallBack       fDownLoadDataCallBack;             // 数据回调
    LDWORD              dwDataUser;                        // 数据回调用户信息
    int                 nPlayDirection;                    // 播放方向, 0:正放; 1:倒放;
    int                 nWaittime;                         // 接口超时时间, 目前倒放使用
	EVENT_INFO*			pstuEventInfo;				   	   // 事件信息（定制），用户分配内存，不用时赋值为NULL
	UINT				nEventInfoCount;				   // pstuEventInfo 个数，最大为 16
    BYTE                bReserved[1012];                   // 预留字段
}NET_IN_PLAY_BACK_BY_TIME_INFO;

// 录像回放出参信息
typedef struct tagNET_OUT_PLAY_BACK_BY_TIME_INFO
{
    BYTE                bReserved[1024];                   // 预留字节
}NET_OUT_PLAY_BACK_BY_TIME_INFO;

// 录像回放速度
typedef enum tagEM_PLAY_BACK_SPEED
{
	EM_PLAY_BACK_SPEED_SLOW_16 = -4,               // 1/16倍慢放
	EM_PLAY_BACK_SPEED_SLOW_8,                     // 1/8倍慢放
	EM_PLAY_BACK_SPEED_SLOW_4,                     // 1/4倍慢放
	EM_PLAY_BACK_SPEED_SLOW_2,                     // 1/2倍慢放
	EM_PLAY_BACK_SPEED_NORMAL = 0,                 // 正常速度
	EM_PLAY_BACK_SPEED_FAST_2,                     // 2倍快放
	EM_PLAY_BACK_SPEED_FAST_4,                     // 4倍快放
	EM_PLAY_BACK_SPEED_FAST_8,                     // 8倍快放
	EM_PLAY_BACK_SPEED_FAST_16,                    // 16倍快放
}EM_PLAY_BACK_SPEED;

typedef struct
{
    unsigned short      left;                        // 0~8192
    unsigned short      right;                       // 0~8192
    unsigned short      top;                         // 0~8192
    unsigned short      bottom;                      // 0~8192
} MotionDetectRect;

// 智能回放信息
typedef struct 
{
    MotionDetectRect    motion_rect;               // 动检帧检索区域
    NET_TIME            stime;                     // 回放的开始时间
    NET_TIME            etime;                     // 回放的结束时间
    BYTE                bStart;                    // 开始停止命令: 1,开始,2:停止
    BYTE                reserved[116];
} IntelligentSearchPlay, *LPIntelligentSearchPlay;

// 最早录像时间
typedef struct  
{
    int                 nChnCount;                  // 通道数目
    NET_TIME            stuFurthestTime[16];        // 最早录像时间,有效值为前面0 到 (nChnCount-1)个.如果某通道没有录象的话,最早录象时间全为0
    DWORD               dwFurthestTimeAllSize;      // 当通道个数大于16时,使用。表示下面pStuFurthestTimeAll这块内存大小。
    NET_TIME*           pStuFurthestTimeAll;        // 当通道个数大于16时,使用。此部分内存需要用户申请,申请大小为(通道个数*sizeof(NET_TIME))。
    BYTE                bReserved[376];             // 保留字段
} NET_FURTHEST_RECORD_TIME;

// CLIENT_FindFrameInfo 接口输入参数
typedef struct __NET_IN_FIND_FRAMEINFO_PRAM
{
    DWORD                 dwSize;                   // 结构体大小 
    BOOL                  abFileName;               // 文件名是否作为有效的查询条件,若文件名有效,则不用填充文件信息（stRecordInfo）
    char                  szFileName[MAX_PATH];     // 文件名
    NET_RECORDFILE_INFO   stuRecordInfo;            // 文件信息
    DWORD                 dwFramTypeMask;           // 帧类型掩码,FRAME_TYPE_MOTION 动检帧;  FRAME_TYPE_HUMAN动检帧(人); FRAME_TYPE_VEHICLE动检帧(车)
}NET_IN_FIND_FRAMEINFO_PRAM;

// CLIENT_FindFrameInfo 接口输出参数
typedef struct __NET_OUT_FIND_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // 结构体大小 
    LLONG                 lFindHandle;          // 文件查找句柄
}NET_OUT_FIND_FRAMEINFO_PRAM;

// 动检帧信息
typedef struct __NET_MOTION_FRAME_INFO
{
    DWORD                 dwSize;               // 结构体大小
    NET_TIME              stuTime;              // 当前帧,时间戳 
    int                   nMotionRow;           // 动态检测区域的行数
    int                   nMotionCol;           // 动态检测区域的列数
    BYTE                  byRegion[DH_MOTION_ROW][DH_MOTION_COL];// 检测区域,最多32*32块区域
    int					  nHumanMotionRow;		// 人动态检测区域的行数
    int					  nHumanMotionCol;	    // 人动态检测区域的列数
    BYTE				  byHumanRegion[DH_MOTION_ROW][DH_MOTION_COL]; // 人检测区域, 最多32*32块区域
    int					  nVehicleMotionRow;	// 车动态检测区域的行数
    int					  nVehicleMotionCol;	// 车动态检测区域的列数
    BYTE				  byVehicleRegion[DH_MOTION_ROW][DH_MOTION_COL]; // 车检测区域, 最多32*32块区域
}NET_MOTION_FRAME_INFO;

// 文件帧信息
typedef struct __NET_FILE_FRAME_INFO
{
    DWORD                 dwSize;               // 结构体大小
    int                   nChannelId;           // 通道号
    NET_TIME              stuStartTime;         // 开始时间
    NET_TIME              stuEndTime;           // 结束时间
    WORD                  wRecType;             // 0-主码流录像 1-辅码1流录像 2-辅码流2 3-辅码流3录像
    WORD                  wFameType;            // 帧类型,详见EM_FRAME_TYPE
    void*                 pFramInfo;            // 对应类型帧信息,空间由用户申请,建议申请内存大小为sizeof(NET_MOTION_FRAME_INFO)
}NET_FILE_FRAME_INFO;

// CLIENT_FindNextFrameInfo 接口输入参数
typedef struct __NET_IN_FINDNEXT_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // 结构体大小  
    int                   nFramCount;           // 待查询帧条数,0,表示查询符合查询条件的所有帧信息
}NET_IN_FINDNEXT_FRAMEINFO_PRAM;

// CLIENT_FindNextFrameInfo 接口输出参数
typedef struct __NET_OUT_FINDNEXT_FRAMEINFO_PRAM
{
    DWORD                 dwSize;               // 结构体大小 
    NET_FILE_FRAME_INFO*  pFramInfos;           // 帧信息,由用户申请空间,空间大小为 sizeof(NET_FILE_FRAME_INFO) * nMaxFramCount
    int                   nMaxFramCount;        // 用户申请的帧信息个数
    int                   nRetFramCount;        // 实际返回的帧信息个数
}NET_OUT_FINDNEXT_FRAMEINFO_PRAM;

#define	MAX_LABEL_ARRAY		1024

// 标签数组
typedef struct tagNET_FILE_STREAM_TAG_INFO
{
	DWORD				dwSize;									// 结构体大小
	NET_TIME			stuTime;								// 标签时间
	char				szContext[DH_COMMON_STRING_64];			// 标签内容，中文必须使用utf8编码
	char				szUserName[DH_COMMON_STRING_32];		// 用户名，中文必须使用utf8编码，EVS定制增加
	char				szChannelName[DH_COMMON_STRING_64];		// 通道名称，中文必须使用utf8编码，EVS定制增加
	int 				nDuration;							    // 打标的录像持续时间，单位秒
} NET_FILE_STREAM_TAG_INFO;

// 文件类型
typedef enum tagNET_FILE_STREAM_TYPE
{
	NET_FILE_STREAM_TYPE_UNKNOWN = 0,				// 未知
	NET_FILE_STREAM_TYPE_NORMAL,					// 普通
	NET_FILE_STREAM_TYPE_ALARM,						// 报警
	NET_FILE_STREAM_TYPE_DETECTION,					// 动检
} NET_FILE_STREAM_TYPE;

// 查询到的标签信息
typedef struct tagNET_FILE_STREAM_TAG_INFO_EX
{
	DWORD					dwSize;	
	NET_TIME				stuTime;									// 标签所对于视频的时间，精确到秒
	int						nMillisecond;								// 毫秒
	int						nSequence;									// 视频序列号
	char					szContext[DH_COMMON_STRING_64];				// 标签内容，中文必须使用utf8编码
	NET_TIME				stuStartTime;								// 录像文件开始时间
	NET_TIME				stuEndTime;									// 录像文件结束时间
	NET_FILE_STREAM_TYPE	emType;										// 文件类型
	char					szUserName[DH_COMMON_STRING_32];			// 用户名，中文必须使用utf8编码，EVS定制增加
	char					szChannelName[DH_COMMON_STRING_64];			// 通道名称，中文必须使用utf8编码，EVS定制增加
	int						nDuration;								    // 打标的录像持续时间，单位秒
} NET_FILE_STREAM_TAG_INFO_EX;


// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags 接口输入参数
typedef struct tagNET_IN_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;								// 结构体大小 
	int							nArrayCount;						// 标签数组个数
	NET_FILE_STREAM_TAG_INFO*	pstuTagInfo;						// 标签数组，各项内容关系为"且", 用户分配内存,大小为sizeof(NET_FILE_STREAM_TAG_INFO)*nArrayCount						
} NET_IN_FILE_STREAM_TAGS_INFO;

// CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags 接口输出参数
typedef struct tagNET_OUT_FILE_STREAM_TAGS_INFO
{
	DWORD						dwSize;					// 结构体大小 
} NET_OUT_FILE_STREAM_TAGS_INFO;


// CLIENT_FileStreamGetTags 接口输入参数
typedef struct tagNET_IN_FILE_STREAM_GET_TAGS_INFO
{
	DWORD					dwSize;					// 结构体大小 
} NET_IN_FILE_STREAM_GET_TAGS_INFO;

// CLIENT_FileStreamGetTags / CLIENT_FileStreamfilterTags 接口输出参数
typedef struct tagNET_OUT_FILE_STREAM_GET_TAGS_INFO
{
	DWORD							dwSize;								// 结构体大小 
	int								nMaxNumber;							// 标签数组最大个数
	int								nRetTagsNumber;						// 标签数组实际返回的个数
	NET_FILE_STREAM_TAG_INFO_EX*	pstuTagInfo;						// 标签数组
} NET_OUT_FILE_STREAM_GET_TAGS_INFO;


// CLIENT_FileStreamFilterTags 接口输入参数
typedef struct tagNET_IN_FILE_STREAM_FILTER_TAGS_INFO
{
	DWORD						dwSize;									// 结构体大小 
	char						szContext[DH_COMMON_STRING_64];			// 标签内容，中文必须使用utf8编码
	char						szUserName[DH_COMMON_STRING_32];		// 用户名，中文必须使用utf8编码，EVS定制增加
	char						szChannelName[DH_COMMON_STRING_64];		// 通道名称，中文必须使用utf8编码，EVS定制增加			
} NET_IN_FILE_STREAM_FILTER_TAGS_INFO;

// CLIENT_FileStreamfilterTags 接口输出参数
// typedef struct tagNET_OUT_FILE_STREAM_FILTER_TAGS_INFO
// {
// 	DWORD							dwSize;								// 结构体大小 
// 	NET_FILE_STREAM_TAG_INFO_EX		stuTagInfo[MAX_LABEL_ARRAY];		// 标签数组
// 	int								nRetTagsCount;						// 实际返回的标签信息个数
// } NET_OUT_FILE_STREAM_FILTER_TAGS_INFO;

// 子标签信息
typedef struct tagNET_TAGMANAGER_SUB_TAG_INFO
{
	NET_TIME					stuTime;								// 子标签时间
	char						szSubTagName[DH_COMMON_STRING_64];		// 子标签名字
	BYTE						byReserved[512];						// 保留字段
}NET_TAGMANAGER_SUB_TAG_INFO;

// 标签信息。该标签有开始和结束时间，与 NET_FILE_STREAM_TAG_INFO_EX 不同
typedef struct tagNET_TAGMANAGER_TAG_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// 标签内容	
	NET_TIME					stuStartTime;							// 录像标签开始时间
	NET_TIME					stuEndTime;								// 录像标签结束时间
	int							nSubTagVaildNum;						// 子标签有效个数
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// 子标签数组
	BYTE						byReserved[1024];						// 保留字段
}NET_TAGMANAGER_TAG_INFO;

// 标签查询的条件信息
typedef struct tagNET_FINDTAGS_CONDITION_INFO
{
	char						szContext[DH_COMMON_STRING_64];			// 标签内容	
	BYTE						byReserved[1024];						// 保留字段
}NET_FINDTAGS_CONDITION_INFO;

// 查询标签信息, CLIENT_FileStreamFindTags 输入参数
typedef struct tagNET_IN_FINDTAGS_INFO
{
	DWORD							dwSize;
	BOOL							bConditionEnable;					// 为True时, stuCondition有效, lToken无效; 为False时, stuCondition无效, lToken有效
	NET_FINDTAGS_CONDITION_INFO		stuCondition;						// 查询条件，第一次查询时使用
	UINT							lToken;								// 查询句柄，第二次查询时开始使用，由第一次的 NET_OUT_FINDTAGS_INFO 获取
	int								nOffset;							// 查询偏移量
	int								nCount;								// 单次查询数量，不超过60
}NET_IN_FINDTAGS_INFO;

// // 查询标签信息, CLIENT_FileStreamFindTags 输出参数
typedef struct tagNET_OUT_FINDTAGS_INFO
{
	DWORD							dwSize;
	UINT							lToken;									// 查询句柄，第一次查询返回
	int								nTotal;									// 设备返回的记录总数
	int								nMaxTagsNumber;							// 标签数组(pstuTagInfo)最大个数, 不小于 NET_IN_FINDTAGS_INFO 的nCount字段 
	int								nRetTagsNumber;							// 标签数组(pstuTagInfo)实际返回的个数
	NET_TAGMANAGER_TAG_INFO*		pstuTagInfo;							// 标签数组指针, 用户分配内存, 大小为sizeof(NET_TAGMANAGER_TAG_INFO)*nMaxTagsNumber
}NET_OUT_FINDTAGS_INFO;

// 标签状态
typedef struct tagNET_TAGMANAGER_TAGSTATE_INFO
{
	int							nChannel;								// 通道号
	char						szContext[DH_COMMON_STRING_64];			// 标签内容,废弃,请使用szContextEx	
	NET_TIME					stuStartTime;							// 标签开始时间
	int							nSubTagVaildNum;						// 子标签(stuSubTag)有效个数
	NET_TAGMANAGER_SUB_TAG_INFO stuSubTag[MAX_SUB_TAG_NUM];				// 子标签数组
    char						szContextEx[DH_COMMON_STRING_256];		// 标签内容扩展
	BYTE						byReserved[768];						// 保留字段 
}NET_TAGMANAGER_TAGSTATE_INFO;

// 获取设备打标签状态, CLIENT_TagManagerGetTagState 输入参数
typedef struct tagNET_IN_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;
}NET_IN_TAGMANAGER_GETTAGSTATE_INFO;

// 获取设备打标签状态, CLIENT_TagManagerGetTagState 输出参数
typedef struct tagNET_OUT_TAGMANAGER_GETTAGSTATE_INFO
{
	DWORD							dwSize;                             // 结构体大小 
	int								nState;								// 打标签状态, 0未打标签, 1正在打标签
	int								nMaxTagStaeNumber;					// 标签数组(pstuTagStateInfo)的最大个数
	int								nRetTagStaeNumber;					// 标签数组(pstuTagStateInfo)的实际返回的个数
	NET_TAGMANAGER_TAGSTATE_INFO*	pstuTagStateInfo;					// 标签数组的指针, 用户分配内存, 大小为sizeof(NET_TAGMANAGER_TAGSTATE_INFO)*nMaxTagStaeNumber
}NET_OUT_TAGMANAGER_GETTAGSTATE_INFO;

// 开始打标签, CLIENT_TagManagerStartTag 输入参数
typedef struct tagNET_IN_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;                                 // 结构体大小 
	int							nChannel;								// 通道号
	char						szContext[DH_COMMON_STRING_64];			// 标签内容	
    char						szContextEx[DH_COMMON_STRING_256];		// 标签内容扩展
    bool                        bIsUsingContextEx;                      // 扩展标签是否有用
}NET_IN_TAGMANAGER_STARTTAG_INFO;

// 开始打标签, CLIENT_TagManagerStartTag 输出参数
typedef struct tagNET_OUT_TAGMANAGER_STARTTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_STARTTAG_INFO;

// 打子标签, CLIENT_TagManagerSetSubTag 输入参数
typedef struct tagNET_IN_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// 通道号
	char						szSubTagName[DH_COMMON_STRING_64];		// 子标签名字	
}NET_IN_TAGMANAGER_SETSUBTAG_INFO;

// 打子标签, CLIENT_TagManagerSetSubTag 输出参数
typedef struct tagNET_OUT_TAGMANAGER_SETSUBTAG_INFO
{
	DWORD						dwSize;
}NET_OUT_TAGMANAGER_SETSUBTAG_INFO;

// 停止打标签, CLIENT_TagManagerStopTag 输入参数
typedef struct tagNET_IN_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;
	int							nChannel;								// 通道号
}NET_IN_TAGMANAGER_STOPTAG_INFO;

// 停止打标签, CLIENT_TagManagerStopTag 输出参数
typedef struct tagNET_OUT_TAGMANAGER_STOPTAG_INFO
{
	DWORD						dwSize;             
}NET_OUT_TAGMANAGER_STOPTAG_INFO;

// 获取标签查询能力, CLIENT_TagManagerGetCaps 输入参数
typedef struct tagNET_IN_TAGMANAGER_GETCAPS_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
}NET_IN_TAGMANAGER_GETCAPS_INFO;

// 获取标签查询能力, CLIENT_TagManagerGetCaps 输出参数
typedef struct tagNET_OUT_TAGMANAGER_GETCAPS_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
    UINT                        nMaxCount;                              // 每次最大查询条数
}NET_OUT_TAGMANAGER_GETCAPS_INFO;

// 开始查询标签信息, CLIENT_TagManagerStartFind  输入参数
typedef struct tagNET_IN_TAGMANAGER_STARTFIND_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
    int                         nChannel;                               // 通道
    char						szContext[DH_COMMON_STRING_256];		// 标签内容
    NET_TIME                    stuStartTime;                           // 开始时间
    NET_TIME                    stuEndTime;                             // 结束时间
}NET_IN_TAGMANAGER_STARTFIND_INFO;

// 开始查询标签信息, CLIENT_TagManagerStartFind 输出参数
typedef struct tagNET_OUT_TAGMANAGER_STARTFIND_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
    int                         nTotalCount;                            // 查询返回的条数
}NET_OUT_TAGMANAGER_STARTFIND_INFO;

// 获取标签查询结果信息, CLIENT_TagManagerDoFind  输入参数
typedef struct tagNET_IN_TAGMANAGER_DOFIND_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
    int                         nBeginNumber;                           // 起始查询编号
    int                         nCount;                                 // 查询数量, 最大请参考CLIENT_TagManagerGetCaps返回的设备查询能力
}NET_IN_TAGMANAGER_DOFIND_INFO;

// 子标签信息
typedef struct tagNET_FINDSUBTAG_INFO
{
    NET_TIME                    stuStartTime;                           // 子标签开始时间
    char                        szSubTagName[DH_COMMON_STRING_64];      // 子标签内容
    BYTE                        byReserved[128];                        // 保留字节
}NET_FINDSUBTAG_INFO;

// 录像标签信息
typedef struct tagNET_FINDTAG_INFO
{
    char						szContext[DH_COMMON_STRING_256];		// 标签内容
    NET_TIME                    stuStartTime;                           // 开始时间
    NET_TIME                    stuEndTime;                             // 结束时间
    int                         nSubtagInfoCount;                       // 子标签信息个数
    NET_FINDSUBTAG_INFO         stuSubTagInfo[20];                      // 子标签信息
    BYTE                        byReserved[1020];                       // 保留字节
}NET_FINDTAG_INFO;

// 获取标签查询结果信息, CLIENT_TagManagerDoFind 输出参数
typedef struct tagNET_OUT_TAGMANAGER_DOFIND_INFO
{
    DWORD						dwSize;                                 // 结构体大小 
    UINT                        nMaxTagInfoCount;                       // 本次查询最多可以接受到标签数量，用户预先分配好的pstuTagInfo内存个数
    UINT                        nRetTagInfoCount;                       // 设备返回的实际标签数量，返回0或者小于CLIENT_TagManagerDoFind查询的Count都代表查询结束
    NET_FINDTAG_INFO*           pstuTagInfo;                            // 查找的标签信息，需要用户预先分配好内存
}NET_OUT_TAGMANAGER_DOFIND_INFO;

///////////////////////////////报警相关定义///////////////////////////////

// 普通报警信息
typedef struct
{
    int                  channelcount;
    int                  alarminputcount;
    unsigned char        alarm[16];                // 外部报警
    unsigned char        motiondection[16];        // 动态检测
    unsigned char        videolost[16];            // 视频丢失
} NET_CLIENT_STATE;

// 普通报警信息
typedef struct
{
    int                  channelcount;
    int                  alarminputcount;
    unsigned char        alarm[32];                // 外部报警
    unsigned char        motiondection[32];        // 动态检测
    unsigned char        videolost[32];            // 视频丢失
    BYTE                 bReserved[32];
} NET_CLIENT_STATE_EX;

// 外部报警状态信息对应结构体
typedef struct
{
    DWORD                dwSize;
    int                  alarminputcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //每一个DWORD按位表示32通道的报警状态, 0-表示无报警, 1-表示有报警
}NET_CLIENT_ALARM_STATE;

// 视频丢失报警状态信息对应结构体
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //每一个DWORD按位表示32通道的报警状态, 0-表示无报警, 1-表示有报警
}NET_CLIENT_VIDEOLOST_STATE;

// 动态检测报警状态信息对应结构体
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //每一个DWORD按位表示32通道的报警状态, 0-表示无报警, 1-表示有报警
}NET_CLIENT_MOTIONDETECT_STATE;

// 视频遮挡报警状态信息对应结构体
typedef struct
{
    DWORD                dwSize;
    int                  channelcount;
    DWORD                dwAlarmState[DH_MAX_CHANMASK]; //每一个DWORD按位表示32通道的报警状态, 0-表示无报警, 1-表示有报警
}NET_CLIENT_VIDEOBLIND_STATE;

// 查询 动态检测报警状态详细信息对应结构体
typedef struct
{
    DWORD               dwSize;
    int                 nChannelID;                 // 通道号
    BOOL                bAlarm;                     // 是否报警 TRUE/FALSE
    int                 nLevel;                     // 报警级别,单位千分之,以动检发生小格数除以总小格数计算
}NET_CLIENT_DETAILEDMOTION_STATE;

// 报警IO控制
typedef struct 
{
    unsigned short       index;                    // 端口序号
    unsigned short       state;                    // 端口状态，0 - 关闭，1 - 打开
} ALARM_CONTROL;

// 触发方式
typedef struct
{
    unsigned short       index;                    // 端口序号
    unsigned short       mode;                     // 触发方式(0关闭1手动2自动);不设置的通道,sdk默认将保持原来的设置。
    BYTE                 bReserved[28];            
} TRIGGER_MODE_CONTROL;

// 报警解码器控制
typedef struct 
{
    int                 decoderNo;               // 报警解码器号,从0开始
    unsigned short      alarmChn;                // 报警输出口,从0开始
    unsigned short      alarmState;              // 报警输出状态；1：打开,0：关闭
} DECODER_ALARM_CONTROL;

// 呼叫无应答报警事件
typedef struct __ALARM_NO_RESPONSE_INFO
{
    DWORD               dwSize;
    char                szCallID[DH_MAX_CALLID];                             //Call ID
}ALARM_NO_RESPONSE_INFO;

// 报警上传功能的报警信息
typedef struct  
{
    DWORD               dwAlarmType;                            // 报警类型，dwAlarmType = DH_UPLOAD_EVENT时，dwAlarmMask和bAlarmDecoderIndex是无效的
    DWORD               dwAlarmMask;                            // 报警信息掩码，按位表示各报警通道状态
    char                szGlobalIP[DH_MAX_IPADDR_LEN];          // 客户端IP地址
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];   // 客户端域名
    int                 nPort;                                  // 报警上传时客户端连接的端口
    char                szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];    // 报警发生的时间
    BYTE                bAlarmDecoderIndex;                     // 表示第几个报警解码器，dwAlarmType = DH_UPLOAD_DECODER_ALARM 才有效.
    BYTE                bChannelIndex;                          // 通道掩码起始值(0,1,2...)大于0有效,和 dwHighAlarmMask 共同表示高于32通道的报警状态
                                                                // 如 bChannelIndex=1,表示dwHighAlarmMask为通道33-64的报警状态
    BYTE                bReserved[2];
    DWORD               dwHighAlarmMask;                        // 高于32通道的报警信息掩码,按位表示各报警通道状态
    BYTE                bReservedSpace[8];
} NEW_ALARM_UPLOAD;

// 报警中心: pir 设备检查报警
typedef struct tagALARM_UPLOAD_PIRDETECTION_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRDETECTION_INFO;

// 报警中心: pir 设备防拆报警
typedef struct tagALARM_UPLOAD_PIRTAMPER_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRTAMPER_INFO;

// 报警中心: pir 设备光线遮挡报警
typedef struct tagALARM_UPLOAD_PIRCLOAK_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRCLOAK_INFO;

// 报警中心: pir 设备震动报警
typedef struct tagALARM_UPLOAD_PIRSHOCK_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRSHOCK_INFO;

// 报警中心: pir 设备传感器故障报警
typedef struct tagALARM_UPLOAD_PIRFAILURE_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRFAILURE_INFO;

// 报警中心: pir 设备电池电量低报警
typedef struct tagALARM_UPLOAD_PIRBATTERYLOW_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRBATTERYLOW_INFO;

// 报警中心: pir 设备信号丢失报警
typedef struct tagALARM_UPLOAD_PIRMISSINGCALL_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_PIRMISSINGCALL_INFO;

// 报警中心: 视频虚焦事件
typedef struct tagALARM_UPLOAD_VIDEO_UNFOCUS_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_VIDEO_UNFOCUS_INFO;

// 报警中心: PIR报警事件
typedef struct tagALARM_UPLOAD_ALARMPIR_INFO
{
	int				nIndex;						// 序列号
	NET_TIME_EX		UTC;						// 事件发生的时间
	char			szName[DH_EVENT_NAME_LEN];	// 事件名称
	int				nAction;					// 事件动作, 0表示脉冲事件,1表示事件开始,2表示事件结束;	
	BYTE			byReserved[1024];       	// 保留 
} ALARM_UPLOAD_ALARMPIR_INFO;

// 报警中心心跳事件
typedef struct tagALARM_UPLOAD_HEARTBEAT_INFO
{
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // 客户端IP地址
    char            szMAC[DH_MACADDR_LEN];                       // MAC地址
    int             nKeepAlive;                                  // 设备端保活时间，即多久会发一个保活包。单位：秒
    NET_TIME_EX     stuTime;                                     // 事件发生时间    
    BYTE            byReserved[1024];                            // 保留字节
}ALARM_UPLOAD_HEARTBEAT_INFO;

// 报警中心上线/断线事件
typedef struct tagALARM_UPLOAD_ONLINE_INFO
{
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // 客户端IP地址
    int             nPort;                                       // 客户端端口
    NET_TIME_EX     stuTime;                                     // 事件发生时间
    BOOL            bOnLine;                                     // 在线:TRUE(在线)  FALSE(断线)
    BYTE            byReserved[1020];                            // 保留字节
}ALARM_UPLOAD_ONLINE_INFO;

// 报警中心烟感报警事件
typedef struct __ALARM_UPLOAD_SMOKESENSOR_INFO
{
    DWORD           dwSize;
    char            szGlobalIP[DH_MAX_IPADDR_LEN];               // 客户端IP地址
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];        // 客户端域名
    int             nPort;                                       // 报警上传时客户端连接的端口
    char            szAlarmOccurTime[DH_ALARM_OCCUR_TIME_LEN];   // 报警发生的时间
    int             nChannel;                                    // 报警通道 从0开始
    BYTE            byHighTemperature;                           // 1:高温报警开始,0：高温报警结束
    BYTE            bySmoke;                                     // 1:烟感报警开始,0：烟感报警结束
}ALARM_UPLOAD_SMOKESENSOR_INFO;

// 警戒区入侵方向
typedef enum tagNET_CROSSREGION_DIRECTION_INFO
{
    EM_CROSSREGION_DIRECTION_UNKNOW = 0 , 
    EM_CROSSREGION_DIRECTION_ENTER      ,   //进入
    EM_CROSSREGION_DIRECTION_LEAVE      ,   //离开
    EM_CROSSREGION_DIRECTION_APPEAR     ,   //出现
    EM_CROSSREGION_DIRECTION_DISAPPEAR  ,   //消失
}NET_CROSSREGION_DIRECTION_INFO;

// 报警中心智能报警事件
typedef struct __ALARM_UPLOAD_IVS_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // 事件发生时间    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // 客户端域名
    int             nChannelID;                                 // 通道号,从0开始
    char            szType[MAX_PATH];                           // 报警类型, 检测规则
                                                                // "CrossLineDetection" 警戒线
                                                                // "CrossFenceDetection" 穿越围栏
                                                                // "CrossRegionDetection" 警戒区
                                                                // "PasteDetection" ATM贴条
                                                                // "LeftDetection" 物品遗留
                                                                // "Preservation" 物品保全
                                                                // "TakenAwayDetection" 物品搬移
                                                                // "StayDetection" 停留/滞留
                                                                // "ParkingDetection" 非法停车
                                                                // "WanderDetection" 徘徊
                                                                // "MoveDetection" 运动
                                                                // "TailDetection" 尾随
                                                                // "RioterDetection" 聚集
                                                                // "FightDetection" 打架
                                                                // "RetrogradeDetection" 逆行
                                                                // "FireDetection" 火焰
                                                                // "SmokeDetection" 烟雾
                                                                // "NumberStat" 数量统计
                                                                // "VideoAbnormalDetection" 视频异常
                                                                // "PrisonerRiseDetection" 看守所囚犯起身检测
                                                                // "FaceDetection" 人脸检测
                                                                // "FaceRecognition" 人脸识别
                                                                // "DensityDetection" 密集度检测
                                                                // "QueueDetection" 排队检测
    int             nState;                                     // 报警状态,0-报警复位,1-报警置位, 2-脉冲式报警
    char            szRuleName[DH_COMMON_STRING_128];           // 规则名称  
    char            szIPAddress[DH_MAX_IPADDR_LEN_EX];          // 设备IP地址  
    int             nPort;                                      // 设备端口号
    char            szMacAddress[DH_MACADDR_LEN];               // 设备端mac地址
    char            szPicFilePath[MAX_PATH];                    // 图片存放文件夹路径
    int             nPicFileNum;                                // 当前报警对应的图片文件个数
    int             nUploadPicFileNum;                          // 已上传FTP的图片文件个数
    DWORD           dwChannelMask;                              // 抓图视频通道的掩码,15表示此次报警抓图的有1,2,3,4通道 
	NET_CROSSREGION_DIRECTION_INFO  emDirection;                // 警戒区入侵方向, 仅在szType 为CrossRegionDetection 时有效
} ALARM_UPLOAD_IVS_INFO;

// 报警中心外部报警扩展信息
typedef struct _ALARM_UPLOAD_ALARMEX_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                                    // 事件发生时间    
    char            szDomainName[DH_MAX_DOMAIN_NAME_LEN];       // 客户端域名
    DWORD           dwAlarmMask;                                // 报警信息掩码,按位表示各报警通道状态, 7表示1,2,3报警输入通道
    char            szDevMac[DH_MACADDR_LEN];                   // 设备端mac地址
    char            szPicFilePath[MAX_PATH];                    // 图片存放文件夹路径
    int             nPicFileNum;                                // 当前报警对应的图片文件个数
    int             nUploadPicFileNum;                          // 已上传FTP的图片文件个数
    char            szAreaName[DH_COMMON_STRING_128];           // 防区名称
    DWORD           dwChannelMask;                              // 抓图视频通道的掩码,15表示此次报警抓图的有1,2,3,4通道 
}ALARM_UPLOAD_ALARMEX_INFO;

typedef enum _EM_LOGIN_FAILED_TYPE
{
    LOGIN_FAILED_UNKNOW = 0 ,
    LOGIN_FAILED_PASSWORD   ,           //密码不正确
    LOGIN_FAILED_USER       ,           //帐号不存在
    LOGIN_FAILED_TIMEOUT    ,           //等待登录返回超时
    LOGIN_FAILED_RELOGGIN   ,           //帐号已经登录
    LOGIN_FAILED_LOCKED     ,           //帐号已被锁定
    LOGIN_FAILED_BLACKLIST  ,           //帐号被列入黑名单
    LOGIN_FAILED_ERROR_BUSY ,           //资源不足,系统忙
    LOGIN_FAILED_VERSION    ,           //版本不对,无法登陆 
}EM_LOGIN_FAILED_TYPE;

//远程登录失败报警信息
typedef struct  __ALARM_UPLOAD_LOGIN_FAILED_INFO
{
    DWORD                   dwSize;
    EM_LOGIN_FAILED_TYPE    emFailedType;                       //登陆失败类型
    char                    szDeviceIP[DH_COMMON_STRING_64];    //登入设备IP
    DWORD                   nDevicePort;                        //登入设备端口
}ALARM_UPLOAD_LOGIN_FAILED_INFO;

// 录像状态变化报警信息
typedef struct
{
    int                 nChannel;               // 录像通道号
    char                reserved[12];
} ALARM_RECORDING_CHANGED;

// 视频码流类型
typedef enum tagNET_STREAM_TYPE
{
    NET_EM_STREAM_ERR,                      // 其它
    NET_EM_STREAM_MAIN,                     // "Main"-主码流
    NET_EM_STREAM_EXTRA_1,                  // "Extra1"-辅码流1
    NET_EM_STREAM_EXTRA_2,                  // "Extra2"-辅码流2
    NET_EM_STREAM_EXTRA_3,                  // "Extra3"-辅码流3
    NET_EM_STREAM_SNAPSHOT,                 // "Snapshot"-抓图码流
    NET_EM_STREAM_OBJECT,                   // "Object"-物体流
    NET_EM_STREAM_AUTO,                     // "Auto"-自动选择合适码流
    NET_EM_STREAM_PREVIEW,                  // "Preview"-预览裸数据码流
    NET_EM_STREAM_NONE,                     // 无视频码流(纯音频)
}NET_STREAM_TYPE;

// 录像状态变化报警(DH_ALARM_RECORD_CHANGED_EX)
typedef struct __ALARM_RECORD_CHANGED_INFO_EX
{
    int                 nAction;                // 0:开始 1:停止
	int                 nChannel;               // 通道
	char				szStoragePoint[DH_COMMON_STRING_64];	// 录像存储点
	NET_STREAM_TYPE		emStreamType;							// 录像码流
	char				szUser[DH_COMMON_STRING_128];			// 操作用户
	BYTE                byReserved[828];						// 保留 
} ALARM_RECORD_CHANGED_INFO_EX;

// MPT录像导入NVR的进度事件(DH_ALARM_POLICE_RECORD_PROGRESS)
typedef struct tagALARM_POLICE_RECORD_PROGRESS_INFO
{
    int                 nAction;                // 0:pulse,-1未知
    int                 nUsbSlot;               // MPT所在USB槽位号
    UINT                nTotalSize;             // 文件总大小，单位KB
    UINT                nTransferSize;          // 已经导入NVR的文件大小，单位KB
    BYTE                byReserved[1024];       // 保留 
}ALARM_POLICE_RECORD_PROGRESS_INFO;

// MPT设备状态
typedef enum tagEM_MPT_STATE
{
    EM_MPT_STATE_UNKNOWN,                                       // 未知
    EM_MPT_STATE_PLUGIN_OUT,                                    // 设备拔出
    EM_MPT_STATE_PLUGIN_IN_WORKING_PROPERLY,                    // 设备插入且工作正常
    EM_MPT_STATE_PLUGIN_IN_STORAGE_ERROR,                       // 设备插入但存储介质损坏
}EM_MPT_STATE;

// MPT插入拔出设备事件(DH_ALARM_POLICE_PLUGIN)
typedef struct tagALARM_POLICE_PLUGIN_INFO
{
    int                 nAction;                                // 0:pulse,-1未知
    int                 nUsbSlot;                               // MPT所在USB槽位号
    EM_MPT_STATE        eState;                                 // MPT状态
    char                szSerialNumber[DH_COMMON_STRING_32];    // MPT设备序列号
    BYTE                byReserved[1024];                       // 保留 
}ALARM_POLICE_PLUGIN_INFO;

// GPS未定位报警(DH_ALARM_GPS_NOT_ALIGNED)
typedef struct tagALARM_GPS_NOT_ALIGNED_INFO
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;  
	NET_TIME_EX                         stuTime;                        // 事件发生的时间
	NET_TIME_EX							stuStartTime;					// 开始时间,nAction为2时上报此字段
	BYTE                                byReserved[988];                // 保留字节 
}ALARM_GPS_NOT_ALIGNED_INFO;

// 网络未连接报警(包括wifi，3G/4G)(DH_ALARM_WIRELESS_NOT_CONNECTED)
typedef struct tagALARM_WIRELESS_NOT_CONNECTED_INFO
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;  
	NET_TIME_EX                         stuTime;                        // 事件发生的时间
	BYTE                                byReserved[1024];               // 保留字节 
}ALARM_WIRELESS_NOT_CONNECTED_INFO;

// 离线日志同步状态
typedef enum tagEM_OFFLINE_LOGSYNC_STATE
{
    EM_OFFLINE_LOGSYNC_STATE_UNKNOWN,                             // 未知
    EM_OFFLINE_LOGSYNC_STATE_SUCCEEDED,                           // 成功
    EM_OFFLINE_LOGSYNC_STATE_FAILED,                              // 失败
}EM_OFFLINE_LOGSYNC_STATE;

//同步离线日志事件
typedef struct tagALARM_OFFLINE_LOGSYNC_INFO
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;  
	NET_TIME_EX                         stuTime;                        // 事件发生的时间
	int                                 nDevAddrs;                      // 分控制器ID
	EM_OFFLINE_LOGSYNC_STATE            emState;                        //同步情况
	BYTE                                byReserved[1024];               // 保留字节 
}ALARM_OFFLINE_LOGSYNC_INFO;

#define NET_MAX_WINDINGID_NUM    8

// 线圈/车检器报警
typedef struct __ALARM_WINGDING_INFO
{
    int                 nDriveWayID;            // 车道号
    int                 nWindingID;             // 线圈ID,此字段废除,以nWindingIDs为准
    NET_TIME            stuTime;                // 报警发生时间
    int                 nState;                 // 设备状态,0表示故障恢复,1表示发生故障
    DWORD               dwChannel;              // 报警的通道号
    char                reserve[28];
    int                 nWindingIDNum;          // 线圈ID个数
    int                 nWindingIDs[NET_MAX_WINDINGID_NUM];// 具体线圈ID 
} ALARM_WINGDING_INFO;

// 交通拥塞报警
typedef struct __ALARM_TRAF_CONGESTION_INFO
{
    int                 nDriveWayID;            // 车道号
    int                 nCongestionLevel;       // 交通拥塞等级:1,2,3,4,5,6;1级最严重
    NET_TIME            stuTime;                // 报警发生时间
    int                 nState;                 // 设备状态,0表示故障恢复,1表示发生故障
    DWORD               dwChannel;              // 报警的通道号
    char                reserve[28];
} ALARM_TRAF_CONGESTION_INFO;

// 交通异常报警
typedef struct __ALARM_TRAF_EXCEPTION_INFO
{
    int                 nDriveWayID;            // 车道号
    NET_TIME            stuTime;                // 报警发生时间
    int                 nState;                 // 设备状态,0表示故障恢复,1表示发生故障
    DWORD               dwChannel;              // 报警的通道号
    char                reserve[28];
} ALARM_TRAF_EXCEPTION_INFO;

// 补光设备故障报警
typedef struct __ALARM_EQUIPMENT_FILL_INFO
{
    int                 nDriveWayID;            // 车道号
    NET_TIME            stuTime;                // 报警发生时间
    int                 nState;                 // 设备状态,0表示故障恢复,1表示发生故障
    DWORD               dwChannel;              // 报警的通道号
    char                reserve[28];
} ALARM_EQUIPMENT_FILL_INFO;

// 报警布撤防状态信息
typedef struct __ALARM_ARM_DISARM_STATE_INFO
{
    BYTE                bState;                 // 布撤防状态,0表示撤防,1表示布防,2表示强制布防
    char                reserve[31];
} ALARM_ARM_DISARM_STATE_INFO;

// 3G流量超出阈值状态信息 
typedef struct __DHDEV_3GFLOW_EXCEED_STATE_INFO
{
    BYTE                bState;                 // 3G流量超出阈值状态,0表示未超出阀值,1表示超出阀值
    char                reserve[31];
} DHDEV_3GFLOW_EXCEED_STATE_INFO;

// 限速报警或路口限速报警 (DH_DEVSTATE_SPEED_LIMIT)
typedef struct __ALARM_SPEED_LIMIT
{
    char                szType[DH_SPEEDLIMIT_TYPE_LEN];     // 限速报警类别：LowerSpeed, UpperSpeed
    int                 iSpeedLimit;                        // 限速 单位KM/H 
    int                 iSpeed;                             // 速度 单位KM/H
    char                szCrossingID[DH_MAX_CROSSING_ID];   // 路口序列号
    DWORD               dwLongitude;                        // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
    DWORD               dwLatidude;                         // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
                                                            // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    DHDEVTIME           stTime;                             // 报警发生时间
    BYTE                bOffline;                           // 0-实时 1-补传 
    char                reserve[19];
}ALARM_SPEED_LIMIT;

// 限速报警

// 超载报警
typedef struct __ALARM_OVER_LOADING
{
    NET_TIME            stuCurTime;                         // 当前时间
    DWORD               dwLatidude;                         // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
    DWORD               dwLongitude;                        // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
                                                            // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    char                szDriverNo[DH_VEHICLE_DRIVERNO_LEN];// 驾驶员ID
    DWORD               dwCurSpeed;                         // 当前速度
    BYTE                byReserved[128]; 
}ALARM_OVER_LOADING;

// 急刹车报警
typedef struct __ALARM_HARD_BRAKING
{
    NET_TIME        stuCurTime;                             // 当前时间
    DWORD           dwLatidude;                             // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
    DWORD           dwLongitude;                            // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
                                                            // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    char            szDriverNo[DH_VEHICLE_DRIVERNO_LEN];    // 驾驶员ID
    DWORD           dwCurSpeed;                             // 当前速度
    BYTE            byReserved[128]; 
}ALARM_HARD_BRAKING;

// 烟感报警
typedef struct __ALARM_SMOKE_SENSOR
{
    NET_TIME        stuCurTime;             // 当前时间
    int             nChannel;               // 报警通道
    BYTE            byHighTemperature;      // 1:高温报警开始,0：高温报警结束
    BYTE            bySmoke;                // 1:烟感报警开始,0：烟感报警结束
    BYTE            byReservrd[126];
}ALARM_SMOKE_SENSOR;

// 交通灯故障报警
typedef struct _LIGHT_INFO
{
    BYTE               byDirection;            // 交通灯方向: 1-左行,2-右行,3-直行, 4-掉头
    BYTE               byState;                // 交通灯状态: 1-故障,2-正常
    BYTE               byReserved[62];         // 保留字节 
}LIGHT_INFO;

typedef struct __ALARM_TRAFFIC_LIGHT_FAULT 
{
    NET_TIME           stTime;                 // 报警发生时间
    int                nInfoNumber;            // 故障信息数
    LIGHT_INFO         stLightInfo[8];         // 交通灯故障信息
    BYTE               byReserved[128];        // 保留字段
}ALARM_TRAFFIC_LIGHT_FAULT;

// 流量统计报警通道信息
typedef struct __ALARM_TRAFFIC_FLUX_LANE_INFO
{
    NET_TIME            stuCurTime;            // 当前时间
    int                 nLane;                 // 车道号
    int                 nState;                // 状态值：1-表示拥堵, 2-表示拥堵恢复, 3-表示正常, 4-表示中断, 5-表示中断恢复
    int                 nFlow;                 // 流量值,单位：辆/分
    BYTE                byReserved[124];       // 保留
}ALARM_TRAFFIC_FLUX_LANE_INFO;

// SIP状态改变报警()
typedef struct __ALARM_SIP_STATE
{
    int     nChannelID;
    BYTE    byStatus;                         //0:注册成功,1:未注册,2:无效,3:注册中,4:通话中
    BYTE    bReserved[63];                    //保留
}ALARM_SIP_STATE;

// 车载自定义信息上传(DH_DEVSTATE_VIHICLE_INFO_UPLOAD)
typedef struct __ALARM_VEHICLE_INFO_UPLOAD
{
    char                szType[DH_VEHICLE_TYPE_LEN];                 // 信息类别: DriverCheck：司机签入签出
    char                szCheckInfo[DH_VEHICLE_INFO_LEN];            // 签入：CheckIn、签出：CheckOut  
    char                szDirverNO[DH_VEHICLE_DRIVERNO_LEN];         // 司机工号字符串
    DHDEVTIME           stTime;                                      // 报警发生时间
    BYTE                bOffline;                                    // 0-实时 1-补传 
    char                reserved[59];                     
}ALARM_VEHICLE_INFO_UPLOAD;
// 车载自定义信息上传

// 卡号录像信息上传
typedef struct __ALARM_CARD_RECORD_INFO_UPLOAD
{
    int                 nChannel;                           // 通道号
    BOOL                bEnable;                            // 是否正在卡号录像
    char                szCardInfo[DH_MAX_CARD_INFO_LEN];   // 卡号信息
    NET_TIME            stuTime;                            // 该卡号生效起始时间
    BOOL                bPreviewOverlayEn;                  // 预览叠加使能
    BYTE                byOverlayPos;                       // 叠加位置,1-左上,2-左下,3-右上,4-右下
    char                reserved[59];
}ALARM_CARD_RECORD_INFO_UPLOAD;



typedef enum __ATMTradeTypes{
    TRADE_TYPE_INC = 0,        //插卡INSERTCARD
    TRADE_TYPE_WDC,            //退卡WITHDRAWCARD
    TRADE_TYPE_CKT,            //校时CHECKTIME
    TRADE_TYPE_INQ,            //查询
    TRADE_TYPE_CWD,            //取款
    TRADE_TYPE_PIN,            //改密
    TRADE_TYPE_TFR,            //转帐
    TRADE_TYPE_DEP,            //存款
    TRADE_TYPE_NCINQ,          //无卡查询
    TRADE_TYPE_NCDEP,          //无卡存款
    TRADE_TYPE_OTHERS,         //其它
    TRADE_TYPE_ALL,            //总
}DH_eATMTradeTypes;

typedef struct __ALARM_ATM_INFO_UPLOAD_CHNL
{
    int                 nChannel;                   // 查询的第几通道ATM叠加信息,范围0-N-1（N表示通道数）
    char                szATMID[32];                // ATM终端号
    char                szCardNo[32];               // 卡号    例：6222421541208230456 
    char                szTradetime[32];            // 交易时间    例：20111118112200表示2011-11-18 11:22:00
    DH_eATMTradeTypes   emTradeType;                // 交易类型    范围: ATMTradeTypes
    int                 nAmount;                    // 交易金额    0-4294967296
    BYTE                byRerved[32];               // 保留
}ALARM_ATM_INFO_UPLOAD_CHNL;

// ATM交易信息上传(DH_ALARM_ATM_INFO_UPLOAD)事件对应结构体
typedef struct __ALARM_ATM_INFO_UPLOAD
{
    int                           nCnt;
    ALARM_ATM_INFO_UPLOAD_CHNL    m_stAtmInfo[DH_MAX_CHANNUM];
}ALARM_ATM_INFO_UPLOAD;

// 摄像机移位报警事件
typedef struct __ALARM_CAMERA_MOVE_INFO
{
    int                         nChannelNum;                        // 报警发生通道数
    unsigned char               alarmChannels[DH_MAX_CHANNUM_EX];   // 发生报警通道号信息
    BYTE                        byReserved[128];
}ALARM_CAMERA_MOVE_INFO;

// 详细动检报警信息
typedef struct __ALARM_DETAILEDMOTION_CHNL_INFO
{
    DWORD              dwSize;
    int                nChannelID;    // 通道号
    BOOL               bAlarm;        // 是否报警 TRUE/FALSE
    int                nLevel;        // 报警级别,单位千分之,以动检发生小格数除以总小格数计算
}ALARM_DETAILEDMOTION_CHNL_INFO;

/// 存储异常报警
typedef struct __ALARM_STORAGE_FAILURE
{
    DWORD     dwSize;                                     // 结构体大小
    UINT      ActionType;                                 // 0：停止, 1：开始
    char      szProtocol[DH_MAX_STRING_LEN];              // 协议类型,目前只支持FTP
    char      szServerAddr[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // 服务器IP地址
    DWORD     dwPort;                                     // 端口号
    NET_TIME  stuTime;                                    // 事件发生时间
    int       nChannel;                                   // 通道号, 从1开始, 0表示不区分通道
}ALARM_STORAGE_FAILURE;

// 前端断网报警信息
typedef struct __ALARM_FRONTDISCONNET_INFO
{
    DWORD              dwSize;                           // 结构体大小
    int                nChannelID;                       // 通道号
    int                nAction;                          // 0:开始 1:停止
    NET_TIME           stuTime;                          // 事件发生时间
    char               szIpAddress[MAX_PATH];            // 前端IPC的IP地址
}ALARM_FRONTDISCONNET_INFO;

// 电池电压过低报警
typedef struct __ALARM_BATTERYLOWPOWER_INFO
{
    DWORD             dwSize;                            // 结构体大小
    int               nAction;                           // 0:开始 1:停止
    int               nBatteryLeft;                      // 剩余电量百分比,单位%
    NET_TIME          stTime;                            // 事件发生时间
    int               nChannelID;                        // 通道号, 标识子设备电池, 从0开始
}ALARM_BATTERYLOWPOWER_INFO;

// 温度过高报警
typedef struct __ALARM_TEMPERATURE_INFO
{
    DWORD              dwSize;                           // 结构体大小
    char               szSensorName[DH_MACHINE_NAME_NUM];// 温度传感器名称
    int                nChannelID;                       // 通道号
    int                nAction;                          // 0:开始 1:停止
    float              fTemperature;                     // 当前温度值, 单位摄氏度
    NET_TIME           stTime;                           // 事件发生时间
}ALARM_TEMPERATURE_INFO;

// 疲劳驾驶报警
typedef struct __ALARM_TIREDDRIVE_INFO
{
    DWORD             dwSize;                            // 结构体大小
    int               nAction;                           // 0:开始 1:停止
    int               nDriveTime;                        // 持续驾驶时间,单位分钟
    NET_TIME          stTime;                            // 事件发生时间
}ALARM_TIREDDRIVE_INFO;

// 丢录像事件报警
typedef struct __ALARM_LOST_RECORD
{
    DWORD     dwSize;                                     //结构体大小
    UINT      ActionType;                                 // 0：停止, 1：开始
    UINT      nChannelID;                                 // 通道号,从1开始
    UINT      nStreamType;                                // 码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；4：抓图码流
    NET_TIME  stuTime;                                    // 事件发生时间    
}ALARM_LOST_RECORD;

// CPU占用率过高事件报警,暂定上限95%。
typedef struct __ALARM_HIGH_CPU
{
    DWORD     dwSize;                                     //结构体大小
    UINT      ActionType;                                 // 0：停止, 1：开始
    UINT      nUsed;                                      // CPU占用率的1000倍
    NET_TIME  stuTime;                                    // 事件发生时间    
}ALARM_HIGH_CPU;

// 网络发送数据丢包事件报警
typedef struct __ALARM_LOST_NETPACKET
{
    DWORD     dwSize;                                     //结构体大小
    UINT      ActionType;                                 // 0：停止, 1：开始
    UINT      nChannelID;                                 // 通道号,从1开始
    UINT      nStreamType;                                // 码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；4：抓图码流
    char      szRemoteIP[DH_MAX_IPADDR_LEN];              // 发送端IP地址
    DWORD     dwRemotePort;                               // 发送端的端口地址
    NET_TIME  stuTime;                                    // 事件发生时间    
}ALARM_LOST_NETPACKET;

// 内存占用率过高事件报警,暂定上限95%。
typedef struct __ALARM_HIGH_MEMORY
{
    DWORD     dwSize;                                     //结构体大小
    UINT      ActionType;                                 // 0：停止, 1：开始
    UINT      nUsed;                                      // 内存占用率的1000倍
    NET_TIME  stuTime;                                    // 事件发生时间    
}ALARM_HIGH_MEMORY;

// 黑名单车辆抓拍事件
typedef struct __DH_BLACKLIST_SNAP_INFO
{
    DWORD     dwSize;
    char      szPlateNumber[32];                          // 车牌号
    NET_TIME  stuTime;                                    // 事件发生时间
}DH_BLACKLIST_SNAP_INFO;

// 硬盘流量异常事件
typedef struct __ALARM_DISK_FLUX
{
    DWORD                dwSize;    
    DWORD                dwAction;                         // 0-开始, 1-停止
    DWORD                dwDataFlux;                       // 当前数据流量, KB            
    NET_TIME             stuTime;                          // 事件发生时间
} ALARM_DISK_FLUX;

// 网络流量异常事件
typedef struct __ALARM_NET_FLUX
{
    DWORD                dwSize;    
    DWORD                dwAction;                           // 0-开始, 1-停止
    DWORD                dwDataFlux;                         // 当前数据流量, KB
    NET_TIME             stuTime;                            // 事件发生时间
} ALARM_NET_FLUX;

// 风扇转速异常事件
typedef struct __ALARM_FAN_SPEED
{
    DWORD                dwSize;    
    DWORD                dwAction;                            // 0-开始, 1-停止
    DWORD                dwIndex;                             // 风扇序号
    char                 szName[DH_MACHINE_NAME_NUM];         // 传感器名称
    NET_TIME             stuTime;                             // 事件发生时间
    DWORD                dwCurrent;                           // 当前转速
} ALARM_FAN_SPEED;

// 硬盘报警
typedef struct __ALARM_DISK_INFO 
{
    DWORD                dwSize;
    DWORD                nChannel;                            // 硬盘通道号
    DWORD                nHDDNumber;                          // 磁盘列阵号, 0: 主柜,1: 扩展柜1,  2: 扩展柜2 
    DWORD                nHDDState;                           // 硬盘状态, 0: Unknown, 1: Running, 2: Offline, 3: Warning, 4: Failed
} ALARM_DISK_INFO;

// 文件系统告警
typedef struct __ALARM_FILE_SYSTEM_INFO 
{
    DWORD                dwSize;
    char                 szMountDir[MAX_PATH];                // 文件系统挂载名
    DWORD                nState;                              // 文件系统状态, 0: Unkown, 1: Normal, 2: Error
} ALARM_FILE_SYSTEM_INFO;

// 远程外部报警信息
typedef struct __ALARM_REMOTE_ALARM_INFO
{
    DWORD      dwSize;
    int        nChannelID;                               // 通道号,从1开始
    int        nState;                                   // 报警状态,0-报警复位,1-报警置位
}ALARM_REMOTE_ALARM_INFO;

// 智能报警事件
typedef struct __ALARM_IVS_INFO
{
    DWORD      dwSize;
    NET_TIME   stuTime;                                  // 事件发生时间    
    int        nChannelID;                               // 通道号,从0开始
    char       szType[MAX_PATH];                         // 报警类型
    int        nState;                                   // 报警状态,0-报警复位,1-报警置位, 2-脉冲式报警
}ALARM_IVS_INFO;

// 车载货重报警
typedef struct __ALARM_GOODS_WEIGHT_INFO
{
    DWORD        dwSize;
    int          nAction;                               // 0-开始, 1-停止
    int          nAlarmType;                            // 0-大于最大货重, 1-小于最小货重, 2-货重变化超过报警阈值
    DWORD        dwGoodsWeight;                         // 当前货重(kg)
    DWORD        dwSelfWeight;                          // 自重(kg)
    DWORD        dwTotalWeight;                         // 总重(kg)
    DWORD        dwStandardWeight;                      // 核定货重(kg)
    DWORD        dwWeightScale;                         // 货重比例
    DWORD        dwMaxGoodsWeight;                      // 最大货重(kg)
    DWORD        dwMinGoodsWeight;                      // 最小货重(kg)
    DWORD        dwAlarmWeight;                         // 报警阈值(kg)
    int          nWeightChange;                         // 采集时间间隔内货重变化(kg)
    int          nCheckTime;                            // 静止采集时间(s)
} ALARM_GOODS_WEIGHT_INFO;

// 车载货重信息上传
typedef struct __ALARM_GOODS_WEIGHT_UPLOAD_INFO 
{
    DWORD        dwSize;
    DWORD        dwGoodsWeight;                         // 当前货重(kg)
    DWORD        dwSelfWeight;                          // 自重(kg)
    DWORD        dwTotalWeight;                         // 总重(kg)
    DWORD        dwStandardWeight;                      // 核定货重(kg)
    DWORD        dwWeightScale;                         // 货重比例
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // 卡号
} ALARM_GOODS_WEIGHT_UPLOAD_INFO;

// 数据来源
typedef enum tagEM_DATE_SOURCE
{
    EM_DATE_SOURCE_GPS,                                     // GPS 
    EM_DATE_SOURCE_INERTIALNAVIGATION,                      // 惯性导航数据
}EM_DATE_SOURCE;

// GPS状态信息
typedef struct _NET_GPS_STATUS_INFO
{
    NET_TIME                revTime;                        // 定位时间
    char                    DvrSerial[50];                  // 设备序列号
    BYTE                    byRserved1[6];                  // 对齐字节
    double                  longitude;                      // 经度(单位是百万分之度,范围0-360度)
    double                  latidude;                       // 纬度(单位是百万分之度,范围0-180度)
    double                  height;                         // 高度(米)
    double                  angle;                          // 方向角(正北方向为原点,顺时针为正)
    double                  speed;                          // 速度(单位km/H)
    WORD                    starCount;                      // 定位星数, emDateSource为 EM_DATE_SOURCE_GPS时有效
    BYTE                    byRserved2[2];                  // 对齐字节
    NET_THREE_STATUS_BOOL   antennaState;                   // 天线状态, emDateSource为 EM_DATE_SOURCE_GPS时有效    
    NET_THREE_STATUS_BOOL   orientationState;               // 定位状态
    int                     workStae;                       // 工作状态(0=未定位,1=非差分定位,2=差分定位,3=无效PPS,6=正在估算 
                                                            // emDateSource为 EM_DATE_SOURCE_GPS时有效
    int                     nAlarmCount;                    // 发生的报警位置个数
    int                     nAlarmState[128];               // 发生的报警位置,值可能多个, emDateSource为 EM_DATE_SOURCE_GPS时有效
    BYTE                    bOffline;                       // 0-实时 1-补传 
    BYTE                    bSNR;                           // GPS信噪比,表示GPS信号强度,值越大,信号越强 范围：0~100,0表示不可用	
    BYTE                    byRserved3[2];                  // 对齐字节
    EM_DATE_SOURCE          emDateSource;                   // 数据来源
    BYTE                    byRserved[124];                 // 保留字节
} NET_GPS_STATUS_INFO,*LPNET_GPS_STATUS_INFO;

// 硬盘刻录满报警事件
typedef struct __ALARM_DISKBURNED_FULL_INFO
{
    DWORD       dwSize;
    int         nIndex;                             //光盘号
}ALARM_DISKBURNED_FULL_INFO;

// 存储容量不足事件
typedef struct tagALARM_STORAGE_LOW_SPACE_INFO 
{
    DWORD               dwSize;
    int                 nAction;                            // 0:开始 1:停止
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                szDevice[DH_STORAGE_NAME_LEN];      // 存储设备名称
    char                szGroup[DH_STORAGE_NAME_LEN];       // 存储组名称
    INT64               nTotalSpace;                        // 总容量, byte
    INT64               nFreeSpace;                         // 剩余容量, byte
    int                 nPercent;                           // 已经使用的百分比
} ALARM_STORAGE_LOW_SPACE_INFO;

// 存储错误类型
typedef enum __EM_STORAGE_ERROR
{
    STORAGE_ERROR_NONE,                             // 无
    STORAGE_ERROR_PATITION,                         // 分区错误          
    STORAGE_ERROR_INIT_FS,                          // 初始化文件系统错误    
    STORAGE_ERROR_READ_DATA,                        // 读数据失败
    STORAGE_ERROR_WRITE_DATA,                       // 写数据失败
    STORAGE_ERROR_RAID_FAILED,                      // RAID错误
    STORAGE_ERROR_RAID_DEGRADED,                    // RAID降级
    STORAGE_ERROR_ISCSI_FAILED,                     // iSCSI错误
} EM_STORAGE_ERROR;

// 存储错误报警
typedef struct __ALARM_STORAGE_FAILURE_EX
{
    DWORD               dwSize;
    int                 nAction;                            // 0:开始 1:停止
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                szDevice[DH_STORAGE_NAME_LEN];      // 存储设备名称
    char                szGroup[DH_STORAGE_NAME_LEN];       // 存储组名称
    char                szPath[MAX_PATH];                   // 路径
    EM_STORAGE_ERROR    emError;                            // 错误类型
    int                 nPhysicNo;                          // 硬盘所在槽编码, 从1开始
    NET_TIME_EX			stuTime;							// 事件发生的时间
} ALARM_STORAGE_FAILURE_EX;

// 录像异常报警
typedef struct __ALARM_RECORD_FAILED_INFO 
{
    DWORD                dwSize;
    int                  nAction;                           // 0:开始 1:停止
    int                  nIndex;                            // 通道号
} ALARM_RECORD_FAILED_INFO;

// 存储崩溃事件
typedef struct __ALARM_STORAGE_BREAK_DOWN_INFO 
{
    DWORD                dwSize;
    int                  nAction;                           // 0:开始 1:停止
} ALARM_STORAGE_BREAK_DOWN_INFO;

//热插拔动作类型
typedef enum tagEM_STORAGE_HOT_PLUG_ACTION
{
    HOT_PLUG_ACTION_UNKNOW = 0  ,
    HOT_PLUG_ACTION_ADD         ,       //插入设备
    HOT_PLUG_ACTION_REMOVE      ,       //拔出设备
}EM_STORAGE_HOT_PLUG_ACTION;

//存储热插拔事件(对应事件 DH_ALARM_STORAGE_HOT_PLUG)
typedef struct __ALARM_STORAGE_HOT_PLUG_INFO
{
    int                         nAction;                            // 0:开始 1:停止
    EM_STORAGE_HOT_PLUG_ACTION  emHotPLugAction;                    // 热插拔动作类型
    char                        szDevice[DH_STORAGE_NAME_LEN];      // 存储设备名称
    char                        szMediaType[DH_COMMON_STRING_32];   // 介质类型
    char                        szBusType[DH_COMMON_STRING_32];     // 总线类型
    char                        szMountOn[DH_COMMON_STRING_128];    // 设备挂载点
                                                                    // 如果非空,插入时表示设备已挂载
                                                                    //          拔出时表示设备没有正常卸载
    int                         nPhysicNo;                          // 物理编号,从1开始
    int                         nLogicNo;                           // 逻辑编号
    BYTE                        bReserved[256];                     // 保留字节,留待扩展.
}ALARM_STORAGE_HOT_PLUG_INFO;

// 流量使用情况事件(对应事件DH_ALARM_FLOW_RATE)
typedef struct tagALARM_FLOW_RATE_INFO
{
	int				nAction;				// 0:暂停, 1:开始, 2:停止
	int				nChannelID;				// 通道号
	UINT			nFlowRate;				// 传输的流量值(单位:MB)
	BYTE			bReserved[512];			// 保留字节
} ALARM_FLOW_RATE_INFO;
 
typedef enum tagEM_NET_UPS_STATUS
{
    EM_NET_UPS_SYS_SIGN=0,              //系统温度值符号位. 1:表示温度负; 0:表示温度正
    EM_NET_UPS_SYS_SHUTDOWN,            //系统关机.         1:表示关机激活状态
    EM_NET_UPS_SYS_TEST,                //系统测试中.       1:表示测试中
    EM_NET_UPS_SYS_TYPE,                //UPS 类型.         1:表示后备机 ; 0:表示在线机
    EM_NET_UPS_SYS_FAULT,               //UPS 故障.         1:表示UPS内部故障 ; 0:正常
    EM_NET_UPS_ELE_SUPPLY,              //旁路/逆变状态.    1:AC供电 ; 0:电池供电
    EM_NET_UPS_VOL_LOW,                 //电池电压低.       1:表示电池电压低 ; 0:表示电池正常
    EM_NET_UPS_BYPASS_STATUS,           //市电故障.         1:表示市电故障 ; 0:表示市电正常
    EM_NET_UPS_MAX = 64,                //
}EM_NET_UPS_STATUS;

typedef struct tagNET_UPS_INFO
{
    DWORD dwSize;
    float fInputVoltage;                        //输入电压    具体参考 智能交通专用电源通信协议(V1.2),蓝盾专用定义
    float fInputAbnormalVoltage;                //输入异常电压    
    float fOutputVoltage;                       //输出电压
    float fOutputCurrent;                       //输出电流百分比,单位(%)
    float fInputFrequency;                      //输入频率
    float fVoltage;                             //电压
    float fTemp;                                //温度
    BYTE  bStatusInfo[EM_NET_UPS_MAX];          //UPS状态集,参见NET_UPS_STATUS枚举
    char  szVersionInfo[DH_MAX_VERSION_STR];    //版本
}NET_UPS_INFO;

typedef struct tagALARM_COMM_PORT_EVENT_INFO
{
    DWORD           dwSize;
    UINT            nEventAction;       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    NET_UPS_INFO    stUPSInfo;          // UPS串口信息
}ALARM_COMM_PORT_EVENT_INFO;

// 视频输入通道失效事件（例：配置的视频输入通道码流,超出设备处理能力）DH_ALARM_VIDEO_ININVALID
typedef struct __ALARM_VIDEO_ININVALID_INFO 
{
    DWORD               dwSize;                         // 结构体大小
    int                 nChannelID;                     // 通道号,从0开始
} ALARM_VIDEO_ININVALID_INFO;


// 存储组不存在事件信息
typedef struct tagALARM_STORAGE_NOT_EXIST_INFO 
{
    DWORD           dwSize;
    int             nAction;                            // 0:开始 1:停止
    char            szGroup[DH_STORAGE_NAME_LEN];       // 在录像或抓图存储点中设置但不存在的组
    NET_TIME        stuTime;                            // 事件触发时间
}ALARM_STORAGE_NOT_EXIST_INFO;

//网络故障事件类型
typedef enum __EM_NETABORT_EVENT_TYPE
{
    EM_NETABORT_EVENT_TYPE_WIRE = 0,                    // 有线网络故障事件
    EM_NETABORT_EVENT_TYPE_WIRELESS,                    // 无线网络故障事件
    EM_NETABORT_EVENT_TYPE_3G,                          // 3G网络故障事件
}EM_NETABORT_EVENT_TYPE;

// 网络故障事件
typedef struct tagALARM_NETABORT_INFO
{
    DWORD                   dwSize;
    int                     nAction;                    // 0:开始 1:停止
    EM_NETABORT_EVENT_TYPE  emNetAbortType;             // 事件类型
    NET_TIME                stuTime;                    // 事件触发时间

	char					szInterface[DH_MAX_ETH_NAME];	//冲突网卡名
}ALARM_NETABORT_INFO;

// IP冲突事件
typedef struct tagALARM_IP_CONFLICT_INFO
{
    DWORD            dwSize;
    int              nAction;                        // 0:开始 1:停止
    NET_TIME         stuTime;                        // 事件触发时间
}ALARM_IP_CONFLICT_INFO;


// MAC冲突事件
typedef struct tagALARM_MAC_CONFLICT_INFO
{
    DWORD           dwSize;
    int             nAction;                        // 0:开始 1:停止
    NET_TIME        stuTime;                        // 事件触发时间
}ALARM_MAC_CONFLICT_INFO;


// 电源类型
typedef enum __EM_POWER_TYPE
{
    EM_POWER_TYPE_MAIN = 0,                          // 主电源
    EM_POWER_TYPE_BACKUP,                            // 备用电源
}EM_POWER_TYPE;

// 电源故障事件类型
typedef enum __EM_POWERFAULT_EVENT_TYPE
{
	EM_POWERFAULT_EVENT_UNKNOWN = -1,				 // 未知
	EM_POWERFAULT_EVENT_LOST = 0,                    // 掉电、电池不在位
	EM_POWERFAULT_EVENT_LOST_ADAPTER,                // 适配器不在位
	EM_POWERFAULT_EVENT_LOW_BATTERY,				 // 电池欠压
	EM_POWERFAULT_EVENT_LOW_ADAPTER,				 // 适配器欠压
}EM_POWERFAULT_EVENT_TYPE;

// 电源故障事件
typedef struct tagALARM_POWERFAULT_INFO
{
    DWORD                    dwSize;            
    EM_POWER_TYPE            emPowerType;            // 电源类型
    EM_POWERFAULT_EVENT_TYPE emPowerFaultEvent;      // 电源故障事件
    NET_TIME                 stuTime;                // 报警事件发生的时间
    int                      nAction;                // 0:开始 1:停止
}ALARM_POWERFAULT_INFO;

// 防拆报警事件
typedef struct tagALARM_CHASSISINTRUDED_INFO
{
    DWORD               dwSize;
    int                 nAction;                // 0:开始 1:停止
    NET_TIME            stuTime;                // 报警事件发生的时间
    int                 nChannelID;             // 通道号
    char                szReaderID[DH_COMMON_STRING_32];// 读卡器ID    
    UINT 			    nEventID;				//事件ID
    char                szSN[32];               // 无线设备序列号
}ALARM_CHASSISINTRUDED_INFO;

// 扩展模块报警事件
typedef struct tagALARM_ALARMEXTENDED_INFO
{
    DWORD               dwSize;
    int                 nChannelID;             // 通道号
    int                 nAction;                // 0:开始 1:停止
    NET_TIME            stuTime;                // 报警事件发生的时间
}ALARM_ALARMEXTENDED_INFO;


// 对讲发起方
typedef enum __EM_TALKING_CALLER
{
    EM_TALKING_CALLER_UNKNOWN = 0,                 // 未知发起方
    EM_TALKING_CALLER_PLATFORM,                    // 对讲发起方为平台
}EM_TALKING_CALLER;

// Invite事件远程设备协议
typedef enum tagTALKINGINVITE_REMOTEDEVICE_PROTOCOL
{
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_UNKNOWN = 0,    // 未知
    EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_HIKVISION       // 海康
}EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL;

#define MAX_REMOTEDEVICEINFO_IPADDR_LEN         128       // 远程设备IP地址最大长度
#define MAX_REMOTEDEVICEINFO_USERNAME_LEN       128       // 远程设备用户名最大长度
#define MAX_REMOTEDEVICEINFO_USERPSW_LENGTH     128       // 远程设备密码最大长度

// Invite事件远端设备信息
typedef struct tagTALKINGINVITE_REMOTEDEVICEINFO
{
    char		                            szIP[MAX_REMOTEDEVICEINFO_IPADDR_LEN];	        // 设备IP
	int	                                    nPort;					                        // 端口
	EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL  emProtocol;                                     // 协议类型
	char		                            szUser[MAX_REMOTEDEVICEINFO_USERNAME_LEN];	    // 用户名
	char		                            szPassword[MAX_REMOTEDEVICEINFO_USERPSW_LENGTH];// 密码
	char                                    szReverse[1024];                                // 保留字段
}TALKINGINVITE_REMOTEDEVICEINFO;

// 报警事件类型DH_ALARM_TALKING_INVITE(设备请求对方发起对讲事件)对应的数据描述信息
typedef struct tagALARM_TALKING_INVITE_INFO
{
    DWORD                                   dwSize;
    EM_TALKING_CALLER                       emCaller;                       // 设备希望的对讲发起方
    NET_TIME                                stuTime;                        // 事件触发时间
    char                                    szCallID[DH_COMMON_STRING_64];  // 呼叫惟一标识符
    int                                     nLevel;                         // 表示所呼叫设备所处层级
    TALKINGINVITE_REMOTEDEVICEINFO          stuRemoteDeviceInfo;             // 远端设备信息
}ALARM_TALKING_INVITE_INFO;

// 报警事件类型DH_ALARM_TALKING_IGNORE_INVITE(设备取消对讲请求事件)对应的数据描述信息
typedef struct tagALARM_TALKING_IGNORE_INVITE_INFO
{
    DWORD                dwSize;
} ALARM_TALKING_IGNORE_INVITE_INFO;

// 报警事件类型DH_ALARM_TALKING_HANGUP对应的数据描述信息
typedef struct tagALARM_TALKING_HANGUP_INFO 
{
    DWORD               dwSize;
    NET_TIME            stuTime;                // 事件触发时间
}ALARM_TALKING_HANGUP_INFO;

// 岗亭更新事件状态
typedef enum tagEM_GUARD_EVENT_STATE
{
    EM_GUARD_EVENT_STATE_UNKNOWN = 0,   // 未知状态
    EM_GUARD_EVNET_STATE_ONGUARD,       // 到岗
    EM_GUARD_EVENT_STATE_OFFGUARD       // 离岗
}EM_GUARD_EVENT_STATE;

// 岗亭信息更新事件,DH_ALARM_GUARD_INFO_UNPDATE对用的数据描述信息
typedef struct tagALARM_GUARD_UPDATE_INFO
{
    DWORD                dwSize;
    EM_GUARD_EVENT_STATE emEventState;                          // 岗亭更新事件状态
    int                  nIDCount;                              // 触发检测事件的人员ID个数
    int                  nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT];// 人员ID数组
    NET_TIME             stuTime;                               // 事件触发时间
}ALARM_GUARD_UPDATE_INFO;

// 岗亭检测事件,DH_ALARM_GUARD_DETECT对应的数据描述信息
typedef struct tagALARM_GUARD_DETECT_INFO
{
    DWORD               dwSize;
    int                 nAction;                                // 0:开始 1:停止
    int                 nIndex;                                 // 岗亭检测配置下标 
    int                 nIDCount;                               // 触发检测事件的人员ID个数
    int                 nIDArray[DH_MAX_GUARD_DETECT_ID_COUNT]; // 人员ID数组
    NET_TIME            stuTime;                                // 事件触发时间
}ALARM_GUARD_DETECT_INFO;

//银行卡插卡事件DH_ALARM_BANKCARDINSERT对应的数据描述信息
typedef struct tagALARM_BANKCARDINSERT_INFO 
{
    DWORD               dwSize;
    int                 nAction;                // -1:未知 0:开始 1:停止
}ALARM_BANKCARDINSERT_INFO;

#define MAX_CARD_RECORD_FIELD_NUM 16            // 卡号录像最大域数量

// 事件触发录像,stop时的保存策略
typedef enum tagNET_RECORD_SAVEFLAG
{
    NET_RECORD_SAVEFLAG_UNKNOWN = 0,            //未知类型
    NET_RECORD_SAVEFLAG_MARK,                   //保存录像、并加锁
    NET_RECORD_SAVEFLAG_SAVE,                   //仅保存录像
}NET_RECORD_SAVEFLAG;

//卡号录像事件 DH_ALARM_CARD_RECORD 对应的数据描述信息
typedef struct tagALARM_CARD_RECORD_INFO 
{
    DWORD               dwSize;					
    int                 nAction;                // -1:未知 0:开始 1:停止
    int                 nChannelID;             // 通道号,从0开始
    unsigned int        nFieldCount;            // 域数量
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256]; // 域信息
    NET_RECORD_SAVEFLAG emRecordSaveFlag;       // 事件触发录像,stop时的保存策略,详见枚举 NET_RECORD_SAVEFLAG
}ALARM_CARD_RECORD_INFO;

// 网络报警事件 DH_ALARM_CARD_RECORD 对应的数据描述信息
typedef struct tagALARM_NET_INFO
{
    DWORD               dwSize;
    int                 nAction;                // -1:未知 0:开始 1:停止
    int                 nChannelID;             // 通道号,从0开始
} ALARM_NET_INFO;

//动检事件对应 DH_ALARM_VIDEOMOTION_EVENT  
typedef struct tagALARM_VIDEOMOTION_EVENT_INFO
{
	DWORD				 dwSize;
	int                  nAction;             // -1:未知 0:开始 1:停止
	int                  nChannelID;          // 通道号,从0开始	
}ALARM_VIDEOMOTION_EVENT_INFO;

//WideViewRegions事件 对应 DH_ALARM_WIDE_VIEW_REGION_EVENT  
typedef struct tagALARM_WIDE_VIEW_REGION_EVENT_INFO
{
    DWORD				 dwSize;
    int                  nAction;             // -1:未知 0:脉冲(Pusle)   
}ALARM_WIDE_VIEW_REGION_EVENT_INFO;

// CLIENT_ControlDevice接口的 DH_CTRL_NOTIFY_EVNENT 命令参数(向设备发送事件)
typedef struct tagNET_NOTIFY_EVENT_DATA
{
    DWORD                       dwSize;
    LONG                        lCommand;       // 事件类型
    void*                       pEventData;     // 事件内容,与lCommand对应的结构体指针
}NET_NOTIFY_EVENT_DATA;

// 传感器感应方式枚举类型
typedef enum tagNET_SENSE_METHOD
{
    NET_SENSE_UNKNOWN = -1,      //未知类型
    NET_SENSE_DOOR=0,            //门磁
    NET_SENSE_PASSIVEINFRA,      //被动红外
    NET_SENSE_GAS,               //气感
    NET_SENSE_SMOKING,           //烟感
    NET_SENSE_WATER,             //水感
    NET_SENSE_ACTIVEFRA,         //主动红外
    NET_SENSE_GLASS,             //玻璃破碎
    NET_SENSE_EMERGENCYSWITCH,   //紧急开关
    NET_SENSE_SHOCK,             //震动
    NET_SENSE_DOUBLEMETHOD,      //双鉴(红外+微波)
    NET_SENSE_THREEMETHOD,       //三技术
    NET_SENSE_TEMP,              //温度
    NET_SENSE_HUMIDITY,          //湿度
    NET_SENSE_WIND,              //风速
    NET_SENSE_CALLBUTTON,        //呼叫按钮
    NET_SENSE_GASPRESSURE,       //气体压力
    NET_SENSE_GASCONCENTRATION,  //燃气浓度
    NET_SENSE_GASFLOW,           //气体流量
    NET_SENSE_OTHER,             //其他
    NET_SENSE_OIL,               // 油量检测,汽油、柴油等车辆用油检测
    NET_SENSE_MILEAGE,           // 里程数检测   
    NET_SENSE_URGENCYBUTTON,     //紧急按钮
    NET_SENSE_STEAL,             //盗窃
    NET_SENSE_PERIMETER,         //周界
    NET_SENSE_PREVENTREMOVE,     //防拆
    NET_SENSE_DOORBELL,          //门铃
    NET_SENSE_ALTERVOLT,         //交流电压传感器
    NET_SENSE_DIRECTVOLT,        //直流电压传感器
    NET_SENSE_ALTERCUR,          //交流电流传感器
    NET_SENSE_DIRECTCUR,         //直流电流传感器
    NET_SENSE_RSUGENERAL,        //高新兴通用模拟量	4~20mA或0~5V
    NET_SENSE_RSUDOOR,           //高新兴门禁感应
    NET_SENSE_RSUPOWEROFF,       //高新兴断电感应	
    NET_SENSE_TEMP1500 ,         //1500温度传感器	
    NET_SENSE_TEMPDS18B20 ,      //DS18B20温度传感器	
    NET_SENSE_HUMIDITY1500,      //1500湿度传感器
    NET_SENSE_INFRARED,          //红外报警
    NET_SENSE_FIREALARM,         //火警
	NET_SENSE_CO2,				 //CO2浓度检测,典型值:0~5000ppm
	NET_SNESE_SOUND,			 //噪音检测,典型值:30~130dB
	NET_SENSE_PM25,				 //PM2.5检测,典型值:0~1000ug/m3
	NET_SENSE_SF6,				 //SF6浓度检测,典型值:0~3000ppm
	NET_SENSE_O3,				 //臭氧浓度检测,典型值:0~100ppm
	NET_SENSE_AMBIENTLIGHT,		 //环境光照检测,典型值:0~20000Lux
    NET_SENSE_SIGNINBUTTON,      //签入按钮
	NET_SENSE_LIQUIDLEVEL,		 //液位
	NET_SENSE_DISTANCE,			 //测距
	NET_SENSE_WATERFLOW,		 //水流量



	NET_SENSE_NUM               //枚举类型总数
}NET_SENSE_METHOD;

//传感器感应方式对应单位的枚举类型
typedef enum tagEM_SENSE_METHOD_UNIT
{
	EM_SENSE_UNIT_UNKOWN =-1,		 // 未知类型
	EM_SENSE_TEMP_CENTIGRADE = 0,    // 温度单位: Centigrade
	EM_SENSE_TEMP_FAHRENHEIT,	     // 温度单位：Fahrenheit
	EM_SENSE_WIND_SPEED,             // 风速单位：m/s
	EM_SENSE_HUMIDITY_PERCENT,       // 湿度单位: Percent          
}EM_SENSE_METHOD_UNIT;	

// 布撤防模式
typedef enum tagNET_ALARM_MODE
{    
    NET_ALARM_MODE_UNKNOWN = -1,        // 未知
    NET_ALARM_MODE_DISARMING,           // 撤防
    NET_ALARM_MODE_ARMING,              // 布防
    NET_ALARM_MODE_FORCEON,             // 强制布防
    NET_ALARM_MODE_PARTARMING,          // 部分布防
}NET_ALARM_MODE;

// 布撤防场景模式
typedef enum tagNET_SCENE_MODE
{
    NET_SCENE_MODE_UNKNOWN,             // 未知场景
    NET_SCENE_MODE_OUTDOOR,             // 外出模式
    NET_SCENE_MODE_INDOOR,              // 室内模式
    NET_SCENE_MODE_WHOLE,               // 全局模式
    NET_SCENE_MODE_RIGHTNOW,            // 立即模式
    NET_SCENE_MODE_SLEEPING,            // 就寝模式
    NET_SCENE_MODE_CUSTOM,              // 自定义模式
}NET_SCENE_MODE;

// 触发方式
typedef enum tagNET_EM_TRIGGER_MODE
{
    NET_EM_TRIGGER_MODE_UNKNOWN = 0,
    NET_EM_TRIGGER_MODE_NET,            // 网络用户(平台或Web)
    NET_EM_TRIGGER_MODE_KEYBOARD,       // 键盘
    NET_EM_TRIGGER_MODE_REMOTECONTROL,  // 遥控器
}NET_EM_TRIGGER_MODE;

// 布撤防状态变化事件的信息
typedef struct tagALARM_ARMMODE_CHANGE_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;        // 报警事件发生的时间
    NET_ALARM_MODE      bArm;           // 变化后的状态
    NET_SCENE_MODE      emSceneMode;    // 情景模式
    DWORD               dwID;           // ID号, 遥控器编号或键盘地址, emTriggerMode为NET_EM_TRIGGER_MODE_NET类型时为0
    NET_EM_TRIGGER_MODE emTriggerMode;  // 触发方式
    char 				szNetClientAddr[64]; //网络用户IP地址或网络地址
    UINT            nUserCode;  //用户ID，0:管理员，1~20：普通用户，21：安装员，22：挟持用户  
}ALARM_ARMMODE_CHANGE_INFO;

// 防区类型
typedef enum
{
    NET_DEFENCEAREA_TYPE_UNKNOWN,       // 未知类型防区
    NET_DEFENCEAREA_TYPE_ALARM,         // 开关量防区
    NET_DEFENCEAREA_TYPE_ANALOGALARM,   // 模拟报警                 
}NET_DEFENCEAREA_TYPE;

// 旁路状态类型
typedef enum
{
    NET_BYPASS_MODE_UNKNOW,             //未知状态
    NET_BYPASS_MODE_BYPASS,             //旁路
    NET_BYPASS_MODE_NORMAL,             //正常
    NET_BYPASS_MODE_ISOLATED,           //隔离
}NET_BYPASS_MODE;

// 旁路状态变化事件的信息
typedef struct tagALARM_BYPASSMODE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // 通道号
    NET_TIME                stuTime;                    // 报警事件发生的时间
    NET_DEFENCEAREA_TYPE    emDefenceType;              // 防区类型
    int                     nIsExtend;                  // 是否为扩展(通道)防区, 1:扩展通道, 0: 非扩展通道
    NET_BYPASS_MODE         emMode;                     // 变化后的模式
    DWORD                   dwID;                       // ID号, 遥控器编号或键盘地址, emTriggerMode为NET_EM_TRIGGER_MODE_NET类型时为0
    NET_EM_TRIGGER_MODE     emTriggerMode;              // 触发方式
}ALARM_BYPASSMODE_CHANGE_INFO;


// 紧急事件(对应DH_URGENCY_ALARM_EX2, 对原有的DH_URGENCY_ALARM_EX类型的升级, 指人为触发的紧急事件, 一般处理是联动外部通讯功能请求帮助)
typedef struct tagALARM_URGENCY_ALARM_EX2 
{
    DWORD           dwSize;
    NET_TIME        stuTime;                     // 事件产生的时间
    DWORD           nID;                         // 用于标识不同的紧急事件
}ALARM_URGENCY_ALARM_EX2;

// 报警输入源事件详情(只要有输入就会产生改事件,不论防区当前的模式,无法屏蔽)
typedef struct tagALARM_INPUT_SOURCE_SIGNAL_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // 通道号
    int             nAction;                            // 0:开始 1:停止
    NET_TIME        stuTime;                            // 报警事件发生的时间
}ALARM_INPUT_SOURCE_SIGNAL_INFO;

// 模拟量报警输入通道事件信息(对应DH_ALARM_ANALOGALARM_EVENT)
typedef struct tagALARM_ANALOGALARM_EVENT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // 通道号
    int             nAction;                            // 0:开始 1:停止
    NET_TIME        stuTime;                            // 报警事件发生的时间
    NET_SENSE_METHOD  emSensorType;                     // 传感器类型
    char            szName[DH_COMMON_STRING_128];       // 通道名称
    int             nIsValid;                           // 数据是否有效,-1:未知,0:无效,1:有效
    int             nStatus;                            // 数据状态, -1:未知,0:正常,1:数据无效(超过量程),
                                                        // 2:超过阈值1,3:超过阈值2,4:超过阈值3,5:超过阈值4,
                                                        // 6:低于阈值1,7:低于阈值2,8:低于阈值3,9:低于阈值4
    float           fValue;                             // 探测器数值
    NET_TIME        stuCollectTime;                     // 数据采集时间(UTC)
    NET_GPS_STATUS_INFO stGPSStatus;                    // GPS信息 
}ALARM_ANALOGALARM_EVENT_INFO;


// 门禁状态类型
typedef enum tagNET_ACCESS_CTL_STATUS_TYPE
{
    NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN = 0,
    NET_ACCESS_CTL_STATUS_TYPE_OPEN,                    // 开门
    NET_ACCESS_CTL_STATUS_TYPE_CLOSE,                   // 关门
    NET_ACCESS_CTL_STATUS_TYPE_ABNORMAL,                // 异常
    NET_ACCESS_CTL_STATUS_TYPE_FAKELOCKED,              // 假锁
    NET_ACCESS_CTL_STATUS_TYPE_CLOSEALWAYS,           // 常闭
    NET_ACCESS_CTL_STATUS_TYPE_OPENALWAYS,            // 常开
}NET_ACCESS_CTL_STATUS_TYPE;

// 门禁状态事件
typedef struct tagALARM_ACCESS_CTL_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                  // 门通道号
    NET_TIME                    stuTime;                // 事件发生的时间
    NET_ACCESS_CTL_STATUS_TYPE  emStatus;               // 门禁状态
    char                        szSerialNumber[256];              //无线设备序列号(智能锁)
}ALARM_ACCESS_CTL_STATUS_INFO;

// 门禁抓图类型
typedef enum tagNET_ACCESS_SNAP_TYPE
{
    NET_ACCESS_SNAP_TYPE_UNKNOWN = 0,
    NET_ACCESS_SNAP_TYPE_CARD,                          // 刷卡
    NET_ACCESS_SNAP_TYPE_PASSWORD,                      // 密码
	NET_ACCESS_SNAP_TYPE_REMOTE,						// 远程开门
	NET_ACCESS_SNAP_TYPE_BUTTON,						// 开门按钮
	NET_ACCESS_SNAP_TYPE_FINGERPRINT,					// 指纹
	NET_ACCESS_SNAP_TYPE_QRCODE,						// 二维码
	NET_ACCESS_SNAP_TYPE_BLUETOOTH,						// 蓝牙
	NET_ACCESS_SNAP_TYPE_FACE,							// 人脸
}NET_ACCESS_SNAP_TYPE;

// 门禁抓图事件
typedef struct tagALARM_ACCESS_SNAP_INFO
{
    DWORD           dwSize;
    NET_ACCESS_SNAP_TYPE emType;                        // 类型
    char            szCardNO[DH_COMMON_STRING_32];      // 卡号, 刷卡开门时有效
    char            szPassword[DH_COMMON_STRING_64];    // 密码, 密码开门时才有效    
    char            szFtpUrl[MAX_PATH];                 // ftp上传地址, 图片路径
    int             nImageNum;                          // 抓图张数
    NET_TIME        stuTime;                            // 事件发生的时间
}ALARM_ACCESS_SNAP_INFO;

// 消警事件
typedef struct tagALARM_ALARMCLEAR_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // 通道号
    NET_TIME        stuTime;                            // 报警事件发生的时间
    int             bEventAction;                       // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
}ALARM_ALARMCLEAR_INFO;

// CID事件
typedef struct tagALARM_CIDEVENT_INFO
{
    DWORD           dwSize;
    NET_TIME        stuTime;                            // 报警事件发生的时间
    char            szCID[DH_COMMON_STRING_32];         // CID码,标准协议码 字符串长度为16,字符数值为0~F
                                                        // 4位用户码 + 2位识别码 + 1位事件限定码 + 3位事件码 + 2位系统号 + 3位防区码 + 1位校验码
}ALARM_CIDEVENT_INFO;

// 紧急救助事件类型
typedef enum tagEM_RCEMERGENCY_CALL_TYPE
{
    EM_RCEMERGENCY_CALL_UNKNOWN = 0,
    EM_RCEMERGENCY_CALL_FIRE,                           // 火警
    EM_RCEMERGENCY_CALL_DURESS,                         // 胁迫
    EM_RCEMERGENCY_CALL_ROBBER,                         // 匪警
    EM_RCEMERGENCY_CALL_MEDICAL,                        // 医疗
    EM_RCEMERGENCY_CALL_EMERGENCY,                      // 紧急
}EM_RCEMERGENCY_CALL_TYPE;

// 报警方式
typedef enum tagEM_RCEMERGENCY_MODE_TYPE
{
    EM_RCEMERGENCY_MODE_UNKNOWN = 0,
    EM_RCEMERGENCY_MODE_KEYBOARD,                       // 键盘
    EM_RCEMERGENCY_MODE_WIRELESS_CONTROL,               // 遥控器
}EM_RCEMERGENCY_MODE_TYPE;

// 紧急救助事件详情
typedef struct tagALARM_RCEMERGENCY_CALL_INFO 
{
    DWORD                       dwSize;
    int                         nAction;                // -1:未知 0:开始 1:停止
    EM_RCEMERGENCY_CALL_TYPE    emType;                 // 紧急类型
    NET_TIME                    stuTime;                // 事件发生时间
    EM_RCEMERGENCY_MODE_TYPE    emMode;                 // 报警方式
    DWORD                       dwID;                   // 用于标示不同的紧急事件(只有emMode是遥控器类型时有效, 表示遥控器的编号, 0表示无效ID)
}ALARM_RCEMERGENCY_CALL_INFO;

// 多人组合开门事件(对应DH_ALARM_OPENDOORGROUP类型)
typedef struct tagALARM_OPEN_DOOR_GROUP_INFO
{
    DWORD           dwSize;
    int             nChannelID;                         // 门通道号(从0开始)
    NET_TIME        stuTime;                            // 事件时间
}ALARM_OPEN_DOOR_GROUP_INFO;

// 获取指纹事件(对应DH_ALARM_FINGER_PRINT类型)
typedef struct tagALARM_CAPTURE_FINGER_PRINT_INFO 
{
    DWORD           dwSize;
    int             nChannelID;                         // 门通道号(从0开始)
    NET_TIME        stuTime;                            // 事件时间
    char            szReaderID[DH_COMMON_STRING_32];    // 门读卡器ID
    int             nPacketLen;                         // 单个指纹数据包长度
    int             nPacketNum;                         // 指纹数据包个数
    char*           szFingerPrintInfo;                  // 指纹数据(数据总长度即nPacketLen*nPacketNum)
	BOOL			bCollectResult;						// 采集结果
	char			szCardNo[32];						// 指纹所属人员卡号（定制）
	char			szUserID[32];						// 指纹所属人员ID（定制）
}ALARM_CAPTURE_FINGER_PRINT_INFO;

// 子系统状态类型
typedef enum __EM_SUBSYSTEM_STATE_TYPE
{
    EM_SUBSYSTEM_STATE_UNKNOWN = 0,                     // 未知
    EM_SUBSYSTEM_STATE_ACTIVE,                          // 已激活
    EM_SUBSYSTEM_STATE_INACTIVE,                        // 未激活
}EM_SUBSYSTEM_STATE_TYPE;

// 子系统状态改变事件
typedef struct tagALARM_SUBSYSTEM_STATE_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // 子系统序号(从0开始)
    NET_TIME                stuTime;                    // 事件发生的时间
    EM_SUBSYSTEM_STATE_TYPE emState;                    // 变化后的状态
}ALARM_SUBSYSTEM_STATE_CHANGE_INFO;

// 电池电量定时通知事件
typedef struct tagALARM_BATTERYPOWER_INFO
{
    DWORD       dwSize;
    int         nChannel;                                  // 电池序号
    NET_TIME    stuTime;                                   // 事件时间
    int         nPercent;                                  // 电池电量百分比
    float       fVoltage;                                  // 电压,单位:伏
    BOOL        bCharging;                                 // 是否正在充电 true:正在充电 false:没有充电
}ALARM_BATTERYPOWER_INFO;

// 警号状态事件
typedef struct tagALARM_BELLSTATUS_INFO 
{
    DWORD       dwSize;
    int         nChannel;                                   // 警号通道号 
    NET_TIME    stuTime;                                    // 事件时间
    int         nAction;                                    // 0:开始 1:停止
}ALARM_BELLSTATUS_INFO;

// 防区状态变化事件, 对应事件类型DH_ALARM_DEFENCE_STATE_CHANGE_EVENT
typedef struct tagALARM_DEFENCE_STATUS_CHANGE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 防区ID,即报警输入通道号(从0开始)
    NET_TIME                stuTime;                        // 事件发生的时间
    EM_DEFENCE_STATE_TYPE   emStatus;                       // 防区变化后的状态
}ALARM_DEFENCE_STATUS_CHANGE_INFO;

// 登陆失败事件
typedef struct tagALARM_LOGIN_FAILIUR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // 0:开始 1:停止
    unsigned int            nSequence;                      // 序号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名,填用户名称
    char                    szType[DH_COMMON_STRING_128];   // 登录类型
    char                    szAddr[DH_MAX_IPADDR_EX_LEN];   // 来源IP地址
    int                     nError;                         // 用户登陆失败错误码
}ALARM_LOGIN_FAILIUR_INFO;

// 车票统计信息事件 对应事件类型 DH_ALARM_TICKET_STATISTIC
typedef struct tagALARM_TICKET_STATISTIC
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS信息
    NET_TIME                stuTime;                        // 事件上报时间
    int                     nNormalCount;                   // 普通票张数
    int                     nDiscountCount;                 // 优惠票张数
    int                     nSubsidyCount;                  // 老幼补贴票张数
    int                     nDriverCount;                   // 司机票张数
    int                     nNormalPrice;                   // 普通票价格
    int                     nDiscountPrice;                 // 优惠票价格
    int                     nSubsidyPrice;                  // 老幼补贴票价格
}ALARM_TICKET_STATISTIC;

#define MAX_ALARMEXT_MODULE_NUM        256                  // 最大扩展模块数目

// 总线类型
typedef enum tagNET_BUS_TYPE
{
    NET_BUS_TYPE_UNKNOWN = 0,
    NET_BUS_TYPE_MBUS,                                      // M-BUS总线
    NET_BUS_TYPE_RS485,                                     // RS-485总线
    NET_BUS_TYPE_CAN,                                       // CAN总线
	NET_BUS_TYPE_NET,										// 网络设备
}NET_BUS_TYPE;

// 扩展模块掉线事件 对应事件类型 DH_ALARM_MODULE_LOST
typedef struct tagALARM_MODULE_LOST_INFO 
{
    DWORD                   dwSize;
    NET_TIME                stuTime;                        // 事件上报时间
    int                     nSequence;                      // 扩展模块接的总线的序号(从0开始)
    NET_BUS_TYPE            emBusType;                      // 总线类型
    int                     nAddr;                          // 掉线的扩展模块数目
    int                     anAddr[MAX_ALARMEXT_MODULE_NUM];// 掉线的扩展模块的序号(从0开始)
	char					szDevType[DH_COMMON_STRING_64];	// 设备类型 "SmartLock",是级联设备;当设备类型"AlarmDefence"接口序号为报警序号
															// "LiftController":梯控设备
	BOOL					bOnline;						// 在线情况,默认FALSE. false:不在线；true:在线
    char                    szSN[32];                       // 无线配件序列号	
}ALARM_MODULE_LOST_INFO;

// PSTN掉线事件
typedef struct tagALARM_PSTN_BREAK_LINE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                 // 电话线序号(从0开始)
    int                     nAction;                    // 0:开始 1:停止
    NET_TIME                stuTime;                    // 事件发生的时间
}ALARM_PSTN_BREAK_LINE_INFO;

// 模拟量报警事件(瞬时型事件), 特定传感器类型时(如超速、里程、油量)才触发
typedef struct tagALARM_ANALOGPULSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 模拟量报警通道号
    NET_TIME                stuEventTime;                   // 报警事件发生的时间
    NET_SENSE_METHOD        emSense;                        // 传感器类型
    char                    szName[DH_COMMON_STRING_128];   // 传感器名称
    int                     nStatus;                        // 数据状态, -1:未知,0:正常,1:数据无效(超过量程),
                                                            // 2:超过阈值1,3:超过阈值2,4:超过阈值3,5:超过阈值4,
                                                            // 6:低于阈值1,7:低于阈值2,8:低于阈值3,9:低于阈值4
    float                   fValue;                         // 传感器数值
    NET_TIME                stuCollectTime;                 // 采集时间
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;               // GPS信息
}ALARM_ANALOGPULSE_INFO;

//调度信息确认动作类型
typedef enum tagNET_MISSION_CONFIRM_TYPE
{
    NET_MISSION_CONFIRM_UNKNOWN = 0  ,  //未知
    NET_MISSION_CONFIRM_YES ,           //同意并执行
    NET_MISSION_CONFIRM_NO ,            //拒绝执行
}NET_MISSION_CONFIRM_TYPE;

// 任务确认事件(对应命令DH_ALARM_MISSION_CONFIRM)
typedef struct tagALARM_MISSION_CONFIRM_INFO 
{
    DWORD                   dwSize;
    char                    szTitle[DH_COMMON_STRING_256];   // 任务名称
    char                    szMissionID[DH_COMMON_STRING_256];// 任务ID
    char                    szComment[DH_COMMON_STRING_256]; // 回复内容
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                // GPS信息
    NET_MISSION_CONFIRM_TYPE emConfirmType;                  //调度信息确认动作类型
}ALARM_MISSION_CONFIRM_INFO;

// 集群节点分组类型
typedef enum tagNET_CLUSTER_GROUP_TYPE
{
    NET_CLUSTER_GROUP_UNKNOWN,                          // 未知
    NET_CLUSTER_GROUP_IDLE,                             // 单机
    NET_CLUSTER_GROUP_MASTER,                           // 主用
    NET_CLUSTER_GROUP_SLAVE,                            // 备用
}NET_CLUSTER_GROUP_TYPE;

// 节点激活事件, 对应事件类型 DH_ALARM_NODE_ACTIVE
typedef struct tagALARM_NODE_ACTIVE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                 // 集群中的节点号
    NET_TIME                stuTime;                    // 事件发生事件
    NET_CLUSTER_GROUP_TYPE  emGroup;                    // 当前节点所属组
}ALARM_NODE_ACTIVE_INFO;

// 集群节点状态
typedef struct tagNET_CLUSTER_STATE_INFO 
{
    DWORD                   dwSize;
    NET_CLUSTER_GROUP_TYPE  emGroup;                    // 当前节点所属组
}NET_CLUSTER_STATE_INFO;

// 设备报警的模式
typedef enum tagEM_ALARM_VIDEO_STATIC_MODE
{
    EM_ALARM_VIDEO_STATIC_MODE_UNKNOWN,                 // 未知
    EM_ALARM_VIDEO_STATIC_MODE_INDOOR,                  // 室内模式 "Indoor"
    EM_ALARM_VIDEO_STATIC_MODE_OUTDOOR,                 // 室外模式 "Outdoor"
}EM_ALARM_VIDEO_STATIC_MODE;

// 视频静态检测事件, 对应事件类型 DH_ALARM_VIDEO_STATIC
typedef struct tagALARM_VIDEO_STATIC_INFO 
{
    DWORD                       dwSize;
    DWORD                       dwAction;                       // 事件动作, 0:Start, 1:Stop
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                         // 设备报警的模式
    int                         nChannelID;                     // 视频静态检测报警通道号
}ALARM_VIDEO_STATIC_INFO;

// 主动注册设备重新登陆事件, 对应事件类型 DH_ALARM_REGISTER_REONLINE
typedef struct tagALARM_REGISTER_REONLINE_INFO
{
    DWORD           dwSize;
}ALARM_REGISTER_REONLINE_INFO;

// 连接状态
typedef enum tagEM_ALARM_ISCSI_STATUS
{
    EM_ALARM_ISCSI_STATUS_UNKNOWN,                  // 未知
    EM_ALARM_ISCSI_STATUS_CONNECTED,                // 已连接
    EM_ALARM_ISCSI_STATUS_NOT_CONNECTED,            // 未连接
    EM_ALARM_ISCSI_STATUS_CONNECT_FAILED,           // 连接失败
    EM_ALARM_ISCSI_STATUS_AUTHENTICATION_FAILED,    // 认证失败
    EM_ALARM_ISCSI_STATUS_CONNECT_TIMEOUT,          // 连接超时
    EM_ALARM_ISCSI_STATUS_NOT_EXIST,                // 设备不存在
}EM_ALARM_ISCSI_STATUS;

// ISCSI告警事件, 对应事件类型 DH_ALARM_ISCSI_STATUS
typedef struct tagALARM_ISCSI_STATUS_INFO
{
    DWORD                   dwSize;
    int                     nIndex;                             // 表示ISCSI设备索引号
    char                    szAddress[DH_COMMON_STRING_32];     // 服务器地址
    char                    szName[DH_COMMON_STRING_64];        // Target名称
    char                    szUserName[DH_COMMON_STRING_64];    // 用户名
    EM_ALARM_ISCSI_STATUS   emStatus;                           // 连接状态
}ALARM_ISCSI_STATUS_INFO;

//SCADA类型
typedef enum tagEM_ALARM_SCADA_DEV_TYPE
{
	EM_ALARM_SCADA_DEV_UNKNOWN,						// 未知
	EM_ALARM_SCADA_DEV_LEAKAGE,						// 漏水检测
	EM_ALARM_SCADA_DEV_THCONTROLLER,				// 湿温度
	EM_ALARM_SCADA_DEV_UPS,							// UPS
	EM_ALARM_SCADA_DEV_SWITCH,						// 开关电源
	EM_ALARM_SCADA_DEV_ELECTRICMETER,				// 智能电表
	EM_ALARM_SCADA_DEV_COMMERCIALPOWER,				// 市电检测
	EM_ALARM_SCADA_DEV_BATTERY,						// 蓄电池
	EM_ALARM_SCADA_DEV_AIRCONDITION,				// 空调
	EM_ALARM_SCADA_DEV_ACCESS,						// 门禁
	EM_ALARM_SCADA_DEV_SMOKINGSENSOR,				// 烟感
	EM_ALARM_SCADA_DEV_INFRARED,					// 红外
	EM_ALARM_SCADA_DEV_CHEMICAL,					// 化工
 	EM_ALARM_SCADA_DEV_PERIMETER,					// 周界
	EM_ALARM_SCADA_DEV_DOORMAGNETISM,				// 门磁
	EM_ALARM_SCADA_DEV_DISTANCE,					// 测距
	EM_ALARM_SCADA_DEV_WINDSENSOR,					// 风速
	EM_ALARM_SCADA_DEV_LOCATION,					// 位置
	EM_ALARM_SCADA_DEV_ATMOSPHERE,					// 大气
	EM_ALARM_SCADA_DEV_SOLARPOWER,					// 太阳能
}EM_ALARM_SCADA_DEV_TYPE;

//设备状态
typedef enum tagEM_SCADA_DEVICE_STATUS
{
	EM_SCADA_DEVICE_STATUS_KNOWN = -1,								// 未知
	EM_SCADA_DEVICE_STATUS_NORMAL,									// 正常
	EM_SCADA_DEVICE_STATUS_ALARM,									// 报警
	EM_SCADA_DEVICE_STATUS_OFFLINE,									// 离线
}EM_SCADA_DEVICE_STATUS;

// 检测采集设备报警事件, 对应事件类型 DH_ALARM_SCADA_DEV_ALARM
typedef struct tagALARM_SCADA_DEV_INFO 
{
    DWORD							dwSize;
    int								nChannel;                           // 通道号
    NET_TIME						stuTime;                            // 事件发生的时间
    char							szDevName[DH_COMMON_STRING_64];     // 故障设备名称
    char							szDesc[DH_COMMON_STRING_256];       // 报警描述
    int								nAction;                            // -1:未知 0:脉冲 1:开始 2:停止
    char							szID[DH_COMMON_STRING_32];          // 点位ID, 目前使用16字节
    char							szSensorID[DH_COMMON_STRING_32];    // 设备ID, 目前使用16字节
    char							szDevID[DH_COMMON_STRING_32];       // 报警主机ID, 目前使用16字节
    char							szPointName[DH_COMMON_STRING_64];   // 点位名,与点表匹配
    int								nAlarmFlag;                         // 0:开始, 1:结束
	EM_ALARM_SCADA_DEV_TYPE			emDevType;							// 设备类型
	EM_SCADA_DEVICE_STATUS			emDevStatus;						// 设备状态
}ALARM_SCADA_DEV_INFO;

// 车辆ACC报警事件, 对应事件类型 DH_ALARM_VEHICLE_ACC
typedef struct tagALARM_VEHICLE_ACC_INFO 
{
    DWORD                   dwSize;
    int                     nACCStatus;                         // ACC状态, 0:无效, 1:开启, 2:关闭 
    int                     nAction;                            // 事件动作, 0:Start, 1:Stop
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                   // GPS信息
    int                     nConstantElectricStatus;            // 常电状态, 0:未知, 1:连接, 2:断开                            
	NET_TIME_EX				stuTime;							// 事件发生的时间
	unsigned int			nTotalMileage;						// 总的里程数,单位:米,当nACCStatus为2时,将ntotalMileage进行上报
	NET_TIME_EX				stuStartTime;						// nACCStatus为1时刻的时间
	NET_GPS_STATUS_INFO		stuStartGPS;						// nACCStatus为1时刻的GPS信息
}ALARM_VEHICLE_ACC_INFO;

typedef NET_ACCESS_CTL_STATUS_TYPE  NET_ACCESS_LOCK_STATUS_TYPE;

// 门锁状态事件, 对应事件类型 DH_ALARM_ACCESS_LOCK_STATUS
typedef struct tagALARM_ACCESS_LOCK_STATUS_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                       // 门通道号(从0开始)
    NET_TIME                    stuTime;                        // 事件发生的时间
    NET_ACCESS_LOCK_STATUS_TYPE emLockStatus;                   // 门锁状态
}ALARM_ACCESS_LOCK_STATUS_INFO;

// 业务类型
typedef enum tagEM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE
{
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_UNKNOWN,         // 未知
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_ORGANIZATION,    // 机构性理财
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_SEAL,            // 封闭式理财
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EXCLUSIVE,       // 专属理财
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_GATHER,          // 集合理财计划
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE_EVEN,            // 保本理财
}EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE;

// 理财经办事件, 对应事件类型 DH_ALARM_FINACE_SCHEME
typedef struct tagALARM_FINACE_SCHEME_INFO 
{
    DWORD                       dwSize;
    int                         nChannel;                                   // 视频通道号
    char                        szBusinessSeverID[DH_COMMON_STRING_64];     // 业务单号
    EM_ALARM_FINACE_SCHEME_BUSINESS_SEVER_TYPE  emBusinessSeverType;        // 业务类型
    NET_TIME                    stuFinaceSchemeTime;                        // 理财经办时间
    NET_TIME                    stuSchemeStartTime;                         // 理财生效时间
    NET_TIME                    stuSchemeEndTime;                           // 理财失效时间
    char                        szProductName[DH_COMMON_STRING_128];        // 理财产品名称
    char                        szCardNo[DH_COMMON_STRING_64];              // 银行卡号
    char                        szPersonID[DH_COMMON_STRING_64];            // 客户身份证
    char                        szPersonName[DH_COMMON_STRING_64];          // 客户姓名
    char                        szOrgNo[DH_COMMON_STRING_64];               // 支行机构号
    char                        szStuffID[DH_COMMON_STRING_64];             // 银行员工工号
    NET_TIME                    stuRecStartTime;                            // 录像开始时间
    NET_TIME                    stuRecEndTime;                              // 录像结束时间
}ALARM_FINACE_SCHEME_INFO;

//////////////////////////////////////////////////////////////////////////

// 记录集新增操作(insert)输入参数
typedef struct tagNET_CTRL_RECORDSET_IN
{
    DWORD           dwSize;
    EM_NET_RECORD_TYPE emType;                          // 记录集信息类型
    void*           pBuf;                               // 记录集信息缓存,详见EM_NET_RECORD_TYPE注释，由用户申请内存.
	int             nBufLen;                            // 记录集信息缓存大小,大小参照记录集信息类型对应的结构体
}NET_CTRL_RECORDSET_INSERT_IN;

// 记录集新增操作(insert)输出参数
typedef struct tagNET_CTRL_RECORDSET_OUT 
{
    DWORD           dwSize;
    int             nRecNo;                             // 记录编号(新增insert时设备返回)
}NET_CTRL_RECORDSET_INSERT_OUT;

// 记录集新增操作(insert)参数
typedef struct tagNET_CTRL_RECORDSET_INSERT_PARAM 
{
    DWORD                           dwSize;
    NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // 记录集信息(用户填写)
    NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // 记录集信息(设备返回)
}NET_CTRL_RECORDSET_INSERT_PARAM;

// 记录集操作参数
typedef struct tagNET_CTRL_RECORDSET_PARAM 
{
    DWORD               dwSize;
    EM_NET_RECORD_TYPE  emType;                         // 记录集信息类型
    void*               pBuf;                           // 新增\更新\查询\导入时,为记录集信息缓存,详见 EM_NET_RECORD_TYPE 注释,由用户申请内存，长度为nBufLen
                                                        // 删除时,为存放记录集编号的内存地址(类型为int*)
    int                 nBufLen;                        // 记录集信息缓存大小,大小参照记录集信息类型对应的结构体
}NET_CTRL_RECORDSET_PARAM;

// 视频播放模式
typedef enum tagEM_VIDEO_PLAY_MODE_TYPE
{
    EM_VIDEO_PLAY_MODE_TYPE_UNKNOWN,                    // 未知
    EM_VIDEO_PLAY_MODE_TYPE_ONCE,                       // 播放一次
    EM_VIDEO_PLAY_MODE_TYPE_REPEAT,                     // 循环播放
}EM_VIDEO_PLAY_MODE_TYPE;

#define MAX_DELIVERY_FILE_NUM 128                       // 最大投放文件数量
#define DELIVERY_FILE_URL_LEN 128                       // 投放文件的URL长度

// 投放的文件类型
typedef enum tagEM_DELIVERY_FILE_TYPE
{
    EM_DELIVERY_FILE_TYPE_UNKNOWN,                      // 未知
    EM_DELIVERY_FILE_TYPE_VIDEO,                        // 视频
    EM_DELIVERY_FILE_TYPE_IMAGE,                        // 图片
	EM_DELIVERY_FILE_TYPE_AUDIO,                        // 音频
}EM_DELIVERY_FILE_TYPE;

// 文件所属的模式
typedef enum tagEM_PLAY_WITH_MODE
{
    EM_PLAY_WITH_MODE_UNKNOWN,                          // 未知
    EM_PLAY_WITH_MODE_RECOGNITION,                      // 识别模式
    EM_PLAY_WITH_MODE_INFORMATION_RELEASE,              // 信息发布模式
} EM_PLAY_WITH_MODE;

// 投放文件信息
typedef struct tagNET_DELIVERY_FILE_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // 文件类型
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // 文件的资源地址
    int                     nImageSustain;                      // 每张图片停留多长时间，单位秒 (emFileType为EM_DELIVERY_FILE_TYPE_IMAGE时此字段有效)
    EM_PLAY_WITH_MODE       emPlayWithMode;                     // 文件所属的模式
    BYTE                    byReserved[1020];                   // 保留字节
}NET_DELIVERY_FILE_INFO;

// 向视频输出口投放视频和图片文件
typedef struct tagNET_CTRL_DELIVERY_FILE 
{
    DWORD                   dwSize;                             // 结构体大小
    int                     nPort;                              // 视频输出口
    EM_VIDEO_PLAY_MODE_TYPE emPlayMode;                         // 播放类型
    NET_TIME                stuStartPlayTime;                   // 开始播放的时间
    NET_TIME                stuStopPlayTime;                    // 结束播放的时间，emPlayMode为EM_VIDEO_PLAY_MODE_TYPE_REPEAT时，此值有效    
    int                     nFileCount;                         // 投放的文件个数
    NET_DELIVERY_FILE_INFO  stuFileInfo[MAX_DELIVERY_FILE_NUM]; // 投放的文件信息
}NET_CTRL_DELIVERY_FILE;

// 投放文件信息
typedef struct tagNET_DELIVERY_FILE_BYCAR_INFO
{
    EM_DELIVERY_FILE_TYPE   emFileType;                         // 文件类型
    char                    szFileURL[DELIVERY_FILE_URL_LEN];   // 文件的资源地址
    int                     nImageSustain;                      // 每张图片停留多长时间，单位秒 (emFileType为EM_DELIVERY_FILE_TYPE_IMAGE时此字段有效)
    NET_TIME                stuStartPlayTime;                   // 开始播放的时间
    NET_TIME                stuStopPlayTime;                    // 结束播放的时间，emPlayMode为EM_VIDEO_PLAY_MODE_TYPE_REPEAT时，此值有效    
    BYTE                    byReserved[1024];                   // 保留字节
}NET_DELIVERY_FILE_BYCAR_INFO;

// 向视频输出口投放视频和图片文件, 车载使用，广告单独时间投放
typedef struct tagNET_CTRL_DELIVERY_FILE_BYCAR
{
    DWORD                           dwSize;                             // 结构体大小
    int                             nPort;                              // 视频输出口
    EM_VIDEO_PLAY_MODE_TYPE         emPlayMode;                         // 播放类型
    int                             nFileCount;                         // 投放的文件个数
    NET_DELIVERY_FILE_BYCAR_INFO    stuFileInfo[MAX_DELIVERY_FILE_NUM]; // 投放的文件信息
}NET_CTRL_DELIVERY_FILE_BYCAR;

// 卡状态
typedef enum tagNET_ACCESSCTLCARD_STATE
{
    NET_ACCESSCTLCARD_STATE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_STATE_NORMAL = 0,                 // 正常
    NET_ACCESSCTLCARD_STATE_LOSE   = 0x01,              // 挂失
    NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02,              // 注销
    NET_ACCESSCTLCARD_STATE_FREEZE = 0x04,              // 冻结
    NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08,           // 欠费
    NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10,             // 逾期
    NET_ACCESSCTLCARD_STATE_PREARREARAGE = 0x20,        // 预欠费(还是可以开门,但有语音提示)
}NET_ACCESSCTLCARD_STATE;

// 卡类型
typedef enum tagNET_ACCESSCTLCARD_TYPE
{
    NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1,
    NET_ACCESSCTLCARD_TYPE_GENERAL,                     // 一般卡
    NET_ACCESSCTLCARD_TYPE_VIP,                         // VIP卡
    NET_ACCESSCTLCARD_TYPE_GUEST,                       // 来宾卡
    NET_ACCESSCTLCARD_TYPE_PATROL,                      // 巡逻卡
    NET_ACCESSCTLCARD_TYPE_BLACKLIST,                   // 黑名单卡
    NET_ACCESSCTLCARD_TYPE_CORCE,                       // 胁迫卡
	NET_ACCESSCTLCARD_TYPE_POLLING,                     // 巡检卡
	NET_ACCESSCTLCARD_TYPE_GB_CUSTOM1,                  // 国标自定义1卡,上海新地标定制，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_GB_CUSTOM2,                  // 国标自定义2卡,上海新地标定制，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_TEMPORARY_PERSON = 0x09,		// 临时人员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_INVENTORY_PERSON,			// 清分人员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_INVENTORY_DIRECTOR,			// 清分主管，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_SECURITY_GUARD,				// 保卫人员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_SECURITYGUARD_DIRECTOR,		// 保卫主管，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_STORE_KEEPER,				// 库管员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_STORE_DIRECTOR,				// 库主管，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_ESCORT_PERSON,				// 押运人员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_REPAIR_PERSON,				// 维修人员，定制项目，不支持配套，其他项目禁用
	NET_ACCESSCTLCARD_TYPE_INSPECTOR = 0x12,			// 检查人员，定制项目，不支持配套，其他项目禁用
    NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff,           // 母卡
}NET_ACCESSCTLCARD_TYPE;

#define DH_MAX_DOOR_NUM               32                // 最大有权限门禁数目
#define DH_MAX_TIMESECTION_NUM        32                // 最大有效时间段数目
#define DH_MAX_CARDNAME_LEN           64                // 门禁卡命名最大长度
#define DH_MAX_CARDNO_LEN             32                // 门禁卡号最大长度
#define DH_MAX_USERID_LEN             32                // 门禁卡用户ID最大长度
#define DH_MAX_IC_LEN				  32				// 身份证最大长度
#define DH_MAX_QRCODE_LEN			  128				// QRCode 最大长度

// 指纹数据，只用于下发信息
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET
{
    DWORD   dwSize; 
    int     nLength;        // 单个数据包长度,单位字节
    int     nCount;         // 包个数
    char*   pPacketData;    // 所有指纹数据包，用户申请内存并填充，长度为 nLength*nCount
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET;

// 指纹数据扩展，可用于下发和获取信息
typedef struct tagNET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX
{
    int     nLength;        // 单个数据包长度,单位字节
    int     nCount;         // 包个数
    char*   pPacketData;    // 所有指纹数据包, 用户申请内存,大小至少为nLength * nCount
    int     nPacketLen;     // pPacketData 指向内存区的大小，用户填写
    int     nRealPacketLen; // 返回给用户实际指纹总大小
	int	    nDuressIndex;   // 胁迫指纹序号，范围1~nCount
    BYTE    byReverseed[1020]; //保留大小
}NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX;

#define MAX_REPEATENTERROUTE_NUM   12 //反潜路径个数

// 帽子款式
typedef enum tagEM_HAT_STYLE
{
	EM_HAT_UNKNOWN,									// 未知
	EM_HAT_ORDINARY,								// 普通帽子
	EM_HAT_HELMET,									// 头盔
	EM_HAT_SAFETYHAT,								// 安全帽
	EM_HAT_EAVELESS,								// 无檐帽
	EM_HAT_PEAKEDCAP,								// 鸭舌帽
	EM_HAT_FISHERMANHAT,							// 渔夫帽
	EM_HAT_NONE,									// 未戴帽
} EM_HAT_STYLE;

// 统一后的颜色枚举
typedef enum tagEM_UNIFIED_COLOR_TYPE
{
	EM_UNIFIED_COLOR_TRANSPARENT = -1,				// 透明
	EM_UNIFIED_COLOR_UNKNOWN,						// 未知
	EM_UNIFIED_COLOR_WHITE,							// 白色
	EM_UNIFIED_COLOR_ORANGE,						// 橙色
	EM_UNIFIED_COLOR_PINK,							// 粉色
	EM_UNIFIED_COLOR_BLACK,							// 黑色
	EM_UNIFIED_COLOR_RED,							// 红色
	EM_UNIFIED_COLOR_YELLOW,						// 黄色
	EM_UNIFIED_COLOR_GRAY,							// 灰色
	EM_UNIFIED_COLOR_BLUE,							// 蓝色
	EM_UNIFIED_COLOR_GREEN,							// 绿色
	EM_UNIFIED_COLOR_PURPLE,						// 紫色
	EM_UNIFIED_COLOR_BROWN,							// 棕色	
}EM_UNIFIED_COLOR_TYPE;

// 性别
typedef enum tagNET_ACCESSCTLCARD_SEX
{
    NET_ACCESSCTLCARD_SEX_UNKNOWN,
    NET_ACCESSCTLCARD_SEX_MALE,                           // 男
    NET_ACCESSCTLCARD_SEX_FEMALE,                         // 女    
}NET_ACCESSCTLCARD_SEX;

// 用户权限
typedef enum tagNET_ACCESSCTLCARD_AUTHORITY
{
    NET_ACCESSCTLCARD_AUTHORITY_UNKNOWN,                  // 未知
    NET_ACCESSCTLCARD_AUTHORITY_ADMINISTRATORS,           // 管理员 
    NET_ACCESSCTLCARD_AUTHORITY_CUSTOMER,                 // 普通用户      
}NET_ACCESSCTLCARD_AUTHORITY;

// 门禁卡记录集信息
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARD
{
    DWORD           dwSize;
    int             nRecNo;                                 // 记录集编号,只读
    NET_TIME        stuCreateTime;                          // 创建时间
    char            szCardNo[DH_MAX_CARDNO_LEN];            // 卡号
    char            szUserID[DH_MAX_USERID_LEN];            // 用户ID, 设备暂不支持
    NET_ACCESSCTLCARD_STATE       emStatus;                 // 卡状态
    NET_ACCESSCTLCARD_TYPE        emType;                   // 卡类型
    char            szPsw[DH_MAX_CARDPWD_LEN];              // 卡密码
    int             nDoorNum;                               // 有效的门数目;
    int             sznDoors[DH_MAX_DOOR_NUM];              // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置的数组下标
    int             nTimeSectionNum;                        // 有效的的开门时间段数目
    int             sznTimeSectionNo[DH_MAX_TIMESECTION_NUM];  // 开门时间段索引,即CFG_ACCESS_TIMESCHEDULE_INFO的数组下标
    int             nUserTime;                              // 使用次数,仅当来宾卡时有效
    NET_TIME        stuValidStartTime;                      // 开始有效期, 设备暂不支持时分秒
    NET_TIME        stuValidEndTime;                        // 结束有效期, 设备暂不支持时分秒
    BOOL            bIsValid;                               // 是否有效,TRUE有效;FALSE无效
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;// 下发指纹数据信息，仅为兼容性保留，请使用 stuFingerPrintInfoEx
    BOOL            bFirstEnter;                            // 是否拥有首卡权限
    char            szCardName[DH_MAX_CARDNAME_LEN];        // 卡命名
    char            szVTOPosition[DH_COMMON_STRING_64];     // 门口机关联位置
    BOOL            bHandicap;                              // 是否为残疾人卡
    BOOL            bEnableExtended;                        // 启用成员 stuFingerPrintInfoEx
    NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX     stuFingerPrintInfoEx;	// 指纹数据信息
    int             nFaceDataNum;                           // 人脸数据个数不超过20
    char            szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];	// 人脸模版数据
	char			szDynamicCheckCode[MAX_COMMON_STRING_16];			// 动态校验码。
																		// VTO等设备会保存此校验码，以后每次刷卡都以一定的算法生成新校验码并写入IC卡中，同时更新VTO设备的校验码，只有卡号和此校验码同时验证通过时才可开门。
																		// 缺点：目前方案只支持一卡刷一个设备。
    int             nRepeatEnterRouteNum;                         // 反潜路径个数
    int             arRepeatEnterRoute[MAX_REPEATENTERROUTE_NUM]; // 反潜路径
    int             nRepeatEnterRouteTimeout;                     // 反潜超时时间
    BOOL            bNewDoor;                                     // 是否启动新开门授权字段，TRUE表示使用nNewDoorNum和nNewDoors字段下发开门权限
    int             nNewDoorNum;                                  // 有效的门数目;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];                // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置的数组下标
    int             nNewTimeSectionNum;                           // 有效的的开门时间段数目
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];        // 开门时间段索引,即CFG_ACCESS_TIMESCHEDULE_INFO的数组下标
	char			szCitizenIDNo[MAX_COMMON_STRING_32];		  // 身份证号码
	int				nSpecialDaysScheduleNum;					  // 假日计划表示数量
	int				arSpecialDaysSchedule[MAX_ACCESSDOOR_NUM];	  // 假日计划标识
    UINT            nUserType;                                    // 用户类型, 0 普通用户, 1 黑名单用户
    int             nFloorNum;                                              // 有效的楼层数量
    char            szFloorNo[MAX_ACCESS_FLOOR_NUM][DH_COMMON_STRING_4];   // 楼层号
	char			szSection[MAX_COMMON_STRING_64];				// 部门名称
    int             nScore;                                         // 信用积分
    char            szCompanyName[MAX_COMPANY_NAME_LEN];            // 单位名称
	UINT			nSectionID;										// 部门ID
    NET_ACCESSCTLCARD_SEX        emSex;                             // 性别
    char            szRole[MAX_COMMON_STRING_32];                   // 角色
    char            szProjectNo[MAX_COMMON_STRING_32];              // 项目ID
    char            szProjectName[MAX_COMMON_STRING_64];            // 项目名称
    char            szBuilderName[MAX_COMMON_STRING_64];            // 施工单位全称
    char            szBuilderID[MAX_COMMON_STRING_32];              // 施工单位ID
    char            szBuilderType[MAX_COMMON_STRING_32];            // 施工单位类型
    char            szBuilderTypeID[MAX_COMMON_STRING_8];           // 施工单位类别ID
    char            szPictureID[MAX_COMMON_STRING_64];              // 人员照片ID
    char            szContractID[MAX_COMMON_STRING_16];             // 原合同系统合同编号
    char            szWorkerTypeID[MAX_COMMON_STRING_8];            // 工种ID
    char            szWorkerTypeName[MAX_COMMON_STRING_32];         // 工种名称
    BOOL            bPersonStatus;                                  // 人员状态, TRUE:启用, FALSE:禁用
    NET_ACCESSCTLCARD_AUTHORITY   emAuthority;                      // 用户权限
    char			szCompanionName[120];							// 陪同人姓名
    char			szCompanionCompany[200];						// 陪同人单位
	NET_TIME		stuTmpAuthBeginTime;							// 临时授权开始时间,当该时间和其他时间同时生效时，以此时间为最高优先级
	NET_TIME		stuTmpAuthEndTime;								// 临时授权结束时间,当该时间和其他时间同时生效时，以此时间为最高优先级
	BOOL			bFloorNoExValid;								// 楼层号扩展 szFloorNoEx 是否有效
	int             nFloorNumEx;									// 有效的楼层数量扩展
	char            szFloorNoEx[512][DH_COMMON_STRING_4];			// 楼层号扩展
	char			szSubUserID[32];								// 用户ID（定制）
}NET_RECORDSET_ACCESS_CTL_CARD;

// 门禁密码记录集信息
typedef struct tagNET_RECORDSET_ACCESS_CTL_PWD 
{
    DWORD           dwSize;
    int             nRecNo;                                 // 记录集编号,只读
    NET_TIME        stuCreateTime;                          // 创建时间
    char            szUserID[DH_MAX_USERID_LEN];            // 用户ID, 设备暂不支持
    char            szDoorOpenPwd[DH_MAX_CARDPWD_LEN];      // 开门密码
    char            szAlarmPwd[DH_MAX_CARDPWD_LEN];         // 报警密码
    int             nDoorNum;                               // 有效的的门数目
    int             sznDoors[DH_MAX_DOOR_NUM];              // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置CFG_ACCESS_EVENT_INFO的数组下标
    char            szVTOPosition[DH_COMMON_STRING_64];     // 门口机关联位置
    int             nTimeSectionNum;                        // 开门时间段个数
    int             nTimeSectionIndex[DH_MAX_TIMESECTION_NUM];  // 开门时间段索引,是个数组，每个元素与sznDoors中的门对应
    BOOL            bNewDoor;                               // 是否启动新开门授权字段，TRUE表示使用nNewDoorNum和nNewDoors字段下发开门权限
    int             nNewDoorNum;                            // 有效的门数目;
    int             nNewDoors[MAX_ACCESSDOOR_NUM];          // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置的数组下标
    int             nNewTimeSectionNum;                     // 有效的的开门时间段数目
    int             nNewTimeSectionNo[MAX_ACCESSDOOR_NUM];  // 开门时间段索引,即CFG_ACCESS_TIMESCHEDULE_INFO的数组下标
    NET_TIME        stuValidStartTime;                      // 开始有效期
    NET_TIME        stuValidEndTime;                        // 结束有效期
    int        		nValidCounts;							// 有效次数
	char			szCitizenIDNo[20];						// 身份证号码
}NET_RECORDSET_ACCESS_CTL_PWD;


// 开门方式(门禁配置,门的一种工作模式)
typedef enum tagNET_DOOR_OPEN_METHOD
{
    NET_DOOR_OPEN_METHOD_UNKNOWN = 0,
    NET_DOOR_OPEN_METHOD_PWD_ONLY,                          // 只允许密码开锁
    NET_DOOR_OPEN_METHOD_CARD,                              // 只允许刷卡开锁
    NET_DOOR_OPEN_METHOD_PWD_OR_CARD,                       // 密码或刷卡开锁
    NET_DOOR_OPEN_METHOD_CARD_FIRST,                        // 先刷卡后密码开锁
    NET_DOOR_OPEN_METHOD_PWD_FIRST,                         // 先密码后刷卡开锁
    NET_DOOR_OPEN_METHOD_SECTION,                           // 分时段开门
}NET_DOOR_OPEN_METHOD;

// 开门方式(门禁事件,门禁出入记录,实际的开门方式)
typedef enum tagNET_ACCESS_DOOROPEN_METHOD
{
    NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0,
    NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY,                    // 密码开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD,                        // 刷卡开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST,                  // 先刷卡后密码开锁
    NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST,                   // 先密码后刷卡开锁
    NET_ACCESS_DOOROPEN_METHOD_REMOTE,                      // 远程开锁,如通过室内机或者平台对门口机开锁
    NET_ACCESS_DOOROPEN_METHOD_BUTTON,                      // 开锁按钮进行开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT,                 // 指纹开锁
    NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT,        // 密码+刷卡+指纹组合开锁
    NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10,        // 密码+指纹组合开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11,       // 刷卡+指纹组合开锁
    NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12,                // 多人开锁
    NET_ACCESS_DOOROPEN_METHOD_KEY = 13,                    // 钥匙开门
    NET_ACCESS_DOOROPEN_METHOD_COERCE_PWD = 14,             // 胁迫密码开门
    NET_ACCESS_DOOROPEN_METHOD_QRCODE = 15,                 // 二维码开门
    NET_ACCESS_DOOROPEN_METHOD_FACE_RECOGNITION = 16,       // 人脸识别开门
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD = 18,             // 人证对比
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_AND_IDCARD = 19,	// 身份证+ 人证比对
    NET_ACCESS_DOOROPEN_METHOD_BLUETOOTH = 20,				//蓝牙开门
    NET_ACCESS_DOOROPEN_METHOD_CUSTOM_PASSWORD = 21,        // 个性化密码开门
    NET_ACCESS_DOOROPEN_METHOD_USERID_AND_PWD = 22,         // UserID+密码
    NET_ACCESS_DOOROPEN_METHOD_FACE_AND_PWD = 23,           // 人脸+密码开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_PWD = 24,    // 指纹+密码开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE = 25,   // 指纹+人脸开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE = 26,          // 刷卡+人脸开锁
    NET_ACCESS_DOOROPEN_METHOD_FACE_OR_PWD = 27,            // 人脸或密码开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_PWD = 28,     // 指纹或密码开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE = 29,    // 指纹或人脸开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE = 30,           // 刷卡或人脸开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT = 31,    // 刷卡或指纹开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE_AND_PWD   = 32,             // 指纹+人脸+密码开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE_AND_PWD = 33,                      // 刷卡+人脸+密码开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_PWD = 34,               // 刷卡+指纹+密码开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_PWD_AND_FACE = 35,                      // 卡+指纹+人脸组合开锁
    NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE_OR_PWD = 36,                 // 指纹或人脸或密码
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE_OR_PWD = 37,                        // 卡或人脸或密码开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE = 38,                // 卡或指纹或人脸开锁
    NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_FACE_AND_PWD = 39,      // 卡+指纹+人脸+密码组合开锁 
    NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE_OR_PWD     = 40,     // 卡或指纹或人脸或密码开锁
    NET_ACCESS_DOOROPEN_METHOD_FACEIPCARDANDIDCARD_OR_CARD_OR_FACE    = 41,     //(身份证+人证比对)或 刷卡 或 人脸
    NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_OR_CARD_OR_FACE = 42,                 // 人证比对 或 刷卡(二维码) 或 人脸
    NET_ACCESS_DOOROPEN_METHOD_DTMF = 43,					//DTMF开锁(包括SIPINFO,RFC2833,INBAND)
	NET_ACCESS_DOOROPEN_METHOD_REMOTE_QRCODE = 44,			// 远程二维码开门
	NET_ACCESS_DOOROPEN_METHOD_REMOTE_FACE = 45,			// 远程人脸开门
	NET_ACCESS_DOOROPEN_METHOD_CITIZEN_FINGERPRINT = 46,		// 人证比对开门(指纹)
}NET_ACCESS_DOOROPEN_METHOD;

//考勤状态
typedef enum tagNET_ATTENDANCESTATE
{
    NET_ATTENDANCESTATE_UNKNOWN,
    NET_ATTENDANCESTATE_SIGNIN,                    //签入
    NET_ATTENDANCESTATE_GOOUT,                     //外出
    NET_ATTENDANCESTATE_GOOUT_AND_RETRUN,          //外出归来
    NET_ATTENDANCESTATE_SIGNOUT,                   // 签出
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNIN,      // 加班签到
    NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNOUT,     // 加班签出
}NET_ATTENDANCESTATE;

// 开门方向
typedef enum tagNET_ENUM_DIRECTION_ACCESS_CTL
{
    NET_ENUM_DIRECTION_UNKNOWN,
    NET_ENUM_DIRECTION_ENTRY,                              // 进门             
    NET_ENUM_DIRECTION_EXIT,                               // 出门
}NET_ENUM_DIRECTION_ACCESS_CTL;
// 民族
typedef enum tagEM_CITIZENIDCARD_ETHNICITY_TYPE
{
	EM_CITIZENIDCARD_ETHNICITY_Unknown = 0,				// 未知
	EM_CITIZENIDCARD_ETHNICITY_Han,						// 汉族
	EM_CITIZENIDCARD_ETHNICITY_Mongolian,				// 蒙古族
	EM_CITIZENIDCARD_ETHNICITY_Hui,						// 回族
	EM_CITIZENIDCARD_ETHNICITY_Tibetan,					// 藏族
	EM_CITIZENIDCARD_ETHNICITY_Uygur,					// 维吾尔族
	EM_CITIZENIDCARD_ETHNICITY_Miao,					// 苗族
	EM_CITIZENIDCARD_ETHNICITY_Yi,						// 彝族
	EM_CITIZENIDCARD_ETHNICITY_Zhuang,					// 壮族
	EM_CITIZENIDCARD_ETHNICITY_Bouyei,					// 布依族
	EM_CITIZENIDCARD_ETHNICITY_Korean,					// 朝鲜族
	EM_CITIZENIDCARD_ETHNICITY_Manchu,					// 满族
	EM_CITIZENIDCARD_ETHNICITY_Dong,					// 侗族
	EM_CITIZENIDCARD_ETHNICITY_Yao,						// 瑶族
	EM_CITIZENIDCARD_ETHNICITY_Bai,						// 白族
	EM_CITIZENIDCARD_ETHNICITY_Tujia,					// 土家族
	EM_CITIZENIDCARD_ETHNICITY_Hani,					// 哈尼族
	EM_CITIZENIDCARD_ETHNICITY_Kazak,					// 哈萨克族
	EM_CITIZENIDCARD_ETHNICITY_Dai,						// 傣族
	EM_CITIZENIDCARD_ETHNICITY_Li,						// 黎族
	EM_CITIZENIDCARD_ETHNICITY_Lisu,					// 傈僳族
	EM_CITIZENIDCARD_ETHNICITY_Va,						// 佤族
	EM_CITIZENIDCARD_ETHNICITY_She,						// 畲族
	EM_CITIZENIDCARD_ETHNICITY_Gaoshan,					// 高山族
	EM_CITIZENIDCARD_ETHNICITY_Lahu,					// 拉祜族
	EM_CITIZENIDCARD_ETHNICITY_Shui,					// 水族
	EM_CITIZENIDCARD_ETHNICITY_Dongxiang,				// 东乡族
	EM_CITIZENIDCARD_ETHNICITY_Naxi,					// 纳西族
	EM_CITIZENIDCARD_ETHNICITY_Jingpo,					// 景颇族
	EM_CITIZENIDCARD_ETHNICITY_Kirgiz,					// 柯尔克孜族
	EM_CITIZENIDCARD_ETHNICITY_Tu,						// 土族
	EM_CITIZENIDCARD_ETHNICITY_Daur,					// 达斡尔族
	EM_CITIZENIDCARD_ETHNICITY_Mulam,					// 仫佬族
	EM_CITIZENIDCARD_ETHNICITY_Qoiang,					// 羌族
	EM_CITIZENIDCARD_ETHNICITY_Blang,					// 布朗族
	EM_CITIZENIDCARD_ETHNICITY_Salar,					// 撒拉族
	EM_CITIZENIDCARD_ETHNICITY_Maonan,					// 毛南族
	EM_CITIZENIDCARD_ETHNICITY_Gelo,					// 仡佬族
	EM_CITIZENIDCARD_ETHNICITY_Xibe,					// 锡伯族
	EM_CITIZENIDCARD_ETHNICITY_Achang,					// 阿昌族
	EM_CITIZENIDCARD_ETHNICITY_Pumi,					// 普米族
	EM_CITIZENIDCARD_ETHNICITY_Tajik,					// 塔吉克族
	EM_CITIZENIDCARD_ETHNICITY_Nu,						// 怒族
	EM_CITIZENIDCARD_ETHNICITY_Ozbek,					// 乌孜别克族
	EM_CITIZENIDCARD_ETHNICITY_Russian,					// 俄罗斯族
	EM_CITIZENIDCARD_ETHNICITY_Ewenkl,					// 鄂温克族
	EM_CITIZENIDCARD_ETHNICITY_Deang,					// 德昂族
	EM_CITIZENIDCARD_ETHNICITY_Bonan,					// 保安族
	EM_CITIZENIDCARD_ETHNICITY_Yugur,					// 裕固族
	EM_CITIZENIDCARD_ETHNICITY_Jing,					// 京族
	EM_CITIZENIDCARD_ETHNICITY_Tatar,					// 塔塔尔族
	EM_CITIZENIDCARD_ETHNICITY_Drung,					// 独龙族
	EM_CITIZENIDCARD_ETHNICITY_Oroqen,					// 鄂伦春族
	EM_CITIZENIDCARD_ETHNICITY_Hezhen,					// 赫哲族
	EM_CITIZENIDCARD_ETHNICITY_Moinba,					// 门巴族
	EM_CITIZENIDCARD_ETHNICITY_Lhoba,					// 珞巴族
	EM_CITIZENIDCARD_ETHNICITY_Jino						// 基诺族
}EM_CITIZENIDCARD_ETHNICITY_TYPE;

//性别
typedef enum tagEM_CITIZENIDCARD_SEX_TYPE
{
	EM_CITIZENIDCARD_SEX_TYPE_UNKNOWN,          // 未知
	EM_CITIZENIDCARD_SEX_TYPE_MALE,             // 男
	EM_CITIZENIDCARD_SEX_TYPE_FEMALE,           // 女
	EM_CITIZENIDCARD_SEX_TYPE_UNTOLD,           // 未说明
}EM_CITIZENIDCARD_SEX_TYPE;

// 门禁刷卡记录记录集信息
typedef struct tagNET_RECORDSET_ACCESS_CTL_CARDREC
{
    DWORD           dwSize;
    int             nRecNo;                                 // 记录集编号,只读
    char            szCardNo[DH_MAX_CARDNO_LEN];            // 卡号
    char            szPwd[DH_MAX_CARDPWD_LEN];              // 密码
    NET_TIME        stuTime;                                // 刷卡时间
    BOOL            bStatus;                                // 刷卡结果,TRUE表示成功,FALSE表示失败
    NET_ACCESS_DOOROPEN_METHOD    emMethod;                 // 开门方式
    int             nDoor;                                  // 门号,即CFG_CMD_ACCESS_EVENT配置CFG_ACCESS_EVENT_INFO的数组下标
    char            szUserID[DH_MAX_USERID_LEN];            // 用户ID
    int             nReaderID;                              // 读卡器ID (废弃,不再使用)
	char			szSnapFtpUrl[MAX_PATH];					// 开锁抓拍上传的FTP地址

	char            szReaderID[DH_COMMON_STRING_32];        // 读卡器ID													// 开门并上传抓拍照片,在记录集记录存储地址,成功才有
    NET_ACCESSCTLCARD_TYPE      emCardType;                 // 卡类型
    int                         nErrorCode;                 // 开门失败的原因,仅在bStatus为FALSE时有效
                                                            // 0x00 没有错误
                                                            // 0x10 未授权
                                                            // 0x11 卡挂失或注销
                                                            // 0x12 没有该门权限
                                                            // 0x13 开门模式错误
                                                            // 0x14 有效期错误
                                                            // 0x15 防反潜模式
                                                            // 0x16 胁迫报警未打开
                                                            // 0x17 门常闭状态
                                                            // 0x18 AB互锁状态
                                                            // 0x19 巡逻卡
                                                            // 0x1A 设备处于闯入报警状态
                                                            // 0x20 时间段错误
                                                            // 0x21 假期内开门时间段错误
                                                            // 0x30 需要先验证有首卡权限的卡片
                                                            // 0x40 卡片正确,输入密码错误
                                                            // 0x41 卡片正确,输入密码超时
                                                            // 0x42 卡片正确,输入指纹错误
                                                            // 0x43 卡片正确,输入指纹超时
                                                            // 0x44 指纹正确,输入密码错误
                                                            // 0x45 指纹正确,输入密码超时
                                                            // 0x50 组合开门顺序错误
                                                            // 0x51 组合开门需要继续验证
                                                            // 0x60 验证通过,控制台未授权
                                                            // 0x61 卡片正确,人脸错误
                                                            // 0x62 卡片正确,人脸超时
                                                            // 0x63 重复进入
                                                            // 0x64 未授权,需要后端平台识别

    char           szRecordURL[MAX_COMMON_STRING_128];      // 刷卡录像的地址
    int            nNumbers;                                // 抓图的张数
	NET_ATTENDANCESTATE         emAttendanceState;          // 考勤状态 
    NET_ENUM_DIRECTION_ACCESS_CTL   emDirection;            // 开门方向
	char						szClassNumber[MAX_CLASS_NUMBER_LEN];		// 班级（考勤肯尼亚定制）
	char						szPhoneNumber[MAX_PHONENUMBER_LEN];			// 电话（考勤肯尼亚定制）
	char						szCardName[DH_MAX_CARDNAME_LEN];			// 卡命名
    char                        szSN[DH_COMMON_STRING_32];					// 智能锁序列号,无线配件需要该字段

	BOOL						bCitizenIDResult;							// 人证比对结果	
	char						szCitizenIDName[30];						// 名字
	BYTE						byReserved1[2];								// 字节对齐
	EM_CITIZENIDCARD_SEX_TYPE			emCitizenIDSex;						// 性别
	EM_CITIZENIDCARD_ETHNICITY_TYPE		emCitizenIDEthnicity;				// 民族
	NET_TIME					stuCitizenIDBirth;							// 出生日期(时分秒无效)
	char						szCitizenIDAddress[108];					// 住址
	char						szCitizenIDAuthority[48];					// 签发机关
	NET_TIME					stuCitizenIDStart;							// 有效起始日期(时分秒无效)
	NET_TIME					stuCitizenIDEnd;							// 有效截止日期(时分秒无效, 年为负数时表示长期有效)
	BOOL						bIsEndless;									// 是否长期有效
	char						szSnapFaceURL[DH_COMMON_STRING_128];		// 人脸图片保存地址
	char						szCitizenPictureURL[DH_COMMON_STRING_128];	// 身份证图片保存地址
	char						szCitizenIDNo[20];							// 身份证号码
    NET_ACCESSCTLCARD_SEX       emSex;                                      // 性别
    char                        szRole[MAX_COMMON_STRING_32];               // 角色
    char                        szProjectNo[MAX_COMMON_STRING_32];          // 项目ID
    char                        szProjectName[MAX_COMMON_STRING_64];        // 项目名称
    char                        szBuilderName[MAX_COMMON_STRING_64];        // 施工单位全称
    char                        szBuilderID[MAX_COMMON_STRING_32];          // 施工单位ID
    char                        szBuilderType[MAX_COMMON_STRING_32];        // 施工单位类型
    char                        szBuilderTypeID[MAX_COMMON_STRING_8];       // 施工单位类别ID
    char                        szPictureID[MAX_COMMON_STRING_64];          // 人员照片ID
    char                        szContractID[MAX_COMMON_STRING_16];         // 原合同系统合同编号
    char                        szWorkerTypeID[MAX_COMMON_STRING_8];        // 工种ID
    char                        szWorkerTypeName[MAX_COMMON_STRING_32];     // 工种名称
    BOOL                        bPersonStatus;                              // 人员状态, TRUE:启用, FALSE:禁用
	EM_HAT_STYLE				emHatStyle;									// 帽子类型
	EM_UNIFIED_COLOR_TYPE		emHatColor;									// 帽子颜色
}NET_RECORDSET_ACCESS_CTL_CARDREC;

// 假日记录集信息
typedef struct tagNET_RECORDSET_HOLIDAY
{
    DWORD           dwSize;
    int             nRecNo;                                 // 记录集编号,只读
    int             nDoorNum;                               // 有效的的门数目    
    int             sznDoors[DH_MAX_DOOR_NUM];              // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置CFG_ACCESS_EVENT_INFO的数组下标
    NET_TIME        stuStartTime;                           // 开始时间
    NET_TIME        stuEndTime;                             // 结束时间
    BOOL            bEnable;                                // 假期使能
    char            szHolidayNo[DH_COMMON_STRING_32];       // 假期编号
    char            szHolidayName[DH_COMMON_STRING_128];    // 假期名称
}NET_RECORDSET_HOLIDAY;

// 卡号省份
typedef enum tagEM_CARD_PROVINCE
{
	EM_CARD_UNKNOWN			= 10,		// 解析出错，未知省份
	EM_CARD_BEIJING			= 11,		// 北京
	EM_CARD_TIANJIN			= 12,		// 天津
	EM_CARD_HEBEI			= 13,		// 河北
	EM_CARD_SHANXI_TAIYUAN	= 14,		// 山西
	EM_CARD_NEIMENGGU		= 15,		// 内蒙古
	EM_CARD_LIAONING		= 21,		// 辽宁
	EM_CARD_JILIN			= 22,		// 吉林
	EM_CARD_HEILONGJIANG	= 23,		// 黑龙江
	EM_CARD_SHANGHAI		= 31,		// 上海
	EM_CARD_JIANGSU			= 32,		// 江苏
	EM_CARD_ZHEJIANG		= 33,		// 浙江
	EM_CARD_ANHUI			= 34,		// 安徽
	EM_CARD_FUJIAN			= 35,		// 福建
	EM_CARD_JIANGXI			= 36,		// 江西
	EM_CARD_SHANDONG		= 37,		// 山东
	EM_CARD_HENAN			= 41,		// 河南
	EM_CARD_HUBEI			= 42,		// 湖北
	EM_CARD_HUNAN			= 43,		// 湖南
	EM_CARD_GUANGDONG		= 44,		// 广东
	EM_CARD_GUANGXI			= 45,		// 广西
	EM_CARD_HAINAN			= 46,		// 海南
	EM_CARD_CHONGQING		= 50,		// 重庆
	EM_CARD_SICHUAN			= 51,		// 四川
	EM_CARD_GUIZHOU			= 52,		// 贵州
	EM_CARD_YUNNAN			= 53,		// 云南
	EM_CARD_XIZANG			= 54,		// 西藏
	EM_CARD_SHANXI_XIAN		= 61,		// 陕西
	EM_CARD_GANSU			= 62,		// 甘肃
	EM_CARD_QINGHAI			= 63,		// 青海
	EM_CARD_NINGXIA			= 64,		// 宁夏
	EM_CARD_XINJIANG		= 65,		// 新疆
	EM_CARD_XIANGGANG		= 71,		// 香港
	EM_CARD_AOMEN			= 82,		// 澳门
} EM_CARD_PROVINCE;

// 车辆类型
typedef enum tagEM_CAR_TYPE
{	
	EM_CAR_0,					//其他车辆
	EM_CAR_1,					//大型普通客车
	EM_CAR_2,					//大型双层客车
	EM_CAR_3,					//大型卧铺客车
	EM_CAR_4,					//大型铰接客车
	EM_CAR_5,					//大型越野客车
	EM_CAR_6,					//大型轿车
	EM_CAR_7,					//大型专用客车
	EM_CAR_8,					//大型专用校车
	EM_CAR_9,					//中型普通客车
	EM_CAR_10,					//中型双层客车 
	EM_CAR_11,					//中型卧铺客车
	EM_CAR_12,					//中型铰接客车
	EM_CAR_13,					//中型越野客车
	EM_CAR_14,					//中型轿车 
	EM_CAR_15,					//中型专用客车 
	EM_CAR_16,					//中型专用校车 
	EM_CAR_17,					//小型普通客车 
	EM_CAR_18,					//小型越野客车 
	EM_CAR_19,					//小型轿车 
	EM_CAR_20,					//小型专用客车 
	EM_CAR_21,					//小型专用校车 
	EM_CAR_22,					//小型面包车 
	EM_CAR_23,					//微型普通客车 
	EM_CAR_24,					//微型越野客车 
	EM_CAR_25,					//微型轿车
	EM_CAR_26,					//微型面包车
	EM_CAR_27,					//重型半挂牵引车
	EM_CAR_28,					//重型全挂牵引车
	EM_CAR_29,					//中型半挂牵引车
	EM_CAR_30,					//中型全挂牵引车
	EM_CAR_31,					//轻型半挂牵引车
	EM_CAR_32,					//轻型全挂牵引车 
	EM_CAR_33,					//大型非载货专项作业车
	EM_CAR_34,					//大型载货专项作业车 
	EM_CAR_35,					//中型非载货专项作业车
	EM_CAR_36,					//中型载货专项作业车 
	EM_CAR_37,					//小型非载货专项作业车
	EM_CAR_38,					//小型载货专项作业车 
	EM_CAR_39,					//微型非载货专项作业车
	EM_CAR_40,					//微型载货专项作业车 
	EM_CAR_41,					//重型非载货专项作业车
	EM_CAR_42,					//重型载货专项作业车 
	EM_CAR_43,					//轻型非载货专项作业车
	EM_CAR_44,					//轻型载货专项作业车 
	EM_CAR_45,					//普通正三轮摩托车 
	EM_CAR_46,					//轻便正三轮摩托车 
	EM_CAR_47,					//正三轮载客摩托车 
	EM_CAR_48,					//正三轮载货摩托车 
	EM_CAR_49,					//侧三轮摩托车 
	EM_CAR_50,					//普通二轮摩托车 
	EM_CAR_51,					//轻便二轮摩托车 
	EM_CAR_52,					//无轨电车 
	EM_CAR_53,					//有轨电车 
	EM_CAR_54,					//三轮汽车 
	EM_CAR_55,					//轮式装载机械 
	EM_CAR_56,					//轮式挖掘机械 
	EM_CAR_57,					//轮式平地机械 
	EM_CAR_58,					//重型普通货车 
	EM_CAR_59,					//重型厢式货车 
	EM_CAR_60,					//重型封闭货车 
	EM_CAR_61,					//重型罐式货车 
	EM_CAR_62,					//重型平板货车 
	EM_CAR_63,					//重型集装箱车 
	EM_CAR_64,					//重型自卸货车 
	EM_CAR_65,					//重型特殊结构货车 
	EM_CAR_66,					//重型仓栅式货车 
	EM_CAR_67,					//重型车辆运输车 
	EM_CAR_68,					//重型厢式自卸货车 
	EM_CAR_69,					//重型罐式自卸货车 
	EM_CAR_70,					//重型平板自卸货车 
	EM_CAR_71,					//重型集装箱自卸货车 
	EM_CAR_72,					//重型特殊结构自卸货车
	EM_CAR_73,					//重型仓栅式自卸货车 
	EM_CAR_74,					//中型普通货车 
	EM_CAR_75,					//中型厢式货车 
	EM_CAR_76,					//中型封闭货车 
	EM_CAR_77,					//中型罐式货车 
	EM_CAR_78,					//中型平板货车 
	EM_CAR_79,					//中型集装箱车 
	EM_CAR_80,					//中型自卸货车 
	EM_CAR_81,					//中型特殊结构货车 
	EM_CAR_82,					//中型仓栅式货车 
	EM_CAR_83,					//中型车辆运输车 
	EM_CAR_84,					//中型厢式自卸货车 
	EM_CAR_85,					//中型罐式自卸货车 
	EM_CAR_86,					//中型平板自卸货车 
	EM_CAR_87,					//中型集装箱自卸货车 
	EM_CAR_88,					//中型特殊结构自卸货车
	EM_CAR_89,					//中型仓栅式自卸货车 
	EM_CAR_90,					//轻型普通货车 
	EM_CAR_91,					//轻型厢式货车 
	EM_CAR_92,					//轻型封闭货车 
	EM_CAR_93,					//轻型罐式货车 
	EM_CAR_94,					//轻型平板货车 
	EM_CAR_95,					//轻型自卸货车 
	EM_CAR_96,					//轻型特殊结构货车 
	EM_CAR_97,					//轻型仓栅式货车 
	EM_CAR_98,					//轻型车辆运输车 
	EM_CAR_99,					//轻型厢式自卸货车 
	EM_CAR_100,					//轻型罐式自卸货车 
	EM_CAR_101,					//轻型平板自卸货车 
	EM_CAR_102,					//轻型特殊结构自卸货车 
	EM_CAR_103,					//轻型仓栅式自卸货车 
	EM_CAR_104,					//微型普通货车 
	EM_CAR_105,					//微型厢式货车 
	EM_CAR_106,					//微型封闭货车 
	EM_CAR_107,					//微型罐式货车 
	EM_CAR_108,					//微型自卸货车 
	EM_CAR_109,					//微型特殊结构货车 
	EM_CAR_110,					//微型仓栅式货车 
	EM_CAR_111,					//微型车辆运输车 
	EM_CAR_112,					//微型厢式自卸货车 
	EM_CAR_113,					//微型罐式自卸货车 
	EM_CAR_114,					//微型特殊结构自卸货车 
	EM_CAR_115,					//微型仓栅式自卸货车 
	EM_CAR_116,					//普通低速货车 
	EM_CAR_117,					//厢式低速货车 
	EM_CAR_118,					//罐式低速货车 
	EM_CAR_119,					//自卸低速货车 
	EM_CAR_120,					//仓栅式低速货车 
	EM_CAR_121,					//厢式自卸低速货车 
	EM_CAR_122,					//罐式自卸低速货车 
	EM_CAR_123,					//重型普通全挂车 
	EM_CAR_124,					//重型厢式全挂车 
	EM_CAR_125,					//重型罐式全挂车 
	EM_CAR_126,					//重型平板全挂车 
	EM_CAR_127,					//重型集装箱全挂车 
	EM_CAR_128,					//重型自卸全挂车 
	EM_CAR_129,					//重型仓栅式全挂车 
	EM_CAR_130,					//重型旅居全挂车 
	EM_CAR_131,					//重型专项作业全挂车 
	EM_CAR_132,					//重型厢式自卸全挂车 
	EM_CAR_133,					//重型罐式自卸全挂车 
	EM_CAR_134,					//重型平板自卸全挂车 
	EM_CAR_135,					//重型集装箱自卸全挂车 
	EM_CAR_136,					//重型仓栅式自卸全挂车 
	EM_CAR_137,					//重型专项作业自卸全挂车 
	EM_CAR_138,					//中型普通全挂车 
	EM_CAR_139,					//中型厢式全挂车 
	EM_CAR_140,					//中型罐式全挂车 
	EM_CAR_141,					//中型平板全挂车 
	EM_CAR_142,					//中型集装箱全挂车 
	EM_CAR_143,					//中型自卸全挂车 
	EM_CAR_144,					//中型仓栅式全挂车 
	EM_CAR_145,					//中型旅居全挂车 
	EM_CAR_146,					//中型专项作业全挂车 
	EM_CAR_147,					//中型厢式自卸全挂车 
	EM_CAR_148,					//中型罐式自卸全挂车 
	EM_CAR_149,					//中型平板自卸全挂车 
	EM_CAR_150,					//中型集装箱自卸全挂车 
	EM_CAR_151,					//中型仓栅式自卸全挂车 
	EM_CAR_152,					//中型专项作业自卸全挂车 
	EM_CAR_153,					//轻型普通全挂车 
	EM_CAR_154,					//轻型厢式全挂车 
	EM_CAR_155,					//轻型罐式全挂车 
	EM_CAR_156,					//轻型平板全挂车 
	EM_CAR_157,					//轻型自卸全挂车 
	EM_CAR_158,					//轻型仓栅式全挂车 
	EM_CAR_159,					//轻型旅居全挂车 
	EM_CAR_160,					//轻型专项作业全挂车 
	EM_CAR_161,					//轻型厢式自卸全挂车 
	EM_CAR_162,					//轻型罐式自卸全挂车 
	EM_CAR_163,					//轻型平板自卸全挂车 
	EM_CAR_164,					//轻型集装箱自卸全挂车 
	EM_CAR_165,					//轻型仓栅式自卸全挂车 
	EM_CAR_166,					//轻型专项作业自卸全挂车 
	EM_CAR_167,					//重型普通半挂车 
	EM_CAR_168,					//重型厢式半挂车 
	EM_CAR_169,					//重型罐式半挂车 
	EM_CAR_170,					//重型平板半挂车 
	EM_CAR_171,					//重型集装箱半挂车 
	EM_CAR_172,					//重型自卸半挂车 
	EM_CAR_173,					//重型特殊结构半挂车 
	EM_CAR_174,					//重型仓栅式半挂车 
	EM_CAR_175,					//重型旅居半挂车 
	EM_CAR_176,					//重型专项作业半挂车 
	EM_CAR_177,					//重型低平板半挂车 
	EM_CAR_178,					//重型车辆运输半挂车 
	EM_CAR_179,					//重型罐式自卸半挂车 
	EM_CAR_180,					//重型平板自卸半挂车 
	EM_CAR_181,					//重型集装箱自卸半挂车 
	EM_CAR_182,					//重型特殊结构自卸半挂车 
	EM_CAR_183,					//重型仓栅式自卸半挂车 
	EM_CAR_184,					//重型专项作业自卸半挂车 
	EM_CAR_185,					//重型低平板自卸半挂车 
	EM_CAR_186,					//重型中置轴旅居挂车 
	EM_CAR_187,					//重型中置轴车辆运输车 
	EM_CAR_188,					//重型中置轴普通挂车 
	EM_CAR_189,					//中型普通半挂车 
	EM_CAR_190,					//中型厢式半挂车 
	EM_CAR_191,					//中型罐式半挂车 
	EM_CAR_192,					//中型平板半挂车 
	EM_CAR_193,					//中型集装箱半挂车 
	EM_CAR_194,					//中型自卸半挂车 
	EM_CAR_195,					//中型特殊结构半挂车 
	EM_CAR_196,					//中型仓栅式半挂车 
	EM_CAR_197,					//中型旅居半挂车 
	EM_CAR_198,					//中型专项作业半挂车 
	EM_CAR_199,					//中型低平板半挂车 
	EM_CAR_200,					//中型车辆运输半挂车 
	EM_CAR_201,					//中型罐式自卸半挂车 
	EM_CAR_202,					//中型平板自卸半挂车 
	EM_CAR_203,					//中型集装箱自卸半挂车 
	EM_CAR_204,					//中型特殊结构自卸挂车 
	EM_CAR_205,					//中型仓栅式自卸半挂车 
	EM_CAR_206,					//中型专项作业自卸半挂车 
	EM_CAR_207,					//中型低平板自卸半挂车 
	EM_CAR_208,					//中型中置轴旅居挂车 
	EM_CAR_209,					//中型中置轴车辆运输车
	EM_CAR_210,					//中型中置轴普通挂车 
	EM_CAR_211,					//轻型普通半挂车 
	EM_CAR_212,					//轻型厢式半挂车 
	EM_CAR_213,					//轻型罐式半挂车 
	EM_CAR_214,					//轻型平板半挂车 
	EM_CAR_215,					//轻型自卸半挂车 
	EM_CAR_216,					//轻型仓栅式半挂车 
	EM_CAR_217,					//轻型旅居半挂车 
	EM_CAR_218,					//轻型专项作业半挂车 
	EM_CAR_219,					//轻型低平板半挂车 
	EM_CAR_220,					//轻型车辆运输半挂车 
	EM_CAR_221,					//轻型罐式自卸半挂车 
	EM_CAR_222,					//轻型平板自卸半挂车 
	EM_CAR_223,					//轻型集装箱自卸半挂车 
	EM_CAR_224,					//轻型特殊结构自卸挂车 
	EM_CAR_225,					//轻型仓栅式自卸半挂车 
	EM_CAR_226,					//轻型专项作业自卸半挂车 
	EM_CAR_227,					//轻型低平板自卸半挂车 
	EM_CAR_228,					//轻型中置轴旅居挂车 
	EM_CAR_229,					//轻型中置轴车辆运输车 
	EM_CAR_230,					//轻型中置轴普通挂车
} EM_CAR_TYPE;

// 号牌类型
typedef enum tagEM_PLATE_TYPE
{
	EM_PLATE_OTHER,					// 其他车
	EM_PLATE_BIG_CAR,				// 大型汽车
	EM_PLATE_SMALL_CAR,				// 小型汽车
	EM_PLATE_EMBASSY_CAR,			// 使馆汽车
	EM_PLATE_CONSULATE_CAR,			// 领馆汽车
	EM_PLATE_ABROAD_CAR,			// 境外汽车
	EM_PLATE_FOREIGN_CAR,			// 外籍汽车
	EM_PLATE_LOW_SPEED_CAR,			// 低速车
	EM_PLATE_COACH_CAR,				// 教练车
	EM_PLATE_MOTORCYCLE,			// 摩托车
	EM_PLATE_NEW_POWER_CAR,			// 新能源车 
	EM_PLATE_POLICE_CAR,			// 警用车
	EM_PLATE_HONGKONG_MACAO_CAR,	// 港澳两地车 
	EM_PLATE_ARMEDPOLICE_CAR,		// 武警车辆
	EM_PLATE_MILITARY_CAR,			// 军队车辆
	EM_PLATE_TEMPORARY_LICENSE_FOR_NON_MOTOR_VEHICLES,	  // 非机动车临时牌照
	EM_PLATE_OFFICIAL_LICENSE_PLATE_FOR_NON_MOTOR_VEHICLE, // 非机动车牌正式牌照
} EM_PLATE_TYPE;

// 车身颜色
typedef enum tagEM_CAR_COLOR_TYPE
{
	EM_CAR_COLOR_WHITE,				// 白色
	EM_CAR_COLOR_BLACK,				// 黑色
	EM_CAR_COLOR_RED,				// 红色
	EM_CAR_COLOR_YELLOW,			// 黄色
	EM_CAR_COLOR_GRAY,				// 灰色
	EM_CAR_COLOR_BLUE,				// 蓝色
	EM_CAR_COLOR_GREEN,				// 绿色
	EM_CAR_COLOR_PINK,				// 粉色
	EM_CAR_COLOR_PURPLE,			// 紫色
	EM_CAR_COLOR_DARK_PURPLE,		// 暗紫色
	EM_CAR_COLOR_BROWN,				// 棕色
	EM_CAR_COLOR_MAROON,			// 粟色
	EM_CAR_COLOR_SILVER_GRAY,		// 银灰色
	EM_CAR_COLOR_DARK_GRAY,			// 暗灰色
	EM_CAR_COLOR_WHITE_SMOKE,		// 白烟色
	EM_CAR_COLOR_DEEP_ORANGE,		// 深橙色
	EM_CAR_COLOR_LIGHT_ROSE,		// 浅玫瑰色
	EM_CAR_COLOR_TOMATO_RED,		// 番茄红色
	EM_CAR_COLOR_OLIVE,				// 橄榄色
	EM_CAR_COLOR_GOLDEN,			// 金色
	EM_CAR_COLOR_DARK_OLIVE,		// 暗橄榄色
	EM_CAR_COLOR_YELLOW_GREEN,		// 黄绿色
	EM_CAR_COLOR_GREEN_YELLOW,		// 绿黄色
	EM_CAR_COLOR_FOREST_GREEN,		// 森林绿
	EM_CAR_COLOR_OCEAN_BLUE,		// 海洋绿
	EM_CAR_COLOR_DEEP_SKYBLUE,		// 深天蓝	
	EM_CAR_COLOR_CYAN,				// 青色
	EM_CAR_COLOR_DEEP_BLUE,			// 深蓝色
	EM_CAR_COLOR_DEEP_RED,			// 深红色
	EM_CAR_COLOR_DEEP_GREEN,		// 深绿色
	EM_CAR_COLOR_DEEP_YELLOW,		// 深黄色
	EM_CAR_COLOR_DEEP_PINK,			// 深粉色
	EM_CAR_COLOR_DEEP_PURPLE,		// 深紫色
	EM_CAR_COLOR_DEEP_BROWN,		// 深棕色
	EM_CAR_COLOR_DEEP_CYAN,			// 深青色
	EM_CAR_COLOR_ORANGE,			// 橙色
	EM_CAR_COLOR_DEEP_GOLDEN,		// 深金色
	EM_CAR_COLOR_OTHER	= 255,		// 未识别、其他
} EM_CAR_COLOR_TYPE;

// 使用性质
typedef enum tagEM_USE_PROPERTY_TYPE
{
	EM_USE_PROPERTY_NONOPERATING,			// 非营运
	EM_USE_PROPERTY_HIGWAY,					// 公路客运,旅游客运
	EM_USE_PROPERTY_BUS,					// 公交客运
	EM_USE_PROPERTY_TAXI,					// 出租客运
	EM_USE_PROPERTY_FREIGHT,				// 货运
	EM_USE_PROPERTY_LEASE,					// 租赁
	EM_USE_PROPERTY_SECURITY,				// 警用,消防,救护,工程救险
	EM_USE_PROPERTY_COACH,					// 教练
	EM_USE_PROPERTY_SCHOOLBUS,				// 幼儿校车,小学生校车,其他校车
	EM_USE_PROPERTY_FOR_DANGE_VEHICLE,		// 危化品运输
	EM_USE_PROPERTY_OTHER,					// 其他
	EM_USE_PROPERTY_ONLINE_CAR_HAILING,		// 网约车
	EM_USE_PROPERTY_NON_MOTORIZED_TAKE_OUT_VEHICLE,	// 非机动外卖车
	EM_USE_PROPERTY_NON_MOTORIZED_EXPRESS_CAR,		// 非机动快递车
} EM_USE_PROPERTY_TYPE;

// RFID 电子车牌标签信息
typedef struct tagNET_RFIDELETAG_INFO
{
	BYTE					szCardID[MAX_RFIDELETAG_CARDID_LEN];			// 卡号
	int						nCardType;										// 卡号类型, 0:交通管理机关发行卡, 1:新车出厂预装卡
	EM_CARD_PROVINCE		emCardPrivince;									// 卡号省份
	char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];			// 车牌号码
	char					szProductionDate[MAX_RFIDELETAG_DATE_LEN];		// 出厂日期
	EM_CAR_TYPE				emCarType;										// 车辆类型
	int						nPower;											// 功率,单位：千瓦时，功率值范围0~254；255表示该车功率大于可存储的最大功率值
	int						nDisplacement;									// 排量,单位：百毫升，排量值范围0~254；255表示该车排量大于可存储的最大排量值
	int						nAntennaID;										// 天线ID，取值范围:1~4
	EM_PLATE_TYPE			emPlateType;									// 号牌种类
	char					szInspectionValidity[MAX_RFIDELETAG_DATE_LEN];	// 检验有效期，年-月
	int						nInspectionFlag;								// 逾期未年检标志, 0:已年检, 1:逾期未年检
	int						nMandatoryRetirement;							// 强制报废期，从检验有效期开始，距离强制报废期的年数
	EM_CAR_COLOR_TYPE		emCarColor;										// 车身颜色
	int						nApprovedCapacity;								// 核定载客量，该值<0时：无效；此值表示核定载客，单位为人
	int						nApprovedTotalQuality;							// 此值表示总质量，单位为百千克；该值<0时：无效；该值的有效范围为0~0x3FF，0x3FF（1023）表示数据值超过了可存储的最大值
	NET_TIME_EX				stuThroughTime;									// 过车时间
	EM_USE_PROPERTY_TYPE	emUseProperty;									// 使用性质
	char					szPlateCode[MAX_COMMON_STRING_8];				// 发牌代号，UTF-8编码
	char					szPlateSN[MAX_COMMON_STRING_16];				// 号牌号码序号，UTF-8编码
	char					szTID[MAX_COMMON_STRING_64];					// 标签(唯一标识), UTF-8编码
	BYTE               		bReserved[40];		                      		// 保留字节,留待扩展.
} NET_RFIDELETAG_INFO;

// 电子车牌记录信息
typedef struct tagNET_RECORD_ELECTRONICSTAG_INFO
{
	DWORD					dwSize;
	int						nRecNo;							// 记录集编号,只读
	BOOL					bMatch;							// 是否已匹配图片
	UINT					unDevID;						// 读写器序号，从0开始
	NET_RFIDELETAG_INFO		stuEleTagInfo;					// 电子车牌标签信息
} NET_RECORD_ELECTRONICSTAG_INFO;

// GPS位置记录集信息
typedef struct tagNET_RECORD_GPS_LOCATION_INFO
{
    DWORD           dwSize;                                 // 结构体大小
    int             nRecNo;                                 // 记录集编号,只读
    double          dLongitude;                             // GPS坐标经度值, 单位度
    double          dLatitude;                              // GPS坐标纬度值, 单位度
    char            szPlaceName[128];                       // GPS坐标对应的地名
    char            szRadius[16];                           // 半径
} NET_RECORD_GPS_LOCATION_INFO;

// 公租房租户记录集信息
typedef struct tagNET_RECORD_RESIDENT_INFO
{
    DWORD           dwSize;                                 // 结构体大小
    int             nRecNo;                                 // 记录集编号,只读
    char            szResidentName[DH_MAX_USERID_LEN];      // 用户姓名
    char            szCardNo[DH_MAX_CARDNO_LEN];            // 卡号
    NET_TIME        stuStartTime;                           // 有效期开始时间
    NET_TIME        stuEndTime;                             // 有效期截止时间
    char 			szICNum[DH_MAX_IC_LEN];					// 身份证
}NET_RECORD_RESIDENT_INFO;

// 监测量数据记录信息
typedef struct tagNET_RECORD_SENSOR_RECORD
{
	DWORD						dwSize;                                 // 结构体大小
	UINT						uRecNo;                                 // 记录集编号,只读
	NET_TIME					stuTime;								// 采集时间, 字段为"time" 
	UINT						uDeviceID;                              // 采集设备ID号, 高8位表示仪表类型，低24位表示仪表组内序号。仪表类型如下：0-电力； 1-模拟传感器。
	BYTE						byStatus;                               // 数据状态, 0:正常,1:异常
	BYTE						byExceptionCode;                        // 异常数据状态掩码，与具体仪表关联。Status =1时有效。
	// 当设备类型为电力时，掩码为:Bit0-欠压,Bit1-过压,Bit2-欠流,Bit3-过流,Bit4-状态无效，此状态不与其他同时置位
	BYTE						bySwitchOn;								// 开、关,0：关，1:开
	BYTE						byReserved;                             // 保留字节
	int							nPowerVoltage;                          // 电压,单位：mV
	int							nPowerCurrent;                          // 电流,单位：mA
	int							nPowerValue;							// 功率,单位：mW
	BYTE						byReservedSpace[4];                     // 保留字节							
	double						dActualValue;							// 模拟量使用。计量值，与具体模拟量仪表关联
	char			            szName[128];							// 仪表名称
	NET_SENSE_METHOD			emSenseMethod;						    // SenseMethod, 感应方式,参见具体枚举定义
	EM_SENSE_METHOD_UNIT		emUnit;							        // 单位, 具体单位和emSenseMethod变量有关
} NET_RECORD_SENSOR_RECORD;

//开门二维码记录集信息
typedef struct tagNET_RECORD_ACCESSQRCODE_INFO
{
	DWORD                       dwSize;                                 // 结构体大小
	int                         nRecNo;                                 // 记录集编号,只读
	char						szQRCode[DH_MAX_QRCODE_LEN];            // 二维码
	UINT						nLeftTimes;                             // 剩余的有效次数
	NET_TIME        			stuStartTime;                           // 有效期开始时间
    NET_TIME        			stuEndTime;                             // 有效期截止时间
    char                        szRoomNumber[16];                       // 房间号
}NET_RECORD_ACCESSQRCODE_INFO;

//蓝牙开门记录集信息
typedef struct tagNET_RECORD_ACCESS_BLUETOOTH_INFO
{
    DWORD                       dwSize;                                 // 结构体大小
    int                         nRecNo;                                 // 记录集编号,只读
    char						szUserName[DH_COMMON_STRING_128];       // 用户名
    char						szPassword[DH_COMMON_STRING_128];       // 密码
    char        			    szMac[DH_COMMON_STRING_32];             // mac地址
    char        			    szNote[DH_COMMON_STRING_128];           // 用户备注信息
}NET_RECORD_ACCESS_BLUETOOTH_INFO;

// 蓝牙开门记录集信息查询条件
typedef struct tagFIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION
{
    DWORD					dwSize;
    char					szUserName[DH_COMMON_STRING_128];           // 用户名
} FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION;

// 报警类型
typedef enum tagEM_RECORD_ACCESS_ALARM_TYPE
{
    EM_RECORD_ACCESS_ALARM_TYPE_UNKNOWN,                                // 未知
    EM_RECORD_ACCESS_ALARM_TYPE_DOOR_NOTCLOSE,                          // 门未关
    EM_RECORD_ACCESS_ALARM_TYPE_BREAK_IN,                               // 闯入
    EM_RECORD_ACCESS_ALARM_TYPE_REPEAT_ENTER,                           // 反潜
    EM_RECORD_ACCESS_ALARM_TYPE_DURESS,                                 // 胁迫
    EM_RECORD_ACCESS_ALARM_TYPE_ALARMLOCAL,                             // 本地
    EM_RECORD_ACCESS_ALARM_TYPE_CHASSIS_INTRUDED,                       // 防拆
}EM_RECORD_ACCESS_ALARM_TYPE;

// 门禁报警记录集信息
typedef struct tagNET_RECORD_ACCESS_ALARMRECORD_INFO
{
    DWORD                       dwSize;                                  // 结构体大小
    int                         nRecNo;                                  // 记录集编号,只读
    char					    szUserID[DH_COMMON_STRING_128];          // 用户ID
    EM_RECORD_ACCESS_ALARM_TYPE emAlarmType;                             // 报警类型
    int                         nDevAddress;                             // 分控器ID,0 表示集中控制器或者直连设备本身 大于0 表示分控制器
    int                         nChannel;                                // 通道号
    NET_TIME                    stuTime;                                 // 事件发生的时间
}NET_RECORD_ACCESS_ALARMRECORD_INFO;

typedef struct tagFIND_NET_RECORD_ACCESS_ALARMRECORD_INFO_CONDITION
{   
    DWORD					    dwSize;
    char					    szUserID[DH_COMMON_STRING_128];          // 用户ID
    NET_TIME                    stStartTime;                             // 起始时间
    NET_TIME                    stEndTime;                               // 结束时间
}FIND_NET_RECORD_ACCESS_ALARMRECORD_INFO_CONDITION;

// 呼叫类型
typedef enum tagEM_VIDEO_TALK_LOG_CALLTYPE
{
    EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0,         // 未知
    EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING,            // 呼入
    EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING,            // 呼出
    EM_VIDEO_TALK_LOG_CALLTYPE_MAX,                 //
}EM_VIDEO_TALK_LOG_CALLTYPE;

// 最终状态
typedef enum tagEM_VIDEO_TALK_LOG_ENDSTATE
{
    EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0,         // 未知
    EM_VIDEO_TALK_LOG_ENDSTATE_MISSED,              // 未接
    EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED,            // 已接
    EM_VIDEO_TALK_LOG_ENDSTATE_MAX,                 //
}EM_VIDEO_TALK_LOG_ENDSTATE;

// 对方类型
typedef enum tagEM_VIDEO_TALK_LOG_PEERTYPE
{
    EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0,         // 未知
    EM_VIDEO_TALK_LOG_PEERTYPE_VTO,                 // 门口机
    EM_VIDEO_TALK_LOG_PEERTYPE_VTH,                 // 室内机
    EM_VIDEO_TALK_LOG_PEERTYPE_VTS,                 // 管理中心
}EM_VIDEO_TALK_LOG_PEERTYPE;


//记录是否已经浏览
typedef enum tagNET_RECORD_READFLAG
{
	NET_RECORD_READFLAG_UNREADED = 0, //未读
	NET_RECORD_READFLAG_READED,	    //已读
	NET_RECORD_READFLAG_UNKNOWN,      //未知
}NET_RECORD_READFLAG;

// 平台呼出类型
typedef enum tagNET_EM_OFFLINE_CALL_TYPE
{
	NET_EM_OFFLINE_CALL_UNKNOWN = -1,			// 未知
	NET_EM_OFFLINE_CALL_ONLINECALL,				// 在线呼出
	NET_EM_OFFLINE_CALL_OFFLINECALL,			// 断线呼出
	NET_EM_OFFLINE_CALL_NONE = 255,				// 其他
}NET_EM_OFFLINE_CALL_TYPE;
// 通话记录记录集信息
typedef struct tagNET_RECORD_VIDEO_TALK_LOG
{
    DWORD                           dwSize;
    int                             nRecNo;                             // 记录集编号,只读
    NET_TIME                        stuCreateTime;                      // 开始时间
    EM_VIDEO_TALK_LOG_CALLTYPE      emCallType;                         // 呼叫类型
    EM_VIDEO_TALK_LOG_ENDSTATE      emEndState;                         // 最终状态
    char                            szPeerNumber[DH_COMMON_STRING_64];  // 对方号码 可以是短号,中号或长号
    EM_VIDEO_TALK_LOG_PEERTYPE      emPeerType;                         // 对方类型
    char                            szLocalNumber[DH_COMMON_STRING_64]; // 本机号码 可以是短号,中号或长号
    int                             nTalkTime;                          // 通话时间 单位秒
    int                             nMessageTime;                       // 留言时间 单位秒
    char                            szPicturePath[DH_COMMON_STRING_128];// 照片路径
	NET_EM_OFFLINE_CALL_TYPE		emOfflineCall;						// 平台断线是否呼出
}NET_RECORD_VIDEO_TALK_LOG;

// 语音对讲状态
typedef enum tagEM_REGISTER_USER_STATE
{
    EM_REGISTER_USER_STATE_UNKNOWN = 0,         // 未知
    EM_REGISTER_USER_STATE_IDLE,                // 初始状态
    EM_REGISTER_USER_STATE_CALLING,             // 呼叫状态（对方未回应）
    EM_REGISTER_USER_STATE_RINGING,             // 回铃状态（对方回应,但没有接听）
    EM_REGISTER_USER_STATE_PREVIEWING,          // 正在预览
    EM_REGISTER_USER_STATE_LEAVINGMESSAGE,      // 正在留言
    EM_REGISTER_USER_STATE_TALKING,             // 通话中
    EM_REGISTER_USER_STATE_MAX,                 //
}EM_REGISTER_USER_STATE;

// 设备类型
typedef enum tagEM_REGISTER_USER_STATE_DEV_TYPE
{
    EM_REGISTER_USER_STATE_DEV_TYPE_UNKNOWN = 0,            // 未知
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTH,              // 数字VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTH,             // 模拟VTH
    EM_REGISTER_USER_STATE_DEV_TYPE_DIGIT_VTO,              // 数字VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_ANALOG_VTO,             // 模拟VTO
    EM_REGISTER_USER_STATE_DEV_TYPE_MAX,                    //
}EM_REGISTER_USER_STATE_DEV_TYPE;

// 是否支持锁
typedef enum tagEM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE
{
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_UNKNOWN = 0,                // 未知
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_SUPPORTLOCK,                // 支持
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE_NOT_SUPPORTLOCK,            // 不支持
}EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE;

typedef enum tagNET_MONITORSTATE_TYPE
{
	NET_MONITORSTATE_TYPE_UNMONITORED = 0,		// 0 未监视（初始状态）
	NET_MONITORSTATE_TYPE_MONITORREQUEST,		// 1 收到监视请求
	NET_MONITORSTATE_TYPE_MONITORED,			// 2 被监视状态
	NET_MONITORSTATE_TYPE_UNKNOWN,				// 未知状态
}NET_MONITORSTATE_TYPE;


// 状态记录记录集信息
typedef struct tagNET_RECORD_REGISTER_USER_STATE
{
    DWORD                                   dwSize;
    int                                     nRecNo;                             // 记录集编号,只读
    NET_TIME                                stuCreateTime;                      // 创建时间
    char                                    szUserID[DH_MAX_USERID_LEN];       // 用户ID
    BOOL                                    bOnline;                            // 是否在线
    char                                    szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];     // 网络地址
    int                                     nPort;                              // 端口号
    EM_REGISTER_USER_STATE                  emVideoTalkState;                   // 语音对讲状态
    NET_TIME                                stuOnlineTime;                      // 上线时间
    NET_TIME                                stuOfflineTime;                     // 下线时间
    EM_REGISTER_USER_STATE_DEV_TYPE         emDevType;                          // 设备类型
    EM_REGISTER_USER_STATE_SUPPORTLOCK_TYPE emSupportLock;                      // 是否支持锁
	NET_MONITORSTATE_TYPE					emMonitorState;						// 监视状态
}NET_RECORD_REGISTER_USER_STATE;

// 可视对讲模拟室内机接入时的模式
typedef enum tagEM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE
{
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_UNKNOWN,              // 未知
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEADDRESS,         // 通过SlaveAddress
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE_SLAVEID_SLAVEPORT,    // 通过SlaveID+SlavePort
}EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE;

// 用户类型
typedef enum tagEM_VIDEO_TALK_CONTACT_TYPE
{
    EM_VIDEO_TALK_CONTACT_TYPE_UNKNOWN,             // 未知
    EM_VIDEO_TALK_CONTACT_TYPE_VTH,                 // "VTH" 室内机
    EM_VIDEO_TALK_CONTACT_TYPE_VTO,                 // "VTO" 门口机
}EM_VIDEO_TALK_CONTACT_TYPE;

// 注册方式
typedef enum tagEM_VIDEO_TALK_CONTACT_REGISTER_TYPE
{
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_UNKNOWN,                // 未知
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_PUBLIC,                 // "public"
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE_LOCAL,                  // "local"
}EM_VIDEO_TALK_CONTACT_REGISTER_TYPE;

// 联系人记录记录集信息
typedef struct tagNET_RECORD_VIDEO_TALK_CONTACT
{
    DWORD                                   dwSize;
    int                                     nRecNo;                                 // 记录集编号,只读
    NET_TIME                                stuCreateTime;                          // 创建时间
    char                                    szFirstName[DH_COMMON_STRING_32];       // 名字
    char                                    szFamilyName[DH_COMMON_STRING_32];      // 姓
    char                                    szVTShortNumber[DH_COMMON_STRING_16];   // 可视对讲短号
    char                                    szVTMiddleNumber[DH_COMMON_STRING_32];  // 可视对讲中号
    char                                    szVTLongNumber[DH_COMMON_STRING_64];    // 可视对讲长号,或VTH模拟室内机的序列号
    char                                    szVTNetAddress[DH_MAX_IPADDR_LEN_EX];   // 可视对讲网络地址
    char                                    szVTOPosition[DH_COMMON_STRING_64];     // 室内机关联的门口机位置
    EM_VIDEO_TALK_CONTACT_VTSLAVEBINDMODE   emVTSlaveBindMode;                      // 可视对讲模拟室内机接入时的模式
    char                                    szVTSlaveId[DH_COMMON_STRING_32];       // 该字段已废弃,使用 nVTSlaveId
    char                                    szVTSlavePort[DH_COMMON_STRING_32];     // 该字段已废弃,使用 nVTSlavePort
    char                                    szVTSlaveAddress[DH_COMMON_STRING_64];  // 可视对讲模拟室内机的地址
    char                                    szNickname[DH_COMMON_STRING_64];        // 昵称
    char                                    szNotes[DH_COMMON_STRING_64];           // 备注
    EM_VIDEO_TALK_CONTACT_TYPE              emType;                                 // 用户类型
    EM_VIDEO_TALK_CONTACT_REGISTER_TYPE     emRegisterType;                         // 注册方式
    char                                    szVTHPassword[DH_COMMON_STRING_64];     // 注册密码
    char                                    szVTOBuilding[DH_COMMON_STRING_64];     // 所属幢号
    char                                    szVTOUnit[DH_COMMON_STRING_64];         // 所属单元号
    char                                    szGroupNumber[DH_COMMON_STRING_64];     // 所属群组
    int                                     nVTSlaveId;                             // 可视对讲模拟室内机接入时的分配器地址
    int                                     nVTSlavePort;                           // 可视对讲模拟室内机接入时的分配器端口
}NET_RECORD_VIDEO_TALK_CONTACT;

//公告的状态
typedef enum tagNET_ANNOUNCE_STATE
{
	NET_ANNOUNCE_STATE_UNSENDED = 0, //初始状态(未发送)
	NET_ANNOUNCE_STATE_SENDED,		//已经发送
	NET_ANNOUNCE_STATE_EXPIRED,		//已经过期
	NET_ANNOUNCE_STATE_UNKNOWN,		//未知
}NET_ANNOUNCE_STATE;

//公告是否已经浏览
typedef enum tagNET_ANNOUNCE_READFLAG
{
	NET_ANNOUNCE_READFLAG_UNREADED = 0, //未读
	NET_ANNOUNCE_READFLAG_READED,	    //已读
	NET_ANNOUNCE_READFLAG_UNKNOWN,      //未知
}NET_ANNOUNCE_READFLAG;

//公告记录信息
typedef struct tagNET_RECORD_ANNOUNCEMENT_INFO
{
	DWORD									dwSize;									
	int										nRecNo;									// 记录集编号,只读
	NET_TIME                                stuCreateTime;                          // 创建时间
	NET_TIME								stuIssueTime;							// 公告发布时间
	char									szAnnounceTitle[DH_COMMON_STRING_64];	// 公告标题
	char									szAnnounceContent[DH_COMMON_STRING_256];	//公告内容
	char									szAnnounceDoor[DH_COMMON_STRING_16];	//公告要发送的房间号
	NET_TIME								stuExpireTime;							//公告过期的时间
	NET_ANNOUNCE_STATE						emAnnounceState;						//公告的状态
	NET_ANNOUNCE_READFLAG					emAnnounceReadFlag;						//公告是否已经浏览
}NET_RECORD_ANNOUNCEMENT_INFO;


// 公告记录信息查询条件
typedef struct tagFIND_RECORD_ANNOUNCEMENT_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // 启用时间段查询
	NET_TIME                  stStartTime;                      // 起始时间
	NET_TIME                  stEndTime;                        // 结束时间
}FIND_RECORD_ANNOUNCEMENT_CONDITION;


//报警记录信息
typedef struct tagNET_RECORD_ALARMRECORD_INFO
{
	DWORD									dwSize;
	int										nRecNo;									// 记录集编号,只读
	NET_TIME                                stuCreateTime;							// 报警时间,UTC秒数,只读
	int										nChannelID;								// 报警通道号
	NET_SENSE_METHOD						emSenseMethod;							// 传感器感应方式
	char									szRoomNumber[DH_MAX_DOOR_NUM];			// 报警房间号 
	NET_ANNOUNCE_READFLAG					emReadFlag;								//0未读。1已读
}NET_RECORD_ALARMRECORD_INFO;

//报警记录信息查询条件
typedef struct tagFIND_RECORD_ALARMRECORD_CONDITION
{
	DWORD                     dwSize;
	BOOL                      bTimeEnable;                      // 启用时间段查询
	NET_TIME                  stStartTime;                      // 起始时间
	NET_TIME                  stEndTime;                        // 结束时间
}FIND_RECORD_ALARMRECORD_CONDITION;


// 门禁未关事件详细信息
typedef struct tagALARM_ACCESS_CTL_NOT_CLOSE_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // 门通道号
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // 门禁名称
    NET_TIME        stuTime;                                // 报警事件发生的时间
    int             nAction;                                // 0:开始 1:停止    
    UINT 		    nEventID;				                //事件ID
}ALARM_ACCESS_CTL_NOT_CLOSE_INFO;

// 闯入方式
typedef enum tagEM_BREAK_IN_METHOD
{
    EM_BREAK_IN_METHOD_UNKNOWN,                             // 未知
    EM_BREAK_IN_METHOD_ILLEGAL,                             // 非法闯入:未授权的时候闯入
    EM_BREAK_IN_METHOD_REVERSE,                             // 反向闯入:授权门开后,对面有人进入
} EM_BREAK_IN_METHOD;

// 闯入事件详细信息
typedef struct tagALARM_ACCESS_CTL_BREAK_IN_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // 门通道号
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // 门禁名称
    NET_TIME        stuTime;                                // 报警事件发生的时间    
    UINT 			nEventID;				                //事件ID
    EM_BREAK_IN_METHOD   emMethod;                          // 闯入方式
    BYTE            reserved[4];                            // 字节对齐
}ALARM_ACCESS_CTL_BREAK_IN_INFO;


// 反复进入事件详细信息
typedef struct tagALARM_ACCESS_CTL_REPEAT_ENTER_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // 门通道号
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // 门禁名称
    NET_TIME        stuTime;                                // 报警事件发生的时间
    char            szCardNo[DH_MAX_CARDNO_LEN];            // 卡号    
    UINT 			nEventID;				                //事件ID
}ALARM_ACCESS_CTL_REPEAT_ENTER_INFO;


// 胁迫卡刷卡事件详细信息
typedef struct tagALARM_ACCESS_CTL_DURESS_INFO 
{
    DWORD           dwSize;
    int             nDoor;                                  // 门通道号
    char            szDoorName[DH_MAX_DOORNAME_LEN];        // 门禁名称
    char            szCardNo[DH_MAX_CARDNO_LEN];            // 胁迫卡号
    NET_TIME        stuTime;                                // 报警事件发生的时间    
    UINT 			nEventID;				                // 事件ID
    char            szSN[32];                               // 无线设备序列号
	char			szUserID[12];							// 用户ID
}ALARM_ACCESS_CTL_DURESS_INFO;


// 门禁事件类型
typedef enum tagNET_ACCESS_CTL_EVENT_TYPE
{
    NET_ACCESS_CTL_EVENT_UNKNOWN = 0,
    NET_ACCESS_CTL_EVENT_ENTRY,                             // 进门
    NET_ACCESS_CTL_EVENT_EXIT,                              // 出门
}NET_ACCESS_CTL_EVENT_TYPE;

// 当前门采集状态
typedef enum tagEM_CARD_STATE
{
	EM_CARD_STATE_UNKNOWN = -1,			// 未知
	EM_CARD_STATE_SWIPE,				// 门禁刷卡
	EM_CARD_STATE_COLLECTION,			// 门禁采集卡
}EM_CARD_STATE;

// 梯控方式触发者
typedef enum tagEM_LIFT_CALLER_TYPE
{
	EM_LIFT_CALLER_TYPE_UNKNOWN = 0,	// 未知
	EM_LIFT_CALLER_TYPE_VTO,			// VTO 呼叫
	EM_LIFT_CALLER_TYPE_PLATFORM,		// 平台呼叫
	EM_LIFT_CALLER_TYPE_LOCAL_AUTH,		// 本机鉴权呼叫
}EM_LIFT_CALLER_TYPE;


// 门禁事件
typedef struct tagALARM_ACCESS_CTL_EVENT_INFO 
{
    DWORD                       dwSize;
    int                         nDoor;                              // 门通道号
    char                        szDoorName[DH_MAX_DOORNAME_LEN];    // 门禁名称
    NET_TIME                    stuTime;                            // 报警事件发生的时间
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // 门禁事件类型
    BOOL                        bStatus;                            // 刷卡结果,TRUE表示成功,FALSE表示失败
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // 卡类型
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // 开门方式
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // 卡号
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // 密码
    char                        szReaderID[DH_COMMON_STRING_32];    // 门读卡器ID
    char                        szUserID[DH_COMMON_STRING_64];      // 开门用户
    char                        szSnapURL[DH_COMMON_STRING_256];    // 抓拍照片存储地址
    int                         nErrorCode;                         // 开门失败的原因,仅在bStatus为FALSE时有效
                                                                    // 0x00 没有错误
                                                                    // 0x10 未授权
                                                                    // 0x11 卡挂失或注销
                                                                    // 0x12 没有该门权限
                                                                    // 0x13 开门模式错误
                                                                    // 0x14 有效期错误
                                                                    // 0x15 防反潜模式
                                                                    // 0x16 胁迫报警未打开
                                                                    // 0x17 门常闭状态
                                                                    // 0x18 AB互锁状态
                                                                    // 0x19 巡逻卡
                                                                    // 0x1A 设备处于闯入报警状态
                                                                    // 0x20 时间段错误
                                                                    // 0x21 假期内开门时间段错误
                                                                    // 0x30 需要先验证有首卡权限的卡片
                                                                    // 0x40 卡片正确,输入密码错误
                                                                    // 0x41 卡片正确,输入密码超时
                                                                    // 0x42 卡片正确,输入指纹错误
                                                                    // 0x43 卡片正确,输入指纹超时
                                                                    // 0x44 指纹正确,输入密码错误
                                                                    // 0x45 指纹正确,输入密码超时
                                                                    // 0x50 组合开门顺序错误
                                                                    // 0x51 组合开门需要继续验证
                                                                    // 0x60 验证通过,控制台未授权
                                                                    // 0x61 卡片正确,人脸错误
                                                                    // 0x62 卡片正确,人脸超时
                                                                    // 0x63 重复进入
                                                                    // 0x64 未授权,需要后端平台识别
																	// 0xA8 未佩戴安全帽（定制）
    int                         nPunchingRecNo;                     // 刷卡记录集中的记录编号
	int							nNumbers;							// 抓图张数
    NET_ACCESSCTLCARD_STATE     emStatus;		                    // 卡状态 
    char                        szSN[32];                           // 智能锁序列号
    NET_ATTENDANCESTATE         emAttendanceState;                  // 考勤状态
    char                        szQRCode[512];                      // 二维码
    char                        szCallLiftFloor[16];				// 呼梯楼层号
	EM_CARD_STATE				emCardState;							// 是否为采集卡片
	char						szCitizenIDNo[20];					// 身份证号
	char				        szCompanionCards[MAX_COMPANION_CARD_NUM][DH_MAX_CARDINFO_LEN];    // 陪同者卡号信息
	int				            nCompanionCardCount;				// 陪同者卡号个数
	EM_HAT_STYLE				emHatStyle;							// 帽子类型
	EM_UNIFIED_COLOR_TYPE		emHatColor;							// 帽子颜色
	EM_LIFT_CALLER_TYPE			emLiftCallerType;					// 梯控方式触发者
}ALARM_ACCESS_CTL_EVENT_INFO;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_UNKNOWN,        // 未知
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_SUPERMARKET,    // 超市
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_RESTAURANT,     // 餐厅
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE_FRUITSTORE,     // 水果店
}EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE;

typedef enum tagEM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE
{
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_UNKNOWN,        // 未知
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_YES,            // 特价
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE_NO,             // 不是特价
}EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE;

// 下发商品记录记录集信息
typedef struct tagNET_RECORD_COMMODITY_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // 记录集编号,只读
    NET_TIME                                        stuSaleTime;                            // 货品上架时间
    char                                            szName[DH_COMMON_STRING_128];           // 货品名称
    EM_NET_RECORD_COMMODITY_NOTICE_SOURCE_TYPE      emSource;                               // 货品类型
    char                                            szURL[DH_COMMON_STRING_256];            // 货品图片路径, ftp 路径
    float                                           fPrice;                                 // 货品价格, 单位：元 float
    char                                            szID[DH_COMMON_STRING_64];              // ID号,由平台统一管理	一种货品有唯一的ID标识
    EM_NET_RECORD_COMMODITY_NOTICE_BARGAIN_TYPE     emBargain;                              // 是否特价商品
}NET_RECORD_COMMODITY_NOTICE;


typedef enum tagEM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE
{
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_UNKNOWN,           // 未知
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_DIGEST,            // 消化科
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE_STOMATOLOGY,       // 口腔科
}EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE;

// 就诊信息记录记录集信息
typedef struct tagNET_RECORD_HEALTH_CARE_NOTICE
{
    DWORD                                           dwSize;
    int                                             nRecNo;                                 // 记录集编号,只读
    NET_TIME                                        stuStartTime;                           // 上班时间
    NET_TIME                                        stuEndTime;                             // 下班时间
    char                                            szHospital[DH_COMMON_STRING_128];       // 就诊医院
    EM_NET_RECORD_HEALTH_CARE_NOTICE_OFFICE_TYPE    emOffice;                               // 科室
    char                                            szOfficeNumber[DH_COMMON_STRING_64];    // 科室号
    char                                            szDoctorName[DH_COMMON_STRING_128];     // 医生姓名
    char                                            szID[DH_COMMON_STRING_64];              // ID号,由平台统一管理	一种货品有唯一的ID标识
}NET_RECORD_HEALTH_CARE_NOTICE;

///////////////////////// 智能交通报警事件[CLIENT_StartListenEx] /////////////////////////////////////

//事件类型 DH_IVS_TRAFFIC_REALFLOWINFO(交通实时流量信息事件)对应的数据块描述信息
typedef struct tagALARM_IVS_TRAFFIC_REALFLOW_INFO
{
    int                 nChannelID;                     // 通道号
    char                szName[128];                    // 事件名称
    char                bReserved1[4];                  // 字节对齐
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    unsigned int        nSequence;                      // 序号
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[3];
    int                 nLane;                          // 对应车道号
    int                 nCount;                         // 车辆总数
    int                 nSpeed;                         // 车速,km/h
    int                 nOverPercent;                   // 平均超速百分比
    int                 nMetersUints;                   // 速度单位,0：公里,1：英里
    BYTE                bReserved[1024];                // 保留字节,留待扩展.
}ALARM_IVS_TRAFFIC_REALFLOW_INFO;

//事件类型 DH_YUEQINGLIGHTING_STATE_EVENT(平台统计灯光开关的时间事件)对应的数据块描述信息 
typedef struct tagDEV_YUEQINGLIGHTING_STATE_INFO
{
	DWORD               dwAction;                       // 事件动作, 0:开始, 1:结束
	int                 nChannelID;                     // 通道号
	NET_TIME_EX         UTC;							// 事件发生的时间 
	BYTE                bReserved[1024];                // 保留字节,留待扩展.
}DEV_YUEQINGLIGHTING_STATE_INFO;

// 报警事件类型 DH_ALARM_VEHICLE_TURNOVER(车辆侧翻事件)对应的数据描述信息
typedef struct tagALARM_VEHICEL_TURNOVER_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS信息
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                   // 对齐
    NET_TIME_EX         UTC;							// 事件发生的时间
    BYTE                bReserved[984];                // 保留字节,留待扩展.
}ALARM_VEHICEL_TURNOVER_EVENT_INFO;

// 报警事件类型DH_ALARM_VEHICLE_COLLISION(车辆撞车事件)对应的数据描述信息
typedef struct tagALARM_VEHICEL_COLLISION_EVENT_INFO
{
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS信息
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                   // 对齐
    NET_TIME_EX         UTC;							// 事件发生的时间
    BYTE                bReserved[984];                 // 保留字节,留待扩展.
}ALARM_VEHICEL_COLLISION_EVENT_INFO;

// 报警事件类型DH_ALARM_VEHICLE_CONFIRM(车辆上传信息事件)对应的数据描述信息
typedef struct tagALARM_VEHICEL_CONFIRM_INFO
{
    DWORD               dwStructSize;                   // 结构体大小
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS信息
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                   // 对齐
    char                szInfo[128];                    // 上传报警具体信息
}ALARM_VEHICEL_CONFIRM_INFO;

//事件类型DH_EVENT_REGISTER_OFF(车载设备主动下线事件)对应的数据描述信息
typedef struct tagEVENT_REGISTER_OFF_INFO
{
    DWORD               dwStructSize;                   // 结构体大小
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS信息
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                   // 对齐
}EVENT_REGISTER_OFF_INFO;

// 报警事件类型DH_ALARM_VIDEO_TIMING(视频定时检测事件)对应的数据描述信息
typedef struct tagALARM_VIDEO_TIMING
{
    DWORD               dwStructSize;                   // 结构体大小
    DWORD               dwAction;                       // 事件动作, 0:Pause, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // 视频通道号
}ALARM_VIDEO_TIMING;

// 报警事件类型DH_ALARM_VEHICLE_LARGE_ANGLE(车载摄像头大角度扭转事件)对应的数据描述信息
typedef struct tagALARM_VEHICEL_LARGE_ANGLE
{
    DWORD               dwStructSize;                   // 结构体大小
    NET_GPS_STATUS_INFO stGPSStatusInfo;                // GPS信息
    BYTE                bEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                   // 对齐
    unsigned int        nSequence;                      // 序号
}ALARM_VEHICEL_LARGE_ANGLE;

// 报警事件类型DH_ALARM_AUDIO_ANOMALY(音频异常事件)对应的数据描述信息
typedef struct tagALARM_AUDIO_ANOMALY
{
    DWORD               dwStructSize;                   // 结构体大小
    DWORD               dwAction;                       // 事件动作, 0:Start, 1:Stop
    DWORD               dwChannelID;                    // 音频通道号

    int                 nDecibel;                       // 声音强度
    int                 nFrequency;                     // 声音频率
}ALARM_AUDIO_ANOMALY;

// 报警事件类型DH_ALARM_AUDIO_MUTATION(声强突变事件)对应的数据描述信息
typedef struct tagALARM_AUDIO_MUTATION
{
    DWORD               dwStructSize;                   // 结构体大小
    DWORD               dwAction;                       // 事件动作, 0:Start, 1:Stop
    DWORD               dwChannelID;                    // 音频通道号
}ALARM_AUDIO_MUTATION;

// 报警事件类型 DH_ALARM_AUDIO_DETECT (音频检测事件)对应的数据描述信息
typedef struct tagALARM_AUDIO_DETECT
{
    DWORD               dwAction;                       // 事件动作, 1:Start, 2:Stop
    DWORD               dwChannelID;                    // 音频通道号
    char                reserved[512];                  // 保留
} ALARM_AUDIO_DETECT;

#define MAX_SENSORID_NUMBER 20                          // 传感器最大个数
#define MAX_TYRE_NUM        128                         // 最大轮胎个数
// 轮胎告警标志位对应枚举
typedef enum tagAlarmTyreFlag
{
    ALARM_TYRE_FLAG_NONE,                               // 无有效数据
    ALARM_TYRE_FLAG_NORMAL,                             // 正常
    ALARM_TYRE_FLAG_HIGHPRESSURE,                       // 高压
    ALARM_TYRE_FLAG_LOWERPRESSURE,                      // 低压
    ALARM_TYRE_FLAG_HIGHTEMP,                           // 高温
    ALARM_TYRE_FLAG_HIGHTEMP_HIGHPRESSURE,              // 高温、高压
    ALARM_TYRE_FLAG_HIGHTEMP_LOWERPRESSURE,             // 高温、低压

    ALARM_TYRE_FLAG_INVALID,                            // 非法的标志位数据
}EM_ALARM_TYER_FALG;

// 轮胎信息结构
typedef struct tagTYRE_INFO_UNIT
{
    DWORD               dwStructSize;                    // 结构体大小
    DWORD               dwSensorIDNum;                   // 传感器个数
    DWORD               dwSensorID[MAX_SENSORID_NUMBER]; // 传感器ID信息
    DWORD               dwTyreNum;                       // 胎位编号
    DWORD               dwTyrePlace;                     // 轮胎位于第几轴

    EM_ALARM_TYER_FALG  emAlarmFlag;                     // 轮胎告警标志位

    int                 nTemp;                           // 温度,单位℃
    int                 nTempLimit;                      // 温度,单位℃

    float               fPressure;                       // 压力,单位Kpa
    float               fUpperLimit;                     // 告警压力阈值上限,单位Kpa
    float               fLowerLimit;                     // 告警压力阈值下限,单位Kpa
    float               fVoltage;                        // 当前的传感器电压,单位 V
}TYRE_INFO_UNIT;

// 报警事件类型DH_EVENT_TYREINFO(轮胎信息上报事件)对应的数据描述信息
typedef struct tagEVENT_TYRE_INFO
{
    DWORD               dwStructSize;                   // 结构体大小
    DWORD               dwAction;                       // 事件动作, 0:Pause, 1:Stop
    DWORD               dwTyreNum;                      // 轮胎个数
    TYRE_INFO_UNIT      *pstuTyre;                      // 轮胎信息
}EVENT_TYRE_INFO;

/////////////////////////////语音对讲相关定义/////////////////////////////

// 音频格式信息
typedef struct
{
    BYTE                byFormatTag;                    // 编码类型,如0：PCM
    WORD                nChannels;                      // 声道数
    WORD                wBitsPerSample;                 // 采样深度            
    DWORD               nSamplesPerSec;                 // 采样率
} DH_AUDIO_FORMAT, *LPDH_AUDIO_FORMAT;

/////////////////////////////用户管理相关定义/////////////////////////////

// 支持用户名最大长度为8位的设备,对应CLIENT_QueryUserInfo和CLIENT_OperateUserInfo接口
// 权限信息
typedef struct _OPR_RIGHT
{
    DWORD               dwID;
    char                name[DH_RIGHT_NAME_LENGTH];
    char                memo[DH_MEMO_LENGTH];
} OPR_RIGHT;

// 用户信息
typedef struct _USER_INFO
{
    DWORD               dwID;
    DWORD               dwGroupID;
    char                name[DH_USER_NAME_LENGTH];
    char                passWord[DH_USER_PSW_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
    DWORD               dwReusable;                     // 是否复用；1：复用,0：不复用
} USER_INFO;

// 用户组信息
typedef struct _USER_GROUP_INFO
{
    DWORD               dwID;
    char                name[DH_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO;

// 用户信息表
typedef struct _USER_MANAGE_INFO
{
    DWORD                dwRightNum;                    // 权限信息
    OPR_RIGHT            rightList[DH_MAX_RIGHT_NUM];
    DWORD                dwGroupNum;                    // 用户组信息
    USER_GROUP_INFO      groupList[DH_MAX_GROUP_NUM];
    DWORD                dwUserNum;                     // 用户信息
    USER_INFO            userList[DH_MAX_USER_NUM];
    DWORD                dwSpecial;                     // 用户复用能力；1：支持用户复用,0：不支持用户复用
} USER_MANAGE_INFO;

// 支持用户名最大长度为8位或16位的设备,对应扩展接口CLIENT_QueryUserInfoEx和CLIENT_OperateUserInfoEx
#define DH_USER_NAME_LENGTH_EX       16                 // 用户名长度
#define DH_USER_PSW_LENGTH_EX        16                 // 密码

// 权限信息
typedef struct _OPR_RIGHT_EX
{
    DWORD                dwID;
    char                 name[DH_RIGHT_NAME_LENGTH];
    char                 memo[DH_MEMO_LENGTH];
} OPR_RIGHT_EX;

// 用户信息
typedef struct _USER_INFO_EX
{
    DWORD                dwID;
    DWORD                dwGroupID;
    char                 name[DH_USER_NAME_LENGTH_EX];
    char                 passWord[DH_USER_PSW_LENGTH_EX];
    DWORD                dwRightNum;
    DWORD                rights[DH_MAX_RIGHT_NUM];
    char                 memo[DH_MEMO_LENGTH];
    DWORD                dwFouctionMask;                // 掩码,0x00000001 - 支持用户复用
    BYTE                 byReserve[32];
} USER_INFO_EX;

// 用户组信息
typedef struct _USER_GROUP_INFO_EX
{
    DWORD                dwID;
    char                 name[DH_USER_NAME_LENGTH_EX];
    DWORD                dwRightNum;
    DWORD                rights[DH_MAX_RIGHT_NUM];
    char                 memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX;

// 用户信息表
typedef struct _USER_MANAGE_INFO_EX
{
    DWORD                dwRightNum;                    // 权限信息
    OPR_RIGHT_EX         rightList[DH_MAX_RIGHT_NUM];
    DWORD                dwGroupNum;                    // 用户组信息
    USER_GROUP_INFO_EX   groupList[DH_MAX_GROUP_NUM];
    DWORD                dwUserNum;                     // 用户信息
    USER_INFO_EX         userList[DH_MAX_USER_NUM];
    DWORD                dwFouctionMask;                // 掩码；0x00000001 - 支持用户复用,0x00000002 - 密码修改需要校验
    BYTE                 byNameMaxLength;               // 支持的用户名最大长度
    BYTE                 byPSWMaxLength;                // 支持的密码最大长度
    BYTE                 byReserve[254];
} USER_MANAGE_INFO_EX;

// 最大支持64通道的设备,对应扩展接口CLIENT_QueryUserInfoNew和CLIENT_OperateUserInfoNew
#define DH_NEW_MAX_RIGHT_NUM        1024
#define DH_NEW_USER_NAME_LENGTH     128                 // 用户名长度
#define DH_NEW_USER_PSW_LENGTH      128                 // 密码


// 权限信息
typedef struct _OPR_RIGHT_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_RIGHT_NAME_LENGTH];
    char                memo[DH_MEMO_LENGTH];
} OPR_RIGHT_NEW;

// 用户信息
typedef struct _USER_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    DWORD               dwGroupID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    char                passWord[DH_NEW_USER_PSW_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
    DWORD               dwFouctionMask;                 // 掩码,0x00000001 - 支持用户复用
    NET_TIME            stuTime;                        // 最后修改时间
    BYTE                byIsAnonymous;                  // 是否可以匿名登录, 0:不可匿名登录, 1: 可以匿名登录
    BYTE                byReserve[7];
} USER_INFO_NEW;

// 剩余修改密码的尝试次数和锁定时间
typedef struct tagREMAIN_MODIFY_TIME_AND_LOCK_SECOND
{
	DWORD			dwSize;						// 结构体大小
	int				nRemainModifytimes;			// 旧密码输错，剩余可尝试的次数
	int				nRemainLockSecond;			// 旧密码输入次数达到限定值，剩余锁定时间，单位是秒
}REMAIN_MODIFY_TIME_AND_LOCK_SECOND;
// 用户组信息
typedef struct _USER_GROUP_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_USER_NAME_LENGTH_EX];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_NEW;

// 用户组信息扩展,用户组名加长
typedef struct _USER_GROUP_INFO_EX2
{
    DWORD               dwSize;
    DWORD               dwID;
    char                name[DH_NEW_USER_NAME_LENGTH];
    DWORD               dwRightNum;
    DWORD               rights[DH_NEW_MAX_RIGHT_NUM];
    char                memo[DH_MEMO_LENGTH];
} USER_GROUP_INFO_EX2;

// 用户信息表
typedef struct _USER_MANAGE_INFO_NEW
{
    DWORD               dwSize;
    DWORD               dwRightNum;                         // 权限信息
    OPR_RIGHT_NEW       rightList[DH_NEW_MAX_RIGHT_NUM];
    DWORD               dwGroupNum;                         // 用户组数
    USER_GROUP_INFO_NEW groupList[DH_MAX_GROUP_NUM];        // 用户组信息,此参数废弃,请使用groupListEx
    DWORD               dwUserNum;                          // 用户信息
    USER_INFO_NEW       userList[DH_MAX_USER_NUM];
    DWORD               dwFouctionMask;                     // 掩码；0x00000001 - 支持用户复用,0x00000002 - 密码修改需要校验
    BYTE                byNameMaxLength;                    // 支持的用户名最大长度
    BYTE                byPSWMaxLength;                     // 支持的密码最大长度
    BYTE                byReserve[254];
    USER_GROUP_INFO_EX2 groupListEx[DH_MAX_GROUP_NUM];      // 用户组信息扩展
} USER_MANAGE_INFO_NEW;

///////////////////////////////查询相关定义///////////////////////////////

// 设备支持语言种类
typedef struct _DH_LANGUAGE_DEVINFO
{
    DWORD               dwLanguageNum;                      // 支持语言个数
    BYTE                byLanguageType[252];                // 枚举值,详见DH_LANGUAGE_TYPE
} DH_DEV_LANGUAGE_INFO, *LPDH_DEV_LANGUAGE_INFO;

// 查询设备支持的IPC能力信息
typedef struct
{
    int                 nTypeCount;                         // 支持的IPC个数
    BYTE                bSupportTypes[128];                 // 枚举值,详见EM_IPC_TYPE
}DH_DEV_IPC_INFO;

//3G网络流量信息
typedef struct
{
    int                 nStrategy;                          // 包月策略,0-按流量包月,1-按时间包月
    int                 nUplimit;                           // 流量上限, 与策略对应, 按流量, 单位MB; 按时间,单位小时
    int                 nUsed;                              // 已使用流量,单位与nUplimit相同
    BYTE                bReserved[64];                      // 保留字段
}DH_DEV_3GFLOW_INFO;

// 3G模块信息
typedef struct
{
    BYTE                byEthNum;                           // 3G模块数
    BYTE                byReserved[255];                    // 保留字节
}DH_DEV_3GMODULE_INFO;

typedef struct
{
    DWORD               dwId;                               // ddns 服务器id号
    char                szState[DH_MAX_DDNS_STATE_LEN];     // ddns 状态
    BYTE                bReserved[512];                     // 保留字段
}DH_DEV_DNS_INFO;
typedef struct
{
    DWORD               dwDdnsServerNum;    
    DH_DEV_DNS_INFO     stDdns[DH_MAX_DDNS_NUM];
}DH_DEV_MULTI_DDNS_INFO;

// 设备URL信息
typedef struct
{
    char               szURLInfo[512];                      //设备URL信息, 由字符串组成
    BYTE               bReserved[512];
}DH_DEV_URL_INFO;
// 硬盘信息
typedef struct
{
    DWORD               dwVolume;                           // 硬盘的容量, 单位MB(B表示字节)
    DWORD               dwFreeSpace;                        // 硬盘的剩余空间, 单位MB(B表示字节)
    BYTE                dwStatus;                           // 高四位的值表示硬盘类型,具体见枚举类型EM_DISK_TYPE；低四位的值表示硬盘的状态,0-休眠,1-活动,2-故障等；将DWORD拆成四个BYTE
    BYTE                bDiskNum;                           // 硬盘号
    BYTE                bSubareaNum;                        // 分区号
    BYTE                bSignal;                            // 标识,0为本地 1为远程
} NET_DEV_DISKSTATE,*LPNET_DEV_DISKSTATE;

// 设备硬盘信息
typedef struct _DH_HARDDISK_STATE
{
    DWORD                dwDiskNum;                         // 个数
    NET_DEV_DISKSTATE    stDisks[DH_MAX_DISKNUM];           // 硬盘或分区信息
} DH_HARDDISK_STATE, *LPDH_HARDDISK_STATE;

typedef DH_HARDDISK_STATE    DH_SDCARD_STATE;             // SD卡,数据结构同硬盘信息

// 语音编码信息
typedef struct  
{
    DH_TALK_CODING_TYPE encodeType;                         // 编码类型, 目前只能是DH_TALK_PCM
    int                 nAudioBit;                          // 位数,如8或16, 目前只能是16
    DWORD               dwSampleRate;                       // 采样率,如8000或16000, 目前只能是16000
    int                 nPacketPeriod;                      // 打包周期, 单位ms, 目前只能是25
    char                reserved[60];
} DHDEV_TALKDECODE_INFO;

// 设备支持的语音对讲类型
typedef struct 
{
    int                     nSupportNum;                    // 个数
    DHDEV_TALKDECODE_INFO   type[64];                       // 编码类型
    char                    reserved[64];
} DHDEV_TALKFORMAT_LIST;

// 云台属性信息
#define  NAME_MAX_LEN 16
typedef struct 
{
    DWORD               dwHighMask;                 // 操作的掩码高位
    DWORD               dwLowMask;                  // 操作的掩码低位
    char                szName[NAME_MAX_LEN];       // 操作的协议名
    WORD                wCamAddrMin;                // 通道地址的最小值
    WORD                wCamAddrMax;                // 通道地址的最大值
    WORD                wMonAddrMin;                // 监视地址的最小值
    WORD                wMonAddrMax;                // 监视地址的最大值
    BYTE                bPresetMin;                 // 预置点的最小值
    BYTE                bPresetMax;                 // 预置点的最大值
    BYTE                bTourMin;                   // 自动巡航线路的最小值
    BYTE                bTourMax;                   // 自动巡航线路的最大值
    BYTE                bPatternMin;                // 轨迹线路的最小值
    BYTE                bPatternMax;                // 轨迹线路的最大值
    BYTE                bTileSpeedMin;              // 垂直速度的最小值
    BYTE                bTileSpeedMax;              // 垂直速度的最大值
    BYTE                bPanSpeedMin;               // 水平速度的最小值
    BYTE                bPanSpeedMax;               // 水平速度的最大值
    BYTE                bAuxMin;                    // 辅助功能的最小值
    BYTE                bAuxMax;                    // 辅助功能的最大值
    int                 nInternal;                  // 发送命令的时间间隔
    char                cType;                      // 协议的类型
    BYTE                bReserved_1;                // 保留
    BYTE                bFuncMask;                  // 协议功能掩码,按位表示,置１表示支持,第一位表示内置云台功能,其它７位暂时保留
    BYTE                bReserved_2;
    char                Reserved[4];
} PTZ_OPT_ATTR;

// 光驱托盘状态
typedef enum tagEM_NET_BURN_DEV_TRAY_TYPE
{
    EM_NET_BURN_DEV_TRAY_TYPE_UNKNOWN,    // 未知
	EM_NET_BURN_DEV_TRAY_TYPE_READY,      // 光盘就绪
	EM_NET_BURN_DEV_TRAY_TYPE_OPEN,       // 托盘弹出
	EM_NET_BURN_DEV_TRAY_TYPE_NODISK,     // 无盘
	EM_NET_BURN_DEV_TRAY_TYPE_NOT_READY,  // 光盘未就绪
}EM_NET_BURN_DEV_TRAY_TYPE;

// 光驱使用状态
typedef enum tagEM_NET_BURN_DEV_OPERATE_TYPE
{
    EM_NET_BURN_DEV_OPERATE_TYPE_UNKNOWN, // 未知
	EM_NET_BURN_DEV_OPERATE_TYPE_WRITE,   // 执行写
	EM_NET_BURN_DEV_OPERATE_TYPE_READ,    // 执行读
	EM_NET_BURN_DEV_OPERATE_TYPE_IDLE,    // 空闲
}EM_NET_BURN_DEV_OPERATE_TYPE;

// 刻录机信息
typedef struct _NET_DEV_BURNING
{
    DWORD               dwDriverType;               // 刻录驱动器类型；0：DHFS,1：DISK,2：CDRW
    DWORD               dwBusType;                  // 总线类型；0：USB,1：1394,2：IDE, 3: SATA, 4: ESATA
    DWORD               dwTotalSpace;               // 总容量(KB)
    DWORD               dwRemainSpace;              // 剩余容量(KB)
    BYTE                dwDriverName[DH_BURNING_DEV_NAMELEN];    // 刻录驱动器名称
	EM_NET_BURN_DEV_TRAY_TYPE  emTrayType;						 // 光驱托盘状态
	EM_NET_BURN_DEV_OPERATE_TYPE emOperateType;					 // 光盘使用状态
} NET_DEV_BURNING, *LPNET_DEV_BURNING;

// 设备刻录机信息
typedef struct _DH_BURNING_DEVINFO
{
    DWORD               dwDevNum;                           // 刻录设备个数
    NET_DEV_BURNING     stDevs[DH_MAX_BURNING_DEV_NUM];     // 各刻录设备信息
} DH_BURNING_DEVINFO, *LPDH_BURNING_DEVINFO;

// 刻录进度
typedef struct _DH_BURNING_PROGRESS
{

    BYTE                bBurning;                   // 刻录机状态；0：可以刻录,1：刻录机类型不对,是一个非光盘设备,
                                                    // 2：未找到刻录机(即剩余空间为0),3：有其它光盘在刻录,4：刻录机处于非空闲状态,即在备份、刻录或回放中
    BYTE                bRomType;                   // 盘片类型；0：私有文件系统,1：移动硬盘或U盘,2：光盘
    BYTE                bOperateType;               // 操作类型；0：空闲,1：正在备份中,2：正在刻录中,3：正在进行光盘回放, 4: 无盘刻录
    BYTE                bType;                      // 备份或刻录过程状态；0-停止 1-开始 2-出错 3-满 4-结束 5-正在初始化 6-暂停 7-等待附件
    NET_TIME            stTimeStart;                // 开始时间　
    DWORD               dwTimeElapse;               // 已刻录时间(秒)
    DWORD               dwTotalSpace;               // 光盘总容量
    DWORD               dwRemainSpace;              // 光盘剩余容量
    DWORD               dwBurned;                   // 已刻录容量
    WORD                dwStatus;                   // 保留
    WORD                wChannelMask;               // 正在刻录的通道掩码
} DH_BURNING_PROGRESS, *LPDH_BURNING_PROGRESS;

// 日志信息,对应接口CLIENT_QueryLog接口
typedef struct _DH_LOG_ITEM
{
    DHDEVTIME           time;                       // 日期
    unsigned short      type;                       // 日志类型，对应结构体 DH_LOG_TYPE
    unsigned char       reserved;                   // 保留
    unsigned char       data;                       // 数据
    unsigned char       context[8];                 // 内容
} DH_LOG_ITEM, *LPDH_LOG_ITEM;

// 日志信息,对应扩展接口CLIENT_QueryLogEx,参数reserved(int nType=1;reserved=&nType;)
typedef struct _DH_NEWLOG_ITEM
{
    DHDEVTIME           time;                       // 日期
    WORD                type;                       // 扩展日志类型，对应结构体 DH_NEWLOG_TYPE
    WORD                data;                       // 数据
    char                szOperator[8];              // 用户名
    BYTE                context[16];                // 内容    
} DH_NEWLOG_ITEM, *LPDH_NEWLOG_ITEM;

// 日志信息,对应接口CLIENT_QueryDeviceLog接口
typedef struct _DH_DEVICE_LOG_ITEM
{
    int                 nLogType;                   // 日志类型
    DHDEVTIME           stuOperateTime;             // 日期
    char                szOperator[16];             // 操作者
    BYTE                bReserved[3];
    BYTE                bUnionType;                 //  union结构类型,0:szLogContext；1:stuOldLog。
    union
    {
        char            szLogContext[64];           // 日志备注信息
        struct 
        {
            DH_LOG_ITEM     stuLog;                 // 旧的日志结构体
            BYTE            bReserved[48];          // 保留
        }stuOldLog;
    };
    char                reserved[16];
} DH_DEVICE_LOG_ITEM, *LPDH_DEVICE_LOG_ITEM;

// 新日志信息结构,对应接口CLIENT_QueryDeviceLog接口
typedef struct _DH_DEVICE_LOG_ITEM_EX
{
    int                 nLogType;                   // 日志类型
    DHDEVTIME           stuOperateTime;             // 日期
    char                szOperator[16];             // 操作者
    BYTE                bReserved[3];
    BYTE                bUnionType;                 //  union结构类型,0:szLogContext；1:stuOldLog。
    union
    {
        char            szLogContext[64];           // 日志备注信息
        struct 
        {
            DH_LOG_ITEM     stuLog;                 // 旧的日志结构体
            BYTE            bReserved[48];          // 保留
        }stuOldLog;
    };
    char                szOperation[32];            // 具体的操作内容
    char                szDetailContext[4*1024];    // 详细日志信息描述
} DH_DEVICE_LOG_ITEM_EX, *LPDH_DEVICE_LOG_ITEM_EX;

// 录象日志信息,对应日志结构体里的context
typedef struct _LOG_ITEM_RECORD
{
    DHDEVTIME           time;                       // 时间
    BYTE                channel;                    // 通道
    BYTE                type;                       // 录像类型
    BYTE                reserved[2];
} LOG_ITEM_RECORD, *LPLOG_ITEM_RECORD;

typedef struct _QUERY_DEVICE_LOG_PARAM
{
    DH_LOG_QUERY_TYPE   emLogType;                  // 查询日志类型
    NET_TIME            stuStartTime;               // 查询日志的开始时间
    NET_TIME            stuEndTime;                 // 查询日志的结束时间
    int                 nStartNum;                  // 在时间段中从第几条日志开始查询,开始第一次查询可设为0
    int                 nEndNum;                    // 一次查询中到第几条日志结束,日志返回条数的最大值为1024
    BYTE                nLogStuType;                // 日志数据结构体类型,0:表示DH_DEVICE_LOG_ITEM；1:表示DH_DEVICE_LOG_ITEM_EX
    BYTE                reserved[3];                // 保留 对齐
    unsigned int        nChannelID;                 // 通道号,0:兼容之前表示所有通道号,所以通道号从1开始; 1:第一个通道
    BYTE                bReserved[40];
} QUERY_DEVICE_LOG_PARAM;

// 订阅上报日志类型
typedef enum tagNET_EM_LOG_QUERY_TYPE
{
	EM_LOG_QUERY_TYPE_UNKNOWN,
	EM_LOG_QUERY_TYPE_TEXT = 1,             //文本类型日志
}NET_EM_LOG_QUERY_TYPE;

// 设备硬盘里的录象信息
typedef struct __DEV_DISK_RECORD_INFO 
{
    NET_TIME            stuBeginTime;               // 最早录象时间
    NET_TIME            stuEndTime;                 // 最近录象时间
    char                reserved[128];
} DEV_DISK_RECORD_INFO;

// 设备硬盘录像时间信息
typedef struct __DEV_DISK_RECORD_TIME
{
    NET_TIME            stuStartTime1;              // 录像时间段1开始时间
    NET_TIME            stuEndTime1;                // 录像时间段1结束时间
    BOOL                bTwoPart;                   // 是否有第二段
    NET_TIME            stuStartTime2;              // 录像时间段2开始时间
    NET_TIME            stuEndTime2;                // 录像时间段2结束时间
    BYTE                bDiskNum;                   // 硬盘号
    BYTE                bSubareaNum;                // 分区号
    BYTE                byReserved[62];             // 保留字节  

}DEV_DISK_RECORD_TIME;

///////////////////////////////控制相关定义///////////////////////////////
//新网络键盘控制
typedef struct _NKB_PARAM
{
    BYTE                bAddressCode;               // 为DVR等设备的物理地址号,0xFF为广播地址
    BYTE                bKeyStatus;                 // 状态码 0/1 0表示按键按下 1表示按键放开
    BYTE                bExtern1;                   // 扩展字节1
    BYTE                bExtern2;                   // 扩展字节2
    BYTE                bReserved[60];
}NKB_PARAM;

// 硬盘操作
typedef struct _DISKCTRL_PARAM
{
    DWORD               dwSize;                     // 结构体大小,版本控制用
    int                 nIndex;                     // 为硬盘信息结构体DH_HARDDISK_STATE里的数组stDisks下标,从0开始
    int                 ctrlType;                   // 操作类型,
                                                    // 0 - 清除数据, 1 - 设为读写盘, 2 - 设为只读盘
                                                    // 3 - 设为冗余盘, 4 - 恢复错误, 5 - 设为快照盘,7 - 弹出SD卡（对SD卡操作有效）
    NET_DEV_DISKSTATE   stuDisk;                    // 磁盘信息, 由于磁盘顺序可能改变导致下标不准, 用来代替下标
} DISKCTRL_PARAM;

typedef struct  
{
    BYTE                bSubareaNum;                // 预分区的个数
    BYTE                bIndex;                     // 为硬盘信息结构体DH_HARDDISK_STATE里的数组stDisks下标,从0开始
    BYTE                bSubareaSize[32];           // 分区大小（百分比）
    BYTE                bReserved[30];              // 保留
} DISKCTRL_SUBAREA;

// 报警状态
typedef struct _ALARMCTRL_PARAM
{
    DWORD               dwSize;
    int                 nAlarmNo;                   // 报警通道号,从0开始
    int                 nAction;                    // 1：触发报警,0：停止报警
} ALARMCTRL_PARAM;

// 矩阵控制
typedef struct _MATRIXCTRL_PARAM
{
    DWORD               dwSize;
    int                 nChannelNo;                 // 视频输入号,从0开始
    int                 nMatrixNo;                  // 矩阵输出号,从0开始
} MATRIXCTRL_PARAM;

// 刻录控制
typedef struct _BURNING_PARM
{
    int                 channelMask;                // 通道掩码,按位表示要刻录的通道
    BYTE                devMask;                    // 刻录机掩码,根据查询到的刻录机列表,按位表示
    BYTE                bySpicalChannel;            // 画中画通道(通道数+31,例如对于4通道设备,该值应为35)
    BYTE                byReserved[2];              // 保留字段
} BURNNG_PARM;

// 附件刻录
typedef struct _BURNING_PARM_ATTACH
{
    BOOL                bAttachBurn;                // 是否为附件刻录,0:不是; 1:是
    BYTE                bReserved[12];              // 保留字段
} BURNING_PARM_ATTACH;

// 手动抓拍参数
typedef struct  _MANUAL_SNAP_PARAMETER{
    int                 nChannel;                   // 抓图通道,从0开始
    BYTE                bySequence[64];             // 抓图序列号字符串
    BYTE                byReserved[60];             // 保留字段
}MANUAL_SNAP_PARAMETER;

// 控制设备端本地预览分割参数
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_PARAMETER
{
    int                 nSliptMode;                 // 分割模式,见设备端本地预览支持的分割模式
    int                 nSubSliptNum;               // 当前要预览的子分割,从1开始
    BYTE                byReserved[64];             // 保留字段
}DEVICE_LOCALPREVIEW_SLIPT_PARAMETER;

// 设备端本地预览支持的分割模式
typedef struct _DEVICE_LOCALPREVIEW_SLIPT_CAP
{
    int                 nModeNumber;
    int                 nSliptMode[36];             // 支持的分割模式,
    BYTE                byReserved[64];             // 保留字段
}DEVICE_LOCALPREVIEW_SLIPT_CAP;

// 路口信息
typedef struct  _CROSSING_INFO
{
    char                szCrossingID[DH_MAX_CROSSING_ID];   // 路口序列号
    DWORD               dwLatitude;                         // 纬度(单位是百万分之度,范围0-180度)如北纬30（.）183382度表示为120183382)
    DWORD               dwLongitude;                        // 经度(单位是百万分之度,范围0-360度) 如东经100（.）178274度表示为280178274）
                                                            // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    WORD                wSpeedLimit;                        // 路口限速值,单位Km/h 0表示不限速,其他表示限速值上限
    BYTE                byReserved[22];
}CROSSING_INFO;

// 路线点位信息
typedef struct  _ROUTE_CROSSING_INFO
{
    BYTE                byCrossingNum;                      // 路口有效数量范围1~DH_MAX_CROSSING_NUM
    BYTE                byReserved1;
    WORD                wCrossingRange;                     // 定位精度范围单位m
    CROSSING_INFO       stCrossingInfo[DH_MAX_CROSSING_NUM];// 路口信息最大支持128个路口
    BYTE                byReserved2[2044];
}ROUTE_CROSSING_INFO;

// raid操作
typedef struct _CTRL_RAID_INFO
{
    char                szAction[16];                       // Add增加,Delete删除
    char                szName[16];                         // Raid名称
    int                 nType;                              // 类型 1:Jbod     2:Raid0      3:Raid1     4:Raid5
    int                 nStatus;                            // 状态 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
    int                 nCntMem;                            // nMember数组的有效数据个数
    int                 nMember[32];                        // 1,2,3,... 组成磁盘通道,是个数组
    int                 nCapacity;                          // 容量,单位G
    int                 nRemainSpace;                       // 剩余容量,单位M
    int                 nTank;                              // 扩展柜 0:主机,1:扩展柜1,2:扩展柜2,……
    char                reserved[128];
}CTRL_RAID_INFO;

// 热备操作
typedef struct _CTRL_SPARE_DISK_INFO
{
    char                szAction[16];                       // Enable,使能,Disable,不使能
    char                szScope[16];                        // Global,全局热备,Local,非全局热备
    char                szName[16];                         // 热备名字,若Scope为Global,则为热备池的名称,否则表示Raid组的名称
    unsigned int        nIndex;                             // 磁盘序号
    const char*         pszDevName;                         // 存储设备名称,由用户申请内存
    char                reserved[124];
}CTRL_SPARE_DISK_INFO;

typedef struct _CTRL_SPARE_DISK_INFO_A
{
    int                     nCnt;                           // 热备盘的个数
    CTRL_SPARE_DISK_INFO    stSpaceDiskInfo[32];
}CTRL_SPARE_DISK_INFO_A;

// 报警布撤防控制
typedef struct __CTRL_ARM_DISARM_PARAM
{
    BYTE                bState;                             // 布撤防状态,0表示撤防,1表示布防,2表示强制布防
    char                reserve[3];
    const char*         szDevPwd;                           // 用户密码
    NET_SCENE_MODE      emSceneMode;                        // 情景模式
    const char*         szDevID;                            // 转发目标设备ID,为NULL表示不转发
    char                reserve1[16];
} CTRL_ARM_DISARM_PARAM;

// 报警布撤防控制扩展输入参数
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_IN
{
    DWORD               dwSize;
    NET_ALARM_MODE      emState;                            // 布撤防状态
    const char*         szDevPwd;                           // 用户密码
    NET_SCENE_MODE      emSceneMode;                        // 情景模式
    const char*         szDevID;                            // 转发目标设备ID,为NULL表示不转发
} CTRL_ARM_DISARM_PARAM_EX_IN;

#define ARM_DISARM_ZONE_MAX (256)                           // 防区最大个数

// 报警布撤防控制扩展输出参数
typedef struct tagCTRL_ARM_DISARM_PARAM_EX_OUT
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // 有报警源输入布防失败的防区个数
    int                 nSource[ARM_DISARM_ZONE_MAX];       // 有报警源输入失败的防区号, 防区号从0开始
    DWORD               dwLinkNum;                          // 有联动报警布防失败的防区个数
    int                 nLink[ARM_DISARM_ZONE_MAX];         // 有联动报警失败的防区号, 防区号从0开始
} CTRL_ARM_DISARM_PARAM_EX_OUT;

// 报警布撤防控制扩展(对应DH_CTRL_ARMED_EX)
typedef struct tagCTRL_ARM_DISARM_PARAM_EX
{
    DWORD                        dwSize;
    CTRL_ARM_DISARM_PARAM_EX_IN  stuIn;                     // 报警布撤防控制输入
    CTRL_ARM_DISARM_PARAM_EX_OUT stuOut;                    // 报警布撤防控制输出
} CTRL_ARM_DISARM_PARAM_EX;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_IN
{
    DWORD               dwSize;
    int                 nType;                              // WPS连接类型,0:虚拟按钮方式; 1:(设备端)pin码方式; 2:(wifi热点端)pin码方式
    char                szSSID[DH_MAX_SSID_LEN];            // SSID,nType为1或2时有效,最大支持32位
    char                szApPin[DH_MAX_APPIN_LEN];          // APPIN码, nType为2时有效,PIN码为8位数字,这个pin码是从wifi热点端拿到的
    char                szWLanPin[DH_MAX_APPIN_LEN];        // 设备pin码,nType为1时有效:为空时由设备产生;不为空时即表示由用户设定,最大支持8位数字,这个pin码要在WIFI热点端增加
}DHCTRL_CONNECT_WIFI_BYWPS_IN;

typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS_OUT
{
    DWORD               dwSize;
    char                szRetWLanPin[DH_MAX_APPIN_LEN];// 返回设备PIN码,当WPS连接类型为(设备端)pin码方式时该输出参数有效
}DHCTRL_CONNECT_WIFI_BYWPS_OUT;

// CLIENT_ControlDevice接口的DH_CTRL_WIFI_BY_WPS命令参数(WPS快速配置WIFI)
typedef struct tagDHCTRL_CONNECT_WIFI_BYWPS
{
    DWORD                dwSize;
    DHCTRL_CONNECT_WIFI_BYWPS_IN     stuWpsInfo;            // 连接参数(由用户填写)
    DHCTRL_CONNECT_WIFI_BYWPS_OUT    stuWpsResult;          // 返回数据(由设备返回)
} DHCTRL_CONNECT_WIFI_BYWPS;

// CLIENT_ControlDevice接口的 DH_CTRL_CLOSE_BURNER 等 命令参数
typedef struct tagNET_CTRL_BURNERDOOR
{
    DWORD               dwSize;
    const char*         szBurnerName;                       // 光盘名称,如“/dev/sda”
    BOOL                bResult;                            // 操作结果
    BOOL                bSafeEject;                         // 是否安全弹出光驱, TRUE-弹出前做数据保存, FALSE-直接弹出
}NET_CTRL_BURNERDOOR;

// CLIENT_ControlDevice接口的 DH_CTRL_START_PLAYAUDIO 命令参数
typedef struct tagNET_CTRL_START_PLAYAUDIO
{
    DWORD               dwSize;
    char                szAudioPath[DH_MAX_AUDIO_PATH];
}NET_CTRL_START_PLAYAUDIO;

// 播报单元类型
typedef enum tagNET_PLAYAUDIO_TYPE
{
    NET_PLAYAUDIO_TYPE_UNKNOWN = 0,
    NET_PLAYAUDIO_TYPE_PHRASE,                          // 短语类型,不进行解析,依次读每个字,有该字的语音文件支持
    NET_PLAYAUDIO_TYPE_FILE,                            // 播放指定路径的语音文件(设备端完整路径)
    NET_PLAYAUDIO_TYPE_PLATERNUM,                       // 播报车牌号码,按车牌号码格式读出
    NET_PLAYAUDIO_TYPE_MONEY,                           // 播报金额,按金额形式读出
    NET_PLAYAUDIO_TYPE_DATE,                            // 播报日期,按日期形式读出
    NET_PLAYAUDIO_TYPE_TIME,                            // 播报时间,按时间形式读出
    NET_PLAYAUDIO_TYPE_EMPTY,                           // 空类型,停顿一个字符时间
}NET_PLAYAUDIO_TYPE;


// 语音播报优先级
enum EM_PLAYAUDIO_PRIORITY
{
	EM_PLAYAUDIO_PRIORITY_UNKNOWN,						// 未知			
	EM_PLAYAUDIO_PRIORITY_FRONT,						// 插入播放队列最前端，播放完该文件后播放原来的文件
	EM_PLAYAUDIO_PRIORITY_BACK,							// 插入播放队列最后，等待其它文件播放完再播放该文件
	EM_PLAYAUDIO_PRIORITY_EMERGENCY,					// 优先级同 EM_PLAYAUDIO_PRIORITY_FRONT，但取消队列中正在播放文件
};


// 语音播报内容
typedef struct tagNET_CTRL_PLAYAUDIO_INFO
{
    DWORD						dwSize;
    NET_PLAYAUDIO_TYPE			emPlayAudioType;                // 播报单元类型,详见NET_PLAYAUDIO_TYPE
    char						szDetail[DH_COMMON_STRING_128]; // 详细内容各类型详细内容：
																// Phrase类型:"欢迎"
																// File类型: "/home/停车.pcm"
																// PlateNumbe类型: "浙A12345"
																// Money类型: "80.12元"
																// Date类型: "2014年4月10日"
																// Time类型: "1天10小时20分5秒
	int							nRepeatTimes;					// 播放重复次数
	EM_PLAYAUDIO_PRIORITY		emPriority;						// 播放优先级
}NET_CTRL_PLAYAUDIO_INFO;

#define DH_MAX_PLAYAUDIO_COUNT    16  // 最大播报内容数目

// CLIENT_ControlDevice接口的 DH_CTRL_START_PLAYAUDIOEX 命令参数
typedef struct tagNET_CTRL_START_PLAYAUDIOEX
{
    DWORD                       dwSize;
    unsigned int                nAudioCount;                            // 播报内容数目               
    NET_CTRL_PLAYAUDIO_INFO     stuAudioInfos[DH_MAX_PLAYAUDIO_COUNT];  // 语音播报内容
}NET_CTRL_START_PLAYAUDIOEX;

// CLIENT_ControlDevice接口的 DH_CTRL_START_ALARMBELL、DH_CTRL_STOP_ALARMBELL命令参数
typedef struct tagNET_CTRL_ALARMBELL
{
    DWORD               dwSize;
    int                 nChannelID;             // 通道号(0开始)            
}NET_CTRL_ALARMBELL;

// 门禁控制--开门方式
typedef enum tagEM_OPEN_DOOR_TYPE
{
	EM_OPEN_DOOR_TYPE_UNKNOWN = 0,
	EM_OPEN_DOOR_TYPE_REMOTE,						// 远程开门
	EM_OPEN_DOOR_TYPE_LOCAL_PASSWORD,				// 本地密码开门
	EM_OPEN_DOOR_TYPE_LOCAL_CARD,					// 本地刷卡开门
	EM_OPEN_DOOR_TYPE_LOCAL_BUTTON,					// 本地按钮开门
}EM_OPEN_DOOR_TYPE;

// 开门方向
typedef enum tagEM_OPEN_DOOR_DIRECTION
{
	EM_OPEN_DOOR_DIRECTION_UNKNOWN,						// 未知，设备自行决定
	EM_OPEN_DOOR_DIRECTION_FROM_ENTER,					// 朝进门方向开门
	EM_OPEN_DOOR_DIRECTION_FROM_LEAVE,					// 朝出门方向开门
}EM_OPEN_DOOR_DIRECTION;

// CLIENT_ControlDevice接口的 DH_CTRL_ACCESS_OPEN 命令参数
typedef struct tagNET_CTRL_ACCESS_OPEN
{
    DWORD               		dwSize;
    int                 		nChannelID;                    	// 通道号(0开始)
    const char*         		szTargetID;                    	// 转发目标设备ID,为NULL表示不转发
    char                		szUserID[MAX_COMMON_STRING_32];	// 远程用户ID
	EM_OPEN_DOOR_TYPE			emOpenDoorType;                	// 开门方式
	EM_OPEN_DOOR_DIRECTION		emOpenDoorDirection;			// 开门方向
}NET_CTRL_ACCESS_OPEN;

// 门禁工作模式类型
typedef enum tagEM_NET_DOOR_WORK_MODE_TYPE
{
    NET_DOOR_WORK_MODE_UNKNOWN,            // 未知
	NET_DOOR_WORK_MODE_NORMAL,             // 正常模式
	NET_DOOR_WORK_MODE_SHUTDOWN,           // 关闭
	NET_DOOR_WORK_MODE_UNUSED,             // 停用
	NET_DOOR_WORK_MODE_OPEN_DOOR_CONTINUE, // 持续打开

}EM_NET_DOOR_WORK_MODE_TYPE;

// 设置门禁工作模式（入参）
typedef struct tagNET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
	DWORD                   dwSize;
	EM_NET_DOOR_WORK_MODE_TYPE emWorkMode;    // 工作模式类型
}NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// 设置门禁工作模式（出参）
typedef struct tagNET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE
{
    DWORD                   dwSize;
}NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE;

// 同步防护舱LED的时间（入参）
typedef struct tagNET_IN_CTRL_SYNC_CABINLED_TIME
{
	DWORD                   dwSize;
}NET_IN_CTRL_SYNC_CABINLED_TIME;

// 同步防护舱LED的时间（出参）
typedef struct tagNET_OUT_CTRL_SYNC_CABINLED_TIME
{
    DWORD                   dwSize;
}NET_OUT_CTRL_SYNC_CABINLED_TIME;

// 防护舱LED播放控制类型
typedef enum tagEM_NET_CABIN_LED_PLAY_CONTROL_MODE
{
    NET_CABIN_LED_PLAY_CONTROL_MODE_UNKNOWN,          // 未知
    NET_CABIN_LED_PLAY_CONTROL_MODE_NORMAL_TURN_ON,   // 正常播放 ( 开屏 )
    NET_CABIN_LED_PLAY_CONTROL_MODE_NEXT_PROGRAM,     // 后一节目       
    NET_CABIN_LED_PLAY_CONTROL_MODE_PREVIOUS_PROGRAM, // 前一节目
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE,            // 暂停播放
    NET_CABIN_LED_PLAY_CONTROL_MODE_PAUSE_TURN_OFF,   // 暂停播放 ( 关屏 )
    NET_CABIN_LED_PLAY_CONTROL_MODE_PLAY_GO_ON,       // 继续播放
    NET_CABIN_LED_PLAY_CONTROL_MODE_GO_TO_TEST_ITSELF,// 进入自测
    NET_CABIN_LED_PLAY_CONTROL_MODE_EXIT_TEST_ITSELF, // 退出自测
    NET_CABIN_LED_PLAY_CONTROL_MODE_SYSTEM_RESET,     // 复位系统
}EM_NET_CABIN_LED_PLAY_CONTROL_MODE;

// 防护舱LED播放控制（入参）
typedef struct tagNET_IN_CTRL_CABINLED_PLAYCONTROL
{
	DWORD                                   dwSize;
	EM_NET_CABIN_LED_PLAY_CONTROL_MODE         emAction; // 播放类型
}NET_IN_CTRL_CABINLED_PLAYCONTROL;

// 防护舱LED播放控制（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_PLAYCONTROL
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_PLAYCONTROL;

// 防护舱LED更改内容的命令类型
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE
{
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_UNKNOWN,
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_ADD       = 0, // 增加
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_MODIFY    = 1, // 修改
    NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE_DELETE    = 2, // 删除
}EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE;

// 防护舱LED播放控制效果
typedef enum tagEM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE
{
    NET_MODIFY_CONTENT_EFFECT_TYPE_UNKNOWN = -1,
    NET_MODIFY_CONTENT_EFFECT_TYPE_SHOW = 0,                      // 立即显示
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_LEFT,                     // 左移
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_RIGHT,                    // 右移
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_UP,                       // 上移
    NET_MODIFY_CONTENT_EFFECT_TYPE_MOVE_DOWN,                     // 下移
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT,                  // 左填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_RIGHT,                 // 右填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP,                    // 上填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN,                  // 下填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_LEFT,               // 从左上角填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_LEFT,             // 从左下角填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_RIGHT,              // 从右上角填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_DOWN_RIGHT,            // 从右下角填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_RIGHT_TO_CENTER,  // 两边向中间填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_LEFT_RIGHT,  // 中间向两边填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_DOWN_TO_CENTER,     // 上下向中间填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_UP_DOWN,     // 中间向上下填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_LEFT_CROSS_RIGHT,      // 左右交叉填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_UP_CROSS_DOWN,         // 上下交叉填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_VERTICAL_BLINDS,               // 垂直百叶窗
    NET_MODIFY_CONTENT_EFFECT_TYPE_HORIZONTAL_BLINDS,             // 水平百叶窗  
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_SIDES,       // 中间向四边填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_SIDES_TO_CENTER,       // 四边向中间填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CENTER_TO_CORNER,      // 中间向四角填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_FILL_UP_CORNER_TO_CENTER,      // 四角向中间填充
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_360,                    // 旋转360度
    NET_MODIFY_CONTENT_EFFECT_TYPE_ROTATE_180,                    // 旋转180度
}EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE;

// 防护舱LED内容更改（入参）
typedef struct tagNET_IN_CTRL_CABINLED_MODIFY_CONTENT
{
	DWORD                                    dwSize;
	EM_NET_CABIN_LED_MODIFY_CONTENT_CMD_TYPE emCmd;             // 消息类型
	int                                      nMsgID;            // 消息ID 取值1-5
	EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;       // 特效类型
	int                                      nSpeed;            // 显示速度 取值为0到15
	int                                      nDuration;         // 停留时间 单位为秒
	char                                     szText[512];       // 文本行内容
}NET_IN_CTRL_CABINLED_MODIFY_CONTENT;

// 防护舱LED内容更改（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_MODIFY_CONTENT
{
    DWORD                   dwSize;
}NET_OUT_CTRL_CABINLED_MODIFY_CONTENT;

// 获取防护舱LED内容（入参）
typedef struct tagNET_IN_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;    
    int                     nMsgID;            // 消息ID 取值1-5   
}NET_IN_CTRL_CABINLED_GET_CONTENT;

// 获取防护舱LED内容（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CONTENT
{
    DWORD                   dwSize;
    int                     nMsgID;            // 消息ID 取值1-5
    EM_NET_CABIN_LED_MODIFY_CONTENT_EFFECT_TYPE emEffect;          // 特效类型
    int                     nSpeed;            // 显示速度 取值为0到15
    int                     nDuration;         // 停留时间 单位为秒
    char                    szText[512];       // 文本行内容
}NET_OUT_CTRL_CABINLED_GET_CONTENT;

// 时间段结构                                                                
typedef struct tagDH_TSECT
{
    int             bEnable;                        // 当表示录像时间段时,按位表示四个使能,从低位到高位分别表示动检录象、报警录象、普通录象、动检和报警同时发生才录像
													// 当表示布撤防时间段时, 表示使能
													// 当表示推送时间段时, 表示使能：1表示使能，0表示非使能
    int             iBeginHour;
    int             iBeginMin;
    int             iBeginSec;
    int             iEndHour;
    int             iEndMin;
    int             iEndSec;
} DH_TSECT, *LPDH_TSECT;

#define NET_CABINLED_SCHEDULE_TIME_SECTION_NUM 8  // 防护舱LED显示计划时间段的最大数目

// 设置防护舱LED显示设置计划（入参）
typedef struct tagNET_IN_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // 计划索引号 0 表示周日 1~6 表示周一到周六    
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // 时间段数据数组 DH_TSECT中的字段bEnable 为0表示无效，正值表示消息号

}NET_IN_CTRL_CABINLED_SET_SCHEDULE;

// 设置防护舱LED显示设置计划（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_SET_SCHEDULE
{
    DWORD dwSize;   
}NET_OUT_CTRL_CABINLED_SET_SCHEDULE;

// 获取防护舱LED显示设置计划（入参）
typedef struct tagNET_IN_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD                       dwSize;    
    int                         nIndex;                                                 // 计划索引号 0 表示周日 1~6 表示周一到周六
}NET_IN_CTRL_CABINLED_GET_SCHEDULE;

// 获取防护舱LED显示设置计划（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_GET_SCHEDULE
{
    DWORD dwSize;
    DH_TSECT                    stuTimeSection[NET_CABINLED_SCHEDULE_TIME_SECTION_NUM]; // 时间段数据数组 DH_TSECT中的字段bEnable 为0表示无效，正值表示消息号
}NET_OUT_CTRL_CABINLED_GET_SCHEDULE;

// 获取防护舱LED显示字符编码方式（入参）
typedef struct tagNET_IN_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD                       dwSize;                     // 结构体大小    
}NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING;

// 获取防护舱LED显示字符编码方式（出参）
typedef struct tagNET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING
{
    DWORD dwSize;                                           // 结构体大小
    int nCharacterEncoding;                                 // 字符编码方式 0-GB2312 1-Unicode                         
}NET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING;


// 防护舱LED控制类型
typedef enum tagEM_CABIN_LED_CONTROL_TYPE
{
    DH_CABIN_LED_CONTROL_UNKNOWN,                       // 未知                      
    DH_CABIN_LED_CONTROL_SYNC_TIME,                     // 同步防护舱LED的时间(pInParam对应结构体NET_IN_CTRL_SYNC_CABINLED_TIME,pOutParam对应结构体NET_OUT_CTRL_SYNC_CABINLED_TIME)
    DH_CABIN_LED_CONTROL_PLAY_CONTROL,                  // 防护舱LED播放控制(pInParam对应结构体NET_IN_CTRL_CABINLED_PLAYCONTROL,pOutParam对应结构体NET_OUT_CTRL_CABINLED_PLAYCONTROL)
    DH_CABIN_LED_CONTROL_MODIFY_CONTENT,                // 防护舱LED更改内容(pInParam对应结构体NET_IN_CTRL_CABINLED_MODIFY_CONTENT,pOutParam对应结构体NET_OUT_CTRL_CABINLED_MODIFY_CONTENT)
    DH_CABIN_LED_CONTROL_GET_CONTENT,                   // 获取防护舱LED内容(pInParam对应结构体NET_IN_CTRL_CABINLED_GET_CONTENT,pOutParam对应结构体NET_OUT_CTRL_CABINLED_GET_CONTENT)
    DH_CABIN_LED_CONTROL_SET_SCHEDULE,                  // 设置防护舱LED显示计划(pInParam对应结构体NET_IN_CTRL_CABINLED_SET_SCHEDULE,pOutParam对应结构体NET_OUT_CTRL_CABINLED_SET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_SCHEDULE,                  // 获取防护舱LED显示计划(pInParam对应结构体NET_IN_CTRL_CABINLED_GET_SCHEDULE,pOutParam对应结构体NET_OUT_CTRL_CABINLED_GET_SCHEDULE)
    DH_CABIN_LED_CONTROL_GET_CHAR_ENCODING,             // 获取防护舱LED显示字符编码方式(pInParam对应结构体NET_IN_CTRL_CABINLED_GET_CHAR_ENCODING,pOutParam对应结构体NET_OUT_CTRL_CABINLED_GET_CHAR_ENCODING)
}EM_CABIN_LED_CONTROL_TYPE;

// CLIENT_ControlDevice接口的 DH_CTRL_ACCESS_CLOSE 命令参数
typedef struct tagNET_CTRL_ACCESS_CLOSE
{
    DWORD						dwSize;					// 结构体大小
    int							nChannelID;             // 通道号(0开始)
}NET_CTRL_ACCESS_CLOSE;

typedef enum tagNET_ALARM_TYPE
{
    NET_ALARM_LOCAL = 0,                        //开关量防区的报警事件(对应 DH_ALARM_ALARM_EX2 事件)
    NET_ALARM_ALARMEXTENDED,                    //扩展模块报警事件(对应 DH_ALARM_ALARMEXTENDED 事件)
    NET_ALARM_TEMP,                             //温度报警事件(对应 DH_ALARM_TEMPERATURE 事件)
    NET_ALARM_URGENCY,                          //紧急报警事件(对应 DH_URGENCY_ALARM_EX 事件)
    NET_ALARM_RCEMERGENCYCALL,                  //紧急呼叫报警事件(对应 DH_ALARM_RCEMERGENCY_CALL 事件)
    NET_ALARM_ALL,                              //所有报警事件
}NET_ALARM_TYPE;

// CLIENT_ControlDevice接口的 DH_CTRL_CLEAR_ALARM 命令参数
typedef struct tagNET_CTRL_CLEAR_ALARM
{
    DWORD               dwSize;
    int                 nChannelID;             // 防区通道号, -1 表示所有通道
    NET_ALARM_TYPE      emAlarmType;            // 事件类型(支持的类型较少,建议用nEventType字段)
    const char*         szDevPwd;               // 登陆设备的密码,如不使用加密消警,直接赋值为NULL
    BOOL                bEventType;             // 表示是否启用nEventType字段, TRUE:nEventType代替emAlarmType字段, FALSE:沿用emAlarmType字段,忽略nEventType字段
    int                 nEventType;             // 事件类型, 对应 fMessCallBack 回调来上的lCommand字段, 即CLIENT_StartListenEx接口获得事件类型
                                                // 比如DH_ALARM_ALARM_EX2表示本地报警事件
}NET_CTRL_CLEAR_ALARM;

// 电视墙显示信息控制参数
typedef struct tagNET_CTRL_MONITORWALL_TVINFO 
{
    DWORD               dwSize;
    int                 nMonitorWallID;         // 电视墙ID, DH_CTRL_MONITORWALL_TVINFO 和 DH_DEVSTATE_MONITORWALL_TVINFO都需要填写
    BOOL                bDecodeChannel;         // 显示解码通道信息, DH_CTRL_MONITORWALL_TVINFO 填写
    BOOL                bControlID;             // 显示屏幕控制ID, DH_CTRL_MONITORWALL_TVINFO 填写
    BOOL                bCameraID;              // 显示解码通道视频源控制ID, DH_CTRL_MONITORWALL_TVINFO 填写
} NET_CTRL_MONITORWALL_TVINFO;

// CLIENT_ControlDevice接口的 DH_CTRL_START_VIDEO_ANALYSE 命令参数
typedef struct tagNET_CTRL_START_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // 通道号  
}NET_CTRL_START_VIDEO_ANALYSE;

// CLIENT_ControlDevice接口的 DH_CTRL_STOP_VIDEO_ANALYSE 命令参数
typedef struct tagNET_CTRL_STOP_VIDEO_ANALYSE
{
    DWORD               dwSize; 
    int                 nChannelId;             // 通道号  
}NET_CTRL_STOP_VIDEO_ANALYSE;

// CLIENT_ControlDevice接口的 DH_CTRL_MULTIPLAYBACK_CHANNALES 命令参数 
typedef struct tagNET_CTRL_MULTIPLAYBACK_CHANNALES
{
    DWORD               dwSize;
    LLONG               lPlayBackHandle;        // 回放句柄,CLIENT_MultiPlayBack接口返回值
    int                 nChannels[DH_MAX_MULTIPLAYBACK_CHANNEL_NUM];// 预览通道号
    int                 nChannelNum;            // 预览通道数 
}NET_CTRL_MULTIPLAYBACK_CHANNALES;

// CLIENT_ControlDevice接口的 DH_CTRL_SET_BYPASS 命令参数
typedef struct tagNET_CTRL_SET_BYPASS
{
    DWORD               dwSize;
    const char*         szDevPwd;               // 登入设备的密码
    NET_BYPASS_MODE     emMode;                 // 通道状态
    int                 nLocalCount;            // 本地报警输入通道个数
    int*                pnLocal;                // 本地报警输入通道号    
    int                 nExtendedCount;         // 扩展模块报警输入通道个数
    int*                pnExtended;             // 扩展模块报警输入通道号
}NET_CTRL_SET_BYPASS;
 
// CLIENT_ControlDevice接口的  DH_CTRL_SET_MEDIAKIND 命令参数
typedef struct tagNET_CTRL_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  用户使用该结构体时,dwSize 需赋值为 sizeof(NET_CTRL_SET_MEDIAKIND)
    int                  nMediaKind;                    //  媒体种类,0:包含音频和视频,1:只包含视频,2:只包含音频
    DWORD                dwChannelCount;                //  有效通道数
    int                  nChannels[256];                //  视频通道号(从0开始)
} NET_IN_SET_MEDIAKIND;

// CLIENT_ControlDevice接口的  DH_CTRL_SET_MEDIAKIND 输出参数
typedef struct tagNET_OUT_SET_MEDIAKIND
{
    DWORD                dwSize;                        //  用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_SET_MEDIAKIND)
} NET_OUT_SET_MEDIAKIND;

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CLIENT_QueryDevState接口的 DH_DEVSTATE_GET_BYPASS 命令参数
typedef struct tagNET_DEVSTATE_GET_BYPASS
{
    DWORD               dwSize;
    int                 nLocalCount;            // 本地报警输入通道个数
    int*                pnLocal;                // 本地报警输入通道号    
    int                 nExtendedCount;         // 扩展模块报警输入通道个数
    int*                pnExtended;             // 扩展模块报警输入通道号
    NET_BYPASS_MODE*    pemLocal;               // 本地报警输入通道状态
    NET_BYPASS_MODE*    pemExtended;            // 扩展模块报警输入通道状态
}NET_DEVSTATE_GET_BYPASS;

// CLIENT_QueryDevState接口的 DH_DEVSTATE_BURNERDOOR 命令参数
typedef struct tagNET_DEVSTATE_BURNERDOOR
{
    DWORD               dwSize;
    const char*         szBurnerName;            // 光盘名称,如“/dev/sda”
    bool                bEjected;                // 是否已经弹出
    BYTE                Reserved[3];             // 保留
}NET_DEVSTATE_BURNERDOOR;

// CLIENT_QueryDevState接口的 DH_DEVSTATE_GET_DATA_CHECK 命令参数
typedef struct tagNET_DEVSTATE_DATA_CHECK
{
    DWORD               dwSize;                     // 结构体大小
    const char*         szBurnerName;               // 光盘名称,如“/dev/s",如果是多光盘的话,任何一个光盘都可以
    char                szState[DH_MAX_STRING_LEN]; // "NotStart":尚未开始,"Verifying":校验中,"Failed":失败,"Successed":成功
    int                 nPercent;                   // 校验百分比:0-100,state是Verifying时才有效
}NET_DEVSTATE_DATA_CHECK;

// CLIENT_ListenServer 接口回调fServiceCallBack函数支持的命令类型
enum { 
    DH_DVR_DISCONNECT=-1,                           // 验证期间设备断线回调
    DH_DVR_SERIAL_RETURN=1,                         // 设备注册携带序列号 对应 char* szDevSerial
    NET_DEV_AUTOREGISTER_RETURN,                    // 设备注册携带序列号和令牌 对应NET_CB_AUTOREGISTER
    NET_DEV_NOTIFY_IP_RETURN,                       // 设备仅上报IP, 不作为主动注册用, 用户获取ip后只能按照约定的端口按照非主动注册的类型登录
};
typedef struct tagNET_CB_AUTOREGISTER
{
    DWORD           dwSize;                          // 结构体大小
    char            szDevSerial[DH_DEV_SERIALNO_LEN];// 序列号
    char            szToken[MAX_PATH];               // 令牌
}NET_CB_AUTOREGISTER;

// 公网代理注册相关结构体
typedef struct tagCLOUDSERVICE_CONNECT_PARAM
{
    DWORD               dwSize;   
    char                szDstIp[DH_MAX_IPADDR_EX_LEN];    // 服务器IP
    int                 nDstPort;                         // 服务器端口号 
    DWORD               dwConnectType;                    // 连接类型：0表示主连接,1表示隧道连接,2数据连接, 3动态注册子连接（使用0xb4注册）  
    char                szToken[MAX_PATH];                // 使用者自定义设备通道唯一ID令牌
}NET_CLOUDSERVICE_CONNECT_PARAM;

typedef struct tagCLOUDSERVICE_CONNECT_RESULT
{
    DWORD               dwSize;  
    DWORD               dwConnectState;                           // 当前连接状态：1成功,0失败
    char                szMessage[DH_MAX_CLOUDCONNECT_STATE_LEN]; // 连接状态信息,"Success","Password Error","Network Error","Timeout"
}NET_CLOUDSERVICE_CONNECT_RESULT;
///////////////////////////////配置相关定义///////////////////////////////

//-------------------------------设备属性---------------------------------
// 设备信息
typedef struct
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];     // 序列号
    BYTE                byAlarmInPortNum;                   // DVR报警输入个数
    BYTE                byAlarmOutPortNum;                  // DVR报警输出个数
    BYTE                byDiskNum;                          // DVR硬盘个数
    BYTE                byDVRType;                          // DVR类型,见枚举 NET_DEVICE_TYPE
    union
    {
        BYTE            byChanNum;                          // DVR通道个数,登陆成功时有效
        BYTE            byLeftLogTimes;                     // 当登陆失败原因为密码错误时,通过此参数通知用户,剩余登陆次数,为0时表示此参数无效
    };
} NET_DEVICEINFO, *LPNET_DEVICEINFO;

// 设备信息扩展
typedef struct
{
    BYTE                sSerialNumber[DH_SERIALNO_LEN];     // 序列号
    int                 nAlarmInPortNum;                    // DVR报警输入个数
    int                 nAlarmOutPortNum;                   // DVR报警输出个数
    int                 nDiskNum;                           // DVR硬盘个数
    int                 nDVRType;                           // DVR类型,见枚举 NET_DEVICE_TYPE
    int                 nChanNum;                           // DVR通道个数
    BYTE                byLimitLoginTime;                   // 在线超时时间,为0表示不限制登陆,非0表示限制的分钟数
    BYTE                byLeftLogTimes;                     // 当登陆失败原因为密码错误时,通过此参数通知用户,剩余登陆次数,为0时表示此参数无效
    BYTE                bReserved[2];                       // 保留字节,字节对齐
    int                 nLockLeftTime;                      // 当登陆失败,用户解锁剩余时间（秒数）, -1表示设备未设置该参数
    char                Reserved[24];                       // 保留
} NET_DEVICEINFO_Ex, *LPNET_DEVICEINFO_Ex;

// 设备软件版本信息,高16位表示主版本号,低16位表示次版本号
typedef struct 
{
    DWORD               dwSoftwareVersion;
    DWORD               dwSoftwareBuildDate;
    DWORD               dwDspSoftwareVersion;
    DWORD               dwDspSoftwareBuildDate;
    DWORD               dwPanelVersion;
    DWORD               dwPanelSoftwareBuildDate;
    DWORD               dwHardwareVersion;
    DWORD               dwHardwareDate;
    DWORD               dwWebVersion;
    DWORD               dwWebBuildDate;
} DH_VERSION_INFO, *LPDH_VERSION_INFO;

// 设备软件版本信息,对应CLIENT_QueryDevState接口
typedef struct  
{
    char                szDevSerialNo[DH_DEV_SERIALNO_LEN];         // 序列号
    char                byDevType;                                  // 设备类型,见枚举NET_DEVICE_TYPE
    char                szDevType[DH_DEV_TYPE_LEN];                 // 设备详细型号,字符串格式,可能为空
    int                 nProtocalVer;                               // 协议版本号
    char                szSoftWareVersion[DH_MAX_URL_LEN];
    DWORD               dwSoftwareBuildDate;
    char                szPeripheralSoftwareVersion[DH_MAX_URL_LEN];// 从片版本信息,字符串格式,可能为空
    DWORD               dwPeripheralSoftwareBuildDate;
    char                szGeographySoftwareVersion[DH_MAX_URL_LEN]; // 地理信息定位芯片版本信息,字符串格式,可能为空
    DWORD               dwGeographySoftwareBuildDate;
    char                szHardwareVersion[DH_MAX_URL_LEN];
    DWORD               dwHardwareDate;
    char                szWebVersion[DH_MAX_URL_LEN];
    DWORD               dwWebBuildDate;
    char                szDetailType[MAX_COMMON_STRING_64];          // 设备详细型号,字符串格式,可能为空
    char                reserved[192];
} DHDEV_VERSION_INFO;

// DSP能力描述,对应CLIENT_GetDevConfig接口
typedef struct 
{
    DWORD               dwVideoStandardMask;        // 视频制式掩码,按位表示设备能够支持的视频制式
    DWORD               dwImageSizeMask;            // 分辨率掩码,按位表示设备能够支持的分辨率设置
    DWORD               dwEncodeModeMask;           // 编码模式掩码,按位表示设备能够支持的编码模式设置    
    DWORD               dwStreamCap;                // 按位表示设备支持的多媒体功能,
                                                    // 第一位表示支持主码流
                                                    // 第二位表示支持辅码流1
                                                    // 第三位表示支持辅码流2
                                                    // 第五位表示支持jpg抓图
    DWORD               dwImageSizeMask_Assi[8];    // 表示主码流为各分辨率时,支持的辅码流分辨率掩码。
    DWORD               dwMaxEncodePower;           // DSP支持的最高编码能力 
    WORD                wMaxSupportChannel;         // 每块DSP支持最多输入视频通道数 
    WORD                wChannelMaxSetSync;         // DSP每通道的最大编码设置是否同步；0：不同步,1：同步
} DH_DSP_ENCODECAP, *LPDH_DSP_ENCODECAP;

// DSP能力描述,扩展类型,对应CLIENT_QueryDevState接口
typedef struct 
{
    DWORD               dwVideoStandardMask;        // 视频制式掩码,按位表示设备能够支持的视频制式
    DWORD               dwImageSizeMask;            // 分辨率掩码,按位表示设备能够支持的分辨率
    DWORD               dwEncodeModeMask;           // 编码模式掩码,按位表示设备能够支持的编码模式
    DWORD               dwStreamCap;                // 按位表示设备支持的多媒体功能,
                                                    // 第一位表示支持主码流
                                                    // 第二位表示支持辅码流1
                                                    // 第三位表示支持辅码流2
                                                    // 第五位表示支持jpg抓图
    DWORD               dwImageSizeMask_Assi[32];   // 表示主码流为各分辨率时,支持的辅码流分辨率掩码。
    DWORD               dwMaxEncodePower;           // DSP支持的最高编码能力 
    WORD                wMaxSupportChannel;         // 每块DSP支持最多输入视频通道数 
    WORD                wChannelMaxSetSync;         // DSP每通道的最大编码设置是否同步；0：不同步,1：同步
    BYTE                bMaxFrameOfImageSize[32];   // 不同分辨率下的最大采集帧率,与dwVideoStandardMask按位对应
    BYTE                bEncodeCap;                 // 标志,配置时要求符合下面条件,否则配置不能生效；
                                                    // 0：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力,
                                                    // 1：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力,
                                                    // 辅码流的编码能力 <= 主码流的编码能力,
                                                    // 辅码流的分辨率 <= 主码流的分辨率,
                                                    // 主码流和辅码流的帧率 <= 前端视频采集帧率
                                                    // 2：N5的计算方法
                                                    // 辅码流的分辨率 <= 主码流的分辨率
                                                    // 查询支持的分辨率和相应最大帧率
    char                reserved[95];
} DHDEV_DSP_ENCODECAP, *LPDHDEV_DSP_ENCODECAP;

// DSP扩展能力描述,对应CLIENT_QueryDevState接口
typedef struct 
{
    DWORD               dwVideoStandardMask;        // 视频制式掩码,按位表示设备能够支持的视频制式
    DWORD               dwImageSizeMask;            // 分辨率掩码,按位表示设备能够支持的分辨率
    DWORD               dwEncodeModeMask;           // 编码模式掩码,按位表示设备能够支持的编码模式
    DWORD               dwStreamCap;                // 按位表示设备支持的多媒体功能,
                                                    // 第一位表示支持主码流
                                                    // 第二位表示支持辅码流1
                                                    // 第三位表示支持辅码流2
                                                    // 第四位表示支持辅码流3
                                                    // 第五位表示支持jpg抓图
    DWORD               dwImageSizeMask_Assi[3][64];// 表示主码流为各分辨率时,支持的辅码流分辨率掩码, 数组中的0,1,2元素分别代表辅码流1,2,3
    DWORD               dwMaxEncodePower;           // DSP支持的最高编码能力 
    WORD                wMaxSupportChannel;         // 每块DSP支持最多输入视频通道数 
    WORD                wChannelMaxSetSync;         // DSP每通道的最大编码设置是否同步；0：不同步,1：同步
    BYTE                bMaxFrameOfImageSize[32];   // 不同分辨率下的最大采集帧率,与dwVideoStandardMask按位对应
    BYTE                bEncodeCap;                 // 标志,配置时要求符合下面条件,否则配置不能生效；
                                                    // 0：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力,
                                                    // 1：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力,
                                                    // 辅码流的编码能力 <= 主码流的编码能力,
                                                    // 辅码流的分辨率 <= 主码流的分辨率,
                                                    // 主码流和辅码流的帧率 <= 前端视频采集帧率
                                                    // 2：N5的计算方法
                                                    // 辅码流的分辨率 <= 主码流的分辨率
                                                    // 查询支持的分辨率和相应最大帧率
    BYTE                btReserve1[3];              // 字节对齐

    DWORD               dwExtraStream;              // 第0位表示主码流, 其它按位依次表示辅码流, 如第一位表示辅码流1,第二们表示辅码流2
    DWORD               dwCompression[3];           // 每一个值表示对应辅码流的编码格式支持
    
    char                reserved[108];
} DHDEV_DSP_ENCODECAP_EX, *LPDHDEV_DSP_ENCODECAP_EX;

// 系统信息
typedef struct 
{
    DWORD               dwSize;
    /* 下面是设备的只读部分 */
    DH_VERSION_INFO     stVersion;
    DH_DSP_ENCODECAP    stDspEncodeCap;                     // DSP能力描述
    BYTE                szDevSerialNo[DH_DEV_SERIALNO_LEN]; // 序列号
    BYTE                byDevType;                          // 设备类型,见枚举NET_DEVICE_TYPE
    BYTE                szDevType[DH_DEV_TYPE_LEN];         // 设备详细型号,字符串格式,可能为空
    BYTE                byVideoCaptureNum;                  // 视频口数量
    BYTE                byAudioCaptureNum;                  // 音频口数量
    BYTE                byTalkInChanNum;                    // 对讲输入接口数量
    BYTE                byTalkOutChanNum;                   // 对讲输出接口数量
    BYTE                byDecodeChanNum;                    // NSP
    BYTE                byAlarmInNum;                       // 报警输入口数
    BYTE                byAlarmOutNum;                      // 报警输出口数
    BYTE                byNetIONum;                         // 网络口数
    BYTE                byUsbIONum;                         // USB口数量
    BYTE                byIdeIONum;                         // IDE数量
    BYTE                byComIONum;                         // 串口数量
    BYTE                byLPTIONum;                         // 并口数量
    BYTE                byVgaIONum;                         // NSP
    BYTE                byIdeControlNum;                    // NSP
    BYTE                byIdeControlType;                   // NSP
    BYTE                byCapability;                       // NSP,扩展描述
    BYTE                byMatrixOutNum;                     // 视频矩阵输出口数
    /* 下面是设备的可写部分 */
    BYTE                byOverWrite;                        // 硬盘满处理方式(覆盖、停止)
    BYTE                byRecordLen;                        // 录象打包长度
    BYTE                byDSTEnable;                        // 是否实行夏令时 1-实行 0-不实行
    WORD                wDevNo;                             // 设备编号,用于遥控
    BYTE                byVideoStandard;                    // 视频制式:0-PAL,1-NTSC
    BYTE                byDateFormat;                       // 日期格式
    BYTE                byDateSprtr;                        // 日期分割符(0：".",1："-",2："/")
    BYTE                byTimeFmt;                          // 时间格式 (0-24小时,1－12小时)
    BYTE                byLanguage;                         // 枚举值详见DH_LANGUAGE_TYPE
} DHDEV_SYSTEM_ATTR_CFG, *LPDHDEV_SYSTEM_ATTR_CFG;

// 修改设备配置返回信息
typedef struct
{
    DWORD               dwType;                     // 类型(即GetDevConfig和SetDevConfig的类型)
    WORD                wResultCode;                // 返回码；0：成功,1：失败,2：数据不合法,3：暂时无法设置,4：没有权限
    WORD                wRebootSign;                // 重启标志；0：不需要重启,1：需要重启才生效
    DWORD               dwReserved[2];              // 保留    
} DEV_SET_RESULT;

// 请求监视或回放的错误返回信息
typedef struct
{
    DWORD               dwResultCode;               // 错误返回码
                                                    // 1:无权限,2:设备不支持此操作,3:资源不足, 4:设备无法获取当前请求数据
                                                    // 11:表示高级用户抢占低级用户资源, 12:禁止入网, 13:磁盘读数据限制
                                                    // 14: 多画面预览已打开,资源不足,压缩回放失败, 15: 压缩回放功能已打开,导致失败
                                                    // 16: 表示此视频通道处于离线，拉流失败
                                                    // 21: 未知的压缩失败原因, 22: 超出解码能力，导致压缩失败,
                                                    // 23: 超出压缩能力，导致压缩失败, 24: 无原始码流，导致压缩失败
                                                    // 25: 压缩通道所在的从片掉线，导致压缩失败
    LLONG               lPlayHandle;                // 相应句柄值
    BYTE                byReserved[32];             // 保留字节                         

}DEV_PLAY_RESULT;

// 请求语音对讲的错误返回信息
typedef struct
{
    DWORD               dwResultCode;               // 错误返回码 CLIENT_GetLastError接口的返回值
                                                    // NET_ERROR_TALK_REJECT _EC(375) // 拒绝对讲
                                                    // NET_ERROR_TALK_RESOURCE_CONFLICIT _EC(377) // 资源冲突
                                                    // NET_ERROR_TALK_UNSUPPORTED_ENCODE _EC(378) // 不支持的语音编码格式
                                                    // NET_ERROR_TALK_RIGHTLESS _EC(379) // 无权限
    LLONG               lTalkHandle;                // 相应句柄值
    BYTE                byReserved[32];             // 保留字节                         
}DEV_TALK_RESULT;

//DST(夏令时)配置
typedef struct  
{
    int                 nYear;                      // 年[200 - 2037]
    int                 nMonth;                     // 月[1 - 12]
    int                 nHour;                      // 小时 [0 - 23]
    int                 nMinute;                    // 分钟 [0 - 59]
    int                 nWeekOrDay;                 // [-1 - 4]0:表示使用按日期计算的方法
                                                    // 1: 按周计算: 第一周,2: 第二周,3: 第三周,4: 第四周,-1: 最后一周
    union
    {
        int             iWeekDay;                   // 周[0 - 6](nWeekOrDay：按周计算时)0:星期日, 1:星期一, 2:星期二,3:星期三,4:星期四,5:星期五,6:星期六
        int             iDay;                       // 日期[1 - 31] (nWeekOrDay：按日期计算)
    };
    
    DWORD               dwReserved[8];              // 保留    
}DH_DST_POINT;

typedef struct  
{
    DWORD               dwSize;
    int                 nDSTType;                   // 夏令时定位方式 0:按日期定位方式, 1:按周定位方式
    DH_DST_POINT        stDSTStart;                 // 开始夏令时
    DH_DST_POINT        stDSTEnd;                   // 结束夏令时
    DWORD               dwReserved[16];             // 保留    
}DHDEV_DST_CFG;


// 自动维护配置
typedef struct
{
    DWORD               dwSize;
    BYTE                byAutoRebootDay;            // 自动重启；0：从不, 1：每天,2：每星期日,3：每星期一,......
    BYTE                byAutoRebootTime;           // 0：0:00,1：1:00,......23：23:00
    BYTE                byAutoDeleteFilesTime;      // 自动删除文件；0：从不,1：24H,2：48H,3：72H,4：96H,5：ONE WEEK,6：ONE MONTH
    BYTE                reserved[13];               // 保留位
} DHDEV_AUTOMT_CFG;

// 车载中硬盘信息
typedef struct  
{
    DWORD               dwSize;                                     // 结构体大小,此属性必须初始化
    DWORD               dwVolume;                                   // 硬盘容量
    DWORD               dwFreeSpace;                                // 硬盘的剩余空间, 单位MB(B表示字节)
    BYTE                byModle[DH_MAX_HARDDISK_TYPE_LEN];          // 硬盘型号
    BYTE                bySerialNumber[DH_MAX_HARDDISK_SERIAL_LEN]; // 硬盘序列号
}DHDEV_VEHICLE_DISK;

// 车载相关的3G模块信息,最大支持DH_MAX_SIM_NUM个模块
typedef struct
{
    DWORD               dwSize;                                     // 结构体大小,此属性必须初始化
    BYTE                szIMSI[DH_MAX_SIM_LEN];                     // SIM卡的值例如460012002778636 ,前3位为国家代号MCC,4-6位为网络代号MNC,后面的为移动用户身份标识MSIN,总共不会超过15个字符
    BYTE                szMDN[DH_MAX_MDN_LEN];                      // SIM卡MDN值
}DHDEV_VEHICLE_3GMODULE;

// 车载的基本信息
typedef struct 
{
    DWORD                   dwSize;                                 // 结构体大小,此属性必须初始化
    DWORD                   dwSoftwareBuildDate;                    // 软件生成日期
    char                    szVersion[DH_MAX_VERSION_LEN];          // 软件版本
    char                    szDevSerialNo[DH_DEV_SERIALNO_LEN];     // 主板序列号
    char                    szDevType[DH_DEV_TYPE_LEN];             // 设备详细型号,字符串格式,可能为空
    DWORD                   dwDiskNum;                              // 硬盘个数
    DHDEV_VEHICLE_DISK      stuHarddiskInfo[DH_MAX_DISKNUM];        // 硬盘相关信息
    DWORD                   dw3GModuleNum;                          // 3G模块个数
    DHDEV_VEHICLE_3GMODULE  stu3GModuleInfo[DH_MAX_SIM_NUM];        // 3G模块相关信息
}DHDEV_VEHICLE_INFO;

// 网络接口,最大支持DH_MAX_NETINTERFACE_NUM个网卡
typedef struct tagDHDEV_NETINTERFACE_INFO
{
    int             dwSize;
    BOOL            bValid;                                         // 是否有效
    BOOL            bVirtual;                                       // 是否虚拟网卡
    int             nSpeed;                                         // 网卡理论速度(Mbps)
    int             nDHCPState;                                     // 0-未使能, 1-正在获取, 2-获取成功
    char            szName[DH_NETINTERFACE_NAME_LEN];               // 网口名称
    char            szType[DH_NETINTERFACE_TYPE_LEN];               // 网络类型
    char            szMAC[DH_MACADDR_LEN];                          // MAC地址
    char            szSSID[DH_MAX_SSID_LEN];                        // SSID, 只对无线网络有效(szType == "Wireless")
    char            szConnStatus[DH_MAX_CONNECT_STATUS_LEN];        // Wifi、3G的连接状态,"Inexistence" : 网络不存在 "Down"：关闭 "Disconn"：未连接 "Connecting"：正连接 "Connected"： 已连接
    int             nSupportedModeNum;                              // 实际3G支持的网络模式个数
    char            szSupportedModes[DH_MAX_MODE_NUM][DH_MAX_MODE_LEN];// 3G支持的网络模式    "TD-SCDMA", "WCDMA", "CDMA1x", "EDGE", "EVDO"
	
	BOOL            bSupportLongPoE;                                // 是否支持长距离POE速度协商，需要网卡和交换机协商后才能确定
	char			szNetCardName[8];								// 真实网卡名
} DHDEV_NETINTERFACE_INFO;

//-----------------------------图像通道属性-------------------------------

// 区域；各边距按整长8192的比例
typedef struct 
{
   long             left;
   long             top;
   long             right;
   long             bottom;
} DH_RECT, *LPDH_RECT;

typedef struct tagNET_RECT
{
    int             nLeft;
    int             nTop;
    int             nRight;
    int             nBottom;
} NET_RECT;

// 二维空间点
typedef struct 
{
   short            nx;
   short            ny;
} DH_POINT, *LPDH_POINT, NET_POINT, *LPNET_POINT;

// 区域或曲线顶点信息
typedef struct
{
    int        nPointNum;                               // 顶点数
    DH_POINT   stuPoints[DH_MAX_DETECT_REGION_NUM];     // 顶点信息
}DH_POLY_POINTS;

// OSD属性结构
typedef struct  tagENCODE_WIDGET
{
    DWORD               rgbaFrontground;                // 物件的前景；按字节表示,分别为红、绿、蓝和透明度
    DWORD               rgbaBackground;                 // 物件的背景；按字节表示,分别为红、绿、蓝和透明度
    DH_RECT             rcRect;                         // 位置
    BYTE                bShow;                          // 显示使能
    BYTE                bExtFuncMask;                   // 扩展使能 ,掩码 
                                                        // bit0 表示是否显示星期几,0-不显示 1-显示 
    BYTE                byReserved[2];
} DH_ENCODE_WIDGET, *LPDH_ENCODE_WIDGET;

// 通道音视频属性
typedef struct 
{
    // 视频参数
    BYTE                byVideoEnable;                  // 视频使能；1：打开,0：关闭
    BYTE                byBitRateControl;               // 码流控制；参照常量"码流控制"定义
    BYTE                byFramesPerSec;                 // 帧率
    BYTE                byEncodeMode;                   // 编码模式；参照常量"编码模式"定义
    BYTE                byImageSize;                    // 分辨率；参照常量"分辨率"定义
    BYTE                byImageQlty:7;                  // 将byImageQlty进行扩展,若byImageQlty为0,抓图配置的ImgQlty为10/30/50/60/80/100六个值,码流配置的ImgQlty值为1-6,兼容之前的1-6档次,若//ImgQltyType为1,则ImgQlty范围为0~100
    BYTE                byImageQltyType:1;       
    WORD                wLimitStream;                   // 限码流参数
    // 音频参数
    BYTE                byAudioEnable;                  // 音频使能；1：打开,0：关闭
    BYTE                wFormatTag;                     // 音频编码类型: 0:G711A,1:PCM,2:G711U,3:AMR,4:AAC
    WORD                nChannels;                      // 声道数
    WORD                wBitsPerSample;                 // 采样深度    
    BYTE                bAudioOverlay;                  // 音频叠加使能
    BYTE                bH264ProfileRank;               // H.264 Profile等级(当编码模式为H264时此参数值有效),参照枚举类型EM_H264_PROFILE_RANK,传0,兼容以前,表示该字段无效,不需要考虑级别。
    DWORD               nSamplesPerSec;                 // 采样率
    BYTE                bIFrameInterval;                // I帧间隔帧数量,描述两个I帧之间的P帧个数,0-149
    BYTE                bScanMode;                      // NSP
    BYTE                bReserved_3;
    BYTE                bReserved_4;
} DH_VIDEOENC_OPT, *LPDH_VIDEOENC_OPT;

// 画面颜色属性
typedef struct 
{
    DH_TSECT            stSect;
    BYTE                byBrightness;                   // 亮度；0-100
    BYTE                byContrast;                     // 对比度；0-100
    BYTE                bySaturation;                   // 饱和度；0-100
    BYTE                byHue;                          // 色度；0-100
    BYTE                byGainEn;                       // 增益使能
    BYTE                byGain;                         // 增益；0-100
    BYTE                byGamma;                        // 伽马值 0-100
    BYTE                byReserved[1];
} DH_COLOR_CFG, *LPDH_COLOR_CFG;

// 图像通道属性结构体
typedef struct 
{
    WORD                dwSize;
    BYTE                bNoise;
    BYTE                bMode;                          // (车载特殊需求)模式一(画质优先):录像分辨率采用4路D1,帧率2fps,码率128kbps(每小时225MB)
                                                        // 模式二(流畅优先):录像分辨率采用4路CIF,帧率12fps,码率256kbps(每小时550MB)
                                                        // 模式三(自定义)录像分辨率可以由用户自定义,限定最大能力为4CIF/25fps
    char                szChannelName[DH_CHAN_NAME_LEN];
    DH_VIDEOENC_OPT     stMainVideoEncOpt[DH_REC_TYPE_NUM];
    DH_VIDEOENC_OPT     stAssiVideoEncOpt[DH_N_ENCODE_AUX];        
    DH_COLOR_CFG        stColorCfg[DH_N_COL_TSECT];
    DH_ENCODE_WIDGET    stTimeOSD;
    DH_ENCODE_WIDGET    stChannelOSD;
    DH_ENCODE_WIDGET    stBlindCover[DH_N_COVERS];      // 单区域遮挡
    BYTE                byBlindEnable;                  // 区域遮盖开关；0x00：不使能遮盖,0x01：仅遮盖设备本地预览,0x10：仅遮盖录像及网络预览,0x11：都遮盖
    BYTE                byBlindMask;                    // 区域遮盖掩码；第一位：设备本地预览；第二位：录像(及网络预览) */
    BYTE                bVolume;                        // 音量阀值(0~100可调)
    BYTE                bVolumeEnable;                  // 音量阀值使能
} DHDEV_CHANNEL_CFG, *LPDHDEV_CHANNEL_CFG;

// 预览图像参数
typedef struct 
{
    DWORD               dwSize;
    DH_VIDEOENC_OPT     stPreView;
    DH_COLOR_CFG        stColorCfg[DH_N_COL_TSECT];
}DHDEV_PREVIEW_CFG;

// 抓图控制配置
typedef struct _config_snap_control
{
    BYTE                bySnapState[32];                // 每个通道对应抓图开关 0:自动(则表示是否抓图,由其他配置和事件控制); 1:抓图开启; 2:抓图关闭
    BYTE                byReserved[480];
}DHDEV_SNAP_CONTROL_CFG;

enum _gps_mode
{
    GPS_OR_GLONASS_MODE,            // GPS、GLONASS混合模式(模块定位数据从GPS、GLONASS两者中获取,但具体来源于哪个系统不能确定,可能模块内部自动会处理)
    GLONASS_MODE,                   // GLONASS模式(即模块的定位数据从俄罗斯的GLONASS定位系统中获取)
    GPS_MODE,                       // GPS模式(即模块的定位数据从美国的GPS系统中获取) 
};
// DH_DEV_GPS_MODE_CFG 配置结构
typedef struct tagDHDEV_GPS_MODE_CFG
{
    BYTE                byGPSMode;                      // GPS定位模式,见
    BYTE                byRev[255];
}DHDEV_GPS_MODE_CFG;

// 图片上传配置信息 DH_DEV_SNAP_UPLOAD_CFG 配置结构
typedef struct tagDHDEV_SNAP_UPLOAD_CFG
{
    int                 nUploadInterval;                //定时抓图图片上传间隔,单位秒
    BYTE                byReserved[252];    
}DHDEV_SNAP_UPLOAD_CFG;


// DHDEV_SPEED_LIMIT_CFG 配置结构
typedef struct tagDHDEV_SPEED_LIMIT_CFG
{
    BYTE                byEnable;                       // 限速使能1：使能；0：不使能。
    BYTE                byReserved1;                    // 保留字段
    WORD                wMaxSpeed;                      // 速度上限值：单位KM/H 0表示不限速,大于0表示限速
    WORD                wMinSpeed;                      // 速度下限值：单位KM/H 0表示不限速,大于0表示限速
    BYTE                byReserved2[122];               // 保留字段
}DHDEV_SPEED_LIMIT_CFG;

// 无线路由配置
typedef struct
{
    BOOL                bEnable;                        // 使能
    char                szSSID[36];                     // SSID名称
    BOOL                bHideSSID;                      // 是否隐藏SSID
    char                szIP[DH_MAX_IPADDR_LEN];        // IP
    char                szSubMark[DH_MAX_IPADDR_LEN];   // 子网掩码
    char                szGateWay[DH_MAX_IPADDR_LEN];   // 网关
    char                szCountry[32];                  // 国家, Default默认不指定。国家名称列表参考无线路由能力信息
    int                 nSafeType;                      // 鉴权模式: 1-不加密; 2-WEP模式; 2-WPA-PSK模式; 3-WPA2-PSK模式
    int                 nEncryption;                    // 加密方式: WEP模式(1-自动 2-开放 3-共享); WPA-PSK模式/WPA2-PSK模式(4-TKIP 5-AES)
    char                szKey[32];                      // 连接密钥
    int                 nChannel;                       // 信道, 有效信道列表参考无线路由能力信息
    BOOL                bAutoChannelSelect;             // 自动选择信道    
}DHDEV_WIRELESS_ROUTING_CFG;

//-------------------------------串口属性---------------------------------

// 串口基本属性
typedef struct
{
    BYTE                byDataBit;                      // 数据位；0：5,1：6,2：7,3：8
    BYTE                byStopBit;                      // 停止位；0：1位,1：1.5位,2：2位
    BYTE                byParity;                       // 校验位；0：无校验,1：奇校验；2：偶校验; 3:标志校验; 4:空校验
    BYTE                byBaudRate;                     // 波特率；0：300,1：600,2：1200,3：2400,4：4800,
                                                        // 5：9600,6：19200,7：38400,8：57600,9：115200
} DH_COMM_PROP;

// 485解码器配置
typedef struct
{ 
    DH_COMM_PROP        struComm;
    BYTE                wProtocol;                      // 协议类型,对应"协议名列表"下标
    BYTE                bPTZType;                       // 0-兼容,本地云台 1-远程网络云台,通过能力查询(见DEV_ENCODER_CFG)。
    BYTE                wDecoderAddress;                // 解码器地址；0 - 255
    BYTE                byMartixID;                     // 矩阵号
} DH_485_CFG;

// 232串口配置
typedef struct
{
    DH_COMM_PROP        struComm;
    BYTE                byFunction;                     // 串口功能,对应"功能名列表"下标
    BYTE                byReserved[3];
} DH_RS232_CFG;

// 串口配置结构体
typedef struct
{
    DWORD               dwSize;

    DWORD               dwDecProListNum;                                        // 解码器协议个数
    char                DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];   // 协议名列表
    DH_485_CFG          stDecoder[DH_MAX_DECODER_NUM];                          // 各解码器当前属性

    DWORD               dw232FuncNameNum;                                       // 232功能个数
    char                s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];         // 功能名列表
    DH_RS232_CFG        st232[DH_MAX_232_NUM];                                  // 各232串口当前属性
} DHDEV_COMM_CFG;

// 扩展串口配置结构体
typedef struct
{
    DWORD               dwSize;
    
    DWORD               dwDecProListNum;                                        // 解码器协议个数
    char                DecProName[DH_MAX_DECPRO_LIST_SIZE][DH_MAX_NAME_LEN];   // 协议名列表
    DH_485_CFG          stDecoder[DH_MAX_DECODER_NUM];                          // 各解码器当前属性
    
    DWORD               dw232FuncNameNum;                                       // 232功能个数
    char                s232FuncName[DH_MAX_232FUNCS][DH_MAX_NAME_LEN];         // 功能名列表
    DWORD               dw232ComNum;                                            // 232串口个数   
    DH_RS232_CFG        st232[DH_MAX_232_NUM_EX];                               // 各232串口当前属性
} DHDEV_COMM_CFG_EX;

// 串口状态
typedef struct
{
    unsigned int        uBeOpened;
    unsigned int        uBaudRate;
    unsigned int        uDataBites;
    unsigned int        uStopBits;
    unsigned int        uParity;
    BYTE                bReserved[32];
} DH_COMM_STATE;

//-------------------------------录象配置---------------------------------

// 定时录象
typedef struct 
{
    DWORD               dwSize;
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    BYTE                byPreRecordLen;                     // 预录时间,单位是s,0表示不预录
    BYTE                byRedundancyEn;                     // 录像冗余开关
    BYTE                byRecordType;                       // 录像码流类型：0-主码流 1-辅码流1 2-辅码流2 3-辅码流3
    BYTE                byReserved;
} DHDEV_RECORD_CFG, *LPDH_RECORD_CFG;

// NTP配置
typedef struct  
{
    BOOL                bEnable;                            // 是否启用
    int                 nHostPort;                          // NTP服务器默认端口为123
    char                szHostIp[32];                       // 主机IP
    char                szDomainName[128];                  // 域名
    int                 nType;                              // 不可设置,0：表示IP,1：表示域名,2：表示IP和域名
    int                 nUpdateInterval;                    // 更新时间(分钟)
    int                 nTimeZone;                          // 见DH_TIME_ZONE_TYPE
    char                reserved[128];
} DHDEV_NTP_CFG;

// FTP上传配置
typedef struct
{
    struct
    {
        DH_TSECT        struSect;                           // 该时间段内的“使能”无效,可忽略
        BOOL            bMdEn;                              // 上传动态检测录象
        BOOL            bAlarmEn;                           // 上传外部报警录象
        BOOL            bTimerEn;                           // 上传普通定时录像
        DWORD           dwRev[4];
    } struPeriod[DH_TIME_SECTION];
} DH_FTP_UPLOAD_CFG;

typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;                            // 是否启用
    char                szHostIp[DH_MAX_IPADDR_LEN];        // 主机IP
    WORD                wHostPort;                          // 主机端口
    char                szDirName[DH_FTP_MAX_PATH];         // FTP目录路径
    char                szUserName[DH_FTP_USERNAME_LEN];    // 用户名
    char                szPassword[DH_FTP_PASSWORD_LEN];    // 密码
    int                 iFileLen;                           // 文件长度
    int                 iInterval;                          // 相邻文件时间间隔(1~600),单位秒 
    DH_FTP_UPLOAD_CFG   struUploadCfg[DH_MAX_CHANNUM][DH_N_WEEKS];
    char                protocol;                           // 0-FTP 1-SMB 2-NFS,3-ISCSI
    char                NASVer;                             // 网络存储服务器版本0=老的FTP(界面上显示时间段),1=NAS存储(界面上屏蔽时间段)
    DWORD               dwFunctionMask;                     // 功能能力掩码,按位表示,低16位(网络存储)依次表示FTP,SMB,NFS,ISCSI, 高16位(本地存储)依次为DISK,U
    BYTE                bDataType;                          // 数据类型, 0-所有类型, 1-视频, 2-图片
    BYTE                reserved[123];
} DHDEV_FTP_PROTO_CFG;

// FTP上传扩展配置(支持通道独立设置FTP存储路径,最大存储图片数等)
typedef struct 
{
    int            nMaxPictures;                             // 总存储张数,每一个通道文件夹中的图片数量可以限制,
                                                             // 超过限制就覆盖老的文件,0:表示不限制,写满为止
    char           szPreChannelName[DH_FTP_MAX_SUB_PATH];    // 图片文件名
    char           szFTPChannelPath[DH_FTP_MAX_SUB_PATH];    // ftp存储路径(存储子目录)
    char           szRev[128];                               // 保留字段
}DHDEV_FTP_CHANNEL_CFG; 


typedef struct 
{ 
    DHDEV_FTP_PROTO_CFG       stuFtpNormalSet;                     // FTP原有功能,扩展通道数
    DHDEV_FTP_CHANNEL_CFG     stuFtpChannelSet[DH_MAX_CHANNUM];    // FTP扩展功能
    char                      szRev[128];                          // 保留字段
}DHDEV_FTP_PROTO_CFG_EX;

//-------------------------------网络配置---------------------------------

// 以太网配置
typedef struct 
{
    char                sDevIPAddr[DH_MAX_IPADDR_LEN];      // DVR IP 地址
    char                sDevIPMask[DH_MAX_IPADDR_LEN];      // DVR IP 地址掩码
    char                sGatewayIP[DH_MAX_IPADDR_LEN];      // 网关地址

    /*
     * 1：10Mbps 全双工
     * 2：10Mbps 自适应
     * 3：10Mbps 半双工
     * 4：100Mbps 全双工
     * 5：100Mbps 自适应
     * 6：100Mbps 半双工
     * 7：自适应
     */
    // 为了扩展将DWORD拆成四个
    BYTE                dwNetInterface;                     // NSP
    BYTE                bTranMedia;                         // 0：有线,1：无线
    BYTE                bValid;                             // 按位表示,第一位：1：有效 0：无效；第二位：0：DHCP关闭 1：DHCP使能；第三位：0：不支持DHCP 1：支持DHCP
    BYTE                bDefaultEth;                        // 是否作为默认的网卡 1：默认 0：非默认
    char                byMACAddr[DH_MACADDR_LEN];          // MAC地址,只读
} DH_ETHERNET; 

// 远程主机配置
typedef struct 
{
    BYTE                byEnable;                           // 连接使能
    BYTE                byAssistant;                        // 目前只对于PPPoE服务器有用,0：在有线网卡拨号；1：在无线网卡上拨号
    WORD                wHostPort;                          // 远程主机 端口
    char                sHostIPAddr[DH_MAX_IPADDR_LEN];     // 远程主机 IP 地址        
    char                sHostUser[DH_MAX_HOST_NAMELEN];     // 远程主机 用户名
    char                sHostPassword[DH_MAX_HOST_PSWLEN];  // 远程主机 密码
} DH_REMOTE_HOST;

// 邮件配置
typedef struct 
{
    char                sMailIPAddr[DH_MAX_IPADDR_LEN];     // 邮件服务器IP地址
    WORD                wMailPort;                          // 邮件服务器端口
    WORD                wReserved;                          // 保留
    char                sSenderAddr[DH_MAX_MAIL_ADDR_LEN];  // 发送地址
    char                sUserName[DH_MAX_NAME_LEN];         // 用户名
    char                sUserPsw[DH_MAX_NAME_LEN];          // 用户密码
    char                sDestAddr[DH_MAX_MAIL_ADDR_LEN];    // 目的地址
    char                sCcAddr[DH_MAX_MAIL_ADDR_LEN];      // 抄送地址
    char                sBccAddr[DH_MAX_MAIL_ADDR_LEN];     // 暗抄地址
    char                sSubject[DH_MAX_MAIL_SUBJECT_LEN];  // 标题
} DH_MAIL_CFG;

// 网络配置结构体
typedef struct
{ 
    DWORD               dwSize; 
    char                sDevName[DH_MAX_NAME_LEN];          // 设备主机名
    WORD                wTcpMaxConnectNum;                  // TCP最大连接数
    WORD                wTcpPort;                           // TCP帧听端口
    WORD                wUdpPort;                           // UDP侦听端口
    WORD                wHttpPort;                          // HTTP端口号
    WORD                wHttpsPort;                         // HTTPS端口号
    WORD                wSslPort;                           // SSL端口号
    DH_ETHERNET         stEtherNet[DH_MAX_ETHERNET_NUM];    // 以太网口
    DH_REMOTE_HOST      struAlarmHost;                      // 报警服务器
    DH_REMOTE_HOST      struLogHost;                        // 日志服务器
    DH_REMOTE_HOST      struSmtpHost;                       // SMTP服务器
    DH_REMOTE_HOST      struMultiCast;                      // 多播组
    DH_REMOTE_HOST      struNfs;                            // NFS服务器
    DH_REMOTE_HOST      struPppoe;                          // PPPoE服务器
    char                sPppoeIP[DH_MAX_IPADDR_LEN];        // PPPoE注册返回的IP
    DH_REMOTE_HOST      struDdns;                           // DDNS服务器
    char                sDdnsHostName[DH_MAX_HOST_NAMELEN]; // DDNS主机名
    DH_REMOTE_HOST      struDns;                            // DNS服务器
    DH_MAIL_CFG         struMail;                           // 邮件配置
} DHDEV_NET_CFG;

// 以太网扩展配置
typedef struct 
{
	char                sDevIPAddr[DH_MAX_IPADDR_LEN];      // DVR IP 地址
	char                sDevIPMask[DH_MAX_IPADDR_LEN];      // DVR IP 地址掩码
	char                sGatewayIP[DH_MAX_IPADDR_LEN];      // 网关地址

	/*
	* 1：10Mbps 全双工
	* 2：10Mbps 自适应
	* 3：10Mbps 半双工
	* 4：100Mbps 全双工
	* 5：100Mbps 自适应
	* 6：100Mbps 半双工
	* 7：自适应
	*/
	// 为了扩展将DWORD拆成四个
	BYTE                dwNetInterface;                     // NSP
	BYTE                bTranMedia;                         // 0：有线,1：无线
	BYTE                bValid;                             // 按位表示,第一位：1：有效 0：无效；第二位：0：DHCP关闭 1：DHCP使能；第三位：0：不支持DHCP 1：支持DHCP
	BYTE                bDefaultEth;                        // 是否作为默认的网卡 1：默认 0：非默认
	char                byMACAddr[DH_MACADDR_LEN];          // MAC地址,只读
	BYTE                bMode;                              // 网卡所处模式, 0:绑定模式, 1:负载均衡模式, 2:多址模式, 3:容错模式
	BYTE                bReserved1[3];                      // 字节对齐
	char                szEthernetName[DH_MAX_NAME_LEN];    // 网卡名,只读
	BYTE                bReserved[12];                      // 保留字节   
} DH_ETHERNET_EX; 

// 扩展网络配置结构体
typedef struct
{ 
	DWORD               dwSize; 
    char                sDevName[DH_MAX_NAME_LEN];          // 设备主机名
    WORD                wTcpMaxConnectNum;                  // TCP最大连接数
    WORD                wTcpPort;                           // TCP帧听端口
    WORD                wUdpPort;                           // UDP侦听端口
    WORD                wHttpPort;                          // HTTP端口号
    WORD                wHttpsPort;                         // HTTPS端口号
    WORD                wSslPort;                           // SSL端口号
    int                 nEtherNetNum;                       // 以太网口数
    DH_ETHERNET_EX      stEtherNet[DH_MAX_ETHERNET_NUM_EX]; // 以太网口
    DH_REMOTE_HOST      struAlarmHost;                      // 报警服务器
    DH_REMOTE_HOST      struLogHost;                        // 日志服务器
    DH_REMOTE_HOST      struSmtpHost;                       // SMTP服务器
    DH_REMOTE_HOST      struMultiCast;                      // 多播组
    DH_REMOTE_HOST      struNfs;                            // NFS服务器
    DH_REMOTE_HOST      struPppoe;                          // PPPoE服务器
    char                sPppoeIP[DH_MAX_IPADDR_LEN];        // PPPoE注册返回的IP
    DH_REMOTE_HOST      struDdns;                           // DDNS服务器
    char                sDdnsHostName[DH_MAX_HOST_NAMELEN]; // DDNS主机名
    DH_REMOTE_HOST      struDns;                            // DNS服务器
    DH_MAIL_CFG         struMail;                           // 邮件配置
    BYTE                bReserved[128];                     // 保留字节
} DHDEV_NET_CFG_EX;

typedef struct tagDEV_IPV4_CFG
{
	DWORD				dwSize;								// 结构体大小
	char                szDevName[DH_MAX_NAME_LEN];         // 设备主机名
	WORD                wTcpMaxConnectNum;                  // TCP最大连接数
	WORD                wTcpPort;                           // TCP帧听端口
	WORD                wUdpPort;                           // UDP侦听端口
	WORD                wHttpPort;                          // HTTP端口号
	WORD                wHttpsPort;                         // HTTPS端口号
	WORD                wSslPort;                           // SSL端口号	
	DH_ETHERNET_EX      stuEtherNet[DH_MAX_ETHERNET_NUM_EX];// 以太网口
	int					nEtherNetNum;						// stuEtherNet 个数
}DEV_IPV4_CFG;

// 多ddns配置结构体
typedef struct
{
    DWORD               dwId;                                           // ddns服务器id号
    BOOL                bEnable;                                        // 使能,同一时间只能有一个ddns服务器处于使能状态
    char                szServerType[DH_MAX_SERVER_TYPE_LEN];           // 服务器类型,希网..
    char                szServerIp[DH_MAX_DOMAIN_NAME_LEN];             // 服务器ip或者域名
    DWORD               dwServerPort;                                   // 服务器端口
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];           // dvr域名,如jeckean.3322.org
    char                szUserName[DH_MAX_HOST_NAMELEN];                // 用户名
    char                szUserPsw[DH_MAX_HOST_PSWLEN];                  // 密码
    char                szAlias[DH_MAX_DDNS_ALIAS_LEN];                 // 服务器别名
    DWORD               dwAlivePeriod;                                  // DDNS 保活时间
    BYTE                ByMode;                                         // 域名模式:0-手动输入域名,szDomainName有效; 1-默认域名szDefaultDomainName有效。
    char                szDefaultDomainName[DH_MAX_DEFAULT_DOMAIN_LEN]; // 默认域名,只读
    BYTE                bReserved[3];                                   // 字节对齐
    char                szEmailUserName[DH_MAX_MAIL_NAME_LEN];          // 邮箱用户名
    char                reserved[128];
} DH_DDNS_SERVER_CFG;

typedef struct
{
    DWORD                dwSize;
    DWORD                dwDdnsServerNum;    
    DH_DDNS_SERVER_CFG   struDdnsServer[DH_MAX_DDNS_NUM];    
} DHDEV_MULTI_DDNS_CFG;

// 邮件配置结构体
typedef struct 
{
    char                sMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];    // 邮件服务器地址(IP或者域名)
    char                sSubMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];
    WORD                wMailPort;                              // 邮件服务器端口
    WORD                wSubMailPort;
    WORD                wReserved;                              // 保留
    char                sSenderAddr[DH_MAX_MAIL_ADDR_LEN];      // 发送地址
    char                sUserName[DH_MAX_MAIL_NAME_LEN];        // 用户名
    char                sUserPsw[DH_MAX_MAIL_NAME_LEN];         // 用户密码
    char                sDestAddr[DH_MAX_MAIL_ADDR_LEN];        // 目的地址
    char                sCcAddr[DH_MAX_MAIL_ADDR_LEN];          // 抄送地址
    char                sBccAddr[DH_MAX_MAIL_ADDR_LEN];         // 暗抄地址
    char                sSubject[DH_MAX_MAIL_SUBJECT_LEN];      // 标题
    BYTE                bEnable;                                // 使能0:false,    1:true
    BYTE                bSSLEnable;                             // SSL使能
    WORD                wSendInterval;                          // 发送时间间隔,[0,3600]秒
    BYTE                bAnonymous;                             // 匿名选项[0,1], 0表示FALSE,1表示TRUE.
    BYTE                bAttachEnable;                          // 附件使能[0,1], 0表示FALSE,1表示TRUE.
    char                reserved[154];
} DHDEV_MAIL_CFG;

// DNS服务器配置
typedef struct  
{
    char                szPrimaryIp[DH_MAX_IPADDR_LEN];
    char                szSecondaryIp[DH_MAX_IPADDR_LEN];
    char                reserved[256];
} DHDEV_DNS_CFG;

// 录象下载策略配置
typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;                                // TRUE：高速下载,FALSE：普通下载
}DHDEV_DOWNLOAD_STRATEGY_CFG;

// 网络传输策略配置
typedef struct
{
    DWORD               dwSize;
    BOOL                bEnable;
    int                 iStrategy;                              // 0：画质优先,1：流畅性优先,2：自动
}DHDEV_TRANSFER_STRATEGY_CFG;

// 设置登入时的相关参数
typedef struct  
{
    int                 nWaittime;                              // 等待超时时间(毫秒为单位),为0默认5000ms
    int                 nConnectTime;                           // 连接超时时间(毫秒为单位),为0默认1500ms
    int                 nConnectTryNum;                         // 连接尝试次数,为0默认1次
    int                 nSubConnectSpaceTime;                   // 子连接之间的等待时间(毫秒为单位),为0默认10ms
    int                 nGetDevInfoTime;                        // 获取设备信息超时时间,为0默认1000ms
    int                 nConnectBufSize;                        // 每个连接接收数据缓冲大小(字节为单位),为0默认250*1024
    int                 nGetConnInfoTime;                       // 获取子连接信息超时时间(毫秒为单位),为0默认1000ms
    int                 nSearchRecordTime;                      // 按时间查询录像文件的超时时间(毫秒为单位),为0默认为3000ms
    int                 nsubDisconnetTime;                      // 检测子链接断线等待时间(毫秒为单位),为0默认为60000ms
    BYTE                byNetType;                              // 网络类型, 0-LAN, 1-WAN
    BYTE                byPlaybackBufSize;                      // 回放数据接收缓冲大小（M为单位）,为0默认为4M
    BYTE                bDetectDisconnTime;                     // 心跳检测断线时间(单位为秒),为0默认为60s,最小时间为2s
    BYTE                bKeepLifeInterval;                      // 心跳包发送间隔(单位为秒),为0默认为10s,最小间隔为2s
    int                 nPicBufSize;                            // 实时图片接收缓冲大小（字节为单位）,为0默认为2*1024*1024
    BYTE                bReserved[4];                           // 保留字段字段
} NET_PARAM;

// UDP和组播参数
typedef struct tagNET_UDP_OPTION
{
   unsigned int nPacketArriveTimeout;           // 等待乱序包到达超时时间, 单位为ms, 默认为50ms, 最大值为200ms, 为0表示不更改当前值
   unsigned int nRetransmitPacketArriveTimeout; // 等待重传包的超时时间,        单位为ms, 默认为100ms, 最大值为400ms, 为0表示不更改当前值
   unsigned int nMaxLostNumOfMulitcastSeqNo;    // 最大的可接受的组播丢包个数, 默认为1000, 最大值为2000, 为0表示不更改当前值
   unsigned int nMaxWaitNumOfUdpSeqNo;          // 最大的等待UDP乱序到达的包个数, 默认为30, 最大值为1000, 为0表示不更改当前值
   unsigned int nMultiSocketSendBufferSize;     // 组播套接字发送缓存大小, 单位：Byte, 默认64K, 最小8K, 最大1M, 为0表示不更改当前值
   unsigned int nMultiSocketRecvBufferSize;     // 组播套接字接受缓存大小, 单位：Byte, 默认1M, 最小8K, 最大1M, 为0表示不更改当前值
   unsigned int nUdpSocketSendBufferSize;       // UDP套接字发送缓存大小, 单位：Byte, 默认64K, 最小8K, 最大1M, 为0表示不更改当前值
   unsigned int nUdpSocketRecvBufferSize;       // UDP套接字接受缓存大小, 单位：Byte, 默认1M, 最小8K, 最大1M, 为0表示不更改当前值
   BYTE bReserved[128];                         // 保留字段字段
}NET_UDP_OPTION;

// 对应CLIENT_SearchDevices接口
typedef struct 
{
    char                szIP[DH_MAX_IPADDR_LEN];                // IP
    int                 nPort;                                  // tcp端口
    char                szSubmask[DH_MAX_IPADDR_LEN];           // 子网掩码
    char                szGateway[DH_MAX_IPADDR_LEN];           // 网关
    char                szMac[DH_MACADDR_LEN];                  // MAC地址
    char                szDeviceType[DH_DEV_TYPE_LEN];          // 设备类型
    BYTE                byManuFactory;                          // 目标设备的生产厂商,具体参考EM_IPC_TYPE类
    BYTE                byIPVersion;                            // 4: IPv4, szXXX为点分字符串形式;  6:IPv6, szXXX为128位(16字节)数值形式
	BYTE				byInitStatus;							// 设备初始化状态，按位确定初始化状态
																// bit0~1：0-老设备，没有初始化功能 1-未初始化账号 2-已初始化账户
																// bit2~3：0-老设备，保留 1-公网接入未使能 2-公网接入已使能
																// bit4~5：0-老设备，保留 1-手机直连未使能 2-手机直连使能
	
	BYTE				byPwdResetWay;							// 支持密码重置方式：按位确定密码重置方式，只在设备有初始化账号时有意义															
																// bit0-支持预置手机号 bit1-支持预置邮箱 bit2-支持文件导出
	BYTE				bySpecialAbility;						// 设备初始化能力，按位确定初始化状态,bit0-2D Code修改IP: 0 不支持 1 支持,bit1-PN制:0 不支持 1 支持
    BYTE                bReserved[27];                          // 保留字节
} DEVICE_NET_INFO;

#define DH_DEV_CUSTOM_DEVICEID_LEN               24				// 定制ID长度

// 对应CLIENT_StartSearchDevices接口
typedef struct 
{
    int                 iIPVersion;                             // 4 for IPV4, 6 for IPV6
    char                szIP[64];                               // IP IPV4形如"192.168.0.1" IPV6形如"2008::1/64"
    int                 nPort;                                  // tcp端口
    char                szSubmask[64];                          // 子网掩码 IPV6无子网掩码
    char                szGateway[64];                          // 网关
    char                szMac[DH_MACADDR_LEN];                  // MAC地址
    char                szDeviceType[DH_DEV_TYPE_LEN];          // 设备类型
    BYTE                byManuFactory;                          // 目标设备的生产厂商,具体参考EM_IPC_TYPE类    
    BYTE                byDefinition;                           // 1-标清 2-高清
    bool                bDhcpEn;                                // Dhcp使能状态, true-开, false-关
    BYTE                byReserved1;                            // 字节对齐
    char                verifyData[88];                         // 校验数据 通过异步搜索回调获取(在修改设备IP时会用此信息进行校验)
    char                szSerialNo[DH_DEV_SERIALNO_LEN];        // 序列号
    char                szDevSoftVersion[DH_MAX_URL_LEN];       // 设备软件版本号    
    char                szDetailType[DH_DEV_TYPE_LEN];          // 设备型号
    char                szVendor[DH_MAX_STRING_LEN];            // OEM客户类型
    char                szDevName[DH_MACHINE_NAME_NUM];         // 设备名称
    char                szUserName[DH_USER_NAME_LENGTH_EX];     // 登陆设备用户名（在修改设备IP时需要填写）
    char                szPassWord[DH_USER_NAME_LENGTH_EX];     // 登陆设备密码（在修改设备IP时需要填写）
    unsigned short      nHttpPort;                              // HTTP服务端口号
    WORD                wVideoInputCh;                          // 视频输入通道数
    WORD                wRemoteVideoInputCh;                    // 远程视频输入通道数
    WORD                wVideoOutputCh;                         // 视频输出通道数
    WORD                wAlarmInputCh;                          // 报警输入通道数
    WORD                wAlarmOutputCh;                         // 报警输出通道数）
    BOOL                bNewWordLen;                            // TRUE使用新密码字段szNewPassWord
    char                szNewPassWord[DH_COMMON_STRING_64];     // 登陆设备密码（在修改设备IP时需要填写）
    BYTE                byInitStatus;                           // 设备初始化状态，按位确定初始化状态
                                                                // bit0~1：0-老设备，没有初始化功能 1-未初始化账号 2-已初始化账户
                                                                // bit2~3：0-老设备，保留 1-公网接入未使能 2-公网接入已使能
                                                                // bit4~5：0-老设备，保留 1-手机直连未使能 2-手机直连使能
                                                                // bit6~7: 0- 未知 1-不支持密码重置 2-支持密码重置

    BYTE                byPwdResetWay;                          // 支持密码重置方式：按位确定密码重置方式，只在设备有初始化账号时有意义															
                                                                // bit0-支持预置手机号 bit1-支持预置邮箱 bit2-支持文件导出 bit3-支持密保问题 bit4-支持更换手机号
    BYTE                bySpecialAbility;                       // 设备初始化能力，按位确定初始化能力,高八位 bit0-2D Code修改IP: 0 不支持 1 支持, bit1-PN制:0 不支持 1支持

    char                szNewDetailType[DH_COMMON_STRING_64];   // 设备型号 
    BOOL                bNewUserName;               // TRUE表示使用新用户名(szNewUserName)字段
    char                szNewUserName[DH_COMMON_STRING_64];     // 登陆设备用户名（在修改设备IP时需要填写）
    BYTE                byPwdFindVersion;                       // 密码找回的版本号,设备支持密码重置时有效;
                                                                // 0-设备使用的是老方案的密码重置版本;1-支持预留联系方式进行密码重置操作;
                                                                // 2-支持更换联系方式进行密码重置操作;
    char                szDeviceID[DH_DEV_CUSTOM_DEVICEID_LEN]; // 定制字段, 不作为通用协议，不对接通用客户端
    DWORD               dwUnLoginFuncMask;                      // 未登陆功能掩码, Bit0 Wifi列表扫描及WLan设置
    char                cReserved[12];                          // 扩展字段
}DEVICE_NET_INFO_EX;

// 对应CLIENT_StartSearchDevicesEx接口
typedef struct 
{
    DEVICE_NET_INFO_EX  stuDevInfo;                             // 设备信息结构体						
    char                szLocalIP[MAX_LOCAL_IP_LEN];            // 搜索到设备的本地IP地址
    char                cReserved[2048];                        // 扩展字段
}DEVICE_NET_INFO_EX2;

// 对应CLIENT_SearchDevicesByIPs接口
typedef struct
{
    DWORD               dwSize;                                 // 结构体大小
    int                 nIpNum;                                 // 当前搜索的IP个数
    char                szIP[DH_MAX_SAERCH_IP_NUM][64];         // 具体待搜索的IP信息	
}DEVICE_IP_SEARCH_INFO;

// 设备搜索参数
typedef struct tagNET_DEVICE_SEARCH_PARAM
{
    DWORD       dwSize;						// 结构体大小
    BOOL        bUseDefault;				// 是否使用默认配置,默认为TRUE
    WORD        wBroadcastLocalPort;		// 广播本地端口, 默认5050, 值为0时使用最近一次配置
    WORD        wBroadcastRemotePort;		// 广播远程端口, 默认5050, 值为0时使用最近一次配置
    WORD        wMulticastRemotePort;		// 组播远程端口, 默认37810, 值为0时使用最近一次配置
    BOOL        bMulticastModifyRespond;	// 组播修改设备时是否只支持组播回复,默认FALSE表示单播或组播回复
	WORD        wMulticastLocalPort;		// 组播本地端口, 默认37810, 值为0时使用最近一次配置
	int			iAutoUpdatePortTimes;		// 端口不可用时自动更新端口次数,默认50次，范围[0-65534]		
	WORD        wAOLMulticastRemotePort;	// AOL 组播远程端口, 默认8087, 值为0时使用最近一次配置
	WORD        wAOLMulticastLocalPort;		// AOL 组播本地端口, 默认37811, 值为0时使用最近一次配置
}NET_DEVICE_SEARCH_PARAM;

// struct SNMP配置结构
typedef struct
{
    BOOL                bEnable;                                // SNMP使能
    int                 iSNMPPort;                              // SNMP端口
    char                szReadCommon[DH_MAX_SNMP_COMMON_LEN];   // 读共同体
    char                szWriteCommon[DH_MAX_SNMP_COMMON_LEN];  // 写共同体
    char                szTrapServer[64];                       // trap地址
    int                 iTrapPort;                              // trap端口
    BYTE                bSNMPV1;                                // 设备是否开启支持版本1格式,0不使能；1使能
    BYTE                bSNMPV2;                                // 设备是否开启支持版本2格式,0不使能；1使能
    BYTE                bSNMPV3;                                // 设备是否开启支持版本3格式,0不使能；1使能
    char                szReserve[125];
}DHDEV_NET_SNMP_CFG;

// ISCSI服务器结构定义
typedef struct
{
    char                szServerName[32];                       // 名称
    union
    { 
        BYTE            c[4];
        WORD            s[2];
        DWORD           l;
    }                   stuIP;                                  // IP地址
    int                 nPort;                                  // 端口号
    char                szUserName[32];                         // 用户名
    char                szPassword[32];                         // 密码
    BOOL                bAnonymous;                             // 是否匿名登录
}DHDEV_ISCSI_SERVER;

// ISCSI配置结构
typedef struct
{
    BOOL                bEnable;                                // 使能
    DHDEV_ISCSI_SERVER  stuServer;                              // 服务器
    char                szRemotePath[240];                      // 远程目录
    BYTE                reserved[256];
}DHDEV_ISCSI_CFG;

//-------------------------------报警属性---------------------------------

// 云台联动
typedef struct 
{
    int                 iType;                                  // 0-None,1-Preset,2-Tour,3-Pattern
    int                 iValue;
} DH_PTZ_LINK, *LPDH_PTZ_LINK;

// 报警联动结构体
typedef struct 
{
    /* 消息处理方式,可以同时多种处理方式,包括
     * 0x00000001 - 报警上传
     * 0x00000002 - 联动录象
     * 0x00000004 - 云台联动
     * 0x00000008 - 发送邮件
     * 0x00000010 - 本地轮巡
     * 0x00000020 - 本地提示
     * 0x00000040 - 报警输出
     * 0x00000080 - Ftp上传
     * 0x00000100 - 蜂鸣
     * 0x00000200 - 语音提示
     * 0x00000400 - 抓图
    */


    DWORD               dwActionMask;                           // 当前报警所支持的处理方式,按位掩码表示 
    DWORD               dwActionFlag;                           // 触发动作,按位掩码表示,具体动作所需要的参数在各自的配置中体现 
    BYTE                byRelAlarmOut[DH_MAX_ALARMOUT_NUM];     // 报警触发的输出通道,报警触发的输出,为1表示触发该输出 
    DWORD               dwDuration;                             // 报警持续时间 
    BYTE                byRecordChannel[DH_MAX_VIDEO_IN_NUM];   // 报警触发的录象通道,为1表示触发该通道 
    DWORD               dwRecLatch;                             // 录象持续时间 
    BYTE                bySnap[DH_MAX_VIDEO_IN_NUM];            // 抓图通道 
    BYTE                byTour[DH_MAX_VIDEO_IN_NUM];            // 轮巡通道 
    DH_PTZ_LINK         struPtzLink[DH_MAX_VIDEO_IN_NUM];       // 云台联动 
    DWORD               dwEventLatch;                           // 联动开始延时时间,s为单位,范围是0~15,默认值是0 
    BYTE                byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM];   // 报警触发的无线输出通道,报警触发的输出,为1表示触发该输出 
    BYTE                bMessageToNet;
    BYTE                bMMSEn;                                 // 短信报警使能
    BYTE                bySnapshotTimes;                        // 短信发送抓图张数 
    BYTE                bMatrixEn;                              // 矩阵使能 
    DWORD               dwMatrix;                               // 矩阵掩码           
    BYTE                bLog;                                   // 日志使能,目前只有在WTN动态检测中使用 
    BYTE                bSnapshotPeriod;                        // 抓图帧间隔,每隔多少帧抓一张图片,一定时间内抓拍的张数还与抓图帧率有关。0表示不隔帧,连续抓拍
    BYTE                byEmailType;                            // 0,图片附件,1,录像附件
    BYTE                byEmailMaxLength;                       // 附件录像时的最大长度,单位MB
    BYTE                byEmailMaxTime;                         // 附件是录像时最大时间长度,单位秒
    BYTE                byReserved[99];   
} DH_MSG_HANDLE;

// 外部报警
typedef struct
{
    BYTE                byAlarmType;                            // 报警器类型,0：常闭,1：常开
    BYTE                byAlarmEn;                              // 报警使能
    BYTE                byReserved[2];                        
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             // 处理方式
} DH_ALARMIN_CFG, *LPDHDEV_ALARMIN_CFG; 

// 动态检测报警
typedef struct 
{
    BYTE                byMotionEn;                             // 动态检测报警使能
    BYTE                byReserved;
    WORD                wSenseLevel;                            // 灵敏度
    WORD                wMotionRow;                             // 动态检测区域的行数
    WORD                wMotionCol;                             // 动态检测区域的列数
    BYTE                byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // 检测区域,最多32*32块区域
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             //处理方式
} DH_MOTION_DETECT_CFG;

// 视频丢失报警
typedef struct
{
    BYTE                byAlarmEn;                              // 视频丢失报警使能
    BYTE                byReserved[3];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     //NSP
    DH_MSG_HANDLE       struHandle;                             // 处理方式
} DH_VIDEO_LOST_CFG;

// 图像遮挡报警
typedef struct
{
    BYTE                byBlindEnable;                          // 使能
    BYTE                byBlindLevel;                           // 灵敏度1-6
    BYTE                byReserved[2];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];     // NSP
    DH_MSG_HANDLE       struHandle;                             // 处理方式
} DH_BLIND_CFG;

// 硬盘消息(内部报警)
typedef struct 
{
    BYTE                byNoDiskEn;                             // 无硬盘时报警
    BYTE                byReserved_1[3];
    DH_TSECT            stNDSect[DH_N_WEEKS][DH_N_REC_TSECT];   // NSP
    DH_MSG_HANDLE       struNDHandle;                           // 处理方式
    BYTE                byLowCapEn;                             // 硬盘低容量时报警
    BYTE                byLowerLimit;                           // 容量阀值,0-99
    BYTE                byReserved_2[2];
    DH_TSECT            stLCSect[DH_N_WEEKS][DH_N_REC_TSECT];   // NSP
    DH_MSG_HANDLE       struLCHandle;                           // 处理方式
    BYTE                byDiskErrEn;                            // 硬盘故障报警
    BYTE                bDiskNum;
    BYTE                byReserved_3[2];
    DH_TSECT            stEDSect[DH_N_WEEKS][DH_N_REC_TSECT];   //NSP
    DH_MSG_HANDLE       struEDHandle;                           // 处理方式
} DH_DISK_ALARM_CFG;

typedef struct
{
    BYTE                byEnable;
    BYTE                byReserved[3];
    DH_MSG_HANDLE       struHandle;
} DH_NETBROKEN_ALARM_CFG;

// 报警布防
typedef struct
{
    DWORD dwSize;
    DH_ALARMIN_CFG          struLocalAlmIn[DH_MAX_ALARM_IN_NUM];
    DH_ALARMIN_CFG          struNetAlmIn[DH_MAX_ALARM_IN_NUM];
    DH_MOTION_DETECT_CFG    struMotion[DH_MAX_VIDEO_IN_NUM];
    DH_VIDEO_LOST_CFG       struVideoLost[DH_MAX_VIDEO_IN_NUM];
    DH_BLIND_CFG            struBlind[DH_MAX_VIDEO_IN_NUM];
    DH_DISK_ALARM_CFG       struDiskAlarm;
    DH_NETBROKEN_ALARM_CFG  struNetBrokenAlarm;
} DHDEV_ALARM_SCHEDULE;

#define DECODER_OUT_SLOTS_MAX_NUM        16
#define DECODER_IN_SLOTS_MAX_NUM         16

// 报警解码器配置
typedef struct  
{
    DWORD               dwAddr;                                     // 报警解码器地址
    BOOL                bEnable;                                    // 报警解码器使能
    DWORD               dwOutSlots[DECODER_OUT_SLOTS_MAX_NUM];      // 现在只支持8个.
    int                 nOutSlotNum;                                // dwOutSlots数组有效元素个数.
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle[DECODER_IN_SLOTS_MAX_NUM];       // 现在只支持8个.
    int                 nMsgHandleNum;                              // stuHandle数组有效元素个数.
    BYTE                bReserved[120];
} DH_ALARMDEC_CFG;

// 报警上传的配置
typedef struct  
{
    BYTE                byEnable;                                   // 上传使能
    BYTE                bReserverd;                                 // 保留
    WORD                wHostPort;                                  // 报警中心侦听端口
    char                sHostIPAddr[DH_MAX_IPADDR_LEN];             // 报警中心IP
    int                 nByTimeEn;                                  // 定时上传使能,可以用来向中心上传IP或域名等
    int                 nUploadDay;                                 /* 设置上传日期    
                                                                       "Never = 0", "Everyday = 1", "Sunday = 2", 
                                                                       "Monday = 3", Tuesday = 4", "Wednesday = 5",
                                                                       "Thursday = 6", "Friday = 7", "Saturday = 8"*/    
    int                 nUploadHour;                                // 设置上传时间 ,[0~23]点
    DWORD               dwReserved[300];                            // 保留待扩展。
} ALARMCENTER_UP_CFG;

// 全景切换报警配置
typedef struct __DH_PANORAMA_SWITCH_CFG 
{
    BOOL                bEnable;                                    // 使能
    int                 nReserved[5];                               // 保留
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                                 // 报警联动
} DH_PANORAMA_SWITCH_CFG;

typedef struct __ALARM_PANORAMA_SWITCH_CFG 
{
    int                    nAlarmChnNum;                            // 报警通道个数
    DH_PANORAMA_SWITCH_CFG stuPanoramaSwitch[DH_MAX_VIDEO_IN_NUM];
} ALARM_PANORAMA_SWITCH_CFG;

// 失去焦点报警配置
typedef struct __DH_LOST_FOCUS_CFG
{
    BOOL                bEnable;                                    // 使能
    int                 nReserved[5];                               // 保留
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                                 // 报警联动
} DH_LOST_FOCUS_CFG;

typedef struct __ALARM_LOST_FOCUS_CFG 
{
    int                 nAlarmChnNum;                               // 报警通道个数
    DH_LOST_FOCUS_CFG   stuLostFocus[DH_MAX_VIDEO_IN_NUM];
} ALARM_LOST_FOCUS_CFG;

// IP冲突检测报警配置
typedef struct __ALARM_IP_COLLISION_CFG
{
    BOOL                bEnable;                                    // 使能
    DH_MSG_HANDLE       struHandle;                                 // 报警联动
    int                 nReserved[300];                             // 保留
} ALARM_IP_COLLISION_CFG;

// MAC冲突检测配置
typedef struct __ALARM_MAC_COLLISION_CFG
{
    BOOL                bEnable;                                    // 使能
    DH_MSG_HANDLE       struHandle;                                 // 报警联动
    int                 nReserved[300];                             // 保留
} ALARM_MAC_COLLISION_CFG;

// 232串口卡号信号、485串口卡号信号事件配置
typedef struct __COM_CARD_SIGNAL_INFO
{
    WORD                wCardStartPose;                             // 卡号起始位
    WORD                wCardLenth;                                 // 卡号长度
    char                cStartCharacter[32];                        // 开始符
    char                cEndCharacter[32];                          // 结束符
    BYTE                byReserved[28];                             // 保留字段 
}COM_CARD_SIGNAL_INFO;

// 232串口卡号信号、485串口卡号信号联动配置(在串口发过来的卡号信息满足配置的卡号信息后,将触发设备抓图)
typedef struct __COM_CARD_SIGNAL_LINK_CFG
{
    COM_CARD_SIGNAL_INFO  struCardInfo;                             // 卡号信息
    DH_MSG_HANDLE         struHandle;                               // 事件联动
    BYTE                  byReserved[24];                           // 保留字段

}COM_CARD_SIGNAL_LINK_CFG;

//------------------------------多区域遮挡--------------------------------

// 遮挡信息
typedef struct __VIDEO_COVER_ATTR
{
    DH_RECT             rcBlock;                                    // 覆盖的区域坐标
    int                 nColor;                                     // 覆盖的颜色
    BYTE                bBlockType;                                 // 覆盖方式；0：黑块,1：马赛克
    BYTE                bEncode;                                    // 编码级遮挡；1：生效,0：不生效
    BYTE                bPriview;                                   // 预览遮挡； 1：生效,0：不生效
    char                reserved[29];                               // 保留
} VIDEO_COVER_ATTR;

// 多区域遮挡配置
typedef struct __DHDEV_VIDEOCOVER_CFG 
{
    DWORD               dwSize;
    char                szChannelName[DH_CHAN_NAME_LEN];            // 只读
    BYTE                bTotalBlocks;                               // 支持的遮挡块数
    BYTE                bCoverCount;                                // 已设置的遮挡块数
    VIDEO_COVER_ATTR    CoverBlock[DH_MAX_VIDEO_COVER_NUM];         // 覆盖的区域    
    char                reserved[30];                               // 保留
}DHDEV_VIDEOCOVER_CFG;

// 设备的解码策略配置
typedef struct __DHDEV_DECODEPOLICY_CFG 
{
    int                 nMinTime;                                   // 码缓冲时间范围(只读)：最小缓冲时间(单位：ms)
    int                 nMaxTime;                                   // 码缓冲时间范围(只读)：最大缓冲时间(单位：ms)
    int                 nDeocdeBufTime;                             // 目标设备解码缓冲时间(单位：ms)
    char                reserved[128];                              // 保留
}DHDEV_DECODEPOLICY_CFG;

// 机器相关的配置
typedef struct __DHDEV_MACHINE_CFG 
{
    char                szMachineName[DH_MACHINE_NAME_NUM];         // 机器名称或编号
    char                szMachineAddress[DH_MACHINE_NAME_NUM];      // 机器部署地点
    char                reserved[128];                              // 保留
}DHDEV_MACHINE_CFG;

////////////////////////////////IPC产品支持////////////////////////////////

// 配置无线网络信息
typedef struct 
{
    int                 nEnable;                    // 无线使能, 0: 使能, 1: 关闭
    char                szSSID[36];                 // SSID
    int                 nLinkMode;                  // 连接模式；0：auto,1：adhoc,2：Infrastructure
    int                 nEncryption;                // 加密；0：off,2：WEP64bit,3：WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP
    int                 nKeyType;                   // 0：Hex,1：ASCII
    int                 nKeyID;                     // 序号
    union
    {
        char            szKeys[4][32];              // 四组密码
        char            szWPAKeys[128];             // nEncryption为4、5时使用,传128长度,不用结束符。
    };
    int                 nKeyFlag;
    BYTE                byConnectedFlag;            // 0: 无连接, 1: 连接 
    char                reserved[11];
} DHDEV_WLAN_INFO;

// 选择使用某个无线设备
typedef struct  
{
    char                szSSID[36];
    int                 nLinkMode;                  // 连接模式；0：adhoc,1：Infrastructure
    int                 nEncryption;                // 加密；0：off,2：WEP64bit,3：WEP128bit
    char                reserved[48];
} DHDEV_WLAN_DEVICE;

// 搜索到的无线设备列表
typedef struct  
{
    DWORD               dwSize;
    BYTE                bWlanDevCount;              // 搜索到的无线设备个数
    DHDEV_WLAN_DEVICE   lstWlanDev[DH_MAX_WLANDEVICE_NUM];
    char                reserved[255];
} DHDEV_WLAN_DEVICE_LIST;

// 无线设备扩展配置
typedef struct
{
    char                szSSID[36];                         // 服务名称
    char                szMacAddr[18];                      // mac地址
    BYTE                byApConnected;                      // 是否连接成功 0:没有,1: 连接成功
    BYTE                byLinkMode;                         // 连接模式 0:adhoc 1:Infrastructure;
    int                 nRSSIQuality;                       // 信号强度(dbm)
    unsigned int        unApMaxBitRate;                     // 站点的最大传输速率
    BYTE                byAuthMode;                         // 认证模式0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
                                                            // 6:WPA-NONE(用在adhoc网络模式),
                                                            // 7-11是混合模式,选择其中任何一种都可以进行连接 
                                                            // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
                                                            // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
    BYTE                byEncrAlgr;                         // 加密模式0:off; 2:WEP64bit; 3:WEP128bit; 4:WEP; 5:TKIP; 6:AES(CCMP)
                                                            // 7: TKIP+AES(混合模式) 8: UnKnown
    BYTE                byLinkQuality;                      // 连接强度 0~100(%)
    BYTE                byReserved[129];                    // Reserved 
}DHDEV_WLAN_DEVICE_EX;

// 搜索到的无线设备扩展配置列表
typedef struct  
{
    DWORD               dwSize;
    BYTE                bWlanDevCount;            // 搜索到的无线设备个数
    DHDEV_WLAN_DEVICE_EX  lstWlanDev[DH_MAX_WLANDEVICE_NUM_EX];
    char                reserved[255];
} DHDEV_WLAN_DEVICE_LIST_EX;

// 搜索到的无线设备扩展配置列表
typedef struct  
{
	DWORD					dwSize;
	BYTE					bWlanDevCount;            // 搜索到的无线设备个数
	DHDEV_WLAN_DEVICE_EX	lstWlanDev[MAX_WLAN_DEVICE_NUM];
} DHDEV_WLAN_DEVICE_LIST_EX2;

//测试设置有效性
typedef struct
{
    int                 nResult;                  // 0：表示设置成功,1：表示设置失败
    BYTE                reserved[32];
} DHDEV_FUNC_TEST;

// FTP服务器信息
typedef struct
{
    char                szServerName[32];          // 服务器名
    char                szIp[16];                  // IP地址
    int                 nPort;                     // 端口号
    char                szUserName[32];            // 用户名
    char                szPassword[32];            // 密码
    BOOL                bAnonymity;                // 是否匿名登录
    BYTE                byReserved[256];           // 保留字节
}FTP_SERVER_CFG;

// ftp服务器连接测试
typedef struct
{
    FTP_SERVER_CFG     stuFtpServerInfo;           // ftp服务器信息（由用户填写）
    DHDEV_FUNC_TEST    stuTestResult;              // ftp服务器连接状态(由设备返回)
    BYTE               byReserved[64];
}DHDEV_FTP_SERVER_TEST;

// DDNS域名信息
typedef struct
{

    char                szServerType[DH_MAX_SERVER_TYPE_LEN];   // 服务器类型,希网..
    char                szServerIp[DH_MAX_DOMAIN_NAME_LEN];     // 服务器ip或者域名
    DWORD               dwServerPort;                           // 服务器端口
    char                szDomainName[DH_MAX_DOMAIN_NAME_LEN];   // dvr域名,如jeckean.3322.org
    char                szUserName[DH_MAX_HOST_NAMELEN];        // 用户名
    char                szUserPsw[DH_MAX_HOST_PSWLEN];          // 密码
    BYTE                byReserved[256];                        // 保留字节
}DDNS_DOMAIN_INFO;


// DDNS域名是否可用测试
typedef struct
{
    DDNS_DOMAIN_INFO   stuDomainInfo;                           // DDNS域名信息（由用户填写）
    DHDEV_FUNC_TEST    stuTestResult;                           // 测试结果
    char               szMemo[128];                             // 测试结果描述
    BYTE               byReserved[64];
}DHDEV_DDNS_DOMAIN_TEST;


//表示硬盘的基本信息
typedef struct 
{
    BYTE                byModle[32];                  // 型号
    BYTE                bySerialNumber[32];           // 序列号
    BYTE                byFirmWare[32];               // 固件号
    int                 nAtaVersion;                  // ATA协议版本号
    int                 nSmartNum ;                   // smart 信息数
    INT64               Sectors;    
    int                 nStatus;                      // 磁盘状态 0-正常 1-异常
    int                 nReserved[33];                // 保留字节
} DHDEV_DEVICE_INFO;

//硬盘的smart信息,可能会有很多条,最多不超过30个　　
typedef struct
{
    BYTE    byId;               // ID
    BYTE    byCurrent;          // 属性值
    BYTE    byWorst;            // 最大出错值
    BYTE    byThreshold;        // 阈值
    char    szName[64];         // 属性名
    char    szRaw[8];           // 实际值
    int     nPredict;           // 状态
    char    reserved[128];
} DHDEV_SMART_VALUE;

//硬盘smart信息查询
typedef struct
{
    BYTE                nDiskNum;                       // 硬盘号
    BYTE                byRaidNO;                       // Raid子盘,0表示单盘
    BYTE                byReserved[2];                  // 保留字节
    DHDEV_DEVICE_INFO   deviceInfo;
    DHDEV_SMART_VALUE   smartValue[MAX_SMART_VALUE_NUM];
} DHDEV_SMART_HARDDISK;

// 各子模块信息
typedef struct
{
    char               szModuleName[64];      //  子模块名称
    char               szHardWareVersion[32]; //  子模块硬件版本号
    char               szSoftwareVersion[32]; //  子模块软件版本号
    BYTE               reserved[128]; 
} DHDEV_SUBMODELE_VALUE;

// 查询设备子模块信息
typedef struct
{
    int                    nSubModuleNum;                         //  返回子模块总数
    DHDEV_SUBMODELE_VALUE  stuSubmoduleValue[MAX_SUBMODULE_NUM];  //  子模块详细信息
    BYTE                   bReserved[256];
} DHDEV_SUBMODULE_INFO;

// 查询硬盘坏道能力
typedef struct
{
    BYTE                bDiskDamageLevel[DH_MAX_DISK_NUM];  //各磁盘坏道等级
    BYTE                bReserved[128];
} DHDEV_DISKDAMAGE_INFO;


// syslog的远程服务器配置
typedef struct 
{
    char    szServerIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];    //服务器地址
    int     nServerPort;                                //服务器端口
    BYTE    bEnable;                                    //服务器使能
    BYTE    bReserved[255];                             //保留字节
}DHDEV_SYSLOG_REMOTE_SERVER;

// 视频备份配置
typedef struct
{
    BYTE    backupVideoFormat;                  // 备份文件类型, 0:dav, 1:asf
    BYTE    password[6];                        // 备份密码
    BYTE    reversed[505];
}DHDEV_BACKUP_VIDEO_FORMAT;


// 主动注册参数配置
typedef struct  
{
    char                szServerIp[32];             // 注册服务器IP
    int                 nServerPort;                // 端口号
    BYTE                byReserved[3];              // 对齐
    BYTE                bServerIpExEn;              // 注册服务器IP扩展使能,0-表示无效, 1-表示有效
    char                szServerIpEx[60];           // 注册服务器IP扩展,支持ipv4,ipv6,域名等类型的IP
} DHDEV_SERVER_INFO;

typedef struct  
{
    DWORD               dwSize;
    BYTE                bServerNum;                 // 支持的最大ip数
    DHDEV_SERVER_INFO   lstServer[DH_MAX_REGISTER_SERVER_NUM];
    BYTE                bEnable;                    // 使能
    char                szDeviceID[32];             // 设备id
    char                reserved[94];
} DHDEV_REGISTER_SERVER;

// 摄像头属性
typedef struct __DHDEV_CAMERA_INFO
{
    BYTE                bBrightnessEn;              // 亮度可调；1：可,0：不可
    BYTE                bContrastEn;                // 对比度可调
    BYTE                bColorEn;                   // 色度可调
    BYTE                bGainEn;                    // 增益可调
    BYTE                bSaturationEn;              // 饱和度可调
    BYTE                bBacklightEn;               // 背光补偿 0表示不支持背光补偿,1表示支持一级补偿（开,关）,2表示支持两级补偿（关,高,低）,3表示支持三级补偿（关,高,中,低）
    BYTE                bExposureEn;                // 曝光选择: 0:表示不支持曝光控制 1:表示只支持自动曝光 n:曝光的等级数(1表示支持自动曝光 2~n表示支持的手动控制曝光的等级)
    BYTE                bColorConvEn;               // 自动彩黑转换可调
    BYTE                bAttrEn;                    // 属性选项；1：可,0：不可
    BYTE                bMirrorEn;                  // 镜像；1：支持,0：不支持
    BYTE                bFlipEn;                    // 翻转；1：支持,0：不支持
    BYTE                iWhiteBalance;              // 白平衡 0-不支持白平衡,1-支持自动白平衡,2-支持预置白平衡（即情景模式） 3-支持自定义白平衡
    BYTE                iSignalFormatMask;          // 信号格式掩码,按位从低到高位分别为：0-Inside(内部输入) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
    BYTE                bRotate90;                  // 90度旋转 0-不支持 1-支持
    BYTE                bLimitedAutoExposure;       // 是否支持带时间上下限的自动曝光
    BYTE                bCustomManualExposure;      // 是否支持用户自定义手动曝光时间
    BYTE                bFlashAdjustEn;             // 是否支持闪光灯调节
    BYTE                bNightOptions;              // 是否支持夜晚选项
    BYTE                iReferenceLevel;            // 是否支持参考电平设置
    BYTE                bExternalSyncInput;         // 是否支持外部同步信号输入,0-不支持,1-支持
    unsigned short      usMaxExposureTime;          // 自定义曝光区间最大曝光时间,单位毫秒         
    unsigned short      usMinExposureTime;          // 自定义曝光区间最小曝光时间,单位毫秒
    BYTE                bWideDynamicRange;          // 宽动态能力范围,0-表示不支持,2~n表示最大的范围值
    BYTE                bDoubleShutter;             // 双快门0不支持,1-支持双快门全帧率,即图像和视频只有快门参数不同,2-支持双快门半帧率,即图像和视频快门及白平衡参数均不同,3-支持双快门全帧率和半帧率
    BYTE                byExposureCompensation;     // 1支持, 0 不支持
    BYTE                bRev[109];                  // 保留
} DHDEV_CAMERA_INFO;

//夜晚特殊配置选项,在晚上光线较暗时自动切换到夜晚的配置参数
typedef struct __DHDEV_NIGHTOPTIONS 
{
    BYTE  bEnable;                                  // 0-不切换,1-切换 
                                                    // 大致日出和日落时间,日落之后日出之前,将采用夜晚特殊的配置。
                                                    // 00:00:00 ~23:59:59
    BYTE  bSunriseHour;
    BYTE  bSunriseMinute;
    BYTE  bSunriseSecond;
    BYTE  bSunsetHour;
    BYTE  bSunsetMinute;
    BYTE  bSunsetSecond;  
    BYTE  bWhiteBalance ;                           // 白平衡 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
    BYTE  bGainRed;                                 // 红色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE  bGainBlue;                                // 绿色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE  bGainGreen;                               // 蓝色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE  bGain;                                    // 0~100
    BYTE  bGainAuto;                                // 0-不自动增益 1-自动增益
    BYTE  bBrightnessThreshold ;                    // 亮度值 0~100
    BYTE  ReferenceLevel;                           // 电平参考值 0~100   
    BYTE  bExposureSpeed;                           // 取值范围取决于设备能力集：0-自动曝光 1~n-1-手动曝光等级 n-带时间上下限的自动曝光 n+1-自定义时间手动曝光 (n表示支持的曝光等级数）
    float ExposureValue1;                           // 自动曝光时间下限或者手动曝光自定义时间,毫秒为单位,取值0.1ms~80ms
    float ExposureValue2;                           // 自动曝光时间上限,毫秒为单位,取值0.1ms~80ms
    BYTE  bAutoApertureEnable;                      // 自动光圈使能,1开启,0关闭
    BYTE  bWideDynamicRange;                        // 宽动态值     取值范围由能力决定
    WORD  wNightSyncValue;                          // 夜晚相位 0~360
    WORD  wNightSyncValueMillValue;                 // 夜晚相位0~999(千分之一度),与wNightSyncValue组合构成夜晚相位值
    BYTE res[10];                                   // 保留
} DHDEV_NIGHTOPTIONS;

// 摄像头属性配置
typedef struct __DHDEV_CAMERA_CFG 
{
    DWORD                dwSize;
    BYTE                bExposure;                  // 曝光模式；取值范围取决于设备能力集：0-自动曝光,1-曝光等级1,2-曝光等级2…n-1最大曝光等级数 n带时间上下限的自动曝光 n+1自定义时间手动曝光 (n==bExposureEn）
    BYTE                bBacklight;                 // 背光补偿：背光补偿等级取值范围取决于设备能力集,0-关闭,1-背光补偿强度1,2-背光补偿强度2…n-最大背光补偿等级数 
    BYTE                bAutoColor2BW;              // 日/夜模式；3-根据时间自动切换 2：开(黑白),1：根据亮度启动切换,0：关(彩色)
    BYTE                bMirror;                    // 镜像；1：开,0：关
    BYTE                bFlip;                      // 翻转；1：开,0：关
    BYTE                bLensEn;                    // 自动光圈功能能力: 1：支持；0 ：不支持
    BYTE                bLensFunction;              // 自动光圈功能: 1:开启自动光圈；0: 关闭自动光圈
    BYTE                bWhiteBalance;              // 白平衡 0:Disabled,1:Auto 2:sunny 3:cloudy 4:home 5:office 6:night 7: Custom
    BYTE                bSignalFormat;              // 信号格式0-Inside(内部输入) 1- BT656 2-720p 3-1080i  4-1080p  5-1080sF
    BYTE                bRotate90;                  // 0-不旋转,1-顺时针90°,2-逆时针90°
    BYTE                bReferenceLevel;            // 电平参考值 0~100  
    BYTE                byReserve;                  // 保留
    float               ExposureValue1;             // 自动曝光时间下限或者手动曝光自定义时间,毫秒为单位,取值0.1ms~80ms
    float               ExposureValue2;             // 自动曝光时间上限,毫秒为单位,取值0.1ms~80ms    
    DHDEV_NIGHTOPTIONS  stuNightOptions;            // 夜晚配置参数选项 
    BYTE                bGainRed;                   // 红色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE                bGainBlue;                  // 绿色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE                bGainGreen;                 // 蓝色增益调节,白平衡为"Custom"模式下有效 0~100
    BYTE                bFlashMode;                 // 闪光灯工作模式,0-关闭,1-始终,2-自动
    BYTE                bFlashValue;                // 闪光灯工作值, 0-0us, 1-64us, 2-128us,...15-960us
    BYTE                bFlashPole;                 // 闪光灯触发模式0-低电平 1-高电平
    BYTE                bExternalSyncPhase;         // 外部同步信号输入,0-内部同步 1-外部同步
    BYTE                bFlashInitValue;            // 闪光灯亮度预设值  区间0~100
    WORD                wExternalSyncValue ;        // 外同步的相位设置 0~360(小数点后3位数字有效)
    WORD                wExternalSyncValueMillValue;//  外同步的相位设置0~999(千分之一度),与wExternalSyncValue组合构成外同步的相位值
    BYTE                bWideDynamicRange;          //宽动态值     取值范围由能力决定
    BYTE                byExposureCompensation;     // 曝光补偿值,默认为7,范围0~14
    char                bRev[54];                   // 保留
} DHDEV_CAMERA_CFG;

#define ALARM_MAX_NAME 64
// (无线)红外报警配置
typedef struct
{
    BOOL                bEnable;                            // 报警输入使能
    char                szAlarmName[DH_MAX_ALARM_NAME];     // 报警输入名称
    int                 nAlarmInPattern;                    // 报警器输入波形
    int                 nAlarmOutPattern;                   // 报警输出波形
    char                szAlarmInAddress[DH_MAX_ALARM_NAME];// 报警输入地址
    int                 nSensorType;                        // 外部设备传感器类型常开 or 常闭
    int                 nDefendEfectTime;                   // 布撤防延时时间,在此时间后该报警输入有效
    int                 nDefendAreaType;                    // 防区类型 
    int                 nAlarmSmoothTime;                   // 报警平滑时间,即在此时间内如果只有一个报警输入连续输入两次则忽略掉后面一次
    char                reserved[128];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];
    DH_MSG_HANDLE       struHandle;                         // 处理方式
} DH_INFRARED_INFO;

// 无线遥控器配置
typedef struct 
{
    BYTE                address[ALARM_MAX_NAME];        // 遥控器地址
    BYTE                name[ALARM_MAX_NAME];           // 遥控器名称
    BYTE                reserved[32];                   // 保留字段
} DH_WI_CONFIG_ROBOT;

// 无线报警输出配置
typedef struct 
{
    BYTE                address[ALARM_MAX_NAME];        // 报警输出地址
    BYTE                name[ALARM_MAX_NAME];           // 报警输出名称
    BYTE                reserved[32];                   // 保留字段
} DH_WI_CONFIG_ALARM_OUT;

typedef struct  
{
    DWORD                   dwSize;
    BYTE                    bAlarmInNum;                // 无线报警输入数
    BYTE                    bAlarmOutNum;               // 无线报警输出数
    DH_WI_CONFIG_ALARM_OUT  AlarmOutAddr[16];           // 报警输出地址
    BYTE                    bRobotNum;                  // 遥控器个数
    DH_WI_CONFIG_ROBOT      RobotAddr[16];              // 遥控器地址
    DH_INFRARED_INFO        InfraredAlarm[16];
    char                    reserved[256];
} DH_INFRARED_CFG;

// 新音频检测报警信息
typedef struct
{
    int                 channel;                        // 报警通道号
    int                 alarmType;                      // 报警类型；0：音频值过低,1：音频值过高
    unsigned int        volume;                         // 音量值
    BYTE                byState;                        // 音频报警状态, 0: 音频报警出现, 1: 音频报警消失
    char                reserved[255];
} NET_NEW_SOUND_ALARM_STATE;

typedef struct  
{
    int                         channelcount;           // 报警的通道个数
    NET_NEW_SOUND_ALARM_STATE   SoundAlarmInfo[DH_MAX_ALARM_IN_NUM];
} DH_NEW_SOUND_ALARM_STATE;

// 抓图功能属性结构体
typedef struct 
{
    int                 nChannelNum;                // 通道号
    DWORD               dwVideoStandardMask;        // 分辨率(按位),具体查看枚举 CAPTURE_SIZE                        
    int                 nFramesCount;               // Frequence[128]数组的有效长度
    char                Frames[128];                // 帧率(按数值)
                                                    // -25：25秒1帧；-24：24秒1帧；-23：23秒1帧；-22：22秒1帧
                                                    // ……
                                                    // 0：无效；1：1秒1帧；2：1秒2帧；3：1秒3帧
                                                    // 4：1秒4帧；5：1秒5帧；17：1秒17帧；18：1秒18帧
                                                    // 19：1秒19帧；20：1秒20帧
                                                    // ……
                                                    // 25: 1秒25帧
    int                 nSnapModeCount;             // SnapMode[16]数组的有效长度
    char                SnapMode[16];               // (按数值)0：定时触发抓图,1：手动触发抓图
    int                 nPicFormatCount;            // Format[16]数组的有效长度
    char                PictureFormat[16];          // (按数值)0：BMP格式,1：JPG格式
    int                 nPicQualityCount;           // Quality[32]数组的有效长度
    char                PictureQuality[32];         // 按数值
                                                    // 100：图象质量100%；80:图象质量80%；60:图象质量60%
                                                    // 50:图象质量50%；30:图象质量30%；10:图象质量10%
    char                nReserved[128];             // 保留
} DH_QUERY_SNAP_INFO;

typedef struct 
{
    int                 nChannelCount;              // 通道个数
    DH_QUERY_SNAP_INFO  stuSnap[DH_MAX_CHANNUM];
} DH_SNAP_ATTR_EN;


/* IP过滤功能配置 */
#define DH_IPIFILTER_NUM            200             // IP
#define DH_IPIFILTER_NUM_EX         512             // IP

// IP信息
typedef struct 
{
    DWORD               dwIPNum;                                    // IP个数
    char                SZIP[DH_IPIFILTER_NUM][DH_MAX_IPADDR_LEN];  // IP
    char                byReserve[32];                              // 保留
} IPIFILTER_INFO;

// IP过滤配置结构体
typedef struct
{
    DWORD               dwSize;
    DWORD               dwEnable;                   // 使能
    DWORD               dwType;                     // 当前名单类型：0：白名单 1：黑名单（设备只能使一种名单生效,或者是白名单或者是黑名单）
    IPIFILTER_INFO      BannedIP;                   // 黑名单
    IPIFILTER_INFO      TrustIP;                    // 白名单
    char                byReserve[256];             // 保留
} DHDEV_IPIFILTER_CFG;

// IP信息扩展
typedef struct 
{
    DWORD               dwIPNum;                                        // IP个数
    char                SZIP[DH_IPIFILTER_NUM_EX][DH_MAX_IPADDR_LEN];   // IP
    char                byReserve[32];                                  // 保留
} IPIFILTER_INFO_EX;

// IP过滤配置结构体扩展
typedef struct
{
    DWORD                dwSize;
    DWORD                dwEnable;                  // 使能
    DWORD                dwType;                    // 当前名单类型：0：白名单 1：黑名单（设备只能使一种名单生效,或者是白名单或者是黑名单）
    IPIFILTER_INFO_EX    BannedIP;                  // 黑名单
    IPIFILTER_INFO_EX    TrustIP;                   // 白名单
    char                 byReserve[256];            // 保留
} DHDEV_IPIFILTER_CFG_EX;

/* MAC过滤配置 */
#define DH_MACFILTER_NUM            512             // MAC

// MAC信息
typedef struct 
{
    DWORD                dwSize;                                    // 使用时,用初始化为本结构体大小
    DWORD                dwMacNum;                                  // MAC个数
    char                 szMac[DH_MACFILTER_NUM][DH_MACADDR_LEN];   // MAC
} MACFILTER_INFO;

// MAC过滤配置结构体
typedef struct
{
    DWORD                 dwSize;                   // 使用时,用初始化为本结构体大小
    DWORD                 dwEnable;                 // 使能
    DWORD                 dwType;                   // 当前名单类型：0：白名单 1：黑名单（设备只能使一种名单生效,或者是白名单或者是黑名单）
    MACFILTER_INFO        stuBannedMac;             // 黑名单Mac
    MACFILTER_INFO        stuTrustMac;              // 白名单Mac
} DHDEV_MACFILTER_CFG;

/* MAC,IP过滤配置 */
#define DH_MACIPFILTER_NUM           512            // MAC,IP

// MAC,IP过滤信息
typedef struct
{
    DWORD       dwSize;                             // 使用时,用初始化为本结构体大小
    char        szMac[DH_MACADDR_LEN];              // mac
    char        szIp[DH_MAX_IPADDR_LEN];            // ip
}MACIP_INFO;

// MAC,IP过滤配置结构体
typedef struct
{
    DWORD                    dwSize;                                // 使用时,用初始化为本结构体大小
    DWORD                    dwEnable;                              // 使能
    DWORD                    dwType;                                // 当前名单类型：0：白名单 1：黑名单（设备只能使一种名单生效,或者是白名单或者是黑名单）
    DWORD                    dwBannedMacIpNum;                      // 黑名单MAC,IP个数(MAC,IP一一对应)
    MACIP_INFO               stuBannedMacIp[DH_MACIPFILTER_NUM];    // 黑名单Mac,IP
    DWORD                    dwTrustMacIpNum;                       // 白名单MAC,IP个数(MAC,IP一一对应)
    MACIP_INFO               stuTrustMacIp[DH_MACIPFILTER_NUM];     // 白名单Mac,IP
} DHDEV_MACIPFILTER_CFG;

typedef struct
{
    int                nCardNum;                                        // 有效卡号数
    char               cardInfo [DH_MAX_CARD_NUM][DH_MAX_CARDINFO_LEN]; // 卡号信息字符串 
    BYTE               byReserve[32];                                   // 保留字段
}DHDEV_NETCARD_CFG;

// RTSP 配置
typedef struct
{
    WORD               wPort;                  // 端口号
    BYTE               byReserved[62];         // 保留字段
}DHDEV_RTSP_CFG;

//-------------------------码流加密配置---------
// 具体密钥信息36个字节
typedef struct _ENCRYPT_KEY_INFO
{
    BYTE        byEncryptEnable;       //  是否加密0:不加密, 1:加密
    BYTE        byReserved[3]; 
    union
    {
        BYTE    byDesKey[8];           // des密钥
        BYTE    by3DesKey[3][8];       // 3des密钥
        BYTE    byAesKey[32];          // aes密钥

    };
}ENCRYPT_KEY_INFO;

// 加密算法参数
typedef struct _ALGO_PARAM_INFO
{
    WORD       wEncryptLenth;       // 密钥长度,当前为AES算法类型时,表示密钥位数(目前支持128,192,256位三种, 如: wEncryptLenth为128,则密钥信息ENCRYPT_KEY_INFO里的byAesKey[0]~[15])
                                    // 为DES算法类型时,密钥长度固定为64位
                                    // 为3DES算法类型时,表示密钥的个数(2或3个密钥)
    BYTE       byAlgoWorkMode ;     // 工作模式,参考枚举类型 EM_ENCRYPT_ALOG_WORKMODE 
    BYTE       reserved[13];        // 保留字段
}ALGO_PARAM_INFO;

// 码流加密配置信息
typedef struct _DHEDV_STREAM_ENCRYPT
{
    BYTE                    byEncrptAlgoType;           // 加密算法类型：00: AES、01:DES、02: 3DES
    BYTE                    byReserved1[3];
    ALGO_PARAM_INFO         stuEncrptAlgoparam;         // 加密算法参数
    ENCRYPT_KEY_INFO        stuEncryptKeys[32];         // 各通道的密钥信息 
    BYTE                    byEncrptPlanEnable;         // 加密计划使能
    BYTE                    byReserved3[3];
    NET_TIME                stuPreTime;                 // 加密计划的开始时间
    BYTE                    reserved2[1360];
}DHEDV_STREAM_ENCRYPT;

// 限码流配置
typedef struct _DHDEV_BIT_RATE
{
    DWORD                   nExpectCodeRate;          // 限制码流,单位kps
    BYTE                    byReserved[64];           // 保留字节
}DHDEV_LIMIT_BIT_RATE;

// 用户自定义配置
typedef struct _DHDEV_CUSTOM_CFG
{
    char                   szData[1024];            // 用户自定义配置信息
    char                   reserved[3072];          // 保留字段
}DHDEV_CUSTOM_CFG;

/*语音对讲编码配置*/
typedef struct
{
    DWORD               dwSize;
    int                 nCompression;               // 压缩格式,枚举值,相见DH_TALK_CODING_TYPE,请根据设备支持的语音对讲类型设置压缩格式。
    int                 nMode;                      // 编码模式,枚举值,为0时表示该压缩格式不支持编码模式。
                                                    // 根据压缩格式可以设置对应的编码格式,如
                                                    // AMR详见EM_ARM_ENCODE_MODE
    char                 byReserve[256];            // 保留
} DHDEV_TALK_ENCODE_CFG;

// 以下是mobile功能相关
// (事件触发多媒体彩信/短信发送)MMS配置结构体
typedef struct
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // 使能
    DWORD               dwReceiverNum;                          // 短信接收者个数
    char                SZReceiver[DH_MMS_RECEIVER_NUM][32];    // 短信接收者,一般为手机号码
    BYTE                byType;                                 // 短信信息类型 0:MMS；1:SMS
    char                SZTitle[32];                            // 短信信息标题
    char                byReserve[223];                         // 保留
} DHDEV_MMS_CFG;

// (短信激活无线连接配置)
typedef struct  
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // 使能
    DWORD               dwSenderNum;                            // 短信发送者个数
    char                SZSender[DH_MMS_SMSACTIVATION_NUM][32]; // 短信发送者,一般为手机号码
     char               byReserve[256];                         // 保留
}DHDEV_SMSACTIVATION_CFG;

// (拨号激活无线连接配置)
typedef struct  
{
    DWORD               dwSize;
    DWORD               dwEnable;                               // 使能
    DWORD               dwCallerNum;                            // 发送者个数
    char                SZCaller[DH_MMS_DIALINACTIVATION_NUM][32];// 发送者, 一般为手机号码
    char                byReserve[256];                         // 保留
}DHDEV_DIALINACTIVATION_CFG;
// 以上是mobile功能相关


// 无线网络信号强度结构体
typedef struct
{
    DWORD               dwSize;
    DWORD               dwTDSCDMA;                  // TD-SCDMA强度,范围：0－100
    DWORD               dwWCDMA;                    // WCDMA强度,范围：0－100
    DWORD               dwCDMA1x;                   // CDMA1x强度,范围：0－100
    DWORD               dwEDGE;                     // EDGE强度,范围：0－100
    DWORD               dwEVDO;                     // EVDO强度,范围：0－100
    int                 nCurrentType;               // 当前类型
                                                    // 0 设备不支持这一项
                                                    // 1 TD-SCDMA
                                                    // 2 WCDMA
                                                    // 3 CDMA_1x
                                                    // 4 EDGE
                                                    // 5 EVDO
													// 6 TD-LTE
													// 7 FDD-LTE
    DWORD               dwTDLTE;                    // TD-LTE强度,范围：0－100
    DWORD               dwFDDLTE;                   // FDD-LTE强度,范围：0－100
    char                byReserve[244];             // 保留
} DHDEV_WIRELESS_RSS_INFO;

typedef struct _DHDEV_SIP_CFG
{
    BOOL        bUnregOnBoot;                       //Unregister on Reboot
    char        szAccoutName[64];                   //Account Name
    char        szSIPServer[128];                   //SIP Server
    char        szOutBoundProxy[128];               //Outbound Proxy
    DWORD       dwSIPUsrID;                         //SIP User ID
    DWORD       dwAuthID;                           //Authenticate ID
    char        szAuthPsw[64];                      //Authenticate Password
    char        szSTUNServer[128];                  //STUN Server
    DWORD       dwRegExp;                           //Registration Expiration
    DWORD       dwLocalSIPPort;                     //Local SIP Port
    DWORD       dwLocalRTPPort;                     //Local RTP Port
    BOOL        bEnable;                            // 使能
    char        szNotifyID[128];                    // 联动ID
    NET_TIME    stuRegTime;                         // 注册成功的时间；只读字段,设备指定。   
    BYTE        bReserved[868];                     //reserved
} DHDEV_SIP_CFG;

typedef struct _DHDEV_SIP_STATE
{
    int         nStatusNum;                         //状态信息总的个数
    BYTE        byStatus[64];                       //0:注册成功,1:未注册,2:无效,3:注册中,4:通话中
    BYTE        bReserved[64];                      //保留
}DHDEV_SIP_STATE;

typedef struct _DHDEV_HARDKEY_STATE
{
    BOOL        bState;                             // 0:未插入HardKey, 1:已插入HardKey
    BYTE        bReserved[64];                      // 保留
}DHDEV_HARDKEY_STATE;

typedef struct _DHDEV_ISCSI_PATHLIST
{
    int         nCount;
    char        szPaths[DH_MAX_ISCSI_PATH_NUM][MAX_PATH_STOR];    // 远程目录数组
} DHDEV_ISCSI_PATHLIST;

// 无线路由能力信息
typedef struct _DHDEV_WIFI_ROUTE_CAP_COUNTRY
{
    char        szCountry[32];                      // 国家
    int         nValidChnNum;                       // 有效通道数量
    int         nValideChannels[32];                // 有效通道列表
    char        reserved[64];                       // 保留
} DHDEV_WIFI_ROUTE_CAP_COUNTRY;

typedef struct _DHDEV_WIFI_ROUTE_CAP
{
    int         nCountryNum;                        // 国家数量
    DHDEV_WIFI_ROUTE_CAP_COUNTRY stuCountry[256];   // 不同国家的配置信息
    char        reserved[256];                      // 保留
} DHDEV_WIFI_ROUTE_CAP;

//  画面监控辅助信息
typedef struct _MONITOR_INFO
{
    int         nPresetObjectNum;                   // 预置应有目标数目
    int         nActualObjectNum;                   // 现场实际目标数目 
    char        reserved[64]; 
}MONITOR_INFO;

typedef struct _DHDEV_MONITOR_INFO
{
    int              nChannelNumber;
    MONITOR_INFO     stMonitorInfo[64];             //  画面监控辅助信息
    char             reserved[128];
}DHDEV_MONITOR_INFO;

// 多通道预览回放分割能力
typedef struct tagNET_MULTIPLAYBACK_SPLIT_CAP
{
    DWORD            dwSize;
    int              nSliptMode[DH_MAX_MULTIPLAYBACK_SPLIT_NUM]; // 支持的分割模式,  
    int              nModeNumber;       
}NET_MULTIPLAYBACK_SPLIT_CAP;

/***************************** 云台预制点配置 ***********************************/
typedef struct _POINTEANBLE
{
    BYTE             bPoint;                        //预制点的有效范围闭区间[1,80],无效设置为0。
    BYTE             bEnable;                       //是否有效,0无效,1有效
    BYTE             bReserved[2];
} POINTEANBLE;

typedef struct _POINTCFG
{
    char             szIP[DH_MAX_IPADDR_LEN];       // ip
    int              nPort;                         // 端口    
    POINTEANBLE      stuPointEnable[80];            // 预制点使能
    BYTE             bReserved[256];
}POINTCFG;

typedef struct _DHDEV_POINT_CFG
{
    int              nSupportNum;                   // 只读参数,设置的时候需要返回给sdk,表示支持的预制点数
    POINTCFG         stuPointCfg[16];               // 二维下标表示通道号。要设置的点数值放在前nSupportNum个下标里面。
    BYTE             bReserved[256];                // 保留
}DHDEV_POINT_CFG;
////////////////////////////////车载DVR支持////////////////////////////////

// GPS信息(车载设备)
typedef struct _GPS_Info
{
    NET_TIME         revTime;                       // 定位时间
    char             DvrSerial[50];                 // 设备序列号
    double           longitude;                     // 经度(单位是百万分之度,范围0-360度)
    double           latidude;                      // 纬度(单位是百万分之度,范围0-180度)
    double           height;                        // 高度(米)
    double           angle;                         // 方向角(正北方向为原点,顺时针为正)
    double           speed;                         // 速度(单位是海里,speed/1000*1.852公里/小时)
    WORD             starCount;                     // 定位星数
    BOOL             antennaState;                  // 天线状态(true 好,false 坏)
    BOOL             orientationState;              // 定位状态(true 定位,false 不定位)
} GPS_Info,*LPGPS_Info;

// 报警状态信息
typedef struct 
{
    int              nAlarmCount;                   // 发生的报警事件个数
    int              nAlarmState[128];              // 发生的报警事件类型
    BYTE             byRserved[128];                // 保留字节
}ALARM_STATE_INFO;

// Gps定位信息
typedef struct tagNET_GPS_LOCATION_INFO
{
	GPS_Info	        stuGpsInfo;               // GPS信息
	ALARM_STATE_INFO    stuAlarmStateInfo;        // 报警状态信息
	int				    nTemperature;		      // 温度(单位:0.1摄氏度)
	int					nHumidity;				  // 湿度(单位:0.1%)
	unsigned int		nIdleTime;				  // 怠速时长(单位:秒)
	unsigned int        nMileage;				  // 里程(单位:0.1km)
	int					nVoltage;				  // 设置电压值(单位:0.1伏)
    BYTE                bOffline;                 // 0-实时 1-补传  
	BYTE			    byReserved[1023];  
}NET_GPS_LOCATION_INFO, *LPNET_GPS_LOCATION_INFO;

// 抓图参数结构体
typedef struct _snap_param
{
    unsigned int     Channel;                       // 抓图的通道
    unsigned int     Quality;                       // 画质；1~6
    unsigned int     ImageSize;                     // 画面大小；0：QCIF,1：CIF,2：D1
    unsigned int     mode;                          // 抓图模式；-1:表示停止抓图, 0：表示请求一帧, 1：表示定时发送请求, 2：表示连续请求
    unsigned int     InterSnap;                     // 时间单位秒；若mode=1表示定时发送请求时
													// 只有部分特殊设备(如：车载设备)支持通过该字段实现定时抓图时间间隔的配置
													// 建议通过 CFG_CMD_ENCODE 配置的stuSnapFormat[nSnapMode].stuVideoFormat.nFrameRate字段实现相关功能
    unsigned int     CmdSerial;                     // 请求序列号，有效值范围 0~65535，超过范围会被截断为 unsigned short
    unsigned int     Reserved[4];
} SNAP_PARAMS, *LPSNAP_PARAMS;

// 抓图功能配置
typedef struct 
{
    DWORD            dwSize;
    BYTE             bTimingEnable;                 // 定时抓图开关(报警抓图开关在各报警联动配置中体现)
    BYTE             bPicIntervalHour;              // 定时抓图时间间隔小时数
    short            PicTimeInterval;               // 定时抓图时间间隔,单位为秒,目前设备支持最大的抓图时间间隔为30分钟                           
    DH_VIDEOENC_OPT  struSnapEnc[SNAP_TYP_NUM];     // 抓图编码配置,现支持其中的分辨率、画质、帧率设置,帧率在这里是负数,表示一秒抓图的次数。
} DHDEV_SNAP_CFG;

// 抓图功能配置扩展
typedef struct 
{
    DWORD            dwSize;
    BYTE             bTimingEnable;                 // 定时抓图开关(报警抓图开关在各报警联动配置中体现)
    BYTE             bPicIntervalHour;              // 定时抓图时间间隔小时数
    short            PicTimeInterval;               // 定时抓图时间间隔,单位为秒,目前设备支持最大的抓图时间间隔为30分钟                           
    DH_VIDEOENC_OPT  struSnapEnc[SNAP_TYP_NUM];     // 抓图编码配置,现支持其中的分辨率、画质、帧率设置,帧率在这里是负数,表示一秒抓图的次数。
    DWORD            dwTrigPicIntervalSecond;       // 报警触发后每次抓图时间间隔时间 单位秒
    BYTE             byRserved[256];                // 保留字节
} DHDEV_SNAP_CFG_EX;


//车载wifi状态
typedef struct  
{
    char            szSSID[128];                    //SSID
    BOOL            bEnable;                        //是否启用wifi功能, 0:不使能 1:使能
    int             nSafeType;                      //校验类型
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int             nEncryprion;                    //加密方式
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(不校验)
                                                    //5:AUTO
                                                    //6:SHARED
    int             nStrength;                      //AP站点信号
    char            szHostIP[128];                  //主机地址
    char            szHostNetmask[128];             //主机掩码
    char            szHostGateway[128];             //主机网关
    int             nPriority;                      //优先级,(1-32)
    int             nEnDHCP;                        //0：不使能; 1：使能(扫描到的dhcp默认使能打开)
    BYTE            bReserved[1016];
} DHDEV_VEHICLE_WIFI_STATE;

typedef struct
{
    char            szSSID[128];                    //SSID
    int             nPriority;                      //优先级,(1-32)
    int             nSafeType;                      //校验类型
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int             nEncryprion;                    //加密方式
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(不校验)
                                                    //5:AUTO
                                                    //6:SHARED
    char            szKey[128];                     //连接密钥
    char            szHostIP[128];                  //主机地址
    char            szHostNetmask[128];             //主机掩码
    char            szHostGateway[128];             //主机网关
    int             nEnDHCP;                        //0：不使能; 1：使能(扫描到的dhcp默认使能打开)
    BYTE            byKeyIndex;                     //WEP校验类型下的密钥索引,0：不支持密钥索引 >0:密钥索引值,范围1-4
    BYTE            bReserved[1019];
} DHDEV_VEHICLE_WIFI_CONFIG;

typedef struct
{
    char    szSSID[128];                            // SSID   
    BYTE    bReserved[256];                         // 保留字节
}WIFI_CONNECT;

// IP修改配置
typedef struct __DHCTRL_IPMODIFY_PARAM
{
    int             nStructSize;
    char            szRemoteIP[DH_MAX_IPADDR_OR_DOMAIN_LEN];        // 前端设备IP
    char            szSubmask[DH_MAX_IPADDR_LEN];                   // 子网掩码
    char            szGateway[DH_MAX_IPADDR_OR_DOMAIN_LEN];         // 网关
    char            szMac[DH_MACADDR_LEN];                          // MAC地址
    char            szDeviceType[DH_DEV_TYPE_LEN];                  // 设备类型
}DHCTRL_IPMODIFY_PARAM;

typedef struct 
{
    BOOL        bIsScan;                            //0:非扫描wifi (手动添加的), 1扫描到的wifi
    char        szSSID[128];                        //SSID
    int         nSafeType;                          //校验类型
                                                    //0:OPEN 
                                                    //1:RESTRICTE
                                                    //2:WEP
                                                    //3:WPA
                                                    //4:WPA2
                                                    //5:WPA-PSK
                                                    //6:WPA2-PSK
    int        nEncryprion;                         //加密方式
                                                    //0:OPEN
                                                    //1:TKIP
                                                    //2:WEP
                                                    //3:AES
                                                    //4:NONE(不校验)
                                                    //5:AUTO
                                                    //6:SHARED
    char        szKey[128];                         //连接密钥
    int         nStrength;                          //AP站点信号
    int         nMaxBitRate;                        //AP站点的最大传输速率,带单位 只读
    int         nIsCnnted;                          //是否连接成功只读
    int         nIsSaved;                           //是否已经保存只读
    int         nPriority;                          //优先级,(1-32)
    char        szHostIP[128];                      //主机地址
    char        szHostNetmask[128];                 //主机掩码
    char        szHostGateway[128];                 //主机网关
    int         nWifiFreq;                          //无线频率,采用通道标识
    int         nEnDHCP;                            //0：不使能 1：使能(扫描到的dhcp默认使能打开)
    BYTE        byKeyIndex;                         //WEP校验类型下的密钥索引,0：不支持密钥索引 >0:密钥索引值,范围1-4
    BYTE        bReserved[1019];
}DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG;

typedef struct 
{
    BOOL        bEnable;                            //是否启用wifi功能, 0:不使能 1:使能
    int         nWifiApNum;                         //DHDEV_VEHICLE_WIFI_AP_CFG结构体有效个数
    DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG struWifiAp[64];//单个WIFI AP配置
    int         nReserved[512];                     //保留
}DHDEV_VEHICLE_WIFI_AP_CFG;

typedef struct  
{    
    BOOL        bEnable;                            //是否启用wifi功能, 0:不使能 1:使能
    int         nRetWifiApNum;                      //解析得到的DHDEV_VEHICLE_WIFI_AP_CFG结构体有效个数
    int         nMaxWifiApNum;                      //申请的DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG个数
    DHDEV_VEHICLE_SINGLE_WIFI_AP_CFG* pWifiAp;      //单个WIFI AP配置
    int         nReserved[512];                     //保留
}DHDEV_VEHICLE_WIFI_AP_CFG_EX;

// GPS日志信息结构体
typedef struct _DH_DEVICE_GPS_LOG_ITEM
{
    DHDEVTIME       stuDevTime;             // 设备时间  
    DWORD           dwLatidude;             // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
    DWORD           dwLongitude;            // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
                                            // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    DWORD           dwSpeed;                // 速度,单位是海里,speed/1000*1.852公里/小时
    DWORD           dwHight;                // 高度,米
    DWORD           dwAngle;                // 方向,角度0~360,正北方向为原点,顺时针为正
    DHDEVTIME       stuGpsTime;             // GPS时间
    BYTE            bAntStatus;             // GPS天线状态,为0表示好;不为0表示异常 
    BYTE            bOriStatus;             // 定位状态,不为0表示定位成功
    BYTE            bSatCount;              // 卫星数量
    BYTE            bGPSStatus;             // GPS状态,0,未定位 1,无差分定位信息 2,带差分定位信息
    DWORD           dwTemp;                 // 温度值(摄氏度),实际值的1000倍,如30.0摄氏度表示为30000
    DWORD           dwHumidity;             // 湿度值(%),实际值的1000倍,如30.0%表示为30000
    BYTE            bReserved[24];          // 保留字节
    
}DH_DEVICE_GPS_LOG_ITEM;

// GPS 日志查询参数结构体
typedef struct _QUERY_GPS_LOG_PARAM
{
    NET_TIME            stuStartTime;               // 查询日志的开始时间
    NET_TIME            stuEndTime;                 // 查询日志的结束时间
    int                 nStartNum;                  // 在时间段中从第几条日志开始查询,开始第一次查询可设为0
    BYTE                bReserved[20];
} QUERY_GPS_LOG_PARAM;

typedef struct _GPS_TEMP_HUMIDITY_INFO
{
    double              dTemperature;               // 温度值(摄氏度),实际值的1000倍,如30.0摄氏度表示为30000
    double              dHumidity;                  // 湿度值(%),实际值的1000倍,如30.0%表示为30000
    BYTE                bReserved[128];             // 保留字节
}GPS_TEMP_HUMIDITY_INFO;

// 电子围栏类型枚举
typedef enum
{
    ENCLOSURE_UNKNOWN = 0x00,                       // 未知
    ENCLOSURE_LIMITSPEED = 0x01,                    // 限速区
    ENCLOSURE_DRIVEALLOW = 0x02,                    // 驾驶区
    ENCLOSURE_FORBIDDRIVE = 0x04,                   // 禁止区
    ENCLOSURE_LOADGOODS = 0x08,                     // 装货区
    ENCLOSURE_UPLOADGOODS = 0x10,                   // 卸货区
    ENCLOSURE_FLYALLOW = 0x20,                      // 飞行区
    ENCLOSURE_MANUALFORBIDFLY = 0x40,               // 禁飞区(手动设置)
    ENCLOSURE_FIXEDFORBIDFLY = 0x80,                // 禁飞区(机场) - 不可配置
    ENCLOSURE_FiXEDLIMITFLY = 0x81,                 // 限制飞行 - 不可配置
}ENCLOSURE_TYPE;

typedef enum
{
     ENCLOSURE_ALARM_DRIVEIN ,                      // 驶入
     ENCLOSURE_ALARM_DRIVEOUT,                      // 驶出
     ENCLOSURE_ALARM_OVERSPEED,                     // 超速
     ENCLOSURE_ALARM_SPEEDCLEAR,                    // 超速消失
     ENCLOSURE_ALARM_FLYNEAR,                       // 飞行靠近
}ENCLOSURE_ALARM_TYPE;

typedef struct 
{
    DWORD         dwLongitude;                      // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
    DWORD         dwLatidude;                       // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
                                                    // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
}GPS_POINT;

// 电子围栏配置
typedef struct _DHDEV_ENCLOSURE_CFG
{
    UINT          unType;                              // 电子围栏类型掩码,见 ENCLOSURE_TYPE 
    BYTE          bRegion[8];                          // 前四位分别代表国家、省、市或区、县(0-255),后4bytes保留
    UINT          unId;                                // 一个区域以一个ID标识
    UINT          unSpeedLimit;                        // 限速,单位km/h
    UINT          unPointNum;                          // 电子围栏区域顶点数
    GPS_POINT     stPoints[128];                       // 电子围栏区域信息
    char          szStationName[DH_STATION_NAME_LEN];  // 电子围栏包围的车站站点名称
    BYTE          bDisenable;                          // 去使能。 0 启用 ;1 不启用
    BYTE          bShape;                              // 围栏形状 0 多边形 1 圆形；
    BYTE          bLimitType;                          // 围栏限制类型 0 无; 1 限高; 2 限半径; 3 限高限半径
    BYTE          bAction;                             // 触发围栏后，设备的动作；0 无,兼容以前; 1 只报告; 2 悬停; 3 返航;
    int           nLimitAltitude;                      // 高度 单位：厘米。 0 无效
    int           nAlarmAltitude;                      // 预警高度单位：厘米。 0 无效
    UINT          unLimitRadius;                       // 半径单位：厘米。0 无效
    UINT          unAlarmRadius;                       // 预警半径：厘米。0 无效
    BYTE          reserved[12];                        // 保留
}DHDEV_ENCLOSURE_CFG;

// 电子围栏版本号配置
typedef struct _DHDEV_ENCLOSURE_VERSION_CFG
{
    UINT          unType;                              // 围栏类型掩码,如LIMITSPEED | DRIVEALLOW
    UINT          unVersion[32];                       // 每个类型一个版本号,用于统一平台与设备上的围栏配置
    int           nReserved;                           // 保留    
}DHDEV_ENCLOSURE_VERSION_CFG;

// 电子围栏报警
typedef struct __ALARM_ENCLOSURE_INFO
{
    int           nTypeNumber;                          // 有效电子围栏类型个数
    BYTE          bType[16];                            // 电子围栏类型, 见 ENCLOSURE_TYPE
    int           nAlarmTypeNumber;                     // 有效报警类型个数
    BYTE          bAlarmType[16];                       // 报警类型,见ENCLOSURE_ALARM_TYPE
    char          szDriverId[DH_VEHICLE_DRIVERNO_LEN];  // 司机工号
    UINT          unEnclosureId;                        // 电子围栏ID
    UINT          unLimitSpeed;                         // 限速,单位km/h
    UINT          unCurrentSpeed;                       // 当前速度
    NET_TIME      stAlarmTime;                          // 报警发生时间
    DWORD         dwLongitude;                          // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
    DWORD         dwLatidude;                           // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
                                                        // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
    BYTE          bOffline;                             // 0-实时 1-补传 
    UINT          unTriggerCount;                       // 围栏触发次数
    BYTE          byReserved[115];                      // 保留字节
}ALARM_ENCLOSURE_INFO;

// RAID异常信息
#define DH_MAX_RAID_NUM  16
#define DH_MAX_RAID_DEVICE_NAME 16
typedef struct __RAID_STATE_INFO
{
    char          szName[16];                           // Raid名称
    BYTE          byType;                               // 类型 1:Jbod     2:Raid0      3:Raid1     4:Raid5
    BYTE          byStatus;                             // 状态 0:unknown ,1:active,2:degraded,3:inactive,4:recovering
    BYTE          byReserved[2];
    int           nCntMem;                              // nMember数组的有效数据个数
    int           nMember[32];                          // 1,2,3,... 组成磁盘通道,是个数组
    int           nCapacity;                            // 容量,单位G
    int           nRemainSpace;                         // 剩余容量,单位M
    int           nTank;                                // 扩展柜 0:主机,1:扩展柜1,2:扩展柜2,……
    char          reserved[32];
}RAID_STATE_INFO;

typedef struct __ALARM_RAID_INFO
{
    int              nRaidNumber;                       // 上报的RAID个数   
    RAID_STATE_INFO  stuRaidInfo[DH_MAX_RAID_NUM];      // 异常的RAID信息
    char             reserved[128];
}ALARM_RAID_INFO;

// RAID错误类型
typedef enum tagEM_RAID_ERROR
{
	EM_RAID_ERROR_UNKNOW,                                        // 未知
	EM_RAID_ERROR_FAILED,                                        // RAID错误
	EM_RAID_ERROR_DEGRADED,                                      // RAID降级
} EM_RAID_ERROR;

// 故障子盘状态
typedef enum tagEM_RAID_ERR_SUBDISK
{
    EM_RAID_ERR_SUBDISK_UNKNOWN,                                // 未知
        EM_RAID_ERR_SUBDISK_OFFLINE,                            // 离线
        EM_RAID_ERR_SUBDISK_FAULTY,                             // 异常
        EM_RAID_ERR_SUBDISK_WRITEERR,                           // 写错误
} EM_RAID_ERR_SUBDISK;

// 故障子盘详细信息
typedef struct tagNET_RAID_ERR_DETAIL_INFO
{
    DWORD                 dwSlotNum;                            // 子盘槽位号
    EM_RAID_ERR_SUBDISK   emErrSubDisk;                         // 子盘状态
    BYTE                  byReserved[24];                       // 保留
}NET_RAID_ERR_DETAIL_INFO;

// 新RAID异常信息 对应DH_ALARM_RAID_STATE_EX报警
typedef struct tagALARM_RAID_INFO_EX
{
	DWORD                nAction;                               // 0-开始, 1-停止
	char                 szDevice[DH_MAX_RAID_DEVICE_NAME];     // 设备名称
	EM_RAID_ERROR        emErrorType;                           // 错误类型
    int                  nDetailNum;                            // 有效的故障子盘个数
    NET_RAID_ERR_DETAIL_INFO stuErrDetail[16];                  // 故障子盘详细信息
	BYTE                 byReserved[508];                       // 保留
}ALARM_RAID_INFO_EX;

// IPC的存储介质故障事件(SD卡异常)结构体 对应 DH_ALARM_STORAGE_IPC_FAILURE 报警
typedef struct tagALARM_STORAGE_IPC_FAILURE_INFO
{
    int                  nAction;                               // 0:开始 1:停止
    int                  nChannelID;                            // 发生报警的通道号
    BYTE                 byReserved[1024];                      // 保留字节
}ALARM_STORAGE_IPC_FAILURE_INFO;

// 静止报警,如果设备坐标在指定时间内没有变化，触发静止报警信息对应 DH_ALARM_DEVICE_STAY
typedef struct tagALARM_DEVICE_STAY_INFO
{
	int					nAction;								// 0:开始 1:停止
	int					nChannelID;								// 发生报警的通道号
	BYTE				byReserved[1024];						// 保留字节
}ALARM_DEVICE_STAY_INFO;

// 地铁车厢门状态类型
typedef enum tagEM_SUB_WAY_DOOR_STATE_TYPE
{
    EM_SUB_WAY_DOOR_STATE_TYPE_UNKNOWN,     // 未知的
    EM_SUB_WAY_DOOR_STATE_TYPE_LOST,        // 状态丢失
    EM_SUB_WAY_DOOR_STATE_TYPE_ISOLATION,   // 隔离
    EM_SUB_WAY_DOOR_STATE_TYPE_UNLOCK,      // 解锁
    EM_SUB_WAY_DOOR_STATE_TYPE_NORMAL,      // 正常
}EM_SUB_WAY_DOOR_STATE_TYPE;

// 地铁车厢号类型
typedef enum tagEM_SUB_WAY_CARRIAGE_NUMBER_TYPE
{
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_UNKNOWN, // 未知的
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC1,     // TC1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M1,      // M1
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_M2,      // M2
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE_TC2,     // TC2
}EM_SUB_WAY_CARRIAGE_NUMBER_TYPE;

// 地铁车厢门状态 对应 DH_ALARM_SUB_WAY_DOOR_STATE 报警
typedef struct tagALARM_SUB_WAY_DOOR_STATE_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nDoorNumber;         // 门号   
    EM_SUB_WAY_DOOR_STATE_TYPE          emDoorState;         // 状态
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_DOOR_STATE_INFO;

// 地铁PECE柜门状态 对应 DH_ALARM_SUB_WAY_PECE_SWITCH 报警
typedef struct tagALARM_SUB_WAY_PECE_SWITCH_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nDoorNumber;         // 门号
    int                                 nState;              // 状态，1表示打开，0表示关闭,其他值表示未知
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_PECE_SWITCH_INFO;

// 地铁火警事件 对应 DH_ALARM_SUB_WAY_FIRE_ALARM 报警
typedef struct tagALARM_SUB_WAY_FIRE_ALARM_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nSourceNumber;       // 火警源号
    BOOL                                bState;              // 状态，TRUE表示有火警，FALSE表示无火警    
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_FIRE_ALARM_INFO;

// 地铁乘客紧急手柄动作 对应 DH_ALARM_SUB_WAY_EMER_HANDLE 报警
typedef struct tagALARM_SUB_WAY_EMER_HANDLE_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    BOOL                                bState;              // 状态，TRUE表示有动作，FALSE表示无动作
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_EMER_HANDLE_INFO;

// 地铁司机室盖板状态 对应 DH_ALARM_SUB_WAY_CAB_COVER 报警
typedef struct tagALARM_SUB_WAY_CAB_COVER_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nState;              // 状态，1表示打开，0表示关闭,其他值表示未知
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_CAB_COVER_INFO;

// 地铁检测到障碍物或脱轨 对应 DH_ALARM_SUB_WAY_DERA_OBST 报警
typedef struct tagALARM_SUB_WAY_DERA_OBST_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    BOOL                                bState;              // 状态，TRUE表示检测到障碍物或脱轨，FALSE表示未检测到障碍物或脱轨
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_DERA_OBST_INFO;

// 地铁客室报警器状态 对应 DH_ALARM_SUB_WAY_PECU_CALL 报警
typedef struct tagALARM_SUB_WAY_PECU_CALL_INFO
{
    int                                 nAction;             // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nCallNumber;         // 报警器号
    BOOL                                bState;              // 状态，TRUE表示报警，FALSE表示无报警
    EM_SUB_WAY_CARRIAGE_NUMBER_TYPE     emCarriageNumber;    // 车厢号
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_SUB_WAY_PECU_CALL_INFO;

// 人为关门结构体对应 DH_ALARM_DOOR_CLOSEDMANUALLY 报警
typedef struct tagALARM_DOOR_CLOSEDMANUALLY_INFO
{
    int                                 nAction;             // 事件动作，-1未知1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nDoor;               // 门通道号
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; // 门禁名称
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_DOOR_CLOSEDMANUALLY_INFO;

// 门超长时间未关对应 DH_ALARM_DOOR_NOTCLOSED_LONGTIME 报警
typedef struct tagALARM_DOOR_NOTCLOSED_LONGTIME_INFO
{
    int                                 nAction;             // 事件动作，-1未知1表示持续性事件开始,2表示持续性事件结束
    int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    int                                 nDoor;               // 门通道号
    char                                szDoorName[DH_MAX_DOORNAME_LEN]; // 门禁名称
    BYTE                                byReserved[1024];    // 保留字节
}ALARM_DOOR_NOTCLOSED_LONGTIME_INFO;

// 剪断报警信息，对应DH_ALARM_CUT_LINE报警
typedef struct tagALARM_CUT_LINE_INFO
{
	int									nChannel;			 // 通道号
	int                                 nAction;             // 事件动作，-1表示未知动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    BYTE                                byReserved[1024];    // 保留字节
} ALARM_CUT_LINE_INFO;

// 断纤报警信息，对应 DH_ALARM_FIBRE_OPTIC_ABORT 报警     
typedef struct tagALARM_FIBRE_OPTIC_ABORT       
{     
	int                                 nAlarmIn;            // 报警输入号           
	int                                 nAction;             // 事件动作,1表示持续性事件开始,2表示持续性事件结束;       
	NET_TIME_EX                         UTC;                 // 事件发生的时间       
	BYTE                                byReserved[1024];    // 保留字节       
}ALARM_FIBRE_OPTIC_ABORT; 

//尾随报警事件信息，对应 DH_ALARM_TAIL_DETECTION 报警
typedef struct tagALARM_TAIL_DETECTION_INFO       
{     
	int									nAction;						// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int									nChannelID;						// 通道号
    double								dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX							stuTime;						// 事件发生的时间
    int									nEventID;						// 事件ID
	BYTE                				byReserved[1024];   			// 保留字节     
}ALARM_TAIL_DETECTION_INFO; 

// 近距离接触报警信息，对应DH_ALARM_NEAR_DISTANCE_DETECTION 报警
typedef struct tagALARM_NEAR_DISTANCE_INFO
{
	int									nChannel;			 // 通道号
	int                                 nAction;             // 事件动作,1表示持续性事件开始,2表示持续性事件结束;       
	int					                nEventID;			 // 事件ID
    double				                dbPTS;			     // 时间戳(单位是毫秒)
    NET_TIME_EX			                stuTime;			 // 事件发生的时间
    BYTE                                byReserved[1024];    // 保留字节
} ALARM_NEAR_DISTANCE_INFO; 


// 立体视觉站立事件区域内人员列表
typedef struct tagMAN_STAND_LIST_INFO
{
	DH_POINT			stuCenter;			// 站立人员所在位置,8192坐标系
	char                szReversed[128];    // 保留字节
} MAN_STAND_LIST_INFO;

// 立体视觉站立报警信息，对应DH_ALARM_MAN_STAND_DETECTION 报警
typedef struct tagALARM_MAN_STAND_INFO
{
	int							nChannel;			 		// 通道号
	int                         nAction;             		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;       
	int					        nEventID;			 		// 事件ID
    double				        dbPTS;			     		// 时间戳(单位是毫秒)
    NET_TIME_EX			        stuTime;			 		// 事件发生的时间

	int							nManListCount;				// 区域人员列表数量
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// 区域内人员列表
    BYTE                        byReserved[1024];    		// 保留字节
} ALARM_MAN_STAND_INFO;

// 立体视觉区域内人数统计事件区域人员列表
typedef struct tagMAN_NUM_LIST_INFO
{
	DH_RECT				stuBoudingBox;			// 人员包围盒,8192坐标系
	int					nStature;				// 人员身高，单位cm
	char                szReversed[128];    	// 保留字节
} MAN_NUM_LIST_INFO;


// 立体视觉区域内人数统计报警，对应DH_ALARM_MAN_NUM_DETECTION 报警
typedef struct tagALARM_MAN_NUM_INFO
{
	int							nChannel;			 		// 通道号
	int                         nAction;             		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;       
	int					        nEventID;			 		// 事件ID
    double				        dbPTS;			     		// 时间戳(单位是毫秒)
    NET_TIME_EX			        stuTime;			 		// 事件发生的时间
    int							nManListCount;				// 区域人员列表数量
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// 区域内人员列表
    BYTE                        byReserved[1024];    		// 保留字节
} ALARM_MAN_NUM_INFO;
//相机码流大于通道解码规格报警信息，对应DH_ALARM_BITRATES_OVERLIMIT 报警 
typedef struct tagALARM_BITRATES_OVERLIMIT_INFO        
{      
	int                                 nChannel;                       // 视频通道号            
	int                                 nAction;                        // 事件动作,1表示报警开始,2表示报警结束;   
	int                                 nLimitBps;                      // 限制码率，单位Kbps 
	int                                 nCurrentBps;                    // 当前码率，单位Kbps  
	BYTE                                byReserved[1024];               // 保留字节    
}ALARM_BITRATES_OVERLIMIT_INFO;  

//声音高分贝检测报警信息，对应 DH_ALARM_HIGH_DECIBEL 报警
typedef struct tagALARM_HIGH_DECIBEL_INFO
{
	int                                 nAudioChannel;                  // 音频通道号 
	int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;
	NET_TIME_EX                         stuTime;                        // 事件发生的时间
    BYTE                                byReserved[1024];               // 保留字节
}ALARM_HIGH_DECIBEL_INFO;

//摇晃检测报警信息，对应 DH_ALARM_SHAKE_DETECTION 报警
typedef struct tagALARM_SHAKE_DETECTION_INFO
{          
	int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;   
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
	BYTE                                byReserved[1024];               // 保留字节    
}ALARM_SHAKE_DETECTION_INFO;

// 控制方式
typedef enum tagNET_ACCESS_METHOD
{
    NET_ACCESS_METHOD_UNKNOWN,                                          // 未知
    NET_ACCESS_METHOD_CARD,                                             // 卡
    NET_ACCESS_METHOD_PASSWORD,                                         // 密码
    NET_ACCESS_METHOD_FINGERPRINT,                                      // 指纹 
} NET_ACCESS_METHOD;

//恶意开门事件， 对应 DH_ALARM_ACCESS_CTL_MALICIOUS
typedef struct tagALARM_ACCESS_CTL_MALICIOUS
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;   
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
    NET_ACCESS_METHOD                   emMethod;                       // 开门方式
    char                                szSerialNum[MAX_COMMON_STRING_32];     // 无线配件序列号
	int									nChannel;						// 门通道号
	BYTE                                byReserved[1020];               // 保留字节  
}ALARM_ACCESS_CTL_MALICIOUS;

// 用户已注册事件, 对应 DH_ALARM_ACCESS_CTL_USERID_REGISTER
typedef struct tagALARM_ACCESS_CTL_USERID_REGISTER
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;   
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
    char                                UserID[DH_USER_NAME_LEN_EX];    // 用户名
    NET_ACCESS_METHOD                   emMethod;                       // 注册方式
    char                                szSerialNum[MAX_COMMON_STRING_32];  // 智能锁序列号
	BYTE                                byReserved[1024];               // 保留字节 
}ALARM_ACCESS_CTL_USERID_REGISTER;

// 上锁方式
typedef enum tagNET_ACCESS_CTL_LOCKTYPE
{
    NET_ACCESS_CTL_LOCKTYPE_UNKNOWN,                                    // 未知
    NET_ACCESS_CTL_LOCKTYPE_DEADBOLT,                                   // 方舌
    NET_ACCESS_CTL_LOCKTYPE_STAYBOLT,                                   // 呆舌
}NET_ACCESS_CTL_LOCKTYPE;

// 锁体信息上报事件, 对应 DH_ALARM_ACCESS_CTL_REVERSELOCK
typedef struct tagALARM_ACCESS_CTL_REVERSELOCK
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;   
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
    BOOL                                bStatus;                        // 上锁结果
    NET_ACCESS_CTL_LOCKTYPE             emMethod;                       // 上锁方式
    char                                szSerialNum[MAX_COMMON_STRING_32];     // 智能锁序列号
	BYTE                                byReserved[1024];               // 保留字节 
}ALARM_ACCESS_CTL_REVERSELOCK;

// 删除用户上报事件, 对应 DH_ALARM_ACCESS_CTL_USERID_DELETE
typedef struct tagALARM_ACCESS_CTL_USERID_DELETE
{
    int                                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;   
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
    NET_ACCESS_METHOD                   emMethod;                       // 注册方式
    char                                szSerialNum[MAX_COMMON_STRING_32];     // 智能锁序列号
	BYTE                                byReserved[1024];               // 保留字节 
}ALARM_ACCESS_CTL_USERID_DELETE;

//事件类型DH_ALARM_ACCESS_DOOR_BELL(响铃事件)对应的数据描述信息
typedef struct tagALARM_ACCESS_DOOR_BELL_INFO
{
	int 					nChannelID; 								// 通道号
	NET_TIME_EX       		stuTime;									// 事件发生的UTC 时间
	char                    szName[DH_MAX_NAME_LEN];     				// 门禁名称
	char                    szWirelessDevSN[DH_MAX_ACCESS_NAME_LEN];	// 无线设备序列号
	BYTE			        bReserved[512];				        		// 保留字节
}ALARM_ACCESS_DOOR_BELL_INFO;

//事件类型DH_ALARM_ACCESS_FACTORY_RESET(门锁恢复出厂设置)对应的描述信息
typedef struct tagALARM_ACCESS_FACTORY_RESET_INFO
{					
	NET_TIME_EX   		    stuTime;								// 事件发生的UTC 时间
	char                    szSmartLockSN[DH_MAX_ACCESS_NAME_LEN];	// 智能锁序列号
	BYTE			        bReserved[512];				        	// 保留字节
}ALARM_ACCESS_FACTORY_RESET_INFO;


// 柜门开关动作类型
typedef enum tagEM_NET_CABINET_SWITCH_ACTION_TYPE
{
    NET_CABINET_SWITCH_ACTION_TYPE_UNKNOWN,							// 未知
	NET_CABINET_SWITCH_ACTION_TYPE_OPEN,							// 开柜门
	NET_CABINET_SWITCH_ACTION_TYPE_CLOSE,							// 关柜门
} EM_NET_CABINET_SWITCH_ACTION_TYPE;

// 存放设备关联的视频监控通道最大数量
#define MAX_LINK_CHANNEL_NUMBER		16

// 云柜设备发送的物品存放单号信息实时上报事件(DH_ALARM_CABINET)
typedef struct tagALARM_CABINET_INFO
{
    int									nAction;                                // 0:Pulse,1:Start,2:Stop,3:State
	NET_TIME_EX							stuTime;								// 事件发生的时间
	EM_NET_CABINET_SWITCH_ACTION_TYPE	emType;									// 柜门开关动作类型
	char								szSerialNo[MAX_COMMON_STRING_32];		// 物品序列号
	int									nLinkChannelNum;						// 存放设备关联的视频监控通道数量
	int									nLinkChannel[MAX_LINK_CHANNEL_NUMBER];	// 存放设备关联的视频监控通道
    BYTE								byReserved[1024];                       // 保留 
} ALARM_CABINET_INFO;

//事件类型DH_SWITCH_SCREEN (切换屏幕事件 )对应的描述信息
typedef struct tagDH_SWITCH_SCREEN_INFO
{
	
	int              nChannelID;                                    //通道号
	
	BYTE             bReserved[512];                               
	
}DH_SWITCH_SCREEN_INFO;

#define MAX_EVENT_INFO_LEN			128          // 事件详细信息最大长度

// 微云常规容量事件信息, 对应 DH_MCS_GENERAL_CAPACITY_LOW
typedef struct tagALARM_MCS_GENERAL_CAPACITY_LOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_GENERAL_CAPACITY_LOW_INFO;

// 微云存储节点下线事件信息, 对应 DH_MCS_DATA_NODE_OFFLINE
typedef struct tagALARM_MCS_DATA_NODE_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DATA_NODE_OFFLINE_INFO;

// 微云磁盘下线事件信息, 对应 DH_MCS_DISK_OFFLINE
typedef struct tagALARM_MCS_DISK_OFFLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DISK_OFFLINE_INFO;

// 微云磁盘变慢事件信息, 对应 DH_MCS_DISK_SLOW
typedef struct tagALARM_MCS_DISK_SLOW_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DISK_SLOW_INFO;

// 微云磁盘损坏事件信息, 对应 DH_MCS_DISK_BROKEN
typedef struct tagALARM_MCS_DISK_BROKEN_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DISK_BROKEN_INFO;

// 微云磁盘未知错误事件信息, 对应 DH_MCS_DISK_UNKNOW_ERROR
typedef struct tagALARM_MCS_DISK_UNKNOW_ERROR_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DISK_UNKNOW_ERROR_INFO;

// 微云元数据服务器异常事件信息, 对应 DH_MCS_METADATA_SERVER_ABNORMAL
typedef struct tagALARM_MCS_METADATA_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_METADATA_SERVER_ABNORMAL_INFO;

// 微云目录服务器异常事件信息, 对应 DH_MCS_CATALOG_SERVER_ABNORMAL
typedef struct tagALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_CATALOG_SERVER_ABNORMAL_INFO;

// 微云常规容量恢复事件信息信息, 对应 DH_MCS_GENERAL_CAPACITY_RESUME
typedef struct tagALARM_MCS_GENERAL_CAPACITY_RESUME_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_GENERAL_CAPACITY_RESUME_INFO;

// 微云存储节点上线事件信息, 对应 DH_MCS_DATA_NODE_ONLINE
typedef struct tagALARM_MCS_DATA_NODE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DATA_NODE_ONLINE_INFO;

// 微云磁盘上线事件信息, 对应 DH_MCS_DISK_ONLINE
typedef struct tagALARM_MCS_DISK_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_DISK_ONLINE_INFO;

// 微云元数据备机上线事件信息, 对应 DH_MCS_METADATA_SLAVE_ONLINE
typedef struct tagALARM_MCS_METADATA_SLAVE_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_METADATA_SLAVE_ONLINE_INFO;

// 微云目录服务器上线事件, 对应 DH_MCS_CATALOG_SERVER_ONLINE
typedef struct tagALARM_MCS_CATALOG_SERVER_ONLINE_INFO
{
	char		szEventInfo[MAX_EVENT_INFO_LEN];			// 事件详细信息 
	BYTE		byReserved[1024];							// 保留字节
}ALARM_MCS_CATALOG_SERVER_ONLINE_INFO;

//////////////////////////////////ATM支持//////////////////////////////////

typedef struct
{
    int           Offset;                               // 标志位的位偏移
    int           Length;                               // 标志位的长度
    char          Key[16];                              // 标志位的值
} DH_SNIFFER_FRAMEID;

typedef struct 
{
    int           Offset;                       // 标志位的位偏移
    int           Offset2;                      // 目前没有应用
    int           Length;                       // 标志位的长度
    int           Length2;                      // 目前没有应用
    char          Title[12];                    // 标题的值
    char          Key[12];                      // 关键字的值
} DH_SNIFFER_CONTENT;

// 网络抓包配置
typedef struct 
{
    DH_SNIFFER_FRAMEID    snifferFrameId;                           // 每个FRAME ID 选项
    DH_SNIFFER_CONTENT    snifferContent[DH_SNIFFER_CONTENT_NUM];   // 每个FRAME对应的4个抓包内容
} DH_SNIFFER_FRAME;

// 每组抓包对应的配置结构
typedef struct
{
    char                SnifferSrcIP[DH_MAX_IPADDR_LEN];        // 抓包源地址        
    int                 SnifferSrcPort;                         // 抓包源端口
    char                SnifferDestIP[DH_MAX_IPADDR_LEN];       // 抓包目标地址
    int                 SnifferDestPort;                        // 抓包目标端口
    char                reserved[28];                           // 保留字段
    DH_SNIFFER_FRAME    snifferFrame[DH_SNIFFER_FRAMEID_NUM];   // 6个FRAME 选项
    int                 displayPosition;                        // 显示位置
    int                 recdChannelMask;                        // 通道掩码
} DH_ATM_SNIFFER_CFG;

typedef struct  
{
    DWORD               dwSize;
    DH_ATM_SNIFFER_CFG  SnifferConfig[4];
    char                reserved[256];                          // 保留字段
} DHDEV_SNIFFER_CFG;

typedef DH_SNIFFER_FRAMEID DH_SNIFFER_FRAMEID_EX;
typedef DH_SNIFFER_CONTENT DH_SNIFFER_CONTENT_EX;

// 网络抓包配置
typedef struct  
{
    DH_SNIFFER_FRAMEID    snifferFrameId;                               // 每个FRAME ID 选项
    DH_SNIFFER_CONTENT    snifferContent[DH_SNIFFER_CONTENT_NUM_EX];    // 每个FRAME对应的8个抓包内容    
} DH_SNIFFER_FRAME_EX;

// 每组抓包对应的配置结构
typedef struct
{
    char                SnifferSrcIP[DH_MAX_IPADDR_LEN];                // 抓包源地址        
    int                 SnifferSrcPort;                                 // 抓包源端口
    char                SnifferDestIP[DH_MAX_IPADDR_LEN];               // 抓包目标地址
    int                 SnifferDestPort;                                // 抓包目标端口
    DH_SNIFFER_FRAME_EX snifferFrame[DH_SNIFFER_FRAMEID_NUM];           // 6个FRAME 选项
    int                 displayPosition;                                // 显示位置
    int                 recdChannelMask;                                // 通道掩码  0  ~ 31 通道
    BOOL                bDateScopeEnable;                               // 数据来源使能
    BOOL                bProtocolEnable;                                // 协议使能
    char                szProtocolName[DH_SNIFFER_PROTOCOL_SIZE];       // 协议名字
    int                 nSnifferMode;                                   // 抓包方式,0:net,1:232.
    int                 recdChannelMask1;                               // 通道掩码  32 ~ 63 通道
    char                reserved[252];
} DH_ATM_SNIFFER_CFG_EX;

// Atm交易类型查询返回结构体
#define ATM_MAX_TRADE_TYPE_NAME    64
#define ATM_MAX_TRADE_NUM        1024

typedef struct __DH_ATM_QUERY_TRADE   
{
    int  nTradeTypeNum;                                                     // 实际交易类型数量
    int  nExceptionTypeNum;                                                 // 实际异常事件数量
    char szSupportTradeType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];    // 交易事件名数组
    char szSupportExceptionType[ATM_MAX_TRADE_NUM][ATM_MAX_TRADE_TYPE_NAME];// 异常事件名数组
} DH_ATM_QUERY_TRADE, *LPDH_ATM_QUERY_TRADE;

/////////////////////////////////解码器支持/////////////////////////////////
#define nEncoderID nDecoderID
#define byEncoderID byDecoderID

// 解码器信息
typedef struct __DEV_DECODER_INFO 
{
    char            szDecType[64];                      // 类型
    int             nMonitorNum;                        // TV个数
    int             nEncoderNum;                        // 解码通道个数
    BYTE            szSplitMode[16];                    // 支持的TV画面分割数,以数组形式表示,0为结尾
    BYTE            bMonitorEnable[16];                 // 各TV使能
    BYTE            bTVTipDisplay;                      // 指示是否支持TV提示信息叠加设置, 0:不支持 1:支持.
    BYTE            reserved1[3];
    BYTE            byLayoutEnable[48];                 // 各解码通道显示叠加信息使能
    DWORD           dwLayoutEnMask[2];                  // 各解码通道显示叠加信息使能掩码,从低位到高位支持64个通道,其中dwLayoutEnMask[0]是低32位
    char            reserved[4];
} DEV_DECODER_INFO, *LPDEV_DECODER_INFO;

//#define NANJINGDITIE_NVD
#ifndef NANJINGDITIE_NVD
// 连接的编码器信息
typedef struct __DEV_ENCODER_INFO 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];             // 前端DVR的IP地址
    WORD            wDevPort;                               // 前端DVR的端口号
    BYTE            bDevChnEnable;                          // 解码通道使能
    BYTE            byDecoderID;                            // 该字段已废弃,后续开发请用 dwDecoderID
    char            szDevUser[DH_USER_NAME_LENGTH_EX];      // 用户名
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];        // 密码
    int             nDevChannel;                            // 通道号
    int             nStreamType;                            // 码流类型,0：主码流；1：辅码流1; 2:snap; 3: 辅码流2
    BYTE            byConnType;                             // -1: auto, 0：TCP；1：UDP；2：组播
    BYTE            byWorkMode;                             // 0：直连；1：转发
    WORD            wListenPort;                            // 指示侦听服务的端口,转发时有效
    DWORD           dwProtoType;                            // 协议类型,
                                                            // 0:兼容以前
                                                            // 1:大华二代协议
                                                            // 2:大华系统集成协议
                                                            // 3:大华DSS协议
                                                            // 4:大华rtsp协议
    char            szDevName[64];                          // 前端设备名称
    BYTE            byVideoInType;                          // 该解码通道当前视频源类型:0-标清(SD),1-高清(HD),注:设备支持高清通道才有效        
    char            szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp扩展,前端DVR的IP地址(可以输入域名)
    BYTE            bySnapMode;                             // 抓图模式(nStreamType==2时有效) 0：表示请求一帧,1：表示定时发送请求
    BYTE            byManuFactory;                          // 目标设备的生产厂商,具体参考EM_IPC_TYPE类
    BYTE            byDeviceType;                           // 目标设备的设备类型,0:IPC
    BYTE            byDecodePolicy;                         // 目标设备的解码策略,0:兼容以前
                                                            // 1:实时等级高 2:实时等级中
                                                            // 3:实时等级低 4:默认等级
                                                            // 5:流畅等级高 6:流畅等级中
                                                            // 7:流畅等级低
    BYTE            bReserved[3];                           // 保留字节
    DWORD           dwHttpPort;                             // Http端口号,0-65535
    DWORD           dwRtspPort;                             // Rtsp端口号,0-65535
    char            szChnName[32];                          // 远程通道名称, 只有读取到的名称不为空时才可以修改该通道的名称
    DWORD           dwDecoderID;                            // 对应解码通道号
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#else

// 连接的编码器信息
typedef struct __DEV_ENCODER_INFO 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];             // 前端DVR的IP地址
    WORD            wDevPort;                               // 前端DVR的端口号
    BYTE            bDevChnEnable;                          // 解码通道使能
    BYTE            byDecoderID;                            // 该字段已废弃,后续开发请用 dwDecoderID
    char            szDevUser[DH_USER_NAME_LENGTH_EX];      // 用户名
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];        // 密码
    int             nDevChannel;                            // 通道号
    int             nStreamType;                            // 码流类型,0：主码流；1：辅码流1; 2:snap; 3: 辅码流2
    BYTE            byConnType;                             // -1: auto, 0：TCP；1：UDP；2：组播
    BYTE            byWorkMode;                             // 0：直连；1：转发
    WORD            wListenPort;                            // 指示侦听服务的端口,转发时有效;byConnType为组播时,则作为多播端口
    DWORD           dwProtoType;                            // 协议类型,
                                                            // 0:兼容以前
                                                            // 1:大华二代协议
                                                            // 2:大华系统集成协议
                                                            // 3:大华DSS协议
                                                            // 4:大华rtsp协议
                                                            // 5:标准TS流
    char            szDevName[32];                          // 前端设备名称
    BYTE            byVideoInType;                          // 该解码通道当前视频源类型:0-标清(SD),1-高清(HD),注:设备支持高清通道才有效        
    char            szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp扩展,前端DVR的IP地址(可以输入域名)
    BYTE            bySnapMode;                             // 抓图模式(nStreamType==2时有效) 0：表示请求一帧,1：表示定时发送请求
    BYTE            byManuFactory;                          // 目标设备的生产厂商,具体参考EM_IPC_TYPE类
    BYTE            byDeviceType;                           // 目标设备的设备类型,0:IPC
    BYTE            byDecodePolicy;                         // 目标设备的解码策略,0:兼容以前
                                                            // 1:实时等级高 2:实时等级中
                                                            // 3:实时等级低 4:默认等级
                                                            // 5:流畅等级高 6:流畅等级中
                                                            // 7:流畅等级低
    BYTE            bReserved[3];                           // 保留字节
    DWORD           dwHttpPort;                             // Http端口号,0-65535
    DWORD           dwRtspPort;                             // Rtsp端口号,0-65535
    char            szChnName[32];                          // 远程通道名称, 只有读取到的名称不为空时才可以修改该通道的名称
    char            szMcastIP[DH_MAX_IPADDR_LEN];           // 多播IP地址,byConnType为组播时有效
    DWORD           dwDecoderID;                            // 对应解码通道号
    char            reserved[124];
} DEV_ENCODER_INFO, *LPDEV_ENCODER_INFO;

#endif

// 解码器rtsp url配置
typedef struct __DHDEV_DECODER_URL_CFG
{
    DWORD           dwSize;
    char            szMainStreamUrl[MAX_PATH];          // 主码流url
    char            szExtraStreamUrl[MAX_PATH];         // 辅码流url
} DHDEV_DECODER_URL_CFG;

typedef enum tagDH_SPLIT_DISPLAY_TYPE
{
    DH_SPLIT_DISPLAY_TYPE_GENERAL=1,          // 普通显示类型
    DH_SPLIT_DISPLAY_TYPE_PIP=2,              // 画中画显示类型
    DH_SPLIT_DISPLAY_TYPE_CUSTOM=3,           // 自由组合分割模式
} DH_SPLIT_DISPLAY_TYPE;

// CLIENT_CtrlDecTVScreen 接口参数
typedef struct tagDH_CTRL_DECTV_SCREEN
{
    DWORD           dwSize;                             // 结构体大小
    int             nSplitType;                         // 分割模式
    BYTE *          pEncoderChannel;                    // 显示通道,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_GENERAL时有效,由用户申请内存，调用者分配的内存长度不能小于nSplitType的大小
    BYTE            byGroupNo;                          // 输入通道组号,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_PIP时表示画中画显示类型下有效；
    char            reserved[3];                        // 保留字节
    DWORD           dwDisplayType;                      // 显示类型；具体见DH_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）
}DH_CTRL_DECTV_SCREEN;

// TV参数信息
typedef struct __DEV_DECODER_TV 
{
    int                 nID;                            // TV号
    BOOL                bEnable;                        // 使能,开启或关闭
    int                 nSplitType;                     // 画面分割数
    DEV_ENCODER_INFO    stuDevInfo[16];                 // 各画面编码器信息dwDisplayType=DH_SPLIT_DISPLAY_TYPE_GENERAL时有效
    BYTE                bySupportSplit[10];             // 支持的分割模式
    BYTE                byGroupNo;                      // 输入通道组号,dwDisplayType=DH_SPLIT_DISPLAY_TYPE_PIP时表示画中画显示类型下有效；
    char                reserved[1];                    // 保留字节
    DWORD               dwDisplayType;                  // 显示类型；具体见DH_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）
} DEV_DECODER_TV, *LPDEV_DECODER_TV;

// 解码器画面组合信息
typedef struct __DEC_COMBIN_INFO
{
    int             nCombinID;                          // 组合ID
    int             nSplitType;                         // 画面分割数 
    BYTE            bDisChn[16];                        // 显示通道
    char            reserved[16];
} DEC_COMBIN_INFO, *LPDEC_COMBIN_INFO;

// 解码器轮巡信息
#define DEC_COMBIN_NUM             32                   // 轮巡组合个数
typedef struct __DEC_TOUR_COMBIN 
{
    int             nTourTime;                          // 轮巡间隔(秒)
    int             nCombinNum;                         // 组合个数
    BYTE            bCombinID[DEC_COMBIN_NUM];          // 组合表
    char            reserved1[32];
    BYTE            bCombinState[DEC_COMBIN_NUM];       // 组合项的使能状态,0：关；1：开
    char            reserved2[32];
} DEC_TOUR_COMBIN, *LPDEC_TOUR_COMBIN;

// 解码器回放类型
typedef enum __DEC_PLAYBACK_MODE
{
    Dec_By_Device_File = 0,                             // 前端设备－按文件方式
    Dec_By_Device_Time,                                 // 前端设备－按时间方式
} DEC_PLAYBACK_MODE;

// 解码器回放控制类型
typedef enum __DEC_CTRL_PLAYBACK_TYPE
{
    Dec_Playback_Seek = 0,                              // 拖动
    Dec_Playback_Play,                                  // 播放
    Dec_Playback_Pause,                                 // 暂停
    Dec_Playback_Stop,                                  // 停止
} DEC_CTRL_PLAYBACK_TYPE;

//轮巡控制类型
typedef enum __DEC_CTRL_TOUR_TYPE
{
    Dec_Tour_Stop = 0,                                  // 停止
    Dec_Tour_Start,                                     // 开始
    Dec_Tour_Pause,                                     // 暂停
    Dec_Tour_Resume,                                    // 恢复
} DEC_CTRL_TOUR_TYPE;

// 按文件回放前端设备条件
typedef struct __DEC_PLAYBACK_FILE_PARAM 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];         // 前端DVR的IP地址
    WORD            wDevPort;                           // 前端DVR的端口号
    BYTE            bDevChnEnable;                      // 解码通道使能
    BYTE            byDecoderID;                        // 对应解码通道号
    char            szDevUser[DH_USER_NAME_LENGTH_EX];  // 用户名
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];    // 密码
    NET_RECORDFILE_INFO stuRecordInfo;                  // 录像文件信息
    char            reserved[12];
} DEC_PLAYBACK_FILE_PARAM, *LPDEC_PLAYBACK_FILE_PARAM;

// 按时间回放前端设备条件
typedef struct __DEC_PLAYBACK_TIME_PARAM 
{
    char            szDevIp[DH_MAX_IPADDR_LEN];         // 前端DVR的IP地址
    WORD            wDevPort;                           // 前端DVR的端口号
    BYTE            bDevChnEnable;                      // 解码通道使能
    BYTE            byDecoderID;                        // 对应解码通道号
    char            szDevUser[DH_USER_NAME_LENGTH_EX];  // 用户名
    char            szDevPwd[DH_USER_PSW_LENGTH_EX];    // 密码
    int             nChannelID;
    NET_TIME        startTime;
    NET_TIME        endTime;
    char            reserved[12];
} DEC_PLAYBACK_TIME_PARAM, *LPDEC_PLAYBACK_TIME_PARAM;

// 当前解码通道状态信息(包括通道状态,解码流信息等)
typedef struct __DEV_DECCHANNEL_STATE
{
    BYTE            byDecoderID;                        // 对应解码通道号
    BYTE            byChnState;                         // 当前解码通道正在操作状态:0－空闲,1－实时监视,2－回放 3 - 轮巡
    BYTE            byFrame;                            // 当前数据帧率
    BYTE            byReserved;                         // 保留
    int             nChannelFLux;                       // 解码通道数据总量
    int             nDecodeFlux;                        // 解码数据量
    char            szResolution[16];                   // 当前数据分辨率
    char            reserved[256];
} DEV_DECCHANNEL_STATE, *LPDEV_DECCHANNEL_STATE;

// 设备TV输出参数信息
typedef struct __DEV_VIDEOOUT_INFO
{
    DWORD           dwVideoStandardMask;            // NSP,视频制式掩码,按位表示设备能够支持的视频制式(暂不支持)
    int             nVideoStandard;                 // NSP,当前的制式(暂不支持,请使用DHDEV_SYSTEM_ATTR_CFG的byVideoStandard对制式读取和配置)
    DWORD           dwImageSizeMask;                // 分辨率掩码,按位表示设备能够支持的分辨率
    int             nImageSize;                     // 当前的分辨率
    char            reserved[256];
}DEV_VIDEOOUT_INFO, *LPDEV_VIDEOOUT_INFO;

// 调节TV输出
typedef struct __DEV_TVADJUST_CFG
{
    int             nTop;                           // 上测边距（0－100）
    int             nBotton;                        // 下测边距（0－100）
    int             nLeft;                          // 左测边距（0－100）
    int             nRight;                         // 右测边距（0－100）
    int             reserved[32];
}DHDEV_TVADJUST_CFG, *LPDHDEV_TVADJUST_CFG;

//云台控制坐标单元
typedef struct tagPTZ_SPEED_UNIT
{
    float                  fPositionX;           //云台水平方向速率,归一化到-1~1
    float                  fPositionY;           //云台垂直方向速率,归一化到-1~1
    float                  fZoom;                //云台光圈放大倍率,归一化到 0~1
    char                   szReserve[32];        //预留32字节
}PTZ_SPEED_UNIT;

//云台控制(相对)坐标单元
typedef struct tagPTZ_SPACE_RELATIVELY_UNIT
{
	float                    fPositionX;           // 云台水平方向,有效范围-1~1
	float                    fPositionY;           // 云台垂直方向,有效范围-1~1
	float	                 fZoom;                // 云台光圈放大倍率,有效范围-1~1
	char					 szReserve[32];        // 预留32字节
} PTZ_SPACE_RELATIVELY_UNIT;

//云台控制坐标单元
typedef struct tagPTZ_SPACE_UNIT
{
	int                    nPositionX;           //云台水平运动位置,有效范围：[0,3600]
	int                    nPositionY;           //云台垂直运动位置,有效范围：[-1800,1800]
	int                    nZoom;                //云台光圈变动位置,有效范围：[0,128]
	char                   szReserve[32];        //预留32字节
}PTZ_SPACE_UNIT;

// 解码轮巡配置
typedef struct __DEV_DECODER_TOUR_SINGLE_CFG
{
    char        szIP[128];                          // 前端设备ip.例如"10.7.5.21". 保留对域名的支持.需要以'\0'结束.
    int         nPort;                              // 前端设备端口.(0, 65535).
    int         nPlayChn;                           // 请求前端设备通道[1, 16].
    int         nPlayType;                          // 请求前端码流类型, 0:主码流; 1:辅码流.
    char        szUserName[32];                     // 登陆前端设备的用户名,需要以'\0'结束.
    char        szPassword[32];                     // 登陆前端设备的密码,需要以'\0'结束.
    int         nInterval;                          // 轮巡间隔时间[10, 120],单位秒.
    DWORD       nManuFactory;                       // 目标设备厂商(枚举 详见IPC_TYPE)
    UINT        nHttpPport;                         // 目标设备的端口(Http端口)
    UINT        nRtspPort;                          // 目标设备的端口(Rtsp端口)
    BYTE        byServiceType;                      // 服务类型, -1: auto, 0：TCP；1：UDP；2：组播
    BYTE        bReserved[51];                      // 保留字节,留待扩展.
}DHDEV_DECODER_TOUR_SINGLE_CFG;

typedef struct __DEV_DECODER_TOUR_CFG
{
    int                             nCfgNum;        // 配置结构体数目. 现在最大支持32个.具体支持数目可以通过能力查询.
    DHDEV_DECODER_TOUR_SINGLE_CFG   tourCfg[64];    // 轮询配置数组,有效结构体个数由成员"nCfgNum"指定. 保留32个留待扩展.
    BYTE                            bReserved[256]; // 保留字节,留待扩展.
}DHDEV_DECODER_TOUR_CFG;

/////////////////////////////////智能支持/////////////////////////////////
// 物体对应图片文件信息
typedef struct  
{
    DWORD           dwOffSet;                       // 文件在二进制数据块中的偏移位置, 单位:字节
    DWORD           dwFileLenth;                    // 文件大小, 单位:字节
    WORD            wWidth;                         // 图片宽度, 单位:像素
    WORD            wHeight;                        // 图片高度, 单位:像素
    char*           pszFilePath;                    // 鉴于历史原因,该成员只在事件上报时有效
                                                    // 文件路径
                                                    // 用户使用该字段时需要自行申请空间进行拷贝保存
    BYTE            bIsDetected;                    // 图片是否算法检测出来的检测过的提交识别服务器时,
								                    // 则不需要再时检测定位抠图,1:检测过的,0:没有检测过
	BYTE			bReserved[3];					// 预留字节数
	int				nFilePathLen;					// 文件路径长度 既pszFilePath 用户申请的大小
	DH_POINT		stuPoint;						// 小图左上角在大图的位置，使用绝对坐标系				
}DH_PIC_INFO;

// 物体对应图片文件信息(包含图片路径)
typedef struct tagDH_PIC_INFO_EXX
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];   // 鉴于历史原因,该成员在设置/获取时有效
                                                        // 文件路径
    DH_PIC_INFO     stuPicInfo;                         // 图片信息
}DH_PIC_INFO_EX2;

// 物体对应图片文件信息(包含图片路径)
typedef struct
{
    DWORD           dwOffSet;                       // 文件在二进制数据块中的偏移位置, 单位:字节
    DWORD           dwFileLenth;                    // 文件大小, 单位:字节
    WORD            wWidth;                         // 图片宽度, 单位:像素
    WORD            wHeight;                        // 图片高度, 单位:像素
	char            szFilePath[64];                 // 文件路径
    BYTE            bIsDetected;                    // 图片是否算法检测出来的检测过的提交识别服务器时,
	                                                // 则不需要再时检测定位抠图,1:检测过的,0:没有检测过
    BYTE            bReserved[11];                  // 保留
}DH_PIC_INFO_EX3;

// 扩展字段中加入了int64, 强制4字节对齐
#ifndef LINUX64_JNA
#pragma pack(push)
#pragma pack(4)
#endif
// 视频分析物体信息结构体
typedef struct 
{
    int                 nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
    char                szObjectType[128];                  // 物体类型
    int                 nConfidence;                        // 置信度(0~255),值越大表示置信度越高
    int                 nAction;                            // 物体动作:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // 包围盒
    DH_POINT            Center;                             // 物体型心
    int                 nPolygonNum;                        // 多边形顶点个数
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // 较精确的轮廓多边形
    DWORD               rgbaMainColor;                      // 表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000.
    char                szText[128];                        // 物体上相关的带0结束符文本,比如车牌,集装箱号等等
                                                            // "ObjectType"为"Vehicle"或者"Logo"时（尽量使用Logo。Vehicle是为了兼容老产品）表示车标,支持：
                                                            // "Unknown"未知 
                                                            // "Audi" 奥迪
                                                            // "Honda" 本田
                                                            // "Buick" 别克
                                                            // "Volkswagen" 大众
                                                            // "Toyota" 丰田
                                                            // "BMW" 宝马
                                                            // "Peugeot" 标致
                                                            // "Ford" 福特
                                                            // "Mazda" 马自达
                                                            // "Nissan" 尼桑(日产)
                                                            // "Hyundai" 现代
                                                            // "Suzuki" 铃木
                                                            // "Citroen" 雪铁龙
                                                            // "Benz" 奔驰
                                                            // "BYD" 比亚迪
                                                            // "Geely" 吉利
                                                            // "Lexus" 雷克萨斯
                                                            // "Chevrolet" 雪佛兰
                                                            // "Chery" 奇瑞
                                                            // "Kia" 起亚
                                                            // "Charade" 夏利
                                                            // "DF" 东风
                                                            // "Naveco" 依维柯
                                                            // "SGMW" 五菱
                                                            // "Jinbei" 金杯
                                                            
                                                            // "JAC" 江淮
                                                            // "Emgrand" 帝豪
                                                            // "ChangAn" 长安
                                                            // "Great Wall" 长城
                                                            // "Skoda" 斯柯达
                                                            // "BaoJun" 宝骏
                                                            // "Subaru" 斯巴鲁
                                                            // "LandWind" 陆风
                                                            // "Luxgen" 纳智捷
                                                            // "Renault" 雷诺
                                                            // "Mitsubishi" 三菱
                                                            // "Roewe" 荣威
                                                            // "Cadillac" 凯迪拉克
                                                            // "MG" 名爵
                                                            // "Zotye" 众泰
                                                            // "ZhongHua" 中华
                                                            // "Foton" 福田
                                                            // "SongHuaJiang" 松花江
                                                            // "Opel" 欧宝
                                                            // "HongQi" 一汽红旗
                                                            // "Fiat" 菲亚特
                                                            // "Jaguar" 捷豹
                                                            // "Volvo" 沃尔沃
                                                            // "Acura" 讴歌
                                                            // "Porsche" 保时捷
                                                            
                                                            // "Jeep" 吉普
                                                            // "Bentley" 宾利
                                                            // "Bugatti" 布加迪
                                                            // "ChuanQi" 传祺
                                                            // "Daewoo" 大宇
                                                            // "DongNan" 东南
                                                            // "Ferrari" 法拉利
                                                            // "Fudi" 福迪
                                                            // "Huapu" 华普
                                                            // "HawTai" 华泰
                                                            // "JMC" 江铃
                                                            // "JingLong" 金龙客车
                                                            // "JoyLong" 九龙
                                                            // "Karry" 开瑞
                                                            // "Chrysler" 克莱斯勒
                                                            // "Lamborghini" 兰博基尼
                                                            // "RollsRoyce" 劳斯莱斯
                                                            // "Linian" 理念
                                                            // "LiFan" 力帆
                                                            // "LieBao" 猎豹
                                                            // "Lincoln" 林肯
                                                            // "LandRover" 路虎
                                                            // "Lotus" 路特斯
                                                            // "Maserati" 玛莎拉蒂
                                                            // "Maybach" 迈巴赫

                                                            // "Mclaren" 迈凯轮
                                                            // "Youngman" 青年客车
                                                            // "Tesla" 特斯拉
                                                            // "Rely" 威麟
                                                            // "Lsuzu" 五十铃
                                                            // "Yiqi" 一汽
                                                            // "Infiniti" 英菲尼迪
                                                            // "YuTong" 宇通客车
                                                            // "AnKai" 安凯客车
                                                            // "Canghe" 昌河
                                                            // "HaiMa" 海马
                                                            // "Crown" 丰田皇冠
                                                            // "HuangHai" 黄海
                                                            // "JinLv" 金旅客车
                                                            // "JinNing" 精灵
                                                            // "KuBo" 酷博
                                                            // "Europestar" 莲花
                                                            // "MINI" 迷你
                                                            // "Gleagle" 全球鹰
                                                            // "ShiDai" 时代
                                                            // "ShuangHuan" 双环
                                                            // "TianYe" 田野
                                                            // "WeiZi" 威姿
                                                            // "Englon" 英伦
                                                            // "ZhongTong" 中通客车

                                                            // "Changan" 长安轿车
                                                            // "Yuejin" 跃进
                                                            // "Taurus" 金牛星
                                                            // "Alto" 奥拓
                                                            // "Weiwang" 威旺
                                                            // "Chenglong" 乘龙
                                                            // "Haige" 海格
                                                            // "Shaolin" 少林客车
                                                            // "Beifang" 北方客车
                                                            // "Beijing" 北京汽车
                                                            // "Hafu" 哈弗

															// "BeijingTruck" 北汽货车
															// "Besturn" 奔腾
															// "ChanganBus" 长安客车
															// "Dodge" 道奇
															// "DongFangHong" 东方红
															// "DongFengTruck" 东风货车
                                                            // "DongFengBus" 东风客车
															// "MultiBrand" 多品牌
															// "FotonTruck" 福田货车
															// "FotonBus" 福田客车
															// "GagcTruck" 广汽货车
															// "HaFei" 哈飞
															// "HowoBus" 豪沃客车
															// "JACTruck" 江淮货车
															// "JACBus" 江淮客车
															// "JMCTruck" 江铃货车
															// "JieFangTruck" 解放货车
															// "JinBeiTruck" 金杯货车
															// "KaiMaTruck" 凯马货车
															// "CoasterBus" 柯斯达客车
															// "MudanBus" 牡丹客车
															// "NanJunTruck" 南骏货车
															// "QingLing" 庆铃
															// "NissanCivilian" 日产碧莲客车
															// "NissanTruck" 日产货车
															// "MitsubishiFuso" 三菱扶桑
															// "SanyTruck" 三一货车
															// "ShanQiTruck" 陕汽货车
															// "ShenLongBus" 申龙客车
															// "TangJunTruck" 唐骏货车
															// "MicroTruck" 微货车
															// "VolvoBus" 沃尔沃客车
															// "LsuzuTruck" 五十铃货车
															// "WuZhengTruck" 五征货车
															// "Seat" 西雅特
															// "YangZiBus" 扬子客车
															// "YiqiBus" 一汽客车
															// "YingTianTruck" 英田货车
															// "YueJinTruck" 跃进货车
															// "ZhongDaBus" 中大客车
															// "ZxAuto" 中兴

															// "ZhongQiWangPai" 重汽王牌
															// "WAW" 奥驰
															// "BeiQiWeiWang" 北汽威旺
															// "BYDDaimler"	比亚迪戴姆勒
															// "ChunLan" 春兰
															// "DaYun" 大运
															// "DFFengDu" 东风风度
															// "DFFengGuang" 东风风光
															// "DFFengShen" 东风风神
															// "DFFengXing" 东风风行
															// "DFLiuQi" 东风柳汽
															// "DFXiaoKang" 东风小康
															// "FeiChi" 飞驰
															// "FordMustang" 福特野马
															// "GuangQi" 广汽
															// "GuangTong" 广通
															// "HuiZhongTruck" 汇众重卡
															// "JiangHuai" 江环
															// "SunWin" 申沃
															// "ShiFeng" 时风
															// "TongXin" 同心
															// "WZL" 五洲龙
															// "XiWo" 西沃
															// "XuGong" 徐工
															// "JingGong" 精工
															// "SAAB" 萨博
															// "SanHuanShiTong" 三环十通
															// "KangDi" 康迪
															// "YaoLong" 耀隆


    char                szObjectSubType[62];                // 物体子类别,根据不同的物体类型,可以取以下子类型：
                                                            // Vehicle Category:"Unknown"  未知,"Motor" 机动车,"Non-Motor":非机动车,"Bus": 公交车,"Bicycle" 自行车,"Motorcycle":摩托车,"PassengerCar":客车,
                                                            // "LargeTruck":大货车,    "MidTruck":中货车,"SaloonCar":轿车,"Microbus":面包车,"MicroTruck":小货车,"Tricycle":三轮车,    "Passerby":行人   
                                                            // "DregsCar":渣土车, "Excavator":挖掘车, "Bulldozer":推土车, "Crane":吊车, "PumpTruck":泵车, "MachineshopTruck":工程车
                                                            //  Plate Category："Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
                                                            // "Military" 部队号牌,"DoubleMilitary" 部队双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
                                                            // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
															// "Civilaviation"民航号牌,"Black"黑牌
															// "PureNewEnergyMicroCar"纯电动新能源小车,"MixedNewEnergyMicroCar,"混合新能源小车,"PureNewEnergyLargeCar",纯电动新能源大车
															// "MixedNewEnergyLargeCar"混合新能源大车
                                                            // HumanFace Category:"Normal" 普通人脸,"HideEye" 眼部遮挡,"HideNose" 鼻子遮挡,"HideMouth" 嘴部遮挡,"TankCar"槽罐车(装化学药品、危险品)

    
    WORD                wColorLogoIndex;                    // 车标索引
    WORD                wSubBrand;                          // 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
    BYTE                byReserved1;                     
    bool                bPicEnble;                          // 是否有物体对应图片文件信息
    DH_PIC_INFO         stPicInfo;                          // 物体对应图片信息
    bool                bShotFrame;                         // 是否是抓拍张的识别结果
    bool                bColor;                             // 物体颜色(rgbaMainColor)是否可用
    BYTE                byReserved2;
    BYTE                byTimeType;                         // 时间表示类型,详见EM_TIME_TYPE说明
    NET_TIME_EX         stuCurrentTime;                     // 针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
    NET_TIME_EX         stuStartTime;                       // 开始时间戳（物体开始出现时）
    NET_TIME_EX         stuEndTime;                         // 结束时间戳（物体最后出现时）
    DH_RECT             stuOriginalBoundingBox;             // 包围盒(绝对坐标)
    DH_RECT             stuSignBoundingBox;                 // 车标坐标包围盒
    DWORD               dwCurrentSequence;                  // 当前帧序号（抓下这个物体时的帧）
    DWORD               dwBeginSequence;                    // 开始帧序号（物体开始出现时的帧序号）
    DWORD               dwEndSequence;                      // 结束帧序号（物体消逝时的帧序号）
    INT64               nBeginFileOffset;                   // 开始时文件偏移, 单位: 字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
    INT64               nEndFileOffset;                     // 结束时文件偏移, 单位: 字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // 物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 上半身物体颜色相似度(物体类型为人时有效)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 下半身物体颜色相似度(物体类型为人时有效)
    int                 nRelativeID;                        // 相关物体ID
    char                szSubText[20];                      // "ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
    WORD                wBrandYear;                         // 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
} DH_MSG_OBJECT;

// 入侵方向
typedef enum tagEM_MSG_OBJ_PERSON_DIRECTION
{
    EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN,         // 未知方向
    EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT,  // 从左向右
    EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT   // 从右向左
}EM_MSG_OBJ_PERSON_DIRECTION;

// 视频分析物体信息扩展结构体
typedef struct tagDH_MSG_OBJECT_EX
{
    DWORD               dwSize;
    int                 nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
    char                szObjectType[128];                  // 物体类型
    int                 nConfidence;                        // 置信度(0~255),值越大表示置信度越高
    int                 nAction;                            // 物体动作:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // 包围盒
    DH_POINT            Center;                             // 物体型心
    int                 nPolygonNum;                        // 多边形顶点个数
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // 较精确的轮廓多边形
    DWORD               rgbaMainColor;                      // 表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000.
    char                szText[128];                        // 同DH_MSG_OBJECT相应字段   
    char                szObjectSubType[64];                // 物体子类别,根据不同的物体类型,可以取以下子类型：
                                                            // 同DH_MSG_OBJECT相应字段
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // 是否有物体对应图片文件信息
    DH_PIC_INFO         stPicInfo;                          // 物体对应图片信息
    bool                bShotFrame;                         // 是否是抓拍张的识别结果
    bool                bColor;                             // 物体颜色(rgbaMainColor)是否可用
    BYTE                bLowerBodyColor;                    // 下半身颜色(rgbaLowerBodyColor)是否可用
    BYTE                byTimeType;                         // 时间表示类型,详见EM_TIME_TYPE说明
    NET_TIME_EX         stuCurrentTime;                     // 针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
    NET_TIME_EX         stuStartTime;                       // 开始时间戳（物体开始出现时）
    NET_TIME_EX         stuEndTime;                         // 结束时间戳（物体最后出现时）
    DH_RECT             stuOriginalBoundingBox;             // 包围盒(绝对坐标)
    DH_RECT             stuSignBoundingBox;                 // 车标坐标包围盒
    DWORD               dwCurrentSequence;                  // 当前帧序号（抓下这个物体时的帧）
    DWORD               dwBeginSequence;                    // 开始帧序号（物体开始出现时的帧序号）
    DWORD               dwEndSequence;                      // 结束帧序号（物体消逝时的帧序号）
    INT64               nBeginFileOffset;                   // 开始时文件偏移, 单位: 字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
    INT64               nEndFileOffset;                     // 结束时文件偏移, 单位: 字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // 物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 上半身物体颜色相似度(物体类型为人时有效)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 下半身物体颜色相似度(物体类型为人时有效)
    int                 nRelativeID;                        // 相关物体ID
    char                szSubText[20];                      // "ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。

    int                 nPersonStature;                     // 入侵人员身高,单位cm
    EM_MSG_OBJ_PERSON_DIRECTION emPersonDirection;          // 人员入侵方向
    DWORD               rgbaLowerBodyColor;                 // 使用方法同rgbaMainColor,物体类型为人时有效 
} DH_MSG_OBJECT_EX;


// 视频分析物体信息扩展结构体,扩展版本2
typedef struct tagDH_MSG_OBJECT_EX2
{
    DWORD				dwSize;
    int                 nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
    char                szObjectType[128];                  // 物体类型
    int                 nConfidence;                        // 置信度(0~255),值越大表示置信度越高
    int                 nAction;                            // 物体动作:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
    DH_RECT             BoundingBox;                        // 包围盒
    DH_POINT            Center;                             // 物体型心
    int                 nPolygonNum;                        // 多边形顶点个数
    DH_POINT            Contour[DH_MAX_POLYGON_NUM];        // 较精确的轮廓多边形
    DWORD               rgbaMainColor;                      // 表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000.
    char                szText[128];                        // 同DH_MSG_OBJECT相应字段	
    char                szObjectSubType[64];                // 物体子类别,根据不同的物体类型,可以取以下子类型：
    // 同DH_MSG_OBJECT相应字段
    BYTE                byReserved1[3];
    bool                bPicEnble;                          // 是否有物体对应图片文件信息
    DH_PIC_INFO         stPicInfo;                          // 物体对应图片信息
    bool                bShotFrame;                         // 是否是抓拍张的识别结果
    bool                bColor;                             // 物体颜色(rgbaMainColor)是否可用
    BYTE                bLowerBodyColor;                    // 下半身颜色(rgbaLowerBodyColor)是否可用
    BYTE                byTimeType;                         // 时间表示类型,详见EM_TIME_TYPE说明
    NET_TIME_EX         stuCurrentTime;                     // 针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
    NET_TIME_EX         stuStartTime;                       // 开始时间戳（物体开始出现时）
    NET_TIME_EX         stuEndTime;                         // 结束时间戳（物体最后出现时）
    DH_RECT             stuOriginalBoundingBox;             // 包围盒(绝对坐标)
    DH_RECT             stuSignBoundingBox;                 // 车标坐标包围盒
    DWORD               dwCurrentSequence;                  // 当前帧序号（抓下这个物体时的帧）
    DWORD               dwBeginSequence;                    // 开始帧序号（物体开始出现时的帧序号）
    DWORD               dwEndSequence;                      // 结束帧序号（物体消逝时的帧序号）
    INT64               nBeginFileOffset;                   // 开始时文件偏移, 单位: 字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
    INT64               nEndFileOffset;                     // 结束时文件偏移, 单位: 字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
    BYTE                byColorSimilar[NET_COLOR_TYPE_MAX]; // 物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
    BYTE                byUpperBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 上半身物体颜色相似度(物体类型为人时有效)
    BYTE                byLowerBodyColorSimilar[NET_COLOR_TYPE_MAX]; // 下半身物体颜色相似度(物体类型为人时有效)
    int                 nRelativeID;                        // 相关物体ID
    char				szSubText[20];						// "ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
    
    int					nPersonStature;						// 入侵人员身高,单位cm
    EM_MSG_OBJ_PERSON_DIRECTION	emPersonDirection;			// 人员入侵方向
    DWORD               rgbaLowerBodyColor;                 // 使用方法同rgbaMainColor,物体类型为人时有效

    //视频浓缩额外信息
    int                 nSynopsisSpeed;                             // 浓缩速度域值,共分1~10共十个档位,5表示浓缩后只保留5以上速度的物体。是个相对单位
                                                                    // 为0时,该字段无效
    int                 nSynopsisSize;                              // 浓缩尺寸域值,共分1~10共十个档位,3表示浓缩后只保留3以上大小的物体。是个相对单位
                                                                    // 为0时,该字段无效
    BOOL                bEnableDirection;                           // 为True时,对物体运动方向做过滤
                                                                    // 为False时,不对物体运动方向做过滤,
    DH_POINT            stuSynopsisStartLocation;                   // 浓缩运动方向,起始坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
    DH_POINT            stuSynopsisEndLocation;                     // 浓缩运动方向,终止坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
    BYTE                byReserved[2048];                           // 扩展字节
} DH_MSG_OBJECT_EX2;
#ifndef LINUX64_JNA
#pragma pack(pop)
#endif

// 抓拍信息
typedef struct
{
    short              snSpeed;                         // 当前车的速度,km/h
    short              snCarLength;                     // 当前车长,分米为单位
    float              fRedTime;                        // 当前车道红灯时间,秒.毫秒
    float              fCapTime;                        // 当前车道抓拍时间,秒.毫秒 
    BYTE               bSigSequence;                    // 当前抓拍序号
    BYTE               bType;                           // 当前车道的抓拍类型
                                                        // 0: 雷达高限速;1: 雷达低限速;2: 车检器高限速;3:车检器低限速
                                                        // 4: 逆向;5: 闯红灯;6: 红灯亮;7: 红灯灭;8: 全部抓拍或者卡口
    BYTE               bDirection;                      // 闯红灯类型:01:左转红灯;02:直行红灯;03:右转红灯
    BYTE               bLightColor;                     // 当前车道的红绿灯状态,0: 绿灯, 1: 红灯, 2: 黄灯
    BYTE               bSnapFlag[16];                   // 设备产生的抓拍标识
}DH_SIG_CARWAY_INFO;

// 车检器冗余信息
typedef struct
{
    BYTE                byRedundance[8];                // 由车检器产生抓拍信号冗余信息
    BYTE                bReserved[120];                 // 保留字段
}DH_SIG_CARWAY_INFO_EX;

// 每个车道的相关信息
typedef struct  
{
    BYTE                bCarWayID;                           // 当前车道号 
    BYTE                bReserve[2];                         // 保留字段
    BYTE                bSigCount;                           // 被触发抓拍的个数
    DH_SIG_CARWAY_INFO  stuSigInfo[DH_MAX_SNAP_SIGNAL_NUM];  // 当前车道上,被触发抓拍对应的抓拍信息    
    BYTE                bReserved[12];                       // 保留字段
}DH_CARWAY_INFO;

// 事件对应文件信息
typedef struct
{
    BYTE               bCount;                               // 当前文件所在文件组中的文件总数
    BYTE               bIndex;                               // 当前文件在文件组中的文件编号(编号1开始)
    BYTE               bFileTag;                             // 文件标签, EM_EVENT_FILETAG
    BYTE               bFileType;                            // 文件类型,0-普通 1-合成 2-抠图
    NET_TIME_EX        stuFileTime;                          // 文件时间
    DWORD              nGroupId;                             // 同一组抓拍文件的唯一标识
}DH_EVENT_FILE_INFO;

// 图片分辨率
typedef struct
{
    unsigned short   snWidth;    // 宽
    unsigned short   snHight;    // 高
}DH_RESOLUTION_INFO;

// 颜色RGBA
typedef struct tagDH_COLOR_RGBA
{
    int                 nRed;                       // 红
    int                 nGreen;                     // 绿
    int                 nBlue;                      // 蓝
    int                 nAlpha;                     // 透明
} DH_COLOR_RGBA, NET_COLOR_RGBA;

#define	NET_COUNTRY_LENGTH		3		// 国家缩写长度
#define NET_COMMENT_LENGTH		100		// 备注信息长度
#define NET_GROUPID_LENGTH		64		// group id 信息长度
#define NET_GROUPNAME_LENGTH	128		// group name 信息长度
#define NET_FEATUREVALUE_LENGTH	128		// 人脸特征 信息长度

// 人员信息 (在事件(如EVENT_IVS_FACERECOGNITION)结构体中pszComment/pszGroupID/pszGroupName/pszFeatureValue指针由SDK内部申请释放内存, 其他结构体中由用户申请释放内存

//人脸检测对应人脸特征类型
typedef enum tagEM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
{
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN,               // 未知
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES,          // 戴眼镜
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE,                 // 微笑
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER,                 // 愤怒
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS,               // 悲伤
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST,               // 厌恶
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR,                  // 害怕
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE,              // 惊讶
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL,               // 正常
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH,                 // 大笑
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NOGLASSES,				// 没戴眼镜
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_HAPPY,					// 高兴
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_CONFUSED,				// 困惑
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SCREAM,				// 尖叫
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_SUNGLASSES,       // 戴太阳眼镜
}EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE;

typedef struct tagFACERECOGNITION_PERSON_INFO
{
    char                szPersonName[DH_MAX_NAME_LEN];                  // 姓名,此参数作废                 
    WORD                wYear;                                          // 出生年,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                byMonth;                                        // 出生月,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                byDay;                                          // 出生日,作为查询条件时,此参数填0,则表示此参数无效
    char                szID[DH_MAX_PERSON_ID_LEN];                     // 人员唯一标示(身份证号码,工号,或其他编号)
    BYTE                bImportantRank;                                 // 人员重要等级,1~10,数值越高越重要,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                bySex;                                          // 性别,1-男,2-女,作为查询条件时,此参数填0,则表示此参数无效
    WORD                wFacePicNum;                                    // 图片张数
    DH_PIC_INFO         szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];         // 当前人员对应的图片信息
    BYTE                byType;                                         // 人员类型,详见 EM_PERSON_TYPE
    BYTE                byIDType;                                       // 证件类型,详见 EM_CERTIFICATE_TYPE
	BYTE				byGlasses;										// 是否戴眼镜，0-未知 1-不戴 2-戴						
    BYTE                byAge;											// 年龄,0表示未知  
    char                szProvince[DH_MAX_PROVINCE_NAME_LEN];           // 省份
    char                szCity[DH_MAX_CITY_NAME_LEN];                   // 城市
    char                szPersonNameEx[DH_MAX_PERSON_NAME_LEN];         // 姓名,因存在姓名过长,16字节无法存放问题,故增加此参数, 
    char                szUID[DH_MAX_PERSON_ID_LEN];                    // 人员唯一标识符,首次由服务端生成,区别于ID字段
                                                                        // 修改,删除操作时必填
	char				szCountry[NET_COUNTRY_LENGTH];					// 国籍,符合ISO3166规范
	BYTE				byIsCustomType;									// 人员类型是否为自定义: 0 使用Type规定的类型 1 自定义,使用szPersonName字段
	char				*pszComment;									// 备注信息, 用户自己申请内存的情况时, 
																		// 下方bCommentLen需填写对应的具体长度值，推荐长度 NET_COMMENT_LENGTH
																		
	char				*pszGroupID;									// 人员所属组ID, 用户自己申请内存的情况时, 
																		// 下方bGroupIdLen需填写对应的具体长度值，推荐长度 NET_GROUPID_LENGTH
																		
	char				*pszGroupName;									// 人员所属组名, 用户自己申请内存的情况时, 
																		// 下方bGroupNameLen需填写对应的具体长度值，推荐长度 NET_GROUPNAME_LENGTH
																		
	char				*pszFeatureValue;								// 人脸特征, 用户自己申请内存的情况时, 
																		// 下方bFeatureValueLen需填写对应的具体长度值，推荐长度 NET_FEATUREVALUE_LENGTH
																		
	BYTE				bGroupIdLen;									// pszGroupID的长度
	BYTE				bGroupNameLen;									// pszGroupName的长度
	BYTE				bFeatureValueLen;								// pszFeatureValue的长度
	BYTE				bCommentLen;									// pszComment的长度
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion;					// 表情						 	
}FACERECOGNITION_PERSON_INFO;

// 眼镜类型
typedef enum tagEM_GLASSES_TYPE
{
	EM_GLASSES_UNKNOWN,		// 未知
	EM_GLASSES_SUNGLASS,	// 太阳眼镜
	EM_GLASSES_GLASS,		// 普通眼镜
} EM_GLASSES_TYPE;

// 种族类型
typedef enum tagEM_RACE_TYPE
{
	EM_RACE_UNKNOWN,			// 未知
	EM_RACE_NODISTI,			// 未识别
	EM_RACE_YELLOW,				// 黄种人
	EM_RACE_BLACK,				// 黑人
	EM_RACE_WHITE,				// 白人
} EM_RACE_TYPE;

// 眼睛状态
typedef enum tagEM_EYE_STATE_TYPE
{
	EM_EYE_STATE_UNKNOWN,		// 未知
	EM_EYE_STATE_NODISTI,		// 未识别
	EM_EYE_STATE_CLOSE,			// 闭眼
	EM_EYE_STATE_OPEN,			// 睁眼
} EM_EYE_STATE_TYPE;

// 嘴巴状态
typedef enum tagEM_MOUTH_STATE_TYPE
{
	EM_MOUTH_STATE_UNKNOWN,		// 未知
	EM_MOUTH_STATE_NODISTI,		// 未识别
	EM_MOUTH_STATE_CLOSE,		// 闭嘴
	EM_MOUTH_STATE_OPEN,		// 张嘴
} EM_MOUTH_STATE_TYPE;

// 口罩状态
typedef enum tagEM_MASK_STATE_TYPE
{
	EM_MASK_STATE_UNKNOWN,		// 未知
	EM_MASK_STATE_NODISTI,		// 未识别
	EM_MASK_STATE_NOMASK,		// 没戴口罩
	EM_MASK_STATE_WEAR,			// 戴口罩
} EM_MASK_STATE_TYPE;

// 胡子状态
typedef enum tagEM_BEARD_STATE_TYPE
{
	EM_BEARD_STATE_UNKNOWN,		// 未知
	EM_BEARD_STATE_NODISTI,		// 未识别
	EM_BEARD_STATE_NOBEARD,		// 没胡子
	EM_BEARD_STATE_HAVEBEARD,	// 有胡子
} EM_BEARD_STATE_TYPE;

// 人脸检测人脸戴眼镜特征类型
typedef enum tagEM_FACEDETECT_GLASSES_TYPE
{
	EM_FACEDETECT_GLASSES_UNKNOWN,      // 未知
	EM_FACEDETECT_WITH_GLASSES,         // 戴眼镜
	EM_FACEDETECT_WITHOUT_GLASSES,      // 不戴眼镜
}EM_FACEDETECT_GLASSES_TYPE;

// 人员建模状态
typedef enum tagEM_PERSON_FEATURE_STATE
{
	EM_PERSON_FEATURE_UNKNOWN,			// 未知
	EM_PERSON_FEATURE_FAIL,				// 建模失败,可能是图片不符合要求,需要换图片
	EM_PERSON_FEATURE_USEFUL,			// 有可用的特征值
	EM_PERSON_FEATURE_CALCULATING,		// 正在计算特征值
	EM_PERSON_FEATURE_UNUSEFUL,			// 已建模，但算法升级导致数据不可用，需要重新建模
} EM_PERSON_FEATURE_STATE;

// 建模失败原因
typedef enum tagEM_PERSON_FEATURE_ERRCODE
{
    EM_PERSON_FEATURE_ERRCODE_UNKNOWN,          // 未知
    EM_PERSON_FEATURE_ERRCODE_PIC_FORMAT,       // 图片格式问题
    EM_PERSON_FEATURE_ERRCODE_NO_FACE,          // 无人脸或不清晰
    EM_PERSON_FEATURE_ERRCODE_MULTI_FACE,       // 多个人脸
    EM_PERSON_FEATURE_ERRCODE_PIC_DECODE_FAIL,  // 图片解码失败
    EM_PERSON_FEATURE_ERRCODE_NOT_RECOMMEND,    // 不推荐入库
    EM_PERSON_FEATURE_ERRCODE_FACEDB_FAIL,      // 数据库操作失败
    EM_PERSON_FEATURE_ERRCODE_GET_PICTURE,      // 获取图片失败
    EM_PERSON_FEATURE_ERRCODE_SYSTEM_ERROR,     // 系统异常
} EM_PERSON_FEATURE_ERRCODE;

#define DH_MAX_PERSON_INFO_LEN         64      // 人员扩展信息最大长度

//注册人员信息扩展结构体
typedef struct tagCUSTOM_PERSON_INFO
{
	char szPersonInfo[DH_MAX_PERSON_INFO_LEN];     //人员扩展信息
    BYTE                        byReserved[124];   		// 保留字节
} CUSTOM_PERSON_INFO;

// 注册库属性
typedef enum tagEM_REGISTER_DB_TYPE
{
	EM_REGISTER_DB_TYPE_UNKNOWN,		// 未知
	EM_REGISTER_DB_TYPE_NORMAL,			// 普通库
	EM_REGISTER_DB_TYPE_BLACKLIST,		// 黑名单
	EM_REGISTER_DB_TYPE_WHITELIST,		// 白名单
	EM_REGISTER_DB_TYPE_VIP,			// VIP库
	EM_REGISTER_DB_TYPE_STAFF,			// 员工库
	EM_REGISTER_DB_TYPE_LEADER,			// 领导库
} EM_REGISTER_DB_TYPE;

#define	DH_MAX_CUSTOM_PERSON_INFO_NUM		4	   // 注册人员信息扩展最大个数
// 人员信息扩展结构体
typedef struct tagFACERECOGNITION_PERSON_INFOEX
{
    char                        szPersonName[DH_MAX_PERSON_NAME_LEN];           // 姓名             
    WORD                        wYear;                                          // 出生年,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                        byMonth;                                        // 出生月,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                        byDay;                                          // 出生日,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                        bImportantRank;                                 // 人员重要等级,1~10,数值越高越重要,作为查询条件时,此参数填0,则表示此参数无效
    BYTE                        bySex;                                          // 性别,1-男,2-女,作为查询条件时,此参数填0,则表示此参数无效
    char                        szID[DH_MAX_PERSON_ID_LEN];                     // 人员唯一标示(身份证号码,工号,或其他编号)
    WORD                        wFacePicNum;                                    // 图片张数
    DH_PIC_INFO                 szFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];         // 当前人员对应的图片信息
    BYTE                        byType;                                         // 人员类型,详见 EM_PERSON_TYPE
    BYTE                        byIDType;                                       // 证件类型,详见 EM_CERTIFICATE_TYPE
    BYTE                        byGlasses;                                      // 是否戴眼镜，0-未知 1-不戴 2-戴						
    BYTE                        byAge;                                          // 年龄,0表示未知  
    char                        szProvince[DH_MAX_PROVINCE_NAME_LEN];           // 省份
    char                        szCity[DH_MAX_CITY_NAME_LEN];                   // 城市
    char                        szUID[DH_MAX_PERSON_ID_LEN];                    // 人员唯一标识符,首次由服务端生成,区别于ID字段
                                                                                // 修改,删除操作时必填
    char                        szCountry[NET_COUNTRY_LENGTH];                  // 国籍,符合ISO3166规范
    BYTE                        byIsCustomType;                                 // 人员类型是否为自定义: 0 使用Type规定的类型 1 自定义,使用szCustomType字段
    char                        szCustomType[DH_COMMON_STRING_16];              // 人员自定义类型
    char                        szComment[NET_COMMENT_LENGTH];                  // 备注信息
    char                        szGroupID[NET_GROUPID_LENGTH];                  // 人员所属组ID
    char                        szGroupName[NET_GROUPNAME_LENGTH];              // 人员所属组名, 用户自己申请内存的情况时, 
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;                          // 表情
    char                        szHomeAddress[DH_COMMON_STRING_128];            // 注册人员家庭地址
    EM_GLASSES_TYPE             emGlassesType;                                  // 眼镜类型
    EM_RACE_TYPE                emRace;                                         // 种族
    EM_EYE_STATE_TYPE           emEye;                                          // 眼睛状态
    EM_MOUTH_STATE_TYPE         emMouth;                                        // 嘴巴状态
    EM_MASK_STATE_TYPE          emMask;                                         // 口罩状态
    EM_BEARD_STATE_TYPE         emBeard;                                        // 胡子状态
    int                         nAttractive;                                    // 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
    EM_PERSON_FEATURE_STATE     emFeatureState;                                 // 人员建模状态
    BOOL                        bAgeEnable;                                     // 是否指定年龄段
    int                         nAgeRange[2];                                   // 年龄范围
    int                         nEmotionValidNum;               // 人脸特征数组有效个数,与 emFeature 结合使用, 如果为0则表示查询所有表情
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotions[DH_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 byFeatureValidNum 结合使用  设置查询条件的时候使用
    int                         nCustomPersonInfoNum;                                    // 注册人员信息扩展个数
    CUSTOM_PERSON_INFO          szCustomPersonInfo[DH_MAX_CUSTOM_PERSON_INFO_NUM];       //注册人员信息扩展
    EM_REGISTER_DB_TYPE         emRegisterDbType;                           // 注册库类型
    NET_TIME                    stuEffectiveTime;                           // 有效期时间
    EM_PERSON_FEATURE_ERRCODE   emFeatureErrCode;                           // 建模失败原因
    BYTE                        byReserved[1112];                           // 保留字节
} FACERECOGNITION_PERSON_INFOEX;

// 候选人员信息
typedef struct tagCANDIDATE_INFO
{
    FACERECOGNITION_PERSON_INFO  stPersonInfo;            // 人员信息
                                                          // 布控（黑名单）库,指布控库中人员信息；
                                                          // 历史库,指历史库中人员信息
                                                          // 报警库,指布控库的人员信息

    BYTE                         bySimilarity;            // 和查询图片的相似度,百分比表示,1~100
    BYTE                         byRange;                 // 人员所属数据库范围,详见EM_FACE_DB_TYPE
    BYTE                         byReserved1[2];
    NET_TIME                     stTime;                  // 当byRange为历史数据库时有效,表示查询人员出现的时间
    char                         szAddress[MAX_PATH];     // 当byRange为历史数据库时有效,表示查询人员出现的地点  
	BOOL                         bIsHit;                  // 是否有识别结果,指这个检测出的人脸在库中有没有比对结果
	DH_PIC_INFO_EX3              stuSceneImage;           // 人脸全景图
	int							 nChannelID;			  // 通道号
    BYTE                         byReserved[32];          // 保留字节
}CANDIDATE_INFO;

// 衣服颜色
typedef enum tagEM_CLOTHES_COLOR
{
    EM_CLOTHES_COLOR_UNKNOWN,       // 未知
    EM_CLOTHES_COLOR_WHITE,         // 白色
    EM_CLOTHES_COLOR_ORANGE,        // 橙色
    EM_CLOTHES_COLOR_PINK,          // 粉色
    EM_CLOTHES_COLOR_BLACK,         // 黑色
    EM_CLOTHES_COLOR_RED,           // 红色
    EM_CLOTHES_COLOR_YELLOW,        // 黄色
    EM_CLOTHES_COLOR_GRAY,          // 灰色
    EM_CLOTHES_COLOR_BLUE,          // 蓝色
    EM_CLOTHES_COLOR_GREEN,         // 绿色 
    EM_CLOTHES_COLOR_PURPLE,        // 紫色
    EM_CLOTHES_COLOR_BROWN,         // 棕色
    EM_CLOTHES_COLOR_OTHER,         // 其他颜色
}EM_CLOTHES_COLOR;

//上衣类型
typedef enum tagEM_COAT_TYPE
{
    EM_COAT_TYPE_UNKNOWN,           // 未知
    EM_COAT_TYPE_LONG_SLEEVE,       // 长袖
    EM_COAT_TYPE_COTTA,             // 短袖
}EM_COAT_TYPE;

// 裤子类型
typedef enum tagEM_TROUSERS_TYPE
{
    EM_TROUSERS_TYPE_UNKNOWN,       // 未知
    EM_TROUSERS_TYPE_TROUSERS,      // 长裤
    EM_TROUSERS_TYPE_SHORTS,        // 短裤
    EM_TROUSERS_TYPE_SKIRT,         // 裙子
}EM_TROUSERS_TYPE;

// 是否戴帽子
typedef enum tagEM_HAS_HAT
{
    EM_HAS_HAT_UNKNOWN,             // 未知
    EM_HAS_HAT_NO,                  // 不戴帽子
    EM_HAS_HAT_YES,                 // 戴帽子
}EM_HAS_HAT;


// 是否戴包(包括背包或拎包)
typedef enum tagEM_HAS_BAG
{
    EM_HAS_BAG_UNKNOWN,             // 未知
    EM_HAS_BAG_NO,                  // 不带包
    EM_HAS_BAG_YES,                 // 带包
}EM_HAS_BAG;

// 是否有背包
typedef enum tagEM_HAS_BACK_BAG
{
    EM_HAS_BACK_BAG_UNKNOWN,        // 未知
    EM_HAS_BACK_BAG_NO,             // 没有背包
    EM_HAS_BACK_BAG_YES,            // 有背包
} EM_HAS_BACK_BAG;

// 是否有手提包
typedef enum tagEM_HAS_CARRIER_BAG
{
    EM_HAS_CARRIER_BAG_UNKNOWN,     // 未知
    EM_HAS_CARRIER_BAG_NO,          // 没有手提包
    EM_HAS_CARRIER_BAG_YES,         // 有手提包
} EM_HAS_CARRIER_BAG;

// 是否有肩包
typedef enum tagEM_HAS_SHOULDER_BAG
{
    EM_HAS_SHOULDER_BAG_UNKNOWN,    // 未知
    EM_HAS_SHOULDER_BAG_NO,         // 没有肩包
    EM_HAS_SHOULDER_BAG_YES,        // 有肩包
} EM_HAS_SHOULDER_BAG;

// 是否有斜挎包
typedef enum tagEM_HAS_MESSENGER_BAG
{
    EM_HAS_MESSENGER_BAG_UNKNOWN,   // 未知
    EM_HAS_MESSENGER_BAG_NO,        // 没有斜挎包
    EM_HAS_MESSENGER_BAG_YES,       // 有斜挎包
} EM_HAS_MESSENGER_BAG;

// 角度
typedef enum tagEM_ANGLE_TYPE
{
    EM_ANGLE_UNKNOWN = 0,           // 未知
    EM_ANGLE_FRONT,                 // 正面
    EM_ANGLE_SIDE,                  // 侧面
    EM_ANGLE_BACK,                  // 背面
}EM_ANGLE_TYPE;

// 是否打伞
typedef enum tagEM_HAS_UMBRELLA
{
    EM_HAS_UMBRELLA_UNKNOWN,        // 未知
    EM_HAS_UMBRELLA_NO,             // 未打伞
    EM_HAS_UMBRELLA_YES,            // 打伞
} EM_HAS_UMBRELLA;

// 包类型
typedef enum tagEM_BAG_TYPE
{
    EM_BAG_UNKNOWN,                 // 未知
    EM_BAG_HANDBAG,                 // 手提包
    EM_BAG_SHOULDERBAG,             // 肩包
    EM_BAG_KNAPSACK,                // 背包
    EM_BAG_DRAWBARBOX,              // 拉杆箱
    EM_BAG_WAISTPACK,               // 腰包
    EM_BAG_NONE,                    // 无包
} EM_BAG_TYPE;

// 帽子类型
typedef enum tagEM_CAP_TYPE
{
    EM_CAP_UNKNOWN,         // 未知
    EM_CAP_ORDINARY,        // 普通帽子
    EM_CAP_HELMET,          // 头盔
    EM_CAP_SAFE,            // 安全帽
} EM_CAP_TYPE;

// 衣服图案
typedef enum tagEM_CLOTHES_PATTERN
{
    EM_CLOTHES_PATTERN_UNKNOWN,     // 未知
    EM_CLOTHES_PATTERN_PURE,        // 纯色
    EM_CLOTHES_PATTERN_STRIPE,      // 条纹
    EM_CLOTHES_PATTERN_PATTERN,     // 图案
    EM_CLOTHES_PATTERN_GAP,         // 缝隙
    EM_CLOTHES_PATTERN_LATTICE,     // 格子
    EM_CLOTHES_PATTERN_SPLITJOIN,   // 拼接
} EM_CLOTHES_PATTERN;

// 头发样式
typedef enum tagEM_HAIR_STYLE
{
    EM_HAIR_UNKNOWN = 0,    // 未知
    EM_HAIR_LONG_HAIR,      // 长发
    EM_HAIR_SHORT_HAIR,     // 短发
    EM_HAIR_PONYTAIL,       // 马尾
    EM_HAIR_UPDO,           // 盘发
    EM_HAIR_HEAD_BLOCKED,   // 头部被遮挡
    EM_HAIR_NONE,           // 无头发
} EM_HAIR_STYLE;

// 性别
typedef enum tagEM_SEX_TYPE
{
    EM_SEX_TYPE_UNKNOWN,        //未知
    EM_SEX_TYPE_MALE,           //男性
    EM_SEX_TYPE_FEMALE,         //女性
}EM_SEX_TYPE;

// 历史库人体图片信息
typedef struct tagNET_HISTORY_HUMAN_IMAGE_INFO
{
    int                 nLength;            // 图片大小,单位:字节
    int                 nWidth;             // 图片宽度
    int                 nHeight;            // 图片高度
    char                szFilePath[260];    // 文件路径
} NET_HISTORY_HUMAN_IMAGE_INFO;

// 历史库人体信息
typedef struct tagNET_HISTORY_HUMAN_INFO
{
    EM_CLOTHES_COLOR                emCoatColor;            // 上衣颜色
    EM_COAT_TYPE                    emCoatType;             // 上衣类型
    EM_CLOTHES_COLOR                emTrousersColor;        // 裤子颜色
    EM_TROUSERS_TYPE                emTrousersType;         // 裤子类型
    EM_HAS_HAT                      emHasHat;               // 是否戴帽子
    EM_HAS_BAG                      emHasBag;               // 是否带包
    NET_RECT                        stuBoundingBox;         // 包围盒(8192坐标系)
    int                             nAge;                   // 年龄
    EM_SEX_TYPE                     emSex;                  // 性别
    EM_ANGLE_TYPE                   emAngle;                // 角度
    EM_HAS_UMBRELLA                 emHasUmbrella;          // 是否打伞
    EM_BAG_TYPE                     emBag;                  // 包类型
    EM_CLOTHES_PATTERN              emUpperPattern;         // 上半身衣服图案
    EM_HAIR_STYLE                   emHairStyle;            // 头发样式
    EM_CAP_TYPE                     emCap;                  // 帽类型
    EM_HAS_BACK_BAG                 emHasBackBag;           // 是否有背包
    EM_HAS_CARRIER_BAG              emHasCarrierBag;        // 是否带手提包
    EM_HAS_SHOULDER_BAG             emHasShoulderBag;       // 是否有肩包
    EM_HAS_MESSENGER_BAG            emMessengerBag;         // 是否有斜跨包
    NET_HISTORY_HUMAN_IMAGE_INFO    stuImageInfo;           // 人体图片信息
    NET_HISTORY_HUMAN_IMAGE_INFO    stuFaceImageInfo;       // 人脸图片信息
    BYTE                            byReserved[256];        // 保留字节
} NET_HISTORY_HUMAN_INFO;

// 候选人员信息扩展结构体
typedef struct tagCANDIDATE_INFOEX
{
    FACERECOGNITION_PERSON_INFOEX  stPersonInfo;          // 人员信息扩展
                                                          // 布控（黑名单）库,指布控库中人员信息；
                                                          // 历史库,指历史库中人员信息
                                                          // 报警库,指布控库的人员信息

    BYTE                         bySimilarity;            // 和查询图片的相似度,百分比表示,1~100
    BYTE                         byRange;                 // 人员所属数据库范围,详见EM_FACE_DB_TYPE
    BYTE                         byReserved1[2];
    NET_TIME                     stTime;                  // 当byRange为历史数据库时有效,表示查询人员出现的时间
    char                         szAddress[MAX_PATH];     // 当byRange为历史数据库时有效,表示查询人员出现的地点  
    BOOL                         bIsHit;                  // 是否有识别结果,指这个检测出的人脸在库中有没有比对结果
    DH_PIC_INFO_EX3              stuSceneImage;           // 人脸全景图
    int                          nChannelID;              // 通道号
    char                         szFilePathEx[256];       // 文件路径
    NET_HISTORY_HUMAN_INFO       stuHistoryHumanInfo;     // 历史库人体信息
    BYTE                         byReserved[136];         // 保留字节
} CANDIDATE_INFOEX;

// 大类业务方案       
typedef enum tagEM_CLASS_TYPE        
{
	EM_CLASS_UNKNOWN                	= 0,    // 未知业务       
    EM_CLASS_VIDEO_SYNOPSIS            	= 1,    // 视频浓缩       
    EM_CLASS_TRAFFIV_GATE            	= 2,    //卡口       
    EM_CLASS_ELECTRONIC_POLICE        	= 3,    // 电警       
    EM_CLASS_SINGLE_PTZ_PARKING        	= 4,    // 单球违停       
    EM_CLASS_PTZ_PARKINBG            	= 5,    // 主从违停       
    EM_CLASS_TRAFFIC                	= 6,    // 交通事件"Traffic"       
    EM_CLASS_NORMAL                    	= 7,    // 通用行为分析"Normal"       
    EM_CLASS_PRISON                    	= 8,    // 监所行为分析"Prison"       
    EM_CLASS_ATM                    	= 9,    // 金融行为分析"ATM"       
    EM_CLASS_METRO                    	= 10,   // 地铁行为分析       
    EM_CLASS_FACE_DETECTION            	= 11,   // 人脸检测"FaceDetection"       
    EM_CLASS_FACE_RECOGNITION        	= 12,   // 人脸识别"FaceRecognition"       
    EM_CLASS_NUMBER_STAT            	= 13,   // 人数统计"NumberStat"       
    EM_CLASS_HEAT_MAP                	= 14,   // 热度图"HeatMap"       
    EM_CLASS_VIDEO_DIAGNOSIS        	= 15,   // 视频诊断"VideoDiagnosis"       
    EM_CLASS_VIDEO_ENHANCE            	= 16,   // 视频增强       
    EM_CLASS_SMOKEFIRE_DETECT        	= 17,   // 烟火检测       
    EM_CLASS_VEHICLE_ANALYSE        	= 18,   // 车辆特征识别"VehicleAnalyse"       
    EM_CLASS_PERSON_FEATURE            	= 19,   // 人员特征识别     
    EM_CLASS_SDFACEDETECTION			= 20,	// 多预置点人脸检测"SDFaceDetect"  
    											//配置一条规则但可以在不同预置点下生效
	EM_CLASS_HEAT_MAP_PLAN				= 21,	// 球机热度图计划"HeatMapPlan" 
	EM_CLASS_NUMBERSTAT_PLAN			= 22,	// 球机客流量统计计划 "NumberStatPlan"
	EM_CLASS_ATMFD						= 23,	// 金融人脸检测，包括正常人脸、异常人脸、相邻人脸、头盔人脸等针对ATM场景特殊优化
	EM_CLASS_HIGHWAY					= 24,	// 高速交通事件检测"Highway"
	EM_CLASS_CITY						= 25,	// 城市交通事件检测 "City"
	EM_CLASS_LETRACK					= 26,	// 民用简易跟踪"LeTrack"
	EM_CLASS_SCR						= 27,	// 打靶相机"SCR"
	EM_CLASS_STEREO_VISION              = 28,   // 立体视觉(双目)"StereoVision"
	EM_CLASS_HUMANDETECT                = 29,   // 人体检测"HumanDetect"
	EM_CLASS_FACE_ANALYSIS				= 30,	// 人脸分析 "FaceAnalysis"
	EM_CALSS_XRAY_DETECTION				= 31,	// X光检测 "XRayDetection"
	EM_CLASS_STEREO_NUMBER				= 32,	// 双目相机客流量统计 "StereoNumber"
    EM_CLASS_CROWDDISTRIMAP				= 33,	// 人群分布图
    EM_CLASS_OBJECTDETECT				= 34,	// 目标检测
	EM_CLASS_FACEATTRIBUTE				= 35,	// IVSS人脸检测 "FaceAttribute" 
	EM_CLASS_FACECOMPARE				= 36,	// IVSS人脸识别 "FaceCompare" 
	EM_CALSS_STEREO_BEHAVIOR			= 37,	// 立体行为分析 "StereoBehavior"
	EM_CALSS_INTELLICITYMANAGER			= 38,	// 智慧城管 "IntelliCityMgr"
	EM_CALSS_PROTECTIVECABIN			= 39,	// 防护舱（ATM舱内）"ProtectiveCabin"
	EM_CALSS_AIRPLANEDETECT				= 40,	// 飞机行为检测 "AirplaneDetect"
	EM_CALSS_CROWDPOSTURE				= 41,	// 人群态势（人群分布图服务）"CrowdPosture"
	EM_CLASS_PHONECALLDETECT			= 42,	// 打电话检测 "PhoneCallDetect"
	EM_CLASS_SMOKEDETECTION				= 43,	// 烟雾检测 "SmokeDetection"
	EM_CLASS_BOATDETECTION				= 44,	// 船只检测 "BoatDetection"
	EM_CLASS_SMOKINGDETECT				= 45,	// 吸烟检测 "SmokingDetect"
	EM_CLASS_WATERMONITOR				= 46,	// 水利监测 "WaterMonitor"
    EM_CLASS_GENERATEGRAPHDETECTION     = 47,   // 生成图规则 "GenerateGraphDetection" 
    EM_CLASS_TRAFFIC_PARK               = 48,	// 交通停车 "TrafficPark"		  
    EM_CLASS_OPERATEMONITOR 			= 49,	// 作业检测 "OperateMonitor"
    EM_CLASS_INTELLI_RETAIL				= 50,	// 智慧零售大类 "IntelliRetail"
    EM_CLASS_CLASSROOM_ANALYSE			= 51,	// 教育智慧课堂"ClassroomAnalyse"
    EM_CLASS_FEATURE_ABSTRACT           = 52,   // 特征向量提取大类 "FeatureAbstract" 
	EM_CLASS_FACEBODY_DETECT			= 53,	// 人体检测大类 "FaceBodyDetect"
	EM_CLASS_FACEBODY_ANALYSE			= 54,	// 人体识别大类 "FaceBodyAnalyse"
	EM_CLASS_VEHICLES_DISTRI			= 55,	// 车辆密度 "VehiclesDistri"
	EM_CLASS_INTELLI_BREED              = 56,   // 智慧养殖检测 "IntelliBreed"
	EM_CLASS_INTELLI_PRISON             = 57,   // 监狱行为分析 "IntelliPrison"
	EM_CLASS_ELECTRIC_DETECT            = 58,   // 电力检测 "ElectricDetect"
	EM_CLASS_RADAR_DETECT				= 59,     // 雷达检测 "RadarDetect"
    EM_CLASS_PARKINGSPACE               = 60,     // 车位检测大类 "ParkingSpace" 
} EM_CLASS_TYPE; 


//大类业务方案，内容与EM_SCENE_TYPE一致
typedef enum tagEM_SCENE_CLASS_TYPE
{
	EM_SCENE_CLASS_UNKNOW,			// 未知
	EM_SCENE_CLASS_NORMAL,			// "Normal" 普通场景
	EM_SCENE_CLASS_TRAFFIC,			// "Traffic" 交通场景
	EM_SCENE_CLASS_TRAFFIC_PATROL,	// "TrafficPatrol" 交通巡视
	EM_SCENE_CLASS_FACEDETECTION,	// "FaceDetection" 人脸检测/人脸识别
	EM_SCENE_CLASS_ATM,				// "ATM"
	EM_SENCE_CLASS_INDOOR,			// "Indoor"  室内行为分析，和普通规则相同，对室内场景的算法优化版
	EM_SENCE_CLASS_FACERECOGNITION,	// "FaceRecognition" 人脸识别
	EM_SENCE_CLASS_PRISON,			// "Prison" 监狱
	EM_SENCE_CLASS_NUMBERSTAT,		// "NumberStat" 客流量统计
	EM_SENCE_CLASS_HEAT_MAP,		// "HeatMap" 热度图
	EM_SENCE_CLASS_VIDEODIAGNOSIS,	// "VideoDiagnosis" 视频诊断
	EM_SENCE_CLASS_VEHICLEANALYSE,	// "VehicleAnalyse" 车辆特征检测分析
	EM_SENCE_CLASS_COURSERECORD,	// "CourseRecord" 自动录播
	EM_SENCE_CLASS_VEHICLE,			// "Vehicle" 车载场景(车载行业用，不同于智能交通的Traffic)
	EM_SENCE_CLASS_STANDUPDETECTION,// "StandUpDetection" 起立检测
	EM_SCENE_CLASS_GATE,			// "Gate" 卡口
	EM_SCENE_CLASS_SDFACEDETECTION,	// "SDFaceDetect"  多预置点人脸检测，配置一条规则但可以在不同预置点下生效
	EM_SCENE_CLASS_HEAT_MAP_PLAN,	// "HeatMapPlan" 球机热度图计划
	EM_SCENE_CLASS_NUMBERSTAT_PLAN,	// "NumberStatPlan"	球机客流量统计计划
	EM_SCENE_CLASS_ATMFD,			// "ATMFD"金融人脸检测，包括正常人脸、异常人脸、相邻人脸、头盔人脸等针对ATM场景特殊优化
	EM_SCENE_CLASS_HIGHWAY,			// "Highway" 高速交通事件检测
	EM_SCENE_CLASS_CITY,			// "City" 城市交通事件检测
	EM_SCENE_CLASS_LETRACK,			// "LeTrack" 民用简易跟踪
	EM_SCENE_CLASS_SCR,				// "SCR" 打靶相机
	EM_SCENE_CLASS_STEREO_VISION,   // "StereoVision" 立体视觉(双目)
	EM_SCENE_CLASS_HUMANDETECT,		// "HumanDetect"人体检测
	EM_SCENE_CLASS_FACEANALYSIS,	// "FaceAnalysis" 人脸分析
	EM_SCENE_CLASS_XRAY_DETECTION,	// "XRayDetection" X光检测
	EM_SCENE_CLASS_STEREO_NUMBER,	// "StereoNumber" 双目相机客流量统计
	EM_SCENE_CLASS_CROWDDISTRIMAP,	// "CrowdDistriMap"人群分布图
    EM_SCENE_CLASS_OBJECTDETECT,	// "ObjectDetect"目标检测
	EM_SCENE_CLASS_FACEATTRIBUTE,	// "FaceAttribute" IVSS人脸检测
	EM_SCENE_CLASS_FACECOMPARE,		// "FaceCompare" IVSS人脸识别
	EM_SCENE_CLASS_STEREO_BEHAVIOR,	// "StereoBehavior" 立体行为分析(典型场景ATM舱)
	EM_SCENE_CLASS_INTELLICITYMANAGER,	// "IntelliCityMgr" 智慧城管
	EM_SCENE_CLASS_PROTECTIVECABIN,	// "ProtectiveCabin" 防护舱（ATM舱内）
	EM_SCENE_CLASS_AIRPLANEDETECT,	// "AirplaneDetect" 飞机行为检测
	EM_SCENE_CLASS_CROWDPOSTURE,	// "CrowdPosture" 人群态势（人群分布图服务）
	EM_SCENE_CLASS_PHONECALLDETECT,	// "PhoneCallDetect"  打电话检测
	EM_SCENE_CLASS_SMOKEDETECTION,	// "SmokeDetection"   烟雾检测
	EM_SCENE_CLASS_BOATDETECTION,	// "BoatDetection"	  船只检测
	EM_SCENE_CLASS_SMOKINGDETECT,	// "SmokingDetect"	  吸烟检测
	EM_SCENE_CLASS_WATERMONITOR,	// "WaterMonitor"	  水利监测
	EM_SCENE_CLASS_GENERATEGRAPHDETECTION,// "GenerateGraphDetection" 生成图规则 
    EM_SCENE_CLASS_TRAFFIC_PARK,	// "TrafficPark"		  交通停车
    EM_SCENE_CLASS_OPERATEMONITOR, 	// "OperateMonitor" 作业检测 
    EM_SCENE_CLASS_INTELLI_RETAIL,	// IntelliRetail" 智慧零售大类 
    EM_SCENE_CLASS_CLASSROOM_ANALYSE,// "ClassroomAnalyse" 教育智慧课堂
    EM_SCENE_CLASS_FEATURE_ABSTRACT, // "FeatureAbstract" 特征向量提取大类
	EM_SCENE_CLASS_FACEBODY_DETECT,	// "FaceBodyDetect" 人像检测大类
	EM_SCENE_CLASS_FACEBODY_ANALYSE,// "FaceBodyAnalyse"人像识别大类
	EM_SCENE_CLASS_VEHICLES_DISTRI,	// "VehiclesDistri" 车辆密度 
	EM_SCENE_CLASS_INTELLI_BREED,   // "IntelliBreed"智慧养殖检测
	EM_SCENE_CLASS_INTELLI_PRISON,  // "IntelliPrison"监狱行为分析
	EM_SCENE_CLASS_ELECTRIC_DETECT, // "ElectricDetect" 电力检测
	EM_SCENE_CLASS_RADAR_DETECT,       // "RadarDetect"雷达检测
    EM_SCENE_CLASS_PARKINGSPACE,    // "ParkingSpace" 车位检测大类
} EM_SCENE_CLASS_TYPE;

// 智能报警事件公共信息
typedef struct tagEVENT_INTELLI_COMM_INFO
{
	EM_CLASS_TYPE		emClassType;								// 智能事件所属大类
	int					nPresetID;									// 该事件触发的预置点，取值范围为0~255，大于0表示在此预置点时有效。
	BYTE                bReserved[124];                     		// 保留字节,留待扩展.
} EVENT_INTELLI_COMM_INFO;

// 智能事件抓图信息
typedef struct tagNET_INTELLIGENCE_IMAGE_INFO
{
	UINT				nOffSet;					// 在二进制数据块中的偏移   
	UINT				nLength;					// 图片大小,单位字节
	UINT				nWidth;						// 图片宽度(像素)
	UINT				nHeight;					// 图片高度(像素)
	BYTE				byReserved[48];				// 预留字节
}NET_INTELLIGENCE_IMAGE_INFO;

// 交通车辆部分信息
typedef struct tagEVENT_TRAFFIC_CAR_PART_INFO
{
    char                szMachineName[128];                  // 本地或远程设备名称    来源于普通配置General.MachineName    
    char                szRoadwayNo[32];                     // 道路编号
    char                szPlateNumber[32];                   // 车牌号码
    char                szCategory[32];                      // 车辆子类型
    BYTE                bReserved[288];                      // 保留字节
}EVENT_TRAFFIC_CAR_PART_INFO;

// 交通车辆行驶方向类型
typedef enum tagEM_TRAFFICCAR_MOVE_DIRECTION
{
    EM_TRAFFICCAR_MOVE_DIRECTION_UNKNOWN,                           // 未知的
    EM_TRAFFICCAR_MOVE_DIRECTION_STRAIGHT,                          // 直行
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_LEFT,                         // 左转
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_RIGHT,                        // 右转
    EM_TRAFFICCAR_MOVE_DIRECTION_TURN_AROUND,                       // 掉头
}EM_TRAFFICCAR_MOVE_DIRECTION;

// 白名单权限列表
typedef struct tagNET_WHITE_LIST_AUTHORITY_LIST
{
    BOOL                bOpenGate;                         // 是否有开闸权限
    BYTE                bReserved[16];                      // 保留字节
}NET_WHITE_LIST_AUTHORITY_LIST;

// 白名单信息
typedef struct tagNET_TRAFFICCAR_WHITE_LIST
{
    BOOL                          bTrustCar;              // 车牌是否属于白名单
    NET_TIME                       stuBeginTime;           // 白名单起始时间
    NET_TIME                       stuCancelTime;           // 白名单过期时间
    NET_WHITE_LIST_AUTHORITY_LIST         stuAuthorityList;        // 白名单权限列表
    BYTE                          bReserved[32];           // 保留字节
}NET_TRAFFICCAR_WHITE_LIST;

// 黑名单信息
typedef struct tagNET_TRAFFICCAR_BLACK_LIST
{
    BOOL                          bEnable;					// 是否已启用黑名单
	BOOL						  bIsBlackCar;				// 车牌是否属于黑名单
    NET_TIME                      stuBeginTime;				// 黑名单起始时间
    NET_TIME                      stuCancelTime;			// 黑名单过期时间
    BYTE                          bReserved[32];			// 保留字节
}NET_TRAFFICCAR_BLACK_LIST;

// 车辆类型
typedef enum tagEM_TRAFFICCAR_CAR_TYPE
{
    EM_TRAFFICCAR_CAR_TYPE_UNKNOWN,                       // 未知
    EM_TRAFFICCAR_CAR_TYPE_TRUST_CAR,                      // 白名单车辆
    EM_TRAFFICCAR_CAR_TYPE_SUSPICIOUS_CAR,                    // 黑名单车辆
    EM_TRAFFICCAR_CAR_TYPE_NORMAL_CAR,                      // 非白名单且非黑名单车辆
}EM_TRAFFICCAR_CAR_TYPE;

// 车道类型
typedef enum tagEM_TRAFFICCAR_LANE_TYPE
{
    EM_TRAFFICCAR_LANE_TYPE_UNKNOWN,						// 未知
    EM_TRAFFICCAR_LANE_TYPE_NORMAL,							// 普通车道
    EM_TRAFFICCAR_LANE_TYPE_NONMOTOR,						// 非机动车车道
	EM_TRAFFICCAR_LANE_TYPE_LIGHT_DUTY,                     // 小型车车道
	EM_TRAFFICCAR_LANE_TYPE_BUS,							// 公交车车道
	EM_TRAFFICCAR_LANE_TYPE_EMERGENCY,						// 应急车道
	EM_TRAFFICCAR_LANE_TYPE_DANGEROUS,						// 危险品车道
}EM_TRAFFICCAR_LANE_TYPE;

// TrafficCar 交通车辆信息
typedef struct tagDEV_EVENT_TRAFFIC_TRAFFICCAR_INFO
{
    char               szPlateNumber[32];                   // 车牌号码
    char               szPlateType[32];                     // 号牌类型 "Unknown" 未知; "Normal" 蓝牌黑牌; "Yellow" 黄牌; "DoubleYellow" 双层黄尾牌
                                                            // "Police" 警牌; "Armed" 武警牌; "Military" 部队号牌; "DoubleMilitary" 部队双层
                                                            // "SAR" 港澳特区号牌; "Trainning" 教练车号牌; "Personal" 个性号牌; "Agri" 农用牌
                                                            // "Embassy" 使馆号牌; "Moto" 摩托车号牌; "Tractor" 拖拉机号牌; "Other" 其他号牌
    char               szPlateColor[32];                    // 车牌颜色    "Blue","Yellow", "White","Black","YellowbottomBlackText","BluebottomWhiteText","BlackBottomWhiteText","ShadowGreen","YellowGreen"
    char               szVehicleColor[32];                  // 车身颜色    "White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
    int                nSpeed;                              // 速度    单位Km/H
    char               szEvent[64];                         // 触发的相关事件    参见事件列表Event List,只包含交通相关事件。
    char               szViolationCode[32];                 // 违章代码    详见TrafficGlobal.ViolationCode
    char               szViolationDesc[64];                 // 违章描述
    int                nLowerSpeedLimit;                    // 速度下限
    int                nUpperSpeedLimit;                    // 速度上限
    int                nOverSpeedMargin;                    // 限高速宽限值    单位：km/h 
    int                nUnderSpeedMargin;                   // 限低速宽限值    单位：km/h 
    int                nLane;                               // 车道    参见事件列表Event List中卡口和路口事件。
    int                nVehicleSize;                        // 车辆大小,-1表示未知,否则按位
                                                            // 第0位:"Light-duty", 小型车
                                                            // 第1位:"Medium", 中型车
                                                            // 第2位:"Oversize", 大型车
                                                            // 第3位:"Minisize", 微型车
                                                            // 第4位:"Largesize", 长车
    float              fVehicleLength;                      // 车辆长度    单位米
    int                nSnapshotMode;                       // 抓拍方式    0-未分类,1-全景,2-近景,4-同向抓拍,8-反向抓拍,16-号牌图像
    char               szChannelName[32];                   // 本地或远程的通道名称,可以是地点信息    来源于通道标题配置ChannelTitle.Name 
    char               szMachineName[256];                  // 本地或远程设备名称    来源于普通配置General.MachineName
    char               szMachineGroup[256];                 // 机器分组或叫设备所属单位    默认为空,用户可以将不同的设备编为一组,便于管理,可重复。
    char               szRoadwayNo[64];                     // 道路编号
    char               szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION];      // 
                                                                            // 行驶方向 , "DrivingDirection" : ["Approach", "上海", "杭州"],
                                                                            // "Approach"-上行,即车辆离设备部署点越来越近；"Leave"-下行,
                                                                            // 即车辆离设备部署点越来越远,第二和第三个参数分别代表上行和
                                                                            // 下行的两个地点
    char              *szDeviceAddress;                     // 设备地址,OSD叠加到图片上的,来源于配置TrafficSnapshot.DeviceAddress,'\0'结束
    char               szVehicleSign[32];                   // 车辆标识, 例如 "Unknown"-未知, "Audi"-奥迪, "Honda"-本田 ...
    DH_SIG_CARWAY_INFO_EX stuSigInfo;                       // 由车检器产生抓拍信号冗余信息
    char              *szMachineAddr;                       // 设备部署地点
    float              fActualShutter;                      // 当前图片曝光时间,单位为毫秒
    BYTE               byActualGain;                        // 当前图片增益,范围为0~100
    BYTE               byDirection;                         // 车道方向,0-南向北 1-西南向东北 2-西向东 3-西北向东南 4-北向南 5-东北向西南 6-东向西 7-东南向西北 8-未知 9-自定义
    BYTE               byReserved[2];
    char*              szDetailedAddress;                   // 详细地址, 作为szDeviceAddress的补充
    char               szDefendCode[DH_COMMON_STRING_64];   // 图片防伪码  
    int                nTrafficBlackListID;                 // 关联黑名单数据库记录默认主键ID, 0,无效；> 0,黑名单数据记录
    DH_COLOR_RGBA      stuRGBA;                             // 车身颜色RGBA
    NET_TIME           stSnapTime;                          // 抓拍时间
    int                nRecNo;                              // 记录编号
    char               szCustomParkNo[DH_COMMON_STRING_32 + 1]; // 自定义车位号（停车场用）
    BYTE               byReserved1[3];
    int                nDeckNo;                             // 车板位号
    int                nFreeDeckCount;                      // 空闲车板数量
    int                nFullDeckCount;                      // 占用车板数量
    int                nTotalDeckCount;                     // 总共车板数量 
    char               szViolationName[64];                 // 违章名称
    unsigned int	   nWeight;                             // 车重(单位 Kg)
    char               szCustomRoadwayDirection[32];        // 自定义车道方向,byDirection为9时有效
    BYTE               byPhysicalLane;                      // 物理车道号,取值0到5
    BYTE               byReserved2[3];
    EM_TRAFFICCAR_MOVE_DIRECTION emMovingDirection;         // 车辆行驶方向
    NET_TIME           stuEleTagInfoUTC;                    // 对应电子车牌标签信息中的过车时间(ThroughTime)
    NET_RECT           stuCarWindowBoundingBox;             // 车窗包围盒，0~8191
    NET_TRAFFICCAR_WHITE_LIST   stuWhiteList;               // 白名单信息
    EM_TRAFFICCAR_CAR_TYPE      emCarType;                  // 车辆类型
    EM_TRAFFICCAR_LANE_TYPE     emLaneType;                 // 车道类型
    char               szVehicleBrandYearText[64];          // 车系年款翻译后文本内容
    char               szCategory[32];                      // 车辆子类型
	NET_TRAFFICCAR_BLACK_LIST	stuBlackList;				// 黑名单信息
    BYTE               bReserved[240];                      // 保留字节,留待扩展.
}DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO;

#ifndef LINUX64_JNA
#pragma pack(push)
#pragma pack(4)
#endif
// GPS信息
typedef struct tagNET_GPS_INFO
{
    unsigned int                    nLongitude;         	// 经度(单位是百万分之一度)
                                                            // 西经：0 - 180000000				实际值应为: 180*1000000 C dwLongitude
                                                            // 东经：180000000 - 360000000		实际值应为: dwLongitude C 180*1000000
                                                            // 如: 300168866应为（300168866 - 180*1000000）/1000000 即东经120.168866度
    unsigned int					nLatidude;              // 纬度(单位是百万分之一度)
                                                            // 南纬：0 - 90000000				实际值应为: 90*1000000 C dwLatidude
                                                            // 北纬：90000000 C 180000000		实际值应为: dwLatidude C 90*1000000
															// 如: 120186268应为 (120186268 - 90*1000000)/1000000 即北纬30. 186268度
    double                          dbAltitude;              // 高度,单位为米
    double                          dbSpeed;                 // 速度,单位km/H
    double                          dbBearing;               // 方向角,单位°
	BYTE                            bReserved[8];           // 保留字段
}NET_GPS_INFO;
#ifndef LINUX64_JNA
#pragma pack(pop)
#endif

// 事件扩展信息
typedef struct tagNET_EXTENSION_INFO
{
	char        szEventID[MAX_EVENT_ID_LEN];				// 国标事件ID
	BYTE        byReserved[80];                             // 保留字节
} NET_EXTENSION_INFO;

// 全景广角图
typedef struct tagSCENE_IMAGE_INFO_EX
{
	unsigned int	   nOffSet;					// 在二进制数据块中的偏移   
	unsigned int	   nLength;					// 图片大小,单位字节
	unsigned int	   nWidth;					// 图片宽度(像素)
	unsigned int	   nHeight;					// 图片高度(像素)
	char               szFilePath[260];         // 全景图片路径
	BYTE			   byReserved[512];			// 预留字节
}SCENE_IMAGE_INFO_EX;

// 制服样式
typedef enum tagEM_UNIFORM_STYLE
{
    EM_UNIFORM_STYLE_UNKNOWN,						// 未知
    EM_UNIFORM_STYLE_POLICE,						// 警服
}EM_UNIFORM_STYLE;

// 检测到的人信息
typedef struct tagNET_VAOBJECT_NUMMAN
{
    UINT                nObjectID;                          // 物体ID，每个ID表示一个唯一的物体
    EM_UNIFORM_STYLE    emUniformStyle;                     // 制服样式
    NET_RECT			stuBoundingBox;                     // 包围盒,手套对象在全景图中的框坐标,为0~8191相对坐标
    NET_RECT			stuOriginalBoundingBox;             // 包围盒,绝对坐标
    BYTE			    byReserved[128];			        // 预留字节
}NET_VAOBJECT_NUMMAN;

// 事件类型EVENT_IVS_CROSSLINEDETECTION(警戒线事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CROSSLINE_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // 规则检测线
    int                 nDetectLineNum;                     // 规则检测线顶点数
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // 物体运动轨迹
    int                 nTrackLineNum;                      // 物体运动轨迹顶点数
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bDirection;                         // 表示入侵方向, 0-由左至右, 1-由右至左
    BYTE                byReserved[1];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
	SCENE_IMAGE_INFO_EX stuSceneImage;                      // 全景广角图
    UINT                nObjetcHumansNum;                   // 检测到人的数量
   NET_VAOBJECT_NUMMAN stuObjetcHumans[100];                // 检测的到人
    BYTE			    byReserved1[512];			        // 预留字节 
} DEV_EVENT_CROSSLINE_INFO;

// 事件类型EVENT_IVS_CROSSLINEDETECTION_EX(警戒线事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CROSSLINE_INFO_EX 
{
    DWORD               dwSize;
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    float               PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT_EX    stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM]; // 规则检测线
    int                 nDetectLineNum;                     // 规则检测线顶点数
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // 物体运动轨迹
    int                 nTrackLineNum;                      // 物体运动轨迹顶点数
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bDirection;                         // 表示入侵方向, 0-由左至右, 1-由右至左
    BYTE                byReserved[1];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数

    int                 nMsgObjArrayCount;                  // 检测到的物体信息个数
    DH_MSG_OBJECT_EX*   pMsgObjArray;                       // 检测到的物体信息数组指针
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	SCENE_IMAGE_INFO_EX stuSceneImage;                      // 全景广角图
    UINT                nObjetcHumansNum;                	// 检测到人的数量
    NET_VAOBJECT_NUMMAN stuObjetcHumans[100];               // 检测的到人
    BYTE			    byReserved1[512];			        // 预留字节
} DEV_EVENT_CROSSLINE_INFO_EX;

// 货物通道信息（IPC捷克物流定制）
typedef struct tagNET_CUSTOM_INFO
{
	int					nCargoChannelNum;						// 货物通道个数
	float				fCoverageRate[MAX_CARGO_CHANNEL_NUM];	// 货物覆盖率
	BYTE				byReserved[40];							// 保留字节
} NET_CUSTOM_INFO;

// 事件类型EVENT_IVS_CROSSREGIONDETECTION(警戒区事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CROSSREGION_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved2[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];   // 物体运动轨迹
    int                 nTrackLineNum;                      // 物体运动轨迹顶点数
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bDirection;                         // 表示入侵方向, 0-进入, 1-离开,2-出现,3-消失
    BYTE                bActionType;                        // 表示检测动作类型,0-出现 1-消失 2-在区域内 3-穿越区域
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
	NET_CUSTOM_INFO		stuCustom;							// 货物通道信息
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
	BYTE                bReserved[328];                     // 保留字节,留待扩展.
    int                 nObjectNum;                         // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // 检测到的物体
    int                 nTrackNum;                          // 轨迹数(与检测到的物体个数对应)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];   // 轨迹信息(与检测到的物体对应)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	SCENE_IMAGE_INFO_EX stuSceneImage;                      // 全景广角图
    UINT                nObjetcHumansNum;                   // 检测到人的数量
    NET_VAOBJECT_NUMMAN stuObjetcHumans[100];               // 检测的到人
    BYTE			    byReserved1[512];			    	// 保留字节
} DEV_EVENT_CROSSREGION_INFO;

//特殊区域类型
typedef enum tagEM_SPECIAL_REGION_TYPE
{
    EM_SPEICAL_REGION_UNKNOW = 0        , // 未知
    EM_SPEICAL_REGION_HIGH_LIGHT        , // 高亮;ATM键盘区
    EM_SPEICAL_REGION_REGULAR_BLINK     , // 规律的闪烁;ATM插卡区
    EM_SPEICAL_REGION_IRREGULAR_BLINK   , // 不规律的闪烁;ATM屏幕区
}EM_SPECIAL_REGION_TYPE;

// 事件类型EVENT_IVS_PASTEDETECTION(贴条事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_PASTE_INFO 
{
    int                     nChannelID;                         // 通道号
    char                    szName[128];                        // 事件名称
    char                    bReserved1[4];                      // 字节对齐
    double                  PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                // 事件发生的时间
    int                     nEventID;                           // 事件ID
    DH_MSG_OBJECT           stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO      stuFileInfo;                        // 事件对应文件信息
    int                     nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT                DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    BYTE                    bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                    byReserved[2];
    BYTE                    byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD                   dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    unsigned int            nOccurrenceCount;                   // 事件触发累计次数
    EM_SPECIAL_REGION_TYPE  emSpecialRegion;                    // 特殊区域类型
    EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                    bReserved[748];                     // 保留字节,留待扩展.
} DEV_EVENT_PASTE_INFO;

// 事件类型EVENT_IVS_LEFTDETECTION(物品遗留事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_LEFT_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	short				nPreserID;							// 事件触发的预置点号，从1开始（没有表示未知）
	char				szPresetName[64];					// 事件触发的预置名称
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
    BYTE                bReserved[290];                     // 保留字节,留待扩展.
} DEV_EVENT_LEFT_INFO;

// 事件类型EVENT_IVS_PRESERVATION(物品保全事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_PRESERVATION_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    BYTE                bReserved[488];                     // 保留字节,留待扩展.
} DEV_EVENT_PRESERVATION_INFO;

// 事件类型EVENT_IVS_STAYDETECTION(停留事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_STAY_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    int                 nObjectNum;                         // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_NUM];    // 检测到的物体
	UINT				nAreaID;							// 区域ID(一个预置点可以对应多个区域ID)
    BOOL                bIsCompliant;                       // 该场景下是否合规
	BYTE                bReserved[1016];                    // 保留字节,留待扩展.
} DEV_EVENT_STAY_INFO;

// 事件类型EVENT_IVS_WANDERDETECTION(徘徊事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WANDER_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nObjectNum;                         // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // 检测到的物体
    int                 nTrackNum;                          // 轨迹数(与检测到的物体个数对应)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];   // 轨迹信息(与检测到的物体对应)
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	short				nPreserID;							// 事件触发的预置点号，从1开始（没有表示未知）
	char				szPresetName[64];					// 事件触发的预置名称
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
    BYTE                bReserved[426];                     // 保留字节,留待扩展.
} DEV_EVENT_WANDER_INFO;

// 事件类型EVENT_IVS_MOVEDETECTION(移动事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_MOVE_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    int                 nTrackLineNum;                      // 物体运动轨迹顶点数                 
    DH_POINT            stuTrackLine[DH_MAX_TRACK_LINE_NUM];// 物体运动轨迹      
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
    BYTE                bReserved[272];                     // 保留字节,留待扩展.
} DEV_EVENT_MOVE_INFO;

// 事件类型EVENT_IVS_TAILDETECTION(尾随事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TAIL_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    BYTE                bReserved[488];                     // 保留字节,留待扩展.
} DEV_EVENT_TAIL_INFO;

// 事件类型 EVENT_IVS_RIOTERDETECTION (聚众事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_RIOTER_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    int                 nObjectNum;                         // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // 检测到的物体列表
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域

    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	NET_EXTENSION_INFO	stuExtensionInfo;                   // 扩展信息
    BYTE                bReserved[360];                     // 保留字节,留待扩展.
} DEV_EVENT_RIOTERL_INFO;

// 事件类型EVENT_IVS_FIGHTDETECTION(斗殴事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FIGHT_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    int                 nObjectNum;                         // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];   // 检测到的物体列表
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域
    
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
    BYTE                bReserved[360];                     // 保留字节,留待扩展.
} DEV_EVENT_FIGHT_INFO;

// 事件类型EVENT_IVS_FIREDETECTION(火警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FIRE_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域
    
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    BYTE                bReserved[488];                     // 保留字节,留待扩展.
} DEV_EVENT_FIRE_INFO;

// 事件类型EVENT_IVS_GETOUTBEDDETECTION(看守所下床事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_GETOUTBED_INFO 
{
    // 公共字段
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    // 事件对应字段
    DH_MSG_OBJECT       stuObject;                          // Object表示下床的物体信息
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // 保留字节,留待扩展. 
} DEV_EVENT_GETOUTBED_INFO;

// 事件类型EVENT_IVS_PATROLDETECTION(巡逻检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_PATROL_INFO 
{
    // 公共字段
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    // 事件对应字段
    DH_MSG_OBJECT       stuObject;                          // Object表示巡逻的物体信息
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // 保留字节,留待扩展. 
} DEV_EVENT_PATROL_INFO;

// 事件类型 EVENT_IVS_ONDUTYDETECTION(站岗检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ONDUTY_INFO
{
    // 公共字段
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    // 事件对应字段
    DH_MSG_OBJECT       stuObject;                          // Object表示巡逻的物体信息
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[1024];                    // 保留字节,留待扩展. 
} DEV_EVENT_ONDUTY_INFO;

// 事件类型 EVENT_IVS_ELECTROSPARKDETECTION(电火花事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTROSPARK_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[972];                     // 保留字节,留待扩展.
    
} DEV_EVENT_ELECTROSPARK_INFO;

// 事件类型EVENT_IVS_SMOKEDETECTION(烟雾报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SMOKE_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_MSG_OBJECT       stuObject;                          // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON   
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	PTZ_SPACE_UNIT		stuPtzPosition;						// 云台的坐标和放大倍数
    BYTE                bReserved[792];                     // 保留字节,留待扩展.
} DEV_EVENT_SMOKE_INFO;

// 事件类型EVENT_IVS_FLOWSTAT(流量统计事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FLOWSTAT_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    int                 nNumberLeft;                        // 从左边穿越的人的个数
    int                 nNumberRight;                       // 从右边穿越的人的个数
    int                 nUpperLimit;                        // 设置的上限
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON  
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    BYTE                bReserved[972];                     // 保留字节,留待扩展.

} DEV_EVENT_FLOWSTAT_INFO;

// 事件类型EVENT_IVS_NUMBERSTAT(数量统计事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_NUMBERSTAT_INFO 
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved2[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    int                 nNumber;                            // 区域内物体的个数
    int                 nUpperLimit;                        // 设置的上限
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved1[2];                      // 字节对齐
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nEnteredNumber;                     // 表示进入区域或者出入口的内物体的个数
    int                 nExitedNumber;                      // 表示出来区域或者出入口的内物体的个数
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    UINT				nAreaID;							// 区域ID，一个预置点可以有多个区域ID
    BOOL                bIsCompliant;                       // 该场景下是否合规
	BYTE                bReserved[820];                     // 保留字节,留待扩展.
} DEV_EVENT_NUMBERSTAT_INFO;

// 事件类型EVENT_IVS_CROSSFENCEDETECTION(翻越围栏事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CROSSFENCEDETECTION_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nUpstairsLinePointNumber;                   // 围栏上边线顶点数
    DH_POINT            stuUpstairsLine[DH_MAX_DETECT_LINE_NUM];    // 围栏上边线信息
    int                 nDownstairsLinePointNumber;                 // 围栏下边线顶点数
    DH_POINT            stuDownstairsLine[DH_MAX_DETECT_LINE_NUM];  // 围栏下边线信息  
    int                 nTrackLineNum;                              // 物体运动轨迹顶点数                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // 物体运动轨迹
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bDirection;                                 // 表示入侵方向, 0-由左至右, 1-由右至左
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[616];                             // 保留字节,留待扩展.    
} DEV_EVENT_CROSSFENCEDETECTION_INFO;

// 事件类型EVENT_IVS_INREGIONDETECTION(区域内检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_INREGIONDETECTION_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nObjectNum;                                 // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // 检测到的物体
    int                 nTrackNum;                                  // 轨迹数(与检测到的物体个数对应)
    DH_POLY_POINTS      stuTrackInfo[DH_MAX_OBJECT_LIST];           // 轨迹信息(与检测到的物体对应)
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[1016];                            // 保留字节,留待扩展.
    
} DEV_EVENT_INREGIONDETECTION_INFO;

// 事件类型EVENT_IVS_TAKENAWAYDETECTION(物品搬移事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TAKENAWAYDETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	short				nPreserID;									// 事件触发的预置点号，从1开始（没有表示未知）
	char				szPresetName[64];							// 事件触发的预置名称
	NET_EXTENSION_INFO  stuExtensionInfo;					        // 扩展信息
	BYTE                bReserved[418];                             // 保留字节,留待扩展.
} DEV_EVENT_TAKENAWAYDETECTION_INFO;

// 事件类型 EVENT_IVS_VIDEOABNORMALDETECTION(视频异常事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_VIDEOABNORMALDETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bType;                                      // 异常类型, 255-无意义（通常是设备了返回错误值）0-视频丢失, 1-视频冻结, 2-摄像头遮挡, 3-摄像头移动, 4-过暗, 5-过亮, 6-图像偏色, 7-噪声干扰
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[620];                             // 保留字节,留待扩展.
} DEV_EVENT_VIDEOABNORMALDETECTION_INFO;

// 事件类型EVENT_IVS_PARKINGDETECTION(非法停车事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_PARKINGDETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	NET_EXTENSION_INFO  stuExtensionInfo;					        // 扩展信息
    BYTE                bReserved[484];                             // 保留字节,留待扩展.
} DEV_EVENT_PARKINGDETECTION_INFO;

// 事件级别，GB30147需求
typedef enum tagEM_EVENT_LEVEL
{
	EM_EVENT_LEVEL_HINT = 0,										// 提示
	EM_EVENT_LEVEL_GENERAL,											// 普通
	EM_EVENT_LEVEL_WARNING											// 警告
}EM_EVENT_LEVEL;

#define HDBJ_MAX_OBJECTS_NUM 200            // 检测到目标的最大个数

// 事件类型EVENT_IVS_SHOPPRESENCE(商铺占道经营事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SHOPPRESENCE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体，推荐使用字段stuObjects获取物体信息
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	char				szPresetName[DH_COMMON_STRING_64];			// 事件触发的预置点名称
	EM_EVENT_LEVEL		emEventLevel;								// 事件级别，GB30147需求
	char				szShopAddress[DH_COMMON_STRING_256];		// 商铺地址
    UINT                nViolationDuration;                         // 违法持续时长，单位：秒，缺省值0表示无意义
    int					nObjectNum;									// 检测到的物体个数
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];			// 检测到的物体
    char				szSourceID[32];								// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	BYTE                byReserved2[2048];							// 保留字节
} DEV_EVENT_SHOPPRESENCE_INFO;

// 事件类型EVENT_IVS_WASTEDUMPED(垃圾违章倾倒事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WASTEDUMPED_INFO
{
	int                 nChannelID;                                 // 通道号
	char                szName[128];                                // 事件名称
	char                bReserved1[4];                              // 字节对齐
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	int                 nEventID;                                   // 事件ID
	DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
	int                 nDetectRegionNum;                           // 规则检测区域顶点数
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byReserved[2];
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
	char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
	unsigned int        nOccurrenceCount;                           // 事件触发累计次数
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	char				szPresetName[DH_COMMON_STRING_64];			// 事件触发的预置点名称
	EM_EVENT_LEVEL		emEventLevel;								// 事件级别，GB30147需求
	BYTE                byReserved2[512];							// 保留字节,留待扩展.
} DEV_EVENT_WASTEDUMPED_INFO;

// 事件类型EVENT_IVS_ABNORMALRUNDETECTION(异常奔跑事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ABNORMALRUNDETECTION 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    double              dbSpeed;                                    // 物体运动速度,km/h
    double              dbTriggerSpeed;                             // 触发速度,km/h
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    int                 nTrackLineNum;                              // 物体运动轨迹顶点数                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // 物体运动轨迹
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bRunType;                                   // 异常奔跑类型, 0-快速奔跑, 1-突然加速, 2-突然减速
    BYTE                byReserved[1];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[616];                             // 保留字节,留待扩展.
} DEV_EVENT_ABNORMALRUNDETECTION_INFO;

// 事件类型EVENT_IVS_RETROGRADEDETECTION(人员逆行事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_RETROGRADEDETECTION_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nTrackLineNum;                              // 物体运动轨迹顶点数                 
    DH_POINT            TrackLine[DH_MAX_TRACK_LINE_NUM];           // 物体运动轨迹
    int                 nDirectionPointNum;                         // 规则里规定的方向顶点数
    DH_POINT            stuDirections[DH_MAX_DETECT_LINE_NUM];      // 规则里规定的方向
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[616];                             // 保留字节,留待扩展.
} DEV_EVENT_RETROGRADEDETECTION_INFO;

//人脸检测对应性别类型
typedef enum tagEM_DEV_EVENT_FACEDETECT_SEX_TYPE
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN,                   // 未知
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN,                       // 男性
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN,                     // 女性
}EM_DEV_EVENT_FACEDETECT_SEX_TYPE;


//民族
typedef enum tagEM_NATION_TYPE
{
	EM_NATION_TYPE_UNKNOWN,                                             // 未知
	EM_NATION_TYPE_UYGUR,                                               // 维族(新疆)	
	EM_NATION_TYPE_OTHER,                                               // 其他
	EM_NATION_TYPE_UNIDENTIFIED,                                        // 设备未识别	
}EM_NATION_TYPE;

// 姿态角数据
typedef struct tagNET_EULER_ANGLE
{
	int		nPitch;				// 仰俯角
	int		nYaw;				// 偏航角
	int		nRoll;				// 翻滚角
} NET_EULER_ANGLE;

// 人脸数据
typedef struct tagNET_FACE_DATA
{
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE 		emSex;						// 性别
	int        								nAge;						// 年龄,-1表示该字段数据无效
    unsigned int        					nFeatureValidNum;           // 人脸特征数组有效个数,与 emFeature 结合使用
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 nFeatureValidNum 结合使用
	EM_RACE_TYPE							emRace;						// 种族
	EM_EYE_STATE_TYPE						emEye;						// 眼睛状态
	EM_MOUTH_STATE_TYPE						emMouth;					// 嘴巴状态
	EM_MASK_STATE_TYPE 						emMask;						// 口罩状态
	EM_BEARD_STATE_TYPE						emBeard;					// 胡子状态
	int										nAttractive;				// 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
	EM_NATION_TYPE                          emNation;                   // 民族
	NET_EULER_ANGLE							stuFaceCaptureAngle;		// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
																		// 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
	UINT									nFaceQuality;				// 人脸抓拍质量分数
    int                                     nFaceAlignScore;            // 人脸对齐得分分数,范围 0~10000,-1为无效值
    int                                     nFaceClarity;               // 人脸清晰度分数,范围 0~10000,-1为无效值

    BYTE                					bReserved[100];             // 保留字节,留待扩展.
} NET_FACE_DATA;

// 存储IVSS项目招行VIP需求,特征值信息
typedef struct tagNET_FEATURE_VECTOR
{
	DWORD				dwOffset;							// 人脸小图特征值在二进制数据块中的偏移
	DWORD				dwLength;							// 人脸小图特征值长度，单位:字节
	BYTE				byReserved[120];					// 保留
}NET_FEATURE_VECTOR;

// 人脸在摄像机画面中的状态
typedef enum tagEM_FACE_DETECT_STATUS
{
    EM_FACE_DETECT_UNKNOWN,             // 未知
    EM_FACE_DETECT_APPEAR,              // 出现
    EM_FACE_DETECT_INPICTURE,           // 在画面中
    EM_FACE_DETECT_EXIT,                // 离开
} EM_FACE_DETECT_STATUS;

// 路人信息
typedef struct tagNET_PASSERBY_INFO
{
	char				szPasserbyUID[MAX_COMMON_STRING_32];			// 路人唯一标识符
	char                szPasserbyGroupId[MAX_COMMON_STRING_64];		// 路人库ID
	char				szPasserbyGroupName[MAX_COMMON_STRING_128];		// 路人库名称
	BYTE				byReserved[128];									// 保留
} NET_PASSERBY_INFO;

// 事件类型EVENT_IVS_FACERECOGNITION(人脸识别)对应的数据块描述信息
typedef struct tagDEV_EVENT_FACERECOGNITION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    int                 nEventID;                                   // 事件ID
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nCandidateNum;                              // 当前人脸匹配到的候选对象数量
    CANDIDATE_INFO      stuCandidates[DH_MAX_CANDIDATE_NUM];        // 当前人脸匹配到的候选对象信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];                             // 对齐
    BOOL                bGlobalScenePic;                            // 全景图是否存在
    DH_PIC_INFO         stuGlobalScenePicInfo;                      // 全景图片信息
    char                szSnapDevAddress[MAX_PATH];                 // 抓拍当前人脸的设备地址,如：滨康路37号  
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	NET_FACE_DATA		stuFaceData;								// 人脸数据
	char				szUID[DH_COMMON_STRING_32];					// 抓拍人员写入数据库的唯一标识符
	NET_FEATURE_VECTOR	stuFeatureVector;							// 特征值信息
	char				szFeatureVersion[32];						// 特征值算法版本
	EM_FACE_DETECT_STATUS emFaceDetectStatus;                       // 人脸在摄像机画面中的状态
    char				szSourceID[32];								// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
    NET_PASSERBY_INFO	stuPasserbyInfo;							// 路人库信息
	unsigned int		nStayTime;									// 路人逗留时间 单位：秒
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息
	BYTE                bReserved[432];                             // 保留字节,留待扩展.
    int					nRetCandidatesExNum;						// 当前人脸匹配到的候选对象数量实际返回值
	CANDIDATE_INFOEX    stuCandidatesEx[DH_MAX_CANDIDATE_NUM];      // 当前人脸匹配到的候选对象信息扩展
	char				szSerialUUID[22];							// 级联物体ID唯一标识
																	// 格式如下：前2位%d%d:01-视频片段,02-图片,03-文件,99-其他;
																	// 中间14位YYYYMMDDhhmmss:年月日时分秒;后5位%u%u%u%u%u：物体ID，如00001
	BYTE                byReserved[2];                              // 对齐

}DEV_EVENT_FACERECOGNITION_INFO;

// 事件类型EVENT_IVS_DENSITYDETECTION(人员密度检测)对应数据块描述信息
typedef struct tagDEV_EVENT_DENSITYDETECTTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nObjectNum;                                 // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // 检测到的物体列表
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                              // 保留字节
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域

    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// 智能事件公共信息
    int					nUnit;										// 密度检测数值单位(0-Level,1-Percent)
	int					nValue;										// 密度值，单位为Level时，取值0~3，分别表示(很稀疏，稀疏，密集，很密集)单位为Percent时，取值0~100
	BYTE                bReserved[612];                             // 保留字节,留待扩展.
}DEV_EVENT_DENSITYDETECTION_INFO;

// 事件类型 EVENT_IVS_QUEUEDETECTION(排队检测报警事件)对应数据块描述信息
typedef struct tagDEV_EVENT_QUEUEDETECTION_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved2[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved1[2];                              // 保留字节,留待扩展.
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DH_POINT            stuDetectLine[2];                           // 规则检测线
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    BYTE                bReserved[1012];                            // 保留字节,留待扩展.
}DEV_EVENT_QUEUEDETECTION_INFO;

// 事件类型EVENT_IVS_TRAFFICCONTROL(交通管制事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFICCONTROL_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[932];                             // 保留字节,留待扩展.

} DEV_EVENT_TRAFFICCONTROL_INFO;


// 事件类型EVENT_IVS_TRAFFICACCIDENT(交通事故事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFICACCIDENT_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nObjectNum;                                 // 检测到的物体个数
    DH_MSG_OBJECT       stuObjectIDs[DH_MAX_OBJECT_LIST];           // 检测到的物体列表
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // 交通车辆部分信息
    UINT                nLane;                                      // 车道号
    BYTE                bReserved[460];                             // 保留字节,留待扩展.

} DEV_EVENT_TRAFFICACCIDENT_INFO;

#define DH_EVENT_MAX_CARD_NUM       16      // 事件上报信息包含最大卡片个数
#define DH_EVENT_CARD_LEN           36      // 卡片名称长度

// 事件上报携带卡片信息
typedef struct tagEVENT_CARD_INFO
{
    char szCardNumber[DH_EVENT_CARD_LEN];           // 卡片序号字符串
    BYTE bReserved[32];                             // 保留字节,留待扩展.
}EVENT_CARD_INFO;

typedef enum tagEM_OPEN_STROBE_STATE
{
    NET_OPEN_STROBE_STATE_UNKOWN,                   // 未知状态
    NET_OPEN_STROBE_STATE_CLOSE,                    // 关闸
    NET_OPEN_STROBE_STATE_AUTO,                     // 自动开闸    
    NET_OPEN_STROBE_STATE_MANUAL,                   // 手动开闸
}EM_OPEN_STROBE_STATE;

typedef enum tagEM_VEHICLE_DIRECTION
{
    NET_VEHICLE_DIRECTION_UNKOWN,                   // 未知
    NET_VEHICLE_DIRECTION_HEAD,                     // 车头    
    NET_VEHICLE_DIRECTION_TAIL,                     // 车尾  
}EM_VEHICLE_DIRECTION;

//NTP校时状态
typedef enum  tagEM_NTP_STATUS
{
    NET_NTP_STATUS_UNKNOWN = 0 ,
    NET_NTP_STATUS_DISABLE , 
    NET_NTP_STATUS_SUCCESSFUL , 
    NET_NTP_STATUS_FAILED , 
}EM_NTP_STATUS;

#define COMMON_SEAT_MAX_NUMBER        8             // 默认检测最大座驾个数

typedef enum tagEM_COMMON_SEAT_TYPE
{
    COMMON_SEAT_TYPE_UNKNOWN    = 0,                // 未识别
    COMMON_SEAT_TYPE_MAIN       = 1,                // 主驾驶
    COMMON_SEAT_TYPE_SLAVE      = 2,                // 副驾驶
}EM_COMMON_SEAT_TYPE;

// 违规状态
typedef struct tagEVENT_COMM_STATUS                 
{
    BYTE bySmoking;                                 // 是否抽烟
    BYTE byCalling;                                 // 是否打电话
    char szReserved[14];                            // 预留字段
}EVENT_COMM_STATUS;

typedef enum tagNET_SAFEBELT_STATE
{
    SS_NUKNOW   = 0 ,				//未知
	SS_WITH_SAFE_BELT ,				                //已系安全带  
	SS_WITHOUT_SAFE_BELT ,			                //未系安全带
}NET_SAFEBELT_STATE;

//遮阳板状态
typedef enum tagNET_SUNSHADE_STATE
{
    SS_NUKNOW_SUN_SHADE	= 0 ,						// 未知
	SS_WITH_SUN_SHADE,				                // 有遮阳板  
	SS_WITHOUT_SUN_SHADE,			                // 无遮阳板
}NET_SUNSHADE_STATE;
// 驾驶位违规信息
typedef struct tagEVENT_COMM_SEAT
{
    BOOL                    bEnable;                // 是否检测到座驾信息
    EM_COMMON_SEAT_TYPE     emSeatType;             // 座驾类型, 0:未识别; 1:主驾驶; 2:副驾驶
    EVENT_COMM_STATUS       stStatus;               // 违规状态
	NET_SAFEBELT_STATE      emSafeBeltStatus;       // 安全带状态
    NET_SUNSHADE_STATE      emSunShadeStatus;       // 遮阳板状态
    char                    szReserved[24];         // 预留字节
}EVENT_COMM_SEAT;

// 车辆物件类型
typedef enum tagEM_COMM_ATTACHMENT_TYPE      
{       
	COMM_ATTACHMENT_TYPE_UNKNOWN    = 0,            // 未知类型       
    COMM_ATTACHMENT_TYPE_FURNITURE  = 1,            // 摆件       
    COMM_ATTACHMENT_TYPE_PENDANT    = 2,            // 挂件       
    COMM_ATTACHMENT_TYPE_TISSUEBOX  = 3,            // 纸巾盒       
    COMM_ATTACHMENT_TYPE_DANGER     = 4,            // 危险品  
    COMM_ATTACHMENT_TYPE_PERFUMEBOX = 5,			// 香水
 }EM_COMM_ATTACHMENT_TYPE;

// 车辆物件
typedef struct tagEVENT_COMM_ATTACHMENT      
{       
	EM_COMM_ATTACHMENT_TYPE     emAttachmentType;       // 物件类型       
	NET_RECT                    stuRect;                // 坐标   
    BYTE						bReserved[20];		    // 预留字节
 }EVENT_COMM_ATTACHMENT;

// 交通抓图图片信息
typedef struct tagEVENT_PIC_INFO
{
    DWORD                       nOffset;                // 原始图片偏移，单位字节
    DWORD                       nLength;                // 原始图片长度，单位字节
}EVENT_PIC_INFO;

//收费站车型分类
typedef enum tagEM_VEHICLE_TYPE
{
	EM_VEHICLE_TYPE_UNKNOWN,                            // 未知
	EM_VEHICLE_TYPE_PASSENGERCAR1,                      // 客1
	EM_VEHICLE_TYPE_TRUCK1,                             // 货1
	EM_VEHICLE_TYPE_PASSENGERCAR2,                      // 客2 
	EM_VEHICLE_TYPE_TRUCK2,                             // 货2
	EM_VEHICLE_TYPE_PASSENGERCAR3,                      // 客3
	EM_VEHICLE_TYPE_TRUCK3,                             // 货3
	EM_VEHICLE_TYPE_PASSENGERCAR4,                      // 客4 
	EM_VEHICLE_TYPE_TRUCK4,                             // 货4
	EM_VEHICLE_TYPE_PASSENGERCAR5,                      // 客5
	EM_VEHICLE_TYPE_TRUCK5,                             // 货5
}EM_VEHICLE_TYPE;

//抓拍的类型
typedef enum tagEM_SNAPCATEGORY
{
    EM_SNAPCATEGORY_MOTOR,                         // 机动车
    EM_SNAPCATEGORY_NONMOTOR,                      // 非机动车
}EM_SNAPCATEGORY;

// 按功能划分的车辆类型
typedef enum tagEM_VEHICLE_TYPE_BY_FUNC
{
    EM_VEHICLE_TYPE_BY_FUNC_UNKNOWN,                // 未知
    /*以下为特种车辆类型*/
    EM_VEHICLE_TYPE_BY_FUNC_TANK_CAR,               // 危化品车辆
    EM_VEHICLE_TYPE_BY_FUNC_SLOT_TANK_CAR,          // 槽罐车
    EM_VEHICLE_TYPE_BY_FUNC_DREGS_CAR,              // 渣土车
    EM_VEHICLE_TYPE_BY_FUNC_CONCRETE_MIXER_TRUCK,   // 混凝土搅拌车
    EM_VEHICLE_TYPE_BY_FUNC_TAXI,                   // 出租车
    EM_VEHICLE_TYPE_BY_FUNC_POLICE,                 // 警车
    EM_VEHICLE_TYPE_BY_FUNC_AMBULANCE,              // 救护车
    EM_VEHICLE_TYPE_BY_FUNC_GENERAL,                // 普通车
    EM_VEHICLE_TYPE_BY_FUNC_WATERING_CAR,           // 洒水车
    EM_VEHICLE_TYPE_BY_FUNC_FIRE_ENGINE,            // 消防车
    EM_VEHICLE_TYPE_BY_FUNC_MACHINESHOP_TRUCK,      // 工程车
    EM_VEHICLE_TYPE_BY_FUNC_POWER_LOT_VEHICLE,      // 粉粒物料车
    EM_VEHICLE_TYPE_BY_FUNC_SUCTION_SEWAGE_TRUCK,   // 吸污车
    EM_VEHICLE_TYPE_BY_FUNC_NORMAL_TANK_TRUCK,      // 普通罐车
    EM_VEHICLE_TYPE_BY_FUNC_SCHOOL_BUS,             // 校车
    EM_VEHICLE_TYPE_BY_FUNC_EXCAVATOR,              // 挖掘机
    EM_VEHICLE_TYPE_BY_FUNC_BULLDOZER,              // 推土车
    EM_VEHICLE_TYPE_BY_FUNC_CRANE,                  // 吊车
    EM_VEHICLE_TYPE_BY_FUNC_PUMP_TRUCK,             // 泵车
    /*以上为特种车辆类型*/
} EM_VEHICLE_TYPE_BY_FUNC;

// 标准车辆类型
typedef enum tagEM_STANDARD_VEHICLE_TYPE
{
    EM_STANDARD_VEHICLE_UNKNOWN,               // 未知
    EM_STANDARD_VEHICLE_MOTOR,                 // 机动车
    EM_STANDARD_VEHICLE_BUS,                   // 公交车
    EM_STANDARD_VEHICLE_UNLICENSED_MOTOR,      // 无牌机动车
    EM_STANDARD_VEHICLE_LARGE_CAR,             // 大型汽车
    EM_STANDARD_VEHICLE_MICRO_CAR,             // 小型汽车
    EM_STANDARD_VEHICLE_EMBASSY_CAR,           // 使馆汽车
    EM_STANDARD_VEHICLE_MARGINAL_CAR,          // 领馆汽车
    EM_STANDARD_VEHICLE_AREAOUT_CAR,           // 境外汽车
    EM_STANDARD_VEHICLE_FOREIGN_CAR,           // 外籍汽车
    EM_STANDARD_VEHICLE_FARM_TRANS_CAR,        // 农用运输车
    EM_STANDARD_VEHICLE_TRACTOR,               // 拖拉机
    EM_STANDARD_VEHICLE_TRAILER,               // 挂车
    EM_STANDARD_VEHICLE_COACH_CAR,             // 教练汽车
    EM_STANDARD_VEHICLE_TRIAL_CAR,             // 试验汽车
    EM_STANDARD_VEHICLE_TEMPORARYENTRY_CAR,    // 临时入境汽车
    EM_STANDARD_VEHICLE_TEMPORARYENTRY_MOTORCYCLE,  // 临时入境摩托
    EM_STANDARD_VEHICLE_TEMPORARY_STEER_CAR,        // 临时行驶车
    EM_STANDARD_VEHICLE_LARGE_TRUCK,                // 大货车
    EM_STANDARD_VEHICLE_MID_TRUCK,                  // 中货车
    EM_STANDARD_VEHICLE_MICRO_TRUCK,                // 小货车
    EM_STANDARD_VEHICLE_MICROBUS,                   // 面包车
    EM_STANDARD_VEHICLE_SALOON_CAR,                 // 轿车
    EM_STANDARD_VEHICLE_CARRIAGE,                   // 小轿车
    EM_STANDARD_VEHICLE_MINI_CARRIAGE,              // 微型轿车
    EM_STANDARD_VEHICLE_SUV_MPV,                    // SUV或者MPV
    EM_STANDARD_VEHICLE_SUV,                        // SUV
    EM_STANDARD_VEHICLE_MPV,                        // MPV
    EM_STANDARD_VEHICLE_PASSENGER_CAR,              // 客车
    EM_STANDARD_VEHICLE_MOTOR_BUS,                  // 大客车
    EM_STANDARD_VEHICLE_MID_PASSENGER_CAR,          // 中客车
    EM_STANDARD_VEHICLE_MINI_BUS,                   // 小客车
    EM_STANDARD_VEHICLE_PICKUP,                     // 皮卡车
    EM_STANDARD_VEHICLE_OILTANK_TRUCK,              // 油罐车
} EM_STANDARD_VEHICLE_TYPE;


//海外车辆类型中的子类别，一个车辆只能是子类型的某一种。（海外专用
typedef enum tagEM_OVERSEA_VEHICLE_CATEGORY_TYPE
{
    EM_OVERSEA_VEHICLE_CATEGORY_UNKNOWN,                     // 未知
    EM_OVERSEA_VEHICLE_CATEGORY_MOTORCYCLE,                  //摩托车
    EM_OVERSEA_VEHICLE_CATEGORY_LIGHT_GOODS_VEHICLE,         //轻型货车
    EM_OVERSEA_VEHICLE_CATEGORY_COMPANY_VEHICLE,             //公司用私家车        
    EM_OVERSEA_VEHICLE_CATEGORY_PRIVATE_VEHICLE,             //个人用私家车
    EM_OVERSEA_VEHICLE_CATEGORY_TAXI,                        //TAXI或者快线车
    EM_OVERSEA_VEHICLE_CATEGORY_TRAILER,                     //拖车
    EM_OVERSEA_VEHICLE_CATEGORY_ENGINEERING_PLANT_VEHICLE,   //工程车
    EM_OVERSEA_VEHICLE_CATEGORY_VERY_HEAVY_GOODS_VEHICLE,    //超大货车
    EM_OVERSEA_VEHICLE_CATEGORY_HEAVY_GOODS_VEHICLE,         //大货车
    EM_OVERSEA_VEHICLE_CATEGORY_PUBLIC_BUS,                  //公共BUS 
    EM_OVERSEA_VEHICLE_CATEGORY_PRIVATE_BUS,                 //私营BUS  
    EM_OVERSEA_VEHICLE_CATEGORY_SPECIAL_VEHICLE,             //特殊车辆
}EM_OVERSEA_VEHICLE_CATEGORY_TYPE;

typedef struct tagEVENT_COMM_INFO
{
    EM_NTP_STATUS               emNTPStatus;                                            // NTP校时状态
    int                         nDriversNum;                                            // 驾驶员信息数
    DH_MSG_OBJECT_EX            *pstDriversInfo;                                        // 驾驶员信息数据 
    char*                       pszFilePath;                                            // 本地硬盘或者sd卡成功写入路径,为NULL时,路径不存在
    char*                       pszFTPPath;                                             // 设备成功写到ftp服务器的路径
    char*                       pszVideoPath;                                           // 当前接入需要获取当前违章的关联视频的FTP上传路径
    EVENT_COMM_SEAT             stCommSeat[COMMON_SEAT_MAX_NUMBER];                     // 驾驶位信息
    int                         nAttachmentNum;                                         // 车辆物件个数
    EVENT_COMM_ATTACHMENT       stuAttachment[NET_MAX_ATTACHMENT_NUM];                  // 车辆物件信息
    int                         nAnnualInspectionNum;                                   // 年检标志个数
    NET_RECT                    stuAnnualInspection[NET_MAX_ANNUUALINSPECTION_NUM];     // 年检标志
    float                       fHCRatio;                                               // HC所占比例，单位：%/1000000 
    float                       fNORatio;                                               // NO所占比例，单位：%/1000000 
    float                       fCOPercent;                                             // CO所占百分比，单位：% 取值0~100
    float                       fCO2Percent;                                            // CO2所占百分比，单位：% 取值0~100     
    float                       fLightObscuration;                                      // 不透光度，单位：% 取值0~100
    int                         nPictureNum;                                            // 原始图片张数
    EVENT_PIC_INFO              stuPicInfos[NET_MAX_EVENT_PIC_NUM];                     // 原始图片信息
    float                       fTemperature;                                           // 温度值,单位摄氏度
    int                         nHumidity;                                              // 相对湿度百分比值   
    float                       fPressure;                                              // 气压值,单位Kpa
    float                       fWindForce;                                             // 风力值,单位m/s
    UINT                        nWindDirection;                                         // 风向,单位度,范围:[0,360]
    float                       fRoadGradient;                                          // 道路坡度值,单位度
    float                       fAcceleration;                                          // 加速度值,单位:m/s2   
    NET_RFIDELETAG_INFO         stuRFIDEleTagInfo;                                      // RFID 电子车牌标签信息
    EVENT_PIC_INFO              stuBinarizedPlateInfo;                                  // 二值化车牌抠图
    EVENT_PIC_INFO              stuVehicleBodyInfo;                                     // 车身特写抠图
    EM_VEHICLE_TYPE             emVehicleTypeInTollStation;                             // 收费站车型分类
    EM_SNAPCATEGORY             emSnapCategory;                                         // 抓拍的类型，默认为机动车
    int                         nRegionCode;                                            // 车牌所属地区代码,(孟加拉海外车牌识别项目),默认-1表示未识别
    EM_VEHICLE_TYPE_BY_FUNC     emVehicleTypeByFunc;                                    // 按功能划分的车辆类型
    EM_STANDARD_VEHICLE_TYPE    emStandardVehicleType;                                  // 标准车辆类型
    UINT                        nExtraPlateCount;                                       // 额外车牌数量
    char                        szExtraPlateNumber[3][32];                              // 额外车牌信息
	EM_OVERSEA_VEHICLE_CATEGORY_TYPE emOverseaVehicleCategory;                          // 海外车辆类型中的子类别
	char						szProvince[64];											// 车牌所属国家的省、州等地区名
    BYTE                        bReserved[500];                                         // 预留字节 
    char                        szCountry[20];                                          // 国家
}EVENT_COMM_INFO;

//建委地磅定制称重信息
typedef struct tagEVENT_CUSTOM_WEIGHT_INFO
{
	DWORD        dwRoughWeight;                    // 毛重,车辆满载货物重量。单位KG
    DWORD        dwTareWeight;                     // 皮重,空车重量。单位KG
    DWORD        dwNetWeight;                      // 净重,载货重量。单位KG
	BYTE		 bReserved[28];					   // 预留字节 
}EVENT_CUSTOM_WEIGHT_INFO;

// 雷达自由流信息
typedef struct tagNET_RADAR_FREE_STREAM
{
	TP_U64						nABSTime;	// 1年1月1日0时起至今的毫秒数
	int							nVehicleID; // 车辆ID
	UINT						unOBUMAC;	// OBU的MAC地址
	BYTE						byReserved[16];	// 保留字节
}NET_RADAR_FREE_STREAM;

//卡口事件专用定制上报内容，定制需求增加到Custom下
typedef struct tagEVENT_JUNCTION_CUSTOM_INFO
{
    EVENT_CUSTOM_WEIGHT_INFO    stuWeightInfo;				// 原始图片信息
	DWORD                       nCbirFeatureOffset;			// 数据偏移，单位字节 （由于结构体保留字节有限的限制,添加在此处， 下同）
	DWORD                       nCbirFeatureLength;			// 数据大小，单位字节 
	DWORD						dwVehicleHeadDirection;		// 车头朝向 0:未知 1:左 2:中 3:右
	BYTE						byReserved1[4];				// 字节对齐
	NET_RADAR_FREE_STREAM		stuRadarFreeStream;			// 雷达自由流信息
	BYTE						bReserved[12];				// 预留字节 
}EVENT_JUNCTION_CUSTOM_INFO;

// 驾驶位信息
typedef struct tagNET_SEAT_INFO
{
    NET_RECT stuFaceRect;   // 人脸矩形框信息(8192坐标系)
    BYTE   bySunShade;      // 遮阳板状态 0: 未知 1：无遮阳板 2：有遮阳板    
    BYTE   byDriverCalling; // 打电话状态 0: 未知 1：未打电话 2：打电话
    BYTE   byDriverSmoking; // 抽烟状态	0: 未知 1：未吸烟 2：吸烟
    BYTE   bySafeBelt;      // 安全带状态	0: 未知 1：未系安全带 2：系安全带
    BYTE   byReserved[32];  // 保留字节
}NET_SEAT_INFO;

// 车上附件
typedef struct tagNET_VEHICLE_ATTACH
{
    int         nType;              // 附件类型	0-未知 1-年检标志 2-挂件 3-纸巾盒 4-香水盒
    NET_RECT    stuBoundingBox;     // 包围盒信息(8192坐标系)

    BYTE        byReserved[32];
}NET_VEHICLE_ATTACH;

// 全景广角图
typedef struct tagSCENE_IMAGE_INFO
{
	UINT	   nOffSet;					// 在二进制数据块中的偏移   
	UINT	   nLength;					// 图片大小,单位字节
	UINT	   nWidth;					// 图片宽度(像素)
	UINT	   nHeight;					// 图片高度(像素)
	BYTE	   byReserved[56];			// 预留字节
}SCENE_IMAGE_INFO;

// 人脸全景图
typedef struct tagFACE_SCENE_IMAGE
{
	unsigned int	   nOffSet;					// 在二进制数据块中的偏移   
	unsigned int	   nLength;					// 图片大小,单位字节
	unsigned int	   nWidth;					// 图片宽度(像素)
	unsigned int	   nHeight;					// 图片高度(像素)
	BYTE			   byReserved[56];			// 预留字节
} FACE_SCENE_IMAGE;

// 颜色类型
typedef enum tagEM_OBJECT_COLOR_TYPE
{
	EM_OBJECT_COLOR_TYPE_UNKNOWN,									    // 未知
	EM_OBJECT_COLOR_TYPE_WHITE,										    // 白色
	EM_OBJECT_COLOR_TYPE_ORANGE,									    // 橙色
	EM_OBJECT_COLOR_TYPE_PINK,										    // 粉色
	EM_OBJECT_COLOR_TYPE_BLACK,										    // 黑色
	EM_OBJECT_COLOR_TYPE_RED,										    // 红色
	EM_OBJECT_COLOR_TYPE_YELLOW,									    // 黄色
	EM_OBJECT_COLOR_TYPE_GRAY,										    // 灰色
	EM_OBJECT_COLOR_TYPE_BLUE,										    // 蓝色
	EM_OBJECT_COLOR_TYPE_GREEN,										    // 绿色
	EM_OBJECT_COLOR_TYPE_PURPLE,									    // 紫色
	EM_OBJECT_COLOR_TYPE_BROWN,										    // 棕色
	EM_OBJECT_COLOR_TYPE_SLIVER,									    // 银色
	EM_OBJECT_COLOR_TYPE_DARKVIOLET,								    // 暗紫罗兰色
	EM_OBJECT_COLOR_TYPE_MAROON,									    // 栗色
	EM_OBJECT_COLOR_TYPE_DIMGRAY,									    // 暗灰色
	EM_OBJECT_COLOR_TYPE_WHITESMOKE,								    // 白烟色
	EM_OBJECT_COLOR_TYPE_DARKORANGE,								    // 深橙色
	EM_OBJECT_COLOR_TYPE_MISTYROSE,									    // 浅玫瑰色
	EM_OBJECT_COLOR_TYPE_TOMATO,									    // 番茄红色
	EM_OBJECT_COLOR_TYPE_OLIVE,										    // 橄榄色
	EM_OBJECT_COLOR_TYPE_GOLD,										    // 金色
	EM_OBJECT_COLOR_TYPE_DARKOLIVEGREEN,							    // 暗橄榄绿色
	EM_OBJECT_COLOR_TYPE_CHARTREUSE,								    // 黄绿色
	EM_OBJECT_COLOR_TYPE_GREENYELLOW,								    // 绿黄色
	EM_OBJECT_COLOR_TYPE_FORESTGREEN,								    // 森林绿色
	EM_OBJECT_COLOR_TYPE_SEAGREEN,									    // 海洋绿色
	EM_OBJECT_COLOR_TYPE_DEEPSKYBLUE,								    // 深天蓝色
	EM_OBJECT_COLOR_TYPE_CYAN,									        // 青色
	EM_OBJECT_COLOR_TYPE_OTHER,										    // 无法识别
}EM_OBJECT_COLOR_TYPE;

// 肤色
typedef enum tagEM_COMPLEXION_TYPE
{
	EM_COMPLEXION_NODISTI,				// 未识别
	EM_COMPLEXION_YELLOW,				// 黄
	EM_COMPLEXION_BLACK,				// 黑
	EM_COMPLEXION_WHITE,				// 白
} EM_COMPLEXION_TYPE;

// 是否带眼镜
typedef enum tagEM_HAS_GLASS
{
	EM_HAS_GLASS_UNKNOWN,			// 未知
	EM_HAS_GLASS_NO,				// 未戴
	EM_HAS_GLASS_NORMAL,			// 戴普通眼镜
	EM_HAS_GLASS_SUN,				// 戴太阳眼镜
	EM_HAS_GLASS_BLACK,				// 戴黑框眼镜
} EM_HAS_GLASS;

// 事件/物体状态
typedef enum tagEM_NONMOTOR_OBJECT_STATUS
{
	EM_NONMOTOR_OBJECT_STATUS_UNKNOWN,								  // 未识别
	EM_NONMOTOR_OBJECT_STATUS_NO,									  // 否
	EM_NONMOTOR_OBJECT_STATUS_YES,								  	  // 是
}EM_NONMOTOR_OBJECT_STATUS;

// 表情
typedef enum tagEM_EMOTION_TYPE
{
	EM_EMOTION_TYPE_UNKNOWN,                                          // 未知
	EM_EMOTION_TYPE_NORMAL,                                           // 普通/正常
	EM_EMOTION_TYPE_SMILE,                                            // 微笑
	EM_EMOTION_TYPE_ANGER,                                            // 愤怒
	EM_EMOTION_TYPE_SADNESS,                                          // 悲伤
	EM_EMOTION_TYPE_DISGUST,                                          // 厌恶
	EM_EMOTION_TYPE_FEAR,                                             // 害怕
	EM_EMOTION_TYPE_SURPRISE,                                         // 惊讶
	EM_EMOTION_TYPE_NEUTRAL,                                          // 正常
	EM_EMOTION_TYPE_LAUGH,                                            // 大笑
	EM_EMOTION_TYPE_HAPPY,                                            // 高兴
	EM_EMOTION_TYPE_CONFUSED,                                         // 困惑
	EM_EMOTION_TYPE_SCREAM,                                           // 尖叫
	EM_EMOTION_TYPE_CALMNESS,                                         // 平静
}EM_EMOTION_TYPE;

typedef enum tagEM_CLOTHES_TYPE
{
	EM_CLOTHES_TYPE_UNKNOWN,                                          //未知
	EM_CLOTHES_TYPE_LONG_SLEEVE,                                      //长袖
	EM_CLOTHES_TYPE_SHORT_SLEEVE,                                     //短袖
	EM_CLOTHES_TYPE_TROUSERS,                                         //长裤
	EM_CLOTHES_TYPE_SHORTS,                                           //短裤
	EM_CLOTHES_TYPE_SKIRT,                                            //裙子
	EM_CLOTHES_TYPE_WAISTCOAT,                                        //背心
	EM_CLOTHES_TYPE_MINIPANTS,                                        //超短裤
	EM_CLOTHES_TYPE_MINISKIRT,                                        //超短裙
}EM_CLOTHES_TYPE;

// 非机动车子类型
typedef enum tagEM_CATEGORY_NONMOTOR_TYPE
{
	EM_CATEGORY_NONMOTOR_TYPE_UNKNOWN,									// 未知
	EM_CATEGORY_NONMOTOR_TYPE_TRICYCLE,									// "Tricycle" 三轮车
	EM_CATEGORY_NONMOTOR_TYPE_MOTORCYCLE,								// "Motorcycle" 摩托车
	EM_CATEGORY_NONMOTOR_TYPE_NON_MOTOR,								// "Non-Motor" 非机动车 
	EM_CATEGORY_NONMOTOR_TYPE_BICYCLE,									// "Bicycle" 自行车     
	EM_CATEGORY_NONMOTOR_TYPE_DUALTRIWHEELMOTORCYCLE,					// "DualTriWheelMotorcycle"两、三轮摩托车
	EM_CATEGORY_NONMOTOR_TYPE_LIGHTMOTORCYCLE,							// "LightMotorcycle" 轻便摩托车
	EM_CATEGORY_NONMOTOR_TYPE_EMBASSYMOTORCYCLE,						// "EmbassyMotorcycle "使馆摩托车
	EM_CATEGORY_NONMOTOR_TYPE_MARGINALMOTORCYCLE,						// "MarginalMotorcycle " 领馆摩托车
	EM_CATEGORY_NONMOTOR_TYPE_AREAOUTMOTORCYCLE,						// "AreaoutMotorcycle " 境外摩托车
	EM_CATEGORY_NONMOTOR_TYPE_FOREIGNMOTORCYCLE,						// "ForeignMotorcycle " 外籍摩托车
	EM_CATEGORY_NONMOTOR_TYPE_TRIALMOTORCYCLE,							// "TrialMotorcycle " 试验摩托车
	EM_CATEGORY_NONMOTOR_TYPE_COACHMOTORCYCLE,							// "CoachMotorcycle " 教练摩托车
	EM_CATEGORY_NONMOTOR_TYPE_PASSERBY,									// "Passerby" 行人
    EM_CATEGORY_NONMOTOR_TYPE_VANTRICYCLE,                              // "VanTricycle" 厢式三轮车
    EM_CATEGORY_NONMOTOR_TYPE_MANNEDCONVERTIBLETRICYCLE,                // "MannedConvertibleTricycle" 载人敞篷三轮车
    EM_CATEGORY_NONMOTOR_TYPE_NOMANNEDCONVERTIBLETRICYCLE,              // "NoMannedConvertibleTricycle" 不载人敞篷三轮车
}EM_CATEGORY_NONMOTOR_TYPE;

// 非机动车抠图信息
typedef struct tagNET_NONMOTOR_PIC_INFO
{
	UINT					uOffset;							// 在二进制数据块中的偏移
	UINT					uLength;							// 图片大小,单位：字节
	UINT					uWidth;								// 图片宽度
	UINT					uHeight;							// 图片高度
	char					szFilePath[MAX_PATH_LEN];			// 文件路径
	BYTE					byReserved[512];					// 保留
}NET_NONMOTOR_PIC_INFO;

// 骑车人脸图片信息
typedef struct tagRIDER_FACE_IMAGE_INFO
{
	unsigned int	   nOffSet;					// 在二进制数据块中的偏移   
	unsigned int	   nLength;					// 图片大小,单位字节
	unsigned int	   nWidth;					// 图片宽度(像素)
	unsigned int	   nHeight;					// 图片高度(像素)
	BYTE			   byReserved[48];			// 保留
}RIDER_FACE_IMAGE_INFO;

// 斜视状态
typedef enum tagEM_STRABISMUS_TYPE
{
	EM_STRABISMUS_UNKNOWN,			// 未知
	EM_STRABISMUS_NORMAL,			// 正常
	EM_STRABISMUS_YES,				// 斜视
} EM_STRABISMUS_TYPE;

// 人脸属性
typedef struct tagNET_FACE_ATTRIBUTE_EX
{
	EM_SEX_TYPE 							emSex;						// 性别
	int        								nAge;						// 年龄,-1表示该字段数据无效
	EM_COMPLEXION_TYPE						emComplexion;				// 肤色
	EM_EYE_STATE_TYPE						emEye;						// 眼睛状态
	EM_MOUTH_STATE_TYPE						emMouth;					// 嘴巴状态
	EM_MASK_STATE_TYPE 						emMask;						// 口罩状态
	EM_BEARD_STATE_TYPE						emBeard;					// 胡子状态
	int										nAttractive;				// 魅力值, 0未识别，识别时范围1-100,得分高魅力高
	EM_HAS_GLASS							emGlass;					// 眼镜
	EM_EMOTION_TYPE							emEmotion;					// 表情
	DH_RECT									stuBoundingBox;				// 包围盒(8192坐标系)
	EM_NATION_TYPE							emNation;					// 民族
	EM_STRABISMUS_TYPE						emStrabismus;				// 斜视状态
	BYTE                					byReserved[64];             // 保留字节,留待扩展.
} NET_FACE_ATTRIBUTE_EX;

// 骑车人信息
typedef struct tagNET_RIDER_INFO
{
	BOOL						bFeatureValid;							// 是否识别到特征信息, TRUE时下面数据才有效
	EM_SEX_TYPE		            emSex;								    // 性别
	int					        nAge;								    // 年龄

	EM_NONMOTOR_OBJECT_STATUS   emHelmet;					  		    // 头盔状态
	EM_NONMOTOR_OBJECT_STATUS   emCall;							        // 是否在打电话
	EM_NONMOTOR_OBJECT_STATUS   emBag;					  			    // 是否有背包
	EM_NONMOTOR_OBJECT_STATUS   emCarrierBag;					  	    // 有没有手提包
	EM_NONMOTOR_OBJECT_STATUS   emUmbrella;					  	        // 是否打伞
	EM_NONMOTOR_OBJECT_STATUS   emGlasses;					  	  	    // 是否有带眼镜
	EM_NONMOTOR_OBJECT_STATUS   emMask;					  	  	        // 是否带口罩

	EM_EMOTION_TYPE             emEmotion;                              // 表情
	EM_CLOTHES_TYPE             emUpClothes;                            // 上衣类型
	EM_CLOTHES_TYPE             emDownClothes;                          // 下衣类型
	EM_OBJECT_COLOR_TYPE        emUpperBodyColor;                       // 上衣颜色
	EM_OBJECT_COLOR_TYPE        emLowerBodyColor;                       // 下衣颜色
	BOOL						bHasFaceImage;							// 是否有骑车人人脸抠图信息
	RIDER_FACE_IMAGE_INFO		stuFaceImage;							// 骑车人人脸特写描述
	BOOL						bHasFaceAttributes;						// 是否有人脸属性
	NET_FACE_ATTRIBUTE_EX		stuFaceAttributes;						// 人脸属性
    EM_HAS_HAT                  emHasHat;                               // 是否戴帽子
    EM_CAP_TYPE                 emCap;                                  // 帽类型
    EM_HAIR_STYLE               emHairStyle;                            // 头发样式
	BYTE						byReserved[304];						// 保留
}NET_RIDER_INFO;

#define MAX_RIDER_NUM 16											// 骑车人数组上限

// 非机动车特征值数据在二进制数据中的位置信息
typedef struct tagNET_NONMOTOR_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // 非机动车特征值在二进制数据中的偏移, 单位:字节
    UINT                nLength;            // 非机动车特征值数据长度, 单位:字节
    BYTE                byReserved[32];     // 保留字节
} NET_NONMOTOR_FEATURE_VECTOR_INFO;

// 特征值版本类型
typedef enum tagEM_FEATURE_VERSION
{
    EM_FEATURE_VERSION_UNKNOWN,                                 // 未知
    EM_FEATURE_VERSION_FACE_LARGE_1_01_001              = 1,    // 人脸，大模型，1.01.001
    EM_FEATURE_VERSION_FACE_LARGE_1_02_001,                     // 人脸，大模型，1.02.001
    EM_FEATURE_VERSION_FACE_LARGE_1_03_001,                     // 人脸，大模型，1.03.001
    EM_FEATURE_VERSION_FACE_LARGE_1_04_001,                     // 人脸，大模型，1.04.001
    EM_FEATURE_VERSION_FACE_MIDDLE_1_01_002             = 31,   // 人脸，中模型，1.01.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_02_002,                    // 人脸，中模型，1.02.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_03_002,                    // 人脸，中模型，1.03.002
    EM_FEATURE_VERSION_FACE_MIDDLE_1_04_002,                    // 人脸，中模型，1.04.002
    EM_FEATURE_VERSION_FACE_SMALL_1_01_003              = 61,   // 人脸，小模型，1.01.003
    EM_FEATURE_VERSION_FACE_SMALL_1_02_003,                     // 人脸，小模型，1.02.003
    
    EM_FEATURE_VERSION_HUMAN_NONMOTOR                   = 91,   // 人和非机动车，全局无版本号
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_00_01,            // 人和非机动车，全局浮点，1.00.01
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_00_01,             // 人和非机动车，全局哈希，1.00.01
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_01_00,            // 人和非机动车，全局浮点，1.01.00
    EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_01_00,             // 人和非机动车，全局哈希，1.01.00
    
    EM_FEATURE_VERSION_TRAFFIC                          = 121,  // 机动车，全局无版本号
    EM_FEATURE_VERSION_TRAFFIC_FLOAT,                           // 机动车，全局浮点版本号0
    EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_01,                   // 机动车，全局浮点版本号1.00.01
    EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_01,                    // 机动车，全局哈希版本号1.00.01
    EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_02,                   // 机动车，全局浮点版本号1.00.02
    EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_02,                    // 机动车，全局哈希版本号1.00.02
    
    EM_FEATURE_VERSION_SHANGTANG_FACE_1_5_0             = 151,  // 商汤，人脸，1.5.0
    EM_FEATURE_VERSION_SHANGTANG_FACE_1_8_1,                    // 商汤，人脸，1.8.1
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_1_3,                    // 商汤，人脸，2.1.3
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_6,                   // 商汤，人脸，2.39.6
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_7,                   // 商汤，人脸，2.39.7
    EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_8,                   // 商汤，人脸，2.39.8
    EM_FEATURE_VERSION_SHANGTANG_FACE_239,                      // 商汤，人脸，239
    EM_FEATURE_VERSION_SHANGTANG_FACE_242,                      // 商汤，人脸，242
    EM_FEATURE_VERSION_SHANGTANG_FACE_244,                      // 商汤，人脸，244
    EM_FEATURE_VERSION_SHANGTANG_FACE_245,                      // 商汤，人脸，245
    
    EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_4_2   = 181,  // 深a，人脸/机动车/非机动车，2.4.2
    EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_5_7,          // 深a，人脸/机动车/非机动车，2.5.7
} EM_FEATURE_VERSION;

// 非机动车车牌图片信息
typedef struct tagNET_NONMOTOR_PLATE_IMAGE
{
    UINT        nOffset;            // 在二进制数据块中的偏移
    UINT        nLength;            // 图片大小
    UINT        nWidth;             // 图片宽度
    UINT        nHeight;            // 图片高度
    BYTE        byReserved[512];    // 保留字节
}NET_NONMOTOR_PLATE_IMAGE;


//车牌颜色
typedef enum tagEM_PLATE_COLOR_TYPE
{
    EM_PLATE_COLOR_UNKNOWN,                            // 未知 "Unknown"
    EM_PLATE_COLOR_OTHER,                              // 其他颜色 "Other"
    EM_PLATE_COLOR_BLUE,                               // 蓝色 "Blue"
    EM_PLATE_COLOR_YELLOW,                             // 黄色 "Yellow"    
    EM_PLATE_COLOR_WHITE,                              // 白色 "White"
    EM_PLATE_COLOR_BLACK,                              // 黑色 "Black"
    EM_PLATE_COLOR_RED,                                // 红色 "Red"
	EM_PLATE_COLOR_GREEN,                              // 绿色 "Green"
	EM_PLATE_COLOR_SHADOW_GREEN,					   // 渐变绿 "ShadowGreen"
	EM_PLATE_COLOR_YELLOW_GREEN,					   // 黄绿双拼 "YellowGreen""
}EM_PLATE_COLOR_TYPE;

// 非机动车配牌信息
typedef struct tagNET_NONMOTOR_PLATE_INFO
{
    char                        szPlateNumber[128];                 // 非机动车车牌号
    NET_RECT					stuBoundingBox;                     // 包围盒， 非机动车矩形框，0~8191相对坐标
    NET_RECT					stuOriginalBoundingBox;             // 包围盒， 非机动车矩形框，绝对坐标
    NET_NONMOTOR_PLATE_IMAGE    stuPlateImage;                      // 非机动车车牌抠图
    EM_PLATE_COLOR_TYPE         emPlateColor;                       // 车牌颜色

    BYTE						byReserved[132];					// 保留
}NET_NONMOTOR_PLATE_INFO;

// 非机动车对象
typedef struct tagVA_OBJECT_NONMOTOR
{
	int							nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
	EM_CATEGORY_NONMOTOR_TYPE	emCategory;							// 非机动车子类型
	DH_RECT						stuBoundingBox;                     // 包围盒， 非机动车矩形框，0~8191相对坐标
	DH_RECT						stuOriginalBoundingBox;             // 包围盒， 非机动车矩形框，绝对坐标
	NET_COLOR_RGBA				stuMainColor;						// 非机动车颜色, RGBA
	EM_OBJECT_COLOR_TYPE		emColor;							// 非机动车颜色, 枚举
	BOOL						bHasImage;							// 是否有抠图
	NET_NONMOTOR_PIC_INFO		stuImage;							// 物体截图
	int							nNumOfCycling;						// 骑车人数量
	NET_RIDER_INFO				stuRiderList[MAX_RIDER_NUM];		// 骑车人特征,个数和nNumOfCycling关联
	SCENE_IMAGE_INFO			stuSceneImage;						// 全景广角图
	FACE_SCENE_IMAGE			stuFaceSceneImage;					// 人脸全景广角图
	int							nNumOfFace;							// 检测到的人脸数量
	float						fSpeed;								// 物体速度，单位为km/h
    NET_NONMOTOR_FEATURE_VECTOR_INFO stuNonMotorFeatureVectorInfo;  // 非机动车特征值数据在二进制数据中的位置信息
    EM_FEATURE_VERSION          emNonMotorFeatureVersion;           // 非机动车特征值版本号

    NET_NONMOTOR_PLATE_INFO     stuNomotorPlateInfo;                // 非机动车牌信息
    NET_POINT                   stuObjCenter;                       // 物体型心(不是包围盒中心), 0-8191相对坐标, 相对于大图
    BYTE						byReserved[3072];				    // 保留
}VA_OBJECT_NONMOTOR;

// 事件类型EVENT_IVS_TRAFFICJUNCTION(交通路口老规则事件/视频电警上的交通卡口老规则事件)对应的数据块描述信息
// 由于历史原因,如果要处理卡口事件,DEV_EVENT_TRAFFICJUNCTION_INFO和EVENT_IVS_TRAFFICGATE要一起处理,以防止有视频电警和线圈电警同时接入平台的情况发生
// 另外EVENT_IVS_TRAFFIC_TOLLGATE只支持新卡口事件的配置
typedef struct tagDEV_EVENT_TRAFFICJUNCTION_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    BYTE                byMainSeatBelt;                             // 主驾驶座,系安全带状态,1-系安全带,2-未系安全带
    BYTE                bySlaveSeatBelt;                            // 副驾驶座,系安全带状态,1-系安全带,2-未系安全带
    BYTE                byVehicleDirection;                         // 当前被抓拍到的车辆是车头还是车尾,具体请见 EM_VEHICLE_DIRECTION
    BYTE                byOpenStrobeState;                          // 开闸状态,具体请见 EM_OPEN_STROBE_STATE 
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nLane;                                      // 对应车道号
    DWORD               dwBreakingRule;                             // 违反规则掩码,第一位:闯红灯; 
                                                                    // 第二位:不按规定车道行驶;
                                                                    // 第三位:逆行; 第四位：违章掉头;
                                                                    // 第五位:交通堵塞; 第六位:交通异常空闲
                                                                    // 第七位:压线行驶; 否则默认为:交通路口事件

    NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度Km/h                 
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byDirection;                                // 路口方向,1-表示正向,2-表示反向
    BYTE                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
    BYTE                byReserved;                                 // 保留字节
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    char                szRecordFile[DH_COMMON_STRING_128];         // 报警对应的原始录像文件信息
    EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // 自定义信息
    BYTE                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
    BYTE                bReserved1[3];                              // 保留字节,留待扩展.
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制

    BYTE                byNoneMotorInfo;                            // 0-无非机动车人员信息信息,1-有非机动车人员信息信息
                                                                    // 此字段为1时下面11个字段生效
    BYTE                byBag;                                      // 是否背包, 0-未知 1-不背包   2-背包
    BYTE                byUmbrella;                                 // 是否打伞, 0-未知 1-不打伞   2-打伞
    BYTE                byCarrierBag;                               // 手提包状态,0-未知 1-没有 2-有    
    BYTE                byHat;                                      // 是否戴帽子, 0-未知 1-不戴帽子 2-戴帽子    
    BYTE                byHelmet;                                   // 头盔状态,0-未知 1-没有 2-有
    BYTE                bySex;                                      // 性别,0-未知 1-男性 2-女性
    BYTE                byAge;                                      // 年龄
    NET_COLOR_RGBA      stuUpperBodyColor;                          // 上身颜色
    NET_COLOR_RGBA      stuLowerBodyColor;                          // 下身颜色
    BYTE                byUpClothes;                                // 上身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙
    BYTE                byDownClothes;                              // 下身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙   

    NET_EXTENSION_INFO  stuExtensionInfo;                           // 扩展信息
    BYTE                bReserved[22];                              // 保留字节,留待扩展
    int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频,3RSU
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    DWORD               dwRetCardNumber;                            // 卡片个数
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // 卡片信息   
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

    BOOL                bNonMotorInfoEx;                            // 是否有非机动车信息
    VA_OBJECT_NONMOTOR  stuNonMotor;                                // 非机动车信息
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                byReserved2[1916];                          // 保留字节,留待扩展
} DEV_EVENT_TRAFFICJUNCTION_INFO;

// 事件类型EVENT_IVS_TRAFFIC_NONMOTORINMOTORROUTE (非机动车占用机动车道)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved1[3];                              // 保留字节.
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID

    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息

    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息  

    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    char                szRecordFile[DH_COMMON_STRING_128];         // 报警对应的原始录像文件信息

    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束 
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	BOOL				bHasNonMotor;								// 是否有非机动车对象
	VA_OBJECT_NONMOTOR	stuNonMotor;								// 非机动车对象
    BYTE                bReserved[4096];                            // 保留字节,留待扩展.
} DEV_EVENT_TRAFFIC_NONMOTORINMOTORROUTE_INFO;

// 车辆信息
typedef struct tagNET_VEHICLE_INFO
{
    UINT                nUID;                                       // 车辆唯一标识符,由服务端生成用于程序中表示惟一
    char                szGroupID[64];                              // 车辆所属组ID
    char                szGroupName[128];                           // 车辆所属组名
    char                szPlateNumber[64];                          // 车牌号码
    char                szPlateCountry[4];                          // 车辆所在国家,2字节，符合ISO3166规范
    int                 nPlateType;                                 // 车牌类型     
                                                                    // 01  大型汽车号牌 黄底黑字 
                                                                    // 02  小型汽车号牌 蓝底白字 
                                                                    // 03  使馆汽车号牌 黑底白字、红“使”字 
                                                                    // 04  领馆汽车号牌 黑底白字、红“领”字 
                                                                    // 05  境外汽车号牌 黑底白、红字 
                                                                    // 06  外籍汽车号牌 黑底白字 
                                                                    // 13  农用运输车号牌 黄底黑字黑框线 
                                                                    // 15  挂车号牌 黄底黑字黑框线 
                                                                    // 16  教练汽车号牌 黄底黑字黑框线 
                                                                    // 18  试验汽车号牌 
                                                                    // 20  临时入境汽车号牌 白底红字黑“临时入境” 
                                                                    // 22  临时行驶车号牌 白底黑字黑线框 
                                                                    // 23  公安警用汽车号牌

    int                 nVehicleType;                               // 车型(轿车、卡车等)
                                                                    // 001  巡逻车 
                                                                    // 002  交警车辆 
                                                                    // 003  消防车 
                                                                    // 004  单兵 
                                                                    // 005  其他警车 
                                                                    // 006  其他设备 
                                                                    // 020  政府车辆 
                                                                    // 031  校车 
                                                                    // 032  运钞车 
                                                                    // 033  客运车辆 
                                                                    // 034  公交车 
                                                                    // 035  出租车 
                                                                    // 036  危险品车辆
    int                 nBrand;                                     // 车辆车标,需要通过映射表得到真正的车标.同卡口事件的CarLogoIndex
    int                 nCarSeries;                                 // 车辆子品牌，需要通过映射表得到真正的子品牌,同卡口事件的SubBrand
    int                 nCarSeriesModelYearIndex;                   // 车辆品牌年款，需要通过映射表得到真正的年款，同卡口事件的BrandYear 车头年款序号范围1~999；车尾年款序号范围1001~1999；0表示未知；1000预留。
    NET_COLOR_RGBA      stuVehicleColor;                            // 车色 第一个元素表示红色分量值； 第二个元素表示绿色分量值； 第三个元素表示蓝色分量值； 第四个元素表示透明度分量(无意义)
    NET_COLOR_RGBA      stuPlateColor;                              // 车牌颜色,规则同车色
    char                szOwnerName[64];                            // 车主名称
    int                 nSex;                                       // 车主性别 0-未知,1-男,2,女
    int                 nCertificateType;                           // 车主证件类型 0-未知 1-身份证 2-护照 3-军官证
    char                szPersonID[32];                             // 人员身份证号码,工号,或其他编号    
    char                szOwnerCountry[4];                          // 车主国籍,2字节,符合ISO3166规范
    char                szProvince[64];                             // 省份
    char                szCity[64];                                 // 城市
    char                szHomeAddress[128];                         // 注册人员家庭地址(IVSS需求)
    char                szEmail[32];                                // 车主电子邮箱
    char                szPhoneNo[128];                             // 注册车主电话号码

    BYTE                bReserved[512];
}NET_VEHICLE_INFO;

#define MAX_CAR_CANDIDATE_NUM (50)

// 候选车辆信息
typedef struct tagNET_CAR_CANDIDATE_INFO
{   
    NET_VEHICLE_INFO    stuVehicleInfo;                             // 车辆信息
    int                 nDifferentAttributresNum;                   // 和数据库不相符的属性数目
    int                 nDifferentAttributres[16];                  // 和数据库不相符的属性集合,元素值取值意义:0-未知 1-车牌属地 2-车标 3-车型 4-车色 5-车牌颜色
    
    BYTE                byReserved[512];
}NET_CAR_CANDIDATE_INFO;

// 车牌识别比对事件信息
typedef struct tagDEV_EVENT_VEHICLE_RECOGNITION_INFO 
{
    char                szName[128];                                // 事件名称    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nVehicleAction;                             // 车辆动作 0-未知,1-在检测区域内,2-离开检测区域

    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体    
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息    

    NET_SEAT_INFO       stuMainSeatInfo;                            // 主驾驶位信息
    NET_SEAT_INFO       stuSlaveSeatInfo;                           // 副驾驶位信息
    int                 nVehicleAttachNum;                          // 车上附件数量
    NET_VEHICLE_ATTACH  stuVehicleAttach[8];                        // 车上附件数据
    char                szCountry[32];                              // 国家,2字节,符合ISO3166规范

    int                 nCarCandidateNum;                           // 候选车辆数量    
    NET_CAR_CANDIDATE_INFO stuCarCandidate[MAX_CAR_CANDIDATE_NUM];  // 候选车辆数据

    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    int                 nChannel;                                   // 通道号
    BYTE                bReserved[1024];
} DEV_EVENT_VEHICLE_RECOGNITION_INFO;


// 事件类型EVENT_IVS_TRAFFICGATE(交通卡口老规则事件/线圈电警上的交通卡口老规则事件)对应的数据块描述信息
// 由于历史原因,如果要处理卡口事件,DEV_EVENT_TRAFFICJUNCTION_INFO和EVENT_IVS_TRAFFICGATE要一起处理,以防止有视频电警和线圈电警同时接入平台的情况发生
// 另外EVENT_IVS_TRAFFIC_TOLLGATE只支持新卡口事件的配置
typedef struct tagDEV_EVENT_TRAFFICGATE_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    BYTE                byOpenStrobeState;                          // 开闸状态,具体请见EM_OPEN_STROBE_STATE
    char                bReserved1[3];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体，车标
    int                 nLane;                                      // 对应车道号
    int                 nSpeed;                                     // 车辆实际速度Km/h
    int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
    int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h 
    DWORD               dwBreakingRule;                             // 违反规则掩码,第一位:逆行; 
                                                                    // 第二位:压线行驶; 第三位:超速行驶; 
                                                                    // 第四位：欠速行驶; 第五位:闯红灯;第六位:穿过路口(卡口事件)
                                                                    // 第七位: 压黄线; 第八位: 有车占道; 第九位: 黄牌占道;否则默认为:交通卡口事件
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息    
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息，有存放车牌信息
    BYTE                szManualSnapNo[64];                         // 手动抓拍序号                
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束; 
    BYTE                byReserved[3];                              // 保留字节
    BYTE                szSnapFlag[16];                             // 设备产生的抓拍标识
    BYTE                bySnapMode;                                 // 抓拍方式,0-未分类 1-全景 2-近景 4-同向抓拍 8-反向抓拍 16-号牌图像
    BYTE                byOverSpeedPercentage;                      // 超速百分比
    BYTE                byUnderSpeedingPercentage;                  // 欠速百分比
    BYTE                byRedLightMargin;                           // 红灯容许间隔时间,单位：秒
    BYTE                byDriveDirection;                           // 行驶方向,0-上行(即车辆离设备部署点越来越近),1-下行(即车辆离设备部署点越来越远)
    char                szRoadwayNo[32];                            // 道路编号
    char                szViolationCode[16];                        // 违章代码
    char                szViolationDesc[128];                       // 违章描述
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    char                szVehicleType[32];                          // 车辆大小类型 Minisize"微型车,"Light-duty"小型车,"Medium"中型车,
                                                                    // "Oversize"大型车,"Huge"超大车,"Largesize"长车 "Unknown"未知
    BYTE                byVehicleLenth;                             // 车辆长度, 单位米
    BYTE                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
    BYTE                byReserved1;                                // 保留字节,留待扩展
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nOverSpeedMargin;                           // 限高速宽限值    单位：km/h 
    int                 nUnderSpeedMargin;                          // 限低速宽限值    单位：km/h 
    char                szDrivingDirection[3][DH_MAX_DRIVINGDIRECTION]; //
                                                                    // "DrivingDirection" : ["Approach", "上海", "杭州"],行驶方向
                                                                    // "Approach"-上行,即车辆离设备部署点越来越近；"Leave"-下行,
                                                                    // 即车辆离设备部署点越来越远,第二和第三个参数分别代表上行和
                                                                    // 下行的两个地点,UTF-8编码
    char                szMachineName[256];                         // 本地或远程设备名称
    char                szMachineAddress[256];                      // 机器部署地点、道路编码
    char                szMachineGroup[256];                        // 机器分组、设备所属单位
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_SIG_CARWAY_INFO_EX stuSigInfo;                               // 由车检器产生抓拍信号冗余信息
    char                szFilePath[MAX_PATH];                       // 文件路径
    NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
    char              * szDeviceAddress;                            // 设备地址,OSD叠加到图片上的,来源于配置TrafficSnapshot.DeviceAddress,'\0'结束
    float               fActualShutter;                             // 当前图片曝光时间,单位为毫秒
    BYTE                byActualGain;                               // 当前图片增益,范围为0~100
    BYTE                byDirection;                                // 0-南向北 1-西南向东北 2-西向东 3-西北向东南 4-北向南 5-东北向西南 6-东向西 7-东南向西北 8-未知
    BYTE                bReserve;                                   // 保留字节, 字节对齐
    BYTE                bRetCardNumber;                             // 卡片个数
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // 卡片信息
    char               szDefendCode[DH_COMMON_STRING_64];           // 图片防伪码
    int                nTrafficBlackListID;                         // 关联黑名单数据库记录默认主键ID, 0,无效；> 0,黑名单数据记录
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    BYTE                bReserved[452];                             // 保留字节,留待扩展.
} DEV_EVENT_TRAFFICGATE_INFO;

//事件类型EVENT_TRAFFICSNAPSHOT(交通抓拍事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFICSNAPSHOT_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    BYTE                bReserv[3];                                 // 保留字节 
    BYTE                bCarWayCount;                               // 触发抓拍的车道个数
    DH_CARWAY_INFO      stuCarWayInfo[DH_MAX_CARWAY_NUM];           // 触发抓拍的车道相关信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[344];                             // 保留字节,留待扩展
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFICSNAPSHOT_INFO;

//事件类型EVENT_IVS_TRAFFIC_RUNREDLIGHT(交通-闯红灯事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
    int                 nLightState;                                // 红绿灯状态 0:未知 1：绿灯 2:红灯 3:黄灯
    int                 nSpeed;                                     // 车速,km/h
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    NET_TIME_EX         stRedLightUTC;                              // 红灯开始时间
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                byRedLightMargin;                           // 红灯容许间隔时间,单位：秒
    BYTE                byAlignment[3];                             // 字节对齐
    int                 nRedLightPeriod;                            // 表示红灯周期时间,单位毫秒
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[928];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	BOOL				bHasNonMotor;								// 是否有非机动车对象
	VA_OBJECT_NONMOTOR	stuNonMotor;								// 非机动车对象
} DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO;

//事件类型EVENT_IVS_TRAFFIC_PEDESTRAINRUNREDLIGHT(交通-行人闯红灯事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 行人信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                bReserved[1024];                            // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_PEDESTRAINRUNREDLIGHT_INFO;

//事件类型EVENT_IVS_TRAFFIC_PASSNOTINORDER(交通-未按规定依次通过)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[984];                             // 保留字节
}DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO;

//事件类型EVENT_IVS_TRAFFIC_OVERLINE(交通-压线事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_OVERLINE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度,Km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[968];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_OVERLINE_INFO;


//事件类型EVENT_IVS_TRAFFIC_RETROGRADE(交通-逆行事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_RETROGRADE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度,Km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BOOL                bIsExistAlarmRecord;                        // rue:有对应的报警录像; false:无对应的报警录像
    DWORD               dwAlarmRecordSize;                          // 录像大小
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // 录像路径
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[484];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    int                 nDetectNum;                                 // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	BOOL				bHasNonMotor;								// 是否有非机动车对象
	VA_OBJECT_NONMOTOR	stuNonMotor;								// 非机动车对象
} DEV_EVENT_TRAFFIC_RETROGRADE_INFO;

//事件类型EVENT_IVS_TRAFFIC_TURNLEFT(交通-违章左转)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_TURNLEFT_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度,Km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[968];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_TURNLEFT_INFO;


//事件类型 EVENT_IVS_TRAFFIC_TURNRIGHT (交通-违章右转)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_TURNRIGHT_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度,Km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[968];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_TURNRIGHT_INFO;

//事件类型EVENT_IVS_TRAFFIC_UTURN(违章调头事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_UTURN_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    int                 nSpeed;                                     // 车辆实际速度,Km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[968];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_UTURN_INFO;

//事件类型EVENT_IVS_TRAFFIC_OVERSPEED(交通超速事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_OVERSPEED_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSpeed;                                     // 车辆实际速度Km/h
    int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
    int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h 
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    char                szFilePath[MAX_PATH];                       // 文件路径
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息  车载定制
	int                 nSpeedingPercentage;                        // 超速百分比
    BYTE                bReserved[572];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_OVERSPEED_INFO;

//事件类型EVENT_IVS_TRAFFIC_UNDERSPEED(交通欠速事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_UNDERSPEED_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved2[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nSpeed;                                     // 车辆实际速度Km/h
    int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
    int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h 
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved1[2];                              // 对齐
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nUnderSpeedingPercentage;                   // 欠速百分比
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[832];                             // 保留字节
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_UNDERSPEED_INFO;

//事件类型EVENT_IVS_TRAFFIC_JAM_FORBID_INTO(交通拥堵禁入事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ALARM_JAMFORBIDINTO_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[4];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
	int					nMark;										// 底层产生的触发抓拍帧标记
	int					nSource;									// 视频分析的数据源地址
	int					nSequence;									// 表示抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
	int					nFrameSequence;								// 帧序号
	int					nLane;										// 车道号
	BYTE                byImageIndex;                   			// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DH_MSG_OBJECT       stuObject;                      			// 检测到的物体
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
	BYTE                bReserved[984];                             // 保留字节
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
	EVENT_COMM_INFO     stCommInfo;                     			// 公共信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
} DEV_EVENT_ALARM_JAMFORBIDINTO_INFO;

//事件类型EVENT_IVS_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING(拥堵滞留斑马线违章事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO
{
	int                 nChannelID;                                 // 通道号
	char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
	char                bReserved1[4];                              // 字节对齐
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	int                 nEventID;                                   // 事件ID
	///////////////////////////////以上为公共字段//////////////////////////////
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
	int					nSequence;									// 表示抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
	int					nLane;										// 车道号
	BYTE                byImageIndex;                   			// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始  
	BYTE                byReserved[3];
	DH_MSG_OBJECT       stuObject;                      			// 检测到的物体
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
	EVENT_COMM_INFO     stuCommInfo;                     			// 公共信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	BYTE                bReserved[2048];                            // 保留字节
} DEV_EVENT_TRAFFIC_JAM_STOP_ON_ZEBRACROSSING_INFO;

//分析的信息
typedef struct tagEVENT_PIC_ANALYSE_INFO
{
	DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	EVENT_COMM_INFO     stuCommInfo;                     			// 公共信息
    BYTE                bReserved[1024];                            // 预留字节
}EVENT_PIC_ANAKYSE_INFO;

//事件类型 DH_ALARM_TRAFFIC_PIC_ANALYSE(图片二次分析事件)对应的数据块描述信息
typedef struct tagDEV_ALARM_PIC_ANALYSE_INFO
{
    int						nIndex;                                     // 通道号
    char					szName[128];                                // 事件名称
    double					PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX				UTC;                                        // 事件发生的时间
    int						nEventID;                                   // 事件ID
    DH_MSG_OBJECT			stuObject;                                  // 车牌信息
    DH_MSG_OBJECT			stuVehicle;                                 // 车身信息
    int						nGroupID;									// 事件组ID，同一辆车抓拍过程内GroupID相同
	int						nCountInGroup;								// 一个事件组内的抓拍张数
	int						nIndexInGroup;								// 一个事件组内的抓拍序号
	char					szFilePath[MAX_PATH];						// 图片路径
	EVENT_COMM_INFO			stuCommInfo;                     			// 公共信息
	EVENT_PIC_ANAKYSE_INFO	stuAnalyseInfo;								// 分析的信息
	BYTE					bReserved[1024];							// 保留字节
} ALARM_PIC_ANALYSE_INFO;
typedef struct tagNET_BULLET_HOLES_INFO
{
    int                 nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
    char                szObjectType[128];                  // 物体类型,支持以下: "Unknown", "Human", "Vehicle",
    DH_RECT             stuBoundingBox;                     // 包围盒
    DH_POINT            stuCenter;                          // 物体型心
	int				    nSequence;							// 序号
	int                 nScore;							    // 环数
    BYTE                byReserved[512];                    // 保留字节
}NET_BULLET_HOLES_INFO;
typedef struct tagDEV_ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO
{
    int						nIndex;                                     // 通道号
    char					szName[128];                                // 事件名称
    double					dbPTS;                                      // 时间戳(单位是毫秒)
    NET_TIME_EX				stuUTC;                                     // 事件发生的时间
    int						nEventID;                                   // 事件ID
    int						nGroupID;									// 事件组ID，同一辆车抓拍过程内GroupID相同
	int						nCountInGroup;								// 一个事件组内的抓拍张数
	int						nIndexInGroup;								// 一个事件组内的抓拍序号
	char					szFilePath[MAX_PATH];						// 图片路径
	DH_POINT				stuDetectRegion;							// 规则检测区域
	int						nValidBulletHolesNum;						// 检测到的有效弹孔个数
	NET_BULLET_HOLES_INFO   stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// 检测到的弹孔
	BYTE					bReserved[1024];							// 保留字节
} ALARM_PIC_SHOOTINGSCORERECOGNITION_INFO;


//4G流量超过阈值的报警事件(对应事件 DH_ALARM_OIL_4G_OVERFLOW)
typedef struct tagNET_ALARM_OIL_4G_OVERFLOW_INFO
{	
	int					            nChannelID;						// 通道号从0开始	
    double				            dbPTS;							// 时间戳(单位是毫秒)    
    NET_TIME_EX			            stuTime;						// 事件发生的时间 
	int								nFlowRateCur;					// 当前使用了的流量	单位MB	
	int								nFlowRateMax;					// 当月流量的阈值	单位MB
	BYTE                			byReserved[1024];   			// 保留字节
}NET_ALARM_OIL_4G_OVERFLOW_INFO;

//供电电源开关状态异常事件
typedef struct tagDEV_ALARM_POWERSWITCHER_INFO
{
	int                     nEventAction;                       // 持续型事件动作, 1表示开始, 2表示停止
	int                     nEventIndex;                        // 供电电源开关序号, 与PowerSwitcher配置下标序号一致
	char					szName[128];                        // 供电电源开关名称, 与PowerSwitcher配置名称对应
	NET_TIME_EX				stuUTC;                             // 事件采集时间
	int                     nPowerVoltage;                      // 电压值, 单位：mV
	int                     nPowerCurrent;                      // 电流值, 单位：mA
	int                     nPowerValue;                        // 功率, 单位：mW
	int						nSwitchOn;                          // 开关通断, 1为开，0为关
	int                     nPowerState;                        // 数据状态掩码,全0表示正常, bit0表示欠压, bit1表示过压, bit2表示欠流, bit3表示过流, bit4表示无状态(此状态不与其他同时置位)
	BYTE					byReserved[1024];				    // 保留字节
}DEV_ALRAM_POWERSWITCHER_INFO;

//  场景变更事件 StartListen(对应事件 DH_ALARM_SCENNE_CHANGE_ALARM)
typedef struct tagDEV_ALARM_PIC_SCENECHANGE_INFO
{
    int						nChannelID;                                 // 通道号
	int						nEventAction;								// 持续型事件动作,  1表示开始, 2表示停止
    double					dbPTS;                                      // 时间戳(单位是毫秒)
    NET_TIME_EX				stuUTC;                                     // 事件发生的时间
    int						nEventID;                                   // 事件ID
	BYTE					bReserved[1024];							// 保留字节
} ALARM_PIC_SCENECHANGE_INFO;


//  场景变更事件，ReloadPicture(对应事件 EVENT_IVS_SCENE_CHANGE)
typedef struct tagDEV_ALRAM_SCENECHANGE_INFO
{
    int							nChannelID;									// 通道号
	int                         nEventAction;								// 持续型事件动作, 1表示开始, 2表示停止
    double						dbPTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX					stuUTC;										// 事件发生的时间
    int							nEventID;									// 事件ID

    DH_EVENT_FILE_INFO			stuFileInfo;								// 事件对应文件信息
    BYTE						byImageIndex;								// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD						dwSnapFlagMask;								// 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE						bReserved[1024];							// 保留字节,留待扩展. 
} DEV_ALRAM_SCENECHANGE_INFO;

//事件类型 EVENT_IVS_SNAPMANUAL(SnapManual事件)对应数据块描述信息
typedef struct tagDEV_EVENT_SNAPMANUAL
{
	int                 nChannelID;                                   // 通道号
    char                szName[DH_EVENT_NAME_LEN];                    // 事件名称
    char                bReserved1[4];                                // 字节对齐
    double              PTS;                                          // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                          // 事件发生的时间
    int                 nEventID;                                     // 事件ID
	
	DH_EVENT_FILE_INFO	stuFileInfo;								  // 事件对应文件信息
    BYTE				byImageIndex;								  // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD				dwSnapFlagMask;								  // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE				bReserved[1024];							  // 保留字节,留待扩展. 
}DEV_EVENT_SNAPMANUAL;

// 超时未刷卡事件
typedef struct tagALARM_SWIPE_OVERTIME_INFO
{                           
    NET_TIME_EX             stuTime;                            // 事件发生的时间
    BYTE					bReserved[1024];
}ALARM_SWIPE_OVERTIME_INFO;

// 无卡驾驶事件
typedef struct tagALARM_DRIVING_WITHOUTCARD_INFO
{
    NET_TIME_EX             stuTime;                            // 事件发生的时间
    BYTE					bReserved[1024];
}ALARM_DRIVING_WITHOUTCARD_INFO;


// 多人脸检测信息
typedef struct tagNET_FACE_INFO
{
    int                 nObjectID;                          // 物体ID,每个ID表示一个唯一的物体
    char                szObjectType[128];                  // 物体类型
    int                 nRelativeID;                        // 这张人脸抠图所属的大图的ID
    DH_RECT             BoundingBox;                        // 包围盒
    DH_POINT            Center;                             // 物体型心
} NET_FACE_INFO;

//事件类型EVENT_IVS_FACEDETECT(人脸检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FACEDETECT_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                reserved[2];                                // 保留字节
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON  
    char                szSnapDevAddress[MAX_PATH];                 // 抓拍当前人脸的设备地址,如：滨康路37号
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // 性别
    int                 nAge;                                       // 年龄,-1表示该字段数据无效
    unsigned int        nFeatureValidNum;                           // 人脸特征数组有效个数,与 emFeature 结合使用
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeature[DH_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 nFeatureValidNum 结合使用
    int                 nFacesNum;                                  // 指示stuFaces有效数量
    NET_FACE_INFO       stuFaces[10];                               // 多张人脸时使用,此时没有Object
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	EM_RACE_TYPE				emRace;								// 种族
	EM_EYE_STATE_TYPE			emEye;								// 眼睛状态
	EM_MOUTH_STATE_TYPE			emMouth;							// 嘴巴状态
	EM_MASK_STATE_TYPE 			emMask;								// 口罩状态
	EM_BEARD_STATE_TYPE			emBeard;							// 胡子状态
	int							nAttractive;						// 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
	char						szUID[DH_COMMON_STRING_32];			// 抓拍人员写入数据库的唯一标识符
	EM_NATION_TYPE              emNation;                           // 民族
	NET_FEATURE_VECTOR			stuFeatureVector;					// 特征值信息
	char						szFeatureVersion[32];				// 特征值算法版本
	EM_FACE_DETECT_STATUS       emFaceDetectStatus;                 // 人脸在摄像机画面中的状态
	NET_EULER_ANGLE				stuFaceCaptureAngle;				// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
																	// 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
	UINT						nFaceQuality;						// 人脸抓拍质量分数,范围 0~10000 
    double                      dHumanSpeed;                        // 人的运动速度, km/h
    int                         nFaceAlignScore;                    // 人脸对齐得分分数,范围 0~10000,-1为无效值
    int                         nFaceClarity;                       // 人脸清晰度分数,范围 0~10000,-1为无效值
	BYTE                		bReserved[636];                     // 保留字节,留待扩展
} DEV_EVENT_FACEDETECT_INFO;

// 事件类型EVENT_IVS_TRAFFICJAM(交通拥堵事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFICJAM_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bJamLenght;                                 // 表示拥堵长度(总车道长度百分比）0-100
    BYTE                reserved;                                   // 保留字节
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    NET_TIME_EX         stuStartJamTime;                            // 开始停车时间
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束(bEventAction=2时此参数有效)
    int                 nAlarmIntervalTime;                         // 报警时间间隔,单位:秒。(此事件为连续性事件,在收到第一个此事件之后,若在超过间隔时间后未收到此事件的后续事件,则认为此事件异常结束了)
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    int                 nJamRealLength;                             // 表实际的拥堵长度,单位米
	NET_EXTENSION_INFO  stuExtensionInfo;                           // 扩展信息
    BYTE                bReserved[876];                            // 保留字节,留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息  
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    
} DEV_EVENT_TRAFFICJAM_INFO;

// 事件类型EVENT_IVS_TRAFFIC_PARKING(交通违章停车事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PARKING_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                reserved[2];                                // 保留字节
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    NET_TIME_EX         stuStartParkingTime;                        // 开始停车时间
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束(bEventAction=2时此参数有效)
    int                 nAlarmIntervalTime;                         // 报警时间间隔,单位:秒。(此事件为连续性事件,在收到第一个此事件之后,若在超过间隔时间后未收到此事件的后续事件,则认为此事件异常结束了)
    int                 nParkingAllowedTime;                        // 允许停车时长,单位：秒。
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESEED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BOOL                bIsExistAlarmRecord;                        // rue:有对应的报警录像; false:无对应的报警录像
    DWORD               dwAlarmRecordSize;                          // 录像大小
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // 录像路径
    char                szFTPPath[DH_COMMON_STRING_256];            // FTP路径 
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
	BYTE				byPreAlarm;									// 是否为违章预警图片,0 违章停车事件1 预警事件(预警触发后一定时间，车辆还没有离开，才判定为违章)由于此字段会导致事件含义改变，必须和在平台识别预警事件后，才能有此字段, 
	BYTE                bReserved2[3];                              // 保留字节,留待扩展.
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[228];                             // 保留字节,留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_PARKING_INFO, DEV_EVENT_TRAFFIC_PARKING_B_INFO, DEV_EVENT_TRAFFIC_PARKING_C_INFO, DEV_EVENT_TRAFFIC_PARKING_D_INFO,DEV_EVENT_TRAFFIC_PARKING_MANUAL_INFO;

//事件类型EVENT_IVS_TRAFFIC_WRONGROUTE(交通违章-不按车道行驶)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_WRONGROUTE_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];           
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nSpeed;                                     // 车辆实际速度,km/h
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[972];                             // 保留字节,留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_WRONGROUTE_INFO;

//事件类型EVENT_IVS_TRAFFIC_CROSSLANE(交通违章-违章变道)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_CROSSLANE_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];       
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
     int                nSpeed;                                     // 车辆实际速度,km/h
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
	BYTE                bReserved[836];                             // 保留字节,留待扩展.留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
} DEV_EVENT_TRAFFIC_CROSSLANE_INFO;

//事件类型EVENT_IVS_TRAFFIC_OVERYELLOWLINE(交通违章-压黄线)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];  
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nSpeed;                                     // 车辆实际速度,km/h
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BOOL                bIsExistAlarmRecord;                        // rue:有对应的报警录像; false:无对应的报警录像
    DWORD               dwAlarmRecordSize;                          // 录像大小
    char                szAlarmRecordPath[DH_COMMON_STRING_256];    // 录像路径
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[532];                             // 保留字节,留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息

    int                 nDetectNum;                                 // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域    
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

} DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO;

//事件类型EVENT_IVS_TRAFFIC_DRIVINGONSHOULDER(交通违章-路肩行驶事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];      
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nSpeed;                                     // 车辆实际速度,km/h
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    
} DEV_EVENT_TRAFFIC_DRIVINGONSHOULDER_INFO;

//事件类型EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE(交通违章-黄牌车占道事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];     
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nSpeed;                                     // 车辆实际速度,km/h
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                bReserved[1016];                            // 保留字节,留待扩展.
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

} DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO;

//事件类型EVENT_IVS_TRAFFIC_NOPASSING(交通违章-禁止通行事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_NOPASSING_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 UTCMS;                                      // 
    int                 nMark;                                      // 底层产生的触发抓拍帧标记
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[3];
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nFrameSequence;                             // 视频分析帧序号
    int                 nSource;                                    // 视频分析的数据源地址
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                byReserved[984];                            // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_NOPASSING_INFO;

typedef struct tagDH_TRAFFICFLOWSTAT
{
    char                szMachineAddress[256];                      // 同DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineGroup
    char                szMachineName[256];                         // 同DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO.MachineName
    char                szDrivingDirection[3][32];                  // 行驶方向"Approach"-上行,即车辆离设备部署点越来越近；"Leave"-下行,即车辆离设备部署点越来越远,第二和第三个参数分别代表上行和下行的两个地点,UTF-8编码
    int                 nLane;                                      // 车道号 使用用户配置的车道编号
    NET_TIME_EX         UTC;                                        // 统计时间,转换到UTC
    int                 nPeriod;                                    // 统计周期,单位分钟
    int                 nVehicles;                                  // 通过车辆总数
    float               fAverageSpeed;                              // 平均车速,单位km/h
    float               fAverageLength;                             // 平均车长,单位米
    float               fTimeOccupyRatio;                           // 时间占有率,即单位时间内通过断面的车辆所用时间的总和占单位时间的比例
    float               fSpaceOccupyRatio;                          // 空间占有率,即按百分率计量的车辆长度总和除以时间间隔内车辆平均行驶距离
    float               fSpaceHeadway;                              // 车头间距,相邻车辆之间的距离,单位米/辆
    float               fTimeHeadway;                               // 车头时距,单位秒/辆
    float               fDensity;                                   // 车辆密度,每公里的车辆数,单位辆/km
    int                 nOverSpeedVehicles;                         // 超速车辆数
    int                 nUnderSpeedVehicles;                        // 低速车辆数
    int                 nLargeVehicles;                             // 大车数量  车辆类型判断标准参见TrafficSnapshot配置表
    int                 nMediumVehicles;                            // 中型车数量
    int                 nSmallVehicles;                             // 小车数量
    int                 nMotoVehicles;                              // 摩托车数量
    int                 nLongVehicles;                              // 超长车数量
}DH_TRAFFICFLOWSTAT; 

// 事件类型 TrafficFlowStat Info(交通流量统计事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_FLOWSTAT_INFO
{
    char                szName[128];                                // 事件名称
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLaneCnt;                                   // 通道总数
    DH_TRAFFICFLOWSTAT  stTrafficFlowStats[DH_MAX_LANE_NUM];        // 流量统计记录,是一个数组
    char                Reserved[4];                                // 保留字节对齐
}DEV_EVENT_TRAFFIC_FLOWSTAT_INFO;

// 手动抓拍专用上报定制内容
typedef struct tagEVENT_MANUALSNAP_CUSTOM_DATA
{
	EVENT_CUSTOM_WEIGHT_INFO	stuWeighInfo;							// 建委地磅定制称重信息
	BYTE						byReserved[472];                        // 保留字节
}EVENT_MANUALSNAP_CUSTOM_DATA;

//事件类型EVENT_IVS_TRAFFIC_MANUALSNAP(交通手动抓拍事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_MANUALSNAP_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    BYTE                szManualSnapNo[64];                         // 手动抓拍序号 
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 检测到的车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byOpenStrobeState;                          // 开闸状态, 具体请见 EM_OPEN_STROBE_STATE
	BYTE                byReserved[1];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE                bReserved[504];								// 保留字节,留待扩展.
	EVENT_MANUALSNAP_CUSTOM_DATA	stuCustom;						// 手动抓拍专用上报内容
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_MANUALSNAP_INFO;

//事件类型 EVENT_IVS_TRAFFIC_STAY(交通滞留事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_STAY_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                byReserved[1012];         
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_STAY_INFO;

//事件类型 EVENT_IVS_TRAFFIC_VEHICLEINROUTE(有车占道事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
    int                 nSpeed;                                     // 车速
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息               
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved0[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                byReserved[884];           
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO;

// 报警事件类型 EVENT_ALARM_LOCALALARM(外部报警),EVENT_ALARM_MOTIONALARM(动检报警)报警)
typedef struct tagDEV_EVENT_ALARM_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID  
    
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_ALARM_INFO;

// 报警事件类型 EVENT_ALARM_VIDEOBLIND(视频遮挡报警)
typedef struct tagDEV_EVENT_ALARM_VIDEOBLIND
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID        
    
    NET_TIME_EX         stuTime;                                    // 事件发生的时间, (设备时间, 不一定是utc时间)
    char                szDriverID[32];                             // 司机ID
    NET_GPS_STATUS_INFO stuGPSStatus;                               // GPS信息
    char                szVideoPath[256];                           // 违章关联视频FTP上传路径
    BYTE                byReserved2[1024];                          // 保留字节,留待扩展
}DEV_EVENT_ALARM_VIDEOBLIND;

// 报警事件类型 EVENT_ALARM_ANALOGALARM(模拟量报警通道报警),
typedef struct tagDEV_EVENT_ALARM_ANALOGALRM_INFO 
{
    int                 nChannelID;                                 // (视频)通道号
    char                szName[DH_COMMON_STRING_128];               // 模拟量报警通道名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID 
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息   
    int                 nIndex;                                     // 模拟量报警通道号
    NET_SENSE_METHOD    emSensor;                                   // 传感器类型
    int                 nStatus;                                    // 数据状态, -1:未知,0:正常,1:数据无效(超过量程),
                                                                    // 2:超过阈值1,3:超过阈值2,4:超过阈值3,5:超过阈值4,
                                                                    // 6:低于阈值1,7:低于阈值2,8:低于阈值3,9:低于阈值4
    float               fValue;                                     // 探测器数值
    NET_TIME            stuCollectTime;                             // 数据采集时间(UTC)
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved2[1023];                          // 保留字节,留待扩展
}DEV_EVENT_ALARM_ANALOGALRM_INFO;

//EVENT_ALARM_VEHICLEACC(ACC断电报警)
typedef struct tagDEV_EVENT_ALARM_VEHICLEACC_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_COMMON_STRING_128];               // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID      
    NET_GPS_STATUS_INFO stGPSStatusInfo;                            // GPS信息
    int                 nACCStatus;                                 // ACC状态    0:无效(兼容用) , 1:开启 , 2:关闭    
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bConstantElectricStatus;                    // 常电状态 , 0:无效(兼容用) , 1:连接 , 2:断开                            
    BYTE                bReserved[1022];                            // 保留字节,留待扩展.
}DEV_EVENT_ALARM_VEHICLEACC_INFO;


// 报警事件类型 EVENT_ALARM_VEHICLE_TURNOVER(车辆侧翻) , EVENT_ALARM_VEHICLE_COLLISION(车辆撞车)
typedef struct tagDEV_EVENT_VEHICEL_ALARM_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID  
    NET_GPS_STATUS_INFO stGPSStatusInfo;                            // GPS信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                              // 字节对齐用
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                bReserved[1024];                            // 保留字节,留待扩展.
}DEV_EVENT_VEHICEL_ALARM_INFO;

// 事件类型 EVENT_IVS_PRISONERRISEDETECTION (看守所囚犯起身事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_PRISONERRISEDETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    double              dInitialUTC;                                // 事件初始UTC时间    UTC为事件的UTC (1970-1-1 00:00:00)秒数。
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[616];                             // 保留字节,留待扩展.
}DEV_EVENT_PRISONERRISEDETECTION_INFO;

//事件类型 EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(斑马线行人优先事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nLane;                                      // 对应车道号
    double              dInitialUTC;                                // 事件初始UTC时间    UTC为事件的UTC (1970-1-1 00:00:00)秒数。
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[984];                             // 保留字节,留待扩展.
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO;

//事件类型 EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(占用公交车道事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
    int                 nSpeed;                                     // 车速,km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[980];                             // 保留字节,留待扩展.
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO;

//事件类型 EVENT_IVS_TRAFFIC_BACKING(违章倒车事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_IVS_TRAFFIC_BACKING_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
    int                 nSpeed;                                     // 车速,km/h
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[848];                             // 保留字节,留待扩展.
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_IVS_TRAFFIC_BACKING_INFO;

//事件类型EVENT_IVS_AUDIO_ABNORMALDETECTION(声音异常检测)对应数据块描述信息
typedef struct tagDEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    int                 nDecibel;                                   // 声音强度
    int                 nFrequency;                                 // 声音频率
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    BYTE                bReserved[1024];                            // 保留字节,留待扩展.
}DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO;

//事件类型 EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(交通违章-闯黄灯事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
    int                 nLightState;                                // 红绿灯状态 0:未知 1：绿灯 2:红灯 3:黄灯
    int                 nSpeed;                                     // 车速,km/h
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    NET_TIME_EX         stYellowLightUTC;                           // 黄灯开始时间
    unsigned int        nYellowLightPeriod;                         // 黄灯周期间隔时间,单位秒
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
     BYTE               byRedLightMargin;                           // 黄灯容许间隔时间,单位：秒
    char                szSourceDevice[MAX_PATH];                   // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    BYTE                bReserved[1024];                            // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

} DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO;

// 离岗的触发模式
typedef enum tagEM_LEAVEDETECTION_TRIGGER_MODE
{
    EM_LEAVEDETECTION_TRIGGER_UNKNOEN,              // 未知
    EM_LEAVEDETECTION_TRIGGER_NOPERSON,             // 无人
    EM_LEAVEDETECTION_TRIGGER_LEAVE,                // 离开
    EM_LEAVEDETECTION_TRIGGER_STATIC,               // 静止(睡岗)
    EM_LEAVEDETECTION_TRIGGER_OUTPERSONLIMIT,       // 不在允许值岗人数范围内(值岗人数异常)
}EM_LEAVEDETECTION_TRIGGER_MODE;

//事件类型 EVENT_IVS_LEAVEDETECTION(离岗检测事件)对应数据块描述信息
typedef struct tagDEV_EVENT_IVS_LEAVE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    int                 nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM];     // 规则检测区域
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    EM_LEAVEDETECTION_TRIGGER_MODE emTriggerMode;                   // 离岗的触发模式
	BYTE                bReserved[890];                            // 保留字节
} DEV_EVENT_IVS_LEAVE_INFO;

//事件类型 EVENT_IVS_CLIMBDETECTION(攀高检测事件)对应数据块描述信息
typedef struct tagDEV_EVENT_IVS_CLIMB_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    int                 nDetectLineNum;                             // 规则检测线顶点数
    DH_POINT            DetectLine[DH_MAX_DETECT_LINE_NUM];         // 规则检测线
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    unsigned int        nOccurrenceCount;                           // 事件触发累计次数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[890];                            // 保留字节
}DEV_EVENT_IVS_CLIMB_INFO;

//事件类型 EVENT_IVS_MULTISCENESWITCH(多场景切换事件)对应数据块描述信息
typedef struct tagDEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    
    BYTE                bReserved[1027];                            // 保留字节
} DEV_EVENT_IVS_MULTI_SCENE_SWICH_INFO;

//事件类型 EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(黄网格线抓拍事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息

    int                 nInterval1;                                 // 第二张和第一张的延时时间,单位秒
    int                 nInterval2;                                 // 第三张和第二张的延时时间,单位秒
    int                 nFollowTime;                                // 跟随时间,如果一辆车与前一辆车进入黄网格的时间差小于此值,就认为是跟车进入,跟车进入情况下如果停车则不算违章

    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[984];                             // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO;


//停车场信息
typedef struct tagDEV_TRAFFIC_PARKING_INFO
{
    int           nFeaturePicAreaPointNum;                  // 特征图片区点个数
    DH_POINT      stFeaturePicArea[DH_MAX_POLYGON_NUM];     // 特征图片区信息
    BYTE          bReserved[572];                           // 保留字节
}DEV_TRAFFIC_PARKING_INFO;

//事件类型 EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(车位有车事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束    
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    int                 nParkingSpaceStatus;                        // 车位综合的状态,0-占用,1-空闲,2-压线
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // 停车场信息
    BYTE                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
    BYTE                byReserved2[3];                             // 字节对齐
	char                szParkingNum[32];                           // 车位(地磁)编号，球机定制项目
	DWORD               dwPresetNum;                                // 球机预置位编号，球机定制项目
	BOOL                bParkingFault;                              // 车位是否有故障，球机定制项目
	BYTE                bReserved[364];                             // 保留字节 
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;                    // 车位图片信息
    BYTE			    byReserved1[1024];			                // 为图片信息做预留字节，新增的字段请在该保留字节下面添加
}DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO;


//事件类型 EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(车位无车事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // 停车场信息
    BYTE                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
	BYTE                byReserved2[3];                             // 字节对齐
	char                szParkingNum[32];                           // 车位(地磁)编号，球机定制项目
	DWORD               dwPresetNum;                                // 球机预置位编号，球机定制项目
	BOOL                bParkingFault;                              // 车位是否有故障，球机定制项目
	BYTE                bReserved[368];                             // 保留字节 
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    NET_INTELLIGENCE_IMAGE_INFO stuGlobalImage;                     // 全景大图信息                
    NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;                    // 车位图片信息
    BYTE			    byReserved1[1024];			                // 为图片信息做预留字节，新增的字段请在该保留字节下面添加
}DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_PARKINGSPACEOVERLINE (车位压线事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
    DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // 停车场信息
    BYTE                byReserved[384];                           // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_PARKINGSPACEOVERLINE_INFO;


// 事件类型 EVENT_IVS_TRAFFIC_TURNLEFTAFTERSTRAIGHT (左转未礼让直行事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // 车辆信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                byReserved[984];                            // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TURNLEFTAFTERSTRAIGHT_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_BIGBENDSMALLTURN (大弯小转事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_BIGBENDSMALLTURN_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // 车辆信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE                byReserved[1024];                           // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_BIGBENDSMALLTURN_INFO;

// 事件类型EVENT_IVS_ROAD_CONSTRUCTION (道路施工监测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_ROAD_CONSTRUCTION_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
    int                 nEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	EM_CLASS_TYPE		emClassType;								// 智能事件所属大类
	DH_RECT				stuBoudingBox;								// 施工位置包围盒,8192坐标系
	BYTE                byReserved[512];                            // 保留字节
} DEV_EVENT_ROAD_CONSTRUCTION_INFO;


// 事件类型EVENT_IVS_ROAD_BLOCK (路障监测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_ROAD_BLOCK_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
    int                	nEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	EM_CLASS_TYPE		emClassType;								// 智能事件所属大类
	DH_RECT				stuBoudingBox;								// 路障位置包围盒,8192坐标系
	BYTE                byReserved[512];                            // 保留字节
} DEV_EVENT_ROAD_BLOCK_INFO;

// 事件类型 EVENT_IVS_INSTALL_CARDREADER (安装读卡器事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_INSTALL_CARDREADER_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID        
	BYTE                byReserved[1024];						    // 保留字节,留待扩展
}DEV_EVENT_INSTALL_CARDREADER_INFO;

// 事件类型 EVENT_IVS_ACC_OFF_SNAP (车载设备断电前抓拍上传事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ACC_OFF_SNAP_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID        
	BYTE                byReserved[1024];						    // 保留字节,留待扩展
}DEV_EVENT_ACC_OFF_SNAP_INFO;

// 危险等级
typedef enum tagEM_DANGER_GRADE_TYPE
{
	EM_DANGER_GRADE_UNKNOWN  = -1,									// 未知
	EM_DANGER_GRADE_NORMAL,											// 普通级别
	EM_DANGER_GRADE_WARN,											// 警示级别
	EM_DANGER_GRADE_DANGER,											// 危险级别
} EM_DANGER_GRADE_TYPE;

// 包裹信息
typedef struct tagNET_PACKAGE_INFO
{
	EM_DANGER_GRADE_TYPE	emDangerGrade;							// 包裹危险等级, 一个包裹内有多个危险等级显示最高危等级
	BYTE            		byReserved[128];						// 保留字节,留待扩展
} NET_PACKAGE_INFO;

// 物品类型
typedef enum tagEM_INSIDE_OBJECT_TYPE
{
	EM_INSIDE_OBJECT_UNKNOWN,										// 算法未识别物品
	EM_INSIDE_OBJECT_KNIFE,											// 刀具
	EM_INSIDE_OBJECT_BOTTLELIQUID,									// 瓶装液体
	EM_INSIDE_OBJECT_GUN,											// 枪支
	EM_INSIDE_OBJECT_UMBRELLA,										// 雨伞
	EM_INSIDE_OBJECT_PHONE,											// 手机
	EM_INSIDE_OBJECT_NOTEBOOK,										// 笔记本
	EM_INSIDE_OBJECT_POWERBANK,										// 充电宝
	EM_INSIDE_OBJECT_SHOES,											// 鞋子
	EM_INSIDE_OBJECT_ROD,											// 杠子
	EM_INSIDE_OBJECT_METAL,											// 金属
	EM_INSIDE_OBJECT_EXPLOSIVE,										// 爆炸物
    EM_INSIDE_OBJECT_CONTAINERSPRAY,								// 喷雾喷灌
    EM_INSIDE_OBJECT_EXPLOSIVE_FIREWORKS,							// 烟花爆竹
    EM_INSIDE_OBJECT_LIGHTER,										// 打火机
    EM_INSIDE_OBJECT_STICK,										    // 警棍
    EM_INSIDE_OBJECT_BRASSKNUCKLE,									// 指虎
    EM_INSIDE_OBJECT_HANDCUFFS,										// 手铐
    EM_INSIDE_OBJECT_IVORY,										    // 象牙
    EM_INSIDE_OBJECT_BOOK,										    // 书籍
    EM_INSIDE_OBJECT_CD,										    // 光盘
    EM_INSIDE_OBJECT_HAMMERS,										// 锤子
    EM_INSIDE_OBJECT_PLIERS,										// 钳子
    EM_INSIDE_OBJECT_AXE,										    // 斧头
    EM_INSIDE_OBJECT_SCREW_DRIVER,									// 螺丝刀
    EM_INSIDE_OBJECT_WRENCH,										// 扳手
    EM_INSIDE_OBJECT_ELECTRIC_SHOCK_STICK,							// 电击棍
} EM_INSIDE_OBJECT_TYPE;

// 物品信息
typedef struct tagNET_INSIDE_OBJECT
{
	EM_DANGER_GRADE_TYPE	emDangerGrade;							// 物品危险等级
	EM_INSIDE_OBJECT_TYPE	emObjType;								// 物品类型
	UINT					nSimilarity;							// 相似度
	NET_RECT             	stuBoundingBox;                         // 包围盒
	BYTE            		byReserved[108];							// 保留字节,留待扩展
} NET_INSIDE_OBJECT;

// X光机图片类型
typedef enum tagEM_XRAY_IMAGE_TYPE
{
	EM_XRAY_IMAGE_TYPE_UNKNOWN = -1,								// 未知
	EM_XRAY_IMAGE_TYPE_COLOR,										// 彩图
	EM_XRAY_IMAGE_COLOR_TYPE_OVERLAY,								// 彩色叠加图
}EM_XRAY_IMAGE_TYPE;

// X光机视角类型
typedef enum tagEM_XRAY_VIEW_TYPE
{
	EM_XRAY_VIEW_TYPE_UNKNOWN = -1,									// 未知
	EM_XRAY_VIEW_TYPE_MASTER,										// 主视角
	EM_XRAY_VIEW_TYPE_SLAVE,										// 从视角
}EM_XRAY_VIEW_TYPE;

// 图片列表
typedef struct tagNET_XRAY_IMAGE_INFO
{
	EM_XRAY_VIEW_TYPE		emViewType;								// 视图类型
	EM_XRAY_IMAGE_TYPE		emImageType;							// 图片类型
	unsigned int			nOffset;								// 在二进制数据块中的偏移
	unsigned int			nLength;								// 图片大小,单位:字节	
	BYTE					byReserved[1024];						// 预留字节
}NET_XRAY_IMAGE_INFO;

// 客户自定义信息, X光机定制专用
typedef struct tagNET_XRAY_CUSTOM_INFO
{
    EM_XRAY_VIEW_TYPE               emViewType;             // 视角类型
    char                            szSerialNumber[128];    // 流水号
    BYTE                            byReserved[124];        // 保留字节
} NET_XRAY_CUSTOM_INFO;

// 事件类型EVENI_IVS_XRAY_DETECTION (X光检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_XRAY_DETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID        
    EM_CLASS_TYPE       emClassType;                                // 所属大类
    NET_PACKAGE_INFO    stuPacketInfo;                              // 包裹信息
    char                Reserved1[4];                               // 保留字节对齐 
    UINT                nObjectNum;                                 // 主视角包裹内物品个数
    NET_INSIDE_OBJECT   stuInsideObj[MAX_INSIDEOBJECT_NUM];         // 主视角包裹内物品信息
    UINT                nSlaveViewObjectNum;                        // 从视角包裹内物品个数
    NET_INSIDE_OBJECT   stuSlaveViewInsideObj[MAX_INSIDEOBJECT_NUM];// 从视角包裹内物品信息
    UINT                nImageCount;                                // 图片数量
    NET_XRAY_IMAGE_INFO stuImageInfo[8];                            // 图片信息
    UINT                nViewCustomInfoNum;                         // 客户自定义信息个数
    NET_XRAY_CUSTOM_INFO    stuViewCustomInfo[4];                   // 客户自定义信息, X光机定制专用
    BYTE                byReserved[1020];                           // 保留字节,留待扩展
} DEV_EVENT_XRAY_DETECTION_INFO;

// 事件类型 EVENT_IVS_NOTCLEARCAR(未清车告警)对应的数据块描述信息
typedef struct tagDEV_EVENT_NOTCLEARCAR_INFO
{
	int					nChannelID;									// 通道号
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1024];                           // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_NOTCLEARCAR_INFO;

// 事件类型 EVENT_IVS_SOSALEART(sos求救报警)对应的数据块描述信息
typedef struct tagDEV_EVENT_SOSALEART_INFO
{
	int					nChannelID;									// 通道号
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1024];                           // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_SOSALEART_INFO;

// 事件类型 EVENT_IVS_OVERLOAD(超载抓图)对应的数据块描述信息
typedef struct tagDEV_EVENT_OVERLOAD_INFO
{
	int					nChannelID;									// 通道号
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1024];                           // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_OVERLOAD_INFO;

// 事件类型 EVENT_IVS_NONWORKINGTIME(非工作时间告警)对应的数据块描述信息
typedef struct tagDEV_EVENT_NONWORKINGTIME_INFO
{
	int					nChannelID;									// 通道号
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1024];                           // 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_NONWORKINGTIME_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_HIGH_BEAM(远光灯违章事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_HIGH_BEAM_INFO
{
	int					nChannelID;									// 通道号
	char				szName[DH_EVENT_NAME_LEN];					// 事件名称
	BYTE				byReserved1[4];								// 保留字节对齐
	double              PTS;                                        // 时间戳(单位是毫秒)
	int					nEventID;                                   // 事件ID
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved2[3];								// 保留字节对齐
	DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	int					nLane;										// 车道号
	int					nSequence;									// 抓拍结束状态,3/2/1表示抓拍正常结束，0表示抓拍异常结束
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stuTrafficCar;              // 车辆信息
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	EVENT_COMM_INFO     stuCommInfo;                                // 公共信息
	BYTE				byReserved[1024];                           // 保留字节
}DEV_EVENT_TRAFFIC_HIGH_BEAM_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_TRUCKFORBID(货车禁止事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFICTRUCKFORBID_INFO
{
	int					nChannel;									// 通道号
	char				szName[DH_EVENT_NAME_LEN];					// 事件名称
	int					nGroupID;									// 事件组ID，同一辆车抓拍过程内GroupID相同
	int					nCountInGroup;								// 一个事件组内的抓拍张数
	int					nIndexInGroup;								// 一个事件组内的抓拍序号
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	int					UTCMS;										// UTC时间对应的毫秒数
    int		            nEventID;                                   // 事件ID
	DH_MSG_OBJECT		stuObject;									// 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	int					nLane;										// 车道号
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // 车辆信息
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	DH_EVENT_FILE_INFO	stuFileInfo;								// 事件对应文件信息
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO	stuResolution;								// 对应图片的分辨率
	BYTE                byReserved[1016];                           // 保留字节
} DEV_EVENT_TRAFFICTRUCKFORBID_INFO;

// 事件类型 EVENT_IVS_DRIVINGWITHOUTCARD(无人驾驶报警事件）对应的数据块描述信息 
typedef struct tagDEV_EVENT_DRIVINGWITHOUTCARD_INFO
{
	int                 nChannelID;                                 // 通道号
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byReserved[3];								// 保留对齐字节 
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	DWORD				nEventID;									// 事件ID
	BYTE				byReserved1[1024];                          // 保留字节
}DEV_EVENT_DRIVINGWITHOUTCARD_INFO;


// 事件类型 EVENT_IVS_HIGHSPEED(车辆超速报警事件）对应的数据块描述信息 
typedef struct tagDEV_EVENT_HIGHSPEED_INFO
{
	int								nChannelID;                     // 通道号
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX			            UTC;							// 事件发生的时间
	BYTE							byReserved[4];					// 保留字节
	double				            dbPTS;							// 时间戳(单位是毫秒)	
	NET_GPS_STATUS_INFO 			stGPSStatusInfo;                // GPS信息
	int								nSpeedLimit;					// 车连限速值(km/h)
	int								nCurSpeed;						// 当前车辆速度(km/h)
	int								nMaxSpeed;					    // 最高速度(Km/h)
	NET_TIME_EX						stuStartTime;					// 开始时间(车载定制需求),nAction为2时上报此字段
	BYTE                			byReserved1[1024];       		// 保留字节  
}DEV_EVENT_HIGHSPEED_INFO;

// 全局拥挤人群密度列表(圆形)信息
typedef struct tagNET_CROWD_LIST_INFO
{
	DH_POINT			stuCenterPoint;				// 中心点坐标,8192坐标系
	unsigned int		nRadiusNum;					// 半径像素点个数
	BYTE				byReserved[1024];			// 保留字节
}NET_CROWD_LIST_INFO;

// 人数超限的报警区域ID列表信息
typedef struct tagNET_REGION_LIST_INFO
{	
	unsigned int		nRegionID;				// 配置的区域下标
	unsigned int		nPeopleNum;				// 区域内人数统计值
	BYTE				byReserved[1024];		// 保留字节
}NET_REGION_LIST_INFO;

// 报警业务类型
typedef enum tagEM_ALARM_TYPE
{
	EM_ALARM_TYPE_UNKNOWN,								// 未知类型
	EM_ALARM_TYPE_CROWD_DENSITY,						// 拥挤人群密度报警
	EM_ALARM_TYPE_NUMBER_EXCEED,						// 人数超限报警
	EM_ALARM_TYPE_CROWD_DENSITY_AND_NUMBER_EXCEED,		// 拥挤人群密度报警和人数超限报警
}EM_ALARM_TYPE;

#define RECT_POINT                2              // 表示矩形的2个点（左上角与右下角）
#define MAX_CROWD_RECT_LIST       5              // 矩形描述信息的最大个数

// 全局拥挤人群密度列表(矩形)信息
typedef struct tagNET_CROWD_RECT_LIST_INFO
{
    DH_POINT			stuRectPoint[RECT_POINT];   // 矩形的左上角点与右下角点,8192坐标系，表示矩形的人群密度矩形框
    BYTE				byReserved[32];			    // 保留字节
}NET_CROWD_RECT_LIST_INFO;

// 事件类型 EVENT_IVS_CROWDDETECTION(人群密度检测事件）对应的数据块描述信息 
typedef struct tagDEV_EVENT_CROWD_DETECTION_INFO
{
    int					  nChannelID;							// 通道号
    int					  nEventID;								// 事件ID
    double				  PTS;									// 时间戳(单位是毫秒)
    NET_TIME_EX			  UTC;									// 事件发生的时间
    int                   nEventAction;							// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    EM_ALARM_TYPE		  emAlarmType;							// 报警业务类型
    char				  szName[MAX_CROWD_DETECTION_NAME_LEN];	// 事件名称
    int					  nCrowdListNum;						// 返回的全局拥挤人群密度列表个数 （圆形描述）
    int					  nRegionListNum;						// 返回的人数超限的报警区域ID列表个数 
    NET_CROWD_LIST_INFO	  stuCrowdList[MAX_CROWD_LIST_NUM];		// 全局拥挤人群密度列表信息（圆形描述）
    NET_REGION_LIST_INFO  stuRegionList[MAX_REGION_LIST_NUM];	// 人数超限的报警区域ID列表信息
    NET_EXTENSION_INFO    stuExtensionInfo;					    // 扩展信息
    int					  nCrowdRectListNum;					// 返回的全局拥挤人群密度列表个数 (矩形描述)
    NET_CROWD_RECT_LIST_INFO stuCrowdRectList[MAX_CROWD_RECT_LIST];  // 全局拥挤人群密度列表信息(矩形描述)
    BYTE				  byReserved[692];						// 保留扩展字节
}DEV_EVENT_CROWD_DETECTION_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_CARDISTANCESHORT (车间距过小报警事件）对应的数据块描述信息 
typedef struct tagDEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO
{
	int                 nChannelID;											// 通道号
	BYTE				byReserved[4];										// 保留字节，为了对齐
	char				szName[MAX_EVENT_NAME_LEN];							// 事件名称
	double				dbPTS;												// 时间戳(单位是毫秒)
	NET_TIME_EX			UTC;												// 事件发生的时间
	int					nEventID;											// 事件ID
	DH_MSG_OBJECT		stuObject;											// 车牌信息
	DH_MSG_OBJECT       stuVehicle;											// 车身信息
	int					nLane;												// 车道号
	int                 nSequence;											// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;						// 车辆信息
	DH_EVENT_FILE_INFO	stuFileInfo;										// 事件对应文件信息
	BYTE                byReserved1[1024];									// 保留字节
	EVENT_COMM_INFO     stCommInfo;											// 公共信息
}DEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_QUEUEJUMP (车辆加塞事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_QUEUEJUMP_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // 车辆信息
    int                 nLane;                                      // 对应车道号
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	BYTE                byReserved[1024];                           // 保留字节
} DEV_EVENT_TRAFFIC_QUEUEJUMP_INFO;

// 事件类型 EVENT_IVS_PEDESTRIAN_JUNCTION (行人卡口事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_PEDESTRIAN_JUNCTION_INFO
{
	int					nChannelID;									// 通道号
	char				szName[DH_EVENT_NAME_LEN];					// 事件名称 
	int					nGroupID;									// 事件组ID, 同一个人抓拍过程内nGroupID相同
	int					nCountInGroup;								// 一个事件组内的抓拍张数
	int					nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
	double				PTS;										// 事件戳(单位是毫秒)
	NET_TIME_EX			UTC;										// 事件发生的时间
	int					UTCMS;										// UTC时间对应的毫秒数
	int					nEventID;									// 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	DH_MSG_OBJECT		stuObject;									// 人脸信息
	int					nLane;										// 人行道号
	int					nSequence;									// 表示抓拍序号,如3/2/1,1表示抓拍结束,0表示异常结束
	BYTE				byReserved[1024];							// 保留字节
} DEV_EVENT_PEDESTRIAN_JUNCTION_INFO;

// 事件类型 EVENT_IVS_VEHICLE_SUSPICIOUSCAR (嫌疑车辆事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                Reserved[4];                                // 保留字节对齐    
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    DWORD               nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息    
    int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                byReserved1[2];
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                byReserved[4096];                           // 保留字节
}DEV_EVENT_VEHICLE_SUSPICIOUSCAR_INFO;

// 行人信息
typedef struct tagEVENT_VEHICLE_INFO
{
	char				szCategory[MAX_CATEGORY_LEN];				// 物体类型，Passerby表示行人
	BYTE				byReserved[64];								// 预留字节				
}EVENT_VEHICLE_INFO;

//事件类型 EVENT_IVS_TRAFFIC_PEDESTRAIN(交通行人事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_PEDESTRAIN_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout" 
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // 交通车辆部分信息
	EVENT_VEHICLE_INFO  stuVehicle;									// 行人信息
    BYTE                bReserved[252];                             // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO;

//事件类型 EVENT_IVS_TRAFFIC_THROW(交通抛洒物品事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_THROW_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout" 
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nLane;                                      // 对应车道号
    DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    EVENT_TRAFFIC_CAR_PART_INFO   stuTrafficCarPartInfo;            // 交通车辆部分信息
    NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
    BYTE                bReserved[340];                             // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_THROW_INFO;

//事件类型 EVENT_IVS_TRAFFIC_IDLE(交通空闲事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_IDLE_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
    DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
    DWORD               dwSnapFlagMask;                             // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout" 
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved2[2];
    BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    int                 nLane;                                      // 对应车道号
    BYTE                bReserved[1024];                            // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

}DEV_EVENT_TRAFFIC_IDLE_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_TURNRIGHTAFTERSTRAIGHT(右转不礼让横向直行)对应数据块描述信息
typedef struct tagDEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO
{
    int                 nChannelID;                                  // 通道号
    char                szName[DH_EVENT_NAME_LEN];                   // 事件名称
    char                bReserved[4];                                // 字节保留
    double              dPTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         stuUTC;                                      // 事件发生的时间
    int                 nEventID;                                    // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                 // 事件对应文件信息
    DH_MSG_OBJECT       stuObject;                                   // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                  // 车身信息    
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;                // 车辆信息
    int                 nLane;                                       // 车道号
    int                 nSequence;                                   // 抓拍序号, 如3, 2, 1, 1表示抓拍结束, 0表示异常结束
	BYTE                byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1012];                            // 保留字节
    EVENT_COMM_INFO     stCommInfo;                                  // 公共信息
}DEV_EVENT_TURNRIGHTAFTERSTRAIGHT_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_TURNRIGHTAFTERPEOPLE(右转不礼让直行行人)对应数据块描述信息
typedef struct tagDEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO
{
	int					nChannelID;									// 通道号
	char				szName[DH_EVENT_NAME_LEN];					// 事件名称
	char				bReserved[4];								// 字节保留
	double				dPTS;										// 时间戳(单位是毫秒)	
	NET_TIME_EX			stuUTC;										// 事件发生的时间
	int					nEventID;									// 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息    
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;               // 车辆信息
	int					nLane;										// 车道号
	int					nSequence;									// 抓拍序号，如3, 2, 1, 1表示抓拍正常结束，0表示抓拍异常结束
	BYTE                byEventAction;                              // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	BYTE                byReserved1[2];
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	BYTE				byReserved[1012];							// 保留字节
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
}DEV_EVENT_TURNRIGHTAFTERPEOPLE_INFO;

#define MAX_DRIVING_DIR_NUM          16                             //  车道行驶方向最大个数

// 车辆行驶方向
typedef enum tagNET_FLOWSTAT_DIRECTION
{
    DRIVING_DIR_UNKNOW = 0 ,                                        //兼容之前
    DRIVING_DIR_APPROACH ,                                          //上行,即车辆离设备部署点越来越近
    DRIVING_DIR_LEAVE ,                                             //下行,即车辆离设备部署点越来越远
}NET_FLOWSTAT_DIRECTION;

// 道路方向
typedef enum tagNET_ROAD_DIRECTION
{
    ROAD_DIR_UNKNOW,             // 未知  
    ROAD_DIR_TURNLEFT,           // 左转 
    ROAD_DIR_TURNRIGHT,          // 右转
    ROAD_DIR_STRAIGHT,           // 直行
    ROAD_DIR_UTURU,              // 掉头
    ROAD_DIR_NUM,    
}NET_ROAD_DIRECTION;

//车辆流量统计车辆行驶方向信息 
typedef struct tagNET_TRAFFIC_FLOWSTAT_INFO_DIR
{
    NET_FLOWSTAT_DIRECTION      emDrivingDir;                       //行驶方向
    char                        szUpGoing[FLOWSTAT_ADDR_NAME];      //上行地点 
    char                        szDownGoing[FLOWSTAT_ADDR_NAME];    //下行地点 
    BYTE                        reserved[32];                       //保留字节
    
}NET_TRAFFIC_FLOWSTAT_INFO_DIR;

//道路拥挤状况
typedef enum tagNET_TRAFFIC_JAM_STATUS
{
    JAM_STATUS_UNKNOW   =0  ,   //未知
    JAM_STATUS_CLEAR        ,   //通畅
    JAM_STATUS_JAMMED       ,   //拥堵
    JAM_STATUS_SLOWED       ,   //拥堵
}NET_TRAFFIC_JAM_STATUS;

// 道路等级
typedef enum tagNET_TRAFFIC_ROAD_RANK
{
	ROAD_RANK_UNKNOWN	=0	,
	ROAD_RANK_RAPID		=1	,	//快速路
	ROAD_RANK_TRUNK		=2	,	//主干路
	ROAD_RANK_SUBTRUNK	=3	,	//次干路
	ROAD_RANK_BRANCH	=4	,	//支路
}NET_TRAFFIC_ROAD_RANK;

// 车道流量信息属性
typedef enum tagNET_EM_FLOW_ATTRIBUTE
{
	EM_FLOW_ATTRIBUTE_UNKNOWN = 0,
	EM_FLOW_ATTRIBUTE_FLOW_DETECTION,								// 流量监测
	EM_FLOW_ATTRIBUTE_QUEUE_DETECTION,								// 排队检测
}NET_EM_FLOW_ATTRIBUTE;

typedef struct tagNET_TRAFFIC_FLOW_STATE 
{
    int                             nLane;                          // 车道号
    DWORD                           dwState;                        // 状态值  若emJamState字段为有效值(不为 JAM_STATUS_UNKNOW) ,则dwState字段无效
                                                                    // 1- 流量过大
                                                                    // 2- 流量过大恢复
                                                                    // 3- 正常
                                                                    // 4- 流量过小
                                                                    // 5- 流量过小恢复
    DWORD                           dwFlow;                         // 流量值, 单位: 辆
    DWORD                           dwPeriod;                       // 流量值对应的统计时间, 单位:分钟。与dwPeriodByMili一起使用。
    NET_TRAFFIC_FLOWSTAT_INFO_DIR   stTrafficFlowDir;               // 车道方向信息
    int                             nVehicles;                      // 通过车辆总数
    float                           fAverageSpeed;                  // 平均车速,单位km/h
    float                           fAverageLength;                 // 平均车长,单位米
    float                           fTimeOccupyRatio;               // 时间占有率,即单位时间内通过断面的车辆所用时间的总和占单位时间的比例
    float                           fSpaceOccupyRatio;              // 空间占有率,即按百分率计量的车辆长度总和除以时间间隔内车辆平均行驶距离
    float                           fSpaceHeadway;                  // 车头间距,相邻车辆之间的距离,单位米/辆
    float                           fTimeHeadway;                   // 车头时距,单位秒/辆
    float                           fDensity;                       // 车辆密度,每公里的车辆数,单位辆/km
    int                             nOverSpeedVehicles;             // 超速车辆数
    int                             nUnderSpeedVehicles;            // 低速车辆数
    int                             nLargeVehicles;                 // 大车交通量(9米<车长<12米),辆/单位时间
    int                             nMediumVehicles;                // 中型车交通量(6米<车长<9米),辆/单位时间
    int                             nSmallVehicles;                 // 小车交通量(4米<车长<6米),辆/单位时间,
    int                             nMotoVehicles;                  // 摩托交通量(微型车,车长<4米),辆/单位时间,
    int                             nLongVehicles;                  // 超长交通量(车长>=12米),辆/单位时间,
    int                             nVolume;                        // 交通量, 辆/单位时间, 某时间间隔通过车道、道路或其他通道上一点的车辆数,常以1小时计, 
    int                             nFlowRate;                      // 流率小车当量,辆/小时, 车辆通过车道、道路某一断面或某一路段的当量小时流量
    int                             nBackOfQueue;                   // 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离(建议废掉 改用dBackOfQueue下面)
    int                             nTravelTime;                    // 旅行时间,单位：秒, 车辆通过某一条道路所用时间。包括所有停车延误
    int                             nDelay;                         // 延误,单位：秒,驾驶员、乘客或行人花费的额外的行程时间
    BYTE                            byDirection[MAX_DRIVING_DIR_NUM]; // 车道方向,详见NET_ROAD_DIRECTION
    BYTE                            byDirectionNum;                 // 车道行驶方向个数
    BYTE                            reserved1[3];                    // 字节对齐
    NET_TRAFFIC_JAM_STATUS          emJamState;                     // 道路拥挤状况  若此字段为有效值(不为 JAM_STATUS_UNKNOW) ,则以此字段为准, dwState字段无效
    //  按车辆类型统计交通量
    int                             nPassengerCarVehicles;                      // 客车交通量(辆/单位时间)
    int                             nLargeTruckVehicles;                        // 大货车交通量(辆/单位时间)
    int                             nMidTruckVehicles;                          // 中货车交通量(辆/单位时间)
    int                             nSaloonCarVehicles;                         // 轿车交通量(辆/单位时间)
    int                             nMicrobusVehicles;                          // 面包车交通量(辆/单位时间)
    int                             nMicroTruckVehicles;                        // 小货车交通量(辆/单位时间)
    int                             nTricycleVehicles;                          // 三轮车交通量(辆/单位时间)
    int                             nMotorcycleVehicles;                        // 摩托车交通量(辆/单位时间)
    int                             nPasserbyVehicles;                          // 行人交通量(辆/单位时间)
	NET_TRAFFIC_ROAD_RANK			emRank;										// 道路等级
	int								nState;										// 流量状态
																				// 1- 流量过大(拥堵)
																				// 2- 流量过大恢复(略堵)
																				// 3- 正常
																				// 4- 流量过小(通畅)
																				// 5- 流量过小恢复(良好)
    BOOL                            bOccupyHeadCoil;                            // 车头虚拟线圈是否被占用 TURE表示占用，FALSE表示未占用
    BOOL                            bOccupyTailCoil;                            // 车尾虚拟线圈是否被占用 TURE表示占用，FALSE表示未占用
    BOOL                            bStatistics;                                // 流量数据是否有效 TURE表示有效，FALSE表示无效

	int								nLeftVehicles;								// 左转车辆总数,单位:分钟
	int								nRightVehicles;								// 右转车辆总数,单位:分钟
	int								nStraightVehicles;							// 直行车辆总数,单位:分钟
	int								nUTurnVehicles;								// 掉头车辆总数,单位:分钟
    DH_POINT                        stQueueEnd;                                 // 每个车道的最后一辆车坐标,采用8192坐标系
	double							dBackOfQueue;								// 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离
	DWORD							dwPeriodByMili;								// 流量值的毫秒时间,值不超过60000,和dwPeriod一起使用,流量值总时间:dwPeriod*60*1000+dwPeriodByMili(单位：毫秒)
    int								nBusVehicles;								// 公交车交通量(辆/单位时间)
	int								nMPVVehicles;								// MPV交通量(辆/单位时间)
	int								nMidPassengerCarVehicles;					// 中客车交通量(辆/单位时间)
	int								nMiniCarriageVehicles;						// 微型轿车交通量(辆/单位时间)
	int								nOilTankTruckVehicles;						// 油罐车交通量(辆/单位时间)
	int								nPickupVehicles;							// 皮卡车交通量(辆/单位时间)
	int								nSUVVehicles;								// SUV交通量(辆/单位时间)
	int								nSUVorMPVVehicles;							// SUV或者MPV交通量(辆/单位时间)
	int								nTankCarVehicles;							// 槽罐车交通量(辆/单位时间)
	int								nUnknownVehicles;							// 未知车辆交通量(辆/单位时间)
	NET_EM_FLOW_ATTRIBUTE			emCustomFlowAttribute;						// 车道流量信息属性
	BYTE                            reserved[720];                              // 保留字节
}NET_TRAFFIC_FLOW_STATE;

// 交通流量事件信息trafficflowstatinfo 对应结构体 
typedef struct tagNET_TRAFFICFLOWSTATINFO
{
    DH_TRAFFICFLOWSTAT				stuTrafficFlowStat;				// 交通流量状态
	
	double							dbBackOfQueue;					// 排队长度
	NET_TRAFFIC_ROAD_RANK			emRank;							// 道路等级
	int								nState;							// 流量状态
																	// 1- 流量过大(拥堵)
																	// 2- 流量过大恢复(略堵)
																	// 3- 正常
																	// 4- 流量过小(通畅)
																	// 5- 流量过小恢复(良好)
    BYTE                            reserved[1024];                 // 保留字节
}NET_TRAFFICFLOWSTATINFO; 


//事件类型 EVENT_IVS_TRAFFIC_FLOWSTATE(交通流量事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_FLOW_STATE
{
    int                     nChannelID;                             // 通道号
    char                    szName[DH_EVENT_NAME_LEN];              // 事件名称
    char                    bReserved1[8];                          // 字节对齐
    DWORD                   PTS;                                    // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                    // 事件发生的时间
    int                     nEventID;                               // 事件ID
    int                     nSequence;                              // 序号
    int                     nStateNum;                              // 流量状态数量
    NET_TRAFFIC_FLOW_STATE  stuStates[DH_MAX_LANE_NUM];             // 流量状态, 每个车道对应数组中一个元素
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;                 	// 智能事件公共信息
	BYTE                    bReserved[892];                        // 保留字节
}DEV_EVENT_TRAFFIC_FLOW_STATE;

// 事件类型EVENT_IVS_VIDEOSTATIC(视频静态检测事件)对应数据块描述信息, 
typedef struct tagDEV_EVENT_ALARM_VIDEOSTATIC_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    EM_ALARM_VIDEO_STATIC_MODE  emMode;                             // 设备报警的模式
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved[1027];                            // 保留字节
}DEV_EVENT_ALARM_VIDEOSTATIC_INFO;

// 事件类型EVENT_IVS_VIDEOTIMING(视频定时检测时间)对应数据块描述信息
typedef struct tagDEV_EVENT_ALARM_VIDEOTIMING_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                bReserved[1027];                            // 保留字节
}DEV_EVENT_ALARM_VIDEOTIMING_INFO;


//事件源信息结构
typedef struct tagDEV_SRC_INFO
{
    char          szSrcEvent[DH_COMMON_STRING_32];// 事件源
    NET_TIME_EX   stSrcTime;                      // 事件源发生的时间
    int           iSrcChannel;                    // 事件源发生的通道号
    BYTE          reserved[512];                  // 保留字节
}DEV_SRC_INFO;

//事件类型EVENT_IVS_LINKSD(LinkSD事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_LINK_SD
{
    //公共字段
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[8];                     // 字节对齐
    DWORD               PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

    //事件对应字段
    DEV_SRC_INFO       *pstSrcInfo;                         // 事件源信息
    NET_TIME_EX         stStartTime;                        // 预置点到达的时间
    NET_TIME_EX         stEndTime;                          //预置点结束的时间
    int                 iPresetID;                          //联动球机转到的对应预置点
    BYTE                reserved[512];                      //保留字节
    
}DEV_EVENT_LINK_SD;

// 事件类型EVENT_IVS_FLOWRATE(流量使用情况事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FLOWRATE_INFO
{
	//公共字段
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[8];                     	// 字节对齐
    double              dbPTS;                              // 时间戳(单位是毫秒)
    NET_TIME_EX         stuTime;                            // 事件发生的时间
    int                 nEventID;                           // 事件ID

	//事件对应字段
	unsigned int 		nFlowRate;							// 传输流量的值(MB)
	BYTE                reserved[1024];                     // 保留字节
} DEV_EVENT_FLOWRATE_INFO;

// 事件类型 EVENT_IVS_CITIZENIDCARD(身份证信息读取事件)对应数据块描述信息
typedef struct tagDEV_EVENT_ALARM_CITIZENIDCARD_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
    int                 nGroupID;                                   // nGroupID事件组ID,同一物体抓拍过程内nGroupID相同
    int                 nCountInGroup;                              // nCountInGroup一个事件组内的抓拍张数
    int                 nIndexInGroup;                              // IndexInGroup一个事件组内的抓拍序号
    char                szCitizen[DH_COMMON_STRING_64];             // 姓名
    EM_CITIZENIDCARD_SEX_TYPE   emSex;                              // 性别
    int                 nEthnicity;                                 // 民族
    // 0 无效数据
    // 1 汉族
    // 2 蒙古族
    // 3 回族
    // 4 藏族
    // 5 维吾尔族
    // 6 苗族
    // 7 彝族
    // 8 壮族
    // 9 布依族
    // 10 朝鲜族
    // 11 满族
    // 12 侗族
    // 13 瑶族
    // 14 白族
    // 15 土家族
    // 16 哈尼族
    // 17 哈萨克族
    // 18 傣族
    // 19 黎族
    // 20 傈僳族
    // 21 佤族
    // 22 畲族
    // 23 高山族
    // 24 拉祜族
    // 25 水族
    // 26 东乡族
    // 27 纳西族
    // 28 景颇族
    // 29 柯尔克孜族
    // 30 土族
    // 31 达斡尔族
    // 32 仫佬族
    // 33 羌族
    // 34 布朗族
    // 35 撒拉族
    // 36 毛南族
    // 37 仡佬族
    // 38 锡伯族
    // 39 阿昌族
    // 40 普米族
    // 41 塔吉克族
    // 42 怒族
    // 43 乌孜别克族
    // 44 俄罗斯族
    // 45 鄂温克族
    // 46 德昂族
    // 47 保安族
    // 48 裕固族
    // 49 京族
    // 50 塔塔尔族
    // 51 独龙族
    // 52 鄂伦春族
    // 53 赫哲族
    // 54 门巴族
    // 55 珞巴族
    // 56 基诺族
    NET_TIME            stuBirth;                                   // 出生日期
    char                szAddress[DH_COMMON_STRING_256];            // 住址
    char                szNumber[DH_COMMON_STRING_64];              // 身份证号
    char                szAuthority[DH_COMMON_STRING_256];          // 签发机关
    NET_TIME            stuStart;                                   // 起始日期
    BOOL                bLongTimeValidFlag;                         // 该值为 TRUE, 截止日期 表示长期有效,此时 stuEnd 值无意义
    // 该值为 FALSE, 此时 截止日期 查看 stuEnd 值
    NET_TIME            stuEnd;                                     // 截止日期,bLongTimeValidFlag 为 FALSE 时有效
    char                szReversed[1024];                           // 保留字节
}DEV_EVENT_ALARM_CITIZENIDCARD_INFO;

// 事件类型 EVENT_IVS_PICINFO(图片信息事件)对应数据块描述信息
typedef struct tagDEV_EVENT_ALARM_PIC_INFO 
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间(车载设备不支持)
    int                 nEventID;                                   // 事件ID
	///////////////////////////////以上为公共字段//////////////////////////////
	NET_TIME_EX         stuTime;                                    // 事件发生的时间, (设备时间, 不一定是utc时间)
    DWORD               dwEventType;                                // 事件类型
    DWORD               dwSpeed;                                    // 车速,单位km/h
	DWORD               dwSpeedHighLine;                            // 高速上限报警值, 单位km/h
    DWORD               dwDisk;                                     // 磁盘号
    DWORD               dwCluster;                                  // 簇号
    DWORD               dwPartition;                                // 分区号
    char                szSnapAddr[DH_COMMON_STRING_128];           // 抓图地点, 有效64字节
    char                szPicID[DH_COMMON_STRING_32];               // 图片唯一ID
    char                szPlate[DH_COMMON_STRING_16];               // 车牌
    char                szReversed[2000];                           // 保留字节
}DEV_EVENT_ALARM_PIC_INFO;

//图片类型
typedef enum tagEM_ACCESS_CTL_IMAGE_TYPE
{
	EM_ACCESS_CTL_IMAGE_UNKNOWN = -1,					// 未知
	EM_ACCESS_CTL_IMAGE_LOCAL,							// 本地人脸图库
	EM_ACCESS_CTL_IMAGE_SCENE,							// 拍摄场景抠图
	EM_ACCESS_CTL_IMAGE_FACE,							// 人脸抠图
    EM_ACCESS_CTL_IMAGE_INFRARED,						// 红外抓图
}EM_ACCESS_CTL_IMAGE_TYPE;


//图片信息
typedef struct tagDEV_ACCESS_CTL_IMAGE_INFO
{
	EM_ACCESS_CTL_IMAGE_TYPE	emType;					// 图片类型
	UINT						nOffSet;				// 二进制块偏移字节
	UINT						nLength;				// 图片大小
	UINT						nWidth;					// 图片宽度(单位:像素)
	UINT						nHeight;				// 图片高度(单位:像素)
	NET_RECT            		stuBoundingBox;         // 包围盒
	BYTE						byReserved[48];			// 保留字节
}DEV_ACCESS_CTL_IMAGE_INFO;

// 定制人员信息
typedef struct tagDEV_ACCESS_CTL_CUSTOM_WORKER_INFO
{
    NET_ACCESSCTLCARD_SEX       emSex;                                      // 性别
    char                        szRole[MAX_COMMON_STRING_32];               // 角色
    char                        szProjectNo[MAX_COMMON_STRING_32];          // 项目ID
    char                        szProjectName[MAX_COMMON_STRING_64];        // 项目名称
    char                        szBuilderName[MAX_COMMON_STRING_64];        // 施工单位全称
    char                        szBuilderID[MAX_COMMON_STRING_32];          // 施工单位ID
    char                        szBuilderType[MAX_COMMON_STRING_32];        // 施工单位类型
    char                        szBuilderTypeID[MAX_COMMON_STRING_8];       // 施工单位类别ID
    char                        szPictureID[MAX_COMMON_STRING_64];          // 人员照片ID
    char                        szContractID[MAX_COMMON_STRING_16];         // 原合同系统合同编号
    char                        szWorkerTypeID[MAX_COMMON_STRING_8];        // 工种ID
    char                        szWorkerTypeName[MAX_COMMON_STRING_32];     // 工种名称
    BOOL                        bPersonStatus;                              // 人员状态, TRUE:启用, FALSE:禁用
    BYTE						byReserved[256];			                // 保留字节
}DEV_ACCESS_CTL_CUSTOM_WORKER_INFO;

// 事件类型 EVENT_IVS_ACCESS_CTL(门禁事件)对应数据块描述信息
typedef struct tagDEV_EVENT_ACCESS_CTL_INFO 
{
    int                         nChannelID;                         // 门通道号
    char                        szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                		bReserved1[4];                      // 字节对齐
    double              		PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         		UTC;                                // 事件发生的时间
    int                 		nEventID;                           // 事件ID        
    DH_MSG_OBJECT           	stuObject;                          // 检测到的物体
	DH_EVENT_FILE_INFO			stuFileInfo;	                    // 事件对应文件信息
    NET_ACCESS_CTL_EVENT_TYPE   emEventType;                        // 门禁事件类型
    BOOL                        bStatus;                            // 刷卡结果,TRUE表示成功,FALSE表示失败
    NET_ACCESSCTLCARD_TYPE      emCardType;                         // 卡类型
    NET_ACCESS_DOOROPEN_METHOD  emOpenMethod;                       // 开门方式
    char                        szCardNo[DH_MAX_CARDNO_LEN];        // 卡号
    char                        szPwd[DH_MAX_CARDPWD_LEN];          // 密码
    char                        szReaderID[DH_COMMON_STRING_32];    // 门读卡器ID
    char                        szUserID[DH_COMMON_STRING_64];      // 开门用户
    char                        szSnapURL[DH_COMMON_STRING_128];    // 抓拍照片存储地址
    int                         nErrorCode;                         // 开门失败的原因,仅在bStatus为FALSE时有效
                                                                    // 0x00 没有错误
                                                                    // 0x10 未授权
                                                                    // 0x11 卡挂失或注销
                                                                    // 0x12 没有该门权限
                                                                    // 0x13 开门模式错误
                                                                    // 0x14 有效期错误
                                                                    // 0x15 防反潜模式
                                                                    // 0x16 胁迫报警未打开
                                                                    // 0x17 门常闭状态
                                                                    // 0x18 AB互锁状态
                                                                    // 0x19 巡逻卡
                                                                    // 0x1A 设备处于闯入报警状态
                                                                    // 0x20 时间段错误
                                                                    // 0x21 假期内开门时间段错误
                                                                    // 0x30 需要先验证有首卡权限的卡片
                                                                    // 0x40 卡片正确,输入密码错误
                                                                    // 0x41 卡片正确,输入密码超时
                                                                    // 0x42 卡片正确,输入指纹错误
                                                                    // 0x43 卡片正确,输入指纹超时
                                                                    // 0x44 指纹正确,输入密码错误
                                                                    // 0x45 指纹正确,输入密码超时
                                                                    // 0x50 组合开门顺序错误
                                                                    // 0x51 组合开门需要继续验证
                                                                    // 0x60 验证通过,控制台未授权
                                                                    // 0x61 卡片正确,人脸错误
                                                                    // 0x62 卡片正确,人脸超时
                                                                    // 0x63 重复进入
                                                                    // 0x64 未授权,需要后端平台识别
    int                         nPunchingRecNo;                     // 刷卡记录集中的记录编号
	int							nNumbers;							// 抓图张数
    BYTE						byImageIndex;	                    // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始	
	BYTE                        byReserved[3];                      // 字节对齐
	DWORD						dwSnapFlagMask;						// 抓图标志(按位),具体见 NET_RESERVED_COMMON        
    NET_ATTENDANCESTATE         emAttendanceState;                  // 考勤状态
	char						szClassNumber[MAX_CLASS_NUMBER_LEN];	// 班级（考勤肯尼亚定制）
	char						szPhoneNumber[MAX_PHONENUMBER_LEN];		// 电话（考勤肯尼亚定制）
	char						szCardName[DH_MAX_CARDNAME_LEN];			// 卡命名
	UINT                          uSimilarity;                         // 人脸识别相似度,范围为0~100
	DEV_ACCESS_CTL_IMAGE_INFO	stuImageInfo[6];						// 图片信息
	int							nImageInfoCount;							// 图片信息数量
	char						szCitizenIDNo[20];						// 身份证号
	UINT						nGroupID;							// 事件组ID
    int				            nCompanionCardCount;					// 陪同者卡号个数
    char				        szCompanionCards[MAX_COMPANION_CARD_NUM][DH_MAX_CARDINFO_LEN];    // 陪同者卡号信息
    DEV_ACCESS_CTL_CUSTOM_WORKER_INFO  stuCustomWorkerInfo;                 // 定制人员信息
	EM_CARD_STATE				emCardState;						// 当前事件是否为采集卡片
	char						szSN[32];							// 设备序列号
	EM_HAT_STYLE				emHatStyle;							// 帽子类型
	EM_UNIFIED_COLOR_TYPE		emHatColor;							// 帽子颜色
	EM_LIFT_CALLER_TYPE			emLiftCallerType;					// 梯控方式触发者
    BYTE						bReserved[464];					    // 保留字节,留待扩展.
}DEV_EVENT_ACCESS_CTL_INFO;

//事件类型 EVENT_IVS_NETPALYCHECK(上网登记事件)对应数据块描述信息
typedef struct tagDEV_EVENT_ALARM_NETPLAYCHECK_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[8];                              // 字节对齐
    DWORD               PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
	NET_TIME_EX         stuTime;                                    // 事件发生的时间, (设备时间, 不一定是utc时间)
	char				szIdentityCard[DH_COMMON_STRING_32];		//上网人员身份证
	char				szNetBarName[DH_COMMON_STRING_32];			//网吧名称
	char				szNetBarID[DH_COMMON_STRING_32];			//网吧编号
	char				szNetBarAddr[DH_COMMON_STRING_64];			//网吧地址
}DEV_EVENT_ALARM_NETPLAYCHECK_INFO;

#define MAX_SNAPBYTIME_DATA_NUM 20
// 用户数据
typedef struct tagEVENT_SNAPBYTIME_DATA
{
	DWORD				dwLiquidLevel;								  // 液位值,单位mm
	DWORD				dwDistMeasure;								  // 测距值,单位mm
	int					nTemperature;								  // 温度值,单位℃
	int					nHumidity;									  // 湿度值,单位RH
	DWORD				dwWaterFlow;									  // 流量值,单位m^3
	BOOL				bAlarmFlag;									  // 报警状态： 正常 FALSE, 报警  TRUE
	char                szReversed[40];                               // 保留字节
}EVENT_SNAPBYTIME_DATA;

//事件类型 EVENT_IVS_SNAPBYTIME(定时抓图事件)对应数据块描述信息
typedef struct tagDEV_EVENT_SNAPBYTIME
{
	int                 nChannelID;                                   // 通道号
    char                szName[DH_EVENT_NAME_LEN];                    // 事件名称
    char                bReserved1[4];                                // 字节对齐
    double              PTS;                                          // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                          // 事件发生的时间
    int                 nEventID;                                     // 事件ID
    ///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
    NET_TIME_EX         stuSnapTime;                                  // 抓图时间
	unsigned int		uLiquidLevel;								  // 液位值,单位mm
	unsigned int		uDistMeasure;								  // 测距值,单位mm
	int					nTemperature;								  // 温度值,单位℃
	int					nHumidity;									  // 湿度值,单位RH

	int					nDataNum;									  // 数据个数
	EVENT_SNAPBYTIME_DATA	stuDataList[MAX_SNAPBYTIME_DATA_NUM];	  // 数据列表
    char                szReversed[748];                              // 保留字节
}DEV_EVENT_SNAPBYTIME;

// 事件类型EVENT_IVS_MAN_STAND_DETECTION(立体视觉站立事件)对应数据块描述信息
typedef struct tagDEV_EVENT_MANSTAND_DETECTION_INFO
{
	int                 		nChannelID;                 // 通道号
    char                		szName[DH_EVENT_NAME_LEN];  // 事件名称
    char                		bReserved1[4];              // 字节对齐,非保留字节
    double              		PTS;                        // 时间戳(单位是毫秒)
    NET_TIME_EX         		UTC;                        // 事件发生的时间
    int                 		nEventID;                   // 事件ID
    ///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
	int                 		nAction;                    // 0:脉冲 1:开始 2:停止
	int							nManListCount;				// 区域人员列表数量
	MAN_STAND_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// 区域内人员列表
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	char                		szReversed[2048];           // 保留字节
} DEV_EVENT_MANSTAND_DETECTION_INFO;

// 事件类型EVENT_IVS_MAN_NUM_DETECTION(立体视觉区域内人数统计事件)对应数据块描述信息
typedef struct tagDEV_EVENT_MANNUM_DETECTION_INFO
{
	int                 		nChannelID;                 // 通道号
    char                		szName[DH_EVENT_NAME_LEN];  // 事件名称
    char                		bReserved1[4];              // 字节对齐, 非保留字节
    double              		PTS;                        // 时间戳(单位是毫秒)
    NET_TIME_EX         		UTC;                        // 事件发生的时间
    int                 		nEventID;                   // 事件ID
    ///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
	int                 		nAction;                    // 0:脉冲 1:开始 2:停止
	int							nManListCount;				// 区域人员列表数量
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// 区域内人员列表
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	UINT						nAreaID;					// 区域ID(一个预置点可以对应多个区域ID)
    UINT                        nPrevNumber;                // 变化前人数
    UINT                        nCurrentNumber;             // 当前人数
	char                		szReversed[2036];           // 保留字节
} DEV_EVENT_MANNUM_DETECTION_INFO;

// 事件类型 EVENT_IVS_QUEUENUM_DETECTION（排队人数异常报警事件）对应数据块描述信息
typedef struct tagDEV_EVENT_QUEUENUM_DETECTION_INFO
{
	int                 		nChannelID;                 // 通道号
	char                		szName[DH_EVENT_NAME_LEN];  // 事件名称
	char                		bReserved1[4];              // 字节对齐, 非保留字节
	double              		PTS;                        // 时间戳(单位是毫秒)
	NET_TIME_EX         		UTC;                        // 事件发生的时间
	DWORD                 		nEventID;                   // 事件ID
	int							nAction;                    // 0:脉冲 1:开始 2:停止
	///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
	UINT						nAreaID;					// 区域ID(一个预置点可以对应多个区域ID)
	int							nMaxManListNum;				// 区域内检测到的人员个数
	MAN_NUM_LIST_INFO			stuManList[MAX_MAN_LIST_COUNT];	// 区域内人员列表
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	DH_EVENT_FILE_INFO			stuFileInfo;                // 事件对应文件信息
	BYTE                		byReversed[1024];           // 保留字节
} DEV_EVENT_QUEUENUM_DETECTION_INFO;

// 事件类型 EVENT_IVS_GENERATEGRAPH_DETECTION（生成图规则）对应的数据块描述信息
typedef struct tagDEV_EVENT_GENERATEGRAPH_DETECTION_INFO
{	
	int                 		nChannelID;                 // 通道号
	char                		szName[DH_EVENT_NAME_LEN];  // 事件名称
	char                		bReserved1[4];              // 字节对齐, 非保留字节
	double              		PTS;                        // 时间戳(单位是毫秒)
	NET_TIME_EX         		UTC;                        // 事件发生的时间
	int                 		nEventID;                   // 事件ID
	int							nAction;                    // 0:脉冲 1:开始 2:停止
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	DH_EVENT_FILE_INFO			stuFileInfo;                // 事件对应文件信息
	///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
	BYTE                		byReversed[1024];           // 保留字节
} DEV_EVENT_GENERATEGRAPH_DETECTION_INFO;

// 事件类型EVENT_IVS_TIREDPHYSIOLOGICAL(生理疲劳驾驶事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TIREDPHYSIOLOGICAL_INFO
{
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

    int                 nAction;                            // 0:脉冲 1:开始 2:停止
    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS信息
    char                szDriverID[32];                     // 司机ID
    char                szVideoPath[256];                   // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                     // 保留字节,留待扩展. 
} DEV_EVENT_TIREDPHYSIOLOGICAL_INFO;

// 事件类型EVENT_IVS_TRAFFIC_TIREDLOWERHEAD(开车低头报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TIREDLOWERHEAD_INFO
{
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS信息
    char                szDriverID[32];                     // 司机ID
    char                szVideoPath[256];                   // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                     // 保留字节,留待扩展. 
} DEV_EVENT_TIREDLOWERHEAD_INFO;

// 事件类型EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND(开车左顾右盼报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_DRIVERLOOKAROUND_INFO
{
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS信息
    char                szDriverID[32];                     // 司机ID
    char                szVideoPath[256];                   // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                     // 保留字节,留待扩展. 
} DEV_EVENT_DRIVERLOOKAROUND_INFO;

// 事件类型EVENT_IVS_INFRAREDBLOCK(红外阻断报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_INFRAREDBLOCK_INFO
{
    int                 nChannelID;                         // 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

    NET_GPS_STATUS_INFO stuGPSStatus;                       // GPS信息
    char                szDriverID[32];                     // 司机ID
    char                szVideoPath[256];                   // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                     // 保留字节,留待扩展. 
} DEV_EVENT_INFRAREDBLOCK_INFO;

// 事件类型EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST(开车离岗报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_DRIVERLEAVEPOST_INFO
{
    int                 nChannelID;                                   // 通道号
    char                szName[DH_EVENT_NAME_LEN];                    // 事件名称
    char                bReserved1[4];                                // 字节对齐
    double              PTS;                                          // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                          // 事件发生的时间
    int                 nEventID;                                     // 事件ID

    NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS信息
    char                szDriverID[32];                               // 司机ID
    char                szVideoPath[256];                             // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                               // 保留字节,留待扩展. 
} DEV_EVENT_DRIVERLEAVEPOST_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_DRIVERYAWN (开车打哈欠事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_DRIVERYAWN_INFO
{
    int                 nChannelID;                                   // 通道号
    char                szName[DH_EVENT_NAME_LEN];                    // 事件名称
    char                szReserved1[4];                               // 字节对齐
    double              PTS;                                          // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                          // 事件发生的时间
    int                 nEventID;                                     // 事件ID

    NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS信息
    char                szDriverID[32];                               // 司机ID
    char                szVideoPath[256];                             // 违章关联视频FTP上传路径
    BYTE                byReserved[736];                              // 保留字节,留待扩展. 
} DEV_EVENT_DRIVERYAWN_INFO;

// 图片类型
typedef enum tagEM_FIREWARNING_PIC_TYPE
{
	EM_PIC_UNKNOWN,		// 未知
	EM_PIC_NONE,		// 无
	EM_PIC_OVERVIEW,	// 全景图
	EM_PIC_DETAIL,		// 细节图
}EM_FIREWARNING_PIC_TYPE;
// 事件类型 EVENT_IVS_FIREWARNING(火警事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_FIREWARNING_INFO
{
	int								nChannelID;									// 通道号
	char							szName[DH_EVENT_NAME_LEN];                  // 事件名称
	DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息
	int								nAction;									// 1:开始 2:停止
	UINT							nFSID;										// Uint32	火情编号ID
	EM_FIREWARNING_PIC_TYPE			emPicType;									// 图片类型
	BOOL							bIsLeaveFireDetect;							// 是否属于离岗火点检测项目(TRUE:是 FALSE:不是)
	BYTE							byReserved[1012];							// 保留字节
}DEV_EVENT_FIREWARNING_INFO;


// 检测到的人的信息
typedef enum tagEM_DETECT_OBJECT
{
	EM_DETECT_OBJECT_UNKNOWN,					// 未知信息
	EM_DETECT_OBJECT_HUMAN_BODY_AND_FACE,		// 人体和人脸都有
	EM_DETECT_OBJECT_HUMAN_BODY,				// 仅有人体
	EM_DETECT_OBJECT_HUMAN_FACE,				// 仅有人脸
}EM_DETECT_OBJECT;

// 人体图片信息
typedef struct tagHUMAN_IMAGE_INFO
{
	UINT       nOffSet;					// 偏移 		
	UINT	   nLength;					// 图片大小,单位字节
	UINT	   nWidth;					// 图片宽度
	UINT	   nHeight;					// 图片高度
	BYTE	   byReserved[56];			// 预留字节
}HUMAN_IMAGE_INFO;

// 人脸图片信息
typedef struct tagFACE_IMAGE_INFO
{
	UINT	   nOffSet;					// 偏移   
	UINT	   nLength;					// 图片大小,单位字节
	UINT	   nWidth;					// 图片宽度
	UINT	   nHeight;					// 图片高度
	BYTE	   byReserved[56];			// 预留字节
}FACE_IMAGE_INFO;

// 人体属性信息
typedef struct tagHUMAN_ATTRIBUTES_INFO
{
	EM_CLOTHES_COLOR    emCoatColor;									// 上衣颜色
	EM_COAT_TYPE		emCoatType;										// 上衣类型
	EM_CLOTHES_COLOR	emTrousersColor;								// 裤子颜色
	EM_TROUSERS_TYPE	emTrousersType;									// 裤子类型
	EM_HAS_HAT			emHasHat;										// 是否戴帽子
	EM_HAS_BAG			emHasBag;										// 是否带包
	NET_RECT            stuBoundingBox;								    // 包围盒(8192坐标系)

	int					nAge;											// 年龄
	EM_SEX_TYPE			emSex;											// 性别
	EM_ANGLE_TYPE		emAngle;										// 角度
	EM_HAS_UMBRELLA		emHasUmbrella;									// 是否打伞
	EM_BAG_TYPE			emBag;											// 包类型
	EM_CLOTHES_PATTERN	emUpperPattern;									// 上半身衣服图案
	EM_HAIR_STYLE		emHairStyle;									// 头发样式
	EM_CAP_TYPE			emCap;											// 帽类型
	NET_POINT           stuHumanCenter;                                 // 人体型心(不是包围盒中心), 0-8191相对坐标, 相对于大图
	BYTE				byReserved[76];									// 预留字节
}HUMAN_ATTRIBUTES_INFO;

// 人脸属性
typedef struct tagNET_FACE_ATTRIBUTE
{
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE 		emSex;						// 性别
	int        								nAge;						// 年龄,-1表示该字段数据无效
    unsigned int        					nFeatureValidNum;           // 人脸特征数组有效个数,与 emFeature 结合使用
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emFeatures[DH_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 nFeatureValidNum 结合使用
	EM_COMPLEXION_TYPE						emComplexion;				// 肤色
	EM_EYE_STATE_TYPE						emEye;						// 眼睛状态
	EM_MOUTH_STATE_TYPE						emMouth;					// 嘴巴状态
	EM_MASK_STATE_TYPE 						emMask;						// 口罩状态
	EM_BEARD_STATE_TYPE						emBeard;					// 胡子状态
	int										nAttractive;				// 魅力值, 0未识别，识别时范围1-100,得分高魅力高
	NET_RECT								stuBoundingBox;				// 包围盒(8192坐标系)

    NET_EULER_ANGLE				            stuFaceCaptureAngle;		// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
                                                                        // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
    UINT                                    nFaceQuality;               // 人脸抓拍质量分数,范围 0~10000 
    int                                     nFaceAlignScore;            // 人脸对齐得分分数,范围 0~10000,-1为无效值
    int                                     nFaceClarity;               // 人脸清晰度分数,范围 0~10000,-1为无效值
    NET_POINT                               stuFaceCenter;              // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于大图
    BYTE                					bReserved[84];              // 保留字节,留待扩展.
} NET_FACE_ATTRIBUTE;

// 当前人体特征是由什么事件产生的
typedef struct tagNET_HUMANTRAIT_EXTENSION_INFO
{
	char                szAdditionalCode[MAX_HUMANTRAIT_EVENT_LEN];     // 当前人体特征是由什么事件产生的,设备刚好返回32个字节数据，多加4个字节用于字节对齐和添加字符结束符
	BYTE                byReserved[32];                                 // 保留字节
} NET_HUMANTRAIT_EXTENSION_INFO;

// 人体特征值数据在二进制数据中的位置信息
typedef struct tagNET_HUMAN_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // 人体特征值在二进制数据中的偏移, 单位:字节
    UINT                nLength;            // 人体特征值数据长度, 单位:字节
    BYTE                byReserved[32];     // 保留字节
} NET_HUMAN_FEATURE_VECTOR_INFO;

// 人脸特征值数据在二进制数据中的位置信息
typedef struct tagNET_FACE_FEATURE_VECTOR_INFO
{
    UINT                nOffset;            // 人脸特征值在二进制数据中的偏移, 单位:字节
    UINT                nLength;            // 人脸特征值数据长度, 单位:字节
    BYTE                byReserved[32];     // 保留字节
} NET_FACE_FEATURE_VECTOR_INFO;

// 事件类型 EVENT_IVS_HUMANTRAIT(人体特征事件)对应的数据块描述信息 
typedef struct tagDEV_EVENT_HUMANTRAIT_INFO
{
	int					nChannelID;									  // 通道号
	char				szName[DH_EVENT_NAME_LEN];					  // 事件名称
	int                 nEventID;                                     // 事件ID
	double              PTS;                                          // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                          // 事件发生的时间
	int                 nAction;                                      // 1:开始 2:停止
	
	EM_CLASS_TYPE		emClassType;								  // 智能事件所属大类
	int					nGroupID;									  // 事件组ID，一次检测的多个人体特征nGroupID相同
	int					nCountInGroup;								  // 一个事件组内的抓拍张数(人体个数),一次检测的多个人体特征nCountInGroup相同
	int					nIndexInGroup;								  // 一个事件组内的抓拍序号，从1开始
	HUMAN_IMAGE_INFO	stuHumanImage;								  // 人体图片信息
	FACE_IMAGE_INFO		stuFaceImage;								  // 人脸图片信息
	EM_DETECT_OBJECT	emDetectObject;								  // 检测到的人的信息
	HUMAN_ATTRIBUTES_INFO  stuHumanAttributes;						  // 人体属性
    SCENE_IMAGE_INFO    stuSceneImage;                                // 全景大图信息
	NET_FACE_ATTRIBUTE	stuFaceAttributes;							  // 人脸属性
	FACE_SCENE_IMAGE	stuFaceSceneImage;							  // 人脸全景图
	NET_EXTENSION_INFO  stuExtensionInfo;                             // 扩展信息
 	NET_HUMANTRAIT_EXTENSION_INFO   stuHumanTrait;                    // 补充事件，表示当前人体特征是由该事件产生的
    NET_HUMAN_FEATURE_VECTOR_INFO   stuHumanFeatureVectorInfo;        // 人体特征值数据在二进制数据中的位置信息
    EM_FEATURE_VERSION              emHumanFeatureVersion;            // 人体特征值版本号
    NET_FACE_FEATURE_VECTOR_INFO    stuFaceFeatureVectorInfo;         // 人脸特征值数据在二进制数据中的位置信息
    EM_FEATURE_VERSION              emFaceFeatureVersion;             // 人脸特征值版本号
}DEV_EVENT_HUMANTRAIT_INFO;

// 事件类型EVENT_IVS_BUSSHARPTURN(车辆急转报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_BUSSHARPTURN_INFO
{
	int                 nChannelID;                                   // 通道号
    char                szName[DH_EVENT_NAME_LEN];                    // 事件名称
    char                bReserved1[4];                                // 字节对齐
    double              PTS;                                          // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                          // 事件发生的时间
    int                 nEventID;                                     // 事件ID

	int                 nAction;                                      // 0:脉冲 1:开始 2:停止
	NET_GPS_STATUS_INFO stuGPSStatus;                                 // GPS信息
    BYTE				bReserved[1024];							  // 保留字节,留待扩展. 
} DEV_EVENT_BUSSHARPTURN_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_ELETAGINFO(RFID电子车牌标签事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_ELETAGINFO_INFO
{
	
	int                 nChannelID;							// 通道号
    char                szName[DH_EVENT_NAME_LEN];			// 事件名称
    char                bReserved1[4];						// 字节对齐
    double              PTS;								// 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;								// 事件发生的时间
    int                 nEventID;							// 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
    int                 nAction;                            // 0:脉冲 1:开始 2:停止
    NET_RFIDELETAG_INFO	stuRFIDEleTagInfo;					// RFID电子车牌标签信息
	int					nRetChannelNum;						// 返回通道数
	int					nLinkChannel[DH_MAX_CHANNUM];		// 关联的相机通道,通道号从0开始
	BYTE				bReserved[956];						// 保留字节,留待扩展. 
} DEV_EVENT_TRAFFIC_ELETAGINFO_INFO;


// 图片文件类型
typedef enum tagEM_PASS_CHANGE_PICTURE_TYPE
{
	EM_PASS_CHANGE_PICTURE_TYPE_UNKNOWN,					// 未知
	EM_PASS_CHANGE_PICTURE_TYPE_PASS,						// 历史图片
	EM_PASS_CHANGE_PICTURE_TYPE_REAL,						// 实时图片
} EM_PASS_CHANGE_PICTURE_TYPE;

// 事件类型 EVENT_IVS_PASS_CHANGE(预置点图片变化事件)对应数据块描述信息
typedef struct tagDEV_EVENT_PASS_CHANGE_INFO
{
	int                 nChannelID;							// 通道号
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    char                szReserved1[4];                     // 字节对齐
    double              dbPTS;                              // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID

	int					nPresetID;							// 预置点编号，从1开始
	int					nGroupID;							// 事件组ID
	int					nCountInGroup;						// 一个事件组内的抓拍张数
	int					nIndexInGroup;						// 一个事件组内的抓拍序号，从1开始
	EM_PASS_CHANGE_PICTURE_TYPE			emPictureType;		// 图片文件类型，用于回调时指定
	BYTE                byReserved1[1020];				    // 保留字节  
} DEV_EVENT_PASS_CHANGE_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_WAITINGAREA(违章进入待行区事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_WAITINGAREA_INFO
{
	int                 nChannelID;											// 通道号
	BYTE				byReserved[4];										// 保留字节，为了对齐
	char				szName[MAX_EVENT_NAME_LEN];							// 事件名称
	double				dbPTS;												// 时间戳(单位是毫秒)
	NET_TIME_EX			UTC;												// 事件发生的时间
	int					nEventID;											// 事件ID
	DH_MSG_OBJECT		stuObject;											// 车牌信息
	DH_MSG_OBJECT       stuVehicle;											// 车身信息
	int					nLane;												// 车道号
	int                 nSequence;											// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;						// 车辆信息
	DH_EVENT_FILE_INFO	stuFileInfo;										// 事件对应文件信息
	BYTE                byReserved1[1024];									// 保留字节
	EVENT_COMM_INFO     stCommInfo;											// 公共信息
}DEV_EVENT_TRAFFIC_WAITINGAREA_INFO;

#define MAX_OBJECT_NUM			32	// 最大物体个数

// 事件类型 EVENT_IVS_QUEUESTAY_DETECTION(排队滞留时间报警事件)对应数据块描述信息
typedef struct tagDEV_EVENT_QUEUESTAY_DETECTION_INFO
{
	int                 		nChannelID;                 // 通道号
	char                		szName[DH_EVENT_NAME_LEN];  // 事件名称
	char                		bReserved1[4];              // 字节对齐, 非保留字节
	double              		PTS;                        // 时间戳(单位是毫秒)
	NET_TIME_EX         		UTC;                        // 事件发生的时间
	int                 		nEventID;                   // 事件ID
	int							nAction;                    // 0:脉冲 1:开始 2:停止
	///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
	int							nGroupID;					// 事件组ID，一次检测的多个人体特征nGroupID相同
	int							nCountInGroup;				// 一个事件组内的抓拍张数(人体个数),一次检测的多个人体特征nCountInGroup相同
	int							nIndexInGroup;				// 一个事件组内的抓拍序号，从1开始
	DH_MSG_OBJECT				stuObject;					// 检测到的物体信息
	int							nObjectNum;					// 检测到的物体个数
	DH_MSG_OBJECT				stuObjects[MAX_OBJECT_NUM]; // 检测到的多个物体
	int							nDetectRegionNum;						// 实际检测到区域个数	
	DH_POINT					stuDetectRegion[DH_MAX_DETECT_REGION_NUM];	// 检测区域
	UINT						nAreaID;					// 区域ID(一个预置点可以对应多个区域ID)
	int							nCount;						// 事件被触发的次数
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	DH_EVENT_FILE_INFO			stuFileInfo;                // 事件对应文件信息
	BYTE                		byReversed[1024];           // 保留字节
} DEV_EVENT_QUEUESTAY_DETECTION_INFO;

// 事件类型EVENT_IVS_BANNER_DETECTION(拉横幅事件)对应数据块描述信息
typedef struct tagDEV_EVENT_BANNER_DETECTION_INFO
{
	int					nChannelID;									  // 通道号
	int                 nEventID;                                     // 事件ID
	char				szName[DH_EVENT_NAME_LEN];					  // 事件名称
	double              PTS;                                          // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                          // 事件发生的时间
	int                 nAction;                                      // 1:开始 2:停止
	
	EM_CLASS_TYPE		emClassType;								  // 智能事件所属大类
	DH_EVENT_FILE_INFO	stuFileInfo;								  // 事件对应文件信息
	int					nObjectNum;									  // 检测到的物体个数
	DH_MSG_OBJECT       stuObjects[MAX_OBJECT_NUM];                    // 检测到的物体
    int                 nDetectRegionNum;                   		  // 检测区域顶点数	
    DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 	  // 检测区域
    int					nCount;										  // 事件触发次数
    int				    nPresetID;									  // 预置点
	NET_EXTENSION_INFO  stuExtensionInfo;                             // 扩展信息
	BYTE				byReserved[1028];							  // 保留字节,留待扩展.
} DEV_EVENT_BANNER_DETECTION_INFO;

// 非机动车抠图信息
typedef struct tagNONMOTOR_IMAGE_INFO
{
    int nOffset;                                                        // 在二进制数据块中的偏移
    int nLength;                                                        // 图片大小,单位字节
}NONMOTOR_IMAGE_INFO;

// 事件类型EVENT_IVS_NONMOTORDETECT(非机动车检测) 对应数据块描述信息
typedef struct tagDEV_EVENT_NONMOTORDETECT_INFO
{
	int					nChannelID;									    // 通道号
	int                 nEventID;                                       // 事件ID
	char				szName[DH_EVENT_NAME_LEN];					    // 事件名称
	double              PTS;                                            // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                            // 事件发生的时间
	int                 nAction;                   					    // 0:脉冲 1:开始 2:停止

    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                     // 智能事件公共信息
    DWORD               dwSnapFlagMask;                                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO  stuResolution;                                  // 对应图片的分辨率

    NONMOTOR_IMAGE_INFO stuImageInfo;                                   // 非机动车抠图信息
    int					nNumOfCycling;								    // 骑车人数量
    EM_OBJECT_COLOR_TYPE emNonMotorColor;							    // 非机动车颜色
    DH_RECT				        stuBoundingBox;                         // 包围盒
    EM_SEX_TYPE		            emSex;								    // 车上一人时的性别
    int					        nAge;								    // 车上一人时的年龄
    
    EM_NONMOTOR_OBJECT_STATUS   emHelmet;					  		    // 车上人员头盔状态
    EM_NONMOTOR_OBJECT_STATUS   emCall;							        // 车上一人时是否在打电话
    EM_NONMOTOR_OBJECT_STATUS   emHat;					  			    // 车上一人时是否戴帽子
    EM_NONMOTOR_OBJECT_STATUS   emBag;					  			    // 车上一人时是否有背包
    EM_NONMOTOR_OBJECT_STATUS   emCarrierBag;					  	    // 车上一人时有没有手提包
    EM_NONMOTOR_OBJECT_STATUS   emUmbrella;					  	        // 是否打伞
    EM_NONMOTOR_OBJECT_STATUS   emGlasses;					  	  	    // 车上一人时是否有带眼镜
    EM_NONMOTOR_OBJECT_STATUS   emMask;					  	  	        // 车上一人时是否带口罩

	EM_EMOTION_TYPE             emEmotion;                              // 车上一人时的表情
    EM_CLOTHES_TYPE             emUpClothes;                            // 车上一人时上衣类型
	EM_CLOTHES_TYPE             emDownClothes;                          // 车上一人时下衣类型
	EM_OBJECT_COLOR_TYPE        emUpperBodyColor;                       // 车上一人时上衣颜色
	EM_OBJECT_COLOR_TYPE        emLowerBodyColor;                       // 车上一人时下衣颜色
	EM_CATEGORY_NONMOTOR_TYPE   emCategoryType;                         // 物体类型（NonMotor）中的子类别
	BYTE						byReserved[1024];						// 保留字节,留待扩展.
}DEV_EVENT_NONMOTORDETECT_INFO;

// 触发类型
typedef enum tagEM_TRIGGER_TYPE
{
	EM_TRIGGER_TYPE_UNKNOWN = -1,          // 未知类型
	EM_TRIGGER_TYPE_CAR_INSPECTION_DEV,	   // 车检器
	EM_TRIGGER_TYPE_DADAR,				   // 雷达
	EM_TRIGGER_TYPE_VIDEO,				   // 视频
}EM_TRIGGER_TYPE;

// 违章事件类型
typedef enum tagEM_VIOLATION_ALARM_TYPE
{
	EM_VIOLATION_ALARM_TYPE_UNKNOWN = -1,			// 未知类型
	EM_VIOLATION_ALARM_TYPE_PARKING_VIOLATION,		// 违章停车事件
	EM_VIOLATION_ALARM_TYPE_PREALARM,				// 预警事件
}EM_VIOLATION_ALARM_TYPE;

// 车载定制GPS信息
typedef struct tagNET_CUSTOM_GPS_INFO
{
	double                  dbLongitude;                      // 经度(单位是百万分之度,范围0-360度)
	double                  dbLatidude;                       // 纬度(单位是百万分之度,范围0-180度)
	double					dbAltitude;						  // 高度,单位:米
	double				    dbSpeed;						  // 速度,单位:km/H
	double					dbBearing;						  // 方向角,单位:度
	BYTE					byReserved[1024];				  // 保留字节
}NET_CUSTOM_GPS_INFO;

// 机动车违法禁令标识事件(对应EVENT_IVS_TRAFFIC_BAN)
typedef struct tagDEV_EVENT_TRAFFIC_BAN_INFO
{
	int							nChannelID;											// 通道号
	EM_TRIGGER_TYPE				emTriggerType;										// 触发类型
	char						szName[MAX_EVENT_NAME_LEN];							// 事件名称
	double						dbPTS;												// 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;												// 事件发生的时间
	int							nEventID;											// 事件ID
	DH_MSG_OBJECT				stuObject;											// 车牌信息
	DH_MSG_OBJECT				stuVehicle;											// 车身信息
	int							nMark;												// 底层产生的触发抓拍帧标记
	int							nSource;											// 视频分析的数据源地址
	int							nFrameSequence;										// 视频分析帧序号
	int							nLane;											    // 车道编号
	NET_TIME					stuStartParkingTime;								// 开始停车时间
	int							nAlarmInterval;										// 报警间隔时间,单位:秒
	int							nParkingAllowedTime;								// 允许停车时间,单位:秒
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO   stTrafficCar;								// 车辆信息
	DH_EVENT_FILE_INFO			stuFileInfo;										// 事件对应文件信息
	NET_CUSTOM_GPS_INFO			stuCustomGPSStatus;									// 定制GPS信息
	EM_VIOLATION_ALARM_TYPE		emViolationAlarmType;								// 违章事件类型
	int							nSequence;											// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
	BYTE						byReserved[1024];									// 保留字节
	EVENT_COMM_INFO				stCommInfo;											// 公共信息
}DEV_EVENT_TRAFFIC_BAN_INFO;

// 事件类型EVENT_IVS_ELEVATOR_ABNORMAL(电动扶梯运行异常事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELEVATOR_ABNORMAL_INFO
{
	int                 nChannelID;							// 通道号
    int                 nEventID;                           // 事件ID
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称
    double              dbPTS;                              // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    
    int                 nAction;                            // 1:开始 2:停止
    EM_CLASS_TYPE		emClassType;						// 智能事件所属大类
    int					nDetectRegionPointNum;				// 扶梯检测区顶点数
    NET_POINT		    stuDetectRegion[20];				// 扶梯检测区多边形类型，多边形中每个顶点的坐标归一化到[0,8192)区间。
    NET_POINT           stuDirection[2];                    // 扶梯的运动方向，第一个点是起点，第二个点是终点。坐标归一化到[0,8192)区间。
	BYTE                byReserved1[920];				    // 保留字节
} DEV_EVENT_ELEVATOR_ABNORMAL_INFO;

// POS交易中的商品清单信息
typedef struct tagNET_POS_ITEM_INFO
{
	char				szItemName[DH_COMMON_STRING_32];					// 商品名称
	double				dbPrice;											// 商品单价
	double				dbQuantity;											// 数量
	double				dbAmount;											// 总价
	char				szUnit[DH_COMMON_STRING_8];							// 计价单位
	BYTE				byReserved[256];									// 保留字节
} NET_POS_ITEM_INFO;

// 事件类型 EVENT_IVS_POS_EXCHANGE(POS机交易事件)对应数据块描述信息
typedef struct tagDEV_EVENT_POS_EXCHANGE_INFO
{
	int                 nChannelID;							// 通道号
	int                 nAction;                            // 0:脉冲 1:开始 2:停止
    char                szName[DH_EVENT_NAME_LEN];			// 事件名称
    double              dbPTS;								// 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;								// 事件发生的时间
    int                 nEventID;							// 事件ID
	
	char				szDealNum[DH_COMMON_STRING_16];		// 交易号
	char				szCardID[DH_COMMON_STRING_16];		// 卡号
	BYTE				byReserved1[4];						// 字节对齐
	int					nItemListCount;						// 商品清单数量 
	NET_POS_ITEM_INFO	*pstItemList;						// 商品清单信息, 大小为nItemListCount*sizeof(NET_POS_ITEM_INFO)
	NET_RECT			stRect;								// POS采集内容在视频上的叠加位置,矩形区域
	NET_COLOR_RGBA      stFrontColor;						// OSD前景颜色
	unsigned int		nFontSize;							// 字体大小, 单位px
	BYTE                byReserved[1020];				    // 保留字节  
} DEV_EVENT_POS_EXCHANGE_INFO;

// 事件类型 EVENT_IVS_DISTANCE_DETECTION (异常间距事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_DISTANCE_DETECTION_INFO
{
	int                 nChannelID;                         // 通道号
	char                szName[128];                        // 事件名称
	int                 nAction;                            // 0:脉冲 1:开始 2:停止
	double              PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                // 事件发生的时间
	int                 nEventID;                           // 事件ID
	DH_MSG_OBJECT       stuObject;                          // 检测到的物体
	int                 nDetectRegionNum;                   // 检测区域顶点数
	NET_POINT           stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; // 检测区域
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息 
	BYTE                byReserved[1024];				    // 保留字节  
} DEV_EVENT_DISTANCE_DETECTION_INFO;

// 事件类型 EVENT_IVS_FORWARDCOLLISION_WARNNING(前向碰撞预警) 对应的数据块描述信息
typedef struct tagDEV_EVENT_FORWARDCOLLISION_WARNNING_INFO
{
    int                     nChannelID;                                 // 通道号
    int                     nEventID;                                   // 事件ID
    char                    szName[DH_EVENT_NAME_LEN];                  // 事件名称
    double                  PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                        // 事件发生的时间
    int                     nAction;                                    // 0:脉冲 1:开始 2:停止

    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                           // GPS信息
    char                    szDriverID[32];                             // 司机ID
    char                    szVideoPath[256];                           // 违章关联视频FTP上传路径
    BYTE                    byReserved[736];                            // 保留字节
} DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO;

// 事件类型 EVENT_IVS_MATERIALSSTAY(物料堆放事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_MATERIALSSTAY_INFO
{
	int						nChannelID;										// 通道号
	int						nEventID;										// 事件ID
	char					szName[DH_EVENT_NAME_LEN];						// 事件名称
	double					PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX				UTC;											// 事件发生的时间
	int						nAction;										// 0:脉冲 1:开始 2:停止

	DH_EVENT_FILE_INFO		stuFileInfo;									// 事件对应文件信息
	int						nDetectRegionNum;                   			// 检测区域顶点数	
	DH_POINT				DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// 检测区域
	char					szPresetName[64];								// 事件触发的预置名称
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;								// 智能事件公共信息 
	BYTE					byReserved[4092];								// 保留字节  
} DEV_EVENT_MATERIALSSTAY_INFO;

// 事件类型 EVNET_IVS_LANEDEPARTURE_WARNNING(车道偏移预警) 对应的数据块描述信息
typedef struct tagDEV_EVENT_LANEDEPARTURE_WARNNING_INFO
{
    int                     nChannelID;                                 // 通道号
    int                     nEventID;                                   // 事件ID
    char                    szName[DH_EVENT_NAME_LEN];                  // 事件名称
    double                  PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                        // 事件发生的时间
    int                     nAction;                                    // 0:脉冲 1:开始 2:停止

    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                           // GPS信息
    char                    szDriverID[32];                             // 司机ID
    char                    szVideoPath[256];                           // 违章关联视频FTP上传路径
    BYTE                    byReserved[736];                            // 保留字节
} DEV_EVENT_LANEDEPARTURE_WARNNING_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_NONMOTOR_OVERLOAD (非机动车超载事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO
{
	int							nChannelID;                         // 通道号
	char						szName[128];                        // 事件名称
	int							nAction;                            // 0:脉冲 1:开始 2:停止
	double						PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;                                // 事件发生的时间
	int							nEventID;                           // 事件ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// 事件对应文件信息
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// 智能事件公共信息 
	DWORD						dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO			stuResolution;                      // 对应图片的分辨率

	VA_OBJECT_NONMOTOR			stuNonMotor;						// 非机动车信息
	int							nLane;								// 车道号
	int							nSequence;							// 抓拍序号，如3-2-1/0，1表示抓拍正常结束，0表示抓拍异常结束
	EVENT_COMM_INFO				stuCommInfo;						// 公共信息
	BYTE						byReserved[2048];				    // 保留字节  
} DEV_EVENT_TRAFFIC_NONMOTOR_OVERLOAD_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT (非机动车未戴安全帽事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO
{
	int							nChannelID;                         // 通道号
	char						szName[128];                        // 事件名称
	int							nAction;                            // 0:脉冲 1:开始 2:停止
	double						PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;                                // 事件发生的时间
	int							nEventID;                           // 事件ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// 事件对应文件信息
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// 智能事件公共信息 
	DWORD						dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO			stuResolution;                      // 对应图片的分辨率

	VA_OBJECT_NONMOTOR			stuNonMotor;						// 非机动车信息
	int							nLane;								// 车道号
	int							nSequence;							// 抓拍序号，如3-2-1/0，1表示抓拍正常结束，0表示抓拍异常结束
	EVENT_COMM_INFO				stuCommInfo;						// 公共信息
	BYTE						byReserved[2048];				    // 保留字节  
} DEV_EVENT_TRAFFIC_NONMOTOR_WITHOUTSAFEHAT_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_NONMOTOR_HOLDUMBRELLA (非机动车装载伞具事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO
{
	int							nChannelID;                         // 通道号
	int							nAction;                            // 0:脉冲 1:开始 2:停止
	char						szName[128];                        // 事件名称
	double						PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;                                // 事件发生的时间
	int							nEventID;                           // 事件ID
	DH_EVENT_FILE_INFO			stuFileInfo;						// 事件对应文件信息
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// 智能事件公共信息 
	DWORD						dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO			stuResolution;                      // 对应图片的分辨率

	DH_MSG_OBJECT				stuObject;                          // 检测到的物体
	VA_OBJECT_NONMOTOR			stuNonMotor;						// 非机动车信息
	int							nLane;								// 车道号
	int							nSequence;							// 抓拍序号，如3-2-1/0，1表示抓拍正常结束，0表示抓拍异常结束
	EVENT_COMM_INFO				stCommInfo;                         // 公共信息
	BYTE						byReserved[4096];				    // 保留字节  
}DEV_EVENT_TRAFFIC_NONMOTOR_HOLDUMBRELLA_INFO;

// 事件类型EVENT_IVS_VIDEOUNFOCUS (视频虚焦事件)
typedef struct tagDEV_EVENT_VIDEOUNFOCUS_INFO
{
	int						nChannelID;									  // 通道号
	int						nEventID;                                     // 事件ID
	char					szName[DH_EVENT_NAME_LEN];					  // 事件名称
	double					PTS;                                          // 时间戳(单位是毫秒)
	NET_TIME_EX				UTC;                                          // 事件发生的时间
	int						nAction;                                      // 0:脉冲 1:开始 2:停止
	BYTE					byReserved[4096];				    		  // 保留字节  
}DEV_EVENT_VIDEOUNFOCUS_INFO; 


// 事件类型 EVENT_IVS_FLOWBUSINESS (流动摊贩事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_FLOWBUSINESS_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[128];									// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
	int                 nDetectRegionNum;                   			// 检测区域顶点数	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// 检测区域
	char				szPresetName[64];								// 事件触发的预置名称
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息 
    UINT                nViolationDuration;                             // 违法持续时长，单位：秒 缺省值0表示无意义 
    int					nObjectNum;										// 检测到的物体个数
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];				// 检测到的物体
    char				szSourceID[32];								    // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;									// 抓图标志(按位),具体见NET_RESERVED_COMMON    
	BYTE                byReserved[2044];								// 保留字节  
} DEV_EVENT_FLOWBUSINESS_INFO;

// 事件类型 EVENT_IVS_CITY_MOTORPARKING (城市机动车违停事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_CITY_MOTORPARKING_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[128];									// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
	int					nObjectNum;										// 检测到的物体个数
	DH_MSG_OBJECT		stuObjects[MAX_OBJECT_NUM];						// 检测到的物体
	int                 nDetectRegionNum;                   			// 检测区域顶点数	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// 检测区域
	char				szPresetName[64];								// 事件触发的预置名称
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息 
    UINT                nParkingDuration;                               // 违停持续时长，单位：秒 缺省值0表示无意义 
    char				szSourceID[32];								    // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;									// 抓图标志(按位),具体见NET_RESERVED_COMMON    
	BYTE                byReserved[4056];								// 保留字节  
} DEV_EVENT_CITY_MOTORPARKING_INFO;

// 事件类型 EVENT_IVS_CITY_NONMOTORPARKING (城市非机动车违停事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_CITY_NONMOTORPARKING_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[128];									// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
	int                 nDetectRegionNum;                   			// 检测区域顶点数	
	DH_POINT            DetectRegion[DH_MAX_DETECT_REGION_NUM]; 		// 检测区域
	int					nAlarmNum;										// 报警阈值
	int					nNoMotorNum;									// 非机动车的个数
	char				szPresetName[64];								// 事件触发的预置名称
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息 
    UINT                nViolationDuration;                             // 违法持续时长，单位：秒 缺省值0表示无意义 
    int					nObjectNum;										// 检测到的物体个数
    DH_MSG_OBJECT		stuObjects[HDBJ_MAX_OBJECTS_NUM];				// 检测到的物体
    char				szSourceID[32];								    // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;									// 抓图标志(按位),具体见NET_RESERVED_COMMON    
	BYTE                byReserved[2044];								// 保留字节 
} DEV_EVENT_CITY_NONMOTORPARKING_INFO;

// 飞机行为状态
typedef enum tagEM_AIRPLANE_STATE
{
	EM_AIRPLANE_STATE_UNKNOWN = 0,
	EM_AIRPLANE_STATE_ENTER,						// 飞机入位
	EM_AIRPLANE_STATE_LEAVE,						// 飞机离位
	EM_AIRPLANE_STATE_CHOCKON,						// 上轮挡
	EM_AIRPLANE_STATE_CHOCKOFF,						// 下轮挡
	EM_AIRPLANE_STATE_NEARBRIDGE,					// 靠廊桥
	EM_AIRPLANE_STATE_LEAVEBRIDGE,					// 撤廊桥
	EM_AIRPLANE_STATE_OPENDOOR,						// 舱门开
	EM_AIRPLANE_STATE_CLOSEDOOR						// 舱门关
}EM_AIRPLANE_STATE;

// 事件类型 EVENT_IVS_AIRPLANE_DETECTION (飞机行为检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_AIRPLANE_DETECTION_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[128];									// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID

	DH_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息 

	NET_POINT			stuGuideLine[2];								// 配置的导向线
	NET_POINT			stuStopLine[10][2];								// 配置的停止线
	int					nStopLineNum;									// 配置的停止线数量
	int					nAirPlaneID;									// 飞机ID
	NET_POINT			stuAirPlaneStopLine[2];							// 飞机停止位置线
	NET_RECT			stuRect;										// 检测飞机的位置
	EM_AIRPLANE_STATE	emAirPlaneState;								// 飞机行为状态

	BYTE                byReserved[4096];								// 保留字节  
} DEV_EVENT_AIRPLANE_DETECTION_INFO;

// 事件类型 EVENT_IVS_PHONECALL_DETECT(打电话检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_PHONECALL_DETECT_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[MAX_EVENT_NAME];							// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID
	
	int					nGroupID;										// 事件组ID
	int					nCountInGroup;									// 一个事件组内的抓拍张数
	int					nIndexInGroup;									// 一个事件组内的抓拍序号，从1开始
	unsigned int		UTCMS;											// UTC对应的毫秒数
	DH_MSG_OBJECT		stuObject;										// 检测到的物体
	int					nDetectRegionNum;								// 规则检测区域顶点数
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];		// 规则检测区域
	EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;						// 智能事件公共信息 
	BYTE				byReserved[1024];								// 保留字节
} DEV_EVENT_PHONECALL_DETECT_INFO;

// 事件类型 EVENT_IVS_SMOKING_DETECT(吸烟检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SMOKING_DETECT_INFO
{
	int                 nChannelID;										// 通道号
	int                 nAction;										// 0:脉冲 1:开始 2:停止
	char                szName[MAX_EVENT_NAME];							// 事件名称
	double              PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;											// 事件发生的时间
	int                 nEventID;										// 事件ID

	int					nGroupID;										// 事件组ID
	int					nCountInGroup;									// 一个事件组内的抓拍张数
	int					nIndexInGroup;									// 一个事件组内的抓拍序号，从1开始
	unsigned int		UTCMS;											// UTC对应的毫秒数
	DH_MSG_OBJECT		stuObject;										// 检测到的物体
	int					nDetectRegionNum;								// 规则检测区域顶点数
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];		// 规则检测区域
	EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;						// 智能事件公共信息 
	BYTE				byReserved[1024];								// 保留字节
} DEV_EVENT_SMOKING_DETECT_INFO;

// 事件类型 EVENT_IVS_RADAR_SPEED_LIMIT_ALARM(雷达限速报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO
{
	int                 nChannelID;                                     // 通道号
	int                 nAction;                                        // 0:脉冲 1:开始 2:停止
    char                szAddress[32];                                  // 设备IP地址
    int                 nSpeed;                                         // 时速, 单位km/h
    NET_TIME_EX         UTC;                                            // 事件发生时间；

    int                 nGroupID;                                       // 事件组ID
    int                 nCountInGroup;                                  // 一个事件组内的抓拍张数
    int                 nIndexInGroup;                                  // 一个事件组内的抓拍序号，测速过程第n张图片,从1开始
    EVENT_INTELLI_COMM_INFO    stuIntelliCommInfo;                      // 智能事件公共信息
    BYTE                byReserved[1024];                               // 保留字节
}DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO;

// 水果类型
typedef enum tagEM_FRUIT_TYPE
{
	EM_FRUIT_TYPE_UNKNOWN,					// 未知
	EM_FRUIT_TYPE_GREEN_TANGERINE,			// 青橘
	EM_FRUIT_TYPE_YELLOW_TANGERINE_ORANGE,	// 黄橘，橙类
	EM_FRUIT_TYPE_GRAPEFRUIT,				// 柚子
	EM_FRUIT_TYPE_LEMON,					// 柠檬
	EM_FRUIT_TYPE_WATERMELON,				// 西瓜
	EM_FRUIT_TYPE_BANANA,					// 香蕉
	EM_FRUIT_TYPE_RED_APPLE,				// 红苹果
	EM_FRUIT_TYPE_GREEN_APPLE,				// 青苹果
	EM_FRUIT_TYPE_MUSKMELON,				// 香瓜
	EM_FRUIT_TYPE_HAMIMELON,				// 哈密瓜
	EM_FRUIT_TYPE_PEAR,						// 梨
	EM_FRUIT_TYPE_KIWI,						// 奇异果
	EM_FRUIT_TYPE_PAPAYA,					// 木瓜
	EM_FRUIT_TYPE_PINEAPPLE,				// 菠萝
	EM_FRUIT_TYPE_MANGO,					// 芒果
	EM_FRUIT_TYPE_LONGAN,					// 龙眼
	EM_FRUIT_TYPE_GINSENG_FRUIT,			// 人参果
	EM_FRUIT_TYPE_POMEGRABATE,				// 石榴
	EM_FRUIT_TYPE_COCONUT,					// 椰子
	EM_FRUIT_TYPE_CREAM_JUJUBE,				// 奶油枣
	EM_FRUIT_TYPE_WINTER_JUJUBE,			// 冬枣
	EM_FRUIT_TYPE_AVOCADO,					// 牛油果
	EM_FRUIT_TYPE_RED_PLUM,					// 红布林
	EM_FRUIT_TYPE_PITAYA,					// 火龙果
	EM_FRUIT_TYPE_GUAVA,					// 芭乐
	EM_FRUIT_TYPE_PERSIMMON,				// 柿子
	EM_FRUIT_TYPE_YACON,					// 雪莲果
} EM_FRUIT_TYPE;

// 检测到的水果信息
typedef struct tagNET_CANDIDATE_FRUIT_INFO
{
	UINT				nSimilarity;				// 相似度
	EM_FRUIT_TYPE		emFruitType;				// 检测到的水果类型
	BYTE                byReserved[1024];            // 保留字节
} NET_CANDIDATE_FRUIT_INFO;

// 事件类型 EVENT_IVS_WEIGHING_PLATFORM_DETECTION(称重平台检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO
{
	int                 		nChannelID;					// 通道号
	int                 		nAction;					// 0:脉冲 1:开始 2:停止
	char                		szName[MAX_EVENT_NAME];		// 事件名称
	double              		PTS;						// 时间戳(单位是毫秒)
	NET_TIME_EX         		UTC;						// 事件发生的时间
	int                 		nEventID;					// 事件ID

	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	UINT						nCandidateFruitNum;			// 检测到的水果信息个数
	NET_CANDIDATE_FRUIT_INFO	stuFruitInfos[100];			// 检测到的水果信息
	SCENE_IMAGE_INFO_EX			stuSceneImage;				// 全景图
	SCENE_IMAGE_INFO_EX			stuFruitImage;				// 水果抠图
	BYTE                		byReserved[1024];            // 保留字节
} DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO;

// media文件查询条件
typedef enum __EM_FILE_QUERY_TYPE
{
    DH_FILE_QUERY_TRAFFICCAR,                           // 交通车辆信息,对应结构体为MEDIA_QUERY_TRAFFICCAR_PARAM
    DH_FILE_QUERY_ATM,                                  // ATM信息
    DH_FILE_QUERY_ATMTXN,                               // ATM交易信息 
    DH_FILE_QUERY_FACE,                                 // 人脸信息 MEDIAFILE_FACERECOGNITION_PARAM 和 MEDIAFILE_FACERECOGNITION_INFO  
    DH_FILE_QUERY_FILE,                                 // 文件信息对应 NET_IN_MEDIA_QUERY_FILE 和 NET_OUT_MEDIA_QUERY_FILE
    DH_FILE_QUERY_TRAFFICCAR_EX,                        // 交通车辆信息, 扩展DH_FILE_QUERY_TRAFFICCAR, 支持更多的字段，对应结构体为MEDIA_QUERY_TRAFFICCAR_PARAM_EX
    DH_FILE_QUERY_FACE_DETECTION,                       // 人脸检测事件信息 MEDIAFILE_FACE_DETECTION_PARAM 和 MEDIAFILE_FACE_DETECTION_INFO 
    DH_FILE_QUERY_IVS_EVENT,                            // 智能事件信息 MEDIAFILE_IVS_EVENT_PARAM 和 MEDIAFILE_IVS_EVENT_INFO
    DH_FILE_QUERY_ANALYSE_OBJECT,                       // 智能分析其他物体(人和车除外) MEDIAFILE_ANALYSE_OBJECT_PARAM 和 MEDIAFILE_ANALYSE_OBJECT_INFO
    DH_FILE_QUERY_MPT_RECORD_FILE,                      // MPT设备的录像文件 MEDIAFILE_MPT_RECORD_FILE_PARAM 和 MEDIAFILE_MPT_RECORD_FILE_INFO
	DH_FILE_QUERY_XRAY_DETECTION,						// X光检包裹信息对应 MEDIAFILE_XRAY_DETECTION_PARAM 和 MEDIAFILE_XRAY_DETECTION_INFO
    DH_FILE_QUERY_HUMAN_TRAIT,                          // 人体检测 MEDIAFILE_HUMAN_TRAIT_PARAM 和 MEDIAFILE_HUMAN_TRAIT_INFO
	DH_FILE_QUERY_NONMOTOR,								// 非机动车查询,  MEDIAFILE_NONMOTOR_PARAM 和 MEDIAFILE_NONMOTOR_INFO
	DH_FILE_QUERY_DOORCONTROL_RECORD,					// 门打开事件查询, MEDIAFILE_DOORCONTROL_RECORD_PARAM 和 MEDIAFILE_DOORCONTROL_RECORD_INFO	
	DH_FILE_QUERY_FACEBODY_DETECT,						// 人像检测查询，MEDIAFILE_FACEBODY_DETECT_PARAM 和 MEDIAFILE_FACEBODY_DETECT_INFO
	DH_FILE_QUERY_FACEBODY_ANALYSE,						// 人像识别查询，MEDIAFILE_FACEBODY_ANALYSE_PARAM 和 MEDIAFILE_FACEBODY_ANALYSE_INFO
	DH_FILE_QUERY_FILE_EX,								// 文件信息扩展（定制），对应 NET_IN_MEDIA_QUERY_FILE 和 NET_OUT_MEDIA_QUERY_FILE
														// 此时 NET_IN_MEDIA_QUERY_FILE 中的 stuEventInfo 字段有效, nEventLists 及 nEventCount字段无效
} EM_FILE_QUERY_TYPE;

typedef enum _EM_RECORD_SNAP_FLAG_TYPE
{
    FLAG_TYPE_TIMING ,                  //定时文件
    FLAG_TYPE_MANUAL ,                  //手动文件
    FLAG_TYPE_MARKED ,                  //重要文件
    FLAG_TYPE_EVENT  ,                  //事件文件
    FLAG_TYPE_MOSAIC ,                  //合成图片
    FLAG_TYPE_CUTOUT ,                  //抠图图片
    FLAG_TYPE_LEAVE_WORD ,              //留言文件
    FLAG_TYPE_TALKBACK_LOCAL_SIDE ,     //对讲本地方文件
    FLAG_TYPE_TALKBACK_REMOTE_SIDE ,    //对讲远程方文件
    FLAG_TYPE_SYNOPSIS_VIDEO ,          //浓缩视频
    FLAG_TYPE_ORIGINAL_VIDEO ,          //原始视频
    FLAG_TYPE_PRE_ORIGINAL_VIDEO ,      //已经预处理的原始视频
    FLAG_TYPE_BLACK_PLATE ,             //黑名单图片
    FLAG_TYPE_ORIGINAL_PIC ,            //原始图片
    FLAG_TYPE_CARD,                     //卡号录像
    FLAG_TYPE_MAX = 128, 
}EM_RECORD_SNAP_FLAG_TYPE;

// ATM交易类型
typedef enum
{
    ATM_TRADE_ALL,                      // 所有类型
    ATM_TRADE_ENQUIRY,                  // 查询
    ATM_TRADE_WITHDRAW,                 // 取款
    ATM_TRADE_MODIFY_PASSWORD,          // 修改密码
    ATM_TRADE_TRANSFER,                 // 转账
    ATM_TRADE_DEPOSIT,                  // 存款
    ATM_TRADE_CARDLESS_ENQUIRY,         // 无卡查询
    ATM_TRADE_CARDLESS_DEPOSIT,         // 无卡存款
    ATM_TRADE_OTHER,                    // 其他
}EM_ATM_TRADE_TYPE;

// 卡号录像信息
typedef struct
{
    DWORD               dwSize;
    int                 nType;                                          // 类型, 0-Card, 1-Field
    char                szCardNo[DH_MAX_CARD_INFO_LEN];                 // 卡号
    EM_ATM_TRADE_TYPE   emTradeType;                                    // 交易类型
    char                szAmount[DH_COMMON_STRING_64];                  // 交易金额, 空字符串表示不限金额
    int                 nError;                                         // 错误码, 0-所有错误, 1-吞钞, 2-吞卡
    int                 nFieldCount;                                    // 域数量, 按域查询时有效
    char                szFields[MAX_CARD_RECORD_FIELD_NUM][DH_COMMON_STRING_256];   // 域信息, 按域查询时有效
	char				szChange[DH_COMMON_STRING_32];		            // 零钱
}NET_RECORD_CARD_INFO;

#define MAX_IVS_EVENT_NUM    256
#define MAX_QUERY_USER_NUM   4                  // 最大查询用户个数

// 查询结果排序方式
typedef enum tagEM_RESULT_ORDER_TYPE
{
    EM_RESULT_ORDER_UNKNOWN,                    // 未知
    EM_RESULT_ORDER_ASCENT_BYTIME,              // 按时间升序排序
    EM_RESULT_ORDER_DESCENT_BYTIME,             // 按时间降序排序   
}EM_RESULT_ORDER_TYPE;

// 录像信息对应 CLIENT_FindFileEx 接口的 DH_FILE_QUERY_FILE / DH_FILE_QUERY_FILE_EX 命令 查询条件
// 目前支持通过路径查询
typedef struct  tagNET_IN_MEDIA_QUERY_FILE
{
    DWORD							dwSize;                 // 结构体大小
    char*							szDirs;                 // 工作目录列表,一次可查询多个目录,为空表示查询所有目录。目录之间以分号分隔,如“/mnt/dvr/sda0;/mnt/dvr/sda1”,szDirs==null 或"" 表示查询所有
    int								nMediaType;             // 文件类型,0:查询任意类型,1:查询jpg图片,2:查询dav
    int								nChannelID;             // 通道号从0开始,-1表示查询所有通道
    NET_TIME						stuStartTime;           // 开始时间    
    NET_TIME						stuEndTime;             // 结束时间
    int								nEventLists[MAX_IVS_EVENT_NUM]; // 事件类型列表,参见智能分析事件类型
    int								nEventCount;            // 事件总数
    BYTE							byVideoStream;          // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3  5-所有的辅码流类型
    BYTE							bReserved[3];           // 字节对齐
    EM_RECORD_SNAP_FLAG_TYPE		emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件
    int								nFalgCount;             // 标志总数
    NET_RECORD_CARD_INFO			stuCardInfo;			// 卡号录像信息, emFalgLists包含卡号录像时有效
    int								nUserCount;             // 用户名有效个数
    char							szUserName[MAX_QUERY_USER_NUM][DH_NEW_USER_NAME_LENGTH]; // 用户名
    EM_RESULT_ORDER_TYPE			emResultOrder;			// 查询结果排序方式
    BOOL							bTime;                  // 是否按时间查询
	NET_EM_COMBINATION_MODE			emCombination;			// 查询结果是否合并录像文件
	EVENT_INFO						stuEventInfo[16];		// 事件信息（定制），当查询为 DH_FILE_QUERY_FILE_EX 类型时有效
	int								nEventInfoCount;		// stuEventInfo 个数
}NET_IN_MEDIA_QUERY_FILE;

// 文件摘要信息
typedef struct 
{
    char szKey[DH_COMMON_STRING_64];           // 摘要名称
    char szValue[DH_COMMON_STRING_512];        // 摘要内容
    BYTE bReserved[256];                       // 保留字段   
}NET_FILE_SUMMARY_INFO;

// 录像信息对应 CLIENT_FindFileEx 接口的 DH_FILE_QUERY_FILE / DH_FILE_QUERY_FILE_EX 命令 查询结果
typedef struct  
{
    DWORD               dwSize;                 // 结构体大小
    int                 nChannelID;             // 通道号从0开始,-1表示查询所有通道
    NET_TIME            stuStartTime;           // 开始时间    
    NET_TIME            stuEndTime;             // 结束时间
    unsigned int        nFileSize;              // 文件长度,该字段废弃,使用nFileSizeEx字段
    BYTE                byFileType;             // 文件类型 1:jpg图片, 2: dav
    BYTE                byDriveNo;              // 该字段已废弃,后续开发使用 nDriveNo成员
    BYTE                byPartition;            // 分区号
    BYTE                byVideoStream;          // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流 4-辅码流 
    unsigned int        nCluster;               // 簇号
    char                szFilePath[MAX_PATH];   // 文件路径
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // 关联的事件列表,事件类型列表,参见智能分析事件类型
    int                 nEventCount;            //事件总数
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志 
    int                 nFalgCount;             //标志总数
    unsigned int        nDriveNo;               // 磁盘号

    //频浓缩文件相关信息
    char szSynopsisPicPath[DH_COMMON_STRING_512];              // 预处理文件提取到的快照	文件路径
                                                               // 支持HTTP URL表示:"http://www.dahuate.com/1.jpg"
                                                               // 支持FTP URL表示: "ftp://ftp.dahuate.com/1.jpg"
                                                               // 支持服务器本地路径 
                                                               // a)"C:/pic/1.jpg" 
                                                               // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int                 nSynopsisMaxTime;                      // 支持浓缩视频最大时间长度,单位 秒
    int                 nSynopsisMinTime;                      // 支持浓缩视频最小时间长度,单位 秒
   
    //文件摘要信息
    int                     nFileSummaryNum;                                // 文件摘要信息数
    NET_FILE_SUMMARY_INFO   stFileSummaryInfo[MAX_FILE_SUMMARY_NUM];        // 文件摘要信息 
	INT64					nFileSizeEx;									// 文件长度扩展,支持文件长度大于4G，单位字节
	UINT					nTotalFrame;									// 查询录像段内所有帧总和，不区分帧类型(定制)
}NET_OUT_MEDIA_QUERY_FILE;

// 安全带状态
typedef enum tagEM_SAFE_BELT_STATE
{
	EM_SAFE_BELT_UNKNOWN,			// 未知
	EM_SAFE_BELT_OTHER,				// 未识别
	EM_SAFE_BELT_WITH,				// 有安全带
	EM_SAFE_BELT_WITHOUT,			// 无安全带
} EM_SAFE_BELT_STATE;

// 车内饰品类型
typedef enum tagEM_ATTACHMENT_TYPE
{
	EM_ATTACHMENT_UNKNOWN,			// 未知
	EM_ATTACHMENT_OTHER,			// 其他类型
	EM_ATTACHMENT_FURNITURE,		// 摆件
	EM_ATTACHMENT_PENDANT,			// 挂件
	EM_ATTACHMENT_TISSUEBOX,		// 纸巾盒
	EM_ATTACHMENT_DANGER,			// 危险品
	EM_ATTACHMENT_PERFUMEBOX,		// 香水
} EM_ATTACHMENT_TYPE;

// 打电话状态
typedef enum tagEM_CALLING_STATE
{
	EM_CALLING_UNKNOWN,				// 未知
	EM_CALLING_OTHER,				// 未识别
	EM_CALLING_NO,					// 未打电话
	EM_CALLING_YES,					// 打电话
} EM_CALLING_STATE;

// 车辆类型
typedef enum tagEM_CATEGORY_TYPE
{
	EM_CATEGORY_UNKNOWN,					// 未知
	EM_CATEGORY_OTHER,						// 其他 
	EM_CATEGORY_MOTOR,						// 机动车
	EM_CATEGORY_BUS,						// 公交车
	EM_CATEGORY_UNLICENSED_MOTOR,			// 无牌机动车
	EM_CATEGORY_LARGE_CAR,					// 大型汽车
	EM_CATEGORY_MICRO_CAR,					// 小型汽车
	EM_CATEGORY_EMBASSY_CAR,				// 使馆汽车
	EM_CATEGORY_MARGINAL_CAR,				// 领馆汽车
	EM_CATEGORY_AREAOUT_CAR,				// 境外汽车
	EM_CATEGORY_FOREIGN_CAR,				// 外籍汽车
	EM_CATEGORY_FARMTRANSMIT_CAR,			// 农用运输车
	EM_CATEGORY_TRACTOR,					// 拖拉机
	EM_CATEGORY_TRAILER,					// 挂车
	EM_CATEGORY_COACH_CAR,					// 教练汽车
	EM_CATEGORY_TRIAL_CAR,					// 试验汽车
	EM_CATEGORY_TEMPORARY_ENTRY_CAR,		// 临时入境汽车
	EM_CATEGORY_TEMPORARY_ENTRY_MOTORCYCLE,	// 临时入境摩托
	EM_CATEGORY_TEMPORARY_STEER_CAR,		// 临时行驶车
	EM_CATEGORY_LARGE_TRUCK,				// 大货车
	EM_CATEGORY_MID_TRUCK,					// 中货车
	EM_CATEGORY_MICRO_TRUCK,				// 小货车
	EM_CATEGORY_MICROBUS,					// 面包车
	EM_CATEGORY_SALOON_CAR,					// 轿车
	EM_CATEGORY_CARRIAGE,					// 小轿车
	EM_CATEGORY_MINI_CARRIAGE,				// 微型轿车
	EM_CATEGORY_SUV_MPV,					// SUV或者MPV
	EM_CATEGORY_SUV,						// SUV
	EM_CATEGORY_MPV,						// MPV
	EM_CATEGORY_PASSENGER_CAR,				// 客车
	EM_CATEGORY_MOTOR_BUS,					// 大客
	EM_CATEGORY_MID_PASSENGER_CAR,			// 中客车
	EM_CATEGORY_MINI_BUS,					// 小客车
	EM_CATEGORY_PICKUP,						// 皮卡车
	EM_CATEGORY_OILTANK_TRUCK,				// 油罐车
	EM_CATEGORY_TANK_CAR,					// 危化品车辆
	EM_CATEGORY_SLOT_TANK_CAR,				// 槽罐车
	EM_CATEGORY_DREGS_CAR,					// 渣土车
	EM_CATEGORY_CONCRETE_MIXER_TRUCK,		// 混凝土搅拌车
	EM_CATEGORY_TAXI,						// 出租车
	EM_CATEGORY_POLICE,						// 警车
	EM_CATEGORY_AMBULANCE,					// 救护车
	EM_CATEGORY_GENERAL,					// 普通车
	EM_CATEGORY_WATERING_CAR,				// 洒水车
	EM_CATEGORY_FIRE_ENGINE,				// 消防车
	EM_CATEGORY_MACHINE_TRUCK,				// 工程车
	EM_CATEGORY_POWER_LOT_VEHICLE,			// 粉粒物料车
	EM_CATEGORY_SUCTION_SEWAGE_TRUCK,		// 吸污车
	EM_CATEGORY_NORMAL_TANK_TRUCK,			// 普通罐车
	EM_CATEGORY_SCHOOL_BUS,					// 校车
	EM_CATEGORY_EXCAVATOR,					// 挖掘车
	EM_CATEGORY_BULLDOZER,					// 推土车
	EM_CATEGORY_CRANE,						// 吊车
	EM_CATEGORY_PIMP_TRUCK,					// 泵车
} EM_CATEGORY_TYPE;

// DH_MEDIA_QUERY_TRAFFICCAR对应的查询条件
typedef struct  
{
    int                 nChannelID;                     // 通道号从0开始,-1表示查询所有通道
    NET_TIME            StartTime;                      // 开始时间    
    NET_TIME            EndTime;                        // 结束时间
    int                 nMediaType;                     // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
    int                 nEventType;                     // 事件类型,详见"智能分析事件类型", 0:表示查询任意事件,此参数废弃,请使用pEventTypes
    char                szPlateNumber[32];              // 车牌号, "\0"则表示查询任意车牌号
    int                 nSpeedUpperLimit;               // 查询的车速范围; 速度上限 单位: km/h
    int                 nSpeedLowerLimit;               // 查询的车速范围; 速度下限 单位: km/h 
    BOOL                bSpeedLimit;                    // 是否按速度查询; TRUE:按速度查询,nSpeedUpperLimit和nSpeedLowerLimit有效。
    DWORD               dwBreakingRule;                 // 违章类型：
                                                        // 当事件类型为 EVENT_IVS_TRAFFICGATE时
                                                        //        第一位:逆行;  第二位:压线行驶; 第三位:超速行驶; 
                                                        //        第四位：欠速行驶; 第五位:闯红灯;
                                                        // 当事件类型为 EVENT_IVS_TRAFFICJUNCTION
                                                        //        第一位:闯红灯;  第二位:不按规定车道行驶;  
                                                        //        第三位:逆行; 第四位：违章掉头;
                                                        //        第五位:压线行驶;

    char                szPlateType[32];                // 车牌类型,"Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
                                                        // "Military" 部队号牌,"DoubleMilitary" 部队双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
                                                        // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
														// "Civilaviation"民航号牌,"Black"黑牌
														// "PureNewEnergyMicroCar"纯电动新能源小车,"MixedNewEnergyMicroCar,"混合新能源小车,"PureNewEnergyLargeCar",纯电动新能源大车
														// "MixedNewEnergyLargeCar"混合新能源大车
    char                szPlateColor[16];               // 车牌颜色, "Blue"蓝色,"Yellow"黄色, "White"白色,"Black"黑色
    char                szVehicleColor[16];             // 车身颜色:"White"白色, "Black"黑色, "Red"红色, "Yellow"黄色, "Gray"灰色, "Blue"蓝色,"Green"绿色
    char                szVehicleSize[16];              // 车辆大小类型:"Light-duty":小型车;"Medium":中型车; "Oversize":大型车; "Unknown": 未知
    int                 nGroupID;                       // 事件组编号(此值>=0时有效)
    short               byLane;                         // 车道号(此值>=0时表示具体车道,-1表示所有车道,即不下发此字段)
    BYTE                byFileFlag;                     // 文件标志, 0xFF-使用nFileFlagEx, 0-表示所有录像, 1-定时文件, 2-手动文件, 3-事件文件, 4-重要文件, 5-合成文件
    BYTE                byRandomAccess;                 // 是否需要在查询过程中随意跳转,0-不需要,1-需要
    int                 nFileFlagEx;                    // 文件标志, 按位表示: bit0-定时文件, bit1-手动文件, bit2-事件文件, bit3-重要文件, bit4-合成文件, bit5-黑名单图片 0xFFFFFFFF-所有录像
    int                 nDirection;                     // 车道方向（车开往的方向）    0-北 1-东北 2-东 3-东南 4-南 5-西南 6-西 7-西北 8-未知 -1-所有方向
    char*               szDirs;                         // 工作目录列表,一次可查询多个目录,为空表示查询所有目录。目录之间以分号分隔,如“/mnt/dvr/sda0;/mnt/dvr/sda1”,szDirs==null 或"" 表示查询所有
    int*                pEventTypes;                    // 待查询的事件类型数组指针,事件类型,详见"智能分析事件类型",若为NULL则认为查询所有事件（缓冲需由用户申请）
    int                 nEventTypeNum;                  // 事件类型数组大小
    char*               pszDeviceAddress;               // 设备地址, NULL表示该字段不起作用
    char*               pszMachineAddress;              // 机器部署地点, NULL表示该字段不起作用
    char*               pszVehicleSign;                 // 车辆标识, 例如 "Unknown"-未知, "Audi"-奥迪, "Honda"-本田... NULL表示该字段不起作用
	WORD                wVehicleSubBrand;               // 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
    WORD                wVehicleYearModel;              // 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
	EM_SAFE_BELT_STATE	emSafeBeltState;				// 安全带状态
	EM_CALLING_STATE	emCallingState;					// 打电话状态
	EM_ATTACHMENT_TYPE	emAttachMentType;				// 车内饰品类型
	EM_CATEGORY_TYPE	emCarType;						// 车辆类型
	int                 bReserved[12];                  // 保留字段
} MEDIA_QUERY_TRAFFICCAR_PARAM;

// 加油类型
typedef enum tagEM_REFUEL_TYPE
{
        EM_REFUEL_TYPE_UNKNOWN = 0,							// unknown
		EM_REFUEL_TYPE_NINETY_EIGHT,						// "98#"
		EM_REFUEL_TYPE_NINETY_SEVEN,						// "97#"
		EM_REFUEL_TYPE_NINETY_FIVE,							// "95#"
		EM_REFUEL_TYPE_NINETY_THREE,                        // "93#"
		EM_REFUEL_TYPE_NINETY,								// "90#"
		EM_REFUEL_TYPE_TEN,									// "10#"
		EM_REFUEL_TYPE_FIVE,								// "5#"
		EM_REFUEL_TYPE_ZERO,								// "0#"
		EM_REFUEL_TYPE_NEGATIVE_TEN,						// "-10#"
		EM_REFUEL_TYPE_NEGATIVE_TWENTY,						// "-20#"
		EM_REFUEL_TYPE_NEGATIVE_THIRTY_FIVE,				// "-35#"
		EM_REFUEL_TYPE_NEGATIVE_FIFTY,						// "-50#"
}EM_REFUEL_TYPE;

// DH_MEDIA_QUERY_TRAFFICCAR查询出来的media文件信息
typedef struct
{
    unsigned int        ch;                                 // 通道号
    char                szFilePath[128];                    // 文件路径
    unsigned int        size;                               // 文件长度,该字段废弃，请使用sizeEx
    NET_TIME            starttime;                          // 开始时间
    NET_TIME            endtime;                            // 结束时间
    unsigned int        nWorkDirSN;                         // 工作目录编号                                    
    BYTE                nFileType;                          // 文件类型  1:图片 2:视频
    BYTE                bHint;                              // 文件定位索引
    BYTE                bDriveNo;                           // 磁盘号
    BYTE                bReserved2;
    unsigned int        nCluster;                           // 簇号
    BYTE                byPictureType;                      // 图片类型或文件标记, 0-普通, 1-合成, 2-抠图。更多文件标记信息请参考 MEDIAFILE_TRAFFICCAR_INFO_EX 的 emFalgLists 字段
	BYTE                byVideoStream;						// 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流
	BYTE                byPartition;						// 精确定位号
    BYTE                bReserved[1];                       // 保留字段

    //以下是交通车辆信息
    char                szPlateNumber[32];                  // 车牌号码
    char                szPlateType[32];                    // 号牌类型"Unknown" 未知; "Normal" 蓝牌黑牌; "Yellow" 黄牌; "DoubleYellow" 双层黄尾牌
                                                            // "Police" 警牌; "Armed" 武警牌; "Military" 部队号牌; "DoubleMilitary" 部队双层
                                                            // "SAR" 港澳特区号牌; "Trainning" 教练车号牌; "Personal" 个性号牌; "Agri" 农用牌
                                                            // "Embassy" 使馆号牌; "Moto" 摩托车号牌; "Tractor" 拖拉机号牌; "Other" 其他号牌
															// "Civilaviation"民航号牌,"Black"黑牌
															// "PureNewEnergyMicroCar"纯电动新能源小车,"MixedNewEnergyMicroCar,"混合新能源小车,"PureNewEnergyLargeCar",纯电动新能源大车
															// "MixedNewEnergyLargeCar"混合新能源大车
    char                szPlateColor[16];                   // 车牌颜色:"Blue","Yellow", "White","Black"
    char                szVehicleColor[16];                 // 车身颜色:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
    int                 nSpeed;                             // 车速,单位Km/H
    int                 nEventsNum;                         // 关联的事件个数
    int                 nEvents[32];                        // 关联的事件列表,数组值表示相应的事件,详见"智能分析事件类型"        
    DWORD               dwBreakingRule;                     // 具体违章类型掩码,第一位:闯红灯; 第二位:不按规定车道行驶;
                                                            // 第三位:逆行; 第四位：违章掉头;否则默认为:交通路口事件
    char                szVehicleSize[16];                  // 车辆大小类型:"Light-duty":小型车;"Medium":中型车; "Oversize":大型车
    char                szChannelName[DH_CHAN_NAME_LEN];    // 本地或远程的通道名称
    char                szMachineName[DH_MAX_NAME_LEN];     // 本地或远程设备名称

    int                 nSpeedUpperLimit;                   // 速度上限 单位: km/h
    int                 nSpeedLowerLimit;                   // 速度下限 单位: km/h    
    int                 nGroupID;                           // 事件里的组编号
    BYTE                byCountInGroup;                     // 一个事件组内的抓拍张数
    BYTE                byIndexInGroup;                     // 一个事件组内的抓拍序号
    BYTE                byLane;                             // 车道,参见MEDIA_QUERY_TRAFFICCAR_PARAM
    BYTE                bReserved1[21];                     // 保留
    NET_TIME            stSnapTime;                          // 抓拍时间
    int                 nDirection;                         // 车道方向,参见MEDIA_QUERY_TRAFFICCAR_PARAM
    char                szMachineAddress[MAX_PATH];         // 机器部署地点
	INT64               sizeEx;                             // 文件长度扩展，支持文件长度大于4G，单位字节
} MEDIAFILE_TRAFFICCAR_INFO, *LPMEDIAFILE_TRAFFICCAR_INFO;


// DH_MEDIA_QUERY_TRAFFICCAR_EX对应的查询条件
typedef struct tagMEDIA_QUERY_TRAFFICCAR_PARAM_EX
{
    DWORD               dwSize;
    MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;                  // 基本查询参数
} MEDIA_QUERY_TRAFFICCAR_PARAM_EX;

// 车内饰品信息
typedef struct tagNET_ATTACH_MENET_INFO
{
	EM_ATTACHMENT_TYPE	emAttachMentType;					// 车内物品类型
	BYTE                bReserved1[128];                    // 保留字节
} NET_ATTACH_MENET_INFO;

// 是否抽烟
typedef enum tagEM_SMOKING_STATE
{
	EM_SMOKING_UNKNOWN,			// 未知
	EM_SMOKING_NO,				// 未抽烟
	EM_SMOKING_YES,				// 抽烟
}EM_SMOKING_STATE;

// DH_MEDIA_QUERY_TRAFFICCAR_EX查询出来的文件信息
typedef struct tagMEDIAFILE_TRAFFICCAR_INFO_EX
{
    DWORD               dwSize;
    MEDIAFILE_TRAFFICCAR_INFO stuInfo;                          // 基本信息
    char                szDeviceAddr[DH_COMMON_STRING_256];     // 设备地址
    char                szVehicleSign[DH_COMMON_STRING_32];     // 车辆标识, 例如 "Unknown"-未知, "Audi"-奥迪, "Honda"-本田...
    char                szCustomParkNo[DH_COMMON_STRING_64];    // 自定义车位号（停车场用）
    WORD                wVehicleSubBrand;                       // 车辆子品牌，需要通过映射表得到真正的子品牌
    WORD                wVehicleYearModel;                      // 车辆年款，需要通过映射表得到真正的年款
	NET_TIME			stuEleTagInfoUTC;						// 对应电子车牌标签信息中的过车时间(ThroughTime)
	EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX];		// 录像或抓图文件标志 
    int                 nFalgCount;								// 标志总数
    EM_SAFE_BELT_STATE	emSafeBelSate;							// 安全带状态
    EM_CALLING_STATE	emCallingState;							// 打电话状态
    int					nAttachMentNum;							// 车内物品个数
	NET_ATTACH_MENET_INFO stuAttachMent[MAX_ATTACHMENT_NUM];	// 车内物品信息
	char				szCountry[DH_COMMON_STRING_32];			// 车牌所属国家和地区
	EM_CATEGORY_TYPE	emCarType;								// 车辆类型
	NET_SUNSHADE_STATE	emSunShadeState;						// 遮阳板状态
	EM_SMOKING_STATE	emSmokingState;							// 是否抽烟
	int					nAnnualInspection;						// 年检标个数
} MEDIAFILE_TRAFFICCAR_INFO_EX;

// FINDNEXT查询输入参数
typedef struct __NET_FINDNEXT_RESERVED
{
    DWORD               dwSize;                         // 结构体大小
    
    unsigned int        nBeginNumber;                   // 查询起始序号,表示从beginNumber条记录开始查 0<=beginNumber<= totalCount-1
}NET_FINDNEXT_RESERVED;

// 查询跳转条件
typedef struct __NET_FINDING_JUMP_OPTION_INFO
{
    DWORD           dwSize;
    int             nOffset;                            // 查询结果偏移量, 是相对于当前查询的第一条查询结果的位置偏移
}NET_FINDING_JUMP_OPTION_INFO;

// DH_FILE_QUERY_FACE对应的人脸识别服务查询参数
typedef struct __MEDIAFILE_FACERECOGNITION_PARAM
{
    DWORD               dwSize;                         // 结构体大小

    // 查询过滤条件
    NET_TIME            stStartTime;                    // 开始时间
    NET_TIME            stEndTime;                      // 结束时间
    char                szMachineAddress[MAX_PATH];     // 地点,支持模糊匹配     
    int                 nAlarmType;                     // 待查询报警类型,详见 EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // 人员信息是否有效
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // 人员信息
    int                 nChannelId;                     // 通道号  
    int                 nGroupIdNum;                    // 人员组数   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // 人员组ID 
	BOOL                abPersonInfoEx;                 // 人员信息扩展是否有效
	FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;		// 人员信息扩展

	BOOL				bSimilaryRangeEnable;			//相似度是否有效
	int					nSimilaryRange[2];				//相似度范围
}MEDIAFILE_FACERECOGNITION_PARAM;

typedef struct  tagDH_PIC_INFO_EX
{
    DWORD                dwSize;                        // 结构体大小
    DWORD                dwFileLenth;                   // 文件大小, 单位:字节
    char                 szFilePath[MAX_PATH];          // 文件路径          
}DH_PIC_INFO_EX;

typedef struct  tagNET_PIC_INFO
{
    DWORD                dwFileLenth;                   // 文件大小, 单位:字节
    char                 szFilePath[MAX_PATH];          // 文件路径
	BYTE                 bReserved[256];                // 保留字段
}NET_PIC_INFO;

typedef struct __NET_CANDIDAT_PIC_PATHS
{
    DWORD                dwSize;                        // 结构体大小
    int                  nFileCount;                    // 实际文件个数
    DH_PIC_INFO_EX       stFiles[DH_MAX_PERSON_IMAGE_NUM];//文件信息
}NET_CANDIDAT_PIC_PATHS;

typedef struct tagNET_CANDIDAT_PIC_PATHS_EX
{
    int                  nFileCount;                      // 实际文件个数
    NET_PIC_INFO	     stFiles[DH_MAX_PERSON_IMAGE_NUM];// 文件信息
	BYTE                 bReserved[256];				  // 保留字段
}NET_CANDIDAT_PIC_PATHS_EX;

// 物体截图信息
typedef struct tagIMAGE_INFO
{
	int					nLength;			// 图片大小,单位:字节
	int					nWidth;				// 图片宽度
	int					nHeight;			// 图片高度
	char				szFilePath[260];	// 文件路径
	BYTE				byReserved[512];	// 预留字节
}IMAGE_INFO;

// 目标人脸信息
typedef struct tagFACE_INFO_OBJECT
{
	IMAGE_INFO							   stuImageInfo;			// 物体截图信息
	EM_DEV_EVENT_FACEDETECT_SEX_TYPE       emSex;                   // 性别类型
	unsigned int                           nAge;                    // 年龄
	EM_FACEDETECT_GLASSES_TYPE             emGlasses;               // 是否戴眼镜
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE   emEmotion;               // 人脸表情
	EM_COMPLEXION_TYPE				       emComplexion;			// 肤色
	EM_EYE_STATE_TYPE			           emEye;					// 眼睛状态
	EM_MOUTH_STATE_TYPE			           emMouth;					// 嘴巴状态
	EM_MASK_STATE_TYPE			           emMask;				    // 是否带口罩
	EM_BEARD_STATE_TYPE			           emBeard;				    // 是否有胡子
	int							           nAttractive;				// 魅力值,0表示未识别,识别时范围1-100,得分高魅力高
	NET_EULER_ANGLE				   		   stuFaceCaptureAngle;		// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
																	// 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
	UINT								   nFaceQuality;			// 人脸抓拍质量分数
	BYTE                                   byReserved[2032];			// 保留字段
}FACE_INFO_OBJECT;

// DH_FILE_QUERY_FACE对应的人脸识别服务FINDNEXT查询返回参数
typedef struct __MEDIAFILE_FACERECOGNITION_INFO
{
    DWORD						dwSize;                                 // 结构体大小
    BOOL						bGlobalScenePic;                        // 全景图是否存在
    DH_PIC_INFO_EX				stGlobalScenePic;                       // 全景图片文件路径
    DH_MSG_OBJECT				stuObject;                              // 目标人脸物体信息
    DH_PIC_INFO_EX				stObjectPic;                            // 目标人脸文件路径
    int							nCandidateNum;                          // 当前人脸匹配到的候选对象数量
    CANDIDATE_INFO				stuCandidates[DH_MAX_CANDIDATE_NUM];    // 当前人脸匹配到的候选对象信息
    NET_CANDIDAT_PIC_PATHS		stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // 当前人脸匹配到的候选对象图片文件路径
    NET_TIME					stTime;                                 // 报警发生时间  
    char						szAddress[MAX_PATH];                    // 报警发生地点
    int							nChannelId;                             // 通道号   
    BOOL						bUseCandidatesEx;						// 是否使用候选对象扩展结构体, 
																		// 若为TRUE, 则表示使用stuCandidatesEx, 且stuCandidates无效, 否则相反
	int							nCandidateExNum;						// 当前人脸匹配到的候选对象(扩展结构体) 数量																
    CANDIDATE_INFOEX			stuCandidatesEx[DH_MAX_CANDIDATE_NUM];	// 当前人脸匹配到的候选对象信息, 实际返回个数同nCandidateNum
	FACE_INFO_OBJECT			stuFaceInfoObject;                      // 目标人脸信息
	NET_POINT                   stuFaceCenter;                          // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
}MEDIAFILE_FACERECOGNITION_INFO;

typedef enum __EM_FACEPIC_TYPE
{
    NET_FACEPIC_TYPE_UNKOWN,            // 未知类型
    NET_FACEPIC_TYPE_GLOBAL_SENCE,      // 人脸全景大图
    NET_FACEPIC_TYPE_SMALL,             // 人脸小图
}EM_FACEPIC_TYPE;

#define  NET_MAX_FRAMESEQUENCE_NUM     2
#define  NET_MAX_TIMESTAMP_NUM         2

typedef struct __MEDIAFILE_FACE_DETECTION_DETAIL_PARAM
{
    DWORD               dwSize;
    DWORD               dwObjectId;                     // 物体ID
    DWORD               dwFrameSequence;                // 帧序号
    NET_TIME_EX         stTime;                         // 发生时间
}MEDIAFILE_FACE_DETECTION_DETAIL_PARAM;
 
// DH_FILE_QUERY_FACE_DETECTION 对应的人脸识别服务查询参数
typedef struct __MEDIAFILE_FACE_DETECTION_PARAM
{
    DWORD               dwSize;                         // 结构体大小
    
    // 查询过滤条件
    int                 nChannelID;                     // 通道号
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
    EM_FACEPIC_TYPE     emPicType;                      // 图片类型,详见 EM_FACEPIC_TYPE
    BOOL                bDetailEnable;                  // 是否有详细信息
    MEDIAFILE_FACE_DETECTION_DETAIL_PARAM stuDetail;    // 参数详细信息
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;             // 性别类型
    BOOL                bAgeEnable;                     // 是否指定年龄段
    int                 nAgeRange[2];                   // 年龄范围
    int                 nEmotionValidNum;               // 人脸特征数组有效个数,与 emFeature 结合使用, 如果为0则表示查询所有表情
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion[DH_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 byFeatureValidNum 结合使用
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;              // 是否戴眼镜
	EM_MASK_STATE_TYPE			emMask;					// 是否带口罩
	EM_BEARD_STATE_TYPE			emBeard;				// 是否有胡子
	int					nIsStranger;					// 0-都查询；1-仅查未开启陌生人模式；2-仅查开启陌生人模式
}MEDIAFILE_FACE_DETECTION_PARAM;

// 人脸检测记录大图信息
typedef struct tagNET_FACEDETECT_IMAGE_INFO
{
    UINT            nLength;                // 文件大小
    char            szFilePath[260];        // 文件路径
    BYTE            byReserved[128];        // 保留字段
} NET_FACEDETECT_IMAGE_INFO;

// DH_FILE_QUERY_FACE_DETECTION对应的人脸识别服务FINDNEXT查询返回参数
typedef struct __MEDIAFILE_FACE_DETECTION_INFO
{
    DWORD               dwSize;                                     // 结构体大小

    unsigned int        ch;                                         // 通道号
    char                szFilePath[128];                            // 文件路径
    unsigned int        size;                                       // 文件长度,该字段废弃，请使用sizeEx
    NET_TIME            starttime;                                  // 开始时间
    NET_TIME            endtime;                                    // 结束时间
    unsigned int        nWorkDirSN;                                 // 工作目录编号                                    
    BYTE                nFileType;                                  // 文件类型  1：jpg图片
    BYTE                bHint;                                      // 文件定位索引
    BYTE                bDriveNo;                                   // 磁盘号
    BYTE                byPictureType;                              // 图片类型, 0-普通, 1-合成, 2-抠图
    unsigned int        nCluster;                                   // 簇号
    
    EM_FACEPIC_TYPE     emPicType;                                  // 图片类型,详见 EM_FACEPIC_TYPE
    DWORD               dwObjectId;                                 // 物体ID
    DWORD               dwFrameSequence[NET_MAX_FRAMESEQUENCE_NUM]; // 帧序号,数组有2个元素时,第一个表示小图,第二个表示大图
    int                 nFrameSequenceNum;                          // 帧序号个数 
    NET_TIME_EX         stTimes[NET_MAX_TIMESTAMP_NUM];             // 发生时间,数组有2个元素时,第一个表示小图,第二个表示大图
    int                 nTimeStampNum;
    int                 nPicIndex;                                  // 表示在簇中的图片序号
                                                                    // 对于同一个簇中打包多张图片,提供索引方式定位图片
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE emSex;                         // 性别类型
    int                 nAge;                                       // 年龄
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;              // 人脸表情
    EM_FACEDETECT_GLASSES_TYPE  emGlasses;                          // 否戴眼镜
    INT64               sizeEx;                                     // 文件长度扩展，支持文件长度大于4G，单位字节
    EM_MASK_STATE_TYPE          emMask;                             // 是否带口罩
    EM_BEARD_STATE_TYPE         emBeard;                            // 是否有胡子
    EM_RACE_TYPE                emRace;                             // 种族
    EM_EYE_STATE_TYPE           emEye;                              // 眼睛状态
    EM_MOUTH_STATE_TYPE         emMouth;                            // 嘴巴状态
    int                         nAttractive;                        // 魅力值
    int                         nIsStranger;                        // 0-未知；1-未开启陌生人模式；2-开启了陌生人模式
    char                        szFaceObjectUrl[128];               // 当 emPicType 为 NET_FACEPIC_TYPE_GLOBAL_SENCE 时, 代表人脸小图路径
    NET_EULER_ANGLE             stuFaceCaptureAngle;                // 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
                                                                    // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
    UINT                        nFaceQuality;                       // 人脸抓拍质量分数
    NET_FACEDETECT_IMAGE_INFO   stuSceneImage;                      // 大图信息
    NET_POINT                   stuFaceCenter;                      // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
}MEDIAFILE_FACE_DETECTION_INFO;

// 区域检测事件动作
typedef enum tagNET_CROSSREGION_ACTION_INFO
{
    EM_CROSSREGION_ACTION_UNKNOW = 0    , 
    EM_CROSSREGION_ACTION_INSIDE        ,   //在区域内
    EM_CROSSREGION_ACTION_CROSS         ,   //穿越区域
    EM_CROSSREGION_ACTION_APPEAR        ,   //出现
    EM_CROSSREGION_ACTION_DISAPPEAR     ,   //消失
}NET_CROSSREGION_ACTION_INFO;

// 查询智能事件信息的对象类型
typedef enum tagEM_MEDIAFILE_IVS_OBJECT
{
	EM_MEDIAFILE_IVS_UNKNOWN,		// unknown
	EM_MEDIAFILE_IVS_OTHER,			// other
	EM_MEDIAFILE_IVS_HUMAN,			// human
	EM_MEDIAFILE_IVS_VEHICLE,		// vehicle
	EM_MEDIAFILE_IVS_NONMOTOR,		// nonmotor
} EM_MEDIAFILE_IVS_OBJECT;

// DH_FILE_QUERY_IVS_EVENT 对应的智能事件查询参数
typedef struct __MEDIAFILE_IVS_EVENT_PARAM
{
    DWORD               dwSize;                         // 结构体大小
    // 查询过滤条件
    int                 nChannelID;                     // 通道号
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
    int                 nMediaType;                     // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件

    int                 nVideoStream;                    // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // 事件类型列表,参见智能分析事件类型
    int                 nEventCount;                     // 事件总数
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 nFalgCount;                      // 标志总数
    
    int                 nRuleType;                      // 智能分析事件名, 事件类型,详见"智能分析事件类型"
    NET_CROSSREGION_ACTION_INFO emAction;               // 事件动作
    int					nIvsObjectNum;					// 对象类型个数
    EM_MEDIAFILE_IVS_OBJECT		emIvsObject[DH_MAX_OBJECT_LIST];	// 规则触发的对象类型
}MEDIAFILE_IVS_EVENT_PARAM;

// 事件抠图信息
typedef struct tagNET_EVENT_IMAGE_INFO
{
	int			nImageLength;							// 图片长度
	char		szImagePath[DH_COMMON_STRING_128];		// 图片路径
	BYTE        bReserved[256];                			// 保留字段
} NET_EVENT_IMAGE_INFO;

// DH_FILE_QUERY_IVS_EVENT 查询出来的media文件信息 
typedef struct __MEDIAFILE_IVS_EVENT_INFO
{
    DWORD               dwSize;                          // 结构体大小
    int                 nChannelID;                      // 通道号
    NET_TIME            stuStartTime;                    // 起始时间
    NET_TIME            stuEndTime;                      // 结束时间
    char                szFilePath[128];                 // 文件路径
    int                 nMediaType;                      // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
    unsigned int        nFileLength;                     // 文件长度,该字段废弃,请使用nFileLengthEx
    unsigned int        nCluster;                        // 簇号
    unsigned int        nHint;                           // 文件定位索引
    unsigned int        nDriveNo;                        // 磁盘号       

    int                 nVideoStream;                    // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // 事件类型列表,参见智能分析事件类型
    int                 nEventCount;                     // 事件总数
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 nFalgCount;                      // 标志总数

    int                 nRuleType;                       // 智能分析事件名, 事件类型,详见"智能分析事件类型"
    NET_CROSSREGION_ACTION_INFO emAction;                // 事件动作
	INT64               nFileLengthEx;                   // 文件长度扩展，支持文件长度大于4G，单位字节
	EM_MEDIAFILE_IVS_OBJECT	emIvsObject;				 // 规则触发的对象类型
	NET_EVENT_IMAGE_INFO	stuEventImageInfo;			 // 事件抠图信息
	NET_POINT           stuObjCenter;                    // 物体型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
}MEDIAFILE_IVS_EVENT_INFO;

// 视频分析支持的对象类型
typedef enum tagEM_ANALYSE_OBJECT_TYPE
{
    EM_ANALYSE_OBJECT_TYPE_UNKNOWN,           // 未知的
    EM_ANALYSE_OBJECT_TYPE_HUMAN,             // 人       
    EM_ANALYSE_OBJECT_TYPE_VEHICLE,           // 车辆
    EM_ANALYSE_OBJECT_TYPE_FIRE,              // 火
    EM_ANALYSE_OBJECT_TYPE_SMOKE,             // 烟雾
    EM_ANALYSE_OBJECT_TYPE_PLATE,             // 片状物体             
    EM_ANALYSE_OBJECT_TYPE_HUMANFACE,         // 人脸
    EM_ANALYSE_OBJECT_TYPE_CONTAINER,         // 货柜
    EM_ANALYSE_OBJECT_TYPE_ANIMAL,            // 动物
    EM_ANALYSE_OBJECT_TYPE_TRAFFICLIGHT,      // 红绿灯
    EM_ANALYSE_OBJECT_TYPE_PASTEPAPER,        // 贴纸 贴片
    EM_ANALYSE_OBJECT_TYPE_HUMANHEAD,         // 人的头部
    EM_ANALYSE_OBJECT_TYPE_ENTITY,            // 普通物体
}EM_ANALYSE_OBJECT_TYPE;

// DH_FILE_QUERY_ANALYSE_OBJECT 对应的智能分析其他物体参数
typedef struct __MEDIAFILE_ANALYSE_OBJECT_PARAM
{
    DWORD               dwSize;                         // 结构体大小
    // 查询过滤条件
    int                 nChannelID;                     // 通道号
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
    int                 nMediaType;                     // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件    
    int                 nVideoStream;                   // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3 
    int                 nEventLists[MAX_IVS_EVENT_NUM]; // 事件类型列表,参见智能分析事件类型
    int                 nEventCount;                    // 事件总数
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 nFalgCount;                     // 标志总数

    EM_ANALYSE_OBJECT_TYPE emObject;                    // 查找的物体类型
}MEDIAFILE_ANALYSE_OBJECT_PARAM;

// DH_FILE_QUERY_ANALYSE_OBJECT 查询出来的media文件信息 
typedef struct __MEDIAFILE_ANALYSE_OBJECT_INFO
{
    DWORD               dwSize;                          // 结构体大小
    int                 nChannelID;                      // 通道号
    NET_TIME            stuStartTime;                    // 起始时间
    NET_TIME            stuEndTime;                      // 结束时间
    char                szFilePath[128];                 // 文件路径
    int                 nMediaType;                      // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
    unsigned int        nFileLength;                     // 文件长度，该字段废弃，使用nFileLengthEx
    unsigned int        nCluster;                        // 簇号
    unsigned int        nHint;                           // 文件定位索引
    unsigned int        nDriveNo;                        // 磁盘号 

    int                 nVideoStream;                    // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3 
    int                 nEventLists[MAX_IVS_EVENT_NUM];  // 事件类型列表,参见智能分析事件类型
    int                 nEventCount;                     // 事件总数
    EM_RECORD_SNAP_FLAG_TYPE emFalgLists[FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 nFalgCount;                      // 标志总数

    EM_ANALYSE_OBJECT_TYPE emObject;                     // 查找的物体类型
	INT64               nFileLengthEx;                   // 文件长度扩展，支持文件长度大于4G，单位字节
}MEDIAFILE_ANALYSE_OBJECT_INFO;

// DH_FILE_QUERY_MPT_RECORD_FILE 对应的录像文件查询参数
typedef struct __MEDIAFILE_MPT_RECORD_FILE_PARAM
{
    DWORD               dwSize;                                 // 结构体大小
    // 查询过滤条件
    int                 nChannelID;                             // 通道号
    NET_TIME            stuStartTime;                           // 起始时间
    NET_TIME            stuEndTime;                             // 结束时间
    int                 nMediaType;                             // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
    int                 nVideoStream;                           // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3

    char                szPoliceID[DH_COMMON_STRING_32];        // 警员ID,为空时表示该字段无效
    int                 nCrimeType;                             // 犯罪类型,值为0表示该字段无效
    int                 nCrimeTag;                              // 犯罪标记,值为0表示该字段无效
    char                szSerialNumber[DH_COMMON_STRING_32];    // MPT设备序列号,为空时表示该字段无效    
}MEDIAFILE_MPT_RECORD_FILE_PARAM;

// DH_FILE_QUERY_MPT_RECORD_FILE 查询出来的media文件信息 
typedef struct __MEDIAFILE_MPT_RECORD_FILE_INFO
{
    DWORD               dwSize;                          // 结构体大小
    int                 nChannelID;                      // 通道号
    NET_TIME            stuStartTime;                    // 起始时间
    NET_TIME            stuEndTime;                      // 结束时间
    char                szFilePath[DH_COMMON_STRING_128];// 文件路径
    int                 nMediaType;                      // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
    int                 nVideoStream;                    // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3
    unsigned int        nFileLength;                     // 文件长度,该字段废弃，请使用nFileLengthEx
    unsigned int        nCluster;                        // 簇号
    unsigned int        nHint;                           // 文件定位索引
    unsigned int        nDriveNo;                        // 磁盘号 

    int                 nCrimeType;                      // 犯罪类型
    int                 nCrimeTag;                       // 犯罪标记
    char                szComment[DH_COMMON_STRING_256]; // 用户对文件做的备注
	INT64               nFileLengthEx;                   // 文件长度扩展，支持文件长度大于4G，单位字节
}MEDIAFILE_MPT_RECORD_FILE_INFO;

// 包裹内危险物品信息的查询类型
typedef enum tagNET_EM_INSIDE_TYPE
{
	NET_EM_INSIDE_TYPE_GRADE,			// 危险物品等级
	NET_EM_INSIDE_TYPE_OBJECT,			// 物品类型
}NET_EM_INSIDE_TYPE;

// DH_FILE_QUERY_XRAY_DETECTION 对应的文件查询参数
typedef struct tagMEDIAFILE_XRAY_DETECTION_PARAM
{
	DWORD					dwSize;                                 // 结构体大小
	// 查询过滤条件
	int						nChannelID;                             // 通道号
	NET_TIME				stuStartTime;                           // 起始时间
	NET_TIME				stuEndTime;                             // 结束时间
	
	NET_EM_INSIDE_TYPE		emInsideType;							// 包裹内危险物品信息的查询类型，必填
	int						nDangerGradeNum;						// 包裹的危险等级有效个数 
	EM_DANGER_GRADE_TYPE	emDangerGrade[MAX_DANGER_GRADE_NUM];	// 包裹的危险等级，当emInsideType字段为NET_EM_INSIDE_TYPE_GRADE时有效
	int						nInsideObjTypeNum;						// 包裹中的物品类型有效个数
	EM_INSIDE_OBJECT_TYPE	emInsideObjType[MAX_INSIDE_OBJECT_TYPE_NUM];	// 包裹中的物品类型，当emInsideType字段为NET_EM_INSIDE_TYPE_OBJECT时有效
}MEDIAFILE_XRAY_DETECTION_PARAM;

// DH_FILE_QUERY_XRAY_DETECTION 查询出来的media文件信息 
typedef struct tagMEDIAFILE_XRAY_DETECTION_INFO
{
	DWORD					dwSize;											// 结构体大小
	int						nChannelID;										// 通道号
	NET_TIME				stuStartTime;									// 起始时间
	NET_TIME				stuEndTime;										// 结束时间

	char					szProcessedFilePath[MAX_PATH_LEN];				// 处理后的X光图片文件路径
	char					szOriginalPath[MAX_PATH_LEN];					// X光检包裹原始图片的路径
	unsigned int			nOriginalLength;								// 原始图片的长度，单位字节
	EM_DANGER_GRADE_TYPE	emDangerGrade;									// 包裹的危险等级
	EM_INSIDE_OBJECT_TYPE	emInsideObjectType[MAX_INSIDE_OBJECT_TYPE_NUM];	// 包裹中包含的物品类型
	int						nRetInsideObjectTypeNum;						// 返回的包裹中包含的物品类型个数			
}MEDIAFILE_XRAY_DETECTION_INFO;

#define MAX_CLOTH_NUM		4 // 最大衣裤件数
#define MAX_CLOTHTYPE_NUM	2 // 最大衣裤类型数量

// DH_FILE_QUERY_HUMAN_TRAIT人体检测对应查询参数
typedef struct tagMEDIAFILE_HUMAN_TRAIT_PARAM
{
    DWORD               dwSize;                 				// 结构体大小 
    int                 nChannel;               				// 通道
    NET_TIME            stStartTime;            				// 开始时间
    NET_TIME            stEndTime;              				// 结束时间

    EM_CLOTHES_COLOR    emCoatColor[MAX_CLOTH_NUM];         	// 上衣颜色
    EM_CLOTHES_COLOR    emTrousersColor[MAX_CLOTH_NUM];     	// 裤子颜色
    EM_COAT_TYPE        emCoatType[MAX_CLOTHTYPE_NUM];          // 上衣类型
    EM_TROUSERS_TYPE	emTrousersType[MAX_CLOTHTYPE_NUM];      // 裤子类型
    UINT                nCoatColorNum;         					// 需要查询的上衣颜色个数
    UINT                nTrousersColorNum;     					// 需要查询的裤子颜色个数
    UINT                nCoatTypeNum;          					// 需要查询的上衣类型个数
    UINT                nTrousersTypeNum;      					// 需要查询的裤子类型个数
    EM_HAS_HAT          emHasHat;               				// 是否戴帽子
    EM_HAS_BAG          emHasBag;               				// 是否带包
    EM_SEX_TYPE			emSex;									// 性别
    EM_HAIR_STYLE		emHairStyle;							// 头发样式
    UINT				nAgeMin;								// 查询年龄段的最小年龄
    UINT				nAgeMax;								// 查询年龄段的最大年龄
}MEDIAFILE_HUMAN_TRAIT_PARAM;

// 查询到的人体检测相关信息
typedef struct tagHUMAN_TRAIT_INFO
{
    EM_CLOTHES_COLOR    emCoatColor;            // 上衣颜色
    EM_CLOTHES_COLOR    emTrousersColor;        // 裤子颜色
    EM_COAT_TYPE        emCoatType;             // 上衣类型
    EM_TROUSERS_TYPE    emTrousersType;         // 裤子类型
    EM_HAS_HAT          emHasHat;               // 是否戴帽子
    EM_HAS_BAG          emHasBag;               // 是否带包
    EM_SEX_TYPE			emSex;					// 性别
    UINT				nAge;					// 年龄
    EM_HAIR_STYLE		emHairStyle;			// 头发样式
    EM_HAS_UMBRELLA		emHasUmbrella;			// 是否打伞
    EM_BAG_TYPE			emBagType;				// 包类型
    EM_CAP_TYPE			emCapType;				// 帽子类型
    BYTE                byReserved[1024];       // 保留字段
}HUMAN_TRAIT_INFO;

// 查询到的人脸属性信息
typedef struct tagNET_HUMAN_FACE_ATTRIBUTE
{
    EM_SEX_TYPE			emSex;					// 性别
    int					nAge;					// 年龄
    EM_MASK_STATE_TYPE 	emMask;					// 口罩状态
    EM_BEARD_STATE_TYPE	emBeard;				// 胡子状态
    EM_HAS_GLASS		emHasGlass;				// 是否戴眼镜
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE emEmotion;	 // 表情
    BYTE                byReserved[1024];       // 保留字段
} NET_HUMAN_FACE_ATTRIBUTE;

// DH_FILE_QUERY_HUMAN_TRAIT人体检测对应FINDNEXT查询返回参数
typedef struct tagMEDIAFILE_HUMAN_TRAIT_INFO
{  
    DWORD               dwSize;                 // 结构体大小

    // 文件属性
    int                 nChannel;               // 通道
    NET_TIME            stStartTime;            // 开始时间
    NET_TIME            stEndTime;              // 结束时间
    char                szFilePath[MAX_PATH];   // 文件路径
    int                 nFileSize;              // 文件大小

    char				szFacePath[MAX_PATH];		// 人脸小图路径
    char				szFaceScenePath[MAX_PATH];	// 人脸小图对应的全景图路径
    char				szHumanPath[MAX_PATH];		// 人体小图路径
    char				szHumanSceneImage[MAX_PATH];// 人体小图对应的全景图路径

    UINT				nFaceImageLength;			// 人脸小图大小, 单位: 字节
    UINT				nFaceSceneImageLength;		// 人脸小图对应的全景图大小, 单位: 字节
    UINT				nHumanImageLength;			// 人体小图大小, 单位: 字节
    UINT				nHumanSceneImageLength;		// 人体小图对应的全景图大小, 单位: 字节

    // 人体信息
    HUMAN_TRAIT_INFO    stuHumanTrait;          // 人体检测信息

    // 人脸属性信息
    NET_HUMAN_FACE_ATTRIBUTE stuFaceAttribute;	// 人脸属性信息

    NET_POINT           stuFaceCenter;              // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
    NET_POINT           stuHumanCenter;             // 人体型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
}MEDIAFILE_HUMAN_TRAIT_INFO;

// 非机动车颜色类型
typedef enum tagEM_NONMOTOR_COLOR
{
	EM_NONMOTOR_UNKNOWN,						// 未知
	EM_NONMOTOR_COLOR_OTHER,					// 无法识别
	EM_NONMOTOR_COLOR_WHITE,					// 白色
	EM_NONMOTOR_COLOR_ORANGE,					// 橙色
	EM_NONMOTOR_COLOR_PINK,						// 粉色
	EM_NONMOTOR_COLOR_BLACK,					// 黑色
	EM_NONMOTOR_COLOR_RED,						// 红色
	EM_NONMOTOR_COLOR_YELLOW,					// 黄色
	EM_NONMOTOR_COLOR_GRAY,						// 灰色
	EM_NONMOTOR_COLOR_BLUE,						// 蓝色
	EM_NONMOTOR_COLOR_GREEN,					// 绿色
	EM_NONMOTOR_COLOR_PURPLE,					// 紫色
	EM_NONMOTOR_COLOR_BROWN,					// 棕色
	EM_NONMOTOR_COLOR_SLIVER,					// 银色
	EM_NONMOTOR_COLOR_DARKVIOLET,				// 暗紫罗兰色
	EM_NONMOTOR_COLOR_MAROON,					// 栗色
	EM_NONMOTOR_COLOR_DIMGRAY,					// 暗灰色
	EM_NONMOTOR_COLOR_WHITESMOKE,				// 白烟色
	EM_NONMOTOR_COLOR_DARKORANGE,				// 深橙色
	EM_NONMOTOR_COLOR_MISTYROSE,				// 浅玫瑰色
	EM_NONMOTOR_COLOR_TOMATO,					// 番茄红色
	EM_NONMOTOR_COLOR_OLIVE,					// 橄榄色
	EM_NONMOTOR_COLOR_GOLD,						// 金色
	EM_NONMOTOR_COLOR_DARKOLIVEGREEN,			// 暗橄榄绿色
	EM_NONMOTOR_COLOR_CHARTREUSE,				// 黄绿色
	EM_NONMOTOR_COLOR_GREENYELLOW,				// 绿黄色
	EM_NONMOTOR_COLOR_FORESTGREEN,				// 森林绿
	EM_NONMOTOR_COLOR_SEAGREEN,					// 海洋绿
	EM_NONMOTOR_COLOR_DEEPSKYBLUE,				// 深天蓝
	EM_NONMOTOR_COLOR_CYAN,						// 青色
} EM_NONMOTOR_COLOR;

// 非机动车子类型
typedef enum tagEM_NONMOTOR_SUBTYPE
{
	EM_NONMOTOR_SUBTYPE_UNKNOWN,				// 未知
	EM_NONMOTOR_SUBTYPE_NONMOTOR,				// 非机动车
	EM_NONMOTOR_SUBTYPE_BICYCLE,				// 自行车
	EM_NONMOTOR_SUBTYPE_TRICYCLE,				// 三轮车
	EM_NONMOTOR_SUBTYPE_MOTORCYCLE,				// 摩托车
	EM_NONMOTOR_SUBTYPE_DUALTRIWHEEL,			// (两) 三轮摩托车
	EM_NONMOTOR_SUBTYPE_LIGHT_MOTORCYCLE,		// 轻便摩托车
	EM_NONMOTOR_SUBTYPE_EMBASSY_MOTORCYCLE,		// 使馆摩托车
	EM_NONMOTOR_SUBTYPE_MARGINAL_MOTORCYCLE,	// 领馆摩托车
	EM_NONMOTOR_SUBTYPE_AREAOUT_MOTORCYCLE,		// 境外摩托车
	EM_NONMOTOR_SUBTYPE_FOREIGN_MOTORCYCLE,		// 外籍摩托车
	EM_NONMOTOR_SUBTYPE_TRIAL_MOTORCYCLE,		// 试验摩托车
	EM_NONMOTOR_SUBTYPE_COACH_MOTORCYCLE,		// 教练摩托车
	EM_NONMOTOR_SUBTYPE_PASSERBY,				// 行人
}EM_NONMOTOR_SUBTYPE;

// 头盔状态
typedef enum tagEM_HELMET_STATE
{
	EM_HELMET_UNKNOWN,			// 未知
	EM_HELMET_OTHER,			// 未识别
	EM_HELMET_NO,				// 未戴头盔
	EM_HELMET_YES,				// 戴头盔
} EM_HELMET_STATE;

// DH_FILE_QUERY_NONMOTOR 非机动车对应查询参数
typedef struct tagMEDIAFILE_NONMOTOR_PARAM
{
	DWORD               dwSize;             // 结构体大小 
	int                 nChannel;           // 通道
	NET_TIME            stStartTime;        // 开始时间
	NET_TIME            stEndTime;          // 结束时间
	
	UINT				nNumOfCyclingMin;	// 骑车人数最小值
	UINT				nNumOfCyclingMax;	// 骑车人数最大值
	EM_NONMOTOR_COLOR	emNonmotorColor;	// 非机动车颜色
	EM_NONMOTOR_SUBTYPE	emNonmotorSubtype;	// 非机动车子类型
	EM_HELMET_STATE 	emHelmetState;		// 头盔状态
} MEDIAFILE_NONMOTOR_PARAM;

// DH_FILE_QUERY_NONMOTOR 非机动车对应FINDNEXT查询返回参数
typedef struct tagMEDIAFILE_NONMOTOR_INFO
{
	DWORD               dwSize;             	// 结构体大小
   
	// 文件属性
	int                 nChannel;               // 通道
	NET_TIME            stStartTime;            // 开始时间
	NET_TIME            stEndTime;              // 结束时间
	char                szFilePath[MAX_PATH];   // 文件路径
	int                 nFileSize;              // 文件大小
   
	// 非机动车信息
	UINT				nNumOfCycling;			// 骑车人数
	EM_NONMOTOR_COLOR	emNonmotorColor;		// 非机动车颜色
	EM_NONMOTOR_SUBTYPE	emNonmotorSubtype;		// 非机动车子类型
	EM_HELMET_STATE 	emHelmetState;			// 头盔状态
	NET_POINT           stuFaceCenter;          // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
} MEDIAFILE_NONMOTOR_INFO;

// 人脸图片信息
typedef struct tagNET_FACE_IMAGE_INFO
{
    DWORD       dwOffSet;                               // 图片在二进制数据块中的偏移位置, 单位:字节
    DWORD       dwFileLength;                           // 图片大小, 单位:字节
    DWORD       dwWidth;                                // 图片宽度
    DWORD       dwHeight;                               // 图片高度   
    BOOL        bIsDetected;                            // 图片是否算法检测出来的,检测过的提交识别服务器时,
								                        // 则不需要再时检测定位抠图,TRUE:检测过的,FALSE:没有检测过
	char        szPicFilePath[DH_COMMON_STRING_256];    // 人脸图片文件路径, 与dwOffSet和dwFileLenth互斥
	BYTE        bReserved[512];					        // 预留字节数
} NET_FACE_IMAGE_INFO;

// 查询文件的类型
typedef enum tagEM_FINDFILE_TYPE
{
	EM_FINDFILE_UNKNOWN,		// 未知
	EM_FINDFILE_JPG,			// 泛指图片
	EM_FINDFILE_DAV,			// 泛指视频
	EM_FINDFILE_LOG,			// log信息
	EM_FINDFILE_GPS,			// gps信息
} EM_FINDFILE_TYPE;

// 开门方式
typedef enum tagEM_OPEN_DOOR_METHOD
{
	EM_OPEN_DOOR_METHOD_UNKNOWN		= -1,		// 未知
	EM_OPEN_DOOR_METHOD_OTHER,					// 其他方式
	EM_OPEN_DOOR_METHOD_FACE,					// 人脸
} EM_OPEN_DOOR_METHOD;

// 开门结果
typedef enum tagEM_OPEN_DOOR_STATE
{
	EM_OPEN_DOOR_STATE_UNKNOWN		= -1,		// 未知
	EM_OPEN_DOOR_STATE_FAIL,					// 失败
	EM_OPEN_DOOR_STATE_SUCCESS,					// 成功
} EM_OPEN_DOOR_STATE;

// DH_FILE_QUERY_DOORCONTROL_RECORD 门打开事件对应查询参数
typedef struct tagMEDIAFILE_DOORCONTROL_RECORD_PARAM
{
	DWORD               	dwSize;             	// 结构体大小

	// 文件属性
	int                 	nChannel;               // 通道
	NET_TIME            	stStartTime;            // 开始时间
	NET_TIME            	stEndTime;              // 结束时间
	UINT					nFileTypeNum;			// 文件类型个数, 为0表示查询任意类型
	EM_FINDFILE_TYPE		emFileType[32];			// 文件类型

	// 门打开事件信息
	EM_OPEN_DOOR_METHOD		emOpenDoorMethod;		// 开门方式, EM_OPEN_DOOR_METHOD_UNKNOWN 表示查所有方式
	EM_OPEN_DOOR_STATE		emOpenDoorState;		// 开门结果, EM_OPEN_DOOR_STATE_UNKNOWN 表示查询所有结果
} MEDIAFILE_DOORCONTROL_RECORD_PARAM;


// 表情
typedef enum tagEM_FACE_TRAIT_EMOTION_TYPE
{
	EM_FACE_TRAIT_EMOTION_UNKNOWN,					// 未知
	EM_FACE_TRAIT_EMOTION_UNRECOGNIZE,				// 未识别
	EM_FACE_TRAIT_EMOTION_ANGRY,					// 生气
	EM_FACE_TRAIT_EMOTION_SAD,						// 悲伤
	EM_FACE_TRAIT_EMOTION_DISGUST,					// 厌恶
	EM_FACE_TRAIT_EMOTION_FEAR,						// 恐惧
	EM_FACE_TRAIT_EMOTION_SURPRISE,					// 诧异
	EM_FACE_TRAIT_EMOTION_CALM,						// 平静
	EM_FACE_TRAIT_EMOTION_SMILE,					// 微笑
	EM_FACE_TRAIT_EMOTION_LAUGH,					// 大笑
	EM_FACE_TRAIT_EMOTION_HAPPY,					// 高兴
	EM_FACE_TRAIT_EMOTION_CONFUSED,					// 困惑
	EM_FACE_TRAIT_EMOTION_SCREAM,					// 尖叫
}EM_FACE_TRAIT_EMOTION_TYPE;

// 活体
typedef enum tagEM_FACE_TRAIT_ALIVE_TYPE
{
	EM_FACE_TRAIT_ALIVE_UNKNOWN,					// 未知
	EM_FACE_TRAIT_ALIVE_NON,						// 非活体
	EM_FACE_TRAIT_ALIVE,							// 活体		
}EM_FACE_TRAIT_ALIVE_TYPE;

// 人脸属性（定制）
typedef struct tagFACE_TRAIT
{
	EM_SEX_TYPE					emSex;				// 性别
	UINT						nAge;				// 年龄
	EM_HAS_GLASS				emGlass;			// 眼镜
	EM_BEARD_STATE_TYPE			emBeard;			// 胡子
	EM_COMPLEXION_TYPE			emComplexion;		// 肤色
	EM_MASK_STATE_TYPE			emMask;				// 口罩
	EM_FACE_TRAIT_EMOTION_TYPE	emEmotion;			// 表情
	NET_TIME_EX					stuSnapTime;		// 抓拍时间	
	EM_FACE_TRAIT_ALIVE_TYPE	emAlive;			// 活体信息
	BYTE						byReserved[1020];	// 预留字段
}FACE_TRAIT;

// 年龄组
typedef enum tagEM_AGE_GROUP_TYPE
{
	EM_AGE_GROUP_UNKNOWN,							// 未知
	EM_AGE_GROUP_OLD,								// 老人
	EM_AGE_GROUP_ADULT,								// 成年人
	EM_AGE_GROUP_CHILD,								// 小孩
}EM_AGE_GROUP_TYPE;

// 胸前是否有东西
typedef enum tagEM_HAS_HOLD
{
	EM_HAS_HOLD_UNKNOWN,							// 未知
	EM_HAS_HOLD_NO,									// 无东西
	EM_HAS_HOLD_YES,								// 有东西
} EM_HAS_HOLD;

// 上衣类型
typedef enum tagEM_UPPER_TYPE
{
	EM_UPPER_UNKNOWN,								// 未知
	EM_UPPER_LONGCOAT,								// 1-长款大衣
	EM_UPPER_JACKETORJEANS,							// 2-夹克及牛仔服
	EM_UPPER_TSHIRT,								// 3-T恤
	EM_UPPER_SPORTSWEAR,							// 4-运动服
	EM_UPPER_DOWNJACKET,							// 5-羽绒服
	EM_UPPER_SHIRT,									// 6-衬衫
	EM_UPPER_DRESS,									// 7-连衣裙
	EM_UPPER_SUIT,									// 8-西装
}EM_UPPER_TYPE;

// 鞋子类型
typedef enum tagEM_SHOES_TYPE
{
	EM_SHOES_UNKNOWN,								// 未知
	EM_SHOES_LEATHER,								// 皮鞋
	EM_SHOES_BOOTS,									// 靴子
	EM_SHOES_CASUAL,								// 休闲鞋
	EM_SHOES_SANDALS,								// 凉鞋
} EM_SHOES_TYPE;


// 是否戴口罩
typedef enum tagEM_MASK_TYPE
{
	EM_MASK_UNKNOWN,								// 未知
	EM_MASK_NO,										// 无
	EM_MASK_YES,									// 戴
}EM_MASK_TYPE;

// 人体属性（定制）
typedef struct tagBODY_TRAIT
{
	EM_SEX_TYPE				emSex;					// 性别
	EM_AGE_GROUP_TYPE		emAgeGroup;				// 年龄组
	EM_COAT_TYPE			emCoatType;				// 上衣类型
	EM_TROUSERS_TYPE		emTrousersType;			// 裤子类型
	EM_ANGLE_TYPE			emAngle;				// 人体角度
	EM_CLOTHES_PATTERN		emUpperPattern;			// 上衣模式
	EM_UNIFIED_COLOR_TYPE	emTrousersColor;		// 裤子颜色
	EM_HAS_UMBRELLA			emUmbrella;				// 打伞
	EM_UNIFIED_COLOR_TYPE	emUmbrellaColor;		// 雨伞颜色
	EM_HAS_HOLD				emHold;					// 胸前抱东西
	EM_CLOTHES_PATTERN		emTrousersPattern;		// 裤子模式
	EM_HAT_STYLE			emHatType;				// 帽子款式
	EM_UNIFIED_COLOR_TYPE	emHatColor;				// 帽子颜色
	EM_UPPER_TYPE			emUpperType;			// 上衣类型
	EM_UNIFIED_COLOR_TYPE	emCoatColor;			// 上衣颜色
	EM_HAIR_STYLE			emHairStyle;			// 发型
	EM_UNIFIED_COLOR_TYPE	emHairColor;			// 头发颜色
	EM_SHOES_TYPE			emShoesType;			// 鞋子款式
	EM_UNIFIED_COLOR_TYPE	emShoesColor;			// 鞋子颜色
	EM_BAG_TYPE				emBagType;				// 箱包款式
	EM_UNIFIED_COLOR_TYPE	emBagColor;				// 箱包颜色
	EM_MASK_TYPE			emMaskType;				// 口罩
	EM_UNIFIED_COLOR_TYPE	emMaskColor;			// 口罩颜色
	NET_TIME_EX				stuSnapTime;			// 抓图时间
	BYTE					szReserved[1024];		// 预留字段
}BODY_TRAIT;

// 人像检测查询人员属性过滤信息
typedef struct tagFACEBODY_DETECT_RECORDFILTER
{
	int			nAgeRange[2]; 						// 查询年龄区间:[0, 0]表示查询未知，[0, 200]表示查询所有（默认）
	FACE_TRAIT	stuFaceTrait;						// 人脸特征
	BODY_TRAIT	stuBodyTrait;						// 人体特征
	BYTE		byReserved[1024];					// 预留字段
}FACEBODY_DETECT_RECORDFILTER;


// 事件图片偏移信息
typedef struct tagNET_EVENT_IMAGE_OFFSET_INFO
{
	unsigned int       nOffSet;						// 偏移 		
	unsigned int	   nLength;						// 图片大小,单位字节
	unsigned int	   nWidth;						// 图片宽度
	unsigned int	   nHeight;						// 图片高度
	char			   szPath[260];					// 图片路径
	BYTE			   byReserved[252];				// 预留字节
}NET_EVENT_IMAGE_OFFSET_INFO;


// DH_FILE_QUERY_FACEBODY_DETECT 对应查询参数
typedef struct tagMEDIAFILE_FACEBODY_DETECT_PARAM
{
	DWORD               			dwSize;                			// 结构体大小   
    int                 			nFileType;             			// 文件类型,0:查询任意类型,1:查询jpg图片,2:查询dav
    int                 			nChannelID;             		// 通道号从0开始,-1表示查询所有通道    
    UINT               				nVideoStream;          			// 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3  5-所有的辅码流类型
	NET_TIME            			stuBeginTime;           		// 开始时间    
	NET_TIME            			stuEndTime;             		// 结束时间    
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagList[FLAG_TYPE_MAX]; 		// 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 			nFlagCount;            			// 标志总数
    NET_RECORD_CARD_INFO 			stuCardInfo;           			// 卡号录像信息, emFlagList包含卡号录像时有效
    EM_RESULT_ORDER_TYPE 			emResultOrder;         			// 查询结果排序方式
    BOOL							bTime;                  		// 是否按时间查询
	FACEBODY_DETECT_RECORDFILTER	stuFilter;						// 人像检测过滤条件
} MEDIAFILE_FACEBODY_DETECT_PARAM;


// DH_FILE_QUERY_FACEBODY_DETECT 对应 FINDNEXT 查询返回结果
typedef struct tagMEDIAFILE_FACEBODY_DETECT_INFO
{
	DWORD               			dwSize;                			// 结构体大小
    int                 			nChannelID;             		// 通道号从0开始,-1表示查询所有通道
    NET_TIME            			stuBeginTime;           		// 开始时间    
    NET_TIME            			stuEndTime;             		// 结束时间
	UINT                			nFileType;             			// 文件类型 1:jpg图片, 2: dav    
    UINT        					nFileSize;              		// 文件长度       
    UINT                			nVideoStream;          			// 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3 
	UINT                			nPartition;            			// 分区号
    UINT		        			nCluster;               		// 簇号
    char                			szFilePath[MAX_PATH];   		// 文件路径   
    EM_RECORD_SNAP_FLAG_TYPE 		emFlagList[FLAG_TYPE_MAX]; 		// 录像或抓图文件标志 
    int                 			nFlagCount;             		// 标志总数
    UINT		        			nDriveNo;               		// 磁盘号   
	FACE_TRAIT						stuFaceTrait;					// 人脸特征
	BODY_TRAIT						stuBodyTrait;					// 人体特征
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 					// 人脸图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;					// 人体图片信息	
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;					// 全景图片信息
} MEDIAFILE_FACEBODY_DETECT_INFO;


// 人像识别查询人员属性信息过滤信息
typedef struct tagFACEBODY_ANALYSE_RECORDFILTER
{	
	int								nAgeRange[2]; 								// 查询年龄区间:[0, 0]表示查询未知，[0, 200]表示查询所有（默认）
	EM_SEX_TYPE						emSex;										// 性别
	char							szCountry[NET_COUNTRY_LENGTH];				// 国籍,符合ISO3166规范
	BYTE							byReserved1;								// 字节对齐
	char                			szProvince[DH_MAX_PROVINCE_NAME_LEN];       // 省份
	char                			szCity[DH_MAX_CITY_NAME_LEN];               // 城市
	char                			szID[DH_MAX_PERSON_ID_LEN];                 // 人员唯一标示(身份证号码,护照号,军官证，或其他编号)
	EM_CERTIFICATE_TYPE				emCertificateType;							// 证件类型	
	BYTE							byReserved[1028];							// 预留字段
} FACEBODY_ANALYSE_RECORDFILTER;


// DH_FILE_QUERY_FACEBODY_ANALYSE  对应查询参数
typedef struct tagMEDIAFILE_FACEBODY_ANALYSE_PARAM
{
	DWORD               			dwSize;                			// 结构体大小   
    int                 			nFileType;             			// 文件类型,0:查询任意类型,1:查询jpg图片,2:查询dav
    int                 			nChannelID;             		// 通道号从0开始,-1表示查询所有通道    
    UINT               				nVideoStream;          			// 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3  5-所有的辅码流类型
	NET_TIME            			stuBeginTime;           		// 开始时间    
	NET_TIME            			stuEndTime;             		// 结束时间    
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagLists[FLAG_TYPE_MAX]; 	// 录像或抓图文件标志, 不设置标志表示查询所有文件
    int                 			nFlagCount;            			// 标志总数
    NET_RECORD_CARD_INFO 			stuCardInfo;           			// 卡号录像信息, emFlagLists包含卡号录像时有效
    EM_RESULT_ORDER_TYPE 			emResultOrder;         			// 查询结果排序方式
    BOOL							bTime;                  		// 是否按时间查询
	FACEBODY_ANALYSE_RECORDFILTER	stuFilter;						// 人像识别过滤条件
} MEDIAFILE_FACEBODY_ANALYSE_PARAM;

// DH_FILE_QUERY_FACEBODY_ANALYSE 对应 FINDNEXT 查询返回结果
typedef struct tagMEDIAFILE_FACEBODY_ANALYSE_INFO
{
	DWORD               			dwSize;                			// 结构体大小
	int                 			nChannelID;             		// 通道号从0开始,-1表示查询所有通道
	NET_TIME            			stuBeginTime;           		// 开始时间    
	NET_TIME            			stuEndTime;             		// 结束时间
	UINT        					nFileSize;              		// 文件长度
	UINT                			nFileType;             			// 文件类型 1:jpg图片, 2: dav    
	UINT                			nVideoStream;          			// 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流 4-辅码流 
	UINT                			nPartition;            			// 分区号	
	UINT		        			nCluster;               		// 簇号
	char                			szFilePath[MAX_PATH];   		// 文件路径   
	EM_RECORD_SNAP_FLAG_TYPE 		emFlagLists[FLAG_TYPE_MAX]; 	// 录像或抓图文件标志 
	int                 			nFlagCount;             		// 标志总数
	UINT		        			nDriveNo;               		// 磁盘号   
	FACE_TRAIT						stuFaceTrait;					// 人脸特征
	BODY_TRAIT						stuBodyTrait;					// 人体特征
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 					// 人脸图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;					// 人体图片信息	
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;					// 全景图片信息
	CANDIDATE_INFOEX				stuCandidates[DH_MAX_CANDIDATE_NUM];	// 候选人脸列表
	int								nCandidateNum;							// 返回的候选人脸个数
} MEDIAFILE_FACEBODY_ANALYSE_INFO;


// 目标人脸信息
typedef struct tagNET_DOORCONTROL_FACE_OBJECT
{
	NET_RECT            stuBoundingBox;                 // 包围盒
	IMAGE_INFO			stuFaceImageInfo;				// 人脸图片信息
	BYTE				byReserved[512];	            // 预留字节
} NET_DOORCONTROL_FACE_OBJECT;

//  注册库人员信息
typedef struct tagNET_REGISTER_PERSON_INFO
{
	char                		szUID[DH_MAX_PERSON_ID_LEN];                    // 人员唯一标识符,首次由服务端生成,区别于ID字段
                                                                        		// 修改,删除操作时必填
    char						szGroupID[NET_GROUPID_LENGTH];					// 人员所属组ID
	char						szGroupName[NET_GROUPNAME_LENGTH];				// 人员所属组名
	EM_REGISTER_DB_TYPE			emRegisterDbType;								// 注册库类型
	EM_SEX_TYPE                 emSexType;                                      // 性别
	UINT                		nFacePicNum;                                    // 图片张数
	NET_FACE_IMAGE_INFO			stuFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];        // 当前人员对应的图片信息
	EM_PERSON_FEATURE_STATE		emFeatureState;									// 人员建模状态

	char                		szPersonName[DH_MAX_PERSON_NAME_LEN];           // 姓名   
	NET_TIME					stuBirthday;									// 生日
	char						szCountry[NET_COUNTRY_LENGTH];					// 国籍,符合ISO3166规范
	char                		szProvince[DH_MAX_PROVINCE_NAME_LEN];           // 省份
	char                		szCity[DH_MAX_CITY_NAME_LEN];                   // 城市
	char						szHomeAddress[DH_COMMON_STRING_128];			// 注册人员家庭地址
	EM_CERTIFICATE_TYPE			emCertificateType;								// 证件类型
	char                		szID[DH_MAX_PERSON_ID_LEN];                     // 人员身份证号码,工号,或其他编号
	UINT						nImportant;										// 人员重要等级, [1,10]，数值越高越重要
	char						szComment[NET_COMMENT_LENGTH];					// 备注信息
	BYTE                        byReserved[2048];   								// 保留字节
} NET_REGISTER_PERSON_INFO;

// 门打开事件中候选人信息
typedef struct tagNET_DOORCONTROL_CANDIDATE
{
	UINT						nSimilarity;			// 相似度, [1,100]
	NET_REGISTER_PERSON_INFO	stuPersonInfo;			// 人员信息
	BYTE                        byReserved[1024];   		// 保留字节
} NET_DOORCONTROL_CANDIDATE;

// DH_FILE_QUERY_DOORCONTROL_RECORD 门打开事件对应FINDNEXT查询返回参数
typedef struct tagMEDIAFILE_DOORCONTROL_RECORD_INFO
{
	DWORD               		dwSize;             					// 结构体大小
   
	// 文件属性
	int                 		nChannel;               				// 通道
	UINT        				nDriveNo;               				// 磁盘号
	UINT        				nCluster;               				// 簇号
	UINT						nHint;									// 精确定位号
	char                		szFilePath[MAX_PATH];   				// 文件路径
	int                 		nFileSize;              				// 文件大小
   
	// 门打开事件信息
	EM_OPEN_DOOR_METHOD			emOpenDoorMethod;						// 开门方式
	EM_OPEN_DOOR_STATE			emOpenDoorState;						// 开门结果
	IMAGE_INFO					stuSceneImageInfo;						// 全景大图信息
	NET_TIME					stuSnapTime;							// 抓拍时间
	NET_DOORCONTROL_FACE_OBJECT	stuFaceObject;							// 目标人脸信息
	UINT						nCandidatesNum;							// 候选人数量
	NET_DOORCONTROL_CANDIDATE	stuCandidates[DH_MAX_CANDIDATE_NUM]; 	// 候选人信息
} MEDIAFILE_DOORCONTROL_RECORD_INFO;

// 视频浓缩相关文件查询参数
typedef struct __MEDIA_QUERY_VIDEOSYNOPSIS_PARAM
{
    DWORD               dwSize;
    NET_TIME            StartTime;                          // 开始时间    
    NET_TIME            EndTime;                            // 结束时间
    int                 nMediaType;                         // 文件类型,0:查询任意类型,1:图片,2:录像
    int                 nQueryType;                         // 查询类型,1:原始视频文件 2:浓缩后的视频文件
}MEDIA_QUERY_VIDEOSYNOPSIS_PARAM;

typedef struct __MEDIAFILE_VIDEOSYNOPSIS_INFO
{
    char                szFilePath[128];                    // 文件路径
    unsigned int        size;                               // 文件长度
    NET_TIME            starttime;                          // 开始时间
    NET_TIME            endtime;                            // 结束时间
    unsigned int        nWorkDirSN;                         // 工作目录编号                                    
    BYTE                nFileType;                          // 文件类型  1：jpg图片
    BYTE                bHint;                              // 文件定位索引
    BYTE                bDriveNo;                           // 磁盘号
    BYTE                bReserved2;
    unsigned int        nCluster;                           // 簇号
    BYTE                byPictureType;                      // 图片类型, 0-普通, 1-合成, 2-抠图
    BYTE                bReserved[3];                       // 保留字段

    // 视频源文件相关信息
    int                 nTaskID;                            // 任务ID
    char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // 视频浓缩状态
    int                 nProgress;                          // 对应浓缩状态
    int                 nObjectNum;                         // 浓缩得到的物体个数

    // 浓缩后的视频文件相关信息
    int                 nDurationTime;                      // 持续时间,单位s
}MEDIAFILE_VIDEOSYNOPSIS_INFO;


// 结构体(NET_IN_SNAPSHOT)成员 闪关灯调节控制     是一个数组,每个元素对应一个闪光灯配置
typedef struct __NET_FLASHCONTROL
{
    DWORD               dwSize;                             // 此结构体大小
    int                 nMode;                              // 工作模式    0-禁止闪光,1-始终闪光,2-自动闪光
}NET_FLASHCONTROL;

// 抓拍客户端类型
typedef enum tagSNAP_CLIENT_TYPE
{
    SNAP_CLIENT_TYPE_COMMON,                // 对应"Common"类型, 默认类型
    SNAP_CLIENT_TYPE_PARKINGSPACE,          // 对应"ParkingSpace"类型, 停车场
}SNAP_CLIENT_TYPE;

#define DH_MAX_USER_DEFINE_INFO        1024

// nTriggerType==2时 客户端触发抓拍参数
typedef struct _NET_CLIENT_SNAP_INFO
{
    DWORD               dwSize;                                         // 此结构体大小
    unsigned int        nFrameSequence;                                 // 帧序号
    double              PTS;                                            // 时间戳,64位毫秒时间戳
    char                szUserDefinedInfo[DH_MAX_USER_DEFINE_INFO];     // 字符串,客户端自定义,"\0"结尾
    SNAP_CLIENT_TYPE    emSNAP_CLIENT_TYPE;                             // 客户端类型
    DWORD               dwRetCardNumber;                                // 卡片个数
    EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];             // 卡片信息     
}NET_CLIENT_SNAP_INFO;

// 接口(CLIENT_TrafficSnapByNetwork)输入参数
typedef struct __NET_IN_SNAPSHOT
{
    DWORD                   dwSize;                     // 此结构体大小
    int                     nTriggerType;               // 触发类型    0-未知    1-中盟网络触发 2-客户端触发（此时只需要填写stClientInfo参数）
    int                     nLaneID;                    // 车道号
    int                     nGroupID;                   // 组序号
    int                     nGrabTimes;                 // 抓拍图片数量
    int                     nStartPicNum;               // 第一张图片开始序号
    int                     nDirection;                 // 车道方向（车开往的方向）    0-北 1-东北 2-东 3-东南 4-南 5-西南 6-西 7-西北 8-未知
    //NET_GRAB_WAITTIME     stGrabWaitTime;             // 多张图片之间抓拍间隔
    int                     nGrabWaitTime;              // pGrabWaitTime数组成员个数
    DWORD*                  pGrabWaitTime;              // 多张图片之间抓拍间隔,由用户申请内存，大小为nGrabWaitTime
    int                     nLowerSpeedLimit;           // 速度下限,单位km/h
    int                     nUpperSpeedLimit;           // 速度下限,单位km/h
    int                     nSpeed;                     // 车速,单位km/h
    int                     nViolationNo;               // 违法编号    0-未违法
                                                        // 1-黑名单
                                                        // 2-超速不超过50% 
                                                        // 3-超速在50%到100%之间
                                                        // 4-超速超过100%
                                                        // 5-逆行
                                                        // 6-闯红灯
                                                        // 7-低于限速
                                                        // 8-禁行,不按车道行驶
    int                     nRedLightTime;              // 红灯时间,即红灯点亮多少时间后触发抓拍,单位秒
    //NET_FLASHCONTROL      stFlashControl;             // 闪关灯调节控制
    int                     nFlashControl;              // pFlashControl数组个数
    NET_FLASHCONTROL*       pFlashControl;              // 闪关灯调节控制,由用户申请内存，大小为sizeof(NET_FLASHCONTROL)*nFlashControl
    DWORD                   dwUser;                     // 用户数据 NSP
    NET_CLIENT_SNAP_INFO    stClientInfo;               // 客户端触发时传入的抓拍参数
}NET_IN_SNAPSHOT;

// 接口(CLIENT_TrafficSnapByNetwork)输出参数
typedef struct __NET_OUT_SNAPSHOT
{
    DWORD                dwSize;                    // 此结构体大小
}NET_OUT_SNAPSHOT;

// 接口(CLIENT_TrafficForceLightState)输入参数
typedef struct __NET_IN_FORCELIGHTSTATE
{
    DWORD               dwSize;                     // 此结构体大小
    unsigned int        nDirection;                 // 按位表示：0位："Straight",1位："TurnLeft",2位："TurnRight",3位："U-Turn"
}NET_IN_FORCELIGHTSTATE;

// 接口(CLIENT_TrafficForceLightState)输出参数
typedef struct __NET_OUT_FORCELIGHTSTATE
{
    DWORD                dwSize;                    // 此结构体大小
}NET_OUT_FORCELIGHTSTATE;

// 接口(CLIENT_StartTrafficFluxStat)回调
typedef int  (CALLBACK *fFluxStatDataCallBack)(LLONG lFluxStatHandle, DWORD dwEventType, void* pEventInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// 接口(CLIENT_StartTrafficFluxStat)输入参数
typedef struct __NET_IN_TRAFFICFLUXSTAT
{
    DWORD                   dwSize;                 // 此结构体大小
    fFluxStatDataCallBack   cbData;                 // 回调函数指针
    LDWORD                  dwUser;                 // 用户数据
}NET_IN_TRAFFICFLUXSTAT;

// 接口(CLIENT_StartTrafficFluxStat)输出参数
typedef struct __NET_OUT_TRAFFICFLUXSTAT
{
    DWORD                dwSize;                    // 此结构体大小    
}NET_OUT_TRAFFICFLUXSTAT;

// 接口(CLIENT_StartFindFluxStat)输入参数
typedef struct __NET_IN_TRAFFICSTARTFINDSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    NET_TIME            stStartTime;                // 开始时间 暂时精确到小时
    NET_TIME            stEndTime;                  // 结束时间 暂时精确到小时
    int                 nWaittime;                  // 等待接收数据的超时时间
}NET_IN_TRAFFICSTARTFINDSTAT;

// 接口(CLIENT_StartFindFluxStat)输出参数
typedef struct __NET_OUT_TRAFFICSTARTFINDSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    DWORD               dwTotalCount;               // 符合此次查询条件的结果总条数                 
}NET_OUT_TRAFFICSTARTFINDSTAT;

// 接口(CLIENT_DoFindFluxStat)输入参数
typedef struct __NET_IN_TRAFFICDOFINDSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    unsigned int        nCount;                     // 每次查询的流量统计条数
    int                 nWaittime;                  // 等待接收数据的超时时间
}NET_IN_TRAFFICDOFINDSTAT;

typedef struct
{
    DWORD               dwSize;                     // 此结构体大小
    int                 nStatInfo;                  // 统计信息个数
    DH_TRAFFICFLOWSTAT  *pStatInfo;                 // 统计信息指针,由用户申请内存，大小为sizeof(DH_TRAFFICFLOWSTAT)*nStatInfo
}DH_TRAFFICFLOWSTAT_OUT;

// 接口(CLIENT_DoFindFluxStat)输出参数
typedef struct __NET_OUT_TRAFFICDOFINDSTAT
{
    DWORD                   dwSize;                 // 此结构体大小
    DH_TRAFFICFLOWSTAT_OUT  stStatInfo;             // 统计信息指针
}NET_OUT_TRAFFICDOFINDSTAT;

// 规则类型
typedef enum tagEM_RULE_TYPE
{
	EM_RULE_UNKNOWN,			// 未知
	EM_RULE_NUMBER_STAT,		// 人数统计
	EM_RULE_MAN_NUM_DETECTION,	// 区域内人数统计
    EM_RULE_QUEUE_DETECTION,	// 排队检测
} EM_RULE_TYPE;

// 其他规则
typedef enum tagEM_OTHER_RULE_TYPE
{
	EM_OTHER_RULE_TYPE_UNKOWN,				// 未知
	EM_OTHER_RULE_TYPE_AVERAGE_STAYTIME,	// 平均滞留时间	
} EM_OTHER_RULE_TYPE; 

// 接口(CLIENT_StartFindNumberStat)输入参数
typedef struct __NET_IN_FINDNUMBERSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    int                 nChannelID;                 // 要进行查询的通道号
    NET_TIME            stStartTime;                // 开始时间 暂时精确到小时
    NET_TIME            stEndTime;                  // 结束时间 暂时精确到小时
    int                 nGranularityType;           // 查询粒度0:分钟,1:小时,2:日,3:周,4:月,5:季,6:年, 
    												// 7:即时, 8:人员 (7和8只在emRuleType为EM_RULE_MAN_NUM_DETECTION时有效)
    int                 nWaittime;                  // 等待接收数据的超时时间
    UINT                nPlanID;                    // 计划ID,仅球机有效,从1开始
	EM_RULE_TYPE		emRuleType;					// 规则类型
	int					nMinStayTime;				// 区域人数查询最小滞留时间，不填默认为0，返回滞留时长大于等于该时间的人数信息
													// NumberStat时不需要此参数
	int					nAreaIDNum;					// 区域ID个数
	UINT				nAreaID[20];				// 区域ID(一个预置点可以对应多个区域ID)
	EM_OTHER_RULE_TYPE	emOtherRule;				// 其他规则
}NET_IN_FINDNUMBERSTAT;

// 接口(CLIENT_StartFindNumberStat)输出参数
typedef struct __NET_OUT_FINDNUMBERSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    DWORD               dwTotalCount;               // 符合此次查询条件的结果总条数
}NET_OUT_FINDNUMBERSTAT;

// 接口(CLIENT_DoFindNumberStat)输入参数
typedef struct __NET_IN_DOFINDNUMBERSTAT
{
    DWORD               dwSize;                     // 此结构体大小
    unsigned int        nBeginNumber;               // [0, totalCount-1], 查询起始序号,表示从beginNumber条记录开始,取count条记录返回; 
    unsigned int        nCount;                     // 每次查询的流量统计条数
    int                 nWaittime;                  // 等待接收数据的超时时间            
}NET_IN_DOFINDNUMBERSTAT;

typedef struct __DH_NUMBERSTAT
{
    DWORD    		dwSize;
    int      		nChannelID;                         // 统计通道号
    char     		szRuleName[DH_CHAN_NAME_LEN];       // 规则名称
    NET_TIME 		stuStartTime;                       // 开始时间
    NET_TIME 		stuEndTime;                         // 结束时间
    int      		nEnteredSubTotal;                   // 进入人数小计
    int      		nExitedSubtotal;                    // 出去人数小计
    int      		nAvgInside;                         // 平均保有人数(除去零值)
    int      		nMaxInside;                         // 最大保有人数
    int      		nEnteredWithHelmet;                 // 戴安全帽进入人数小计
    int      		nEnteredWithoutHelmet;              // 不戴安全帽进入人数小计
    int      		nExitedWithHelmet;                  // 戴安全帽出去人数小计
    int      		nExitedWithoutHelmet;               // 不戴安全帽出去人数小计
    int				nInsideSubtotal;					// 在区域内人数小计
	UINT            nPlanID;							// 计划ID,仅球机有效,从1开始
	UINT			nAreaID;							// 区域ID(一个预置点可以对应多个区域ID)
	UINT			nAverageStayTime;					// 区域内平均滞留时间
}DH_NUMBERSTAT;

// 接口(CLIENT_DoFindNumberStat)输出参数
typedef struct __NET_OUT_DOFINDNUMBERSTAT
{
    DWORD               dwSize;                          // 此结构体大小
    int                 nCount;                          // 查询返回人数统计信息个数
    DH_NUMBERSTAT       *pstuNumberStat;                 // 返回人数统计信息数组
														 // 由用户申请内存，大小为nBufferLen
    int                 nBufferLen;                      // 用户申请的内存大小,以DH_NUMBERSTAT中的dwsize大小为单位
	int					nMinStayTime;					 // 区域人数查询时指定的最小滞留时间
}NET_OUT_DOFINDNUMBERSTAT;

// 视频统计小计信息
typedef struct tagNET_VIDEOSTAT_SUBTOTAL 
{
    int                 nTotal;                         // 设备运行后人数统计总数
    int                 nHour;                          // 小时内的总人数
    int                 nToday;                         // 当天的总人数, 不可手动清除
    int                 nOSD;                           // 统计人数, 用于OSD显示, 可手动清除
    char                reserved[252];
} NET_VIDEOSTAT_SUBTOTAL;

#define MAX_EXIT_MAN_NUM		32		// 最大支持的离开人员数量

// 离开人员的滞留时间信息
typedef struct tagNET_EXITMAN_STAY_STAT
{
	NET_TIME	stuEnterTime;		// 人员进入区域时间
	NET_TIME	stuExitTime;		// 人员离开区域时间
	BYTE		reserved[128];		// 保留字节
} NET_EXITMAN_STAY_STAT;

// 视频统计摘要信息
typedef struct tagNET_VIDEOSTAT_SUMMARY
{
    int                     nChannelID;                 			// 通道号
    char                    szRuleName[32];             			// 规则名称
    NET_TIME_EX             stuTime;                    			// 统计时间
    NET_VIDEOSTAT_SUBTOTAL  stuEnteredSubtotal;         			// 进入小计
    NET_VIDEOSTAT_SUBTOTAL  stuExitedSubtotal;          			// 出去小计
	UINT					nInsidePeopleNum;						// 区域内人数
	EM_RULE_TYPE			emRuleType;								// 规则类型
	int						nRetExitManNum;							// 离开的人数个数
	NET_EXITMAN_STAY_STAT	stuExitManStayInfo[MAX_EXIT_MAN_NUM];	// 离开人员的滞留时间信息
	UINT					nPlanID;								// 计划ID,仅球机有效,从1开始
	UINT					nAreaID;								// 区域ID(一个预置点可以对应多个区域ID)
    UINT                    nCurrentDayInsidePeopleNum;             // 当天区域内总人数
	BYTE					reserved[1012];							// 保留字节
} NET_VIDEOSTAT_SUMMARY;

// 视频统计摘要信息回调函数原形，lAttachHandle 是 CLIENT_AttachVideoStatSummary 返回值
typedef void (CALLBACK *fVideoStatSumCallBack) (LLONG lAttachHandle, NET_VIDEOSTAT_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachVideoStatSummary 入参
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
    int                     nChannel;                    // 视频通道号         
    fVideoStatSumCallBack   cbVideoStatSum;              // 视频统计摘要信息回调
    LDWORD                  dwUser;                      // 用户数据                   
} NET_IN_ATTACH_VIDEOSTAT_SUM;

// CLIENT_AttachVideoStatSummary 出参
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_SUM
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_VIDEOSTAT_SUM;

// 热度图类型
typedef enum tagEM_HEATMAP_TYPE
{
	EM_HEATMAP_UNKNOWN,									// 未知
	EM_HEATMAP_AVERAGESTAYTIME,							// 平均滞留时间热度图
	EM_HEATMAP_HUMANSTATISTICS,							// 人数统计热度图
	EM_HEATMAP_HUMANTRACK,								// 行人轨迹图
}EM_HEATMAP_TYPE;

// 获取热图数据接口入参
typedef struct tagNET_IN_GET_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;                      // 此结构体大小
	int						nPlanID;					 // 计划（预置点,仅球机有效,范围1~MaxNumberStatPlan）
	NET_TIME				stuStartTime;				 // 开始时间
	NET_TIME				stuEndTime;					 // 结束时间
	EM_HEATMAP_TYPE			emHeatMapType;				 // Ai 热度图类型
}NET_IN_GET_VIDEOSTAT_HEATMAP;

// 获取热图数据接口出参
typedef struct tagNET_OUT_GET_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;                      // 此结构体大小
	UINT					nToken;						 //  查询的Token
}NET_OUT_GET_VIDEOSTAT_HEATMAP;

// 热度图数据信息
typedef struct tagNET_CB_VIDEOSTAT_HEATMAP
{
	UINT					nToken;
	EM_HEATMAP_TYPE			emHeatMapType;				// 热度图类型
	BYTE					byReserved[1024];			// 保留字节
}NET_CB_VIDEOSTAT_HEATMAP;

// 热度图数据回调函数
typedef void (CALLBACK *fVideoStatHeatMapCallBack) (LLONG lAttachHandle, NET_CB_VIDEOSTAT_HEATMAP* pBuf, const char* pBinData, DWORD dwBinDataLen, LDWORD dwUser);

// 订阅热度图信息入参
typedef struct tagNET_IN_ATTACH_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;                      // 此结构体大小
	int                     nChannel;                    // 视频通道号    
	fVideoStatHeatMapCallBack cbVideoStatHeatMap;        // 热图数据回调
	LDWORD                  dwUser;                      // 用户数据                   
} NET_IN_ATTACH_VIDEOSTAT_HEATMAP;

// 订阅热度图信息出参
typedef struct tagNET_OUT_ATTACH_VIDEOSTAT_HEATMAP
{
	DWORD                   dwSize;                      // 此结构体大小
} NET_OUT_ATTACH_VIDEOSTAT_HEATMAP;

// 接口 CLIENT_GetParkingSpaceStatus 的输入参数
typedef struct tagNET_IN_GET_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    DWORD                dwWaitTime;                     // 接口超时等待时间
    int                  nChannelID;                     // 通道号
    int *                pLaneID;                        // 取值范围[0,255], pLaneID==NULL表示所有车位,车位最大数同DH_PRODUCTION_DEFNITION.nMaxRoadWays
    int                  nLaneCount;                     // 申请的内存为sizeof(int)*nLaneCount
} NET_IN_GET_PARKINGSPACE_STATUS;

typedef struct tagNET_LANE_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nLaneID;                        // 车位号
    unsigned int         nPictureId;                     // 图片ID,用于获取图片数据
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;      // 交通车辆信息
} NET_LANE_PARKINGSPACE_STATUS;

// 接口 CLIENT_GetParkingSpaceStatus 的输出参数
typedef struct tagNET_OUT_GET_PARKINGSPACE_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    NET_LANE_PARKINGSPACE_STATUS* pStatus;               // 返回的车位状态,由用户申请内存
    int                  nMaxStatus;                     // 需要事先申请的内存为sizeof(NET_LANE_PARKINGSPACE_STATUS)*nMaxStatus,且nMaxStatus == DH_PRODUCTION_DEFNITION.nMaxRoadWays
    int                  nRetStatus;                     // 实际返回的车位状态数
} NET_OUT_GET_PARKINGSPACE_STATUS;

// 接口 CLIENT_AttachParkingSpaceData 的输入参数
typedef struct tagNET_CB_PARKINGSPACE_DATA
{
    DWORD                dwSize;                         // 此结构体大小
    void*                pPicBuffer;                     // 图片二进制数据,由用户申请内存，大小为sizeof(unsigned int)*nPicLength
    unsigned int         nPicLength;                     // 图片总长度
} NET_CB_PARKINGSPACE_DATA;

// 接口 CLIENT_AttachParkingSpaceData 回调函数,pBuf是json和图片数据,nBufLen是pBuf相应长度,用于转发服务
typedef int (CALLBACK *fNotifySnapData)(LLONG lParkingHandle, NET_CB_PARKINGSPACE_DATA* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// 接口 CLIENT_AttachParkingSpaceData 的输入参数
typedef struct tagNET_IN_ATTACH_PARKINGSPACE
{
    DWORD                dwSize;                         // 此结构体大小
    DWORD                dwWaitTime;                     // 接口超时等待时间
    int                  nChannelID;                     // 通道号
    unsigned int         nPictureId;                     // 图片ID,见NET_LANE_PARKINGSPACE_STATUS.nPictureId
    
    fNotifySnapData      cbNotifySnapData;               // 回调函数
    LDWORD               dwUser;                         // 用户自定义参数
} NET_IN_ATTACH_PARKINGSPACE;

// 指纹信息
typedef struct tagNET_CB_FINGERPRINT_INFO
{
	UINT 		nIndex;                                     // 指纹索引号，从左手小指依次到右手小指为0到9 
	char        szFingerprintData[DH_COMMON_STRING_2048];   // 指纹数据，经过Base64后的字符串              
	BYTE        bReserved[256];                             // 保留字段
}NET_CB_FINGERPRINT_INFO;

// 回调函数中人脸信息
typedef struct tagNET_CB_PERSON_INFO
{
    UINT                 nSID;                           // 服务器订阅ID号
	UINT 	             nPicLength;                     // 采集的人员图片长度
	char                 szUserID[DH_MAX_USERID_LEN];    // 用户ID
	UINT                 nRetFaceDataNum;                // 返回的人脸模版数据个数
    char                 szFaceData[MAX_FACE_DATA_NUM][MAX_FACE_DATA_LEN];  // 人脸数据
    char                 szPassword[DH_COMMON_STRING_64];//卡密码
    char                 szCardNo[DH_MAX_CARDNO_LEN];    // 卡号
    char                 szCardName[DH_COMMON_STRING_32];//卡命名
    UINT                 nFingerPrintNum;                // 返回指纹个数
    NET_CB_FINGERPRINT_INFO stuFingerPrintInfo[MAX_FINGERPRINT_NUM];//指纹信息
	BYTE                 bReserved[2048];                // 保留字段
}NET_CB_PERSON_INFO;

// 人脸信息采集回调函数
typedef int (CALLBACK *fNotifyPersonInfo)(LLONG lLoginID, LLONG lPersonHandle, NET_CB_PERSON_INFO *pstuPersonInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, void *reserved);

// CLIENT_AttachPersonInfoCollect 入参
typedef struct tagNET_IN_ATTACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                         // 结构体大小
	DWORD               dwWaitTime;                     // 接口超时等待时间
	fNotifyPersonInfo   cbNotifyPersonInfo;             // 回调函数
	LDWORD              dwUser;                         // 用户自定义参数
}NET_IN_ATTACH_PERSONINFOCOLLECT;

//CLIENT_AttachPersonInfoCollect 出参
typedef struct tagNET_OUT_ATTACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                         // 结构体大小
}NET_OUT_ATTACH_PERSONINFOCOLLECT;

// CLIENT_DetachPersonInfoColloect 入参
typedef struct tagNET_IN_DETACH_PERSONINFOCOLLECT
{
	DWORD 				dwSize;                        //结构体大小
	DWORD               dwWaitTime;                    // 接口超时等待时间
	LLONG               lPersonHandle;                 // CLIENT_AttachPersonInfoCollect 返回的句柄
}NET_IN_DETACH_PERSONINFOCOLLECT;

//CLIENT_DetachPersonInfoColloect 出参
typedef struct tagNET_OUT_DETACH_PERSONINFOCOLLECT
{
	DWORD               dwSize;                        // 结构体大小
}NET_OUT_DETACH_PERSONINFOCOLLECT;

/******************************************************************************
功能描述	:	订阅人脸信息采集
输入参数	:	
	lLoginID: 登陆接口返回句柄
	pstuInParam:订阅输入参数，带回调函数等信息
输出参数	：pstuOutParam:订阅输出参数
返 回 值	：	LLONG 返回订阅句柄，用于detach操作
其他说明	：
******************************************************************************/
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPersonInfoCollect(LLONG lLoginID, NET_IN_ATTACH_PERSONINFOCOLLECT *pstuInParam, NET_OUT_ATTACH_PERSONINFOCOLLECT *pstuOutParam);

/******************************************************************************
功能描述	:	取消订阅人脸信息采集
输入参数	:	
	lLoginID: 登陆接口返回句柄
	pstuInParam: 取消订阅输入参数，其中lPersonHandle为CLIENT_AttachPersonInfoCollect返回的句柄
输出参数	：pstuOutParam:取消订阅输出参数
返 回 值	：	TRUE 成功FALSE 失败
其他说明	：
******************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPersonInfoColloect(NET_IN_DETACH_PERSONINFOCOLLECT* pstuInParam, NET_OUT_DETACH_PERSONINFOCOLLECT* pstuOutParam);

//NET_CAR_PASS_INFOS 相关枚举类型
typedef enum tagNET_CAR_SIZE
{
    CAR_SIZE_UNKNOWN  = 0 ,     //未知
    CAR_SIZE_SAMLL        ,     //小车
    CAR_SIZE_BIG          ,     //大车
}NET_CAR_SIZE;

typedef enum tagNET_CAR_ACTION
{
    CAR_ACTION_UNKNOWN = 0 , 
    CAR_ACTION_ENTER       ,  //进入检测区域
    CAR_ACTION_LEAVE       ,  //离开检测区域
}NET_CAR_ACTION;


//CLIENT_AttachCarPassInfo 回调函数返回的过车信息结构体
typedef struct tagNET_CAR_PASS_INFO
{
     DWORD                dwSize; 
       
     DWORD                nID;                              // 车辆物体ID
     DWORD                nLaneNumber;                      // 从0开始,比如现有3个车道,则车道号分别为0 1 2
     DWORD                nRoadwayNumber;                   // 自定义车道号,用户配置的车道号,目前取值范围为1-16
     DWORD                nSpeed;                           // 车速,单位(km/h)
     NET_CAR_SIZE         emCarSize;                        // 车辆大小类型
     NET_CAR_ACTION       emCarAction;                      // 车辆动作类型
     NET_TIME_EX          stuTime;                          // 动作发生的时间,精确到毫秒
}NET_CAR_PASS_INFO;

// 接口 CLIENT_AttachCarPassInfo 回调函数
// nInfoNum 过车信息数
// pstuCarPassInfos 过车信息数组
typedef int (CALLBACK *fNotifyCarPassInfo)(LLONG lCarPassHandle, NET_CAR_PASS_INFO* pstuCarPassInfos,  int nInfoNum ,   LDWORD dwUser);

//接口 CLIENT_AttachCarPassInfo 的输入参数
typedef struct tagNET_IN_ATTACH_CAR_PASS_INFO
{
    DWORD                dwSize;                         // 此结构体大小,必须赋值
    int                  nChannelID;                     // 通道号

    fNotifyCarPassInfo   cbNotifyCarPassInfo;            // 回调函数,有过车信息时,回调给上层
    LDWORD               dwUser;                         // 用户自定义参数
}NET_IN_ATTACH_CAR_PASS_INFO;

//接口 CLIENT_AttachCarPassInfo 的输出参数
typedef struct tagNET_OUT_ATTACH_CAR_PASS_INFO
{
    DWORD       dwSize;         //此结构体大小,必须赋值
}NET_OUT_ATTACH_CAR_PASS_INFO;

// 接口 CLIENT_AttachParkingSpaceData 的输出参数
typedef struct tagNET_OUT_ATTACH_PARKINGSPACE
{
    DWORD                dwSize;                         // 此结构体大小
} NET_OUT_ATTACH_PARKINGSPACE;

// 接口 CLIENT_DetachParkingSpaceData 的输入参数
typedef struct tagNET_IN_DETACH_PARKINGSPACE
{
    DWORD                dwSize;                         // 此结构体大小
    DWORD                dwWaitTime;                     // 接口超时等待时间
    LLONG                lParkingHandle;                 // CLIENT_AttachParkingSpaceData返回的句柄
} NET_IN_DETACH_PARKINGSPACE;
// 接口 CLIENT_DetachParkingSpaceData 的输出参数
typedef struct tagNET_OUT_DETACH_PARKINGSPACE
{
    DWORD                dwSize;                         // 此结构体大小
} NET_OUT_DETACH_PARKINGSPACE;

// 获取车位锁状态接口，CLIENT_GetParkingLockState 入参
typedef struct tagNET_IN_GET_PARKINGLOCK_STATE_INFO
{
	DWORD				dwSize;							// 结构体大小
} NET_IN_GET_PARKINGLOCK_STATE_INFO;

// 车位锁状态
typedef enum tagEM_STATE_TYPE
{
	EM_STATE_TYPE_UNKNOW,		// 未知
	EM_STATE_TYPE_LOCKRISE,		// 车位锁升起
	EM_STATE_TYPE_LOCKDOWN,		// 车位锁降下
	EM_STATE_TYPE_LOCKERROR,	// 车位锁异常
} EM_STATE_TYPE;

// 车位锁状态通信接口参数
typedef struct tagNET_STATE_LIST_INFO
{
	unsigned int		 nLane;				// 车位号
	EM_STATE_TYPE		 emState;			// 车位锁状态
	BYTE				 byReserved[256];	// 保留
} NET_STATE_LIST_INFO;

// 获取车位锁状态， CLIENT_GetParkingLockState 出参
typedef struct tagNET_OUT_GET_PARKINGLOCK_STATE_INFO
{
	DWORD					dwSize;										// 结构体大小
	int						nStateListNum;								// 车位锁状态个数
	NET_STATE_LIST_INFO		stuStateList[MAX_PARKINGLOCK_STATE_NUM];	// 车位锁状态
} NET_OUT_GET_PARKINGLOCK_STATE_INFO;

// 设置车位锁状态接口，CLIENT_SetParkingLockState 入参
typedef struct tagNET_IN_SET_PARKINGLOCK_STATE_INFO
{
	 DWORD					dwSize;										// 结构体大小
	 int					nStateListNum;								// 车位锁状态个数
	 NET_STATE_LIST_INFO	stuStateList[MAX_PARKINGLOCK_STATE_NUM];	// 车位锁状态
} NET_IN_SET_PARKINGLOCK_STATE_INFO;

// 设置车位锁状态接口，CLIENT_SetParkingLockState 出参
typedef	struct tagNET_OUT_SET_PARKINGLOCK_STATE_INFO
{
	DWORD					dwSize;										// 结构体大小
} NET_OUT_SET_PARKINGLOCK_STATE_INFO; 

// 设置停车规则接口，CLIENT_SetParkingRule 入参
typedef struct tagNET_IN_SET_PARKINGRULE_INFO
{
	DWORD					dwSize;										// 结构体大小
	UINT					nParkingTimeThreshold;					    // 停车时长阈值，单位秒
} NET_IN_SET_PARKINGRULE_INFO;

// 设置停车规则接口，CLIENT_SetParkingRule 出参
typedef	struct tagNET_OUT_SET_PARKINGRULE_INFO
{
	DWORD					dwSize;										// 结构体大小
} NET_OUT_SET_PARKINGRULE_INFO; 

// 文件批量下载

// 下载进度回调函数原型, nError表示在下载过程出现的错误,1-缓存不足,2-对返回数据的校验出错,3-下载当前文件失败,4-创建对应保存文件失败
// 按文件下载时,ID为用户设置的dwFileID,按条件下载时,ID为用户设置的dwConditionID                    
typedef void (CALLBACK *fMultiFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

//下载文件方式
typedef enum tagEM_DOWNLOAD_FILE_TYPE
{
   EM_DOWNLOAD_BY_FILENAME = 0      ,       //按文件名下载
   EM_DOWNLOAD_BY_CONDITION         ,       //按条件下载
}EM_DOWNLOAD_FILE_TYPE;

//下载时间类型
typedef enum tagEM_DOWNLOAD_TIME_TYPE
{
    EM_DOWNLOAD_TIME_SNAP = 0       ,         //抓拍时间
    EM_DOWNLOAD_TIME_STORAGE        ,         //存储时间
}EM_DOWNLOAD_TIME_TYPE;

//下载数据类型
typedef enum tagEM_DOWNLOAD_DATA_TYPE
{
    EM_DOWNLOAD_DATA_RECORD = 0 ,               //录像
    EM_DOWNLOAD_DATA_PICTURE ,                  //图片
}EM_DOWNLOAD_DATA_TYPE;

// CLIENT_DownLoadMultiFile 接口参数
typedef struct tagNET_DOWNLOADFILE_INFO
{
    DWORD               dwSize;
    DWORD               dwFileID;                       // 文件ID, 由用户自己分配
    int                 nFileSize;                      // 查询到的文件大小
    char                szSourceFilePath[MAX_PATH];     // 查询到的文件路径
    char                szSavedFileName[MAX_PATH];      // 文件保存路径
}NET_DOWNLOADFILE_INFO;

typedef struct tagNET_DOWNLOAD_CONDITION_INFO
{
    DWORD                   dwSize;
    DWORD                   dwConditionID;                  // 条件ID, 由用户自己分配
    int                     nChannel;                       // 通道号
    NET_TIME                stuStartTime;                   // 开始时间
    NET_TIME                stuEndTime;                     // 结束时间
    EM_DOWNLOAD_TIME_TYPE   emTimeType;                     // 时间类型
    EM_DOWNLOAD_DATA_TYPE   emDataType;                     // 数据类型 
    char                    szSavedFileName[MAX_PATH];      // 文件保存路径
}NET_DOWNLOAD_CONDITION_INFO;

typedef struct tagNET_IN_DOWNLOAD_MULTI_FILE
{
    DWORD                   dwSize;
    //按文件名下载
    int                             nFileCount;                 // 待下载文件数,emDownloadType为EM_DOWNLOAD_BY_FILENAME有效
    NET_DOWNLOADFILE_INFO*          pFileInfos;                 // 待下载文件信息,emDownloadType为EM_DOWNLOAD_BY_FILENAME有效
																// 由用户申请内存，大小为sizeof(NET_DOWNLOADFILE_INFO)*nFileCount
    fMultiFileDownLoadPosCB         cbPosCallBack;              // 进度回调函数
    LDWORD                          dwUserData;                 // 用户数据
    EM_DOWNLOAD_FILE_TYPE           emDownloadType;             // 下载方式
    //按查询条件下载
    int                             nConditionCount;             // 下载条件数,emDownloadType为EM_DOWNLOAD_BY_CONDITION有效
    NET_DOWNLOAD_CONDITION_INFO*    pConditionInfos;             // 下载条件,emDownloadType为EM_DOWNLOAD_BY_CONDITION有效    
															     // 由用户申请内存，大小为sizeof(NET_DOWNLOAD_CONDITION_INFO)*nConditionCount
}NET_IN_DOWNLOAD_MULTI_FILE;

typedef struct tagNET_OUT_DOWNLOAD_MULTI_FILE
{
    DWORD               dwSize;
    LLONG               lDownLoadHandle;                // 下载句柄
}NET_OUT_DOWNLOAD_MULTI_FILE;

typedef struct __NET_VIDEOANALYSE_STATE
{
    DWORD            dwSize;
    DWORD            dwProgress;                        // 分析进度,0-100
    char             szState[DH_COMMON_STRING_64];      // 通道状态,Running"：运行,"Stop"：停止,"NoStart"：未启动,"Failed"：失败,"Successed"：成功
    char             szFailedCode[DH_COMMON_STRING_64]; // 错误码
}NET_VIDEOANALYSE_STATE;

//视频分析进度状态实时回调函数
typedef int (CALLBACK *fVideoAnalyseState)(LLONG lAttachHandle, NET_VIDEOANALYSE_STATE* pAnalyseStateInfos, LDWORD dwUser, void* pReserved);

// CLIENT_AttachVideoAnalyseState接口输入参数
typedef struct __NET_IN_ATTACH_VIDEOANALYSE_STATE 
{
    DWORD              dwSize;
    int                nChannleId;            // 通道号
    fVideoAnalyseState cbVideoAnalyseState;   // 视频分析状态回调函数
    LDWORD             dwUser;                // 用户信息 
}NET_IN_ATTACH_VIDEOANALYSE_STATE;

// CLIENT_AttachVideoAnalyseState接口输出参数
typedef struct __NET_OUT_ATTACH_VIDEOANALYSE_STATE 
{
    DWORD              dwSize;
    LLONG              lAttachHandle;         // 分析进度句柄,唯一标识某一通道的分析进度
}NET_OUT_ATTACH_VIDEOANALYSE_STATE;

// 语音对讲状态
typedef enum tagEM_TALK_STATE
{
    EM_TALK_STATE_UNKNOWN,                 // 未知
    EM_TALK_STATE_INVITING,                // 主叫
    EM_TALK_STATE_RINGING,                 // 被叫
    EM_TALK_STATE_ANSWER,                  // 应答
    EM_TALK_STATE_REFUSE,                  // 拒绝
    EM_TALK_STATE_HANGUP,                  // 挂断
    EM_TALK_STATE_BUSYING,                 // 忙碌
    EM_TALK_STATE_CANCEL,                  // 取消呼叫
} EM_TALK_STATE;

#define NET_CALL_NUM_MAX           128         // 最大通话号码数量

// CLIENT_AttachTalkState 回调函数返回的语音对讲状态
typedef struct tagNET_TALK_STATE
{
    DWORD                dwSize; 
    char                 szCallID[DH_COMMON_STRING_64];  // 呼叫惟一标识符
    int                  nAudioPort;                     // 音频端口
    int                  nVideoPort;                     // 视频端口
    char                 szMediaAddr[DH_MAX_IPADDR_LEN]; // 取流地址
    EM_TALK_STATE        emState;                        // 状态
    int                  nNumberCount;                   // 呼叫号码数
    char                 szNumbers[NET_CALL_NUM_MAX][DH_COMMON_STRING_32]; // 呼叫号码列表
} NET_TALK_STATE;

// 接口 CLIENT_AttachTalkState 的回调函数
typedef void (CALLBACK *fNotifyTalkState)(LLONG lAttachHandle, NET_TALK_STATE* pstuState, int nLen, LDWORD dwUser);

// 接口 CLIENT_AttachTalkState 的输入参数
typedef struct tagNET_IN_ATTACH_TALK_STATE
{
    DWORD                dwSize;                         // 此结构体大小,必须赋值
    int                  nChnId;                         // 通道号,用于标识对讲单元
    fNotifyTalkState     cbCallBack;                     // 回调函数,有对讲状态时,回调给上层
    LDWORD               dwUser;                         // 用户自定义参数
}NET_IN_ATTACH_TALK_STATE;

// 接口 CLIENT_AttachTalkState 的输出参数
typedef struct tagNET_OUT_ATTACH_TALK_STATE
{
    DWORD       dwSize;                                  // 此结构体大小,必须赋值
    char        szCallID[DH_COMMON_STRING_64];           // 呼叫惟一标识符
}NET_OUT_ATTACH_TALK_STATE;

///////////////////////////////// IVS 服务器视频诊断模块 /////////////////////////////////
// 视频诊断上报结果检测类型定义
#define NET_DIAGNOSIS_DITHER                    "VideoDitherDetection"                       // 视频抖动检测 对应结构体(NET_VIDEO_DITHER_DETECTIONRESULT)
#define NET_DIAGNOSIS_STRIATION                 "VideoStriationDetection"                    // 视频条纹检测 对应结构体(NET_VIDEO_STRIATION_DETECTIONRESULT)
#define NET_DIAGNOSIS_LOSS                      "VideoLossDetection"                         // 视频丢失检测 对应结构体(NET_VIDEO_LOSS_DETECTIONRESULT)
#define NET_DIAGNOSIS_COVER                     "VideoCoverDetection"                        // 视频遮挡检测 对应结构体(NET_VIDEO_COVER_DETECTIONRESULT)
#define NET_DIAGNOSIS_FROZEN                    "VideoFrozenDetection"                       // 视频冻结检测 对应结构体(NET_VIDEO_FROZEN_DETECTIONRESULT)
#define NET_DIAGNOSIS_BRIGHTNESS                "VideoBrightnessDetection"                   // 视频亮度异常检测 对应结构体(NET_VIDEO_BRIGHTNESS_DETECTIONRESULT)
#define NET_DIAGNOSIS_CONTRAST                  "VideoContrastDetection"                     // 视频对比度异常检测 对应结构体(NET_VIDEO_CONTRAST_DETECTIONRESULT)
#define NET_DIAGNOSIS_UNBALANCE                 "VideoUnbalanceDetection"                    // 视频偏色检测 对应结构体(NET_VIDEO_UNBALANCE_DETECTIONRESULT)
#define NET_DIAGNOSIS_NOISE                     "VideoNoiseDetection"                        // 视频噪声检测 对应结构体(NET_VIDEO_NOISE_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLUR                      "VideoBlurDetection"                         // 视频模糊检测 对应结构体(NET_VIDEO_BLUR_DETECTIONRESULT)
#define NET_DIAGNOSIS_SCENECHANGE               "VideoSceneChangeDetection"                  // 视频场景变化检测 对应结构体(NET_VIDEO_SCENECHANGE_DETECTIONRESULT)
#define NET_DIAGNOSIS_VIDEO_DELAY               "VideoDelay"                                 // 视频延时检测 对应结构体(NET_VIDEO_DELAY_DETECTIONRESUL)
#define NET_DIAGNOSIS_PTZ_MOVING                "PTZMoving"                                  // 云台移动检测 对应结构体(NET_PTZ_MOVING_DETECTIONRESULT)
#define NET_DIAGNOSIS_BLACK_WHITE				"VideoBlackAndWhite"						 // 黑白图像检测, 对应结构体(NET_BLACK_WHITE_DETECTIONRESULT)
#define NET_DIAGNOSIS_DRAMATIC_CHANGE			"VideoDramaticChange"						 // 场景剧变检测, 对应结构体(NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT)
#define NET_DIAGNOSIS_VIDEO_AVAILABILITY	    "VideoAvailability"						     // 视频完好率监测, 对应结构体(NET_VIDEO_AVAILABILITY_DETECTIONRESULT)


typedef enum tagNET_STATE_TYPE
{
    NET_EM_STATE_ERR,        // 其它
    NET_EM_STATE_NORMAL,     // "Normal" 正常 
    NET_EM_STATE_WARNING,    // "Warning" 警告
    NET_EM_STATE_ABNORMAL,   // "Abnormal" 异常
}NET_STATE_TYPE;

// 视频诊断结果类型
typedef enum tagNET_VIDEODIAGNOSIS_RESULT_TYPE
{
    NET_EM_ROTATION,                        // "Rotation"    -视频轮巡分析结果
    NET_EM_REAL,                            // "Real" -实时视频分析结果
    NET_EM_NR_UNKNOW,                       // 未定义
}NET_VIDEODIAGNOSIS_RESULT_TYPE;

//视频诊断错误原因
typedef enum tagNET_VIDEODIAGNOSIS_FAIL_TYPE
{
    NET_EM_NO_ERROR,                        // 诊断成功
    NET_EM_DISCONNECT,                      // "Disconnect" - 末能连接设备
    NET_EM_CH_NOT_EXIST,                    // "ChannelNotExist" - 通道不存在
    NET_EM_LOGIN_OVER_TIME,                 // "LoginOverTime" - 登录超时
    NET_EM_NO_VIDEO,                        // "NoVideo" - 登录成功无视频
    NET_EM_NO_RIGHT,                        // "NoRight" - 无操作权限
    NET_EM_PLATFROM_LOGIN_FAILED,           // "PlatformLoginFailed" - 平台登入失败
    NET_EM_PLATFROM_DISCONNECT,             // "PlatformDisconnect" - 平台断开连接
    NET_EM_GET_STREAM_OVER_TIME,            // "GetStreamOverTime" - 获取码流超时
    NET_EM_GET_NO_ENOUGH_STREAM,            // "NoEnoughStream" - 码流不足
    NET_EM_DECODE_STREAM_FAILED,            // "DecodeStreamFailed" - 解码失败
    NET_EM_GET_OFF_LINE,                    // "OffLine" - 前端设备离线
    NET_EM_NF_UNKNOW,                       //  其他原因,详见结构体里的失败原因描述
    NET_EM_NOT_SD,                          //  "NotSD" - 设备非球机，云台类检测无效

    NET_EM_RTSP_PROCESS_FAILED,             //  "RtspProcesssFailed" - RTSP过程失败
    NET_EM_PLAY_FAILED,                     //  "PlayFailed" - 播放失败
    NET_EM_SNAP_FAILED,                     //  "SnapFailed" - 抓图失败
    NET_EM_FULL_CHANNEL_LINKS,              //  "FullChannelLinks" - 由于资源管控，该角色的用户连接数已满，导致拉流失败
}NET_VIDEODIAGNOSIS_FAIL_TYPE;

// 通用变长字符串以‘\0’结束
typedef struct tagNET_ARRAY
{
    DWORD          dwSize;                  // 此结构体大小
    char*          pArray;                  // 缓冲区 目前最小260字节,调用者申请内存 填充数据保证是'\0'结束
    DWORD          dwArrayLen;              // 缓冲空间长度
}NET_ARRAY;

#define MAX_BACKPIC_COUNT	8	// 最大背景图片个数

// 视频诊断结果上报通用数据
typedef struct tagNET_VIDEODIAGNOSIS_COMMON_INFO
{
    DWORD                           dwSize;                                 // 此结构体大小
    int                             nDiagnosisID;                           // 检测通道
    NET_ARRAY                       stProject;                              // 计划名称
    NET_ARRAY                       stTask;                                 // 任务名称
    NET_ARRAY                       stProfile;                              // 参数表名称
    NET_ARRAY                       stDeviceID;                             // 设备唯一标志
    NET_TIME                        stStartTime;                            // 开始时间
    NET_TIME                        stEndTime;                              // 结束时间
    int                             nVideoChannelID;                        // 视频通道号 前端设备比如DVR,IPC的通道
    NET_STREAM_TYPE                 emVideoStream;                          // 视频码流
    NET_VIDEODIAGNOSIS_RESULT_TYPE  emResultType;                           // 诊断结果类型 
    BOOL                            bCollectivityState;                     // 诊断结果
    NET_VIDEODIAGNOSIS_FAIL_TYPE    emFailedCause;                          // 失败原因
    char                            szFailedCode[DH_COMMON_STRING_64];      // 失败原因描述
    char                            szResultAddress[DH_COMMON_STRING_128];  // 诊断结果存放地址,建议使用szResultAddressEx字段
    int                             nFrameRate;                             // 码率	单位 kb/s, 每天上报一次
    int                             nFrameWidth;                            // 宽	每天上报一次
    int                             nFrameHeight;                           // 高	每天上报一次
	int								nBackPic;								// 背景图片个数
	char							szBackPicAddress[MAX_BACKPIC_COUNT][DH_COMMON_STRING_128];	// 背景图片路径
	char                            szResultAddressEx[DH_COMMON_STRING_256];  // 诊断结果存放地址扩展
}NET_VIDEODIAGNOSIS_COMMON_INFO;

// 对应检测类型(NET_DIAGNOSIS_DITHER) 视频抖动检测结果 -- 画面变化 风吹,晃动,转动包括云台转动
typedef struct tagNET_VIDEO_DITHER_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态  一般小于是正常,大于是异常,中间是警告
    int                  nDuration;                      // 状态持续时间  检测项持续检测时间 暂时无用
}NET_VIDEO_DITHER_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_STRIATION)视频条纹检测结果 -- 相机受到干扰出现异常条纹
typedef struct tagNET_VIDEO_STRIATION_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_STRIATION_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_LOSS)视频丢失检测结果 -- 断电 断线等造成的
typedef struct tagNET_VIDEO_LOSS_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_LOSS_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_COVER)视频遮挡检测结果 -- 相机被遮挡了
typedef struct tagNET_VIDEO_COVER_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_COVER_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_FROZEN)视频冻结检测结果 -- 画面不动多久为冻结
typedef struct tagNET_VIDEO_FROZEN_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_FROZEN_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_BRIGHTNESS)视频亮度异常检测结果 --以下是相机配置不正确的一些现象检测
typedef struct tagNET_VIDEO_BRIGHTNESS_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_BRIGHTNESS_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_CONTRAST)视频对比度异常检测结果
typedef struct tagNET_VIDEO_CONTRAST_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_CONTRAST_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_UNBALANCE)视频偏色异常检测结果
typedef struct tagNET_VIDEO_UNBALANCE_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_UNBALANCE_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_NOISE)视频噪声异常检测结果
typedef struct tagNET_VIDEO_NOISE_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_NOISE_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_BLUR)视频模糊异常检测结果
typedef struct tagNET_VIDEO_BLUR_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_BLUR_DETECTIONRESULT;
// 对应检测类型(NET_DIAGNOSIS_SCENECHANGE)视频场景变化检测结果
typedef struct tagNET_VIDEO_SCENECHANGE_DETECTIONRESULT
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nValue;                         // 检测结果量化值
    NET_STATE_TYPE       emState;                        // 检测结果状态
    int                  nDuration;                      // 状态持续时间
}NET_VIDEO_SCENECHANGE_DETECTIONRESULT;

// 运动移动检测结果类型
typedef enum tagEM_PTZ_MOVING_RESULT_TYPE
{   
    EM_PTZ_MOVING_UNKNOWN ,          // 未知
    EM_PTZ_MOVING_NORMAL  ,      // 检测正常
    EM_PTZ_MOVING_NOTOBEY ,      // 不按指令运动
    EM_PTZ_MOVING_NOTMOVE ,      // 不能运动
    EM_PTZ_MOVING_NOTDETECT ,    // 未做检测
}EM_PTZ_MOVING_RESULT_TYPE;

// 对应检测类型(NET_DIAGNOSIS_PTZ_MOVING)云台移动检测结果
typedef struct tagNET_PTZ_MOVING_DETECTIONRESULT
{
    DWORD                       dwSize;                 // 此结构体大小
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingUp;          // 向上运动检测结果
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingDown;        // 向下运动检测结果
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingLeft;        // 向左运动检测结果
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingRight;       // 向右运动检测结果
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomWide;    // 变倍(大)运动检测结果
    EM_PTZ_MOVING_RESULT_TYPE   emPTZMovingZoomTele;    // 变倍(小)运动检测结果      
}NET_PTZ_MOVING_DETECTIONRESULT;

// 对应检测类型(NET_DIAGNOSIS_BLACK_WHITE) 黑白图像检测结果
typedef struct tagNET_BLACK_WHITE_DETECTIONRESULT
{
	DWORD                dwSize;                 // 此结构体大小
	int                  nValue;                 // 检测结果量化值
    NET_STATE_TYPE       emState;                // 检测结果状态
    int                  nDuration;              // 状态持续时间
} NET_BLACK_WHITE_DETECTIONRESULT;

// 对应检测类型(NET_DIAGNOSIS_DRAMATIC_CHANGE) 场景剧变检测结果
typedef struct tagNET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT
{
	DWORD                dwSize;                 // 此结构体大小
	int                  nValue;                 // 检测结果量化值
    NET_STATE_TYPE       emState;                // 检测结果状态
    int                  nDuration;              // 状态持续时间
} NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT;


// 对应检测类型(NET_DIAGNOSIS_VIDEO_DELAY)视频延时检测结果
typedef struct tagNET_VIDEO_DELAY_DETECTIONRESUL
{
    DWORD       dwSize;             // 此结构体大小
    int         nSignalDelay;       // 信令延时,-1表示检测失败, 单位ms
    int         nStreamDelay;       // 视频流延时,-1表示检测失败, 单位ms
    int         nIFrameDelay;       // I帧延时,-1表示检测失败 单位ms
}NET_VIDEO_DELAY_DETECTIONRESUL;

typedef struct tagNET_DIAGNOSIS_RESULT_HEADER
{
    DWORD                dwSize;                         // 此结构体大小

    char                 szDiagnosisType[MAX_PATH];      // 诊断类型,详见dhnetsdk.h中"视频诊断上报结果检测类型定义" 如NET_DIAGNOSIS_DITHER
    int                  nDiagnosisTypeLen;              // 该诊断类型结构体大小
}NET_DIAGNOSIS_RESULT_HEADER;

// cbVideoDiagnosis 回调参数类型
typedef struct tagNET_REAL_DIAGNOSIS_RESULT
{
    DWORD                dwSize;                         // 此结构体大小
    NET_VIDEODIAGNOSIS_COMMON_INFO* pstDiagnosisCommonInfo;  //视频诊断通用信息
    int                  nTypeCount;                     // 诊断结果数据诊断类型个数
    void*                pDiagnosisResult;               // 一次诊断结果数据,格式如NET_DIAGNOSIS_RESULT_HEADER+诊断类型1+NET_DIAGNOSIS_RESULT_HEADER+诊断类型2+...
    DWORD                dwBufSize;                      // 缓冲长度
}NET_REAL_DIAGNOSIS_RESULT;

//视频诊断结果上报回调函数
typedef int (CALLBACK *fRealVideoDiagnosis)(LLONG lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT* pDiagnosisInfo, void* pBuf, int nBufLen, LDWORD dwUser);

// 接口 CLIENT_StartVideoDiagnosis 的输入参数
typedef struct tagNET_IN_VIDEODIAGNOSIS
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nDiagnosisID;                   // 视频诊断ID,从0开始
    DWORD                dwWaitTime;                     // 接口超时等待时间
    fRealVideoDiagnosis  cbVideoDiagnosis;               // 视频诊断结果回调函数
    LDWORD               dwUser;                         // 用户自定义参数
}NET_IN_VIDEODIAGNOSIS;

// 接口 CLIENT_StartVideoDiagnosis 的输出参数
typedef struct tagNET_OUT_ATTACH_REALDIAGNOSIS
{
    DWORD                dwSize;                         // 此结构体大小
    LLONG                lDiagnosisHandle;               // 订阅句柄
}NET_OUT_VIDEODIAGNOSIS;

// 接口 CLIENT_StartFindDiagnosisResult 的输入参数
typedef struct tagNET_IN_FIND_DIAGNOSIS
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nDiagnosisID;                   // 视频诊断ID,从0开始
    DWORD                dwWaitTime;                     // 接口超时等待时间
    NET_ARRAY            stuDeviceID;                    // 设备唯一标志,pArray:NULL表示不使用设备ID查询
    NET_TIME             stuStartTime;                   // 开始时间
    NET_TIME             stuEndTime;                     // 结束时间
    int                  nVideoChannel;                  // 视频通道号,-1:所有通道号
    int                  nTypeCount;                     // 诊断类型个数,0:不使用诊断类型查询
    NET_ARRAY*           pstDiagnosisTypes;              // 诊断类型数组,表示需要查询的诊断类型
														 // 由用户申请内存，大小为sizeof(NET_ARRAY)*nTypeCount
    char                 szProjectName[MAX_PATH];        // 计划名称
} NET_IN_FIND_DIAGNOSIS;

// 接口 CLIENT_StartFindDiagnosisResult 的输出参数
typedef struct tagNET_OUT_FIND_DIAGNOSIS
{
    DWORD                dwSize;                         // 此结构体大小
    LLONG                lFindHandle;                    // 查询句柄
    DWORD                dwTotalCount;                   // 符合条件的总个数
}NET_OUT_FIND_DIAGNOSIS;

// 接口 CLIENT_DoFindDiagnosisResult 的输入参数
typedef struct tagNET_IN_DIAGNOSIS_INFO
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nDiagnosisID;                   // 视频诊断ID,从0开始
    DWORD                dwWaitTime;                     // 接口超时等待时间
    int                  nFindCount;                     // 每次查询的视频诊断结果条数
    int                  nBeginNumber;                   // 查询起始序号 0<=beginNumber<= totalCount-1
}NET_IN_DIAGNOSIS_INFO;

// CLIENT_StartRealTimeProject 接口输入参数
typedef struct tagNET_IN_START_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // 此结构体大小
    char*                pszProjectInfo;                 // 实时计划信息,通过调用dhconfigsdk.dll中接口CLIENT_PacketData封装得到
                                                         // 对应的封装命令为 CFG_CMD_VIDEODIAGNOSIS_REALPROJECT                      
}NET_IN_START_RT_PROJECT_INFO;

// CLIENT_StartRealTimeProject 接口输出参数
typedef struct tagNET_OUT_START_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // 此结构体大小
}NET_OUT_START_RT_PROJECT_INFO;

// CLIENT_UpdateProjectBackGround 接口输入参数
typedef struct tagNET_IN_UPDATE_PROJECT_BCKGROUND_INFO
{
    DWORD                dwSize;                         // 此结构体大小
    char                 szProjectName[MAX_PATH];        // 计划名，值为""表示更新所有执行计划的背景
    char                 szTaskName[MAX_PATH];           // 任务名，值为""表示更新所有任务的背景
    char                 szDeviceID[MAX_PATH];           // 设备唯一标志，值为""表示更新所有设备的背景
    int                  nChannelID;                     // 视频通道号，值为-1(此时Device必然不为空)表示更新该设备所有通道的背景
} NET_IN_UPDATE_PROJECT_BACKGROUND_INFO;

// CLIENT_UpdateProjectBackGround 接口输出参数
typedef struct tagNET_OUT_UPDATE_PROJECT_BACKGROUND_INFO
{
    DWORD                dwSize;                         // 此结构体大小
} NET_OUT_UPDATE_PROJECT_BACKGROUND_INFO;

// CLIENT_StopRealTimeProject 接口输入参数
typedef struct tagNET_IN_STOP_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // 此结构体大小
    char*                pszProjectNames;                // 计划名称,以&&作为名字的分割符,示例：Project1&&Project2   
}NET_IN_STOP_RT_PROJECT_INFO; 

// CLIENT_StopRealTimeProject 接口输出参数
typedef struct tagNET_OUT_STOP_RT_PROJECT_INFO
{
    DWORD                dwSize;                         // 此结构体大小
}NET_OUT_STOP_RT_PROJECT_INFO;

#define MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN    260     // 视频诊断计划名称最大长度
#define MAX_VIDEODIAGNOSIS_TASK_NAME_LEN       260     // 视频诊断任务名称最大长度

// CLIENT_StartManualDiagnosisProject 接口输入参数
typedef struct tagNET_IN_START_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                                 // 此结构体大小
    char                szProjectName[MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN];     // 诊断计划名称
    NET_TIME            stuStartTime;                                           // 计划预计的开始时间
    BOOL                bIsCycle;                                               // 任务是否循环
    char                szTaskName[MAX_VIDEODIAGNOSIS_TASK_NAME_LEN];           // 计划使用的任务名称
} NET_IN_START_MANUAL_PROJECT_INFO;

// CLIENT_StartManualDiagnosisProject 接口输出参数
typedef struct tagNET_OUT_START_MANUAL_PROJECT_INFO
{
    DWORD                dwSize;                                // 此结构体大小
} NET_OUT_START_MANUAL_PROJECT_INFO;

// CLIENT_StopManualDiagnosisProject 接口输入参数
typedef struct tagNET_IN_STOP_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                                 // 此结构体大小
    char                szProjectName[MAX_VIDEODIAGNOSIS_PROJECT_NAME_LEN];    // 诊断计划名称
} NET_IN_STOP_MANUAL_PROJECT_INFO;

// CLIENT_StopManualDiagnosisProject 接口输出参数
typedef struct tagNET_OUT_STOP_MANUAL_PROJECT_INFO
{
    DWORD               dwSize;                                 // 此结构体大小
} NET_OUT_STOP_MANUAL_PROJECT_INFO;

// 车位灯信息
typedef struct tagNET_CARPORTLIGHT_INFO
{
    DWORD               dwSize;  
    NET_CARPORTLIGHT_TYPE emType;                        // 车位灯类型
    NET_CARPORTLIGHT_MODE emMode;                        // 车位灯亮灯方式
}NET_CARPORTLIGHT_INFO;

// 车位灯状态
typedef struct tagNET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nLightNum;                      // 车位灯数 
    NET_CARPORTLIGHT_INFO stuLights[DH_MAX_CARPORTLIGHT_NUM]; // 车位灯信息,数组中emType不能重复,一个红灯和一个绿灯
    int                  nFiringTime;                    // 状态启动时间,单位秒
    int                  nHoldTime;                      // 状态保持时间,单位秒,-1表示无限保持,0表示自行控制
}NET_CARPORTLIGHT_STATUS;

// 接口CLIENT_GetCarPortLightStatus的输入参数
typedef struct tagNET_IN_GET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nChannelId;                     // 通道号
}NET_IN_GET_CARPORTLIGHT_STATUS;

// 接口CLIENT_GetCarPortLightStatus的输出参数
typedef struct tagNET_OUT_GET_CARPORTLIGHT_STATUS
{
    DWORD                   dwSize;                      // 此结构体大小
    NET_CARPORTLIGHT_STATUS stuLightStatus;              // 车位灯状态
}NET_OUT_GET_CARPORTLIGHT_STATUS;

// 接口 CLIENT_SetCarPortLightStatus 的输入参数
typedef struct tagNET_IN_SET_CARPORTLIGHT_STATUS
{
    DWORD                   dwSize;                      // 此结构体大小
    int                     nChannelId;
    NET_CARPORTLIGHT_STATUS stuLightStatus;              // 车位灯状态
}NET_IN_SET_CARPORTLIGHT_STATUS;

// 接口 CLIENT_SetCarPortLightStatus 的输出参数
typedef struct tagNET_OUT_SET_CARPORTLIGHT_STATUS
{
    DWORD                dwSize;                         // 此结构体大小
    
}NET_OUT_SET_CARPORTLIGHT_STATUS;

// 视频完好率监测结果
typedef struct tagNET_VIDEO_AVAILABILITY_DETECTIONRESULT
{
	DWORD                dwSize;                 // 结构体大小
	int					 nSignalDelay;           // 信令延时,-1表示检测失败, 单位ms
	int                  nStreamDelay;           // 视频流延时,-1表示检测失败, 单位ms
	int                  nIFrameDelay;           // I帧延时,-1表示检测失败 单位ms
}NET_VIDEO_AVAILABILITY_DETECTIONRESULT;


typedef struct tagNET_DEV_VIDEODIAGNOSIS_MULTI_INFO
{
    DWORD                dwSize;                                // 此结构体大小

    NET_VIDEODIAGNOSIS_COMMON_INFO*       pstDiagnosisCommonInfo;//视频诊断通用信息  以下结构体指针需要调用者分配
    BOOL                 abDither;                              // 用于表示此次结果中这个诊断项是否有效
    NET_VIDEO_DITHER_DETECTIONRESULT*     pstDither;            // 视频抖动检测    
    BOOL                 abStration;
    NET_VIDEO_STRIATION_DETECTIONRESULT*  pstStration;          // 视频条纹检测    
    BOOL                 abLoss;
    NET_VIDEO_LOSS_DETECTIONRESULT*       pstLoss;              // 视频丢失检测    
    BOOL                 abCover;
    NET_VIDEO_COVER_DETECTIONRESULT*      pstCover;             // 视频遮挡检测    
    BOOL                 abFrozen;
    NET_VIDEO_FROZEN_DETECTIONRESULT*     pstFrozen;            // 视频冻结检测   
    BOOL                 abBrightness;
    NET_VIDEO_BRIGHTNESS_DETECTIONRESULT* pstBrightness;        // 视频亮度异常检测    
    BOOL                 abContrast;
    NET_VIDEO_CONTRAST_DETECTIONRESULT*   pstContrast;          // 视频对比度异常检测   
    BOOL                 abUnbalance;
    NET_VIDEO_UNBALANCE_DETECTIONRESULT*  pstUnbalance;         // 视频偏色检测    
    BOOL                 abNoise;
    NET_VIDEO_NOISE_DETECTIONRESULT*      pstNoise;             // 视频噪声检测    
    BOOL                 abBlur;
    NET_VIDEO_BLUR_DETECTIONRESULT*       pstBlur;              // 视频模糊检测    
    BOOL                 abSceneChange;
    NET_VIDEO_SCENECHANGE_DETECTIONRESULT* pstSceneChange;      // 视频场景变化检测
    BOOL                 abVideoDelay;
    NET_VIDEO_DELAY_DETECTIONRESUL*       pstVideoDelay;        // 视频延迟检测
    BOOL                abPTZMoving;
    NET_PTZ_MOVING_DETECTIONRESULT*       pstPTZMoving;         // 云台操作检测
    BOOL				abBlackAndWhite;
	NET_BLACK_WHITE_DETECTIONRESULT*	  pstBlackAndWhite;		// 黑白图像检测
	BOOL				abDramaticChange;
	NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT* pstDramaticChange;	// 场景剧变检测

	BOOL				abVideoAvailability;                    // 是否支持视频完好率监测
	NET_VIDEO_AVAILABILITY_DETECTIONRESULT* pstVideoAvailability;	// 视频完好率监测结果
}NET_VIDEODIAGNOSIS_RESULT_INFO;

// 接口 CLIENT_DoFindDiagnosisResult 的输出参数
typedef struct tagNET_OUT_DIAGNOSIS_INFO
{
    DWORD                dwSize;                         // 此结构体大小

    int                  nInputNum;                      // 用户分配的NET_DEV_RESULT_VIDEODIAGNOSIS_INFO个数
    int                  nReturnNum;                     // 返回结果个数
    NET_VIDEODIAGNOSIS_RESULT_INFO*  pstDiagnosisResult; // 结果数据  结构体指针需要调用者分配
														 // 申请内存大小为sizeof(NET_VIDEODIAGNOSIS_RESULT_INFO)*nInputNum
}NET_OUT_DIAGNOSIS_INFO;

///////////////////////////////// 主从式设备控制模块 //////////////////////////////////////////////////////
///////////////////////////////// CLIENT_OperateMasterSlaveDevice接口参数定义 /////////////////////////////////
#define        MASTERSLAVE_CMD_START                   "masterSlaveTracker.start"                   // 开启主从式跟踪器工作
#define        MASTERSLAVE_CMD_STOP                    "masterSlaveTracker.stop"                    // 停止主从式跟踪器工作
#define        MASTERSLAVE_CMD_MANUALTRACK             "masterSlaveTracker.manualSelectObjectTrack" // 手动选定目标跟踪
#define        MASTERSLAVE_CMD_POINTTRACK              "masterSlaveTracker.selectPointTrack"        // 定点跟踪
#define        MASTERSLAVE_CMD_GETCALIBPOINTS          "masterSlaveTracker.getCalibratePoints"      // 得到所有标定点
#define        MASTERSLAVE_CMD_CALIBRATE               "masterSlaveTracker.calibrate"               // 保存标定点
#define        MASTERSLAVE_CMD_ADDCALIBPOINT           "masterSlaveTracker.addCalibratePoint"       // 增加标定点
#define        MASTERSLAVE_CMD_REMOVECALIBPOINT        "masterSlaveTracker.removeCalibratePoint"    // 删除标定点
#define        MASTERSLAVE_CMD_MARKMAXZOOM             "masterSlaveTracker.markSceneMaxZoom"        // 标定场景最大跟踪倍率, 把当前倍率作为最大倍率

// 主从式设备点对
typedef struct __NET_MS_PAIRPOINTS
{
    int                nStructSize;
    DH_POINT           stMasterPoint;    // 主相机标定点,点的坐标归一化到[0,8192]区间
    DH_POINT           stSlavePoint;     // 从相机标定点,点的坐标归一化到[0,8192]区间
}NET_MS_PAIRPOINTS;
//MASTERSLAVE_CMD_START命令的输入结构体
typedef struct __NET_IN_MS_START
{
    int                nStructSize;
}NET_IN_MS_START;

//MASTERSLAVE_CMD_START命令的输出结构体
typedef struct __NET_OUT_MS_START
{
    int                nStructSize;
}NET_OUT_MS_START;

//MASTERSLAVE_CMD_STOP命令的输入结构体
typedef struct __NET_IN_MS_STOP
{
    int                nStructSize;
}NET_IN_MS_STOP;

//MASTERSLAVE_CMD_STOP命令的输出结构体
typedef struct __NET_OUT_MS_STOP
{
    int                nStructSize;
}NET_OUT_MS_STOP;

//MASTERSLAVE_CMD_MANUALTRACK命令的输入结构体
typedef struct __NET_IN_MS_MANUALTRACK
{
    int                nStructSize;
    DWORD              dwObject;          // -1 表示整个区域的任意位置物体, >=0表示指定的物体（可以从设备返回智能帧得到）
}NET_IN_MS_MANUALTRACK;

//MASTERSLAVE_CMD_MANUALTRACK命令的输出结构体
typedef struct __NET_OUT_MS_MANUALTRACK
{
    int                nStructSize;
}NET_OUT_MS_MANUALTRACK;

//MASTERSLAVE_CMD_POINTTRACK命令的输入结构体
typedef struct __NET_IN_MS_POINTTRACK
{
    int                nStructSize;
    DH_POINT           stTrackerPoint;    // 跟踪点,点的坐标归一化到[0,8192]区间 
}NET_IN_MS_POINTTRACK;

//MASTERSLAVE_CMD_POINTTRACK命令的输出结构体
typedef struct __NET_OUT_MS_POINTTRACK
{
    int                nStructSize;
}NET_OUT_MS_POINTTRACK;

//MASTERSLAVE_CMD_GETCALIBPOINTS命令的输入结构体
typedef struct __NET_IN_MS_GETCALIBPOINTS
{
    int                nStructSize;
}NET_IN_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_GETCALIBPOINTS命令的输出结构体
typedef struct __NET_OUT_MS_GETCALIBPOINTS
{
    int                        nStructSize;
    int                        nPointsNum;                           // 实际标定点数
    NET_MS_PAIRPOINTS          stPairPoints[MAX_CALIBPOINTS_NUM];    // 标定坐标点组
}NET_OUT_MS_GETCALIBPOINTS;

//MASTERSLAVE_CMD_CALIBRATE命令的输入结构体
typedef struct __NET_IN_MS_CALIBRATE
{
    int                nStructSize;
}NET_IN_MS_CALIBRATE;

//MASTERSLAVE_CMD_CALIBRATE命令的输出结构体
typedef struct __NET_OUT_MS_CALIBRATE
{
    int                nStructSize;      
}NET_OUT_MS_CALIBRATE;

//MASTERSLAVE_CMD_ADDCALIBPOINT命令的输入结构体
typedef struct __NET_IN_MS_ADDCALIBPOINT
{
    int                        nStructSize;
    BOOL                       bSlavePointEn;        // 从相机标定点使能位, TURE设置从相机标定点有效；FASLE则无效, 设备自己获取当前的从相机标定点。
    NET_MS_PAIRPOINTS          stPairPoints;         // 主从相机定标点对
}NET_IN_MS_ADDCALIBPOINT;

//MASTERSLAVE_CMD_ADDCALIBPOINT命令的输出结构体
typedef struct __NET_OUT_MS_ADDCALIBPOINT
{
    int                nStructSize;
    DH_POINT           stPoint;      // 从标定点
}NET_OUT_MS_ADDCALIBPOINT;


//MASTERSLAVE_CMD_REMOVECALIBPOINT命令的输入结构体
typedef struct __NET_IN_MS_REMOVECALIBPOINT
{
    int                nStructSize;
    DH_POINT           stPoint;      // 主标定点
}NET_IN_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_REMOVECALIBPOINT命令的输出结构体
typedef struct __NET_OUT_MS_REMOVECALIBPOINT
{
    int                nStructSize;      
}NET_OUT_MS_REMOVECALIBPOINT;

//MASTERSLAVE_CMD_MARKMAXZOOM命令输入结构体
typedef struct __NET_IN_MS_MARKMAXZOOM
{
    int                nStructSize; 
}NET_IN_MS_MARKMAXZOOM;

//MASTERSLAVE_CMD_MARKMAXZOOM命令输出结构体
typedef struct __NET_OUT_MS_MARKMAXZOOM
{
    int                nStructSize; 
}NET_OUT_MS_MARKMAXZOOM;

///////////////////////////////// CLIENT_OperateCommDevice 接口参数定义 /////////////////////////////////
#define        COMMDEV_GET_EXTERNLDATA                            "devComm.getExternalData"        //获取串口外接数据    用于第三方通用数据

#define        MAX_EXTERN_DATA_LEN                2048

//COMMDEV_GET_EXTERNLDATA 输入参数
typedef struct __COMMDEV_IN_GET_EXTERNDATA
{
    DWORD        dwSize;

}COMMDEV_IN_GET_EXTERNDATA;

//COMMDEV_GET_EXTERNLDATA 输出参数
typedef struct __COMMDEV_OUT_GET_EXTERNDATA
{
    DWORD        dwSize;
    char         szGetData[MAX_EXTERN_DATA_LEN];                //串口外接设备采集数据(数据格式根据项目自定义)
}COMMDEV_OUT_GET_EXTERNDATA;


///////////////////////////////// CLIENT_OperateVideoAnalyseDevice 接口参数定义 /////////////////////////////////
#define     NET_SET_MODULESTATE                         "devVideoAnalyse.setModuleState"                        // 设置模块状态
#define     NET_TEST_WITH_SCREENPOINTS                  "devVideoAnalyse.testCalibrateWithScreenPoints"            // 根据屏幕坐标测试景深参数,得到的是两点之间的实际距离。在测试之前,需要先完成参数设置。
#define     NET_TEST_WITH_METRICLENGTH                  "devVideoAnalyse.testCalibrateWithMetricLength"            // 根据实际长度、起始点及方向点坐标,测试景深参数
#define     NET_GET_INTERNALOPTIONS                     "devVideoAnalyse.getInternalOptions"                    // 获取内部选项
#define     NET_TUNE_INTERNALOPTIONS                    "devVideoAnalyse.tuneInternalOptions"                    // 调试内部选项
#define     NET_RESET_INTERNALOPTIONS                   "devVideoAnalyse.resetInternalOptions"                    // 复位所有调试内部选项
#define     NET_SET_PTZ_PRESET_STATUS                   "devVideoAnalyse.setPtzPresetStatus"                    // 获取预置点信息

// 线段类型
typedef enum tagNET_EM_LINETYPE
{
    NET_EM_HORIZONTAL,
    NET_EM_VERTICAL,
}NET_EM_LINETYPE;

// 预置点状态枚举
typedef enum tagEM_DH_PTZ_PRESET_STATUS
{
    EM_DH_PTZ_PRESET_STATUS_UNKNOWN,        // 未知
    EM_DH_PTZ_PRESET_STATUS_REACH,          // 预置点到达
    EM_DH_PTZ_PRESET_STATUS_UNREACH,        // 预置点未到达
}EM_DH_PTZ_PRESET_STATUS;

//云台定位信息报警
typedef struct
{
    int     nChannelID;                 // 通道号 
    int     nPTZPan;                    // 云台水平运动位置,有效范围：[0,3600]
    int     nPTZTilt;                   // 云台垂直运动位置,有效范围：[-1800,1800]
    int     nPTZZoom;                   // 云台光圈变动位置,有效范围：[0,128]
    BYTE    bState;                     // 云台运动状态, 0-未知 1-运动 2-空闲 
    BYTE    bAction;                    // 云台动作,255-未知,0-预置点,1-线扫,2-巡航,3-巡迹,4-水平旋转,5-普通移动,6-巡迹录制,7-全景云台扫描,8-热度图
                                        // 9-精确定位,10-设备校正,11-智能配置，12-云台重启
    BYTE    bFocusState;                // 云台聚焦状态, 0-未知, 1-运动状态, 2-空闲
    BYTE    bEffectiveInTimeSection;    //在时间段内预置点状态是否有效
                                        //如果当前上报的预置点是时间段内的预置点,则为1,其他情况为0
    int     nPtzActionID;               // 巡航ID号
    DWORD   dwPresetID;                 // 云台所在预置点编号
    float   fFocusPosition;             // 聚焦位置
    BYTE    bZoomState;                 // 云台ZOOM状态,0-未知,1-ZOOM,2-空闲
    BYTE    bReserved[3];               // 对齐
    DWORD   dwSequence;                 // 包序号,用于校验是否丢包
    DWORD   dwUTC;                      // 对应的UTC(1970-1-1 00:00:00)秒数。
    EM_DH_PTZ_PRESET_STATUS emPresetStatus; // 预置点位置
	int	    nZoomValue;				    // 真实变倍值 当前倍率（扩大100倍表示）
    int     reserved[244];              // 保留字段
}DH_PTZ_LOCATION_INFO;

// NET_SET_PTZ_PRESET_STATUS
typedef struct __NET_IN_PTZ_PRESET_STATUS
{
    DWORD                    dwSize;
    DH_PTZ_LOCATION_INFO     stPTZStatus;
}NET_IN_PTZ_PRESET_STATUS;

typedef struct __NET_OUT_PTZ_PRESET_STATUS
{
    DWORD    dwSize;
}NET_OUT_PTZ_PRESET_STATUS;


// NET_TEST_WITH_SCREENPOINTS
typedef struct __NET_IN_CALIBRATE_BY_POINTS
{
    DWORD               dwSize;                 // 此结构体大小

    DH_POINT            stStartPoint;           // 线段起点坐标    点的坐标坐标归一化到[0,8191]区间。
    DH_POINT            stEndPoint;             // 终止点坐标    点的坐标坐标归一化到[0,8191]区间。    
    NET_EM_LINETYPE     emType;                 // 线段类型    em_Horizontal("Horizontal") 水平线段 em_Vertical("Vertical")垂直线段
}NET_IN_CALIBRATE_BY_POINTS;
typedef struct __NET_OUT_CALIBRATE_BY_POINTS
{
    DWORD               dwSize;                 // 此结构体大小

    double              dlength;                // 两点之间的实际长度    单位为米
}NET_OUT_CALIBRATE_BY_POINTS;

// NET_TEST_WITH_METRICLENGTH
typedef struct __NET_IN_CALIBRATE_BY_LENGTH
{
    DWORD               dwSize;                 // 此结构体大小

    double              nLength;                // 两点之间的实际长度,米为单位
    DH_POINT            stStartPoint;           // 线段起点坐标,点的坐标坐标归一化到[0,8191]区间。
    DH_POINT            stDirection;            // 线段方向点坐标,只对垂直线段有效。点的坐标坐标归一化到[0,8191]区间。
    NET_EM_LINETYPE     emType;                 // 线段类型,em_Horizontal("Horizontal") 水平线段 em_Vertical("Vertical")垂直线段                
}NET_IN_CALIBRATE_BY_LENGTH;

typedef struct __NET_OUT_CALIBRATE_BY_LENGTH
{
    DWORD               dwSize;                 // 此结构体大小
    
    DH_POINT            stEndPoint;             // 线段终点屏幕坐标    点的坐标坐标归一化到[0,8191]区间。    
}NET_OUT_CALIBRATE_BY_LENGTH;

typedef struct __NET_INTERNAL_OPTION
{
    DWORD               dwSize;                 // 此结构体大小

    int                 nIndex;                 // 选项序号
    NET_ARRAY           stKey;                  // 选项名称,包括‘\0’共256字节,加密数据
    int                 nValue;                 // 选项取值
    int                 nMinValue;              // 最小值
    int                 nMaxValue;              // 最大值
}NET_INTERNAL_OPTION;

// 调试内部选项 NET_GET_INTERNALOPTIONS
typedef struct __NET_IN_GETINTERNAL_OPTIONS
{
    DWORD               dwSize;                 // 此结构体大小
}NET_IN_GETINTERNAL_OPTIONS;

typedef struct __NET_OUT_GETINTERNAL_OPTIONS
{
    DWORD                dwSize;                // 此结构体大小

    int                  nTotalOptionNum;       // 选项个数 最大值查询能力
    int                  nReturnOptionNum;      // 返回的实际选项个数
    NET_INTERNAL_OPTION* pstInternalOption;     // 选项列表 调用者分配地址
												// 由用户申请内存，大小为sizeof(NET_INTERNAL_OPTION)*nTotalOptionNum
}NET_OUT_GETINTERNAL_OPTIONS;

// NET_TUNE_INTERNALOPTIONS
typedef struct __NET_IN_TUNEINTERNAL_OPTION
{
    DWORD                dwSize;                // 此结构体大小
    int                  nOptionCount;          // 选项个数
    NET_INTERNAL_OPTION* pstInternalOption;     // 选项列表 能力来体现个数
												// 由用户申请内存，大小为sizeof(NET_INTERNAL_OPTION)*nOptionCount
}NET_IN_TUNEINTERNAL_OPTION;
typedef struct __NET_OUT_TUNEINTERNAL_OPTION
{
    DWORD               dwSize;                 // 此结构体大小
}NET_OUT_TUNEINTERNAL_OPTION;

// NET_RESET_INTERNALOPTIONS
typedef struct __NET_IN_RESETINTERNAL_OPTION
{
    DWORD               dwSize;                 // 此结构体大小
}NET_IN_RESETINTERNAL_OPTION;
typedef struct __NET_OUT_RESETINTERNAL_OPTION
{
    DWORD               dwSize;                 // 此结构体大小
}NET_OUT_RESETINTERNAL_OPTION;

// NET_SET_MODULESTATE
typedef enum tagNET_EM_MODULESTATE
{
    NET_EM_MODULESTATE_OK,
    NET_EM_MODULESTATE_PAUSE,
}NET_EM_MODULESTATE;
typedef struct __NET_IN_SETMODULESTATE
{
    DWORD               dwSize;                 // 此结构体大小
    NET_EM_MODULESTATE  emState;                // 0-正常工作,1-暂停,再次切换到正常后画面可能已经发生变化,需要重建背景。
    int                 nIndex;                 // 模块编号    -1指所有模块
}NET_IN_SETMODULESTATE;
typedef struct __NET_OUT_SETMODULESTATE
{
    DWORD               dwSize;                 // 此结构体大小
}NET_OUT_SETMODULESTATE;

/////////////////////////////////CLIENT_DeleteDevConfig 接口参数/////////////////////////////////
/*
 * CLIENT_DeleteDevConfig 输入输出参数
 */

typedef enum tagNET_EM_CONFIGOPTION
{
    NET_EM_CONFIGOPTION_OK,
    NET_EM_CONFIGOPTION_NEEDRESTART,
    NET_EM_CONFIGOPTION_NEEDREBOOT=2,
    NET_EM_CONFIGOPTION_WRITEFILEERROR=4,
    NET_EM_CONFIGOPTION_CAPSNOTSUPPORT=8,
    NET_EM_CONFIGOPTION_VALIDATEFAILED=16,
}NET_EM_CONFIGOPTION;

typedef struct tagNET_IN_DELETECFG
{
    DWORD         dwSize;                       // 结构体大小
    char*         szCommand;                    // 配置命令
}NET_IN_DELETECFG;
typedef struct tagNET_OUT_DELETECFG
{
    DWORD         dwSize;                       // 结构体大小
    int           nError;                       // 设备返回的错误码
    int           nRestart;                     // 设备是否重启
    DWORD         dwOptionMask;                 // 选项 具体见枚举NET_EM_CONFIGOPTION
}NET_OUT_DELETECFG;

/////////////////////////////////CLIENT_GetMemberNames 接口参数/////////////////////////////////
/*
 * CLIENT_GetMemberNames 输入输出参数
 */
typedef struct tagNET_IN_MEMBERNAME
{
    DWORD         dwSize;                       // 结构体大小
    char*         szCommand;                    // 配置命令
}NET_IN_MEMBERNAME;
typedef struct tagNET_OUT_MEMBERNAME
{
    DWORD         dwSize;                       // 结构体大小
    int           nError;                       // 设备返回的错误码
    int           nRestart;                     // 设备是否重启
    int           nTotalNameCount;              // 名称个数 通过能力集得到,调用者填写
    int           nRetNameCount;                // 返回的实际名称个数
    NET_ARRAY*    pstNames;                     // 名称数组 调用者申请内存,个数是nTotalNameCount个
												// 由用户申请内存，大小为sizeof(NET_ARRAY)*nTotalNameCount
}NET_OUT_MEMBERNAME;

////////////////////////////////////视频浓缩相关结构体//////////////////////////////////////
// 标尺类型
typedef enum tagNET_EM_STAFF_TYPE
{
    NET_EM_STAFF_TYPE_ERR,
    NET_EM_STAFF_TYPE_HORIZONTAL,               // "Horizontal" 水平线段
    NET_EM_STAFF_TYPE_VERTICAL,                 // "Vertical" 垂直线段
    NET_EM_STAFF_TYPE_ANY,                      // "Any" 任意线段
    NET_EM_STAFF_TYPE_CROSS,                    // "Cross" 垂直面交线段
}NET_EM_STAFF_TYPE;

// 区域类型
typedef enum tagNET_EM_CALIBRATEAREA_TYPE
{
    NET_EM_CALIBRATEAREA_TYPE_ERR,
    NET_EM_CALIBRATEAREA_TYPE_GROUD,            // "Groud" : 地面,需要N条竖直线段+M条水平线段（（N=3,M=1）；（N=2,M=2）；今后扩展）。
    NET_EM_CALIBRATEAREA_TYPE_HORIZONTAL,       // "Horizontal"  : 水平面,需要水平面上一点到地面点的投影垂直线段。        
    NET_EM_CALIBRATEAREA_TYPE_VERTICAL,         // "Vertical" : 垂直面,需要垂直面与地面的交线。
    NET_EM_CALIBRATEAREA_TYPE_ANY,              // "Any" 任意平面,N条竖直线段,及每条长度（N=3,及今后扩展）。
}NET_EM_CALIBRATEAREA_TYPE;

// 浓缩后的输出资料子类型
typedef enum tagNET_EM_OUTPUT_SUB_TYPE
{
    NET_EM_OUTPUT_SUB_TYPE_ERR,
    NET_EM_OUTPUT_SUB_TYPE_NORMAL,              // 普通播放速度（父类型为浓缩视频时有效）
    NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS,            // 按浓缩后的播放速度（父类型为浓缩视频时有效）,在没有物体时快放,在物体出现时按正常速度播放
}NET_EM_OUTPUT_SUB_TYPE;

// 标尺信息
typedef struct tagNET_STAFF_INFO
{
    DH_POINT            stuStartLocation;       // 起始坐标点
    DH_POINT            stuEndLocation;         // 终止坐标点
    float               nLenth;                 // 实际长度,单位米
    NET_EM_STAFF_TYPE   emType;                 // 标尺类型
}NET_STAFF_INFO;

// 标定区域,普通场景使用
typedef struct tagNET_CALIBRATEAREA_INFO
{
    int                     nLinePoint;                         // 水平方向标尺线顶点数
    DH_POINT                stuLine[DH_MAX_POLYLINE_NUM];       // 水平方向标尺线
    float                   fLenth;                             // 实际长度
    DH_POLY_POINTS          stuArea;                            // 区域
    int                     nStaffNum;                          // 垂直标尺数
    NET_STAFF_INFO          stuStaffs[DH_MAX_STAFF_NUM];        // 垂直标尺         
    NET_EM_CALIBRATEAREA_TYPE emType;                           // 区域类型
}NET_CALIBRATEAREA_INFO;

typedef struct tagNET_LOCALFILE_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];               // 文件绝对路径
    NET_TIME			stuStartTime;						// 开始时间(设备本地时间)
    NET_TIME			stuEndTime;							// 结束时间(设备本地时间)
    UINT				nFileLength;						// 文件大小, 单位: 字节
}NET_LOCALFILE_INFO;

typedef struct tagNET_REMOTEFILE_INFO
{
    DWORD               dwSize;
    char                szIP[MAX_PATH];                     // 远程设备IP
    unsigned int        nPort;                              // 远程设备端口
    char                szName[DH_MAX_NAME_LEN];            // 登陆远程设备用户名
    char                szPassword[DH_MAX_NAME_LEN];        // 登陆远程设备密码
    BYTE                byProtocolType;                     // 远程设备使用的协议类型,2-私有二代,3-私有三代
    BYTE                byReserved[3];                      // 字节对齐
    char                szFilePath[MAX_PATH];               // 文件绝对路径,byProtocolType为3时有效
    int                 nStartCluster;                      // 起始簇号,byProtocolType为2时有效
    int                 nDriverNo;                          // 盘号,byProtocolType为2时有效
    NET_TIME			stuStartTime;						// 开始时间(设备本地时间)，优先使用磁盘号和分区号
	NET_TIME			stuEndTime;							// 结束时间(设备本地时间)，优先使用磁盘号和分区号
	int					nChannel;							// 录像通道号, 优先使用磁盘号和分区号
	NET_STREAM_TYPE		emStreamType;						// 码流类型, 只支持主码流和辅码流1/ 2
}NET_REMOTEFILE_INFO;

// 文件位置信息
typedef struct tagNET_FILEPATH_INFO
{
    DWORD               dwSize;
    BOOL                bFileType;                          // TRUE: 服务器本地文件; FALSE: 远程设备文件
    NET_LOCALFILE_INFO  stuLocalFile;                       // 本地文件信息, bFileType==TRUE有效
    NET_REMOTEFILE_INFO stuRemoteFile;                      // 远程文件信息, bFileType==FALSE有效
}NET_FILEPATH_INFO;

// 全局参数
typedef struct tagNET_GLOBAL_INFO
{
    DWORD                   dwSize;
    char                    szSceneType[DH_MAX_NAME_LEN];           // 应用场景,只支持"Normal"
    int                     nStaffNum;                              // 标尺数
    NET_STAFF_INFO          stuStaffs[DH_MAX_STAFF_NUM];            // 标尺    
    int                     nCalibrateAreaNum;                      // 标定区域数
    NET_CALIBRATEAREA_INFO  stuCalibrateArea[DH_MAX_CALIBRATEBOX_NUM]; // 标定区域(若该字段不存在,则以整幅场景为标定区域)
    int                     nJitter;                                // 摄像机抖动率 : 摄像机抖动率,取值0-100,反应静止摄像机抖动程度,抖动越厉害,值越大。
    BOOL                    bDejitter;                              // 是否开启去抖动模块
}NET_GLOBAL_INFO;

// 模块参数
typedef struct tagNET_MODULE_INFO
{
    DWORD               dwSize;                                     // 该结构体大小
    BYTE                bSensitivity;                               // 灵敏度,取值1-10,值越小灵敏度越低
    BYTE                bReserved[3];
    int                 nDetectRegionPoint;                         // 检测区域顶点数
    DH_POINT            stuDetectRegion[DH_MAX_POLYGON_NUM];        // 检测区域
    int                 nExcludeRegionNum;                          // 排除区域数
    DH_POLY_POINTS      stuExcludeRegion[DH_MAX_EXCLUDEREGION_NUM]; // 排除区域
}NET_MODULE_INFO;

// 物体过滤信息
typedef struct tagNET_OBJFILTER_INFO
{
    DWORD               dwSize;                             // 该结构体大小
    NET_TIME            stuStartTime;                       // 开始时间
    NET_TIME            stuEndTime;                         // 结束时间
    char                szObjectType[DH_MAX_NAME_LEN];      // 物体类型,支持以下:
                                                            //"Unknown", "Human", "Vehicle",
                                                            //"Fire", "Smoke", "Plate", "HumanFace", "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "Entity"
    char                szObjectSubType[64];                // 物体子类别,根据不同的物体类型,可以取以下子类型：
                                                            // Vehicle Category:"Unknown"  未知,"Motor" 机动车,"Non-Motor":非机动车,"Bus": 公交车,"Bicycle" 自行车,"Motorcycle":摩托车
                                                            // Plate Category："Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
                                                            // "Military" 部队号牌,"DoubleMilitary" 部队双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
                                                            // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
															// "Civilaviation"民航号牌,"Black"黑牌
															// "PureNewEnergyMicroCar"纯电动新能源小车,"MixedNewEnergyMicroCar,"混合新能源小车,"PureNewEnergyLargeCar",纯电动新能源大车
															// "MixedNewEnergyLargeCar"混合新能源大车
                                                            //  HumanFace Category:"Normal" 普通人脸,"HideEye" 眼部遮挡,"HideNose" 鼻子遮挡,"HideMouth" 嘴部遮挡
    DWORD               dwRGBMainColor[DH_MAX_COLOR_NUM];   // 物体主要颜色,物体为人时表示上半身颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000
    DWORD               dwLowerBodyColor[DH_MAX_COLOR_NUM]; // 物体为人时表示下半身颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000
    int                 nMinSize;                           // 物体最小尺寸, m
    int                 nMaxSize;                           // 物体最大尺寸, m
    int                 nMinSpeed;                          // 最小速度, km/h
    int                 nMaxSpeed;                          // 最大速度, km/h
    DWORD               dwRGBMainColorNum;                  // 当物体类型为人,标志dwRGBMainColor有效的颜色种类数
    DWORD               dwLowerBodyColorNum;                // 当物体类型为人且bRGBMainColor==true,标志下半身有效的颜色种类数
    BOOL                bRGBMainColor;                      // true-dwRGBMainColor表示上半身颜色,dwLowerBodyColor表示下半身颜色; false-dwRGBMainColor表示人主要颜色,dwLowerBodyColor无效
}NET_OBJFILTER_INFO;

// 规则参数
typedef struct tagNET_VIDEOSYNOPSISRULE_INFO
{
    DWORD               dwSize;                             // 该结构体大小
    BYTE                byOutputType;                       // 浓缩后输出资料的类型,1-视频大纲(一组快照);2-浓缩视频;3-既有快照又有视频
    BYTE                byDensity;                          // 密度, 1-10, 值越大, 浓缩密度越高
    bool                bShowTime;                          // 浓缩结果是否显示时标
    bool                bShowBox;                           // 浓缩结果是否显示物标
    bool                bEnableRecordResult;                // 浓缩结果是否记录入数据库
    BYTE                byTime;                             // 视频浓缩后时长,单位:分钟
    BYTE                byReserved[2];
    NET_OBJFILTER_INFO  stuFilter[MAX_OBJFILTER_NUM];       // 物体过滤信息
    DWORD               dwObjFilterNum;                     // 物体过滤信息数目

    // NET_OUT_QUERY_VIDEOSYNOPSIS和TYPE_CB_VIDEOSYNOPSIS_RULE回调解析时, 按照CFG_CMD_ANALYSERULE命令调用dhconfigsdk.dll中接口CLIENT_ParseData解析,得到对应的结构体,这时要先分配足够内存
    // NET_IN_ADD_VIDEOSYNOPSIS中,按照CFG_CMD_ANALYSERULE命令调用dhconfigsdk.dll中接口CLIENT_PacketData封装,得到此信息
    char*               szAnalyseRuleInfo;                  // JSON封装规则信息
    int                 nBufferLen;                         // TYPE_CB_VIDEOSYNOPSIS_RULE, NET_OUT_QUERY_VIDEOSYNOPSIS用时,申请的szAnalyseRuleInfo长度
    BOOL                bCustomResolution;                  // 自定义分辨率使能, TRUE-分辨率由emResolution确定, FALSE-根据原始视频分辨率生产浓缩视频
    CAPTURE_SIZE        emResolution;                       // 分辨率, bCustomResolution为TRUE才有效
    BOOL                bEnableMaxUsedCPU;                  // 是否最大化占有需求的CPU资源
    BOOL                bEnableSmoothBorder;                // 是否平滑目标边框
    NET_EM_OUTPUT_SUB_TYPE emOutputSubType;                 // 浓缩后输出资料的子类型,详见NET_EM_OUTPUT_SUB_TYPE
    int                 nExtractFrameRate;                  // 浓缩视频的抽帧速率    1-32,值越大,抽帧速率越高,客户端呈现的播放速度越快
                                                            // 该字段仅在浓缩后的输出资料子类型(emOutputSubType)是NET_EM_OUTPUT_SUB_TYPE_SYNOPSIS有效 
    //视频浓缩额外信息
    int                 nSynopsisSpeed;                     // 浓缩速度域值,共分1~10共十个档位,5表示浓缩后只保留5以上速度的物体。是个相对单位
                                                            // 为0时,该字段无效
    int                 nSynopsisSize;                      // 浓缩尺寸域值,共分1~10共十个档位,3表示浓缩后只保留3以上大小的物体。是个相对单位
                                                            // 为0时,该字段无效
    BOOL                bEnableDirection;                   // 为True时,对物体运动方向做过滤
                                                            // 为False时,不对物体运动方向做过滤,
    DH_POINT            stuSynopsisStartLocation;           // 浓缩运动方向,起始坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
    DH_POINT            stuSynopsisEndLocation;             // 浓缩运动方向,终止坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
}NET_VIDEOSYNOPSISRULE_INFO;

// 添加浓缩视频任务输入参数
typedef struct tagNET_IN_ADD_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // 该结构体大小
    NET_FILEPATH_INFO*      pFilePathInfo;                  // 文件位置信息,用户分配空间
															// 由用户分配内存,大小为sizeof(NET_FILEPATH_INFO)*dwFileCount
    DWORD                   dwFileCount;                    // 有效文件个数
    NET_GLOBAL_INFO         stuGlobalInfo;                  // 全局信息
    NET_MODULE_INFO         stuModuleInfo;                  // 模块信息
    NET_VIDEOSYNOPSISRULE_INFO stuRuleInfo;                 // 规则信息
    unsigned int        nWaitTime;                          // 等待超时时间,单位ms
}NET_IN_ADD_VIDEOSYNOPSIS;

// 添加浓缩视频任务输出参数
typedef struct tagNET_OUT_ADD_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // 该结构体大小
    DWORD*              pnTaskID;                           // TaskID数组,用户分配空间.按顺序一一对应添加任务的文件;等于0表示对应任务添加失败
    DWORD               nTaskIDCount;                       // TaskID个数
}NET_OUT_ADD_VIDEOSYNOPSIS;

// 浓缩视频预处理任务输入参数
typedef struct tagNET_IN_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD                   dwSize;                         // 该结构体大小
    NET_FILEPATH_INFO*      pFilePathInfo;                  // 文件位置信息,用户分配空间,大小为sizeof(NET_FILEPATH_INFO)*dwFileCount
    DWORD                   dwFileCount;                    // 有效文件个数
    unsigned int            nWaitTime;                      // 等待超时时间,单位ms
    char                    szTaskName[DH_COMMON_STRING_64];// 浓缩任务名称,可以为空 
}NET_IN_PRE_HANDLE_VIDEOSYNOPSIS;

// 浓缩视频预处理任务输出参数
typedef struct tagNET_OUT_PRE_HANDLE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // 该结构体大小
    DWORD*              pnTaskID;                           // TaskID数组,用户分配空间.按顺序一一对应添加任务的文件;等于0表示对应任务添加失败
															// 由用户分配内存，大小为sizeof(DWORD)*nTaskIDCount
	DWORD               nTaskIDCount;                       // TaskID个数
}NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS;

// 以视频通道为单位执行视频浓缩预处理任务入参
typedef struct tagNET_IN_PRETASK_BYCHANNEL
{
	DWORD				dwSize;
	int					nChannelCount;						// 下发通道个数
	int					nChannel[DH_PRETASK_CHANNEL];		// 下发通道
	NET_TIME			stuStartTime;						// 浓缩录像开始时间
	NET_TIME			stuEndTime;							// 浓缩录像结束时间
	unsigned int		nWaitTime;							// 等待超时时间
}NET_IN_PRETASK_BYCHANNEL;

// 以视频通道为单位执行视频浓缩预处理任务出参
typedef struct tagNET_OUT_PRETASK_BYCHANNEL
{
	DWORD				dwSize;
	int					nTaskCount;							// 需要申请的预处理任务ID个数
	int					nRealCount;							// 实际返回的预处理任务ID个数
	DWORD*              pnTaskID;							// 视频浓缩预处理任务ID, 与通道一一对应，大小为sizeof(DWORD)*nTaskCount
															// 0表示该任务添加创建失败；>0表示成功
}NET_OUT_PRETASK_BYCHANNEL;

// 获取浓缩任务进度入参
typedef struct tagNET_IN_GET_VIDEOSYNOPSIS_STATE
{
	DWORD				dwSize;
	unsigned int		nTaskID;							// 视频浓缩任务ID
	unsigned int		nWaitTime;							// 等待超时时间
}NET_IN_GET_VIDEOSYNOPSIS_STATE;

// 视频浓缩当前状态
typedef enum tagEM_VIDEOSYNOPSIS_STATE
{
	EM_VIDEOSYNOPSIS_STATE_UNKNOWN,							// 未知
	EM_VIDEOSYNOPSIS_STATE_SUCESSED,						// 浓缩成功
	EM_VIDEOSYNOPSIS_STATE_FAILED,							// 浓缩失败
	EM_VIDEOSYNOPSIS_STATE_PRETASK,							// 在addPreTask阶段
	EM_VIDEOSYNOPSIS_STATE_SYNO								// 在addSynoInfo阶段
}EM_VIDEOSYNOPSIS_STATE;

// 获取浓缩任务进度出参
typedef struct tagNET_OUT_GET_VIDEOSYNOPSIS_STATE
{
	DWORD						dwSize;
	int							nProcess;					// 单位: %百分数。空闲为-1
	EM_VIDEOSYNOPSIS_STATE		emState;					// 浓缩任务当前状态
}NET_OUT_GET_VIDEOSYNOPSIS_STATE;

// 开始查询智能录像浓缩历史入参
typedef struct tagNET_IN_VIDEOSYNOPSIS_STARTFIND
{
	DWORD						dwSize;
	int							nChannelCount;				// 视频通道个数
	int*						pnChannel;					// 视频通道号, 大小为sizeof(pnChannel)*nChannelCount;
	NET_TIME					stuStartTime;				// 开始时间
	NET_TIME					stuEndTime;					// 结束时间
	unsigned int				nWaitTime;					// 等待超时时间
}NET_IN_VIDEOSYNOPSIS_STARTFIND;

// 开始查询智能录像浓缩历史出参
typedef struct tagNET_OUT_VIDEOSYNOPSIS_STARTFIND
{
	DWORD						dwSize;
	int							nToken;						// 取到的查询令牌
	int							nTotalCount;				// 符合此次查询条件的结果总条数
}NET_OUT_VIDEOSYNOPSIS_STARTFIND;

// 获取历史搜索结果信息入参
typedef struct tagNET_IN_VIDEOSYNOPSIS_DOFIND
{
	DWORD						dwSize;
	int							nToken;						// 查询令牌
	int							nBeginNumber;				// 查询起始序号，表示从nBeginNumber条记录开始，取nCount条记录返回；
	int							nCount;						// 每次查询的结果个数
	unsigned int				nWaitTime;					// 等待超时时间
}NET_IN_VIDEOSYNOPSIS_DOFIND;

// 获取历史搜索结果信息
typedef struct tagNET_VIDEOSYNOPSIS_DOFIND_INFO
{
	int							nChannel;					// 录像通道
	NET_TIME					stuStartTime;				// 原始视频开始时间
	NET_TIME					stuEndTime;					// 原始视频结束时间
	int							nDisk;						// 磁盘号
	int							nPartition;					// 分区号
	int							nCluster;					// 簇号
	int							nFileLength;				// 浓缩视频的时间长度, 单位秒
	int							nFileSize;					// 浓缩视频文件长度, 下载时需要，单位K
	BOOL						bLocked;					// 是否被锁定
    NET_TIME					stuBeginWriteTime;			// 浓缩视频文件开始写入的时间
	NET_TIME					stuEndWriteTime;			// 浓缩视频文件结束写入的时间
	BYTE						byReserved[976];			// 保留字节
}NET_VIDEOSYNOPSIS_DOFIND_INFO;

// 获取历史搜索结果信息出参
typedef struct tagNET_OUT_VIDEOSYNOPSIS_DOFIND
{
	DWORD							dwSize;
	int								nMaxFind;				// 要查询的最大条数
	int								nRealFound;				// 实际查询到的条数
	NET_VIDEOSYNOPSIS_DOFIND_INFO*	pstuFindInfo;			// 查询信息，由用户申请，大小为sizeof(NET_VIDEOSYNOPSIS_DOFIND_INFO) * nMaxFind
}NET_OUT_VIDEOSYNOPSIS_DOFIND;

// 结束浓缩历史查询入参
typedef struct tagNET_IN_VIDEOSYNOPSIS_STOPFIND
{
	DWORD						dwSize;
	int							nToken;						// 查询令牌
	unsigned int				nWaitTime;					// 等待超时时间
}NET_IN_VIDEOSYNOPSIS_STOPFIND;

// 结束浓缩历史查询出参
typedef struct tagNET_OUT_VIDEOSYNOPSIS_STOPFIND
{
	DWORD						dwSize;
}NET_OUT_VIDEOSYNOPSIS_STOPFIND;

// 执行浓缩视频任务输入参数
typedef struct tagNET_IN_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD                       dwSize;                     // 该结构体大小
    DWORD                       nTaskID;                    // 任务ID,CLIENT_PreHandleVideoSynopsisTask接口输出函数返回
    NET_GLOBAL_INFO             stuGlobalInfo;              // 全局信息
    NET_MODULE_INFO             stuModuleInfo;              // 模块信息
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                // 规则信息
    unsigned int                nWaitTime;                  // 等待超时时间,单位ms
}NET_IN_RUN_VIDEOSYNOPSIS_TASK;

//  执行浓缩视频任务输出参数
typedef struct tagNET_OUT_RUN_VIDEOSYNOPSIS_TASK
{
    DWORD               dwSize;                             // 该结构体大小
    DWORD               nPlayID;                            // 回放ID,等于0表示接口失败,否则传入CLIENT_PlayBackBySynopsisFile接口用于回放视频
    DWORD               nTime;                              // 浓缩视频时长,单位:秒
}NET_OUT_RUN_VIDEOSYNOPSIS_TASK;

// 暂停视频浓缩任务输入参数
typedef struct tagNET_IN_PAUSE_VIDEOSYNOPSIS
{
    DWORD               dwSize;                             // 该结构体大小
    BOOL                bPause;                             // TRUE-表示暂停任务   FALSE-表示恢复任务 
    DWORD*              pnTaskID;                           // TaskID数组,用户分配空间,大小为sizeof(DWORD)*nTaskIDCount
    DWORD               nTaskIDCount;                       // TaskID个数
    DWORD               nWaitTime;                          // 等待超时时间,单位ms
}NET_IN_PAUSE_VIDEOSYNOPSIS;

//要移除的任务类型
typedef enum tagNET_SYNOPSIS_REMOVE_TYPE
{
    EM_SYNOPSIS_REMOVE_UNKNOW =0 , // 未知
    EM_SYNOPSIS_REMOVE_PRETASK   , // 预处理任务
    EM_SYNOPSIS_REMOVE_SYNO      , // 浓缩任务
}NET_SYNOPSIS_REMOVE_TYPE;

// 移除视频浓缩任务输入参数
typedef struct tagNET_IN_REMOVE_VIDEOSYNOPSIS
{
    DWORD                       dwSize;                            // 该结构体大小
    DWORD*                      pnTaskID;                          // TaskID数组,用户分配空间,大小为sizeof(DWORD)*nTaskIDCount
    DWORD                       nTaskIDCount;                      // TaskID个数
    DWORD                       nWaitTime;                         // 等待超时时间,单位ms
    NET_SYNOPSIS_REMOVE_TYPE    emRemoveType;                      // 要移除的任务类型
}NET_IN_REMOVE_VIDEOSYNOPSIS;

// 视频浓缩返回的物体信息
typedef struct tagNET_REAL_SYNOPSIS_OBJECT_INFO
{
    DWORD               dwSize;
    
    DWORD               dwTaskID;                       // 当前物体对应的任务ID
    DH_MSG_OBJECT_EX2   stuObjectInfo;                  // 物体具体信息
}NET_REAL_SYNOPSIS_OBJECT_INFO;

typedef struct tagNET_REAL_SYNOPSIS_STATE_INFO
{
    DWORD           dwSize;
    
    DWORD           dwTaskID;                           // 任务ID   
    int             nObjectNum;                         // 目前浓缩过程中已发现的物体数量
    int             nTaolProgress;                      // 当前浓缩源（整个过程的,含下载、准备、浓缩）的完成进度,0~100
    char            szState[DH_MAX_SYNOPSIS_STATE_NAME];// 对应视频浓缩状态,"Downloading"-正在下载","Synopsising"-正在浓缩",
                                                        // "DownloadFailed"-下载失败","DownloadSucceeded"-下载成功
                                                        // "SynopsisFailed"-浓缩失败","Succeeded"-浓缩成功
                                                        // "DownloadPause"-下载暂停,"SynopsisPause"-浓缩暂停
    int             nProgressOfCurrentState;            // 当前浓缩步骤对应的完成进度,0~100
    char            szFailedCode[DH_MAX_STRING_LEN];    // 失败码,szState="SynopsisFailed"有效
                                                        // "OutOfMemory" 内存不足;
                                                        // "TooMany_TargetInVideo"  整个视频目标数过多;
                                                        // "InvalidFilePointer" 文件指针无效;
                                                        // "InvalidFilePath" 文件路径无效;
                                                        // "CreateDirectoryFailed"  创建文件夹路径失败;
                                                        // "WriteDataFailed" 写Tube中间文件失败
                                                        // "DataSizeTooLarge" Tube文件太大
                                                        // "Detect_Nothing" 场景中无运动目标
                                                        // "OpenDataFailed" 打开中间文件失败
                                                        // "InvalidSynopsisBackgroud" 浓缩背景无效
                                                        // "ColorRetrieval" 错误的颜色检索配置
                                                        // "UnsupportRuleType" 不支持的规则类型
                                                        // "RuleNumberExceedLimit" 规则数超限
                                                        // "NoFunctionCfgInfo" 指定了相应功能但没有配置信息
                                                        // "FunctionNumberExceedLimit" 每条规则的功能数目数量超限
                                                        // "PointsExceedLimit" 线或者区域的点数超限
                                                        // "BadFunctionType" 错误的功能类型
                                                        // "RulePointNumber" 规则点数错误
                                                        // "MaskRegionNumberExceedLimit" 屏蔽区域数量超限
                                                        // "CameraSceneSwitch" 相机场景切换
                                                        // "TooManyTargeInFrame" 单帧中目标数过多
                                                        // "InalidSynopsisDesity" 浓缩密度无效
                                                        // "ExtrackColorFeatureFailed" 提取颜色特征失败
                                                        // "JpegEncodeFrameFailed" Jpeg编码失败
                                                        // "JpegParamRestFailed" Jpeg重置编码参数失败
                                                        // "JpegDecodeFrameFailed" Jpeg解码失败
                                                        // "RetrieveObjectIdInvalid" 检索目标ID无效
                                                        // "RetrieveImageInvalid" 检索图像无效
                                                        // "NetworkAnomaly" 映射盘网络异常
                                                        // "ObjectNumberLimit" 超过分析目标数目限制
                                                        // "CreateChannelFailed" 创建通道失败
                                                        // "ReadUGFileFailed" 读取UG文件失败
                                                        // "GetSynopsisInfoFailed" 获取浓缩视频信息失败
                                                        // "ObjectNumberExceedLimit" 场景中目标数目超过限制
                                                        // "RebuildBackgroudFailed" 重建背景失败
                                                        // "NotExistMiddleFile" 中间文件不存在
                                                        // "NotExistSourceFile" 原始文件不存在
                                                        // "NotDog" 没有加密狗
                                                        // "NotEnoughFreeDisk" 磁盘空间不够
                                                        // "StartDecodeFail" 开始解码失败
                                                        // "DecodeTimeOut" 解码等待超时
                                                        // "EncodeTimeOut" 编码等待超时
                                                        // "ExactTimeOut" 提取快照等待超时
                                                        // "ReadMidlleFileFail" 读取中间文件失败
                                                        // "ExactPictureFail" 提取图片失败

     char szPicPath[DH_COMMON_STRING_512];              // 预处理文件提取到的快照	文件路径
                                                        // 支持HTTP URL表示:"http://www.dahuate.com/1.jpg"
                                                        // 支持FTP URL表示: "ftp://ftp.dahuate.com/1.jpg"
                                                        // 支持服务器本地路径 
                                                        // a)"C:/pic/1.jpg" 
                                                        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int         nMaxTime;                               // 支持浓缩视频最大时间长度,单位 秒
    int         nMinTime;                               // 支持浓缩视频最小时间长度,单位 秒
    char		szVideoPath[DH_COMMON_STRING_512];		// 浓缩录像路径, 当前面的浓缩状态szState 为Succeeded 时有效
}NET_REAL_SYNOPSIS_STATE_INFO;

//视频浓缩物体信息实时回调函数
typedef int (CALLBACK *fVideoSynopsisObjData)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_OBJECT_INFO* pSynopsisObjectInfo, void* pBuf, int nBufLen, LDWORD dwUser, void* pReserved);

//视频浓缩进度状态实时回调函数
typedef int (CALLBACK *fVideoSynopsisState)(LLONG lRealLoadHandle, NET_REAL_SYNOPSIS_STATE_INFO* pSynopsisStateInfos, int nInfoCount, LDWORD dwUser, void* pReserved);

// CLIENT_RealLoadObjectData接口参数定义
typedef struct tagNET_IN_REALLOAD_OBJECTDATA
{
    DWORD               dwSize;                         // 结构体大小   
    int                 nTaskIDNum;                     // 任务ID个数
    DWORD               *pTaskIDs;                      // 具体任务ID,由用户分配内存，大小为sizeof(DWORD)*nTaskIDNum
    BOOL                bNeedPicFile;                   // 是否下载对应的图片文件 
    int                 nWaitTime;                      // 等待时间,单位ms
    fVideoSynopsisObjData cbVideoSynopsisObjData;       // 视频浓缩物体信息实时回调函数指针
    LDWORD         dwUser;
}NET_IN_REALLOAD_OBJECTDATA;

typedef struct tagNET_OUT_REALLOAD_OBJECTDATA
{
    DWORD               dwSize;                         // 结构体大小
    LLONG               lRealLoadHandle;                // 接口返回的订阅句柄,可唯一标识某个订阅
}NET_OUT_REALLOAD_OBJECTDATA;

// CLIENT_StopLoadObjectData接口参数定义
typedef struct tagNET_IN_STOPLOAD_OBJECTDATA
{
    DWORD               dwSize;
    int                 nTackIDNum;                     // 任务ID个数
    DWORD               *pTaskIDs;                      // 具体任务ID, 由用户分配内存，大小为sizeof(DWORD)*nTaskIDNum 
}NET_IN_STOPLOAD_OBJECTDATA;

// CLIENT_RealLoadSynopsisState接口参数定义
typedef struct tagNET_IN_REALLAOD_SYNOPSISSTATE
{
    DWORD               dwSize;                         // 结构体大小  
    int                 nTaskIDNum;                     // 任务ID个数, 0 表示订阅全部
    DWORD               *pTaskIDs;                      // 具体任务ID,由用户申请内存，大小为sizeof(DWORD)*nTaskIDNum 
    int                 nWaitTime;                      // 等待时间,单位ms
    fVideoSynopsisState cbVideoSynopsisState;           // 视频浓缩物体信息实时回调函数指针
    LDWORD         dwUser;
}NET_IN_REALLAOD_SYNOPSISSTATE;

typedef struct tagNET_OUT_REALLOAD_SYNOPSISSTATE
{
    DWORD               dwSize;                         // 结构体大小    
    LLONG               lRealLoadHandle;                // 接口返回的下载句柄,可唯一标识某个下载
}NET_OUT_REALLOAD_SYNOPSISSTATE;

// CLIENT_StopLoadSynopsisState接口参数定义
typedef struct tagNET_IN_STOPLOAD_SYNOPSISSTATE
{
    DWORD               dwSize;   
    int                 nTackIDNum;                     // 任务ID个数
    DWORD               *pTaskIDs;                      // 具体任务ID,由用户申请内存，大小为sizeof(DWORD)*nTaskIDNum   
}NET_IN_STOPLOAD_SYNOPSISSTATE;

// 浓缩视频信息的查找类型
typedef enum tagEM_VIDEOSYNOPSIS_QUERY_TYPE
{
    EM_VIDEOSYNOPSIS_TASK,                              // 任务信息
    EM_VIDEOSYNOPSIS_OBJ,                               // 物体对应的快照
}EM_VIDEOSYNOPSIS_QUERY_TYPE;

// 查询浓缩视频的任务信息的条件
typedef struct tagNET_QUERY_VSTASK_INFO
{
    DWORD                dwSize;                        // 该结构体大小
    DWORD                dwTaskID;                      // 该任务ID,为0时表示查询所有任务
}NET_QUERY_VSTASK_INFO;

// 浓缩物体颜色信息, 物体相对于某一颜色的相似度
typedef struct tagNET_VSO_COLORSIMILAR_INFO
{
	int					nRed;							// 红色相似度, 范围0到100, 0表示不关心该颜色
	int					nYellow;						// 黄色相似度, 范围0到100, 0表示不关心该颜色
	int					nGreen;							// 绿色相似度, 范围0到100, 0表示不关心该颜色
	int					nCyan;							// 青色相似度, 范围0到100, 0表示不关心该颜色
	int					nBlue;							// 蓝色相似度, 范围0到100, 0表示不关心该颜色
	int					nPurple;						// 紫色相似度, 范围0到100, 0表示不关心该颜色
	int					nBlack;							// 黑色相似度, 范围0到100, 0表示不关心该颜色
	int					nWhite;							// 白色相似度, 范围0到100, 0表示不关心该颜色
	BYTE				byReserved[512];				// 保留字节
} NET_VSO_COLORSIMILAR_INFO;

// 查询浓缩视频任务中物体信息的条件
typedef struct tagNET_QUERY_VSOBJECT_INFO
{
    DWORD                dwSize;                         // 该结构体大小
    DWORD*               pdwTaskID;                      // 物体所在任务的ID,为-1表示查询所有任务
    DWORD                dwTaskIDCount;                  // 有效的任务数目
    DH_MSG_OBJECT        stuObjInfo;                     // 物体信息,objectID为非0时表示查询该任务中所有物体
    int					 nSpeed;						 // 物体速度, 单位为km/h, -1表示不关心速度
    int					 nDirection;					 // 目标方向, 单位度, 范围为-1到360, 12点钟方向为0, 顺时针旋转, -1表示不关心方向
    NET_TIME_EX          stuStartTime;                   // 开始时间（设备本地时间）
    NET_TIME_EX          stuEndTime;                     // 结束时间（设备本地时间）
	NET_VSO_COLORSIMILAR_INFO	stuColorSimilarInfo;	 // 浓缩物体颜色信息, 物体相对于某一颜色的相似度
}NET_QUERY_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo接口输入参数定义
typedef struct tagNET_IN_QUERY_VIDEOSYNOPSIS
{
    DWORD                dwSize;                         // 该结构体大小
    EM_VIDEOSYNOPSIS_QUERY_TYPE emQueryType;             // 查找类型
    DWORD                dwCount;                        // 查询的条数
    DWORD                dwBeginNumber;                  // 查询起始序号    
    void*                pQueryInfo;                     // 查询条件信息,用户分配空间；
                                                         // 如果emQueryType==EM_VIDEOSYNOPSIS_TASK,对应NET_QUERY_VSTASK_INFO,大小为sizeof(NET_QUERY_VSTASK_INFO)*dwCount
                                                         // 如果emQueryType==EM_VIDEOSYNOPSIS_OBJ,对应NET_QUERY_VSOBJECT_INFO,大小为sizeof(NET_QUERY_VSOBJECT_INFO)*dwCount

    DWORD                dwWaitTime;                     // 等待超时时间,单位ms
}NET_IN_QUERY_VIDEOSYNOPSIS;

// 查询到的每个浓缩视频任务的信息
typedef struct tagNET_VSTASK_INFO
{
    DWORD                       dwSize;                             // 该结构体大小
    DWORD                       dwTaskID;                           // 任务ID
    NET_MODULE_INFO             stuModuleInfo;                      // 模块信息
    NET_VIDEOSYNOPSISRULE_INFO  stuRuleInfo;                        // 任务的规则信息
    NET_GLOBAL_INFO             stuGlobalInfo;                      // 全局参数
    NET_TIME                    stuCreateTime;                      // 任务的创建时间
    char                        szCurrState[DH_MAX_SYNOPSIS_STATE_NAME];  // 当前视频浓缩状态,"Downloading"-正在下载","Synopsising"-正在浓缩",
                                                                    // "DownloadFailed"-下载失败","DownloadSucceeded"-下载成功
                                                                    // "SynopsisFailed"-浓缩失败","Succeeded"-浓缩成功
                                                                    // "DownloadPause"-下载暂停,"SynopsisPause"-浓缩暂停
    char                        szCreateUser[DH_MAX_NAME_LEN];      // 创建任务的用户
    int                         nProgressOfCurrentState;            // 当前浓缩步骤对应的完成进度,0~100
    char                        szLocalFilePath[MAX_PATH];          // 本地文件路径或远端视频源文件下载后在本地的路径
    int                         nObjectNum;                         // 目前浓缩过程中已发现的物体数量
    NET_FILEPATH_INFO           stuVideoSourceFilePath;             // 源视频文件路径
    NET_FILEPATH_INFO           stuSynopsisVideoFilePath;           // 浓缩视频文件路径
    char                        szFailedCode[DH_MAX_STRING_LEN];    // 浓缩视频失败错误码,szCurrState为"SynopsisFailed"时有效
                                                                    // "OutOfMemory" 内存不足;
                                                                    // "TooMany_TargetInVideo"  整个视频目标数过多;
                                                                    // "InvalidFilePointer" 文件指针无效;
                                                                    // "InvalidFilePath" 文件路径无效;
                                                                    // "CreateDirectoryFailed"  创建文件夹路径失败;
                                                                    // "WriteDataFailed" 写Tube中间文件失败
                                                                    // "DataSizeTooLarge" Tube文件太大
                                                                    // "Detect_Nothing" 场景中无运动目标
                                                                    // "OpenDataFailed" 打开中间文件失败
                                                                    // "InvalidSynopsisBackgroud" 浓缩背景无效
                                                                    // "ColorRetrieval" 错误的颜色检索配置
                                                                    // "UnsupportRuleType" 不支持的规则类型
                                                                    // "RuleNumberExceedLimit" 规则数超限
                                                                    // "NoFunctionCfgInfo" 指定了相应功能但没有配置信息
                                                                    // "FunctionNumberExceedLimit" 每条规则的功能数目数量超限
                                                                    // "PointsExceedLimit" 线或者区域的点数超限
                                                                    // "BadFunctionType" 错误的功能类型
                                                                    // "RulePointNumber" 规则点数错误
                                                                    // "MaskRegionNumberExceedLimit" 屏蔽区域数量超限
                                                                    // "CameraSceneSwitch" 相机场景切换
                                                                    // "TooManyTargeInFrame" 单帧中目标数过多
                                                                    // "InalidSynopsisDesity" 浓缩密度无效
                                                                    // "ExtrackColorFeatureFailed" 提取颜色特征失败
                                                                    // "JpegEncodeFrameFailed" Jpeg编码失败
                                                                    // "JpegParamRestFailed" Jpeg重置编码参数失败
                                                                    // "JpegDecodeFrameFailed" Jpeg解码失败
                                                                    // "RetrieveObjectIdInvalid" 检索目标ID无效
                                                                    // "RetrieveImageInvalid" 检索图像无效
                                                                    // "NetworkAnomaly" 映射盘网络异常
                                                                    // "ObjectNumberLimit" 超过分析目标数目限制
                                                                    // "CreateChannelFailed" 创建通道失败
                                                                    // "ReadUGFileFailed" 读取UG文件失败
                                                                    // "GetSynopsisInfoFailed" 获取浓缩视频信息失败
                                                                    // "ObjectNumberExceedLimit" 场景中目标数目超过限制
                                                                    // "RebuildBackgroudFailed" 重建背景失败
                                                                    // "NotExistMiddleFile" 中间文件不存在
                                                                    // "NotExistSourceFile" 原始文件不存在
                                                                    // "NotDog" 没有加密狗
                                                                    // "NotEnoughFreeDisk" 磁盘空间不够
                                                                    // "StartDecodeFail" 开始解码失败
                                                                    // "DecodeTimeOut" 解码等待超时
                                                                    // "EncodeTimeOut" 编码等待超时
                                                                    // "ExactTimeOut" 提取快照等待超时
                                                                    // "ReadMidlleFileFail" 读取中间文件失败
                                                                    // "ExactPictureFail" 提取图片失败
    char                        szTaskName[DH_COMMON_STRING_64];    //  浓缩任务名称                           
}NET_VSTASK_INFO;

// 浓缩视频任务中每个物体信息
typedef struct tagNET_VSOBJECT_INFO
{
    DWORD                dwSize;                        // 该结构体大小
    DWORD                dwTaskID;                      // 物体对应任务ID
    DH_MSG_OBJECT        stuObjInfo;                    // 物体信息，建议使用stuObjInfoEx
    NET_FILEPATH_INFO    stuFilePathInfo;               // 物体对应的文件信息
    DWORD                dwFileLength;                  // 快照文件的字节数大小
    int					 nDirection;					// 目标方向, 单位度, 范围有效值[0,360], -1表示不关心方向, 12点钟方向为0, 顺时针旋转
	DH_MSG_OBJECT_EX2    stuObjInfoEx;					// 物体信息扩展
}NET_VSOBJECT_INFO;

//--CLIENT_QueryVideoSynopsisInfo接口输出参数定义
typedef struct tagNET_OUT_QUERY_VIDEOSYNOPSIS
{
    DWORD                dwSize;                        // 该结构体大小
    DWORD                dwTotalCount;                  // 符合此次查询条件的结果总条数
    DWORD                dwFoundCount;                  // 本次查询返回的条数
    void*                pResult;                       // 返回的信息,用户分配空间
                                                        // 如果emQueryType==EM_VIDEOSYNOPSIS_TASK,对应NET_VSTASK_INFO,大小为sizeof(NET_VSTASK_INFO)*dwMaxCount
                                                        // 如果emQueryType==EM_VIDEOSYNOPSIS_OBJ,对应NET_VSOBJECT_INFO,大小为sizeof(NET_VSOBJECT_INFO)*dwMaxCount
    DWORD                dwMaxCount;                    // 用户希望的结果的个数
}NET_OUT_QUERY_VIDEOSYNOPSIS;

// CLIENT_FindSynopsisFile接口参数定义 
// 浓缩相关文件查询类型
typedef enum tagNET_EM_QUERY_SYNOPSIS_FILE
{
    DH_FILE_QUERY_VIDEO,                                // 普通录像文件信息,对应查询结构体:NET_SYNOPSIS_QUERY_VIDEO_PARAM, 返回结果结构体:NET_SYNOPSISFILE_VIDEO_INFO
    DH_FILE_QUERY_SYNOPSISVIDEO,                        // 浓缩视频信息, 对应查询结构体:NET_QUERY_SYNOPSISVIDEO_PARAM,返回结果结构体:NET_QUERY_SYNOPSISVIDEO_INFO
}NET_EM_QUERY_SYNOPSIS_FILE;

typedef struct __NET_SYNOPSIS_QUERY_VIDEO_PARAM
{
    DWORD               dwSize;
    DWORD               dwQueryMask;                    // 查询类型掩码, 按照从低到高位,第一位按时间段、第二位按文件路径 
    NET_TIME            stuStartTime;                   // 开始时间    
    NET_TIME            stuEndTime;                     // 结束时间
    char                szFilePath[DH_MAX_SYNOPSIS_QUERY_FILE_COUNT][MAX_PATH];    // 待查询文件的绝对路径
    DWORD               dwFileCount;                    // 待查询文件的个数
}NET_SYNOPSIS_QUERY_VIDEO_PARAM;

typedef struct  
{
    DWORD               dwSize;
    int                 nTaskId;                        // 任务ID
    DWORD               dwOutPutTypeMask;               // 当前任务的输出类型,第1位.视频大纲(一组快照);第2位浓缩视频    
    char                szCurrentState[DH_MAX_SYNOPSIS_STATE_NAME]; // 当前浓缩状态
}NET_VIDEOSYNOPSIS_TASK_INFO;

// DH_FILE_QUERY_VIDEO 返回的录像文件信息
typedef struct
{
    DWORD               dwSize;
    unsigned int        nchannelId;                     // 通道号
    char                szFilePath[MAX_PATH];           // 文件路径
    unsigned int        nFileLenth;                     // 文件长度,字节为单位,该字段废弃，请使用nFileLengthEx
    NET_TIME            stuStarttime;                   // 开始时间
    NET_TIME            stuEndtime;                     // 结束时间
    unsigned int        nWorkDirSN;                     // 工作目录编号    
    unsigned int        nCluster;                       // 簇号                        
    BYTE                bHint;                          // 文件定位索引
    BYTE                bDriveNo;                       // 磁盘号
    BYTE                bReserved[18];                  // 保留字段
    int                 nTaskInfoNum;                   // 录像文件对应的浓缩任务个数
    NET_VIDEOSYNOPSIS_TASK_INFO stuTaskInfo[16];        // 具体浓缩任务信息
    //频浓缩文件相关信息
    char szSynopsisPicPath[DH_COMMON_STRING_512];       // 预处理文件提取到的快照	文件路径
                                                        // 支持HTTP URL表示:"http://www.dahuate.com/1.jpg"
                                                        // 支持FTP URL表示: "ftp://ftp.dahuate.com/1.jpg"
                                                        // 支持服务器本地路径 
                                                        // a)"C:/pic/1.jpg" 
                                                        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
    int                 nSynopsisMaxTime;               //支持浓缩视频最大时间长度,单位 秒
    int                 nSynopsisMinTime;               //支持浓缩视频最小时间长度,单位 秒
	INT64               nFileLengthEx;                  //文件长度扩展，支持文件长度大于4G，单位字节
}NET_SYNOPSISFILE_VIDEO_INFO;

// DH_FILE_QUERY_SYNOPSISVIDEO 浓缩视频文件查询参数
typedef struct __NET_QUERY_SYNOPSISVIDEO_PARAM
{
    DWORD               dwSize;
    int                 nTaskID;                        // 任务ID
}NET_QUERY_SYNOPSISVIDEO_PARAM;

// DH_FILE_QUERY_SYNOPSISVIDEO浓缩视频查询结果
typedef struct __NET_QUERY_SYNOPSISVIDEO_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // 文件路径
    unsigned int        nFileLenth;                     // 文件长度,该字段废弃，请使用nFileLengthEx
    int                 nDurationTime;                  // 持续时间,单位s
	INT64               nFileLengthEx;                  // 文件长度扩展，支持文件长度大于4G，单位字节
}NET_QUERY_SYNOPSISVIDEO_INFO;

// CLIENT_FindSynopsisFile 接口参数
typedef struct tagNET_IN_FIND_SYNOPSISFILE
{
    DWORD               dwSize;                          
    NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // 查询类型
    void*               pQueryCondition;                // 查询条件,由用户分配内存
														// 若查询类型为DH_FILE_QUERY_VIDEO,对应查询结构体:NET_SYNOPSIS_QUERY_VIDEO_PARAM,申请大小为sizeof(NET_SYNOPSIS_QUERY_VIDEO_PARAM)
														// 若查询类型为DH_FILE_QUERY_SYNOPSISVIDEO,对应查询结构体:NET_QUERY_SYNOPSISVIDEO_PARAM,申请大小为sizeof(NET_QUERY_SYNOPSISVIDEO_PARAM)
	int                 nWaitTime;                      // 等待超时时间,单位ms
}NET_IN_FIND_SYNOPSISFILE;

typedef struct tagNET_OUT_FIND_SYNOPSISFILE
{
    DWORD               dwSize;
    LLONG               lFindHandle;                    // 查询句柄         
}NET_OUT_FIND_SYNOPSISFILE;

// CLIENT_FindNextSynopsisFile 接口参数
typedef struct tagNET_IN_FINDNEXT_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nFileCount;                     // 待查询的文件条数
    NET_EM_QUERY_SYNOPSIS_FILE emQueryType;             // 查询类型
    void*               pSynopsisFileInfo;              // 文件信息存放缓冲,由用户申请内存，大小为nMaxlen										
    int                 nMaxlen;                        // 缓冲区大小
    int                 nWaitTime;                      // 等待超时时间,单位ms
}NET_IN_FINDNEXT_SYNOPSISFILE;

typedef struct tagNET_OUT_FINDNEXT_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nRetFileCount;                  // 接口实际返回的信息条数,返回值<nFileCount(输入参数)则相应时间段内的文件查询完毕
}NET_OUT_FINDNEXT_SYNOPSISFILE;

// 下载进度回调函数原形, nError表示在下载过程出现的错误,1-缓存不足,2-对返回数据的校验出错,3-下载当前文件失败,4-创建对应保存文件失败
typedef void (CALLBACK *fSynopsisFileDownLoadPosCB)(LLONG lDownLoadHandle, DWORD dwFileID, DWORD dwFileTotalSize, DWORD dwDownLoadSize, int nError, LDWORD dwUser, void* pReserved);

// CLIENT_DownLoadSynosisFile 接口参数
typedef  NET_DOWNLOADFILE_INFO NET_SYNOPSIS_DOWNLOADFILE_INFO;

typedef struct tagNET_IN_DOWNLOAD_SYNOPSISFILE
{
    DWORD               dwSize;
    int                 nFileCount;                     // 待下载文件数
    NET_SYNOPSIS_DOWNLOADFILE_INFO* pFileInfos;         // 待下载文件信息,由用户申请内存，大小为sizeof(NET_SYNOPSIS_DOWNLOADFILE_INFO)*nFileCount
    fSynopsisFileDownLoadPosCB cbPosCallBack;           // 进度回调函数
    LDWORD              dwUserData;                     // 用户数据
    int                 nWaitTime;                      // 等待超时时间,单位ms
}NET_IN_DOWNLOAD_SYNOPSISFILE;

typedef struct tagNET_OUT_DOWNLOAD_SYNOPSISFILE
{
    DWORD               dwSize;
    LLONG               lDownLoadHandle;                // 下载句柄
}NET_OUT_DOWNLOAD_SYNOPSISFILE;

// 文件(夹)路径信息
typedef struct    tagNET_SET_FILEPATH_INFO
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // 可以是文件夹路径,也可以是文件路径。目前浓缩视频服务器只支持dav格式的文件
}NET_SET_FILEPATH_INFO;

// CLIENT_SetFilePathInfo()接口输入参数
typedef struct tagNET_IN_SET_FILEPATHINFO
{
    DWORD                dwSize;
    DWORD                dwCount;                       // 添加的文件路径信息个数
    void*                pFilePathInfo;                 // 指向文件路径信息NET_SET_FILEPATH_INFO数组
														// 由用户申请内存，大小为sizeof(NET_SET_FILEPATH_INFO)*dwCount
    DWORD                dwWaitTime;                    // 等待超时时间,单位ms
}NET_IN_SET_FILEPATHINFO;


// fAddFileStateCB 参数
typedef struct tagNET_CB_ADDFILESTATE
{
    DWORD               dwSize;
    const char*         szFileName;                     // 文件名称
    const char*         szState;                        // 文件分析状态, "Successed",成功; "Failed",失败；
}NET_CB_ADDFILESTATE;

// 刻录设备回调函数原形, 每次1条,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAddFileStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_ADDFILESTATE* pBuf,  int nBufLen, LDWORD dwUser);

// CLIENT_AttacAddFileState()接口输入参数
typedef struct tagNET_IN_ADDFILE_STATE
{
    DWORD               dwSize;
    fAddFileStateCB     cbAttachState;                 // 监听增加文件状态回调
    LDWORD              dwUser;                        // 用户数据
}NET_IN_ADDFILE_STATE;
typedef struct tagNET_OUT_ADDFILE_STATE
{
    DWORD                dwSize;
}NET_OUT_ADDFILE_STATE;

///////////////////////////////////人脸识别模块相关结构体///////////////////////////////////////
typedef struct tagNET_UID_CHAR
{
    char szUID[DH_MAX_PERSON_ID_LEN];  //UID内容
}NET_UID_CHAR;

// CLIENT_OperateFaceRecognitionDB接口输入参数
typedef struct __NET_IN_OPERATE_FACERECONGNITIONDB
{
    DWORD             dwSize;
    EM_OPERATE_FACERECONGNITIONDB_TYPE emOperateType;  // 操作类型
    FACERECOGNITION_PERSON_INFO        stPersonInfo;   // 人员信息 

    //emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用,stPeronInfo字段无效
    DWORD            nUIDNum;                          //UID个数               
    NET_UID_CHAR     *stuUIDs;                         //人员唯一标识符,首次由服务端生成,区别于ID字段
										               // 由用户申请内存,大小为sizeof(NET_UID_CHAR)*nUIDNum
    // 图片二进制数据
    char              *pBuffer;                        // 缓冲地址
    int               nBufferLen;                      // 缓冲数据长度

	BOOL			  bUsePersonInfoEx;				   // 使用人员扩展信息
	FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;	   // 人员信息扩展
}NET_IN_OPERATE_FACERECONGNITIONDB;

// 错误代码，emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用
typedef enum tagEM_ERRORCODE_TYPE
{
    EM_ERRORCODE_TYPE_UNKNOWN = -1,               // 未知错误
    EM_ERRORCODE_TYPE_SUCCESS,               // 成功
    EM_ERRORCODE_TYPE_PERSON_NOT_EXIST,            // 人员不存在
    EM_ERRORCODE_TYPE_DATABASE_ERROR,             //  数据库操作失败
} EM_ERRORCODE_TYPE;

// CLIENT_OperateFaceRecognitionDB接口输出参数
typedef struct __NET_OUT_OPERATE_FACERECONGNITIONDB
{
    DWORD               dwSize;
	char				szUID[DH_MAX_PERSON_ID_LEN];	// 人员唯一标识符, 只有在操作类型为NET_FACERECONGNITIONDB_ADD时有效

    //emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用
    int                nErrorCodeNum; // 错误码个数
    EM_ERRORCODE_TYPE          emErrorCodes[MAX_ERRORCODE_NUM]; // 错误码
    // emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用
}NET_OUT_OPERATE_FACERECONGNITIONDB;

// CLIENT_BatchAppendFaceRecognition 接口输入参数
typedef struct tagNET_IN_BATCH_APPEND_FACERECONGNITION
{
    DWORD                           dwSize;             // 结构体大小
    UINT                            nPersonNum;         // 需要添加的人员数量
    FACERECOGNITION_PERSON_INFOEX   *pstPersonInfo;     // 人员信息，内存由用户申请，大小为nPersonNum * sizeof(FACERECOGNITION_PERSON_INFOEX)

    // 图片二进制数据
    char                            *pBuffer;           // 缓冲地址
    UINT                            nBufferLen;         // 缓冲数据长度
    BYTE                            bReserved[4];       // 字节对齐
} NET_IN_BATCH_APPEND_FACERECONGNITION;

// 批量添加人员结果信息
typedef struct tagNET_BATCH_APPEND_PERSON_RESULT
{
    UINT            nUID;               // 人员UID
    DWORD           dwErrorCode;        // 错误码信息
    BYTE            bReserved[512];     // 保留字段
} NET_BATCH_APPEND_PERSON_RESULT;

// CLIENT_BatchAppendFaceRecognition 接口输出参数
typedef struct tagNET_OUT_BATCH_APPEND_FACERECONGNITION
{
    DWORD                           dwSize;                 // 结构体大小
    UINT                            nResultNum;             // 批量添加结果个数，由用户指定，数值与NET_IN_BATCH_APPEND_FACERECONGNITION中的nPersonNum一致
    NET_BATCH_APPEND_PERSON_RESULT  *pstResultInfo;         // 批量添加结果信息
} NET_OUT_BATCH_APPEND_FACERECONGNITION;

// 以图搜图查询模式
typedef enum tagEM_FINDPIC_QUERY_MODE
{
    EM_FINDPIC_QUERY_UNKNOWN,               // 未知
    EM_FINDPIC_QUERY_PASSIVE,               // 被动查询
    EM_FINDPIC_QUERY_ACTIVE,                // 主动推送
} EM_FINDPIC_QUERY_MODE;

// 以图搜图结果上报排序方式
typedef enum tagEM_FINDPIC_QUERY_ORDERED
{
	EM_FINDPIC_QUERY_BY_SIMILARITY,			// 按相似度从高到底
	EM_FINDPIC_QUERY_BY_TIME_FORWARD,		// 按时间正序
	EM_FINDPIC_QUERY_BY_TIME_REVERSE,		// 按时间倒序
} EM_FINDPIC_QUERY_ORDERED;

typedef struct __NET_FACE_MATCH_OPTIONS
{
    DWORD               dwSize;
    unsigned int        nMatchImportant;               // 人员重要等级    1~10,数值越高越重要,(查询重要等级大于等于此等级的人员)
    EM_FACE_COMPARE_MODE emMode;                       // 人脸比对模式,详见EM_FACE_COMPARE_MODE
    int                 nAreaNum;                      // 人脸区域个数
    EM_FACE_AREA_TYPE   szAreas[MAX_FACE_AREA_NUM];    // 人脸区域组合,emMode为NET_FACE_COMPARE_MODE_AREA时有效
    int                 nAccuracy;                     // 识别精度(取值1~10,随着值增大,检测精度提高,检测速度下降。最小值为1 表示检测速度优先,最大值为10表示检测精度优先。 暂时只对人脸检测有效)
    int                 nSimilarity;                   // 相似度(必须大于该相识度才报告;百分比表示,1~100)
    int                 nMaxCandidate;                 // 报告的最大候选个数(根据相似度进行排序,取相似度最大的候选人数报告)
    EM_FINDPIC_QUERY_MODE emQueryMode;                 // 以图搜图查询模式
    EM_FINDPIC_QUERY_ORDERED emOrdered;				   // 以图搜图结果上报排序方式
}NET_FACE_MATCH_OPTIONS;

typedef struct __NET_FACE_FILTER_CONDTION
{
    DWORD               dwSize;
    NET_TIME            stStartTime;                   // 开始时间
    NET_TIME            stEndTime;                     // 结束时间
    char                szMachineAddress[MAX_PATH];    // 地点,支持模糊匹配    
    int                 nRangeNum;                     // 实际数据库个数     
    BYTE                szRange[MAX_FACE_DB_NUM];      // 待查询数据库类型,详见 EM_FACE_DB_TYPE
    EM_FACERECOGNITION_FACE_TYPE emFaceType;           // 待查询人脸类型,详见 EM_FACERECOGNITION
    int                 nGroupIdNum;                   // 人员组数   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // 人员组ID 
    NET_TIME            stBirthdayRangeStart;          // 生日起始时间
    NET_TIME            stBirthdayRangeEnd;            // 生日结束时间
	BYTE				byAge[MAX_AGE_NUM];			   // 年龄区间，当byAge[0]=0与byAge[1]=0时，表示查询全年龄
	BYTE				byReserved[2];				   // 保留字节对齐
	EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion[MAX_EMOTION_NUM];		// 表情条件
	int					nEmotionNum;				   // 表情条件的个数
    int                 nUIDNum;                       // 人员唯一标识数
    char                szUIDs[64][32];                // 人员唯一标识列表
}NET_FACE_FILTER_CONDTION;

#define MAX_SMALLPIC_NUM	32		// 最大小图张数

// CLIENT_StartFindFaceRecognition接口输入参数
typedef struct __NET_IN_STARTFIND_FACERECONGNITION
{
    DWORD               dwSize;
    BOOL                bPersonEnable;                  // 人员信息查询条件是否有效
    FACERECOGNITION_PERSON_INFO stPerson;               // 人员信息查询条件
    NET_FACE_MATCH_OPTIONS stMatchOptions;              // 人脸匹配选项
    NET_FACE_FILTER_CONDTION stFilterInfo;              // 查询过滤条件
  
    // 图片二进制数据
    char                *pBuffer;                       // 缓冲地址
    int                 nBufferLen;                     // 缓冲数据长度

    int                 nChannelID;                     // 通道号         

    BOOL                bPersonExEnable;                // 人员信息查询条件是否有效, 并使用扩展结构体
    FACERECOGNITION_PERSON_INFOEX   stPersonInfoEx;     // 人员信息扩展
    int                 nSmallPicIDNum;                 // 小图ID数量
    int                 nSmallPicID[MAX_SMALLPIC_NUM];  // 小图ID
    EM_OBJECT_TYPE      emObjectType;                   // 搜索的目标类型 
}NET_IN_STARTFIND_FACERECONGNITION;

// CLIENT_StartFindFaceRecognition接口输出参数
typedef struct __NET_OUT_STARTFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nTotalCount;                   // 返回的符合查询条件的记录个数 
                                                       // -1表示总条数未生成,要推迟获取
                                                       // 使用CLIENT_AttachFaceFindState接口状态

    LLONG               lFindHandle;                   // 查询句柄
    int                 nToken;                        // 获取到的查询令牌
}NET_OUT_STARTFIND_FACERECONGNITION;


// CLIENT_StartMultiFindFaceRecognition 接口输入参数
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int*                pChannelID;                    //  通道号
    int                 nChannelCount;                  //  通道申请个数
    BOOL                bPersonEnable;                 // 人员信息查询条件是否有效
    FACERECOGNITION_PERSON_INFO stPerson;              // 人员信息查询条件
    NET_FACE_MATCH_OPTIONS stMatchOptions;             // 人脸匹配选项
    NET_FACE_FILTER_CONDTION stFilterInfo;             // 查询过滤条件

    // 图片二进制数据
    char                *pBuffer;                      // 缓冲地址
    int                 nBufferLen;                    // 缓冲数据长度

    BOOL                bPersonExEnable;               // 人员信息查询条件是否有效, 并使用人员信息扩展结构体
    FACERECOGNITION_PERSON_INFOEX   stPersonInfoEx;     // 人员信息扩展
    EM_OBJECT_TYPE      emObjectType;                   // 搜索的目标类型 
}NET_IN_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognition 接口输出参数
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nTotalCount;                    // 返回的符合查询条件的记录个数 
														// -1表示总条数未生成,要推迟获取
														// 使用CLIENT_AttachFaceFindState接口状态
	
	LLONG               lFindHandle;                   // 查询句柄
    int                 nToken;                        // 获取到的查询令牌
}NET_OUT_STARTMULTIFIND_FACERECONGNITION;

// CLIENT_StartMultiFindFaceRecognitionRecord 输入参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD
{
    DWORD               dwSize;                         // 结构体大小
	
    // 查询过滤条件
    NET_TIME            stStartTime;                    // 开始时间
    NET_TIME            stEndTime;                      // 结束时间
    char                szMachineAddress[MAX_PATH];     // 地点,支持模糊匹配     
    int                 nAlarmType;                     // 待查询报警类型,详见 EM_FACERECOGNITION_ALARM_TYPE
    BOOL                abPersonInfo;                   // 人员信息是否有效
    FACERECOGNITION_PERSON_INFO stPersonInfo;           // 人员信息
    int*                pChannelID;                     // 通道号
	int					nChannelCount;					// 通道个数
    int                 nGroupIdNum;                    // 人员组数   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // 人员组ID 

	BOOL                abPersonExInfo;                 // 人员信息是否有效, 并使用人员信息扩展结构体
	FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;		//  人员信息扩展
}NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD;

// CLIENT_StartMultiFindFaceRecognitionRecord 输出参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                    // 返回的符合查询条件的记录个数 
														// -1表示总条数未生成,要推迟获取
														// 使用CLIENT_AttachFaceFindState接口状态
	LLONG               lFindHandle;                   // 查询句柄
	int                 nToken;                        // 获取到的查询令牌
}NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD;

//CLIENT_DoFindFaceRecognitionRecord 输入参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_IN_DOFIND_FACERECONGNITIONRECORD
{
	DWORD               dwSize;
    int                 nTotalCount;                    // 查询条件的记录个数 
	LLONG               lFindHandle;                    // 查询句柄 
	int					nBeginNumber;					// 查询起始序号，表示从beginNumber条记录开始，取count条记录返回；
}NET_IN_DOFIND_FACERECONGNITIONRECORD;

// 人脸识别信息数据
typedef struct tagNET_DOFIND_FACERECONGNITIONRECORD_INFO
{
    BOOL                    bGlobalScenePic;                        // 全景图是否存在
    NET_PIC_INFO			stGlobalScenePic;                       // 全景图片文件路径
    DH_MSG_OBJECT           stuObject;                              // 目标人脸物体信息
    NET_PIC_INFO			stObjectPic;                            // 目标人脸文件路径
    int                     nCandidateNum;                          // 当前人脸匹配到的候选对象数量
    CANDIDATE_INFO          stuCandidates[DH_MAX_CANDIDATE_NUM];    // 当前人脸匹配到的候选对象信息
    NET_CANDIDAT_PIC_PATHS_EX  stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // 当前人脸匹配到的候选对象图片文件路径
    NET_TIME                stTime;                                 // 报警发生时间  
    char                    szAddress[MAX_PATH];                    // 报警发生地点
    int                     nChannelId;                             // 通道号 
	BYTE					bReserved[256];							// 保留
}NET_DOFIND_FACERECONGNITIONRECORD_INFO;

//CLIENT_DoFindFaceRecognitionRecord 输出参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_OUT_DOFIND_FACERECONGNITIONRECORD
{
	DWORD											dwSize;
	NET_DOFIND_FACERECONGNITIONRECORD_INFO			*stuResults;		// 返回的人脸识别信息数据(内存申请释放由用户管理)
	int												nResultNum;			// 申请的人脸识别信息的内存个数
	int												nTotalCount;		// 实际返回个数
}NET_OUT_DOFIND_FACERECONGNITIONRECORD;

//CLIENT_DoFindFaceRecognitionRecordEx 输入参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_IN_DOFIND_FACERECONGNITIONRECORD_EX
{
	DWORD               dwSize;
    int                 nTotalCount;                    // 每次需要获取的条数
	LLONG               lFindHandle;                    // 查询句柄 
	int					nBeginNumber;					// 查询起始序号，表示从beginNumber条记录开始，取count条记录返回；
}NET_IN_DOFIND_FACERECONGNITIONRECORD_EX;

// 人脸识别信息数据扩展
typedef struct tagNET_DOFIND_FACERECONGNITIONRECORD_INFO_EX
{
    BOOL                    bGlobalScenePic;                        // 全景图是否存在
    NET_PIC_INFO			stGlobalScenePic;                       // 全景图片文件路径
    DH_MSG_OBJECT           stuObject;                              // 目标人脸物体信息
    NET_PIC_INFO			stObjectPic;                            // 目标人脸文件路径
    int                     nCandidateNum;                          // 当前人脸匹配到的候选对象数量
    CANDIDATE_INFOEX        stuCandidates[DH_MAX_CANDIDATE_NUM];    // 当前人脸匹配到的候选对象信息
    NET_CANDIDAT_PIC_PATHS_EX  stuCandidatesPic[DH_MAX_CANDIDATE_NUM]; // 当前人脸匹配到的候选对象图片文件路径
    NET_TIME                stTime;                                 // 报警发生时间  
    char                    szAddress[MAX_PATH];                    // 报警发生地点
    int                     nChannelId;                             // 通道号 
	BYTE					bReserved[1024];							// 保留
}NET_DOFIND_FACERECONGNITIONRECORD_INFO_EX;

//CLIENT_DoFindFaceRecognitionRecordEx 输出参数(对应的开始识别人脸多通道查询)
typedef struct tagNET_OUT_DOFIND_FACERECONGNITIONRECORD_EX
{
	DWORD											dwSize;
	NET_DOFIND_FACERECONGNITIONRECORD_INFO_EX		*pstResults;		// 返回的人脸识别信息数据(内存申请释放由用户管理)
	int												nMaxResultNum;		// 申请的人脸识别信息的内存个数
	int												nRetResultNum;		// 实际返回个数
}NET_OUT_DOFIND_FACERECONGNITIONRECORD_EX;

#define MAX_FIND_COUNT  20

// 查询结果返回图片的格式
typedef enum tagEM_NEEDED_PIC_RETURN_TYPE
{
    EM_NEEDED_PIC_TYPE_UNKOWN,            // 未知类型
    EM_NEEDED_PIC_TYPE_HTTP_URL,          // 返回图片HTTP链接
    EM_NEEDED_PIC_TYPE_BINARY_DATA,       // 返回图片二进制数据
    EM_NEEDED_PIC_TYPE_HTTP_AND_BINARY,   // 返回二进制和HTTP链接
}EM_NEEDED_PIC_RETURN_TYPE;

// CLIENT_DoFindFaceRecognition 接口输入参数
typedef struct __NET_IN_DOFIND_FACERECONGNITION
{
    DWORD               dwSize;
    LLONG               lFindHandle;                    // 查询句柄
    int                 nBeginNum;                      // 查询起始序号
    int                 nCount;                         // 当前想查询的记录条数 
    EM_NEEDED_PIC_RETURN_TYPE   emDataType;             // 指定查询结果返回图片的格式
}NET_IN_DOFIND_FACERECONGNITION;

// CLIENT_DoFindFaceRecognition接口输出参数
typedef struct __NET_OUT_FINDNEXT_FACERECONGNITION
{
    DWORD               dwSize;
    int                 nCadidateNum;                   // 实际返回的候选信息结构体个数
    CANDIDATE_INFO      stCadidateInfo[MAX_FIND_COUNT]; // 候选信息数组
    
    // 图片二进制数据
    char                *pBuffer;                       // 缓冲地址
    int                 nBufferLen;                     // 缓冲数据长度

    BOOL                bUseCandidatesEx;               // 是否使用候选对象扩展结构体, 
                                                        // 若为TRUE, 则表示使用stuCandidatesEx, 且stuCandidates无效, 否则相反
    int                 nCadidateExNum;                 // 实际返回的候选信息结构体个数
    CANDIDATE_INFOEX    stuCandidatesEx[MAX_FIND_COUNT];// 当前人脸匹配到的候选对象信息, 实际返回个数同nCandidateNum
}NET_OUT_DOFIND_FACERECONGNITION;

// 眼镜状态
typedef enum tagEM_GLASSES_STATE
{
    EM_GLASSES_STATE_UNKNOWN,       // 未知
    EM_GLASSES_STATE_NO,            // 不戴
    EM_GLASSES_STATE_WEAR,          // 戴
} EM_GLASSES_STATE;

// 历史库人员信息
typedef struct tagNET_HISTORY_PERSON_INFO
{
    char                		szUID[DH_MAX_PERSON_ID_LEN];                    // 人员唯一标识符,首次由服务端生成,区别于ID字段
                                                                        		// 修改,删除操作时必填
    EM_SEX_TYPE                 emSexType;                                      // 性别  
    UINT                        nAge;                                           // 年龄, 0表示未知
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE	emEmotion;							// 表情
    EM_GLASSES_STATE            emGlassesState;                                 // 眼镜状态
    EM_GLASSES_TYPE             emGlassesType;                                  // 眼镜类型
    EM_RACE_TYPE                emRace;                                         // 种族
    EM_EYE_STATE_TYPE			emEye;											// 眼睛状态
    EM_MOUTH_STATE_TYPE			emMouth;										// 嘴巴状态
	EM_MASK_STATE_TYPE 			emMask;											// 口罩状态
	EM_BEARD_STATE_TYPE			emBeard;										// 胡子状态
	int							nAttractive;									// 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
    UINT                		nFacePicNum;                                    // 图片张数
    NET_FACE_IMAGE_INFO         stuFacePicInfo[DH_MAX_PERSON_IMAGE_NUM];        // 当前人员对应的图片信息
    BYTE                        bReserved[2048];					            // 预留字节数
} NET_HISTORY_PERSON_INFO;

// 历史库以图搜图主动上报的候选人信息
typedef struct tagNET_HISTORY_ACTIVE_CANDIDATE
{
    UINT                    nSimilarity;                    // 相似度
    int                     nChannelID;                     // 抓拍通道号
    NET_HISTORY_PERSON_INFO stuHistoryPerson;               // 历史库人员信息
    NET_TIME                stuTime;                        // 查询人员出现的时间
    NET_FACE_IMAGE_INFO		stuSceneImage;					// 人脸全景图
    BYTE                    bReserved[1236];					// 预留字节数
} NET_HISTORY_ACTIVE_CANDIDATE;

#define MAX_CANDIDATE_NUM        50      // 候选人员最大数量

// 历史库以图搜图主动上报结果信息
typedef struct tagNET_RESULT_OF_FINDHISTORY_BYPIC
{
    UINT                            nSmallPicID;                            // 小图ID
    UINT                            nPictureID;                             // 人脸图ID
    UINT                            nCandidateNum;                          // 候选人员数量
    NET_HISTORY_ACTIVE_CANDIDATE    stuCandidateInfo[MAX_CANDIDATE_NUM];    // 候选人员信息
    BYTE                            bReserved[1024];				        // 预留字节数
} NET_RESULT_OF_FINDHISTORY_BYPIC;

#define MAX_FINDPERSON_RESULT_NUM       32 // 以图搜图主动上报结果最大数量
// 历史库以图搜图回调信息
typedef struct tagNET_CB_RESULT_OF_FIND_HISTORY_BYPIC
{
    UINT                                nToken;                                         // 查询令牌
    UINT                                nProgress;                                      // 查询进度百分比
    UINT                                nTotalCount;                                    // 满足条件的总条数
    int                                 nHistoryResultNum;                              // 历史库以图搜图查询结果数量
    NET_RESULT_OF_FINDHISTORY_BYPIC     stuHistoryResult[MAX_FINDPERSON_RESULT_NUM];    // 历史库以图搜图查询结果信息
    BYTE                                bReserved[1024];				        // 预留字节数
} NET_CB_RESULT_OF_FIND_HISTORY_BYPIC;

// 订阅历史库以图搜图回调函数原型, lAttachHandle为CLIENT_AttachResultOfFindHistoryByPic接口的返回值
typedef void (CALLBACK *fResultOfFindHistory)(LLONG lAttachHandle, NET_CB_RESULT_OF_FIND_HISTORY_BYPIC* pstesult, const char *pBinBuf, int nBinBufLen, LDWORD dwUser);

// CLIENT_AttachResultOfFindHistoryByPic接口输入参数
typedef struct tagNET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC
{
    DWORD                   dwSize;                     // 结构体大小
    UINT                    nToken;                     // 查询令牌, 由CLIENT_StartFindFaceRecognition返回
    fResultOfFindHistory    cbResultOfFindHistory;      // 订阅历史库以图搜图回调函数
    LDWORD                  dwUser;                     // 用户数据
} NET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC;

// CLIENT_AttachResultOfFindHistoryByPic接口输出参数
typedef struct tagNET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC
{
    DWORD                   dwSize;                     // 结构体大小
} NET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC;

// 人体历史库以图搜图主动上报的候选人信息
typedef struct tagNET_HUMANHISTORY_CANDIDATE
{
    UINT                    nSimilarity;                    // 相似度
    int                     nChannelID;                     // 抓拍通道号
    NET_HISTORY_HUMAN_INFO  stuHistoryHuman;                // 历史库人体信息
    NET_TIME                stuTime;                        // 查询人员出现的时间
    NET_FACE_IMAGE_INFO		stuSceneImage;					// 人体全景图
    BYTE                    bReserved[748];				    // 预留字节数
} NET_HUMANHISTORY_CANDIDATE;

// 人体历史库以图搜图主动上报结果信息
typedef struct tagNET_RESULT_OF_HUMANHISTORY_BYPIC
{
    UINT                            nSmallPicID;                            // 小图ID
    UINT                            nPictureID;                             // 人脸图ID
    NET_HUMANHISTORY_CANDIDATE      stuCandidateInfo[50];                   // 候选人员信息
    UINT                            nCandidateNum;                          // 候选人员数量
    BYTE                            bReserved[1028];				        // 预留字节数
} NET_RESULT_OF_HUMANHISTORY_BYPIC;


// 人体历史库以图搜图回调信息
typedef struct tagNET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC
{
    UINT                                nToken;                                         // 查询令牌
    UINT                                nProgress;                                      // 查询进度百分比
    UINT                                nTotalCount;                                    // 满足条件的总条数
    int                                 nHistoryResultNum;                              // 历史库以图搜图查询结果数量
    NET_RESULT_OF_HUMANHISTORY_BYPIC    stuHistoryResult[32];                           // 历史库以图搜图查询结果信息
    BYTE                                bReserved[1024];				                // 预留字节数
} NET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC;


// 订阅人体历史库以图搜图回调函数原型, lAttachHandle为CLIENT_AttachResultOfHumanHistoryByPic接口的返回值
typedef void (CALLBACK *fResultOfHumanHistory)(LLONG lAttachHandle, NET_CB_RESULT_OF_HUMAN_HISTORY_BYPIC* pstesult, const char *pBinBuf, int nBinBufLen, LDWORD dwUser);

// CLIENT_AttachResultOfHumanHistoryByPic 接口输入参数
typedef struct tagNET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC
{
    DWORD                   dwSize;                     // 结构体大小
    UINT                    nToken;                     // 查询令牌, 由CLIENT_StartFindFaceRecognition返回
    fResultOfHumanHistory   cbResultOfHumanHistory;     // 订阅人体历史库以图搜图回调函数
    LDWORD                  dwUser;                     // 用户数据
} NET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC;

// CLIENT_AttachResultOfHumanHistoryByPic 接口输出参数
typedef struct tagNET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC
{
    DWORD                   dwSize;                     // 结构体大小
} NET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC;

// CLIENT_DetectFace接口输入参数
typedef struct __NET_IN_DETECT_FACE
{
    DWORD               dwSize; 
    DH_PIC_INFO         stPicInfo;                     // 大图信息

    // 图片二进制数据
    char                *pBuffer;                      // 缓冲地址
    int                 nBufferLen;                    // 缓冲数据长度
}NET_IN_DETECT_FACE;

// CLIENT_DetectFace接口输出参数
typedef struct __NET_OUT_DETECT_FACE
{
    DWORD               dwSize; 
    DH_PIC_INFO         *pPicInfo;                     // 检测出的人脸图片信息,由用户申请空间,大小为sizeof(DH_PIC_INFO)*nMaxPicNum
    int                 nMaxPicNum;                    // 最大人脸图片信息个数
    int                 nRetPicNum;                    // 实际返回的人脸图片个数 
    
    // 图片二进制数据
    char                *pBuffer;                      // 缓冲地址,由用户申请空间,存放检测出的人脸图片数据
    int                 nBufferLen;                    // 缓冲数据长度
}NET_OUT_DETECT_FACE;

// 人员组操作枚举
typedef enum tagEM_OPERATE_FACERECONGNITION_GROUP_TYPE
{
    NET_FACERECONGNITION_GROUP_UNKOWN,
    NET_FACERECONGNITION_GROUP_ADD,                     // 添加人员组信息
    NET_FACERECONGNITION_GROUP_MODIFY,                  // 修改人员组信息  
    NET_FACERECONGNITION_GROUP_DELETE,                  // 删除人员组信息
}EM_OPERATE_FACERECONGNITION_GROUP_TYPE;

// 人员组信息
typedef struct tagNET_FACERECONGNITION_GROUP_INFO
{
    DWORD               		dwSize;
    EM_FACE_DB_TYPE     		emFaceDBType;							// 人员组类型,详见 EM_FACE_DB_TYPE
    char                		szGroupId[DH_COMMON_STRING_64];			// 人员组ID,唯一标识一组人员(不可修改,添加操作时无效)
    char                		szGroupName[DH_COMMON_STRING_128];		// 人员组名称 
    char                		szGroupRemarks[DH_COMMON_STRING_256];	// 人员组备注信息
    int                 		nGroupSize;								// 当前组内人员数
    int							nRetSimilarityCount;					// 实际返回的库相似度阈值个数
	int							nSimilarity[MAX_SIMILARITY_COUNT];		// 库相似度阈值，人脸比对高于阈值认为匹配成功
	int							nRetChnCount;							// 实际返回的通道号个数
	int							nChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// 当前组绑定到的视频通道号列表
	UINT						nFeatureState[MAX_FEATURESTATE_NUM];	// 人脸组建模状态信息:
																		// [0]-准备建模的人员数量，不保证一定建模成功
																		// [1]-建模失败的人员数量，图片不符合算法要求，需要更换图片
																		// [2]-已建模成功人员数量，数据可用于算法进行人脸识别
																		// [3]-曾经建模成功，但因算法升级变得不可用的数量，重新建模就可用
	EM_REGISTER_DB_TYPE			emRegisterDbType;						// 注册库类型
}NET_FACERECONGNITION_GROUP_INFO;

// 添加人员组信息
typedef struct tagNET_ADD_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;      // 人员组信息 
}NET_ADD_FACERECONGNITION_GROUP_INFO;

// 删除人员组信息
typedef struct tagNET_DELETE_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64];// 人员组ID,唯一标识一组人员
}NET_DELETE_FACERECONGNITION_GROUP_INFO;

// 修改人员组信息
typedef struct tagNET_MODIFY_FACERECONGNITION_GROUP_INFO
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO stuGroupInfo;      // 人员组信息 
}NET_MODIFY_FACERECONGNITION_GROUP_INFO;

// CLIENT_OperateFaceRecognitionGroup接口输入参数
typedef struct tagNET_IN_OPERATE_FACERECONGNITION_GROUP
{
    DWORD               dwSize;
    EM_OPERATE_FACERECONGNITION_GROUP_TYPE emOperateType; // 操作类型
    void                *pOPerateInfo;                    // 相关操作信息,由用户申请内存，申请大小参照操作类型对应的结构体
														  // 若操作类型为NET_FACERECONGNITION_GROUP_ADD,对应结构体为NET_ADD_FACERECONGNITION_GROUP_INFO;
														  // 若操作类型为NET_FACERECONGNITION_GROUP_MODIFY,对应结构体为NET_MODIFY_FACERECONGNITION_GROUP_INFO
														  // 若操作类型为NET_FACERECONGNITION_GROUP_DELETE,对应结构体为NET_DELETE_FACERECONGNITION_GROUP_INFO
}NET_IN_OPERATE_FACERECONGNITION_GROUP;   

// CLIENT_OperateFaceRecognitionGroup接口输出参数
typedef struct tagNET_OUT_OPERATE_FACERECONGNITION_GROUP
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64]; // 新增记录的人员组ID,唯一标识一组人员
}NET_OUT_OPERATE_FACERECONGNITION_GROUP;   

// 获取人员类型最大个数
#define MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE		64

// CLIENT_GetFaceRecognitionPersonType接口输入参数
typedef struct tagNET_IN_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;				// 结构体大小
} NET_IN_GET_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_GetFaceRecognitionPersonType接口输出参数
typedef struct tagNET_OUT_GET_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;																		// 结构体大小
    char                szPersonType[MAX_FACE_RECOGNITION_SERVER_PERSON_TYPE][DH_COMMON_STRING_16];	// 人员类型
	int					nPersonTypeNum;																// 实际返回的人员类型个数
	BYTE                byDefault[DH_COMMON_STRING_16];												// 人员类型,详见 EM_PERSON_TYPE
	int					nDefaultNum;																// 返回人员个数
} NET_OUT_GET_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_GetDevCaps 对应的类型(NET_FACERECOGNITIONSE_CAPS) 输入参数
typedef struct tagNET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD               dwSize;				// 结构体大小
} NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY; 

// 人脸检测框颜色
typedef struct tagNET_FACEBOXCOLOR_CAPS
{
	BOOL				bSupport;				// 是否支持人脸检测框颜色上报
	NET_COLOR_RGBA		stuDefaultColor;		// 默认颜色
	BYTE				byReserved[1024];		// 保留
}NET_FACEBOXCOLOR_CAPS;

// 是否支持以图搜图
typedef enum tagEM_SUPPORT_SEARCH_BY_PIC
{
    EM_SUPPORT_SEARCH_BY_PIC_UNKNOWN,       // 未知, IVSS, NVR, DVR大概率支持人脸以图搜图，IPC-FR不支持
    EM_SUPPORT_SEARCH_BY_PIC_UNSUPPORT,     //不支持
    EM_SUPPORT_SEARCH_BY_PIC_SUPPORT,       // 支持
} EM_SUPPORT_SEARCH_BY_PIC;

// CLIENT_GetDevCaps 对应的类型(NET_FACERECOGNITIONSE_CAPS)输出参数
typedef struct tagNET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY
{
    DWORD                       dwSize;                 // 结构体大小
    BOOL                        bmultiFind;             // 是否支持多通道查找
    UINT                        nmaxFaceType;           // 最多支持添加自定义人脸类型数量
    NET_FACEBOXCOLOR_CAPS       stuFaceBoxColor;        // 人脸检测框颜色能力
    BOOL                        bAsynPush;              // 是否支持以图搜图数据推送
    UINT                        nMaxGroupNum;           // 最大人脸库数量, 0表示无效
    UINT                        nMaxPersonNum;          // 最大存储人脸容量, 0表示无效
    UINT                        nMultiAppendPicLength;  // 批量导图每次接收图片的大小, 单位KB
    EM_SUPPORT_SEARCH_BY_PIC    emSupportSearchByPic;   // 是否支持以图搜图
    DWORD                       dwSearchTypeMask;       // 以图搜图支持的目标类型掩码, emSupportSearchByPic为EM_SUPPORT_SEARCH_BY_PIC_SUPPORT时有效
                                                        // bit0:人脸, bit1:人体, bit2:机动车,  bit3:非机动车
    UINT                        nSinglePicMaxLength;    // 单个图片最大大小的值，单位KB
} NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY; 

// 人员类型操作枚举
typedef enum tagEM_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    NET_PERSON_TYPE_UNKOWN,				// 未知
	NET_PERSON_TYPE_ADD,				// 添加自定义人员类型
	NET_PERSON_TYPE_MODIFY,				// 修改人员类型
	NET_PERSON_TYPE_DELETE,				// 删除人员类型
} EM_OPERATE_FACERECOGNITION_PERSON_TYPE;

// 添加人员类型信息
typedef struct tagNET_ADD_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// 结构体大小
	char				szType[DH_COMMON_STRING_16];			// 人员类型
} NET_ADD_FACERECOGNITION_PERSON_TYPE_INFO;   

// 修改人员类型信息
typedef struct tagNET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// 结构体大小
	char				szType[DH_COMMON_STRING_16];			// 修改的人员类型
	char				szNewType[DH_COMMON_STRING_16];			// 新的人员类型
} NET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO;   

// 删除人员类型信息
typedef struct tagNET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO
{
    DWORD               dwSize;									// 结构体大小
	char				szType[DH_COMMON_STRING_16];			// 人员类型
} NET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO;   

// CLIENT_OperateFaceRecognitionPersonType接口输入参数
typedef struct tagNET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD											dwSize;			// 结构体大小
    EM_OPERATE_FACERECOGNITION_PERSON_TYPE			emOperateType;	// 操作类型
    void											*pOPerateInfo;	// 相关操作信息,由用户申请内存，申请大小参照操作类型对应的结构体
																	// 若操作类型为NET_PERSON_TYPE_ADD,对应结构体为NET_ADD_FACERECOGNITION_PERSON_TYPE_INFO;
																	// 若操作类型为NET_PERSON_TYPE_MODIFY,对应结构体为NET_MODIFY_FACERECOGNITION_PERSON_TYPE_INFO
																	// 若操作类型为NET_PERSON_TYPE_DELETE,对应结构体为NET_DELETE_FACERECOGNITION_PERSON_TYPE_INFO
} NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_OperateFaceRecognitionPersonType接口输出参数 (删除人员类型时有效)
typedef struct tagNET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE
{
    DWORD               dwSize;										// 结构体大小
    char                szFailedCode[DH_COMMON_STRING_16];			// 错误代码
} NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE;   

// CLIENT_FindGroupInfo接口输入参数
typedef struct tagNET_IN_FIND_GROUP_INFO   
{
    DWORD               dwSize;
    char                szGroupId[DH_COMMON_STRING_64];// 人员组ID,唯一标识一组人员,为空表示查询全部人员组信息
}NET_IN_FIND_GROUP_INFO;

// CLIENT_FindGroupInfo接口输出参数
typedef struct tagNET_OUT_FIND_GROUP_INFO   
{
    DWORD               dwSize;
    NET_FACERECONGNITION_GROUP_INFO *pGroupInfos;      // 人员组信息,由用户申请空间,大小为sizeof(NET_FACERECONGNITION_GROUP_INFO)*nMaxGroupNum
    int                 nMaxGroupNum;                  // 当前申请的数组大小
    int                 nRetGroupNum;                  // 设备返回的人员组个数
}NET_OUT_FIND_GROUP_INFO;


// CLIENT_SetGroupInfoForChannel接口输入参数
typedef struct tagNET_IN_SET_GROUPINFO_FOR_CHANNEL
{
    DWORD               dwSize;
    int                 nChannelID;                    // 通道号
    int                 nGroupIdNum;                   // 人员组数   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // 人员组ID, 填[""]表示视频通道不布控人脸组，此时人脸识别退化为人脸检测
    int					nSimilaryNum;					// 相似度阈值个数, 与人员组数相同
    int					nSimilary[MAX_GOURP_NUM];		// 每个人脸组的相似度阈值, 0-100
}NET_IN_SET_GROUPINFO_FOR_CHANNEL;

// CLIENT_SetGroupInfoForChannel接口输出参数
typedef struct tagNET_OUT_SET_GROUPINFO_FOR_CHANNEL
{
    DWORD                dwSize;
}NET_OUT_SET_GROUPINFO_FOR_CHANNEL;

// CLIENT_GetGroupInfoForChannel接口输入参数
typedef struct tagNET_IN_GET_GROUPINFO_FOR_CHANNEL
{
    DWORD              dwSize;
    int                nChannelID;                    // 通道号
}NET_IN_GET_GROUPINFO_FOR_CHANNEL;

// CLIENT_GetGroupInfoForChannel接口输出参数
typedef struct tagNET_OUT_GET_GROUPINFO_FOR_CHANNEL
{
    DWORD               dwSize;
	int                 nGroupIdNum;                    // 人员组数   
    char                szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64]; // 人员组ID 
    int					nSimilaryNum;					// 相似度阈值个数, 与人员组数相同
    int					nSimilary[MAX_GOURP_NUM];		// 每个人脸组的相似度阈值, 0-100
}NET_OUT_GET_GROUPINFO_FOR_CHANNEL;

// 人脸查询状态信息回调函数, lAttachHandle是CLIENT_AttachFaceFindState的返回值
typedef struct tagNET_CB_FACE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //视频浓缩任务数据库主键ID
    int                 nProgress;      //正常取值范围：0-100,-1,表示查询token不存在(当订阅一个不存在或结束的查询时)
    int                 nCurrentCount;  //目前符合查询条件的人脸数量
}NET_CB_FACE_FIND_STATE;

typedef void (CALLBACK *fFaceFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_FACE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

//CLIENT_AttachFaceFindState接口输入参数
typedef struct tagNET_IN_FACE_FIND_STATE
{
    DWORD           dwSize;             //结构体大小,必须填写
    
    int             nTokenNum;          //查询令牌数,为0时,表示订阅所有的查询任务
    int            *nTokens;            //查询令牌,由用户申请内存，大小为sizeof(int)*nTokenNum
    fFaceFindState  cbFaceFindState;    //回调函数
    LDWORD          dwUser;             //用户数据
}NET_IN_FACE_FIND_STATE;

//CLIENT_AttachFaceFindState接口输出参数
 typedef struct  tagNET_OUT_FACE_FIND_STATE
 {
    DWORD           dwSize;
 }NET_OUT_FACE_FIND_STATE;


// CLIENT_FaceRecognitionSetSearchImageInfo 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD               dwSize;
    int                 nChannel;                           // 视频分析通道号
    char                szFilePath[DH_COMMON_STRING_256];   // 人文件路径,人脸图片路径
}NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;

// CLIENT_FaceRecognitionSetSearchImageInfo 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO
{
    DWORD                dwSize;
}NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO;

// 布控的视频通道信息
typedef struct tagNET_DISPOSITION_CHANNEL_INFO
{
	int					nChannelID;			// 视频通道号
	int					nSimilary;			// 相似度阈值, 0-100
	BYTE				bReserved[256];		// 保留
} NET_DISPOSITION_CHANNEL_INFO;

// CLIENT_FaceRecognitionPutDisposition 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO
{
	DWORD               			dwSize;
	char                			szGroupId[DH_COMMON_STRING_64]; 					// 人员组ID 
	int								nDispositionChnNum;									// 布控视频通道个数
	NET_DISPOSITION_CHANNEL_INFO	stuDispositionChnInfo[DH_MAX_CAMERA_CHANNEL_NUM];	// 布控视频通道信息
} NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO;

// CLIENT_FaceRecognitionPutDisposition 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO
{
	DWORD               dwSize;
	int					nReportCnt;							// 通道布控结果个数
	BOOL				bReport[DH_MAX_CAMERA_CHANNEL_NUM];	// 通道布控结果, TRUE追加成功, FALSE追加失败
} NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO;

// CLIENT_FaceRecognitionDelDisposition 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO
{
	DWORD               			dwSize;
	char                			szGroupId[DH_COMMON_STRING_64]; 				// 人员组ID 
	int								nDispositionChnNum;								// 撤控视频通道个数
	int								nDispositionChn[DH_MAX_CAMERA_CHANNEL_NUM];		// 撤控视频通道列表
} NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO;

// CLIENT_FaceRecognitionDelDisposition 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO
{
	DWORD               dwSize;
	int					nReportCnt;							// 通道布控结果个数
	BOOL				bReport[DH_MAX_CAMERA_CHANNEL_NUM];	// 通道布控结果, TRUE删除成功, FALSE删除失败
} NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO;

#define MAX_BIG_PIC_NUM     50      // 大图搜小图最大支持的大图数量
#define MAX_TOKEN_NUM       128     // 最大查询令牌数量

// 大图信息(大图抠小图功能)
typedef struct tagNET_DETECT_BIG_PIC_INFO 
{
    int             nPicID;                                     // 大图ID
    DWORD           dwOffSet;                                   // 文件在二进制数据块中的偏移位置, 单位:字节
    DWORD           dwFileLenth;                                // 文件大小, 单位:字节
    DWORD           dwWidth;                                    // 图片宽度, 单位:像素
    DWORD           dwHeight;                                   // 图片高度, 单位:像素
    int             nDetectRegionNum;                           // 规则检测区域顶点数
    NET_POINT       stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 规则检测区域
    BYTE            bReserved[44];                              // 保留字节
}NET_DETECT_BIG_PIC_INFO;

// CLIENT_FaceRecognitionDetectMultiFace 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO
{
    DWORD                       dwSize;                         // 此结构体的大小
    int                         nBigPicNum;                     // 大图张数
    NET_DETECT_BIG_PIC_INFO     stuBigPicInfo[MAX_BIG_PIC_NUM]; // 大图信息

    // 图片二进制数据
    char                        *pBuffer;                      // 缓冲地址
    int                         nBufferLen;                    // 缓冲数据长度
    EM_OBJECT_TYPE              emDetectObjType;               // 目标类型
} NET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO;

// CLIENT_FaceRecognitionDetectMultiFace 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO
{
    DWORD                       dwSize;                         // 此结构体的大小
} NET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO;

// 大图中小图的信息
typedef struct tagNET_SMALL_PIC_INFO
{
    int                         nSmallPicId;                // 小图ID
    NET_RECT                    stuRect;                    // 小图在大图中的位置
    EM_OBJECT_TYPE              emDetectObjType;            // 目标类型
    BYTE                        bReserved[124];             // 保留字节
} NET_SMALL_PIC_INFO;

// 大图检测小图结果错误码
typedef enum tagEM_MULTIFACE_DETECT_ERRCODE
{
    EM_MULTIFACE_DETECT_UNKNOWN     = -1,       // 未知
    EM_MULTIFACE_DETECT_SUCCESS,                // 成功
    EM_MULTIFACE_DETECT_DECODE_FAIL,            // 解码失败
    EM_MULTIFACE_DETECT_NO_OBJECT,              // 未检测到有效目标
} EM_MULTIFACE_DETECT_ERRCODE;

// 一张大图检测到小图的结果
typedef struct tagNET_IMAGE_RELATION
{
    int                         nBigPicId;                          // 大图ID
    int                         nSmallPicNum;                       // 大图中小图张数
    NET_SMALL_PIC_INFO          stuSmallPicInfo[MAX_SMALLPIC_NUM];  // 大图中小图的信息
    EM_MULTIFACE_DETECT_ERRCODE emDetectErrCode;                    // 大图检测小图结果错误码
    BYTE                        bReserved[124];                     // 保留字节
} NET_IMAGE_RELATION;

//  订阅大图检测小图进度回调结构体
typedef struct tagNET_CB_MULTIFACE_DETECT_STATE
{
    int                         nProgress;                      // 检测进度
    NET_IMAGE_RELATION          stuImageRelation;               // 大图检测小图的检测结果
    BYTE                        byReserved[512];                //保留字节
} NET_CB_MULTIFACE_DETECT_STATE;

// 订阅大图检测小图进度回调函数原型
typedef void (CALLBACK *fMultiFaceDetectState)(LLONG lAttachHandle, NET_CB_MULTIFACE_DETECT_STATE *pstStates, LDWORD dwUser);

// CLIENT_AttachDetectMultiFaceState 接口输入参数
typedef struct tagNET_IN_MULTIFACE_DETECT_STATE
{
    DWORD                       dwSize;                         // 此结构体大小
    BYTE                        bReserved[4];                   // 用于字节对齐
    fMultiFaceDetectState       cbMultiFaceDetectState;         //回调函数
    LDWORD                      dwUser;                         //用户数据
} NET_IN_MULTIFACE_DETECT_STATE;

// CLIENT_AttachDetectMultiFaceState 接口输出参数
typedef struct tagNET_OUT_MULTIFACE_DETECT_STATE
{
    DWORD                       dwSize;                         // 此结构体大小
} NET_OUT_MULTIFACE_DETECT_STATE;

// 人员重建信息
typedef struct tagNET_REABSTRACT_PERSON_INFO
{
	char                		szUID[DH_MAX_PERSON_ID_LEN];  	// 人员唯一标识符
	BYTE						bReserved[1024];	
} NET_REABSTRACT_PERSON_INFO;

// CLIENT_FaceRecognitionReAbstract 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_REABSTRACT_INFO
{
	DWORD						dwSize;							// 此结构体大小
	int							nPersonNum;						// 重新建模的人员个数
	NET_REABSTRACT_PERSON_INFO	*pstReAbstractPersonInfo;		// 重新建模的人员信息
} NET_IN_FACE_RECOGNITION_REABSTRACT_INFO;

// CLIENT_FaceRecognitionReAbstract 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_REABSTRACT_INFO
{
	DWORD						dwSize;							// 此结构体大小
} NET_OUT_FACE_RECOGNITION_REABSTRACT_INFO;

// CLIENT_FaceRecognitionGroupReAbstract 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;											// 此结构体大小
	int							nGroupNum;										// 人员组个数
	char						szGroupId[MAX_GOURP_NUM][DH_COMMON_STRING_64];	// 人员组ID
} NET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO;

// CLIENT_FaceRecognitionGroupReAbstract 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// 此结构体大小
	UINT						nToken;							// 重建令牌，可以用该令牌来中止重建
} NET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO;

// CLIENT_FaceRecognitionStopGroupReAbstract 接口输入参数
typedef struct tagNET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// 此结构体大小
	UINT						nToken;							// 重建令牌
} NET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO;

// CLIENT_FaceRecognitionStopGroupReAbstract 接口输出参数
typedef struct tagNET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO
{
	DWORD						dwSize;							// 此结构体大小
} NET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO;

// CLIENT_GetFaceParam 接口输入参数
typedef struct tagNET_IN_GET_FACE_PARAM
{
    DWORD                       dwSize;                         // 此结构体大小
    int                         nChannel;                       // 通道号
} NET_IN_GET_FACE_PARAM;

// CLIENT_GetFaceParam 接口输出参数
typedef struct tagNET_OUT_GET_FACE_PARAM
{
    DWORD                       dwSize;                         // 此结构体大小
    int                         nRegMinQuality;                 // 图片质量阀值, 1-100
    UINT                        nMinFaceSize;                   // 入库最小人脸像素过滤, 真实分辨率下, 单位像素, 默认0表示不生效
    unsigned short              nConfidence;                    // 入库人脸检测置信度过滤, 1-100, 默认0表示不生效
    unsigned short              nAlignScore;                    // 入库人脸关键点置信度过滤, 1-100, 默认0表示不生效
    short                       nRoll;                          // 入库人脸角度过滤 翻滚角, -90~90, 默认0表示不生效
    short                       nPitch;                         // 入库人脸角度过滤 俯仰角, -90~90, 默认0表示不生效
    short                       nYaw;                           // 入库人脸角度过滤 航偏角, -90~90, 默认0表示不生效
    BYTE                        reserved[2];                    // 保留字节
} NET_OUT_GET_FACE_PARAM;

// CLIENT_SetFaceParam 接口输入参数
typedef struct tagNET_IN_SET_FACE_PARAM
{
    DWORD                       dwSize;                         // 此结构体大小
    int                         nChannel;                       // 通道号
    int                         nRegMinQuality;                 // 图片质量阀值, 1-100
    UINT                        nMinFaceSize;                   // 入库最小人脸像素过滤, 真实分辨率下, 单位像素, 默认0表示不生效
    unsigned short              nConfidence;                    // 入库人脸检测置信度过滤, 1-100, 默认0表示不生效
    unsigned short              nAlignScore;                    // 入库人脸关键点置信度过滤, 1-100, 默认0表示不生效
    short                       nRoll;                          // 入库人脸角度过滤 翻滚角, -90~90, 默认0表示不生效
    short                       nPitch;                         // 入库人脸角度过滤 俯仰角, -90~90, 默认0表示不生效
    short                       nYaw;                           // 入库人脸角度过滤 航偏角, -90~90, 默认0表示不生效
    BYTE                        reserved[6];                    // 保留字节
} NET_IN_SET_FACE_PARAM;

// CLIENT_SetFaceParam 接口输出参数
typedef struct tagNET_OUT_SET_FACE_PARAM
{
    DWORD                       dwSize;                         // 此结构体大小
} NET_OUT_SET_FACE_PARAM;
///////////////////////////////// 刻录上传 /////////////////////////////////

// fBurnCheckCallBack 参数
typedef struct tagNET_CB_BURN_CHECK_STATE
{
    DWORD               dwSize;
    const char*         szType;                         // 消息类型
                                                        // "Checking": 校验中
                                                        // "CheckResult": 校验结果    
    BOOL                bCheckResult;                   // 校验结果, 用于"CheckResult", TRUE-成功, FALSE-失败
    BYTE                byProgress;                     // 校验进度, 用于"Checking", 百分比, 0~100
    BYTE                reserved[3];
} NET_CB_BURN_CHECK_STATE;

// 刻录校验回调函数原形, lAttachHandle是CLIENT_AttachBurnCheckState的返回值
typedef void (CALLBACK *fBurnCheckCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURN_CHECK_STATE* pstState, void* reserved, LDWORD dwUser);

// CLIENT_AttachBurnCheckState 接口的输入参数(监听刻录校验状态)
typedef struct tagNET_IN_ATTACH_BURN_CHECK 
{
    DWORD               dwSize;
    fBurnCheckCallBack  cbBurnCheck;                    // 刻录校验回调
    LDWORD              dwUser;                         // 用户数据
} NET_IN_ATTACH_BURN_CHECK;

// CLIENT_AttachBurnCheckState 接口的输出参数(监听刻录校验状态)
typedef struct tagNET_OUT_ATTACH_BURN_CHECK
{
    DWORD            dwSize;
} NET_OUT_ATTACH_BURN_CHECK;

///////////////////////////////// 逻辑设备 /////////////////////////////////

typedef struct tagNET_CB_CAMERASTATE
{
    DWORD               dwSize;
    int                 nChannel;             // 通道
    CONNECT_STATE       emConnectState;       // 连接状态
}NET_CB_CAMERASTATE;

// CLIENT_AttachCameraState()回调函数原形, 每次1条,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fCameraStateCallBack) (LLONG lLoginID, LLONG lAttachHandle, const NET_CB_CAMERASTATE *pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachCameraState()输入参数
typedef struct tagNET_IN_CAMERASTATE
{
    DWORD                   dwSize;
    int *                   pChannels;              // 观察的通道号,数组元素中,有一个是-1,则观察所有通道
													// 由用户申请内存，大小为sizeof(int)*nChannels
    int                     nChannels;              // pChannels指针长度
    fCameraStateCallBack    cbCamera;               // 状态回调函数
    LDWORD                  dwUser;                 // 用户数据
}NET_IN_CAMERASTATE;

typedef struct tagNET_OUT_CAMERASTATE
{
    DWORD                dwSize;
	int                  nObjectID;                 // 物体ID,每个ID表示一个唯一的物体
}NET_OUT_CAMERASTATE;

/////////////////////////////////特殊版本/////////////////////////////////

// 触发设备抓图,叠加卡号信息
typedef struct __NET_SNAP_COMMANDINFO 
{
    char                szCardInfo[16];             // 卡号信息
    char                reserved[64];               // 保留
} NET_SNAP_COMMANDINFO, LPNET_SNAP_COMMANDINFO;

typedef struct
{
    int                 nChannelNum;                // 通道号
    char                szUseType[32];              // 通道用途
    DWORD               dwStreamSize;               // 流量大小(单位：kb/s)
    char                reserved[32];               // 保留
} DHDEV_USE_CHANNEL_STATE;

typedef struct 
{
    char                szUserName[32];                     // 用户名
    char                szUserGroup[32];                    // 用户组
    NET_TIME            time;                               // 登入时间
    int                 nOpenedChannelNum;                  // 开启的通道个数
    DHDEV_USE_CHANNEL_STATE    channelInfo[DH_MAX_CHANNUM];
    char                szIpAddress[DH_MAX_IPADDR_LEN_EX];  // ip地址
    char                reserved[24];
} DHDEV_USER_NET_INFO;

// 网络运行状态信息
typedef    struct 
{
    int                 nUserCount;                      // 用户数量
    DHDEV_USER_NET_INFO stuUserInfo[32];
    char                reserved[256];
}DHDEV_TOTAL_NET_STATE;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip地址
    char                szUserGroup[32];                 // 用户组
    char                szUserName[32];                  // 用户名
    char                reserved[64];
}DHDEV_USER_REJECT_INFO;

// 剔除用户
typedef struct
{ 
    int                       nUserCount;                // 用户数量
    DHDEV_USER_REJECT_INFO    stuUserInfo[10];     
    char                      reserved[256];
}DHDEV_REJECT_USER;

typedef struct
{
    char                szIpAddress[DH_MAX_IPADDR_LEN];  // ip地址
    char                szUserGroup[32];                 // 用户组
    char                szUserName[32];                  // 用户名
    int                 nForbiddenTime;                  // 屏蔽时间
    char                reserved[64];
}DHDEV_USER_SHIELD_INFO;

// 屏蔽用户
typedef struct
{ 
    int                       nUserCount;                // 用户数量
    DHDEV_USER_SHIELD_INFO    stuUserInfo[10];     
    char                      reserved[256];
}DHDEV_SHIELD_USER;

// 经纬度
typedef struct
{//  经度在前,维度在后
    char                chPreLogi;        // 经度前置标志：N、S、W、E,分别表示北、南、西、东。
    char                chPreLati;        // 纬度前置标志：N、S、W、E,分别表示北、南、西、东。
    BYTE                reserved[6];      // 保留字节,对齐
    double              dbLongitude;      // 经度
    double              dbLatitude;       // 纬度
}DHDEV_LONGI_LATI;
// 导航信息和短消息
typedef struct
{
    char                szPhoneNum[DH_MAX_PHONE_NO_LEN];    // 电话号码
    NET_TIME            stMsgTime;                          // 信息发送时间
    char                szMsgType[DH_MAX_MSGTYPE_LEN];      // 信息类型（导航信息-Navigation； 短消息--SMS）
    char                szSmsContext[DH_MAX_MSG_LEN];       // 发送的信息内容
    DHDEV_LONGI_LATI    stLogiLati;                         // 起始经纬度
    unsigned int        uFlag;                              // 01：标志发来的是真实经纬度
    char                szNavigationType[16];               // TNC,为凯立德地图中心导航格式,TXZ,为天行者地图中心导航格式
    char                szAddress[32];                      // 地点信息
    char                szNavigationMode[32];               // 导航模式 有Recommend推荐,Economical经济型,Fastest 最快；Shortest 最短；
    DHDEV_LONGI_LATI    stPassLogiLati[5];                  // 经由点
    DHDEV_LONGI_LATI    stNoPassLogiLati[5];                // 不经由点
    BYTE                reserved[256];
}DHDEV_NAVIGATION_SMSS;

// 图象水印配置
typedef struct __DHDEV_WATERMAKE_CFG 
{
    DWORD               dwSize;
    int                 nEnable;                                // 使能
    int                 nStream;                                // 码流(1～n)0-所有码流
    int                 nKey;                                   // 数据类型(1-文字,2-图片)
    char                szLetterData[DH_MAX_WATERMAKE_LETTER];  //    文字
    char                szData[DH_MAX_WATERMAKE_DATA];          // 图片数据
    BYTE                bReserved[512];                         // 保留
} DHDEV_WATERMAKE_CFG;

// 存储位置设置结构体,每通道独立设置,每通道可以选择各种存储类型, 目前包括本地, 可移动, 远程存储.
typedef struct 
{
    DWORD               dwSize;
    DWORD               dwLocalMask;                            // 本地存储掩码；按位表示：
                                                                // 第一位：系统预录,第二位：定时录像,第三位：动检录像,
                                                                // 第四位：报警录像,第五位：卡号录像,第六位：手动录像
    DWORD               dwMobileMask;                           // 可移动存储掩码 存储掩码如本地存储掩码
    int                 RemoteType;                             // 远程存储类型 0: Ftp  1: Smb 
    DWORD               dwRemoteMask;                           // 远程存储掩码 存储掩码如本地存储掩码
    DWORD               dwRemoteSecondSelLocal;                 // 远程异常时本地存储掩码
    DWORD               dwRemoteSecondSelMobile;                // 远程异常时可移动存储掩码
    char                SubRemotePath[MAX_PATH_STOR];           // 远程目录, 其中长度为240
    DWORD               dwFunctionMask;                         // 功能屏蔽位,按位表示,bit0 = 1:屏蔽抓图事件触发存储位置功能
    DWORD               dwAutoSyncMask;                         // 是否同步掩码;远程存储网络故障恢复后,自动将本地存储的数据同步到远程存储。
    BYTE                bAutoSyncRange;                         // 从网络恢复的时刻开始,需要往前同步的数据时间范围,小时为单位。0:同步所有数据  1:1小时内的数据 n:n小时内的数据
    char                reserved[119];
} DH_STORAGE_STATION_CFG;

#define MAX_ALARM_DECODER_NUM 16
typedef struct  
{
    DWORD               dwAlarmDecoder;             // 现在最多支持8个报警输入口,留8位待以后扩展
    BYTE                bDecoderIndex;              // 表示第几个报警解码器
    BYTE                bReserved[3];
} ALARM_DECODER;

// 报警解码器报警
typedef struct
{
    int                 nAlarmDecoderNum;
    ALARM_DECODER       stuAlarmDecoder[MAX_ALARM_DECODER_NUM];
    BYTE                bReserved[32];
} ALARM_DECODER_ALARM;

//DSP报警
typedef struct  
{
    BOOL                bError;             //0,DSP正常 1,DSP异常
    DWORD               dwErrorMask;        //按位表示,非0表示有此错误,0表示没有。(目前每次报警只有一位有效)
                                            //bit DSP报警
                                            // 1  DSP加载失败 
                                            // 2  DSP错误
                                            // 3  制式不对 
                                            // 4  分辨率不支持
                                            // 5  数据格式不支持
                                            // 6  找不到I帧
    DWORD               dwDecChnnelMask;    //按位表示,报警的解码通道号,dwErrorMask为DSP错误,制式不对,分辨率不支持,数据格式不支持时此项有效
    DWORD               dwDecChnnelMask1;   //按位表示,33-64通道的报警的解码通道号, dwErrorMask为DSP错误,制式不对,分辨率不支持,数据格式不支持时此项有效
    BYTE                bReserved[24];
}DSP_ALARM;

// 光纤编码能力报警
typedef struct  
{
    int         nFDDINum;
    BYTE        bAlarm[256];
} ALARM_FDDI_ALARM;

#define ALARM_PTZ_LOCATION_INFO DH_PTZ_LOCATION_INFO

// 新音频检测报警配置
typedef struct
{
    BOOL                bEnable;                    // 报警输入使能
    int                 Volume_min;                 // 音量的最小值
    int                 Volume_max;                 // 音量的最大值
    char                reserved[128];    
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT];    
    DH_MSG_HANDLE       struHandle;                 // 处理方式
} DH_AUDIO_DETECT_INFO;

typedef struct  
{
    DWORD                   dwSize;
    int                     AlarmNum;
    DH_AUDIO_DETECT_INFO    AudioDetectAlarm[DH_MAX_AUDIO_IN_NUM];
    char                    reserved[256];
} DH_AUDIO_DETECT_CFG;

typedef struct
{
    BOOL                bTourEnable;                // 轮巡使能
    int                 nTourPeriod;                // 轮巡间隔,单位秒, 5-300 
    DWORD               dwChannelMask;              // 轮巡的通道,掩码形式表示
    char                reserved[64];
}DH_VIDEOGROUP_CFG;

// 本机矩阵控制策略配置
typedef struct
{
    DWORD               dwSize;
    int                 nMatrixNum;                 // 矩阵个数(注：不允许修改)
    DH_VIDEOGROUP_CFG   struVideoGroup[DH_MATRIX_MAXOUT];
    char                reserved[32];
} DHDEV_VIDEO_MATRIX_CFG;   

// WEB路径配置
typedef struct 
{
    DWORD               dwSize;
    BOOL                bSnapEnable;                    // 是否抓图
    int                 iSnapInterval;                  // 抓图周期
    char                szHostIp[DH_MAX_IPADDR_LEN];    // HTTP主机IP
    WORD                wHostPort;
    int                 iMsgInterval;                   // 状态消息发送间隔
    char                szUrlState[DH_MAX_URL_LEN];     // 状态消息上传URL
    char                szUrlImage[DH_MAX_URL_LEN];     // 图片上传Url
    char                szDevId[DH_MAX_DEV_ID_LEN];     // 机器的web编号
    BYTE                byReserved[2];
} DHDEV_URL_CFG;

// OEM查询
typedef struct  
{
    char                szVendor[DH_MAX_STRING_LEN];
    char                szType[DH_MAX_STRING_LEN];
    char                reserved[128];
} DHDEV_OEM_INFO;


//视频OSD叠加配置
typedef struct 
{ 
    DWORD   rgbaFrontground;            // 物件的前景；按字节表示,分别为红、绿、蓝和透明度
    DWORD   rgbaBackground;             // 物件的背景；按字节表示,分别为红、绿、蓝和透明度    
    RECT    rcRelativePos;              // 位置,物件边距与整长的比例*8191    
    BOOL    bPreviewBlend;              // 预览叠加使能    
    BOOL    bEncodeBlend;               // 编码叠加使能
    BYTE    bReserved[4];               // 保留
} DH_DVR_VIDEO_WIDGET;

typedef struct 
{
    DH_DVR_VIDEO_WIDGET     StOSD_POS;                                 // OSD叠加的位置和背景色
    char                    SzOSD_Name[DH_VIDEO_OSD_NAME_NUM];         // OSD叠加的名称
}DH_DVR_VIDEOITEM;
 
// 每个通道的OSD信息
typedef struct 
{
    DWORD                   dwSize;
    DH_DVR_VIDEOITEM        StOSDTitleOpt [DH_VIDEO_CUSTOM_OSD_NUM];    // 每个通道的OSD信息
    BYTE                    bReserved[16];                              // 保留
} DH_DVR_VIDEOOSD_CFG;

// 配置CDMA/GPRS网络信息
// 时间段结构                                                                
typedef struct 
{
    BYTE                bEnable;                  // 时间段使能,1表示该时间段有效,0表示该时间段无效。
    BYTE                bBeginHour;
    BYTE                bBeginMin;
    BYTE                bBeginSec;
    BYTE                bEndHour;
    BYTE                bEndMin;
    BYTE                bEndSec;
    BYTE                bReserved;                //保留
} DH_3G_TIMESECT, *LPDH_3G_TIMESECT;

typedef struct 
{
    DWORD               dwSize;
    BOOL                bEnable;                        // 无线模块使能标志
    DWORD               dwTypeMask;                     // 设备支持网络类型掩码;按位表示,第一位;自动选择;
                                                        // 第二位：TD-SCDMA网络；第三位：WCDMA网络;
                                                        // 第四位：CDMA 1.x网络;第五位：CDMA2000网络;第六位：GPRS网络;
                                                        // 第七位：EVDO网络;第八位：WIFI
    DWORD               dwNetType;                      // 当前的无线网络类型,为EM_GPRSCDMA_NETWORK_TYPE值
    char                szAPN[128];                     // 接入点名称
    char                szDialNum[128];                 // 拨号号码
    char                szUserName[128];                // 拨号用户名
    char                szPWD[128];                     // 拨号密码
    
    /* 下面是设备的只读部分 */
    BOOL                iAccessStat;                    // 无线网络注册状态
    char                szDevIP[16];                    // 前端设备拨号IP,字符串, 包括'\0'结束符共16byte  
    char                szSubNetMask [16];              // 前端设备拨号子网掩码,字符串, 包括'\0'结束符共16byte 
    char                szGateWay[16];                  // 前端设备拨号网关,字符串, 包括'\0'结束符共16byte 
    /* 上面是设备的只读部分 */
    int                 iKeepLive;                      // 保活时间
    DH_3G_TIMESECT      stSect[DH_N_WEEKS][DH_N_TSECT]; // 3G拨号时间段,有效时间段之内,开启拨号；有效时间段之外,关闭拨号。
    BYTE                byActivate;                     // 是否需要被语音或短信激活

    BYTE                bySimStat;                      // SIM(UIM)状态:存在1,不存在0  (只读数据) 占用Reserved的1个字节
    char                szIdentify[128];                // 鉴权方式
    bool                bPPPEnable;                     // PPP拨号,0-断开ppp连接,1-ppp拨号
    BYTE                bPPPState;                      // PPP拨号状态(只读),具体含义见EM_MOBILE_PPP_STATE
    BYTE                bNetCardState;                  // 网卡所处状态(只读),具体含义见EM_3GMOBILE_STATE
    char                szPhyCardNo[32];                // 物理卡号
    char                Reserved[4];                    // 保留字节,用于扩展
    BYTE                byPinShow;                      // PIN码是否显示(只读), 0-不支持, 1-显示, 2-不显示
    BYTE                byPinEnable;                    // PIN码设置使能(只读), 0-不使能, 1-使能
    BYTE                byPinCount;                     // PIN码剩余设置次数(只读), 0~3
    //-------------------------------以下字段设置dwSize后才有效------------------------------------
    char                szPinNo[16];                    // PIN码值, 字母或数字的任意组合
} DHDEV_CDMAGPRS_CFG;

// 录像打包长度配置
typedef struct  
{
    DWORD               dwSize;
    int                 nType;                          // 0:按时间,1：按大小
    int                 nValue;                         // nType = 0时:单位分钟,nType = 1时:单位KB
    char                Reserved[128];                  // 保留字节,用于扩展
} DHDEV_RECORD_PACKET_CFG;

// (定向)主动注册服务器信息
typedef struct __DEV_AUTOREGISTER_INFO 
{
    LONG            lConnectionID;                      // 连接ID
    char            szServerIp[DH_MAX_IPADDR_LEN];      // 主动注册服务器的IP
    int             nPort;                              // 主动注册服务器端口0- 65535
    int             nState;                             // 服务器的状态：0－注册失败；1-注册成功; 2-连接失败
    char            reserved[16];
} DEV_AUTOREGISTER_INFO;

typedef struct __DEV_SERVER_AUTOREGISTER 
{
    DWORD                    dwSize;
    int                      nRegisterSeverCount;                                            // 主动注册服务器个数
    DEV_AUTOREGISTER_INFO    stuDevRegisterSeverInfo[DH_CONTROL_AUTO_REGISTER_NUM];            // 各主动注册服务器信息
    char                     reserved[256];
} DEV_SERVER_AUTOREGISTER, *LPDEV_SERVER_AUTOREGISTER;

// 附件刻录附件上传
typedef struct
{
    DWORD               dwSize;        
    char                szSourFile[MAX_PATH_STOR];    // 源文件路径
    int                 nFileSize;                    // 源文件大小,如果小于等于0,sdk自行计算文件大小.
    char                szBurnFile[MAX_PATH_STOR];    // 刻录后的文件名
    BYTE                bReserved[64];
} DHDEV_BURNFILE_TRANS_CFG;

// 升级文件上传
typedef struct
{
    char                 szFile[MAX_PATH_STOR];      // 升级文件路径
    int                  nFileSize;                  // 升级文件大小 
    BYTE                 byChannelId;                // 通道号
    BYTE                 byManufactryType;           // 厂商类型,详见EM_IPC_TYPE
    BYTE                 byReserved[126];            // 保留      
}DHDEV_UPGRADE_FILE_INFO;

// 黑白名单上传
typedef struct  
{
    char                 szFile[MAX_PATH_STOR];     // 黑白名单文件路径
    int                  nFileSize;                 // 升级文件大小
    BYTE                 byFileType;                // 当前文件类型,0-黑名单,1-白名单 
    BYTE                 byAction;                  // 动作,0-覆盖,1-追加
    BYTE                 byReserved[126];           // 保留
}DHDEV_BLACKWHITE_LIST_INFO;

// 黑白名单下载
typedef struct
{
    char                 szFile[MAX_PATH_STOR];     // 黑白名单文件保存路径
    BYTE                 byFileType;                // 当前文件类型,0-黑名单,1-白名单
    BYTE                 byReserved[127];           // 保留
}DHDEV_LOAD_BLACKWHITE_LIST_INFO;

// 郑州威科姆EC_U视频数据叠加使能配置
typedef struct 
{
    BOOL                bEnable;                    // 使能
    int                 nPort;                      // 端口
    BYTE                bReserved[64];
} DHDEV_OSD_ENABLE_CFG;

// 车载相关配置:北京公交使用配置
typedef struct    
{
    BOOL                bAutoBootEnable;                //自动开机使能
    DWORD               dwAutoBootTime;                 //每天自动开机时间点, 单位秒,从0算起.[0,82800]
    BOOL                bAutoShutDownEnable;            //自动关机使能
    DWORD               dwAutoShutDownTime;             //每天自动关机时间点, 单位秒,从0算起.[0,82800]
    DWORD               dwShutDownDelayTime;            //延时关机时间,单位秒.
    BYTE                bEventNoDisk;                   //1,(Ignore:忽略); 2,(Reboot:重起系统)
    BYTE                bWifiEnable;                    //是否支持车载无线模块.
    BYTE                bUpperSpeedEnable;              //是否使用超速判断
    BYTE                bLowerSpeedEnable;              //是否使用低速判断
    DWORD               dwUpperSpeedValue;              //超速值开区间(1,1000).公里/小时
    DWORD               dwLowerSpeedValue;              //低速值开区间(1,1000).公里/小时
    DWORD               dwUpperSpeedDelayTime;          //设置超速持续值
    DWORD               dwLowerSpeedDelayTime;          //设置低速持续值
    DWORD               dwAlarmMaskEnable;              //查询/设置叠加报警信息使能,0:关闭,1:打开, 每一位从低到高表示各个外部报警通道0-N使能
    BOOL                bSpeedOverAlarmRecordEnable;    // 超速报警联动录像使能
    BOOL                bSpeedLowAlarmRecordEnable;     // 低速报警联动录像使能 
    BYTE                bReserved[480];                 //reserved byte.
} DHDEV_ABOUT_VEHICLE_CFG;

// atm:查询叠加相关能力信息
typedef struct  
{
    DWORD               dwDataSource;                   //按位, 位0:Net(网络), 位1:Com(串口), 位2:Com422(串口422)
    char                szProtocol[32][33];             //协议名字,最大长度32(保留一个结束符).
    BYTE                bReserved[256];
} DHDEV_ATM_OVERLAY_GENERAL;
 
// atm:配置叠加设置
typedef struct 
{
    DWORD               dwDataSource;                   // 1:Net(网络), 2:Com(串口), 3:Com422(串口422)
    char                szProtocol[33];                 // 协议名字,由DHDEV_ATM_OVERLAY_GENERAL返回
    BYTE                bReserved_1[3];
    DWORD               dwChannelMask;                  // 叠加的通道号,掩码表示。
    BYTE                bMode;                          // 1:Preview(预览叠加), 2:Encode(编码叠加), 3:Preview&Encode(预览和编码叠加)
    BYTE                bLocation;                      // 1:LeftTop(左上), 2:LeftBottom(左下), 3:RightTop(右上), 4:RightBottom(右下)
    BYTE                bReserved_3[2];           
    int                 nLatchTime;                     // 叠加显示延迟时间,卡号录像延时关闭时间,0~65535s
    BYTE                bReserved_4[3];
    BYTE                bRecordSrcKeyNum;               // 关键字个数  
    int                 nRecordSrcKey[32];              // 各视频通道对应数据源关键字(不同通道可以对应不同的数据源)  
    BYTE                bReserved_2[120];
} DHDEV_ATM_OVERLAY_CONFIG;


// atm:配置叠加设置
typedef struct 
{
    DWORD               dwSize;                         // 结构体大小
    DWORD               dwDataSource;                   // 1:Net(网络), 2:Com(串口), 3:Com422(串口422)
    char                szProtocol[33];                 // 协议名字,
    BYTE                bReserved_1[3];
    DWORD               dwChannelMask[8];               // 叠加的通道号,掩码表示, dwChannelMask[0]表示0-31通道,依此类推。
    BYTE                bMode;                          // 1:Preview(预览叠加), 2:Encode(编码叠加), 3:Preview&Encode(预览和编码叠加)
    BYTE                bLocation;                      // 1:LeftTop(左上), 2:LeftBottom(左下), 3:RightTop(右上), 4:RightBottom(右下)
    BYTE                bReserved_3[2];           
    int                 nLatchTime;                     // 叠加显示延迟时间,卡号录像延时关闭时间,0~65535s
    BYTE                bReserved_4[3];
    BYTE                bRecordSrcKeyNum;               // 关键字个数  
    int                 nRecordSrcKey[256];             // 各视频通道对应数据源关键字(不同通道可以对应不同的数据源)  
} DHDEV_ATM_OVERLAY_CONFIG_EX;

// 雷达配置――车速
typedef struct tagNET_RADAR_CARSPEED_INFO
{

    int                 nTriggerLower;                  // 触发值下限  范围 1~255km/h
    int                 nTriggerUpper;                  // 触发值上限  范围 1~255km/h
    int                 nLimitLower;                    // 限速值下限  范围 5~255km/h
    int                 nLimitUpper;                    // 限速值上限  范围 5~255km/h
} NET_RADAR_CARSPEED_INFO;

// 大华雷达配置 
typedef struct tagDEV_DAHUA_RADAR_CONFIG
{
    int							nAngle;                         // 角度，用于修正雷达探头安装的角度造成的速度误差 单位度，范围0~45
    BOOL						bLowSpeed;                      // 是否启用低限速，为 TRUE NET_RADAR_CARSPEED_INFO 结构中各下限值有效
    BOOL						bSpeedForSize;                  // 是否启用大小车限速，为 FALSE 时仅小车速度配置（stuSmallCarSpeed）有效
    NET_RADAR_CARSPEED_INFO     stuSmallCarSpeed;               // 小车速度配置，bSpeedForSize 为 TRUE 时 nTriggerLower 成员同时也代表中车和大车的触发值下限
    NET_RADAR_CARSPEED_INFO     stuMediumCarSpeed;              // 中车速度配置，bSpeedForSize 为 TRUE 时有效，但 nTriggerLower 成员始终无效
    NET_RADAR_CARSPEED_INFO     stuBigCarSpeed;                 // 大车速度配置，bSpeedForSize 为 TRUE 时有效，但 nTriggerLower 成员始终无效
    char						szName[256];                    // 设备安装地址
    int							nSensitivity;                   // 灵敏度 范围0~5，0最高
    int							nDetectMode;                    // 检测模式，取值：-1 无意义 0 前向来车 1 前向去车 2 后向来车 3 后向去车 4 前向双向 5 后向双向
	BYTE						bReserved[1024];
} DEV_DAHUA_RADAR_CONFIG;

// 雷达配置
typedef struct tagDEV_RADAR_CONFIG
{	
	DWORD							dwSize;
	BOOL							bEnable;                          		// 是否开启功能
	int								nPort;							  		// 串口端口号
	DH_COMM_PROP					stuCommAttr;							// 串口属性
	int								nAddress;								// 设备地址，如果串口上挂了多个串口设备，通过地址区分
	int								nPreSpeedWait;							// 速度先来情况下等待时间，速度来时尚未抓拍 范围 (1 -- 5000ms)
	int								nDelaySpeedWait;						// 速度后来情况下等待时间，抓拍时还没有来速度 范围 (1 -- 5000ms)
	BOOL							bDahuaRadarEnable;						// 大华雷达配置是否可用
	DEV_DAHUA_RADAR_CONFIG			stuDhRadarConfig;						// 大华雷达参数配置
}DEV_RADAR_CONFIG;


#define DH_MAX_BACKUPDEV_NUM            16
#define DH_MAX_BACKUP_NAME              32

// 备份设备列表
typedef struct 
{
    int                 nBackupDevNum;                                // 实际的备份设备数量
    char                szBackupDevNames[DH_MAX_BACKUPDEV_NUM][DH_MAX_BACKUP_NAME]; // 备份设备的名称
} DHDEV_BACKUP_LIST, *LPDHDEV_BACKUP_LIST;

// 备份设备介质类型
typedef enum __BACKUP_TYPE
{
    BT_DHFS = 0,                            // 私有文件系统
    BT_DISK,                                // 移动硬盘
    BT_CDRW                                 // 光盘刻录
} DHDEV_BACKUP_TYPE;    

// 备份设备接口类型
typedef enum __BACKUP_BUS
{
    BB_USB = 0,                             // usb接口
    BB_1394,                                // 1394接口
    BB_IDE,                                 // ide接口
    BB_ESATA,                               // esata接口
} DHDEV_BACKUP_BUS;    

typedef struct 
{
    char                szName[32];                     // 设备名 
    BYTE                byType;                         // 备份设备的介质类型 枚举值见BACKUP_TYPE
    BYTE                byBus;                          // 备份设备的接口类型 枚举值见BACKUP_BUS
    UINT                nCapability;                    // 总容量, 以kBytes为单位
    UINT                nRemain;                        // 剩余容量,以kBytes为单位
    char                szDirectory[128];               // 远程备份的目录
} DHDEV_BACKUP_INFO, *LPDHDEV_BACKUP_INFO;

typedef struct 
{
    char                szName[32];                     // 设备名 
    UINT                nCapability;                    // 总容量, 以kBytes为单位
    UINT                nRemain;                        // 当前备份剩余容量,以kBytes为单位
} DHDEV_BACKUP_FEEDBACK, *LPDHDEV_BACKUP_FEEDBACK;

#define  DH_MAX_BACKUPRECORD_NUM 1024

typedef struct  
{
    char                szDeviceName[DH_MAX_BACKUP_NAME];            //备份设备名称
    int                 nRecordNum;                                  //备份记录数量
    NET_RECORDFILE_INFO stuRecordInfo[DH_MAX_BACKUPRECORD_NUM];      //备份记录信息
} BACKUP_RECORD, *LPBACKUP_RECORD;

// 多通道打开视频输入
typedef struct
{
    int                 iChannelID;      // 通道号
    DH_RealPlayType     realplayType;    // 视频类型
    char                reserve[32];
}DHDEV_IN_MULTIPLAY_PARAM;

// 多通道打开视频输出
typedef struct
{
    int                 iChannelID;      // 通道号
    LLONG               lRealHandle;     // 实时监视句柄
    char                reserve[32];
}DHDEV_OUT_MULTIPLAY_PARAM;


/////////////////////////////////平台接入/////////////////////////////////

// 平台接入配置 － U网通
typedef struct
{
    BOOL                bChnEn;
    char                szChnId[DH_INTERVIDEO_UCOM_CHANID];
} DH_INTERVIDEO_UCOM_CHN_CFG;

typedef struct
{
    DWORD               dwSize;
    BOOL                bFuncEnable;                            // 接入功能使能
    BOOL                bAliveEnable;                           // 心跳使能
    DWORD               dwAlivePeriod;                          // 心跳周期,单位秒,0-3600
    char                szServerIp[DH_MAX_IPADDR_LEN];          // CMS的IP
    WORD                wServerPort;                            // CMS的Port
    char                szRegPwd[DH_INTERVIDEO_UCOM_REGPSW];    // 注册密码
    char                szDeviceId[DH_INTERVIDEO_UCOM_DEVID];   // 设备id
    char                szUserName[DH_INTERVIDEO_UCOM_USERNAME];
    char                szPassWord[DH_INTERVIDEO_UCOM_USERPSW];
    DH_INTERVIDEO_UCOM_CHN_CFG  struChnInfo[DH_MAX_CHANNUM];    // 通道id,en
} DHDEV_INTERVIDEO_UCOM_CFG;

// 平台接入配置 － 阿尔卡特
typedef struct
{
    DWORD               dwSize;
    unsigned short      usCompanyID[2];             // 公司ID,数值,不同的第三方服务公司,考虑4字节对齐,目前只用数组第一个
    char                szDeviceNO[32];             // 前端设备序列号,字符串,包括'\0'结束符共32byte
    char                szVSName[32];               // 前端设备名称,字符串,包括'\0'结束符共16byte
    char                szVapPath[32];              // VAP路径
    unsigned short      usTcpPort;                  // TCP端口,数值：数值 1~65535 
    unsigned short      usUdpPort;                  // UDP端口,数值：数值 1~65535
    bool                bCsEnable[4];               // 中心服务器使能标志,数值：true使能,false不使能,考虑4字节对齐,目前只用数组第一个
    char                szCsIP[16];                 // 中心服务器IP地址,字符串,包括'\0'结束符共16byte
    unsigned short      usCsPort[2];                // 中心服务器端口,数值：数值 1~65535,考虑4字节对齐,目前只用数组第一个
    bool                bHsEnable[4];               // 心跳服务器使能标志,数值：true使能,false不使能,考虑4字节对齐,目前只用数组第一个
    char                szHsIP[16];                 // 心跳服务器IP地址,字符串,包括'\0'结束符共16byte
    unsigned short      usHsPort[2];                // 心跳服务器端口,数值：数值 1~65535,考虑4字节对齐,目前只用数组第一个
    int                 iHsIntervalTime;            // 心跳服务器间隔周期,数值(单位:秒)
    bool                bRsEnable[4];               // 注册服务器使能标志,数值：true使能,false不使能,考虑4字节对齐,目前只用数组第一个
    char                szRsIP[16];                 // 注册服务器IP地址,字符串,包括'\0'结束符共16byte
    unsigned short      usRsPort[2];                // 注册服务器端口,数值：数值 1~65535,考虑4字节对齐,目前只用数组第一个
    int                 iRsAgedTime;                // 注册服务器有效时间,数值(单位:小时)
    char                szAuthorizeServerIp[16];    // 鉴权服务器IP
    unsigned short      usAuthorizePort[2];         // 鉴权服务器端口,考虑4字节对齐,目前只用数组第一个
    char                szAuthorizeUsername[32];    // 鉴权服务器帐号
    char                szAuthorizePassword[36];    // 鉴权服务器密码
    
    char                szIpACS[16];                // ACS(自动注册服务器) IP
    unsigned short      usPortACS[2];               // ACS Port,考虑4字节对齐,目前只用数组第一个
    char                szUsernameACS[32];          // ACS用户名
    char                szPasswordACS[36];          // ACS密码
    bool                bVideoMonitorEnabled[4];    // DVS是否定期上报前端视频信号监控信息,数值：true使能,false不使能
    int                 iVideoMonitorInterval;      // 上报周期(分钟)
    
    char                szCoordinateGPS[64];        // GPS坐标
    char                szPosition[32];             // 设备位置
    char                szConnPass[36];             // 设备接入码
} DHDEV_INTERVIDEO_BELL_CFG;

// 平台接入配置 － 中兴力维
typedef struct  
{
    DWORD               dwSize;
    unsigned short      nSevPort;                               // 服务器端口,数值,数值1~65535
    char                szSevIp[DH_INTERVIDEO_NSS_IP];          // 服务器IP地址,字符串,包括'\0'结束符共32byte
    char                szDevSerial[DH_INTERVIDEO_NSS_SERIAL];  // 前端设备序列号,字符串,包括'\0'结束符共32byte
    char                szUserName[DH_INTERVIDEO_NSS_USER];
    char                szPwd[DH_INTERVIDEO_NSS_PWD];
} DHDEV_INTERVIDEO_NSS_CFG;

// 平台接入配置 － 天地阳光
typedef struct  
{
    char               szDevSerial[DH_INTERVIDEO_AMP_DEVICESERIAL];                  //前端设备序列号,即编码器的序列号,该参数只读
    char               szDevName[DH_INTERVIDEO_AMP_DEVICENAME];                      //前端设备名称,编码器的名称,该参数只读
    char               szRegUserName[DH_INTERVIDEO_AMP_USER];                        //注册服务器用户名
    char               szRegPwd[DH_INTERVIDEO_AMP_PWD];                              //注册服务器密码
    BYTE               bReserved[128];
} DHDEV_INTERVIDEO_AMP_CFG;  
////////////////////////////////HDVR专用//////////////////////////////////

// 报警联动扩展结构体
typedef struct 
{
    /* 消息处理方式,可以同时多种处理方式,包括
     * 0x00000001 - 报警上传
     * 0x00000002 - 联动录象
     * 0x00000004 - 云台联动
     * 0x00000008 - 发送邮件
     * 0x00000010 - 本地轮巡
     * 0x00000020 - 本地提示
     * 0x00000040 - 报警输出
     * 0x00000080 - Ftp上传
     * 0x00000100 - 蜂鸣
     * 0x00000200 - 语音提示
     * 0x00000400 - 抓图
    */

    /* 当前报警所支持的处理方式,按位掩码表示 */
    DWORD               dwActionMask;

    /* 触发动作,按位掩码表示,具体动作所需要的参数在各自的配置中体现 */
    DWORD               dwActionFlag;
    
    /* 报警触发的输出通道,报警触发的输出,为1表示触发该输出 */ 
    BYTE                byRelAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
    DWORD               dwDuration;                                 /* 报警持续时间 */

    /* 联动录象 */
    BYTE                byRecordChannel[DH_MAX_VIDEO_IN_NUM_EX];    /* 报警触发的录象通道,为1表示触发该通道 */
    DWORD               dwRecLatch;                                 /* 录象持续时间 */

    /* 抓图通道 */
    BYTE                bySnap[DH_MAX_VIDEO_IN_NUM_EX];
    /* 轮巡通道 */
    BYTE                byTour[DH_MAX_VIDEO_IN_NUM_EX];             /* 轮巡通道 0-31路*/

    /* 云台联动 */
    DH_PTZ_LINK         struPtzLink[DH_MAX_VIDEO_IN_NUM_EX];
    DWORD               dwEventLatch;                               /* 联动开始延时时间,s为单位,范围是0~15,默认值是0 */
    /* 报警触发的无线输出通道,报警触发的输出,为1表示触发该输出 */ 
    BYTE                byRelWIAlarmOut[DH_MAX_ALARMOUT_NUM_EX];
    BYTE                bMessageToNet;
    BYTE                bMMSEn;                                     /*短信报警使能*/
    BYTE                bySnapshotTimes;                            /*短信发送抓图张数 */
    BYTE                bMatrixEn;                                  /*!< 矩阵使能 */
    DWORD               dwMatrix;                                   /*!< 矩阵掩码 */            
    BYTE                bLog;                                       /*!< 日志使能,目前只有在WTN动态检测中使用 */
    BYTE                bSnapshotPeriod;                            /*!<抓图帧间隔,每隔多少帧抓一张图片,一定时间内抓拍的张数还与抓图帧率有关。0表示不隔帧,连续抓拍。*/
    BYTE                byTour2[DH_MAX_VIDEO_IN_NUM_EX];            /* 轮巡通道 32-63路*/
    BYTE                byEmailType;                                /*<0,图片附件,1,录像附件>*/
    BYTE                byEmailMaxLength;                           /*<附件录像时的最大长度,单位MB>*/
    BYTE                byEmailMaxTime;                             /*<附件是录像时最大时间长度,单位秒>*/
    BYTE                byReserved[475];   
} DH_MSG_HANDLE_EX;

// 外部报警扩展
typedef struct
{
    BYTE                byAlarmType;                        // 报警器类型,0：常闭,1：常开
    BYTE                byAlarmEn;                          // 报警使能
    BYTE                byReserved[2];                        
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struHandle;                         // 处理方式
} DH_ALARMIN_CFG_EX, *LPDHDEV_ALARMIN_CFG_EX; 

// 动态检测报警
typedef struct 
{
    BYTE                byMotionEn;                         // 动态检测报警使能
    BYTE                byReserved;
    WORD                wSenseLevel;                        // 灵敏度
    WORD                wMotionRow;                         // 动态检测区域的行数
    WORD                wMotionCol;                         // 动态检测区域的列数
    BYTE                byDetected[DH_MOTION_ROW][DH_MOTION_COL]; // 检测区域,最多32*32块区域
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX        struHandle;                     //处理方式
} DH_MOTION_DETECT_CFG_EX;


// 火警报警
typedef struct
{
    BOOL                byFireEn;              // 火警报警时能；
    DH_MSG_HANDLE_EX    struHandle;            // 处理方式
    BYTE                byReserved[128];
}DHDEV_FIRE_ALARM_CFG;

// 静态检测报警 
typedef struct 
{
    BYTE                byStaticEn;                         // 静态检测报警使能
    BYTE                byLatch;                            // 检测延时(范围0-127,若超出范围则用nLatch)    
    WORD                wSenseLevel;                        // 灵敏度
    WORD                wStaticRow;                         // 静态检测区域的行数
    WORD                wStaticCol;                         // 静态检测区域的列数
    BYTE                byDetected[DH_STATIC_ROW][DH_STATIC_COL]; // 检测区域,最多32*32块区域
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // 处理方式
    int                 nLatch;                             // 检测延时
    BYTE                bReserved[64];                      // 保留字段
} DH_STATIC_DETECT_CFG_EX;

// ACC断线报警事件配置
typedef struct _DHDEV_ACC_POWEROFF_CFG
{
    BOOL                bEnable;               // ACC断线报警使能
    int                 nDelayTime;            // ACC断线报警延时时间,单位分钟
    DH_MSG_HANDLE_EX    struHandle;            // 处理方式
    BYTE                Reserved[128];         // 保留字段
}DHDEV_ACC_POWEROFF_CFG;

// 防爆盒报警事件配置
typedef struct _DHDEV_EXPLOSION_PROOF_CFG
{
    BOOL                bEnable;               // 防爆盒报警使能
    DH_MSG_HANDLE_EX    struHandle;            // 处理方式
    BYTE                Reserved[128];         // 保留字段
}DHDEV_EXPLOSION_PROOF_CFG;

// Raid事件配置
typedef struct _DHDEV_RAID_EVENT_CFG
{
    BOOL                bEnable;               // Raid事件使能
    DH_MSG_HANDLE_EX    struHandle;            // 处理方式
    BYTE                Reserved[128];         // 保留字段
}DHDEV_RAID_EVENT_CFG;

// 视频丢失报警
typedef struct
{
    BYTE                byAlarmEn;                          // 视频丢失报警使能
    BYTE                byReserved[3];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // 处理方式
} DH_VIDEO_LOST_CFG_EX;

// 图像遮挡报警
typedef struct
{
    BYTE                byBlindEnable;                      // 使能
    BYTE                byBlindLevel;                       // 灵敏度1-6
    BYTE                byReserved[2];
    DH_TSECT            stSect[DH_N_WEEKS][DH_N_REC_TSECT]; // NSP
    DH_MSG_HANDLE_EX    struHandle;                         // 处理方式
} DH_BLIND_CFG_EX;

// 硬盘消息(内部报警)
typedef struct 
{
    BYTE                byNoDiskEn;                         // 无硬盘时报警
    BYTE                byReserved_1[3];
    DH_TSECT            stNDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struNDHandle;                       // 处理方式
    BYTE                byLowCapEn;                         // 硬盘低容量时报警
    BYTE                byLowerLimit;                       // 容量阀值,0-99
    BYTE                byReserved_2[2];
    DH_TSECT            stLCSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struLCHandle;                       // 处理方式
    BYTE                byDiskErrEn;                        // 硬盘故障报警
    BYTE                bDiskNum;
    BYTE                byReserved_3[2];
    DH_TSECT            stEDSect[DH_N_WEEKS][DH_N_REC_TSECT]; //NSP
    DH_MSG_HANDLE_EX    struEDHandle;                       // 处理方式
} DH_DISK_ALARM_CFG_EX;

typedef struct
{
    BYTE                byEnable;
    BYTE                byReserved[3];
    DH_MSG_HANDLE_EX    struHandle;
} DH_NETBROKEN_ALARM_CFG_EX;

// 前端接入配置参数信息
typedef struct __DEV_ENCODER_CFG 
{
    int                 nChannels;                  // 数字通道个数
    DEV_ENCODER_INFO    stuDevInfo[32];             // 各数字通道的前端编码器信息
    BYTE                byHDAbility;                // 数字通道中最多可支持高清视频个数(为0表示不支持高清设置)
                                                    // 注：如果支持高清设置,高清通道为0~N-1,若将N之后的数字通道设置为高清,有可能保存不成功
    BYTE                bTVAdjust;                  // 设备是否支持TV调节, 0:不支持 1:支持.
    BYTE                bDecodeTour;                // 设备是否支持解码轮巡, 0:不支持 大于0:表示前端支持轮巡最大设备数.
    BYTE                bRemotePTZCtl;              // 指示是否支持远程云台控制。

    char                reserved[12];
} DEV_ENCODER_CFG, *LPDEV_ENCODER_CFG;

// 前端接入配置参数信息扩展
typedef struct __DEV_ENCODER_CFG_EX 
{
    int                 nChannels;                  // 数字通道个数
    DEV_ENCODER_INFO    stuDevInfo[128];            // 各数字通道的前端编码器信息
    BYTE                byHDAbility;                // 数字通道中最多可支持高清视频个数(为0表示不支持高清设置)
    // 注：如果支持高清设置,高清通道为0~N-1,若将N之后的数字通道设置为高清,有可能保存不成功
    BYTE                bTVAdjust;                  // 设备是否支持TV调节, 0:不支持 1:支持.
    BYTE                bDecodeTour;                // 设备是否支持解码轮巡, 0:不支持 大于0:表示前端支持轮巡最大设备数.
    BYTE                bRemotePTZCtl;              // 指示是否支持远程云台控制。
    char                reserved[256];
} DEV_ENCODER_CFG_EX, *LPDEV_ENCODER_CFG_EX;

// 前端接入配置参数信息扩展
typedef struct __DEV_ENCODER_CFG_EX2
{
	int                 nChannels;                  // 实际获取/设置的数字通道个数
	int					nDevInfoMaxNum;				// 最大申请数字通道个数
	DEV_ENCODER_INFO    *pstuDevInfo;				// 各数字通道的前端编码器信息，大小为sizeof(DEV_ENCODER_INFO)*nDevInfoMaxNum;
	BYTE                byHDAbility;                // 数字通道中最多可支持高清视频个数(为0表示不支持高清设置)
	// 注：如果支持高清设置,高清通道为0~N-1,若将N之后的数字通道设置为高清,有可能保存不成功
	BYTE                bTVAdjust;                  // 设备是否支持TV调节, 0:不支持 1:支持.
	BYTE                bDecodeTour;                // 设备是否支持解码轮巡, 0:不支持 大于0:表示前端支持轮巡最大设备数.
	BYTE                bRemotePTZCtl;              // 指示是否支持远程云台控制。
	char                reserved[256];
} DEV_ENCODER_CFG_EX2, *LPDEV_ENCODER_CFG_EX2;

// struct 控制器
typedef struct tagDHCONFIG_CONTROLER{
    DH_COMM_PROP        struComm;                        // 串口属性
    BYTE                bLightGroup[DH_MAX_LIGHT_NUM];   // 受控灯数组（灯序号从1开始计数,比如[1,3,8,0…0]表示控制序号为1,3,8的灯
    BYTE                bDeviceAddr;                     // 控制器地址
    BYTE                bComPortType;                    // 串口类型 0:485串口, 1:232串口
    BYTE                bReserved[6];                    // 保留
} DH_CONFIG_CONTROLER;

// 灯光控制配置
typedef struct __DHDEV_LIGHTCONTROL_CFG
{
    DH_CONFIG_CONTROLER    struControlers[DH_MAX_CONTROLER_NUM];  // 控制配置
    BYTE                   bControlerNum;                         // 有效控制器数目
    BYTE                   bReserved[1023];                       // 保留
} DHDEV_LIGHTCONTROL_CFG, *LPDHDEV_LIGHTCONTROL_CFG;


// 3G流量信息配置
typedef struct
{
    int                 nStrategy;       //流量使用策略, 0:按流量包月 1:按时间包月
    int                 nUpLimit;        //流量使用上限, 按流量: 单位MB 按时间: 单位小时
    int                 nreserved[22];   //保留字节
}DHDEV_3GFLOW_INFO_CFG;

// IPv6配置
typedef struct 
{
    char               szLinkAddr[44];      // 链路地址: 字符串, 长度为44;(局域网内每台主机拥有唯一的链路地址,只读)
    char               szHostIP[40];        // 主机IP
    DWORD              dwPreFix;            // 网络前缀（范围：1-128,可读可写）
    char               szGateWay[40];       // 默认网关
    BOOL               bAutoGet;            // 自动获取使能
    char               szPrimaryDns[40];    // 首选DNS
    char               szSecondDns[40];     // 备选DNS
    char               cReserved[256];      // 保留字段
}DHDEV_IPV6_CFG;

//紧急存储配置
typedef struct __DEV_URGENCY_RECORD_CFG
{
    DWORD   dwSize;             // 结构体大小
    BOOL    bEnable;            // 是否使能,1使能,0不使能
    UINT    nMaxRecordTime;     // 最大录像时间,单位秒
	char	szClientMac[64];	// 客户端标识,手动传mac地址时需要自己去掉':';此处若不填写，将使用默认网卡作为标识
								// (注意，如果手动设置非默认网卡的标识，将无法获取到该配置)
}DHDEV_URGENCY_RECORD_CFG;

// 电梯运行参数配置
typedef struct __DEV_ELEVATOR_ATTRI_CFG
{
    DWORD   dwSize;             // 结构体大小
    UINT    nMAXFloorNum;       //最大楼层 最小2
    UINT    nFloorDelayTime;    //停靠判断时间,5-60；保持此时间长度认为是电梯停靠此楼层。
    UINT    nIntervalTime;      //电梯上行或下行经过一层的最大时间,如果超过此时间,则认为电梯故障,轿厢停止了两层之间。
}DHDEV_ELEVATOR_ATTRI_CFG;

// 虚拟摄像头状态查询
typedef struct tagDHDEV_VIRTUALCAMERA_STATE_INFO
{
    DWORD              nStructSize;                  // 结构体大小
    int                nChannelID;                   // 通道号
    CONNECT_STATE      emConnectState;               // 连接状态
    UINT               uiPOEPort;                    // 此虚拟摄像头所连接的POE端口号,0表示不是POE连接 
    char               szDeviceName[64];             // 设备名称
    char               szDeviceType[128];            // 设备类型
    char               szSystemType[128];            // 系统版本
    char               szSerialNo[DH_SERIALNO_LEN];  // 序列号
    int                nVideoInput;                  // 视频输入
    int                nAudioInput;                  // 音频输入
    int                nAlarmOutput;                 // 外部报警
}DHDEV_VIRTUALCAMERA_STATE_INFO;

// 设备工作视频/线圈模式状态等信息查询
typedef struct tagDHDEV_TRAFFICWORKSTATE_INFO
{
    DWORD                nStructSize;      // 结构体大小
    int                  nChannelID;       // 通道号
    DH_TRAFFIC_SNAP_MODE emSnapMode;       // 抓拍模式
}DHDEV_TRAFFICWORKSTATE_INFO;

typedef enum tagEM_NET_DEFENCE_AREA_TYPE
{
    EM_NET_DEFENCE_AREA_TYPE_UNKNOW,                    // 未知
    EM_NET_DEFENCE_AREA_TYPE_INTIME,                    // 即时防区 
    EM_NET_DEFENCE_AREA_TYPE_DELAY,                     // 延时防区
    EM_NET_DEFENCE_AREA_TYPE_FULLDAY,                   // 24小时防区
    EM_NET_DEFENCE_AREA_TYPE_Follow,                    // 跟随防区
    EM_NET_DEFENCE_AREA_TYPE_MEDICAL,                   // 医疗紧急防区
    EM_NET_DEFENCE_AREA_TYPE_PANIC,                     // 恐慌防区
    EM_NET_DEFENCE_AREA_TYPE_FIRE,                      // 火警防区
    EM_NET_DEFENCE_AREA_TYPE_FULLDAYSOUND,              // 24小时有声防区
    EM_NET_DEFENCE_AREA_TYPE_FULLDATSLIENT,             // 24小时无声防区
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE1,                 // 出入防区1
    EM_NET_DEFENCE_AREA_TYPE_ENTRANCE2,                 // 出入防区2
    EM_NET_DEFENCE_AREA_TYPE_INSIDE,                    // 内部防区
    EM_NET_DEFENCE_AREA_TYPE_OUTSIDE,                   // 外部防区
    EN_NET_DEFENCE_AREA_TYPE_PEOPLEDETECT,              // 人员检测防区
} EM_NET_DEFENCE_AREA_TYPE;

// 本地报警事件(对DH_ALARM_ALARM_EX升级)
typedef struct tagALARM_ALARM_INFO_EX2
{
    DWORD                           dwSize;
    int                             nChannelID;             // 通道号
    int                             nAction;                // 0:开始 1:停止
    NET_TIME                        stuTime;                // 报警事件发生的时间
    NET_SENSE_METHOD                emSenseType;            // 传感器类型
    DH_MSG_HANDLE_EX                stuEventHandler;        // 联动信息
    EM_NET_DEFENCE_AREA_TYPE        emDefenceAreaType;      // 防区类型
    UINT 							nEventID;				//事件ID
    char                            szName[DH_COMMON_STRING_32];  // 通道名称               
    int                             nCount;                 // 事件发生次数
	NET_GPS_STATUS_INFO				stuGPS;					// GPS信息
	char							szUserID[32];			// 本地报警时登陆的用户ID
	char							szUserName[128];		// 本地报警时登陆的用户名
    char                            szSN[32];               // 设备序列号
	BYTE                			byReserved[832];       // 保留字节 
}ALARM_ALARM_INFO_EX2;

// 事件类型EVENT_IVS_ALARM_IPC(DVR/NVR设备上的IPC报警 )对应的数据块描述信息
typedef struct tagDEV_EVENT_ALARM_IPC_INFO
{
    int                 			nChannelID;             // 通道号
    char                			szName[128];           	// 事件名称
    char                			bReserved1[4];          // 字节对齐
    double              			PTS;                    // 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                    // 事件发生的时间
    int                 			nEventID;               // 事件ID
    int                             nAction;                // 0:开始 1:停止
	BYTE                			byReserved[1024];       // 保留字节 
} DEV_EVENT_ALARM_IPC_INFO;

/////////////////////////////////智能交通图片订阅接口参数/////////////////////////////////
typedef struct RESERVED_DATA_INTEL_BOX
{
    DWORD  dwEventCount;        //事件个数
    DWORD* dwPtrEventType;      //指向连续的事件类型的值。空间由用户自己申请,大小为sizeof(DWORD)*dwEventCount
    DWORD  dwInternalTime;      // 图片上传间隔时间,单位：s
    BYTE   bReserved[1020];     //保留字节
}ReservedDataIntelBox;

#define RESERVED_TYPE_FOR_INTEL_BOX 0x00000001
typedef struct RESERVED_PARA
{
    DWORD   dwType;         //pData的数据类型
                            //当[dwType]为 RESERVED_TYPE_FOR_INTEL_BOX 时,pData 对应为结构体ReservedDataIntelBox的地址                    
                            //当[dwType]为 RESERVED_TYPE_FOR_COMMON 时,[pData]对应为结构体NET_RESERVED_COMMON的结构体地址
                            //当[dwType]为 RESERVED_TYPE_FOR_PATH 时,[pData]对应结构体NET_RESERVED_PATH的结构体地址
    void*   pData;          //数据,由用户申请内存，大小参考对应的结构体
}ReservedPara;

#define RESERVED_TYPE_FOR_PATH  0x00000100
//图片路径类型
typedef enum tagNET_PICTURE_PATH_TYPE
{
    NET_PATH_LOCAL_PATH     ,   //本地硬盘或者sd卡成功写入路径
    NET_PATH_FTP_PATH       ,   //设备成功写到ftp服务器的路径
    NET_PATH_VIDEO_PATH     ,   //当前接入需要获取当前违章的关联视频的FTP上传路径
}NET_PICTURE_PATH_TYPE;

#define MAX_PIC_PATH_NUM        16
typedef struct tagNET_RESERVED_PATH
{
    int                     nMaxPathNum;                        //图片路径总数,为0时采用设备默认路径
    NET_PICTURE_PATH_TYPE   emPictruePaths[MAX_PIC_PATH_NUM];   //图片路径类型
}NET_RESERVED_PATH;

#define RESERVED_TYPE_FOR_COMMON   0x00000010
//离线传输参数
typedef struct tagNET_OFFLINE_PARAM
{
	char					szClientID[20];			// 客户端mac地址，冒号分隔形式
	BYTE					byReserved[108];		// 保留
}NET_OFFLINE_PARAM;

typedef struct tagNET_RESERVED_COMMON
{
	DWORD                   dwStructSize;
	ReservedDataIntelBox*   pIntelBox;          // 兼容RESERVED_TYPE_FOR_INTEL_BOX
	DWORD                   dwSnapFlagMask;     // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
	NET_OFFLINE_PARAM*		pstuOfflineParam;	// 离线传输参数
	NET_RESERVED_PATH*		pstuPath;			// 兼容RESERVED_TYPE_FOR_PATH
}NET_RESERVED_COMMON;

/////////////////////////////////智能球控制接口参数/////////////////////////////////
// 场景结构信息
typedef struct 
{
    DWORD       dwSize;
    int         nScene;     //场景编号
}DHDEV_INTELLI_SCENE_INFO;
// 场景边界限位信息
typedef struct 
{
    DWORD       dwSize;
    int         nScene;     //场景编号
    int         nType;      //0:上边界限位,1:下边界限位,2:左边界,3:右边界
}DHDEV_INTELLI_SCENELIMIT_INFO;
// 手动跟踪目标结构体信息
typedef struct
{
    DWORD       dwSize;
    int         nObjectID;   // 物体ID,-1 表示web上框选的是智能帧上传框外任意位置物体,>=0表示框选的是智能帧上传的物体
    RECT        stuBound;    // 矩形范围,点的坐标归一化到[0,8192]区间
}DHDEV_INTELLI_TRACKOBJECT_INFO;

typedef enum __TRACKCONTROL_TYPE
{
        DH_TRACK_MARKSCENE,        // 标定场景, 对应于DHDEV_INTELLI_SCENE_INFO结构体
        DH_TRACK_GOTOSCENE,        // 转动到场景,对应于DHDEV_INTELLI_SCENE_INFO结构体
        DH_TRACK_MARKSCENELIMIT,   // 标定场景边界限位,对应于DHDEV_INTELLI_SCENELIMIT_INFO结构体
        DH_TRACK_GOTOSCENELIMIT,   // 转动到场景边界限位处,对应于DHDEV_INTELLI_SCENELIMIT_INFO结构体
        DH_TRACK_MARKSCENEMAXZOOM, // 标定场景最大跟踪倍率, 对应于DHDEV_INTELLI_SCENE_INFO结构体
        DH_TRACK_OBJECT,           // 选中场景中的跟踪目标,对应于DHDEV_INTELLI_TRACKOBJECT_INFO机构体
        DH_TRACK_START,            // 开始智能跟踪,无需指定参数信息
        DH_TRACK_STOP,             // 停止智能跟踪,无需指定参数信息
        DH_TRACK_TYPE_NUM,
}DH_TRACKCONTROL_TYPE;
//智能球机控制输入参数
typedef struct tagNET_IN_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
    int         nChannelID;            // 通道ID
    DH_TRACKCONTROL_TYPE emCtrlType;   // 控制类型
    void*       pCtrlInfo;             // 控制类型对应控制信息结构体指针,参见DH_TRACKCONTROL_TYPE定义。由用户申请内存
    int         nMaxLen;               // 控制信息结构体大小
    int         nWaittime;             // 等待超时时间
}NET_IN_CONTROL_INTELLITRACKER;
//智能球机控制输出参数
typedef struct tagNET_OUT_CONTROL_INTELLITRACKER
{
    DWORD       dwSize;
}NET_OUT_CONTROL_INTELLITRACKER;

/////////////////////////////////视频分析接口参数/////////////////////////////////
#define MAX_TEMPLATEIMAGE_NUM               32                      //有效图片个数上限

//获取视频分析对象输入参数
typedef struct tagNET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // 通道ID
    char                szRule[DH_COMMON_STRING_128];               // 模板图片对应的规则
}NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE;

//获取视频分析对象输出参数
typedef struct tagNET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE
{
    DWORD               dwSize;
    unsigned int        nImageNum;                                  // 有效图片个数
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // 图片信息
    char*               pBuffer;                                    // 图片缓冲区指针, 由用户自己申请
    int                 nBufLen;                                    // 图片缓冲区大小, 由用户自己填写
    int                 nRetLen;                                    // 获取的图片数据总长度, 无需用户填写, 可以根据此参数判断分配的缓存区大小是否足够
}NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE;

//设置视频分析对象输入参数
typedef struct tagNET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD               dwSize;
    int                 nChannelID;                                 // 通道ID
    char                szRule[DH_COMMON_STRING_128];               // 模板图片对应的规则
    unsigned int        nImageNum;                                  // 有效图片个数
    DH_PIC_INFO_EX2     stuImage[MAX_TEMPLATEIMAGE_NUM];            // 图片信息
    char*               pBuffer;                                    // 图片缓冲区指针,由用户申请内存，大小为nBufLen
    int                 nBufLen;                                    // 图片缓冲区大小
}NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE;

//设置视频分析对象输出参数
typedef struct tagNET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE
{
    DWORD       dwSize;
}NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE;

/////////////////////////////////淘汰类型/////////////////////////////////

// 查询设备工作状态通道信息,相关接口已淘汰,请不要使用
typedef struct
{
    BYTE                byRecordStatic;             // 通道是否在录像；0：不录像,1：手动录像,2：自动录象
    BYTE                bySignalStatic;             // 连接的信号状态；0：正常,1：信号丢失
    BYTE                byHardwareStatic;           // 通道硬件状态；0：正常,1：异常,例如DSP死掉
    char                reserve;
    DWORD               dwBitRate;                  // 实际码率
    DWORD               dwLinkNum;                  // 客户端连接的个数
    DWORD               dwClientIP[DH_MAX_LINK];    // 客户端的IP地址
} NET_DEV_CHANNELSTATE, *LPNET_DEV_CHANNELSTATE;

// 查询设备工作状态,相关接口已淘汰,请不要使用
typedef struct
{
    DWORD                dwDeviceStatic;                    // 设备的状态；0x00：正常,0x01：CPU占用过高,0x02：硬件错误
    NET_DEV_DISKSTATE    stHardDiskStatic[DH_MAX_DISKNUM]; 
    NET_DEV_CHANNELSTATE stChanStatic[DH_MAX_CHANNUM];      //通道的状态
    BYTE                 byAlarmInStatic[DH_MAX_ALARMIN];   //报警端口的状态；0：没有报警,1：有报警
    BYTE                 byAlarmOutStatic[DH_MAX_ALARMOUT]; //报警输出端口的状态；0：没有输出,1：有报警输出
    DWORD                dwLocalDisplay;                    // 本地显示状态；0：正常,1：不正常
} NET_DEV_WORKSTATE, *LPNET_DEV_WORKSTATE;

// 协议信息
typedef struct 
{
    char                 protocolname[12];        // 协议名
    unsigned int         baudbase;                // 波特率
    unsigned char        databits;                // 数据位
    unsigned char        stopbits;                // 停止位
    unsigned char        parity;                  // 校验位
    unsigned char        reserve;
} PROTOCOL_INFO, *LPPROTOCOL_INFO;

// 语音对讲参数配置
typedef struct 
{
    // 音频输入参数
    BYTE                byInFormatTag;            // 编码类型,如PCM
    BYTE                byInChannels;             // 声道数
    WORD                wInBitsPerSample;         // 采样深度                    
    DWORD               dwInSamplesPerSec;        // 采样率

    // 音频输出参数
    BYTE                byOutFormatTag;           // 编码类型,如PCM
    BYTE                byOutChannels;            // 声道数
    WORD                wOutBitsPerSample;        // 采样深度                
    DWORD               dwOutSamplesPerSec;       // 采样率
} DHDEV_TALK_CFG, *LPDHDEV_TALK_CFG;


/////////////////////////////////// 矩阵 ///////////////////////////////////////

#define DH_MATRIX_INTERFACE_LEN         16          // 信号接口名称长度
#define DH_MATRIX_MAX_CARDS             128         // 矩阵子卡最大数量
#define DH_SPLIT_PIP_BASE               1000        // 分割模式画中画的基础值
#define DH_MAX_SPLIT_MODE_NUM           64          // 最大分割模式数
#define DH_MATRIX_MAX_CHANNEL_IN        1500        // 矩阵最大输入通道数
#define DH_MATRIX_MAX_CHANNEL_OUT       256         // 矩阵最大输出通道数
#define DH_DEVICE_NAME_LEN              64          // 设备名称长度
#define DH_MAX_CPU_NUM                  16          // 最大CPU数量
#define DH_MAX_FAN_NUM                  16          // 最大风扇数量
#define DH_MAX_POWER_NUM                16          // 最大电源数量
#define DH_MAX_BATTERY_NUM              16          // 最大电池数量
#define DH_MAX_TEMPERATURE_NUM          256         // 最大温度传感器数量
#define DH_MAX_ISCSI_NAME_LEN           128         // ISCSI名称长度
#define DH_VERSION_LEN                  64          // 版本信息长度
#define DH_MAX_STORAGE_PARTITION_NUM    32          // 存储分区最大数量
#define DH_STORAGE_MOUNT_LEN            64          // 挂载点长度
#define DH_STORAGE_FILE_SYSTEM_LEN      16          // 文件系统名称长度
#define DH_MAX_MEMBER_PER_RAID          32          // RAID成员最大数量
#define DH_DEV_ID_LEN_EX                128         // 设备ID最大长度
#define DH_MAX_BLOCK_NUM                32          // 最大区块数量
#define DH_MAX_SPLIT_WINDOW             128         // 最大分割窗口数量
#define DH_FILE_TYPE_LEN                64          // 文件类型长度
#define DH_DEV_ID_LEN                   128         // 设备ID最大长度
#define DH_DEV_NAME_LEN                 128         // 设备名称最大长度
#define DH_TSCHE_DAY_NUM                8           // 时间表第一维大小, 表示天数
#define DH_TSCHE_SEC_NUM                6           // 时间表第二维大小, 表示时段数
#define DH_SPLIT_INPUT_NUM              256         // 司法设备二级切换时第一级split支持的输入通道数

#define DH_DEVICE_ID_LOCAL              "Local"     // 本地设备ID
#define DH_DEVICE_ID_REMOTE             "Remote"    // 远程设备ID
#define DH_DEVICE_ID_UNIQUE             "Unique"    // 设备内统一编号

// 分割模式
typedef enum tagDH_SPLIT_MODE
{
    DH_SPLIT_1 = 1,                                 // 1画面
    DH_SPLIT_2 = 2,                                 // 2画面
    DH_SPLIT_4 = 4,                                 // 4画面
    DH_SPLIT_6 = 6,                                 // 6画面
    DH_SPLIT_8 = 8,                                 // 8画面
    DH_SPLIT_9 = 9,                                 // 9画面
    DH_SPLIT_12 = 12,                               // 12画面
    DH_SPLIT_16 = 16,                               // 16画面
    DH_SPLIT_20 = 20,                               // 20画面
    DH_SPLIT_25 = 25,                               // 25画面
    DH_SPLIT_36 = 36,                               // 36画面
    DH_SPLIT_64 = 64,                               // 64画面
    DH_SPLIT_144 = 144,                             // 144画面
    DH_PIP_1 = DH_SPLIT_PIP_BASE + 1,               // 画中画模式, 1个全屏大画面+1个小画面窗口
    DH_PIP_3 = DH_SPLIT_PIP_BASE + 3,               // 画中画模式, 1个全屏大画面+3个小画面窗口
    DH_SPLIT_FREE = DH_SPLIT_PIP_BASE * 2,          // 自由开窗模式,可以自由创建、关闭窗口,自由设置窗口位置和Z轴次序
    DH_COMPOSITE_SPLIT_1 = DH_SPLIT_PIP_BASE * 3 + 1,    // 融合屏成员1分割
    DH_COMPOSITE_SPLIT_4 = DH_SPLIT_PIP_BASE * 3 + 4,    // 融合屏成员4分割
	DH_SPLIT_3  = 10,                                // 3画面
	DH_SPLIT_3B = 11,								 // 3画面倒品 
} DH_SPLIT_MODE;

#define DH_PROTOCOL_DAHUA2 DH_PROTOCOL_PRIVATE2
#define DH_PROTOCOL_DAHUA3 DH_PROTOCOL_PRIVATE3

// 设备协议类型
typedef enum tagDH_DEVICE_PROTOCOL
{
    DH_PROTOCOL_PRIVATE2,                   // 私有2代协议
    DH_PROTOCOL_PRIVATE3,                   // 私有3代协议
    DH_PROTOCOL_ONVIF,                      // Onvif    
    DH_PROTOCOL_VNC,                        // 虚拟网络计算机
    DH_PROTOCOL_TS,                         // 标准TS
    DH_PROTOCOL_ECLOUD,                     // 云睿接入
    
    DH_PROTOCOL_PRIVATE = 100,              // 私有协议        
    DH_PROTOCOL_AEBELL,                     // 美电贝尔        
    DH_PROTOCOL_PANASONIC,                  // 松下        
    DH_PROTOCOL_SONY,                       // 索尼        
    DH_PROTOCOL_DYNACOLOR,                  // Dynacolor        
    DH_PROTOCOL_TCWS,                       // 天城威视        
    DH_PROTOCOL_SAMSUNG,                    // 三星        
    DH_PROTOCOL_YOKO,                       // YOKO        
    DH_PROTOCOL_AXIS,                       // 安讯视        
    DH_PROTOCOL_SANYO,                      // 三洋               
    DH_PROTOCOL_BOSH,                       // Bosch        
    DH_PROTOCOL_PECLO,                      // Peclo        
    DH_PROTOCOL_PROVIDEO,                   // Provideo        
    DH_PROTOCOL_ACTI,                       // ACTi        
    DH_PROTOCOL_VIVOTEK,                    // Vivotek        
    DH_PROTOCOL_ARECONT,                    // Arecont        
    DH_PROTOCOL_PRIVATEEH,                  // PrivateEH            
    DH_PROTOCOL_IMATEK,                     // IMatek        
    DH_PROTOCOL_SHANY,                      // Shany        
    DH_PROTOCOL_VIDEOTREC,                  // 动力盈科        
    DH_PROTOCOL_URA,                        // Ura        
    DH_PROTOCOL_BITICINO,                   // Bticino         
    DH_PROTOCOL_ONVIF2,                     // Onvif协议类型, 同DH_PROTOCOL_ONVIF    
    DH_PROTOCOL_SHEPHERD,                   // 视霸        
    DH_PROTOCOL_YAAN,                       // 亚安        
    DH_PROTOCOL_AIRPOINT,                   // Airpop        
    DH_PROTOCOL_TYCO,                       // TYCO        
    DH_PROTOCOL_XUNMEI,                     // 讯美        
    DH_PROTOCOL_HIKVISION,                  // 海康        
    DH_PROTOCOL_LG,                         // LG        
    DH_PROTOCOL_AOQIMAN,                    // 奥奇曼        
    DH_PROTOCOL_BAOKANG,                    // 宝康            
    DH_PROTOCOL_WATCHNET,                   // Watchnet        
    DH_PROTOCOL_XVISION,                    // Xvision        
    DH_PROTOCOL_FUSITSU,                    // 富士通        
    DH_PROTOCOL_CANON,                      // Canon        
    DH_PROTOCOL_GE,                         // GE        
    DH_PROTOCOL_Basler,                     // 巴斯勒        
    DH_PROTOCOL_Patro,                      // 帕特罗        
    DH_PROTOCOL_CPKNC,                      // CPPLUS K系列        
    DH_PROTOCOL_CPRNC,                      // CPPLUS R系列        
    DH_PROTOCOL_CPUNC,                      // CPPLUS U系列        
    DH_PROTOCOL_CPPLUS,                     // CPPLUS IPC    
    DH_PROTOCOL_XunmeiS,                    // 讯美s,实际协议为Onvif        
    DH_PROTOCOL_GDDW,                       // 广东电网        
    DH_PROTOCOL_PSIA,                       // PSIA        
    DH_PROTOCOL_GB2818,                     // GB2818            
    DH_PROTOCOL_GDYX,                       // GDYX        
    DH_PROTOCOL_OTHER,                      // 由用户自定义   
} DH_DEVICE_PROTOCOL;

// 一屏幕的分割模式信息
typedef struct tagDH_SPLIT_MODE_INFO
{
    DWORD               dwSize;
    DH_SPLIT_MODE       emSplitMode;            // 分割模式
    int                 nGroupID;               // 分组序号
    DWORD               dwDisplayType;          // 显示类型；具体见DH_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）
} DH_SPLIT_MODE_INFO;

// 分割能力
typedef struct tagDH_SPLIT_CAPS 
{
    DWORD               dwSize;
    int                 nModeCount;                             // 支持的分割模式数量
    DH_SPLIT_MODE       emSplitMode[DH_MAX_SPLIT_MODE_NUM];     // 支持的分割模式
    int                 nMaxSourceCount;                        // 最大显示源配置数
    int                 nFreeWindowCount;                       // 支持的最大自由开窗数目
    BOOL                bCollectionSupported;                   // 是否支持区块收藏
    DWORD               dwDisplayType;                          // 掩码表示多个显示类型,具体见DH_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）
    int                 nPIPModeCount;                          // 画中画支持的分割模式数量
    DH_SPLIT_MODE       emPIPSplitMode[DH_MAX_SPLIT_MODE_NUM];  // 画中画支持的分割模式
    int                 nInputChannels[DH_SPLIT_INPUT_NUM];     // 支持的输入通道
    int                 nInputChannelCount;                     // 支持的输入通道个数, 0表示没有输入通道限制
    int                 nBootModeCount;                         // 启动分割模式数量
    DH_SPLIT_MODE       emBootMode[DH_MAX_SPLIT_MODE_NUM];      // 支持的启动默认画面分割模式
} DH_SPLIT_CAPS;

// 级联权限验证信息
typedef struct tagDH_CASCADE_AUTHENTICATOR
{
    DWORD               dwSize;
    char                szUser[DH_NEW_USER_NAME_LENGTH];        // 用户名
    char                szPwd[DH_NEW_USER_PSW_LENGTH];          // 密码
    char                szSerialNo[DH_SERIALNO_LEN];            // 设备序列号
} DH_CASCADE_AUTHENTICATOR;

typedef enum tagEM_SRC_PUSHSTREAM_TYPE
{   
    EM_SRC_PUSHSTREAM_AUTO,        // 设备端根据码流头自动识别，默认值
    EM_SRC_PUSHSTREAM_HIKVISION,   // 海康私有码流
    EM_SRC_PUSHSTREAM_PS,          // PS流
    EM_SRC_PUSHSTREAM_TS,          // TS流
    EM_SRC_PUSHSTREAM_SVAC,        // SVAC码流
}EM_SRC_PUSHSTREAM_TYPE;


// 加密等级
typedef enum tagEM_ENCRYPT_LEVEL
{
    EM_ENCRYPT_LEVEL_UNKNOWN,		    // 未知
    EM_ENCRYPT_LEVEL_NONE,		        // 不加密
    EM_ENCRYPT_LEVEL_IFRAME256,		    // 加密I帧前256字节
    EM_ENCRYPT_LEVEL_IFRAME_WHOLE,		// 加密整个I帧
    EM_ENCRYPT_LEVEL_IAXFRAME,		    // 对I帧, 音频帧及其他辅助帧进行加密
}EM_ENCRYPT_LEVEL;

// 码流加密方式
typedef enum tagEM_ENCRYPT_ALGORITHM_TYPE
{
    EM_ENCRYPT_ALGORITHM_UNKNOWN,		    // 未知
    EM_ENCRYPT_ALGORITHM_AES,		        // AES加密
    EM_ENCRYPT_ALGORITHM_DES,		        // DES加密
    EM_ENCRYPT_ALGORITHM_3DES,		        // 3DES加密
}EM_ENCRYPT_ALGORITHM_TYPE;

// 密钥交换方式
typedef enum tagEM_KEY_EXCHANGE_TYPE
{
    EM_KEY_EXCHANGE_UNKNOWN,            // 未知
    EM_KEY_EXCHANGE_MIKEY,              // Mikey密钥
    EM_KEY_EXCHANGE_PSK,                // 预共享密钥
    EM_KEY_EXCHANGE_PK,                 // 公共密钥
    EM_KEY_EXCHANGE_DH,                 // 霍夫曼密钥
}EM_KEY_EXCHANGE_TYPE;

// 显示源码流加密方式
typedef struct tagNET_SOURCE_STREAM_ENCRYPT
{
    EM_ENCRYPT_LEVEL            emEncryptLevel;         // 加密等级
    EM_ENCRYPT_ALGORITHM_TYPE   emAlgorithm;            // 加密算法
    EM_KEY_EXCHANGE_TYPE        emExchange;             // 密钥交换方式
    BOOL                        bUnvarnished;           // MTS使用场景,true为交互MIKEY后让数据不进行加/解密
    char                        szPSK[1032];            // 密钥
    BYTE                        byReserved[1024];       // 保留字节
}NET_SOURCE_STREAM_ENCRYPT;

// 显示源
typedef struct tagDH_SPLIT_SOURCE
{
    DWORD               dwSize;
    BOOL                bEnable;                                // 使能
    char                szIp[DH_MAX_IPADDR_LEN];                // IP, 空表示没有设置
    char                szUser[DH_USER_NAME_LENGTH];            // 用户名, 建议使用szUserEx
    char                szPwd[DH_USER_PSW_LENGTH];              // 密码, 建议使用szPwdEx
    int                 nPort;                                  // 端口
    int                 nChannelID;                             // 通道号
    int                 nStreamType;                            // 视频码流, -1-自动, 0-主码流, 1-辅码流1, 2-辅码流2, 3-辅码流3, 4-snap, 5-预览
    int                 nDefinition;                            // 清晰度, 0-标清, 1-高清
    DH_DEVICE_PROTOCOL  emProtocol;                             // 协议类型
    char                szDevName[DH_DEVICE_NAME_LEN];          // 设备名称
    int                 nVideoChannel;                          // 视频输入通道数
    int                 nAudioChannel;                          // 音频输入通道数
    //--------------------------------------------------------------------------------------
    // 以下只对解码器有效
    BOOL                bDecoder;                               // 是否是解码器
    BYTE                byConnType;                             // -1: auto, 0：TCP；1：UDP；2：组播
    BYTE                byWorkMode;                             // 0：直连；1：转发
    WORD                wListenPort;                            // 指示侦听服务的端口,转发时有效; byConnType为组播时,则作为多播端口
    char                szDevIpEx[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp扩展,前端DVR的IP地址(可以输入域名)
    BYTE                bySnapMode;                             // 抓图模式(nStreamType==4时有效) 0：表示请求一帧,1：表示定时发送请求
    BYTE                byManuFactory;                          // 目标设备的生产厂商, 具体参考EM_IPC_TYPE类
    BYTE                byDeviceType;                           // 目标设备的设备类型, 0:IPC
    BYTE                byDecodePolicy;                         // 目标设备的解码策略, 0:兼容以前
                                                                // 1:实时等级高 2:实时等级中
                                                                // 3:实时等级低 4:默认等级
                                                                // 5:流畅等级高 6:流畅等级中
                                                                // 7:流畅等级低
    //--------------------------------------------------------------------------------------
    DWORD               dwHttpPort;                             // Http端口号, 0-65535
    DWORD               dwRtspPort;                             // Rtsp端口号, 0-65535
    char                szChnName[DH_DEVICE_NAME_LEN];          // 远程通道名称, 只有读取到的名称不为空时才可以修改该通道的名称
    char                szMcastIP[DH_MAX_IPADDR_LEN];           // 多播IP地址, byConnType为组播时有效
    char                szDeviceID[DH_DEV_ID_LEN_EX];           // 设备ID, ""-null, "Local"-本地通道, "Remote"-远程通道, 或者填入具体的RemoteDevice中的设备ID
    BOOL                bRemoteChannel;                         // 是否远程通道(只读)
    unsigned int        nRemoteChannelID;                       // 远程通道ID(只读), bRemoteChannel=TRUE时有效
    char                szDevClass[DH_DEV_TYPE_LEN];            // 设备类型, 如IPC, DVR, NVR等
    char                szDevType[DH_DEV_TYPE_LEN];             // 设备具体型号, 如IPC-HF3300
    char                szMainStreamUrl[MAX_PATH];              // 主码流url地址, byManuFactory为DH_IPC_OTHER时有效
    char                szExtraStreamUrl[MAX_PATH];             // 辅码流url地址, byManuFactory为DH_IPC_OTHER时有效
    int                 nUniqueChannel;                         // 设备内统一编号的唯一通道号, 只读
    DH_CASCADE_AUTHENTICATOR stuCascadeAuth;                    // 级联认证信息, 设备ID为"Local/Cascade/SerialNo"时有效, 其中SerialNo是设备序列号
    int                 nHint;                                  // 0-普通视频源, 1-报警视频源
    int                 nOptionalMainUrlCount;                  // 备用主码流地址数量
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH];  // 备用主码流地址列表
    int                 nOptionalExtraUrlCount;                 // 备用辅码流地址数量
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // 备用辅码流地址列表
    //--------------------------------------------------------------------------------------
    //协议后续添加字段
    int                 nInterval;                              // 轮巡时间间隔   单位：秒
    char                szUserEx[DH_NEW_USER_NAME_LENGTH];      // 用户名
    char                szPwdEx[DH_NEW_USER_PSW_LENGTH];        // 密码
    EM_SRC_PUSHSTREAM_TYPE  emPushStream;                       // 推流方式的码流类型,只有byConnType为TCP-Push或UDP-Push才有该字段
	NET_RECT			stuSRect;					            // 视频源区域,当szDeviceID不为空时有效,若区域为(0,0,0,0)表示数据无效，设备使用默认值(0,0,8192,8192)
    NET_SOURCE_STREAM_ENCRYPT stuSourceStreamEncrypt;           // 码流加密方式
    char                szSerialNo[DH_SERIALNO_LEN];            // 设备序列号,当连接设备的协议类型为云睿接入，该字段必填
} DH_SPLIT_SOURCE;


// 视频输出能力集
typedef struct tagDH_VIDEO_OUT_CAPS 
{
    DWORD               dwSize;
    BOOL                bColor;                                 // 是否支持输出颜色设置
    BOOL                bMargin;                                // 是否支持边界设置
    int                 nLayers;                                // 支持同时显示的图层数
    BOOL                bPowerMode;                             // 是否支持电源控制
    int                 bSplitMode;                             // 支持的画面分割模式, 0-单画面, 1-'#'字型模式(包括单画面), 2-任意模式
    unsigned int        nBackground;                            // 支持的背景方式, 按位表示, 0-颜色, 1-图片
    BOOL                bBindOutput;                            // 是否支持输出屏分辨率绑定设置
    BOOL                bAudioSupport;                          // 是否支持音频输出
    DWORD               dwAudioMode;                            // 支持的音频模式, 按位表示, bit0-主控输出, bit1-子卡输出
} DH_VIDEO_OUT_CAPS;

// 颜色BCSH
typedef struct tagDH_COLOR_BCSH 
{
    int                 nBirghtness;                // 亮度
    int                 nContrast;                  // 对比度
    int                 nSaturation;                // 饱和度
    int                 nHue;                       // 色调
} DH_COLOR_BCSH;

// 尺寸
typedef struct tagDH_SIZE 
{
    int                 nWidth;                     // 宽度
    int                 nHeight;                    // 高度
} DH_SIZE;

// 热拔插模式
typedef struct tagDH_HOT_PLUG_MODE
{
    DWORD               dwSize;
    int                 nMode;                      // 热拔插模式, 0-热插拔模式, 1-强制输出模式
} DH_HOT_PLUG_MODE;

// 视频输出选项
typedef struct tagDH_VIDEO_OUT_OPT
{
    DWORD               dwSize;
    DH_RECT*            pstuMargin;                 // 边界范围
    DH_COLOR_BCSH*      pstuColor;                  // 输出颜色
    DH_COLOR_RGBA*      pstuBackground;             // 背景色
    DH_SIZE*            pstuSize;                   // 输出尺寸
    DH_HOT_PLUG_MODE*   pstuHotPlugMode;            // 热拔插模式
} DH_VIDEO_OUT_OPT;

#define NET_VIDEOANALYSE_SCENES (32)
#define NET_VIDEOANALYSE_RULES (64)

// 智能分析
typedef struct tagNET_PD_VIDEOANALYSE
{
    BOOL                bSupport;                   // 是否支持智能分析
    char                szSupportScenes[NET_VIDEOANALYSE_SCENES][DH_COMMON_STRING_64];   // 支持的场景
    char                SupportRules[NET_VIDEOANALYSE_RULES][DH_COMMON_STRING_64];       // 支持的规则
} NET_PD_VIDEOANALYSE;

// 设备声道支持类型
typedef enum tagEM_AUDIO_CHANNEL_TYPE
{
	EM_AUDIO_CHANNEL_SINGLE,		// 单声道
	EM_AUDIO_CHANNEL_DOUBLE,		// 双声道
}EM_AUDIO_CHANNEL_TYPE;

// WIFI扫描及配置支持的版本类型
typedef enum tagEM_WLAN_SCAN_AND_CONFIG_TYPE
{
    EM_WLAN_SCAN_AND_CONFIG_UNKNOWN,    // 未知
    EM_WLAN_SCAN_AND_CONFIG_V2,         // V2:二代协议
    EM_WLAN_SCAN_AND_CONFIG_V3,         // v3:三代协议
}EM_WLAN_SCAN_AND_CONFIG_TYPE;

// 产品定义
typedef struct tagDH_PRODUCTION_DEFNITION
{
    DWORD               dwSize;
    int                 nVideoInChannel;                        // 视频输入通道数
    int                 nVideoOutChannel;                       // 视频输出通道数
    int                 nRemoteDecChannel;                      // 远程解码通道数
    char                szDevType[DH_DEV_TYPE_LEN];             // 设备类型
    char                szVendor[DH_MAX_NAME_LEN];              // OEM客户
    int                 nOEMVersion;                            // OEM版本
    int                 nMajorVerion;                           // 主版本号
    int                 nMinorVersion;                          // 次版本号
    int                 nRevision;                              // 修订版本
    char                szWebVerion[DH_MAX_NAME_LEN];           // Web版本
    char                szDefLanguage[DH_MAX_NAME_LEN];         // 默认语言
    NET_TIME            stuBuildDateTime;                       // 发布时间, 精确到秒
    int                 nAudioInChannel;                        // 音频输入通道数
    int                 nAudioOutChannel;                       // 音频输出通道数
    BOOL                bGeneralRecord;                         // 是否支持定时存储
    BOOL                bLocalStore;                            // 是否支持本地存储
    BOOL                bRemoteStore;                           // 是否支持网络存储
    BOOL                bLocalurgentStore;                      // 是否支持紧急存储到本地
    BOOL                bRealtimeCompress;                      // 是否支持实时压缩存储
    DWORD               dwVideoStandards;                       // 支持的视频制式列表, bit0-PAL, bit1-NTSC
    int                 nDefVideoStandard;                      // 默认视频制式, 0-PAL, 1-NTSC
    int                 nMaxExtraStream;                        // 最大辅码流路数
    int                 nRemoteRecordChannel;                   // 远程录像通道数
    int                 nRemoteSnapChannel;                     // 远程抓图通道数
    int                 nRemoteVideoAnalyseChannel;             // 远程视频分析通道数
    int                 nRemoteTransmitChannel;                 // 远程实时流转发最大通道数
    int                 nRemoteTransmitFileChannel;             // 远程文件流竹筏通道通道数
    int                 nStreamTransmitChannel;                 // 最大网络传输通道总数
    int                 nStreamReadChannel;                     // 最大读文件流通道总数
    int                 nMaxStreamSendBitrate;                  // 最大码流网络发送能力, kbps
    int                 nMaxStreamRecvBitrate;                  // 最大码流网络接口能力, kbps
    BOOL                bCompressOldFile;                       // 是否压缩旧文件, 去除P帧, 保留I帧
    BOOL                bRaid;                                  // 是否支持RAID
    int                 nMaxPreRecordTime;                      // 最大预录时间, s
    BOOL                bPtzAlarm;                              // 是否支持云台报警
    BOOL                bPtz;                                   // 是否支持云台
    BOOL                bATM;                                   // 是否显示ATM相关功能
    BOOL                b3G;                                    // 是否支持3G模块
    BOOL                bNumericKey;                            // 是否带数字键
    BOOL                bShiftKey;                              // 是否带Shift键
    BOOL                bCorrectKeyMap;                         // 数字字母映射表是否正确
    BOOL                bNewATM;                                // 新的二代ATM前面板
    BOOL                bDecoder;                               // 是否是解码器
    DEV_DECODER_INFO    stuDecoderInfo;                         // 解码器信息, bDecoder=true时有效
    int                 nVideoOutputCompositeChannels;          // 融合屏输出通道上限
    BOOL                bSupportedWPS;                          // 是否支持WPS功能
    int                 nVGAVideoOutputChannels;                // VGA视频输出通道数
    int                 nTVVideoOutputChannels;                 // TV视频输出通道数
    int                 nMaxRemoteInputChannels;                // 最大远程通道数
    int                 nMaxMatrixInputChannels;                // 最大矩阵通道数
    int                 nMaxRoadWays;                           // 智能交通最大车道数 1~6
    int                 nMaxParkingSpaceScreen;                 // 和相机对接最多支持的区域屏个数 0~20

    int                 nPtzHorizontalAngleMin;                 // 云台水平最小角度, [0-360]
    int                 nPtzHorizontalAngleMax;                 // 云台水平最大角度, [0-360]
    int                 nPtzVerticalAngleMin;                   // 云台垂直最小角度, [-90,90]
    int                 nPtzVerticalAngleMax;                   // 云台垂直最大角度, [-90,90]
    BOOL                bPtzFunctionMenu;                       // 是否支持云台功能菜单
    BOOL                bLightingControl;                       // 是否支持灯光控制
    DWORD               dwLightingControlMode;                  // 手动灯光控制模式, 按位, 见NET_LIGHTING_CTRL_ON_OFF
    int                 nNearLightNumber;                       // 近光灯组数量, 0表示不支持
    int                 nFarLightNumber;                        // 远光灯组数量, 0表示不支持
    BOOL                bFocus;                                 // 是否支持控制聚焦
    BOOL                bIris;                                  // 是否支持控制光圈
    char                szPtzProtocolList[DH_COMMON_STRING_1024];// 云台支持的协议列表, 可以是多个, 每个用';'分隔
    BOOL                bRainBrushControl;                      // 是否支持雨刷控制
    int                 nBrushNumber;                           // 雨刷数量, 为0时表示不支持
    int                 nLowerMatrixInputChannels[DH_MAX_LOWER_MITRIX_NUM]; // 下位矩阵视频输入通道, 下标对应矩阵编号
    int                 nLowerMatrixOutputChannels[DH_MAX_LOWER_MITRIX_NUM];// 下位矩阵视频输出通道, 下标对应矩阵编号
    BOOL                bSupportVideoAnalyse;                   // 是否支持智能分析
    BOOL                bSupportIntelliTracker;                 // 是否支持智能跟踪

    DWORD               nSupportBreaking;                       //设备支持的违章类型掩码(按位获取)
                                                                //0-闯红灯 1-压线 2-逆行 3-欠速 4-超速 5-有车占道 6-黄牌占道 7-违章行驶（左转、右转、调头）
                                                                //8-违章进入待行区 9-违章停车 10-交通拥堵 11-不按车道行驶 12-违章变道 13-压黄线 14-路肩行驶
                                                                //15-手动抓拍 16-违章滞留 17-斑马线行人优先 18-流量过大 19-流量过小 20-违章占道 21-违章倒车
                                                                //22-压停止线 23-闯黄灯 24-黄网格线停车 25-车位有车 26-车位无车 27-车位有车压线 28-受限车牌
                                                                //29-禁行 30-不系安全带 31-驾驶员抽烟
    DWORD               nSupportBreaking1;                      //0-驾驶员打电话 1-行人闯红灯 2-车辆拥堵禁入 3-未按规定依次交替通行
    NET_PD_VIDEOANALYSE stuVideoAnalyse;                        //智能分析
    BOOL                bTalkTransfer;                          //是否支持转发对讲功能
	BOOL				bCameraAttribute;						// 是否支持球机摄像头属性页面
	BOOL				bPTZFunctionViaApp;						// 是否支持由应用主控的云台功能逻辑
	BOOL				bAudioProperties;						// 喇叭是否支持语音播报
	BOOL				bIsCameraIDOsd;							// 是否支持摄像机编号叠加
	BOOL				bIsPlaceOsd;							// 是否支持地点信息叠加

	unsigned int		nMaxGeographyTitleLine;					// 地理位置叠加最大支持行数
	EM_AUDIO_CHANNEL_TYPE emAudioChannel;					    // 设备声道支持类型
	char				szVendorAbbr[DH_COMMON_STRING_32];		// 厂商缩写
	char				szTypeVersion[DH_COMMON_STRING_32];		// 软件发布类型
	BOOL				bIsVideoNexus;							// 是否是视讯互联大基线
    EM_WLAN_SCAN_AND_CONFIG_TYPE    emWlanScanAndConfig;        // WIFI扫描及配置支持的版本类型
    BOOL                bSupportLensMasking;                    // IPC是否支持镜头调节到负角度，进行结构遮挡
} DH_PRODUCTION_DEFNITION;

// 手动灯光控制模式
#define NET_LIGHTING_CTRL_ON_OFF                0x01            // 直接开关模式
#define NET_LIGHTING_CTRL_ADJUST_BRIGHTNESS     0x02            // 手动调节亮度模式
#define NET_LIGHTING_CTRL_ZOOM_PRIO             0x04            // 倍率优先


// 矩阵子卡类型, 多种类型可以组合
#define DH_MATRIX_CARD_MAIN                 0x10000000          // 主卡
#define DH_MATRIX_CARD_INPUT                0x00000001          // 输入卡
#define DH_MATRIX_CARD_OUTPUT               0x00000002          // 输出卡
#define DH_MATRIX_CARD_ENCODE               0x00000004          // 编码卡
#define DH_MATRIX_CARD_DECODE               0x00000008          // 解码卡
#define DH_MATRIX_CARD_CASCADE              0x00000010          // 级联卡
#define DH_MATRIX_CARD_INTELLIGENT          0x00000020          // 智能卡
#define DH_MATRIX_CARD_ALARM                0x00000040          // 报警卡
#define DH_MATRIX_CARD_RAID                 0x00000080          // 硬Raid卡
#define DH_MATRIX_CARD_NET_DECODE           0x00000100          // 网络解码卡

// 矩阵子卡信息
typedef struct tagDH_MATRIX_CARD
{
    DWORD               dwSize;
    BOOL                bEnable;                                // 是否有效
    DWORD               dwCardType;                             // 子卡类型
    char                szInterface[DH_MATRIX_INTERFACE_LEN];   // 子卡接口类型, "CVBS", "VGA", "DVI", "BT656","BT1120", "Fiber","HD-SDI", "HDCVI","HDMI","Dual-Link","3G-SDI", "RJ45"...
    char                szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN]; // 设备ip或域名, 无网络接口的子卡可以为空
    int                 nPort;                                  // 端口号, 无网络接口的子卡可以为0
    int                 nDefinition;                            // 清晰度, 0=标清, 1=高清
    int                 nVideoInChn;                            // 视频输入通道数
    int                 nAudioInChn;                            // 音频输入通道数
    int                 nVideoOutChn;                           // 视频输出通道数
    int                 nAudioOutChn;                           // 音频输出通道数
    int                 nVideoEncChn;                           // 视频编码通道数
    int                 nAudioEncChn;                           // 音频编码通道数
    int                 nVideoDecChn;                           // 视频解码通道数
    int                 nAudioDecChn;                           // 音频解码通道数
    int                 nStauts;                                // 状态: -1-未知, 0-正常, 1-无响应, 2-网络掉线, 3-冲突, 4-正在升级, 5-链路状态异常, 6-子板背板未插好, 7-程序版本出错
    int                 nCommPorts;                             // 串口数
    int                 nVideoInChnMin;                         // 视频输入通道号最小值
    int                 nVideoInChnMax;                         // 视频输入通道号最大值
    int                 nAudioInChnMin;                         // 音频输入通道号最小值
    int                 nAudioInChnMax;                         // 音频输入通道号最大值
    int                 nVideoOutChnMin;                        // 视频输出通道号最小值
    int                 nVideoOutChnMax;                        // 视频输出通道号最大值
    int                 nAudioOutChnMin;                        // 音频输出通道号最小值
    int                 nAudioOutChnMax;                        // 音频输出通道号最大值    
    int                 nVideoEncChnMin;                        // 视频编码通道号最小值
    int                 nVideoEncChnMax;                        // 视频编码通道号最大值
    int                 nAudioEncChnMin;                        // 音频编码通道号最小值
    int                 nAudioEncChnMax;                        // 音频编码通道号最大值
    int                 nVideoDecChnMin;                        // 视频解码通道号最小值
    int                 nVideoDecChnMax;                        // 视频解码通道号最大值
    int                 nAudioDecChnMin;                        // 音频解码通道号最小值
    int                 nAudioDecChnMax;                        // 音频解码通道号最大值
    int                 nCascadeChannels;                       // 级联通道数
    int                 nCascadeChannelBitrate;                 // 级联通道带宽, 单位Mbps
    int                 nAlarmInChnCount;                       // 报警输入通道数
    int                 nAlarmInChnMin;                         // 报警输入通道号最小值
    int                 nAlarmInChnMax;                         // 报警输入通道号最大值
    int                 nAlarmOutChnCount;                      // 报警输出通道数
    int                 nAlarmOutChnMin;                        // 报警输入通道号最小值
    int                 nAlarmOutChnMax;                        // 报警输入通道号最大值
    int                 nVideoAnalyseChnCount;                  // 智能分析通道数
    int                 nVideoAnalyseChnMin;                    // 智能分析通道号最小值
    int                 nVideoAnalyseChnMax;                    // 智能分析通道号最大值
    int                 nCommPortMin;                           // 串口号最小值
    int                 nCommPortMax;                           // 串口号最大值
    char                szVersion[DH_COMMON_STRING_32];         // 版本信息
    NET_TIME            stuBuildTime;                           // 编译时间
    char                szBIOSVersion[DH_COMMON_STRING_64];     // BIOS版本号
    char				szMAC[DH_MACADDR_LEN];					// MAC地址
} DH_MATRIX_CARD;

// 矩阵子卡列表
typedef struct tagDH_MATRIX_CARD_LIST 
{
    DWORD               dwSize;
    int                 nCount;                                 // 子卡数量
    DH_MATRIX_CARD      stuCards[DH_MATRIX_MAX_CARDS];          // 子卡列表
} DH_MATRIX_CARD_LIST;

// 视频输出窗口
typedef struct tagDH_VIDEO_OUT_WINDOW
{
    DWORD               dwSize;
    int                 nBackboardID;               // 背板号
    int                 nScreenID;                  // 屏幕号
    int                 nWindowID;                  // 窗口号
} DH_VIDEO_OUT_WINDOW;

// 设置备份源信息,输入参数
typedef struct tagNET_IN_SETBACKUP_SOURCES_INFO
{
	DWORD				dwSize;
	int					nSetSourcesNum;				// 	设置源信息个数
	DH_SPLIT_SOURCE	*	pSource;					//  源信息指针(内存由用户申请释放)
} NET_IN_SETBACKUP_SOURCES_INFO;

// 设置备份源信息,输出参数
typedef struct tagNET_OUT_SETBACKUP_SOURCES_INFO
{
	 DWORD				dwSize;
} NET_OUT_SETBACKUP_SOURCES_INFO;

// CLIENT_GetISCSITargets接口输入参数
typedef struct tagDH_IN_ISCSI_TARGETS
{
    DWORD               dwSize;
    const char*         pszAddress;                 // 服务器地址
    int                 nPort;                      // 端口
    const char*         pszUser;                    // 用户名
    const char*         pszPwd;                     // 密码
} DH_IN_ISCSI_TARGETS;

// ISCSI Target信息
typedef struct tagDH_ISCSI_TARGET 
{
    DWORD               dwSize;
    char                szName[DH_MAX_ISCSI_NAME_LEN];              // 名称
    char                szAddress[DH_MAX_IPADDR_OR_DOMAIN_LEN];     // 服务器地址
    char                szUser[DH_NEW_USER_NAME_LENGTH];            // 用户名
    int                 nPort;                                      // 端口
    UINT                nStatus;                                    // 状态, 0-未知, 1-已连接, 2-未连接, 3-连接失败, 4-认证失败, 5-连接超时, 6-不存在    
} DH_ISCSI_TARGET;

// CLIENT_GetISCSITargets接口输出参数
typedef struct tagDH_OUT_ISCSI_TARGETS
{
    DWORD               dwSize;
    DH_ISCSI_TARGET*    pstuTargets;                // iscsi数组,由用户申请内存，大小为sizeof(DH_ISCSI_TARGET)*nMaxCount
    int                 nMaxCount;                  // iscsi数组大小
    int                 nRetCount;                  // 获取到的iscsi信息数
} DH_OUT_ISCSI_TARGETS;

typedef enum tagDH_BITMAP_ACCURACY
{
    BA_DAY ,            //天 
    BA_HOUR ,           //小时
    BA_5MIN ,           //5分钟
}DH_BITMAP_ACCURACY;

#define DH_MAX_BITMAPS        256                        // 位图字节数,DH_MAX_BITMAPS*8位
#define DH_MAX_CHN_NUM        256                        // 最大通道数
//CLIENT_GetBitmap接口输入参数
typedef struct tagDH_IN_BITMAP
{
    DWORD               dwSize;
    NET_TIME            stuStartTime;                   // 开始时间, 精确到秒
    NET_TIME            stuEndTime;                     // 结束时间, 精确到秒
    int                 nChnList[DH_MAX_CHN_NUM];       // [1, …, 10]    通道号列表,-1表示全部通道,0表示列表结束
    DH_BITMAP_ACCURACY  emAccuracy;                     // 位图精度    
}DH_IN_BITMAP;

typedef struct tagDH_BITMAP_INFO
{
    DWORD               dwSize;
    int                 nChnID;                         //通道号,通道号位0,表示列表结束
    BYTE                bBitmap[DH_MAX_BITMAPS];        //位图(每一比特位表示一个查询刻度,由低位向高位填充)
                                                        //支持DH_MAX_BITMAPS * 8个刻度
    int                 nBitNum;                        //获取的位图位数
}DH_BITMAP_INFO;

//CLIENT_GetBitmap接口输出参数
typedef struct tagDH_OUT_BITMAP
{
    DWORD               dwSize;
    DH_BITMAP_INFO      *pstBitmapInfos;   // 由用户申请内存，大小为sizeof(DH_BITMAP_INFO)*nMaxBitmapInfo
    int                 nGetBitmapInfo;
    int                 nMaxBitmapInfo;    
}DH_OUT_BITMAP;

// 存储设备名称
typedef struct tagDH_STORAGE_DEVICE_NAME 
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];
} DH_STORAGE_DEVICE_NAME;

// RAID状态
#define DH_RAID_STATE_ACTIVE            0x00000001
#define DH_RAID_STATE_INACTIVE          0x00000002
#define DH_RAID_STATE_CLEAN             0x00000004
#define DH_RAID_STATE_FAILED            0x00000008
#define DH_RAID_STATE_DEGRADED          0x00000010
#define DH_RAID_STATE_RECOVERING        0x00000020
#define DH_RAID_STATE_RESYNCING         0x00000040
#define DH_RAID_STATE_RESHAPING         0x00000080
#define DH_RAID_STATE_CHECKING          0x00000100
#define DH_RAID_STATE_NOTSTARTED        0x00000200

// RAID成员信息
typedef struct tagNET_RAID_MEMBER_INFO 
{
    DWORD               dwSize;
    DWORD               dwID;                                       // 磁盘号, 可用于描述磁盘在磁柜的槽位
    BOOL                bSpare;                                     // 是否局部热备, true-局部热备, false-RAID子盘
} NET_RAID_MEMBER_INFO;

// RAID信息
typedef struct tagDH_STORAGE_RAID
{
    DWORD               dwSize;
    int                 nLevel;                                     // 等级    
    int                 nState;                                     // RAID状态组合, 如 DH_RAID_STATE_ACTIVE | DH_RAID_STATE_DEGRADED
    int                 nMemberNum;                                 // 成员数量
    char                szMembers[DH_MAX_MEMBER_PER_RAID][DH_STORAGE_NAME_LEN];    // RAID成员	
    float               fRecoverPercent;                            // 同步百分比, 0~100, RAID状态中有"Recovering"或"Resyncing"时有效
    float               fRecoverMBps;                               // 同步速度, 单位MBps, RAID状态中有"Recovering"或"Resyncing"时有效
    float               fRecoverTimeRemain;                         // 同步剩余时间, 单位分钟, RAID状态中有"Recovering"或"Resyncing"时有效
    NET_RAID_MEMBER_INFO stuMemberInfos[DH_MAX_MEMBER_PER_RAID];    // RAID成员信息
	int                 nRaidDevices;                               // RAID设备个数
	int                 nTotalDevices;                              // RAID设备总数
	int                 nActiveDevices;                             // 活动设备个数
	int                 nWorkingDevices;                            // 工作设备个数
	int                 nFailedDevices;                             // 失败设备个数
	int                 nSpareDevices;                              // 热备设备个数
	
	char                szAliasName[DH_COMMON_STRING_24];           // RAID别名,UTF-8编码
} DH_STORAGE_RAID;


// 存储分区信息
typedef struct tagDH_STORAGE_PARTITION
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];                // 名称
    INT64               nTotalSpace;                                // 总空间, byte
    INT64               nFreeSpace;                                 // 剩余空间, byte
    char                szMountOn[DH_STORAGE_MOUNT_LEN];            // 挂载点
    char                szFileSystem[DH_STORAGE_FILE_SYSTEM_LEN];   // 文件系统
    int                 nStatus;                                    // 分区状态, 0-LV不可用, 1-LV可用
} DH_STORAGE_PARTITION;

// 扩展柜信息
typedef struct tagDH_STORAGE_TANK 
{
    DWORD               dwSize;
    int                 nLevel;                                     // 级别, 主机是第0级,其它下属级别类推
    int                 nTankNo;                                    // 同一级扩展柜内的扩展口编号, 从0开始
    int                 nSlot;                                      // 对应主柜上的板卡号, 从0开始编号
} DH_STORAGE_TANK;

// 存储设备状态
#define NET_STORAGE_DEV_OFFLINE                 0                   // 物理硬盘脱机状态
#define NET_STORAGE_DEV_RUNNING                 1                   // 物理硬盘运行状态
#define NET_STORAGE_DEV_ACTIVE                  2                   // RAID活动
#define NET_STORAGE_DEV_SYNC                    3                   // RAID同步
#define NET_STORAGE_DEV_SPARE                   4                   // RAID热备(局部)
#define NET_STORAGE_DEV_FAULTY                  5                   // RAID失效
#define NET_STORAGE_DEV_REBUILDING              6                   // RAID重建
#define NET_STORAGE_DEV_REMOVED                 7                   // RAID移除
#define NET_STORAGE_DEV_WRITE_ERROR             8                   // RAID写错误
#define NET_STORAGE_DEV_WANT_REPLACEMENT        9                   // RAID需要被替换
#define NET_STORAGE_DEV_REPLACEMENT             10                  // RAID是替代设备
#define NET_STORAGE_DEV_GLOBAL_SPARE            11                  // 全局热备
#define NET_STORAGE_DEV_ERROR                   12                  // 错误, 部分分区可用
#define NET_STORAGE_DEV_RAIDSUB                 13                  // 该盘目前是单盘, 原先是块Raid子盘, 有可能在重启后自动加入Raid
#define NET_STORAGE_DEV_FATAL                   14                  // 严重错误,全部分区坏(DVR新增错误类型)
#define NET_STORAGE_DEV_SNAPSHOT_PARENT         15                  // 快照母盘
#define NET_STORAGE_DEV_SNAPSHOT_CHILD          16                  // 快照子盘
#define NET_STORAGE_DEV_VOLUMECLONE_PARENT      17                  // 卷克隆母盘
#define NET_STORAGE_DEV_VOLUMECLONE_CHILD      18                  // 卷克隆子盘

// 硬盘电源状态
typedef enum tagEM_STORAGE_DISK_POWERMODE
{
	EM_STORAGE_DISK_POWERMODE_UNKNOWN,                                  // UNKnown状态（不是以下状态中的值）
	EM_STORAGE_DISK_POWERMODE_NONE,                                     // 未知状态
	EM_STORAGE_DISK_POWERMODE_ACTIVE,                                   // 活动状态
	EM_STORAGE_DISK_POWERMODE_STANDBY,                                  // 休眠状态
	EM_STORAGE_DISK_POWERMODE_IDLE,                                     // 空闲状态
}EM_STORAGE_DISK_POWERMODE;

// 硬盘预检状态(EVS定制字段,配合磁盘预检功能使用)
typedef enum tagEM_STORAGE_DISK_PREDISKCHECK
{
	EM_STORAGE_DISK_PREDISKCHECK_UNKNOWN,                               // UnKnown状态
	EM_STORAGE_DISK_PREDISKCHECK_GOOD,                                  // 硬盘读速度到120以上,smart信息里有少量的错误,其他无任何错误.
	EM_STORAGE_DISK_PREDISKCHECK_WARN,                                  // cmd信息里有少量错误记录,smart信息有错误记录
	EM_STORAGE_DISK_PREDISKCHECK_ERROR,                                 // cmd信息有错误记录,smart信息由错误记录.坏扇区有坏扇区记录
	EM_STORAGE_DISK_PREDISKCHECK_WILLFAIL,                              // 硬盘速度比较低64M以下.cmd信息有错误记录,smart信息由错误记录.坏扇区有坏扇区记录
	EM_STORAGE_DISK_PREDISKCHECK_FAIL,                                  // 硬盘返回错误
	EM_STORAGE_DISK_PREDISKCHECK_NONE,                                  // 未知状态
	EM_STORAGE_DISK_PREDISKCHECK_BECHECK,                               // 正在查询中状态
	EM_STORAGE_DISK_PREDISKCHECK_CHECKFAIL,                             // 查询失败状态
}EM_STORAGE_DISK_PREDISKCHECK;

// 存储设备信息
typedef struct tagDH_STORAGE_DEVICE 
{
    DWORD               dwSize;
    char                szName[DH_STORAGE_NAME_LEN];                    // 名称
    INT64               nTotalSpace;                                    // 总空间, byte
    INT64               nFreeSpace;                                     // 剩余空间, byte
    BYTE                byMedia;                                        // 介质, 0-DISK, 1-CDROM, 2-FLASH
    BYTE                byBUS;                                          // 总线, 0-ATA, 1-SATA, 2-USB, 3-SDIO, 4-SCSI
	BYTE                byVolume;                                       // 卷类型, 0-物理卷, 1-Raid卷, 2-VG虚拟卷, 3-ISCSI, 4-独立物理卷, 5-全局热备卷, 6-NAS卷(包括FTP, SAMBA, NFS)
    BYTE                byState;                                        // 物理硬盘状态, 取值为 NET_STORAGE_DEV_OFFLINE 和 NET_STORAGE_DEV_RUNNING 等
    int                 nPhysicNo;                                      // 同类设备存储接口的物理编号
    int                 nLogicNo;                                       // 同类设备存储接口的逻辑编号
    char                szParent[DH_STORAGE_NAME_LEN];                  // 上级存储组名称
    char                szModule[DH_STORAGE_NAME_LEN];                  // 设备模块
    char                szSerial[DH_SERIALNO_LEN];                      // 设备序列号
    char                szFirmware[DH_VERSION_LEN];                     // 固件版本
    int                 nPartitionNum;                                  // 分区数
    DH_STORAGE_PARTITION stuPartitions[DH_MAX_STORAGE_PARTITION_NUM];   // 分区信息
    DH_STORAGE_RAID     stuRaid;                                        // RAID信息, 只对RAID有效(byVolume == 1)
    DH_ISCSI_TARGET     stuISCSI;                                       // ISCSI信息, 只对ISCSI盘有效(byVolume == 3)
    BOOL                abTank;                                         // 扩展柜使能
    DH_STORAGE_TANK     stuTank;                                        // 硬盘所在扩展柜信息, abTank为TRUE时有效

	EM_STORAGE_DISK_POWERMODE           emPowerMode;                    // 硬盘电源状态
	EM_STORAGE_DISK_PREDISKCHECK        emPreDiskCheck;                 // 硬盘预检状态(EVS定制字段，配合磁盘预检功能使用)
} DH_STORAGE_DEVICE;

// 分割窗口OSD信息
typedef struct tagNET_SPLIT_OSD 
{
    DWORD               dwSize;
    BOOL                bEnable;                    // 使能
    DH_COLOR_RGBA       stuFrontColor;              // 前景颜色
    DH_COLOR_RGBA       stuBackColor;               // 背景颜色
    DH_RECT             stuFrontRect;               // 前景区域
    DH_RECT             stuBackRect;                // 背景区域
    BOOL                bRoll;                      // 是否滚动显示, 只对文本有效
    BYTE                byRollMode;                 // 滚动模式, 只对文本有效, 0-从左往右, 1-从右往左, 2-从上往下滚动, 3-从下往上滚动
    BYTE                byRoolSpeed;                // 滚动速率, 只对文本有效, 0~4, 数值越大滚动越快
    BYTE                byFontSize;                 // 字体大小, 只对文本有效
    BYTE                byTextAlign;                // 对齐方式, 0-靠左, 1-居中, 2-靠右
    BYTE                byType;                     // OSD类型, 0-文本, 1-图标, 2-时间
    BYTE                Reserved[3];                // 保留字节
    char                szContent[MAX_PATH];        // OSD内容
													// 若类型为图标, 内容为图标名称
													// 若类型为Time，内容为”Date”(日期),”Week”(星期),”Time”(时间),”\n”(换行)的自由组合。
													// 例如：不同行显示，需要将此字段填为"Date\nTime",在屏幕上就会显示
													// 2018年4月23日
													// 16:49:15
													// 同行显示，需要将此字段填为"DateTime",在屏幕上就会显示
													// 2018年4月23日16:49:15
    float               fPitch;                     // 字符间距, 0.0 ~ 5.0
    char                szFontType[DH_COMMON_STRING_64]; // 字体类型
} NET_SPLIT_OSD;

// CLIENT_GetSplitOSD 接口输入参数(获取解码窗口输出OSD信息)
typedef struct tagDH_IN_SPLIT_GET_OSD
{
    DWORD               dwSize;
    int                 nChannel;                   // 通道号
    int                 nWindow;                    // 窗口号
} DH_IN_SPLIT_GET_OSD;

// CLIENT_GetSplitOSD 接口输出参数(获取解码窗口输出OSD信息)
typedef struct tagDH_OUT_SPLIT_GET_OSD
{
    DWORD               dwSize;
    int                 nOSDNum;                            // OSD数量
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD信息
} DH_OUT_SPLIT_GET_OSD;

// CLIENT_SetSplitOSD 接口输入参数(设置解码窗口输出OSD信息)
typedef struct tagDH_IN_SPLIT_SET_OSD
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
    int                 nWindow;                            // 窗口号
    int                 nOSDNum;                            // OSD数量
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM];    // OSD信息
} DH_IN_SPLIT_SET_OSD;

// CLIENT_SetSplitOSD 接口输出参数(设置解码窗口输出OSD信息)
typedef struct tagDH_OUT_SPLIT_SET_OSD
{
    DWORD               dwSize;
} DH_OUT_SPLIT_SET_OSD;

// CLIENT_GetSplitOSDEx 接口输入参数(获取解码窗口输出OSD信息)
typedef struct tagNET_IN_SPLIT_GET_OSD_EX
{
    DWORD               dwSize;
    int                 nChannel;                   // 通道号
    int                 nWindow;                    // 窗口号
} NET_IN_SPLIT_GET_OSD_EX;

// CLIENT_GetSplitOSDEx 接口输出参数(获取解码窗口输出OSD信息)
typedef struct tagNET_OUT_SPLIT_GET_OSD_EX
{
    DWORD               dwSize;
    int                 nOSDNum;                            // OSD数量
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX]; // OSD信息
} NET_OUT_SPLIT_GET_OSD_EX;


// CLIENT_SetSplitOSDEx接口输入参数(设置解码窗口输出OSD信息)
typedef struct tagNET_IN_SPLIT_SET_OSD_EX
{
	DWORD               dwSize;
    int                 nChannel;                           	// 通道号
    int                 nWindow;                            	// 窗口号
    int                 nOSDNum;                            	// OSD数量
    NET_SPLIT_OSD       stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];    	// OSD信息
}NET_IN_SPLIT_SET_OSD_EX;

// CLIENT_SetSplitOSDEx 接口输出参数(设置解码窗口输出OSD信息)
typedef struct tagNET_OUT_SPLIT_SET_OSD_EX
{
    DWORD               dwSize;
} NET_OUT_SPLIT_SET_OSD_EX;


// 视频输出控制方式
typedef enum
{
    EM_VIDEO_OUT_CTRL_CHANNEL,              // 逻辑通道号控制方式, 对物理屏和拼接屏都有效
    EM_VIDEO_OUT_CTRL_COMPOSITE_ID,         // 拼接屏ID控制方式, 只对拼接屏有效
} EM_VIDEO_OUT_CTRL_TYPE;

// CLIENT_SetSplitSourceEx 接口的输入参数
typedef struct tagNET_IN_SET_SPLIT_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // 视频输出控制方式
    int                     nChannel;           // 视频输出逻辑通道号, emCtrlType为EM_VIDEO_OUT_CTRL_CHANNEL时有效
    const char*             pszCompositeID;     // 拼接屏ID, emCtrlType为EM_VIDEO_OUT_CTRL_COMPOSITE_ID时有效
    int                     nWindow;            // 窗口号, -1表示当前分割模式下的所有窗口
    DH_SPLIT_SOURCE*        pstuSources;        // 视频源信息, 当nWindow=-1时, 视频源是个数组, 且数量与窗口数一致
												// 由用户申请内存，大小为sizeof(DH_SPLIT_SOURCE)*nSourceCount
    int                     nSourceCount;       // 视频源数量
} NET_IN_SET_SPLIT_SOURCE;

// 设置视频源的返回结果
typedef struct tagNET_SET_SPLIT_SOURCE_RESULT 
{
    DWORD                   dwSize;
    int                     nPushPort;          // 推流模式的设备端监听端口号
} NET_SET_SPLIT_SOURCE_RESULT;

// CLIENT_SetSplitSourceEx 接口的输出参数
typedef struct tagNET_OUT_SET_SPLIT_SOURCE
{
    DWORD                   dwSize;
    NET_SET_SPLIT_SOURCE_RESULT* pstuResults;   // 设置成功后的返回值, 对应NET_IN_SET_SPLIT_SOURCE中的窗口数组, 用户分配内存,大小为sizeof(NET_SET_SPLIT_SOURCE_RESULT)*nMaxResultCount, 如果不需要可以为NULL
    int                     nMaxResultCount;    // pstuResults数组的大小
    int                     nRetCount;          // 返回的数量
} NET_OUT_SET_SPLIT_SOURCE;

// CLIENT_SplitExchangeSource 接口输入参数
typedef struct tagNET_IN_SPLIT_EXCHANGE_SOURCE
{
	DWORD					dwSize;				
	int						nChannel;           // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*				pszCompositeID;     // 融合屏ID
	int						nWindowID1;			// 窗口号1
	int						nWindowID2;			// 窗口号2
}NET_IN_SPLIT_EXCHANGE_SOURCE;

// CLIENT_SplitExchangeSource 接口输出参数
typedef struct tagNET_OUT_SPLIT_EXCHANGE_SOURCE
{
	DWORD					dwSize;		
}NET_OUT_SPLIT_EXCHANGE_SOURCE;


//卷类型枚举
typedef enum tagNET_VOLUME_TYPE
{
    VOLUME_TYPE_ALL = 0      ,      //所有卷
    VOLUME_TYPE_PHYSICAL     ,      //物理卷
    VOLUME_TYPE_RAID         ,      //Raid卷
    VOLUME_TYPE_VOLUME_GROUP ,      //VG虚拟卷组
    VOLUME_TYPE_ISCSI        ,      //iSCSI卷
    VOLUME_TYPE_INVIDUAL_PHY ,      //独立物理卷（这个物理盘,没有加入到, RAID,虚拟卷组等等组中）
    VOLUME_TYPE_GLOBAL_SPARE ,      //全局热备卷
	VOLUME_TYPE_NAS			 ,		//NAS盘(包括FTP, SAMBA, NFS)
	VOLUME_TYPE_INVIDUAL_RAID,		//独立RAID卷（指没有加入到，虚拟卷组等组中）
    VOLUME_TYPE_MAX          ,
}NET_VOLUME_TYPE;


#define    MAX_DEVICE_VOLUME_NUMS        128                //卷类型的最大上限

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES类型接口输入参数
typedef struct tagNET_IN_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //要获取的卷类型
} NET_IN_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_NAMES类型接口输出参数
typedef struct tagNET_OUT_STORAGE_DEV_NAMES
{
    DWORD               dwSize;
    int                 nDevNamesNum;                       //获取到设备的存储模块名数量
    char                szStoregeDevNames[MAX_DEVICE_VOLUME_NUMS][DH_STORAGE_NAME_LEN]; //设备名列表
}NET_OUT_STORAGE_DEV_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS接口输入参数
typedef struct tagNET_IN_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    NET_VOLUME_TYPE     emVolumeType;       //要获取的卷类型
} NET_IN_STORAGE_DEV_INFOS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_STORAGE_INFOS接口输出参数
typedef struct tagNET_OUT_STORAGE_DEV_INFOS
{
    DWORD               dwSize;
    int                 nDevInfosNum;                      //获取到设备的存储模块信息列表
    DH_STORAGE_DEVICE   stuStoregeDevInfos[MAX_DEVICE_VOLUME_NUMS]; //设备信息列表,DH_STORAGE_DEVICE的dwsize需赋值
} NET_OUT_STORAGE_DEV_INFOS;

typedef enum tagNET_RECENCY_CAR_INFO
{
    RECENCY_CAR_INFO_UNKNOW = 0 ,
    RECENCY_CAR_INFOO_NEWEST    ,      //最新
    RECENCY_CAR_INFO_ODLEST     ,      //最旧
    RECENCY_CAR_INFO_MAX        ,
}NET_RECENCY_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO接口输入参数
typedef struct tagNET_IN_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD                   dwSize;
    int                     nChannel;       //抓拍通道号
    NET_RECENCY_CAR_INFO    emRecencyType;  //获取车辆信息的类型,最新的还是最旧的
    DWORD                   nIndex;         //第几个车辆信息,从1开始,如果为0也表示第1个
}NET_IN_GET_RECENCY_JUNCTION_CAR_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_RECENCY_JNNCTION_CAR_INFO接口输出参数
typedef struct tagNET_OUT_GET_RECENCY_JUNCTION_CAR_INFO
{
    DWORD           dwSize;
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;        // 交通车辆信息
}NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO;

// 
#define NET_MAX_FISHEYE_WINDOW_NUM               8         // 最大鱼眼窗口数

// 窗口位置信息
typedef struct tagNET_FISHEYE_WINDOW_INFO
{
    DWORD             dwSize;
    DWORD             dwWindowID;                        // 窗口ID
    int               nFocusX;                           // EPtz（电子云台）的焦点横坐标
    int               nFocusY;                           // EPtz (电子云台）的焦点纵坐标   
    int               nHorizontalAngle;                  // EPtz的水平角度
    int               nVerticalAngle;                    // EPtz的垂直角度
}NET_FISHEYE_WINDOW_INFO;

// 对应CLIENT_QueryDevInfo接口,NET_QUERY_DEV_FISHEYE_WININFO查询鱼眼窗口信息输入参数
typedef struct tagNET_IN_FISHEYE_WININFO
{
    DWORD               dwSize;
    int                 nChannelId;                      // 通道号
    int                 nWindowNum;                      // 待查询的窗口数
    int                 nWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // 窗口id,不可重复
}NET_IN_FISHEYE_WININFO;

// 对应CLIENT_QueryDevInfo接口,NET_QUERY_DEV_FISHEYE_WININFO查询鱼眼窗口信息输出参数
typedef struct tagNET_OUT_FISHEYE_WININFO
{
    DWORD               dwSize;
    int                 nWindowNum;                      //的窗口数
    NET_FISHEYE_WINDOW_INFO stuWindows[NET_MAX_FISHEYE_WINDOW_NUM]; // 窗口具体信息
}NET_OUT_FISHEYE_WININFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE接口输入参数
typedef struct tagNET_IN_GET_LANES_STATE
{
    DWORD                   dwSize;
    int                     nLaneNumber; //-1代表查询所有车道,>=0时表示查询指定车道
}NET_IN_GET_LANES_STATE;

//信号灯指示状态
typedef enum tagNET_TRAFFIC_LIGHT_STATUS
{
    LIGHT_STATUS_UNKNOWN  = 0   ,    //未知
    LIGHT_STATUS_RED            ,    //红灯
    LIGHT_STATUS_GREEN          ,    //绿灯
    LIGHT_STATUS_YELLOW         ,    //黄灯
}NET_TRAFFIC_LIGHT_STATUS;

//信号灯指示信息
typedef struct tatNET_TRAFFIC_LIGHT_INFO
{
    DWORD                       dwSize;
    NET_TRAFFIC_LIGHT_STATUS    emStraightLightInfo;    //直行信号灯状态
    NET_TRAFFIC_LIGHT_STATUS    emLeftLightInfo;        //左转信号灯状态
    NET_TRAFFIC_LIGHT_STATUS    emRightLightInfo;       //右转信号灯状态
    NET_TRAFFIC_LIGHT_STATUS    emUTurnLightInfo;       //调头信号灯状态
}NET_TRAFFIC_LIGHT_INFO;

//车道方向
typedef enum tagNET_TRAFFIC_DIRECTION
{
    DIRECTION_UNKNOW    = 0 ,   //未知
    DIRECTION_STRAIGHT      ,   //直行
    DIRECTION_LEFT          ,   //左转
    DIRECTION_RIGHT         ,   //右转
    DIRECTION_UTURN         ,   //调头
}NET_TRAFFIC_DIRECTION;

//车道信息
typedef struct tagNET_TRAFFIC_LANE_INFO
{
    DWORD                   dwSize;
    UINT                    nLaneNumber;                                    //车道号,0开始
    UINT                    nSupportDirectionNum;                           //车道可以行使的方向数
    NET_TRAFFIC_DIRECTION   emTrafficDirections[MAX_LANE_DIRECTION_NUM];    //车道方向,表示此车道可以行使的所有方向
    NET_TRAFFIC_JAM_STATUS  emJamState;                                     //道路拥挤状况
    //流量信息
    UINT                    nLargeVehicleNum;                               //大型车数量
    UINT                    nMediumVehicleNum;                              //中型车数量
    UINT                    nSmallVehicleNum;                               //小型车数量
    UINT                    nMotoNum;                                       //摩托车数量
}NET_TRAFFIC_LANE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_LANES_STATE接口输出参数
typedef struct tagNET_OUT_GET_LANES_STATE
{
    DWORD                   dwSize;
    int                     nGetLaneInfoNum;                    //获取到的车道信息数
    NET_TRAFFIC_LANE_INFO   stLaneInfos[MAX_LANE_INFO_NUM];     //获取到的车道信息
    NET_TRAFFIC_LIGHT_INFO  stLightInfo;                        //信号灯指示状态
}NET_OUT_GET_LANES_STATE;

//CLIENT_QueryDevInfo , NET_QUERY_SYSTEM_INFO 类型接口输入参数
typedef struct tagNET_IN_SYSTEM_INFO
{
    DWORD               dwSize;
} NET_IN_SYSTEM_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_SYSTEM_INFO 类型接口输出参数
typedef struct tagNET_OUT_SYSTEM_INFO
{
    DWORD               dwSize;
    BOOL                bHasRTC;                       //是否有RTC芯片(记录系统时间用)默认TRUE,表示有RTC
    int                 nRetMCUNum;                   // 返回的单片机个数 	 	 
    char                szMCUVersion[MAX_MCU_NUM][DH_MAX_VERSION_LEN];         // 单片机软件版本号
}NET_OUT_SYSTEM_INFO;


//CLIENT_QueryDevInfo , NET_QUERY_REG_DEVICE_NET_INFO 类型接口输入参数
typedef struct tagNET_IN_REGDEV_NET_INFO
{
    DWORD               dwSize;
    char                szDevSerial[DH_DEV_SERIALNO_LEN];   // 主动注册时上报的设备序列号
}NET_IN_REGDEV_NET_INFO;

//主动注册连接使用的网络类型
typedef enum tagNET_CELLUAR_NET_TYPE 
{
    EM_CELLUAR_NET_UNKNOW           =   -1  ,    //未知
    EM_CELLUAR_NET_PRIVATE_3G_4G    =   0   ,    //专有3G/4G网络,(如公安内网)
    EM_CELLUAR_NET_COMMERCIAL_3G_4G =   1   ,    //商用的3G/4G网络,(如移动、电信等)
    EM_CELLUAR_NET_MAX , 
}NET_CELLUAR_NET_TYPE;

//CLIENT_QueryDevInfo , NET_QUERY_REG_DEVICE_NET_INFO  类型接口输出参数
typedef struct tagNET_OUT_REGDEV_NET_INFO
{
    DWORD                   dwSize;
    NET_CELLUAR_NET_TYPE    emCelluarNetType;           //主动注册连接使用的网络类型
}NET_OUT_REGDEV_NET_INFO;

// 获取视频通道属性命令的子类型
typedef enum tagNET_VIDEO_CHANNEL_TYPE
{
    NET_VIDEO_CHANNEL_TYPE_ALL,                         // 全部
    NET_VIDEO_CHANNEL_TYPE_INPUT,                       // 输入
    NET_VIDEO_CHANNEL_TYPE_OUTPUT,                      // 输出
} NET_VIDEO_CHANNEL_TYPE;

//CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO 命令输入参数
typedef struct tagNET_IN_GET_VIDEOCHANNELSINFO
{
    DWORD                               dwSize;
    NET_VIDEO_CHANNEL_TYPE              emType;         // 需要获取的通道类型                     
} NET_IN_GET_VIDEOCHANNELSINFO;

typedef struct tagNET_VIDEOCHANNELS_INPUT 
{
    int                     nThermographyCount;         // 热成像通道个数
    int                     nThermography[64];          // 热成像通道的通道号
    int                     nMultiPreviewCount;         // 多画面预览通道个数
    int                     nMultiPreview[4];	        // 多画面预览通道号
    int                     nPIPCount;                  // 画中画通道个数
    int                     nPIP[4];    	            // 画中画通道号
    int                     nCompressPlayCount;         // 二次压缩回放通道个数
    int                     nCompressPlay[4];	        // 二次压缩回放通道号
	int						nSDCount;					// 球机通道个数
	int						nSD[64];					// 球机通道号
	int                     nPTZCount;                  // 支持云台程序的通道数量
	short                   nPTZ[64];                   // 支持云台程序的通道号
	int                     nFuseRadarCount;            // 支持融合雷达流，可见光叠加雷达流的通道数量
	int						nFuseRadar[64];             // 支持融合雷达流，可见光叠加雷达流的通道号
	int                     nPureRadarCount;            // 支持纯雷达流，无可见光的通道数量
	int						nPureRadar[64];             // 支持纯雷达流，无可见光的通道号
    char                    reserved[4096];
} NET_VIDEOCHANNELS_INPUT;

typedef struct tagNET_VIDEOCHANNELS_OUTPUT 
{
    int                     nVGACount;                  // VGA输出个数
    int                     nVGA[128];                  // VGA输出
    int                     nTVCount;                   // TV输出个数
    int                     nTV[128];                   // TV输出
    char                    reserved[512];
} NET_VIDEOCHANNELS_OUTPUT;

//CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO 命令输出参数
typedef struct tagNET_OUT_GET_VIDEOCHANNELSINFO
{
    DWORD                       dwSize;
    NET_VIDEOCHANNELS_INPUT     stInputChannels;        // 输入通道信息,获取类型为NET_VIDEO_CHANNEL_TYPE_ALL/INPUT时有效        
    NET_VIDEOCHANNELS_OUTPUT    stOutputChannels;       // 输出通道信息,获取类型为NET_VIDEO_CHANNEL_TYPE_ALL/OUTPUT时有效
} NET_OUT_GET_VIDEOCHANNELSINFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES 命令输入参数
typedef struct tagNET_IN_WORKGROUP_NAMES
{
    DWORD                       dwSize;
} NET_IN_WORKGROUP_NAMES;

// 工作目录组名最大长度
#define WORKGROUP_NAME_LEN      32

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_NAMES 命令输出参数
typedef struct tagNET_OUT_WORKGROUP_NAMES
{
    DWORD                       dwSize;
    int                         nCount;                         // 工作组个数
    char                        szName[64][WORKGROUP_NAME_LEN]; // 每个工作组的名字
} NET_OUT_WORKGROUP_NAMES;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO 命令输入参数
typedef struct tagNET_IN_WORKGROUP_INFO
{
    DWORD                       dwSize;
    char                        szName[WORKGROUP_NAME_LEN];     // 需要获取信息的工作组                    
} NET_IN_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WORKGROUP_INFO 命令输出参数
typedef struct tagNET_OUT_WORKGROUP_INFO
{
    DWORD                       dwSize;
    int                         nState;                         // 状态：0 无意义,1 正常,2 损坏,3 错误
    int                         nTotalSpace;                    // 总空间 单位：MB -1表示获取失败
    int                         nFreeSpace;                     // 剩余空间 单位：MB -1表示获取失败
} NET_OUT_WORKGROUP_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT 命令输入参数
typedef struct tagNET_IN_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    char                        szSSID[DH_MAX_SSID_LEN];        // 需要获取信息的无线网络名称,为空时搜索所有网络
	char						szName[MAX_COMMON_STRING_32];	// 网卡名称, 为空时, 默认为eth2
} NET_IN_WLAN_ACCESSPOINT;

typedef struct tagNET_WLAN_ACCESSPOINT_INFO
{
    char                        szSSID[DH_MAX_SSID_LEN];        // 无线网络名称
    int                         nStrength;                      // 信号强度 范围0-100
    int                         nAuthMode;                      // 认证模式0:OPEN;1:SHARED;2:WPA;3:WPA-PSK;4:WPA2;5:WPA2-PSK;
                                                                // 6:WPA-NONE(用在adhoc网络模式),
                                                                // 7-11是混合模式,选择其中任何一种都可以进行连接 
                                                                // 7:WPA-PSK | WPA2-PSK; 8:WPA | WPA2; 9:WPA | WPA-PSK;
                                                                // 10:WPA2 | WPA2-PSK; 11:WPA | WPA-PSK |WPA2 |WPA2-PSK //12: UnKnown
    int                         nEncrAlgr;                      // 0:NONE, 1:WEP, 2:TKIP, 3:AES(CCMP), 4:TKIP+AES( mix Mode), 5:UnKnown
    char                        reserved[1016];
} NET_WLAN_ACCESSPOINT_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_WLAN_ACCESSPOINT 命令输出参数
typedef struct tagNET_OUT_WLAN_ACCESSPOINT
{
    DWORD                       dwSize;
    int                         nCount;                         // 无线网络接入点个数
    NET_WLAN_ACCESSPOINT_INFO   stuInfo[128];                   // 接入点信息                       
} NET_OUT_WLAN_ACCESSPOINT;

// CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION 命令输入参数
typedef struct tagNET_IN_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    int                     nChannel;                   // 串口号
} NET_IN_TRAFFICRADAR_VERSION;

// CLIENT_QueryDevInfo , NET_QUERY_TRAFFICRADAR_VERSION 命令输出参数
typedef struct tagNET_OUT_TRAFFICRADAR_VERSION
{
    DWORD                   dwSize;
    char                    szVersion[DH_MAX_VERSION_LEN];  // 版本号
} NET_OUT_TRAFFICRADAR_VERSION;

// 接口 CLIENT_AttachLanesState 的输入参数
typedef NET_OUT_GET_LANES_STATE NET_CB_LANES_STATE;

// 接口 CLIENT_AttachLanesState 回调函数
typedef void (CALLBACK *fNotifyLanesState)(LLONG lLanesStateHandle, NET_CB_LANES_STATE* pLanesStateInfo, LDWORD dwUser, void *reserved);

// 接口 CLIENT_AttachLanesState 的输入参数
typedef struct tagNET_IN_ATTACH_LANES_STATE
{
    DWORD                dwSize;                         // 此结构体大小
    int                  nChannelID;                     // 通道号
    int                  nLaneNumber;                    // -1代表订阅所有车道,>=0时表示订阅指定车道
    
    fNotifyLanesState    cbNotifyLanesState;             // 回调函数
    LDWORD               dwUser;                         // 用户自定义参数
} NET_IN_ATTACH_LANES_STATE;

// 接口 CLIENT_AttachLanesState 的输出参数
typedef struct tagNET_OUT_ATTACH_LANES_STATE
{
    DWORD                dwSize;                         // 此结构体大小
} NET_OUT_ATTACH_LANES_STATE;

// CLIENT_MatrixSwitch 输入参数
typedef struct tagNET_IN_MATRIX_SWITCH
{
    DWORD           dwSize;
    DH_SPLIT_MODE   emSplitMode;                // 分割模式
    int*            pnOutputChannels;           // 输出通道, 可同时指定多个输出通道一起切换, 内容一致
												// 由用户申请内存，大小为sizeof(int)*nOutputChannelCount
    int             nOutputChannelCount;        // 输出通道数
    int*            pnInputChannels;            // 输入通道, 每个分割窗口一个对应一个输入通道
												// 由用户申请内存，大小为sizeof(int)*nInputChannelCount
    int             nInputChannelCount;         // 输入通道数
} NET_IN_MATRIX_SWITCH;

// CLIENT_MatrixSwitch 输出参数
typedef struct tagNET_OUT_MATRIX_SWITCH 
{
    DWORD            dwSize;
} NET_OUT_MATRIX_SWITCH;

// CLIENT_SplitSetMultiSource 接口的输入参数
typedef struct tagNET_IN_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
    EM_VIDEO_OUT_CTRL_TYPE  emCtrlType;         // 视频输出控制方式
    int                     nChannel;           // 视频输出逻辑通道号, emCtrlType为EM_VIDEO_OUT_CTRL_CHANNEL时有效
    const char*             pszCompositeID;     // 拼接屏ID, emCtrlType为EM_VIDEO_OUT_CTRL_COMPOSITE_ID时有效
    BOOL                    bSplitModeEnable;   // 是否改变分割模式
    DH_SPLIT_MODE           emSplitMode;        // 分割模式, bSplitModeEnable=TRUE时有效
    int                     nGroupID;           // 分割分组号, bSplitModeEnable=TRUE时有效
    int*                    pnWindows;          // 窗口号数组,由用户申请内存，大小为sizeof(int)*nWindowCount
    int                     nWindowCount;       // 窗口数量
    DH_SPLIT_SOURCE*        pstuSources;        // 视频源信息, 分别对应每个窗口, 数量同窗口数,由用户申请内存，大小为sizeof(DH_SPLIT_SOURCE)*nWindowCount
} NET_IN_SPLIT_SET_MULTI_SOURCE;

// CLIENT_SplitSetMultiSource 接口的输出参数
typedef struct tagNET_OUT_SPLIT_SET_MULTI_SOURCE 
{
    DWORD                   dwSize;
} NET_OUT_SPLIT_SET_MULTI_SOURCE;

// 视频分割操作类型
typedef enum tagNET_SPLIT_OPERATE_TYPE
{
    NET_SPLIT_OPERATE_SET_BACKGROUND,           // 设置背景图片, 对应 NET_IN_SPLIT_SET_BACKGROUND 和 NET_OUT_SPLIT_SET_BACKBROUND
    NET_SPLIT_OPERATE_GET_BACKGROUND,           // 获取背景图片, 对应 NET_IN_SPLIT_GET_BACKGROUND 和 NET_OUT_SPLIT_GET_BACKGROUND
    NET_SPLIT_OPERATE_SET_PREPULLSRC,           // 设置预拉流源, 对应 NET_IN_SPLIT_SET_PREPULLSRC 和 NET_OUT_SPLIT_SET_PREPULLSRC
    NET_SPLIT_OPERATE_SET_HIGHLIGHT,            // 设置源边框高亮使能开关, 对应 NET_IN_SPLIT_SET_HIGHLIGHT 和 NET_OUT_SPLIT_SET_HIGHLIGHT
    NET_SPLIT_OPERATE_SET_ZORDER,               // 调整窗口Z序, 对应 NET_IN_SPLIT_SET_ZORDER 和 NET_OUT_SPLIT_SET_ZORDER
    NET_SPLIT_OPERATE_SET_TOUR,                 // 窗口轮巡控制, 对应 NET_IN_SPLIT_SET_TOUR 和 NET_OUT_SPLIT_SET_TOUR
    NET_SPLIT_OPERATE_GET_TOUR_STATUS,          // 获取窗口轮巡状态, 对应 NET_IN_SPLIT_GET_TOUR_STATUS 和 NET_OUT_SPLIT_GET_TOUR_STATUS
    NET_SPLIT_OPERATE_GET_SCENE,                // 获取屏内窗口信息, 对应 NET_IN_SPLIT_GET_SCENE 和 NET_OUT_SPLIT_GET_SCENE
    NET_SPLIT_OPERATE_OPEN_WINDOWS,             // 批量开窗, 对应 NET_IN_SPLIT_OPEN_WINDOWS 和 NET_OUT_SPLIT_OPEN_WINDOWS
    NET_SPLIT_OPERATE_SET_WORK_MODE,            // 设置工作模式, 对应 NET_IN_SPLIT_SET_WORK_MODE 和 NET_OUT_SPLIT_SET_WORK_MODE
    NET_SPLIT_OPERATE_GET_PLAYER,               // 获取播放器实例,对应 NET_IN_SPLIT_GET_PLAYER 和 NET_OUT_SPLIT_GET_PLAYER
    NET_WM_OPERATE_SET_WORK_MODE,               // 设置窗口工作模式,对应 NET_IN_WM_SET_WORK_MODE 和 NET_OUT_WM_SET_WORK_MODE
    NET_WM_OPERATE_GET_WORK_MODE,               // 获取窗口工作模式,对应 NET_IN_WM_GET_WORK_MODE 和 NET_OUT_WM_GET_WORK_MODE
    NET_SPLIT_OPERATE_CLOSE_WINDOWS,            // 批量关窗, 对应 NET_IN_SPLIT_CLOSE_WINDOWS 和 NET_OUT_SPLIT_CLOSE_WINDOWS
    NET_WM_OPERATE_SET_FISH_EYE_PARAM,          // 设置输出屏的鱼眼矫正规则 , 对应NET_IN_WM_SET_FISH_EYE_PARAM 和 NET_OUT_WM_SET_FISH_EYE_PARAM
	NET_WM_OPERATE_SET_CORRIDOR_MODE,			// 设置窗口走廊模式，对应NET_IN_WM_SET_CORRIDOR_MODE和NET_OUT_WM_SET_CORRIDOR_MODE
	NET_WM_OPERATE_GET_CORRIDOR_MODE,			// 获取窗口走廊模式，对应NET_IN_WM_GET_CORRIDOR_MODE和NET_OUT_WM_GET_CORRIDOR_MODE
	NET_WM_OPERATE_SET_VOLUME_COLUMN,			// 设置显示音量柱使能模式，对应NET_IN_WM_SET_VOLUME_COLUMN和NET_OUT_WM_SET_VOLUME_COLUMN
	NET_WM_OPERATE_GET_VOLUME_COLUMN,			// 获取显示音量柱使能模式，对应NET_IN_WM_GET_VOLUME_COLUMN和NET_OUT_WM_GET_VOLUME_COLUMN
	NET_WM_OPERATE_SET_BACKGROUND,				// 设置窗口背景图片，对应NET_IN_WM_SET_BACKGROUND和NET_OUT_WM_SET_BACKGROUND
	NET_WM_OPERATE_GET_BACKGROUND,				// 获取窗口背景图片，对应NET_IN_WM_GET_BACKGROUND和NET_OUT_WM_GET_BACKGROUND
    NET_WM_OPERATE_SET_ROTATE_MODE,				// 设置图像画面旋转模式，对应NET_IN_WM_SET_ROTATE_MODE和NET_OUT_WM_SET_ROTATE_MODE

    NET_WM_OPERATE_SET_MEETING_MODE,			// 设置视频源显示区域的模式，对应NET_IN_WM_SET_MEETING_MODE和NET_OUT_WM_SET_MEETING_MODE
    NET_WM_OPERATE_SET_LOCK_POSITION,			// 设置锁定窗口当前位置，对应NET_IN_WM_SET_LOCK_POSITION和NET_OUT_WM_SET_LOCK_POSITION
    NET_WM_OPERATE_SET_COLLECTION_CTRL_ID,		// 修改预案控制ID，对应NET_IN_WM_SET_COLLECTION_CTRL_ID和NET_OUT_WM_SET_COLLECTION_CTRL_ID
    NET_SPLIT_OPERATES_SET_SOURCE_ATTRIBUTE,	// 设置信号源属性，对应NET_IN_SPLIT_SET_SOURCE_ATTRIBUTE和NET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE
    NET_SPLIT_OPERATES_SET_DOCK_CONTROL,	    // 设置窗口粘附状态，对应NET_IN_SPLIT_SET_DOCK_CONTROL和NET_OUT_SPLIT_SET_DOCK_CONTROL
    NET_WM_OPERATE_SET_MODE,			        // 设置窗口分割模式，对应NET_IN_WM_SET_MODE和NET_OUT_WM_SET_MODE
} NET_SPLIT_OPERATE_TYPE;
 
// 设置源边框高亮使能开关输入参数
typedef struct tagNET_IN_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize; 
    int             nChannel;                   // 视频输出通道
    int             nWindow;                    // 窗口号
    BOOL            bHighLightEn;               // 边框高亮使能,TRUE-表示高亮
    DH_COLOR_RGBA   stuColor;                   // 边框颜色 
    int				nBlinkTimes;				// 边框闪烁次数
    int				nBlinkInterval;				// 闪烁间隔时间,单位ms
}NET_IN_SPLIT_SET_HIGHLIGHT;

// 设置源边框高亮使能开关输出参数
typedef struct tagNET_OUT_SPLIT_SET_HIGHLIGHT
{
    DWORD           dwSize;
}NET_OUT_SPLIT_SET_HIGHLIGHT;

// 设置预拉流源输入参数
typedef struct tagNET_IN_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nChannel;                   // 视频输出通道
    int             nWindow;                    // 窗口号
    int             nSrcCount;                  // 预拉流源数量
    DH_SPLIT_SOURCE* pSources;                  // 预拉流源信息,由用户申请内存，大小为sizeof(DH_SPLIT_SOURCE)*nSrcCount
} NET_IN_SPLIT_SET_PREPULLSRC;

// 设置预拉流源的返回结果
typedef struct tagNET_SPLIT_SET_PREPULLSRC_RESULT 
{
    DWORD           dwSize;
    BOOL            bResult;                    // 设置结果, TRUE-成功, FALSE-失败
    DWORD           dwErrorCode;                // 失败错误码
} NET_SPLIT_SET_PREPULLSRC_RESULT;

// 设置预拉流源输出参数
typedef struct tagNET_OUT_SPLIT_SET_PREPULLSRC 
{
    DWORD           dwSize;
    int             nResultCount;               // 结果数量, 与预拉流源数量相同
    NET_SPLIT_SET_PREPULLSRC_RESULT* pResults;  // 结果
} NET_OUT_SPLIT_SET_PREPULLSRC;

// 设置视频输出背景图输入参数
typedef struct tagNET_IN_SPLIT_SET_BACKGROUND
{
    DWORD            dwSize;
    int              nChannel;                   // 视频输出通道号
    BOOL             bEnable;                    // 使能
    const char*      pszFileName;                // 背景图名称
} NET_IN_SPLIT_SET_BACKGROUND;

// 设置视频输出背景图输出参数
typedef struct tagNET_OUT_SPLIT_SET_BACKGROUND 
{
    DWORD            dwSize;
} NET_OUT_SPLIT_SET_BACKGROUND;

// 获取视频输出背景图输入参数
typedef struct tagNET_IN_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    int              nChannel;                   // 视频输出通道号
} NET_IN_SPLIT_GET_BACKGROUND;

// 获取视频输出背景图输出参数
typedef struct tagNET_OUT_SPLIT_GET_BACKGROUND 
{
    DWORD            dwSize;
    BOOL             bEnable;                            // 使能
    char             szFileName[DH_COMMON_STRING_256];   // 背景图名称
} NET_OUT_SPLIT_GET_BACKGROUND;

//设置窗口背景图输入参数
typedef struct tagNET_IN_WM_SET_BACKGROUND
{
	DWORD				dwSize;
	int					nChannel;							// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	char			   *pszCompositeID;						// 融合屏ID
	int					nWindowID;							// 窗口号
	BOOL				bEnable;							// 是否叠加底图
	char				szFileName[DH_COMMON_STRING_128];	// 背景图片名称
} NET_IN_WM_SET_BACKGROUND;

// 设置窗口背景图输出参数
typedef struct tagNET_OUT_WM_SET_BACKGROUND
{
	DWORD            	dwSize;
} NET_OUT_WM_SET_BACKGROUND;

// 获取窗口背景图输入参数
typedef struct tagNET_IN_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	int					nChannel;				// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	char			   *pszCompositeID;			// 融合屏ID
	int					nWindowID;				// 窗口号
} NET_IN_WM_GET_BACKGROUND;

// 获取窗口背景图输出参数
typedef struct tagNET_OUT_WM_GET_BACKGROUND
{
	DWORD            	dwSize;
	BOOL             	bEnable;                            // 是否叠加底图
    char             	szFileName[DH_COMMON_STRING_128];   // 背景图名称
} NET_OUT_WM_GET_BACKGROUND;

// 窗口Z次序
typedef enum tagNET_WINDOW_ZORDER
{
    NET_WINDOW_ZORDER_TOP,                              // 顶层
    NET_WINDOW_ZORDER_BOTTOM,                           // 底层
    NET_WINDOW_ZORDER_UP,                               // 往上一层
    NET_WINDOW_ZORDER_DOWN,                             // 往下一层
} NET_WINDOW_ZORDER;

// 窗口层叠次序
typedef struct tagDH_WND_ZORDER
{
    DWORD               dwSize;
    unsigned int        nWindowID;                      // 窗口序号
    unsigned int        nZOrder;                        // Z次序
} DH_WND_ZORDER;

// 设置窗口Z序输入参数
typedef struct tagNET_IN_SPLIT_SET_ZORDER 
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
    int                 nWindow;                        // 窗口号
    NET_WINDOW_ZORDER   emZOrder;                       // 调整的Z序
} NET_IN_SPLIT_SET_ZORDER;

// 设置窗口Z序输出参数, 调整一个窗口的Z序会影响所有窗口, 返回调整后所有窗口的Z序
typedef struct tagNET_OUT_SPLIT_SET_ZORDER
{
    DWORD               dwSize;
    DH_WND_ZORDER*      pZOders;                        // 窗口次序数组, 用户分配内存,大小为sizeof(DH_WND_ZORDER)*nMaxWndCount
    int                 nMaxWndCount;                   // 窗口次序数组大小
    int                 nWndCount;                      // 返回的窗口数量
} NET_OUT_SPLIT_SET_ZORDER;

// 窗口轮巡动作
typedef enum tagEM_NET_WINDOW_TOUR_ACTION 
{
    EM_NET_WND_TOUR_ACTION_START,                       // 开始
    EM_NET_WND_TOUR_ACTION_STOP,                        // 停止
} EM_NET_WINDOW_TOUR_ACTION;

// 窗口轮巡控制输入参数, 对应NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_IN_SPLIT_SET_TOUR 
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
    int                 nWindow;                        // 窗口号
    EM_NET_WINDOW_TOUR_ACTION emAction;                 // 轮巡动作
} NET_IN_SPLIT_SET_TOUR;

// 窗口轮巡控制输出参数, 对应NET_SPLIT_OPERATE_SET_TOUR
typedef struct tagNET_OUT_SPLIT_SET_TOUR 
{
    DWORD               dwSize;
} NET_OUT_SPLIT_SET_TOUR;

// 获取窗口轮巡状态输入参数, 对应NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_IN_SPLIT_GET_TOUR_STATUS
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
    int                 nWindow;                        // 窗口号, -1表示所有窗口
} NET_IN_SPLIT_GET_TOUR_STATUS;

// 轮巡状态
typedef enum tagNET_TOUR_STATUS
{
    NET_TOUR_UNKNOWN,                               // 未知
    NET_TOUR_START,                                 // 轮巡中
    NET_TOUR_STOP,                                  // 轮巡停止
}NET_TOUR_STATUS;

// 窗口轮巡状态信息
typedef struct tagNET_WINDOW_TOUR_STATUS_INFO 
{
    DWORD               dwSize;
    int                 nWindow;                        // 窗口号
    NET_TOUR_STATUS     emStatus;                       // 状态
} NET_WINDOW_TOUR_STATUS_INFO;

// 获取窗口轮巡状态输出参数, 对应NET_SPLIT_OPERATE_GET_TOUR_STATUS
typedef struct tagNET_OUT_SPLIT_GET_TOUR_STATUS
{
    DWORD               dwSize;
    NET_WINDOW_TOUR_STATUS_INFO* pstuStatus;            // 状态信息指针,  用户分配内存. 查询窗口号为-1时表示多个窗口的信息数组.
    int                 nMaxStatusCount;                // 状态信息最大数量, 用户输入
    int                 nRetStatusCount;                // 状态信息实际数量, 查询得到
} NET_OUT_SPLIT_GET_TOUR_STATUS;

// 批量开窗输入参数, 对应NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_IN_SPLIT_OPEN_WINDOWS 
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏id
    int                 nWindowNum;                     // 窗口数量
    NET_RECT*           pstuWindowRects;                // 窗口区域数组,由用户申请内存，大小为sizeof(NET_RECT)*nWindowNum
    BOOL                bDirectable;                    // 满足直通条件
} NET_IN_SPLIT_OPEN_WINDOWS;

// 窗口信息
typedef struct tagNET_SPLIT_WINDOW_INFO
{
    DWORD               dwSize;
    int                 nWindowID;                      // 窗口号
    int                 nZOrder;                        // Z次序
    char                szControlID[DH_DEV_ID_LEN];     // 控制编号
} NET_SPLIT_WINDOW_INFO;

// 批量开窗输出参数, 对应NET_SPLIT_OPERATE_OPEN_WINDOWS
typedef struct tagNET_OUT_SPLIT_OPEN_WINDOWS 
{
    DWORD               dwSize;
    NET_SPLIT_WINDOW_INFO*  pstuWindows;                // 窗口信息, 用户分配内存,大小为sizeof(NET_SPLIT_WINDOW_INFO)*nMaxWindowCount
    int                 nMaxWindowCount;                // 窗口信息最大数量, 用户输入
    int                 nRetWindowCount;                // 开窗数量
} NET_OUT_SPLIT_OPEN_WINDOWS;

// 画面分割工作模式
typedef enum tagNET_SPLIT_WORK_MODE
{
    NET_SPLIT_WORK_MODE_UNKNOWN,                        // 未知
    NET_SPLIT_WORK_MODE_LOCAL,                          // 本地普通模式
    NET_SPLIT_WORK_MODE_REPLAY,                         // 回放模式
}NET_SPLIT_WORK_MODE;

// 设置工作模式输入参数, 对应 NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_SPLIT_SET_WORK_MODE 
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
    NET_SPLIT_WORK_MODE emMode;                         // 工作模式
}NET_IN_SPLIT_SET_WORK_MODE;

// 设置工作模式输出参数, 对应 NET_SPLIT_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_SPLIT_SET_WORK_MODE 
{
    DWORD               dwSize;
}NET_OUT_SPLIT_SET_WORK_MODE;

// 播放器类型
typedef enum tagNET_SPLIT_PLAYER_TYPE
{
    NET_SPLIT_PLAYER_TYPE_UNKNOWN,                       // 未知
    NET_SPLIT_PLAYER_TYPE_FILE_LIST,                     // 文件列表播放器
    NET_SPLIT_PLAYER_TYPE_FILE,                          // 文件播放器
}NET_SPLIT_PLAYER_TYPE;

// 获取播放器实例输入参数, 对应 NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_IN_SPLIT_GET_PLAYER
{
    DWORD                 dwSize;
    int                   nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*           pszCompositeID;                 // 融合屏ID
    NET_SPLIT_PLAYER_TYPE emType;                         // 播放器类型
    int                   nWindow;                        // 播放器所在的窗口号
}NET_IN_SPLIT_GET_PLAYER;

// 获取播放器实例输出参数, 对应 NET_SPLIT_OPERATE_GET_PLAYER
typedef struct tagNET_OUT_SPLIT_GET_PLAYER
{
    DWORD                 dwSize;
    LLONG                 lPlayerID;                      // 播放器实例ID
}NET_OUT_SPLIT_GET_PLAYER;

// 窗口工作模式
typedef enum tagNET_WM_WORK_MODE
{
    NET_WM_WORK_MODE_UNKNOWN,                             // 未知
    NET_WM_WORK_MODE_DISPLAY,                             // 预览模式
    NET_WM_WORK_MODE_REPLAY,                              // 回放模式  
}NET_WM_WORK_MODE;

// 设置窗口工作模式输入参数, 对应 NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_IN_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*           pszCompositeID;                 // 融合屏ID
    int                   nWindow;                        // 窗口号
    NET_WM_WORK_MODE      emMode;                         // 窗口工作模式
}NET_IN_WM_SET_WORK_MODE;

//设置窗口工作模式输出参数, 对应 NET_WM_OPERATE_SET_WORK_MODE
typedef struct tagNET_OUT_WM_SET_WORK_MODE
{
    DWORD                 dwSize;
}NET_OUT_WM_SET_WORK_MODE;

// 获取窗口工作模式输入参数, 对应 NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_IN_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    int                   nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*           pszCompositeID;                 // 融合屏ID
    int                   nWindow;                        // 窗口号
}NET_IN_WM_GET_WORK_MODE;

//获取窗口工作模式输出参数, 对应 NET_WM_OPERATE_GET_WORK_MODE
typedef struct tagNET_OUT_WM_GET_WORK_MODE
{
    DWORD                 dwSize;
    NET_WM_WORK_MODE      emMode;                         // 窗口工作模式
}NET_OUT_WM_GET_WORK_MODE;

// 设置窗口走廊模式输入参数，对应NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// 用户使用时赋值为结构体大小
	int 				  nChannel;			// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	const char* 		  pszCompositeID;	// 融合屏ID
	int 				  nWindow;			// 窗口号
	BOOL	  			  bIsCorridor;		// 窗口走廊模式(TRUE:打开  FALSE:关闭)
} NET_IN_WM_SET_CORRIDOR_MODE;

// 设置窗口走廊模式输出参数，对应NET_WM_OPERATE_SET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_SET_CORRIDOR_MODE
{
	DWORD                 dwSize;		// 用户使用时赋值为结构体大小
} NET_OUT_WM_SET_CORRIDOR_MODE;

// 获取窗口走廊模式输入参数，对应NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_IN_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// 用户使用时赋值为结构体大小
	int 				  nChannel;			// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	const char* 		  pszCompositeID;	// 融合屏ID
	int 				  nWindow;			// 窗口号
} NET_IN_WM_GET_CORRIDOR_MODE;

// 获取窗口走廊模式输出参数，对应NET_WM_OPERATE_GET_CORRIDOR_MODE
typedef struct tagNET_OUT_WM_GET_CORRIDOR_MODE
{
	DWORD                 dwSize;			// 用户使用时赋值为结构体大小
	BOOL	  			  bIsCorridor;		// 窗口走廊模式(TRUE:打开  FALSE:关闭)
} NET_OUT_WM_GET_CORRIDOR_MODE;

// 设置显示音量柱使能模式输入参数，对应NET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_SET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// 用户使用时赋值为结构体大小
	int 				  nChannel;			// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	const char* 		  pszCompositeID;	// 融合屏ID
	BOOL				  bIsEnable;	    // 是否显示音量柱(TRUE:显示  FALSE:关闭)
} NET_IN_WM_SET_VOLUME_COLUMN;				

// 设置显示音量柱使能模式输出参数，对应NET_WM_OPERATE_SET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_SET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// 用户使用时赋值为结构体大小
} NET_OUT_WM_SET_VOLUME_COLUMN;

// 获取显示音量柱使能模式输人参数，对应NET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_IN_WM_GET_VOLUME_COLUMN
{
	DWORD                 dwSize;			// 用户使用时赋值为结构体大小
	int 				  nChannel;			// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
	const char* 		  pszCompositeID;	// 融合屏ID
} NET_IN_WM_GET_VOLUME_COLUMN;

// 获取显示音量柱使能模式输出参数，对应NET_WM_OPERATE_GET_VOLUME_COLUMN
typedef struct tagNET_OUT_WM_GET_VOLUME_COLUMN
{
	DWORD				   dwSize;			// 用户使用时赋值为结构体大小
	BOOL				   bIsEnable;		// 是否显示音量柱(TRUE:显示  FALSE:关闭)	
} NET_OUT_WM_GET_VOLUME_COLUMN;

// 批量关窗输入参数, 对应NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_IN_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
    int*                pnWindows;                      // 窗口号数组指针,由用户申请内存,大小为sizeof(int)*nWindowCount
    int                 nWindowCount;                   // 窗口数量
} NET_IN_SPLIT_CLOSE_WINDOWS;

// 关窗操作结果
typedef struct tagNET_SPLIT_CLOSE_WINDOW_RESULT 
{
    BOOL                bResult;                        // 结果
    char                reserved[256];                  // 保留字节
} NET_SPLIT_CLOSE_WINDOW_RESULT ;

// 批量关窗输出参数, 对应NET_SPLIT_OPERATE_CLOSE_WINDOWS
typedef struct tagNET_OUT_SPLIT_CLOSE_WINDOWS
{
    DWORD               dwSize;
    NET_SPLIT_CLOSE_WINDOW_RESULT* pstuResults;         // 结果数组, 用户分配内存,大小为sizeof(NET_SPLIT_CLOSE_WINDOW_RESULT)*nMaxResultCount. 如果不需要返回结果, 可以为NULL
    int                 nMaxResultCount;                // 结果数组最大数量, 用户填写.
    int                 nRetResultCount;                // 返回的结果数量
} NET_OUT_SPLIT_CLOSE_WINDOWS;

//输出屏鱼眼矫正模式
typedef enum tagNET_WM_FISHEYE_CALIBRATE_MODE
{
    NET_WM_FISHEYE_CALIBRATE_MODE_UNKOWN ,            // 未知模式
    NET_WM_FISHEYE_CALIBRATE_MODE_CLOSE ,             // 关闭鱼眼算法
    NET_WM_FISHEYE_CALIBRATE_MODE_ORIGINAL,           // 原始模式(正方形) 带缩放比例
    NET_WM_FISHEYE_CALIBRATE_MODE_PANORAMA,           // 1P
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_ONE,       // 1P+1
    NET_WM_FISHEYE_CALIBRATE_MODE_DOUBLE_PANORAMA,    // 2P        
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_DOUBLE_PAN,     // 1+2p
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_THREEE,    // 1+3
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_THREEE,    // 1p+3
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_TWO,       // 1+2
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_FOUR,      // 1+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_FOUR,      // 1p+4
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_SIX,       // 1p+6
    NET_WM_FISHEYE_CALIBRATE_MODE_ORI_PLUS_EIGHT,     // 1+8
    NET_WM_FISHEYE_CALIBRATE_MODE_PAN_PLUS_EIGHT,     // 1P+8
}NET_WM_FISHEYE_CALIBRATE_MODE;

//鱼眼矫正窗口区域参数
typedef struct tagNET_WM_FISH_EYE_REGION_PARAM
{
    int     nCoordinateX;         // 窗口中心对应到原始圆的横坐标
    int     nCoordinateY;         // 窗口中心对应到原始圆的横坐标纵坐标
    int     nAngleH;              // 以X、Y为中心,校正区域范围的水平角度
    int     nAngleV;              // 以X、Y为中心,校正区域范围的垂直角度
    int 	nAvailable;			  // 表示是否可用
    BYTE    Reserved[124];        // 保留字节
}NET_WM_FISH_EYE_REGION_PARAM;

#define MAX_FISH_EYE_REGION_NUM     9
//模式初始化各画面信息,适用于模式切换恢复到上一次的状态
typedef struct tagNET_WM_SET_FISHEYE_INIT_PARAM
{
    BOOL                            bUseRegion;         // 为TRUE时,使用以下成员进行初始化,为FALSE时以下成员无效
    int                             nCircular;          // 环形偏移(鱼眼显示模式中带原始图时有意义。如1+3、1+8等模式的1画面)
    int                             nPanorama;          // 全景偏移(鱼眼显示模式带全景时有意义,如1P、2P等模式)
	int                             nFishEyeRegionNum;  // 鱼眼矫正窗口区域参数个数(数组个数等于实际的矫正模式.如1+3,则有4个元素)
    NET_WM_FISH_EYE_REGION_PARAM    stFishEyeRegions[MAX_FISH_EYE_REGION_NUM];    // 鱼眼矫正窗口区域参数信息
    BYTE                            Reserved[1024];                       // 保留字节
}NET_WM_SET_FISHEYE_INIT_PARAM;

//电子云台缩放移动参数
typedef struct tagNET_WM_SET_FISHEYE_EPTZ_PARAM
{
	int 							nOptWayType;		// 操作类型(表示鱼眼云台控制时的arg1,表示是移动还是放大)
	int 							nOptWinNum; 		// 小窗口号(当前正在操作的小窗口号)
	int 							nOptWayData;		// 操作数据(表示鱼眼云台控制时的数据大小。和OptWayType配合使用)
	BYTE                            Reserved[512];      // 保留字节
}NET_WM_SET_FISHEYE_EPTZ_PARAM;

//设置输出屏的鱼眼矫正规则输入参数, 对应NET_IN_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_IN_WM_SET_FISH_EYE_PARAM
{
    DWORD                           dwSize;
    int                             nChannel;            // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*                     pszCompositeID;      // 融合屏ID
    int                             nWindowID;           // 对应输出屏的窗口号

    NET_FISHEYE_MOUNT_MODE          emMount;            // 鱼眼安装模式
    NET_WM_FISHEYE_CALIBRATE_MODE   emCalibrate;        // 鱼眼矫正模式
    NET_WM_SET_FISHEYE_INIT_PARAM   stInitParam;        // 模式初始化各画面信息   
    NET_WM_SET_FISHEYE_EPTZ_PARAM	stEPtzParam;		// 电子云台缩放移动参数
}NET_IN_WM_SET_FISH_EYE_PARAM;

//设置输出屏的鱼眼矫正规则输出参数, 对应NET_OUT_WM_SET_FISH_EYE_PARAM
typedef struct tagNET_OUT_WM_SET_FISH_EYE_PARAM
{
    DWORD dwSize;
}NET_OUT_WM_SET_FISH_EYE_PARAM;

// 图像旋转方式
typedef enum tagEM_WM_ROTATE_TYPE
{
    EM_WM_ROTATE_TYPE_NO_ROTATE,                         // 不旋转 
    EM_WM_ROTATE_TYPE_90_ROTATE,                         // 旋转90° 
    EM_WM_ROTATE_TYPE_180_ROTATE,                        // 旋转180°
    EM_WM_ROTATE_TYPE_270_ROTATE,                        // 旋转270°  
}EM_WM_ROTATE_TYPE;

// 设置图像旋转模式输入参数
typedef struct tagNET_IN_WM_SET_ROTATE_MODE
{
    DWORD				dwSize;
    int                 nChannel;                        // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                  // 融合屏ID
    int					nWindowID;					     // 窗口号
    EM_WM_ROTATE_TYPE	emRotateType;			         // 图像旋转方式
} NET_IN_WM_SET_ROTATE_MODE;

// 设置图像旋转模式输出参数
typedef struct tagNET_OUT_WM_SET_ROTATE_MODE
{
    DWORD            	dwSize;
} NET_OUT_WM_SET_ROTATE_MODE;


// 信号源属性 
typedef struct tagNET_SOURCE_ATTRIBUTE_INFO
{
    unsigned char       ucBrightness;       // 亮度,范围0~255
    unsigned char       ucContrast;         // 对比度,范围0~255
    unsigned char       ucSaturation;       // 色彩饱和度,范围0~255
    unsigned char       ucEQ;               // 视频高频信号的补偿调节,范围0~10
    BYTE                byReserver1[4];     // 保留字节，用于字节对齐
    int                 nMargin[4];         // 边距,每一项分别表示信号源左上右下四个边的边距,每项-50~50 
    BYTE                byReserver[512];    // 保留字节   
}NET_SOURCE_ATTRIBUTE_INFO;

// 设置信号源属性 输入参数
typedef struct tagNET_IN_SPLIT_SET_SOURCE_ATTRIBUTE
{
    DWORD                       dwSize;             // 结构体大小
    char                        szCompositeID[64];  // 拼接屏ID
    int                         nChannel;           // 通道号
    int                         nWindow;            // 窗口号
    NET_SOURCE_ATTRIBUTE_INFO   stuAttribute;       // 信号源属性 
}NET_IN_SPLIT_SET_SOURCE_ATTRIBUTE;

// 设置信号源属性 输出参数
typedef struct tagNET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE
{
    DWORD                       dwSize;             // 结构体大小
}NET_OUT_SPLIT_SET_SOURCE_ATTRIBUTE;

// 设置窗口粘附状态 输入参数
typedef struct tagNET_IN_SPLIT_SET_DOCK_CONTROL
{
    DWORD                       dwSize;             // 结构体大小
    char                        szCompositeID[64];  // 拼接屏ID
    int                         nChannel;           // 通道号
    int                         nWindow;            // 窗口号
    BOOL                        bDock;              // 是否开启窗口粘附效果
}NET_IN_SPLIT_SET_DOCK_CONTROL;

// 设置窗口粘附状态 输出参数
typedef struct tagNET_OUT_SPLIT_SET_DOCK_CONTROL
{
    DWORD                       dwSize;             // 结构体大小
}NET_OUT_SPLIT_SET_DOCK_CONTROL;


//设置视频源显示区域的模式 输入参数
typedef struct tagNET_IN_WM_SET_MEETING_MODE
{
    DWORD                       dwSize;             // 结构体大小
    char                        szComposite[64];    // 拼接屏号
    int                         nChannel;           // 输出通道号或融合屏虚拟通道号, szComposite为空时有效  
    int                         nWindow;            // 窗口号
    BOOL                        bEnable;            // TRUE：会议室模式; FALSE：标准模式
}NET_IN_WM_SET_MEETING_MODE;

//设置视频源显示区域的模式 输出参数
typedef struct tagNET_OUT_WM_SET_MEETING_MODE
{
    DWORD                       dwSize;             // 结构体大小
}NET_OUT_WM_SET_MEETING_MODE;


// 设置锁定窗口当前位置 输入参数
typedef struct tagNET_IN_WM_SET_LOCK_POSITION
{
    DWORD                       dwSize;             // 结构体大小
    char                        szComposite[64];    // 拼接屏号
    int                         nChannel;           // 输出通道号或融合屏虚拟通道号, szComposite为空时有效 
    int                         nWindow;            // 窗口ID,-1代表所有窗口 
    BOOL                        bLock;              // 是否锁定
}NET_IN_WM_SET_LOCK_POSITION;


// 设置锁定窗口当前位置 输出参数
typedef struct tagNET_OUT_WM_SET_LOCK_POSITION
{
    DWORD                       dwSize;             // 结构体大小
}NET_OUT_WM_SET_LOCK_POSITION;

// 修改预案控制ID 输入参数
typedef struct tagNET_IN_WM_SET_COLLECTION_CTRL_ID
{
    DWORD                       dwSize;             // 结构体大小
    int                         nChannel;           // 输出通道号或融合屏虚拟通道号, szComposite为空时有效 
    char                        szComposite[64];    // 拼接屏号
    char                        szName[128];        // 预案名称
    char                        szControlID[8];     // 预案新的控制ID(数值范围：1-255)
}NET_IN_WM_SET_COLLECTION_CTRL_ID;

// 修改预案控制ID 输出参数
typedef struct tagNET_OUT_WM_SET_COLLECTION_CTRL_ID
{
    DWORD                       dwSize;             // 结构体大小
}NET_OUT_WM_SET_COLLECTION_CTRL_ID ;

// 设置窗口分割模式 输入参数
typedef struct tagNET_IN_WM_SET_MODE
{
    DWORD                       dwSize;             // 结构体大小
    int                         nChannel;           // 输出通道号或融合屏虚拟通道号
    int                         nWindow;            // 窗口号
    DH_SPLIT_MODE               emSplitMode;        // 分割模式
}NET_IN_WM_SET_MODE ;

// 分割后的窗口信息
typedef struct tagNET_SPLITED_WINDOW_INFO
{
    NET_RECT            stuRect;                    // 窗口区域,8192坐标系[0-8191]
    int                 nWindow;                    // 窗口号,这个窗口是拆分后的新窗口和原来的窗口号是不同的
    int                 nZOrder;                    // 窗口Z序
    char                szControlID[32];            // 窗口控制ID  
    BYTE                byReserver[512];            // 保留字节
}NET_SPLITED_WINDOW_INFO;


// 设置窗口分割模式 输出参数
typedef struct tagNET_OUT_WM_SET_MODE
{
    DWORD                       dwSize;                 // 结构体大小
    UINT                        nSplitedWindowNum;      // 分割后的窗口个数
    NET_SPLITED_WINDOW_INFO     stuSplitedWindow[144];  // 分割后的窗口信息
}NET_OUT_WM_SET_MODE;

////////////////////////////////// 系统状态 ////////////////////////////////////////

// CPU信息
typedef struct tagDH_CPU_INFO
{
    DWORD               dwSize;
    int                 nUsage;                         // CPU利用率
} DH_CPU_INFO;

// CPU状态
typedef struct tagDH_CPU_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                        // 查询是否成功
    int                 nCount;                         // CPU数量
    DH_CPU_INFO         stuCPUs[DH_MAX_CPU_NUM];        // CPU信息
} DH_CPU_STATUS;

// 内存信息
typedef struct tagDH_MEMORY_INFO
{
    DWORD               dwSize;
    DWORD               dwTotal;                        // 总内存, M
    DWORD               dwFree;                         // 剩余内存, M
} DH_MEMORY_INFO;

// 内存状态
typedef struct tagDH_MEMORY_STATUS 
{
    DWORD               dwSize;
    BOOL                bEnable;                        // 查询是否成功
    DH_MEMORY_INFO      stuMemory;                      // 内存信息
} DH_MEMORY_STATUS;

// 风扇信息
typedef struct tagDH_FAN_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // 名称
    DWORD               nSpeed;                         // 速度
} DH_FAN_INFO;

// 风扇状态
typedef struct tagDH_FAN_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                        // 查询是否成功
    int                 nCount;                         // 风扇数量
    DH_FAN_INFO         stuFans[DH_MAX_FAN_NUM];        // 风扇状态
} DH_FAN_STATUS;

// 电源电流状态类型
typedef enum __EM_CURRENT_STATE_TYPE
{
    EM_CURRENT_STATE_UNKNOWN = 0,
    EM_CURRENT_STATE_OVER_CURRENT,                      // 电流过载
    EM_CURRENT_STATE_NORMAL,                            // 电流正常
    EM_CURRENT_STATE_UNDER_CURRENT,                     // 电源欠流
}EM_CURRENT_STATE_TYPE;

// 电源电压状态类型
typedef enum tagEM_VOLTAGE_STATE_TYPE
{
    EM_VOLTAGE_STATE_UNKNOWN,                           // 未知
    EM_VOLTAGE_STATE_OVER,                              // 过压
    EM_VOLTAGE_STATE_NORMAL,                            // 正常
    EM_VOLTAGE_STATE_UNDER,                             // 欠压
} EM_VOLTAGE_STATE_TYPE;

// 电源信息
typedef struct tagDH_POWER_INFO
{
    DWORD               dwSize;
    BOOL                bPowerOn;                       // 电源状态, 0-关闭, 1-打开, 2-打开但有故障
    EM_CURRENT_STATE_TYPE emCurrentState;               // 电源电流状态
    EM_VOLTAGE_STATE_TYPE emVoltageState;               // 电源电压状态
} DH_POWER_INFO;


// 电池在位状态
typedef enum __EM_BATTERY_EXIST_STATE
{
    EM_BATTERY_EXIST_STATE_UNKNOWN = 0,
    EM_BATTERY_EXIST_STATE_EXIST,                       // 电池在位
    EM_BATTERY_EXIST_STATE_MISSING,                     // 电池丢失
}EM_BATTERY_EXIST_STATE;

// 电池电量状态
typedef enum __EM_BATTERY_STATE
{
    EM_BATTERY_STATE_UNKNOWN = 0,
    EM_BATTERY_STATE_NORMAL,                            // 电量正常
    EM_BATTERY_STATE_LOW,                               // 电量低
}EM_BATTERY_STATE;

// 电池信息, CLIENT_QueryDevState接口的 DH_DEVSTATE_POWER_STATE 命令参数
typedef struct tagDH_BATTERY_INFO
{
    DWORD               dwSize;
    int                 nPercent;                       // 电池容量百分比
    BOOL                bCharging;                      // 是否正在充电
    EM_BATTERY_EXIST_STATE emExistState;                // 电池在位状态
    EM_BATTERY_STATE    emState;                        // 电池电量状态
	float				fVoltage;						// 电池电压
} DH_BATTERY_INFO;

// 电源状态
typedef struct tagDH_POWER_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                            // 查询是否成功
    int                 nCount;                             // 电源数量
    DH_POWER_INFO       stuPowers[DH_MAX_POWER_NUM];        // 电源状态
    int                 nBatteryNum;                        // 电池数量
    DH_BATTERY_INFO     stuBatteries[DH_MAX_BATTERY_NUM];   // 电池状态
} DH_POWER_STATUS;

// 温度信息
typedef struct tagDH_TEMPERATURE_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];         // 传感器名称
    float               fTemperature;                       // 温度
} DH_TEMPERATURE_INFO;

// 温度状态
typedef struct tagDH_TEMPERATURE_STATUS
{
    DWORD               dwSize;
    BOOL                bEnable;                            // 查询是否成功
    int                 nCount;                             // 温度数量
    DH_TEMPERATURE_INFO stuTemps[DH_MAX_TEMPERATURE_NUM];   // 温度信息 
} DH_TEMPERATURE_STATUS;

// 系统状态
typedef struct tagDH_SYSTEM_STATUS
{
    DWORD                   dwSize;
    DH_CPU_STATUS*          pstuCPU;                        // CPU状态
    DH_MEMORY_STATUS*       pstuMemory;                     // 内存状态
    DH_FAN_STATUS*          pstuFan;                        // 风扇状态
    DH_POWER_STATUS*        pstuPower;                      // 电源状态
    DH_TEMPERATURE_STATUS*  pstuTemp;                       // 温度状态
} DH_SYSTEM_STATUS;

// 对应CLIENT_QueryDevState()接口的 DH_DEVSTATE_ALL_ALARM_CHANNELS_STATE命令参数
// 获取报警通道状态
typedef enum tagNET_ALARM_CHANNEL_TYPE
{
    NET_ALARM_CHANNEL_TYPE_ALL,                             // 所有通道（包含以下所有）
    NET_ALARM_CHANNEL_TYPE_ALARMIN,                         // 报警输入通道
    NET_ALARM_CHANNEL_TYPE_ALARMOUT,                        // 报警输出通道
    NET_ALARM_CHANNEL_TYPE_ALARMBELL,                       // 警号通道
    NET_ALARM_CHANNEL_TYPE_EXALARMIN,                       // 扩展模块报警输入通道
    NET_ALARM_CHANNEL_TYPE_EXALARMOUT,                      // 扩展模块报警输出通道
}NET_ALARM_CHANNEL_TYPE;

typedef struct tagNET_CLIENT_ALARM_CHANNELS_STATE
{
    DWORD                       dwSize;
    NET_ALARM_CHANNEL_TYPE      emType;                     // 查询报警通道的类型                                                                                                                                
    int                         nAlarmInCount;              // 报警输入个数,由用户指定
    int                         nAlarmInRetCount;           // 报警输入返回个数
    BOOL*                       pbAlarmInState;             // 报警输入状态数组,由用户分配内存,每个元素表示一个通道状态,TRUE为有输入,FALSE为无输入
															// 由用户申请内存,大小sizeof(BOOL)*nAlarmInCount
	int                         nAlarmOutCount;             // 报警输出个数,由用户指定
    int                         nAlarmOutRetCount;          // 报警输出个数
    BOOL*                       pbAlarmOutState;            // 报警输出状态数组,由用户分配内存,每个元素表示一个通道状态,TRUE为有输出,FALSE为输出
															// 由用户申请内存,大小sizeof(BOOL)*nAlarmOutCount
	int                         nAlarmBellCount;            // 警号个数,由用户指定
    int                         nAlarmBellRetCount;         // 警号返回个数
    BOOL*                       pbAlarmBellState;           // 警号状态数组,由用户分配内存,每个元素表示一个通道状态,TRUE为有输出,FALSE为无输出
															// 由用户申请内存,大小sizeof(BOOL)*nAlarmBellCount
	int                         nExAlarmInCount;            // 扩展模块报警输入个数,由用户指定
    int                         nExAlarmInRetCount;         // 扩展模块报警输入返回个数
    BOOL*                       pbExAlarmInState;           // 扩展模块报警输入状态数组,由用户分配内存,每个元素表示一个通道状态,TRUE为有输出,FALSE为无输出
															// 由用户申请内存,大小sizeof(BOOL)*nExAlarmInCount
	int*                        pnExAlarmInDestionation;    // 扩展模块报警输入有效通道的位置,由用户申请内存,大小sizeof(int)*nExAlarmInCount
    int                         nExAlarmOutCount;           // 扩展模块报警输出个数,由用户指定
    int                         nExAlarmOutRetCount;        // 扩展模块报警输出个数
    BOOL*                       pbExAlarmOutState;          // 扩展模块报警输出状态数组,由用户分配内存,每个元素表示一个通道状态,TRUE为有输出,FALSE为无输出
															// 由用户申请内存，大小为sizeof(BOOL)*nExAlarmOutCount
	int*                        pnExAlarmOutDestionation;   // 扩展模块报警输出有效通道的位置,由用户申请内存，大小为sizeof(int)*nExAlarmOutCount
}NET_CLIENT_ALARM_CHANNELS_STATE;


// 串口上连接的报警键盘数
typedef struct tagNET_ALARMKEYBOARD_COUNT
{
    DWORD               dwSize;
    int                 nAlarmKeyboardCount;        // 连接着的报警键盘数目
}NET_ALARMKEYBOARD_COUNT;

// 设备串口连接的设备类型
typedef enum tagEM_COM_PORT_DEVICE_TYPE
{
    EM_COM_PORT_DEVICE_TYPE_UNKNOWN,        // 未知的
    EM_COM_PORT_DEVICE_TYPE_PTZ,            // ptz
    EM_COM_PORT_DEVICE_TYPE_GPS,            // GPS
    EM_COM_PORT_DEVICE_TYPE_ALARMKEYBOARD,  // 报警键盘
    EM_COM_PORT_DEVICE_TYPE_EXALARMBOX,     // 扩展报警盒子
}EM_COM_PORT_DEVICE_TYPE;

// 获取设备COM端口连接的设备通道信息(入参)
typedef struct tagNET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;
    EM_COM_PORT_DEVICE_TYPE emDeviceType;   // 设备类型
}NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// 获取设备COM端口连接的设备通道信息(出参)
typedef struct tagNET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO
{
    DWORD               dwSize;    
    int                 nDeviceCount;               // 设备数目(出参,包括不在线和在线的)
    int                 nMaxOnlineDeviceCount;      // 在线的设备的最大个数(入参)
    int                 nRetOnlineDeviceCount;      // 设备返回的当前在线的设备数量(出参)      
    int*                pOnlineChannel;             // 当前在线的设备的通道索引数组(入参,由用户申请释放内存)    
}NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO;

// 获取设备COM端口连接的设备通道信息,pInParam与pInParamOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetComPortDeviceChannelInfo(LLONG lLoginID,const NET_IN_GET_COM_PORT_DEVICE_CHANNEL_INFO* pInParam,NET_OUT_GET_COM_PORT_DEVICE_CHANNEL_INFO* pOutParam,int nWaitTime);

////////////////////////////////// 大屏控制 ////////////////////////////////////////
// CLIENT_OpenSplitWindow接口输入参数(开窗)
typedef struct tagDH_IN_SPLIT_OPEN_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                   // 通道号(屏号)
    DH_RECT             stuRect;                    // 窗口位置, 0~8192
    BOOL                bDirectable;                // 坐标是否满足直通条件, 直通是指拼接屏方式下,此窗口区域正好为物理屏区域
} DH_IN_SPLIT_OPEN_WINDOW;

// CLIENT_OpenSplitWindow接口输出参数(开窗)
typedef struct tagDH_OUT_SPLIT_OPEN_WINDOW
{
    DWORD               dwSize;
    unsigned int        nWindowID;                  // 窗口序号
    unsigned int        nZOrder;                    // 窗口次序        
} DH_OUT_SPLIT_OPEN_WINDOW;

// CLIENT_CloseSplitWindow接口输入参数(关窗)
typedef struct tagDH_IN_SPLIT_CLOSE_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                   // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    UINT                nWindowID;                  // 窗口序号
    const char*         pszCompositeID;             // 融合屏ID
} DH_IN_SPLIT_CLOSE_WINDOW;

// CLIENT_CloseSplitWindow接口输出参数(关窗)
typedef struct tagDH_OUT_SPLIT_CLOSE_WINDOW
{
    DWORD               dwSize;
} DH_OUT_SPLIT_CLOSE_WINDOW;

// CLIENT_SetSplitWindowRect输入参数(设置窗口位置)
typedef struct tagDH_IN_SPLIT_SET_RECT
{
    DWORD               dwSize;
    int                 nChannel;                   // 通道号(屏号)
    UINT                nWindowID;                  // 窗口序号
    DH_RECT             stuRect;                    // 窗口位置, 0~8192
    BOOL                bDirectable;                // 坐标是否满足直通条件, 直通是指拼接屏方式下,此窗口区域正好为物理屏区域
} DH_IN_SPLIT_SET_RECT;

// CLIENT_SetSplitWindowRect接口输出参数(设置窗口位置)
typedef struct tagDH_OUT_SPLIT_SET_RECT
{
    DWORD               dwSize;
} DH_OUT_SPLIT_SET_RECT;

// CLIENT_GetSplitWindowRect接口输入参数(获取窗口位置)
typedef struct tagDH_IN_SPLIT_GET_RECT
{
    DWORD               dwSize;
    int                 nChannel;                  // 通道号(屏号)
    UINT                nWindowID;                 // 窗口序号
} DH_IN_SPLIT_GET_RECT;

// CLIENT_GetSplitWindowRect接口输出参数(获取窗口位置)
typedef struct tagDH_OUT_SPLIT_GET_RECT
{
    DWORD               dwSize;    
    DH_RECT             stuRect;                   // 窗口位置, 0~8192
} DH_OUT_SPLIT_GET_RECT;

// CLIENT_SetSplitWindowLevels接口输入参数(设置窗口次序)
typedef struct tagDH_IN_SPLIT_SET_TOP_WINDOW
{
    DWORD               dwSize;
    int                 nChannel;                  // 通道号(屏号)
    int                 nWindowID;                 // 窗口序号
} DH_IN_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetSplitWindowLevels接口输出参数(设置窗口次序)
typedef struct tagDH_OUT_SPLIT_SET_TOP_WINDOW
{
    DWORD               dwSize;
    DH_WND_ZORDER*      pZOders;                   // 窗口次序数组,由用户申请内存,大小为sizeof(DH_WND_ZORDER)*nMaxWndCount
    int                 nMaxWndCount;              // 窗口次序数组大小
    int                 nWndCount;                 // 返回的窗口数量
} DH_OUT_SPLIT_SET_TOP_WINDOW;

// CLIENT_SetDisplayMode接口输入参数(电视墙显示模式设置)
typedef struct tagDH_IN_WM_SET_DISPLAY_MODE 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // 电视墙序号
    const char*         pszBlockID;                 // 区块ID, NULL/""-所有区块
    int                 nTVID;                      // 显示单元序号, -1表示区块中所有显示单元
    UINT                nDisplayMode;               // 显示模式, 0-标准, 1-高亮, 2-节能
} DH_IN_WM_SET_DISPLAY_MODE;

// CLIENT_SetDisplayMode接口输出参数(电视墙显示模式设置)
typedef struct tagDH_OUT_WM_SET_DISPLAY_MODE
{
    DWORD               dwSize;
} DH_OUT_WM_SET_DISPLAY_MODE;

// 区块中所有显示单元的显示模式
typedef struct tagDH_BLOCK_DISPLAY_MODE
{
    DWORD               dwSize;
    int*                pTVModes;                   // TV显示模式数组
    int                 nMaxTVCount;                // TV显示模式数组大小
    int                 nRetTVCount;                // 实际TV数量
} DH_BLOCK_DISPLAY_MODE;

// CLIENT_GetDisplayMode接口的输入参数(获取电视墙显示模式)
typedef struct tagDH_IN_WM_GET_DISPLAY_MODE 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // 电视墙序号
    const char*         pszBlockID;                 // 区块ID, NULL/""-所有区块
    int                 nTVID;                      // 显示单元序号, -1表示区块中所有显示单元
} DH_IN_WM_GET_DISPLAY_MODE;

// CLIENT_GetDisplayMode接口的输出参数(获取电视墙显示模式)
typedef struct tagDH_OUT_WM_GET_DISPLAY_MODE
{
    DWORD                   dwSize;
    DH_BLOCK_DISPLAY_MODE*  pBlockModes;            // 区块显示模式数组,由用户申请内存，大小为sizeof(DH_BLOCK_DISPLAY_MODE)*nMaxBlockCount
    int                     nMaxBlockCount;         // 区块显示模式数组大小
    int                     nRetBlockCount;         // 实际区块数量
} DH_OUT_WM_GET_DISPLAY_MODE;

// CLIENT_PowerControl接口输入参数(电视墙电源控制)
typedef struct tagDH_IN_WM_POWER_CTRL 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // 电视墙序号
    const char*         pszBlockID;                 // 区块ID, NULL/""-所有区块
    int                 nTVID;                      // 显示单元序号, -1表示区块中所有显示单元
    BOOL                bPowerOn;                   // 是否打开电源
} DH_IN_WM_POWER_CTRL;

// CLIENT_PowerControl接口输出参数(电视墙电源控制)
typedef struct tagDH_OUT_WM_POWER_CTRL
{
    DWORD               dwSize;
} DH_OUT_WM_POWER_CTRL;

// CLIENT_LoadMonitorWallCollection接口输入参数(载入电视墙预案)
typedef struct tagDH_IN_WM_LOAD_COLLECTION 
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // 电视墙序号
    const char*         pszName;                    // 预案名称
} DH_IN_WM_LOAD_COLLECTION;

// CLIENT_LoadMonitorWallCollection接口输出参数(载入电视墙预案)
typedef struct tagDH_OUT_WM_LOAD_COLLECTION 
{
    DWORD               dwSize;
} DH_OUT_WM_LOAD_COLLECTION;

// 预案类型
typedef enum tagEM_SAVE_COLLECTION_TYPE
{
    EM_SAVE_COLLECTION_UNKNOWN,            // 未知
    EM_SAVE_COLLECTION_VIDEO,              // 视频预案
    EM_SAVE_COLLECTION_ADDITIONAL,         // 附加预案
}EM_SAVE_COLLECTION_TYPE;

// CLIENT_SaveMonitorWallCollection接口输入参数(保存电视墙预案)
typedef struct tagDH_IN_WM_SAVE_COLLECTION 
{
    DWORD                   dwSize;
    int                     nMonitorWallID;             // 电视墙序号
    const char*             pszName;                    // 预案名称
    const char*             pszControlID;               // 控制id
    BYTE                    bReserverd[4];              // 保留字节，用于字节对齐
    EM_SAVE_COLLECTION_TYPE emType;                     // 预案类型
} DH_IN_WM_SAVE_COLLECTION;

// CLIENT_SaveMonitorWallCollection接口输出参数(保存电视墙预案)
typedef struct tagDH_OUT_WM_SAVE_COLLECTION 
{
    DWORD               dwSize;
} DH_OUT_WM_SAVE_COLLECTION;

// CLIENT_RenameMonitorWallCollection接口输入参数(预案重命名)
typedef struct tagDH_IN_WM_RENAME_COLLECTION 
{
    DWORD               dwSize;
    int                 nMonitorWallID;                // 电视墙序号
    const char*         pszOldName;                    // 原名称
    const char*         pszNewName;                    // 新名称
} DH_IN_WM_RENAME_COLLECTION;

// CLIENT_RenameMonitorWallCollection接口输出参数(预案重命名)
typedef struct tagDH_OUT_WM_RENAME_COLLECTION
{
    DWORD                dwSize;
} DH_OUT_WM_RENAME_COLLECTION;

// 区块窗口信息
typedef struct tagDH_WINDOW_COLLECTION
{
    DWORD               dwSize;
    int                 nWindowID;                      // 窗口ID
    BOOL                bWndEnable;                     // 窗口是否有效
    DH_RECT             stuRect;                        // 窗口区域, 自由分割模式下有效
    BOOL                bDirectable;                    // 坐标是否满足直通条件
    int                 nZOrder;                        // 窗口Z次序
    BOOL                bSrcEnable;                     // 显示源是否有效
    char                szDeviceID[DH_DEV_ID_LEN_EX];   // 设备ID
    int                 nVideoChannel;                  // 视频通道号
    int                 nVideoStream;                   // 视频码流类型
    int                 nAudioChannel;                  // 音频通道
    int                 nAudioStream;                   // 音频码流类型
    int                 nUniqueChannel;                 // 设备内统一编号的唯一通道号
} DH_WINDOW_COLLECTION;

// 拼接区底图信息
typedef struct tagNET_SCREEEN_BACKGROUD
{
    BOOL            bEnable;                        // 底图是否开启
    char            szName[130];                    // 底图名称,底图是已经上传的文件，不带路径名称
    BYTE            byReserved[130];                // 保留字节用
} NET_SCREEEN_BACKGROUD;

// 区块收藏
typedef struct tagDH_BLOCK_COLLECTION 
{
    DWORD                dwSize;
    DH_SPLIT_MODE        emSplitMode;                   // 分割模式
    DH_WINDOW_COLLECTION stuWnds[DH_MAX_SPLIT_WINDOW];  // 窗口信息数组
    int                  nWndsCount;                    // 窗口数量
    char                 szName[DH_DEVICE_NAME_LEN];    // 收藏夹名称
    int                  nScreen;                       // 输出通道号, 包括拼接屏
    char                 szCompositeID[DH_DEV_ID_LEN_EX]; // 拼接屏ID    
    DH_WINDOW_COLLECTION* pstuWndsEx;                   // 窗口信息数组指针, 由用户分配内存. 当stuWnds数组大小不够用时可以使用
    int                  nMaxWndsCountEx;               // 最大窗口数量, 用户填写. pstuWndsEx数组的元素个数
    int                  nRetWndsCountEx;               // 返回窗口数量


    int                   nSplitOsdCount;               // OSD的个数
    NET_SPLIT_OSD         stuSplitOsd[20];              // 拼接区OSD叠加信息，
    NET_SCREEEN_BACKGROUD stuScreenBackground;          // 拼接区底图信息，目前仅预案获取时使用
} DH_BLOCK_COLLECTION;

// 电视墙显示单元
typedef struct tagDH_MONITORWALL_OUTPUT 
{
    DWORD               dwSize;
    char                szDeviceID[DH_DEV_ID_LEN];          // 设备ID, 本机时为""
    int                 nChannel;                           // 通道号
    char                szName[DH_DEV_NAME_LEN];            // 屏幕名称
} DH_MONITORWALL_OUTPUT;

// 电视墙显示区块
typedef struct tagDH_MONITORWALL_BLOCK
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // 区块名称
    char                    szCompositeID[DH_DEV_ID_LEN];   // 拼接屏ID
    char                    szControlID[DH_DEV_ID_LEN];     // 控制ID
    int                     nSingleOutputWidth;             // 单个显示单元所占的网格列数
    int                     nSingleOutputHeight;            // 单个显示单元所占的网格行数
    DH_RECT                 stuRect;                        // 区域坐标
    DH_TSECT                stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // 开机时间表, 第一维各元素表示周日~周六和节假日
    DH_MONITORWALL_OUTPUT*  pstuOutputs;                    // 显示单元数组, 用户分配内存
    int                     nMaxOutputCount;                // 显示单元数组大小, 用户填写
    int                     nRetOutputCount;                // 返回的显示单元数量
	char                    szBlockType[DH_COMMON_STRING_32];   // 显示单元组类型,为支持由接收卡组成单元的小间距LED区块而增加该字段,其他类型的区块填写为"LCD",如不存在该字段,默认采用LCD
} DH_MONITORWALL_BLOCK;

// 电视墙配置
typedef struct tagDH_MONITORWALL 
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // 名称
    int                     nGridLine;                      // 网格行数
    int                     nGridColume;                    // 网格列数
    DH_MONITORWALL_BLOCK*   pstuBlocks;                     // 显示区块数组, 用户分配内存
    int                     nMaxBlockCount;                 // 显示区块数组大小, 用户填写
    int                     nRetBlockCount;                 // 返回的显示区块数量
    BOOL                    bDisable;                       // 是否禁用, 0-该电视墙有效, 1-该电视墙无效
    char                    szDesc[DH_COMMON_STRING_256];   // 电视墙描述信息
} DH_MONITORWALL;

// 电视墙预案
typedef struct tagDH_MONITORWALL_COLLECTION 
{
    DWORD                dwSize;
    char                 szName[DH_DEVICE_NAME_LEN];    // 电视墙预案名称
    DH_BLOCK_COLLECTION  stuBlocks[DH_MAX_BLOCK_NUM];   // 区块数组
    int                  nBlocksCount;                  // 区块数量
    char                 szControlID[DH_DEV_ID_LEN_EX]; // 控制ID
    DH_MONITORWALL       stuMonitorWall;                // 电视墙配置
    EM_SAVE_COLLECTION_TYPE emType;                     // 预案类型
    BYTE                  byReserved[4];                // 保留字节用，于字节对齐
} DH_MONITORWALL_COLLECTION;

// CLIENT_GetMonitorWallCollections接口输入参数(获取电视墙预案信息)
typedef struct tagDH_IN_WM_GET_COLLECTIONS 
{
    DWORD                dwSize;
    int                  nMonitorWallID;                // 电视墙ID
} DH_IN_WM_GET_COLLECTIONS;

// CLIENT_GetMonitorWallCollections接口输出参数(获取电视墙预案信息)
typedef struct tagDH_OUT_WM_GET_COLLECTIONS 
{
    DWORD                       dwSize;    
    DH_MONITORWALL_COLLECTION*  pCollections;           // 电视墙预案数组
    int                         nMaxCollectionsCount;   // 电视墙预案数组大小
    int                         nCollectionsCount;      // 电视墙预案数量
} DH_OUT_WM_GET_COLLECTIONS;

// CLIENT_GetSplitWindowsInfo接口输入参数
typedef struct tagDH_IN_SPLIT_GET_WINDOWS 
{
    DWORD              dwSize;
    int                nChannel;                        // 通道号
} DH_IN_SPLIT_GET_WINDOWS;

// CLIENT_GetSplitWindowsInfo接口输出参数
typedef struct tagDH_OUT_SPLIT_GET_WINDOWS 
{
    DWORD                   dwSize;
    DH_BLOCK_COLLECTION     stuWindows;                 // 窗口信息
} DH_OUT_SPLIT_GET_WINDOWS;

// CLIENT_LoadSplitCollection接口输入参数(载入收藏)
typedef struct tagDH_IN_SPLIT_LOAD_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // 输出通道号
    const char*       pszName;                  // 收藏夹名称
} DH_IN_SPLIT_LOAD_COLLECTION;

// CLIENT_LoadSplitCollection接口输出参数(载入收藏)
typedef struct tagDH_OUT_SPLIT_LOAD_COLLECTION 
{
    DWORD             dwSize;
} DH_OUT_SPLIT_LOAD_COLLECTION;

// CLIENT_SaveSplitCollection接口输入参数(保存收藏)
typedef struct tagDH_IN_SPLIT_SAVE_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // 输出通道号
    const char*       pszName;                  // 收藏夹名称
} DH_IN_SPLIT_SAVE_COLLECTION;

// CLIENT_SaveSplitCollection接口输出参数(保存收藏)
typedef struct tagDH_OUT_SPLIT_SAVE_COLLECTION 
{
    DWORD             dwSize;
} DH_OUT_SPLIT_SAVE_COLLECTION;

// CLIENT_RenameSplitCollection接口输入参数(收藏重命名)
typedef struct tagDH_IN_SPLIT_RENAME_COLLECTION 
{
    DWORD             dwSize;
    int               nChannel;                 // 输出通道号
    const char*       pszOldName;               // 原名称
    const char*       pszNewName;               // 新名称
} DH_IN_SPLIT_RENAME_COLLECTION;

// CLIENT_RenameSplitCollection接口输出参数(收藏重命名)
typedef struct tagDH_OUT_SPLIT_RENAME_COLLECTION
{
    DWORD             dwSize;
} DH_OUT_SPLIT_RENAME_COLLECTION;

// CLIENT_GetSplitCollections接口输入参数(获取收藏夹信息)
typedef struct tagDH_IN_SPLIT_GET_COLLECTIONS 
{
    DWORD             dwSize;
    int               nChannel;                // 输出通道号
} DH_IN_SPLIT_GET_COLLECTIONS;

// CLIENT_GetSplitCollections接口输出参数(获取收藏夹信息)
typedef struct tagDH_OUT_SPLIT_GET_COLLECTIONS 
{
    DWORD                dwSize;    
    DH_BLOCK_COLLECTION* pCollections;                  // 收藏夹数组,由用户申请内存，大小为sizeof(DH_BLOCK_COLLECTION)*nMaxCollectionsCount
    int                  nMaxCollectionsCount;          // 收藏夹数组大小
    int                  nCollectionsCount;             // 返回的收藏夹数量
} DH_OUT_SPLIT_GET_COLLECTIONS;

// CLIENT_DeleteSplitCollection接口的输入参数(删除收藏夹)
typedef struct tagDH_IN_SPLIT_DELETE_COLLECTION 
{
    DWORD                dwSize;
    int                  nChannel;                      // 输出通道号
    const char**         ppszNames;                     // 收藏夹名称数组
    int                  nNameCount;                    // 收藏夹名称数组大小
} DH_IN_SPLIT_DELETE_COLLECTION;

// CLIENT_DeleteSplitCollection接口的输出参数(删除收藏夹)
typedef struct tagDH_OUT_SPLIT_DELETE_COLLECTION 
{
    DWORD                dwSize;
} DH_OUT_SPLIT_DELETE_COLLECTION;

// 融合屏通道信息
typedef struct tagDH_COMPOSITE_CHANNEL
{
    DWORD               dwSize;
    char                szMonitorWallName[DH_DEVICE_NAME_LEN];  // 电视墙名称
    char                szCompositeID[DH_DEV_ID_LEN_EX];        // 融合屏ID
    int                 nVirtualChannel;                        // 虚拟通道号
} DH_COMPOSITE_CHANNEL;

// 轮巡使能配置
typedef struct tagDHDEV_TOUR_ENABLE
{
    DWORD               dwSize;
    BOOL                bEnable;                    // 轮巡使能
    BOOL                bStart;                     // 是否正在轮巡(只读). 轮巡使能打开但没有配置轮巡输入源时, bStart=FALSE
} DHDEV_TOUR_ENABLE_CFG;

// CLIENT_SetDecodePolicy接口输入参数(设置解码策略)
typedef struct tagDH_IN_SET_DEC_POLICY 
{
    DWORD               dwSize;
    int                 nChannel;               // 通道号
    int                 nWindow;                // 窗口号, -1表示通道内所有窗口
    int                 nPolicyLevel;           // 解码策略等级, 共5档(-2, -1, 0, 1, 2), 值越大越流畅但延迟越大
                                                // -2表示实时性最好, 2表示流畅性最好, 0默认
} DH_IN_SET_DEC_POLICY;

// CLIENT_SetDecodePolicy接口输出参数(设置解码策略)
typedef struct tagDH_OUT_SET_DEC_POLICY 
{
    DWORD                dwSize;
} DH_OUT_SET_DEC_POLICY;

// CLIENT_GetDecodePolicy接口输入参数(获取解码策略)
typedef struct tagDH_IN_GET_DEC_POLICY 
{
    DWORD                dwSize;
    int                  nChannel;              // 通道号
    int                  nWindow;               // 窗口号, -1表示通道内所有窗口
} DH_IN_GET_DEC_POLICY;

// CLIENT_GetDecodePolicy接口输出参数(获取解码策略)
typedef struct tagDH_OUT_GET_DEC_POLICY 
{
    DWORD                dwSize;
    int                  nPolicyLevel;          // 解码策略等级, 共5档(-2, -1, 0, 1, 2), 值越大越流畅但延迟越大
                                                // -2表示实时性最好, 2表示流畅性最好, 0默认
} DH_OUT_GET_DEC_POLICY;

// 音频输出模式
typedef enum
{
    DH_AUDIO_AUTO,                              // 自动切换音频输出, 只有一个音频窗口
    DH_AUDIO_DISABLE,                           // 禁止所有音频输出 
    DH_AUDIO_FORCE,                             // 强制输出用户指定的某个窗口的音频, 只有一个音频窗口
    DH_AUDIO_ENABLE_ONE,                        // 开启指定窗口音频, 可以有多路音频输出   
    DH_AUDIO_DISABLE_ONE,                       // 关闭指定窗口音频, 可以有多路音频输出
    DH_AUDIO_MULTI,                             // 多路音频输出, 查询时可用, 设置时该值无效
} DH_AUDIO_OUTPUT_MODE;

// CLIENT_SetSplitAudioOuput接口输入参数(设置音频输出模式)
typedef struct tagDH_IN_SET_AUDIO_OUTPUT 
{
    DWORD                dwSize;
    int                  nChannel;              // 通道号
    DH_AUDIO_OUTPUT_MODE emMode;                // 音频输出模式
    int                  nWindow;               // 输出窗口号, emMode为DH_AUDIO_FORCE/DH_AUDIO_ENABLE_ONE/DH_AUDIO_DISABLE_ONE时有效, 指定输出音频的窗口号
} DH_IN_SET_AUDIO_OUTPUT;

// CLIENT_SetSplitAudioOuput接口输出参数(设置音频输出模式)
typedef struct tagDH_OUT_SET_AUDIO_OUTPUT
{
    DWORD                dwSize;
} DH_OUT_SET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput接口输入参数(获取音频输出模式)
typedef struct tagDH_IN_GET_AUDIO_OUTPUT
{
    DWORD                dwSize;
    int                  nChannel;              // 通道号
} DH_IN_GET_AUDIO_OUTPUT;

// CLIENT_GetSplitAudioOuput接口输出参数(获取音频输出模式)
typedef struct tagDH_OUT_GET_AUDIO_OUTPUT
{
    DWORD                dwSize;
    DH_AUDIO_OUTPUT_MODE emMode;                // 音频输出模式
    int                  nWindow;               // 输出窗口号, emMode为DH_AUDIO_FORCE时有效
    int*                 pMultiWindows;         // 输出窗口号列表, emMode为DH_AUDIO_MULTI时有效, 用户分配内存,大小为sizeof(int)*nMaxMultiWindowCount
    int                  nMaxMultiWindowCount;  // 输出窗口号列表最大数量, 用户填写
    int                  nRetMultiWindowCount;  // 输出窗口号数量, emMode为DH_AUDIO_MULTI时有效
} DH_OUT_GET_AUDIO_OUTPUT;

// CLIENT_GetEncodePlan 接口输入参数(获取刻录光盘时使用的编码参数)
typedef struct tagDH_IN_GET_ENCODE_PLAN
{
    DWORD               dwSize;
    unsigned int        nChannel;               // 指定要获取的编码通道号
    unsigned int        nExpectTime;            // 业务预期时长     整型,单位：分钟
    unsigned int        nCapacity;              // 可用的设备容量,整型,单位:M
}DH_IN_GET_ENCODE_PLAN;
// CLIENT_GetEncodePlan 接口输出参数(获取刻录光盘时使用的编码参数)
typedef struct tagDH_OUT_GET_ENCODE_PLAN
{
    DWORD               dwSize;
    int                 nResolutionType;        // emResolutionTypes成员个数 
    CAPTURE_SIZE        emResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// 视频分辨率范围
    CAPTURE_SIZE        emResolution;           // 推荐视频分辨率
    unsigned int        nBitRate;               // 视频固定码流值
}DH_OUT_GET_ENCODE_PLAN;

// CLIENT_GetEncodePlanByResolution 接口输入参数(根据指定的光盘容量和分辨率码率计算业务时长)
typedef struct tagNET_IN_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nChannel;               // 指定要获取的编码通道号
	CAPTURE_SIZE        emResolution;			// 视频分辨率
	unsigned int        nBitRate;               // 视频码流值
	unsigned int		nCapacity;				// 可用的设备容量
} NET_IN_GET_ENCODEPLANE_BY_RESOLUTION;

// CLIENT_GetEncodePlanByResolution 接口输出参数(根据指定的光盘容量和分辨率码率计算业务时长)
typedef struct tagNET_OUT_GET_ENCODEPLANE_BY_RESOLUTION
{
	DWORD               dwSize;
	unsigned int        nExpectTime;			// 业务预期时长
} NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION;


// 组织目录逻辑对象
typedef struct tagDH_ORGANIZATION_NODE_LOGIC_OBJECT 
{
    DWORD               dwSize;
    char                szName[DH_NODE_NAME_LEN];       // 名称
    char                szType[DH_DEV_TYPE_LEN];        // 类型
    char                szDevID[DH_DEV_ID_LEN_EX];      // 设备ID
    char                szControlID[DH_DEV_ID_LEN_EX];  // 控制ID, 只读
    int                 nChannel;                       // 通道号
} DH_ORGANIZATION_NODE_LOGIC_OBJECT;

// 组织目录
typedef struct tagDH_ORGANIZATION_NODE_DIRECTORY
{
    DWORD               dwSize;
    char                szName[DH_NODE_NAME_LEN];       // 名称
    char                szControlID[DH_DEV_ID_LEN_EX];  // 控制ID
} DH_ORGANIZATION_NODE_DIRECTORY;

// 组织目录节点信息
typedef struct tagDH_ORGANIZATION_NODE 
{
    DWORD               dwSize;
    int                 nNodeType;                        // 节点类型, 0-逻辑对象, 1-目录
    DH_ORGANIZATION_NODE_LOGIC_OBJECT    stuLogicObject;  // 逻辑对象, nNodeType==0时有效
    DH_ORGANIZATION_NODE_DIRECTORY       stuDirectory;    // 目录, nNodeType==1时有效        
} DH_ORGANIZATION_NODE;

// 增加节点参数
typedef struct tagDH_ORGANIZATION_ADD_NODE_PARAM
{
    DWORD                dwSize;
    int                  nPosition;                     // 插入位置, -1-开始, -2-末尾, 0~n
    DH_ORGANIZATION_NODE stuNode;                       // 节点信息
} DH_ORGANIZATION_ADD_NODE_PARAM;

// CLIENT_OrganizationAddNodes接口的输入参数(增加节点)
typedef struct tagDH_IN_ORGANIZATION_ADD_NODES
{
    DWORD                dwSize;
    char*                pszPath;                       // 路径
    DH_ORGANIZATION_ADD_NODE_PARAM* pstuNodes;          // 节点信息数组指针,由用户申请内存，大小为sizeof(DH_ORGANIZATION_ADD_NODE_PARAM)*nNodeCount
    int                  nNodeCount;                    // 节点数量
} DH_IN_ORGANIZATION_ADD_NODES;

// 增加节点的结果
typedef struct tagDH_ORGANIZATION_ADD_NODE_RESULT
{
    DWORD               dwSize;
    BOOL                bResult;                        // 结果
    char                szPath[MAX_PATH];               // 路径, 成功返回node路径,失败返回添加node时的路径
} DH_ORGANIZATION_ADD_NODE_RESULT;

// CLIENT_OrganizationAddNodes接口的输出参数(增加节点)
typedef struct tagDH_OUT_ORGANIZATION_ADD_NODES
{
    DWORD               dwSize;
    DH_ORGANIZATION_ADD_NODE_RESULT* pstuResults;       // 结果数组指针
    int                 nMaxResultCount;                // 结果数组大小
    int                 nRetResultCount;                // 返回的结果数量
} DH_OUT_ORGANIZATION_ADD_NODES;

// 节点路径
typedef struct tagDH_ORGANIZATION_NODE_PATH 
{
    DWORD               dwSize;
    char                szPath[MAX_PATH];               // 路径
} DH_ORGANIZATION_NODE_PATH;

// CLIENT_OrganizationDeleteNodes接口的输入参数(删除节点)
typedef struct tagDH_IN_ORGANIZATION_DELETE_NODES
{
    DWORD               dwSize;
    DH_ORGANIZATION_NODE_PATH*  pstuPath;               // 节点路径数组,由用户申请内存，大小为sizeof(DH_ORGANIZATION_NODE_PATH)*nPathCount
    int                 nPathCount;                     // 节点数量
} DH_IN_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationDeleteNodes接口的输出参数(删除节点)
typedef struct tagDH_OUT_ORGANIZATION_DELETE_NODES 
{
    DWORD               dwSize;
} DH_OUT_ORGANIZATION_DELETE_NODES;

// CLIENT_OrganizationGetNodes接口的输入参数(获取节点信息)
typedef struct tagDH_IN_ORGANIZATION_GET_NODES 
{
    DWORD               dwSize;
    char*               pszPath;                        // 路径
    int                 nLevel;                         // 级别, 0-本级, 1-下一级
} DH_IN_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationGetNodes接口的输出参数(获取节点信息)
typedef struct tagDH_OUT_ORGANIZATION_GET_NODES 
{
    DWORD                   dwSize;
    DH_ORGANIZATION_NODE*   pstuNodes;                  // 节点数组, 用户分配内存,大小为sizeof(DH_ORGANIZATION_NODE)*nMaxNodeCount
    int                     nMaxNodeCount;              // 节点数组大小
    int                     nRetNodeCount;              // 返回的节点数量
} DH_OUT_ORGANIZATION_GET_NODES;

// CLIENT_OrganizationSetNode接口的输入参数(设置节点)
typedef struct tagDH_IN_ORGANIZATION_SET_NODE 
{
    DWORD                dwSize;
    char*                pszPath;                    // 路径
    DH_ORGANIZATION_NODE stuNode;                    // 节点信息
} DH_IN_ORGANIZATION_SET_NODE;

// CLIENT_OrganizationSetNode接口的输出参数(设置节点)
typedef struct tagDH_OUT_ORGANIZATION_SET_NODE 
{
    DWORD               dwSize;
} DH_OUT_ORGANIZATION_SET_NODE;

// 视频输入通道信息
typedef struct tagDH_VIDEO_INPUTS
{
    DWORD               dwSize;
    char                szChnName[DH_DEVICE_NAME_LEN];      // 通道名称
    BOOL                bEnable;                            // 使能
    char                szControlID[DH_DEV_ID_LEN_EX];      // 控制ID
    char                szMainStreamUrl[MAX_PATH];          // 主码流url地址 
    char                szExtraStreamUrl[MAX_PATH];         // 辅码流url地址
    int                 nOptionalMainUrlCount;              // 备用主码流地址数量
    char                szOptionalMainUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH];  // 备用主码流地址列表
    int                 nOptionalExtraUrlCount;             // 备用辅码流地址数量
    char                szOptionalExtraUrls[DH_MAX_OPTIONAL_URL_NUM][MAX_PATH]; // 备用辅码流地址列表
} DH_VIDEO_INPUTS;

typedef struct tagDH_REMOTE_DEVICE 
{
    DWORD               dwSize;
    BOOL                bEnable;                            // 使能
    char                szIp[DH_MAX_IPADDR_LEN];            // IP
    char                szUser[DH_USER_NAME_LENGTH];        // 用户名,建议使用szUserEx
    char                szPwd[DH_USER_PSW_LENGTH];          // 密码,建议使用szPwdEx
    int                 nPort;                              // 端口
    int                 nDefinition;                        // 清晰度, 0-标清, 1-高清
    DH_DEVICE_PROTOCOL  emProtocol;                         // 协议类型
    char                szDevName[DH_DEVICE_NAME_LEN];      // 设备名称
    int                 nVideoInputChannels;                // 视频输入通道数
    int                 nAudioInputChannels;                // 音频输入通道数
    char                szDevClass[DH_DEV_TYPE_LEN];        // 设备类型, 如IPC, DVR, NVR等
    char                szDevType[DH_DEV_TYPE_LEN];         // 设备具体型号, 如IPC-HF3300
    int                 nHttpPort;                          // Http端口
    int                 nMaxVideoInputCount;                // 视频输入通道最大数
    int                 nRetVideoInputCount;                // 返回实际通道个数
    DH_VIDEO_INPUTS*    pstuVideoInputs;                    // 视频输入通道信息,由用户申请内存，大小为sizeof(DH_VIDEO_INPUTS)*nMaxVideoInputCount
    char                szMachineAddress[DH_MAX_CARD_INFO_LEN]; // 设备部署地
    char                szSerialNo[DH_SERIALNO_LEN];        // 设备序列号
    int                 nRtspPort;                          // Rtsp端口

	/*以下用于新平台扩展*/
	char                szUserEx[DH_USER_NAME_LEN_EX];       // 用户名
    char                szPwdEx[DH_USER_PSW_LEN_EX];         // 密码

    char				szVendorAbbr[DH_COMMON_STRING_32];		// 厂商缩写
    char             szSoftwareVersion[DH_COMMON_STRING_64];         // 设备软件版本
    NET_TIME         stuActivationTime;                      // 启动时间    
} DH_REMOTE_DEVICE;

typedef enum tagNET_LOGIC_CHANNEL_TYPE
{
    LOGIC_CHN_UNKNOWN,              // 未知
    LOGIC_CHN_LOCAL,                // 本地通道
    LOGIC_CHN_REMOTE,               // 远程通道
    LOGIC_CHN_COMPOSE,              // 合成通道, 对于庭审设备包含画中画通道和混音通道
    LOGIC_CHN_MATRIX,               // 模拟矩阵通道
    LOGIC_CHN_CASCADE,              // 级联通道
} NET_LOGIC_CHN_TYPE;

// 可用的显示源信息
typedef struct tagDH_MATRIX_CAMERA_INFO
{
    DWORD               dwSize;
    char                szName[DH_DEV_ID_LEN_EX];           // 名称
    char                szDevID[DH_DEV_ID_LEN_EX];          // 设备ID
    char                szControlID[DH_DEV_ID_LEN_EX];      // 控制ID
    int                 nChannelID;                         // 通道号, DeviceID设备内唯一
    int                 nUniqueChannel;                     // 设备内统一编号的唯一通道号
    BOOL                bRemoteDevice;                      // 是否远程设备
    DH_REMOTE_DEVICE    stuRemoteDevice;                    // 远程设备信息
    NET_STREAM_TYPE     emStreamType;                       // 视频码流类型
    NET_LOGIC_CHN_TYPE  emChannelType;                      // 通道类型
} DH_MATRIX_CAMERA_INFO;

// CLIENT_MatrixGetCameras接口的输入参数
typedef struct tagDH_IN_MATRIX_GET_CAMERAS 
{
    DWORD               dwSize;
} DH_IN_MATRIX_GET_CAMERAS;

// CLIENT_MatrixGetCameras接口的输出参数
typedef struct tagDH_OUT_MATRIX_GET_CAMERAS 
{
    DWORD                   dwSize;
    DH_MATRIX_CAMERA_INFO*  pstuCameras;                    // 显示源信息数组, 用户分配内存,大小为sizeof(DH_MATRIX_CAMERA_INFO)*nMaxCameraCount
    int                     nMaxCameraCount;                // 显示源数组大小
    int                     nRetCameraCount;                // 返回的显示源数量
} DH_OUT_MATRIX_GET_CAMERAS;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO 查询远程设备信息输入参数
typedef struct tagNET_IN_GET_DEVICE_INFO
{
    DWORD                       dwSize;                                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_IN_GET_DEVICE_INFO)
    char                        szDevice[DH_DEV_ID_LEN_EX];                 // 设备ID
    // 设备属性,当 szDevice 字段为空时,以下字段生效
    char                        szAttributeIP[DH_COMMON_STRING_32];             // 设备地址
    int                         nAttributePort;                                 // 设备端口
    char                        szAttributeUsername[DH_COMMON_STRING_128];      // 用户名
    char                        szAttributePassword[DH_COMMON_STRING_128];      // 密码
    char                        szAttributeManufacturer[DH_COMMON_STRING_128];  // 厂商协议
}NET_IN_GET_DEVICE_INFO;

//CLIENT_QueryDevInfo , NET_QUERY_DEV_REMOTE_DEVICE_INFO 查询远程设备信息输出参数
typedef struct tagNET_OUT_GET_DEVICE_INFO
{
    DWORD                       dwSize;         // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_GET_DEVICE_INFO)
    DH_REMOTE_DEVICE            stuInfo;        // 设备信息,该结构体内部成员 dwSize 需用户赋值
}NET_OUT_GET_DEVICE_INFO;

// CLIENT_MatrixSetCameras接口的输入参数
typedef struct tagDH_IN_MATRIX_SET_CAMERAS 
{
    DWORD                   dwSize;
    DH_MATRIX_CAMERA_INFO*  pstuCameras;                    // 显示源信息数组, 用户分配内存，大小为sizeof(DH_MATRIX_CAMERA_INFO)*nCameraCount
    int                     nCameraCount;                   // 显示源数组大小
} DH_IN_MATRIX_SET_CAMERAS;

// CLIENT_MatrixSetCameras接口的输出参数
typedef struct tagDH_OUT_MATRIX_SET_CAMERAS 
{
    DWORD                   dwSize;
} DH_OUT_MATRIX_SET_CAMERAS;

// 窗口显示源信息
typedef struct tagDH_SPLIT_WND_SOURCE 
{
    DWORD                   dwSize;
    BOOL                    bEnable;                        // 显示源是否有效
    char                    szDeviceID[DH_DEV_ID_LEN];      // 设备ID
    char                    szControlID[DH_DEV_ID_LEN];     // 控制ID
    int                     nVideoChannel;                  // 视频通道号
    int                     nVideoStream;                   // 视频码流类型
    int                     nAudioChannel;                  // 音频通道
    int                     nAudioStream;                   // 音频码流类型
    int                     nUniqueChannel;                 // 设备内统一编号的唯一通道号, 只读
    BOOL                    bRemoteDevice;                  // 是否远程设备
    DH_REMOTE_DEVICE        stuRemoteDevice;                // 远程设备信息
	NET_RECT				stuSRect;						// 视频源区域,若区域为(0,0,0,0)表示数据无效，设备使用默认值(0,0,8192,8192)
} DH_SPLIT_WND_SOURCE;

// 分割窗口信息
typedef struct tagDH_SPLIT_WINDOW 
{
    DWORD                   dwSize;
    BOOL                    bEnable;                        // 窗口是否有视频源
    int                     nWindowID;                      // 窗口ID
    char                    szControlID[DH_DEV_ID_LEN];     // 控制ID
    DH_RECT                 stuRect;                        // 窗口区域, 自由分割模式下有效
    BOOL                    bDirectable;                    // 坐标是否满足直通条件
    int                     nZOrder;                        // 窗口Z次序
    DH_SPLIT_WND_SOURCE     stuSource;                      // 显示信息
    UINT                     nOSDNum;                        // OSD个数
    NET_SPLIT_OSD           stuOSD[DH_VIDEO_CUSTOM_OSD_NUM_EX];    // OSD信息
    BOOL                    bLock;                          // 窗口是否被锁定位置
    BOOL                    bDock;                          // 窗口是否具有粘附效果
    BOOL                    bMeetingMode;                   // 窗口是否为会议模式状态
} DH_SPLIT_WINDOW;

// 拼接屏场景
typedef struct tagDH_SPLIT_SCENE 
{
    DWORD                   dwSize;
    char                    szCompositeID[DH_DEV_ID_LEN];   // 拼接屏ID
    char                    szControlID[DH_DEV_ID_LEN];     // 控制ID
    DH_SPLIT_MODE           emSplitMode;                    // 分割模式
    DH_SPLIT_WINDOW*        pstuWnds;                       // 窗口信息数组, 用户分配内存,大小为sizeof(DH_SPLIT_WINDOW)*nMaxWndCount
    int                     nMaxWndCount;                   // 窗口信息数组大小, 用户填写
    int                     nRetWndCount;                   // 返回的窗口数量
} DH_SPLIT_SCENE;

// 电视墙场景
typedef struct tagDH_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // 当前预案名称
    char                    szControlID[DH_DEV_ID_LEN];     // 控制ID
    DH_MONITORWALL          stuMonitorWall;                 // 电视墙配置    
    DH_SPLIT_SCENE*         pstuSplitScene;                 // 拼接屏场景信息数组, 用户分配内存,大小为sizeof(DH_SPLIT_SCENE)*nMaxSplitSceneCount
    int                     nMaxSplitSceneCount;            // 拼接屏场景数组大小, 用户填写
    int                     nRetSplitSceneCount;            // 返回的拼接屏场景数量
} DH_MONITORWALL_SCENE;

// CLIENT_MonitorWallGetScene接口输入参数(获取电视墙场景)
typedef struct tagDH_IN_MONITORWALL_GET_SCENE 
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // 电视墙序号
} DH_IN_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallGetScene接口输出参数(获取电视墙场景)
typedef struct tagDH_OUT_MONITORWALL_GET_SCENE 
{
    DWORD                   dwSize;
    char                    szName[DH_DEV_NAME_LEN];        // 当前预案名称, 可以为空
    DH_MONITORWALL_SCENE    stuScene;                       // 电视墙场景
} DH_OUT_MONITORWALL_GET_SCENE;

// CLIENT_MonitorWallSetScene接口输入参数(设置电视墙场景)
typedef struct tagDH_IN_MONITORWALL_SET_SCENE 
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // 电视墙序号
    DH_MONITORWALL_SCENE    stuScene;                       // 电视墙场景
} DH_IN_MONITORWALL_SET_SCENE;

// CLIENT_MonitorWallSetScene接口输出参数(设置电视墙场景)
typedef struct tagDH_OUT_MONITORWALL_SET_SCENE 
{
    DWORD                   dwSize;
} DH_OUT_MONITORWALL_SET_SCENE;

//CLIENT_QueryNetStat接口,查询类型为NET_APP_DATA_STAT时的输入参数(获取协议栈统计数据)
typedef struct tagNET_IN_NETAPP_NET_DATA_STAT
{
    DWORD       dwSize;    
    char        szEthName[DH_MAX_ETH_NAME];                //网卡名
}NET_IN_NETAPP_NET_DATA_STAT;

//接收相关统计数据,意义与ifconfig同
typedef struct tagNET_NETAPP_RECEIVE_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwFrame;
	DWORD        dwSpeed;           // 下行流量速度
}NET_NETAPP_RECEIVE_STAT;

//传输相关统计数据,意义与ifconfig同
typedef struct tagNET_NETAPP_TRANSMIT_STAT
{
    DWORD        dwSize;
    DWORD        dwPackets;
    DWORD        dwBytes;
    DWORD        dwErrors;
    DWORD        dwDroped;
    DWORD        dwOverruns;
    DWORD        dwCarrier;
    DWORD        dwCollisions;
    DWORD        dwTxQueue;
	DWORD        dwSpeed;           // 上行流量速度
}NET_NETAPP_TRANSMIT_STAT;

//CLIENT_QueryNetStat接口,查询类型为NET_APP_DATA_STAT时的输出参数(获取协议栈统计数据)
typedef struct tagNET_OUT_NETAPP_NET_DATA_STAT
{                    
    DWORD                        dwSize;
    NET_NETAPP_RECEIVE_STAT      stuReceiveStat;        // 接收相关统计数据,意义与ifconfig同
    NET_NETAPP_TRANSMIT_STAT     stuTransmitStat;       // 传输相关统计数据,意义与ifconfig同
    int                          nSpeed;                // 网卡速度,单位Mbps
}NET_OUT_NETAPP_NET_DATA_STAT;

//CLIENT_QueryNetStat接口,查询类型为NET_APP_LINK_STAT 时的输入参数(获取物理链路状态)
typedef struct tagNET_IN_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    char        szEthName[DH_MAX_ETH_NAME];             //网卡名
}NET_IN_NETAPP_LINK_STATUS;

//CLIENT_QueryNetStat接口,查询类型为NET_APP_LINK_STAT 时的输出参数(获取物理链路状态)
typedef struct tagNET_OUT_NETAPP_LINK_STATUS
{
    DWORD       dwSize;
    BOOL        bWorking;               // 是否正在工作 
    BOOL        bIPConflict;            // IP是否冲突
}NET_OUT_NETAPP_LINK_STATUS;

// 输入信号类型
#define DH_VIDEO_SIGNAL_CVBS        0x0001
#define DH_VIDEO_SIGNAL_SDI         0x0002
#define DH_VIDEO_SIGNAL_VGA         0x0004 
#define DH_VIDEO_SIGNAL_DVI         0x0008
#define DH_VIDEO_SIGNAL_HDMI        0x0010 
#define DH_VIDEO_SIGNAL_YPBPR       0x0020 
#define DH_VIDEO_SIGNAL_SFP         0x0040 
#define DH_VIDEO_SIGNAL_HDCVI       0x0080 
#define DH_VIDEO_SIGNAL_DUAL_LINK   0x0100 

// 视频输入能力集
typedef struct tagDH_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    DWORD            dwSignalType;                  // 输入信号类型
    BOOL             bAutoFocusPeak;                // 是否支持聚焦峰值计算
    BOOL             bElectricFocus;                // 是否支持电动调焦
    BOOL             bSyncFocus;                    // 是否支持同步对焦
    BOOL             bSetColor;                     // 是否支持视频颜色设置
    BOOL             bGain;                         // 是否支持增益控制
    BOOL             bPhase;                        // 是否支持相位控制
	int				 nSubChannel;					// 视频子通道(采集器)个数
	DH_RECT			 stuRect[MAX_SUBCHANNEL_NUM];	// 每个sensor画面在整个拼接画面中的位置
} DH_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps接口输入参数
typedef struct tagDH_IN_GET_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    int              nChannel;                      // 视频输入通道号
} DH_IN_GET_VIDEO_IN_CAPS;

// CLIENT_GetVideoInCaps接口输出参数
typedef struct tagDH_OUT_GET_VIDEO_IN_CAPS 
{
    DWORD            dwSize;
    DH_VIDEO_IN_CAPS stuCaps;                       // 能力
} DH_OUT_GET_VIDEO_IN_CAPS;

// 视频输出模式
typedef struct tagDH_VIDEO_OUT_MODE 
{
    DWORD            dwSize;
    int              nWidth;                        // 水平分辨率
    int              nHeight;                       // 垂直分辨率
    int              nBPP;                          // 颜色深度
    int              nFormat;                       // 输出信号模式, 0-Auto, 1-TV, 2-VGA, 3-DVI
    int              nRefreshRate;                  // 刷新频率
    int              nPhysicalPort;                 // 物理输出口, VGA, TV, DVI各自独立编号, 各自从0开始
    int              nScanFormat;                   // 扫描模式, 0-逐行, 1-隔行
} DH_VIDEO_OUT_MODE;

// CLIENT_EnumVideoOutModes接口输入参数
typedef struct tagDH_IN_ENUM_VIDEO_OUT_MODES 
{
    DWORD            dwSize;
    int              nChannel;
} DH_IN_ENUM_VIDEO_OUT_MODES;

// CLIENT_EnumVideoOutModes接口输出参数
typedef struct tagDH_OUT_ENUM_VIDEO_OUT_MODES 
{
    DWORD               dwSize;
    DH_VIDEO_OUT_MODE*  pstuModes;                  // 模式数组, 用户分配内存,大小为sizeof(DH_VIDEO_OUT_MODE)*nMaxModeCount
    int                 nMaxModeCount;              // 模式数组大小, 用户填写
    int                 nRetModeCount;              // 返回的模式数量
} DH_OUT_ENUM_VIDEO_OUT_MODES;

// 电视墙屏幕能力类型
typedef enum tagDH_OUTPUT_ATTRIBUTE_TYPE
{
    DH_OUTPUT_ATTRIBUTE_VIDEO, 
    DH_OUTPUT_ATTRIBUTE_YPBPR, 
    DH_OUTPUT_ATTRIBUTE_VGA, 
    DH_OUTPUT_ATTRIBUTE_DVI, 
    DH_OUTPUT_ATTRIBUTE_MENU, 
} DH_OUTPUT_ATTRIBUTE_TYPE;

// 电视墙显示单元屏幕调节能力集(DH_OUTPUT_ATTRIBUTE_CAPS) Video能力
#define    DH_ATTR_VIDEO_BRIGHTNESS     0X00000001
#define    DH_ATTR_VIDEO_CONTRAST       0X00000002
#define    DH_ATTR_VIDEO_SATURATION     0X00000004
#define    DH_ATTR_VIDEO_SHAPENESS      0X00000008
#define    DH_ATTR_VIDEO_DENOISE        0X00000010

// 电视墙显示单元屏幕调节能力集(DH_OUTPUT_ATTRIBUTE_CAPS) YPbPr能力
#define    DH_ATTR_YPBPR_BRIGHTNESS     0X00000001
#define    DH_ATTR_YPBPR_CONTRAST       0X00000002
#define    DH_ATTR_YPBPR_SATURATION     0X00000004
#define    DH_ATTR_YPBPR_SHAPENESS      0X00000008
#define    DH_ATTR_YPBPR_DENOISE        0X00000010

// 电视墙显示单元屏幕调节能力集(DH_OUTPUT_ATTRIBUTE_CAPS) VGA能力
#define    DH_ATTR_VGA_BRIGHTNESS       0X00000001
#define    DH_ATTR_VGA_CONTRAST         0X00000002
#define    DH_ATTR_VGA_HORPOSITION      0X00000004
#define    DH_ATTR_VGA_VERPOSITION      0X00000008
#define    DH_ATTR_VGA_CLOCK            0X00000010

// 电视墙显示单元屏幕调节能力集(DH_OUTPUT_ATTRIBUTE_CAPS) DVI能力
#define    DH_ATTR_DVI_BRIGHTNESS       0X00000001
#define    DH_ATTR_DVI_CONTRAST         0X00000002
#define    DH_ATTR_DVI_HORPOSITION      0X00000004
#define    DH_ATTR_DVI_VERPOSITION      0X00000008
#define    DH_ATTR_DVI_CLOCK            0X00000010

// 电视墙显示单元屏幕调节能力集(DH_OUTPUT_ATTRIBUTE_CAPS) Menu能力
#define    DH_ATTR_MENU_MENU            0X00000001
#define    DH_ATTR_MENU_UP              0X00000002
#define    DH_ATTR_MENU_DOWN            0X00000004
#define    DH_ATTR_MENU_LEFT            0X00000008
#define    DH_ATTR_MENU_RIGHT           0X00000010
#define    DH_ATTR_MENU_FACTORYMENU     0X00000020

// 电视墙显示单元屏幕调节能力集
typedef struct tagDH_OUTPUT_ATTRIBUTE_CAPS
{
    DWORD           dwSize;
    BOOL            abVideo;                // Video能力是否有效
    DWORD           dwVideo;                // Video能力, 按位表示, 具体见DH_ATTR_VIDEO_BRIGHTNESS等
    BOOL            abYPbPr;                // YPbPr能力是否有效
    DWORD           dwYPbPr;                // YPbPr能力, 按位表示, 具体见DH_ATTR_VGA_BRIGHTNESS等
    BOOL            abVGA;                  // VGA能力是否有效
    DWORD           dwVGA;                  // VGA能力, 按位表示, 具体见DH_ATTR_VGA_BRIGHTNESS等
    BOOL            abDVI;                  // DVI能力是否有效
    DWORD           dwDVI;                  // DVI能力, 按位表示, 具体见DH_ATTR_DVI_BRIGHTNESS
    BOOL            abMenu;                 // Menu能力是否有效
    DWORD           dwMemu;                 // Menu能力, 按位表示, 具体见DH_ATTR_MENU_MENU等
} DH_OUTPUT_ATTRIBUTE_CAPS;

// CLIENT_MonitorWallGetAttributeCaps 接口输入参数
typedef struct tagDH_IN_MONITORWALL_GET_ARRT_CAPS
{
    DWORD               dwSize;
    int                 nMonitorWallID;             // 电视墙序号
    const char*         pszCompositeID;             // 拼接屏ID
    int                 nOutputID;                  // 显示单元序号
} DH_IN_MONITORWALL_GET_ARRT_CAPS;

// CLIENT_MonitorWallGetAttributeCaps 接口输出参数
typedef struct tagDH_OUT_MONITORWALL_GET_ARRT_CAPS
{
    DWORD                       dwSize;
    DH_OUTPUT_ATTRIBUTE_CAPS    stuCaps;            // 属性能力集
} DH_OUT_MONITORWALL_GET_ARRT_CAPS;


// CLIENT_MonitorWallAutoAdjust 接口输入参数
typedef struct tagDH_IN_MONITORWALL_AUTO_ADJUST
{
    DWORD           dwSize;
    int             nMonitorWallID;                 // 电视墙序号
    const char*     pszCompositeID;                 // 拼接屏ID
    int*            pOutputs;                       // 显示单元序号数组指针, 数组元素是显示单元ID, 用户申请内存,大小为sizeof(int)*nOutputCount
    int             nOutputCount;                   // 显示单元数量, pOutputs元素数量
} DH_IN_MONITORWALL_AUTO_ADJUST;

// CLIENT_MonitorWallAutoAdjust 接口输出参数
typedef struct tagDH_OUT_MONITORWALL_AUTO_ADJUST
{
    DWORD           dwSize;
} DH_OUT_MONITORWALL_AUTO_ADJUST;

// 显示单元属性键值对
typedef struct tagDH_ATTR_PAIR
{
    DWORD       dwKey;                      // 属性键
                                            // 类型为DH_OUTPUT_ATTRIBUTE_VIDEO时, 使用宏DH_ATTR_VIDEO_BRIGHTNESS等
                                            // 类型为DH_OUTPUT_ATTRIBUTE_YPBPR时, 使用宏DH_ATTR_YPBPR_BRIGHTNESS等
                                            // 其他的类型以此类推
    int         nValue;                     // 属性值, 0-减少 1-增加, 2-不变
} DH_ATTR_PAIR;

// CLIENT_MonitorWallSetAttribute 接口输入参数
typedef struct tagDH_IN_MONITORWALL_SET_ATTR
{
    DWORD                    dwSize;
    int                      nMonitorWallID;                    // 电视墙序号
    const char*              pszCompositeID;                    // 拼接屏ID
    int                      nOutputID;                         // 显示单元序号
    DH_OUTPUT_ATTRIBUTE_TYPE emAttrType;                        // 属性类型, 类型不同时, 对应的属性(stuAttrs)也不同
    DH_ATTR_PAIR             stuAttrs[DH_MAX_ATTR_NUM];         // 属性值
} DH_IN_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetAttribute 接口输出参数
typedef struct tagDH_OUT_MONITORWALL_SET_ATTR
{
    DWORD            dwSize;
} DH_OUT_MONITORWALL_SET_ATTR;

// CLIENT_MonitorWallSetBackLight 接口输入参数
typedef struct tagDH_IN_MONITORWALL_SET_BACK_LIGHT
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // 电视墙序号
    const char*         pszCompositeID;                     // 拼接屏ID
    int                 nOutputID;                          // 显示单元序号
    int                 nMode;                              // 背光模式, 0-循环设置背光模式,1-非循环模式
} DH_IN_MONITORWALL_SET_BACK_LIGHT;

// CLIENT_MonitorWallSetBackLight 接口输出参数
typedef struct tagDH_OUT_MONITORWALL_SET_BACK_LIGHT
{
    DWORD               dwSize;
} DH_OUT_MONITORWALL_SET_BACK_LIGHT;


// CLIENT_MonitorWallGetPowerSchedule 接口输入参数
typedef struct tagNET_IN_WM_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // 电视墙序号
    const char*         pszCompositeID;                     // 拼接屏ID
} NET_IN_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetPowerSchedule 接口输出参数
typedef struct tagNET_OUT_MW_GET_POWER_SCHEDULE
{
    DWORD               dwSize;
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // 开机时间表, 第一维各元素表示周日~周六和节假日
} NET_OUT_MW_GET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule 接口输入参数
typedef struct tagNET_IN_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // 电视墙序号
    const char*         pszCompositeID;                     // 拼接屏ID, NULL表示所有屏
    DH_TSECT            stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];    // 开机时间表, 第一维各元素表示周日~周六和节假日
} NET_IN_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallSetPowerSchedule 接口输出参数
typedef struct tagNET_OUT_MW_SET_POWER_SCHEDULE
{
    DWORD               dwSize;
} NET_OUT_MW_SET_POWER_SCHEDULE;

// CLIENT_MonitorWallGetScrnCtrlParam 接口输入参数
typedef struct tagNET_IN_MW_GET_SCRN_CTRL_PARAM
{
    DWORD               dwSize;
    int                 nMonitorWallID;                     // 电视墙序号
    const char*         pszCompositeID;                     // 拼接屏ID
} NET_IN_MW_GET_SCRN_CTRL_PARAM;

#define DH_MAX_SCREEN_PORT_NUM        16                    // 最大屏幕输入端口数
#define DH_MAX_COMPSITE_SCREEN_NUM    256                   // 最大拼接屏数量

// 屏幕输入端口信息
typedef struct tagNET_SCREEN_PORT_INFO
{
    DWORD               dwSize;
    char                szType[DH_COMMON_STRING_16];        // 端口类型, "DVI", "VGA", "HDMI"等, 允许存在相同类型的多个端口
    char                szAddress[DH_COMMON_STRING_16];     // 端口地址
    char                szDeviceID[DH_DEV_ID_LEN_EX];       // 绑定的视频输出设备号
    int                 nOutputChannel;                     // 视频输出通道号
} NET_SCREEN_PORT_INFO;


typedef struct tagNET_SCREEN_PORT_GROUP 
{
    DWORD                dwSize;
    int                  nPortNum;                          // 端口数
    NET_SCREEN_PORT_INFO stuPorts[DH_MAX_SCREEN_PORT_NUM];  // 端口信息
} NET_SCREEN_PORT_GROUP;

// 电视墙屏幕控制参数
typedef struct tagNET_WM_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nCommPort;                                  // 串口号
    DH_COMM_PROP            stuCommProp;                                // 串口属性
    char                    szProtocol[DH_COMMON_STRING_32];            // 串口协议
    int                     nResolutionNum;                             // 分辨率数量
    CAPTURE_SIZE            emResolutions[DH_MAX_CAPTURE_SIZE_NUM];     // 视频分辨率列表
    int                     nScreenCodeNum;                             // 屏幕编码数
    char                    szScreenCode[DH_MAX_COMPSITE_SCREEN_NUM][DH_COMMON_STRING_16];    // 屏幕编码, 串口命令寻址用, 该编码由用户配置, 可以相同
    int                     nScreenPortsNum;                            // 屏幕输入端口信息数量
    NET_SCREEN_PORT_GROUP   stuScreenPorts[DH_MAX_COMPSITE_SCREEN_NUM]; // 屏幕输入端口信息    
} NET_WM_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetScrnCtrlParam 接口输入参数
typedef struct tagNET_OUT_MW_GET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // 屏幕控制参数
} NET_OUT_MW_GET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam 接口输入参数
typedef struct tagNET_IN_MW_SET_SCRN_CTRL_PARAM
{
    DWORD                   dwSize;
    int                     nMonitorWallID;             // 电视墙序号
    const char*             pszCompositeID;             // 拼接屏ID
    NET_WM_SCRN_CTRL_PARAM  stuScrnCtrlParam;           // 屏幕控制参数
} NET_IN_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallSetScrnCtrlParam 接口输出参数
typedef struct tagNET_OUT_MW_SET_SCRN_CTRL_PARAM
{
    DWORD           dwSize;
} NET_OUT_MW_SET_SCRN_CTRL_PARAM;

// CLIENT_MonitorWallGetBackgroudColor 接口输入参数
typedef struct tagNET_IN_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    int             nMonitorWallID;             // 电视墙序号
} NET_IN_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallGetBackgroudColor 接口输出参数
typedef struct tagNET_OUT_MW_GET_BACKGROUDND_COLOR
{
    DWORD           dwSize;
    DH_COLOR_RGBA   stuScreenColor;             // 屏幕背景色
    DH_COLOR_RGBA   stuWindowColor;             // 窗口背景色
} NET_OUT_MW_GET_BACKGROUDND_COLOR;

// CLIENT_MonitorWallSetBackgroudColor 接口输入参数
typedef struct tagNET_IN_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // 电视墙序号
    DH_COLOR_RGBA   stuScreenColor;             // 屏幕背景色
    DH_COLOR_RGBA   stuWindowColor;             // 窗口背景色
} NET_IN_MW_SET_BACKGROUD_COLOR;

// CLIENT_MonitorWallSetBackgroudColor 接口输出参数
typedef struct tagNET_OUT_MW_SET_BACKGROUD_COLOR 
{
    DWORD           dwSize;
} NET_OUT_MW_SET_BACKGROUD_COLOR;

// 信号源类型
typedef enum tagEM_SIGNAL_TYPE
{
	EM_SIGNAL_TYPE_UNKNOWN,								// 未知类型
	EM_SIGNAL_TYPE_VIDEO,								// "Video"
	EM_SIGNAL_TYPE_VGA,									// "VGA"
	EM_SIGNAL_TYPE_YPBPR,								// "YPbPr"
	EM_SIGNAL_TYPE_HDMI,								// "HDMI"
	EM_SIGNAL_TYPE_DVI,									// "DVI"
	EM_SIGNAL_TYPE_SDI,									// "SDI"
	EM_SIGNAL_TYPE_CVBS,								// "CVBS"
}EM_SIGNAL_TYPE;

// CLIENT_MonitorWallSwitchDisplaySignal 接口输入参数
typedef struct tagNET_IN_MW_SWITCH_DISPLAY_SIGNAL
{	
	DWORD				dwSize;							// 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_INT_SWITCH_DISPLAYSIGNAL)
    int                 nMonitorWallID;                 // 电视墙序号
	char*			    pszCompositeID;					// 显示单元组ID
	int					nOutputID;						// 显示单元索引号, -1表示区块中的所有显示单元
	EM_SIGNAL_TYPE		emSignalType;					// 信号源类型 
	int					nIndex;							// 输入信号端子序号, 从0开始, 有多个相同信号源端子时, 用于指明哪个端子
}NET_IN_MW_SWITCH_DISPLAY_SIGNAL;

// CLIENT_MonitorWallSwitchDisplaySignal 接口输出参数
typedef struct tagNET_OUT_MW_SWITCH_DISPLAY_SIGNAL			
{
	DWORD				dwSize;							// 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_SWICH_DISPLAYSIGNAL)
}NET_OUT_MW_SWITCH_DISPLAY_SIGNAL;

//////////////////////////////////////////////////////////////////////////
// CLIENT_OperateMonitorWall接口参数
//////////////////////////////////////////////////////////////////////////

// 电视墙操作类型
typedef enum tagNET_MONITORWALL_OPERATE_TYPE
{
    NET_MONITORWALL_OPERATE_ADD,            // 添加电视墙, 对应 NET_IN_MONITORWALL_ADD 和 NET_OUT_MONITORWALL_ADD
    NET_MONITORWALL_OPERATE_CTRL_TOUR,      // 预案轮巡控制, 对应 NET_IN_CTRL_COLLECTIONTOUR 和 NET_OUT_CTRL_COLLECTIONTOUR
    NET_MONITORWALL_OPERATE_GET_STATUS,     // 获取矩阵当前状态, 对应 NET_IN_MONITORWALL_GET_STATUS 和 NET_OUT_MONITORWALL_GET_STATUS
    NET_MONITORWALL_OPERATE_SET_COLL_SCHD,  // 设置预案时间表, 对应 NET_IN_MONITORWALL_SET_COLL_SCHD 和 NET_OUT_MONITORWALL_SET_COLL_SCHD
    NET_MONITORWALL_OPERATE_GET_COLL_SCHD,  // 获取预案时间表, 对应 NET_IN_MONITORWALL_GET_COLL_SCHD 和 NET_OUT_MONITORWALL_GET_COLL_SCHD
    NET_MONITORWALL_OPERATE_REMOVE,         // 删除电视墙, 对应 NET_IN_MONITORWALL_REMOVE 和 NET_OUT_MONITORWALL_REMOVE
    NET_MONITORWALL_OPERATE_SET_ENABLE,     // 设置使能, 对应 NET_IN_MONITORWALL_SET_ENABLE 和 NET_OUT_MONITORWALL_SET_ENABLE
    NET_MONITORWALL_OPERATE_GET_ENABLE,     // 获取使能, 对应 NET_IN_MONITORWALL_GET_ENABLE 和 NET_OUT_MONITORWALL_GET_ENABLE
    NET_MONITORWALL_OPERATE_NAME_EXIST,     // 电视墙是否存在, 对应 NET_IN_MONITORWALL_NAME_EXIST 和 NET_OUT_MONITORWALL_NAME_EXIST
    NET_MONITORWALL_OPERATE_RENAME,         // 修改电视墙名称, 对应 NET_IN_MONITORWALL_RENAME  和 NET_OUT_MONITORWALL_RENAME 
    NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL,  // 更新已上墙的视频源URL, 对应 NET_IN_MONITORWALL_UPDATE_SOURCE_URL 和 NET_OUT_MONITORWALL_UPDATE_SOURCE_URL

    NET_MONITORWALL_OPERATE_GET_LOCK_STATUS,// 获取电视墙锁定状态, 对应 NET_IN_MONITORWALL_GET_LOCK_STATUS  和 NET_OUT_MONITORWALL_GET_LOCK_STATUS 
    NET_MONITORWALL_OPERATE_LOCK,			// 锁定电视墙(自由开窗的窗口不能再移动，防止用户误操作), 对应 NET_IN_MONITORWALL_LOCK  和 NET_OUT_MONITORWALL_LOCK 
} NET_MONITORWALL_OPERATE_TYPE;

// 添加电视墙输入参数
typedef struct tagNET_IN_MONITORWALL_ADD
{
    DWORD dwSize;
    DH_MONITORWALL stuMonitorWall; // 电视墙信息
} NET_IN_MONITORWALL_ADD;

// 添加电视墙输出参数
typedef struct tagNET_OUT_MONITORWALL_ADD
{
    DWORD dwSize;
    unsigned int nMonitorWallID; // 电视墙ID
} NET_OUT_MONITORWALL_ADD;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_IN_CTRL_COLLECTIONTOUR 
{
    DWORD              dwSize;
    int                nChannel;                       // 通道号
    int                nAction;                        // 轮巡动作, 0:结束, 1:开始
} NET_IN_CTRL_COLLECTIONTOUR;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_CTRL_TOUR
typedef struct tagNET_OUT_CTRL_COLLECTIONTOUR 
{
    DWORD                   dwSize;
} NET_OUT_CTRL_COLLECTIONTOUR;

// 矩阵运行状态
typedef enum tagNET_MATRIX_STATUS
{
    MATRIX_STATUS_UNKNOWN,              // 未知
    MATRIX_STATUS_TOUR,                 // 预案轮巡
    MATRIX_STATUS_NORMAL,               // 普通预览
} NET_MATRIX_STATUS;

#define DH_MAX_COLLECTION_NUM   64      // 最大预案数
// 矩阵状态信息
typedef struct tagNET_MONITORWALL_STATUS_INFO
{
    DWORD       dwSize;
    int         nInterval;                      // 轮巡时间间隔
    int         nCollectionNum;                 // 预案轮巡数
    char        szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];         // 预案轮巡组内容
    char        szName[DH_DEVICE_NAME_LEN];     // 当前显示的预案名称
} NET_MONITORWALL_STATUS_INFO;

// // CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_IN_MONITORWALL_GET_STATUS 
{
    DWORD              dwSize;
    int                nChannel;                        // 通道号
} NET_IN_MONITORWALL_GET_STATUS;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_GET_STATUS
typedef struct tagNET_OUT_MONITORWALL_GET_STATUS
{
    DWORD                           dwSize;
    NET_MATRIX_STATUS               emMatrixStatus;     // 运行状态
    NET_MONITORWALL_STATUS_INFO     stuStatusInfo;      // 状态信息
} NET_OUT_MONITORWALL_GET_STATUS;

// 电视墙预案时间表
typedef struct tagMONITORWALL_COLLECTION_SCHEDULE
{
    DWORD               dwSize;
    char                szName[DH_DEVICE_NAME_LEN];     // 预案名称
    DH_TSECT            stuSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];   // 时间表, 第一维各元素表示周日~周六和节假日
} MONITORWALL_COLLECTION_SCHEDULE;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // 预案数
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // 预案时间表
    int                 nMonitorWallID;                 // 电视墙ID
} NET_IN_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_SET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_SET_COLL_SCHD 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_COLL_SCHD;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_IN_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    BOOL                bAllCollections;                // TRUE-查询所有预案, 不需要指定预案名称. FALSE-查询名称所对应的预案
    int                 nCollectionNum;                 // 预案数, bAllCollections为FALSE时有效
    char                szCollections[DH_MAX_COLLECTION_NUM][DH_DEVICE_NAME_LEN];   // 预案名称
    int                 nMonitorWallID;                 // 电视墙ID
} NET_IN_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_GET_COLL_SCHD
typedef struct tagNET_OUT_MONITORWALL_GET_COLL_SCHD 
{
    DWORD               dwSize;
    int                 nCollectionNum;                 // 预案数
    MONITORWALL_COLLECTION_SCHEDULE stuCollShedule[DH_MAX_COLLECTION_NUM];  // 预案时间表
} NET_OUT_MONITORWALL_GET_COLL_SCHD;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_IN_MONITORWALL_REMOVE 
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // 要删除的电视墙数量
    char                szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128];  // 电视墙名称
} NET_IN_MONITORWALL_REMOVE;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_REMOVE
typedef struct tagNET_OUT_MONITORWALL_REMOVE 
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_REMOVE;

// 电视墙使能信息
typedef struct tagNET_MONITORWALL_ENABLE_INFO
{
    DWORD               dwSize;
    BOOL                bEanble;                        // 使能
    char                szName[DH_COMMON_STRING_128];   // 电视墙名称
} NET_MONITORWALL_ENABLE_INFO;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_IN_MONITORWALL_SET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // 要设置的电视墙数量
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM];  // 电视墙使能
} NET_IN_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_SET_ENABLE
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_SET_ENABLE;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_GET_ENABLE
typedef struct tagNET_IN_MONITORWALL_GET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // 要查询的电视墙数量, -1表示查询所有电视墙
    char                szNames[DH_MAX_MONITORWALL_NUM][DH_COMMON_STRING_128];  // 电视墙名称, nMonitorWallNum>0时有效
} NET_IN_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_SET_ENABLE
typedef struct tagNET_OUT_MONITORWALL_GET_ENABLE
{
    DWORD               dwSize;
    int                 nMonitorWallNum;                // 电视墙数量
    NET_MONITORWALL_ENABLE_INFO stuEnable[DH_MAX_MONITORWALL_NUM];  // 电视墙使能
} NET_OUT_MONITORWALL_GET_ENABLE;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_IN_MONITORWALL_NAME_EXIST 
{
    DWORD               dwSize;
    const char*         pszName;                        // 电视墙名称
} NET_IN_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_NAME_EXIST
typedef struct tagNET_OUT_MONITORWALL_NAME_EXIST 
{
    DWORD               dwSize;
    BOOL                bExist;                        // 电视墙是否已存在
} NET_OUT_MONITORWALL_NAME_EXIST;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_RENAME修改电视墙名称
typedef struct tagNET_IN_MONITORWALL_RENAME
{
	DWORD               dwSize;
	unsigned int		unMonitorWallID;							// 电视墙ID
	char				szNewName[MAX_MONITORWALL_NAME_LEN];		// 新的电视墙名称
} NET_IN_MONITORWALL_RENAME;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_RENAME修改电视墙名称
typedef struct tagNET_OUT_MONITORWALL_RENAME
{
	DWORD               dwSize;
} NET_OUT_MONITORWALL_RENAME;


// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_GET_LOCK_STATUS获取电视墙锁定状态
typedef struct tagNET_IN_MONITORWALL_GET_LOCK_STATUS
{
    DWORD               dwSize;
    int        			nChannel;	// 通道
} NET_IN_MONITORWALL_GET_LOCK_STATUS;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_GET_LOCK_STATUS获取电视墙锁定状态
typedef struct tagNET_OUT_MONITORWALL_GET_LOCK_STATUS
{
    DWORD               dwSize;
    BOOL                bLock;      // 是否锁定,true:锁定;false：解除锁定
} NET_OUT_MONITORWALL_GET_LOCK_STATUS;


// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_LOCK锁定电视墙
typedef struct tagNET_IN_MONITORWALL_LOCK
{
    DWORD               dwSize;
    int        		    nChannel;		// 通道
    BOOL                bLock;      	// 是否锁定,true:锁定;false：解除锁定
	BYTE				byReserved[4];	// 保留字节
} NET_IN_MONITORWALL_LOCK;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_LOCK锁定电视墙
typedef struct tagNET_OUT_MONITORWALL_LOCK
{
    DWORD               dwSize;
} NET_OUT_MONITORWALL_LOCK;


// 需要更新的URL信息
typedef struct tagNET_UPDATE_URL_INFO
{
    char        szOldURL[512];              // 已上墙的视频源URL
    char        szNewURL[512];              // 需更新的视频源URL
    BYTE        bReserved[1024];            // 保留字节
} NET_UPDATE_URL_INFO;

// CLIENT_OperateMonitorWall接口输入参数=>NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL 更新已上墙的视频源URL
typedef struct tagNET_IN_MONITORWALL_UPDATE_SOURCE_URL
{
    DWORD               dwSize;             // 结构体大小
    UINT                nUpdateURLNum;      // 需要更新的URL信息个数, 最大支持256个
    NET_UPDATE_URL_INFO *pstuUpdateURL;     // 需要更新的URL信息, 资源由用户申请和释放，申请大小nUpdateURLNum*sizeof(NET_UPDATE_URL_INFO)
} NET_IN_MONITORWALL_UPDATE_SOURCE_URL;

// CLIENT_OperateMonitorWall接口输出参数=>NET_MONITORWALL_OPERATE_UPDATE_SOURCE_URL 更新已上墙的视频源URL
typedef struct tagNET_OUT_MONITORWALL_UPDATE_SOURCE_URL
{
    DWORD               dwSize;             // 结构体大小
} NET_OUT_MONITORWALL_UPDATE_SOURCE_URL;

/************************************************************************/
/*                              U盘抓包                                    */
/************************************************************************/

// CLIENT_StartSniffer 接口输入参数
typedef struct tagDH_IN_START_SNIFFER 
{
    DWORD           dwSize;
    const char*     pszNetInterface;            // 网卡名称
    const char*     pszPath;                    // 抓包存储文件名, 空表示保存到默认路径
    int             nSaveType;                  // 文件类型, 0-Wireshark/Tcpdump
    const char*     pszFilter;                  // 过滤条件, 如"host 172.9.88.200 and port 8080 and tcp"
} DH_IN_START_SNIFFER;

// CLIENT_StartSniffer 接口输出参数
typedef struct tagDH_OUT_START_SNIFFER 
{
    DWORD           dwSize;
} DH_OUT_START_SNIFFER;

// 抓包信息
typedef struct tagDH_SNIFFER_INFO
{
    DWORD           dwSize;
    DWORD           nSnifferID;                 // 抓包ID
} DH_SNIFFER_INFO;

// CLIENT_GetSnifferInfo 接口输入参数
typedef struct tagDH_IN_GET_SNIFFER_INFO
{
    DWORD           dwSize;
    const char*     pszNetInterface;
} DH_IN_GET_SNIFFER_INFO;

// CLIENT_GetSnifferInfo 接口输入参数
typedef struct tagDH_OUT_GET_SNIFFER_INFO
{
    DWORD               dwSize;
    DH_SNIFFER_INFO*    pstuSniffers;           // 抓包信息数组, 用户分配内存
    int                 nMaxSnifferCount;       // 抓包信息数组大小, 用户填写
    int                 nRetSnifferCount;       // 返回的抓包信息数量
} DH_OUT_GET_SNIFFER_INFO;

/************************************************************************/
/*                              文件管理                                */
/************************************************************************/

// 格式化分区信息
typedef struct tagDH_FORMAT_PATITION 
{
    DWORD               dwSize;
    const char*         pszStorageName;         // 存储设备名称
    const char*         pszPatitionName;        // 分区名
    const char*         pszFileSystem;          // 文件系统格式
} DH_FORMAT_PATITION;

// CLIENT_CreateRemoteFile 接口输入参数
typedef struct tagDH_IN_CREATE_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszPath;                // 文件名
    BOOL                bDirectory;             // 是否文件夹
} DH_IN_CREATE_REMOTE_FILE;

// CLIENT_CreateRemoteFile 接口输出参数
typedef struct tagDH_OUT_CREATE_REMOTE_FILE 
{
    DWORD               dwSize;
} DH_OUT_CREATE_REMOTE_FILE;

// CLIENT_RemoveRemoteFiles 接口输入参数
typedef struct tagDH_IN_REMOVE_REMOTE_FILES
{
    DWORD               dwSize;
    const char**        pszPath;                // 文件路径数组指针
    int                 nFileCount;             // 文件路径数量
} DH_IN_REMOVE_REMOTE_FILES;

// CLIENT_RemoveRemoteFiles 接口输出参数
typedef struct tagDH_OUT_REMOVE_REMOTE_FILES 
{
    DWORD               dwSize;
} DH_OUT_REMOVE_REMOTE_FILES;

// CLIENT_RenameRemoteFile 接口输入参数
typedef struct tagDH_IN_RENAME_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszOldPath;             // 旧文件名
    const char*         pszNewPath;             // 新文件名
} DH_IN_RENAME_REMOTE_FILE;

// CLIENT_RenameRemoteFile 接口输出参数
typedef struct tagDH_OUT_RENAME_REMOTE_FILE 
{
    DWORD               dwSize;
} DH_OUT_RENAME_REMOTE_FILE;

// 文件/目录信息
typedef struct tagDH_REMOTE_FILE_INFO 
{
    DWORD               dwSize;
    BOOL                bDirectory;                     // 是否文件夹
    char                szPath[MAX_PATH];               // 路径
    NET_TIME            stuCreateTime;                  // 创建时间
    NET_TIME            stuModifyTime;                  // 修改时间
    INT64               nFileSize;                      // 文件大小
    char                szFileType[DH_FILE_TYPE_LEN];   // 文件类型
} DH_REMOTE_FILE_INFO;

// 获取文件的条件
typedef enum tagDH_REMOTE_FILE_COND
{
    DH_REMOTE_FILE_COND_NONE,                           // 无条件
    DH_REMOTE_FILE_COND_VOICE,                          // 语音联动的文件,*无法*按路径获取,*只能*获取获取文件名称
} DH_REMOTE_FILE_COND;

// CLIENT_ListRemoteFile 接口输入参数
typedef struct tagDH_IN_LIST_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszPath;                        // 路径
    BOOL                bFileNameOnly;                  // 只获取文件名称, 不返回文件夹信息, 文件信息中只有文件名有效
    DH_REMOTE_FILE_COND emCondition;                    // 指定获取文件的条件
} DH_IN_LIST_REMOTE_FILE;

// CLIENT_ListRemoteFile 接口输出参数
typedef struct tagDH_OUT_LIST_REMOTE_FILE 
{
    DWORD                   dwSize;
    DH_REMOTE_FILE_INFO*    pstuFiles;                  // 文件信息数组, 用户分配内存,大小为sizeof(DH_REMOTE_FILE_INFO)*nMaxFileCount
    int                     nMaxFileCount;              // 文件信息数组大小, 用户填写
    int                     nRetFileCount;              // 返回的文件数量
} DH_OUT_LIST_REMOTE_FILE;

// 设置文件属性―属性名称
typedef enum tagNET_SET_FILEATTR_ACTION
{
    EM_SET_FILEATTR_ACTION_UNKNOWN = 0,                 // 未知
    EM_SET_FILEATTR_ACTION_MARK,                        // 文件加锁
} NET_SET_FILEATTR_ACTION;

// CLIENT_SetFileAttribute 接口输入参数
typedef struct tagDH_IN_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
    unsigned int            nDriveNo;                       // 磁盘号
    unsigned int            nPartition;                     // 分区号
    unsigned int            nCluster;                       // 簇号
    NET_SET_FILEATTR_ACTION emAction;                       // 每种属性对应一种key,设置值由value决定
                                                            // 设置key:Mark 文件加锁,对应value,延长加锁时间(单位:天)
    char                    szValue[DH_COMMON_STRING_64];   // 属性值
} DH_IN_SET_FILEATTRIBUTE;

// CLIENT_SetFileAttribute 接口输出参数
typedef struct tagDH_OUT_SET_FILEATTRIBUTE
{
    DWORD                   dwSize;
} DH_OUT_SET_FILEATTRIBUTE;

// 手动弹出存储设备
typedef struct tagDH_EJECT_STORAGE_DEVICE
{
    DWORD               dwSize;    
    const char*         pszStorageName;                 // 存储设备名称
} DH_EJECT_STORAGE_DEVICE;

// 手动装载存储设备
typedef struct tagDH_LOAD_STORAGE_DEVICE 
{
    DWORD               dwSize;
    const char*         pszStorageName;                 // 存储设备名称
} DH_LOAD_STORAGE_DEVICE;

// CLIENT_UploadRemoteFile 接口输入参数(上传文件到设备)
typedef struct tagDH_IN_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileSrc;                     // 源文件路径
    const char*         pszFileDst;                     // 目标文件路径
    const char*         pszFolderDst;                   // 目标文件夹路径：可为NULL, NULL时设备使用默认路径
    unsigned int        nPacketLen;                     // 文件分包大小(字节): 0表示不分包
} DH_IN_UPLOAD_REMOTE_FILE;

// CLIENT_UploadRemoteFile 接口输出参数(上传文件到设备)
typedef struct tagDH_OUT_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;
} DH_OUT_UPLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile 接口输入参数(文件下载)
typedef struct tagDH_IN_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
    const char*         pszFileName;                    // 需要下载的文件名
    const char*         pszFileDst;                     // 存放文件路径
} DH_IN_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadRemoteFile 接口输出参数(文件下载)
typedef struct tagDH_OUT_DOWNLOAD_REMOTE_FILE
{
    DWORD               dwSize;
	DWORD				dwMaxFileBufLen;				// 文件缓存区pstFileBuf的大小, 由用户指定
	char				*pstFileBuf;					// 文件缓存区, 由用户申请和释放
	DWORD				dwRetFileBufLen;				// 缓存区中返回的实际文件数据大小
	BYTE              	byReserved[4];            		// 字节对齐
} DH_OUT_DOWNLOAD_REMOTE_FILE;

// CLIENT_DownloadPieceFile 接口输入参数（文件下载）
typedef struct tagNET_IN_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	char				szFileName[MAX_PATH];		   // 需要下载的文件名,支持全路径
	UINT				nOffSet;					   // 下载偏移,单位字节
													   // 如果文件总长度为50KB,每次请求下载数据量为32KB,那么第一次请求时,nOffSet为0,第二次请求nOffSet为32KB
	UINT				nNeedLength;				   // 请求下载数据量,单位字节，建议为32KB,最大不超过4MB	
} NET_IN_DOWNLOAD_PIECE_FILE;

// CLIENT_DownloadPieceFile 接口输出参数（文件下载）
typedef struct tagNET_OUT_DOWNLOAD_PIECE_FILE
{
	DWORD				dwSize;
	UINT				nFileLength;	 // 文件总长度
	UINT				nPacketLength;   // 本次返回的数据长度,单位字节,建议为32KB,最大不超过4MB
	char*               szBuffer;        // 本次请求的文件数据,由用户申请内存,大小为nBufferLen
	UINT				nBufferLen;      // 本次请求的文件数据长度,单位字节
} NET_OUT_DOWNLOAD_PIECE_FILE;

/************************************************************************/
/*                              级联设备                                */
/************************************************************************/
// 级联设备搜索条件
typedef struct tagDH_IN_SEARCH_CONDITON
{
    DWORD               dwSize;
    const char*         pMachineName;                   // 设备名称或编号
    const char*         pMachineAddr;                   // 设备部署地点(如：滨江区.江南大道.伟业路口)
    const char*         pSerialNo;                      // 设备序列号
    const char*         pChannelName;                   // 视频输入通道名
} DH_MATRIX_SEARCH_CONDITON;

// CLIENT_MatrixSearch 接口输入参数(搜索级联设备)
typedef struct tagDH_IN_MATIRX_SEARCH
{
    DWORD                       dwSize;
    const char*                 pSerialNo;              // 搜索设备序列号,"Local"-本设备,"Root"-根设备,其它设备以设备的序列号表示
    DH_MATRIX_SEARCH_CONDITON   stuCondition;           // 搜索条件, 可以为单一条件或组合
} DH_IN_MATRIX_SEARCH;

// CLIENT_MatrixSearch 接口输出参数(搜索级联设备)
typedef struct tagDH_OUT_MATRIX_SEARCH
{
    DWORD               dwSize;
    DH_REMOTE_DEVICE*   pstuRemoteDevices;              // 设备列表, 用户分配内存,大小为sizeof(DH_REMOTE_DEVICE)*nMaxDeviceCount
    int                 nMaxDeviceCount;                // 设备列表最大值, 用户填写
    int                 nRetDeviceCount;                // 实际返回设备个数
} DH_OUT_MATRIX_SEARCH;

// CLIENT_GetMatrixTree 接口输入参数
typedef struct tagDH_IN_GET_MATRIX_TREE
{
    DWORD               dwSize;
    const char*         pSerialNo;                      // 搜索设备序列号,"Local"-本设备,"Root"-根设备,其它设备以设备的序列号表示
    int                 nLevel;                         // 获得几级设备信息,0-整个设备树,1-本级设备,2-本级设备+本设备级联下一级设备,
                                                        // 3-本级设备+本设备级联下一级设备+下一级设备的下一级设备
} DH_IN_GET_MATRIX_TREE;

// 级联设备信息
typedef struct tagDH_CASCADE_DEVICE_INFO
{
    DWORD               dwSize;
    int                 nLevel;                         // 当前设备所属级数
    char                szPath[MAX_PATH];               // 设备所属路径,格式：name1.name2.name3...
    DH_REMOTE_DEVICE    stuDeviceInfo;                  // 设备详细信息
} DH_CASCADE_DEVICE_INFO;

// CLIENT_GetMatrixTree 接口输出参数
typedef struct tagDH_OUT_GET_MATRIX_TREE
{
    DWORD                   dwSize;
    DH_CASCADE_DEVICE_INFO* pstuRemoteDevices;          // 级联设备信息
    int                     nMaxDeviceCount;            // 级联设备信息最大值
    int                     nRetDeviceCount;            // 返回的实际设备个数
} DH_OUT_GET_MATRIX_TREE;

// CLIENT_GetSuperiorMatrixList 接口输入参数
typedef struct tagDH_IN_GET_SUPERIOR_MATRIX_LIST
{
    DWORD                   dwSize;
} DH_IN_GET_SUPERIOR_MATRIX_LIST;

// CLIENT_GetSuperiorMatrixList 接口输出参数
typedef struct tagDH_OUT_GET_SUPERIOR_MATRIX_LIST
{
    DWORD                   dwSize;
    DH_REMOTE_DEVICE*       pstuRemoteDevices;          // 设备列表, 用户分配内存
    int                     nMaxDeviceCount;            // 设备列表最大值, 用户填写
    int                     nRetDeviceCount;            // 实际返回设备个数
} DH_OUT_GET_SUPERIOR_MATRIX_LIST;

////////////////////////////////////录像备份恢复//////////////////////////////////////

// 录像备份恢复任务信息
typedef struct tagDH_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    unsigned int        nTaskID;                        // 任务ID
    char                szDeviceID[DH_DEV_ID_LEN_EX];   // 设备ID
    int                 nChannelID;                     // 通道号
    NET_TIME            stuStartTime;                   // 开始时间
    NET_TIME            stuEndTime;                     // 结束时间
    int                 nState;                         // 当前备份状态, 0-等待, 1-进行中, 2-完成, 3-失败
} DH_REC_BAK_RST_TASK;

// CLIENT_AddRecordBackupRestoreTask接口输入参数
typedef struct tagDH_IN_ADD_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    const char*         pszDeviceID;                    // 设备ID
    int*                pnChannels;                     // 通道数组
    int                 nChannelCount;                  // 通道数组大小,由用户申请内存,大小为sizeof(int)*nChannelCount
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
} DH_IN_ADD_REC_BAK_RST_TASK;

// CLIENT_RemoveRecordBackupRestoreTask接口输入参数
typedef struct tagDH_IN_REMOVE_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
    unsigned int*       pnTaskIDs;                      // 任务ID数组,由用户申请内存，大小为sizeof(int)*nTaskCount
    int                 nTaskCount;                     // 任务数量
} DH_IN_REMOVE_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask接口输入参数
typedef struct tagDH_IN_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD               dwSize;
} DH_IN_QUERY_REC_BAK_RST_TASK;

// CLIENT_QueryRecordBackupRestoreTask接口输出参数
typedef struct tagDH_OUT_QUERY_RECORD_BACKUP_RESTORE_TASK
{
    DWORD                   dwSize;
    DH_REC_BAK_RST_TASK*    pTasks;                     // 任务数组,由用户申请内存，大小为sizeof(DH_REC_BAK_RST_TASK)*nMaxCount
    int                     nMaxCount;                  // 数组大小
    int                     nReturnCount;               // 返回的任务数量
} DH_OUT_QUERY_REC_BAK_RST_TASK;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    const char*             pszDeviceID;                // 设备ID
    int                     nChannel;                   // 通道号
} DH_LOGIC_DEVICE_ADD_CAMERA_PARAM;

typedef struct tagDH_LOGIC_DEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    char                    szDeviceID[DH_DEV_ID_LEN];  // 设备ID
    int                     nChannel;                   // 通道号
    int                     nUniqueChannel;             // 统一编号
    int                     nFailedCode;                // 失败码, 0-成功,1-Unique地址空间用完 2-已经添加
} DH_LOGIC_DEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCameras 接口输入参数
typedef struct tagDH_IN_ADD_LOGIC_DEVICE_CAMERA
{
    DWORD                   dwSize;
    DH_LOGIC_DEVICE_ADD_CAMERA_PARAM* pCameras;         // 视频源信息数组,由用户申请内存，大小为sizeof(DH_LOGIC_DEVICE_ADD_CAMERA_PARAM)*nCameraCount
    int                     nCameraCount;               // 视频源信息数量
} DH_IN_ADD_LOGIC_DEVICE_CAMERA;

// CLIENT_MatrixAddCameras 接口输出参数
typedef struct tagDH_OUT_ADD_LOGIC_DEVICE_CAMERA 
{
    DWORD                   dwSize;
    DH_LOGIC_DEVICE_ADD_CAMERA_RESULT* pResults;        // 添加视频源结果数组, 用户分配内存,大小为sizeof(DH_LOGIC_DEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
    int                     nMaxResultCount;            // 结果数组大小, 用户填写
    int                     nRetResultCount;            // 实际结果数量
} DH_OUT_ADD_LOGIC_DEVICE_CAMERA;

//视频源信息
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // 统一编号
    int                     nChannel;                   // 通道号   
} DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM;

//添加视频源结果信息
typedef struct tagDH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT
{
    DWORD                   dwSize;
    int                     nUniqueChannel;             // 统一编号
    int                     nFailedCode;                // 失败码, 0-成功,1-通道不支持设置
} DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT;

// CLIENT_MatrixAddCamerasByDevice 接口输入参数
typedef struct tagDH_IN_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;
    char                    pszDeviceID[DH_DEV_ID_LEN]; // 设备ID
    DH_REMOTE_DEVICE        stuRemoteDevice;            // 远程设备信息
    int                     nCameraCount;               // 视频源信息数量
    DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM* pCameras;       // 视频源信息数组,用户分配内存,大小为sizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_PARAM)*nCameraCount
}DH_IN_ADD_LOGIC_BYDEVICE_CAMERA;

// CLIENT_MatrixAddCamerasByDevice 接口输出参数
typedef struct tagDH_OUT_ADD_LOGIC_BYDEVICE_CAMERA
{
    DWORD                   dwSize;                         
    char                    szDeviceID[DH_DEV_ID_LEN];    // 设备ID
    int                     nMaxResultCount;              // 结果数组大小, 用户填写
    int                     nRetResultCount;              // 实际结果数量
    DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT* pResults;        // 添加视频源结果数组,用户分配内存,大小为sizeof(DH_LOGIC_BYDEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
}DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA;

// 视频源信息
typedef struct tagNET_CAMERA_INFO
{	
    int                     nUniqueChannel;             // 统一编号,  -1表示设备自动分配通道号
    unsigned int            nChannel;                   // 通道号   
    BYTE                	reserved[128];				// 保留字节
} NET_CAMERA_INFO;

// 设备组信息
typedef struct tagNET_CAMERA_GROUP_INFO
{
	char                    szDeviceID[DH_DEV_ID_LEN];	// 设备ID
    int                     nCameraCount;				// 视频源信息数量
    NET_CAMERA_INFO			*pCameras;       			// 视频源信息数组,用户分配内存,大小为sizeof(NET_CAMERA_INFO)*nCameraCount
	DH_REMOTE_DEVICE        stuRemoteDevice;			// 远程设备信息, szDeviceID 没有值时有效
	BYTE                	reserved[1024];				// 保留字节
} NET_CAMERA_GROUP_INFO;

// CLIENT_MatrixAddCamerasByGroup (批量添加视频源) 接口输入参数
typedef struct tagNET_IN_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   dwSize;
	int						nCameraGroup;				// 设备组个数
	NET_CAMERA_GROUP_INFO	*pstCameraGroupInfo; 		// 设备组信息
} NET_IN_ADD_LOGIC_BYGROUP_CAMERA;

// 添加视频源组返回的视频源添加结果信息
typedef struct tagNET_ADD_BYGROUP_RESULT_CAMERA
{
    unsigned int           	nUniqueChannel;             // 统一编号
    unsigned int            nFailedCode;                // 失败码, 0-成功,1-通道不支持设置
    BYTE					reserved[128];				// 保留字节
} NET_ADD_BYGROUP_RESULT_CAMERA;

// 添加视频源组返回结果信息
typedef struct tagNET_ADD_BYGROUP_RESULT
{
	char                    			szDeviceID[DH_DEV_ID_LEN];    	// 设备ID
	int									nResultCam;						// 视频源结果个数，与NET_CAMERA_GROUP_INFO 中的nCameraCount 一致
	NET_ADD_BYGROUP_RESULT_CAMERA		*pstResultCamera;				// 返回的视频源结果信息
																		// 由用户分配内存，大小为sizoef(NET_ADD_BYGROUP_RESULT_CAMERA)*nRetResultCamera
	BYTE								reserved[1024];					// 保留字节
} NET_ADD_BYGROUP_RESULT;

// CLIENT_MatrixAddCamerasByGroup (批量添加视频源) 接口输出参数
typedef struct tagNET_OUT_ADD_LOGIC_BYGROUP_CAMERA
{
	DWORD                   			dwSize;
	int									nGroupCount;			// 返回的group结果个数，与NET_IN_ADD_LOGIC_BYGROUP_CAMERA 中的nCameraGroup一致
	NET_ADD_BYGROUP_RESULT				*pstAddByGroupResult;	// 添加视频源组返回的结果数组
																// 由用户分配内存, 大小为sizeof(NET_ADD_BYGROUP_RESULT)*nGroupCount
} NET_OUT_ADD_LOGIC_BYGROUP_CAMERA;


/************************************************************************/
/*                         数据库记录操作                               */
/************************************************************************/
#define MAX_ORDER_NUMBER 6										// 排序规则的最大数量

// 排序类型
typedef enum tagEM_RECORD_ORDER_TYPE
{
	EM_RECORD_ORDER_TYPE_UNKNOWN,                               // 未知
	EM_RECORD_ORDER_TYPE_ASCENT,                                // 升序
	EM_RECORD_ORDER_TYPE_DESCENT                                // 降序
}EM_RECORD_ORDER_TYPE;

typedef struct tagNET_AUTHORITY_TYPE
{
  DWORD                       dwSize; 
  EM_NET_AUTHORITY_TYPE       emAuthorityType;                          //权限类型
  BOOL                        bAuthorityEnable;                         //权限使能
}NET_AUTHORITY_TYPE;

// 交通黑白名单记录信息
typedef struct tagNET_TRAFFIC_LIST_RECORD
{
  DWORD                      dwSize; 
  int                        nRecordNo;                                 // 之前查询到的记录号
  char                       szMasterOfCar[DH_MAX_NAME_LEN];            // 车主姓名
  char                       szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];    // 车牌号码 
  EM_NET_PLATE_TYPE          emPlateType;                               // 车牌类型
  EM_NET_PLATE_COLOR_TYPE    emPlateColor;                              // 车牌颜色 
  EM_NET_VEHICLE_TYPE        emVehicleType;                             // 车辆类型 
  EM_NET_VEHICLE_COLOR_TYPE  emVehicleColor;                            // 车身颜色
  NET_TIME                   stBeginTime;                               // 开始时间
  NET_TIME                   stCancelTime;                              // 撤销时间
  int                        nAuthrityNum;                              // 权限个数
  NET_AUTHORITY_TYPE         stAuthrityTypes[DH_MAX_AUTHORITY_LIST_NUM];// 权限列表 , 白名单仅有
  EM_NET_TRAFFIC_CAR_CONTROL_TYPE emControlType;                        // 布控类型 ,黑名单仅有
}NET_TRAFFIC_LIST_RECORD;

// 交通黑白名单账户记录查询条件
typedef struct
{
    DWORD                    dwSize;
    char                     szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];      // 车牌号
    char                     szPlateNumberVague[DH_MAX_PLATE_NUMBER_LEN]; // 车牌号码模糊查询
    int                      nQueryResultBegin;                           // 第一个条返回结果在查询结果中的偏移量 
    BOOL                     bRapidQuery;                                 // 是否快速查询, TRUE:为快速,快速查询时不等待所有增、删、改操作完成。默认为非快速查询
}FIND_RECORD_TRAFFICREDLIST_CONDITION;

// 嫌疑车辆上报事件, 对应事件类型 DH_ALARM_TRAFFIC_SUSPICIOUSCAR
typedef struct tagALARM_TRAFFIC_SUSPICIOUSCAR_INFO
{
    DWORD                   dwSize;
    int                     nAction;                        // 事件动作, -1:未知,0:Start, 1:Stop, 2:Pulse
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // 车辆的黑名单信息
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息
}ALARM_TRAFFIC_SUSPICIOUSCAR_INFO;


// 刻录案件记录查询条件
typedef struct
{
    DWORD                    dwSize;
    NET_TIME                 stuStartTime;                      // 起始时间
    NET_TIME                 stuEndTime;                        // 结束时间
}FIND_RECORD_BURN_CASE_CONDITION;


// 门禁卡记录查询条件
typedef struct tagFIND_RECORD_ACCESSCTLCARD_CONDITION
{
    DWORD                    dwSize;
    char                     szCardNo[DH_MAX_CARDNO_LEN];      // 卡号
    char                     szUserID[DH_MAX_USERID_LEN];      // 用户ID
    BOOL                     bIsValid;                         // 是否有效, TRUE:有效,FALSE:无效
    BOOL                     abCardNo;                         // 卡号查询条件是否有效,针对成员 szCardNo
    BOOL                     abUserID;                         // 用户ID查询条件是否有效,针对成员 szUserID
    BOOL                     abIsValid;                        // IsValid查询条件是否有效,针对成员 bIsValid
}FIND_RECORD_ACCESSCTLCARD_CONDITION;

// 门禁密码记录查询条件
typedef struct tagFIND_RECORD_ACCESSCTLPWD_CONDITION
{
    DWORD                     dwSize;
    char                      szUserID[DH_MAX_USERID_LEN];      // 用户ID
}FIND_RECORD_ACCESSCTLPWD_CONDITION;

// 门禁出入记录排序字段
typedef enum tagEM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD
{
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_UNKNOWN = 0,			// 未知
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_RECNO,				// 记录集编号
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_CREATETIME,			// 创建时间
}EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD;

// 门禁出入记录排序规则详情
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_ORDER
{
	EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD		emField;		// 排序字段
	EM_RECORD_ORDER_TYPE						emOrderType;    // 排序类型
	char										byReverse[64];  // 保留字节
}FIND_RECORD_ACCESSCTLCARDREC_ORDER;

// 门禁出入记录查询条件
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION
{
    DWORD                     dwSize;
    char                      szCardNo[DH_MAX_CARDNO_LEN];      // 卡号
    NET_TIME                  stStartTime;                      // 起始时间
    NET_TIME                  stEndTime;                        // 结束时间
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION;

// 门禁出入记录查询条件
typedef struct tagFIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX
{
    DWORD										dwSize;
    BOOL										bCardNoEnable;                  // 启用卡号查询
    char										szCardNo[DH_MAX_CARDNO_LEN];    // 卡号
    BOOL										bTimeEnable;                    // 启用时间段查询
    NET_TIME									stStartTime;                    // 起始时间
	NET_TIME									stEndTime;                      // 结束时间
	int											nOrderNum;						// 规则数
	FIND_RECORD_ACCESSCTLCARDREC_ORDER          stuOrders[MAX_ORDER_NUMBER];	// 规则数组
}FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX;

// 监测量记录查询条件
typedef struct tagFIND_RECORD_SENSORRECORD_CONDITION
{
	DWORD					  dwSize;							
	NET_TIME                  stStartTime;                      // 采集时间段查询的开始时间，必填
    NET_TIME                  stEndTime;                        // 采集时间段查询的结束时间，必填
	UINT					  uDeviceID;						// 采集设备ID号，uint_32类型。高8位表示仪表类型，低24位表示仪表组内序号。仪表类型如下：0-电力； 1-模拟传感器。选填,0xffff表示数据无效
	BOOL                      bDeviceIDEnable;                  // 启用采集设备ID查询	
	BOOL                      bStatusEnable;                    // 启用数据状态查询
	BYTE					  byStatus;                         // 数据状态0：正常，1:异常，选填。0xff表示无状态
	BYTE					  byReserved[3];					// 保留字节	
} FIND_RECORD_SENSORRECORD_CONDITION;

// 假日记录集查询条件
typedef struct tagFIND_RECORD_ACCESSCTLHOLIDAY_CONDITION
{
    DWORD                     dwSize;	
    char            		  szHolidayNo[DH_COMMON_STRING_32];       // 假期编号
}FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION;

// 电子车牌查询条件
typedef struct tagFIND_RECORD_ELECTRONICSTAG_CONDITION
{
	DWORD					dwSize;
	NET_TIME                stStartTime;								// 根据过车时间段查询的开始时间, 必填
    NET_TIME                stEndTime;									// 根据过车时间段查询的结束时间, 必填
	BOOL					abDevId;									// 读写器序号查询条件是否有效
	UINT					unDevID;									// 根据读写器设备序号查询，从0开始, 可选
	BOOL					abMatchPic;									// 图片匹配查询条件是否有效
    BOOL					bMatch;										// 根据是否匹配了图片查询, 可选
    BOOL					abPlateNumber;								// 车牌查询条件是否有效
    char					szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// 根据车牌查询, 可选
} FIND_RECORD_ELECTRONICSTAG_CONDITION;

//公租信息查询
typedef struct tagFIND_RECORD_RESIDENT_CONDTION
{
	DWORD 					  dwSize;
	char 					  szICNum[DH_MAX_IC_LEN];		   // 身份证号
}FIND_RECORD_RESIDENT_CONDTION;

// 交通流量记录查询条件
typedef struct tagFIND_RECORD_TRAFFICFLOW_CONDITION
{
    DWORD                     dwSize;
    BOOL                      abChannelId;                      // 通道号查询条件是否有效     
    int                       nChannelId;                       // 通道号
    BOOL                      abLane;                           // 车道号查询条件是否有效
    int                       nLane;                            // 车道号
    BOOL                      bStartTime;                      // 开始时间查询条件是否有效   
    NET_TIME                  stStartTime;                      // 开始时间
    BOOL					  bEndTime;                        // 结束时间查询条件是否有效
    NET_TIME                  stEndTime;                        // 结束时间 
    BOOL                      bStatisticsTime;                 // 查询是否为统计时间，bStartTime及bEndTime均为TRUE
}FIND_RECORD_TRAFFICFLOW_CONDITION;

#define DH_MAX_CALLTYPE_LIST_NUM                16                  // 呼叫类型查询条件列表最大个数
#define DH_MAX_ENDSTATE_LIST_NUM                16                  // 最终状态查询条件列表最大个数

// 通话记录查询条件
typedef struct tagFIND_RECORD_VIDEO_TALK_LOG_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bCallTypeEnable;                            // 呼叫类型查询条件是否有效
    int                             nCallTypeListNum;                           // 对应 emCallTypeList 中有效枚举个数
    EM_VIDEO_TALK_LOG_CALLTYPE      emCallTypeList[DH_MAX_CALLTYPE_LIST_NUM];   // 呼叫类型使能列表
    BOOL                            bEndStateEnable;                            // 最终状态查询条件是否有效
    int                             nEndStateListNum;                           // 对应 emEndStateList 中有效枚举个数
    EM_VIDEO_TALK_LOG_ENDSTATE      emEndStateList[DH_MAX_ENDSTATE_LIST_NUM];   // 最终状态使能列表
    BOOL                            bTimeEnable;                                // 启用时间段查询
    NET_TIME                        stStartTime;                                // 起始时间
    NET_TIME                        stEndTime;                                  // 结束时间
}FIND_RECORD_VIDEO_TALK_LOG_CONDITION;

// 状态记录查询条件
typedef struct tagFIND_RECORD_REGISTER_USER_STATE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bUserIDEnable;                                  // 用户ID查询条件是否有效
    char                            szUserID[DH_MAX_USERID_LEN];                    // 用户ID
    BOOL                            bOnlineEnable;                                  // 是否在线查询条件是否有效
    int								nOnline;                                        // 是否在线
    BOOL                            bVideoTalkingEnable;                            // 语音对讲状态查询条件是否有效
    EM_REGISTER_USER_STATE          emVideoTalking;                             // 语音对讲状态
}FIND_RECORD_REGISTER_USER_STATE_CONDITION;

// 联系人记录查询条件
typedef struct tagFIND_RECORD_VIDEO_TALK_CONTACT_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bVTShortNumberEnable;                                   // 可视对讲短号查询条件是否有效
    char                            szVTShortNumber[DH_COMMON_STRING_32];                   // 可视对讲短号
    BOOL                            bVTLongNumberEnable;                                   // 可视对讲长号查询条件是否有效
    char                            szVTLongNumber[DH_COMMON_STRING_64];                   // 可视对讲长号
}FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION;

// 下发商品记录查询条件
typedef struct tagFIND_RECORD_COMMODITY_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // ID号查询条件是否有效
    char                            szID[DH_COMMON_STRING_64];                   // ID号
}FIND_RECORD_COMMODITY_NOTICE_CONDITION;

// 就诊信息记录查询条件
typedef struct tagFIND_RECORD_HEALTH_CARE_NOTICE_CONDITION
{
    DWORD                           dwSize;
    BOOL                            bIDEnable;                                   // ID号查询条件是否有效
    char                            szID[DH_COMMON_STRING_64];                   // ID号
}FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION;

// 交通流量记录
typedef struct tagNET_RECORD_TRAFFIC_FLOW_STATE 
{
    DWORD                           dwSize;
    int                             nRecordNum;                 // 记录编号
    int                             nChannel;                   // 通道号   
    int                             nLane;                      // 车道号
    int                             nVehicles;                  // 通过车辆总数
    float                           fAverageSpeed;              // 平均车速,单位km/h
    float                           fTimeOccupyRatio;           // 时间占有率,即单位时间内通过断面的车辆所用时间的总和占单位时间的比例
    float                           fSpaceOccupyRatio;          // 空间占有率,即按百分率计量的车辆长度总和除以时间间隔内车辆平均行驶距离
    float                           fSpaceHeadway;              // 车头间距,相邻车辆之间的距离,单位米/辆
    float                           fTimeHeadway;               // 车头时距,单位秒/辆
    int                             nLargeVehicles;             // 大车交通量(9米<车长<12米),辆/单位时间
    int                             nMediumVehicles;            // 中型车交通量(6米<车长<9米),辆/单位时间
    int                             nSmallVehicles;             // 小车交通量(4米<车长<6米),辆/单位时间,
    float                           fBackOfQueue;               // 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离
    int                             nPasserby;                  // 通过行人数
}NET_RECORD_TRAFFIC_FLOW_STATE;

// CLIENT_FindRecord接口输入参数
typedef struct _NET_IN_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    EM_NET_RECORD_TYPE        emType;          // 待查询记录类型
    void*                     pQueryCondition; // 查询类型对应的查询条件
											   // 由用户申请内存，根据查询记录类型，找到查询条件对应的结构体，进而确定内存大小
}NET_IN_FIND_RECORD_PARAM;

// CLIENT_FindRecord接口输出参数
typedef struct _NET_OUT_FIND_RECORD_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    LLONG                     lFindeHandle;    // 查询记录句柄,唯一标识某次查询
}NET_OUT_FIND_RECORD_PARAM;

// CLIENT_FindNextRecord接口输入参数
typedef struct _NET_IN_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    LLONG                     lFindeHandle;    // 查询句柄
    int                       nFileCount;      // 当前想查询的记录条数
}NET_IN_FIND_NEXT_RECORD_PARAM;

// CLIENT_FindNextRecord接口输出参数
typedef struct _NET_OUT_FIND_NEXT_RECORD_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    void*                     pRecordList;     // 记录列表,用户分配内存,根据NET_IN_FIND_RECORD_PARAM中的查询类型EM_NET_RECORD_TYPE，确定对应结构体，进入确定内存大小
    int                       nMaxRecordNum;   // 最大查询列表记录数
    int                       nRetRecordNum;   // 查询到的记录条数,当查询到的条数小于想查询的条数时,查询结束
}NET_OUT_FIND_NEXT_RECORD_PARAM;

typedef struct tagNET_INSERT_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // 记录内容信息,由用户分配内存，大小为sizeof(NET_TRAFFIC_LIST_RECORD)             
}NET_INSERT_RECORD_INFO;

typedef struct tagNET_UPDATE_RECORD_INFO
{
    DWORD                     dwSize;
    NET_TRAFFIC_LIST_RECORD   *pRecordInfo;    // 记录内容信息,由用户分配内存，大小为sizeof(NET_TRAFFIC_LIST_RECORD)                
}NET_UPDATE_RECORD_INFO;

typedef struct tagNET_REMOVE_RECORD_INFO
{
    DWORD                     dwSize;
    int                       nRecordNo;       // 之前查询到的记录号    
}NET_REMOVE_RECORD_INFO;

typedef struct tagNET_IN_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    
    EM_RECORD_OPERATE_TYPE    emOperateType;   // 操作类型
    EM_NET_RECORD_TYPE        emRecordType;    // 要操作的记录信息类型（仅NET_RECORD_TRAFFICREDLIST和NET_RECORD_TRAFFICBLACKLIST有效）
    void                      *pstOpreateInfo; // 由用户申请内存，参照操作类型emOperateType，得到操作类型对应的结构体，进而确定对应的内存大小
    
}NET_IN_OPERATE_TRAFFIC_LIST_RECORD;

//现阶段实现的操作接口中,只有返回nRecordNo的操作,stRetRecord暂时不可用
typedef struct tagNET_OUT_OPERATE_TRAFFIC_LIST_RECORD
{
    DWORD                     dwSize;
    int                       nRecordNo;        //记录号    
}NET_OUT_OPERATE_TRAFFIC_LIST_RECORD;


//持续控制云台对应结构
typedef struct tagPTZ_Control_Continuously
{
    PTZ_SPEED_UNIT         stuSpeed;              //云台运行速度
    int                    nTimeOut;              //连续移动超时时间,单位为秒
    char                   szReserve[64];         //预留64字节
}PTZ_CONTROL_CONTINUOUSLY;

//绝对控制云台对应结构
typedef struct tagPTZ_Control_Absolutely
{
    PTZ_SPACE_UNIT         stuPosition;           //云台绝对移动位置
    PTZ_SPEED_UNIT         stuSpeed;              //云台运行速度
    char                   szReserve[64];         //预留64字节
}PTZ_CONTROL_ABSOLUTELY;

//云台控制坐标，持续移动
typedef struct tagPTZ_LOCATION_SPACE_UNIT
{
    int                    nPositionX;           //云台水平坐标，范围[0,3599]，表示0度到359.9度，度数扩大10倍表示。（3600表示水平不定位）
    int                    nPositionY;           //云台垂直坐标，范围[-1800,1800]，表示-180.0度到+180.0度，度数扩大10倍表示。（3600表示垂直不定位）
    int                    nZoom;                //云台真实倍率变倍参数，无范围限定(超过机芯最大倍率时只变倍至机芯最大倍率)，表示最小倍到最大倍的变倍位置，扩大10倍表示
    char                   szReserve[32];        //预留32字节
}PTZ_LOCATION_SPACE_UNIT;

//云台控制坐标,速度单元
typedef struct tagPTZ_LOCATION_SPEED_UNIT
{
    int                    nSpeedX;				//云台水平角速度的真实值,无范围限定(超过云台最大速度时以云台最大速度移动),左为负、右为正,1000代表10°/s，扩大100倍表示
    int                    nSpeedY;				//云台垂直角速度的真实值,无范围限定(超过云台最大速度时以云台最大速度移动),上为负、下为正,1000代表10°/s，扩大100倍表示
    char                   szReserve[32];       //预留32字节
}PTZ_LOCATION_SPEED_UNIT;

//云台连续移动,枪球球联动专用对应结构 DH_EXTPTZ_INTELLI_TRACKMOVE
typedef struct tagPTZ_CONTROL_INTELLI_TRACKMOVE
{
	DWORD						dwSize;
	int							nChannelID;            // 通道号
	int							nFlag;				   // 移动标识位
													   //0:起始locate定位使用,speed速度无效,position的变倍值有效
													   //1:持续跟踪移动使用,speed速度无效,position的变倍值无效
													   //2:持续跟踪移动使用,speed速度有效,position的变倍值无效

	PTZ_LOCATION_SPACE_UNIT     stuPosition;           // 云台绝对移动位置
    PTZ_LOCATION_SPEED_UNIT		stuSpeed;              // 云台运行速度
}PTZ_CONTROL_INTELLI_TRACKMOVE;

// 设置聚焦模式 DH_EXTPTZ_INTELLI_SETLENSWISDOMSTATE
typedef struct tagPTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE
{
	DWORD						dwSize;                // 结构体大小
	int							nChannelID;            // 通道号
	int							nMode;				   // 0: 普通场景模式（不设置时默认0）
													   // 1: 智能跟踪场景模式
}PTZ_CONTROL_INTELLI_SETLENSWISDOMSTATE;

// 设置聚焦区域 DH_EXTPTZ_INTELLI_SETFOCUSAREA
typedef struct tagPTZ_CONTROL_INTELLI_SETFOCUSAREA
{
	DWORD						dwSize;				   // 结构体大小
	int							nChannelID;            // 通道号
	int							nState;				   // 目标跟踪时的聚焦区域有效标志位
													   // 1:设置聚焦区域
													   // 0:取消聚焦区域
	NET_RECT					stuRect;			   // 聚焦区域, 使用相对坐标0~8191
}PTZ_CONTROL_INTELLI_SETFOCUSAREA;

//辅助开关,辅助点对应结构 DH_EXTPTZ_AUXIOPEN,DH_EXTPTZ_AUXICLOSE，云台控制接口CLIENT_DHPTZControlEx2
typedef struct tagPTZ_CONTROL_AUXILIARY
{
	DWORD						dwSize;
	char						szFunctionName[DH_COMMON_STRING_32];   // 云台辅助功能名称，通过 CFG_CAP_CMD_PTZ 命令获取云台能力集( CFG_PTZ_PROTOCOL_CAPS_INFO )，
}PTZ_CONTROL_AUXILIARY;


// 报警输入通道信息
typedef struct tagNET_ALARM_IN_CHANNEL
{
    DWORD                   dwSize;
    BOOL                    bValid;                             // 是否有效, FALSE表示该报警通道没有使用
    int                     nChannel;                           // 报警通道号
    char                    szDeviceID[DH_DEV_ID_LEN];          // 设备ID, 本地报警通道: "Local", 远程设备: 使用uuid表示
    char                    szName[DH_DEV_NAME_LEN];            // 报警通道名称
}NET_ALARM_IN_CHANNEL;

// 报警通道数
typedef struct tagNET_ALARM_CHANNEL_COUNT 
{
    DWORD                   dwSize;
    int                     nLocalAlarmIn;                      // 本地报警输入通道数
    int                     nLocalAlarmOut;                     // 本地报警输出通道数
    int                     nRemoteAlarmIn;                     // 远程报警输入通道数
    int                     nRemoteAlarmOut;                    // 远程报警输出通道数
}NET_ALARM_CHANNEL_COUNT;

//带速度转动到预置位点云台控制对应结构
typedef struct tagPTZ_Control_GotoPreset
{
    int                     nPresetIndex;           //预置位索引
    PTZ_SPEED_UNIT          stuSpeed;               //云台运行速度
    char                    szReserve[64];          //预留64字节
}PTZ_CONTROL_GOTOPRESET;

//删除预置位点云台控制对应结构
typedef struct tagPTZ_Control_RemovePreset
{
    int                     nPresetIndex;           //预置位索引
    char                    szReserve[64];          //预留64字节
}PTZ_CONTROL_REMOVEPRESET;

//带速度转动到预置位点后抓图云台控制对应结构
typedef struct tagPTZ_Control_GotoPresetSnap
{
    int                     nPresetIndex;           //预置位索引
	int						nChannel;               //通道号
    PTZ_SPEED_UNIT          stuSpeed;               //云台运行速度
    char                    szReserve[64];          //预留64字节
}PTZ_CONTROL_GOTOPRESETSNAP;

// CLIENT_SetTourSource 接口输入参数(设置窗口轮巡显示源)
typedef struct tagNET_IN_SET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // 输出通道号
    int                     nWindow;                // 窗口号
    DH_SPLIT_SOURCE*        pstuSrcs;               // 显示源数组, 可进行窗口轮巡,由用户申请内存，大小为sizeof(DH_SPLIT_SOURCE)*nSrcCount
    int                     nSrcCount;              // 显示源数量
} NET_IN_SET_TOUR_SOURCE;

// CLIENT_SetTourSource 接口输出参数(设置窗口轮巡显示源)
typedef struct tagNET_OUT_SET_TOUR_SOURCE
{
    DWORD                   dwSize;
} NET_OUT_SET_TOUR_SOURCE;

// CLIENT_GetTourSource 接口输入参数
typedef struct tagNET_IN_GET_TOUR_SOURCE 
{
    DWORD                   dwSize;
    int                     nChannel;               // 输出通道号, pszCompsiteID为NULL时有效
    const char*             pszCompositeID;         // 拼接屏ID
    int                     nWindow;                // 窗口号, -1表示所有窗口
} NET_IN_GET_TOUR_SOURCE;

// 窗口轮巡显示源信息
typedef struct tagNET_SPLIT_TOUR_SOURCE 
{
    DWORD                   dwSize;
    DH_SPLIT_SOURCE*        pstuSrcs;               // 显示源数组, 用户分配内存,大小为sizeof(DH_SPLIT_SOURCE)*nMaxSrcCount
    int                     nMaxSrcCount;           // 显示源最大数量
    int                     nRetSrcCount;           // 返回的显示源数量
} NET_SPLIT_TOUR_SOURCE;

// CLIENT_GetTourSource 接口输出参数
typedef struct tagNET_OUT_GET_TOUR_SOURCE
{
    DWORD                   dwSize;    
    NET_SPLIT_TOUR_SOURCE*  pstuWndSrcs;            // 窗口轮巡信息数组, 用户分配内存,大小为sizeof(NET_SPLIT_TOUR_SOURCE)*nMaxWndCount
    int                     nMaxWndCount;           // 窗口最大数组, 用户填写
    int                     nRetWndCount;           // 返回的窗口数量
} NET_OUT_GET_TOUR_SOURCE;

// 分割轮巡状态信息
typedef struct tagNET_SPLIT_TOUR_STATUS_INFO
{
    DWORD               dwSize;
    int                 nWindow;                    // 窗口号
    NET_TOUR_STATUS     emStatus;                   // 状态
    DH_SPLIT_WND_SOURCE stuSource;                  // 当前显示源信息
}NET_SPLIT_TOUR_STATUS_INFO;

// 轮巡状态回调函数原形, lAttachHandle是CLIENT_AttachSplitTour的返回值
typedef void (CALLBACK *fTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SPLIT_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_AttachSplitTour接口输入参数
typedef struct tagNET_IN_ATTACH_SPLIT_TOUR
{
    DWORD               dwSize;
    int                 nChannel;                   // 输出通道号, pszCompsiteID为NULL时有效
    const char*         pszCompositeID;             // 拼接屏ID
    fTourStatusCallBack cbStatus;                   // 轮巡状态回调函数
    LDWORD              dwUser;                     // 轮巡状态回调参数
}NET_IN_ATTACH_SPLIT_TOUR;

// CLIENT_AttachSplitTour接口输出参数
typedef struct tagNET_OUT_ATTACH_SPLIT_TOUR 
{
    DWORD               dwSize;
}NET_OUT_ATTACH_SPLIT_TOUR;

// 窗口工作模式
typedef enum tagEM_WINDOW_WORKMODE
{
	EM_WINDOW_DISPLAY,				// 预览模式(默认)
	EM_WINDOW_REPLAY,				// 回放模式
} EM_WINDOW_WORKMODE;

typedef struct tagNET_SOURCE_INFO
{
	int 				nWindowID;					// 当前窗口号
	int					nCaremaChannel;				// 当前视频源通道号
	NET_TIME			stuStartTime;				// 开始播放的时间
	EM_WINDOW_WORKMODE	emWorkMode;					// 窗口工作模式
	BYTE				bReserved[128];				// 保留字节
}NET_SOURCE_INFO;

// 窗口视频源信息
typedef struct tagNET_WINDOW_SOURCE_INFO
{
	DWORD				dwSize;
	int					nRetSrcCount;							// 实际显示源个数
	NET_SOURCE_INFO		*pstSourceInfo;						// 各窗口显示源信息
} NET_WINDOW_SOURCE_INFO;

// 窗口视频源信息回调函数原形, lAttachHandle是CLIENT_AttachWindowsSource的返回值
typedef void (CALLBACK *fWindowSourceCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WINDOW_SOURCE_INFO* pstWindowSource, void* reserved, LDWORD dwUser);

// CLIENT_AttachWindowsSource接口入参
typedef struct tagNET_IN_ATTACH_WINDOW_SOURCE
{
	DWORD					dwSize;
	int						nWindowID;					// 窗口ID，-1表示整个屏幕
	int 					nChannel;					// 输出通道号, pszCompsiteID为NULL时有效
	const char*         	pszCompositeID;             // 拼接屏ID
	fWindowSourceCallBack 	cbWindowSource;             // 窗口视频源回调函数
    LDWORD              	dwUser;                     // 窗口视频源回调参数
} NET_IN_ATTACH_WINDOW_SOURCE;

// CLIENT_AttachWindowsSource接口输出参数
typedef struct tagNET_OUT_ATTACH_WINDOW_SOURCE
{
    DWORD               dwSize;
}NET_OUT_ATTACH_WINDOW_SOURCE;

// CLIENT_WindowRegionEnlarge接口输入参数
typedef struct tagNET_IN_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
    int                 	nChannel;           // 输出通道号或融合屏虚拟通道号
	int						nWindowID;			// 窗口ID
	NET_RECT				stuRect;			// 画面放大区域，坐标系为虚拟坐标系，0~8192
} NET_IN_WINDOW_REGION_ENLARGE;

// CLIENT_WindowRegionEnlarge接口输出参数
typedef struct tagNET_OUT_WINDOW_REGION_ENLARGE
{
	DWORD					dwSize;
} NET_OUT_WINDOW_REGION_ENLARGE;

// CLIENT_WindowEnlargeReduction接口输入参数
typedef struct tagNET_IN_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
    int                 	nChannel;           // 输出通道号或融合屏虚拟通道号
	int						nWindowID;			// 窗口ID
} NET_IN_WINDOW_ENLARGE_REDUCTION;

// CLIENT_WindowEnlargeReduction接口输出参数
typedef struct tagNET_OUT_WINDOW_ENLARGE_REDUCTION
{
	DWORD					dwSize;
} NET_OUT_WINDOW_ENLARGE_REDUCTION;

// 鼠标操作类型
typedef enum tagEM_MOUSE_OPREATE_TYPE
{
	EM_MOUSE_OPREATE_LEFT_PRESS		= 1,	// 左键按下
	EM_MOUSE_OPREATE_LEFT_RELEASE,			// 左键松开
	EM_MOUSE_OPREATE_RIGHT_PRESS,			// 右键按下
	EM_MOUSE_OPREATE_RIGHT_RELEASE,			// 右键松开
	EM_MOUSE_OPREATE_MOUSE_MOVE,			// 鼠标移动
	EM_MOUSE_OPREATE_MOUSE_SCROLL,			// 鼠标滚动
} EM_MOUSE_OPREATE_TYPE;

// 鼠标按钮标记
typedef enum tagEM_MOUSE_FLAG_TYPE
{
	EM_MOUSE_FLAG_LEFT		= 0,			// 鼠标左边按钮
	EM_MOUSE_FLAG_RIGHT,					// 鼠标右边按钮
} EM_MOUSE_FLAG_TYPE;

// CLIENT_SplitOnButtonAction接口输入参数
typedef struct tagNET_IN_WINDOW_ONBUTTON_ACTION
{
	DWORD					dwSize;
    int                 	nChannel;           // 输出通道号或融合屏虚拟通道号
	int						nWindowID;			// 窗口ID
	EM_MOUSE_OPREATE_TYPE	emOpreateType;		// 鼠标操作类型
	EM_MOUSE_FLAG_TYPE		emMouseFlag;		// 鼠标按钮标记
	int						nZDelta;			// 鼠标滚动速度, 大于0表示向前滚动，小于0表示向后滚动，等于0表示没有滚动操作
	DH_POINT				stuMousePoint;		// 鼠标在窗口中的位置坐标
} NET_IN_WINDOW_ONBUTTON_ACTION;

// CLIENT_SplitOnButtonAction接口输出参数
typedef struct tagNET_OUT_WINDOW_ONBUTTON_ACTION
{
	DWORD					dwSize;
} NET_OUT_WINDOW_ONBUTTON_ACTION;

// fAttachRecordInfoCB 参数, 上报的录像文件信息
typedef struct tagNET_CB_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nChannel;               // 通道号
    char                    szFileName[MAX_PATH];   // 录像名称
    DWORD                   dwType;                 // 录像类型, 按位定义如下：
                                                    // Bit0-定时录像
                                                    // Bit1-动态检测录像
                                                    // Bit2-报警录像
                                                    // Bit3-卡号录像
    DWORD                   dwState;                // 录像状态, 0-打包, 1-删除
} NET_CB_RECORD_INFO;

// 录像更新回调函数原形,lAttachHandle是CLIENT_AttachRecordInfo的返回值, 每次n条,pBuf->dwSize * n == nBufLen
typedef void (CALLBACK *fAttachRecordInfoCB)(LLONG lLoginID, LLONG lAttachHandle, NET_CB_RECORD_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordInfo 输入参数
typedef struct tagNET_IN_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
    int                     nInterval;              // 时间间隔, 设备每隔nInterval秒, 发送录像信息
    int                     nDelay;                 // 上报延时, 设备在1和nDelay值间选择随机数后,延迟上报录像状态, nDelay必须小于nInterval
    fAttachRecordInfoCB     cbAttachRecordInfo;     // 录像更新回调函数
    LDWORD                  dwUser;                 // 用户数据
} NET_IN_ATTACH_RECORD_INFO;

typedef struct tagNET_OUT_ATTACH_RECORD_INFO
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_RECORD_INFO;


//订阅云台元数据接口回调函数原型
//pBuf 现阶段主要为 DH_PTZ_LOCATION_INFO 类型
typedef void (CALLBACK *fPTZStatusProcCallBack)(LLONG lLoginID, LLONG lAttachHandle, void* pBuf, int nBufLen, LDWORD dwUser);

// 订阅云台元数据接口输入参数
typedef struct tagNET_IN_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
    int                     nChannel;              // 云台通道
    fPTZStatusProcCallBack  cbPTZStatusProc;       // 状态回调函数
    LDWORD                  dwUser;                // 用户数据
}NET_IN_PTZ_STATUS_PROC;

// 订阅云台元数据接口输输出参数
typedef struct tagNET_OUT_PTZ_STATUS_PROC
{
    DWORD                   dwSize;
}NET_OUT_PTZ_STATUS_PROC;

// 云台可视域状态结构
typedef struct tagDH_OUT_PTZ_VIEW_RANGE_STATUS
{
    DWORD      dwSize;
    double     dbDistance;                         // 可视距离, 单位:米
    int        nAngelH;                            // 水平可视角度, 0~1800, 单位:十分之一度
    int        nAzimuthH;                          // 水平方位角度, 0~3600, 单位:十分之一度
    int        nInclinationH;                      // 水平倾斜角度, -900~900, 单位:十分之一度
	int        nAngelV;                            // 垂直可视角度, 0~1800, 单位:十分之一度
	int        nAzimuthV;                          // 垂直方位角度, 0~3600, 单位:十分之一度
}DH_OUT_PTZ_VIEW_RANGE_STATUS;

//订阅云台可视域回调函数原型
typedef void (CALLBACK *fViewRangeStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, DH_OUT_PTZ_VIEW_RANGE_STATUS* pBuf, int nBufLen, LDWORD dwUser);

// 订阅可视域输入参数
typedef struct tagNET_IN_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
    int                     nChannel;              // 云台通道
    fViewRangeStateCallBack cbViewRange;           // 状态回调函数
    LDWORD                  dwUser;                // 用户数据
}NET_IN_VIEW_RANGE_STATE;

// 订阅可视域输出参数
typedef struct tagNET_OUT_VIEW_RANGE_STATE
{
    DWORD                   dwSize;
}NET_OUT_VIEW_RANGE_STATE;

// 气象信息结构
typedef struct tagNET_WEATHER_INFO
{
	float				    fWindSpeed;		       // 风速,单位m/s,	范围[0.0,60.0]	
	float					fTemperature;		   // 温度,单位摄氏度，范围[-40.0,+80.0]
	float					fHumidity;			   // 后缀%,范围[0.0,100.0]
	unsigned int			nLight;				   // 光照,单位W/(m*m),范围[0,2000]
	float					fWindDirection;		   // 风向,单位度,范围[0,360)
	float				    fAirPressure;		   // 气压,单位百帕,范围[10~1100]
    int                     nRainfall;             // 累计雨量,单位0.01mm
	BYTE					byReserved[2044];	   // 保留字节
}NET_WEATHER_INFO;

// 订阅气象信息回调函数原型
typedef void (CALLBACK *fWeatherInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WEATHER_INFO* pBuf, int nBufLen, LDWORD dwUser);

// 订阅气象信息输入参数
typedef struct tagNET_IN_WEATHER_INFO
{
	DWORD                   dwSize;
	int                     nChannel;              // 云台通道
	fWeatherInfoCallBack	cbWeatherInfo;         // 回调函数
	LDWORD                  dwUser;                // 用户数据
}NET_IN_WEATHER_INFO;

// 订阅气象信息输出参数
typedef struct tagNET_OUT_WEATHER_INFO
{
	DWORD                   dwSize;
}NET_OUT_WEATHER_INFO;

// 根据物距、物体大小及占屏比设置可视域 输入参数
typedef struct tagNET_IN_SET_VIEW_RANGE_BY_OBJECT
{
	DWORD					dwSize;					
	int						nChannel;				// 通道号
	int						nDistance;				// 物体距离  （单位：厘米） 
	int						nWidth;					// 物体宽度  （单位：厘米）
	int						nScreenRatio;			// 物体占屏比（单位：厘米）
}NET_IN_SET_VIEW_RANGE_BY_OBJECT;

// 根据物距、物体大小及占屏比设置可视域 输出参数
typedef struct tagNET_OUT_SET_VIEW_RANGE_BY_OBJECT
{
    DWORD                   dwSize;
}NET_OUT_SET_VIEW_RANGE_BY_OBJECT;

// 根据目标GPS位置设置可视域 输入参数(CLIENT_SetViewRangeByGPS)
typedef struct tagNET_IN_SET_VIEW_RANGE_BY_GPS
{
	DWORD					dwSize;					
	int						nChannel;				// 通道号
	double				    dLongitude;			    // 经度,[-180, 180],单位:度(°),负为西经
	double					dLatitude;				// 纬度,[-90, 90],单位:度(°),负为南纬
}NET_IN_SET_VIEW_RANGE_BY_GPS;

// 根据目标GPS位置设置可视域 输出参数(CLIENT_SetViewRangeByGPS)
typedef struct tagNET_OUT_SET_VIEW_RANGE_BY_GPS
{
	DWORD                   dwSize;
}NET_OUT_SET_VIEW_RANGE_BY_GPS;

//设置云台可视域信息
typedef struct tagPTZ_VIEW_RANGE_INFO
{
    int                     nStructSize;
    int                     nAzimuthH;              // 水平方位角度, 0~3600, 单位:度
}PTZ_VIEW_RANGE_INFO;

//获取云台光学变倍信息,对应命令 DH_DEVSTATE_PTZ_ZOOM_INFO
typedef struct tagDH_OUT_PTZ_ZOOM_INFO
{
    int                     dwSize;
    int                     nZoomValue;              // 光学变倍值
}DH_OUT_PTZ_ZOOM_INFO;

// 通道数量信息
typedef struct tagNET_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    int                     nMaxTotal;              // 设备总通道数(所有有效通道数之和)
    int                     nCurTotal;              // 已配置的通道数
    int                     nMaxLocal;              // 最大本地通道数, 含主板和可插拔子卡通道
    int                     nCurLocal;              // 已配置本地通道数
    int                     nMaxRemote;             // 最大远程通道数
    int                     nCurRemote;             // 已配置远程通道数
} NET_CHN_COUNT_INFO;

// 设备通道数量信息
typedef struct tagNET_DEV_CHN_COUNT_INFO
{
    DWORD                   dwSize;
    NET_CHN_COUNT_INFO      stuVideoIn;             // 视频输入通道
    NET_CHN_COUNT_INFO      stuVideoOut;            // 视频输出通道
} NET_DEV_CHN_COUNT_INFO;

// 录像状态详细信息
typedef struct tagNET_RECORD_STATE_DETAIL 
{
    DWORD                   dwSize;
    BOOL                    bMainStream;            // 主码流, TRUE-正在录像, FALSE-没在录像
    BOOL                    bExtraStream1;          // 辅码流1, TRUE-正在录像, FALSE-没在录像
    BOOL                    bExtraStream2;          // 辅码流2, TRUE-正在录像, FALSE-没在录像
    BOOL                    bExtraStream3;          // 辅码流3, TRUE-正在录像, FALSE-没在录像
} NET_RECORD_STATE_DETAIL;

//云台绝对聚焦对应结构
typedef struct tagPTZ_Focus_Absolutely
{
    DWORD                    dwValue;               //云台聚焦位置,取值范围(0~8191)
    DWORD                    dwSpeed;               //云台聚焦速度,取值范围(0~7)
    char                     szReserve[64];         //预留64字节
}PTZ_FOCUS_ABSOLUTELY;

// CLIENT_PlayAudioFile 接口输入参数
typedef struct tagNET_IN_PLAY_AUDIO_FILE
{
    DWORD                   dwSize;
    const char*             pszFilePath;            // 文件路径
    DWORD                   dwOutput;               // 输出途径, 可以是多种输出, 按位表示, bit0-mic, bit1-speaker
} NET_IN_PLAY_AUDIO_FILE;

// CLIENT_PlayAudioFile 接口输出参数
typedef struct tagNET_OUT_PLAY_FILE_STREAM
{
    DWORD                   dwSize;
} NET_OUT_PLAY_AUDIO_FILE;

// RTSP URL信息列表结构
typedef struct tagNET_DEV_RTSPURL_LIST
{
    DWORD                   dwSize;
    int                     nChannelID;                                 // 通道号(用户输入参数)
    int                     nUrlNum;                                    // Url地址个数
    char                    szURLList[DH_MAX_URL_NUM][DH_MAX_URL_LEN];  // Url地址列表
}NET_DEV_RTSPURL_LIST;

// 云台控制-扇扫对应结构
typedef struct tagPTZ_Control_SectorScan
{
    int             nBeginAngle;                    //起始角度,范围:[-180,180]
    int             nEndAngle;                      //结束角度,范围:[-180,180]
    int             nSpeed;                         //速度,范围:[0,255]
    char            szReserve[64];                  //预留64字节
}PTZ_CONTROL_SECTORSCAN;

// 控制鱼眼电子云台信息
typedef struct tagPTZ_CONTROL_SET_FISHEYE_EPTZ
{
    DWORD           dwSize;                         // 结构体大小
    DWORD           dwWindowID;                     // 进行EPtz控制的窗口编号
    DWORD           dwCommand;                      // 电子云台命令
    DWORD           dwParam1;                       // 命令对应参数1
    DWORD           dwParam2;                       // 命令对应参数2
    DWORD           dwParam3;                       // 命令对应参数3
    DWORD           dwParam4;                       // 命令对应参数4
}PTZ_CONTROL_SET_FISHEYE_EPTZ;

// 轨道机控制信息
typedef struct tagPTZ_CONTROL_SET_TRACK_CONTROL
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_SET_TRACK_CONTROL)
    DWORD           dwChannelID;                    // 通道号
    DWORD           dwCommand;                      // 电子云台命令,对应枚举NET_TRACK_CONTROL_CMD
    DWORD           dwParam1;                       // 命令对应参数1
    DWORD           dwParam2;                       // 命令对应参数2
    DWORD           dwParam3;                       // 命令对应参数3
} PTZ_CONTROL_SET_TRACK_CONTROL;

//===============区域扫描，云台操作=============================

// 区域扫描云台控制命令(CLIENT_DHPTZAreaScan)
typedef enum tagNET_AREASCAN_EPTZ_CMD
{
	NET_AREASCAN_EPTZ_CMD_SET,					// 设置当前位置为某个区域的扫描边界(结构体输入为 PTZ_CONTROL_SET_AREA_SCAN_LIMIT,输出参数无效)
    NET_AREASCAN_EPTZ_CMD_DEL,					// 删除某个区域扫描(结构体输入为 PTZ_CONTROL_DEL_AREA_SCAN,输出参数无效)
    NET_AREASCAN_EPTZ_CMD_GET, 					// 获取所有的区域扫描编号是否有效(结构体输入为 PTZ_CONTROL_GET_AREA_SCAN_IN,输出参数为 PTZ_CONTROL_GET_AREA_SCAN_OUT )
    NET_AREASCAN_EPTZ_CMD_START,				// 开始区域扫描(结构体输入为 PTZ_CONTROL_START_AREA_SCAN,输出参数无效)
    NET_AREASCAN_EPTZ_CMD_STOP,					// 停止区域扫描(结构体输入为 PTZ_CONTROL_STOP_AREA_SCAN,输出参数无效)
}NET_AREASCAN_EPTZ_CMD;

// 设置当前位置为某个区域的扫描边界
typedef struct tagPTZ_CONTROL_SET_AREA_SCAN_LIMIT
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_SET_AREA_SCAN_LIMIT)
    int				nChannelID;                     // 通道号,通道号从0开始
	int             nIndex;							// 区域编号，编号从1开始
	char			szLimitMode[16];				// 区域边界，"Left":左边界 "Right":右边界
	int             nZoom;							// 扫描变倍值,范围0~128，默认为0，表示当前值，1~128表示对应的变倍档位
} PTZ_CONTROL_SET_AREA_SCAN_LIMIT;

// 删除某个区域扫描
typedef struct tagPTZ_CONTROL_DEL_AREA_SCAN
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_DEL_AREA_SCAN)
    int				nChannelID;                     // 通道号,通道号从0开始
	int             nIndex;							// 区域编号，编号从1开始
} PTZ_CONTROL_DEL_AREA_SCAN;

// 获取所有的区域扫描编号是否有效,输入参数
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_IN
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_GET_AREA_SCAN)
    int				nChannelID;                     // 通道号,通道号从0开始
	int             nSize;							// 要获取的区域扫描个数
} PTZ_CONTROL_GET_AREA_SCAN_IN;

// 区域有效信息
typedef struct tagNET_AREASCAN_STATE 
{
    BOOL            bValid;							// 区域是否有效
	BYTE			Reserved[128];					// 保留字节
}NET_AREASCAN_STATE;

// 获取所有的区域扫描编号是否有效,输出参数
typedef struct tagPTZ_CONTROL_GET_AREA_SCAN_OUT
{
    DWORD                       dwSize;                             // 结构体大小, 调用者必须初始化该字段
	UINT				        nValidNum;						    // 数组 stuStateInfo 的有效个数
    NET_AREASCAN_STATE			stuStateInfo[DH_COMMON_STRING_32];  // 区域状态信息
}PTZ_CONTROL_GET_AREA_SCAN_OUT;

// 开始区域扫描
typedef struct tagPTZ_CONTROL_START_AREA_SCAN
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_START_AREA_SCAN)
    int				nChannelID;                     // 通道号,通道号从0开始
	int             nIndex;							// 区域编号，编号从1开始
	int             nSpeed;							// 水平扫描速度，范围1~255
	int				nTitleAngle;					// 垂直扫描角度，从当前位置按此角度递增或者递减扫描，范围0~90度
} PTZ_CONTROL_START_AREA_SCAN;

// 停止区域扫描
typedef struct tagPTZ_CONTROL_STOP_AREA_SCAN
{
    DWORD           dwSize;                         // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_STOP_AREA_SCAN)
    int				nChannelID;                     // 通道号,通道号从0开始
	int             nIndex;							// 区域编号，编号从1开始
} PTZ_CONTROL_STOP_AREA_SCAN;
//===============区域扫描，云台操作=============================


// 区域聚焦模式
typedef enum tagEM_NET_FOCUS_REGION_MODE
{
    EM_NET_FOCUS_REGION_MODE_GLOBAL,                // 全局
    EM_NET_FOCUS_REGION_MODE_AUTO,                  // 自动
    EM_NET_FOCUS_REGION_MODE_INROIREGION,           // ROI 指定的区域内
    EM_NET_FOCUS_REGION_MODE_OUTROIREGION,          // ROI 指定的区域外

}EM_NET_FOCUS_REGION_MODE;

// 区域聚焦(对应枚举DH_EXTPTZ_SET_FOCUS_REGION)
typedef struct tagPTZ_CONTROL_SET_FOCUS_REGION
{
    DWORD                       dwSize;             // 用户使用该结构体时,dwSize 需赋值为 sizeof(PTZ_CONTROL_SET_FOCUS_REGION)   
    EM_NET_FOCUS_REGION_MODE    emMode;	            // 聚焦模式
    NET_RECT                    stuRect;            // 聚焦区域,使用相对坐标体系，取值均为0-8192                        
} PTZ_CONTROL_SET_FOCUS_REGION;


// CLIENT_TransmitInfoForWeb 接口扩展参数
typedef struct tagNET_TRANSMIT_EXT_INFO
{
    DWORD           dwSize;
    unsigned char*  pInBinBuf;                      // 二进制输入数据缓冲
    DWORD           dwInBinBufSize;                 // 二进制输入数据长度
    int             nJsonDataLen;                   // Json输出数据长度
    int             nBinDataLen;                    // 二进制输出数据长度
} NET_TRANSMIT_EXT_INFO;

// 监听CAN总线数据
// fAttachProxyCB 参数
typedef struct tagNET_CB_CANDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // 普通数据长度
    unsigned char*  pDataContent;                   // 普通数据内容
}NET_CB_CANDATA;

// 监听CAN总线数据回调函数原形,lAttachHandle是CLIENT_AttachCAN返回值
typedef void (CALLBACK *fAttachCANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_CANDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachCAN()输入参数
typedef struct tagNET_IN_ATTACH_CAN
{
    DWORD          dwSize;
    int            nChannel;                        // 监听的CAN通道号
    fAttachCANCB   cbAttachCAN;                     // 注册视频电话状态变化回调
    LDWORD         dwUser;                          // 用户数据
}NET_IN_ATTACH_CAN;

// CLIENT_AttachCAN()输出参数
typedef struct tagNET_OUT_ATTACH_CAN
{
    DWORD          dwSize;
}NET_OUT_ATTACH_CAN;

// CLIENT_SendCAN()输入参数
typedef struct tagNET_IN_SEND_CAN
{
    DWORD          dwSize;
    int            nChannel;                       // CAN通道号
    int            nSendDataLength;                // 发送数据长度
    unsigned char* pSendData;                      // 发送数据内容
}NET_IN_SEND_CAN;

// CLIENT_SendCAN()输出参数
typedef struct tagNET_OUT_SEND_CAN
{
    DWORD          dwSize;
}NET_OUT_SEND_CAN;

// 订阅透明串口数据回调fAttachDevCommCB 参数
typedef struct tagNET_CB_DEVCOMMDATA
{
    DWORD           dwSize;
    int             nDataLength;                    // 普通数据长度
    unsigned char*  pDataContent;                   // 普通数据内容
}NET_CB_DEVCOMMDATA;

// 监听透明串口数据回调函数原形,lAttachHandle是CLIENT_AttachDevComm返回值
typedef void (CALLBACK *fAttachDevCommCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_DEVCOMMDATA* pBuf, LDWORD dwUser);

// CLIENT_AttachDevComm()输入参数
typedef struct tagNET_IN_ATTACH_DEVCOMM
{
    DWORD               dwSize;
    int                 nChannel;                        // 监听的透明串口号
    fAttachDevCommCB    cbAttachDevComm;                 // 注册透明串口数据回调
    LDWORD              dwUser;                          // 用户数据
}NET_IN_ATTACH_DEVCOMM;

// CLIENT_AttachDevComm()输出参数
typedef struct tagNET_OUT_ATTACH_DEVCOMM
{
    DWORD          dwSize;
}NET_OUT_ATTACH_DEVCOMM;

// 获取当前设备串口个数,对应CLIENT_QueryDevState()接口的 DH_DEVSTATE_GET_COMM_COUNT 命令参数
typedef struct tagNET_GET_COMM_COUNT
{
    DWORD          dwSize;
    int            nChannelCout;                    // 获取到的串口数
}NET_GET_COMM_COUNT;

// CLIENT_ExChangeData 接口输入结构体
typedef struct tagNET_IN_EXCHANGEDATA
{
    DWORD           dwSize;
    int             nChannel;                       // 串口号
    BOOL            bFlag;                          // TRUE 为发送数据并等待回复,FALSE 只是采集数据
    int             nCollectTime;                   // 串口采集时长(单位：毫秒)
    int             nSendDataLength;                // 发送数据长度,bFlag = TRUE 有效
    unsigned char*  pSendData;                      // 发送数据内容,bFlag = TRUE 有效
}NET_IN_EXCHANGEDATA;

// CLIENT_ExChangeData 接口输出结构体
typedef struct tagNET_OUT_EXCHANGEDATA
{
    DWORD           dwSize;
}NET_OUT_EXCHANGEDATA;

// 云台预置点
typedef struct tagNET_PTZ_PRESET 
{
    int                     nIndex;                         // 编号
    char                    szName[PTZ_PRESET_NAME_LEN];    // 名称
    char                    szReserve[64];                  // 预留64字节
} NET_PTZ_PRESET;

// 云台预置点列表
typedef struct tagNET_PTZ_PRESET_LIST 
{
    DWORD                   dwSize;
    DWORD                   dwMaxPresetNum;                 // 预置点最大个数
    DWORD                   dwRetPresetNum;                 // 返回预置点个数
    NET_PTZ_PRESET          *pstuPtzPorsetList;             // 预置点列表(入参需要根据最大个数申请内存),内存大小为sizeof(NET_PTZ_PRESET)*dwMaxPresetNum
} NET_PTZ_PRESET_LIST;

// 事件类型 EVENT_IVS_TRAFFIC_RESTRICTED_PLATE (受限车牌事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_RESTRICTED_PLATE
{
    int                     nChannelID;                     // 通道号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名称
    int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD                   PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                            // 事件发生的时间
    int                     nEventID;                       // 事件ID
    int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                    byReserved1[2];
    int                     nLane;                          // 对应车道号
    DH_MSG_OBJECT           stuObject;                      // 检测到的物体
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    DH_EVENT_FILE_INFO      stuFileInfo;                    // 事件对应文件信息
    int                     nMark;                          // 底层产生的触发抓拍帧标记
    int                     nFrameSequence;                 // 视频分析帧序号
    int                     nSource;                        // 视频分析的数据源地址
    DWORD                   dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
    NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
    BYTE                    byReserved[984];                // 保留字节
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息
}DEV_EVENT_TRAFFIC_RESTRICTED_PLATE;

// 事件类型 EVENT_IVS_TRAFFIC_OVERSTOPLINE (压停车线事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_OVERSTOPLINE
{
    int                     nChannelID;                     // 通道号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名称
    int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD                   PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                            // 事件发生的时间
    int                     nEventID;                       // 事件ID
    int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                    byReserved1[2];
    int                     nLane;                          // 对应车道号
    DH_MSG_OBJECT           stuObject;                      // 检测到的物体
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    DH_EVENT_FILE_INFO      stuFileInfo;                    // 事件对应文件信息
    int                     nMark;                          // 底层产生的触发抓拍帧标记
    int                     nFrameSequence;                 // 视频分析帧序号
    int                     nSource;                        // 视频分析的数据源地址
    DWORD                   dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // 对应图片的分辨率
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
    int                     nSpeed;                         // 车辆实际速度,Km/h
    NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
    BYTE                    byReserved[984];                // 保留字节
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息

}DEV_EVENT_TRAFFIC_OVERSTOPLINE;



// 事件类型EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(交通未系安全带事件事件)对应的数据块描述信息
typedef struct  tagDEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT
{
    int                     nChannelID;                     // 通道号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名称
    int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD                   PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                            // 事件发生的时间
    int                     nEventID;                       // 事件ID
    int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // 事件对应文件信息
    int                     nLane;                          // 对应车道号
    int                     nMark;                          // 底层产生的触发抓拍帧标记
    int                     nFrameSequence;                 // 视频分析帧序号
    int                     nSource;                        // 视频分析的数据源地址
    DH_MSG_OBJECT           stuObject;                      // 检测到的物体
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
    int                     nSpeed;                         // 车辆实际速度,Km/h
    NET_SAFEBELT_STATE      emMainSeat;                     // 主驾驶座位安全带状态
    NET_SAFEBELT_STATE      emSlaveSeat;                    // 副驾驶座位安全带状态
    DWORD                   dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // 对应图片的分辨率
    NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
    BYTE                    byReserved[984];                // 保留字节
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息

}DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT;

// 事件类型EVENT_IVS_TRAFFIC_DRIVER_SMOKING (驾驶员抽烟事件)对应的数据块描述信息
typedef struct  tagDEV_EVENT_TRAFFIC_DRIVER_SMOKING
{
    int                     nChannelID;                     // 通道号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名称
    int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD                   PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                            // 事件发生的时间
    int                     nEventID;                       // 事件ID
    int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // 事件对应文件信息
    int                     nLane;                          // 对应车道号
    int                     nMark;                          // 底层产生的触发抓拍帧标记
    int                     nFrameSequence;                 // 视频分析帧序号
    int                     nSource;                        // 视频分析的数据源地址
    DH_MSG_OBJECT           stuObject;                      // 检测到的物体
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
    int                     nSpeed;                         // 车辆实际速度,Km/h
    DWORD                   dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // 对应图片的分辨率
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息    
    NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
    char                    szDriverID[32];                 // 司机ID
    BYTE                    byReserved[952];                // 保留字节
}DEV_EVENT_TRAFFIC_DRIVER_SMOKING;

// 事件类型EVENT_IVS_TRAFFIC_DRIVER_CALLING(驾驶员打电话事件)对应的数据块描述信息
typedef struct  tagDEV_EVENT_TRAFFIC_DRIVER_CALLING
{
    int                     nChannelID;                     // 通道号
    char                    szName[DH_EVENT_NAME_LEN];      // 事件名称
    int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
    DWORD                   PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                            // 事件发生的时间
    int                     nEventID;                       // 事件ID
    int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    BYTE                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    BYTE                    byReserved1[2];
    BYTE                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    BYTE                    byReserved1[2];
    DH_EVENT_FILE_INFO      stuFileInfo;                    // 事件对应文件信息
    int                     nLane;                          // 对应车道号
    int                     nMark;                          // 底层产生的触发抓拍帧标记
    int                     nFrameSequence;                 // 视频分析帧序号
    int                     nSource;                        // 视频分析的数据源地址
    DH_MSG_OBJECT           stuObject;                      // 检测到的物体
    DH_MSG_OBJECT           stuVehicle;                     // 车身信息
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
    int                     nSpeed;                         // 车辆实际速度,Km/h
    DWORD                   dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    DH_RESOLUTION_INFO      stuResolution;                  // 对应图片的分辨率
    EVENT_COMM_INFO         stCommInfo;                     // 公共信息
    NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
    char                    szDriverID[32];                 // 司机ID
    BYTE                    byReserved[952];                // 保留字节
}DEV_EVENT_TRAFFIC_DRIVER_CALLING;


// 事件类型EVENT_IVS_OBJECT_DETECTION(物体特征检测事件)对应的数据块描述信息
typedef struct  tagDEV_EVENT_TRAFFIC_OBJECT_DETECTION
{
    int                 nChannelID;                         // 通道号
    char                szName[128];                        // 事件名称
    char                bReserved1[4];                      // 字节对齐
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventID;                           // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
    BYTE                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byReserved[2];                      // 保留字节
    BYTE                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
    char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
    unsigned int        nOccurrenceCount;                   // 事件触发累计次数

    int                 nObjectNum;          //物体信息数
    DH_MSG_OBJECT_EX   *pstObjectInfo;       //物体信息数据  
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;  		// 智能事件公共信息
    BYTE                byReserved2[892];   //保留字节
}DEV_EVENT_TRAFFIC_OBJECT_DETECTION;

// 冗余电源异常报警
typedef struct tagALARM_POWER_ABNORMAL_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 通道号
    NET_TIME                stuTime;                        // 时间
    DWORD                   dwAction;                       // 事件动作, 0:Start, 1:Stop
}ALARM_POWER_ABNORMAL_INFO;

// 三态使能
typedef enum tagNET_THREE_STATE_ENABLE
{
    EM_STATE_ENABLE_INVALID = 0,            // 无效
    EM_STATE_ENABLE_OFF,                    // 关
    EM_STATE_ENABLE_ON,                     // 开
} NET_THREE_STATE_ENABLE;

// 配置使能改变上报事件
typedef struct tagCONFIG_ENABLE_CHANGE_INFO
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 通道号, 从0开始
    NET_THREE_STATE_ENABLE  emMotionDetect;                 // 动检使能,     0:无效, 1:使能关闭, 2:使能打开
    NET_THREE_STATE_ENABLE  emLossDetect;                   // 视频丢失使能, 0:无效, 1:使能关闭, 2:使能打开
    NET_THREE_STATE_ENABLE  emBlindDetect;                  // 视频遮挡使能, 0:无效, 1:使能关闭, 2:使能打开
    NET_THREE_STATE_ENABLE  emAlarmLocal;                   // 外部报警使能, 0:无效, 1:使能关闭, 2:使能打开
}ALARM_CONFIG_ENABLE_CHANGE_INFO;

// 虚点测速仪违章类型
typedef enum tagEM_ITC_HWS000_IT_TYPE
{
    EM_ITC_HWS000_IT_TYPE_UNKNOWN,      // 未知
    EM_ITC_HWS000_IT_TYPE_HIGH_SPEED,   // 高速
    EM_ITC_HWS000_IT_TYPE_LOW_SPEED,    // 低速
}EM_ITC_HWS000_IT_TYPE;

// 虚点测速仪雷达状态
typedef enum tagEM_ITC_HWS000_RS_TYPE
{
    EM_ITC_HWS000_RS_TYPE_UNKNOWN,      // 未知
    EM_ITC_HWS000_RS_TYPE_ONLINE,       // 在线
    EM_ITC_HWS000_RS_TYPE_OFFLINE,      // 离线
}EM_ITC_HWS000_RS_TYPE;

// 虚点测速仪闪光灯状态
typedef enum tagEM_ITC_HWS000_FS_TYPE
{
    EM_ITC_HWS000_FS_TYPE_UNKNOWN,     // 未知
    EM_ITC_HWS000_FS_TYPE_ONLINE,      // 在线
    EM_ITC_HWS000_FS_TYPE_OFFLINE,     // 离线
}EM_ITC_HWS000_FS_TYPE;

// 虚点测速仪设备事件与报警
typedef struct tagALARM_ITC_HWS000
{
    DWORD dwSize;
    EM_ITC_HWS000_IT_TYPE emItType;   // 违章类型
    EM_ITC_HWS000_RS_TYPE emRsType;   // 雷达在线状态
    EM_ITC_HWS000_FS_TYPE emFsType;   // 闪光灯在线状态
    int nOcNum;                       // 超速计数值
    int nLcNum;                       // 欠速计数值
    int nAcNum;                       // 违章总计数值
    int nFcNum;                       // 闪光灯闪烁次数
}ALARM_ITC_HWS000;

// 车辆状态 +-     
typedef enum tagEM_CAR_COME_STATUS       
{       
    EM_CAR_COME_STATUS_UNKNOWN,                            //未知       
    EM_CAR_COME_STATUS_COME_IN,                            //入场       
    EM_CAR_COME_STATUS_COME_OUT,                           //出场       
}EM_CAR_COME_STATUS;       
           
// 手机号码上报事件       
typedef struct tagALARM_TELEPHONE_CHECK_INFO       
{       
    DWORD                       dwSize;       
    EM_CAR_COME_STATUS          emCarStatus;               //车辆状态       
    char                        szTelephoneNum[32];        //手机号码                          
}ALARM_TELEPHONE_CHECK_INFO; 

#define UPDATE_VERSION_LEN        64

// 获取设备升级状态对应结构体
typedef struct tagDHDEV_UPGRADE_STATE_INFO
{
    int                  nState;                            // 0:None-没有检测到更新, 默认状态; 1:Regular-一般升级; 
                                                            // 2:Emergency-强制升级; 3:Upgrading-升级中
    
    char                szOldVersion[UPDATE_VERSION_LEN];   // 旧版本
    char                szNewVersion[UPDATE_VERSION_LEN];   // 新版本
    DWORD               dwProgress;                         // 升级进度
    int                 reserved[256];                      // 保留字段
}DHDEV_UPGRADE_STATE_INFO;

// 警戒线入侵方向
typedef enum tagNET_CROSSLINE_DIRECTION_INFO
{
    EM_CROSSLINE_DIRECTION_UNKNOW = 0 , 
    EM_CROSSLINE_DIRECTION_LEFT2RIGHT ,   //左到右
    EM_CROSSLINE_DIRECTION_RIGHT2LEFT ,   //右到左
    EM_CROSSLINE_DIRECTION_ANY        ,   
}NET_CROSSLINE_DIRECTION_INFO;

// 警戒线事件(对应事件 DH_EVENT_CROSSLINE_DETECTION)
typedef struct tagALARM_EVENT_CROSSLINE_INFO
{
    DWORD                           dwSize;                         
    int					            nChannelID;						// 通道号
    double				            PTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            UTC;							// 事件发生的时间
    int					            nEventID;						// 事件ID
    int                             nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    NET_CROSSLINE_DIRECTION_INFO    emCrossDirection;               // 入侵方向
    int                             nOccurrenceCount;               // 规则被触发生次数
    int                             nLevel;                         // 事件级别,GB30147需求项
	BOOL							bIsObjectInfo;					// 是否检测到物体信息
	DH_MSG_OBJECT			        stuObject;                      // 检测到的物体信息
	int								nRetObjectNum;						// 实际返回多个检测到的物体信息 
	DH_MSG_OBJECT			        stuObjects[MAX_TARGET_OBJECT_NUM];  // 多个检测到的物体信息
}ALARM_EVENT_CROSSLINE_INFO;

// 移动事件(对应事件DH_ALARM_MOVEDETECTION)
typedef struct tagALARM_MOVE_DETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int								nCount;							// 规则被触发的次数
	BYTE                			byReserved[1024];   			//保留字节
} ALARM_MOVE_DETECTION_INFO;

// 徘徊事件(对应事件DH_ALARM_WANDERDETECTION)
typedef struct tagALARM_WANDERDETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int 							nCount;							// 规则被触发的次数
	int								nLevel;							// 事件级别,GB31047需求
	short							nPreserID;						// 事件触发的预置点号，从1开始（没有表示未知）
	char							szPresetName[64];				// 事件触发的预置名称
	BYTE                			byReserved[958];   				//保留字节
} ALARM_WANDERDETECTION_INFO;

// 翻越围栏事件(对应事件DH_ALARM_CROSSFENCEDETECTION)
typedef struct tagALARM_CROSSFENCEDETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_CROSSLINE_DIRECTION_INFO	emCrossDirection;               // 入侵方向
	int 							nCount;							// 规则被触发的次数
	BYTE                			byReserved[1024];   			//保留字节
} ALARM_CROSSFENCEDETECTION_INFO;

// 闯红灯事件(对应事件 ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION)
typedef struct tagALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID
	BYTE                			byReserved[1024];   			//保留字节
} ALARM_TRAFFIC_PEDESTRIAN_RUN_REDLIGHT_DETECTION_INFO;

//斗殴事件(对应事件DH_ALARM_FIGHTDETECTION)
typedef struct tagNET_ALARM_FIGHTDETECTION
{	

	int                             nAction;                   		// 事件动作,0:开始1:停止
	int					            nChannelID;						// 通道号从0开始	
    double				            dbPTS;							// 时间戳(单位是毫秒)    
    NET_TIME_EX			            stuTime;						// 事件发生的时间  
	NET_EXTENSION_INFO              stuExtensionInfo;				// 扩展信息
	BYTE                			byReserved[892];   			    //保留字节
}NET_ALARM_FIGHTDETECTION;

#define VTO_BUILDING_LEN			8
#define VTO_UNIT_LEN				8

//VTO人脸识别事件(对应事件DH_ALARM_ACCESSIDENTIFY)
typedef struct tagNET_ALARM_ACCESSIDENTIFY_INFO
{	
    NET_TIME_EX			            stuTime;						 // 事件发生的时间    
	char 							szVTOBuilding[VTO_BUILDING_LEN]; // 所属幢号
	char 							szVTOUnit[VTO_UNIT_LEN];		 // 所属单元号
	BYTE                			byReserved[1024];   			 // 保留字节
}NET_ALARM_ACCESSIDENTIFY_INFO;

//直连情况下，呼叫无答应事件(对应事件DH_ALARM_CALL_NO_ANSWERED)
typedef struct tagNET_ALARM_CALL_NO_ANSWERED_INFO
{
	NET_TIME_EX			            stuTime;						 // 事件发生的时间
	char 							szCallID[MAX_CALL_ID_LEN];		 // 呼叫ID
	int                             nAction;                   		 // 事件动作, 1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						 // 通道号
	BYTE                			byReserved[1016];   			 // 保留字节
} NET_ALARM_CALL_NO_ANSWERED_INFO;

// 非法停车事件(对应事件DH_ALARM_PARKINGDETECTION)
typedef struct tagALARM_PARKINGDETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int 							nCount;							// 规则被触发的次数
	BYTE                			byReserved[1024];   			//保留字节
} ALARM_PARKINGDETECTION_INFO;

// 人员聚集事件(对应事件DH_ALARM_RIOTERDETECTION)
typedef struct tagALARM_RIOTERDETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int 							nCount;							// 规则被触发的次数
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_RIOTERDETECTION_INFO;

// 事件类型 DH_ALARM_TRAFFIC_PARKING(交通违章停车事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_PARKING_INFO 
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_PARKING_INFO;


// 事件类型DH_ALARM_TRAFFIC_JAM(交通拥堵事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_JAM_INFO 
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_JAM_INFO;

//事件类型 DH_ALARM_TRAFFIC_PEDESTRAIN(交通行人事件)对应数据块描述信息
typedef struct tagALARM_TRAFFIC_PEDESTRAIN_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_PEDESTRAIN_INFO;

//事件类型 DH_ALARM_TRAFFIC_THROW(交通抛洒物品事件)对应数据块描述信息
typedef struct tagALARM_TRAFFIC_THROW_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_THROW_INFO;

//事件类型DH_ALARM_TRAFFIC_RETROGRADE(交通逆行事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_RETROGRADE_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_RETROGRADE_INFO;

//事件类型DH_ALARM_TRAFFIC_OVERSPEED(交通超速事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_OVERSPEED_INFO 
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int								nSpeed;							// 车速
	int								nSpeedUpperLimit;				// 速度上限
	int								nSpeedLowerLimit;				// 速度下限
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_OVERSPEED_INFO;

//事件类型DH_ALARM_TRAFFIC_UNDERSPEED(交通欠速事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_UNDERSPEED_INFO 
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int								nSpeed;							// 车速
	int								nSpeedUpperLimit;				// 速度上限
	int								nSpeedLowerLimit;				// 速度下限
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_TRAFFIC_UNDERSPEED_INFO;

//事件类型DH_ALARM_RETROGRADE_DETECTION(人员逆行事件)对应的数据块描述信息
typedef struct tagALARM_RETROGRADE_DETECTION_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID
	int 							nCount;							// 规则被触发的次数
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_RETROGRADE_DETECTION_INFO;

// AIO报警事件(对应事件DH_ALARM_AIO_APP_CONFIG_EVENT)
typedef struct tagALARM_AIO_APP_CONFIG_EVENT_INFO
{
	NET_TIME_EX			            stuTime;							// 事件发生的时间
	char 							szAddress[DH_MAX_IPADDR_LEN];		// 发布平台的的ip地址
	BYTE                			byReserved[1024];   				// 保留字节
}ALARM_AIO_APP_CONFIG_EVENT_INFO;


//事件类型DH_ALARM_BOX(报警盒子报警事件)对应的数据块描述信息
typedef struct tagALARM_BOX_INFO
{
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	int 							nAlarmBoxIndex;					// 外接多个报警盒时，表示报警盒序号。从0开始
	int								nAlarmIndex;					// 报警盒内部的通道号，从0开始
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_BOX_INFO;

// 事件类型 DH_ALARM_UNDER_VOLTAGE (低电压报警事件) 对应的数据块描述信息
typedef struct tagALARM_UNDER_VOLTAGE_INFO
{
	int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID
    BYTE                			byReserved[512];       			// 保留字节
}ALARM_UNDER_VOLTAGE_INFO;

// 事件类型 DH_ALARM_OVER_VOLTAGE (超电压报警事件) 对应的数据块描述信息
typedef struct tagALARM_OVER_VOLTAGE_INFO
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID
    BYTE                			byReserved[512];       			// 保留字节    
}ALARM_OVER_VOLTAGE_INFO;

// 事件类型 DH_ALARM_TIRED_PHYSIOLOGICAL (生理疲劳事件) 对应的数据块描述信息
typedef struct tagALARM_TIRED_PHYSIOLOGICAL
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TIRED_PHYSIOLOGICAL;


// 事件类型 DH_ALARM_CALLING_WHEN_DRIVING (开车打电话事件) 对应的数据块描述信息
typedef struct tagALARM_CALLING_WHEN_DRIVING
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_CALLING_WHEN_DRIVING;


// 事件类型 DH_ALARM_TRAFFIC_DRIVER_SMOKING (开车抽烟事件) 对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_DRIVER_SMOKING
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TRAFFIC_DRIVER_SMOKING;


// 事件类型 DH_ALARM_TRAFFIC_DRIVER_LOWER_HEAD (开车低头报警事件) 对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_DRIVER_LOWER_HEAD
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TRAFFIC_DRIVER_LOWER_HEAD;


// 事件类型 DH_ALARM_TRAFFIC_DRIVER_LOOK_AROUND (开车左顾右盼报警事件) 对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_DRIVER_LOOK_AROUND
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TRAFFIC_DRIVER_LOOK_AROUND;


// 事件类型 DH_ALARM_TRAFFIC_DRIVER_LEAVE_POST (开车离岗报警事件) 对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_DRIVER_LEAVE_POST
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TRAFFIC_DRIVER_LEAVE_POST;


// 事件类型 DH_ALARM_TRAFFIC_DRIVER_YAWN (开车打哈欠报警事件) 对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_DRIVER_YAWN
{
    int                             nAction;                   		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID

	NET_GPS_STATUS_INFO				stuGPSStatus;					// GPS信息
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_TRAFFIC_DRIVER_YAWN;

// 车辆位置报警事件(DH_ALARM_TRAFFIC_VEHICLE_POSITION)
typedef struct tagALARM_TRAFFIC_VEHICLE_POSITION
{
	int             nAction;                   						// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	char			szEventName[DH_COMMON_STRING_128];				// 事件名称
	unsigned int	nObjectID;										// 物体ID
	char			szPlateNumber[DH_COMMON_STRING_128];									// 车牌号
	int				nPosition;										// 识别车牌与卡口抓拍线的相对距离(0为基准，表示视频抓拍卡口位置时的车牌距离；正数表示越过抓拍线；负数表示未越过抓拍线)
	BYTE            byOpenStrobeState;                              // 开闸状态,具体请见 EM_OPEN_STROBE_STATE 
	BYTE			byReserved[511];       							// 保留字节  
} ALARM_TRAFFIC_VEHICLE_POSITION;

// 事件类型 DH_ALARM_MPTBASE_CONNECT (设备与底座连接状态事件) 对应的数据块描述信息
typedef struct tagALARM_MPTBASE_CONNECT
{
    int                             nAction;                        // 事件动作, 1 表示持续性事件开始, 2 表示持续性事件结束
    BYTE                            byReserved[512];                // 保留字节 
} ALARM_MPTBASE_CONNECT;

// 关机原因
typedef enum tagEM_SHUTDOWN_REASON_TYPE
{
    EM_SHUTDOWN_REASON_UNKNOWN,                 // 未知
    EM_SHUTDOWN_REASON_LOWERPOWER,              // 低电量
    EM_SHUTDOWN_REASON_LOSTPOWER,               // 突然掉电
    EM_SHUTDOWN_REASON_CRASH,                   // 系统崩溃
} EM_SHUTDOWN_REASON_TYPE;

// 事件类型DH_ALARM_CGIRECORD,对应CGI触发手动录像
typedef struct tagALARM_CGIRECORD
{
    int                             nAction;                   		// 事件动作,1表示事件开始,2表示事件结束;
    int                             nChannelID;						// 录像通道号
    double                          dbPTS;							// 时间戳(单位是毫秒)	
    NET_TIME_EX                     stuTime;						// 事件发生的时间    
    int                             nEventID;						// 事件ID
	NET_TIME_EX                     stuStartTime;					// 录像开始时间
	NET_TIME_EX                     stuStopTime;					// 录像结束时间	
	BYTE                            byReserved[512];				// 保留字节		 
} ALARM_CGIRECORD;

// 电池温度上报事件信息，对应DH_ALARM_BATTERY_TEMPERATURE
typedef struct tagALARM_BATTERY_TEMPERATURE_INFO
{
	int					nBatteryIndex;                // 电池序号
	NET_TIME_EX			stuTime;                      // 事件时间
	float				fTemperature;				  // 电池的温度值,单位:°C
	BYTE				byReserved[1024];			  // 保留字节
}ALARM_BATTERY_TEMPERATURE_INFO;

// 事件类型 DH_ALARM_TIRE_PRESSURE ,对应胎压事件上报
typedef struct tagALARM_TIRE_PRESSURE_INFO
{
    int                             nAction;                   		// 事件动作,1表示事件开始,2表示事件结束;
    int                             nEventID;						// 事件ID    
    double                          dbPTS;							// 时间戳(单位是毫秒)	
    NET_TIME_EX                     stuTime;						// 事件发生的时间

    int                             nTireIndex;						// 轮胎编号,从1开始
    int                             nAlarmType;                     // 报警类型,1-低压报警,2-高压报警
    float                           fUpperLimit;					// 胎压上限,单位BAR
    float                           fLowerLimit;					// 胎压下限,单位BAR
    float                           fCurrentPressure;               // 当前胎压,单位BAR
    BYTE                            byReserved[512];				// 保留字节		 
} ALARM_TIRE_PRESSURE_INFO;

// 门禁黑名单刷卡事件,对应 DH_ALARM_ACCESS_CTL_BLACKLIST
typedef struct tagALARM_ACCESS_CTL_BLACKLIST
{
    int                             nChannel;                                          // 门通道号
    char                            szAccessName[DH_COMMON_STRING_64];                 // 门禁名称
    char                            szUserID[DH_COMMON_STRING_32];                     // 用户ID
    char                            szCardNo[DH_COMMON_STRING_64];                     // 黑名单卡号
    char                            szCitizenIDNo[20];                                 // 身份证号
    BYTE                			byReserved[512];       			                   // 保留字节 
}ALARM_ACCESS_CTL_BLACKLIST;

// 未授权卡恶意刷卡事件, 对应 DH_ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP
typedef struct tagALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP
{
    int                             nChannel;                           // 门通道号
    char                            szDoorName[DH_MAX_DOORNAME_LEN];    // 门禁名称
    char						    szUserID[MAX_COMMON_STRING_16];		// 用户ID
    char                            szCardNo[DH_COMMON_STRING_64];      // 卡号
    NET_TIME_EX			            stuTime;						    // 事件发生的时间
    BYTE                			byReserved[476];  
}ALARM_ACCESS_CTL_UNAUTHORIZED_MALICIOUSWIP;

// 用户锁定报警事件,对应 DH_ALARM_USERLOCK
typedef struct tagALARM_USERLOCK_INFO
{	
	double				            dbPTS;							// 时间戳(单位是毫秒)
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	int					            nEventID;						// 事件ID
	
	char							szUserName[MAX_USER_NAME_LEN];  // 用户名
	char							szGroup[MAX_GROUP_LEN];			// 组名
	char							szIllegalLoginIP[MAX_ILLEGAL_LOGIN_IP_LEN];	// 非法登录的IP
	BYTE                            byReserved[1024];				// 保留字节		
}ALARM_USERLOCK_INFO;

// 下载远程文件事件,对应 DH_ALARM_DOWNLOAD_REMOTE_FILE
typedef struct tagALARM_DOWNLOAD_REMOTE_FILE_INFO
{	
	double				            dbPTS;							// 时间戳(单位是毫秒)
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	int					            nEventID;						// 事件ID
	
	char							szURL[DH_COMMON_STRING_256];	// 下载文件对应的URL地址
	UINT							nProgress;						// 下载进度[0,100]		
	UINT							nVelocity;						// 下载平均速度, 单位: Kb/s
	BYTE                            byReserved[1016];				// 保留字节		
}ALARM_DOWNLOAD_REMOTE_FILE_INFO;

// 冲突信息
typedef struct tagNET_CONFLICT_INFO 
{
	char							szSlaveMac[DH_COMMON_STRING_32];	// 分配器MAC地址
	int								nSlaveID;							// 分配器ID
	int								nSlavePort;							// 室内机位于分配器的端口号
	BYTE							byReserved[64];						// 保留字节
} NET_CONFLICT_INFO;

// 冲突信息最大数量
#define	MAX_COUNT_CONFLICT	16

// 事件类型 DH_ALARM_VTH_CONFLICT, 对应房间号冲突上报事件
typedef struct tagALARM_VTH_CONFLICT_INFO 
{
    int                             nAction;                   			// 事件动作,0表示脉冲事件,1表示事件开始,2表示事件结束;	
	int                             nEventID;							// 事件ID    
    double                          dbPTS;								// 时间戳(单位是毫秒)
    NET_TIME_EX                     stuTime;							// 事件发生的时间
	
	int								nConflictNum;						// 冲突数量
	NET_CONFLICT_INFO				stConflictInfo[MAX_COUNT_CONFLICT];	// 冲突信息
	char							szVTNCNum[DH_COMMON_STRING_32];		// 单元联网控制器号码/门口机号码
	char							szVTHNum[DH_COMMON_STRING_32];		// 房间号
	BYTE                            byReserved[512];					// 保留字节	
} ALARM_VTH_CONFLICT_INFO;

// 事件类型DH_ALARM_LATEST_SHUTDOWN (设备上次关机状态事件) 对应的数据块描述信息
typedef struct tagALARM_LATEST_SHUTDOWN
{
	EM_SHUTDOWN_REASON_TYPE			emShutdownReason;				// 关机原因		
	BYTE                			byReserved[512];       			// 保留字节 
} ALARM_LATEST_SHUTDOWN;

// 事件类型DH_ALARM_DISTANCE_DETECTION (异常间距事件) 对应的数据块描述信息
typedef struct tagALARM_DISTANCE_DETECTION_INFO
{
	int                             nAction;                   			// 事件动作,0表示脉冲事件,1表示事件开始,2表示事件结束;	
	int                             nEventID;							// 事件ID    
    double                          dbPTS;								// 时间戳(单位是毫秒)
    int								nChannel;							// 通道号
    NET_TIME_EX                     stuTime;							// 事件发生的时间
	int								nPresetID;							// 事件触发的预置点
	BYTE                			byReserved[508];       				// 保留字节
} ALARM_DISTANCE_DETECTION_INFO;

// 事件类型DH_ALARM_STAY_DETECTION (停留事件) 对应的数据块描述信息
typedef struct tagALARM_STAY_DETECTION_INFO
{
	int                             nAction;                   			// 事件动作,0表示脉冲事件,1表示事件开始,2表示事件结束;	
	int                             nEventID;							// 事件ID    
    double                          dbPTS;								// 时间戳(单位是毫秒)
	int								nChannel;							// 通道号
	NET_TIME_EX                     stuTime;							// 事件发生的时间
    int								nGroupId;							// 事件组ID，同一物体抓拍过程内GroupID相同
    int								nCountInGroup;						// 一个事件组内的抓拍张数
    int								nIndexInGroup;						// 一个事件组内的抓拍序号，从1开始
    int								nCount;								// 规则被触发生次数
	int								nPresetID;							// 事件触发的预置点
	BYTE                			byReserved[508];       				// 保留字节
} ALARM_STAY_DETECTION_INFO;

// 事件类型 DH_ALARM_AUTO_INSPECTION (设备自检事件) 对应的数据块描述信息
typedef struct tagALARM_AUTO_INSPECTION
{
	double				            dbPTS;							// 时间戳(单位是毫秒)
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	int					            nEventID;						// 事件ID

	NET_TIME_EX						stuStartTime;					// 设备开始自检时间
	BOOL							bCheckResult;					// 设备自检结果,FALSE为失败,TRUE为成功
	BYTE							byReserved[1024];				// 保留字节
}ALARM_AUTO_INSPECTION;

// 事件类型
typedef enum tagEM_FACE_VERIFICATION_ACCESS_SNAP_TYPE
{
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_UNKNOWN,			// 未知类型
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_ENTRY,			// 进门
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE_EXIT,				// 出门
}EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE;

// 人脸信息
typedef struct tagNET_PERSON_INFO
{
	BOOL			bCheckResult;					// 人脸比对结果,成功为TRUE,失败为FALSE
	char			szName[MAX_NAME_LENGTH];			// 姓名,比对成功时有效
	char			szSnapURL[MAX_SNAP_URL_LEN];    // 人脸抓图地址
	BYTE			byReserved[512];				// 保留字节
}NET_PERSON_INFO;

// 物品信息
typedef struct tagNET_GOOD_INFO
{
	char			szCode[MAX_CODE_LEN];			    // 物品编号
	char			szSnapURL[MAX_SNAP_URL_LEN];		// 物品抓图地址
	BYTE			byReserved[512];				    // 保留字节
}NET_GOOD_INFO;

// 操作类型
typedef enum tagEM_OPERATION_TYPE
{
	EM_OPERATION_TYPE_UNKNOWN,					// 未知操作
	EM_OPERATION_TYPE_FETCH,                    // 取物品
	EM_OPERATION_TYPE_STORE,					// 存物品
	EM_OPERATION_TYPE_EXCHANGE,					// 换物品
	EM_OPERATION_TYPE_CHECK,					// 检查					
}EM_OPERATION_TYPE;

// 事件类型 DH_ALARM_FACE_VERIFICATION_ACCESS_SNAP（人脸认证开门抓图信息事件）对应的数据块描述信息
typedef struct tagALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO
{
	double										dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX									stuTime;								// 事件发生的时间
	int											nEventID;								// 事件ID

	int											nRecNo;									// 记录编号，与AccessControl事件中的记录编号一致 	
	EM_FACE_VERIFICATION_ACCESS_SNAP_TYPE       emEventType;							// 事件类型
	NET_PERSON_INFO								stuPersonInfo[MAX_PERSON_INFO_NUM];		// 人脸信息
	int											nRetPersonInfoNum;						// 返回的人脸信息个数
	NET_GOOD_INFO								stuGoodInfo[MAX_GOOD_INFO_NUM];			// 物品信息
	int											nRetGoodInfoNum;						// 返回的物品信息个数
	EM_OPERATION_TYPE							emOperation;							// 操作类型
	BYTE										byReserved[1020];						// 保留字节
}ALARM_FACE_VERIFICATION_ACCESS_SNAP_INFO;

// 事件类型DH_ALARM_VIDEOBLIND(视频遮挡事件)对应的数据块描述信息
typedef struct  tagALARM_VIDEO_BLIND_INFO
{
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						// 通道号
    double				            dbPTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    int					            nEventID;						// 事件ID
	NET_TIME_EX						stuStartTime;					// 开始时间,nAction为2时上报此字段
	NET_GPS_STATUS_INFO				stuGPS;							// GPS信息
    BYTE                			byReserved[1024];       		// 保留字节    
} ALARM_VIDEO_BLIND_INFO;

// 事件类型DH_ALARM_DRIVER_NOTCONFIRM (司机未按确认按钮报警事件)对应的数据块描述信息
typedef struct tagALARM_DRIVER_NOTCONFIRM_INFO
{
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    NET_TIME_EX			            stuTime;						// 事件发生的时间
	double				            dbPTS;							// 时间戳(单位是毫秒)
    BYTE                			byReserved[512];       			// 保留字节    
} ALARM_DRIVER_NOTCONFIRM_INFO;

// 事件类型 DH_ALARM_VIOLATE_NO_FLY_TIME (违法禁飞事件) 对应的数据块描述信息
typedef struct tagALARM_VIOLATE_NO_FLY_TIME_INFO
{   
    int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    NET_TIME_EX			            stuTime;						// 事件发生的时间
    double				            dbPTS;							// 时间戳(单位是毫秒)

    BYTE                			byReserved[512];       			// 保留字节  
}ALARM_VIOLATE_NO_FLY_TIME_INFO;

//事件类型 DH_ALARM_BOX_ALARM (报警盒通道的触发报警事件)对应的数据块描述信息
typedef struct tagALARM_BOX_ALARM_INFO
{
    int                             nAction;                   		    // 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    int					            nChannelID;						    // 通道号
    double				            dbPTS;							    // 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;						    // 事件发生的时间
    int					            nEventID;						    // 事件ID
	char                            szAlarmChannelName[DH_COMMON_STRING_64];   // 报警通道名称
	int								nAlarmBoxIndex;						// 外接多个报警盒时，表示报警盒序号,从0开始
	int								nAlarmIndex;						// 报警盒内部的通道号，从0开始
    BYTE                			byReserved[1016];   			    // 保留字节
}ALARM_BOX_ALARM_INFO;

// 事件类型 DH_ALARM_SOSALERT
typedef struct tagALARM_SOSALERT_INFO
{
	int								nChannelID;								// 通道号
	int								nEventID;								// 事件ID
	double							dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX						stuTime;								// 事件发生时间

	char							szPlateNumber[DH_COMMON_STRING_128];	// 车牌内容
	NET_GPS_STATUS_INFO 			stGPSStatusInfo;						// GPS信息	
	BYTE							byReserved[1024];						// 保留字节
}ALARM_SOSALERT_INFO;

// 事件类型 DH_ALARM_GYROABNORMALATTITUDE
typedef struct tagALARM_GYROABNORMALATTITUDE_INFO
{
	int								nAction;								// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	int								nChannelID;								// 通道号
	double							dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX						stuTime;								// 事件发生时间
	int								nEventID;								// 事件ID

	double							dbGyroCurRoll;							// 当前翻滚角，单位：度
	double							dbGyroCurPitch;							// 当前俯仰角，单位：度
	double							dbGyroCurAccel;							// 当前加速度，单位：m/s^2
	BYTE							byReserved[1024];						// 保留字段
}ALARM_GYROABNORMALATTITUDE_INFO;

//事件类型DH_ALARM_ALARMOUTPUT(输出通道状态改变事件)对应的数据块描述信息
typedef struct tagALARM_ALARMOUTPUT_INFO
{
	int 							nAction;								//事件动作,1:Start 2:Stop
	NET_TIME_EX						UTC;									//事件发生时间
	int								nChannel;								//通道号
}ALARM_ALARMOUTPUT_INFO;

//事件类型DH_ALARM_PSTNREPORTFAILURE(电话报警未接警事件)对应的数据块描述信息
typedef struct tagALARM_PSTNREPORTFAILURE_INFO
{
	NET_TIME_EX 					UTC;								//事件发生的时间
}ALARM_PSTNREPORTFAILURE_INFO;

//无线网络通讯错误类型
typedef enum tagGSMFIELD_FAULT_TYPE
{
	GSMFIELD_FAULT_UNKNOWN,				//未知
	GSMFIELD_FAULT_GSMModule,			//通信模块掉线
	GSMFIELD_FAULT_SIMCard,				//未插SIM卡
}GSMFIELD_FAULT_TYPE;
//事件类型DH_ALARM_NOGSMFIELD(通信模块掉线或者sim没插事件)对应数据块描述信息
typedef struct tagALARM_NOGSMFIELD_INFO
{
	int								nAction;			// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX 					UTC;				// 事件发生时间
	GSMFIELD_FAULT_TYPE			emFaultType;		// 通讯错误类型
}ALARM_NOGSMFIELD_INFO;
//事件类型DH_ALARM_MOTION_RECORD_ALARM(动检录像报警事件)对应数据块描述信息
typedef struct tagALARM_MOTION_RECORD_INFO
{
    int								nAction;			// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    int                             nChannel;           // 通道
    BOOL                            bMotionIsOpen;      // 是否处于动检状态
    BOOL                            bRecordIsOpen;      // 是否处于录像状态
    BYTE                			byReserved[512];    // 保留字节 
}ALARM_MOTION_RECORD_INFO;

// 事件类型DH_ALARM_FACEINFO_COLLECT (人脸信息录入事件)对应的数据块描述信息
typedef struct tagALARM_FACEINFO_COLLECT_INFO
{
	
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    NET_TIME_EX			            stuTime;						// 事件发生的时间
	double				            dbPTS;							// 时间戳(单位是毫秒)
	char							szUserID[DH_MAX_USERID_LEN];	// 用户ID
	BYTE                			byReserved[512];       			// 保留字节    
} ALARM_FACEINFO_COLLECT_INFO;

// 事件类型DH_ALARM_HIGH_SPEED (车辆超速报警事件)对应的数据块描述信息
typedef struct tagALARM_HIGH_SPEED_INFO
{
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    NET_TIME_EX			            stuTime;						// 事件发生的时间
	double				            dbPTS;							// 时间戳(单位是毫秒)	
    NET_GPS_STATUS_INFO 			stGPSStatusInfo;                // GPS信息
	int								nSpeedLimit;					// 车连限速值km/h
	int								nCurSpeed;						// 当前车辆速度km/h
	int								nMaxSpeed;					    // 最高速度Km/h
	NET_TIME_EX						stuStartTime;					// 开始时间,nAction为2时上报此字段
	BYTE                			byReserved[472];       			// 保留字节    
} ALARM_HIGH_SPEED_INFO;

// 事件类型DH_ALARM_VIDEO_LOSS (视频丢失事件)对应的数据块描述信息
typedef struct tagALARM_VIDEO_LOSS_INFO
{
	int                             nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;						// 通道号
	double				            dbPTS;							// 时间戳(单位是毫秒)	
	BYTE							byReserved1[4];					// 字节对齐
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	NET_TIME_EX						stuStartTime;					// 开始时间,nAction为2时上报此字段
	NET_GPS_STATUS_INFO				stuGPS;							// GPS信息
	BYTE                			byReserved[1024];       		// 保留字节    
} ALARM_VIDEO_LOSS_INFO;

// 事件类型 DH_ALARM_SMARTHOME_GET_AUTHORIZED (室内机告知平台获取授权二维码信息)对应的数据块描述信息
typedef	struct tagALARM_SMARTHOME_GET_AUTHORIZED
{	
	int								nAction;						// 0:脉冲 1:开始 2:停止
	NET_TIME_EX			            UTC;							// 事件发生的时间
	char							byReserved[1024];				// 预留字节
}ALARM_SMARTHOME_GET_AUTHORIZED;


// 事件类型 DH_ALARM_SMARTHOME_UPDATE_SCENE	(室内机告知平台需要更新智能家居场景列表)对应的数据块描述信息
typedef struct tagALARM_SMARTHOME_UPDATE_SCENE
{
	int								nAction;						// 0:脉冲 1:开始 2:停止
	NET_TIME_EX			            UTC;							// 事件发生的时间
	char							byReserved[1024];				// 预留字节
}ALARM_SMARTHOME_UPDATE_SCENE;

// ASG 报警类型
typedef enum tagEM_ASG_ALARM_TYPE
{
	EM_ASG_ALARM_BREAK_UNKNOWN,										// 未知
	EM_ASG_ALARM_BREAK_DOWN,										// 故障
	EM_ASG_ALARM_ANTI_DEMOLITION,									// 防拆
	EM_ASG_ALARM_FOLLOW,											// 尾随
	EM_ASG_ALARM_TIMEOUT,											// 超时
	EM_ASG_ALARM_STAY,												// 逗留
	EM_ASG_ALARM_FORCIBLY_OPEN,										// 强行打开闸机
	EM_ASG_ALARM_MISTAKENLY_ENTER,									// 误闯
	EM_ASG_ALARM_REVERSE_ENTER,										// 逆闯
	EM_ASG_ALARM_CLIMB,												// 翻越
}EM_ASG_ALARM_TYPE;


// 事件类型 DH_ALARM_ASG (ASG报警)对应的数据块描述信息
typedef struct tagALARM_ASG_INFO
{
	int								nAction;						// 0:脉冲 1:开始 2:停止
	int					            nChannelID;						// 通道号
	NET_TIME_EX			            UTC;							// 事件发生的时间
	EM_ASG_ALARM_TYPE				emAlarmType;					// 报警类型
	char							byReserved[1024];				// 预留字节
}ALARM_ASG_INFO;

// 事件类型 DH_ALARM_ASGSTAY (闸机滞留报警事件) 对应的数据块描述信息
typedef struct tagALARM_ASGSTAY_INFO
{
    int                             nAction;                        // 0:脉冲 1:开始 2:停止
    int                             nChannelID;                     // 通道号
    NET_TIME_EX                     UTC;                            // 事件发生的时间
    char                            byReserved[1020];               // 预留字节
} ALARM_ASGSTAY_INFO;

// 事件类型 DH_ALARM_ASGFOLLOWING (闸机尾随报警事件) 对应的数据块描述信息
typedef struct tagALARM_ASGFOLLOWING_INFO
{
    int                             nAction;                        // 0:脉冲 1:开始 2:停止
    int                             nChannelID;                     // 通道号
    NET_TIME_EX                     UTC;                            // 事件发生的时间
    char                            byReserved[1020];               // 预留字节
} ALARM_ASGFOLLOWING_INFO;

// 事件类型 DH_ALARM_ASGCLIMBOVER (闸机翻越报警事件) 对应的数据块描述信息
typedef struct tagALARM_ASGCLIMBOVER_INFO
{
    int                             nAction;                        // 0:脉冲 1:开始 2:停止
    int                             nChannelID;                     // 通道号
    NET_TIME_EX                     UTC;                            // 事件发生的时间
    char                            byReserved[1020];               // 预留字节
} ALARM_ASGCLIMBOVER_INFO;

// 报警类型
typedef enum tagEM_ASGBREAKDOWN_ALARM_TYPE
{
    EM_ASGBREAKDOWN_ALARM_TYPE_UNKNOWN,                             // 未知
    EM_ASGBREAKDOWN_ALARM_TYPE_INFRARED,                            // 红外
    EM_ASGBREAKDOWN_ALARM_TYPE_COMMUNICATION,                       // 通讯
    EM_ASGBREAKDOWN_ALARM_TYPE_DOOR_WING,                           // 门翼
} EM_ASGBREAKDOWN_ALARM_TYPE;

// 事件类型 DH_ALARM_ASGBREAKDOWN (闸机故障事件) 对应的数据块描述信息
typedef struct tagALARM_ASGBREAKDOWN_INFO
{
    int                             nAction;                        // 0:脉冲 1:开始 2:停止
    int                             nChannelID;                     // 通道号
    NET_TIME_EX                     UTC;                            // 事件发生的时间
    EM_ASGBREAKDOWN_ALARM_TYPE      emAlarmType;                    // 报警类型
    char                            byReserved[1016];               // 预留字节
} ALARM_ASGBREAKDOWN_INFO;

#define  VTS_STATE_LONGNUMBER_LEN	24
// VTS
typedef enum tagVTS_STATE
{
    EM_VTS_STATE_UNKNOWN = 0	, 
	EM_VTS_STATE_BUSY			,								// "Busy" 忙碌
	EM_VTS_STATE_IDLE			,								// "Idle" 空闲
}VTS_STATE;

// VTS状态上报
typedef struct tagALARM_VTSTATE_UPDATE_INFO
{
	int					            nChannelID;						// 通道号
    NET_TIME			            stuTime;						// 事件发生的时间
	VTS_STATE						emState;						// 设备对讲状态
	char							szLongNum[VTS_STATE_LONGNUMBER_LEN];	// 长号
	BYTE                			byReserved[1024];   			// 保留字节
} ALARM_VTSTATE_UPDATE_INFO;

// 事件类型DH_ALARM_VIDEO_TALK_PATH(对讲路径事件)对应的数据块描述信息
typedef struct tagALARM_VIDEO_TALK_PATH_INFO
{
	int                             nAction;                   			// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					            nChannelID;							// 通道号
	double				            dbPTS;								// 时间戳(单位是毫秒)
    NET_TIME_EX			            stuTime;							// 事件发生的时间
	char							szSrcDevID[DH_COMMON_STRING_128];	// 呼叫源设备唯一ID(ID取值参照DevList配置)
	char							szDstDevID[DH_COMMON_STRING_128];	// 呼叫目的设备唯一ID(ID取值参照DevList配置)
	BYTE                			byReserved[1024];   				// 保留字节							
} ALARM_VIDEO_TALK_PATH_INFO;


//警戒区事件(对应事件 DH_EVENT_CROSSREGION_DETECTION)
typedef struct tagALARM_EVENT_CROSSREGION_INFO
{
    DWORD                           dwSize;    
    int					            nChannelID;						// 通道号
    double				            PTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			            UTC;							// 事件发生的时间
	int					            nEventID;						// 事件ID
    int                             nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    NET_CROSSREGION_DIRECTION_INFO  emDirection;                    // 警戒区入侵方向
    NET_CROSSREGION_ACTION_INFO     emActionType;                   // 警戒区检测动作类型
    int                             nOccurrenceCount;               // 规则被触发生次数
    int                             nLevel;                         // 事件级别,GB30147需求项
	char							szName[DH_COMMON_STRING_128];   // 名称
	BOOL							bIsObjectInfo;					// 是否检测到物体信息
	DH_MSG_OBJECT			        stuObject;                      // 检测到的物体信息
	int								nRetObjectNum;						// 实际返回多个检测到的物体信息 
	DH_MSG_OBJECT			        stuObjects[MAX_TARGET_OBJECT_NUM];  // 多个检测到的物体信息
}ALARM_EVENT_CROSSREGION_INFO;


//物品遗留事件(对应事件 DH_EVENT_LEFT_DETECTION)
typedef struct tagALARM_EVENT_LEFT_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// 通道号
    double				PTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			UTC;							// 事件发生的时间
    int					nEventID;						// 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    
    int                 nOccurrenceCount;               // 规则被触发生次数
    int                 nLevel;                         // 事件级别,GB30147需求项
	short				nPreserID;						// 事件触发的预置点号，从1开始（没有表示未知）
	char				szPresetName[64];				// 事件触发的预置名称
}ALARM_EVENT_LEFT_INFO;

//人脸检测事件(对应事件 DH_EVENT_FACE_DETECTION)
typedef struct tagALARM_EVENT_FACE_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// 通道号
    double				PTS;							// 时间戳(单位是毫秒)
    NET_TIME_EX			UTC;							// 事件发生的时间
    int					nEventID;						// 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
}ALARM_EVENT_FACE_INFO;

   
//IPC报警,IPC通过DVR或NVR上报的本地报警(对应事件 DH_ALARM_IPC)
typedef struct tagALARM_IPC_INFO
{
    DWORD               dwSize;    
    int					nChannelID;						// 通道号
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX			UTC;							// 事件发生的时间
	char				szName[MAX_ALARM_CHANNEL_NAME_LEN];	// 报警通道名称 
}ALARM_IPC_INFO;


// NAS文件任务类型
typedef enum tagNASFILE_STATUS_TYPE
{
	EM_NASFILE_STATUS_TYPE_UNKNOW,
    EM_NASFILE_STATUS_TYPE_COPY,   //拷贝
    EM_NASFILE_STATUS_TYPE_MOVE,   //移动
}NASFILE_STATUS_TYPE;

// NAS文件任务状态
typedef enum tagNASFILE_STATUS_STATE
{
	EM_NASFILE_STATUS_STATE_UNKNOW,
    EM_NASFILE_STATUS_STATE_FAILED,    	 //失败
    EM_NASFILE_STATUS_STATE_SUCCESSED,   //成功
}NASFILE_STATUS_STATE;


// NAS文件状态事件(对应事件 DH_ALARM_NASFILE_STATUS)
typedef struct tagALARM_NASFILE_STATUS_INFO
{
	double						dbPTS;															// 时间戳(单位是毫秒)
	NET_TIME_EX					stuTime;														// 事件发生的时间
	NASFILE_STATUS_STATE		emTaskState;													// 任务状态
	char						szTaskID[DH_COMMON_STRING_128];									// 任务ID
	NASFILE_STATUS_TYPE			emTaskType;														// 文件任务类型
	int							nSrcNum;														// 源文件(夹)数量
    char						szSrcList[MAX_NASFILE_NUM][DH_COMMON_STRING_128];				// 源文件(夹)名列表               
	char                        szDstPath[DH_COMMON_STRING_128];								// 目的路径
    int							nProgress;														// 任务进度
    BYTE                		byReserved[1028];												// 保留字节
} ALARM_NASFILE_STATUS_INFO;

// 设备呼叫中取消呼叫事件(对应事件 DH_ALARM_TALKING_CANCELCALL)
typedef struct tagALARM_TALKING_CANCELCALL_INFO
{
    NET_TIME_EX					stuTime;														// 事件发生的时间
    char                        szCallID[DH_COMMON_STRING_32];                                  // 呼叫ID                   
}ALARM_TALKING_CANCELCALL_INFO;

// 人群密度检测事件(对应事件 DH_ALARM_CROWD_DETECTION)
typedef struct tagALARM_CROWD_DETECTION_INFO
{ 
	int					  nChannelID;							// 通道号
	int					  nEventID;								// 事件ID
	double				  PTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX			  UTC;									// 事件发生的时间
	int                   nEventAction;							// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	EM_ALARM_TYPE		  emAlarmType;							// 报警业务类型
	char				  szName[MAX_CROWD_DETECTION_NAME_LEN];	// 事件名称
	int					  nCrowdListNum;						// 返回的全局拥挤人群密度列表个数 
	int					  nRegionListNum;						// 返回的人数超限的报警区域ID列表个数 
	NET_CROWD_LIST_INFO	  stuCrowdList[MAX_CROWD_LIST_NUM];		// 全局拥挤人群密度列表信息
	NET_REGION_LIST_INFO  stuRegionList[MAX_REGION_LIST_NUM];	// 人数超限的报警区域ID列表信息
	NET_EXTENSION_INFO    stuExtensionInfo;				        // 扩展信息
	BYTE				  byReserved[896];						// 保留扩展字节
}ALARM_CROWD_DETECTION_INFO;

// 计算特征向量结果
typedef enum tagEM_ABSTRACT_STATE
{
	EM_ABSTRACT_UNKNOWN,		// 未知
	EM_ABSTRACT_SUCCESS,		// 重建成功
	EM_ABSTRACT_FALSE,			// 重建失败
	EM_ABSTRACT_PROCESS,		// 重建过程中(仅针对GroupID)
} EM_ABSTRACT_STATE;


//特征建模失败错误码
typedef enum tagEM_FEATURE_ERROR_CODE
{
	EM_FEATURE_ERROR_SUCCESS,			                // 成功
	EM_FEATURE_ERROR_UNKNOWN,			                // 未知
	EM_FEATURE_ERROR_IMAGE_FORMAT_ERROR,			    // 图片格式问题
	EM_FEATURE_ERROR_NOFACE_OR_NOTCLEAR,		        // 无人脸或不够清晰 
	EM_FEATURE_ERROR_MULT_FACES,	            		// 多个人脸 
	EM_FEATURE_ERROR_IMAGH_DECODE_FAILED,		    	// 图片解码失败 
	EM_FEATURE_ERROR_NOT_SUGGEST_STORAGE,		        // 不推荐入库 
	EM_FEATURE_ERROR_DATABASE_OPERATE_FAILED,			// 数据库操作失败 
	EM_FEATURE_ERROR_GET_IMAGE_FAILED,			        // 获取图片失败 
	EM_FEATURE_ERROR_SYSTEM_EXCEPTION,		            // 系统异常（如Licence失效、建模分析器未启动导致的失败）
}EM_FEATURE_ERROR_CODE;


// 人脸特征向量重建结果信息
typedef struct tagFACE_FEATURE_ABSTRACT_INFO
{
	EM_ABSTRACT_STATE			emAbstractState;						// 计算特征向量结果
	int							nProcess;								// 人员组重建进度,百分比
	char						szUID[DH_MAX_PERSON_ID_LEN];			// 重建完成的人员编号, IVSS支持
	char						szGroupId[DH_COMMON_STRING_64]; 		// 重建完成的人员组ID, IPC支持
	UINT						nSucceedCnt;							// 人员组建模成功的个数，IPC支持
	UINT						nFailedCnt;								// 人员组建模失败的个数，IPC支持
	EM_FEATURE_ERROR_CODE		emFeatureError;							// 建模失败记录的错误原因(当FailedCnt大于0时有效)；IPC支持
	BYTE						byReserved[500];						// 保留扩展字节
} FACE_FEATURE_ABSTRACT_INFO;

// 人脸特征向量重建结果事件(对应事件DH_ALARM_FACE_FEATURE_ABSTRACT)
typedef struct tagALARM_FACE_FEATURE_ABSTRACT_INFO
{
	int					  		nEventID;								// 事件ID
	NET_TIME_EX			  		UTC;									// 事件发生的时间
	double				  		PTS;									// 时间戳(单位是毫秒)
	BYTE						byReserved1[4];							// 字节对齐
	int							nRetAbstractInfo;						// 实际返回的人脸特征向量重建结果个数
	FACE_FEATURE_ABSTRACT_INFO	stuAbstractInfo[MAX_ABSTRACT_INFO_NUM];	// 人脸特征向量重建结果
	BYTE				  		byReserved[512];						// 保留扩展字节
} ALARM_FACE_FEATURE_ABSTRACT_INFO;

// 录像计划改变事件(对应事件 DH_ALARM_RECORD_SCHEDULE_CHANGE)
typedef struct tagALARM_RECORD_SCHEDULE_CHANGE_INFO 
{
	int						nChannelID;								// 通道号
	int						nEventID;								// 事件ID
	double					dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX				stuTime;								// 事件发生的时间					
	int						nEventAction;							// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	char					szUser[DH_COMMON_STRING_128];			// 操作用户
	BYTE					byReserved[1024];						// 保留字节
} ALARM_RECORD_SCHEDULE_CHANGE_INFO;

// NTP配置修改事件(对应事件 DH_ALARM_NTP_CHANGE)
typedef struct tagALARM_NTP_CHANGE_INFO 
{
	int						nEventID;								// 事件ID
	int						nEventAction;							// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	double					dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX				stuTime;								// 事件发生的时间		
	char					szUser[DH_COMMON_STRING_128];			// 操作用户
	BYTE					byReserved[1028];						// 保留扩展字节
} ALARM_NTP_CHANGE_INFO;

//Raid同步状态
typedef enum tagEM_RAID_SYNC_STATE
{
	EM_RAID_SYNC_STATE_UNKNOWN = -1,                                // 未知
	EM_RAID_SYNC_STATE_SELFADAPTION,                                // 自适应(默认值)
	EM_RAID_SYNC_STATE_SYNCPRIORITY,                                // 同步优先，I/O优先分给Raid同步
	EM_RAID_SYNC_STATE_BUSINESSPRIORITY,                            // 业务优先，I/O优先分给硬盘写数据
	EM_RAID_SYNC_STATE_EQUILIBRIUM,                                 // 均衡
}EM_RAID_SYNC_STATE;

//硬盘Smart信息
typedef struct tagNET_HDDSMART_INFO
{
	int                             nID;                            // 属性ID
	int                             nCurrent;                       // 属性值
	char                            szName[DH_COMMON_STRING_64];    // 属性名	
	int                             nWorst;                         // 最大出错值
	int                             nThreshold;                     // 阈值
	char                            szRaw[DH_COMMON_STRING_32];     // 实际值,可能不仅是数字，需要字符串返回
	int                             nPredict;                       // 状态,对硬盘状态的预测值,无实际意义
	EM_RAID_SYNC_STATE              emSync;                         // Raid同步状态
	BYTE                			byReserved[512];       			// 保留字节 
}NET_HDDSMART_INFO;

//硬盘温度报警事件( DH_ALARM_HDD_TEMPERATUREALARM )
typedef struct tagALARM_HDD_TEMPERATUREALARM_INFO
{
	int                             nAction;                   		// 事件动作1:Start 2:Stop
	int                             nTemperature;                   // 硬盘当前温度值
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	char                 			szHDDName[DH_COMMON_STRING_64];	// 硬盘名称
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // 硬盘Smart信息
	BYTE                			byReserved[512];       			// 保留字节 
}ALARM_HDD_TEMPERATUREALARM_INFO;

//硬盘震动报警事件( DH_ALARM_HDD_SHAKEALARM )
typedef struct tagALARM_HDD_SHAKEALARM_INFO
{
	int                             nAction;                   		// 事件动作1:Start 2:Stop
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	char                 			szHDDName[DH_COMMON_STRING_64];	// 硬盘名称
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // 硬盘Smart信息
	BYTE                			byReserved[512];       			// 保留字节 
}ALARM_HDD_SHAKEALARM_INFO;

//巡更状态
typedef	enum tagEM_PATROL_STATUS
{
	EM_PATROL_STATUS_UNKNOWN,										//未知
	EM_PATROL_STATUS_START,											//巡更开始	
	EM_PATROL_STATUS_END,											//巡更结束
	EM_PATROL_STATUS_FAIL,											//巡更失败
}EM_PATROL_STATUS;

//未巡更报警事件( DH_ALARM_PATROL_STATUS )
typedef struct tagALARM_PATROL_STATUS_INFO
{
	NET_TIME_EX			            stuTime;						//事件发生时间
	EM_PATROL_STATUS				emPatrolStatus;					//巡更状态
	BYTE                			byReserved[512];				//保留字节
}ALARM_PATROL_STATUS_INFO;

//区域防区操作方式
typedef enum tagEM_AREAARM_TRIGGERMODE
{
	EM_AREAARM_TRIGGERMODE_UNKNOWN,           // 未知
	EM_AREAARM_TRIGGERMODE_KEYPAD,            // 键盘
	EM_AREAARM_TRIGGERMODE_REMOTECONTROL,     // 遥控器
	EM_AREAARM_TRIGGERMODE_USER,              // 用户操作
	EM_AREAARM_TRIGGERMODE_LOCAL,             // 本地
}EM_AREAARM_TRIGGERMODE;

//区域防区操作用户
typedef enum tagEM_AREAARM_USER
{
	EM_AREAARM_USER_UNKNOWN,           // 未知
	EM_AREAARM_USER_SUPERVISOR,        // 超级用户
	EM_AREAARM_USER_MANAGER,           // 管理用户
	EM_AREAARM_USER_MASTER,            // 主用户
	EM_AREAARM_USER_USER,              // 普通用户
	EM_AREAARM_USER_TEMPORARY,         // 临时用户
	EM_AREAARM_USER_DURESS,            // 胁迫用户
	EM_AREAARM_USER_PATROL,            // 巡逻用户
}EM_AREAARM_USER;

// 布撤防状态
typedef enum tagEM_ARM_STATE
{
	EM_ARM_STATE_UNKNOWN,           		// 未知
	EM_ARM_STATE_TOTAL_ARMING,              // Total布防
	EM_ARM_STATE_PARTIAL1_ARMING,           // partial1布防
	EM_ARM_STATE_PARTIAL2_ARMING,           // partial2布防
	EM_ARM_STATE_PARTIAL1_PARTIAL2_ARMING,  // partial1+2布防
	EM_ARM_STATE_FORCEARMING,               // 强制布防
	EM_ARM_STATE_DISARMING,                 // 撤防
}EM_ARM_STATE;

//区域防区模式改变事件(对应事件 DH_ALARM_AREAARM_MODECHANGE)
typedef struct tagALARM_AREAARM_MODECHANGE_INFO
{ 
	int                       nAreaIndex;                           // 区域编号
	int					      nEventID;								// 事件ID
	NET_TIME_EX			      UTC;									// 事件发生的时间
	EM_AREAARM_TRIGGERMODE    emTriggerMode;                        // 操作方式
	EM_AREAARM_USER           emUser;                               /* 操作用户，
	仅emTriggerMode = EM_AREAARM_USER_USER时有效*/
	UINT                      nID;									/* ID号,emTriggerMode = EM_AREAARM_TRIGGERMODE_KEYPAD
	表示键盘地址;emTriggerMode =EM_AREAARM_TRIGGERMODE_REMOTECONTROL时表示遥控器编号*/
	EM_ARM_STATE              emArmState;                           // 布撤防状态
	BYTE				      byReserved[1024];						// 保留扩展字节
}ALARM_AREAARM_MODECHANGE_INFO;

// 掉线模块类型
typedef enum tagEM_LOSTMODULE_TYPE
{
	EM_LOSTMODULE_TYPE_UNKNOWN,           		   // 未知
	EM_LOSTMODULE_TYPE_WIRED,                      // 有线扩展模块
	EM_LOSTMODULE_TYPE_WIRELESS,                   // 无线配件
}EM_LOSTMODULE_TYPE;

#define MAX_ZONE_NUMBER      72   //最大防区个数         

//防区模块掉线事件(对应事件 DH_ALARM_ZONEMODULELOST)
typedef struct tagALARM_ZONEMODULE_LOST_INFO
{ 
	EM_LOSTMODULE_TYPE        emType;                               // 掉线模块类型
	int					      nEventID;								// 事件ID
	NET_TIME_EX			      UTC;									// 事件发生的时间
	int                       nZones;                               // 属于此模块的防区个数
	int                       arrZones[MAX_ZONE_NUMBER];   			// 属于此某块的防区号
	bool                      bOnLine;                              // 在线状态,false:不在线 true:在线
	BYTE                      byReserved1[3];                       // 字节对齐
 	BYTE				      byReserved[1024];						// 保留扩展字节
}ALARM_ZONEMODULE_LOST_INFO;

// 防区类型
typedef enum tagEM_DEFENCE_AREA_TYPE
{
	EM_DEFENCE_AREA_TYPE_UNKNOWN,       // 未知
	EM_DEFENCE_AREA_TYPE_INTIME,        // 立即防区
	EM_DEFENCE_AREA_TYPE_DELAY,         // 延时防区
	EM_DEFENCE_AREA_TYPE_DELAY2,        // 延时防区2
	EM_DEFENCE_AREA_TYPE_FOLLOW,        // 跟随防区
	EM_DEFENCE_AREA_TYPE_EXITEND,       // 退出防区
	EM_DEFENCE_AREA_TYPE_FULLDAY,       // 24小时防区
	EM_DEFENCE_AREA_TYPE_FIRE,          // 火警防区
	EM_DEFENCE_AREA_TYPE_PANIC,         // 恐慌防区
	EM_DEFENCE_AREA_TYPE_ROBBERY,       // 匪警防区
	EM_DEFENCE_AREA_TYPE_MEDICAL,       // 医疗紧急防区
	EM_DEFENCE_AREA_TYPE_KEY,           // key防区
}EM_DEFENCE_AREA_TYPE;

//区域报警触发类型
typedef enum tagEM_AREAALARM_TRIGGER_TYPE
{
	EM_AREAALARM_TRIGGER_TYPE_UNKNOWN,   //未知
	EM_AREAALARM_TRIGGER_TYPE_ALARM,     // 通道打开
	EM_AREAALARM_TRIGGER_TYPE_TAMPER,    // 通道防拆
	EM_AREAALARM_TRIGGER_TYPE_MASK,      // 通道遮挡
	EM_AREAALARM_TRIGGER_TYPE_SHORT,     // 通道防短
}EM_AREAALARM_TRIGGER_TYPE;

//区域报警事件(对应事件 DH_ALARM_AREAALARM)
typedef struct tagALARM_AREAALARM_INFO
{ 
	int                       nAreaIndex;                           // 区域号
	int					      nEventID;								// 事件ID
	NET_TIME_EX			      UTC;									// 事件发生的时间
	char                      szName[128];                          // 名称
	EM_DEFENCE_AREA_TYPE      emDefenceAreaType;                    // 防区类型
	int                       nIndex;                               // 触发的通道号
	EM_AREAALARM_TRIGGER_TYPE emTrigerType;                         // 触发类型
 	BYTE				      byReserved[1024];						// 保留扩展字节
}ALARM_AREAALARM_INFO;

#define MAX_AREA_NUMBER   8     //最大area数量

//防区打开事件(对应事件 DH_ALARM_ZONEOPEN)
typedef struct tagALARM_ZONEOPEN_INFO
{ 	
	int                       nAction;               // 事件动作1:Start 2:Stop
	int					      nEventID;				 // 事件ID
	NET_TIME_EX			      UTC;					 // 事件发生的时间
	char                      szName[128];           // 名称
	int                       nAreaNum;              // 区域个数
	int                       arrAreas[MAX_AREA_NUMBER]; //区域号
	int                       nChannelID;            // 防区号
 	BYTE				      byReserved[1024];		 // 保留扩展字节
}ALARM_ZONEOPEN_INFO;

//防拆事件(对应事件 DH_ALARM_SYSTEMTAMPER)
typedef struct tagALARM_SYSTEMTAMPER_INFO
{ 	
	int                       nAction;               // 事件动作1:Start 2:Stop
	int					      nEventID;				 // 事件ID
	NET_TIME_EX			      UTC;					 // 事件发生的时间
 	BYTE				      byReserved[1024];		 // 保留扩展字节
}ALARM_SYSTEMTAMPER_INFO;

// 人证比对事件(对应事件 DH_ALARM_CITIZEN_PICTURE_COMPARE)
typedef struct tagALARM_CITIZEN_PICTURE_COMPARE_INFO 
{
	int						nChannelID;								// 通道号
	int						nEventID;								// 事件ID
	NET_TIME_EX				stuTime;								// 事件发生的时间					
	BOOL                	bCompareResult;                     	// 人证比对结果,相似度大于等于阈值认为比对成功,true表示成功,false表示失败
    BYTE                	nSimilarity;                        	// 两张图片的相似度,单位百分比,范围[1,100]
    BYTE                	nThreshold;                         	// 检测阈值,范围[1,100]
    BYTE                	byReserved1[2];                      	// 字节对齐
    EM_CITIZENIDCARD_SEX_TYPE emSex;                        		// 性别
    int                 	nEthnicity;                         	// 民族(参照DEV_EVENT_ALARM_CITIZENIDCARD_INFO的nEthnicity定义)
    char                	szCitizen[DH_COMMON_STRING_64];    		// 居民姓名    
    char                	szAddress[DH_COMMON_STRING_256];    	// 住址
    char                	szNumber[DH_COMMON_STRING_64];          // 身份证号
    char                    szAuthority[DH_COMMON_STRING_256];      // 签发机关
    NET_TIME            	stuBirth;                               // 出生日期(年月日)
    NET_TIME            	stuValidityStart;                   	// 有效期限起始日期(年月日)
    BOOL               		bLongTimeValidFlag;                 	// 该值为 TRUE, 截止日期 表示长期有效,此时 stuValidityEnd 值无意义
																	// 该值为 FALSE, 此时 截止日期 查看 stuValidityEnd 值
    NET_TIME            	stuValidityEnd;                     	// 有效期限结束日期(年月日)
	char                	szCardNo[DH_COMMON_STRING_32];      	// IC卡号
	char                	szCellPhone[DH_COMMON_STRING_32];   	// 手机号（比对时先输入手机号）
	UINT					nEventType;								// 事件类型：0：人证比对结果	1：人证人脸采集
	char					szUserID[32];							// 人证人脸采集时人员ID（定制）
	BYTE					byReserved[988];						// 保留字节
} ALARM_CITIZEN_PICTURE_COMPARE_INFO;

//硬盘健康状况报警事件( DH_ALARM_HDD_HEALTHALARM )
typedef struct tagALARM_HDD_HEALTHALARM_INFO
{
	int                             nAction;                   		// 事件动作1:Start 2:Stop
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	char                 			szHDDName[DH_COMMON_STRING_64];	// 硬盘名称
	NET_HDDSMART_INFO               stuHDDSmartInfo;                // 硬盘Smart信息
	BYTE                			byReserved[512];       			// 保留字节 
}ALARM_HDD_HEALTHALARM_INFO;

// 当前工作目录切换事件( DH_ALARM_STORAGE_WORKDIRECTORY_SWITCH )
typedef struct tagALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO
{
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	char                            szGroup[DH_COMMON_STRING_64];   // 目录所在工作组
}ALARM_STORAGE_WORKDIRECTORY_SWITCH_INFO;

//情景状态
typedef struct tagHOMESCENE_STATE_INFO
{
	char 							szName[128];					//情景名称
	BOOL							bOnline;						//在线状态
	BYTE							byReserved[512];				//保留字节
}HOMESCENE_STATE_INFO;
//智能家居情景模式变化通知事件(DH_ALARM_HOMESCENE_CHANGE)
typedef struct tagALARM_HOMESCENE_CHANGE_INFO
{
	char							szSceneID[32];					//情景编码
	HOMESCENE_STATE_INFO			stuState;						//情景状态
	BYTE							byReserved[512];				//保留字节
}ALARM_HOMESCENE_CHANGE_INFO;

// 主板动作
typedef enum tagEM_BOARDHOTPLUG_ACTION
{
	EM_BOARDHOTPLUG_ACTION_UNKNOWN,									// 未知
	EM_BOARDHOTPLUG_ACTION_ADD,										// 单板插入
	EM_BOARDHOTPLUG_ACTION_REMOVE,									// 单板拔出
}EM_BOARDHOTPLUG_ACTION;



//双控设备热插拔事件(DH_ALARM_DEVBOARDHOTPLUG)		
typedef struct tagALARM_DEVBOARDHOTPLUG_INFO
{
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	EM_BOARDHOTPLUG_ACTION			emBoardAction;					// 主板动作
	int								nBoardSlot;						// 发生插拔的工作板卡槽序号
	BYTE                			byReserved[512];       			// 保留字节 
}ALARM_DEVBOARDHOTPLUG_INFO;

//各种违章事件联动报警输出事件 (DH_ALARM_TRAFFIC_LINKAGEALARM)		
typedef struct tagALARM_TRAFFIC_LINKAGEALARM_INFO
{
	NET_TIME_EX			            stuTime;						// 事件发生的时间
	char							szCode[DH_COMMON_STRING_32];	// 违章联动报警事件
	BYTE                			byReserved[1024];       		// 保留字节 
}ALARM_TRAFFIC_LINKAGEALARM_INFO;
// 同轴开关报警事件 (DH_ALARM_COAXIAL_ALARM_LOCAL)
typedef struct tagALARM_COAXIAL_ALARM_LOCAL_INFO
{
	int								nAction;						// 事件动作1:Start 2:Stop
	NET_TIME_EX						UTC;							// 事件发生的时间
	
	int								nAlarmChannel;					// 报警输入通道号
	NET_SENSE_METHOD				emSenseMethod;					// 传感器类型
	char							szName[MAX_COMMON_STRING_64];	// 报警通道名
	int								nChannelID;						// 视频通道号
	BYTE                			byReserved[1020];       		// 保留字节 
} ALARM_COAXIAL_ALARM_LOCAL_INFO;

// NAS文件删除结果反馈事件( DH_ALARM_NAS_FILE_REMOVE_STATUS )
typedef struct tagALARM_NAS_FILE_REMOVE_STATUS_INFO 
{
	int						nEventID;								// 事件ID
	int						nAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	double					dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX				stuTime;								// 事件发生的时间					
	
	NASFILE_STATUS_STATE	emStatus;								// 任务状态
	char					szID[MAX_COMMON_STRING_128];			// 任务ID
	UINT					nProgress;								// 任务进度: 0 ~ 100
	BYTE					byReserved[1028];						// 保留扩展字节
} ALARM_NAS_FILE_REMOVE_STATUS_INFO;
// 请求设备安装APK事件( DH_ALARM_NAS_APK_INSTALL_REQUEST )
typedef struct tagALARM_NAS_APK_INSTALL_REQUEST_INFO 
{
	DWORD					dwSize;
	char					szApkPath[MAX_COMMON_STRING_128];		// 安装文件路径名
} ALARM_NAS_APK_INSTALL_REQUEST_INFO;
// APK安装状态
typedef enum tagEM_NAS_APK_INSTALL_STATUS
{
	EM_NAS_APK_INSTALL_STATUS_UNKNOWN,								// 未知
	EM_NAS_APK_INSTALL_STATUS_FAILED,								// 失败
	EM_NAS_APK_INSTALL_STATUS_SUCCEED,								// 成功
	EM_NAS_APK_INSTALL_STATUS_INSTALLING,							// 安装中
} EM_NAS_APK_INSTALL_STATUS;

// 设备安装APK状态事件( DH_ALARM_NAS_APK_INSTALL_STATUS )
typedef struct tagALARM_NAS_APK_INSTALL_STATUS_INFO 
{
	int							nEventID;							// 事件ID
	int							nAction;							// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	double						dbPTS;								// 时间戳(单位是毫秒)
	NET_TIME_EX					stuTime;							// 事件发生的时间					
	
	EM_NAS_APK_INSTALL_STATUS	emStatus;							// 任务状态
	char						szApkPath[MAX_COMMON_STRING_128];	// 安装文件路径名
	UINT						nProgress;							// 任务进度: 0 ~ 100
	BYTE						byReserved[1028];					// 保留扩展字节
} ALARM_NAS_APK_INSTALL_STATUS_INFO;

// 文件压缩解压任务类型
typedef enum tagEM_FILE_COMPRESS_TYPE
{
	EM_FILE_COMPRESS_TYPE_UNKNOWN,									// 未知
	EM_FILE_COMPRESS_TYPE_COMPRESS,									// 压缩文件, 对应结构体pInParam = NET_IN_COMPRESS_FILE,pOutParam = NET_OUT_COMPRESS_FILE
	EM_FILE_COMPRESS_TYPE_DECOMPRESS,								// 解压文件, 对应结构体pInParam = NET_IN_DECOMPRESS_FILE,pOutParam = NET_OUT_DECOMPRESS_FILE
} EM_FILE_COMPRESS_TYPE;

// 文件压缩解压任务状态
typedef enum tagEM_FILE_COMPRESS_STATUS 
{
	EM_FILE_COMPRESS_STATUS_UNKNOWN,								// 未知
	EM_FILE_COMPRESS_STATUS_FAILED,									// 失败
	EM_FILE_COMPRESS_STATUS_SUCCEED,								// 成功
	EM_FILE_COMPRESS_STATUS_NEED_PWD,								// 需要密码
	EM_FILE_COMPRESS_STATUS_WRONG_PWD,								// 密码错误
	EM_FILE_COMPRESS_STATUS_NO_FILE,								// 无法找到文件
} EM_FILE_COMPRESS_STATUS ;

// 文件压缩解压结果反馈事件( DH_ALARM_FILE_COMPRESS_STATUS )
typedef struct tagALARM_FILE_COMPRESS_STATUS_INFO 
{
	int						nEventID;								// 事件ID
	int						nAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	double					dbPTS;									// 时间戳(单位是毫秒)
	NET_TIME_EX				stuTime;								// 事件发生的时间					
	
	char					szID[MAX_COMMON_STRING_128];			// 任务ID
	EM_FILE_COMPRESS_TYPE	emType;									// 任务类型
	int						nSrcNum;								// 源文件(夹)名数量
	char					szSrcList[MAX_NASFILE_NUM][MAX_COMMON_STRING_128];		// 源文件(夹)名列表
	char					szDstPath[MAX_COMMON_STRING_128];		// 目的路径
	EM_FILE_COMPRESS_STATUS	emStatus;								// 任务状态
	UINT					nProgress;								// 任务进度: 0 ~ 100
	BYTE					byReserved[1024];						// 保留扩展字节
} ALARM_FILE_COMPRESS_STATUS_INFO;

// 陌生人报警事件信息( DH_ALARM_STRANGER_ALARM )
typedef struct tagALARM_STRANGER_ALARM_INFO
{
	int						nChannelID;						// 本地报警输入通道号
	int						nEventID;						// 事件ID
	int						nAction;						// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX				UTC;							// 事件发生的时间
	BYTE					byReserved[1024];				// 预留字节
}ALARM_STRANGER_ALARM_INFO;

// 二维码上报事件信息( DH_ALARM_QR_CODE_CHECK )
typedef struct tagALARM_QR_CODE_CHECK_INFO
{
	int						nEventID;						// 事件ID
	NET_TIME_EX		        UTC;							// 事件发生的时间
	double					dbPTS;							// 时间戳(单位是毫秒)
	char                    szQRCode[256];                  // 二维码字符串
	BYTE					byReserved[1024];	            // 预留字节
}ALARM_QR_CODE_CHECK_INFO;

// 门锁工作模式
typedef enum tagEM_LOCK_MODE
{
	EM_MODE_UNKNOWN =  -1,						            // 未知
	EM_MODE_NORMAL =  0,							        // 正常模式
	EM_MODE_CHANNEL =  1,								    // 通道模式(锁把手向下直接可以开门)
	EM_MODE_UNDISTURBED = 2,						        // 免扰模式(锁体会开，但无提示音)
} EM_LOCK_MODE ;

// 门锁模式事件信息( DH_ALARM_ACCESS_CTL_LOCK_MODE  )
typedef struct tagALARM_ACCESS_CTL_LOCK_MODE_INFO
{
	int                     nEventID;                       // 事件ID
	NET_TIME_EX	            UTC;					        // 事件发生时间
	double				    dbPTS;					        // 时间戳(单位是毫秒)
	char                    szSN[32];                       // 设备序列号
	EM_LOCK_MODE		    emLockMode;                     // 门锁工作模式
	BYTE					byReserved[1020];		        // 保留字节
}ALARM_ACCESS_CTL_LOCK_MODE_INFO;

// 房间号绑定事件信息( DH_ALARM_LOCK_ROOM_NUM_BIND )
typedef struct tagALARM_LOCK_ROOM_NUM_BIND_INFO
{
	int                     nEventID;                       // 事件ID
	NET_TIME_EX             UTC;                            // 事件发生的时间
	double                  dbPTS;                          // 时间戳(单位是毫秒)
	char                    szSN[32];                       // 设备序列号
    char                    szName[64];                     // 门锁房间号，此字段已废弃
    UINT                   nTaskID;                        // 任务ID
	char                    szRoomNo[64];                   // 智能锁房间号
	BYTE                    byReserved[956];                // 预留字节
}ALARM_LOCK_ROOM_NUM_BIND_INFO;

// 离岗检测事件信息(DH_ALARM_LEAVE_DETECTION)
typedef struct tagALARM_LEAVE_DETECTION_INFO
{
	int						nChannelID;						// 通道号
	int						nAction;						// 事件动作,0表示脉冲事件，1表示持续性事件开始，2表示持续性事件结束
	NET_TIME_EX				UTC;							// 事件发生的时间
	BYTE					byReserved[1024];				// 预留字节
}ALARM_LEAVE_DETECTION_INFO;

// 车道信息
typedef struct tagALARM_LANE_INFO
{
	UINT		nQueueLen;				// 排队长度，单位：米
	UINT		nLane;					// 车道号：从0开始，车到从左往右数，0、1、2、3、4
	UINT		nUserDefinedLaneNumber;	// 用户自定义车道号
	BYTE		byReserved[256];		// 预留字节
}ALARM_LANE_INFO;

// 广州交通排队长度事件（DH_ALARM_TRAFFICGZJJ_QUEUE_LEN）
typedef struct tagALARM_TRAFFICGZJJ_QUEUE_LEN_INFO
{
	int						nChannelID;		// 通道号
	int						nAction;		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	double                  dbPTS;          // 时间戳(单位是毫秒)
	NET_TIME_EX             UTC;            // 事件发生的时间
	int						nEventID;		// 事件ID

	UINT					nPeriodByMs;	//  上报间隔，单位：毫秒
	ALARM_LANE_INFO			stuAlarmLane[5];	//  车道信息
	BYTE					byReserved[1024];// 预留字节
} ALARM_TRAFFICGZJJ_QUEUE_LEN_INFO;

// 车辆类型
typedef enum _EM_NET_CARTYPE
{
	NET_CARTYPE_UNKNOW = 0,           // 未知
	NET_CARTYPE_PASSENGERCAR,         // 客车
	NET_CARTYPE_LARGETRUCK,           // 大货车
	NET_CARTYPE_MIDTRUCK,             // 中货车
	NET_CARTYPE_SALOONCAR,            // 轿车
	NET_CARTYPE_MICROBUS,             // 面包车
	NET_CARTYPE_MICROTRUCK,           // 小货车
	NET_CARTYPE_TRICYCLE,             // 三轮车
	NET_CARTYPE_MOTOR,                // 摩托车
	NET_CARTYPE_PASSERBY,             // 行人
	NET_CARTYPE_SUVMPV,               // SUV-MPV
	NET_CARTYPE_MIDPASSENGERCAR,      // 中客车
	NET_CARTYPE_TANKCAR,              // 危化品车辆(特殊车辆)
	NET_CARTYPE_SUV,                  // SUV
	NET_CARTYPE_MPV,                  // MPV
	NET_CARTYPE_BUS,                  // 公交车
	NET_CARTYPE_PICKUP,               // 皮卡车
	NET_CARTYPE_MINICARRIAGE,         // 微型车
	NET_CARTYPE_OILTANKTRUCK,         // 油罐车(特殊车辆)
	NET_CARTYPE_SLOTTANKCAR,          // 槽罐车(特殊车辆)
	NET_CARTYPE_RESERVED1,            // 保留1(特殊车辆)
	NET_CARTYPE_DREGSCAR,             // 渣土车(特殊车辆)
	NET_CARTYPE_CONCRETEMIXERTRUCK,   // 混凝土搅拌车(特殊车辆)
	NET_CARTYPE_TAXI,				 // 出租车(特殊车辆)
	NET_CARTYPE_POLICE,				 // 警车(特殊车辆)
	NET_CARTYPE_AMBULANCE,            // 救护车(特殊车辆)
	NET_CARTYPE_GENERAL,				 // 普通车(特殊车辆)
	NET_CARTYPE_WATERINGCAR,			 // 洒水车(特殊车辆)
	NET_CARTYPE_RESERVED2,            // 保留2(特殊车辆)
	NET_CARTYPE_FIREENGINE,			 // 消防车(特殊车辆)
	NET_CARTYPE_TRACTOR,				 // 拖拉机(特殊车辆)
	NET_CARTYPE_MACHINESHOPTRUCK,	 // 工程车(特殊车辆)
	NET_CARTYPE_POWERLOTVEHICLE,		 // 粉粒物料车(特殊车辆)
	NET_CARTYPE_SUCTIONSEWAGETRUCK,   // 吸污车(特殊车辆)
	NET_CARTYPE_NORMALVEHICLETANKTRUCK,	// 普通罐车(特殊车辆) 
	NET_CARTYPE_TWOCYCLE,             // 二轮车
} EM_NET_CARTYPE;

// 线圈信息（主要是里面的车辆信息）
typedef struct tagCOILS_INFO
{
	UINT					nCarId;			//  车辆Id（不是车牌号，ID是设备检测到物体记录的编号)
	char					PlateNum[64];	//  车牌号
	EM_NET_CARTYPE			emCarType;		//  车辆类型
	BYTE					byReserved[1024];// 预留字节
} COILS_INFO;

// 车道信息
typedef struct tagLANE_INFO
{
	UINT					nLane;					// 物理车道号（范围0~4）
	int						nLaneType;				// 车道类型，虚线车道：0， 实线车道：1
	double					dbLaneOcc;				// 车道空间占有率,范围[0.0~1.0]
	UINT					nRoadwayNumber;			// 自定义车道号（范围0~128）
	int						nCurrentLaneVehicleNum;	// 当前车道车的数量
	int						nVehicleNum;			// 从上次统计结束到现在，通过车的辆数(设备0.5秒下发一次)
	UINT					nCarId;					// 保留最近有效过车的ID（不是车牌号），CarId是设备检测到物体记录的编号
	double					dbCarEnterTime;			// 编号CarId车辆进入虚线车道的时间
	double					dbCarLeaveTime;			// 编号CarId车辆离开实线车道的时间
	UINT					nCarDistance;			// 编号CarId车辆行驶的距离，单位：米
	int						nQueueLen;				// 车辆等待时的排队长度，单位：米
	double					dbCarSpeed;				// 编号CarId车辆平均车速，单位：米/秒
	int						nCoilsInfoNum;			// 实际返回线圈信息个数
	COILS_INFO				stuCoilsInfo[70][2];	// 线圈信息（主要是线圈内的车辆信息）
	int						nRetSolidLanNum;		// 实际返回虚线车道个数
	int						nSolidLaneNum[6];		// 虚线车道对应的实线车道自定义车道号
	int						nVehicleNumByTypeNum;	// 实际返回车辆类型统计个数
	UINT					nVehicleNumByType[64];	// 类型车辆统计,数组下标对应不同车型（车型参考 EM_NET_CARTYPE），下标值对应车辆类型统计的数量
	int						nEndLen;				// 车辆运行时，尾部车辆位置距离停车线的距离 ，单位：米
	BYTE					byReserved[1024];		// 预留字节
} LANE_INFO;

// 交通态势事件（DH_ALARM_TRAFFIC_XINKONG）
typedef struct tagALARM_TRAFFIC_XINKONG_INFO
{
	int						nChannelID;				// 通道号
	int						nAction;				// 只有一个事件动作0，表示脉冲事件
	double                  dbPTS;					// 时间戳(单位是毫秒)
	NET_TIME_EX             UTC;					// 事件发生的时间
	int						nEventID;				// 事件ID
	
	char					szName[128];			// 事件名称
	BYTE					byReserved1[4];			// 字节对齐
	int						nLaneInfoNum;			// 实际上报多少车道信息
	LANE_INFO				stuLaneInfo[6];			// 车道信息
	BYTE					byReserved[1024];		// 预留字节
} ALARM_TRAFFIC_XINKONG_INFO;

// Jablotron报警事件类型
typedef enum tagEM_JABLOTRON_ALARM_TYPE
{
	EM_JABLOTRON_ALARM_TYPE_UNKNOWN,						// 未知
	EM_JABLOTRON_ALARM_TYPE_INTRUSION,						// Intrusion
	EM_JABLOTRON_ALARM_TYPE_FIRE,							// Fire
	EM_JABLOTRON_ALARM_TYPE_PANIC,							// Panic
	EM_JABLOTRON_ALARM_TYPE_ARMED,							// Armed
	EM_JABLOTRON_ALARM_TYPE_DISARMED,						// Disarmed
	EM_JABLOTRON_ALARM_TYPE_PG,								// PG
}EM_JABLOTRON_ALARM_TYPE;

typedef struct tagHMS_TIME
{
	DWORD					dwHour;							// 时
	DWORD					dwMinute;						// 分
	DWORD					dwSecond;						// 秒
}HMS_TIME;

// 客户报警产品信息( DH_ALARM_JABLOTRON_ALARM )
typedef struct tagALARM_JABLOTRONALARM_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	char						szName[128];								// 事件名称
	EM_JABLOTRON_ALARM_TYPE		emAlarmType;								// Jablotron报警事件类型
	unsigned int				nDefenceZone;								// 防区号,1~15
	HMS_TIME					stuTime;									// Jablotron报警时其本身的时间值
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_JABLOTRONALARM_INFO;

// 人脸识别框的颜色
typedef struct tagNET_CFG_FACE_BOX_COLOR
{
	int					nFaceID;									// 人脸ID
	NET_COLOR_RGBA		stuColor;									// 颜色值
	BYTE				byReserved[108];							// 保留字节						
}NET_CFG_FACE_BOX_COLOR;

// 人脸识别事件( DH_ALARM_FACE_RECOGNITION )
typedef struct tagALARM_FACE_RECOGNITION_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	
	NET_CFG_FACE_BOX_COLOR		stuFaceBoxColor;							// 人脸识别框的颜色
	BYTE						byReserved[4096];							// 保留字节 
}ALARM_FACE_RECOGNITION_INFO;

// 车载燃料液位事件( DH_ALARM_VEHICLE_OILLEVEL )
typedef struct tagALARM_VEHICLE_OILLEVEL_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	
	float						fOilLevel;									// 车载燃料液位,单位：%
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_VEHICLE_OILLEVEL_INFO;

// 车载燃料载重事件( DH_ALARM_VEHICLE_LOAD )
typedef struct tagALARM_VEHICLE_LOAD_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	
	UINT						nADValue;									// AD采样值
	float						fLoad;										// 当前载重,单位：kg
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_VEHICLE_LOAD_INFO;

// 发动机故障状态
typedef enum tagEM_ENGINE_FAILURE_STATUS
{
	EM_ENGINE_FAILURE_UNKNOWN = 0,											// 未知
	EM_ENGINE_FAILURE_NOTACTIVE,											// "Not active"
	EM_ENGINE_FAILURE_ACTIVE,												// "Active"
	EM_ENGINE_FAILURE_BLINK,												// "Blink"
	EM_ENGINE_FAILURE_NOTAVAILABLE,											// "Not Available"
}EM_ENGINE_FAILURE_STATUS;

// 发动机故障状态上报事件( DH_ALARM_ENGINE_FAILURE_STATUS )
typedef struct tagALARM_ENGINE_FAILURE_STATUS_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	
	EM_ENGINE_FAILURE_STATUS	emStatus;									// 发动机故障状态
	NET_GPS_STATUS_INFO			stuGPS;										// GPS信息(车载需求)
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_ENGINE_FAILURE_STATUS_INFO;

// 车辆状态枚举
typedef enum tagEM_VEHICLE_STATE
{
	EM_VEHICLE_STATE_UNKNOWN = 0,
	EM_VEHICLE_STATE_PARK,							// 停车状态
	EM_VEHICLE_STATE_MOTION,						// 开始运动(速度大于0km/h)
	EM_VEHICLE_STATE_SPORT,							// 运动状态(速度大于10km/h)
}EM_VEHICLE_STATE;

// 车辆档位信息
typedef enum tagEM_VEHICLE_GEARS_TYPE
{
	EM_VEHICLE_GEARS_UNKNOWN = -1,
	EM_VEHICLE_GEARS_P,								//P档
	EM_VEHICLE_GEARS_R,								//R档
	EM_VEHICLE_GEARS_N,								//N档
	EM_VEHICLE_GEARS_D,								//D档
	EM_VEHICLE_GEARS_S,								//S档
}EM_VEHICLE_GEARS_TYPE;

// 车辆状态事件( DH_ALARM_VEHICLE_STATE )
typedef struct tagALARM_VEHICLE_STATE_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	

	EM_VEHICLE_STATE			emVehicleState;								// 车辆状态
	UINT						nOilTankage;								// 油箱容积，单位0.1L
	UINT						nCurrentFuel;								// 当前油箱的油量, 单位0.1L
	UINT						nConsumptionOil;							// 当前油耗，L/100公里 单位0.1L
	UINT						nTotalUsedFuel;								// 总的消耗油量，单位0.1L
	UINT						nTotalDistance;								// 总里程，单位0.1 Km
	int							nServiceDistance;							// 保养距离，单位0.1Km
	EM_VEHICLE_GEARS_TYPE		emCurrentGear;								// 当前档位
	UINT						nSpeed;										// 当前速度，单位：0.1Km/h
	char						szTaskID[64];								// 任务号
	NET_GPS_STATUS_INFO			stuGPS;										// GPS信息
	int							nAlarmFlag;									// 保养里程小于2000km时告警标示，0:无告警 1:有告警 2:无意义
	BYTE						byReserved[1020];							// 保留字节 
}ALARM_VEHICLE_STATE_INFO;

// IMSI检验事件( DH_ALARM_IMSI_CHECK )
typedef struct tagALARM_IMSI_CHECK_INFO
{
	int							nIndex;										// SIM卡槽序号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	

	char						szIMSI[32];									// 检测到的IMSI号
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_IMSI_CHECK_INFO;

// 车辆盲区事件( DH_ALARM_BLIND_ALARM )
typedef struct tagALARM_BLIND_ALARM_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	
	
	NET_GPS_STATUS_INFO			stuGPS;										// GPS信息
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_BLIND_ALARM_INFO;

// 车载人员维护事件( DH_ALARM_VEHICLE_MAINTAINCE )
typedef struct tagALARM_VEHICLE_MAINTAINCE_INFO
{
	int							nIndex;										// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	

	char						szMaintainer[32];							// 维护人员
	char						szMaintainerID[32];							// 维护人员ID
	char						szInfo[256];								// 自定义维护信息
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_VEHICLE_MAINTAINCE_INFO;

// 火警事件 (DH_ALARM_FIRE_DETECTION)
typedef struct tagALARM_FIRE_DETECTION_INFO
{
	int							nChannelID;									// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	

	BYTE						byReserved[1024];							// 保留字节 
}ALARM_FIRE_DETECTION_INFO;

// 车位锁状态
typedef enum tagEM_PARKINGLOCK_STATE
{
	EM_PARKINGLOCK_STATE_UNKNOWN = 0,										// 未知
	EM_PARKINGLOCK_STATE_LOCKRISE,											// 车位锁升起
	EM_PARKINGLOCK_STATE_LOCKDOWN,											// 车位锁降下
	EM_PARKINGLOCK_STATE_LOCKERROR,											// 状态异常
}EM_PARKINGLOCK_STATE;

// 触发源
typedef enum tagEM_TRIGGER_SOURCE
{
	EM_TRIGGER_SOURCE_UNKNOWN = 0,											// 未知
	EM_TRIGGER_SOURCE_SWING_ARM,											// 摆臂自动
	EM_TRIGGER_SOURCE_BLUETOOTH,											// 蓝牙控制
	EM_TRIGGER_SOURCE_RS485,												// 485通信控制
	EM_TRIGGER_SOURCE_ULTRASOUND,											// 超声检测
	EM_TRIGGER_SOURCE_REMOTE_CONTROL,										// 遥控器控制
}EM_TRIGGER_SOURCE;

// 车位锁状态变化事件( DH_ALARM_PARKINGLOCK_STATE )
typedef struct tagALARM_PARKINGLOCK_STATE_INFO
{
	int							nIndex;										// 通道号
	int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间	

	UINT						nLane;										// 车位号
	EM_PARKINGLOCK_STATE		emState;									// 状态
	EM_TRIGGER_SOURCE			emTriggerSource;							// 触发源
	BYTE						byReserved[1024];							// 保留字节 
}ALARM_PARKINGLOCK_STATE_INFO;

// NAS服务器名称
typedef enum tagEM_SERVERNAME
{
	EM_SERVERNAME_UNKNOWN,		// 未知
	EM_SERVERNAME_NFS,			// NFS
	EM_SERVERNAME_FTP,			// FTP
	EM_SERVERNAME_SAMBA,		// SAMBA
	EM_SERVERNAME_ISCSI,		// ISCSI
}EM_SERVERNAME;

// NAS共享服务器异常报警信息(对应 DH_ALARM_NAS_SERVER_STATE)
typedef struct tagALARM_NAS_SERVER_STATE_INFO
{
	int							nAction;									// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间
	EM_SERVERNAME				emServerNames[4];							// NAS服务器名称
	int							nRetServerNamesNum;							// 实际返回的NAS服务器名称个数
	BYTE						byReserved[1024];							// 保留字节
}ALARM_NAS_SERVER_STATE_INFO;

// 存储池异常报警事件信息(对应 DH_ALARM_VOLUME_GROUP_FAULT)
typedef struct tagALARM_VOLUME_GROUP_FAULT_INFO
{
	int							nAction;									// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间
	char						szName[32];									// 异常存储卷名称
	char						szMembers[512][32];							// 存储卷的内容
	int							nRetMembersNum;								// 实际返回的存储卷的内容个数
	BYTE						byReserved[1024];							// 保留字节
}ALARM_VOLUME_GROUP_FAULT_INFO;

// 磁盘巡检报警事件信息(对应 DH_ALARM_DISK_CHECK)
typedef struct tagALARM_DISK_CHECK_INFO
{
	int							nAction;									// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
	NET_TIME_EX					UTC;										// 事件发生的时间
	char						szName[128];								// 报警名称
	BYTE						byReserved[1024];							// 保留字节
}ALARM_DISK_CHECK_INFO;
///////////////////////////////// 刻录会话 /////////////////////////////////////////

// CLIENT_StartBurnSession 接口输入参数
typedef struct tagNET_IN_START_BURN_SESSION 
{
    DWORD               dwSize;
    unsigned int        nSessionID;                         // 会话ID
} NET_IN_START_BURN_SESSION;

typedef struct tagNET_OUT_START_BURN_SESSION 
{
    DWORD               dwSize;
} NET_OUT_START_BURN_SESSION;

// 刻录模式
typedef enum tagNET_BURN_MODE
{
    BURN_MODE_SYNC,                     // 同步
    BURN_MODE_TURN,                     // 轮流
    BURN_MODE_CYCLE,                    // 循环
} NET_BURN_MODE;

// 刻录扩展模式
typedef enum tagNET_BURN_EXTMODE
{
	BURN_EXTMODE_UNKNOWN,					 // 未知
    BURN_EXTMODE_NORMAL = 1,                 // 正常刻录
    BURN_EXTMODE_NODISK,                     // 无盘刻录
} NET_BURN_EXTMODE;

// 刻录流格式
typedef enum tagNET_BURN_RECORD_PACK
{
    BURN_PACK_DHAV,                     // DHAV
    BURN_PACK_PS,                       // PS
    BURN_PACK_ASF,                      // ASF
    BURN_PACK_MP4,                      // MP4
    BURN_PACK_TS,                       // TS
} NET_BURN_RECORD_PACK;

// CLIENT_StartBurn 接口输入参数
typedef struct tagNET_IN_START_BURN 
{
    DWORD                dwSize;
    DWORD                dwDevMask;                             // 刻录设备掩码, 按位表示多个刻录设备组合
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // 刻录通道数组
    int                  nChannelCount;                         // 刻录通道数
    NET_BURN_MODE        emMode;                                // 刻录模式
    NET_BURN_RECORD_PACK emPack;                                // 刻录流格式
    NET_BURN_EXTMODE     emExtMode;                             // 刻录扩展模式
} NET_IN_START_BURN;

// CLIENT_StartBurn 接口输出参数
typedef struct tagNET_OUT_START_BURN 
{
    DWORD               dwSize;
} NET_OUT_START_BURN;

// CLIENT_BurnMarkTag 接口输入参数
typedef struct tagNET_IN_BURN_MAAK_TAG
{
    DWORD               dwSize;
    const char*         pszDescInfo;                            // 标记描述信息
} NET_IN_BURN_MARK_TAG;

// CLIENT_BurnMarkTag 接口输出参数
typedef struct tagNET_OUT_BURN_MAAK_TAG
{
    DWORD               dwSize;
} NET_OUT_BURN_MARK_TAG;

// CLIENT_BurnChangeDisk 接口输入参数
typedef struct tagNET_IN_BURN_CHANGE_DISK
{
    DWORD               dwSize;
    BOOL                nAction;                                // 换盘动作, 0-开始, 1-结束
} NET_IN_BURN_CHANGE_DISK;

// CLIENT_BurnChangeDisk 接口输出参数
typedef struct tagNET_OUT_BURN_CHANGE_DISK
{
    DWORD               dwSize;
} NET_OUT_BURN_CHANGE_DISK;

// 刻录状态
typedef enum tagNET_BURN_STATE
{
    BURN_STATE_STOP,                    // 停止
    BURN_STATE_STOPING,                 // 停止中
    BURN_STATE_INIT,                    // 初始化
    BURN_STATE_BURNING,                 // 刻录中
    BURN_STATE_PAUSE,                   // 暂停
    BURN_STATE_CHANGE_DISK,             // 换盘中
    BURN_STATE_PREPARE_EXTRA_FILE,      // 附件初始化
    BURN_STATE_WAIT_EXTRA_FILE,         // 等待附件刻录
    BURN_STATE_UPLOAD_FILE_START,       // 附件刻录中
    BURN_STATE_CHECKING_DISK,           // 检测光盘中
    BURN_STATE_DISK_READY,              // 光盘准备就绪
} NET_BURN_STATE;

// 刻录错误码
typedef enum tagNET_BURN_ERROR_CODE
{
    BURN_CODE_NORMAL,                   // 正常
    BURN_CODE_UNKNOWN_ERROR,            // 未知错误
    BURN_CODE_SPACE_FULL,               // 刻录满
    BURN_CODE_START_ERROR,              // 开始刻录出错
    BURN_CODE_STOP_ERROR,               // 停止刻录出错
    BURN_CODE_WRITE_ERROR,              // 刻录出错
	BURN_CODE_UNKNOWN,					// 未知
} NET_BURN_ERROR_CODE;

// CLIENT_BurnGetState 接口输入参数
typedef struct tagNET_IN_BURN_GET_STATE
{
    DWORD                dwSize;
} NET_IN_BURN_GET_STATE;

// 光驱使用状态
typedef enum tagEM_NET_BURN_DEV_USED_STATE
{
	EM_NET_BURN_DEV_USED_STATE_UNKNOWN, //未知
	EM_NET_BURN_DEV_USED_STATE_STOP,	//停止
	EM_NET_BURN_DEV_USED_STATE_BURNING,	//刻录中
}EM_NET_BURN_DEV_USED_STATE;

// 刻录设备状态
typedef struct tagNET_BURN_DEV_STATE 
{
    DWORD                dwSize;
    int                  nDeviceID;                             // 光驱设备ID
    char                 szDevName[DH_BURNING_DEV_NAMELEN];     // 光驱设备名称
    DWORD                dwTotalSpace;                          // 光驱总容量, 单位KB
    DWORD                dwRemainSpace;                         // 光驱剩余容量, 单位KB
	EM_NET_BURN_DEV_USED_STATE	            emUsedType;			// 光驱使用状态
	NET_BURN_ERROR_CODE						emError;			// 单个光驱出错状态
} NET_BURN_DEV_STATE;

// CLIENT_BurnGetState 接口输出参数
typedef struct tagNET_OUT_BURN_GET_STATE
{
    DWORD                dwSize;
    NET_BURN_STATE       emState;                               // 刻录状态
    NET_BURN_ERROR_CODE  emErrorCode;                           // 错误码
    DWORD                dwDevMask;                             // 刻录设备掩码, 按位表示多个刻录设备组合
    int                  nChannels[DH_MAX_BURN_CHANNEL_NUM];    // 刻录通道数组
    int                  nChannelCount;                         // 刻录通道数
    NET_BURN_MODE        emMode;                                // 刻录模式
    NET_BURN_RECORD_PACK emPack;                                // 刻录流格式
    int                  nFileIndex;                            // 当前刻录文件编号
    NET_TIME             stuStartTime;                          // 刻录开始时间
    NET_BURN_DEV_STATE   stuDevState[DH_MAX_BURNING_DEV_NUM];   // 刻录设备状态
    int                  nRemainTime;                           // 刻录剩余时间, 单位秒, -1代表无效
	NET_BURN_EXTMODE	 emExtMode;								// 扩展模式,当为无盘刻录时，stuDevState可能无效
} NET_OUT_BURN_GET_STATE;

// fAttachBurnStateCB 参数
typedef struct tagNET_CB_BURNSTATE
{
    DWORD               dwSize;
    const char*         szState;                        // 消息类型
                                                        //"UploadFileStart"：可以开始附件上传
                                                        //"InitBurnDevice":初始化刻录设备
                                                        //"Burning":刻录中
                                                        //"BurnExtraFileStop"：刻录停止
                                                        //"BurnFilePause":刻录暂停
                                                        //"SpaceFull":刻录空间满
                                                        //"BurnFileError":刻录出错    
    const char*         szFileName;                     // 当前刻录附件文件名,用于"UploadFileStart"开始附件上传消息
    unsigned int        dwTotalSpace;                   // 总容量,单位KB,用于"Burning"刻录中,显示容量或计算进度
    unsigned int        dwRemainSpace;                  // 剩余容量,单位KB,用于"Burning"刻录中
    const char*         szDeviceName;                   // 刻录设备名称,用于区分不同的刻录设备
    int                 nRemainTime;                    // 刻录剩余时间, 单位秒, -1代表无效
}NET_CB_BURNSTATE;

// 刻录设备回调函数原形,lAttachHandle是CLIENT_AttachBurnState返回值, 每次1条,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachBurnStateCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CB_BURNSTATE* pBuf, int nBufLen, LDWORD dwUser);

// 刻录设备回调扩展函数原形
typedef void (CALLBACK *fAttachBurnStateCBEx)(LLONG lLoginID, LLONG lAttachHandle, NET_OUT_BURN_GET_STATE* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBurnState()输入参数
typedef struct tagNET_IN_ATTACH_STATE
{
    DWORD                   dwSize;
    const char*             szDeviceName;                   // 光盘名称,如"/dev/sda"
    fAttachBurnStateCB      cbAttachState;                  // 刻录监听回调
    LDWORD                  dwUser;                         // 用户数据
    LLONG                   lBurnSession;                   // 刻录会话句柄, CLIENT_StartBurnSession的返回值. 该值为0时, szDeviceName有效, 此时按刻录设备订阅刻录状态
    fAttachBurnStateCBEx    cbAttachStateEx;                // 扩展刻录监听回调
    LDWORD                  dwUserEx;                       // 扩展刻录监听回调用户数据
}NET_IN_ATTACH_STATE;

// CLIENT_AttachBurnState 输出参数
typedef struct tagNET_OUT_ATTACH_STATE
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_STATE;

// 刻录设备回调函数原形,lUploadHandle是CLIENT_StartUploadFileBurned返回值
typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);

// CLIENT_StartUploadFileBurned()输入参数
typedef struct tagNET_IN_FILEBURNED_START
{
    DWORD                   dwSize;
    const char*             szMode;                         // 文件上传方式
                                                            // "append", 追加模式,此时刻录文件名固定为" FILE.zip ",filename被忽略
                                                            // "evidence", 证据等大附件, 要求单独刻录的光盘内
    const char*             szDeviceName;                   // 光盘名称,如“/dev/sda”
    const char*             szFilename;                     // 本地文件名称
    fBurnFileCallBack       cbBurnPos;                      // 刻录进度回调
    LDWORD                  dwUser;                         // 用户数据
    LLONG                   lBurnSession;                   // 刻录句柄, CLIENT_StartBurnSession的返回值. 该值为0时, szDeviceName有效, 此时按刻录设备订阅刻录状态
}NET_IN_FILEBURNED_START;

// CLIENT_StartUploadFileBurned 输出参数
typedef struct tagNET_OUT_FILEBURNED_START
{
    DWORD                   dwSize;
    char                    szState[DH_MAX_NAME_LEN];      // "start"：系统准备就绪,可以开始上传; "busy"：系统忙,稍后在试。"error"：系统未在刻录中,返回出错,请求失败
}NET_OUT_FILEBURNED_START;

// 刻录案件信息
typedef struct tagNET_BURN_CASE_INFO
{
    DWORD       dwSize;
    int         nChannel;                                   // 通道号
    NET_TIME    stuStartTime;                               // 刻录起始时间
    NET_TIME    stuEndTime;                                 // 刻录结束时间
    int         nIndex;                                     // 序号
    int         nCode;                                      // 编号
    int         nDiscNum;                                   // 光盘编号        
    char        szName[DH_COMMON_STRING_128];               // 名称
    char        szPlace[DH_COMMON_STRING_128];              // 办案地点
    char        szInvestigator[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32]; // 办案人员
    char        szSuspects[DH_MAX_CASE_PERSON_NUM][DH_COMMON_STRING_32];     // 涉案人员
    char        szMemo[DH_COMMON_STRING_256];               // 备注
    char        szVideoName[DH_COMMON_STRING_128];          // 录像名称
    char        szRecorder[DH_COMMON_STRING_32];            // 刻录人
} NET_BURN_CASE_INFO;

// 刻录设备回调函数原形,lAttachHandle是CLIENT_AttachBurnCase返回值
typedef void (CALLBACK *fBurnCaseCallBack) (LLONG lAttachHandle, NET_BURN_CASE_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnCase 接口输入参数
typedef struct tagNET_IN_ATTACH_BURN_CASE
{
    DWORD                dwSize;
    fBurnCaseCallBack    cbBurnCase;                        // 案件信息回调函数
    LDWORD               dwUser;                            // 用户数据
} NET_IN_ATTACH_BURN_CASE;

// CLIENT_AttachBurnCase 接口输出参数
typedef struct tagNET_OUT_ATTACH_BURN_CASE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_CASE;

// 刻录设备总线类型
typedef enum tagEM_NET_BURN_DEV_BUS_TYPE
{
    EM_NET_BURN_DEV_BUS_TYPE_UNKNOWN,   // 未知
    EM_NET_BURN_DEV_BUS_TYPE_IDE,       // IDE
    EM_NET_BURN_DEV_BUS_TYPE_USB,       // USB
    EM_NET_BURN_DEV_BUS_TYPE_1394,      // 1394
    EM_NET_BURN_DEV_BUS_TYPE_SATA,      // SATA
    EM_NET_BURN_DEV_BUS_TYPE_ESATA,     // ESATA
}EM_NET_BURN_DEV_BUS_TYPE;

// 刻录设备介质类型
typedef enum tagEM_NET_BURN_DEV_BK_TYPE
{
    EM_NET_BURN_DEV_BK_TYPE_UNKNOWN,    // 未知
    EM_NET_BURN_DEV_BK_TYPE_DHFS,       // 大华文件系统
    EM_NET_BURN_DEV_BK_TYPE_DISK,       // 移动硬盘
    EM_NET_BURN_DEV_BK_TYPE_CDRW,       // 光盘刻录
}EM_NET_BURN_DEV_BK_TYPE;

// 刻录设备状态信息
typedef struct tagNET_BURN_DEV_STATE_INFO
{
    char            szName[DH_COMMON_STRING_256];               // 刻录设备名称
    unsigned int    nTotalSpace;                                // 光驱总容量，单位KB
    unsigned int    nFreeSpace;                                 // 光驱剩余容量，单位KB
    EM_NET_BURN_DEV_TRAY_TYPE        emTrayType;                // 光驱托盘状态
    EM_NET_BURN_DEV_OPERATE_TYPE     emOperateType;             // 光驱使用状态
    EM_NET_BURN_DEV_BUS_TYPE         emBusType;                 // 刻录设备总线类型
    EM_NET_BURN_DEV_BK_TYPE          emBkType;                  // 刻录设备介质类型
} NET_BURN_DEV_STATE_INFO;

// 刻录设备状态信息列表
typedef struct tagNET_BURN_DEV_STATE_INFO_LIST
{
    unsigned int    nListCount; // 列表有效刻录设备状态信息个数，与 pstuNetBurnDevStateInfo 配合使用
    NET_BURN_DEV_STATE_INFO *pstuNetBurnDevStateInfo;   // 刻录设备状态信息指针，与 nListCount 配合使用
}NET_BURN_DEV_STATE_INFO_LIST;
// 刻录设备状态回调函数原形,lAttachHandle 是 CLIENT_AttachBurnDevState 返回值
typedef void (CALLBACK *fBurnDevStateCallBack) (LLONG lAttachHandle, const NET_BURN_DEV_STATE_INFO_LIST* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachBurnDevState 接口输入参数
typedef struct tagNET_IN_ATTACH_BURN_DEV_STATE
{
    DWORD                       dwSize;
    fBurnDevStateCallBack       cbBurnDevState;             // 刻录设备状态回调函数
    LDWORD                      dwUser;                     // 用户数据
} NET_IN_ATTACH_BURN_DEV_STATE;

// CLIENT_AttachBurnDevState 接口输出参数
typedef struct tagNET_OUT_ATTACH_BURN_DEV_STATE
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BURN_DEV_STATE;

/////////////////////////////////// 案件自动备份系统（刻录） ///////////////////////////////////////

#define CASE_BACK_UP_CHANNEL_MAX_NUM        32  // 案件刻录通道最大数目
#define CASE_BACK_UP_FILE_TYPE_MAX_NUM      8   // 案件刻录文件类型最大数目
#define CASE_BACK_UP_INQUEST_INFO_MAX_NUM   8   // 案件刻录审讯信息最大查询数目
#define CASE_BACK_UP_DEVICE_MAX_NUM         8   // 案件刻录最大设备数目

// 案件刻录文件类型
typedef enum tagEM_CASE_BACK_UP_FILE_TYPE
{
    EM_CASE_BACK_UP_FILE_TYPE_UNKNOWN,          // 未知
    EM_CASE_BACK_UP_FILE_TYPE_DAV,              // DAV
    EM_CASE_BACK_UP_FILE_TYPE_JPG,              // JPG
    EM_CASE_BACK_UP_FILE_TYPE_TXT,              // TXT
}EM_CASE_BACK_UP_FILE_TYPE;

// 案件刻录备份类型
typedef enum tagEM_CASE_BACK_UP_MODE_TYPE
{
    EM_CASE_BACK_UP_MODE_TYPE_UNKNOWN,          // 未知的
    EM_CASE_BACK_UP_MODE_TYPE_SYNC,             // 同步刻录备份 多盘备份相同内容
    EM_CASE_BACK_UP_MODE_TYPE_CYCLE,            // 循环刻录备份 通过换盘来完成所有内容的备份
}EM_CASE_BACK_UP_MODE_TYPE;

// 视频文件备份格式
typedef enum tagEM_CASE_BACK_UP_PACK_TYPE
{
    EM_CASE_BACK_UP_PACK_TYPE_UNKNOWN,          // 未知的
    EM_CASE_BACK_UP_PACK_TYPE_DHAV,             // DHAV
    EM_CASE_BACK_UP_PACK_TYPE_MP4,              // MP4
    EM_CASE_BACK_UP_PACK_TYPE_PS,               // PS   
}EM_CASE_BACK_UP_PACK_TYPE;

// 案件刻录备份查询信息
typedef struct tagNET_CASE_BACK_UP_INQUEST_INFO
{
    char szTitle[128];                          // 字段标题
    char szText[128];                           // 字段内容
    BYTE byReserved[512];                       // 保留字节
}NET_CASE_BACK_UP_INQUEST_INFO;

// 案件备份刻录查询条件
typedef struct tagNET_CASE_BACK_UP_QUERY_CONDITION
{
    int                             nChannelNum;                                        // 查询通道数目                            
    int                             nChannels[CASE_BACK_UP_CHANNEL_MAX_NUM];            // 查询通道数组
    NET_TIME                        stuStartTime;                                       // 开始时间
    NET_TIME                        stuEndTime;                                         // 结束时间
    int                             nFileTypeNum;                                       // 文件类型数目
    EM_CASE_BACK_UP_FILE_TYPE       emFileTypes[CASE_BACK_UP_FILE_TYPE_MAX_NUM];        // 文件类型数组
    char                            szCaseNumber[256];                                  // 案件编号
    int                             nInquestInfoNum;                                    // 查询字段数目
    NET_CASE_BACK_UP_INQUEST_INFO   stuInquestInfo[CASE_BACK_UP_INQUEST_INFO_MAX_NUM];  // 查询字段数组
    BYTE                            byReserved[1024];                                   // 保留字节
}NET_CASE_BACK_UP_QUERY_CONDITION;

// 案件备份刻录模式信息
typedef struct tagNET_CASE_BACK_UP_MODE
{
    EM_CASE_BACK_UP_MODE_TYPE   emBackupMode;                                           // 备份模式
    int                         nDeviceNum;                                             // 设备数目
    char                        szDeviceName[CASE_BACK_UP_DEVICE_MAX_NUM][256];         // 设备数组
    EM_CASE_BACK_UP_PACK_TYPE   emPackType;                                             // 备份文件类型
    BOOL                        bExtraFile;                                             // 是否有附件
    BOOL                        bDataCheck;                                             // 是否有数据校验
    BYTE                        byReserved[1024];                                       // 保留字节
}NET_CASE_BACK_UP_MODE;

// 开始案件备份刻录入参
typedef struct tagNET_IN_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // 结构体大小
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // 查询条件
    NET_CASE_BACK_UP_MODE               stuMode;                                        // 备份模式
}NET_IN_START_CASE_BACK_UP;

// 开始案件备份刻录失败错误码类型
typedef enum tagEM_CASE_BACK_UP_START_ERROR_CODE
{
    EM_CASE_BACK_UP_START_ERROR_CODE_UNKNOWN,                                           // 未知的
    EM_CASE_BACK_UP_START_ERROR_CODE_NORMAL,                                            // 正常
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUPING,                                         // 该案件正在备份中
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_FINDFILE,                                       // 未发现文件
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_BUSY,                                       // 设备忙
    EM_CASE_BACK_UP_START_ERROR_CODE_NO_SUPPORT_MEDIA_FORMAT,                           // 不支持的媒体格式   
    EM_CASE_BACK_UP_START_ERROR_CODE_DEVICE_ERROR,                                      // 备份设备错误
    EM_CASE_BACK_UP_START_ERROR_CODE_BACKUP_FILE_OVER_LIMIT,                            // 备份文件数量超过极限值
    EM_CASE_BACK_UP_START_ERROR_CODE_OTHER_ERROR,                                       // 其它错误
}EM_CASE_BACK_UP_START_ERROR_CODE;

// 开始案件备份刻录出参
typedef struct tagNET_OUT_START_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // 结构体大小
    EM_CASE_BACK_UP_START_ERROR_CODE    emErrorCode;                                    // 错误码
}NET_OUT_START_CASE_BACK_UP;

// 停止案件备份刻录入参
typedef struct tagNET_IN_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // 结构体大小
}NET_IN_STOP_CASE_BACK_UP;

// 停止案件备份刻录出参
typedef struct tagNET_OUT_STOP_CASE_BACK_UP
{
    DWORD                               dwSize;                                         // 结构体大小
}NET_OUT_STOP_CASE_BACK_UP;

// 案件备份刻录状态
typedef enum tagEM_CASE_BACK_UP_STATE_TYPE
{
    EM_CASE_BACK_UP_STATE_TYPE_UNKNOWN,                                                 // 未知的
    EM_CASE_BACK_UP_STATE_TYPE_INIT,                                                    // 初始化
    EM_CASE_BACK_UP_STATE_TYPE_STOP,                                                    // 停止
    EM_CASE_BACK_UP_STATE_TYPE_STOPPING,                                                // 停止中
    EM_CASE_BACK_UP_STATE_TYPE_BACKUPING,                                               // 备份中            
    EM_CASE_BACK_UP_STATE_TYPE_CHANGE_DISK,                                             // 换盘中
    EM_CASE_BACK_UP_STATE_TYPE_PREPARE_EXTRA_FILE,                                      // 附件初始化
    EM_CASE_BACK_UP_STATE_TYPE_WAIT_EXTRA_FILE,                                         // 等待刻录附件
    EM_CASE_BACK_UP_STATE_TYPE_UPLOAD_FILE_START,                                       // 附件刻录中
}EM_CASE_BACK_UP_STATE_TYPE;

// 案件备份刻录状态错误代码
typedef enum tagEM_CASE_BACK_UP_ERROR_CODE
{
    EM_CASE_BACK_UP_ERROR_CODE_UNKNOWN,                                                 // 未知的
    EM_CASE_BACK_UP_ERROR_CODE_NORMAL,                                                  // 正常
    EM_CASE_BACK_UP_ERROR_CODE_SPACE_FULL,                                              // 刻录满
    EM_CASE_BACK_UP_ERROR_CODE_START_ERROR,                                             // 开始刻录出错   
    EM_CASE_BACK_UP_ERROR_CODE_STOP_ERROR,                                              // 停止刻录出错
    EM_CASE_BACK_UP_ERROR_CODE_WRITE_ERROR,                                             // 刻录文件出错   
    EM_CASE_BACK_UP_ERROR_CODE_OTHER_ERROR,                                             // 其他错误      
}EM_CASE_BACK_UP_ERROR_CODE;

// 案件备份刻录状态数据
typedef struct tagNET_CASE_BACK_UP_STATE
{
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // 当前刻录状态
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // 错误代码
    BYTE                        byReserved[512];                                        // 保留字节
}NET_CASE_BACK_UP_STATE;

// 案件备份刻录文件信息
typedef struct tagNET_CASE_BACK_UP_FILE_INFO
{
    int                         nFileCount;                                             // 需要刻录的所有文件的总数量
    int                         nCurFileIndex;                                          // 当前正在刻录的文件的索引号   
    TP_U64                      nFileTotalLength;                                       // 需要刻录的总数据大小
    TP_U64                      nCurBackupTotalLength;                                  // 当前已经刻录了多少数据
    TP_U64                      nCurBackupFileTotalLength;                              // 当前正在刻录的文件的大小
    TP_U64                      nCurBackupFileLength;                                   // 当前正在刻录的文件已经刻录的数据大小   
    BYTE                        byReserved[512];                                        // 保留字节
}NET_CASE_BACK_UP_FILE_INFO;

// 案件备份刻录设备信息
typedef struct tagNET_CASE_BACK_UP_DEVICE_INFO
{
    int                         nDeviceID;                                              // 设备ID
    char                        szDeviceName[256];                                      // 设备名称
    int                         nTotalSpace;                                            // 设备总的容量 单位KB
    int                         nRemainSpace;                                           // 设备剩余容量 单位KB
    EM_CASE_BACK_UP_STATE_TYPE  emBackUpState;                                          // 备份状态
    EM_CASE_BACK_UP_ERROR_CODE  emErrorCode;                                            // 错误代码
    BYTE                        byReserved[512];                                        // 保留字节
}NET_CASE_BACK_UP_DEVICE_INFO;

// 案件备份刻录状态
typedef struct tagNET_OUT_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // 结构体大小
    NET_CASE_BACK_UP_STATE          stuBackUpState;                                     // 备份状态信息
    NET_CASE_BACK_UP_FILE_INFO      stuFileInfo;                                        // 备份文件信息
    int                             nDeviceNum;                                         // 设备数量    
    NET_CASE_BACK_UP_DEVICE_INFO    stuDeviceInfo[CASE_BACK_UP_DEVICE_MAX_NUM];         // 设备信息数组    
}NET_OUT_CASE_BACK_UP_STATE;

// 案件备份刻录状态回调函数
typedef void (CALLBACK *fAttachCaseBackUpState)(LLONG lLoginID, LLONG lAttachHandle, const NET_OUT_CASE_BACK_UP_STATE* pBuf, int nBufLen, LDWORD dwUser);

// 案件备份刻录状态attach操作入参
typedef struct tagNET_IN_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // 结构体大小  
    fAttachCaseBackUpState          cbAttachState;                                      // 回调函数
    LDWORD                          dwUser;                                             // 用户数据
}NET_IN_ATTACH_CASE_BACK_UP_STATE;

// 案件备份刻录状态attach操作出参
typedef struct tagNET_OUT_ATTACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // 结构体大小
}NET_OUT_ATTACH_CASE_BACK_UP_STATE;

// 案件备份刻录状态detach操作入参
typedef struct tagNET_IN_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // 结构体大小
}NET_IN_DETACH_CASE_BACK_UP_STATE;

// 案件备份刻录状态detach操作出参
typedef struct tagNET_OUT_DETACH_CASE_BACK_UP_STATE
{
    DWORD                           dwSize;                                             // 结构体大小
}NET_OUT_DETACH_CASE_BACK_UP_STATE;

// 获取案件备份刻录信息入参
typedef struct tagNET_IN_GET_CASE_BACK_UP_INFO
{
    DWORD                           dwSize;                                             // 结构体大小
}NET_IN_GET_CASE_BACK_UP_INFO;

// 获取案件备份刻录信息出参
typedef struct tagNET_OUT_GET_CASE_BACK_UP_INFO
{
    DWORD                               dwSize;                                         // 结构体大小
    NET_CASE_BACK_UP_QUERY_CONDITION    stuCondition;                                   // 备份条件
    NET_CASE_BACK_UP_MODE               stuMode;                                        // 备份模式
}NET_OUT_GET_CASE_BACK_UP_INFO;

// 开始案件备份刻录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBackUpCase(LLONG lLoginID, const NET_IN_START_CASE_BACK_UP* pstInParam, NET_OUT_START_CASE_BACK_UP *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 停止案件备份刻录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBackUpCase(LLONG lLoginID, const NET_IN_STOP_CASE_BACK_UP* pstInParam, NET_OUT_STOP_CASE_BACK_UP *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 监听案件备份刻录状态
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBackUpCaseState(LLONG lLoginID, const NET_IN_ATTACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_ATTACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 取消监听案件备份刻录状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBackUpCaseState(LLONG lAttachHandle, const NET_IN_DETACH_CASE_BACK_UP_STATE* pstInParam, NET_OUT_DETACH_CASE_BACK_UP_STATE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 获取案件备份刻录信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCaseBackUpInfo(LLONG lLoginID, const NET_IN_GET_CASE_BACK_UP_INFO* pstInParam, NET_OUT_GET_CASE_BACK_UP_INFO *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////// 案件自动备份系统（刻录） ///////////////////////////////////////


/////////////////////////////////// 组合通道 ///////////////////////////////////////

#define NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM 36     // 组合通道最大分割窗口数目

// 临时分割窗口信息
typedef struct tagNET_TEMP_SPLIT_WINDOW_INFO
{
    int nChannel;                                       // 叠加画面通道号
    BOOL bAudio;                                        // 是否混合音频
    DH_RECT stuPosition;                                // 窗口坐标,采用8192坐标系
    BYTE byReserved[128];                               // 保留字节
}NET_TEMP_SPLIT_WINDOW_INFO;

// 获取临时分割窗口信息入参
typedef struct tagNET_IN_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // 结构体大小
    int nComposeChannel;                                // 组合通道号
}NET_IN_GET_TEMP_SPLIT;

// 获取临时分割窗口信息出参
typedef struct tagNET_OUT_GET_TEMP_SPLIT
{
    DWORD dwSize;                                       // 结构体大小
    DH_SPLIT_MODE emSplitMode;                          // 分割模式，目前只支持最大32画面分割模式
    int nSplitNum;                                      // 临时分割窗口数量,目前只支持最大32画面分割
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // 临时分割窗口信息数组
}NET_OUT_GET_TEMP_SPLIT;

// 设置临时分割窗口信息入参
typedef struct tagNET_IN_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // 结构体大小
    int nComposeChannel;                                // 组合通道号
    DH_SPLIT_MODE emSplitMode;                          // 分割模式，目前只支持最大32画面分割模式
    int nSplitNum;                                      // 临时分割窗口数量,目前只支持最大32画面分割
    NET_TEMP_SPLIT_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // 临时分割窗口信息数组
}NET_IN_SET_TEMP_SPLIT;

// 设置临时分割窗口信息出参
typedef struct tagNET_OUT_SET_TEMP_SPLIT
{
    DWORD dwSize;                                       // 结构体大小
}NET_OUT_SET_TEMP_SPLIT;

// 分割窗口信息
typedef struct tagNET_TEMP_SOURCE_WINDOW_INFO
{
    int nWindowID;                                      // 窗口编号,从0开始
    int nUniqueChannel;                                 // 窗口绑定的通道源
    BYTE byReserved[128];                               // 保留字节
}NET_TEMP_SOURCE_WINDOW_INFO;

// 设置临时的分割窗口数据源入参
typedef struct tagNET_IN_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // 结构体大小
    int nComposeChannel;                                // 组合通道号
    int nWindowNum;                                     // 窗口数量
    NET_TEMP_SOURCE_WINDOW_INFO stuWindowInfo[NET_COMPOSE_CHANNEL_MAX_SPLIT_WINDOW_NUM]; // 窗口信息数组
}NET_IN_SET_TEMP_SOURCE;

// 设置临时的分割窗口数据源出参
typedef struct tagNET_OUT_SET_TEMP_SOURCE
{
    DWORD dwSize;                                       // 结构体大小   
}NET_OUT_SET_TEMP_SOURCE;

// 设置临时的分割窗口信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSplit(LLONG lLoginID, const NET_IN_SET_TEMP_SPLIT* pstInParam, NET_OUT_SET_TEMP_SPLIT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 获取临时的分割窗口信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTempSplit(LLONG lLoginID, const NET_IN_GET_TEMP_SPLIT* pstInParam, NET_OUT_GET_TEMP_SPLIT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 设置临时的分割窗口数据源
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTempSource(LLONG lLoginID, const NET_IN_SET_TEMP_SOURCE* pstInParam, NET_OUT_SET_TEMP_SOURCE *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////// 组合通道 ///////////////////////////////////////

/////////////////////////////////// Storage ///////////////////////////////////////

// 远程存储写入结果
typedef enum tagNET_STORAGE_WRITE_STATE
{
    NS_WRITE_UNKNOWN,                                   // 未知
    NS_WRITE_OK,                                        // 成功
    NS_WRITE_DISK_IO_ERROR,                             // 磁盘IO错误
    NS_WRITE_DISK_NOT_READY,                            // 磁盘未准备好
    NS_WRITE_DISK_FAULT,                                // 磁盘故障
    NS_WRITE_STREAM_NOT_EXIST,                          // 数据流ID不存在
    NS_WRITE_MOUNT_DISK_ERROR,                          // 磁盘挂载错误
} NET_STORAGE_WRITE_STATE;

// 远程区块信息
typedef struct tagNET_STORAGE_BLOCK 
{
    DWORD                   dwSize;
    unsigned int            nID;                        // CQFS块ID
    unsigned int            nStreamID;                  // 数据流唯一标识
    unsigned int            nRecycleTimestamp;          // CQFS回收时间戳
    unsigned int            nBeginTimestamp;            // 块内数据开始时间戳
    unsigned int            nEndTimestamp;              // 块内数据结束时间戳
    unsigned int            nLockCount;                 // 锁定计数值, 0表示未锁定
    char                    szDiskUUID[DH_COMMON_STRING_64]; // 磁盘UUID
} NET_STORAGE_BLOCK;

// 远程存储的信息状态
typedef struct tagNET_STORAGE_WRITE_INFO
{
    DWORD                    dwSize;
    NET_STORAGE_WRITE_STATE  emState;                   // 写入结果
    int                      nBlockCount;               // 块数量
    NET_STORAGE_BLOCK        stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // 块信息
} NET_STORAGE_WRITE_INFO;

//////////////////////////////////////////////////////////////////////////
/// \fn 订阅写入远程存储的信息状态回调函数
/// \brief 
/// \author yang_xiuqing
/// \param  LLONG lAttachHandle [OUT] 订阅句柄, CLIENT_NetStorageAttachWriteInfo的返回值 
/// \param  NET_STORAGE_WRITE_INFO * pBuf [OUT] 远程存储的信息状态
/// \param  int nBufLen [OUT] 状态信息长度
/// \param  LDWORD dwUser 用户数据
/// \return 无
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fNetStorageAttachWriteInfoCB)(LLONG lAttachHandle, NET_STORAGE_WRITE_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_NetStorageAttachWriteInfo 接口输入参数
typedef struct tagNET_IN_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                           dwSize;
    const char*                     pszName;                // 远程存储名称, 值从NAS配置中获取
    fNetStorageAttachWriteInfoCB    cbISCSIBlcok;           // 回调函数
    LDWORD                          dwUser;                 // 用户数据
} NET_IN_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageAttachWriteInfo 接口输出参数
typedef struct tagNET_OUT_STORAGE_ATTACH_WRITE_INFO
{
    DWORD                       dwSize;
} NET_OUT_STORAGE_ATTACH_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo 接口输入参数
typedef struct tagNET_IN_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;
    const char*                 pszName;                    // 远程存储名称
} NET_IN_STORAGE_GET_WRITE_INFO;

// CLIENT_NetStorageGetWriteInfo 接口输出参数
typedef struct tagNET_OUT_STORAGE_GET_WRITE_INFO 
{
    DWORD                       dwSize;    
    int                         nBlockCount;                // 块数量
    NET_STORAGE_BLOCK           stuBlocks[DH_MAX_NET_STRORAGE_BLOCK_NUM]; // 块信息
} NET_OUT_STORAGE_GET_WRITE_INFO;

// RAID操作类型
typedef enum tagNET_RAID_OPERATE_TYPE
{
    NET_RAID_OPERATE_ADD,                    // 添加RAID, 对应结构体 NET_IN_RAID_ADD 和 NET_OUT_RAID_ADD
    NET_RAID_OPERATE_REMOVE,                 // 删除RAID, 对应结构体 NET_IN_RAID_REMOVE 和 NET_OUT_RAID_REMOVE
    NET_RAID_OPERATE_GET_SUBDEVICE,          // 获取RAID子设备信息, 对应结构体 NET_IN_RAID_GET_SUBDEVICE 和 NET_OUT_RAID_GET_SUBDEVICE
    NET_RAID_OPERATE_GET_SUBSMART,           // 获取RAID子设备SMART信息, 对应结构体 NET_IN_RAID_GET_SUBSMART 和 NET_OUT_RAID_GET_SUBSMART
    NET_RAID_OPERATE_MODIFY,                 // 修改RAID, 对应结构体 NET_IN_RAID_MODIFY 和 NET_OUT_RAID_MODIFY
} NET_RAID_OPERATE_TYPE;

// RAID信息
typedef struct tagNET_RAID_INFO 
{
    DWORD                dwSize;
    char                 szName[DH_COMMON_STRING_64];     // 名称, 为空时名称由设备返回
    char                 szLevel[DH_COMMON_STRING_16];    // 等级, 例如"RAID0", "RAID5"等
    int                  nMemberNum;                      // 成员数量
    char                 szMembers[DH_MAX_MEMBER_PER_RAID][DH_COMMON_STRING_64]; // 成员信息
} NET_RAID_INFO;

// 添加RAID的返回结果
typedef struct tagNET_RAID_ADD_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                    // 失败错误码
    char                 szName[DH_COMMON_STRING_64];    // 名称
} NET_RAID_ADD_RESULT;

// 添加RAID输入参数
typedef struct tagNET_IN_RAID_ADD 
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID数量
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID信息
} NET_IN_RAID_ADD;

// 添加RAID输出参数
typedef struct tagNET_OUT_RAID_ADD 
{
    DWORD                dwSize;
    int                  nResultNum;                        // 结果数
    NET_RAID_ADD_RESULT  stuResults[DH_MAX_RAID_NUM];       // RAID操作的结果
} NET_OUT_RAID_ADD;

// 删除RAID的返回结果
typedef struct tagNET_RAID_REMOVE_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // 失败错误码
} NET_RAID_REMOVE_RESULT;

// 删除RAID输入参数
typedef struct tagNET_IN_RAID_REMOVE 
{
    DWORD                dwSize;
    int                  nRaidNum;                         // RAID数量
    char                 szRaids[DH_MAX_RAID_NUM][DH_COMMON_STRING_64];    // RAID名称数组
} NET_IN_RAID_REMOVE;

// 删除RAID输出参数
typedef struct tagNET_OUT_RAID_REMOVE
{
    DWORD                dwSize;
    int                  nResultNum;                       // 结果数
    NET_RAID_REMOVE_RESULT stuResults[DH_MAX_RAID_NUM];    // RAID操作的结果
} NET_OUT_RAID_REMOVE;

// 获取RAID子设备信息输入参数
typedef struct tagNET_IN_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    const char*          pszRaidName;                    // RAID名称
} NET_IN_RAID_GET_SUBDEVICE;

// 获取RAID子设备信息输出参数
typedef struct tagNET_OUT_RAID_GET_SUBDEVICE 
{
    DWORD                dwSize;
    int                  nSubDeviceNum;                  // 子设备数量
    DH_STORAGE_DEVICE    stuSubDevices[DH_MAX_MEMBER_PER_RAID]; // 子设备信息
} NET_OUT_RAID_GET_SUBDEVICE;

// RAID子设备SMART信息
typedef struct tagNET_RAID_SMART_INFO 
{
    DWORD                dwSize;
    unsigned int         nID;                            // 属性ID
    char                 szName[DH_COMMON_STRING_64];    // 属性名
    int                  nCurrent;                       // 属性值
    int                  nWorst;                         // 最大出错值
    int                  nThreshold;                     // 阈值
    int                  nPredict;                       // 状态
    char                 szRaw[DH_COMMON_STRING_16];     // 实际值
} NET_RAID_SMART_INFO;

// 获取RAID子设备SMART信息输入参数
typedef struct tagNET_IN_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    const char*          pszSubDevName;                  // RAID子设备名称
} NET_IN_RAID_GET_SUBSMART;

// 获取RAID子设备SMART信息输出参数
typedef struct tagNET_OUT_RAID_GET_SUBSMART
{
    DWORD                dwSize;
    int                  nSmartNum;                          // SMART信息数
    NET_RAID_SMART_INFO  stuSmartInfos[MAX_SMART_VALUE_NUM]; // SMART信息
} NET_OUT_RAID_GET_SUBSMART;

// 修改RAID的返回结果
typedef struct tagNET_RAID_MODIFY_RESULT 
{
    DWORD                dwSize;
    BOOL                 bResult;
    DWORD                dwErrorCode;                       // 失败错误码
} NET_RAID_MODIFY_RESULT;

// 修改RAID输入参数
typedef struct tagNET_IN_RAID_MODIFY
{
    DWORD                dwSize;
    int                  nRaidNun;                          // RAID数量
    NET_RAID_INFO        stuRaids[DH_MAX_RAID_NUM];         // RAID信息
} NET_IN_RAID_MODIFY;

// 修改RAID输出参数
typedef struct tagNET_OUT_RAID_MODIFY 
{
    DWORD                dwSize;
    int                  nResultNum;                        // 结果数
    NET_RAID_MODIFY_RESULT stuResults[DH_MAX_RAID_NUM];     // RAID操作的结果
} NET_OUT_RAID_MODIFY;


//////////////////////////////// 外部设备 //////////////////////////////////////////

// 外接设备类型
typedef enum tagNET_EXT_DEV_TYPE
{
    EXT_DEV_UNKNOWN,                    // 未知
    EXT_DEV_PROJECTOR,                  // 投影仪
    EXT_DEV_SEQUENCE_POWER,            // 电源序列器
} NET_EXT_DEV_TYPE;

// 外接设备信息
typedef struct tagNET_EXTERNAL_DEVICE 
{
    DWORD               dwSize;
    NET_EXT_DEV_TYPE    emType;                             // 设备类型
    char                szDevID[DH_DEV_ID_LEN_EX];          // 设备ID, 唯一编号
    char                szDevName[DH_DEV_ID_LEN_EX];        // 设备名称
} NET_EXTERNAL_DEVICE;

// 电源时序器控制参数
typedef struct tagNET_CTRL_SEQPOWER_PARAM
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // 设备ID
    int                 nChannel;                           // 输出口或输出组序号
} NET_CTRL_SEQPOWER_PARAM;

// 投影仪控制参数
typedef struct tagNET_CTRL_PROJECTOR_PARAM 
{
    DWORD               dwSize;
    const char*         pszDeviceID;                        // 设备ID
} NET_CTRL_PROJECTOR_PARAM;

// 红外按键
typedef struct tagNET_CTRL_INFRARED_KEY_PARAM 
{
    DWORD               dwSize;
    int                 nChannel;                           // 红外控制通道号
    unsigned int        nKey;                               // 红外按键ID
} NET_CTRL_INFRARED_KEY_PARAM;

// 无硬盘报警
typedef struct tagALARM_NO_DISK_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                            // 时间
    DWORD               dwAction;                           // 事件动作, 0:Start, 1:Stop
}ALARM_NO_DISK_INFO;
//防护舱状态枚举
typedef enum __EM_CAPSULE_STATE
{
    CAPSULE_STATE_UNKNOW ,      //未定义
    CAPSULE_STATE_NORMAL ,      //正常
    CAPSULE_STATE_TIME_OUT ,    //超时
    CAPSULE_STATE_EMERGENCY_CALL,   //紧急呼叫
}EM_CAPSULE_STATE;

//防护舱事件
typedef struct tagALARM_PROTECTIVE_CAPSULE_INFO
{
    DWORD               dwSize;
    EM_CAPSULE_STATE    emCapsuleState; //防护舱状态
    DWORD               nLock;          //0:未锁,1:上锁; 仅在emCapsuleState为CAPSULE_STATE_NORMAL时有效
    DWORD               nInfrared;      //0:闲置(无人),1:触发(有人);仅在emCapsuleState为CAPSULE_STATE_NORMAL时有效
}ALARM_PROTECTIVE_CAPSULE_INFO;

// 获取鱼眼能力输入参数
typedef struct tagNET_IN_VIDEOIN_FISHEYE_CAPS
{
    DWORD                dwSize; 
    int                  nChannel;  //通道号
}NET_IN_VIDEOIN_FISHEYE_CAPS;

// 获取鱼眼能力输出参数
typedef struct tagNET_OUT_VIDEOIN_FISHEYE_CAPS
{
    DWORD                       dwSize; 
    int                         nMountModeNum;                     // 支持的安装模式个数         
    NET_FISHEYE_MOUNT_MODE      emMountModes[NET_MAX_FISHEYE_MOUNTMODE_NUM]; // 支持的安装模式列表
    int                         nCalibrateModeNum;                 // 支持的鱼眼矫正模式个数  
    NET_FISHEYE_CALIBRATE_MODE  emCalibrateModes[NET_MAX_FISHEYE_CALIBRATEMODE_NUM]; // 支持的鱼眼矫正模式列表
    int                         nEPtzCmdNum;                       // 支持的鱼眼电子云台操作个数 
    NET_FISHEYE_EPTZ_CMD        emEPtzCmds[NET_MAX_FISHEYE_EPTZCMD_NUM]; // 支持的鱼眼电子云台操作列表
    NET_FISHEYE_TYPE            emType;                                 //鱼眼类型
}NET_OUT_VIDEOIN_FISHEYE_CAPS;

// 获取电源时序器能力输入参数
typedef struct tagNET_IN_CAP_SEQPOWER 
{
    DWORD                dwSize;
    const char*          pszDeviceID;                       // 设备ID
} NET_IN_CAP_SEQPOWER;

// 获取电源时序器能力输出参数
typedef struct tagNET_OUT_CAP_SEQPOWER
{
    DWORD                dwSize;
    int                  nChannelNum;                       // 通道数
} NET_OUT_CAP_SEQPOWER;

// 获取设备编码配置对应能力输入参数
typedef struct tagNET_IN_ENCODE_CFG_CAPS
{
    DWORD               dwSize;           
    int                 nChannelId;                         // 通道号    
    int                 nStreamType;                        // 码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；4：抓图码流
                                                            // 此参数可以不填,不论指定什么类型,设备都返回主、辅、抓图码流的能力
    char*               pchEncodeJson;                      // Encode配置,通过调用dhconfigsdk.dll中接口CLIENT_PacketData封装得到
                                                            // 对应的封装命令为 CFG_CMD_ENCODE                 
}NET_IN_ENCODE_CFG_CAPS;

// 码流配置对应能力
typedef struct tagNET_STREAM_CFG_CAPS
{
    DWORD               dwSize;
    int                 nAudioCompressionTypes[DH_MAX_AUDIO_ENCODE_TYPE]; // 支持的音频编码类型,详见DH_TALK_CODING_TYPE
    int                 nAudioCompressionTypeNum;                   // 音频压缩格式个数
    int                 dwEncodeModeMask;                           // 视频编码模式掩码,详见"编码模式"
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];// 支持的视频分辨率
    int                 nResolutionFPSMax[DH_MAX_CAPTURE_SIZE_NUM]; // 不同分辨率下帧率最大值,下标与nResolutionTypes对应 
    int                 nResolutionTypeNum;                         // 视频分辨率个数
    int                 nMaxBitRateOptions;                         // 最大视频码流(kbps) 
    int                 nMinBitRateOptions;                         // 最小视频码流(kbps)
    BYTE                bH264ProfileRank[DH_PROFILE_HIGH];          // 支持的H.264 Profile等级,参照枚举类型 EM_H264_PROFILE_RANK;  
    int                 nH264ProfileRankNum;                        // 支持的H.264 Profile等级个数
    int                 nCifPFrameMaxSize;                          // 当分辨率为cif时最大p帧(Kbps)
    int                 nCifPFrameMinSize;                          // 当分辨率为cif时最小p帧(Kbps)
    int                 nFPSMax;                                    // 视频帧率最大值,为0时,以nResolutionFPSMax为准
    DH_RESOLUTION_INFO  stuIndivResolutionTypes[DH_MAX_COMPRESSION_TYPES_NUM][DH_MAX_CAPTURE_SIZE_NUM];// 支持的视频分辨率
	BOOL				abIndivResolution;							// 0: stuResolutionTypes,nResolutionTypeNum 有效 
                                                                    // 1: stuIndivResolutionTypes, nIndivResolutionNums 有效
    int                 nIndivResolutionNums[DH_MAX_COMPRESSION_TYPES_NUM];// 不同编码模式分别支持的视频分辨率个数
}NET_STREAM_CFG_CAPS;

// 获取设备编码配置对应能力输出参数
typedef struct tagNET_OUT_ENCODE_CFG_CAPS
{
    DWORD               dwSize;
    NET_STREAM_CFG_CAPS stuMainFormatCaps[DH_REC_TYPE_NUM];         // 主码流配置对应能力, 如果有多个, 第一个表示普通录像码流, 第二个表示动检录像码流, 第三个表示报警录像码流
    NET_STREAM_CFG_CAPS stuExtraFormatCaps[DH_N_ENCODE_AUX];        // 辅码流配置对应能力, 如果有多个, 第一个表示辅码流1, 第二个表示辅码流2, 第三个表示辅码流3
    NET_STREAM_CFG_CAPS stuSnapFormatCaps[SNAP_TYP_NUM];           // 抓图码流配置对应能力, 如果有多个, 第一个表示普通抓图, 第二个表示动检抓图, 第三个表示报警抓图
    int                 nMainFormCaps;                              // 有效的主码流配置对应的能力个数
    int                 nExtraFormCaps;                             // 有效的辅码流配置对应的能力个数
    int                 nSnapFormatCaps;                            // 有效的抓图码流配置对应的能力个数
}NET_OUT_ENCODE_CFG_CAPS;


//获取视频检测输入能力集
typedef struct tagNET_IN_VIDEO_DETECT_CAPS
{
    DWORD               dwSize;           
    int                 nChannel;  //通道号 
}NET_IN_VIDEO_DETECT_CAPS;

// 媒体能力集类型
typedef enum tagNET_MEDIA_CAP_TYPE
{
    NET_MEDIA_CAP_TYPE_SENSORINFO,      // 镜头传感器信息
} NET_MEDIA_CAP_TYPE;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS 命令入参
typedef struct tagNET_IN_MEDIAMANAGER_GETCAPS
{
    DWORD               dwSize;
    NET_MEDIA_CAP_TYPE  emType;         // 需要获取的能力集类型
} NET_IN_MEDIAMANAGER_GETCAPS;

// 获取设备编码配置对应能力输入参数	 
typedef struct tagNET_IN_SNAP_CFG_CAPS	 	 	 
{        	 	 	 
    int                 nChannelId;                     // 通道号(起始通道0) 	 	 	 
    BYTE                bReserved[1024];                // 保留	 	 	 
}NET_IN_SNAP_CFG_CAPS;	 	 	 

#define DH_MAX_FPS_NUM                128                // 最大支持的帧率个数	 	 	 
#define DH_MAX_QUALITY_NUM            32                 // 最大支持的画质个数	 	 	 

// 抓图配置能力	 	 	 
typedef struct tagNET_OUT_SNAP_CFG_CAPS 	 	 	 
{	 	 	 
    int                 nResolutionTypeNum;                // 支持的视频分辨率信息	 	 	 
    DH_RESOLUTION_INFO  stuResolutionTypes[DH_MAX_CAPTURE_SIZE_NUM];	 	 	 
    DWORD               dwFramesPerSecNum;                 // 支持的帧率信息	 	 	 
    int                 nFramesPerSecList[DH_MAX_FPS_NUM]; // -25：25秒1帧；-24：24秒1帧；……	 	 	 
                                                           // 0：无效；1：1秒1帧；2：1秒2帧；3：1秒3帧	 	 	 
                                                           // 4：1秒4帧；5：1秒5帧；17：1秒17帧；18：1秒18帧	 	 	 
                                                           // 19：1秒19帧；20：1秒20帧……	 	 	 
    DWORD               dwQualityMun;                      // 支持的画质信息	 	 	 
    DWORD               nQualityList[DH_MAX_QUALITY_NUM];  // 1-6档（6质量最高） 	 	 
    DWORD               dwMode;                            // 模式,按位：第一位：定时；第二位：手动。	 	 	 
    DWORD               dwFormat;                          // 图片格式模式,按位：第一位：bmp；第二位：jpg。	 	 	 
    BYTE                bReserved[2048];                   // 保留	 	 	 
} NET_OUT_SNAP_CFG_CAPS;

// 镜头传感器类型
typedef enum tagNET_CAMERA_SENSOR
{
    NET_CAMERA_SENSOR_NORMAL,           // 一般（可见光）
    NET_CAMERA_SENSOR_LEPTON,           // Lepton 热成像
    NET_CAMERA_SENSOR_TAU,              // Tau 热成像
} NET_CAMERA_SENSOR;

// 镜头传感器信息
typedef struct tagNET_CAMERA_SENSORINFO
{
    NET_CAMERA_SENSOR   emSensorType;       // 传感器类型
    int                 nChannelsCount;     // 此传感器类型对应的通道个数
    int                 nChannels[512];     // 此传感器类型对应的通道号
    char                reserved[512];
} NET_CAMERA_SENSORINFO;

// 媒体信息――镜头传感器
typedef struct tagNET_MEDIA_SENSORINFO
{
    BOOL                    bSupport;               // 是否支持本能力获取,为TRUE时以下成员有效
    int                     nSensorTypeCount;       // 设备具有的镜头传感器类型个数
    NET_CAMERA_SENSORINFO   stuDetail[16];          // 每个传感器类型的详细信息,有效个数由 nSensorTypeCount 指明
    char                    reserved[1024];
} NET_MEDIA_SENSORINFO;

// CLIENT_GetDevCaps NET_MEDIAMANAGER_CAPS 命令出参
typedef struct tagNET_OUT_MEDIAMANAGER_GETCAPS
{
    DWORD                   dwSize;
    NET_MEDIA_SENSORINFO    stuSensorInfo;          // 镜头传感器信息
} NET_OUT_MEDIAMANAGER_GETCAPS;

// 视频输入能力类型
typedef enum tagNET_ENUM_VIDEOIN_CAP_TYPE
{
    NET_VIDEOIN_CAP_TYPE_CONFLICT,                          // 设备视频输出能力冲突能力项，对应出参NET_OUT_VIDEOIN_CONFLICT_CAPS
}NET_ENUM_VIDEOIN_CAP_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_CAPS
{
    DWORD                               dwSize;
    int                                 nChannel;                    // 通道号
    NET_ENUM_VIDEOIN_CAP_TYPE           emCapType;                   // 设备视频输出能力类型
}NET_IN_VIDEOIN_CAPS;

typedef enum tagNET_ENUM_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE_UNKNOWN,                          // 未知
    NET_ENUM_CONFLICT_TYPE_MAIN,                             // 主码流
    NET_ENUM_CONFLICT_TYPE_EXTRA1,                           // 辅码流1
    NET_ENUM_CONFLICT_TYPE_EXTRA2,                           // 辅码流2
    NET_ENUM_CONFLICT_TYPE_TVOUT,                            // 模拟输出
    NET_ENUM_CONFLICT_TYPE_DSP,                              // 智能
    NET_ENUM_CONFLICT_TYPE_SMARTENC,                         // Smart编码(长GOP)
    NET_ENUM_CONFLICT_TYPE_SETGOP,                           // 设置GOP
    NET_ENUM_CONFLICT_TYPE_ROI,                              // 感兴趣区域
    NET_ENUM_CONFLICT_TYPE_CBR,                              // 恒定码流编码
    NET_ENUM_CONFLICT_TYPE_SVC,                              // SVC编码
    NET_ENUM_CONFLICT_TYPE_MJPEG,                            // MJPEG编码
    NET_ENUM_CONFLICT_TYPE_ROTATE_90,                        // 旋转90度
}NET_ENUM_CONFLICT_TYPE;

typedef struct tagNET_CONFLICT_TYPE
{
    NET_ENUM_CONFLICT_TYPE      emConflict1;                 // 冲突项1              
    NET_ENUM_CONFLICT_TYPE      emConflict2;                 // 冲突项2
    char                        reserved[64];
}NET_CONFLICT_TYPE;
// CLIENT_GetDevCaps NET_VIDEOIN_CAPS 命令出参
typedef struct tagNET_VIDEOIN_CONFLICT_CAPS
{
    BOOL                        bConflict;                  // 是否存在资源冲突项
    int                         nConflictNum;               // 冲突项数量
    NET_CONFLICT_TYPE           stuConflict[MAX_VIDEOIN_CONFLICT_NUM];           // 冲突项
}NET_VIDEOIN_CONFLICT_CAPS;

typedef struct tagNET_OUT_VIDEOIN_CAPS
{
    DWORD                       dwSize;
    NET_VIDEOIN_CONFLICT_CAPS   stuConflictCap;             // 资源冲突结构体
}NET_OUT_VIDEOIN_CAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS命令入参
typedef struct tagNET_IN_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;						// 用户使用时赋值为结构体大小
} NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps  NET_VIDEO_MOSAIC_CAPS命令出参
typedef struct tagNET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS
{
	DWORD               dwSize;									// 用户使用时赋值为结构体大小
	int					nSupportCount;							// 实际支持叠加马赛克的通道数量
	short				snSupport[MAX_MOSAIC_CHANNEL_NUM];		// 支持叠加马赛的通道，[-1]表示全支持
	int					nMosaicCount;							// 实际支持的马赛克颗粒数量
	char				szMosaic[MAX_MOSAIC_NUM];				// 支持的马赛克颗粒大小
	DH_SIZE				stuRectMax;								// 马赛克最大区块尺寸
	DH_SIZE				stuRectMin;								// 马赛克最小区块尺寸
} NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS;

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS 命令入参
typedef struct tagNET_IN_FACEBOARD_CAPS
{
    DWORD               dwSize;						            // 该结构体大小
}NET_IN_FACEBOARD_CAPS;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS 命令入参
typedef struct tagNET_IN_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               dwSize;									// 用户使用时赋值为结构体大小
	int					nChannel;								// 通道号
} NET_IN_VIDEO_IMAGECONTROL_CAPS;

// 防抖类型
typedef enum tagNET_EM_STABLE_CAPS_TYPE
{
	EM_STABLE_UNSPPORT,					// 不支持图像防抖
	EM_STABLE_ELEC,						// 支持电子防抖
	EM_STABLE_LIGHT,					// 支持光学防抖
	EM_STAVLE_ELEC_AND_LIGHT,			// 支持电子防抖和光学防抖
	EM_STABLE_CONTROL,					// 支持控件防抖
	EM_STABLE_ELEC_AND_CONTROL,			// 支持电子防抖和控件防抖
	EM_STABLE_LIGHT_AND_CONTROL,		// 支持光学防抖和控件防抖
} NET_EM_STABLE_CAPS_TYPE;

// CLIENT_GetDevCaps NET_VIDEO_IMAGECONTROL_CAPS 命令出参
typedef struct tagNET_OUT_VIDEO_IMAGECONTROL_CAPS
{
	DWORD               			dwSize;							// 用户使用时赋值为结构体大小
	BOOL							bSupport;						// Mirror,Flip,Rotate90三者任一支持则true
	BOOL							bMirror;						// 是否支持画面镜像功能
	BOOL							bFlip;							// 是否支持画面180翻转功能
	BOOL							bRotate90;						// 支持的画面90/270度旋转
	BOOL							bFreeze;						// 是否支持图像冻结功能
	NET_EM_STABLE_CAPS_TYPE			emStable;						// 支持图像防抖的功能
} NET_OUT_VIDEO_IMAGECONTROL_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               dwSize;									// 用户使用时赋值为结构体大小
	int					nChannel;								// 通道号
} NET_IN_VIDEOIN_EXPOSURE_CAPS;

#define MAX_EXPOSURE_COUNT	8

// 曝光模式
typedef enum tagNET_EM_EXPOSURE_MODE
{
	NET_EM_EXPOSURE_AUTO,					// 默认自动
	NET_EM_EXPOSURE_LOWNICE,				// 低噪声
	NET_EM_EXPOSURE_ANTISHADOW,				// 防拖影
	NET_EM_EXPOSURE_MANUALRANGE	= 4,		// 手动区间
	NET_EM_EXPOSURE_APERTUREFIRST,			// 光圈优先
	NET_EM_EXPOSURE_MANUALFIXATION,			// 手动固定
	NET_EM_EXPOSURE_GIANFIRST,				// 增益优先
	NET_EM_EXPOSURE_SHUTTERFIRST,			// 快门优先
	NET_EM_EXPOSURE_FLASHMATCH,				// 闪光灯匹配模式
} NET_EM_EXPOSURE_MODE;

// 防闪烁模式
typedef enum tagNET_EM_ANTIFLICKER_MODE
{
	NET_EM_ANTIFLICKER_OUTDOOR,			// 室外
	NET_EM_ANTIFLICKER_50HZ,			// 50Hz
	NET_EM_ANTIFLICKER_60HZ,			// 60Hz
} NET_EM_ANTIFLICKER_MODE;

// 曝光速度等级能力数组，值是分母，单位秒。比如100表示1/100秒的曝光时间
// "-1"表示支持用户区间可调，如果不含该字段，表示不支持用户区间可调
typedef struct tagNET_SPEED_CAPS
{
	int			nRetManual;								// 手动模式下的快门实际个数
	int			nManual[DH_COMMON_STRING_16];			// 手动模式下的快门列表
	int			nRetManual50Hz;							// 防闪烁50HZ 模式下，手动模式对应的快门实际个数
	int			nManual50Hz[DH_COMMON_STRING_16];		// 防闪烁50HZ 模式下，手动模式对应的快门列表
	int			nRetManual60Hz;							// 防闪烁60HZ 模式下，手动模式对应的快门实际个数
	int			nManual60Hz[DH_COMMON_STRING_16];		// 防闪烁60HZ 模式下，手动模式对应的快门列表
	int			nRetShutterPAL;							// 快门优先下的P制快门实际个数
	int			nShutterPAL[DH_COMMON_STRING_16];		// 快门优先下的P制快门列表
	int			nRetShutterNTSC;						// 快门优先下的N制快门实际个数
	int			nShutterNTSC[DH_COMMON_STRING_16];		// 快门优先下的N制快门列表
	BYTE		bReserved[128];							// 预留字段
} NET_SPEED_CAPS;

typedef struct tagNET_SLOW_SPEED_CAPS
{
	int			nRetPal;
	int			nPal[DH_COMMON_STRING_16];
	int			nRetNtsc;
	int			nNtsc[DH_COMMON_STRING_16];
	BYTE		bReserved[128];					// 预留字段
} NET_SLOW_SPEED_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_EXPOSURE_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_EXPOSURE_CAPS
{
	DWORD               		dwSize;									// 用户使用时赋值为结构体大小
	BOOL						bSupport;								// 是否支持曝光设置能力
	int							nExposureMode;							// 实际支持的曝光模式个数
	NET_EM_EXPOSURE_MODE		emExposureMode[MAX_EXPOSURE_COUNT];		// 支持的曝光模式
	BOOL						bAntiFlicker;							// 是否支持防闪烁
	int							nAntiFlicker;							// 实际支持的防闪烁功能个数
	NET_EM_ANTIFLICKER_MODE		emAntiFlicker[MAX_ANTIFLICKERMODE_COUNT];	// 防闪烁功能列表
	int							nMinCompensation;						// 曝光补偿最小值
	int							nMaxCompensation;						// 曝光补偿最大值
	BOOL						bGainUpperLimit;						// 支持增益上限选项能力
																		// true:在自动，光圈优先，快门优先模式显示增益上限选项。
																		// false: 在自动，光圈优先，快门优先模式隐藏增益上限选项
	int							nMinGain;								// 增益最小值
	int							nMaxGain;								// 增益最大值
	BOOL						bSlowAutoExposure;						// 是否支持慢曝光设置能力, 默认支持
																		// 如果有该字段且值为false，不下发慢曝光设置，如果没有此值或者值为true，则下发慢曝光配置
	int							nMinSlowAutoExposure;					// 慢曝光最小值
	int							nMaxSlowAutoExposure;					// 慢曝光最大值
	BOOL						bSlowShutter;							// 是否支持慢快门
	float						fMinValueLow;							// 自动曝光时间下限最小值
	float						fMaxValueLow;							// 自动曝光时间下限最大值
	float						fMinValueUp;							// 自动曝光时间上限最小值
	float						fMaxValueUp;							// 自动曝光时间上线最大值
	NET_SPEED_CAPS				stuSpeedCaps;							// 曝光速度等级能力
	NET_SLOW_SPEED_CAPS			stuSlowSpeedCaps;						// 慢曝光速度等级能力
	BOOL						bIrisAuto;								// 是否支持自动光圈
	int							nIrisMin;								// 手动光圈设置最小值
	int							nIrisMax;								// 手动光圈设置最大值
	BOOL						bSupportIrisRange;						// 支持光圈区间可调能力
	BOOL						bDoubleExposure;						// 是否支持ITC双快门调节
	BOOL						bRecoveryTime;							// 是否支持自动曝光恢复
} NET_OUT_VIDEOIN_EXPOSURE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_DENOISE_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_DENOISE_CAPS;

// 支持的3D降噪类型
typedef enum tagNET_EM_3DSUPPORT_TYPE
{
	NET_EM_3DSUPPORT_UNKOWN,									// 未知
	NET_EM_3DSUPPORT_OFF,										// 关闭
	NET_EM_3DSUPPORT_AUTO,										// 自动
	NET_EM_3DSUPPORT_MANUAL,									// 手动
} NET_EM_3DSUPPORT_TYPE;

// 3D降噪支持的算法模式
typedef struct tagNET_3D_ALGORITHM_MODE
{
	// 采用掩码表示，bit0,bit1,bit2...分别表示降噪算法bit0、降噪算法bit1、
	// 降噪算法bit2，以此类推.全为0，表示都不支持降噪算法
	DWORD	dwSingleExposure;				// 单快门降噪能力
	DWORD	dwDoubleExposureFullRate;		// ITC双快门全帧率降噪能力
	DWORD	dwDoubleExposureHalfRate;		// ITC双快门半帧率降噪能力
	DWORD	dsThreeExposure;				// 三快门降噪能力
	BYTE	bReserved[128];					// 预留字段
} NET_3DALGORITHM_MODE;

#define		MAX_3DTYPE_COUNT			8			// 最大支持的3D降噪类型个数 
#define		MAX_GROUP_COUNT				2			// 降噪分组最大值
#define		MAX_PROGRAM_COUNT			8			// 降噪分组每组支持的最大方案数

// 2D降噪能力
typedef struct tagNET_SUPPORT2D_CAPS
{
	BOOL						bSupport2D;								// 是否支持2D降噪
	int							n2DLevelMin;							// 2D降噪等级最小值
	int							n2DLevelMax;							// 2D降噪等级最大值
	int							nMaxRAWLevel;							// 持最大RAW域的2D降噪值, 0 表示不支持
	BYTE						bReserved[128];							// 预留字段
} NET_SUPPORT2D_CAPS;

// 每组降噪分组支持的方案信息
typedef struct tagNET_DENOISEGROUP_PROGRAM
{
	int							nProgramCount;								// 实际的方案个数
	int							nProgram[MAX_PROGRAM_COUNT];			// 支持的方案列表
} NET_DENOISEGROUP_PROGRAM;

// 3D降噪能力
typedef struct tagNET_SUPPORT3D_CAPS
{
	BOOL						bSupport3D;								// 是否支持3D降噪
	int							n3DTypeCount;							// 支持的3D降噪类型个数
	NET_EM_3DSUPPORT_TYPE		em3DSupportType[MAX_3DTYPE_COUNT];		// 支持的3D降噪类型
	int							n3DLevelMin;							// 3D降噪等级最小值
	int							n3DLevelMax;							// 3D降噪等级最大值
	int							nAutoLevelMin;							// 3D自动控制模式最小值
	int							nAutoLevelMax;							// 3D自动控制模式最大值
	NET_3DALGORITHM_MODE		stuAlgorithmSDMode;						// 3D降噪支持的算法模式
	int							nGroupCount;							// 实际分组个数
	NET_DENOISEGROUP_PROGRAM	stuDenoiseGroup[MAX_GROUP_COUNT]; 		// 降噪分组，切换前后方案属于同一组或几组则不重启生效，否则重启生效，数值n对应, DenoiseMode中bit(n)对应的方案
	int							nDenoiseScheme;							// 降噪方案, 1表示采用新方案方式设置降噪参数,0表示直接设置参数方式设置降噪参数（旧方案）
	BYTE						bReserved[128];							// 预留字段
} NET_SUPPORT3D_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DENOISE_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_DENOISE_CAPS
{
	DWORD						dwSize; 								// 用户使用时赋值为结构体大小
	BOOL						bSupport;								// 是否支持降噪设置
	NET_SUPPORT2D_CAPS			stu2DCaps;								// 2D降噪能力 
	NET_SUPPORT3D_CAPS			stu3DCaps;								// 3D降噪能力
	BOOL						bSupportAlgorithm1;						// 是否支持降噪算法1
	int							nTnfLevelRangeMin;						// 时域等级最小值
	int							nTnfLevelRangeMax;						// 时域等级最大值
	int							nSnfLevelRangeMin;						// 空域等级最小值
	int							nSnfLevelRangeMax;						// 空域等级最大值
	int							nSeniotTypeCount;						// 支持的高级降噪类型个数
	NET_EM_3DSUPPORT_TYPE		emSeniorType[MAX_3DTYPE_COUNT];		// 支持的高级降噪类型
} NET_OUT_VIDEOIN_DENOISE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_BACKLIGHT_CAPS;

// 背光模式
typedef enum tagNET_EM_BACK_MODE
{
	NET_EM_BACKLIGHT_MODE_UNKNOW,					// 未知模式
	NET_EM_BACKLIGHT_MODE_OFF,						// 关闭
	NET_EM_BACKLIGHT_MODE_BACKLIGHT,				// 背光补偿
	NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC,				// 宽动态
	NET_EM_BACKLIGHT_MODE_GLAREINHIBITION,			// 强光抑制
	NET_EM_BACKLIGHT_MODE_SSA,						// 场景自适应
} NET_EM_BACK_MODE;

// 背光补偿模式
typedef enum tagNET_EM_BLACKLIGHT_MODE
{
	NET_EM_BLACKLIGHT_UNKNOW,						// 未知模式
	NET_EM_BLACKLIGHT_DEFAULT,						// 默认模式
	NET_EM_BLACKLIGHT_REGION,						// 自定义区域模式
} NET_EM_BLACKLIGHT_MODE;

// 场景自适应对比度强度调节模式
typedef enum tagNET_EM_BACK_INTENSITY_MODE
{
	NET_EM_INTENSITY_UNKNOWN,			// 未知
	NET_EM_INTENSITY_OFF,				// 关闭
	NET_EM_INTENSITY_AUTO,				// 自动
	NET_EM_INTENSITY_MANUAL,			// 手动
} NET_EM_BACK_INTENSITY_MODE;

// 支持强光抑制模式的参数设置方式
typedef enum tagNET_EM_GLAREINHIBITION_MODE
{
	NET_EM_GLAREINHIBITION_UNKNOWN,		// 未知
	NET_EM_GLAREINHIBITION_DEFAULT,		// 普通模式(默认值)
	NET_EM_GLAREINHIBITION_FPGA,		// Fpga强光抑制
} NET_EM_GLAREINHIBITION_MODE;

#define MAX_MODE_COUNT		8		// 模式最大支持数

// CLIENT_GetDevCaps NET_VIDEOIN_BACKLIGHT_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_BACKLIGHT_CAPS
{
	DWORD						dwSize; 								// 用户使用时赋值为结构体大小
	BOOL						bSupport;								// 是否支持背光设置能力
	int							nBackModeCount;							// 背光模式实际支持数量
	NET_EM_BACK_MODE			emBackMode[MAX_MODE_COUNT];				// 支持的背光模式
	int							nBackLightModeCount;					// 背光补偿模式实际支持数
	NET_EM_BLACKLIGHT_MODE		emBackLightMode[MAX_MODE_COUNT];		// 支持的背光补偿模式
	int							nWideDynamicRange;						// 是否支持宽动态
	int							nSSAIntensity;							// 场景自适应对比度强度调节支持的模式数量
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode[MAX_MODE_COUNT];		// 场景自适应对比度强度调节支持的模式
	NET_EM_GLAREINHIBITION_MODE	emGlareInhibition[MAX_MODE_COUNT];		// 支持强光抑制模式的参数设置方式
} NET_OUT_VIDEOIN_BACKLIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_WHITEBALANCE_CAPS;

// 白平衡模式
typedef enum tagNET_EM_WHITEBALANCE_TYPE
{
	NET_EM_WHITEBALANCE_UNKNOW,					// 未知类型
	NET_EM_WHITEBALANCE_DISABLE,				// Disable
	NET_EM_WHITEBALANCE_AUTO,					// Auto
	NET_EM_WHITEBALANCE_SUNNY,					// Sunny晴天,6500K左右
	NET_EM_WHITEBALANCE_CLOUDY,					// Cloudy阴天,7500K左右
	NET_EM_WHITEBALANCE_HOME,					// Home家里 5000K左右
	NET_EM_WHITEBALANCE_OFFICE,					// Office办公 4400K左右 
	NET_EM_WHITEBALANCE_NIGHT,					// Night夜晚 2800K左右
	NET_EM_WHITEBALANCE_CUSTOM,					// Custom自定义
	NET_EM_WHITEBALANCE_HIGHCOLORTEMP,			// HighColorTemperature高色温区间
	NET_EM_WHITEBALANCE_LOWCOLORTEMP,			// LowColorTemperature低色温区间
	NET_EM_WHITEBALANCE_AUTOCOLORTEMP,			// AutoColorTemperature自动色温区间
	NET_EM_WHITEBALANCE_CUSTOMCOLORTEMP,		// CustomColorTemperature自定义色温等级
	NET_EM_WHITEBALANCE_INDOOR,					// Indoor室内
	NET_EM_WHITEBALANCE_OUTDOOR,				// Outdoor室外,重点保证大面积绿草地不偏色
	NET_EM_WHITEBALANCE_ATW,					// ATW跟踪
	NET_EM_WHITEBALANCE_MANUAL,					// Manual手动
	NET_EM_WHITEBALANCE_AUTOOUTDOOR,			// AutoOutdoor
	NET_EM_WHITEBALANCE_SODIUMAUTO,				// SodiumAuto钠灯自动
	NET_EM_WHITEBALANCE_SODIUM,					// Sodium钠灯, 2000K左右
	NET_EM_WHITEBALANCE_MANUALDATUM,			// ManualDatum自定义单区域白平衡
	NET_EM_WHITEBALANCE_PARTWHITEBALANCE,		// PartWhiteBalance自定义多区域白平衡
	NET_EM_WHITEBALANCE_NATURAL,				// Natural自然光, 2000K-12000K 晴天阴天+傍晚凌晨
	NET_EM_WHITEBALANCE_STREETLAMP,				// StreetLamp路灯, 1000K-5000K
} NET_EM_WHITEBALANCE_TYPE;

#define MAX_BALANCEMODES_COUNT			16		// 白平衡模式最大个数

// CLIENT_GetDevCaps NET_VIDEOIN_WHITEBALANCE_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_WHITEBALANCE_CAPS
{
	DWORD								dwSize; 								// 用户使用时赋值为结构体大小
	BOOL								bSupport;								// 是否支持白平衡设置
	int									nWhiteBalance;							// 实际支持的白平衡模式个数
	NET_EM_WHITEBALANCE_TYPE			emWhiteBalance[MAX_BALANCEMODES_COUNT];	// 支持的白平衡模式列表
} NET_OUT_VIDEOIN_WHITEBALANCE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_DAYNIGHT_CAPS;

// ICR切换类型
typedef enum tagNET_EM_ICR_TYPE
{
	NET_EM_ICR_UNKONOW,			// 未知
	NET_EM_ICR_ELECTRON,		// 电子
	NET_EM_ICR_MECHANISM,		// 机械
} NET_EM_ICR_TYPE;

// 彩转黑模式
typedef enum tagNET_EM_COLORBLACK_MODE
{
	NET_EM_COLORBLACK_UNKNOWN,					// 未知
	NET_EM_COLORBLACK_COLOR,					// 总是彩色
	NET_EM_COLORBLACK_BRIGHTNESS,				// 根据亮度自动切换
	NET_EM_COLORBLACK_BLACKWHITE,				// 总是黑白
	NET_EM_COLORBLACK_PHOTORESISTOR,			// 光敏电阻
	NET_EM_COLORBLACK_GAIN,						// 根据增益切换
	NET_EM_COLORBLACK_ALARMINPUT,				// 外部报警输入
	NET_EM_COLORBLACK_IO,						// 外部IO输入
} NET_EM_COLORBLACK_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_DAYNIGHT_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_DAYNIGHT_CAPS
{
	DWORD						dwSize; 								// 用户使用时赋值为结构体大小
	BOOL						bSupport;								// 球机机芯日夜设置能力
	int							nICRType;								// 实际支持的ICR切换类型个数
	NET_EM_ICR_TYPE				emICRType[MAX_MODE_COUNT];				// ICR切换类型列表
	int							nColorBlackMode;						// 实际支持的彩转黑模式个数
	NET_EM_COLORBLACK_MODE		emColorBlackMode[MAX_MODE_COUNT];		// 支持的彩转黑模式列表
	int							nSensitivityRangeMin;					// 彩转黑灵敏度最小值
	int							nSensitivityRangeMax;					// 彩转黑灵敏度最大值
	int							nDelayRangeMin;							// 日夜模式切换延时最小值
	int							nDelayRangeMax;							// 日夜模式切换延时最大值
} NET_OUT_VIDEOIN_DAYNIGHT_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_ZOOM_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_ZOOM_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_ZOOM_CAPS
{
	DWORD						dwSize; 								// 用户使用时赋值为结构体大小

	BOOL						bSupport;								// 是否支持变倍设置
	int							nSpeedRangeMin;							// 变倍速率最小值
	int 						nSpeedRangeMax;							// 变倍速率最大值
	BOOL						bDigitalZoomSupport;					// 是否支持数字变倍
	int							nZoomLimitRangeMin;						// 当前速率下最大变倍上限范围最小值	
	int							nZoomLimitRangeMax;						// 当前速率下最大变倍上限范围最大值
} NET_OUT_VIDEOIN_ZOOM_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_FOCUS_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_FOCUS_CAPS;

// 聚焦模式
typedef enum tagNET_EM_FOCUS_MODE
{
	NET_EM_FOCUS_OFF,				// 关闭
	NET_EM_FOCUS_ASSIST,			// 辅助聚焦
	NET_EM_FOCUS_AUTO,				// 自动聚焦
	NET_EM_FOCUS_SEMI_AUTO,			// 半自动聚焦
	NET_EM_FOCUS_MANUAL,			// 手动聚焦
} NET_EM_FOCUS_MODE;

// 聚焦极限选取模式
typedef enum tagNET_EM_FOCUS_LIMITSELECT_MODE
{
	NET_EM_FOCUS_LIMITSELECT_UNKNOW,			// 未知模式
	NET_EM_FOCUS_LIMITSELECT_MANUAL,			// 手动
	NET_EM_FOCUS_LIMITSELECT_AUTO,				// 自动
} NET_EM_FOCUS_LIMITSELECT_MODE;

// 聚焦类型
typedef enum tagNET_EM_FOCUS_TYPE
{
	NET_EM_FOCUS_UNKNOWN,						// 未知类型
	NET_EM_FOCUS_AUTOTRACE,						// 自动变焦跟踪
} NET_EM_FOCUS_TYPE;

// CLIENT_GetDevCaps NET_VIDEOIN_FOCUS_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_FOCUS_CAPS
{
	DWORD							dwSize; 								// 用户使用时赋值为结构体大小
	BOOL							bSupport;								// 是否支持聚焦设置
	int								nFcousMode;								// 实际支持的聚焦模式格式
	NET_EM_FOCUS_MODE				emFocusMode[MAX_MODE_COUNT];			// 支持的聚焦模式列表
	int								nLimitMode;								// 实际支持的聚焦极限选取模式个数
	NET_EM_FOCUS_LIMITSELECT_MODE	emLimitMode[MAX_MODE_COUNT];			// 支持的聚焦极限选取模式列表
	BOOL							bSupportFocusRegion;					// 是否支持域聚焦
	BOOL							bSensitivity;							// 是否支持聚焦林敏度
	BOOL							bIRCorrection;							// 是否支持红外光聚焦修正
	BOOL							bFocusLimit;							// 是否支持聚焦极限
	int								nFocusTypeCount;						// 实际支持的聚焦类型个数
	NET_EM_FOCUS_TYPE				emFocusType[MAX_MODE_COUNT];			// 支持的聚焦类型列表

    int                             nFocusLimitRangeCount;                  // 聚焦极限范围值的个数
    int								nFocusLimitRange[16];					// 支持聚焦极限时、聚焦极限范围值，单位毫米
                                    /*1. 默认为[100, 1000, 2000, 3000, 5000]以兼容以前设备
                                      2. 当档位中存在xxxx1时，显示时需要把1替换为0，并在最后追加字符+；例如：200001显示时为200000mm+ (通常采用较直观的单位来显示，例如：200m+)*/
} NET_OUT_VIDEOIN_FOCUS_CAPS;

//// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_SHARPNESS_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_SHARPNESS_CAPS;

// 锐度模式
typedef enum tagNET_EM_SHARPNESS_MODE
{
	NET_EM_SHARPNESS_AUTO,				//自动
	NET_EM_SHARPNESS_MANAUL,			// 手动
}NET_EM_SHARPNESS_MODE;

// CLIENT_GetDevCaps NET_VIDEOIN_SHARPNESS_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_SHARPNESS_CAPS
{
	DWORD						dwSize; 								// 用户使用时赋值为结构体大小
	BOOL						bSupport;								// 是否支持锐度设置
	int							nSharpnessMode;							// 实际支持的锐度模式个数
	NET_EM_SHARPNESS_MODE		emSharpnessMode[MAX_MODE_COUNT];		// 支持的锐度模式列表
	int							nSharpnessMin;							// 锐度最小值
	int							nSharpnessMax;							// 锐度最大值

	BOOL						bSupportRestrain;						// 是否支持锐度抑制
	int							nRestrainLevelMin;						// 锐度抑制等级最小值
	int							nRestrainLevelMax;						// 锐度抑制等级最大值
} NET_OUT_VIDEOIN_SHARPNESS_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS 命令入参
typedef struct tagNET_IN_VIDEOIN_COLOR_CAPS
{
	DWORD				dwSize; 								// 用户使用时赋值为结构体大小
	int 				nChannel;								// 通道号
} NET_IN_VIDEOIN_COLOR_CAPS;

// 图像风格能力类型
typedef enum tagNET_EM_STYLE_TYPE
{
	NET_EM_STYLE_UNKONWON,			// 未知
	NET_EM_STYLE_GENTLE,			// 柔和
	NET_EM_STYLE_STANDARD,			// 标准
	NET_EM_STYLE_FLAMBOYANT,		// 艳丽
} NET_EM_STYLE_TYPE;

// 图像风格设置能力
typedef struct tagNET_COLOR_STYLE_CAPS
{
	BOOL				bSupport;								// 是否支持图像风格设置
	int					nStyleType;								// 实际支持的图像风格能力个数
	NET_EM_STYLE_TYPE	emStyleType[MAX_MODE_COUNT];			// 支持的图像风格能力列表
	BYTE				bReserved[128];							// 预留字段
} NET_COLOR_STYLE_CAPS;

#define MAX_GRAYVALUE_COUNT			8  // 灰度值的最大个数

// 灰度范围能力
typedef struct tagNET_GRAY_SCALE_CAPS
{
	BOOL				bSupport;								// 是否支持灰度范围能力
	int					nValueCount;							// 实际支持的灰度范围组数
	int					nValue[MAX_GRAYVALUE_COUNT][2];		// 灰度范围的上下限值
	BYTE				bReserved[128];							// 预留字段
} NET_GRAY_SCALE_CAPS;

// CLIENT_GetDevCaps NET_VIDEOIN_COLOR_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_COLOR_CAPS
{
	DWORD					dwSize; 							// 用户使用时赋值为结构体大小
	BOOL					bSupport;							// 是否支持图像设置能力
	BOOL					bBrightness;						// 是否支持亮度
	BOOL					bContrast;							// 是否支持对比度
	BOOL					bSaturation;						// 是否支持饱和度
	BOOL					bHue;								// 是否支持色度
	BOOL					bGamma;								// 是否支持Gamma
	BOOL					bChromaSuppress;					// 是否支持色彩抑制
	NET_COLOR_STYLE_CAPS	stuColorStype;						// 图像风格能力
	NET_GRAY_SCALE_CAPS		stuGrayScale;						// 灰度范围能力
} NET_OUT_VIDEOIN_COLOR_CAPS;

// CLIENT_GetDevCaps 接口 NET_VIDEOIN_RAWFRAME_CAPS 命令出参
typedef struct tagNET_IN_VIDEOIN_RAWFRAME_CAPS
{
	DWORD					dwSize;
}NET_IN_VIDEOIN_RAWFRAME_CAPS;

// YUV数据格式能力集
typedef struct tagNET_RAWFRAMETYPE_DATA
{
	int						nListNum;										// 实际返回的数据格式个数
	char					szList[DH_COMMON_STRING_16][DH_COMMON_STRING_8];// 支持的YUV数据格式列表
	BYTE					byReserved[1024];
}NET_RAWFRAMETYPE_DATA;

// CLIENT_GetDevCaps 接口 NET_VIDEOIN_RAWFRAME_CAPS 命令出参
typedef struct tagNET_OUT_VIDEOIN_RAWFRAME_CAPS
{
	DWORD								dwSize;
	NET_RAWFRAMETYPE_DATA				stuFrameData;
}NET_OUT_VIDEOIN_RAWFRAME_CAPS;

// 温度单位
typedef enum tagEM_TEMPERATURE_UNIT
{
	EM_TEMPERATURE_CENTIGRADE,			// 摄氏度
	EM_TEMPERATURE_FAHRENHEIT,			// 华氏度
	EM_TEMPERATURE_KELVIN,				// 开尔文
} EM_TEMPERATURE_UNIT;

#define MAX_UNIT_COUNT		8		// 最大支持的问题单位个数

// CLIENT_GetDevCaps NET_FACE_BOARD_CAPS 命令出参
typedef struct tagNET_OUT_FACEBOARD_CAPS
{
    DWORD               	dwSize;						            // 该结构体大小
    BOOL                	bHasBattery;                            // 是否有电池
    BOOL                	bSupportPowerVoltageDetect;             // 是否支持电源电压检测
    BOOL					bTemperatures;							// 是否支持温度传感器
    BOOL					bOSDTemperatureUnit;					// 是否支持温度单位选择
    int						nRetUnitCount;							// 实际支持的温度单位个数
    EM_TEMPERATURE_UNIT		emTempreatureUnit[MAX_UNIT_COUNT];		// OSD叠加时支持的温度单位
}NET_OUT_FACEBOARD_CAPS;

// CLIENT_GetDevCaps接口 NET_COAXIAL_CONTROL_IO_CAPS 命令入参
typedef struct tagNET_IN_GET_COAXIAL_CONTROL_IO_CAPS
{
	DWORD							dwSize;							// 结构体大小
	int								nChannel;						// 通道号
} NET_IN_GET_COAXIAL_CONTROL_IO_CAPS;

// CLIENT_GetDevCaps接口 NET_COAXIAL_CONTROL_IO_CAPS 命令出参
typedef struct tagNET_OUT_GET_COAXIAL_CONTROL_IO_CAPS
{
	DWORD							dwSize;							// 结构体大小
	BOOL							bSupportControlLight;			// 是否支持白光灯
	BOOL							bSupportControlSpeaker;			// 是否支持speaker音频外放
} NET_OUT_GET_COAXIAL_CONTROL_IO_CAPS;

// CLIENT_GetDevCaps接口 NET_FACEINFO_CAPS 命令入参
typedef struct tagNET_IN_GET_FACEINFO_CAPS
{
    DWORD							dwSize;							// 结构体大小
}NET_IN_GET_FACEINFO_CAPS;

// 人脸识别算法
typedef enum tagEM_RECOGNITIONALGORITHM_TYPE
{
    EM_RECOGNITIONALGORITHM_UNKNOWN,                                    // 未知
    EM_RECOGNITIONALGORITHM_DAHUA,                                      // 大华
    EM_RECOGNITIONALGORITHM_SHANGTANG,                                  // 商汤
    EM_RECOGNITIONALGORITHM_YITU,                                       // 依图
    EM_RECOGNITIONALGORITHM_HANWANG,                                    // 汉王
    EM_RECOGNITIONALGORITHM_FIREEYE,                                    // 火眼
}EM_RECOGNITIONALGORITHM_TYPE;

// CLIENT_GetDevCaps接口 NET_FACEINFO_CAPS 命令出参
typedef struct tagNET_OUT_GET_FACEINFO_CAPS
{
    DWORD							    dwSize;							// 结构体大小
    int                                 nRecognitionType;               // 支持的人脸识别类型，0:白光,1:红外
    EM_RECOGNITIONALGORITHM_TYPE        emRecognitionAlgorithm;         // 人脸识别算法
    DWORD                               nRecognitionVersion;            // 算法版本号,如1.5.2表示成0x00010502
    UINT                                nMaxFaces;                      // 人脸存储上限
    int                                 nMaxPhotoSize;                  // 白光照片最大尺寸,单位:KB
    UINT                                nMaxInsertRate;                 // 每次最大插入量
    BOOL                                bIsSupportGetPhoto;             // 是否支持获取白光照片
    BOOL                                bIsSupportFaceEigen;            // 是否支持通过人脸图片提取特征值
}NET_OUT_GET_FACEINFO_CAPS;

typedef enum tagEM_DETECT_VERSION_TYPE
{
    EM_DETECT_VERSION_UNKNOW = 0 , 
    EM_DETECT_VERSION_V1_0 ,           //第一版动检方案
    EM_DETECT_VERSION_V3_0 ,           //第三版动检方案
}EM_DETECT_VERSION_TYPE;
#define    MAX_DETECT_VERSION_NUM           64

typedef enum tagEM_BLIND_DETECT_VERSION_TYPE
{
    EM_BLIND_DETECT_VERSION_UNKNOW = 0 ,
    EM_BLIND_DETECT_VERSION_FULL_SCREEN ,   //全屏遮挡检测
    EM_BLIND_DETECT_VERSION_MULTI_WINDOW ,  //多窗口检测
}EM_BLIND_DETECT_VERSION_TYPE;
#define    MAX_BLIND_DETECT_VERSION_NUM     64

// 智能动检检测类型
typedef enum tagEM_SMART_MOTION_TYPE
{
	EM_SMART_MOTION_UNKNOWN,		// 未知
	EM_SMART_MOTION_HUMAN,			// 人体
	EM_SMART_MOTION_VEHICLE,		// 机动车
} EM_SMART_MOTION_TYPE;

// 智能动检能力信息
typedef struct tagNET_SMART_MOTION_CAPS
{
	BOOL						bSupport;					// 是否支持智能动检
	UINT						nSmartTypeNum;				// 智能动检支持的检测类型个数
	EM_SMART_MOTION_TYPE		emSmartMotionType[8];		// 智能动检支持的检测类型
	BYTE						byReserved[512];				// 保留字节
} NET_SMART_MOTION_CAPS;

typedef struct tagNET_OUT_VIDEO_DETECT_CAPS
{
        DWORD                       dwSize;         
        BOOL                        bSupportBlind;          //是否支持黑屏检测
        BOOL                        bSupportLoss;           //是否支持视频丢失检测
        BOOL                        bSupportMotion;         //是否支持动态检测
        BOOL                        bMotionResult;          //是否能够得到每块区域的检测结果
        DWORD                       nMotionColumns;         //动态检测区域划分的列数
        DWORD                       nMotionRows;            //动态检测区域划分的行数
        DWORD                       nMotionDetectWindow;    //动检支持的视频窗口数
        DWORD                       nBlindColumns;          //视频遮挡检测区域划分的列数
        DWORD                       nBlindRows;             //视频遮挡检测区域划分的行数
        DWORD                       nBlindDetectWindow;     //视频遮挡支持的窗口数
        BOOL                        bPositionDetect;        //是否支持移动位置侦测
        DWORD                       nDetectVersionNum;      //支持的动检方案数
        EM_DETECT_VERSION_TYPE      emDetectVersions[MAX_DETECT_VERSION_NUM];               //支持的动检方案信息
        DWORD                       nBlindDetectVersionNum; //支持的视频遮挡检测版本数
        EM_BLIND_DETECT_VERSION_TYPE emBlindDetectVersions[MAX_BLIND_DETECT_VERSION_NUM];   //支持的视频遮挡检测版本信息
        BOOL                        bMotionLinkPtzPreset;   //动检是否支持联动云台预置点
        BOOL                        bMotionLinkPtzTour;     //动检是否支持联动云台巡航
        BOOL                        bMotionLinkPtzPattern;  //动检是否支持联动云台巡迹
        BOOL                        bUnFocusDetect;         //是否支持虚焦检测
        BOOL                        bAlarmDetect;           //是否支持动检同时检测报警并触发
		BOOL						bSupportMoveDetect;		// 是否支持场景变更检测
		NET_SMART_MOTION_CAPS		stuSmartMotionCaps;		// 智能动检能力信息
}NET_OUT_VIDEO_DETECT_CAPS;

// 跌落事件类型
typedef struct tagALARM_FALLING_INFO
{
    DWORD               dwStructSize;                               // 结构体大小
    BYTE                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                byRserved[3];                               // 对齐   
	char				szUserID[32];								// 设备跌落时登陆的用户信息用户ID
	char				szUserName[128];							// 设备跌落时登陆的用户信息用户名
}ALARM_FALLING_INFO;

//订阅Bus状态回调函数原型
typedef void (CALLBACK *fBusStateCallBack)(LLONG lAttachHandle, LONG lCommand, char *pBuf, DWORD dwBufLen, LDWORD dwUser);

// 刷卡类型
typedef enum tagNET_DRIVER_CHECK_TYPE
{
    NET_DRIVER_CHECK_TYPE_UNKNOWN,                                  // 未知
    NET_DRIVER_CHECK_TYPE_SIGNIN,                                   // 签到
    NET_DRIVER_CHECK_TYPE_SIGNOUT,                                  // 签出
} NET_DRIVER_CHECK_TYPE;

// 刷卡方式
typedef enum tagNET_DRIVER_CHECK_METHOD
{
    NET_DRIVER_CHECK_METHOD_UNKNOWN,                                // 未知
    NET_DRIVER_CHECK_METHOD_POS,                                    // POS机
    NET_DRIVER_CHECK_METHOD_HAND,                                   // 手动输入
} NET_DRIVER_CHECK_METHOD;

// 报警事件类型DH_ALARM_BUS_DRIVER_CHECK( 司机识别卡检测事件)对应的数据描述信息
typedef struct tagALARM_BUS_DRIVER_CHECK_INFO
{
    DWORD                   dwSize;
    char                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // 车牌
    char                    szDriverName[DH_COMMON_STRING_16];      // 司机姓名
    char                    szDriverID[DH_MAX_PERSON_ID_LEN];       // 工号
    char                    szOrganize[DH_COMMON_STRING_128];       // 驾驶证发证机构名称
    NET_TIME_EX             stUsefulLife;                           // 证件有效期
    NET_GPS_STATUS_INFO     stGPSStatusInfo;                        // GPS信息
    NET_TIME_EX             stCheckTime;                            // 打卡时间
    NET_DRIVER_CHECK_METHOD emCheckMethod;                          // 打卡方式
    NET_DRIVER_CHECK_TYPE   emCheckType;                            // 打卡类型
}ALARM_BUS_DRIVER_CHECK_INFO;

// 报警事件类型DH_ALARM_DEVICE_MSG_NOTIFY(设备向平台发通知的事件)对应的数据描述信息
typedef struct tagALARM_DEVICE_MSG_NOTIFY_INFO
{
    DWORD                   dwSize;
    char                    szMsg[DH_COMMON_STRING_256];            // 消息内容
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS信息
} ALARM_DEVICE_MSG_NOTIFY_INFO;

// 报警事件类型DH_ALARM_VEHICLE_STANDING_OVER_TIME(停车超时报警)对应的数据描述信息
typedef struct tagALARM_VEHICLE_STANDING_OVER_TIME_INFO
{
    DWORD                   dwSize;
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS信息
    NET_TIME_EX             stuTime;                                // 第一次发生的时间
    NET_TIME_EX             stuUtc;                                 // 本次事件发生的时间
    DWORD                   dwUtc;                                  // 本次事件发生的时间, 与stuUtc值一样,格式不同,用于事件确认接口入参
    BOOL                    bEventConfirm;                          // 是否需要回复
} ALARM_VEHICLE_STANDING_OVER_TIME_INFO;

// 线路方向
typedef enum tagNET_LINE_DIRECTION
{
    NET_LINE_DIRECTION_UNKNOWN,                                     // 未知
    NET_LINE_DIRECTION_POSTIVE,                                     // 正向
    NET_LINE_DIRECTION_NEGATIVE,                                    // 反向
    NET_LINE_DIRECTION_AROUND,                                      // 环线
    NET_LINE_DIRECTION_DISPERSE,                                    // 离散
} NET_LINE_DIRECTION;

// 进站离站状态
typedef enum tagNET_BUS_STATE
{
    NET_BUS_STATE_UNKNOWN,                                         // 未知
    NET_BUS_STATE_ILLEGAL,                                         // 非法
    NET_BUS_STATE_LEGAL,                                           // 合法
} NET_BUS_STATE;

// 报站方式
typedef enum tagNET_PORT_TYPE
{
    NET_PORT_TYPE_UNKOWN,                                           // 未知
    NET_PORT_TYPE_MANUAL,                                           // 手动报站
    NET_PORT_TYPE_GPS,                                              // GPS报站
} NET_PORT_TYPE;

// 车载开门事件的数据类型
typedef enum tagEM_VEHICLE_DATA_TYPE
{
    EM_VEHICLE_DOOR_OPEN_DATA_UNKNOWN = 0,
    EM_VEHICLE_DOOR_OPEN_DATA_REALTIME,                             // 实时的数据
    EM_VEHICLE_DOOR_OPEN_DATA_HISTORY,                              // 重发的数据
}EM_VEHICLE_DATA_TYPE;

// 报警事件类型DH_ALARM_BUS_IMPORT_SITE(进站事件)对应的数据描述信息
typedef struct tagALARM_BUS_IMPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // 站点标识
    DWORD                   dwSiteNum;                              // 站序
    NET_LINE_DIRECTION      emDirection;                            // 线路方向
    char                    szLineID[DH_COMMON_STRING_64];          // 线路标识
    NET_TIME_EX             stuTime;                                // 进站离站时间
    int                     nTime;                                  // 用来确认事件用的时间, UTC制, 单位为秒
    NET_BUS_STATE           emState;                                // 是否按规定时间进站
    NET_PORT_TYPE           emType;                                 // 报站方式
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS信息
    DWORD                   dwSiteCount;                            // 总站点数
    char                    szSiteName[DH_COMMON_STRING_64];        // 站点名称
    char                    szDesignation[DH_COMMON_STRING_64];     // 线路番号
    EM_VEHICLE_DATA_TYPE    emDataType;                             // 事件数据的类型
    BOOL                    bNeedConfirm;                           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int			nFromMileage;							// 上一站到当前站的里程，单位：m
	unsigned int			nTotalMileage;							// 起点站到当前站的里程，单位：m
	unsigned int			nFromCostTime;							// 上一站到当前站的耗时，单位：s
	unsigned int			nTotalCostTime;							// 起点站到当前站的耗时，单位：s
} ALARM_BUS_IMPORT_SITE_INFO;


typedef struct tagNET_SUBTOTAL
{
    unsigned int            nDevNum;                // 设备编号， 一个车上可能有好几个设备
    unsigned int            nInside;                // 准备上车人数
    unsigned int            nExited;                // 准备下车人数
    BYTE                    byRserved[256];         // 保留字节
}NET_SUBTOTAL;

// 报警事件类型DH_ALARM_BUS_EXPORT_SITE(离站事件)对应的数据描述信息
typedef struct tagALARM_BUS_EXPORT_SITE_INFO
{
    DWORD                   dwSize;
    char                    szSiteID[DH_COMMON_STRING_64];          // 站点标识
    DWORD                   dwSiteNum;                              // 站序
    NET_LINE_DIRECTION      emDirection;                            // 线路方向
    char                    szLineID[DH_COMMON_STRING_64];          // 线路标识
    NET_TIME_EX             stuTime;                                // 进站离站时间
    int                     nTime;                                  // 用来确认事件用的时间, UTC制, 单位为秒
    NET_BUS_STATE           emState;                                // 是否按规定时间离站
    NET_PORT_TYPE           emType;                                 // 报站方式
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS信息
    DWORD                   dwSiteCount;                            // 总站点数
    char                    szSiteName[DH_COMMON_STRING_64];        // 站点名称
    char                    szDesignation[DH_COMMON_STRING_64];     // 线路番号
    EM_VEHICLE_DATA_TYPE    emDataType;                             // 事件数据的类型
    BOOL                    bNeedConfirm;                           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int			nFromMileage;							// 上一站到当前站的里程，单位：m
	unsigned int			nTotalMileage;							// 起点站到当前站的里程，单位：m
	unsigned int			nFromCostTime;							// 上一站到当前站的耗时，单位：s
	unsigned int			nTotalCostTime;							// 起点站到当前站的耗时，单位：s
    int                     nCurrentPeople;                         // 本次关门事件统计到的净人数，只计算当前关门时统计的人数。下车人数比上车人数多则会统计为负数
    unsigned int			nTotalIn;                               // 本次关门总上车人数
    unsigned int			nTotalOut;                              // 本次关门总下车人数
    unsigned int			nSubtotalCount;                         // 统计人数的设备数量
    NET_SUBTOTAL            stuSubtotal[32];                        // 不同设备统计到的人数信息，最多有32个设备（一辆车可能有多个设备统计人数）
} ALARM_BUS_EXPORT_SITE_INFO;

// 异常事件类型
typedef enum tagEM_ALARM_BUS_ABNORMAL_EVENT_TYPE
{
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_UNKNOWN,           // 未知
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RUNNING,           // 恢复营运,"Running"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MEAL,              // 吃饭,"Meal"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BLOCK,             // 路堵,"Block"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CALL,              // 通话,"Call"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_BREAKDOWN,         // 车坏,"Breakdown"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISCONTINUED,      // 停止营运,"Discontinued"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ROBING,            // 盗抢,"Robing"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERLOAD,          // 超载,"Overload"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_DISPUTE,           // 纠纷,"Dispute"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ACCIDENT,          // 事故,"Accident"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_OVERSPEED,         // 超速,"OverSpeed"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_RENTAL,            // 包车,"Rental"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_MAINTENANCE,       // 保养,"Maintenance"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_CLOSURE,           // 脱保停运,"Closure"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_PUBSECURITY,       // 治安事件, "PubSecurity"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_ENTER_PARK,        // 进入停车场, "EnterPark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_LEAVE_PARK,        // 离开平车场, "LeavePark"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_REFUEL,            // 加油, "Refuel"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_FIRE,              // 火灾报警, "Fire"
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE_HELP,              // 乘客救助, "Help"
}EM_ALARM_BUS_ABNORMAL_EVENT_TYPE;

// 报警事件类型DH_ALARM_BUS_ABNORMAL(车辆异常事件)对应的数据描述信息
typedef struct tagALARM_BUS_ABNORMAL_INFO
{
    DWORD                                   dwSize;
    EM_ALARM_BUS_ABNORMAL_EVENT_TYPE        emEventType;                            // 异常事件类型
    char                                    szCarNo[DH_MAX_PLATE_NUMBER_LEN];       // 车牌
    char                                    szLineID[DH_COMMON_STRING_64];          // 线路标识
    NET_LINE_DIRECTION                      emLineDirection;                        // 线路方向
    NET_TIME_EX                             stuTime;                                // 发生时间
    NET_GPS_STATUS_INFO                     stuGPSStatusInfo;                       // GPS信息
} ALARM_BUS_ABNORMAL_INFO;

// 报警事件类型DH_ALARM_ENCLOSURE_ALARM(电子围栏事件)对应的数据描述信息
typedef struct tagALARM_ENCLOSURE_ALARM_INFO
{
    DWORD                   dwSize;
    DWORD                   dwAlarmType;                            // 报警类型, 按位分别表示,
                                                                    // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
    DWORD                   dwAlarmDetail;                          // 报警描述, 按位分别表示,
                                                                    // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
    NET_BUS_STATE           emState;                                // 是否按规定时间触发事件
    DWORD                   dwDriverNo;                             // 司机编号
    DWORD                   dwEnclosureID;                          // 围栏ID
    DWORD                   dwLimitSpeed;                           // 限速
    DWORD                   dwCurrentSpeed;                         // 当前速度
    NET_TIME_EX             stuTime;                                // 当前时间
    NET_GPS_STATUS_INFO     stuGPSStatusInfo;                       // GPS信息
} ALARM_ENCLOSURE_ALARM_INFO;

// 车载的门的状态
typedef NET_ACCESS_CTL_STATUS_TYPE NET_VEHICLE_DOOR_STATUS;

// 车载开门事件, 对应事件类型 DH_VEHICLE_DOOR_OPEN
typedef struct tagALARM_VEHICLE_DOOR_OPEN_INFO 
{
    DWORD                       dwSize;
    NET_VEHICLE_DOOR_STATUS     emStatus;               // 门状态
    int                         nDoor;                  // 门序号, 1:前门,2:中门,3:后门
    NET_TIME                    stuTime;                // 事件时间, UTC制
    int                         nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息
    EM_VEHICLE_DATA_TYPE        emDataType;             // 事件数据的类型
    BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
}ALARM_VEHICLE_DOOR_OPEN_INFO;

// 当前里程事件, 对应事件类型 DH_ALARM_BUS_CUR_MILEAGE
typedef struct tagALARM_BUS_CUR_MILEAGE_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
    int                         nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
    EM_VEHICLE_DATA_TYPE        emDataType;             // 事件数据的类型
    NET_TIME                    stuTime;                // 事件时间, UTC制
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
    NET_TIME                    stuStartTime;           // 当前时间段的开始时间, UTC制
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // 当前时间段的开始时间时的GPS信息, 只有经纬度、速度、方向角字段有效
    unsigned int                nMileage;               // 当前时间段的里程数, 单位:0.1km
	char						szDriverID[32];			// 工号
}ALARM_BUS_CUR_MILEAGE_INFO;

// 当前油耗情况事件, 对应事件类型 DH_ALARM_BUS_CUR_OIL
typedef struct tagALARM_BUS_CUR_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
    int                         nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
    EM_VEHICLE_DATA_TYPE        emDataType;             // 事件数据的类型
    NET_TIME                    stuTime;                // 事件时间, UTC制
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
    NET_TIME                    stuStartTime;           // 当前时间段的开始时间, UTC制
    NET_GPS_STATUS_INFO         stuStartGPSStatusInfo;  // 当前时间段的开始时间时的GPS信息, 只有经纬度、速度、方向角字段有效
    unsigned int                nCurOil;                // 当前油量, 单位: 0.1L
    unsigned int                nOilTankage;            // 油箱容积, 单位: 0.1L
    int                         nOilChange;             // 当前时间段内油量变化, 单位: 0.1L, 正数表示加油, 负数表示耗油
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // 车牌信息
}ALARM_BUS_CUR_OIL_INFO;

// 低油量报警事件, 对应事件类型 DH_ALARM_BUS_LOW_OIL
typedef struct tagALARM_BUS_LOW_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
    int                         nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
    EM_VEHICLE_DATA_TYPE        emDataType;             // 事件数据的类型
    NET_TIME                    stuTime;                // 事件时间, UTC制
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
    unsigned int                nCurOil;                // 当前油量, 单位: 0.1L
    unsigned int                nOilLine;               // 油量阈值, 单位: 0.1L
    unsigned int                nOilTankage;            // 油箱容积, 单位: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // 车牌信息
}ALARM_BUS_LOW_OIL_INFO;

// 偷油报警事件, 对应事件类型 DH_ALARM_BUS_STEAL_OIL
typedef struct tagALARM_BUS_STEAL_OIL_INFO 
{
    DWORD                       dwSize;
    BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
    int                         nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
    EM_VEHICLE_DATA_TYPE        emDataType;             // 事件数据的类型
    NET_TIME                    stuTime;                // 事件时间, UTC制
    NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
    unsigned int                nCurOil;                // 当前油量, 单位: 0.1L
    unsigned int                nOilTankage;            // 油箱容积, 单位: 0.1L
    char                        szCarNO[DH_MAX_PLATE_NUMBER_LEN]; // 车牌信息
}ALARM_BUS_STEAL_OIL_INFO;

// 线路偏移事件, 车载需求,对应事件类型 DH_ALARM_BUS_CIRCUIT_SHIFT
typedef struct tagALARM_BUS_CIRCUIT_SHIFT_INFO
{
	BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int                nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
	NET_TIME                    stuTime;                // 事件发生时间,UTC制
	BYTE						byReserved[1024];		// 保留字节
}ALARM_BUS_CIRCUIT_SHIFT_INFO;

// 线路超时事件,押运车需求,对应事件类型 DH_ALARM_BUS_ROUTE_OVERTIME
typedef struct tagALARM_BUS_ROUTE_OVERTIME_INFO
{
	BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int                nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
	NET_TIME                    stuTime;                // 事件发生时间,UTC制
	BYTE						byReserved[1024];		// 保留字节
}ALARM_BUS_ROUTE_OVERTIME_INFO;

// 载重报警事件,渣土机需求,对应事件 DH_ALARM_BUS_VEHICLE_CARRY_ALARM
typedef struct tagALARM_BUS_VEHICLE_CARRY_ALARM_INFO 
{
    int							nAction;                // 事件动作, 0: 重载, 1: 空载
	BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int                nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
	NET_TIME                    stuTime;                // 事件发生时间,UTC制
	BYTE						byReserved[1024];		// 保留字节
} ALARM_BUS_VEHICLE_CARRY_ALARM_INFO;

// 载重报警事件,渣土机需求,对应事件 DH_ALARM_BUS_VEHICLE_PAULIN_ALARM
typedef struct tagALARM_BUS_VEHICLE_PAULIN_ALARM_INFO
{
	int							nAction;                // 事件动作, 0: 篷布开, 1: 篷布关
	BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int                nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
	NET_TIME                    stuTime;                // 事件发生时间,UTC制
	BYTE						byReserved[1024];		// 保留字节
} ALARM_BUS_VEHICLE_PAULIN_ALARM_INFO;

// 举升报警事件,渣土机需求,对应事件 DH_ALARM_BUS_VEHICLE_LIFT_ALARM
typedef struct tagALARM_BUS_VEHICLE_LIFT_ALARM_INFO
{
	int							nAction;                // 事件动作, 0: 举升机举, 1: 举升机平
	BOOL                        bNeedConfirm;           // 是否需要确认, 通过调用CLIENT_BusConfirmEvent接口确认
	unsigned int                nTime;                  // 用来确认事件用的时间, UTC制, 单位为秒
	NET_GPS_STATUS_INFO         stuGPSStatusInfo;       // GPS信息, 只有经纬度、速度、方向角字段有效
	NET_TIME                    stuTime;                // 事件发生时间,UTC制
	BYTE						byReserved[1024];		// 保留字节
} ALARM_BUS_VEHICLE_LIFT_ALARM_INFO;

// 订阅Bus状态输入参结构
typedef struct tagNET_IN_BUS_ATTACH
{
    DWORD                   dwSize;
    fBusStateCallBack       cbBusState;                             // 状态回调函数
    LDWORD                  dwUser;                                 // 用户数据
}NET_IN_BUS_ATTACH;

// 订阅Bus状态输出参结构
typedef struct tagNET_OUT_BUS_ATTACH
{
    DWORD                dwSize;
}NET_OUT_BUS_ATTACH;

// 扩展模块报警通道信息
typedef struct tagNET_EXALARMCHANNELS_INFO
{
    DWORD           dwSize;
    int             nExAlarmBoxNum;                                 // 扩展报警盒通道号
    int             nChannelNum;                                    // 该通道在扩展报警盒上的通道号
    char            szChannelName[DH_MAX_EXALARMCHANNEL_NAME_LEN];  // 报警通道名称
} NET_EXALARMCHANNELS_INFO;

// CLIENT_QueryDevState 接口输入参数
typedef struct tagNET_EXALARMCHANNELS
{
    DWORD                       dwSize;
    int                         nExAlarmInCount;                    // 扩展模块报警输入通道个数,需用户指定查询个数
    int                         nRetExAlarmInCount;                 // 扩展模块报警输入通道返回个数
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmInInfo;                  // 扩展模块报警输入通道信息
																	// 由用户申请内存，大小为sizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmInCount
    int                         nExAlarmOutCount;                   // 扩展模块报警输出通道个数,需用户指定查询个数
    int                         nRetExAlarmOutCount;                // 扩展模块报警输出通道返回个数
    NET_EXALARMCHANNELS_INFO*   pstuExAlarmOutInfo;                 // 扩展模块报警输出通道信息
																	// 由用户申请内存，大小为sizeof(NET_EXALARMCHANNELS_INFO)*nExAlarmOutCount
} NET_EXALARMCHANNELS;

// 激活的防区信息
typedef struct tagNET_ACTIVATEDDEFENCEAREA_INFO
{
    DWORD                       dwSize;
    int                         nChannel;                           // 防区通道号
    NET_TIME                    stuActivationTime;                  // 防区激活时间 
}NET_ACTIVATEDDEFENCEAREA_INFO;
// CLIENT_QueryDevState 接口输入参数
typedef struct tagNET_ACTIVATEDEFENCEAREA
{
    DWORD                       dwSize;
    int                         nAlarmInCount;                      // 查询本地报警输入通道激活个数,需用户指定个数
    int                         nRetAlarmInCount;                   // 本地报警输入通道实际激活个数
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuAlarmInDefenceAreaInfo;      // 本地报警输入通道信息
																	// 由用户申请内存，大小为sizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nAlarmInCount
    int                         nExAlarmInCount;                    // 查询扩展模块报警输入通道个数,需用户指定个数
    int                         nRetExAlarmInCount;                 // 扩展模块报警输入通道实际激活个数
    NET_ACTIVATEDDEFENCEAREA_INFO* pstuExAlarmInDefenceAreaInfo;    // 扩展模块报警输入通道信息
																	// 由用户申请内存，大小为sizeof(NET_ACTIVATEDDEFENCEAREA_INFO)*nExAlarmInCount
}NET_ACTIVATEDDEFENCEAREA;

// 门禁状态类型
typedef enum tagEM_NET_DOOR_STATUS_TYPE
{
    EM_NET_DOOR_STATUS_UNKNOWN,
    EM_NET_DOOR_STATUS_OPEN,                            // 门打开
    EM_NET_DOOR_STATUS_CLOSE,                           // 门关闭
    EM_NET_DOOR_STATUS_BREAK,                           // 门异常打开
}EM_NET_DOOR_STATUS_TYPE;

// 门禁状态信息(CLIENT_QueryDevState 接口输入参数)
typedef struct tagNET_DOOR_STATUS_INFO
{
    DWORD                       dwSize;
    int                         nChannel;               // 门禁通道号
    EM_NET_DOOR_STATUS_TYPE     emStateType;            // 门禁状态信息
}NET_DOOR_STATUS_INFO;

// CLIENT_QueryRecordCount接口输入参数
typedef struct _NET_IN_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // 结构体大小
    LLONG                       lFindeHandle;           // 查询句柄
}NET_IN_QUEYT_RECORD_COUNT_PARAM;

// CLIENT_QueryRecordCount接口输出参数
typedef struct _NET_OUT_QUEYT_RECORD_COUNT_PARAM
{
    DWORD                       dwSize;                 // 结构体大小
    int                         nRecordCount;           // 设备返回的记录条数
}NET_OUT_QUEYT_RECORD_COUNT_PARAM;

// 模拟量报警输入通道信息
typedef struct tagNET_ANALOGALARM_CHANNELS_INFO 
{
    DWORD               dwSize;
    int                 nSlot;										// 根地址, 0表示本地通道, 1表示连接在第一个串口上的扩展通道, 2、3...以此类推
    int                 nLevel1;									// 第一级级联地址, 表示连接在第nSlot串口上的第nLevel1个探测器, 从0开始
    int                 nLevel2;									// 第二级级联地址, 表示连接在第nLevel1节点上的第nLevel2个探测器,从0开始,-1表示不存在该节点
    char                szName[DH_COMMON_STRING_128];				// 通道名称
	char				szSenseMethod[DH_COMMON_STRING_32];			// 传感器感应方式
	BYTE				byIsNull;									// 判断该通道是否被置空，0为未空置，1为空置
}NET_ANALOGALARM_CHANNELS_INFO;

// 模拟量报警输入通道映射关系(对应DH_DEVSTATE_ANALOGALARM_CHANNELS命令)
typedef struct tagNET_ANALOGALARM_CHANNELS 
{
    DWORD                          dwSize;	
    int                            nMaxAnalogAlarmChannels;						// 最大通道数
    int                            nRetAnalogAlarmChannels;						// 返回的通道数
    NET_ANALOGALARM_CHANNELS_INFO* pstuChannelInfo;								// 通道信息,用户分配内存,大小为sizeof(NET_ANALOGALARM_CHANNELS_INFO)*nMaxAnalogAlarmChannels
	int							   nVideoChannel;								// 指定视频通道号
}NET_ANALOGALARM_CHANNELS;

// 传感器数据信息
typedef struct tagNET_ANALOGALARM_SENSE_INFO 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 通道号(从0开始)
    NET_SENSE_METHOD        emSense;                        // 传感器类型
    float                   fData;                          // 传感器数值
    NET_TIME                stuTime;                        // 采集时间
    int                     nStatus;                        // 数据状态, -1:未知,0:正常,1:数据无效(超过量程),
                                                            // 2:超过阈值1,3:超过阈值2,4:超过阈值3,5:超过阈值4,
                                                            // 6:低于阈值1,7:低于阈值2,8:低于阈值3,9:低于阈值4
    NET_GPS_STATUS_INFO     stuGpsSatus;                    // GPS状态
    int                     nUint;                          // 传感器数值的单位,在 emSense 为以下值时有效：
                                                            // NET_SENSE_TEMP,此时可取值见 NET_TEMPERATURE_UNIT
	int						nVideoChannel;					// 视频通道号
}NET_ANALOGALARM_SENSE_INFO;

//订阅模拟量报警通道数据回调函数原型
typedef void (CALLBACK *fAnalogAlarmDataCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_ANALOGALARM_SENSE_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachAnalogAlarmData()接口输入参数
typedef struct tagNET_IN_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int                         nChannelId;                 // 从0开始, -1表示全部通道
    fAnalogAlarmDataCallBack    cbCallBack;                 // 数据回调函数
    LDWORD                      dwUser;                     // 用户定义参数
	
}NET_IN_ANALOGALARM_DATA;

// CLIENT_AttachAnalogAlarmData()接口输出参数
typedef struct tagNET_OUT_ANALOGALARM_DATA 
{
    DWORD    dwSize;
}NET_OUT_ANALOGALARM_DATA;

// 订阅记录变更接口相关定义
#define DH_MAX_RECORD_INSERT_NUM                            128
#define DH_MAX_RECORD_DELETE_NUM                            128
#define DH_MAX_RECORD_UPDATE_NUM                            128

typedef struct tagNET_RECORDUPDATER_INFO
{
    DWORD                       dwSize;
    int                         nInsertNum;                                     // 记录信息中,插入的记录个数
    int                         nInsertNumberList[DH_MAX_RECORD_INSERT_NUM];    // 表示新增的记录索引号            
    int                         nDeleteNum;                                     // 记录信息中,删除的记录个数
    int                         nDeleteNumberList[DH_MAX_RECORD_DELETE_NUM];    // 表示删除的记录索引号,-1表示删除所有记录         
    int                         nUpdateNum;                                     // 记录信息中,更新的记录个数
    int                         nUpdateNumberList[DH_MAX_RECORD_UPDATE_NUM];    // 表示更新的记录索引号          
}NET_RECORDUPDATER_INFO;

//订阅记录变更接口
typedef void (CALLBACK *fRecordUpdaterCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_RECORDUPDATER_INFO* pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_AttachRecordUpdater()接口输入参数
typedef struct tagNET_IN_RECORDUPDATER_DATA
{
    DWORD                       dwSize;
    EM_NET_RECORD_TYPE          emType;                     // 记录集信息类型
    fRecordUpdaterCallBack      cbRecordUpdater;                 // 记录更新回调函数
    LDWORD                      dwUser;                     // 用户定义参数
}NET_IN_RECORDUPDATER_DATA;

// CLIENT_AttachRecordUpdater()接口输出参数
typedef struct tagNET_OUT_RECORDUPDATER_DATA
{
    DWORD                       dwSize;
}NET_OUT_RECORDUPDATER_DATA;

// 查询设备支持的传感器设备类型 
// CLIENT_QueryDevState接口的 DH_DEVSTATE_GET_SENSORLIST  命令参数
#define MAX_SUPPORT_SENSORTYPE_NUM    128                   // 最大支持传感器设备类型个数

typedef struct tagNET_SENSOR_LIST 
{
    DWORD       dwSize;
    int         nSupportSensorNum;                          // 返回支持传感器设备类型个数
    char        szSensorList[MAX_SUPPORT_SENSORTYPE_NUM][DH_COMMON_STRING_64];
}NET_SENSOR_LIST;

// CLIENT_QueryDevLogCount获取日志条数输入参数
typedef struct tagNET_IN_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    QUERY_DEVICE_LOG_PARAM      stuQueryCondition;          // 查询记录数条件
} NET_IN_GETCOUNT_LOG_PARAM;

// CLIENT_QueryDevLogCount获取日志条数输出参数
typedef struct tagNET_OUT_GETCOUNT_LOG_PARAM
{
    DWORD                       dwSize;
    int                         nLogCount;                  // 日志数(设备返回)
} NET_OUT_GETCOUNT_LOG_PARAM;

// SDK日志回调
typedef int (CALLBACK *fSDKLogCallBack)(const char* szLogBuffer, unsigned int nLogSize, LDWORD dwUser);

// SDK全局日志打印信息
typedef struct tagLogSetPrintInfo
{
    DWORD           dwSize;
    BOOL            bSetFilePath;                           // 是否重设日志路径
    char            szLogFilePath[MAX_LOG_PATH_LEN];        // 日志路径(默认"./sdk_log/sdk_log.log")
    BOOL            bSetFileSize;                           // 是否重设日志文件大小
    unsigned int    nFileSize;                              // 每个日志文件的大小(默认大小10240), 单位:KB
    BOOL            bSetFileNum;                            // 是否重设日志文件个数
    unsigned int    nFileNum;                               // 绕接日志文件个数(默认大小10)
    BOOL            bSetPrintStrategy;                      // 是否重设日志打印输出策略
    unsigned int    nPrintStrategy;                         // 日志输出策略, 0:输出到文件(默认); 1:输出到窗口
	BYTE			byReserved[4];							// 字节对齐
	fSDKLogCallBack	cbSDKLogCallBack;						// 日志回调，需要将sdk日志回调出来时设置，默认为NULL
	LDWORD			dwUser;									// 用户数据
}LOG_SET_PRINT_INFO;

//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network 低速无线私域网 begin
//////////////////////////////////////////////////////////////////////////

// 无线设备类型
typedef enum tagNET_WIRELESS_DEVICE_TYPE
{
    NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0,               
    NET_WIRELESS_DEVICE_TYPE_KEYBOARD,          // 无线键盘
    NET_WIRELESS_DEVICE_TYPE_DEFENCE,           // 无线防区 
    NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL,     // 无线遥控 
    NET_WIRELESS_DEVICE_TYPE_MAGNETOMER,        // 无线门磁
	NET_WIRELESS_DEVICE_TYPE_ALARMBELL,			// 无线警号
	NET_WIRELESS_DEVICE_TYPE_SWITCHER,          // 无线插座
    NET_WIRELESS_DEVICE_TYPE_SMARTLOCK,         // 无线智能锁
    NET_WIRELESS_DEVICE_TYPE_REPEATER,          // 无线中继器
} NET_WIRELESS_DEVICE_TYPE;

// 无线设备工作模式
typedef enum tagEM_WIRELESS_DEVICE_MODE
{
    EM_WIRELESS_DEVICE_MODE_UNKNOWN = 0,                // 模式未识别
    EM_WIRELESS_DEVICE_MODE_NORMAL,                     // Normal 普通模式 
    EM_WIRELESS_DEVICE_MODE_POLLING,                    // Polling 巡检模式 只有Type为RemoteControl时才能处于巡检模式
} EM_WIRELESS_DEVICE_MODE;

// 传感器方式
typedef enum tagEM_CODEID_SENSE_METHOD_TYPE
{
    EM_CODEID_SENSE_METHOD_TYPE_UNKOWN,         // 未知的
    EM_CODEID_SENSE_METHOD_TYPE_DOOR_MAGNETISM, // 门磁
    EM_CODEID_SENSE_METHOD_TYPE_GAS_SENSOR,     // 燃气传感
    EM_CODEID_SENSE_METHOD_TYPE_CURTAIN_SENSOR, // 幕帘传感器
    EM_CODEID_SENSE_METHOD_TYPE_MOBILE_SENSOR,  // 移动传感器
    EM_CODEID_SENSE_METHOD_TYPE_PASSIVEINFRA,   // 被动红外传感器
    EM_CODEID_SENSE_METHOD_TYPE_URGENCY_BUTTON, // 紧急按钮
    EM_CODEID_SENSE_METHOD_TYPE_SMOKING_SENSOR, // 烟雾传感器
    EM_CODEID_SENSE_METHOD_TYPE_DOUBLEMETHOD,   // 双鉴传感器(红外+微波)
    EM_CODEID_SENSE_METHOD_TYPE_WATER_SENSOR,   // 水浸传感器
    EM_CODEID_SENSE_METHOD_TYPE_THREEMETHOD,    // 三技术
}EM_CODEID_SENSE_METHOD_TYPE;

#define DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN 32    // 无线设备序列号最大长度

// 对码信息
typedef struct tagNET_CODEID_INFO
{
    DWORD                       dwSize;
    TP_U64                      nWirelessId;                        // 无线ID号
    NET_WIRELESS_DEVICE_TYPE    emType;                             // 无线设备类型
    char                        szName[DH_USER_NAME_LENGTH];        // 用户名
    BOOL                        bEnable;                            // 是否启用了此设备
    char                        szCustomName[DH_COMMON_STRING_64];  // 自定义名称
    int                         nChannel;                           // 无线防区的alarm通道号,Alarm配置的下标,只有Type为Defence时此字段才有效。
    EM_WIRELESS_DEVICE_MODE     emMode;                             // 无线设备工作模式
    EM_CODEID_SENSE_METHOD_TYPE emSenseMethod;                      // 传感器方式
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 无线设备序列号
    UINT                       nTaskID;                            // 任务ID
    char                        szRoomNo[64];                       // 智能锁房间号
	DWORD                       nMaxFingerprints;                   // 指纹数量:为0时表示不支持指纹
    DWORD                       nMaxCards;                          // 卡片数量:为0时表示不支持卡片
    DWORD                       nMaxPwd;                            // 密码数量:为0时表示不支持密码

}NET_CODEID_INFO;

// 对码错误类型
typedef enum tagNET_CODEID_ERROR_TYPE
{   
    NET_CODEID_ERROR_TYPE_RIGHT = 0,            // 对码正确
    NET_CODEID_ERROR_TYPE_ALREADYEXIST,         // 已经存在
    NET_CODEID_ERROR_TYPE_OTHER,                // 其他错误
} NET_CODEID_ERROR_TYPE;

// 订阅无线对码信息回调函数原形,lAttachHandle是CLIENT_AttachLowRateWPAN返回值
typedef void (CALLBACK *fAttachLowRateWPANCB) (LLONG lLoginID, LLONG lAttachHandle, NET_CODEID_INFO* stuBuf, NET_CODEID_ERROR_TYPE emError, LDWORD dwUser);

// CLIENT_AttachLowRateWPAN()输入参数
typedef struct tagNET_IN_ATTACH_LOWRATEWPAN
{
    DWORD                   dwSize;
    fAttachLowRateWPANCB    cbAttachLowRateWPANCB;         // 对码数据回调
    LDWORD                  dwUser;                        // 用户数据
}NET_IN_ATTACH_LOWRATEWPAN;

// CLIENT_AttachLowRateWPAN()输出参数
typedef struct tagNET_OUT_ATTACH_LOWRATEWPAN
{
    DWORD               dwSize;
}NET_OUT_ATTACH_LOWRATEWPAN;

// 删除指定无线设备
// CLIENT_ControlDevice 接口的 DH_CTRL_LOWRATEWPAN_REMOVE命令参数
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVE
{
    DWORD                   dwSize;
    TP_U64                  nWirelessId;                // 无线设备ID
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 无线设备序列号 无线对码后续采用序列号的方式                                                                                        
}NET_CTRL_LOWRATEWPAN_REMOVE;

// 删除全部无线设备
// CLIENT_ControlDevice接口的 DH_CTRL_LOWRATEWPAN_REMOVEALL命令参数
typedef struct tagNET_CTRL_LOWRATEWPAN_REMOVEALL
{
    DWORD                   dwSize;
}NET_CTRL_LOWRATEWPAN_REMOVEALL;

// 修改无线设备信息
// CLIENT_ControlDevice接口的 DH_CTRL_LOWRATEWPAN_MODIFY 命令参数
typedef struct tagNET_CTRL_LOWRATEWPAN_MODIFY
{
    DWORD                   dwSize;
    NET_CODEID_INFO         stuCodeIDInfo;          // 根据CodeIDInfo中的CodeID,修改其User和Enable信息,其他不能修改
}NET_CTRL_LOWRATEWPAN_MODIFY;

//设置探测器的工作模式
//CLIENT_ControlDevice接口的 DH_CTRL_LOWRATEWPAN_SETWORKMODE命令参数
typedef struct tagNET_IN_CTRL_LOWRATEWPAN_SETWORKMODE
{
	DWORD                   dwSize;
	int                     nMode;                 		//设置模式 0 :省电模式,  1 :常工作模式

}NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE;


// 过车状态
typedef enum tagEM_CARPASS_STATUS
{
	EM_CARPASS_STATUS_UNKNOWN,     // 未知状态     
	EM_CARPASS_STATUS_CARPASS,     // 过车状态
	EM_CARPASS_STATUS_NORMAL,      // 无车状态
}EM_CARPASS_STATUS;

// 设置停车信息,对应DH_CTRL_SET_PARK_INFO命令参数
typedef struct tagNET_CTRL_SET_PARK_INFO
{
	DWORD				   dwSize;
	char				   szPlateNumber[MAX_PLATE_NUMBER_LEN];         // 车牌号码
	unsigned int		   nParkTime;									// 停车时长,单位:分钟
	char				   szMasterofCar[MAX_MASTER_OF_CAR_LEN];		// 车主姓名
	char				   szUserType[MAX_USER_TYPE_LEN];				// 用户类型,非通用,用于出入口抓拍一体机
																		// monthlyCardUser表示月卡用户,yearlyCardUser表示年卡用户,longTimeUser表示长期用户/VIP,casualUser表示临时用户/Visitor
	unsigned int		   nRemainDay;									// 到期天数
	char				   szParkCharge[MAX_PARK_CHARGE_LEN];			// 停车费
	unsigned int		   nRemainSpace;								// 停车库余位数
	unsigned int		   nPassEnable;									// 0:不允许车辆通过 1:允许车辆通过
	NET_TIME			   stuInTime;									// 车辆入场时间
	NET_TIME			   stuOutTime;									// 车辆出场时间
	EM_CARPASS_STATUS	   emCarStatus;									// 过车状态
	char				   szCustom[MAX_CUSTOM_LEN];					// 自定义显示字段，默认空 
	char				   szSubUserType[MAX_SUB_USER_TYPE_LEN];		// 用户类型（szUserType字段）的子类型 
	char				   szRemarks[MAX_REMARKS_LEN];					// 备注信息
    char                   szResource[MAX_RESOURCE_LEN];                // 资源文件（视频或图片）视频支持:mp4格式; 图片支持:BMP/jpg/JPG/jpeg/JPEG/png/PNG格式
}NET_CTRL_SET_PARK_INFO;

// 清除当前时间段内人数统计信息, 重新从0开始计算
//CLIENT_ControlDevice接口的 DH_CTRL_CLEAR_SECTION_STAT命令参数
typedef struct tagNET_CTRL_CLEAR_SECTION_STAT_INFO
{
	DWORD                   dwSize;
	int						nChannel;		// 视频通道号
} NET_CTRL_CLEAR_SECTION_STAT_INFO;

// 获取对码成功的总条数
typedef struct tagNET_GET_CODEID_COUNT
{
    DWORD               dwSize;
    int                 nCodeIDCount;       // 对码成功的总条数
}NET_GET_CODEID_COUNT;

// 获取对码信息
typedef struct tagNET_GET_CODEID_LIST
{
    DWORD               dwSize;
    int                 nStartIndex;            // 开始的索引号,开始第一次查询可设为0
    int                 nQueryNum;              // 本次获取的对码条数,此值小于等于能力集中nMaxPageSize字段的值
    int                 nRetCodeIDNum;          // 实际返回的对码条数
    NET_CODEID_INFO*    pstuCodeIDInfo;         // 获取对码的内容,内存由用户分配,不能小于nQueryNum*sizeof(NET_CODEID_INFO)
}NET_GET_CODEID_LIST;

// 增加对码信息 
typedef struct tagNET_CTRL_LOWRATEWPAN_ADD
{
	DWORD dwSize;
	NET_CODEID_INFO stuCodeIDInfo;             // 对码数据
}NET_CTRL_LOWRATEWPAN_ADD;

// 无线设备在线状态 
typedef enum tagEM_WIRELESS_DEVICE_ONLINE_STATE
{   
    EM_WIRELESS_DEVICE_STATE_UNKNOWN = 0,       // 未知
    EM_WIRELESS_DEVICE_STATE_OUTLINE,           // 离线
    EM_WIRELESS_DEVICE_STATE_ONLINE,            // 在线
} EM_WIRELESS_DEVICE_ONLINE_STATE;

// 无线设备电量状态
typedef enum tagEM_WIRELESS_DEVICE_POWER_STATE
{   
    EM_WIRELESS_DEVICE_POWER_UNKNOWN = 0,      // 电量未知
    EM_WIRELESS_DEVICE_POWER_NORMAL,           // 电量正常
    EM_WIRELESS_DEVICE_POWER_LOW,              // 低电量
} EM_WIRELESS_DEVICE_POWER_STATE;

// 无线设备状态信息
typedef struct tagNET_WIRELESS_DEVICE_INFO
{
    char                            szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 设备序列号 
    EM_WIRELESS_DEVICE_ONLINE_STATE emOnlineState; // 在线状态
    EM_WIRELESS_DEVICE_POWER_STATE  emPowerState;  // 电量状态  
    BYTE                            byReserved[128]; // 保留字段
}NET_WIRELESS_DEVICE_INFO;

// 获取无线设备状态
typedef struct tagNET_GET_WIRELESS_DEVICE_STATE
{
    DWORD               dwSize;
    int                 nStartIndex;           // 开始的索引号,开始第一次查询可设为0, 由用户设置
    int                 nQueryNum;             // 本次获取的设备状态条数, 此值小于等于能力集中nMaxPageSize字段的值, 用户设置
    int                 nRetQueryNum;          // 获取到的实际返回的设备状态条数, 小于等于nQueryNum
    NET_WIRELESS_DEVICE_INFO *pstuDeviceInfo;  // 获取设备状态的内容, 内存有用户分配, 不能小于nQueryNum*sizeof(NET_WIRELESS_DEVICE_INFO)
}NET_GET_WIRELESS_DEVICE_STATE;

// 冗余电源状态
typedef enum tagEM_REDUNDANCE_POWER_STATE
{   
    EM_REDUNDANCE_POWER_STATE_UNKNOWN = 0,       // 状态未知
    EM_REDUNDANCE_POWER_STATE_ON,                // 打开
    EM_REDUNDANCE_POWER_STATE_OFF,               // 关闭
    EM_REDUNDANCE_POWER_STATE_ON_FAULT,          // 故障
} EM_REDUNDANCE_POWER_STATE;

#define MAX_REDUNDANCE_POWER_NUM 16              // 最大冗余电源个数

// 获取冗余电源信息
typedef struct tagNET_GET_REDUNDANCE_POWER_INFO
{
    DWORD                     dwSize;                                   // 结构体大小
    int                       nPowerNum;                                // 电源数量
    EM_REDUNDANCE_POWER_STATE emPowerState[MAX_REDUNDANCE_POWER_NUM];   // 电源状态信息数组
}NET_GET_REDUNDANCE_POWER_INFO;

// 配件防拆状态
typedef enum tagNET_EM_ACCESSORY_TAMPER_STATE
{
    NET_EM_ACCESSORY_TAMPER_UNKNOWN,                    // 未知
    NET_EM_ACCESSORY_TAMPER_ON,                         // 开
    NET_EM_ACCESSORY_TAMPER_OFF,                        // 关
}NET_EM_ACCESSORY_TAMPER_STATE;

// 门磁开门状态
typedef enum tagNET_EM_DOOR_STATE
{
    NET_EM_DOOR_STATE_UNKNOWN,                          // 未知
    NET_EM_DOOR_STATE_ON,                               // 开
    NET_EM_DOOR_STATE_OFF,                              // 关   
}NET_EM_DOOR_STATE;

// 在线状态
typedef enum tagNET_EM_ONLINE_STATE
{
    NET_EM_ONLINE_STATE_UNKNOWN,                        // 未知
    NET_EM_ONLINE_STATE_OFFLINE,                        // 离线
    NET_EM_ONLINE_STATE_ONLINE,                         // 在线
}NET_EM_ONLINE_STATE;

// 告警状态
typedef enum tagNET_EM_ALARM_STATE
{
    NET_EM_ALARM_STATE_UNKNOWN = -1,                    // 未知
    NET_EM_ALARM_STATE_NORMAL,                          // 正常
    NET_EM_ALARM_STATE_ALARM,                           // 告警
}NET_EM_ALARM_STATE;

// 返回的状态信息
typedef struct tagNET_STATUS_INFO
{
    char                            szSN[MAX_COMMON_STRING_32];     // 配件序列号
    UINT                            nPercent;                       // 电池电量百分比,0~100
    float                           fVolt;                          // 电池电量,单位:伏
    UINT                            nIntensity;                     // 无线信号强度等级，0~5
    UINT                            nSignal;                        // 无线信号强度，单位dbm，0~120
    NET_EM_ACCESSORY_TAMPER_STATE   emAccessoryTamperState;         // 配件防拆状态
    NET_EM_DOOR_STATE               emDoorState;                    // 门磁开门状态
    char                            szName[MAX_COMMON_STRING_32];   // 配件名称
    NET_EM_ONLINE_STATE             emOnlineState;                  // 在线状态
    NET_EM_ALARM_STATE              emAlarmState;                   // 告警状态,仅对门磁、水浸等状态量报警有效；对红外灯脉冲报警无效
    char                            szVersion[MAX_COMMON_STRING_16];// 配件版本
}NET_STATUS_INFO;

// 获取配件状态
typedef struct tagNET_GET_ACCESSORY_STATUS
{
    DWORD                       dwSize;                         // 结构体大小
    int                         nSNNum;                         // 配件序列号数组个数（当个数为0时,返回主机下所有配件状态）
    char                        szSN[56][MAX_COMMON_STRING_32]; // 配件序列号数组,一维数组
    int                         nStatusNum;                     // 返回的状态信息数组个数
    NET_STATUS_INFO             stStatusInfo[56];				// 返回的状态信息数组
}NET_GET_ACCESSORY_STATUS;

// 测试邮件, CLIENT_ControlDeviceEx 入参 对应 DH_CTRL_TEST_MAIL
typedef struct tagNET_IN_TEST_MAIL
{
    DWORD dwSize;
}NET_IN_TEST_MAIL;

// 测试邮件, CLIENT_ControlDeviceEx 出参 对应 DH_CTRL_TEST_MAIL
typedef struct tagNET_OUT_TEST_MAIL
{
    DWORD dwSize;
}NET_OUT_TEST_MAIL;

// 控制智能开关, CLIENT_ControlDeviceEx 入参 对应 DH_CTRL_CONTROL_SMART_SWITCH
typedef struct tagNET_IN_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
    char                        szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 设备序列号 
    BOOL                        bEnable; // TRUE - 开, FALSE - 关
    int                         nDelayTime; // 延时时间, 等于0时，表示立即打开或关闭. unit: min
}NET_IN_CONTROL_SMART_SWITCH;

// 控制智能开关, CLIENT_ControlDeviceEx 出参 对应 DH_CTRL_CONTROL_SMART_SWITCH
typedef struct tagNET_OUT_CONTROL_SMART_SWITCH
{
    DWORD                       dwSize;
}NET_OUT_CONTROL_SMART_SWITCH;


// 同轴IO控制类型
typedef enum tagEM_COAXIAL_CONTROL_IO_TYPE
{
	EM_COAXIAL_CONTROL_IO_TYPE_UNKNOWN,				// 未知
	EM_COAXIAL_CONTROL_IO_TYPE_LIGHT,				// 白光灯
	EM_COAXIAL_CONTROL_IO_TYPE_SPEAKER,				// speak音频
} EM_COAXIAL_CONTROL_IO_TYPE;

// 同轴IO控制开关
typedef enum tagEM_COAXIAL_CONTROL_IO_SWITCH
{
	EM_COAXIAL_CONTROL_IO_SWITCH_UNKNOWN,			// 未知
	EM_COAXIAL_CONTROL_IO_SWITCH_OPEN,				// 开
	EM_COAXIAL_CONTROL_IO_SWITCH_CLOSE,				// 关
} EM_COAXIAL_CONTROL_IO_SWITCH;

// 同轴IO触发方式
typedef enum tagEM_COAXIAL_CONTROL_IO_TRIGGER_MODE
{
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_UNKNOWN,			// 未知
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_LINKAGE_TRIGGER,	// 联动触发
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_MANUAL_TRIGGER,	// 手动触发
} EM_COAXIAL_CONTROL_IO_TRIGGER_MODE;

// 同轴IO信息结构体
typedef struct tagNET_COAXIAL_CONTROL_IO_INFO
{
	EM_COAXIAL_CONTROL_IO_TYPE			emType;				// 同轴IO控制类型
	EM_COAXIAL_CONTROL_IO_SWITCH		emSwicth;			// 同轴IO控制开关
	EM_COAXIAL_CONTROL_IO_TRIGGER_MODE	emMode;				// 同轴IO触发方式
	BYTE								byReserved[128];	// 保留字节
} NET_COAXIAL_CONTROL_IO_INFO;

// 同轴IO信息最大个数
#define	MAX_COAXIAL_CONTROL_IO_COUNT	8

// 发送同轴IO控制命令, CLIENT_ControlDeviceEx 入参 对应 DH_CTRL_COAXIAL_CONTROL_IO
typedef struct tagNET_IN_CONTROL_COAXIAL_CONTROL_IO
{
	DWORD							dwSize;									// 结构体大小
	int								nChannel;								// 通道号
	int								nInfoCount;								// 同轴IO信息个数
	NET_COAXIAL_CONTROL_IO_INFO		stInfo[MAX_COAXIAL_CONTROL_IO_COUNT];	// 同轴IO信息
} NET_IN_CONTROL_COAXIAL_CONTROL_IO;

// 发送同轴IO控制命令, CLIENT_ControlDeviceEx 出参 对应 DH_CTRL_COAXIAL_CONTROL_IO
typedef struct tagNET_OUT_CONTROL_COAXIAL_CONTROL_IO
{
	DWORD							dwSize;									// 结构体大小
} NET_OUT_CONTROL_COAXIAL_CONTROL_IO;


//////////////////////////////////////////////////////////////////////////
//       Low Rate Wireless Personal Area Network 低速无线私域网 end
//////////////////////////////////////////////////////////////////////////

// 模拟量通道数据查询(对应 DH_DEVSTATE_ANALOGALARM_DATA 命令)
typedef struct tagNET_GET_ANALOGALARM_DATA 
{
    DWORD                       dwSize;
    int							nChannelID;     // 待查询的模拟量通道号(从0开始)
    NET_ANALOGALARM_SENSE_INFO  stuInfo;        // 获得的模拟量通道数据
}NET_GET_ANALOGALARM_DATA;

// 监测控制和数据采集设备的设备类型
typedef enum tagEM_NET_SCADA_DEV_TYPE
{
    EM_NET_SCADA_DEV_TYPE_UNKNOWN = 0,                         // 未知
    EM_NET_SCADA_DEV_TYPE_ALL,                                 // 所有类型设备
    EM_NET_SCADA_DEV_TYPE_UPS,                                 // UPS
} EM_NET_SCADA_DEV_TYPE;

// 监测控制和数据采集设备的点位表路径信息输入参数, 查询条件
typedef struct tagNET_IN_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    char                            szDevType[DH_COMMON_STRING_64]; // 设备类型
}NET_IN_SCADA_POINT_LIST_INFO;

#define MAX_SCADA_POINT_LIST_INDEX          8               // 最大SCADADev配置下标个数, 即最大通道

// 点位表路径信息
typedef struct tagNET_SCADA_POINT_LIST
{
    DWORD                           dwSize;
    int                             nIndexValidNum;         // 有效的配置下标个数
    int                             nIndex[MAX_SCADA_POINT_LIST_INDEX];// SCADADev配置下标值, 从0开始
    char                            szPath[DH_COMMON_STRING_256];// 点表的完整路径
}NET_SCADA_POINT_LIST;

#define MAX_SCADA_POINT_LIST_INFO_NUM       256               // 最大点位表路径个数
#define MAX_SCADA_POINT_LIST_ALARM_INFO_NUM 256				  // 最大点位表报警个数

// 监测控制和数据采集设备的点位表路径信息输出参数, 查询结果
typedef struct tagNET_OUT_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    int                             nList;                  // 有效点位表路径信息个数
    NET_SCADA_POINT_LIST            stuList[MAX_SCADA_POINT_LIST_INFO_NUM];// 点位表路径信息
}NET_OUT_SCADA_POINT_LIST_INFO;

// 监测控制和数据采集设备的点位表信息, (对应 DH_DEVSTATE_SCADA_POINT_LIST 命令)
typedef struct tagNET_SCADA_POINT_LIST_INFO 
{
    DWORD                           dwSize;
    NET_IN_SCADA_POINT_LIST_INFO    stuIn;                  // 查询条件
    NET_OUT_SCADA_POINT_LIST_INFO   stuOut;                 // 查询结果
}NET_SCADA_POINT_LIST_INFO;

// 点位类型
typedef enum tagEM_NET_SCADA_POINT_TYPE
{
    EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0,                       // 未知
    EM_NET_SCADA_POINT_TYPE_ALL,                               // 所有类型
    EM_NET_SCADA_POINT_TYPE_YC,                                // 遥测 模拟量输入
    EM_NET_SCADA_POINT_TYPE_YX,                                // 遥信 开关量输入
    EM_NET_SCADA_POINT_TYPE_YT,                                // 遥调 模拟量输出
    EM_NET_SCADA_POINT_TYPE_YK,                                // 遥控 开关量输出
} EM_NET_SCADA_POINT_TYPE;

// SCADA监测点位查询条件
typedef struct tagNET_IN_SCADA_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                    // 待查询的点位类型
}NET_IN_SCADA_INFO;

#define MAX_SCADA_YX_NUM                128                 // 最大遥信个数
#define MAX_SCADA_YC_NUM                128                 // 最大遥测个数
#define MAX_SCADA_POINT_INFO_NUM        8                   // 最大点表个数

// 点表信息
typedef struct tagNET_SCADA_POINT_INFO 
{
    DWORD                   dwSize;
    char                    szDevName[DH_COMMON_STRING_64];// 设备名称
    int                     nYX;                            // 有效遥信个数
    unsigned int            anYX[MAX_SCADA_YX_NUM];         // 遥信信息
    int                     nYC;                            // 有效遥测个数
    float                   afYC[MAX_SCADA_YC_NUM];         // 遥测信息
}NET_SCADA_POINT_INFO;

// SCADA监测点位查询结果
typedef struct tagNET_OUT_SCADA_INFO 
{
    DWORD                   dwSize;
    int                     nPointInfoNum;                  // 有效点表个数
    NET_SCADA_POINT_INFO    stuPointInfo[MAX_SCADA_POINT_INFO_NUM];// 点表信息
}NET_OUT_SCADA_INFO;

// 监测控制和数据采集设备的监测点位信息(对应 DH_DEVSTATE_SCADA_INFO 命令)
typedef struct tagNET_SCADA_INFO
{
    DWORD                   dwSize;
    NET_IN_SCADA_INFO       stuIn;                          // 查询条件
    NET_OUT_SCADA_INFO      stuOut;                         // 查询结果
}NET_SCADA_INFO;

// SCADA能力名称
typedef enum tagEM_NET_SCADA_CAPS_TYPE
{
    EM_NET_SCADA_CAPS_TYPE_UNKNOWN,
    EM_NET_SCADA_CAPS_TYPE_ALL,                                // 所有类型
    EM_NET_SCADA_CAPS_TYPE_DEV,                                // DevInfo
} EM_NET_SCADA_CAPS_TYPE;

// 监测控制和数据采集设备能力信息查询条件
typedef struct tagNET_IN_SCADA_CAPS
{
    DWORD                   dwSize;
    EM_NET_SCADA_CAPS_TYPE  emType;                         // 查询类型
} NET_IN_SCADA_CAPS;

#define MAX_NET_SCADA_CAPS_TYPE (16)
#define MAX_NET_SCADA_CAPS_NAME (16)

// 监测控制和数据采集设备类型能力信息
typedef struct tagNET_OUT_SCADA_CAPS_ITEM
{
    DWORD                   dwSize;
    char                    szDevType[DH_COMMON_STRING_32];    // 设备类型
    int                     nValidName;                         // 有效设备名称个数
    char                    szDevName[MAX_NET_SCADA_CAPS_NAME][DH_COMMON_STRING_32];// 设备名称, 唯一标示设备
} NET_OUT_SCADA_CAPS_ITEM;

// 监测控制和数据采集设备能力信息查询结果
typedef struct tagNET_OUT_SCADA_CAPS
{
    DWORD                   dwSize;
    int                     nValidType;                         // 有效设备类型个数
    NET_OUT_SCADA_CAPS_ITEM stuItems[MAX_NET_SCADA_CAPS_TYPE];  // 最多16个类型
} NET_OUT_SCADA_CAPS;

// 监测控制和数据采集设备能力信息(对应 DH_DEVSTATE_SCADA_CAPS 命令)
typedef struct tagNET_SCADA_CAPS
{
    DWORD                   dwSize;
    NET_IN_SCADA_CAPS       stuIn;                          // 查询条件
    NET_OUT_SCADA_CAPS      stuOut;                         // 查询结果
} NET_SCADA_CAPS;

// 点位信息(通过设备、传感器点位获取)
typedef struct tagNET_SCADA_POINT_BY_ID_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emType;                         // 点位类型
    char                    szID[DH_COMMON_STRING_64];      // 监测点位ID
    int                     nMeasuredVal;                   // 点位类型为YX时有效
    float                   fMeasureVal;                    // 点位类型为YC时有效
    int                     nSetupVal;                      // 点位类型为YK时有效
    float                   fSetupVal;                      // 点位类型为YT时有效
    int                     nStatus;                        // 数据状态, -1:未知, 0:正常, 1:1级告警, 2:2级告警, 3:3级告警, 4:4级告警, 5:操作事件, 6:无效数据
    NET_TIME                stuTime;                        // 记录时间
}NET_SCADA_POINT_BY_ID_INFO;

#define MAX_SCADA_ID_OF_SENSOR_NUM  128                     // 最大检测点位ID个数

// 通过设备、获取监测点位信息(对应 NET_SCADA_INFO_BY_ID)
typedef struct tagNET_SCADA_INFO_BY_ID
{
    DWORD                   dwSize;
    char                    szSensorID[DH_COMMON_STRING_64];// 输入参数, 探测器ID
    int                     nIDs;                           // 输入参数, 有效点位ID个数
    char                    szIDs[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_64];// 输入参数, 点位ID
	BOOL					bIsHandle;						// 输入参数，返回数据是否经过处理（无效数据过滤等）:"false"：未处理，"true"：处理
    int                     nMaxCount;                      // 输入参数, pstuInfo对应数组个数
    int                     nRetCount;                      // 输出参数, pstInfo实际返回有效个数, 可能大于用户分配个数nMaxCount
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;                   // 输入输出参数, 用户分配缓存,大小为sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxCount
}NET_SCADA_INFO_BY_ID;

// 监测设备信息
typedef struct tagNET_SCADA_DEVICE_ID_INFO 
{
    char                    szDeviceID[DH_COMMON_STRING_64];// 设备id
    char                    szDevName[DH_COMMON_STRING_64]; // 设备名称, 和CFG_SCADA_DEV_INFO配置中的szDevName一致
    BYTE                    reserve[1024];
}NET_SCADA_DEVICE_ID_INFO;

// 获取当前主机所接入的外部设备ID
typedef struct tagNET_SCADA_DEVICE_LIST
{
    DWORD                       dwSize;
    int                         nMax;                       // 用户分配的结构体个数
    int                         nRet;                       // 设备实际返回的有效结构体个数
    NET_SCADA_DEVICE_ID_INFO*   pstuDeviceIDInfo;           // 监测设备信息,用户分配内存,大小为sizeof(NET_SCADA_DEVICE_ID_INFO)*nMax
}NET_SCADA_DEVICE_LIST;

// 监测点位信息
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO
{
    DWORD                       dwSize; 
    char                        szDevName[DH_COMMON_STRING_64];     // 设备名称,与getInfo获取的名称一致
    EM_NET_SCADA_POINT_TYPE     emPointType;                        // 点位类型
    char                        szPointName[DH_COMMON_STRING_64];   // 点位名,与点位表的取值一致
    float                       fValue;                             // Type为YC时为浮点数
    int                         nValue;                             // Type为YX时为整数
    char                        szFSUID[DH_COMMON_STRING_64];       // 现场监控单元ID(Field Supervision Unit), 即设备本身
    char                        szID[DH_COMMON_STRING_64];          // 点位ID
    char                        szSensorID[DH_COMMON_STRING_64];    // 探测器ID
    NET_TIME_EX                 stuCollectTime;                     // 采集时间
} NET_SCADA_NOTIFY_POINT_INFO;

// 监测点位信息列表
typedef struct tagNET_SCADA_NOTIFY_POINT_INFO_LIST
{
    DWORD                           dwSize;
    int                             nList;                        // 监测点位信息个数
    NET_SCADA_NOTIFY_POINT_INFO     stuList[MAX_SCADA_POINT_LIST_INFO_NUM]; // 监测点位信息
} NET_SCADA_NOTIFY_POINT_INFO_LIST;

// 订阅监测点位信息回调函数原型
typedef void (CALLBACK *fSCADAAttachInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAttachInfo()接口输入参数
typedef struct tagNET_IN_SCADA_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAttachInfoCallBack        cbCallBack;                 // 数据回调函数
    EM_NET_SCADA_POINT_TYPE         emPointType;                // 点位类型
    LDWORD                          dwUser;                     // 用户定义参数
} NET_IN_SCADA_ATTACH_INFO;

// CLIENT_SCADAAttachInfo()接口输出参数
typedef struct tagNET_OUT_SCADA_ATTACH_INFO
{
    DWORD    dwSize;
} NET_OUT_SCADA_ATTACH_INFO;

//////////////////////////////////////////////////////////////////////////
#define MAX_SCADA_ID_NUM                            1024    // 监测点位id的最大个数

// 点位阈值信息
typedef struct tagNET_SCADA_ID_THRESHOLD_INFO 
{
    DWORD                   dwSize;
    EM_NET_SCADA_POINT_TYPE emPointType;                // 点位类型
    char                    szID[DH_COMMON_STRING_32];  // 点位ID
    float                   fThreshold;                 // 告警门限
    float                   fAbsoluteValue;             // 绝对阈值
    float                   fRelativeValue;             // 相对阈值
    int                     nStatus;                    // 数据状态, -1:未知, 0:正常, 1:1级告警, 2:2级告警, 3:3级告警, 4:4级告警, 5:操作事件, 6:无效数据
}NET_SCADA_ID_THRESHOLD_INFO;

// CLIENT_SCADAGetThreshold输入参数
typedef struct tagNET_IN_SCADA_GET_THRESHOLD 
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_64];                // 外接设备id
    int             nIDs;                                           // 有效监测点位个数
    char            szIDs[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];   // 待获取的监测点位ID
}NET_IN_SCADA_GET_THRESHOLD;

// CLIENT_SCADAGetThreshold输出参数
typedef struct tagNET_OUT_SCADA_GET_THRESHOLD 
{
    DWORD                           dwSize;
    int                             nMax;               // 用户分配的点位阈值信息个数
    int                             nRet;               // 实际返回的点位阈值信息
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // 点位阈值信息, 用户分配内存,大小为sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_OUT_SCADA_GET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_SCADASetThreshold输入参数
typedef struct tagNET_IN_SCADA_SET_THRESHOLD 
{
    DWORD                           dwSize;
    char                            szDeviceID[DH_COMMON_STRING_64];// 外接设备id
    int                             nMax;               // 用户分配的点位阈值信息个数
    NET_SCADA_ID_THRESHOLD_INFO*    pstuThresholdInfo;  // 点位阈值信息, 用户分配内存,大小为sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax
}NET_IN_SCADA_SET_THRESHOLD;

// CLIENT_SCADASetThreshold输出参数
typedef struct tagNET_OUT_SCADA_SET_THRESHOLD 
{
    DWORD           dwSize;
    int             nSuccess;                                           // 有效的存放设置阈值成功的id个数
    char            szSuccessID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32]; // 设置阈值成功的id,用户分配内存
    int             nFail;                                              // 用户分配的存放设置阈值失败的id个数
    char            szFailID[MAX_SCADA_ID_NUM][DH_COMMON_STRING_32];    // 设置阈值失败的id, 用户分配内存
}NET_OUT_SCADA_SET_THRESHOLD;

//////////////////////////////////////////////////////////////////////////
// CLIENT_StartFindSCADA输入参数
typedef struct tagNET_IN_SCADA_START_FIND 
{
    DWORD           dwSize;
    NET_TIME        stuStartTime;                   // 开始时间, 必填
    BOOL            bEndTime;                       // 是否限制结束时间, TRUE: 必填stuEndTime, FLASE: 不限制结束时间
    NET_TIME        stuEndTime;                     // 结束时间
    char            szDeviceID[DH_COMMON_STRING_64];// DeviceID, 必填
    char            szID[DH_COMMON_STRING_32];      // 监测点位ID, 必填
	int				nIDsNum;						// 监测点ID数组长度
	char			szIDs[32][DH_COMMON_STRING_32]; // 监控点ID号数组，SDT离网供电扩展字段
}NET_IN_SCADA_START_FIND;

// CLIENT_StartFindSCADA输出参数
typedef struct tagNET_OUT_SCADA_START_FIND 
{
    DWORD           dwSize;
    DWORD           dwTotalCount;                   // 符合查询条件的总数
}NET_OUT_SCADA_START_FIND;

// CLIENT_DoFindSCADA输入参数
typedef struct tagNET_IN_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nStartNo;           // 起始序号
    int                         nCount;             // 本次欲获得结果的个数
}NET_IN_SCADA_DO_FIND;

// CLIENT_DoFindSCADA输出参数
typedef struct tagNET_OUT_SCADA_DO_FIND 
{
    DWORD                       dwSize;
    int                         nRetNum;            // 本次查询到的个数
    NET_SCADA_POINT_BY_ID_INFO* pstuInfo;           // 查询结果, 用户分配内存,大小为sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxNum
    int	                        nMaxNum;            // 用户分配内存的个数
}NET_OUT_SCADA_DO_FIND;

//监测点位报警信息
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO
{
    DWORD           dwSize;
    char            szDevID[DH_COMMON_STRING_16];               // 设备ID
    char            szPointID[DH_COMMON_STRING_128];            // 点位ID
    BOOL            bAlarmFlag;                                 // 报警标志
    NET_TIME        stuAlarmTime;                               // 报警时间
    int	            nAlarmLevel;                                // 报警级别（0~6）
    int             nSerialNo;                                  // 报警编号,同一个告警的开始和结束的编号是相同的。
    char            szAlarmDesc[DH_COMMON_STRING_128];          // 报警描述
} NET_SCADA_NOTIFY_POINT_ALARM_INFO;

// 监测点位报警信息列表
typedef struct tagNET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST
{
    DWORD                               dwSize;
    int	                                nList;                                          // 监测点位报警信息个数
    NET_SCADA_NOTIFY_POINT_ALARM_INFO   stuList[MAX_SCADA_POINT_LIST_ALARM_INFO_NUM];   // 监测点位报警信息
} NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST;

// 定义监测点报警信息回调函数原型
typedef void (CALLBACK *fSCADAAlarmAttachInfoCallBack)(LLONG lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_SCADAAlarmAttachInfo()接口输入参数
typedef struct tagNET_IN_SCADA_ALARM_ATTACH_INFO
{
    DWORD                           dwSize;
    fSCADAAlarmAttachInfoCallBack   cbCallBack;                 // 数据回调函数
    LDWORD                          dwUser;	                    // 用户定义参数
} NET_IN_SCADA_ALARM_ATTACH_INFO;

// CLIENT_SCADAAlarmAttachInfo()接口输出参数
typedef struct tagNET_OUT_SCADA_ALARM_ATTACH_INFO
{
    DWORD                       dwSize;
} NET_OUT_SCADA_ALARM_ATTACH_INFO;

// 监控点值设置参数
typedef struct tagNET_SCADA_POINT_SET_INFO
{
    DWORD                       dwSize;
    EM_NET_SCADA_POINT_TYPE	    emType;                         // 监控点位类型,取YK、YT两种类型
    char                        szPointID[DH_COMMON_STRING_64];	// 监控点位ID
    int	                        nSetupVal;                      // 点位类型为YK时有效
    float                       fSetupVal;                      // 点位类型为YT时有效
} NET_SCADA_POINT_SET_INFO;

// 监控点值设置参数列表,CLIENT_SetSCADAInfo()接口输入参数
typedef struct tagNET_IN_SCADA_POINT_SET_INFO_LIST
{
    DWORD                       dwSize;
    char                        szDevID[DH_COMMON_STRING_32];           // 设备ID
    int	                        nPointNum;                              // 监控点个数
    NET_SCADA_POINT_SET_INFO    stuList[MAX_SCADA_ID_OF_SENSOR_NUM];    // 监控点列表信息
} NET_IN_SCADA_POINT_SET_INFO_LIST;

// 设置监控点值返回的结果列表,CLIENT_SetSCADAInfo()接口输出参数
typedef struct tagNET_OUT_SCADA_POINT_SET_INFO_LIST
{
    DWORD                   dwSize;
    int                     nSuccess;                                                       // 有效的控制或调节成功的ID个数
    char                    szSuccessID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];   // 控制或调节成功的ID的列表
    int                     nFail;                                                          // 有效的控制或调节失败的ID个数
    char                    szFailID[MAX_SCADA_ID_OF_SENSOR_NUM][DH_COMMON_STRING_32];      // 控制或调节失败的ID的列表
} NET_OUT_SCADA_POINT_SET_INFO_LIST;


// 获取当前子系统启用状态(对应DH_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS命令)
typedef struct tagNET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES
{
    DWORD               dwSize;
    int                 nChannelId;                         // 子系统号
    BOOL                bActive;                            // 子系统启用状态, TRUE 表示启用,FALSE表示不启用
}NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES;

// 报警子系统激活设置参数(对应DH_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET命令)
typedef struct tagNET_CTRL_ALARM_SUBSYSTEM_SETACTIVE 
{
    DWORD               dwSize;
    int                 nChannelId;                         // 子系统号
    BOOL                bActive;                            // 子系统启用状态,TRUE 表示启用,FALSE表示不启用
}NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE;

// 禁止开闸参数(对应 DH_CTRL_FORBID_OPEN_STROBE)
typedef struct tagNET_CTRL_FORBID_OPEN_STROBE
{
    DWORD               dwSize;             
    int                 nChannelID;                         // 通道号    
    int                 nTime;                              // 禁止开闸的持续时间,单位:s,即在此操作之后的对应时间内不允许设备开闸 
}NET_CTRL_FORBID_OPEN_STROBE;

#define MAX_PLATENUMBER_LEN    64                           // 最大车牌号码长度

// 开启道闸参数(对应DH_CTRL_OPEN_STROBE命令)
typedef struct tagNET_CTRL_OPEN_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // 通道号, nChannelId为-1时表示未使用通道号, 表示单通道设备
    char                szPlateNumber[MAX_PLATENUMBER_LEN]; // 车牌号码
}NET_CTRL_OPEN_STROBE;

// 异步开启道闸回调函数
// nError = 0 表示查询成功;
// nError = 1 表示内存申请失败;
// nError = 2 表示超时, 即超时时间内设备未返回信息
// nError = 3 表示设备返回数据校验不通过;
// nError = 4 发送查询请求失败
typedef void (CALLBACK *fOpenStrobeCallBack)(LLONG lLoginID, NET_CTRL_OPEN_STROBE stuOpenStrobe, int nError, LDWORD dwUser);

// 异步开启道闸参数(对应DH_CTRL_OPEN_STROBE命令)
typedef struct tagNET_CTRL_OPEN_STROBE_ASYN
{
    DWORD					dwSize;
	NET_CTRL_OPEN_STROBE	stuOpenStrobe;						// 开启道闸参数
	fOpenStrobeCallBack		cbCallBack;							// 数据回调函数
	LDWORD					dwUser;								// 用户定义参数
	int						nWaitTime;							// 超时时间
} NET_CTRL_OPEN_STROBE_ASYN;

// 关闭道闸参数(对应DH_CTRL_CLOSE_STROBE命令)
typedef struct tagNET_CTRL_CLOSE_STROBE
{
    DWORD               dwSize;
    int                 nChannelId;                         // 通道号
}NET_CTRL_CLOSE_STROBE;

// 强制产生违章参数(对应DH_CTRL_FORCE_BREAKING命令)
typedef struct tagNET_CTRL_FORCE_BREAKING
{
	DWORD               dwSize;
    int                 nChannelId;                         // 通道号
	int                 nLaneMask;                          // 车道掩码位
	DWORD               dwBreakingType;                     // 违章类型, 详见dhnetsdk.h中"智能分析事件类型"                
}NET_CTRL_FORCE_BREAKING;

// 回放拒绝接听参数(对应DH_CTRL_TALKING_REFUSE命令)
typedef struct tagNET_CTRL_TALKING_REFUSE 
{
    DWORD           dwSize;
    int             nChannelID;                             // 对讲通道号
}NET_CTRL_TALKING_REFUSE;


// 远程对讲控制类型
typedef enum tagEM_REMOTETALK_CTRL_STATE
{
    EM_REMOTETALK_CTRL_STATE_UNKNOWN = 0,                                // 未定义类型
    EM_REMOTETALK_CTRL_STATE_INVITE,                                     // 设备向平台发起对讲
}EM_REMOTETALK_CTRL_STATE;

// 远程对讲控制参数
typedef struct tagNET_CTRL_REMOTETALK_PARAM
{
    DWORD                       dwSize;                 // 本结构体大小
    EM_REMOTETALK_CTRL_STATE    emAction;               // 远程对讲控制的操作类型
}NET_CTRL_REMOTETALK_PARAM;

// 车位预定状态
typedef enum tagEM_NET_ORDER_STATE
{
    EM_NET_ORDER_STATE_UNKNOWN,
    EM_NET_ORDER_STATE_FREE,                            // 空闲Free
    EM_NET_ORDER_STATE_ORDERED,                         // 预定Ordered
}EM_NET_ORDER_STATE;

// 车位预定状态信息
typedef struct tagNET_ORDER_STATE_INFO
{
    DWORD               dwSize;
    unsigned int        nLane;                          // 车位号
    EM_NET_ORDER_STATE  emOrderState;                   // 预定情况
}NET_ORDER_STATE_INFO;

// 设置车位预定状态参数(对应DH_CTRL_SET_ORDER_STATE命令)
typedef struct tagNET_CTRL_SET_ORDER_STATE
{
    DWORD                   dwSize;
    NET_ORDER_STATE_INFO*   pOrderStateInfo;              // 车位预定信息,用户分配空间,大小为sizeof(NET_ORDER_STATE_INFO)*nStateCount
    unsigned int            nStateCount;                  // 有效预定个数
}NET_CTRL_SET_ORDER_STATE;

// 停车场出入口控制器LED滚动屏幕字幕滚动速度
typedef enum tagNET_ECK_LED_SPEED_TYPE 
{
    NET_ECK_LED_SPEED_UNKNOWN = 0,
    NET_ECK_LED_SPEED_LOW,                              // 慢
    NET_ECK_LED_SPEED_NORMAL,                           // 正常
    NET_ECK_LED_SPEED_HIGH,                             // 快
}NET_ECK_LED_SPEED_TYPE;

// 停车场出入口控制器LED设置 参数DH_CTRL_ECK_LED_SET
typedef struct tagNET_CTRL_ECK_LED_SET_PARAM 
{
    DWORD                   dwSize;
    NET_ECK_LED_SPEED_TYPE  emLEDSpeed;                 // 字幕滚动速度
    int                     nCount;                     // 有效显示次数, 范围0-255, 0表示永久
    char                    szCustomData[DH_COMMON_STRING_512];// LED滚动屏初始自定义字符, 0-256字节
}NET_CTRL_ECK_LED_SET_PARAM;

#define NET_MAX_ECK_PANEL_NUM  12                            // 显示内容的最大数量

//显示内容的类型
typedef enum tagEM_NET_ECK_PANEL_TYPE
{
	EM_NET_ECK_PANEL_TYPE_INTCHAR,                           // 整数、字母、空格
	EM_NET_ECK_PANEL_TYPE_IMAGE,                             // 图形
	EM_NET_ECK_PANEL_TYPE_ARROWS,                            // 箭头
}EM_NET_ECK_PANEL_TYPE;

//是否加粗
typedef enum tagEM_NET_ECK_PANEL_ISBOLD
{
	EM_NET_ECK_PANEL_ISBOLD_FALSE,                           // 不加粗
	EM_NET_ECK_PANEL_ISBOLD_TRUE,                            // 加粗
}EM_NET_ECK_PANEL_ISBOLD;

//显示颜色
typedef enum tagEM_NET_ECK_PANEL_COLOR
{
	EM_NET_ECK_PANEL_COLOR_UNKNOWN,                          // 未知
	EM_NET_ECK_PANEL_COLOR_RED,                              // 红色
	EM_NET_ECK_PANEL_COLOR_GREEN,                            // 绿色 
	EM_NET_ECK_PANEL_COLOR_YELLOW,                           // 黄色
}EM_NET_ECK_PANEL_COLOR;

//箭头指向，箭头专用
typedef enum tagEM_NET_ECK_PANEL_DIRECTION
{
	EM_NET_ECK_PANEL_DIRECTION_UNKNOWN,                      // 未知
	EM_NET_ECK_PANEL_DIRECTION_LEFT,                         // 左
	EM_NET_ECK_PANEL_DIRECTION_UP,                           // 上
	EM_NET_ECK_PANEL_DIRECTION_RIGHT,                        // 右
}EM_NET_ECK_PANEL_DIRECTION;

//图标
typedef enum tagEM_NET_ECK_PANEL_ICON
{
	EM_NET_ECK_PANEL_ICON_UNKNOWN,                           // 未知
	EM_NET_ECK_PANEL_ICON_CLOSE,                             // 禁止
}EM_NET_ECK_PANEL_ICON;

//显示内容
typedef struct tagNET_ECK_PANEL_CONTENT
{
	EM_NET_ECK_PANEL_TYPE        emType;                     // 显示内容的类型,必选
	EM_NET_ECK_PANEL_ISBOLD      emBold;                     // 是否加粗，必选
	EM_NET_ECK_PANEL_COLOR       emColor;                    // 显示颜色，必选
	EM_NET_ECK_PANEL_DIRECTION   emDirection;                // 箭头指向，箭头专用,可选,Type为2时有效
	EM_NET_ECK_PANEL_ICON        emIcon;                     // 图标，图标专用，可选，Type为1时有效
	WORD                         nText;                      // 文本,当前只支持一个字符,限Unicode编码,字符限为:数字、字母、空格（不支持汉字），可选，Type为0时有效
    BYTE                         byReserved[1022];           // 保留字节   
}NET_ECK_PANEL_CONTENT;

//设置诱导屏显示内容(DH_CTRL_ECK_GUIDINGPANEL_CONTENT)
typedef struct tagNET_CTRL_ECK_GUIDINGPANEL_CONTENT 
{
	DWORD                   dwSize;                          // 结构体大小
	int                     nPanelNum;                       // 显示内容数量
	NET_ECK_PANEL_CONTENT   stuContentInfo[NET_MAX_ECK_PANEL_NUM];// 显示内容
}NET_CTRL_ECK_GUIDINGPANEL_CONTENT;


// 智能停车系统出入口机IC卡用户类型
typedef enum tagNET_ECK_IC_CARD_USER_TYPE
{
    NET_ECK_IC_CARD_USER_UNKNOWN,
    NET_ECK_IC_CARD_USER_ALL,                           // 全部类型
    NET_ECK_IC_CARD_USER_TEMP,                          // 临时用户
    NET_ECK_IC_CARD_USER_LONG,                          // 长期用户
    NET_ECK_IC_CARD_USER_ADMIN,                         // 管理员
    NET_ECK_IC_CARD_USER_BLACK_LIST,                    // 黑名单
}NET_ECK_IC_CARD_USER_TYPE;

// 智能停车系统出入口机异常过车记录类型
typedef enum tagNET_ECK_CAR_PASS_FLAG
{
    NET_ECK_CAR_PASS_FLAG_NORMAL = 0,                   // 正常
    NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1,                 // 异常
    NET_ECK_CAR_PASS_FLAG_ALL,                          // 全部
} NET_ECK_CAR_PASS_FLAG;

// 智能停车系统出入口机IC卡信息
typedef struct tagNET_ECK_IC_CARD 
{
    DWORD                   dwSize;
    DWORD                   dwCard;                     // 卡号
    NET_ECK_IC_CARD_USER_TYPE emUserType;               // 用户类型
}NET_ECK_IC_CARD;

#define NET_MAX_ECK_IC_CARD_IMPORT_NUM      50          // 智能停车系统出入口机最大可导入IC卡的数目

// 智能停车系统出入口机IC卡信息导入 参数DH_CTRL_ECK_IC_CARD_IMPORT
typedef struct tagNET_CTRL_ECK_IC_CARD_IMPORT_PARAM
{
    DWORD               dwSize;
    int                 nCardNum;                       // IC卡数量
    NET_ECK_IC_CARD     stuCardInfo[NET_MAX_ECK_IC_CARD_IMPORT_NUM];// IC卡信息
}NET_CTRL_ECK_IC_CARD_IMPORT_PARAM;

// 智能停车系统出入口机IC卡信息同步指令 参数 DH_CTRL_ECK_SYNC_IC_CARD
typedef struct tagNET_CTRL_ECK_SYNC_IC_CARD_PARAM
{
    DWORD               dwSize;
    int                 nCount;                         // 客户端IC卡信息的数量
}NET_CTRL_ECK_SYNC_IC_CARD_PARAM;

#define ECK_SCREEN_NUM_MAX (8)                         // 智能停车系统出入口机最大屏数量

// 智能停车系统出入口机设置车位信息 参数 DH_CTRL_ECK_SET_PARK_INFO
typedef struct tagNET_CTRL_ECK_SET_PARK_INFO_PARAM
{
    DWORD           dwSize;
    int             nScreenNum;                             // 屏数量, 不超过 ECK_SCREEN_NUM_MAX
    int             nScreenIndex[ECK_SCREEN_NUM_MAX];       // 屏号, 每个元素表示屏序号
    int             nFreeParkNum[ECK_SCREEN_NUM_MAX];       // 对应屏管理下的空余车位数
                                                            // 长度和下标与nScreenIndex一致,每个元素表示对应屏号下的空余车位
}NET_CTRL_ECK_SET_PARK_INFO_PARAM;

// 指纹采集(对应DH_CTRL_CAPTURE_FINGER_PRINT命令)
typedef struct tagNET_CTRL_CAPTURE_FINGER_PRINT 
{
    DWORD           dwSize;
    int             nChannelID;                             // 门禁序号(从0开始)
    char            szReaderID[DH_COMMON_STRING_32];        // 读卡器ID
}NET_CTRL_CAPTURE_FINGER_PRINT;

// 门禁控制密码类型
typedef enum tagEM_ACCESS_PASSWORD_TYPE
{
    EM_ACCESS_PASSWORD_OPENDOOR=1,                 // 开门密码
    EM_ACCESS_PASSWORD_ALARM,                      // 防劫持报警密码
}EM_ACCESS_PASSWORD_TYPE;

// 门禁控制-重置密码(对应CLIENT_ControlDevice接口的 DH_CTRL_ACCESS_RESET_PASSWORD 命令)
typedef struct tagNET_CTRL_ACCESS_RESET_PASSWORD 
{
    DWORD                           dwSize;                                 // 结构体大小
    int                             nChannelID;                             // 门禁序号(从0开始)
    EM_ACCESS_PASSWORD_TYPE         emType;                                 // 密码类型
    char                            szUserID[MAX_COMMON_STRING_32];         // 用户ID
    char                            szNewPassword[MAX_COMMON_STRING_32];    // 新密码
}NET_CTRL_ACCESS_RESET_PASSWORD;

// 呼叫电梯命令
typedef enum tagEM_CALLLIFT_CMD
{
    EM_CALLLIFT_CMD_UNKNOWN =-1,         // 未知
    EM_CALLLIFT_CMD_ANY_FLOOR = 0,       // 呼叫电梯到某个楼层，并开放其它任何楼层数
    EM_CALLLIFT_CMD_DEST_FLOOR,          // 呼叫电梯到某个楼层，用户进去后只能按目标楼层
    EM_CALLLIFT_CMD_CARD_UP,             // 呼叫电梯到某个楼层后，还需要刷卡，电梯才能运行, 默认电梯上行
    EM_CALLLIFT_CMD_AUTO_FLOOR,          // 呼叫电梯到某个楼层,用户进去不用按钮，电梯会自动运行到目标楼层
    EM_CALLLIFT_CMD_CARD_DOWN,           // 呼叫电梯到某个楼层后，还需要刷卡，电梯才能运行, 默认电梯下行
}EM_CALLLIFT_CMD;

// 呼叫电梯方式
typedef enum tagEM_CALLLIFT_ACTION
{
    EM_CALLLIFT_ACTION_UNKNOWN =-1,             // 未知
    EM_CALLLIFT_ACTION_USER_UNLOCK_CALL = 0,    // 用户通过对讲分机打开单元门锁，同时呼叫电梯到单元门处
    EM_CALLLIFT_ACTION_USER_DIRECT_CALL,        // 用户呼叫电梯到用户所在楼层
    EM_CALLLIFT_ACTION_USER_REDIRECT_CALL,      // 用户呼叫电梯经由某层到某层
    EM_CALLLIFT_ACTION_DIRECT_UNLOCK_CALL,      // 单元门开锁，同时呼叫电梯到单元门处
}EM_CALLLIFT_ACTION;

// 门禁控制-呼梯(对应CLIENT_ControlDevice接口的 DH_CTRL_ACCESS_CALL_LIFT 命令)
typedef struct tagNET_CTRL_ACCESS_CALL_LIFT
{
    DWORD				    dwSize;
    int                     nChannelID;                         // 通道号
    char                    szSrcFloor[MAX_COMMON_STRING_16];   // 起始地址(楼层+房间号)
    char                    szDestFloor[MAX_COMMON_STRING_16];  // 目标地址(楼层+房间号)
    EM_CALLLIFT_CMD         emCallLiftCmd;                      // 呼叫电梯命令
    EM_CALLLIFT_ACTION      emCallLiftAction;                   // 呼叫电梯的方式  
	char					szUserID[16];						// 用户ID
}NET_CTRL_ACCESS_CALL_LIFT;

// 挂断视频电话(对应 DH_CTRL_VTP_DISCONNECT 命令)
typedef struct tagNET_CTRL_VTP_DISCONNECT 
{
    DWORD                   dwSize;
    const char*             szTargetID;                     // 待转发的设备ID, 为NULL表示不转发
    EM_NET_VTP_CALL_TYPE    emCallType;                     // 呼叫类型
    char                    szCallID[DH_COMMON_STRING_128]; // 对讲唯一标识
}NET_CTRL_VTP_DISCONNECT;

// 对讲客户端响应
typedef enum tagNET_EM_VTP_ACK
{
    NET_EM_VTP_OK,                              // 客户端接收事件,马上呼叫
    NET_EM_VTP_BUSY,                            // 客户端忙,不呼叫
}NET_EM_VTP_ACK;

// 呼叫转发响应
typedef struct tagNET_CTRL_VTP_DIVERTACK
{
    DWORD                   dwSize;
    EM_NET_VTP_CALL_TYPE    emCallType;                     // 待查询的呼叫类型
    const char*             szCallID;                       // 呼叫惟一标识符
    NET_EM_VTP_ACK          emAck;                          // 客户端接受后的响应动作
}NET_CTRL_VTP_DIVERTACK;

// 远程多媒体文件操作方式
typedef enum tagNET_EM_SPEAK_FILE_ACTION
{
    NET_EM_SPEAK_FILE_ACTION_UPDATE = 0,                    // 更新原有文件
    NET_EM_SPEAK_FILE_ACTION_ADD,                           // 新增文件
    NET_EM_SPEAK_FILE_ACTION_DEL,                           // 删除文件
}NET_EM_SPEAK_FILE_ACTION;

// 远程多媒体文件投放操作信息
typedef struct tagNET_SPEAK_FILE_INFO
{
    DWORD                       dwSize;
    char                        szFilePath[MAX_PATH];       // 文件路径, 即预先用CFG_CMD_NASEX配置好的地址
    NET_EM_SPEAK_FILE_ACTION    emAction;                   // 操作类型, 即对szFilePath指定的文件的操作
    BOOL                        bSave;                      // 设备本地是否更新保存该文件
}NET_SPEAK_FILE_INFO;

#define MAX_SPEAK_FILE_NUM      32                          // 远程投放的多媒体文件最大个数

// 远程投放多媒体文件更新
typedef struct tagNET_CTRL_UPDATE_FILES
{
    DWORD                   dwSize;
    DWORD                   dwFileNum;                      // 有效的文件个数
    NET_SPEAK_FILE_INFO     stuFileInfo[MAX_SPEAK_FILE_NUM];// 多媒体文件信息
}NET_CTRL_UPDATE_FILES;

// 雨刷来回刷一次,雨刷模式配置为手动模式时有效(对应命令 DH_CTRL_RAINBRUSH_MOVEONCE)
typedef struct tagNET_CTRL_RAINBRUSH_MOVEONCE
{
    DWORD           dwSize;
    int             nChannel;       // 表示雨刷的索引
}NET_CTRL_RAINBRUSH_MOVEONCE;

// 雨刷来回循环刷,雨刷模式配置为手动模式时有效(对应命令 DH_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
typedef struct tagNET_CTRL_RAINBRUSH_MOVECONTINUOUSLY
{
    DWORD           dwSize;
    int             nChannel;       // 表示雨刷的索引
    unsigned int    nInterval;      // 雨刷间隔
}NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY;

// 雨刷停止刷,雨刷模式配置为手动模式时有效(对应命令 DH_CTRL_RAINBRUSH_STOPMOVE)
typedef struct tagNET_CTRL_RAINBRUSH_STOPMOVE
{
    DWORD           dwSize;
    int             nChannel;       // 表示雨刷的索引
}NET_CTRL_RAINBRUSH_STOPMOVE;

// 报警事件确认(对应 DH_CTRL_ALARM_ACK 命令)
typedef struct tagNET_CTRL_ALARM_ACK
{
    DWORD                   dwSize;
    int                     nEventID;   // 事件编号,用来唯一标志一个事件
}NET_CTRL_ALARM_ACK;

// 对讲请求回复类型
typedef enum tagNET_EM_VTP_INVITEACK_TYPE
{
    NET_EM_VTP_INVITEACK_TYPE_UNKNOWN = 0,               // 未知
    NET_EM_VTP_INVITEACK_TYPE_BUSY                       // 忙类型
}NET_EM_VTP_INVITEACK_TYPE;

// 对讲请求回复
typedef struct tagNET_CTRL_VTP_INVITEACK
{
    DWORD                        dwSize;
    int                          nChnId;                // 通道号,用于标识对讲单元
    NET_EM_VTP_INVITEACK_TYPE    emAck;                 // 客户端收到Invite事件后，将自身状态通知到设备端
}NET_CTRL_VTP_INVITEACK;

////////////////////////////////系统任务订阅//////////////////////////////////////////
// 分区状态
typedef struct __NET_PARTITION_STATE
{
    DWORD             dwSize;
    int               nStatus;                  // 分区状态,0-正常,1-错误 
    double            dbTotalSize;              // 分区总容量,字节为单位
    double            dbRemainSize;             // 剩余容量,字节为单位
    
}NET_PARTITION_STATE;

// 硬盘状态
typedef struct __NET_HDD_STATE
{
    DWORD             dwSize; 
    int               nState;                   // 硬盘状态,0-正常,1-错误   
    double            dbTotalSize;              // 硬盘总容量,字节为单位
    NET_PARTITION_STATE stuPartitions[DH_MAX_STORAGE_PARTITION_NUM]; // 分区状态
    int               nPartitionNum;              // 分区数
}NET_HDD_STATE;

// 通道状态
typedef struct __NET_CHANNLE_STATE
{
    DWORD             dwSize;
    BYTE              byRecState;               // 录像状态,1-录像,0-关闭
    BYTE              byVideoInState;           // 视频输入状态,1-有视频接入,0-无视频  
    BYTE              byReserved[2];            // 字节对齐
}NET_CHANNLE_STATE;

// PAD/DVR连接状态
typedef enum tagNET_PAD_CONNECT_STATE
{
    NET_PAD_CONNECT_STATE_UNKNOWN,             // 未知
    NET_PAD_CONNECT_STATE_UNCONNECTED,         // 未连接
    NET_PAD_CONNECT_STATE_CONNECTED,           // 连接
} NET_PAD_CONNECT_STATE;

// Home键状态
typedef enum tagNET_HOME_STATE
{
    NET_HOME_STATE_UNKNOWN,                    // 未知
    NET_HOME_STATE_UNPRESSED,                  // 未按下
    NET_HOME_STATE_PRESSED,                    // 按下
} NET_HOME_STATE;

// 设备自检信息
typedef struct __NET_SELFCHECK_INFO
{
    DWORD             dwSize;
    int               nAlarmIn;                 // 报警输入通道数
    int               nAlarmOut;                // 报警输出通道数  
    NET_TIME          stuTime;                  // 上报时间
    char              szPlateNo[DH_MAX_PLATE_NUMBER_LEN]; // 车牌
    char              szICCID[DH_MAX_SIM_LEN];  // SIM卡号,建议使用szICCIDExInfo字段
    BYTE              byOrientation;            // 定位状态,0-未定位,1-定位 
    BYTE              byACCState;               // ACC 状态,0-关闭,1-打开
    BYTE              byConstantElecState;      // 常电状态,0-正常连接,1-断开,2-欠压,3-高压
    BYTE              byAntennaState;           // 通信信号状态,0-正常,1-未知故障,2-未接,3-短路
    
    // 外部设备状态
    BYTE              byReportStation;          // 报站器状态,0-未接,1-正常,2-异常
    BYTE              byControlScreen;          // 调度屏状态,0-未接,1-正常,2-异常
    BYTE              byPOS;                    // POS机状态,0-未接,1-正常,2-异常
    BYTE              byCoinBox;                // 投币箱状态,0-未接,1-正常,2-异常
    
    // 能力集
    BOOL              bTimerSnap;               // 定时抓图,TRUE-支持,FALSE-不支持
    BOOL              bElectronEnclosure;       // 电子围栏,TRUE-支持,FALSE-不支持
    BOOL              bTeleUpgrade;             // 远程升级,TRUE-支持,FALSE-不支持   
    
    NET_HDD_STATE     stuHddStates[DH_MAX_DISKNUM]; // 硬盘状态
    int               nHddNum;                  // 硬盘个数
    
    NET_CHANNLE_STATE* pChannleState;           // 通道状态,是一个数组, 
                                                // CLIENT_AttachMission接口,NET_MISSION_TYPE_SELFCHECK类型,回调函数,内存由SDK申请,SDK释放
                                                // CLIENT_GetSelfCheckInfo接口,出参,内存由用户申请,用户释放,大小为sizeof(NET_CHANNLE_STATE)*nChannelMax
    int               nChannleNum;              // 实际上报的通道个数
    int               nChannelMax;              // CLIENT_GetSelfCheckInfo接口,pChannleState内存的最大NET_CHANNLE_STATE个数
    NET_PAD_CONNECT_STATE         emConnState;  // PAD/DVR连接状态
    NET_HOME_STATE                emHomeState;  // Home键状态
	char              szICCIDExInfo[DH_COMMON_STRING_256];  // SIM卡号扩展信息，用于字段扩展使用
	BYTE              by3GState;                // 3G/4G状态, 0-未连接，1-连接，2-模块未找到
	BYTE              byWifiState;              // Wifi状态, 0-未连接，1-连接，2-模块未找到
	BYTE              byGpsState;               // Gps状态, 0-未连接，1-连接，2-模块未找到
	BYTE              byBlackBoxState;          // BlackBox状态, 0-未接，1-正常
	int               nCpuUsage;                // CPU使用百分比, 单位%
	int               nTemperature;             // 设备内部温度, 摄氏度
}NET_SELFCHECK_INFO;

typedef void (CALLBACK *fMissionInfoCallBack)(LLONG lAttachHandle, DWORD dwType, void* pMissionInfo, void* pReserved, LDWORD dwUserData);

typedef enum EM_MISSION_TYPE
{
    NET_MISSION_TYPE_UNKOWN,                    // 未知
    NET_MISSION_TYPE_SELFCHECK,                 // 设备自检,对应结构体 NET_SELFCHECK_INFO
}EM_MISSION_TYPE;

//CLIENT_AttachMission接口输入参数
typedef struct __NET_IN_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    EM_MISSION_TYPE   emMissionType;            // 任务类型
    fMissionInfoCallBack cbMissionInfofunc;     // 任务信息回调函数
    LDWORD            dwUser;                   // 用户数据 
}NET_IN_ATTACH_MISSION_PARAM;

// CLIENT_DetachMission接口输出参数
typedef struct NET_OUT_ATTACH_MISSION_PARAM
{
    DWORD             dwSize;
    LLONG             lAttachHandle;           // 订阅句柄
}NET_OUT_ATTACH_MISSION_PARAM;

#define MAX_EVENT_TO_CONFIRM_NUM        8       // 最大待确认的事件的个数

// 待确认的事件的信息
typedef struct tagNET_EVENT_INFO_TO_CONFIRM 
{
    DWORD               dwSize;
    DWORD               dwEventType;            // 事件类型, 对应CLIENT_AttachBusState接口的事件类型
    NET_TIME            stuTime;                // 事件时间, UTC制
    LONG                lTime;                  // 事件时间, UTC制, 单位秒
}NET_EVENT_INFO_TO_CONFIRM;

// 车辆紧急报警确认 输入参数
typedef struct tagNET_IN_BUS_CONFIRM_EVENT 
{
    DWORD                       dwSize;
    int                         nEvent;         // 待确认事件的有效数目
    NET_EVENT_INFO_TO_CONFIRM   stuEventInfo[MAX_EVENT_TO_CONFIRM_NUM];// 待确认事件的信息
}NET_IN_BUS_CONFIRM_EVENT;

// 车辆紧急报警确认 输出参数
typedef struct tagNET_OUT_BUS_CONFIRM_EVENT 
{
    DWORD                       dwSize;
}NET_OUT_BUS_CONFIRM_EVENT;

// CLIENT_SetDevicePosition设置设备地址信息输入参数
typedef struct tagNET_IN_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
    char                    szPosition[DH_COMMON_STRING_512];   // 地址信息
}NET_IN_SET_DEVICE_POSITION;

// CLIENT_SetDevicePosition设置设备地址信息输出参数
typedef struct tagNET_OUT_SET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
}NET_OUT_SET_DEVICE_POSITION;

// CLIENT_GetDevicePosition获取设备地址信息输入参数
typedef struct tagNET_IN_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
}NET_IN_GET_DEVICE_POSITION;

// CLIENT_GetDevicePosition获取设备地址信息输出参数
typedef struct tagNET_OUT_GET_DEVICE_POSITION
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
    char                    szPosition[DH_COMMON_STRING_512];   // 地址信息
}NET_OUT_GET_DEVICE_POSITION;

// CLIENT_SnapPictureByEvent输入参数
typedef struct tagNET_IN_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
    int                     nChannel;                           // 视频通道号, 从0开始
    DWORD                   dwEventID;                          // 参考CLIENT_RealLoadPicEx的事件类型
}NET_IN_SNAP_BY_EVENT;

// CLIENT_SnapPictureByEvent输出参数
typedef struct tagNET_OUT_SNAP_BY_EVENT 
{
    DWORD                   dwSize;                             // 本结构体大小, 初始化时必须填写
}NET_OUT_SNAP_BY_EVENT;

// CLIENT_StartQueryLog 输入参数
typedef struct tagNET_IN_START_QUERYLOG
{
    DWORD               dwSize;
} NET_IN_START_QUERYLOG;

// CLIENT_StartQueryLog 输出参数
typedef struct tagNET_OUT_START_QUERYLOG
{
    DWORD               dwSize;
}NET_OUT_START_QUERYLOG;

// 日志详细信息
typedef struct tagNET_LOG_MESSAGE
{
    DWORD               dwSize;
    char                szLogMessage[DH_COMMON_STRING_1024];    // 日志内容
} NET_LOG_MESSAGE;

// 日志信息
typedef struct tagNET_LOG_INFO
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // 时间 
    char                szUserName[DH_COMMON_STRING_32];// 操作者
    char                szLogType[DH_COMMON_STRING_128];// 类型
    NET_LOG_MESSAGE     stuLogMsg;                      // 日志信息
} NET_LOG_INFO;

// CLIENT_QueryNextLog 输入参数
typedef struct tagNET_IN_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nGetCount;      // 需要查询的日志条数
}NET_IN_QUERYNEXTLOG;

// CLIENT_QueryNextLog 输出参数
typedef struct tagNET_OUT_QUERYNEXTLOG
{
    DWORD               dwSize;
    int                 nMaxCount;      // 用户指定分配结构体个数,需大于等于NET_IN_GETNEXTLOG的nGetCount
    NET_LOG_INFO*       pstuLogInfo;    // 返回日志信息,缓存大小由用户指定,大小为nMaxCount*sizeof(NET_LOG_INFO)
    int                 nRetCount;      // 实际返回日志条数
}NET_OUT_QUERYNEXTLOG;

// 异步注册设备回调函数原形(当nError返回11时,保留字段reserved为int类型参数且用于调用CLIENT_StartLoginEx登陆时的端口号)
// 当登入失败时：   nError 的错误码对应的说明参考 CLIENT_Login 中的 error说明
typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// CLIENT_StartLoginEx 输入参数
typedef struct tagNET_IN_STARTLOGINEX 
{
    DWORD               dwSize;
    const char*         szIp;           // 设备ip
    DWORD               dwPort;         // 登陆端口
    const char*         szName;         // 用户名
    const char*         szPwd;          // 密码
    fHaveLogin          cbLogin;        // 登陆结果回调
    LDWORD              dwUser;         // 回调用户参数
}NET_IN_STARTLOGINEX;

// CLIENT_StartLoginEx 输出参数
typedef struct tagNET_OUT_STARTLOGINEX 
{
    DWORD       dwSize;
}NET_OUT_STARTLOGINEX;

// 设备支持的协议类型
typedef enum tagEM_DEV_PROTOCOL_TYPE
{
	EM_DEV_PROTOCOL_UNKNOWN,			// 未知
	EM_DEV_PROTOCOL_V2,					// 私有二代
	EM_DEV_PROTOCOL_V3,					// 私有三代
	EM_DEV_PROTOCOL_ONVIF,				// onvif
	EM_DEV_PROTOCOL_GENERAL,			// general
	EM_DEV_PROTOCOL_GB28181,			// 国标GB28181
	EM_DEV_PROTOCOL_EHOME,				// 海康ehome 协议
	EM_DEV_PROTOCOL_HIKVISION,          // 海康私有协议
	EM_DEV_PROTOCOL_BSCP,				// 蓝星接入协议
} EM_DEV_PROTOCOL_TYPE;

// 视频拼接操作类型
typedef enum tagNET_VIDEOJOIN_OPERATE_TYPE
{
    NET_VIDEOJOIN_GET_STATUS,                   // 获取拼接状态, 对应 NET_IN_VIDEOJOIN_GET_STATUS 和 NET_OUT_VIDEOJOIN_GET_STATUS
	NET_VIDEOJOIN_GET_CALIBRATE_POINTS,			// 获取表定点, 对应 tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS 和 tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
    NET_VIDEOJOIN_CALIBRATE,					// 标定,  对应 NET_IN_VIDEOJOIN_CALIBRATE 和 NET_OUT_VIDEOJOIN_CALIBRATE
}NET_VIDEOJOIN_OPERATE_TYPE;

// 视频拼接状态
typedef enum tagNET_VIDEOJOIN_STATUS
{
    NET_VIDEOJOIN_STATUS_UNKNOWN,               // 未知
    NET_VIDEOJOIN_STATUS_NOTSTART,              // 未开始
    NET_VIDEOJOIN_STATUS_DOING,                 // 进行中
    NET_VIDEOJOIN_STATUS_FINISH,                // 完成
}NET_VIDEOJOIN_STATUS;

// 视频拼接标定模式
typedef enum tagNET_VIDEOJOIN_MODE
{
    NET_VIDEOJOIN_MODE_UNKNOWN,                 // 未知
    NET_VIDEOJOIN_MODE_AUTO,                    // 自动
    NET_VIDEOJOIN_MODE_MANUAL,                  // 手动
}NET_VIDEOJOIN_MODE;

// CLIENT_OperateVideoJoin 输入参数, 对应NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_IN_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_STATUS;

// CLIENT_OperateVideoJoin 输出参数, 对应NET_VIDEOJOIN_GET_STATUS
typedef struct tagNET_OUT_VIDEOJOIN_GET_STATUS
{
    DWORD           dwSize;
    NET_VIDEOJOIN_STATUS emStatus;              // 拼接状态
}NET_OUT_VIDEOJOIN_GET_STATUS;

// 相机标定点对, 表示一对坐标点
typedef struct tagNET_POINT_PAIR 
{
    DH_POINT        stuPoints[POINT_NUM_IN_PAIR];           // 相机标定点
}NET_POINT_PAIR;

// 视频拼接标定点组, 每一组表示两个通道和多个标定点对
typedef struct tagNET_VIDEOJOIN_POINT_GROUP
{
    DWORD           dwSize;
    int             nPointPairNum;                          // 标定点数量
    NET_POINT_PAIR  stuPointPairs[MAX_POINT_PAIR_NUM];      // 标定点
    int             nChannels[CHANNEL_NUM_IN_POINT_GROUP];  // 视频通道号, 通过数据下标来对应,下标0通道对应NET_POINT_PAIR中下标0的点
}NET_VIDEOJOIN_POINT_GROUP;

// CLIENT_OperateVideoJoin 输入参数, 对应NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD           dwSize;
}NET_IN_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin 输出参数, 对应NET_VIDEOJOIN_GET_CALIBRATE_POINTS
typedef struct tagNET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // 标定模式
    int                 nPointGroupNum;                         // 标定点组数量
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // 标定点组, 手动模式下有效
}NET_OUT_VIDEOJOIN_GET_CALIBRATE_POINTS;

// CLIENT_OperateVideoJoin 输入参数, 对应NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_IN_VIDEOJOIN_CALIBRATE
{
    DWORD               dwSize;
    NET_VIDEOJOIN_MODE  emMode;                                 // 标定模式
    int                 nPointGroupNum;                         // 标定点组数量
    NET_VIDEOJOIN_POINT_GROUP stuPointGroups[MAX_POINT_GROUP_NUM]; // 标定点组, 手动模式有效
}NET_IN_VIDEOJOIN_CALIBRATE;

// CLIENT_OperateVideoJoin 输出参数, 对应NET_VIDEOJOIN_CALIBRATE
typedef struct tagNET_OUT_VIDEOJOIN_CALIBRATE
{
    DWORD           dwSize;
}NET_OUT_VIDEOJOIN_CALIBRATE;

// 获取屏内窗口信息输入参数, 对应NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_IN_SPLIT_GET_SCENE 
{
    DWORD               dwSize;
    int                 nChannel;                       // 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
    const char*         pszCompositeID;                 // 融合屏ID
}NET_IN_SPLIT_GET_SCENE;

// 获取屏内窗口信息输出参数, 对应NET_SPLIT_OPERATE_GET_SCENE
typedef struct tagNET_OUT_SPLIT_GET_SCENE 
{
    DWORD               dwSize;
    DH_SPLIT_SCENE      stuScene;                       // 窗口信息
}NET_OUT_SPLIT_GET_SCENE;

// 电视墙轮巡状态
typedef enum tagEM_NET_WM_TOUR_STATUS
{
    EM_NET_WM_TOUR_STATUS_UNKNOWN,              // 未知
        EM_NET_WM_TOUR_STATUS_START,                // 轮巡中
        EM_NET_WM_TOUR_STATUS_STOP,                 // 轮巡停止
} EM_NET_WM_TOUR_STATUS;

// 电视墙预案轮巡状态信息
typedef struct tagNET_WM_TOUR_STATUS_INFO 
{
    DWORD                   dwSize;
    EM_NET_WM_TOUR_STATUS   emStatus;           // 轮巡状态
    DH_MONITORWALL_SCENE    stuScene;           // 预案信息
} NET_WM_TOUR_STATUS_INFO;

// 电视墙预案轮巡状态回调函数原形, lAttachHandle是CLIENT_MonitorWallAttachTour的返回值
typedef void (CALLBACK *fMonitorWallTourStatusCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_WM_TOUR_STATUS_INFO* pstStatus, void* reserved, LDWORD dwUser);

// CLIENT_MonitorWallAttachTour 接口输入参数
typedef struct tagNET_IN_WM_ATTACH_TOUR 
{
    DWORD           dwSize;
    int             nMonitorWallID;             // 电视墙ID
    fMonitorWallTourStatusCallBack cbStatus;    // 轮巡状态回调函数
    LDWORD          dwUser;                     // 轮巡状态回调参数
} NET_IN_WM_ATTACH_TOUR;

// CLIENT_MonitorWallAttachTour 接口输出参数
typedef struct tagNET_OUT_WM_ATTACH_TOUR 
{
    DWORD           dwSize;
} NET_OUT_WM_ATTACH_TOUR;

// CLIENT_SnapManagerConfirmUpload 接口输入参数
typedef struct tagNET_IN_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
    char            szFilePath[DH_COMMON_STRING_256];       // 文件路径,用于唯一标识是哪一个图片
    BOOL            bResult;                                // 图片是否上传完成
}NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD;

// CLIENT_SnapManagerConfirmUpload 接口输出参数
typedef struct tagNET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD
{
    DWORD           dwSize;
}NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD;

// 视频电话状态信息
typedef struct tagNET_VTP_CALL_STATE_INFO 
{
    DWORD                       dwSize;
    char                        szNumber[DH_COMMON_STRING_128]; // 呼叫号码
    char                        szCallID[DH_COMMON_STRING_128]; // 对讲唯一标识
    EM_NET_VTP_CALL_STATE_TYPE  emCallState;                    // 呼叫状态
}NET_VTP_CALL_STATE_INFO;

// 订阅视频电话状态信息回调函数原型
typedef void (CALLBACK *fVTPCallStateCallBack)(LLONG lAttachHandle, NET_VTP_CALL_STATE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// 订阅视频电话状态信息 输入参数
typedef struct tagNET_IN_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
    EM_NET_VTP_CALL_TYPE        emCallType;                     // 待查询的呼叫类型
    fVTPCallStateCallBack       cbCallState;                    // 状态回调函数
    LDWORD                      dwUser;                         // 用户参数
    const char*                 szTargetID;                     // 待转发的设备ID, 为NULL表示不转发
}NET_IN_VTP_CALL_STATE_ATTACH;

// 订阅视频电话状态信息 输出参数
typedef struct tagNET_OUT_VTP_CALL_STATE_ATTACH 
{
    DWORD                       dwSize;
}NET_OUT_VTP_CALL_STATE_ATTACH;


//////////////////////////////////////////////////////////////////////////
// 公交业务相关接口参数
//////////////////////////////////////////////////////////////////////////

// 检查公交线路CLIENT_CheckBusLine()输入参数
typedef struct tagNET_IN_CHECK_BUS_LINE 
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // 线路标示
    char            szDesignation[DH_COMMON_STRING_32];     // 线路番号
    NET_LINE_DIRECTION  emDirection;                        // 线路方向
    int             nSiteCount;                             // 线路总站数
    char            szDirectionName[DH_COMMON_STRING_32];   // 线路方向名称
    char            szVersion[DH_COMMON_STRING_32];         // 线路版本号
}NET_IN_CHECK_BUS_LINE;

// 公交线路是否需要更新状态类型
typedef enum tagNET_BUS_LINE_UPDATE_TYPE
{
    NET_BUS_LINE_UPDATE_UNKNOWN = 0,
    NET_BUS_LINE_UPDATE_UPDATED,                            // 需要更新
    NET_BUS_LINE_UPDATE_NOT_UPDATED,                        // 不需要更新
}NET_BUS_LINE_UPDATE_TYPE;

// 检查公交线路CLIENT_CheckBusLine()输出参数
typedef struct tagNET_OUT_CHECK_BUS_LINE
{
    DWORD           dwSize;
    char            szDeviceID[DH_COMMON_STRING_32];        // 设备ID
    char            szLineID[DH_COMMON_STRING_32];          // 线路标示
    NET_BUS_LINE_UPDATE_TYPE emUpdate;                      // 是否需要更新状态指示
}NET_OUT_CHECK_BUS_LINE;
#define MAX_SITE_GPS_POINT_NUM                      64      // 描述一个公交站点最大GPS点个数

// 公交站点区域形状类型
typedef enum tagNET_SITE_AREA_TYPE
{
    NET_SITE_AREA_ENCLOSURE = 0,                            // 围栏型
    NET_SITE_AREA_CIRCLE,                                   // 圆形
}NET_SITE_AREA_TYPE;

// 对应线路的拐点信息
typedef struct tagNET_FLEXION_INFO
{
	int				nLimitDistance;							// 判断线路偏移的限制距离，单位：米
	int				nPointArrayNum;							// 拐点的个数(用户设置的个数)
	GPS_POINT		stuPoint[MAX_SITE_GPS_POINT_NUM];		// 拐点信息
	BYTE			byReserved[1024];						// 预留字节
}NET_FLEXION_INFO;

// 公交站点信息
typedef struct tagNET_BUS_SITE_INFO
{
    DWORD           dwSize;
    char            szLineID[DH_COMMON_STRING_32];          // 线路标示
    int             nSiteCount;                             // 线路总站数
    NET_LINE_DIRECTION  emDirection;                        // 线路方向,不能填成NET_LINE_DIRECTION_UNKNOWN
    int             nStopSequence;                          // 站点序号
    char            szSiteID[DH_COMMON_STRING_32];          // 站点ID
    char            szSiteName[DH_COMMON_STRING_32];        // 站点名称
    NET_SITE_AREA_TYPE emAreaType;                          // 站点区域类型
    int             nGPSPointNum;                           // 有效GPS点数
    GPS_POINT       stuPoint[MAX_SITE_GPS_POINT_NUM];       // 站点GPS信息
    int             nRadius;                                // 站点半径, 单位: 米, 仅圆形站点有效
    int             nSpeedLimit;                            // 站点限速, 单位: km/H
    int             nDriveTime;                             // 上已站到本站时间, 单位:分钟
    int             nTicketPrice;                           // 翻牌票价
    DH_TSECT        stuPowerSchedule[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM]; // 开机时间表, 第一维各元素表示周日~周六和节假日
    char            szDesignation[DH_COMMON_STRING_64];     // 线路番号
    char            szDirectionName[DH_COMMON_STRING_64];   // 线路方向名称
    char            szVersion[DH_COMMON_STRING_32];
    BOOL            bUseExName;                             // 是否使用扩展站点名称
    char            szSiteNameEx[DH_COMMON_STRING_128];     // 站点名称扩展, 长度变大
	NET_FLEXION_INFO stuInflexionInfos;						// 对应线路的拐点信息
}NET_BUS_SITE_INFO;

#define MAX_BUS_STOP_NUM                            32      // 一条公交线路最大站点数目

// 下发公交线路CLIENT_DispatchBusLineInfo()接口输入参数
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
    int             nBusStopNum;                            // 公交线路站点个数
    NET_BUS_SITE_INFO   stuStopInfo[MAX_BUS_STOP_NUM];      // 公交线路信息
}NET_IN_DISPATCH_BUS_LINE_INFO;

// 下发公交线路CLIENT_DispatchBusLineInfo()接口输出参数
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO 
{
    DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO;

// 下发公交线路CLIENT_DispatchBusLineInfoEx()接口输入参数
typedef struct tagNET_IN_DISPATCH_BUS_LINE_INFO_EX 
{
	DWORD				dwSize;
	int					nBusStopNum;                            // 公交线路站点个数
	NET_BUS_SITE_INFO   *pstuStopInfo;							// 公交线路信息,由用户申请内存,大小为sizeof(NET_BUS_SITE_INFO)*nBusStopNum
}NET_IN_DISPATCH_BUS_LINE_INFO_EX;

// 下发公交线路CLIENT_DispatchBusLineInfoEx()接口输出参数
typedef struct tagNET_OUT_DISPATCH_BUS_LINE_INFO_EX 
{
	DWORD           dwSize;
}NET_OUT_DISPATCH_BUS_LINE_INFO_EX;

// 车辆运营调度CLIENT_BusSchedule()接口输入参数
typedef struct tagNET_IN_BUS_SCHEDULE_INFO 
{
    DWORD               dwSize;
    char                szLineID[DH_COMMON_STRING_64];      // 运营线路标识
    NET_LINE_DIRECTION  emDirection;                        // 运营线路方向
    NET_TIME_EX         stuStartTime;                       // 发车时间
}NET_IN_BUS_SCHEDULE_INFO;

// 车辆运营调度CLIENT_BusSchedule()接口输出参数
typedef struct tagNET_OUT_BUS_SCHEDULE_INFO 
{
    DWORD           dwSize;
}NET_OUT_BUS_SCHEDULE_INFO;

// 车辆排班计划信息
typedef struct tagNET_BUS_WORK_PLAN 
{
    DWORD               dwSize;
    char                szID[DH_COMMON_STRING_32];          // 排班记录唯一标示, 最多16个字符
    NET_TIME_EX         stuTime;                            // 发车时间
    char                szDriverName[DH_COMMON_STRING_64];  // 司机名字
    char                szStartSite[DH_COMMON_STRING_64];   // 始发站名字
    char                szEndSite[DH_COMMON_STRING_64];     // 终点站名字
    BOOL                bRunning;                           // 运营状态, TRUE:运营, FALSE:停运
}NET_BUS_WORK_PLAN;

// 下发车辆排班计划CLIENT_DispatchWorkPlan接口输入参数
typedef struct tagNET_IN_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
    NET_BUS_WORK_PLAN   stuWorkPlan;                        // 车辆排班计划信息
}NET_IN_BUS_DISPATCH_WORK_PLAN;

// 下发车辆排班计划CLIENT_DispatchWorkPlan接口输出参数
typedef struct tagNET_OUT_BUS_DISPATCH_WORK_PLAN 
{
    DWORD               dwSize;
}NET_OUT_BUS_DISPATCH_WORK_PLAN;

// 热成像色彩
typedef enum tagNET_THERMO_COLORIZATION 
{
    NET_THERMO_COLORIZATION_UNKNOWN,                        // 未知
    NET_THERMO_COLORIZATION_WHITE_HOT,                      // 白热
    NET_THERMO_COLORIZATION_BLACK_HOT,                      // 黑热
    NET_THERMO_COLORIZATION_IRONBOW2,                       // 铁虹2
    NET_THERMO_COLORIZATION_ICEFIRE,                        // 冰火
	NET_THERMO_COLORIZATION_FUSION,                         // 融合
	NET_THERMO_COLORIZATION_RAINBOW,                        // 彩虹
	NET_THERMO_COLORIZATION_GLOBOW,                         // 
	NET_THERMO_COLORIZATION_IRONBOW1,                       // 铁虹1
	NET_THERMO_COLORIZATION_SEPIA,                          // 深褐
	NET_THERMO_COLORIZATION_COLOR1,                         // 彩色1
	NET_THERMO_COLORIZATION_COLOR2,                         // 彩色2
	NET_THERMO_COLORIZATION_RAIN,                           // 雨天
	NET_THERMO_COLORIZATION_RED_HOT,                        // 红热
	NET_THERMO_COLORIZATION_GREEN_HOT,                      // 绿热
} NET_THERMO_COLORIZATION;

// 热成像感兴趣区域模式
typedef enum tagNET_THERMO_ROI 
{
    NET_THERMO_ROI_UNKNOWN,                                 // 未知
    NET_THERMO_ROI_FULL_SCREEN,                             // 全屏
    NET_THERMO_ROI_SKY,                                     // 顶部
    NET_THERMO_ROI_GROUND,                                  // 中部
    NET_THERMO_ROI_HORIZONTAL,                              // 底部
    NET_THERMO_ROI_CENTER_75,                               // 中心点 75%
    NET_THERMO_ROI_CENTER_50,                               // 中心点 50%
    NET_THERMO_ROI_CENTER_25,                               // 中心点 25%
    NET_THERMO_ROI_CUSTOM,                                  // 自定义
} NET_THERMO_ROI;

// 热成像模式
typedef enum tagNET_THERMO_MODE 
{
    NET_THERMO_MODE_UNKNOWN,                                // 未知
    NET_THERMO_MODE_DEFAULT,                                // 默认
    NET_THERMO_MODE_INDOOR,                                 // 室内
    NET_THERMO_MODE_OUTDOOR,                                // 室外
} NET_THERMO_MODE;

// 热成像优化区域
typedef struct tagNET_THERMO_GRAPHY_OPT_REGION 
{
    BOOL                bOptimizedRegion;                   // 是否开启优化区域
    int                 nOptimizedROIType;                  // 优化区域类型,见NET_THERMO_ROI
    int                 nCustomRegion;                      // 自定义区域个数
    NET_RECT            stCustomRegions[64];                // 自定义区域,仅在 nOptimizedROIType 为 NET_THERMO_ROI_CUSTOM 时有效
    char                Reserved[256];
} NET_THERMO_GRAPHY_OPTREGION;

// 热成像信息
typedef struct tagNET_THERMO_GRAPHY_INFO 
{
    int                         nBrightness;                // 亮度
    int                         nSharpness;                 // 锐度
    int                         nEZoom;                     // 倍数
    int                         nThermographyGamma;         // 伽马值
    int                         nColorization;              // 色彩,见NET_THERMO_COLORIZATION
    int                         nSmartOptimizer;            // 优化指数
    NET_THERMO_GRAPHY_OPTREGION stOptRegion;                // 优化区域
    int                         nAgc;                       // 自动增益控制
    int                         nAgcMaxGain;                // 最大自动增益
    int                         nAgcPlateau;                // 增益均衡
    char                        reserved[244];
} NET_THERMO_GRAPHY_INFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_PRESET 命令入参
typedef struct tagNET_IN_THERMO_GET_PRESETINFO 
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
    NET_THERMO_MODE     emMode;                             // 模式
} NET_IN_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_PRESET 命令出参
typedef struct tagNET_OUT_THERMO_GET_PRESETINFO 
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_INFO      stInfo;                     // 热成像信息
} NET_OUT_THERMO_GET_PRESETINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO 命令入参
typedef struct tagNET_IN_THERMO_GET_EXTSYSINFO
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
} NET_IN_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_LINKCHANNELS 命令入参
typedef struct tagNET_IN_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nChannel;	                        // 通道号,查询该视频通道号是否有关联的视频通道
} NET_IN_GET_LINKCHANNELS;

#define NET_LINKCHANNEL_MAX     512                         // 最大关联的视频通道个数
#define NET_LINKGROUP_MAX       64                          // 最大关联的视频通道组个数

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_LINKCHANNELS 命令出参
typedef struct tagNET_OUT_GET_LINKCHANNELS
{	
    DWORD               dwSize;
    int                 nLinkedCnt;                         // 关联的视频通道号个数
    int                 nLinked[NET_LINKCHANNEL_MAX];	    // 关联的视频通道号,包括请求通道号在内
} NET_OUT_GET_LINKCHANNELS;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_ALLLINKCHANNELS 命令入参
typedef struct tagNET_IN_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
} NET_IN_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_ALLLINKCHANNELS 命令出参
typedef struct tagNET_OUT_GET_ALLLINKCHANNELS
{	
    DWORD               dwSize;
    int                 nGroupCnt;                                              // 关联的视频通道组个数
    int                 nLinkedCnt[NET_LINKGROUP_MAX];                          // 每组关联的视频通道号个数
    int                 nLinked[NET_LINKGROUP_MAX][NET_LINKCHANNEL_MAX];	    // 关联的视频通道号,包括请求通道号在内
                                                                                // 第一维表示通道组,第二维表示通道号
                                                                                // 例如,nLinked[1][2] 表示第二个通道组的第三个关联通道
} NET_OUT_GET_ALLLINKCHANNELS;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_CAMERA_STATE 命令入参
typedef struct tagNET_IN_GET_CAMERA_STATEINFO
{
    DWORD               dwSize;
    BOOL                bGetAllFlag;                                // 是否查询所有摄像机状态,若该成员为 TRUE,则 nChannels 成员无需设置
    int                 nValidNum;                                  // 该成员,bGetAllFlag 为 FALSE时有效,表示 nChannels 成员有效个数
    int                 nChannels[DH_MAX_CAMERA_CHANNEL_NUM];       // 该成员,bGetAllFlag 为 FALSE时有效,将需要查询的通道号依次填入
} NET_IN_GET_CAMERA_STATEINFO;

typedef enum tagEM_CAMERA_STATE_TYPE
{
    EM_CAMERA_STATE_TYPE_UNKNOWN,       // 未知
    EM_CAMERA_STATE_TYPE_CONNECTING,    // 正在连接
    EM_CAMERA_STATE_TYPE_CONNECTED,     // 已连接
    EM_CAMERA_STATE_TYPE_UNCONNECT,     // 未连接
    EM_CAMERA_STATE_TYPE_EMPTY,         // 通道未配置,无信息
    EM_CAMERA_STATE_TYPE_DISABLE,       // 通道有配置,但被禁用
}EM_CAMERA_STATE_TYPE;

typedef struct tagNET_CAMERA_STATE_INFO
{
    int                     nChannel;           // 摄像机通道号, -1表示通道号无效
    EM_CAMERA_STATE_TYPE    emConnectionState;  // 连接状态
    char                    szReserved[1024];   // 保留字节
}NET_CAMERA_STATE_INFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_CAMERA_STATE 命令出参
typedef struct tagNET_OUT_GET_CAMERA_STATEINFO 
{
    DWORD                       dwSize;
    int                         nValidNum;              // 查询到的摄像机通道状态有效个数,由sdk返回
    int                         nMaxNum;                // pCameraStateInfo 数组最大个数,由用户填写
    NET_CAMERA_STATE_INFO*      pCameraStateInfo;       // 摄像机通道信息数组,由用户分配,大小为sizeof(NET_CAMERA_STATE_INFO)*nMaxNum
} NET_OUT_GET_CAMERA_STATEINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE 命令入参
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD               dwSize;
    int                 nChannel;                                   // 通道号
    int                 nStreamType;                                // 码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；4：对讲流
} NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE 命令出参
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO
{
    DWORD                       dwSize;
    int                         nValidNum;                                  // 有效音频编码个数
    DHDEV_TALKDECODE_INFO       stuListAudioEncode[MAX_AUDIO_ENCODE_NUM];   // 音频编码列表
} NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO;


// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_COMM_PORT_INFO 命令入参
typedef struct tagNET_IN_GET_COMM_PORT_INFO
{
    DWORD               dwSize;
} NET_IN_GET_COMM_PORT_INFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_COMM_PORT_INFO 命令出参
//串口类型
typedef enum tagEM_COMM_PORT_TYPE_INFO
{
    EM_COMM_PORT_TYPE_UNKNOW = 0    ,
    EM_COMM_PORT_TYPE_RS232         ,
    EM_COMM_PORT_TYPE_RS485         ,
    EM_COMM_PORT_TYPE_RS422         ,
    EM_COMM_PORT_TYPE_RS485_422     ,
}EM_COMM_PORT_TYPE_INFO;

//串口信息
typedef struct  tagNET_COMM_PORT_INFO
{
    EM_COMM_PORT_TYPE_INFO  emCommPortType;     //串口类型
    int                     nCommPortNum;       //串口数量
    BYTE                    bReserved[1024];    //保留字节
}NET_COMM_PORT_INFO;

#define MAX_COMM_PORT_NUM       8
typedef struct tagNET_OUT_GET_COMM_PORT_INFO
{
    DWORD                       dwSize;
    int                         nPortInfosNum;                          //串口信息数
    NET_COMM_PORT_INFO          stCommPortInfos[MAX_COMM_PORT_NUM];     //串口信息
} NET_OUT_GET_COMM_PORT_INFO;

// 外部系统信息
typedef struct tagNET_THERMO_SYSINFO 
{
    char                szSerialNumber[64];                 // 序列号
    char                szSoftwareVersion[64];              // 软件版本
    char                szFirmwareVersion[64];              // 固件版本
    char                szLibVersion[64];                   // 库版本
    char                reserved[256];
} NET_THERMO_SYSINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO 命令出参
typedef struct tagNET_OUT_THERMO_GET_EXTSYSINFO
{
    DWORD                       dwSize;
    NET_THERMO_SYSINFO          stInfo;                     // 外部系统信息
} NET_OUT_THERMO_GET_EXTSYSINFO;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION 命令入参
typedef struct tagNET_IN_THERMO_GET_OPTREGION
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
} NET_IN_THERMO_GET_OPTREGION;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION 命令出参
typedef struct tagNET_OUT_THERMO_GET_OPTREGION
{
    DWORD                       dwSize;
    NET_THERMO_GRAPHY_OPTREGION stInfo;                     // 优化区域信息
} NET_OUT_THERMO_GET_OPTREGION;


// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_VIDEOOUTPUTCHANNELS 命令入参
typedef struct tagNET_IN_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_IN_GET_VIDEOOUTPUTCHANNELS)
} NET_IN_GET_VIDEOOUTPUTCHANNELS;

// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_VIDEOOUTPUTCHANNELS 命令出参
typedef struct tagNET_OUT_GET_VIDEOOUTPUTCHANNELS
{
    DWORD               dwSize;             // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_GET_VIDEOOUTPUTCHANNELS)
    int                 nMaxLocal;          // 最大本地输出通道总数,含主板和可插拔子卡通道
} NET_OUT_GET_VIDEOOUTPUTCHANNELS;


// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_VIDEOINFO 命令入参
typedef struct tagNET_IN_GET_VIDEOINFO
{
    DWORD               dwSize;             // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_IN_GET_VIDEOINFO)
} NET_IN_GET_VIDEOINFO;

// 解码通道状态
typedef enum  tagNET_VIDEOCHANNEL_STATE
{
    NET_VIDEOCHANNEL_STATE_UNKNOWN,        // 未知状态
    NET_VIDEOCHANNEL_STATE_IDLE,           // 空闲
    NET_VIDEOCHANNEL_STATE_PLAY,           // 播放
    NET_VIDEOCHANNEL_STATE_MONITOR,        // 监视
    NET_VIDEOCHANNEL_STATE_TOUR,           // 轮询
} NET_VIDEOCHANNEL_STATE;

// 解码通道信息
typedef struct tagNET_VIDEOCHANNELINFO
{
    BOOL                         bEnable;                // 通道使能状态, 状态为true时,GB28181协议会将这个通道上报服务器
    NET_VIDEOCHANNEL_STATE       emVideoChannelState;    // 解码通道状态
    int                          nNetflow;               // 网络流量(单位：kbps)
    int                          nBitrate;               // 码率(单位：kbps)
    int                          nFrame;                 // 帧率
    CAPTURE_SIZE                 emResolution;           // 分辨率
    BYTE                         byReserved[512];        // 预留字节 
} NET_VIDEOCHANNELINFO;


// CLIENT_QueryDevInfo 接口 NET_QUERY_GET_VIDEOINFO 命令出参
typedef struct tagNET_OUT_GET_VIDEOINFO
{
    DWORD                    dwSize;                // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_GET_VIDEOINFO)
    int                      nVideoInfoNum;         // 用户需要获取的解码通道信息个数,从0开始获取,用户指定
    NET_VIDEOCHANNELINFO*    pNetVideoChannelInfo;  // 解码通道信息列表,用户申请空间,用户申请列表个数和nVideoInfoNum一致,申请内存大小为sizeof(NET_VIDEOCHANNELINFO)*nVideoInfoNum
    int                      nRetVideoInfoNum;      // 返回实际获取到的解码通道信息个数,SDK返回
} NET_OUT_GET_VIDEOINFO;



// CLIENT_ControlDeviceEx 接口 NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER 命令入参
typedef struct tagNET_IN_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
    BOOL                bEnable;                            // 开关shutter,TRUE 开,FALSE 关
} NET_IN_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx 接口 NET_CTRL_DEV_THERMO_GRAPHY_ENSHUTTER 命令出参
typedef struct tagNET_OUT_THERMO_EN_SHUTTER
{
    DWORD               dwSize;
} NET_OUT_THERMO_EN_SHUTTER;

// CLIENT_ControlDeviceEx 接口 DH_CTRL_THERMO_DO_FFC 命令入参
typedef struct tagNET_IN_THERMO_DO_FFC
{
	DWORD               dwSize;							   // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_IN_THERMO_DO_FFC)
	int                 nChannel;                          // 通道号（双目热成像相机填写热成像通道1）;
} NET_IN_THERMO_DO_FFC;

// CLIENT_ControlDeviceEx 接口 DH_CTRL_THERMO_DO_FFC 命令出参
typedef struct tagNET_OUT_THERMO_DO_FFC
{
	DWORD               dwSize;							   // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_THERMO_DO_FFC)
} NET_OUT_THERMO_DO_FFC;

// CLIENT_ControlDeviceEx 接口 DH_CTRL_THERMO_FIX_FOCUS 命令入参（此方法只有在双目相机中才有效）
typedef struct tagNET_IN_THERMO_FIX_FOCUS
{
	DWORD               dwSize;							    // 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_IN_THERMO_FIX_FOCUS)
	int					anLinkVideoChannel[2];              // 定焦关联通道（[0]为可见光通道号0，[1]为热成像通道号1）
	double				dSpeed;								// 聚焦速度,归一化到0~1(热成像通道有效)
} NET_IN_THERMO_FIX_FOCUS;

// CLIENT_ControlDeviceEx 接口 DH_CTRL_THERMO_FIX_FOCUS 命令出参（此方法只有在双目相机中才有效）
typedef struct tagNET_OUT_THERMO_FIX_FOCUS
{
	DWORD               dwSize;								// 用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_THERMO_FIX_FOCUS)
} NET_OUT_THERMO_FIX_FOCUS;

// CLIENT_GetDevCaps 接口 NET_THERMO_GRAPHY_CAPS 命令入参
typedef struct tagNET_IN_THERMO_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
} NET_IN_THERMO_GETCAPS;

// CLIENT_GetDevCaps 接口 NET_THERMO_GRAPHY_CAPS 命令出参
typedef struct tagNET_OUT_THERMO_GETCAPS
{
    DWORD               dwSize;
    DWORD               dwModes;                            // 支持的预置模式掩码
    DWORD               dwColorization;                     // 预置着色模式掩码
    DWORD               dwROIModes;                         // 预置感兴趣区域模式掩码
    RANGE               stBrightness;                       // 亮度相关能力
    RANGE               stSharpness;                        // 锐度相关能力
    RANGE               stEZoom;                            // 倍数相关能力
    RANGE               stThermographyGamma;                // 伽马相关能力
    RANGE               stSmartOptimizer;                   // 优化参数相关能力
	NET_FFCPERIOD_RANGE stFFCPeriod;                        // 平场聚焦校准相关能力
} NET_OUT_THERMO_GETCAPS;

// CLIENT_GetDevCaps 接口 NET_RADIOMETRY_CAPS 命令入参
typedef struct tagNET_IN_RADIOMETRY_GETCAPS
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
} NET_IN_RADIOMETRY_GETCAPS;

// 测温模式的类型
typedef enum tagNET_RADIOMETRY_METERTYPE 
{
    NET_RADIOMETRY_METERTYPE_UNKNOWN,
    NET_RADIOMETRY_METERTYPE_SPOT,                          // 点
    NET_RADIOMETRY_METERTYPE_LINE,                          // 线
    NET_RADIOMETRY_METERTYPE_AREA,                          // 区域
} NET_RADIOMETRY_METERTYPE;

// 点,线,区域总个数能力
typedef struct tagNET_RADIOMETRY_TOTALNUM 
{
    DWORD               dwMaxNum;                           // 最多支持个数
    DWORD               dwMaxSpots;                         // 最多点的个数
    DWORD               dwMaxLines;                         // 最多划线的条数
    DWORD               dwMaxAreas;                         // 最多区域的个数
    char				reserved[32]; 
} NET_RADIOMETRY_TOTALNUM;

// CLIENT_GetDevCaps 接口 NET_RADIOMETRY_CAPS 命令出参
typedef struct tagNET_OUT_RADIOMETRY_GETCAPS
{
    DWORD                       dwSize;
    NET_RADIOMETRY_TOTALNUM     stTotalNum;                 // 点,线,区域总个数能力
    DWORD                       dwMaxPresets;               // 最多测温预置点的个数
    DWORD                       dwMeterType;                // 测温模式的类型掩码,见NET_RADIOMETRY_METERTYPE
    RANGE                       stObjectEmissivity;         // 辐射系数相关能力
    RANGE                       stObjectDistance;           // 距离相关能力
    RANGE                       stReflectedTemperature;     // 反射温度相关能力
    RANGE                       stRelativeHumidity;         // 相对湿度相关能力
    RANGE                       stAtmosphericTemperature;   // 大气温度相关能力
    int                         nStatisticsMinPeriod;       // 测温点统计功能最小存储数据间隔  单位为秒
    float                       fIsothermMaxTemp;           // 色标条最高温度值
    float                       fIsothermMinTemp;           // 色标条最低温度值
} NET_OUT_RADIOMETRY_GETCAPS;

// 测温信息
typedef struct tagNET_RADIOMETRYINFO
{
    int                 nMeterType;                         // 返回测温类型,见NET_RADIOMETRY_METERTYPE
    int                 nTemperUnit;                        // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
    float               fTemperAver;                        // 点的温度或者平均温度   点的时候 只返回此字段
    float               fTemperMax;                         // 最高温度 
    float               fTemperMin;                         // 最低温度 
    float               fTemperMid;                         // 中间温度值    
    float               fTemperStd;                         // 标准方差值
    char                reserved[64];
} NET_RADIOMETRYINFO;

// 获取测温项温度的条件   
typedef struct tagNET_RADIOMETRY_CONDITION
{
    int                 nPresetId;                          // 预置点编号    
    int                 nRuleId;                            // 规则编号 
    int                 nMeterType;                         // 测温项类别,见NET_RADIOMETRY_METERTYPE
    char                szName[64];                         // 测温项的名称,从测温配置规则名字中选取
    int                 nChannel;                           // 通道号
    char                reserved[256];
} NET_RADIOMETRY_CONDITION;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER 命令入参
typedef struct tagNET_IN_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号
    DH_POINT            stCoordinate;                       // 测温点的坐标,坐标值 0~8192
} NET_IN_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER 命令出参
typedef struct tagNET_OUT_RADIOMETRY_GETPOINTTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stPointTempInfo;                    // 获取测温点的参数值
} NET_OUT_RADIOMETRY_GETPOINTTEMPER;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_TEMPER 命令入参
typedef struct tagNET_IN_RADIOMETRY_GETTEMPER
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // 获取测温项温度的条件
} NET_IN_RADIOMETRY_GETTEMPER;

// CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_TEMPER 命令出参
typedef struct tagNET_OUT_RADIOMETRY_GETTEMPER
{
    DWORD               dwSize;
    NET_RADIOMETRYINFO  stTempInfo;                         // 获取测温参数值
} NET_OUT_RADIOMETRY_GETTEMPER;

// CLIENT_ControlDeviceEx 接口 NET_CTRL_DEV_RADIOMETRY_SETOSDMARK 命令入参
typedef struct tagNET_IN_RADIOMETRY_SETOSDMARK
{
    DWORD                       dwSize;
    NET_RADIOMETRY_CONDITION    stCondition;                // 需要设置 osd 的测温项的匹配条件
} NET_IN_RADIOMETRY_SETOSDMARK;

// CLIENT_ControlDeviceEx 接口 NET_CTRL_DEV_RADIOMETRY_SETOSDMARK 命令出参
typedef struct tagNET_OUT_RADIOMETRY_SETOSDMARK
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_SETOSDMARK;

//热成像查询保存周期
typedef enum tagEM_RADIOMETRY_PERIOD
{
	EM_RADIOMETRY_PERIOD_UNKNOWN,			// 未知
    EM_RADIOMETRY_PERIOD_5  = 5,			// 5分钟记录表，默认
	EM_RADIOMETRY_PERIOD_10 = 10,           // 10分钟记录表
	EM_RADIOMETRY_PERIOD_15 = 15,           // 15分钟记录表
	EM_RADIOMETRY_PERIOD_30 = 30,           // 30分钟记录表
}EM_RADIOMETRY_PERIOD;

// CLIENT_StartFind 接口 NET_FIND_RADIOMETRY 命令入参
typedef struct tagNET_IN_RADIOMETRY_STARTFIND
{   
    DWORD                  dwSize;
    NET_TIME               stStartTime;                       // 查询开始时间
    NET_TIME               stEndTime;                         // 查询结束时间
    int                    nMeterType;                        // 查询类别,见枚举NET_RADIOMETRY_METERTYPE
    int                    nChannel;                          // 通道号
    EM_RADIOMETRY_PERIOD   emPeriod;                          // 所查询表的保存周期
} NET_IN_RADIOMETRY_STARTFIND;

// CLIENT_StartFind 接口 NET_FIND_RADIOMETRY 命令出参
typedef struct tagNET_OUT_RADIOMETRY_STARTFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // 取到的查询句柄
    int                 nTotalCount;                       // 符合此次查询条件的结果总条数
} NET_OUT_RADIOMETRY_STARTFIND;

#define NET_RADIOMETRY_DOFIND_MAX 32

// CLIENT_DoFind 接口 NET_FIND_RADIOMETRY 命令入参
typedef struct tagNET_IN_RADIOMETRY_DOFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                      // 查询句柄
    int                 nBeginNumber;                      // 本次查询开始的索引号
    int                 nCount;                            // 本次查询条数,最大为NET_IN_RADIOMETRY_DOFIND_MAX
} NET_IN_RADIOMETRY_DOFIND;

// 返回查询结果
typedef struct tagNET_RADIOMETRY_QUERY
{
    NET_TIME            stTime;                            // 记录时间
    int                 nPresetId;                         // 预置点编号
    int                 nRuleId;                           // 规则编号
    char                szName[64];                        // 查询项名称
	DH_POINT            stCoordinate;                      // 查询测温点坐标(推荐 stCoordinates)
    int                 nChannel;                          // 通道号
    NET_RADIOMETRYINFO  stTemperInfo;                      // 测温信息,目前nTemperMid, nTemperStd 成员无效
	DH_POINT            stCoordinates[8];				   // 查询测温点坐标
	int					nCoordinateNum;					   // 查询温度点坐标返回的个数
	char                reserved[220];
} NET_RADIOMETRY_QUERY;

// CLIENT_DoFind 接口 NET_FIND_RADIOMETRY 命令出参
typedef struct tagNET_OUT_RADIOMETRY_DOFIND
{   
    DWORD                       dwSize;
    int                         nFound;                             // 实际查询到的点数
    NET_RADIOMETRY_QUERY        stInfo[NET_RADIOMETRY_DOFIND_MAX];  // 温度统计信息
} NET_OUT_RADIOMETRY_DOFIND;

// CLIENT_StopFind 接口 NET_FIND_RADIOMETRY 命令入参
typedef struct tagNET_IN_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
    int                 nFinderHanle;                       // 查询句柄
} NET_IN_RADIOMETRY_STOPFIND;

// CLIENT_StopFind 接口 NET_FIND_RADIOMETRY 命令出参
typedef struct tagNET_OUT_RADIOMETRY_STOPFIND
{   
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_STOPFIND;

// 热成像测温点报警结果值类型
typedef enum tagNET_RADIOMETRY_RESULT 
{
    NET_RADIOMETRY_RESULT_UNKNOWN,
    NET_RADIOMETRY_RESULT_VAL,                  // 具体值
    NET_RADIOMETRY_RESULT_MAX,                  // 最大
    NET_RADIOMETRY_RESULT_MIN,                  // 最小
    NET_RADIOMETRY_RESULT_AVR,                  // 平均
    NET_RADIOMETRY_RESULT_STD,                  // 标准
    NET_RADIOMETRY_RESULT_MID,                  // 中间
    NET_RADIOMETRY_RESULT_ISO,                  // ISO
    NET_RADIOMETRY_RESULT_DIFF,                 // 温差
    NET_RADIOMETRY_RESULT_SLOPE,                // 斜率
} NET_RADIOMETRY_RESULT;

// 热成像测温点报警条件
typedef enum tagNET_RADIOMETRY_ALARMCONTION 
{
    NET_RADIOMETRY_ALARMCONTION_UNKNOWN,
    NET_RADIOMETRY_ALARMCONTION_BELOW,          // 小于
    NET_RADIOMETRY_ALARMCONTION_MATCH,          // 等于
    NET_RADIOMETRY_ALARMCONTION_ABOVE,          // 大于
} NET_RADIOMETRY_ALARMCONTION;

// 温度单位
typedef enum tagNET_TEMPERATURE_UNIT
{
    NET_TEMPERATURE_UNIT_UNKNOWN,
    NET_TEMPERATURE_UNIT_CENTIGRADE,                // 摄氏度
    NET_TEMPERATURE_UNIT_FAHRENHEIT,                // 华氏度
} NET_TEMPERATURE_UNIT;

// 热成像测温点温度异常报警
typedef struct tagALARM_HEATIMG_TEMPER_INFO
{
    char                szName[64];                         // 温度异常点名称  从测温规则配置项中选择
    int                 nAlarmId;                           // 报警项编号    
    int                 nResult;                            // 报警结果值 fTemperatureValue 的类型,见枚举 NET_RADIOMETRY_RESULT
    int                 nAlarmContion;                      // 报警条件,见枚举 NET_RADIOMETRY_ALARMCONTION
    float               fTemperatureValue;                  // 报警温度值
    int                 nTemperatureUnit;                   // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
    DH_POINT            stCoordinate;                       // 报警点的坐标   相对坐标体系,取值均为0~8191
    int                 nPresetID;                          // 预置点
    int                 nChannel;                           // 通道号
    int                 nAction;                            // 0:开始 1:停止 -1:无意义
	DH_POLY_POINTS      stuAlarmCoordinates;				// 报警坐标, 其类型可以是点，线或多边形。替换stCoordinate字段  
    char                reserved[156];
} ALARM_HEATIMG_TEMPER_INFO;

// 热成像着火点报警
typedef struct tagALARM_FIREWARNING_INFO
{
    int                 nPresetId;                          // 该字段废弃，请由DH_ALARM_FIREWARNING_INFO事件获取此信息
    int                 nState;                             // 0 - 开始,1 - 结束,-1:无意义
    DH_RECT             stBoundingBox;                      // 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息	
    int                 nTemperatureUnit;                   // 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息
    float               fTemperature;                       // 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息 
    unsigned            nDistance;                          // 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息
	GPS_POINT           stGpsPoint;                         // 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息
    int                 nChannel;                           // 对应视频通道号
	BOOL				bIsLeaveFireDetect;					// 是否属于离岗火点检测项目(TRUE:是 FALSE:不是)   
	char                reserved[248];
} ALARM_FIREWARNING_INFO;

//云台控制坐标单元
typedef struct tagPTZ_POSITION_UNIT
{
	int                  nPositionX;                        // 云台水平方向角度,范围[0,3599]，表示0度到359.9度，度数扩大10倍表示
	int                  nPositionY;                        // 云台垂直方向角度,范围[-1800,1800]，表示-180.0度到+180.0度，度数扩大10倍表示
	int                  nZoom;                             // 云台光圈放大倍率,范围[0,127]，表示最小倍到最大倍的变倍位置
	char                 szReserve[32];                     // 预留32字节
}PTZ_POSITION_UNIT;

//热成像火情报警信息
typedef struct tagNET_FIREWARNING_INFO
{
	int                 nPresetId;                          // 预置点编号	从测温规则配置CFG_RADIOMETRY_RULE_INFO中选择
	NET_RECT            stuBoundingBox;                     // 着火点矩形框	
	int                 nTemperatureUnit;                   // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
	float               fTemperature;                       // 最高点温度值	同帧检测和差分检测提供
	UINT				nDistance;                          // 着火点距离,单位米 0表示无效
	GPS_POINT           stuGpsPoint;                        // 着火点经纬度
	PTZ_POSITION_UNIT   stuPTZPosition;                     // 云台运行信息
	float               fAltitude;                          // 高度(单位：米)
	UINT				nThermoHFOV;						// Uint32 热成像横向视角
	UINT				nThermoVFOV;						// Uint32 热成像纵向视角
	UINT				nFSID;								// Uint32 火情编号ID
	BYTE                reserved[196];
}NET_FIREWARNING_INFO;
// 热成像火情报警信息上报事件
typedef struct tagALARM_FIREWARNING_INFO_DETAIL
{
    int                     nChannel;                                           // 对应视频通道号
    int                     nWarningInfoCount;                                  // 报警信息个数
    NET_FIREWARNING_INFO    stuFireWarningInfo[MAX_FIREWARNING_INFO_NUM];       // 具体报警信息
    BYTE                    reserved[256];
}ALARM_FIREWARNING_INFO_DETAIL;

//热成像人体发热预警事件
typedef struct tagALARM_FACE_OVERHEATING_INFO
{
    int                     nRelativeId;                                        // 人脸图片ID,与 NET_FACE_INFO->nRelativeID相同
    int                     nTemperatureUnit;                                   // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
    float                   fTemperature;                                       // 人脸温度值
    int                     nChannelID;                                         // 视频通道
    BYTE                    reserved[124];                                      
}ALARM_FACE_OVERHEATING_INFO;

// 探测器状态
typedef enum tagEM_SENSOR_ABNORMAL_STATUS
{
    NET_SENSOR_ABNORMAL_STATUS_UNKNOWN,
    NET_SENSOR_ABNORMAL_STATUS_SHORT,                                   // 短路
    NET_SENSOR_ABNORMAL_STATUS_BREAK,                                   // 断路
    NET_SENSOR_ABNORMAL_STATUS_INTRIDED,                                // 被拆开
} EM_SENSOR_ABNORMAL_STATUS;

//事件类型(DH_ALARM_SENSOR_ABNORMAL) 探测器状态异常报警
typedef struct tagALARM_SENSOR_ABNORMAL_INFO
{
    int                                 nAction;                        // 0:开始 1:停止
    int                                 nChannelID;                     // 视频通道号
    NET_TIME_EX                         stuTime;                        // 事件发生的时间
    EM_SENSOR_ABNORMAL_STATUS           emStatus;                       // 探测器状态
    BYTE                                byReserved[128];                // 预留字段 
}ALARM_SENSOR_ABNORMAL_INFO;

// 热图元数据信息
typedef struct tagNET_RADIOMETRY_METADATA
{
    int                 nHeight;                            // 高
    int                 nWidth;                             // 宽
    int                 nChannel;                           // 通道
    NET_TIME            stTime;                             // 获取数据时间
    int                 nLength;                            // 数据大小
    char                szSensorType[64];                   // 机芯类型
    int                 nUnzipParamR;                       // 解压缩参数R
    int                 nUnzipParamB;                       // 解压缩参数B
    int                 nUnzipParamF;                       // 解压缩参数F
    int                 nUnzipParamO;                       // 解压缩参数O
    char                Reserved[256];
} NET_RADIOMETRY_METADATA;

// 热图数据
typedef struct tagNET_RADIOMETRY_DATA
{
    NET_RADIOMETRY_METADATA     stMetaData;                 // 元数据
    BYTE*                       pbDataBuf;                  // 热图数据缓冲区（压缩过的数据,里面是每个像素点的温度数据,可以使用元数据信息解压）
    DWORD                       dwBufSize;                  // 热图数据缓冲区大小
    char                        reserved[512];
} NET_RADIOMETRY_DATA;

//////////////////////////////////////////////////////////////////////////
/// \fn 温度分布数据状态回调函数
/// \brief 
/// \param  LLONG lAttachHandle [OUT] 订阅句柄, CLIENT_RadiometryAttach 的返回值 
/// \param  NET_RADIOMETRY_DATA* pBuf [OUT] 热图数据信息
/// \param  int nBufLen [OUT] 状态信息长度
/// \param  LDWORD dwUser 用户数据
/// \return 无
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachCB)(LLONG lAttachHandle, NET_RADIOMETRY_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttach 入参
typedef struct tagNET_IN_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
    int                 nChannel;                           // 视频通道号	-1 表示全部
    fRadiometryAttachCB cbNotify;                           // 状态回调函数指针
    LDWORD              dwUser;                             // 用户数据
} NET_IN_RADIOMETRY_ATTACH;

// CLIENT_RadiometryAttach 出参
typedef struct tagNET_OUT_RADIOMETRY_ATTACH
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_ATTACH;

// 订阅温度分布数据（热图）,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttach(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH* pInParam, NET_OUT_RADIOMETRY_ATTACH* pOutParam, int nWaitTime);

// 取消订阅温度分布数据,lAttachHandle是 CLIENT_RadiometryAttach 的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetach(LLONG lAttachHandle);

// CLIENT_RadiometryFetch 入参
typedef struct tagNET_IN_RADIOMETRY_FETCH
{
    DWORD               dwSize;
    int                 nChannel;                           // 通道号, 通道号要与订阅时一致, -1除外
} NET_IN_RADIOMETRY_FETCH;

// CLIENT_RadiometryFetch 出参
typedef struct tagNET_OUT_RADIOMETRY_FETCH 
{
    DWORD               dwSize;
    int                 nStatus;                            // 0: 未知, 1: 空闲, 2: 获取热图中
} NET_OUT_RADIOMETRY_FETCH;

// 通知开始获取热图数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryFetch(LLONG lLoginID, const NET_IN_RADIOMETRY_FETCH* pInParam, NET_OUT_RADIOMETRY_FETCH* pOutParam, int nWaitTime);

// CLIENT_GetHeatMapsDirectly 入参
typedef struct tagNET_IN_GET_HEATMAPS_INFO
{
    DWORD                       dwSize;
    int                         nChannel;                           // 通道号
} NET_IN_GET_HEATMAPS_INFO;

// CLIENT_GetHeatMapsDirectly 出参
typedef struct tagNET_OUT_GET_HEATMAPS_INFO 
{
    DWORD                       dwSize;
    NET_RADIOMETRY_METADATA     stMetaData;                 // 元数据
    DWORD				        dwMaxDataBufLen;			// 热图数据缓存区 pbDataBuf 的大小, 由用户指定
    BYTE				        *pbDataBuf;					// 热图数据缓冲区(压缩过的数据,里面是每个像素点的温度数据,可以使用元数据信息解压),需要用户分配空间
    DWORD				        dwRetDataBufLen;			// 缓存区中返回的实际文件数据大小
	BYTE              	        byReserved[4];            	// 字节对齐
} NET_OUT_GET_HEATMAPS_INFO;

CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetHeatMapsDirectly(LLONG lLoginID, const NET_IN_GET_HEATMAPS_INFO* pInParam, NET_OUT_GET_HEATMAPS_INFO* pOutParam, int nWaitTime);


// 热图数据解压与转换接口
/// \brief 
/// \param  pRadiometryData [IN] 热图数据， 由 fRadiometryAttachCB 获得
/// \param  pGrayImg [IN, OUT] 解压后的数据，是一张灰度图，
///			传空指针表示不需要此数据
///         用户需保证传入的缓冲区足够大（不小于 图像像素数*sizeof(unsigned short)）
///         每个像素对应一个 unsigned short 型数据，表示图像某个像素的热成像灰度（范围 0 ~ 16383），
///         低地址对应画面左上角，高地址对应画面右下角
/// \param  pTempForPixels [IN, OUT] 每个像素的温度数据
///			不能传空指针,否则,返回失败
///         用户需保证传入的缓冲区足够大（不小于 图像像素数*sizeof(float)）
///         每个像素对应一个 float 型数据，表示该像素位置的摄氏温度
///         低地址对应画面左上角，高地址对应画面右下角
/// \return TRUE 成功，FALSE 失败
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDataParse(const NET_RADIOMETRY_DATA* pRadiometryData, unsigned short* pGrayImg, float* pTempForPixels);

// CLIENT_GetRadiometryYImage 入参
typedef struct tagNET_IN_RADIOMETRY_Y_IMAGE
{
    DWORD                       dwSize;
    int                         nChannel;                               // 通道号
}NET_IN_RADIOMETRY_Y_IMAGE;

// CLIENT_GetRadiometryYImage 出参
typedef struct tagNET_OUT_RADIOMETRY_Y_IMAGE
{   
    DWORD                       dwSize; 
    UINT                        nWidth;                                 // 图像宽
    double                      PTS;                                    // 时间戳(单位是毫秒)
    UINT                        nHeight;                                // 图像高
    char*                       pbDataBuf;                              // Y数据缓冲区（用户申请内存，大小为Buflen）
    int                         nBufLen;                                // pbDataBuf最大长度
    int                         nBufRet;                                // 实际返回的长度
}NET_OUT_RADIOMETRY_Y_IMAGE;

// 获取热成像设备的当前Y数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRadiometryYImage(LLONG lLoginID, const NET_IN_RADIOMETRY_Y_IMAGE* pInParam, NET_OUT_RADIOMETRY_Y_IMAGE* pOutParam,int nWaitTime);

// CLIENT_GetRadiometryCurrentHotColdSpotInfo 入参
typedef struct tagNET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	DWORD					dwSize;
	int						nChannel;			// 通道号：只有热成像通道有效
} NET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// 冷（最低温）、热（最高温）点信息
typedef struct tagNET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	NET_POINT				stuHotPoint;		// 热点坐标，范围：【0~8191】
	NET_POINT				stuColdPoint;		// 冷点坐标，范围：【0~8191】
	float					fHotSpotValue;		// 热点温度值（最高温）
	float					fColdSpotValue;		// 冷点温度值（最低温度）
	int						nTemperatrueUnit;	// 温度单位，0:摄氏度 1：华氏度
	BYTE					byReserved[256];	// 保留字节
} NET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// CLIENT_GetRadiometryCurrentHotColdSpotInfo 出参
typedef struct	tagNET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO
{
	DWORD										dwSize;
	NET_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO		stuCurrentHotColdSpotInfo;	// 热成像当前冷（最低温）、热（最高温）点信息
} NET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO;

// 获取热成像当前冷（最低温）、热（最高温）点信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryGetCurrentHotColdSpotInfo(LLONG lLoginID, const NET_IN_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO* pInParam, NET_OUT_RADIOMETRY_CURRENTHOTCOLDSPOT_INFO* pOutParam, int nWaitTime);

#define MAX_RADIOMETRY_TEMPER_NUM  32          // 最大温度统计信息个数
#define MAX_COORDINATE_NUM  8                  // 最大坐标点个数

// 测温查询类型
typedef enum tagEM_RADIOMETRY_QUERY_TYPE 
{
    EM_RADIOMETRY_QUERY_TYPE_UNKNOWN,                       // 未知
    EM_RADIOMETRY_QUERY_TYPE_SPOT,                          // 点
    EM_RADIOMETRY_QUERY_TYPE_AREA,                          // 区域
    EM_RADIOMETRY_QUERY_TYPE_LINE,                          // 线
} EM_RADIOMETRY_QUERY_TYPE;

// 温度信息
typedef struct tagNET_QUERY_TEMPER_INFO
{
    float               fTemperAve;                         // 平均温度
    float               fTemperMax;                         // 最高温度 
    float               fTemperMin;                         // 最低温度 
    BYTE                byReserved[128];                    // 保留字节
} NET_QUERY_TEMPER_INFO;

// 测温查询结果信息
typedef struct tagNET_RADIOMETRY_QUERY_INFO
{
    NET_TIME                     stuTime;                            // 记录时间
    int                          nPresetId;                          // 预置点编号
    int                          nRuleId;                            // 规则编号
    EM_RADIOMETRY_QUERY_TYPE     emQueryType;                        // 查询类型
    char                         szName[MAX_COMMON_STRING_64];       // 查询项名称
    NET_POINT                    stuCoordinate[MAX_COORDINATE_NUM];  // 查询测温点坐标
    int                          nChannel;                           // 通道号
    NET_TEMPERATURE_UNIT         emTemperatureUnit;                  // 温度单位
    NET_QUERY_TEMPER_INFO        stuQueryTemperInfo;                 // 温度信息
    BYTE                         byReserved[256];                    // 保留字节
} NET_RADIOMETRY_QUERY_INFO;

// 测温温度数据
typedef struct tagNET_RADIOMETRY_TEMPER_DATA
{
    int                         nRadiometryTemperNum;                                         // 测温温度信息个数
    NET_RADIOMETRY_QUERY_INFO   stuRadiometryTemperInfo[MAX_RADIOMETRY_TEMPER_NUM];           // 测温温度信息
    BYTE                        byReserved[512];                                              // 保留字节
} NET_RADIOMETRY_TEMPER_DATA;
//////////////////////////////////////////////////////////////////////////
/// \fn 测温温度数据状态回调函数
/// \brief 
/// \param  LLONG lAttachTemperHandle [OUT] 订阅句柄, CLIENT_RadiometryAttachTemper 的返回值 
/// \param  NET_RADIOMETRY_TEMPER_DATA* pBuf [OUT] 测温温度数据
/// \param  int nBufLen [OUT] 状态信息长度
/// \param  LDWORD dwUser 用户数据
/// \return 无
///////////////////////////////////////////////////////////////////////////
typedef void (CALLBACK *fRadiometryAttachTemperCB)(LLONG lAttachTemperHandle, NET_RADIOMETRY_TEMPER_DATA* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_RadiometryAttachTemper 入参
typedef struct tagNET_IN_RADIOMETRY_ATTACH_TEMPER
{
    DWORD                        dwSize;                             // 结构体大小
    int                          nChannel;                           // 通道号
    fRadiometryAttachTemperCB    cbNotify;                           // 状态回调函数指针
    LDWORD                       dwUser;                             // 用户数据
} NET_IN_RADIOMETRY_ATTACH_TEMPER;

// CLIENT_RadiometryAttachTemper 出参
typedef struct tagNET_OUT_RADIOMETRY_ATTACH_TEMPER
{
    DWORD               dwSize;
} NET_OUT_RADIOMETRY_ATTACH_TEMPER;

// 订阅测温温度数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RadiometryAttachTemper(LLONG lLoginID, const NET_IN_RADIOMETRY_ATTACH_TEMPER* pInParam, NET_OUT_RADIOMETRY_ATTACH_TEMPER* pOutParam, int nWaitTime);

// 取消订阅测温温度数据,lAttachTemperHandle是 CLIENT_RadiometryAttachTemper 的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadiometryDetachTemper(LLONG lAttachTemperHandle);

//////////////////////////////////////////////////////////////////////////
// 查询流量信息
//////////////////////////////////////////////////////////////////////////

// 获取流量信息（入参）
typedef struct tagNET_IN_SIM_CARD_FLUX_INFO
{	
	DWORD dwSize;                 // 结构体大小
	int nCardIndex;               // sim编号 从0开始
}NET_IN_SIM_CARD_FLUX_INFO;

#define NET_FLUX_RECORD_MAX_NUM 7      // 流量信息记录最大值

// 流量记录结构体
typedef struct tagNET_SIM_CARD_FLUX_RECORD
{
	NET_TIME stuDate;            // 日期
	UINT nDaySendFlux;           // 当日上行流量 Uint32单位：0.1kb
	UINT nDayRecvFlux;           // 当日下行流量 Uint32单位：0.1kb
	BYTE byReserved[512];        // 保留字节

}NET_SIM_CARD_FLUX_RECORD;

// 获取的流量信息（出参）
typedef struct tagNET_OUT_SIM_CARD_FLUX_INFO
{
	DWORD dwSize;                                        // 结构体大小         
	UINT nTotalFlux;                                     // 总的流量=上行流量+下行流量 Uint32单位：0.1kb  
	UINT nSendFlux;                                      // 上行流量 Uint32单位：0.1kb 
	UINT nRecvFlux;                                      // 下行流量 Uint32单位：0.1kb
	NET_TIME stuTime;                                    // 总流量写入时间
	int nRecordNum;                                      // 记录数量 这个值不应该大于 NET_RECORD_MAX_NUM
	NET_SIM_CARD_FLUX_RECORD stuRecord[NET_FLUX_RECORD_MAX_NUM];  // 最近七天的流量记录
	UINT nLastMonthTotalFlux;                                     // 上个月总流量 Uint32单位：0.1kb 

}NET_OUT_SIM_CARD_FLUX_INFO;

// 获取SIM卡流量信息,pNetDataIn与pNetDataOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSimCardFlux(LLONG lLoginID,const NET_IN_SIM_CARD_FLUX_INFO* pNetDataIn,NET_OUT_SIM_CARD_FLUX_INFO* pNetDataOut,int nWaitTime = 1000);

// 设置防护舱门禁工作模式,pNetDataIn与pNetDataOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDoorWorkMode(LLONG lLoginID,const NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataIn,NET_OUT_CTRL_ACCESS_SET_DOOR_WORK_MODE* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 防护舱LED控制,pInParam与pOutParam由用户申请内存,根据emType对应的结构体,进而确定申请内存大小
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlCabinLED(LLONG lLoginID, EM_CABIN_LED_CONTROL_TYPE emType,const void *pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);


#define NET_SELECT_UPDATE_LOCK_MAX_NUM 32               // 升级锁时最多同时指定的个数

// 远程升级智能锁通道信息(入参)
typedef struct tagNET_IN_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;
    int nChannelNum;                                    // 需要选择的智能锁的个数
    int nChannel[NET_SELECT_UPDATE_LOCK_MAX_NUM];       // 智能锁的通道号
}NET_IN_SELECT_UPDATE_LOCK_INFO;

// 远程升级智能锁通道信息(出参)
typedef struct tagNET_OUT_SELECT_UPDATE_LOCK_INFO
{
    DWORD dwSize;   
}NET_OUT_SELECT_UPDATE_LOCK_INFO;

// 根据锁的通道号选择远程智能锁,pNetDataIn与pNetDataOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SelectLockToUpdate(LLONG lLoginID,const NET_IN_SELECT_UPDATE_LOCK_INFO* pNetDataIn,NET_OUT_SELECT_UPDATE_LOCK_INFO* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

typedef enum tagEM_AUTHORITY_SUB_TYPE
{
    EM_AUTHORITY_SUB_TYPE_UNKNOWN,                            // Unknown
    EM_AUTHORITY_SUB_TYPE_SHUT_DOWN,                          // 关闭设备
    EM_AUTHORITY_SUB_TYPE_MONITOR,                            // 实时监视所有通道
    EM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,                // 实时监视通道
    EM_AUTHORITY_SUB_TYPE_REPLAY,                             // 回放所有通道
    EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,                 // 回放通道
    EM_AUTHORITY_SUB_TYPE_BACKUP,                             // 录像文件备份
    EM_AUTHORITY_SUB_TYPE_MHARDISK,                           // 硬盘管理
    EM_AUTHORITY_SUB_TYPE_MPTZ,                               // 云台的X、Y、Z的电机控制，此权限受产品定义的HasPtz控制，如HasPtz为false，此权限无效
    EM_AUTHORITY_SUB_TYPE_ACCOUNT,                            // 用户帐号
    EM_AUTHORITY_SUB_TYPE_QUERY_LOG,                          // 日志查询
    EM_AUTHORITY_SUB_TYPE_DEL_LOG,                            // 删除日志
    EM_AUTHORITY_SUB_TYPE_SYS_UPDATE,                         // 升级系统
    EM_AUTHORITY_SUB_TYPE_AUTO_MAINTAIN,                      // 自动维护
    EM_AUTHORITY_SUB_TYPE_GENERAL_CONF,                       // 普通设置
    EM_AUTHORITY_SUB_TYPE_ENCODE_CONF,                        // 编码设置
    EM_AUTHORITY_SUB_TYPE_RECORD,                             // 录像模式手动、自动设置(RecordMode配置)
    EM_AUTHORITY_SUB_TYPE_RECORD_CONF,                        // 录像参数时间、文件格式等设置(Record配置)
    EM_AUTHORITY_SUB_TYPE_COM_CONF,                           // 串口设置
    EM_AUTHORITY_SUB_TYPE_NET_CONF,                           // 网络设置
    EM_AUTHORITY_SUB_TYPE_ALARM,                              // 报警输出IO配置
    EM_AUTHORITY_SUB_TYPE_ALARM_CONF,                         // 报警设置
    EM_AUTHORITY_SUB_TYPE_VIDEO_CONFIG,                       // 视频动检遮挡丢失
    EM_AUTHORITY_SUB_TYPE_PTZ_CONFIG,                         // 云台设置
    EM_AUTHORITY_SUB_TYPE_OUTPUT_CONFIG,                      // 视频输出配置
    EM_AUTHORITY_SUB_TYPE_VIDEO_INPUT_CONFIG,                 // 视频输入配置
    EM_AUTHORITY_SUB_TYPE_DEFAULT_CONFIG,                     // 恢复默认
    EM_AUTHORITY_SUB_TYPE_BK_CONFIG,                          // 存储新增，导入导出配置
    EM_AUTHORITY_SUB_TYPE_INTELLI_CONFIG,                     // 智能配置
    EM_AUTHORITY_SUB_TYPE_REMOTE_DEVICE,                      // 添加删除远程设备
    EM_AUTHORITY_SUB_TYPE_ATM_POS,                            // 卡口叠加
    EM_AUTHORITY_SUB_TYPE_OFFLINE_LOGINED_USER,               // 踢除用户
    EM_AUTHORITY_SUB_TYPE_AUDIO_AUTH,                         // 存储使用，语音投放
    EM_AUTHORITY_SUB_TYPE_SPOT_SET,                           // 存储使用，视频矩阵
    EM_AUTHORITY_SUB_TYPE_TVSET,                              // 存储使用，TV边距调节
    EM_AUTHORITY_SUB_TYPE_IPSAN,                              // IPSAN管理
    EM_AUTHORITY_SUB_TYPE_CONFIG,                             // 存储使用，含义较模糊，不建议使用
    EM_AUTHORITY_SUB_TYPE_ARMING,                             // 布防
    EM_AUTHORITY_SUB_TYPE_DISARM,                             // 撤防
    EM_AUTHORITY_SUB_TYPE_BYPASS,                             // 旁路（所有通道）
    EM_AUTHORITY_SUB_TYPE_BYPASS_PARTIAL,                     // 旁路（部分通道）
    EM_AUTHORITY_SUB_TYPE_ALARM_BELL,                         // 警号输出
    EM_AUTHORITY_SUB_TYPE_ALARM_CONFIRM_PARTIAL,              // 消警（部分通道）
    EM_AUTHORITY_SUB_TYPE_DEFENCE_CONFIG_PARTIAL,             // 防区配置（部分通道）
    EM_AUTHORITY_SUB_TYPE_ALARM_OUT_PARITAL,                  // 报警输出（部分通道）
    EM_AUTHORITY_SUB_TYPE_TALK,                               // 语音对讲
    EM_AUTHORITY_SUB_TYPE_WIRELESS_CONFIG,                    // 无线网配置
    EM_AUTHORITY_SUB_TYPE_MOBILE_CONFIG,                      // 移动业务配置
    EM_AUTHORITY_SUB_TYPE_AUDIO_DETECT_CONFIG,                // 音频检测配置
    EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL,            // 预览通道

    EM_AUTHORITY_SUB_TYPE_REBOOT,                             // 设备重启
    EM_AUTHORITY_SUB_TYPE_SYS_LENS,                           // 定制化网络机芯没有云台，但需要控制变倍、聚焦、光圈等功能，增加此权限项
    EM_AUTHORITY_SUB_TYPE_RAIN_BRUSH_CONFIG,                  // 雨刷配置
    EM_AUTHORITY_SUB_TYPE_LIGHTING_CONFIG,                    // 灯光配置
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL,                     // 门禁控制（所有通道）
    EM_AUTHORITY_SUB_TYPE_ACCESS_CONTROL_PARTIAL,             // 门禁控制（部分通道）
    EM_AUTHORITY_SUB_TYPE_DECODE_TOUR,                        // 解码轮巡
    EM_AUTHORITY_SUB_TYPE_VIDEO_OUT,                          // 视频输出
    EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL,                    // 云台控制通道
    EM_AUTHORITY_SUB_TYPE_MODIFY_LANGUANGE,                   // 修改语言
    EM_AUTHORITY_SUB_TYPE_MODIFY_VIDEO,                       // 修改视频制式
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_CONTROL,              // 导播控制
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_SCHEDULE,             // 查询课程表
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_SCHEDULE,      // 修改课程表
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_INTELL_PARAM,         // 录播智能参数
    EM_AUTHORITY_SUB_TYPE_CAMERA_PERIPHERAL,                  // 摄像头外设，包含雨刷、风扇、加热器等
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DOWNLOAD_MEDIA_FILE,  // 下载课程录像文件
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_MEDIA_FILE,    // 修改课程录像文件
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_DELETE_MEDIA_FILE,    // 删除课程录像文件
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_USB,        // 备份课程录像文件到设备端的USB上，与Backup不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_BACKUP_TO_FTP,        // 备份课程录像文件到FTP服务器，与Backup不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_EXPORT_ACCONUT,       // 导出用户信息，与Account不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_QUERY_ACCOUNT,        // 查询账户，与Account不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_MODIFY_ACCOUNT,       // 修改账户，与Account不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_RESET_PASSWORD,       // 密码重置，与Account不能同时生效。
    EM_AUTHORITY_SUB_TYPE_COURSE_RECORD_AUTHORITY,            // 权限管理，与Account不能同时生效。
}EM_AUTHORITY_SUB_TYPE;

typedef enum tagEM_AUTHORITY_MAIN_TYPE
{
    EM_AUTHORITY_MAIN_TYPE_UNKNOWN,            // Unknown
    EM_AUTHORITY_MAIN_TYPE_AUTH_USER_MAG,      // 用户管理
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_CFG,       // 系统设置
    EM_AUTHORITY_MAIN_TYPE_AUTH_OFFLINE_USER,  // 屏蔽用户
    EM_AUTHORITY_MAIN_TYPE_AUTH_DF_UD,         // 默认&升级
    EM_AUTHORITY_MAIN_TYPE_AUTH_PTZ_CTR,       // 云台控制
    EM_AUTHORITY_MAIN_TYPE_AUTH_SYS_INFO,      // 系统信息
    EM_AUTHORITY_MAIN_TYPE_AUTH_MANU_CTR,      // 手动控制
    EM_AUTHORITY_MAIN_TYPE_AUTH_BACKUP,        // 文件备份
    EM_AUTHORITY_MAIN_TYPE_AUTH_COLOR_SET,     // 图像颜色
    EM_AUTHORITY_MAIN_TYPE_AUTH_STORE_CFG,     // 存储管理
    EM_AUTHORITY_MAIN_TYPE_AUTH_EVENT_CFG,     // 事件设置
    EM_AUTHORITY_MAIN_TYPE_AUTH_NET_CFG,       // 网络设置
    EM_AUTHORITY_MAIN_TYPE_AUTH_RMT_DEVICE,    // 摄像头相关
    EM_AUTHORITY_MAIN_TYPE_AUTH_DEL_LOG,       // 删除日志
    EM_AUTHORITY_MAIN_TYPE_AUTH_SHUTDOWN,      // 关闭设备
}EM_AUTHORITY_MAIN_TYPE;

#define NET_AUTHORITY_CLASS_MAX_NUM 256      // 用户权限类型最大值

// 权限类型信息
typedef struct tagNET_AUTH_CLASSIFY_INFO
{	   
    EM_AUTHORITY_MAIN_TYPE  emMainAuthority;    // 主权限类型
    EM_AUTHORITY_SUB_TYPE   emSubAuthority;     // 子权限类型
    int                     nChannel;           // 通道号
                                                // emSubAuthority为EM_AUTHORITY_SUB_TYPE_MONITOR_FOR_CHANNEL,EM_AUTHORITY_SUB_TYPE_REPLAY_FOR_CHANNEL,
                                                // EM_AUTHORITY_SUB_TYPE_NET_PREVIEW_FOR_CHANNEL,EM_AUTHORITY_SUB_TYPE_PTZ_FOR_CHANNEL 时此字段有效
                                                //
    BYTE                    byReserved[128];    // 保留字节
}NET_AUTH_CLASSIFY_INFO;

// 获取权限类型信息（入参）
typedef struct tagNET_IN_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
}NET_IN_GET_AUTHORITY_INFO_LIST;

// 获取权限类型信息（出参）
typedef struct tagNET_OUT_GET_AUTHORITY_INFO_LIST
{
    DWORD dwSize;
    int nRetAuthInfoCount;                                          // 返回的权限类型信息个数
    NET_AUTH_CLASSIFY_INFO stuAuthInfo[NET_AUTHORITY_CLASS_MAX_NUM];// 返回的权限类型信息数据

}NET_OUT_GET_AUTHORITY_INFO_LIST;

// 获取权限类型信息列表,pNetDataIn与pNetDataOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAuthClassifyList(LLONG lLoginID,const NET_IN_GET_AUTHORITY_INFO_LIST* pNetDataIn,NET_OUT_GET_AUTHORITY_INFO_LIST* pNetDataOut,int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

//////////////////////////////////////////////////////////////////////////
// 能力信息
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//  查询类型
typedef enum
{
    ABILITY_DYNAMIC_CONNECT = 1,        // 查询动态多连接能力,对应入参类型为BOOL
    ABILITY_WATERMARK_CFG = 17,         // 水印配置能力，对应结构体为DH_WATERMAKE_EN
    ABILITY_WIRELESS_CFG = 18,          // wireless配置能力,对应结构体为DH_WIRELESS_EN
    ABILITY_DEVALL_INFO = 26,           // 设备的能力列表，对应结构体为DH_DEV_ENABLE_INFO
    ABILITY_CARD_QUERY = 0x0100,        // 卡号查询能力，对应结构体为DH_CARD_QUERY_EN
    ABILITY_MULTIPLAY = 0x0101,         // 多画面预览能力,对应结构体为DH_MULTIPLAY_EN
    ABILITY_QUICK_QUERY_CFG = 0x0102,   // 快速查询配置能力，对应结构体为DH_QUICK_QUERY_CFG_EN
    ABILITY_INFRARED = 0x0121,          // 无线报警能力,对应结构体为DH_WIRELESS_ALARM_INFO
    ABILITY_TRIGGER_MODE = 0x0131,      // 报警输出触发方式能力，对应入参类型为int
    ABILITY_DISK_SUBAREA = 0x0141,      // 网络硬盘分区能力，对应结构体为DH_DISK_SUBAREA_EN
    ABILITY_DSP_CFG = 0x0151,           // 查询DSP能力，对应结构体为DH_DSP_CFG
    ABILITY_STREAM_MEDIA = 0x0161,      // 查询SIP,RTSP能力，对应结构体为DH_STREAM_MEDIA_EN
    ABILITY_INTELLI_TRACKER = 0x0171,   // 查询智能跟踪能力，对应结构体为DH_INTELLI_TRACKER_EN
} DH_SYS_ABILITY;

//////////////////////////////////////////////////////////////////////////
//  设备支持功能列表
enum 
{
    EN_FTP = 0,                         // FTP 按位,1：传送录像文件 2：传送抓图文件
    EN_SMTP,                            // SMTP 按位,1：报警传送文本邮件 2：报警传送图片 3:支持健康邮件功能
    EN_NTP,                             // NTP  按位：1：调整系统时间
    EN_AUTO_MAINTAIN,                   // 自动维护 按位：1：重启 2：关闭 3:删除文件
    EN_VIDEO_COVER,                     // 区域遮挡 按位：1：多区域遮挡
    EN_AUTO_REGISTER,                   // 主动注册 按位：1：注册后sdk主动登陆
    EN_DHCP,                            // DHCP 按位：1：DHCP
    EN_UPNP,                            // UPNP 按位：1：UPNP
    EN_COMM_SNIFFER,                    // 串口抓包 按位：1:CommATM
    EN_NET_SNIFFER,                     // 网络抓包 按位： 1：NetSniffer
    EN_BURN,                            // 刻录功能 按位：1：查询刻录状态
    EN_VIDEO_MATRIX,                    // 视频矩阵 按位：1：是否支持视频矩阵 2:是否支持SPOT视频矩阵 3:是否支持HDMI视频矩阵
    EN_AUDIO_DETECT,                    // 音频检测 按位：1：是否支持音频检测
    EN_STORAGE_STATION,                 // 存储位置 按位：1：Ftp服务器(Ips) 2：SMB 3：NFS 4：ISCSI 16：DISK 17：U盘
    EN_IPSSEARCH,                       // IPS存储查询 按位：1：IPS存储查询 
    EN_SNAP,                            // 抓图  按位：1：分辨率2：帧率3：抓图方式4：抓图文件格式5：图画质量
    EN_DEFAULTNIC,                      // 支持默认网卡查询 按位 1：支持
    EN_SHOWQUALITY,                     // CBR模式下显示画质配置项 按位 1:支持
    EN_CONFIG_IMEXPORT,                 // 配置导入导出功能能力 按位 1:支持
    EN_LOG,                             // 是否支持分页方式的日志查询 按位 1：支持
    EN_SCHEDULE,                        // 录像设置的一些能力 按位 1:冗余 2:预录 3:录像时间段
    EN_NETWORK_TYPE,                    // 网络类型按位表示 1:以态网 2:无线局域 3:CDMA/GPRS 4:CDMA/GPRS多网卡配置
    EN_MARK_IMPORTANTRECORD,            // 标识重要录像 按位:1：设置重要录像标识
    EN_ACFCONTROL,                      // 活动帧率控制 按位：1：支持活动帧率控制, 2:支持定时报警类型活动帧率控制(不支持动检),该能力与ACF能力互斥
    EN_MULTIASSIOPTION,                 // 多路辅码流 按位：1：支持三路辅码流, 2:支持辅码流编码压缩格式独立设置
    EN_DAVINCIMODULE,                   // 组件化模块 按位：1,时间表分开处理 2:标准I帧间隔设置
    EN_GPS,                             // GPS功能 按位：1：Gps定位功能,2:GPS重传
    EN_MULTIETHERNET,                   // 支持多网卡查询 按位 1：支持
    EN_LOGIN_ATTRIBUTE,                 // Login属性 按位：1：支持Login属性查询
    EN_RECORD_GENERAL,                  // 录像相关 按位：1,普通录像；2：报警录像；3：动态检测录像；4：本地存储；5：远程存储；6：冗余存储；7：本地紧急存储；8：支持区分主辅码流的远程存储
    EN_JSON_CONFIG,                     // Json格式配置:按位：1支持Json格式, 2: 使用F6的NAS配置, 3: 使用F6的Raid配置, 4：使用F6的MotionDetect配置, 5：完整支持三代配置(V3),通过F6命令访问
    EN_HIDE_FUNCTION,                   // 屏蔽功能：按位：1,屏蔽PTZ云台功能, 2: 屏蔽3G的保活时段功能
    EN_DISK_DAMAGE,                     // 硬盘坏道信息支持能力: 按位：1,硬盘坏道信息查询支持能力
    EN_PLAYBACK_SPEED_CTRL,             // 支持回放网传速度控制:按位:1,支持回放加速
    EN_HOLIDAYSCHEDULE,                 // 支持假期时间段配置:按位:1,支持假期时间段配置
    EN_FETCH_MONEY_TIMEOUT,             // ATM取钱超时
    EN_BACKUP_VIDEO_FORMAT,             // 备份支持的格式,按位：1:DAV, 2:ASF
    EN_QUERY_DISK_TYPE,                 // 支持硬盘类型查询
    EN_CONFIG_DISPLAY_OUTPUT,           // 支持设备显示输出（VGA等）配置,按位: 1:画面分割轮巡配置
    EN_SUBBITRATE_RECORD_CTRL,          // 支持扩展码流录像控制设置, 按位：1-辅码流录像控制设置
    EN_IPV6,                            // 支持IPV6设置, 按位：1-IPV6配置
    EN_SNMP,                            // SNMP（简单网络管理协议）
    EN_QUERY_URL,                       // 支持获取设备URL地址, 按位: 1-查询配置URL地址
    EN_ISCSI,                           // ISCSI（Internet小型计算机系统接口配置）
    EN_RAID,                            // 支持Raid功能
    EN_HARDDISK_INFO,                   // 支持磁盘信息F5查询
    EN_PICINPIC,                        // 支持画中画功能 按位:1,画中画设置; 2,画中画预览、录像存储、查询、下载;3,支持画中画编码配置,同时支持画中画通道查询
    EN_PLAYBACK_SPEED_CTRL_SUPPORT,     // 同 EN_PLAYBACK_SPEED_CTRL ,只为了兼容协议
    EN_LF_XDEV,                         // 支持24、32、64路LF-X系列,标注这类设备特殊的编码能力计算方式
    EN_DSP_ENCODE_CAP,                  // F5 DSP编码能力查询
    EN_MULTICAST,                       // 组播能力查询
    EM_NET_LIMIT,                       // 网络限制能力查询,按位,1-网络发送码流大小限制,2-支持用户操作数据加密,4-支持配置数据加密,8-支持配置数据加密扩展, 16-支持人脸库导入导出加密                      
    EM_COM422,                          // 串口422
    EM_PROTOCAL_FRAMEWORK,              // 是否支持三代协议框架（需要实现listMethod(),listService()）,通过F6命令访问
    EM_WRITE_DISK_OSD,                  // 刻录OSD叠加, 按位, 1-刻录OSD叠加配置
    EM_DYNAMIC_MULTI_CONNECT,           // 动态多连接, 按位, 1-请求视频数据应答
    EM_CLOUDSERVICE,                    // 云服务,按位,1-支持私有云服务
    EM_RECORD_INFO,                     // 录像信息上报, 按位, 1-录像信息主动上报, 2-支持录像帧数查询
    EN_DYNAMIC_REG,                     // 主动注册能力,按位,1-支持动态主动注册, 2-主动注册动态多链接支持SDK发起IP,port填0的请求
    EM_MULTI_PLAYBACK,                  // 多通道预览回放,按为,1-支持多通道预览回放
    EN_ENCODE_CHN,                      // 编码通道, 按位, 1-支持纯音频通道, 2-监视支持音视频分开获取
    EN_SEARCH_RECORD,                   // 录像查询, 按位, 1-支持异步查询录像, 2-支持三代协议查询录像
    EN_UPDATE_MD5,                      // 支持升级文件传输完成后做MD5验证,1-支持MD5验证2-支持三代升级
	EN_PROTOCOL3ToF6,                   // 三代切F6,按位，1-Log日志功能2.DeleteFile 恢复默认配置支持使用configManager.deleteFile协议
	EN_COMPOSECHANNEL,					// 组合通道, 1-远程预览
	EN_PLAYBACK,						// 回放能力，按位 1-录像二次分析回放
};

typedef struct 
{
    DWORD IsFucEnable[512];             // 功能列表能力集,下标对应上述的枚举值,按位表示子功能
} DH_DEV_ENABLE_INFO;

//////////////////////////////////////////////////////////////////////////
//  卡号查询能力结构体
typedef struct 
{
    char        IsCardQueryEnable;
    char        iRev[3];
} DH_CARD_QUERY_EN;

//////////////////////////////////////////////////////////////////////////
//  wireless能力结构体
typedef struct 
{
    char        IsWirelessEnable;
    char        iRev[3];
} DH_WIRELESS_EN;

//////////////////////////////////////////////////////////////////////////
//  图象水印能力结构体
typedef struct 
{
    char        isSupportWM;            // 1 支持；0 不支持
    char        supportWhat;            // 0：文字水印；1：图片水印；2：同时支持文字水印和图片水印
    char        reserved[2];
} DH_WATERMAKE_EN;

//////////////////////////////////////////////////////////////////////////
//  多画面预览能力结构体
typedef struct  
{
    int         nEnable;                // 1 支持；0 不支持
    DWORD       dwMultiPlayMask;        // 多画面预览掩码
    char        reserved[4];            // 保留
} DH_MULTIPLAY_EN;

//////////////////////////////////////////////////////////////////////////
//  无线报警能力结构体
typedef struct  
{
    BOOL        bSupport;               // 是否支持
    int         nAlarmInCount;          // 输入个数
    int         nAlarmOutCount;         // 输出个数
    int         nRemoteAddrCount;       // 遥控器个数
    BYTE        reserved[32];
} DH_WIRELESS_ALARM_INFO;

//////////////////////////////////////////////////////////////////////////
//  网络硬盘分区能力结构体
typedef struct 
{
    BOOL        bSupported;             // 是否支持网络硬盘分区
    int         nSupportNum;            // 支持分区的数目
    BYTE        bReserved[32];          // 保留字节
} DH_DISK_SUBAREA_EN;

//  DSP能力查询,当DSP能力算法标识为2时使用。
typedef struct  
{
    BYTE        bMainFrame[32];         // 以分辨率枚举值(CAPTURE_SIZE)为索引,主码流分辨率对应支持的最大帧率,如果不支持此分辨率,则值为0.
    BYTE        bExtraFrame_1[32];      // 辅码流1,使用同bMainFrame
    BYTE        bReserved[128];         // 预留给辅码流2和3.       
} DH_DSP_CFG_ITEM;

typedef struct  
{
    int         nItemNum;               // DH_DSP_CFG_ITEM的有效个数,等于通道数
    DH_DSP_CFG_ITEM stuDspCfgItem[32];  // 主码流的信息
    BYTE        bReserved[128];         // 保留
} DH_DSP_CFG; 

//////////////////////////////////////////////////////////////////////////
//  快速查询配置能力结构体
typedef struct 
{
    char        IsQuickQueryEnable;     // 1是设备支持配置命令快速返回,请设置配置时间足够长以保证窄带下配置的正常读取。建议设置60S
    char        iRev[3];
} DH_QUICK_QUERY_CFG_EN;

typedef struct  
{
    int         nStreamType;            // 0,无 1,SIP 2,RTSP
    BYTE        bReserved[16];          // 保留
} DH_STREAM_MEDIA_EN;

//智能球跟踪能力查询
typedef struct
{
    char        IsIntelliTrackerEnable;     // 大于0表示具有智能球跟踪能力
    BYTE        bReserved[3];
}DH_INTELLI_TRACKER_EN;

#define NET_MAX_COMPOSITE_CHANNEL       256                 // 组合融合屏的通道最大数量

// 获取融合能力集的输入参数, 对应NET_COMPOSITE_CAPS
typedef struct tagNET_IN_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nChannelCount;                          // 需要融合的窗口数量
    int             nChannels[NET_MAX_COMPOSITE_CHANNEL];   // 需要融合的窗口号列表
    int             nLayoutX;                               // 水平方向窗口数量
    int             nLayoutY;                               // 垂直方向窗口数量
} NET_IN_COMPOSITE_CAPS;

// 获取融合能力集的输出参数, 对应NET_COMPOSITE_CAPS
typedef struct tagNET_OUT_COMPOSITE_CAPS 
{
    DWORD           dwSize;
    int             nSplitModeCount;                        // 支持的分割模式数量
    DH_SPLIT_MODE   emSplitModes[DH_MAX_SPLIT_MODE_NUM];    // 支持的分割模式列表
    int             nMaxFreeWindow;                         // 最大开窗数
} NET_OUT_COMPOSITE_CAPS;

#define MAX_REGISTER_ID_LEN       (256)
#define MAX_APP_ID_LEN            (256)
#define MAX_URL_LEN               (1024)
#define MAX_IOS_CERTIFICATE_LEN   (1024 * 14)
#define MAX_IOS_SECRET_KEY_LEN    (512)
#define MAX_MOBILE_CHANNEL_NUM    (256)

// 平台类型
typedef enum tagEM_MOBILE_SERVER_TYPE
{
    EM_MOBILE_SERVER_TYPE_UNKNOWN,             // 未知
    EM_MOBILE_SERVER_TYPE_APPLE,               // Apple
    EM_MOBILE_SERVER_TYPE_ANDROID,             // Android
    EM_MOBILE_SERVER_TYPE_SDKCLOUD,            // DAHUA_CLOUD
} EM_MOBILE_SERVER_TYPE;

// 推送服务器配置
typedef struct tagNET_PUSH_SERVER_INFO
{
    char                            szAddress[MAX_URL_LEN];                    // 地址
    int                             nPort;                                     // 端口
} NET_PUSH_SERVER_INFO;

// 事件子类型
typedef enum tagEM_EVENT_SUB_CODE
{
    EM_EVENT_SUB_CODE_UNKNOWN = -1,            // 未知
    EM_EVENT_SUB_CODE_LOSS,                    // Loss
    EM_EVENT_SUB_CODE_COVER,                   // Cover
    EM_EVENT_SUB_CODE_FROZEN,                  // Frozen
    EM_EVENT_SUB_CODE_LIGHT,                   // Light
    EM_EVENT_SUB_CODE_DARK,                    // Dark
    EM_EVENT_SUB_CODE_SCENECHANGE,             // SceneChange
} EM_EVENT_SUB_CODE;

// 订阅类型
typedef struct tagNET_SUBSCRIBE_INFO
{
    int                             nCode;                                     // 事件码
    EM_EVENT_SUB_CODE               emSubCode;                                 // 事件子类型, EM_EVENT_SUB_CODE_UNKNOWN为无效
                                                                               // 仅对VideoAbnormalDetection,AlarmLocal等包含多种类型的报警事件有效
    int                             nChnNum;                                   // 订阅的通道数量, 若无通道概念则为0
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];           // 通道号集合
    char                            szNumber[DH_COMMON_STRING_16];             // 订阅"CallNoAnswered "事件时有效
                                                                               // 无应答号码（设备呼叫这些号码,无应答时,将向手机推送消息）
                                                                               // CFG_CMD_MOBILE_PUSH_NOFITY_CFG时有效
    char                            szSound[DH_COMMON_STRING_64];              // 手机端收到此事件时播放需播放的声音文件
    char                            szIndexsExt[DH_COMMON_STRING_32][DH_COMMON_STRING_16];     //通道号集合扩展
} NET_SUBSCRIBE_INFO;

// 推送网关类型
typedef enum tagEM_PUSH_GATEWAY_TYPE
{
    EM_PUSH_GATEWAY_TYPE_UNKNOWN,              // 未知
    EM_PUSH_GATEWAY_TYPE_APPLE_PUSH,           // 苹果推送网关, ApplePush
    EM_PUSH_GATEWAY_TYPE_ANDROID_SDKPUSH,      // 安卓大华推送网关, AndroidDahuaPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_JPUSH,        // 安卓极光推送网关, AndroidJPush
    EM_PUSH_GATEWAY_TYPE_ANDROID_GCM,          // 安卓GCM网关, AndroidGCM
} EM_PUSH_GATEWAY_TYPE;

// 手机push notification配置, 使用RegisterID订阅
typedef struct tagNET_MOBILE_PUSH_NOTIFY
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // 手机向Appple/ Android服务器注册返回的,每次不同
    EM_MOBILE_SERVER_TYPE           emServerType;                              // 平台类型
    int                             nPeriodOfValidity;                         // 有效时间,单位为秒
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android验证服务器地址
    int                             nAuthServerPort;                           // Android验证服务器端口
    char                            szPushServerAddr[MAX_URL_LEN];             // 推送服务器地址(大华代理,末选服务器,供兼容)
                                                                               // 由大华服务器按官方服务器要求,选用最新的加密算法再转发给官方服务器
    int                             nPushServerPort;                           // 推送服务器端口(大华代理)
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // 推送服务器配置, 官方。首选服务器,如果推送失败,再尝试重定向或代理服务器
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // 推送服务器配置(大华重定向,次选服务器)
    char                            szDevName[DH_COMMON_STRING_64];            // 设备别名,手机端设置显示
    char                            szDevID[DH_COMMON_STRING_64];              // 设备标识,手机端设置使用
    char                            szUser[DH_COMMON_STRING_64];               // 登陆用户名
    char                            szPassword[DH_COMMON_STRING_64];           // 密码
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios证书信息,base64之后的字符串,需要采用TLS加密时有效
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios密钥,base64之后字符串
    int                             nSubScribeMax;                             // 最大订阅类型个数, 表示pstuSubscribes的对象数量
    int                             nSubScribeNum;                             // 实际的订阅类型个数, 获取配置有效
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // 订阅类型,由用户申请内存，大小为sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
} NET_MOBILE_PUSH_NOTIFY;

// 删除手机订阅推送信息入参, CLIENT_DelMobilePushNotify
typedef struct tagNET_MOBILE_PUSH_NOTIFY_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // 手机向Appple/ Android服务器注册返回的,每次不同
} NET_MOBILE_PUSH_NOTIFY_DEL;

// 手机push notification配置,  使用RegisterID+AppID订阅
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // 手机向Appple/ Android服务器注册返回的,每次不同
    char                            szAppID[MAX_APP_ID_LEN];                   // 手机每开一个客户端,会产生一个
    EM_MOBILE_SERVER_TYPE           emServerType;                              // 平台类型
    EM_PUSH_GATEWAY_TYPE            emPushGatewayType;                         // 推送网关类型, emServerType为EM_MOBILE_SERVER_TYPE_SDKCLOUD时有效
    int                             nPeriodOfValidity;                         // 有效时间,单位为秒
    char                            szAuthServerAddr[MAX_URL_LEN];             // Android验证服务器地址
    int                             nAuthServerPort;                           // Android验证服务器端口
    char                            szPushServerAddr[MAX_URL_LEN];             // 推送服务器地址(大华代理,末选服务器,供兼容)
                                                                               // 由大华服务器按官方服务器要求,选用最新的加密算法再转发给官方服务器
    int                             nPushServerPort;                           // 推送服务器端口(大华代理)
    char                            szDevName[DH_COMMON_STRING_64];            // 设备别名,手机端设置显示
    char                            szDevID[DH_COMMON_STRING_64];              // 设备标识,手机端设置使用
    char                            szUser[DH_COMMON_STRING_64];               // 登陆用户名
    char                            szPassword[DH_COMMON_STRING_64];           // 密码
    char                            szCertificate[MAX_IOS_CERTIFICATE_LEN];    // ios证书信息,base64之后的字符串,需要采用TLS加密时有效
    char                            szSecretKey[MAX_IOS_SECRET_KEY_LEN];       // ios密钥,base64之后字符串
    int                             nSubScribeMax;                             // 最大订阅类型个数, 表示pstuSubscribes的对象数量
    int                             nSubScribeNum;                             // 实际的订阅类型个数, 获取配置有效
    NET_SUBSCRIBE_INFO             *pstuSubscribes;                            // 订阅类型,由用户申请内存，大小为sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
    NET_PUSH_SERVER_INFO            stuPushServerMain;                         // 推送服务器配置, 官方。首选服务器,如果推送失败,再尝试重定向或代理服务器
    NET_PUSH_SERVER_INFO            stuPushRedirectServer;                     // 推送服务器配置(大华重定向,次选服务器)
} NET_MOBILE_PUSH_NOTIFY_CFG;

// 删除手机订阅推送信息入参, CLIENT_DelMobilePushNotify
typedef struct tagNET_MOBILE_PUSH_NOTIFY_CFG_DEL
{
    DWORD                           dwSize;
    char                            szRegisterID[MAX_REGISTER_ID_LEN];         // 手机向Appple/ Android服务器注册返回的,每次不同
    char                            szAppID[MAX_APP_ID_LEN];                   // 手机每开一个客户端,会产生一个
} NET_MOBILE_PUSH_NOTIFY_CFG_DEL;

// 手机登陆时过滤可选方式,按照类型进行|或操作。
typedef enum tagEM_OPTTYPE_MOBILE_TYPE
{
    OPTTYPE_MOBILE_DEVICE_ATTR    =0x00000001,			// 设备属性
    OPTTYPE_MOBILE_DEVICE_SN      =0x00000002,			// 设备序列号
    OPTTYPE_MOBILE_DISK_INFO      =0x00000004,			// 硬盘信息
    OPTTYPE_MOBILE_DIGITAL_NUM    =0x00000008,			// 数字通道个数
    OPTTYPE_MOBILE_ALARM_IO       =0x00000010,			// 报警输入输出
    OPTTYPE_MOBILE_DEVICE_ABILITY =0x00000020,			// 能力集
	OPTTYPE_MOBILE_STATE_SOFTWARE =0x00001000,			// 查询软件版本信息APP优化
}EM_OPTTYPE_MOBILE_TYPE;

// SDK设置内部优化方案
typedef enum tagEmOptimizeType
{
    EM_OPT_TYPE_DEFAULT         = 0,    // 默认不优化
    EM_OPT_TYPE_MOBILE_V1       = 1,    // 和选项 EM_OPT_TYPE_MOBILE_OPTION冲突，两者只能使用一个，不支持异步登陆优化
	                                    // 手机使用优化,开启后，默认过滤设备属性和硬盘信息.
    EM_OPT_TYPE_P2P_NETPARAM_V1 = 2,    // P2P网络参数设置，pParam 为 NET_PARAM*
	EM_OPT_TYPE_MOBILE_OPTION   = 3,    // 和选项 EM_OPT_TYPE_MOBILE_V1冲突，两者只能使用一个,支持异步登陆优化
	                                    // 手机优化选项, 参数int, 按位从低到高, 传入的值参考枚举类型 EM_OPTTYPE_MOBILE_TYPE
}EM_OPTIMIZE_TYPE;

typedef struct tagNET_IN_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // 结构体大小 , dwSize 需赋值为 sizeof(NET_IN_MOTIONMATCH_PARAM)
    BOOL                  bFileName;                // 文件名是否作为有效的查询条件,若文件名有效,则不用填充文件信息（stRecordInfo）
    char                  szFileName[MAX_PATH];     // 文件名
    NET_RECORDFILE_INFO   stuRecordInfo;            // 文件信息
    int                   nRegionNum;               // 规则检测区域顶点数
    DH_POINT              stuRegion[DH_MAX_DETECT_REGION_NUM];    // 规则检测区域, 横坐标0~21, 纵坐标0~17
} NET_IN_MOTIONMATCH_PARAM;
typedef struct tagNET_TIME_BEGIN_END
{
    NET_TIME              stuBegin;                 // 开始
    NET_TIME              stuEnd;                   // 结束
} NET_TIME_BEGIN_END;
#define NET_SMART_SEARTCH_TIME_SECTION_MAX (128)
typedef struct tagNET_OUT_MOTIONMATCH_PARAM
{
    DWORD                 dwSize;                   // 结构体大小 , dwSize 需赋值为 sizeof(NET_OUT_MOTIONMATCH_PARAM)
    int                   nTimeNum;                 // 查询到的时间段数目
    NET_TIME_BEGIN_END    stuTime[NET_SMART_SEARTCH_TIME_SECTION_MAX];   // 时间段
} NET_OUT_MOTIONMATCH_PARAM;

// CLIENT_SnapPictureToFile接口输入参数
typedef struct tagNET_IN_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    SNAP_PARAMS stuParam;               // 抓图参数, 其中mode字段仅一次性抓图, 不支持定时或持续抓图; 除了车载DVR, 其他设备仅支持每秒一张的抓图频率
    char        szFilePath[MAX_PATH];   // 写入文件的地址
}NET_IN_SNAP_PIC_TO_FILE_PARAM;

// CLIENT_SnapPictureToFile接口输出参数
typedef struct tagNET_OUT_SNAP_PIC_TO_FILE_PARAM 
{
    DWORD       dwSize;
    char*       szPicBuf;               // 图片内容,用户分配内存,大小为dwPicBufLen
    DWORD       dwPicBufLen;            // 图片内容内存大小, 单位:字节
    DWORD       dwPicBufRetLen;         // 返回的图片大小, 单位:字节
}NET_OUT_SNAP_PIC_TO_FILE_PARAM;

//报警事件类型DH_ALARM_BUS_SHARP_TURN(车辆急转事件)对应的数据描述信息
typedef struct tagALARM_BUS_SHARP_TURN_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS信息
} ALARM_BUS_SHARP_TURN_INFO;

//报警事件类型DH_ALARM_BUS_SCRAM(车辆急停事件)对应的数据描述信息
typedef struct tagALARM_BUS_SCRAM_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS信息
} ALARM_BUS_SCRAM_INFO;

//报警事件类型DH_ALARM_BUS_SHARP_ACCELERATE(车辆急加速事件)对应的数据描述信息
typedef struct tagALARM_BUS_SHARP_ACCELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS信息
    NET_TIME_EX			stuTime;				// 事件发生的时间
} ALARM_BUS_SHARP_ACCELERATE_INFO;

//报警事件类型DH_ALARM_BUS_SHARP_DECELERATE(车辆急减速事件)对应的数据描述信息
typedef struct tagALARM_BUS_SHARP_DECELERATE_INFO
{
    DWORD               dwSize;
    NET_GPS_STATUS_INFO stuGPSStatusInfo;       // GPS信息
    NET_TIME_EX			stuTime;				// 事件发生的时间
} ALARM_BUS_SHARP_DECELERATE_INFO;


//门禁卡数据操作类型       
typedef enum tagNET_ACCESS_ACTION_TYPE        
{       
    NET_ACCESS_ACTION_TYPE_UNKNOWN  = 0,    // 未知       
    NET_ACCESS_ACTION_TYPE_INSERT   = 1,    // 插入       
    NET_ACCESS_ACTION_TYPE_UPDATE   = 2,    // 更新       
    NET_ACCESS_ACTION_TYPE_REMOVE   = 3,    // 删除       
}NET_ACCESS_ACTION_TYPE;   
        
//门禁卡数据操作事件       
typedef struct tagALARM_ACCESS_CARD_OPERATE_INFO       
{       
    DWORD                   dwSize;       
    NET_ACCESS_ACTION_TYPE  emActionType;                    // 门禁卡数据操作类型       
    char                    szCardNo[DH_MAX_CARDINFO_LEN];   // 门禁卡卡号       
    NET_THREE_STATUS_BOOL   emResult;                        // 操作结果,-1为未知,0为失败,1为成功,
    int                     nChannelID;                      // 门通道号(或者门锁,门和门锁一一对应), 从0开始
    char                    szCredentialHolder[16];          // 身份拥有者
    NET_ACCESS_METHOD		emType;                          // 用户类型
    char                    szSerialNum[32];                 // 序列号
    int                     nIndex;                          // 某开门方式下的索引号
	int						nTaskID;						 // 任务ID
}ALARM_ACCESS_CARD_OPERATE_INFO;

// 报警事件类型DH_EVENT_TAKENAWAYDETECTION(物品搬移事件)对应的数据描述信息
typedef struct tagALARM_TAKENAWAY_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // 通道号
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    int                 nOccurrenceCount;               // 规则被触发生次数
    int                 nLevel;                         // 事件级别,GB30147需求项, 0 提示1 普通2 警告
	short				nPreserID;						// 事件触发的预置点号，从1开始（没有表示未知）
	char				szPresetName[64];				// 事件触发的预置名称
} ALARM_TAKENAWAY_DETECTION_INFO;

// 报警事件类型 DH_EVENT_VIDEOABNORMALDETECTION (视频异常事件)对应的数据描述信息
typedef struct tagALARM_VIDEOABNORMAL_DETECTION_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // 通道号
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    int                 nType;                          // 检测类型,0-视频丢失, 1-视频遮挡, 2-画面冻结, 3-过亮, 4-过暗, 5-场景变化
                                                        // 6-条纹检测 , 7-噪声检测 , 8-偏色检测 , 9-视频模糊检测 , 10-对比度异常检测
                                                        // 11-视频运动, 12-视频闪烁, 13-视频颜色, 14-虚焦检测, 15-过曝检测
    int                 nValue;                         // 检测值,值越高表示视频质量越差, GB30147定义
    int                 nOccurrenceCount;               // 规则被触发生次数
} ALARM_VIDEOABNORMAL_DETECTION_INFO;

// 报警事件类型DH_EVENT_LOCALALARM(外部报警事件)对应的数据描述信息
typedef struct tagALARM_LOCAL_ALARM_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // 通道号
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

    int                 nSenseType;                     // 传感器类型
    int                 nDefenceAreaType;               // 防区类型, 详见EM_NET_DEFENCE_AREA_TYPE
} ALARM_LOCAL_ALARM_INFO;

// 动检触发类型
typedef enum tagEM_MOTION_DETECT_TYPE
{
	EM_MOTION_DETECT_UNKNOWN,			// 未知
	EM_MOTION_DETECT_HUMAN,				// 人
	EM_MOTION_DETECT_VEHICLE,			// 车
	EM_MOTION_DETECT_HUMAN_AND_VEHICLE,	// 人和车
} EM_MOTION_DETECT_TYPE;

// 动检区域信息
typedef struct tagNET_MOTIONDETECT_REGION_INFO
{
	UINT			nRegionID;					// 区域ID
	char			szRegionName[64];			// 区域名称
	BYTE        	bReserved[508];				// 保留字节
} NET_MOTIONDETECT_REGION_INFO;

// 报警事件类型DH_EVENT_MOTIONDETECT(视频移动侦测事件)对应的数据描述信息
typedef struct tagALARM_MOTIONDETECT_INFO
{
    DWORD               dwSize;    
    int                 nChannelID;                     // 通道号
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	UINT							nRegionNum;			// 动检区域个数
	NET_MOTIONDETECT_REGION_INFO	stuRegion[32];		// 动检区域信息
	BOOL							bSmartMotionEnable;	// 智能动检是否使能
	UINT							nDetectTypeNum;		// 动检触发类型个数
	EM_MOTION_DETECT_TYPE			emDetectType[32];	// 动检触发类型, 当nRegionNum大于0时，和stuRegion数组一一对应, 
														// 若nRegionNum为0，触发区域未知，不与窗口绑定，默认第一个元素表示触发类型
} ALARM_MOTIONDETECT_INFO;

// 智能动检(人)对象信息
typedef struct tagNET_SMARTDETECT_HUMAN_OBJECT
{
	UINT				nHumanID;					// 人动检ID
	NET_RECT			stuRect;					// 人的位置
	BYTE        	    bReserved[508];				// 保留字节
} NET_SMARTDETECT_HUMAN_OBJECT;

// 报警事件类型DH_ALARM_SMARTMOTION_HUMAN(智能视频移动侦测事件(人))对应的数据描述信息
typedef struct tagALARM_SMARTMOTION_HUMAN_INFO
{
    int                 nChannelID;                     // 通道号
    NET_TIME_EX         UTC;                            // 事件发生的时间
    double              PTS;                            // 时间戳(单位是毫秒)
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	NET_MOTIONDETECT_REGION_INFO	stuSmartRegion[32];	// 智能动检区域信息
	UINT							nSmartRegionNum;	// 智能动检区域个数
	UINT							nHumanObjectNum;	// 智能动检(人)对象个数
	NET_SMARTDETECT_HUMAN_OBJECT	stuHumanObject[64];	// 智能动检(人)对象信息
	BYTE        					bReserved[1024];		// 保留字节
} ALARM_SMARTMOTION_HUMAN_INFO;

// 智能动检(车)对象信息
typedef struct tagNET_SMARTDETECT_VEHICLE_OBJECT
{
	UINT				nVehicleID;					// 车动检ID
	NET_RECT			stuRect;					// 车的位置
	BYTE        	    bReserved[508];				// 保留字节
} NET_SMARTDETECT_VEHICLE_OBJECT;

// 报警事件类型DH_ALARM_SMARTMOTION_VEHICLE(智能视频移动侦测事件(车))对应的数据描述信息
typedef struct tagALARM_SMARTMOTION_VEHICLE_INFO
{
    int                 nChannelID;                     	// 通道号
    NET_TIME_EX         UTC;                            	// 事件发生的时间
    double              PTS;                            	// 时间戳(单位是毫秒)
    int                 nEventID;                       	// 事件ID
    int                 nEventAction;                   	// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	NET_MOTIONDETECT_REGION_INFO	stuSmartRegion[32];		// 智能动检区域信息
	UINT							nSmartRegionNum;		// 智能动检区域个数
	UINT							nVehicleObjectNum;		// 智能动检(车)对象个数
	NET_SMARTDETECT_VEHICLE_OBJECT	stuVehicleObject[64];	// 智能动检(车)对象信息
	BYTE        					bReserved[1024];			// 保留字节
} ALARM_SMARTMOTION_VEHICLE_INFO;

// 报警事件类型DH_ALARM_POLICE_CHECK(警员签入签出事件)对应的数据描述信息
typedef struct tagALARM_POLICE_CHECK_INFO
{
    DWORD               dwSize;
    int                 nChannelID;                     // 通道号
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventID;                       // 事件ID
    int                 nEventAction;                   // 事件动作

    char                szId[32];                       // 签到人ID号
    char                szName[32];                     // 签到人姓名,UTF8
    int                 nSignType;                      // 类型, 详情查看NET_DRIVER_CHECK_TYPE
    NET_GPS_STATUS_INFO stuGPSStatusInfo;               // GPS信息
    char                szComment[1024];                // 备注信息
} ALARM_POLICE_CHECK_INFO;

// 报警事件类型DH_ALARM_NEW_FILE(new file事件)对应的数据描述信息
typedef struct tagALARM_NEW_FILE_INFO
{
    DWORD           dwSize;
    int             nChannel;                           // 抓图通道号
    int             nEventID;                           // 事件ID
    DWORD           dwEvent;                            // 事件类型
    int             FileSize;                           // 文件大小,单位是字节
    int             nIndex;                             // 事件源通道
    DWORD           dwStorPoint;                        // 存储点
    char            szFileName[DH_COMMON_STRING_128];   // 文件名
}ALARM_NEW_FILE_INFO;

// 云台诊断状态类型
typedef enum tagEM_PTZ_STATUS_TYPE
{
	EM_PTZ_STATUS_UNKNOW,                    // 未知状态,返回状态值错误
    EM_PTZ_STATUS_NORMAL,                    // 正常
    EM_PTZ_STATUS_PANOC_FAILED,              // 水平光耦异常
    EM_PTZ_STATUS_TILEOC_FAILED,             // 垂直光耦异常
    EM_PTZ_STATUS_OC_FAILED                  // 全部光耦都异常
} EM_PTZ_STATUS_TYPE;


// 云台状态诊断事件信息(对应DH_ALARM_PTZ_DIAGNOSES)
typedef struct tagALARM_PTZ_DIAGNOSES_INFO
{
	int 				nChannel;			// 视频通道号(球机所在的通道号)
	NET_TIME_EX			UTC;				// 事件产生时间
	EM_PTZ_STATUS_TYPE	emPtzStat;			// 云台诊断状态
	BYTE                Reserved[512];      // 保留字节
} ALARM_PTZ_DIAGNOSES_INFO;

// 爆闪灯(闪光灯)报警事件类型 DH_ALARM_FLASH_LIGHT_FAULT
typedef struct tagALARM_FLASH_LIGHT_FAULT_INFO
{
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventAction;                   // 事件动作, 1-表示事件开始, 2-表示事件结束; 
    int                 nLightNum;                      // 闪光灯个数
    int                 nDevID[MAX_FLASH_LIGHT_NUM];    // 故障的闪光灯设备ID
    int                 nLane;                          // 车道号
    BYTE			    bReserved[512];				    // 保留字节
}ALARM_FLASH_LIGHT_FAULT_INFO;

// 频闪灯报警事件类型 DH_ALARM_STROBOSCOPIC_LIGTHT_FAULT
typedef struct tagALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO
{
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    int                 nEventAction;                       // 事件动作, 1-表示事件开始, 2-表示事件结束; 
    int                 nLightNum;                          // 频闪灯个数
    int                 nDevID[MAX_STROBOSCOPIC_LIGHT_NUM]; // 故障的频闪灯设备ID
    int                 nLane;                              // 车道号
    BYTE			    bReserved[512];				        // 保留字节
}ALARM_STROBOSCOPIC_LIGTHT_FAULT_INFO;

// 人数越上限类型
typedef enum tagEM_UPPER_LIMIT_TYPE
{
    EM_UPPER_LIMIT_TYPE_UNKNOWN,                             // 未知
    EM_UPPER_LIMIT_TYPE_ENTER_OVER,                          // 进入越上限
    EM_UPPER_LIMIT_TYPE_EXIT_OVER,                           // 出来越上限
    EM_UPPER_LIMIT_TYPE_INSIDE_OVER,                         // 内部越上限
} EM_UPPER_LIMIT_TYPE;

// 事件类型 DH_ALARM_HUMAM_NUMBER_STATISTIC (人数量/客流量统计事件NumberStat对应的数据描述信息)
typedef struct tagALARM_NUMBER_STATISTIC_INFO 
{
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                            // 事件发生的时间
    int                 nEventAction;                   // 事件动作,0-事件持续, 1-表示事件开始, 2-表示事件结束;
    int                 nNumber;                        // 区域内物体的个数
    int                 nEnteredNumber;                 // 进入区域或者出入口内的物体个数
    int                 nExitedNumber;                  // 出来区域或者出入口内的物体个数
	EM_UPPER_LIMIT_TYPE emUpperLimitType;               // 人数越上限类型(EnterOver, ExitOver, InsideOver)
	int                 nChannelID;                     // 通道号
    BYTE                reserved[508];                  // 预留       
}ALARM_HUMAN_NUMBER_STATISTIC_INFO;

// 事件类型 DH_ALARM_VIDEOUNFOCUS(视频虚焦报警事件)
typedef struct tagALARM_VIDEOUNFOCUS_INFO
{
    int                 nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    int                 nChannel;                       // 通道号
    BYTE                reserved[60];                   // 预留字节
}ALARM_VIDEOUNFOCUS_INFO;

// 防区布防撤防状态类型
typedef enum tagEM_DEFENCEMODE
{
    EM_DEFENCEMODE_UNKNOWN,             // "unknown"   未知
    EM_DEFENCEMODE_ARMING,              // "Arming"    布防
    EM_DEFENCEMODE_DISARMING,           // "Disarming" 撤防
}EM_DEFENCEMODE;

//触发方式
typedef enum tagEM_ARMMODECHANGE_TRIGGERMODE
{
	EM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN,		//未知
	EM_ARMMODECHANGE_TRIGGERMODE_NET,			//网络用户
	EM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD,		//键盘
	EM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL,	//遥控器
}EM_ARMMODECHANGE_TRIGGERMODE;

//防区类型
typedef enum tagEM_ARMMODECHANGE_DEFENCEAREATYPE
{
	EM_ARMMODECHANGE_DEFENCEAREATYPE_UNKNOWN,	//未知
	EM_ARMMODECHANGE_DEFENCEAREATYPE_INTIME,	//及时
	EM_ARMMODECHANGE_DEFENCEAREATYPE_DELAY,		//延时
	EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAY,	//全天
	EM_ARMMODECHANGE_DEFENCEAREATYPE_FOLLOW,	//跟随
	EM_ARMMODECHANGE_DEFENCEAREATYPE_MEDICAL,	//医疗紧急
	EM_ARMMODECHANGE_DEFENCEAREATYPE_PANIC,		//恐慌
	EM_ARMMODECHANGE_DEFENCEAREATYPE_FIRE,		//火警
	EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSOUND,	//全天有声
	EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSILENT,	//全天无声
	EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE1,		//出入防区1
	EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE2,		//出入防区2
	EM_ARMMODECHANGE_DEFENCEAREATYPE_INSIDE,		//内部防区
	EM_ARMMODECHANGE_DEFENCEAREATYPE_OUTSIDE,		//外部防区
	EM_ARMMODECHANGE_DEFENCEAREATYPE_PEOPLEDETECT,	//人员检测
}EM_ARMMODECHANGE_DEFENCEAREATYPE;


// 事件类型 DH_ALARM_DEFENCE_ARMMODECHANGE (防区布撤防状态改变事件)
typedef struct tagALARM_DEFENCE_ARMMODECHANGE_INFO 
{
   EM_DEFENCEMODE       emDefenceStatus;            //布撤防状态
   int                  nDefenceID;                 //防区号
   NET_TIME_EX          stuTime;                    //时间
   
   EM_ARMMODECHANGE_TRIGGERMODE 		emTriggerMode;		//触发方式
   EM_ARMMODECHANGE_DEFENCEAREATYPE		emDefenceAreaType;	//防区类型
   int					nID;						//遥控器编号或键盘地址
   int 					nAlarmSubSystem;			//子系统号
   char   				szName[64];					//防区名称
   char					szNetClientAddr[64];		//用户IP或网络地址
   
   BYTE                 reserved[368];              //预留
}ALARM_DEFENCE_ARMMODECHANGE_INFO;

// 工作状态
typedef enum tagEM_SUBSYSTEMMODE
{
    EM_SUBSYSTEMMODE_UNKNOWN,             // "unknown"   未知
    EM_SUBSYSTEMMODE_ACTIVE,              // "active"    激活
    EM_SUBSYSTEMMODE_INACTIVE,            // "inactive"  未激活
    EM_SUBSYSTEMMODE_UNDISTRIBUTED,       // "undistributed" 未分配
    EM_SUBSYSTEMMODE_ALLARMING,           // "AllArming" 全部布防
    EM_SUBSYSTEMMODE_ALLDISARMING,        // "AllDisarming" 全部撤防
    EM_SUBSYSTEMMODE_PARTARMING,          // "PartArming" 部分布防
}EM_SUBSYSTEMMODE;

//触发方式
typedef enum tagEM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE
{
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN,		//未知
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_NET,			//网络用户
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD,		//键盘
	EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL,	//遥控器
}EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE;

// 事件类型 DH_ALARM_SUBSYSTEM_ARMMODECHANGE (子系统布撤防状态改变事件)
typedef struct tagALARM_SUBSYSTEM_ARMMODECHANGE_INFO 
{
    EM_SUBSYSTEMMODE    emSubsystemMode;            //布撤防状态 (只支持AllArming，AllDisarming，PartArming三种状态)
    NET_TIME_EX         UTC;                        //事件发生的时间
    char                szSubSystemname[64];        //子系统名称
    int                 nSubSystemID;               //子系统编号
    
    EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE	emTriggerMode; //触发方式
    int				nID;						//键盘或遥控器地址
    char				szNetClientAddr[64];		//网络用户IP地址或网络地址
    
    BYTE                reserved[440];              //预留
}ALARM_SUBSYSTEM_ARMMODECHANGE_INFO;

// 红外线检测信息事件 (对应 DH_ALARM_RFID_INFO)
typedef struct tagALARM_RFID_INFO
{
    int                         nAction;                // 0:开始 1:停止
    int                         nIndex;                 // 通道号
    NET_TIME_EX                 stuEventTime;           // 事件发生的时间
    int                         nValidCount;            // RFID 编号数组有效个数
    char                        szRfid[10][12];         // RFID 编号数组
}ALARM_RFID_INFO;

// 烟雾检测报警事件 (DH_ALARM_SMOKE_DETECTION)
typedef struct tagALARM_SMOKE_DETECTION_INFO
{
    int                 nAction;                        // 0:开始 1:停止
    char                szName[128];                    // 事件名称
    double              PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX         stuTime;                        // 事件发生的时间
	int					nChannel;						// 通道号
	int					nEventID;						// 事件ID
	
	int					nDetectRegionNum;                           // 规则检测区域顶点数
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 规则检测区域
	BYTE                reserved[36];                  // 预留字段               
}ALARM_SMOKE_DETECTION_INFO;

// 事件类型 DH_ALARM_PHONECALL_DETECT (打电话检测事件)
typedef struct tagALARM_PHONECALL_DETECT_INFO
{
	int                 nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	char                szName[128];                    // 事件名称
	BYTE                reserved1[4];					// 预留字段 
	double              PTS;                            // 时间戳(单位是毫秒)
	NET_TIME_EX         stuTime;                        // 事件发生的时间
	int					nChannel;						// 通道号
	int					nEventID;						// 事件ID
	
	int					nDetectRegionNum;                           // 规则检测区域顶点数
	DH_POINT			stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 规则检测区域
	BYTE                reserved[128];                  // 预留字段      
} ALARM_PHONECALL_DETECT_INFO;

// 事件数据类型
typedef enum tagNET_EM_EVENT_DATA_TYPE
{
	NET_EN_EVENT_DATA_TYPE_UNKNOWN,									// 未知
	NET_EN_EVENT_DATA_TYPE_REAL,									// 实时数据
	NET_EN_EVENT_DATA_TYPE_ALARM,									// 报警数据
}NET_EM_EVENT_DATA_TYPE;

// 事件类型 DH_ALARM_FLOATINGOBJECT_DETECTION (漂浮物检测事件)
typedef struct tagALARM_FLOATINGOBJECT_DETECTION_INFO
{
	int                 nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE                reserved1[4];					// 预留字段 
	char                szName[128];                    // 事件名称
	double              PTS;                            // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;							// 事件发生的时间
	int					nChannel;						// 通道号
	int					nEventID;						// 事件ID

	int					nPresetID;						// 事件触发的预置点ID
	char				szPresetName[64];				// 事件触发的预置名称
	BOOL				bExistFloatingObject;			// 是否存在漂浮物
	NET_EM_EVENT_DATA_TYPE		emEventType;			// 事件数据类型
	float				fCurrentRatio;					// 漂浮物当前占比（相对于检测区域）单位:%, 取值范围[0, 100]
	float				fAlarmThreshold;				// 报警阈值。漂浮物相对于检测区域的占比, 取值范围[0, 100]

	NET_POINT           stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
	int                 nDetectRegionNum;                   // 规则检测区域顶点数

	BYTE                byReserved[1020];                 // 预留字段      
} ALARM_FLOATINGOBJECT_DETECTION_INFO;

// 水位状态
typedef enum tagNET_EM_WATER_LEVEL_STATUS
{
	NET_EM_WATER_LEVEL_STATUS_UNKNOWN,									// 未知
	NET_EM_WATER_LEVEL_STATUS_NORMAL,									// 水位正常
	NET_EM_WATER_LEVEL_STATUS_HIGH,										// 水位高于上限阈值
	NET_EM_WATER_LEVEL_STATUS_LOW,										// 水位低于上限阈值
}NET_EM_WATER_LEVEL_STATUS;

// 水位尺颜色
typedef enum tagNET_EM_WATER_RULER_COLOR
{
	NET_EM_WATER_RULER_COLOR_UNKNOW,									// 无法识别
	NET_EM_WATER_RULER_COLOR_BLUE,										// 蓝色
	NET_EM_WATER_RULER_COLOR_RED,										// 红色
}NET_EM_WATER_RULER_COLOR;

// 水位尺
typedef struct tagNET_WATER_RULER
{
	NET_EM_WATER_RULER_COLOR	emRulerColor;							// 水位尺颜色
	char						szRulerNum[128];						// 水位尺编号
	float						fWaterLevel;							// 水位值（对于有拼接的情况，该值为标定的基准值加上当前刻度值，单位：米）
	BYTE						byReserved[512];						// 保留字节
}NET_WATER_RULER;

// 事件类型 DH_ALARM_WATER_LEVEL_DETECTION (水位检测事件)
typedef struct tagALARM_WATER_LEVEL_DETECTION_INFO
{
	int							nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE						reserved1[4];					// 预留字段 
	char						szName[128];                    // 事件名称
	double						PTS;                            // 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;							// 事件发生的时间
	int							nChannel;						// 通道号
	int							nEventID;						// 事件ID
	int							nPresetID;						// 预置点ID
	char						szPresetName[64];				// 预置点名称
	char						szObjectUUID[48];				// 智能物体全局唯一物体标识
	NET_EM_EVENT_DATA_TYPE		emEventType;					// 事件数据类型
	NET_EM_WATER_LEVEL_STATUS	emStatus;						// 水位状态
	NET_WATER_RULER				stuWaterRuler;					// 水位尺
	BYTE						byReserved[1024];                  // 预留字段      
} ALARM_WATER_LEVEL_DETECTION_INFO;

// 事件类型 DH_ALARM_LOW_SPEED
typedef struct tagALARM_LOW_SPEED_INFO
{
	int                 nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					nChannel;						// 通道号
	char                szName[128];                    // 事件名称
	double              PTS;                            // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;							// 事件发生的时间
	int					nEventID;						// 事件ID
	BYTE				byReserved[256];				// 预留字节
} ALARM_LOW_SPEED_INFO;
// 事件类型 DH_ALARM_TRAFFIC_VEHICLEINOUT
typedef struct tagALARM_TRAFFIC_VEHICLEINOUT_INFO
{
	int                 nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	int					nChannel;						// 通道号
	char                szName[128];                    // 事件名称
	double              PTS;                            // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;							// 事件发生的时间
	int					nEventID;						// 事件ID
	int					nLane;							// 车道
	UINT				nRoadwayNumber;					// 自定义车道
	int					nVehicleInOut;					// 车道状态 0 表示离开车道 1 表示进入车道 
	BYTE				byReserved[1024];				// 预留字节
} ALARM_TRAFFIC_VEHICLEINOUT_INFO;

// 事件类型DH_ALARM_TRAFFIC_JUNCTION
typedef struct tagALARM_TAFFIC_JUNCTION_INFO
{
	int					nAction;									// 事件动作
	int                 nChannelID;                                 // 通道号
	char                szName[128];                                // 事件名称
	BYTE                byMainSeatBelt;                             // 主驾驶座,系安全带状态,1-系安全带,2-未系安全带
	BYTE                bySlaveSeatBelt;                            // 副驾驶座,系安全带状态,1-系安全带,2-未系安全带
	BYTE                byVehicleDirection;                         // 当前被抓拍到的车辆是车头还是车尾,具体请见 EM_VEHICLE_DIRECTION
	BYTE                byOpenStrobeState;                          // 开闸状态,具体请见 EM_OPEN_STROBE_STATE
	BYTE				byReserved1[4];								// 字节对齐
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	int                 nEventID;                                   // 事件ID
	DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
	int                 nLane;                                      // 对应车道号
	DWORD               dwBreakingRule;                             // 违反规则掩码,第一位:闯红灯; 
	// 第二位:不按规定车道行驶;
	// 第三位:逆行; 第四位：违章掉头;
	// 第五位:交通堵塞; 第六位:交通异常空闲
	// 第七位:压线行驶; 否则默认为:交通路口事件

	NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
	int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
	int                 nSpeed;                                     // 车辆实际速度Km/h                 
	BYTE                byDirection;                                // 路口方向,1-表示正向,2-表示反向
	BYTE                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
	BYTE                byReserved2;                                 // 保留字节
	BYTE                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	DWORD               dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	DH_RESOLUTION_INFO  stuResolution;                              // 对应图片的分辨率
	char                szRecordFile[DH_COMMON_STRING_128];         // 报警对应的原始录像文件信息
	EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // 自定义信息
	BYTE                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
	BYTE                byReserved3[3];                              // 保留字节,留待扩展.
	NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制

	BYTE                byNoneMotorInfo;                            // 0-无非机动车人员信息信息,1-有非机动车人员信息信息
	// 此字段为1时下面11个字段生效
	BYTE                byBag;                                      // 是否背包, 0-未知 1-不背包   2-背包
	BYTE                byUmbrella;                                 // 是否打伞, 0-未知 1-不打伞   2-打伞
	BYTE                byCarrierBag;                               // 手提包状态,0-未知 1-没有 2-有    
	BYTE                byHat;                                      // 是否戴帽子, 0-未知 1-不戴帽子 2-戴帽子    
	BYTE                byHelmet;                                   // 头盔状态,0-未知 1-没有 2-有
	BYTE                bySex;                                      // 性别,0-未知 1-男性 2-女性
	BYTE                byAge;                                      // 年龄
	NET_COLOR_RGBA      stuUpperBodyColor;                          // 上身颜色
	NET_COLOR_RGBA      stuLowerBodyColor;                          // 下身颜色
	BYTE                byUpClothes;                                // 上身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙
	BYTE                byDownClothes;                              // 下身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙   

	NET_EXTENSION_INFO  stuExtensionInfo;                           // 扩展信息
	BYTE                byReserved4[22];								// 保留字节,留待扩展
	int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频,3RSU
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
	DWORD               dwRetCardNumber;                            // 卡片个数
	EVENT_CARD_INFO     stuCardInfo[DH_EVENT_MAX_CARD_NUM];         // 卡片信息   
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

	BOOL				bNonMotorInfoEx;							// 是否有非机动车信息
	VA_OBJECT_NONMOTOR  stuNonMotor;								// 非机动车信息
	BYTE				byReserved[2048];							// 保留字节,留待扩展
} ALARM_TAFFIC_JUNCTION_INFO;

// 事件类型DH_ALARM_DOOR_CONTROL(报警输出联动开门事件)对应的数据块描述信息
typedef struct tagALARM_DOOR_CONTROL_INFO
{
	int                 			nChannelID;                         	// 通道号
    int								nAction;								// 0:脉冲 1:开始 2:停止
    char                			szName[128];                         	// 事件名称
    double              			PTS;                                	// 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                                	// 事件发生的时间
    UINT                			nEventID;                           	// 事件ID

	EM_OPEN_DOOR_METHOD				emOpenDoorMethod;						// 开门方式
	EM_OPEN_DOOR_STATE				emOpenDoorState;						// 开门结果
	char							szSourceID[32];							// 事件关联ID。应用场景是同一个物体或者同一张图片做不同分析，产生的多个事件的SourceID相同;
																			// 格式如下：前2位%d%d:01-视频片段,02-图片,03-文件,99-其他;
																			// 中间14位YYYYMMDDhhmmss:年月日时分秒;后5位%u%u%u%u%u：物体ID，如00001
	BYTE			    			byReserved[1024];			        	// 预留字节
} ALARM_DOOR_CONTROL_INFO;

// 状态
typedef enum tagNET_EM_ARM_STATUS
{
	EM_ARM_STATUS_UNKNOWN,													// 未知
	EM_ARM_STATUS_DELAY,													// 延时
	EM_ARM_STATUS_ARMING,													// 布防
	EM_ARM_STATUS_DISARMING,												// 撤防
}NET_EM_ARM_STATUS;

// 事件类型DH_ALARM_ARMSTATE(防区状态事件)对应的数据块描述信息
typedef struct tagALARM_ARMSTATE_INFO
{
	int                 			nChannelID;                         	// 通道号
	int								nAction;								// 0:脉冲 1:开始 2:停止
	char                			szName[128];                         	// 事件名称
	double              			PTS;                                	// 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                	// 事件发生的时间
	UINT                			nEventID;                           	// 事件ID
	NET_EM_ARM_STATUS				emStatus;								// 状态
}ALARM_ARMSTATE_INFO;

// 事件类型 DH_ALARM_LAW_ENFORCEMENT_INFO(实时上报执法终端设备信息事件)对应的数据块描述信息
typedef struct tagALARM_LAW_ENFORCEMENT_INFO
{
	int						nAction;									// 0:脉冲 1:开始 2:停止 
	NET_GPS_STATUS_INFO		stuGPSStatus;								// GPS信息
	char					szUserID[32];								// 设备跌落时登陆的用户信息用户ID
	char					szUserName[128];							// 设备跌落时登陆的用户信息用户名
	BYTE					byRserved[4];					            // 字节对齐  
} ALARM_LAW_ENFORCEMENT_INFO;

// 事件类型DH_ALARM_CONGESTION_DETECTION(道路场景车辆拥堵报警事件)对应的数据块描述信息
typedef struct tagALARM_CONGESTION_DETECTION_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 0:脉冲 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	int 							nPresetID;									// 事件触发的预置点号，从1开始
	char							szPresetName[64];							// 事件触发的预置名称
	UINT							nAlarmMask;									// 报警业务掩码, 不同掩码位表示不同报警类型：bit0位表示是否有拥堵报警；bit1位表示是否有排队报警；
	UINT							nVehicleQuantity;							// 拥堵车辆数量
	UINT							nQueueLength;								// 车辆排队长度
	int								nDetectRegionNum;							// stuDetectRegion中有效坐标点个数
	DH_POINT						stuDetectRegion[32];						// 发生报警的区域坐标
	BYTE			    			byReserved[1024];			        		// 预留字节
}ALARM_CONGESTION_DETECTION_INFO;

// 事件类型DH_ALARM_VEHICLELIMIT_DETECTION(停车场场景下停车车辆上限报警)对应的数据块描述信息
typedef struct tagALARM_VEHICLELIMIT_DETECTION_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 0:脉冲 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	int 							nPresetID;									// 事件触发的预置点号，从1开始
	char							szPresetName[64];							// 事件触发的预置名称
	UINT							nVehicleQuantity;							// 车辆数量
	int								nDetectRegionNum;							// stuDetectRegion中有效坐标点个数
	DH_POINT						stuDetectRegion[32];						// 发生报警的区域坐标
	BYTE			    			byReserved[1024];			        		// 预留字节
}ALARM_VEHICLELIMIT_DETECTION_INFO;

// GPS信息
typedef struct tagLAMP_GPS_INFO
{
    DWORD                           dwLatitude;                                 // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
    DWORD                           dwLongitude;                                // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
    int                             nNumOfSatellite;                            // 卫星个数
    BYTE                            byReserved[4];                              // 预留字节
} LAMP_GPS_INFO;

// 设备网络离线异常情况
typedef enum tagEM_IS_OFF_LINE
{
    EM_IS_OFF_LINE_UNKNOWN = -1,                                                // 未知
    EM_IS_OFF_LINE_NORMAL,                                                      // 正常
    EM_IS_OFF_LINE_EXCEPTION,                                                   // 异常
} EM_IS_OFF_LINE;

// 设备电压异常情况
typedef enum tagEM_IS_VOLTAGE_FAULT
{
    EM_IS_VOLTAGE_FAULT_UNKNOWN = -1,                                           // 未知
    EM_IS_VOLTAGE_FAULT_NORMAL,                                                 // 正常
    EM_IS_VOLTAGE_FAULT_EXCEPTION,                                              // 异常
} EM_IS_VOLTAGE_FAULT;

// 设备电流异常情况
typedef enum tagEM_IS_CURRENT_FAULT
{
    EM_IS_CURRENT_FAULT_UNKNOWN = -1,                                           // 未知
    EM_IS_CURRENT_FAULT_NORMAL,                                                 // 正常
    EM_IS_CURRENT_FAULT_EXCEPTION,                                              // 异常
} EM_IS_CURRENT_FAULT;

// 补光灯是否点亮
typedef enum tagEM_BRIGHT_STATE
{
    EM_BRIGHT_STATE_UNKNOWN = -1,                                               // 未知
    EM_BRIGHT_STATE_OFF,                                                        // 未点亮
    EM_BRIGHT_STATE_ON,                                                         // 点亮
} EM_BRIGHT_STATE;

// 补光灯工作模式
typedef enum tagEM_LAMP_STATUS_WORK_MODE
{
    EM_LAMP_STATUS_WORK_MODE_UNKNOWN,                                           // 未知
    EM_LAMP_STATUS_WORK_MODE_DHRS_STROBOSCOPIC_LAMP,                            // RS485频闪灯
    EM_LAMP_STATUS_WORK_MODE_DHRS_STEADY_LAMP,                                  // RS485常亮灯
    EM_LAMP_STATUS_WORK_MODE_DHRS_FLASH_LAMP,                                   // RS485爆闪灯  
} EM_LAMP_STATUS_WORK_MODE; 

// 频闪模式
typedef enum tagEM_STROBOSCOPIC_MODE
{
    EM_STROBOSCOPIC_MODE_UNKNOWN = -1,                                          // 未知
    EM_STROBOSCOPIC_MODE_ACTIVE,                                                // 主动
    EM_STROBOSCOPIC_MODE_PASSIVE,                                               // 被动
} EM_STROBOSCOPIC_MODE;

// 频闪灯参数
typedef struct tagSTROBOSCOPIC_LAMP_PARAM
{
    EM_STROBOSCOPIC_MODE            emStroboscopicMode;                         // 频闪模式
    UINT                            nStayTime;                                  // 频闪持续时间, 单位s, 范围[0,2^32)
    UINT                            nFrequency;                                 // 频闪频率, 单位Hz
    UINT                            nBrightLevel;                               // 亮度等级, 1~20
    UINT                            nPulseWidth;                                // 频闪脉宽, 单位ms, 范围(0,4]
    BYTE                            byReserved[36];                             // 预留字段 
} STROBOSCOPIC_LAMP_PARAM;

// 频闪模式
typedef enum tagEM_TRIGGER_MODE
{
    EM_TRIGGER_MODE_UNKNOWN = -1,                                               // 未知
    EM_TRIGGER_MODE_EDGE,                                                       // 边沿
    EM_TRIGGER_MODE_PWM,                                                        // 脉宽
} EM_TRIGGER_MODE;

// 爆闪灯参数
typedef struct tagFLASH_LAMP_PARAM 
{
    EM_TRIGGER_MODE                 emTriggerMode;                              // 触发方式
    UINT                            nTriggerCount;                              // 触发计数, 范围[0,2^32)
    UINT                            nFlashCount;                                // 爆闪次数, 范围[0,2^32)
    UINT                            nPulseWidth;                                // 爆闪脉宽, 单位ms, 范围(0~4]ms
    UINT                            nPulseWidthDetectThreshold;                 // 脉宽检测阈值1~4等级
    UINT                            nErrorDetectThreshold;                      // 误检阀值, 3~8等级
    BYTE                            byReserved[32];                             // 预留字段 
} FLASH_LAMP_PARAM ;

// 常亮灯参数
typedef struct tagSTEADY_LAMP_PARAM
{
    UINT                            nBrightLevel;                               // 亮度等级, 1~20等级
    BYTE                            byReserved[60];                             // 预留字段 
} STEADY_LAMP_PARAM;

// 补光灯状态信息
typedef struct tagLAMP_STATUS_INFO
{             
    UINT                            nPort;                                      // 表示所连接相机的串口端口号
    UINT                            nAddress;                                   // DHRS补光灯外设地址, 范围0~15
    char                            szSoftwareVersion[128];                     // 软件版本
    char                            szDeviceID[32];                             // 设备ID
    LAMP_GPS_INFO                   stuGPS;                                     // GPS信息
    EM_IS_OFF_LINE                  emIsOffline;                                // 设备离线异常情况
    EM_IS_VOLTAGE_FAULT             emIsVoltageFault;                           // 设备电压异常情况         
    EM_IS_CURRENT_FAULT             emIsCurrentFault;                           // 设备电流异常情况
    EM_BRIGHT_STATE                 emBrightState;                              // 补光灯是否点亮
    UINT                            nPower;                                     // 表示设备的功率，以毫瓦为单位 0~65536999
    UINT                            nTemperature;                               // 表示设备温度，以百分之一度为精度，如1001表示10.01°, 0~25599
    UINT                            nPhotoSensitivity;                          // 表示设备光敏度，无单位0~4095
    UINT                            nAmbientBrightnessThreshold;                // 环境亮度阈值1-6等级
    EM_LAMP_STATUS_WORK_MODE        emWorkMode;                                 // 补光灯工作模式
    STROBOSCOPIC_LAMP_PARAM         stuStroboscopicLampParam;                   // 频闪灯参数
    FLASH_LAMP_PARAM                stuFlashLampParam;                          // 爆闪灯参数
    STEADY_LAMP_PARAM               stuSteadyLampParam;                         // 常亮灯参数
    BYTE                            byReserved[64];                             // 预留字段 
} LAMP_STATUS_INFO;

// 交通相机通过串口与补光灯连接获取补光灯的状态信息
typedef struct tagALARM_TRAFFIC_LAMP_WORK_STATE_INFO
{
    NET_TIME_EX                     UTC;                                        // 对应的UTC秒数
    UINT                            nUTCMS;                                     // 对应的UTC毫秒数
    int                             nChannelID;                                 // 通道号
    int                             nLampStatusNum;                             // 补光灯状态信息数量
    LAMP_STATUS_INFO                stuLampStatus[8];                           // 补光灯状态信息
    BYTE                            byReserved[256];                            // 预留字节
} ALARM_TRAFFIC_LAMP_WORK_STATE_INFO;

// 事件类型 DH_ALARM_TRAFFIC_PARKING_TIMEOUT(停车时长超限事件)对应的数据块描述信息
typedef struct tagALARM_TRAFFIC_PARKING_TIMEOUT_INFO
{
	int                 				nChannelID;                         	// 通道号
	int									nAction;								// 0:脉冲 1:开始 2:停止
	NET_TIME_EX         				UTC;                                	// 事件发生的时间
	NET_TIME							stuInParkTime;							// 进场时间
	NET_TIME							stuOutParkTime;							// 出场时间
	UINT								nParkingTime;							// 停车时长，单位秒
	BYTE			    				byReserved[1024];			        	// 预留字节
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO	stuTrafficCar;							// 交通车辆的数据库记录
}ALARM_TRAFFIC_PARKING_TIMEOUT_INFO;

// 事件类型 DH_ALARM_TICKET_INFO_REPORT (车票信息上报事件)对应的数据块描述信息
typedef struct tagALARM_TICKET_INFO_REPORT
{
	int                         nChannelID;                         // 通道号
	int                         nAction;                            // 0:脉冲 1:开始 2:停止	
	double                      PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX                 UTC;                                // 事件发生的时间
	int							nEventID;                           // 事件ID
	int							nOpenFlag;							// 开门标示，0开门，其他不开门
	BYTE						byReserved[4];						// 预留字段
	char						szPassengerName[256];				// 姓名
	char						szCitizenID[32];					// 身份证号	
	NET_TIME					stuDriveTime;						// 发车时间
	char						szDestination[256];					// 目的站
	char						szScheduleID[64];					// 班次
}ALARM_TICKET_INFO_REPORT;

// 病人活动状态检测具体类型
typedef enum TagEM_PATIENTDETECTION_TYPE
{
    EM_PATIENTDETECTION_TYPE_UNKNOWN,                       // 未知类型
    EM_PATIENTDETECTION_TYPE_CROSS_REGION,                  // 警戒区域报警，可能是病人离开或者有其他靠近病人
    EM_PATIENTDETECTION_TYPE_LIGHT_OFF,                     // 病房电灯被熄灭
    EM_PATIENTDETECTION_TYPE_STOP_DETECTION,                // 撤防，不再监控病人
    EM_PATIENTDETECTION_TYPE_START_DETECTION,               // 开始布防
    EM_PATIENTDETECTION_TYPE_ESCAPE,                        // 病人在押解过程中逃跑
	EM_PATIENTDETECTION_TYPE_ESCAPE_RELEASE,                // 解除病人逃离报警
}EM_PATIENTDETECTION_TYPE;

// 病人活动状态检测报警事件 (DH_ALARM_PATIENTDETECTION)
typedef struct tagALARM_PATIENTDETECTION_INFO
{
    BYTE                        bEventAction;               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    NET_TIME                    stuTime;                    // 事件发生时间
    EM_PATIENTDETECTION_TYPE    emDetectionType;            // 当前事件具体类型
    BYTE                        byReserved[256];            // 预留字段 
}ALARM_PATIENTDETECTION_INFO;

// 雷达监测超速报警事件 智能楼宇专用 (DH_ALARM_RADAR_HIGH_SPEED)
typedef struct tagALARM_RADAR_HIGH_SPEED_INFO
{
    NET_TIME_EX                 stuTime;                    // 事件发生时间
    float                       fSpeed;                     // 速度(单位:km/h)
	char						szPlateNumber[16];			// 车牌
    BYTE                        byReserved[1008];           // 预留字段 
}ALARM_RADAR_HIGH_SPEED_INFO;

// 设备巡检报警事件 智网专用 (DH_ALARM_POLLING_ALARM)
typedef struct tagALARM_POLLING_ALARM_INFO
{
    NET_TIME_EX                 stuTime;                    // 事件发生时间
    BYTE                        byReserved[1024];           // 预留字段 
}ALARM_POLLING_ALARM_INFO;

// 道闸栏状态
typedef enum tagEM_TRAFFICSTROBE_STATUS
{
    NET_TRAFFICSTROBE_STATUS_UNKNOWN,
	NET_TRAFFICSTROBE_STATUS_CLOSE_COMPLETE,                               // 道闸栏关闭
	NET_TRAFFICSTROBE_STATUS_OPEN_COMPLETE,                                // 道闸栏打开
	NET_TRAFFICSTROBE_STATUS_NOT_CLOSE_COMPLETE,                           // 道闸栏未完全关闭
	NET_TRAFFICSTROBE_STATUS_NOT_OPEN_COMPLETE,							   // 道闸栏未完全打开
} EM_TRAFFICSTROBE_STATUS;

// 道闸栏状态事件 ( DH_ALARM_TRAFFICSTROBESTATE )
typedef struct tagALARM_TRAFFICSTROBESTATE_INFO
{
	BYTE                        bEventAction;               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束
    NET_TIME                    stuTime;                    // 事件发生时间
	int                         nChannelID;                 // 视频通道号
    EM_TRAFFICSTROBE_STATUS		emStatus;                   // 道闸栏状态
    BYTE                        byReserved[1024];           // 预留字段 
}ALARM_TRAFFICSTROBESTATE_INFO;

// 贴条事件(对应事件 DH_ALARM_PASTE_DETECTION)
typedef struct tagALARM_PASTE_DETECTION_INFO
{
    int                     nChannelID;                                 // 通道号
    char                    szName[128];                                // 事件名称
    double                  PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                        // 事件发生的时间
    DH_MSG_OBJECT           stuObject;                                  // 检测到的物体
    int                     nDetectRegionNum;                           // 规则检测区域顶点数
    DH_POINT                stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 规则检测区域
    DH_MSG_HANDLE_EX        stuEventHandler;                            // 联动信息
    BYTE                    bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    BYTE                    bReserved[1023];                            // 保留字节,留待扩展.
}ALARM_PASTE_DETECTION_INFO;

// 热成像规则间温差异常报警 (DH_ALARM_BETWEENRULE_TEMP_DIFF)
typedef struct tagALARM_BETWEENRULE_DIFFTEMPER_INFO
{
    int                             nAction;                        // 0:开始 1:停止
    int                             nOsdId;                         // 温差OSD配置中的OSD编号
    int                             nChannelID;                     // 视频通道号
    NET_RADIOMETRY_ALARMCONTION     emAlarmContion;                 // 报警条件 0:小于 1:等于 2:大于
    int                             nRuleId1;                       // 测温规则1,参考配置CFG_RADIOMETRY_RULE_INFO
    int                             nRuleId2;                       // 测温规则2,参考配置CFG_RADIOMETRY_RULE_INFO
    float                           fDiffValue;                     // 规则间温差值
    int                             nTemperatureUnit;               // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
    UINT                            nPresetID;                      // 预置点
    BYTE                            reserved[128];                  // 预留字段  
}ALARM_BETWEENRULE_DIFFTEMPER_INFO;

// 热成像热点异常报警事件(对应 DH_ALARM_HOTSPOT_WARNING)
typedef struct tagALARM_HOTSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:开始 1:停止
    int                 nChannelID;                     // 视频通道号
    DH_POINT            stuCoordinate;                   // 热点的坐标,坐标值 0~8192
    float               fHotSpotValue;                  // 热点温度值
    int                 nTemperatureUnit;               // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
}ALARM_HOTSPOT_WARNING_INFO;

// 热成像冷点异常报警事件(对应 DH_ALARM_COLDSPOT_WARNING)
typedef struct tagALARM_COLDSPOT_WARNING_INFO
{
    int                 nAction;                        // 0:开始 1:停止
    int                 nChannelID;                     // 视频通道号
    DH_POINT            stuCoordinate;                   // 冷点的坐标,坐标值 0~8192
    float               fColdSpotValue;                  // 冷点温度值
    int                 nTemperatureUnit;               // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
}ALARM_COLDSPOT_WARNING_INFO;

// 水流量计信息 (对应 DH_ALARM_FLOW_METER)
typedef struct tagALARM_FLOW_METER_INFO 
{
    DWORD                   dwSize;
    float                   fInstantRate;                       // 瞬时流速 m/s
    float                   fInstantFlow;                       // 瞬时流量 m^3/h
    float                   fTotalFlow;                         // 总流量 m^3
    float                   fCurDayFlow;                        // 当天流量 m^3
    UINT                    unCurDayWorkingTime;                // 当天降尘作业时间,单位: 分
    UINT                    unTotalWorktingTime;                // 累计降尘作业时间,单位: 分
    NET_GPS_STATUS_INFO     stuGPS;                             // GPS信息
    float                   fCurTemp;                           // 设备当前温度值,单位: 摄氏度
} ALARM_FLOW_METER_INFO;

// 录像丢帧类型
typedef enum tagEM_BUF_DROP_FRAME_TYPE
{
    EM_BUF_DROP_FRAME_UNKOWN = 0,                       // 丢帧类型为 未知录像
    EM_BUF_DROP_FRAME_DEVBUF,                           // 丢帧类型为 主码流录像
    EM_BUF_DROP_FRAME_EXTBUF,                           // 丢帧类型为 辅码流录像
    EM_BUF_DROP_FRAME_NETBUF,                           // 丢帧类型为 主码流网络录像
    EM_BUF_DROP_FRAME_EXTRA1NETBUF                      // 丢帧类型为 辅码流1网络录像
}EM_BUF_DROP_FRAME_TYPE;

// 录像缓冲区丢帧事件(对应 DH_ALARM_BUF_DROP_FRAME)
typedef struct tagALARM_BUF_DROP_FRAME_INFO
{
    int                         nAction;                // 0:开始 1:停止
    EM_BUF_DROP_FRAME_TYPE      emDropFrameType;        // 录像丢帧类型
    BYTE                        reserved[1024];         // 预留字段
}ALARM_BUF_DROP_FRAME_INFO;


// 主备切换事件 集群切换报警 (对应 DH_ALARM_DCSSWITCH)
typedef struct tagALARM_DCSSWITCH_INFO
{
    int                         nAction;                // 0:开始 1:停止
    char                        strMasterIP[32];        // 被替换的主用机IP
    char                        strSlaveIP[32];         // 执行替换的备用机IP
    NET_TIME_EX                 stuStartTime;           // 替换的开始时间
    BYTE                        reserved[1024];         // 预留字段
}ALARM_DCSSWITCH_INFO;

// 双控设备主板与备板之间版本信息不一致异常事件 (对应 DH_ALARM_DOUBLE_DEV_VERSION_ABNORMAL)
typedef struct tagALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO
{
    int                         nAction;                // 0:开始 1:停止
    char                        strMasterVer[64];       // 主板的版本信息(仅nAction 为0时 该值有效)
    char                        strSlaveVer[64];        // 备板的版本信息(仅nAction 为0时 该值有效)
    BYTE                        reserved[1024];         // 预留字段
}ALARM_DOUBLE_DEV_VERSION_ABNORMAL_INFO;

// 雷达连接状态
typedef enum tagEM_RADAR_CONNECT_STATE
{
    EM_RADAR_CONNECT_STATE_UNKNOWN,     // 未知
    EM_RADAR_CONNECT_STATE_NORMAL,      // 正常
    EM_RADAR_CONNECT_STATE_EXCEPTION,   // 异常
}EM_RADAR_CONNECT_STATE;

// 雷达连接状态事件 (对应 DH_ALARM_RADAR_CONNECT_STATE)
typedef struct tagALARM_RADAR_CONNECT_STATE_INFO
{
    EM_RADAR_CONNECT_STATE      emRadarConnectState;    // 雷达连接状态
    BYTE                        reserved[1024];         // 预留字段
}ALARM_RADAR_CONNECT_STATE_INFO;

// 高空抛物物体动作
typedef enum tagEM_HIGHTOSS_ACTION_TYPE
{
    EM_HIGHTOSS_ACTION_UNKNOWN,         // 未知
    EM_HIGHTOSS_ACTION_APPEAR,          // 第一次出现在检测区域中，或者跟踪时物理分离动作中尚未确认的新物体
    EM_HIGHTOSS_ACTION_MOVE,            // 正在运动，物体被正常跟踪
    EM_HIGHTOSS_ACTION_STAY,            // 物体停止运动，这个物体不会出现在下一帧物体列表中，物体开始移动后再恢复在列表中
    EM_HIGHTOSS_ACTION_REMOVE,          // 物体从原来的区域移除，或者被遮盖，或者跟踪失败，移除的物体ID不会被自动删除，并且物体重新出现是有可能再次被使用
    EM_HIGHTOSS_ACTION_DISAPPEAR,       // 运动到跟踪区域之外，或者达到了算法跟踪物体的上限而被清除，消失的物体ID将不再出现
    EM_HIGHTOSS_ACTION_SPLIT,           // 从其他物体中分离出来，可以用来检测物体遗留，关联ID表示从这个ID对应物体分离
    EM_HIGHTOSS_ACTION_MERGE,           // 合并到其他物体，可以用来检查物体保全，关联ID表示合并到这个ID对相应的物体
    EM_HIGHTOSS_ACTION_RENAME,          // 如果算法无法确定分离动作中某个物体是原先同一个物体，应该先创建一个新的物体，证据充分后再重命名为旧的物体ID，关联ID表示暂时使用的新的ID
} EM_HIGHTOSS_ACTION_TYPE;

// 高空抛物物体信息
typedef struct tagNET_HIGHTOSS_OBJECT_INFO
{
    UINT                            nObjectID;              // 物体ID
    EM_HIGHTOSS_ACTION_TYPE         emObjAction;            // 物体动作类型
    NET_RECT                        stuBoundingBox;         // 包围盒
    UINT                            nConfidence;            // 置信度
    EM_ANALYSE_OBJECT_TYPE          emObjectType;           // 物体类型
    BYTE                            byReserved[2048];		// 预留字节 
} NET_HIGHTOSS_OBJECT_INFO;


// 事件类型 DH_ALARM_HIGH_TOSS_DETECT (高空抛物检测事件)对应的数据块描述信息
typedef struct tagALARM_HIGH_TOSS_DETECT_INFO
{
	int                         nChannelID;                         // 通道号
	int                         nAction;                            // 0:脉冲 1:开始 2:停止	
	double                      PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX                 UTC;                                // 事件发生的时间
	BYTE                        byReserved1[4];                     // 对齐
	int					        nEventID;                           // 事件ID

    UINT                        nObjNum;                            // 物体个数
    NET_HIGHTOSS_OBJECT_INFO    stuObjInfos[50];                    // 物体信息
    BYTE                        byReserved[1024];                   // 预留字段 
}ALARM_HIGH_TOSS_DETECT_INFO;

typedef enum tagEM_MARKFILE_MODE
{
	EM_MARK_FILE_BY_TIME_MODE,                              // 通过时间方式对录像加锁
	EM_MARK_FILE_BY_NAME_MODE,                              // 通过文件名方式对录像加锁
}EM_MARKFILE_MODE;
typedef enum tagEM_MARKFILE_NAMEMADE_TYPE
{
	EM_MARKFILE_NAMEMADE_DEFAULT,							// 默认方式：需要用户传递录像文件名参数szFilename
	EM_MARKFILE_NAMEMADE_JOINT,								// 拼接文件名方式：用户传递磁盘号(nDriveNo)、起始簇号(nStartCluster)，不需要传递录像文件名
}EM_MARKFILE_NAMEMADE_TYPE;
typedef struct tagNET_IN_SET_MARK_FILE
{
    DWORD                                   dwSize;									// 
	EM_MARKFILE_MODE	                    emLockMode;								// 录像加锁方式，
	EM_MARKFILE_NAMEMADE_TYPE				emFileNameMadeType;						// 文件名产生的方式
    int										nChannelID;								// 通道号
    char									szFilename[MAX_PATH];	                // 文件名
    unsigned int							nFramenum;								// 文件总帧数
    unsigned int							nSize;									// 文件长度
    NET_TIME								stuStartTime;							// 开始时间
    NET_TIME								stuEndTime;								// 结束时间
    unsigned int							nDriveNo;								// 磁盘号(区分网络录像和本地录像的类型,0－127表示本地录像,其中64表示光盘1,128表示网络录像)
    unsigned int							nStartCluster;							// 起始簇号
    BYTE									byRecordFileType;						// 录象文件类型  0：普通录象；1：报警录象；2：移动检测；3：卡号录象；4：图片, 5: 智能录像
    BYTE									byImportantRecID;						// 0:普通录像 1:重要录像
    BYTE									byHint;									// 文件定位索引(nRecordFileType==4<图片>时,bImportantRecID<<8 +bHint ,组成图片定位索引 )
    BYTE									byRecType;								// 0-主码流录像  1-辅码流1录像 2-辅码流2录像 3-辅码流3录像
} NET_IN_SET_MARK_FILE;
typedef struct tagNET_OUT_SET_MARK_FILE
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE;
//CLIENT_SetMarkFileByTime输入参数
typedef struct tagNET_IN_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize;
    int                 nChannel;                             //需要锁定的通道号,从0开始,元素为-1时,表示全通道。
    NET_TIME_EX         stuStartTime;                         //开始时间
    NET_TIME_EX         stuEndTime;                           //结束时间
    BOOL                bFlag;                                //标记动作	true : 标记, false : 清除
} NET_IN_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTime输出参数
typedef struct tagNET_OUT_SET_MARK_FILE_BY_TIME
{
    DWORD               dwSize; 
} NET_OUT_SET_MARK_FILE_BY_TIME;

//CLIENT_SetMarkFileByTimeEx输入参数

//CLIENT_SetMarkFileByTimeEx输出参数

//CLIENT_GetMarkInfo输入参数
typedef struct tagNET_IN_GET_MARK_INFO
{
    DWORD               dwSize;
} NET_IN_GET_MARK_INFO;

//CLIENT_GetMarkInfo输出参数
typedef struct tagNET_OUT_GET_MARK_INFO
{
    DWORD               dwSize;
    int                 nTotalSpace;  //总容量（单位M）
    int                 nMarkSpace;   //录像被锁定的容量 单位M
} NET_OUT_GET_MARK_INFO;

//消除反潜报警入参
typedef struct tagNET_IN_CLEAR_REPEAT_ENTER
{
    char         szCardNO[DH_MAX_CARDINFO_LEN];         // 用户卡号
    BYTE         bReserved[1024];
}NET_IN_CLEAR_REPEAT_ENTER;

//消除反潜报警出参
typedef struct tagNET_OUT_CLEAR_REPEAT_ENTER
{
    BYTE         bReserved[1024];
}NET_OUT_CLEAR_REPEAT_ENTER;

// 报警事件类型DH_ALARM_RECORD_LOSS(录像丢失事件)对应的数据描述信息
typedef struct tagALARM_RECORD_LOSS_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作, 0:Pulse, 1:Start, 2:Stop
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // 发生丢录像的设备IP  
    int                 nPort;                          // 发生丢录像的设备端口
    BYTE                byReserved[1024];               // 预留
} ALARM_RECORD_LOSS_INFO;

// 报警事件类型DH_ALARM_VIDEO_FRAME_LOSS(视频丢帧事件)对应的数据描述信息
typedef struct tagALARM_VIDEO_FRAME_LOSS_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作, 0:Pulse, 1:Start, 2:Stop
    char                szIP[DH_MAX_IPADDR_LEN_EX];     // 发生丢帧的设备IP
    int                 nPort;                          // 发生丢帧的设备端口
    BYTE                byReserved[1024];               // 预留
} ALARM_VIDEO_FRAME_LOSS_INFO;

// 报警事件类型DH_ALARM_RECORD_VOLUME_FAILURE(磁盘卷异常)对应的数据描述信息
typedef struct tagALARM_RECORD_VOLUME_FAILURE_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作, 0:Pulse, 1:Start, 2:Stop
    BYTE                byReserved[1024];               // 预留
} ALARM_RECORD_VOLUME_FAILURE_INFO;

// 事件类型 DH_EVENT_SNAP_UPLOAD(图上传完成事件)对应的数据描述信息
typedef struct tagEVENT_SNAP_UPLOAD_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作, 0:Pulse, 1:Start, 2:Stop
    BOOL                bSnapResult;                    // 图片是否上传成功
    char                szFilePath[MAX_PATH];           // 上传的本地图片名称
    BYTE                byReserved[1024];               // 预留
}EVENT_SNAP_UPLOAD_INFO;

// 报警事件类型DH_ALARM_UPLOADPIC_FAILCOUNT(上传中盟失败数据个数)对应的数据描述信息
typedef struct tagALARM_UPLOADPIC_FAILCOUNT_INFO
{
    int                 nFailCount;                     // 上传失败个数
    BYTE                byReserved[1024];               // 预留
} ALARM_UPLOADPIC_FAILCOUNT_INFO;


// 报警事件类型 DH_ALARM_HUMAN_INSIDE(舱内有人事件) 对应的数据描述信息
typedef struct tagALARM_HUMAN_INSIDE_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作,-1表示未知事件,0表示持续性事件开始,1表示持续性事件结束
    int                 nHumanNumber;                   // 舱内人数
    NET_TIME            stuUtcTime;                     // 事件发生的时间
    BYTE                byReserved[1000];               // 预留  
} ALARM_HUMAN_INSIDE_INFO;
 
// 报警事件类型 DH_ALARM_HUMAN_TUMBLE_INSIDE(舱内有人摔倒事件) 对应的数据描述信息
typedef struct tagALARM_HUMAN_TUMBLE_INSIDE_INFO
{
    int                 nChannelID;                     // 通道号
    int                 nEventAction;                   // 事件动作,-1表示未知事件,0表示持续性事件开始,1表示持续性事件结束
    NET_TIME            stuUtcTime;                     // 事件发生的时间
    BYTE                byReserved[1000];               // 预留
} ALARM_HUMAN_TUMBLE_INSIDE_INFO;

// 报警事件类型 DH_ALARM_DISABLE_LOCKIN(闭锁进门按钮触发事件) 对应的数据描述信息
typedef struct tagALARM_DISABLE_LOCKIN_INFO
{
    int                 nChannelID;                     // 通道号
    NET_TIME            stuUtcTime;                     // 事件发生的时间
    BYTE                byReserved[1000];               // 预留
} ALARM_DISABLE_LOCKIN_INFO;


// 报警事件类型 DH_ALARM_DISABLE_LOCKOUT(闭锁出门按钮触发事件) 对应的数据描述信息
typedef struct tagALARM_DISABLE_LOCKOUT_INFO
{
    int                 nChannelID;                     // 通道号
    NET_TIME            stuUtcTime;                     // 事件发生的时间
    BYTE                byReserved[1000];               // 预留
} ALARM_DISABLE_LOCKOUT_INFO;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CLIENT_GetOperatorName 输入参数
typedef struct tagNET_IN_GET_OPERATOR_NAME
{
    BYTE                byReserved[1024];               // 预留
} NET_IN_GET_OPERATOR_NAME;

//CLIENT_GetOperatorName 输出参数
typedef struct tagNET_OUT_GET_OPERATOR_NAME
{
    char                szOpearatorName[DH_COMMON_STRING_64]; //操作员用户名
    BYTE                byReserved[1024];                     // 预留
} NET_OUT_GET_OPERATOR_NAME;

// CLIENT_GetSelfCheckInfo 输入参数
typedef struct tagNET_IN_GET_SELTCHECK_INFO
{
    DWORD               dwSize;                  // 用户使用该结构体时,dwSize 需赋值为 sizeof (NET_IN_GET_SELTCHECK_INFO)
} NET_IN_GET_SELTCHECK_INFO;

//事件类型EVENT_IVS_PTZ_PRESET(云台转动到预置点事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ALARM_PTZ_PRESET_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
    char                szPresetName[PTZ_PRESET_NAME_LEN];          // 预置点名称
    PTZ_SPEED_UNIT      stuPos;                                     // 预置点的坐标和放大倍数
    int                 nPresetID;                                  // 预置点ID
    BYTE                bReserved[1024];                            // 保留字节
} DEV_EVENT_ALARM_PTZ_PRESET_INFO;

//事件类型EVENT_IVS_RFID_INFO(红外线检测信息事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ALARM_RFID_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
    int                 nAction;                                    // 0:开始 1:停止
    int                 nValidCount;                                // RFID 编号数组有效个数
    char                szRfid[10][12];                             // RFID 编号数组
    BYTE                bReserved[1024];                            // 保留字节
} DEV_EVENT_ALARM_RFID_INFO;



// 称重系统车辆信息
typedef struct tagNET_CAR_WEIGTH_INFO
{
	unsigned int		nAxleNum;									// 车轴数
	unsigned int		nMaxAxleDistance;							// 最大轴距, 单位是毫米
    unsigned int        nAxleWeightInfo[MAX_AXLE_NUM];              // 每根车轴的重量, 单位Kg, 第一个元素表示第一个车轴重, 依次类推
    unsigned int        nAxleDistanceInfo[MAX_AXLE_NUM-1];          // 轴与轴的间隔, 单位毫米, 第一个元素表示一二轴间距, 第二个元素表示二三轴间距, 依次类推
    unsigned int        nOverWeight;                                // 超重信息, 单位千克
    BYTE                byReserved[512];                            // 保留字节
}NET_CAR_WEIGHT_INFO;

// 事件类型 EVENT_IVS_QSYTRAFFICCARWEIGHT (交通卡口称重事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_QSYTRAFFICCARWEIGHT_INFO  
{
    NET_CAR_WEIGHT_INFO                 stCarWeightInfo;		    // 称重系统车辆信息
    DEV_EVENT_TRAFFICJUNCTION_INFO      stJunctionInfo;             // 交通卡口信息
}DEV_EVENT_QSYTRAFFICCARWEIGHT_INFO;

// 前后车牌信息
typedef struct tagNET_PLATE_INFO
{
	char						szFrontPlateNumber[DH_MAX_PLATE_NUMBER_LEN];	// 前车牌号码
	EM_NET_PLATE_COLOR_TYPE		emFrontPlateColor;								//前车牌颜色
	char						szBackPlateNumber[DH_MAX_PLATE_NUMBER_LEN];		// 后车牌号码
	EM_NET_PLATE_COLOR_TYPE		emBackPlateColor;								// 后车牌颜色
	BYTE						bReserved[1024];								// 保留字节
} NET_PLATE_INFO;

// 记录两张卡口图片的抓拍时间
typedef struct tagNET_SNAP_TIME_INFO
{
    NET_TIME_EX stFrontGateSnapTime;    // 前卡口图片抓拍时间(精确到毫秒)
    NET_TIME_EX stBackGateSnapTime;     // 后卡口图片抓拍时间(精确到毫秒) 
    BYTE  bReserved[128];               // 保留字节
}NET_SNAP_TIME_INFO;

// 事件类型EVENT_IVS_TRAFFIC_COMPAREPLATE(卡口车牌合成事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_COMPAREPLARE_INFO
{
	int					nChannelID;							// 通道号
	char				szName[DH_EVENT_NAME_LEN];			// 事件名称
	int                 nTriggerType;                   	// TriggerType:触发类型,0车检器,1雷达,2视频
	double				dbPTS;								// 时间戳(单位是毫秒)
	NET_TIME_EX			stuUTC;								// 事件发生的时间
	int					nEventID;							// 事件ID

	DH_MSG_OBJECT		stuObject;							// 车牌信息
	DH_MSG_OBJECT		stuVehicle;							// 车辆信息
	DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息 
	int					nMark;								// 用于标记抓拍帧
	int					nSource;							// 视频分析的数据源地址
	int					nFrameSequence;						// 视频帧序号
	int					nSpeed;								// 车辆实际速度(单位: km/h)
	int					nLane;								// 对应的车道号 
	int					nSequence;							// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
	DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;         // 交通车辆信息
	NET_PLATE_INFO		stuPlateInfo;						// 前后车牌信息
	EVENT_COMM_INFO     stCommInfo;                         // 公共信息
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON

    NET_SNAP_TIME_INFO  stSnapTimeInfo;                     // 记录两张卡口图片的抓拍时间
	BYTE				bReserved[820];					    // 保留信息
} DEV_EVENT_TRAFFIC_COMPAREPLATE_INFO;
typedef struct tagDEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO
{
    int							nChannelID;									// 通道号
    char						szName[DH_EVENT_NAME_LEN];					// 事件名称
    double						dbPTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX					stuUTC;										// 事件发生的时间
    int							nEventID;									// 事件ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// 事件对应文件信息
    BYTE						bEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	DH_POINT					stuDetectRegion;								// 规则检测区域
	int							nValidBulletHolesNum;						// 检测到的有效弹孔个数
	NET_BULLET_HOLES_INFO       stuBulletHolesInfo[DH_MAX_BULLET_HOLES];	// 检测到的弹孔
    BYTE						byImageIndex;								// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD						dwSnapFlagMask;								// 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE						bReserved[1024];							// 保留字节,留待扩展. 
} DEV_EVENT_SHOOTING_SCORE_RECOGNITION_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_TRANSFINITE(违章超限抓图上报事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_TRANSFINITE_INFO
{
    int							nChannelID;									// 通道号
    char						szName[DH_EVENT_NAME_LEN];					// 事件名称
    double						dbPTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX					stuUTC;										// 事件发生的时间
    int							nEventID;									// 事件ID
    DH_EVENT_FILE_INFO			stuFileInfo;								// 事件对应文件信息
    BYTE						bEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	char						szPlateNumber[16];							// 车牌
    char                        szTime[20];									// 违章时间
	double						dbLong;										// 长，单位米
    double						dbWidth;									// 宽，单位米
	double						dbHeight;									// 高, 单位米
	char						szViolationCode[16];						// 违章代码
	char						szDescribe[132];						    // 违章描述

    BYTE						byImageIndex;								// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD						dwSnapFlagMask;								// 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE						bReserved[4096];							// 保留字节,留待扩展. 
} DEV_EVENT_TRAFFIC_TRANSFINITE_INFO;

// 车辆抓拍图片信息
typedef struct tagDEV_EVENT_TRAFFIC_FCC_IMAGE
{
    DWORD           dwOffSet;                       // 图片文件在二进制数据块中的偏移位置, 单位:字节
    DWORD           dwLength;						// 图片大小, 单位:字节
    WORD            wWidth;                         // 图片宽度, 单位:像素
    WORD            wHeight;                        // 图片高度, 单位:像素
}DEV_EVENT_TRAFFIC_FCC_IMAGE;

// 车辆抓图信息
typedef struct tagDEV_EVENT_TRAFFIC_FCC_OBJECT
{
	DEV_EVENT_TRAFFIC_FCC_IMAGE	stuImage;							// 车辆抓拍图片信息
}DEV_EVENT_TRAFFIC_FCC_OBJECT;

// 事件类型EVENT_IVS_TRAFFIC_FCC_INFO
typedef struct tagDEV_EVENT_TRAFFIC_FCC_INFO
{
	int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    DWORD				nTriggerID;									// 触发类型: 1表示提枪, 2表示挂枪
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////

	DWORD				dwNum;										// 加油枪号
	DWORD				dwLitre;									// 加油升数,单位 0.01升
	EM_REFUEL_TYPE		emType;										// 加油类型: 取值范围{"90#","93#","10#","-20#"}
	DWORD				dwMoney;									// 加油金额,单位 0.01元
	char				szPlateNumber[DH_COMMON_STRING_16];			// 车牌号
	char				szTime[DH_COMMON_STRING_32];				// 事件发生时间: "2016-05-23 10:31:17"
	DEV_EVENT_TRAFFIC_FCC_OBJECT	stuObject;						// 车辆抓图信息
	BYTE				bReserved[1024];					        // 保留字节,留待扩展
}DEV_EVENT_TRAFFIC_FCC_INFO;



typedef enum tagEM_PARKINGSPACE_STATUS
{
    EM_PARKINGSPACE_STATUS_UNKNOWN,
    EM_PARKINGSPACE_STATUS_BUSY,                            // 占用
    EM_PARKINGSPACE_STATUS_FREE,                            // 空闲
    EM_PARKINGSPACE_STATUS_OVERLINE,                        // 压线
}EM_PARKINGSPACE_STATUS;

// 车位抠图信息
typedef struct tagNET_FEATUREPIC_AREA
{
	int					nRetCount;									// 实际返回坐标个数																
	DH_POINT			stuFeaturePicArea[10];						// 车位信息抠图坐标							
	BYTE				bReserved[256];					            // 保留字节
}NET_FEATUREPIC_AREA;

//事件类型EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP(车牌预处理抓片图片事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[128];                                // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         stuTime;                                    // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    int					nGroupID;									// 事件组ID，同一辆车抓拍过程内GroupID相同
    int					nCountInGroup;								// 一个事件组内的抓拍张数
    int					nIndexInGroup;								// 一个事件组内的抓拍序号
    DH_MSG_OBJECT       stuObject;                                  // 车牌信息
    DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
    int					nMark;								        // 用于标记抓拍帧
    int					nSource;							        // 视频分析的数据源地址
    int					nFrameSequence;						        // 视频帧序号
    int					nLane;								        // 对应的车道号 
    int					nSequence;							        // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
    DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
    EM_PARKINGSPACE_STATUS   emParkingSpaceStatus;                  // 设备管理的所有车位的综合状态
	EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
	EM_PARKINGSPACE_STATUS   emCurParkingSpaceStatus;				// 对应当前车位号的车位状态
	NET_FEATUREPIC_AREA		 stuParkingInfo;						// 车位抠图信息坐标，现有支持4个顶点，绝对坐标，值域由图片的分辨率决定
    DH_RESOLUTION_INFO       stuResolution;                         // 图片分辨率
	BYTE				bReserved[716];								// 保留信息
}DEV_EVENT_TRAFFIC_ANALYSE_PRESNAP_INFO;

//事件类型EVENT_IVS_NEAR_DISTANCE_DETECTION(近距离接触事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_NEAR_DISTANCE_DETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    char                bReserved1[4];                              // 字节对齐
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    ///////////////////////////////以上为公共字段//////////////////////////////
    int                 nAction;                                    // 0:脉冲 1:开始 2:停止
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
    BYTE                bReserved[2048];                            // 保留字节
} DEV_EVENT_NEAR_DISTANCE_DETECTION_INFO;

// 事件类型 EVENT_IVS_FLOATINGOBJECT_DETECTION (漂浮物检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_FLOATINGOBJECT_DETECTION_INFO
{
	int                 nChannelID;                         // 通道号
	int					nAction;							// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	char                szName[128];                        // 事件名称
	double              PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                // 事件发生的时间
	int                 nEventID;                           // 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
	NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
	int                 nDetectRegionNum;                   // 规则检测区域顶点数
	int                 nImageIndex;                        // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
	char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
	UINT				nOccurrenceCount;                   // 事件触发累计次数
	int                 nObjectNum;                         // 检测到的物体个数
	DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	char				szPresetName[64];					// 事件触发的预置名称
	BOOL				bExistFloatingObject;				// 是否存在漂浮物
	NET_EM_EVENT_DATA_TYPE		emEventType;				// 事件数据类型
	float				fCurrentRatio;						// 漂浮物当前占比（相对于检测区域）单位:%, 取值范围[0, 100]
	float				fAlarmThreshold;					// 报警阈值。漂浮物相对于检测区域的占比, 取值范围[0, 100]
	NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;			// 原始图
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;				// 球机变到最小倍下的抓图
	BYTE                byReserved[3956];                   // 保留字节,留待扩展.
} DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO;

// 事件类型 EVENT_IVS_WATER_LEVEL_DETECTION(水位检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WATER_LEVEL_DETECTION_INFO
{
	int							nChannelID;										// 通道号
	int							nAction;										// 0:脉冲 1:开始 2:停止
	char						szName[MAX_EVENT_NAME];							// 事件名称
	double						PTS;											// 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;											// 事件发生的时间
	int							nEventID;										// 事件ID

	DH_EVENT_FILE_INFO			stuFileInfo;									// 事件对应文件信息
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;								// 智能事件公共信息 
	char						szPresetName[64];								// 预置点名称
	char						szObjectUUID[48];								// 智能物体全局唯一物体标识
	NET_EM_EVENT_DATA_TYPE		emEventType;									// 事件数据类型
	NET_EM_WATER_LEVEL_STATUS	emStatus;										// 水位状态
	NET_WATER_RULER				stuWaterRuler;									// 水位尺
	NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;								// 原始图
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;									// 球机变到最小倍下的抓图

	BYTE						byReserved[1024];                               // 保留字节
}DEV_EVENT_WATER_LEVEL_DETECTION_INFO;

// 事件类型 EVENT_IVS_SHIP_DETECTION (船舶检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_SHIP_DETECTION_INFO
{
	int                 nChannelID;                         // 通道号
	int					nAction;							// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	char                szName[128];                        // 事件名称
	double              PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                // 事件发生的时间
	int                 nEventID;                           // 事件ID
	DH_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
	NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
	int                 nDetectRegionNum;                   // 规则检测区域顶点数
	int					nImageIndex;						// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
	int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
	NET_CROSSREGION_DIRECTION_INFO emDirection;             // 表示入侵方向
	NET_CROSSREGION_ACTION_INFO    emActionType;            // 表示检测动作类型
	char                szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
	UINT				nOccurrenceCount;                   // 事件触发累计次数
	int                 nTrackLineNum;                      // 物体运动轨迹顶点数
	NET_POINT			stuTrackLine[DH_MAX_TRACK_LINE_NUM];// 物体运动轨迹
	DH_MSG_OBJECT       stuObject;                          // 检测到的物体
	DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
	int                 nObjectNum;                         // 检测到的物体个数
	int                 nTrackNum;                          // 轨迹数(与检测到的物体个数对应)
	DH_POLY_POINTS      stuTrackInfo[HDBJ_MAX_OBJECTS_NUM];	// 轨迹信息(与检测到的物体对应)
	EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
	char				szPresetName[64];					// 事件触发的预置名称
	BOOL				bExistShip;							// 是否存在船舶
	BYTE                bReserved[4096];                    // 保留字节,留待扩展.
} DEV_EVENT_SHIP_DETECTION_INFO;


// 事件类型 EVENT_IVS_HOLD_UMBRELLA (违规撑伞检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_HOLD_UMBRELLA_INFO
{
    int                 nChannelID;                         // 通道号
    int					nAction;						    // 0:脉冲 1:开始 2:停止
    char                szName[128];                        // 事件名称
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    UINT                nEventID;                           // 事件ID    
    DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
    int                 nObjectNum;                         // 检测到的物体个数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    char				szPresetName[64];					// 事件触发的预置名称
    UINT                nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义
    char				szSourceID[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[4092];                    // 保留字节,留待扩展.
} DEV_EVENT_HOLD_UMBRELLA_INFO;

// 事件类型 EVENT_IVS_GARBAGE_EXPOSURE (垃圾暴露检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_GARBAGE_EXPOSURE_INFO
{
    int                 nChannelID;                         // 通道号
    int					nAction;							// 0:脉冲 1:开始 2:停止
    char                szName[128];                        // 事件名称
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    UINT                nEventID;                           // 事件ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
    int                 nObjectNum;                         // 检测到的物体个数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    char				szPresetName[64];					// 事件触发的预置名称
    UINT                nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义 
    char				szSourceID[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[4092];                    // 保留字节,留待扩展.
} DEV_EVENT_GARBAGE_EXPOSURE_INFO;

// 事件类型 EVENT_IVS_DUSTBIN_OVER_FLOW (垃圾桶满溢检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_DUSTBIN_OVER_FLOW_INFO
{
    int                 nChannelID;                         // 通道号
    int					nAction;							// 0:脉冲 1:开始 2:停止
    char                szName[128];                        // 事件名称
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    UINT                nEventID;                           // 事件ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
    int                 nObjectNum;                         // 检测到的物体个数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    char				szPresetName[64];					// 事件触发的预置名称
    UINT                nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义 
    char				szSourceID[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON    
    BYTE                bReserved[4092];                    // 保留字节,留待扩展.
} DEV_EVENT_DUSTBIN_OVER_FLOW_INFO;

// 事件类型 EVENT_IVS_DOOR_FRONT_DIRTY (门前脏乱检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_DOOR_FRONT_DIRTY_INFO
{
    int                 nChannelID;                         // 通道号
    int					nAction;							// 0:脉冲 1:开始 2:停止
    char                szName[128];                        // 事件名称
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    UINT                nEventID;                           // 事件ID
    DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    DH_MSG_OBJECT       stuObjects[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
    int                 nObjectNum;                         // 检测到的物体个数
    EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
    char				szPresetName[64];					// 事件触发的预置名称
    char				szShopAddress[256];					// 商铺地址名称
    UINT                nViolationDuration;                 // 违法持续时长，单位：秒，缺省值0表示无意义 
    char				szSourceID[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
	DWORD               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON   
    BYTE                bReserved[4092];                    // 保留字节,留待扩展.
} DEV_EVENT_DOOR_FRONT_DIRTY_INFO;

// 触发事件的类型
typedef enum tagEM_HELMET_EVENT_TYPE
{
    EM_UNKNOWN_TYPE,
    EM_NOT_WEAR_HELMET,                                 // 未佩戴安全帽
}EM_HELMET_EVENT_TYPE;

// 事件类型 EVENT_IVS_HELMET_DETECTION (安全帽检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_HELMET_DETECTION_INFO
{
    int                     nChannelID;                         // 通道号
    int					    nAction;							// 0:脉冲 1:开始 2:停止
    char                    szName[128];                        // 事件名称
    double                  PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                // 事件发生的时间
    EM_CLASS_TYPE		    emClassType;						// 智能事件所属大类
    UINT                    nEventID;                           // 事件ID
    UINT                    nRuleID;                            // 规则编号
    int                     nObjectID;			                // 目标ID
    DH_EVENT_FILE_INFO	    stuFileInfo;						// 事件对应文件信息
    EM_HELMET_EVENT_TYPE    emHelmetEventType ;                 // 触发事件类型
    HUMAN_IMAGE_INFO        stuHumanImage;                      // 人体图片
    SCENE_IMAGE_INFO        stuSceneImage;                      // 全景广角图    
}DEV_EVENT_HELMET_DETECTION_INFO;

// Mask信息
typedef struct tagNET_CFG_MASK_INFO
{
	UINT					nOffset;							// Mask信息在二进制数据块中的偏移
	UINT					nLength;							// Mask信息大小,单位：字节
	BYTE					byReserved[1016];
}NET_CFG_MASK_INFO;

// 事件类型 EVENT_IVS_DEPOSIT_DETECTION (包裹堆积程度检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_DEPOSIT_DETECTION_INFO
{
    int                 nChannelID;                         // 通道号
    int					nAction;							// 0:脉冲 1:开始 2:停止
    char                szName[128];                        // 事件名称
    double              PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                // 事件发生的时间
    DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
    UINT                nEventID;                           // 事件ID

    int                 nDetectRegionNum;                   // 规则检测区域顶点数
    NET_POINT           DetectRegion[DH_MAX_DETECT_REGION_NUM]; // 规则检测区域
    char                szRegionName[64];                   // 格口名称
    UINT                nStackThreshold;                    // 包裹堆积百分比
    UINT                nGridState;                         // 格口状态 0：未知1：空仓 2：半仓 3：满仓 4： 爆仓     
    NET_INTELLIGENCE_IMAGE_INFO    stuSceneImage;           // 全景大图信息
    NET_INTELLIGENCE_IMAGE_INFO    stuDepositImage;         // 格口抠图图片信息
    BYTE			    byReserved[1024];			        // 为图片信息做预留字节，新增的字段请在该保留字节下面添加
	NET_CFG_MASK_INFO	stuMask;							// Mask信息
}DEV_EVENT_DEPOSIT_DETECTION_INFO;

// 事件类型 EVENT_IVS_HOTSPOT_WARNING (热点异常报警事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_HOTSPOT_WARNING_INFO
{
	int                 nChannelID;                         // 通道号
	int					nAction;							// 0:脉冲 1:开始 2:停止
	char                szName[128];                        // 事件名称
	double              PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                // 事件发生的时间
	DH_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
	UINT                nEventID;                           // 事件ID
	
	DH_POINT				stuPoint;						// 热点的坐标,坐标值 0~8192
	float					fHotSpotValue;                  // 热点温度值
	NET_TEMPERATURE_UNIT    nTemperatureUnit;               // 温度单位(当前配置的温度单位)
	BYTE					byReserved[256];				// 保留字节
}DEV_EVENT_HOTSPOT_WARNING_INFO;

// 课堂行为动作类型
typedef enum tagEM_CLASSROOM_ACTION
{
	EM_CLASSROOM_ACTION_UNKNOWN,			// 未知
	EM_CLASSROOM_ACTION_PLAY_PHONE,			// 玩手机
	EM_CLASSROOM_ACTION_HANDSUP,			// 举手
	EM_CLASSROOM_ACTION_LISTEN,				// 听讲
	EM_CLASSROOM_ACTION_READ_WRITE,			// 读写
	EM_CLASSROOM_ACTION_TABLE,				// 趴桌子
} EM_CLASSROOM_ACTION;

// 事件类型 EVENT_IVS_CLASSROOM_BEHAVIOR (课堂行为分析事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_CLASSROOM_BEHAVIOR_INFO
{
	int                 			nChannelID;                         		// 通道号
    int								nAction;									// 0:脉冲 1:开始 2:停止
    char                			szName[128];                         		// 事件名称
    double              			PTS;                                		// 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                                		// 事件发生的时间
    UINT                			nEventID;                           		// 事件ID
    DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息

	EM_CLASS_TYPE		            emClassType;						        // 智能事件所属大类
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	UINT							nObjectID;									// 物体ID
	UINT							nSequence;									// 帧序号
	EM_CLASSROOM_ACTION				emClassroomAction;							// 课堂行为动作
	NET_POINT           			stuDetectRegion[DH_MAX_DETECT_REGION_NUM]; 	// 规则检测区域
	int                 			nDetectRegionNum;                   		// 规则检测区域顶点数
	UINT							nPresetID;									// 事件触发的预置点号
	char							szPresetName[64];							// 事件触发的预置点名称
	char							szSerialUUID[22];							// 智能物体全局唯一物体标识
																				// 格式如下：前2位%d%d:01-视频片段,02-图片,03-文件,99-其他;
																				//中间14位YYYYMMDDhhmmss:年月日时分秒;后5位%u%u%u%u%u：物体ID，如00001
	BYTE			    			byReserved1[2];								// 用于字节对齐 
    DH_RECT             			stuBoundingBox;                        		// 包围盒
    NET_INTELLIGENCE_IMAGE_INFO		stuSceneImage;           					// 人脸底图信息
    NET_INTELLIGENCE_IMAGE_INFO    	stuFaceImage;         						// 人脸小图信息
    NET_FACE_ATTRIBUTE_EX			stuFaceAttributes;							// 人脸属性
    BYTE			    			byReserved[1024];			        		// 预留字节
} DEV_EVENT_CLASSROOM_BEHAVIOR_INFO;

// 事件类型 EVENT_IVS_VEHICLE_DISTANCE_NEAR (安全驾驶车距过近报警事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO
{
    int                 nAction;                                    // 事件动作, 0表示脉冲事件, 1表示持续性事件开始, 2表示持续性事件结束;
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                           // GPS信息
    char                szDriverID[32];                             // 司机ID
    char                szVideoPath[256];                           // 违章关联视频FTP上传路径
    BYTE                bReserved[736];                             // 预留字节
} DEV_EVENT_VEHICLE_DISTANCE_NEAR_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_DRIVER_ABNORMAL (驾驶员异常报警事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO
{
    int                 nChannelID;                                // 通道号
    int					nAction;							       // 事件动作, 0表示脉冲事件, 1表示持续性事件开始, 2表示持续性事件结束
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                          // GPS信息
    NET_TIME_EX         UTC;							           // 事件发生的时间
    char                szVideoPath[256];                          // 违章关联视频FTP上传路径
    BYTE                bReserved[768];                            // 预留字节
} DEV_EVENT_TRAFFIC_DRIVER_ABNORMAL_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_DRIVER_CHANGE (驾驶员变更报警事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO
{
    int                 nChannelID;                                // 通道号
    int					nAction;							       // 事件动作, 0表示脉冲事件, 1表示持续性事件开始, 2表示持续性事件结束
    NET_GPS_STATUS_INFO stuGPSStatusInfo;                          // GPS信息
    NET_TIME_EX         UTC;							           // 事件发生的时间
    char                szPrevDriverID[MAX_COMMON_STRING_32];      // 驾驶员更换前驾驶员ID
    char                szCurDriverID[MAX_COMMON_STRING_32];       // 驾驶员更换后驾驶员ID
    char                szVideoPath[256];                          // 违章关联视频FTP上传路径
    BYTE                bReserved[768];                            // 预留字节
} DEV_EVENT_TRAFFIC_DRIVER_CHANGE_INFO;

// 安全帽佩戴状态
typedef enum tagEM_WORK_HELMET_STATE
{
	EM_HELMET_STATE_UNKNOWN,		// 未知
	EM_HELMET_STATE_NOTWEAR,		// 不带安全帽
	EM_HELMET_STATE_WEAR,			// 有带安全帽
} EM_WORK_HELMET_STATE;

// 安全帽属性
typedef struct tagNET_HELMET_ATTRIBUTE
{
	EM_WORK_HELMET_STATE			emHelmetState;								// 安全帽佩戴状态
	EM_CLOTHES_COLOR				emHelmetColor;								// 安全帽颜色
	BYTE			    			byReserved[1024];			        		// 预留字节
} NET_HELMET_ATTRIBUTE;

// 工作服穿戴状态
typedef enum tagEM_WORKCLOTHES_STATE
{
	EM_WORKCLOTHES_STATE_UNKNOWN,		// 未知
	EM_WORKCLOTHES_STATE_NOTWEAR,		// 无工作服
	EM_WORKCLOTHES_STATE_WEAR,			// 有工作服
} EM_WORKCLOTHES_STATE;

// 工作服属性
typedef struct tagNET_WORKCLOTHES_ATTRIBUTE
{
	EM_WORKCLOTHES_STATE			emWorkClothesState;							// 工作服穿戴状态
	EM_CLOTHES_COLOR				emWorkClothColor;							// 工作服颜色
	BYTE			    			byReserved[1024];			        		// 预留字节
} NET_WORKCLOTHES_ATTRIBUTE;

// 事件类型EVENT_IVS_WORKCLOTHES_DETECT(工装(安全帽/工作服等)检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WORKCLOTHES_DETECT_INFO
{
	int                 			nChannelID;                         		// 通道号
    int								nAction;									// 0:脉冲 1:开始 2:停止
    char                			szName[128];                         		// 事件名称
    double              			PTS;                                		// 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                                		// 事件发生的时间
    UINT                			nEventID;                           		// 事件ID

	EM_CLASS_TYPE				    emClassType;								// 智能事件所属大类
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	UINT							nObjectID;									// 物体ID
	UINT							nGroupID;									// 事件组ID，一次检测的多个nGroupID相同
	UINT							nCountInGroup;								// 一个事件组内的抓拍张数,一次检测的多个nCountInGroup相同
	UINT							nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
    SCENE_IMAGE_INFO				stuSceneImage;           					// 全景大图信息
    HUMAN_IMAGE_INFO    			stuHumanImage;         						// 人体小图信息
    NET_HELMET_ATTRIBUTE			stuHelmetAttribute;							// 安全帽属性
    NET_WORKCLOTHES_ATTRIBUTE		stuWorkClothesAttribute;					// 工作服属性
    BYTE			    			byReserved[1024];			        		// 预留字节
} DEV_EVENT_WORKCLOTHES_DETECT_INFO;

// 安全门人员通过方向
typedef enum tagEM_SECURITYGATE_PERSON_PASS_DIRECTION
{
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_UNKNOWN = 0,	// 未知
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_IN,			// 进入
	EM_SECURITYGATE_PERSON_PASS_DIRECTION_OUT,			// 离开
}EM_SECURITYGATE_PERSON_PASS_DIRECTION;

// 安全门人员报警级别
typedef enum tagEM_SECURITYGATE_ALARM_LEVEL
{
	EM_SECURITYGATE_ALARM_LEVEL_UNKNOWN = 0,			    // 未知
	EM_SECURITYGATE_ALARM_LEVEL_NON,					// 无报警
	EM_SECURITYGATE_ALARM_LEVEL_LOW,					// 低危报警级别
	EM_SECURITYGATE_ALARM_LEVEL_MIDDLE,					// 中危报警级别
	EM_SECURITYGATE_ALARM_LEVEL_HIGH,					// 高危报警级别
}EM_SECURITYGATE_ALARM_LEVEL;

// 安全门报警位置
typedef enum tagEM_SECURITYGATE_ALARM_POSITION
{
    EM_SECURITYGATE_ALARM_POSITION_UNKNWON       = -1,       // 未知
    EM_SECURITYGATE_ALARM_POSITION_LEFT_1,                   // 左1
    EM_SECURITYGATE_ALARM_POSITION_LEFT_2,                   // 左2
    EM_SECURITYGATE_ALARM_POSITION_LEFT_3,                   // 左3
    EM_SECURITYGATE_ALARM_POSITION_LEFT_4,                   // 左4
    EM_SECURITYGATE_ALARM_POSITION_LEFT_5,                   // 左5
    EM_SECURITYGATE_ALARM_POSITION_LEFT_6,                   // 左6
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_1,                 // 中1
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_2,                 // 中2
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_3,                 // 中3
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_4,                 // 中4
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_5,                 // 中5
    EM_SECURITYGATE_ALARM_POSITION_MIDDLE_6,                 // 中6
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_1,                  // 右1
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_2,                  // 右2
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_3,                  // 右3
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_4,                  // 右4
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_5,                  // 右5
    EM_SECURITYGATE_ALARM_POSITION_RIGHT_6,                  // 右6
} EM_SECURITYGATE_ALARM_POSITION;

// 事件类型 EVENT_IVS_SECURITYGATE_PERSONALARM （安全门人员报警事件）对应的数据块描述信息
typedef struct tagDEV_EVENT_SECURITYGATE_PERSONALARM_INFO
{
    int                                         nChannelID;                                 // 通道号
    int                                         nAction;                                    // 0:脉冲 1:开始 2:停止
    char                                        szName[DH_EVENT_NAME_LEN];                  // 事件名称
    double                                      PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX                                 UTC;                                        // 时间
    UINT                                        nEventID;                                   // 事件ID
    EM_SECURITYGATE_PERSON_PASS_DIRECTION       emDirection;                                // 人员通过方向
    EM_SECURITYGATE_ALARM_LEVEL                 emAlarmLevel;                               // 报警级别
    int                                         nChannelIn;                                 // 关联进入通道
    int                                         nChannelOut;                                // 关联离开通道
    NET_INTELLIGENCE_IMAGE_INFO                 stuImageInfo;                               // 人脸图片信息
    UINT                                        nAlarmPositionNum;                          // 报警位置个数
    EM_SECURITYGATE_ALARM_POSITION              emAlarmPosition[18];                        // 报警位置
    BYTE                                        bReserved[1020];                            // 保留字节
}DEV_EVENT_SECURITYGATE_PERSONALARM_INFO;


// 人员信息
typedef struct tagNET_HUMAN
{
    NET_RECT            stuBoundingBox;						// 包围盒(8192坐标系)
    UINT                nObjectID;                          // 物体ID
    BYTE                bReserved[252];                     // 保留字节
}NET_HUMAN;

// 事件类型 EVENT_IVS_STAY_ALONE_DETECTION (单人独处事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_STAY_ALONE_DETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    int					nAction;							        // 0:脉冲 1:开始 2:停止
    char                szName[DH_EVENT_NAME_LEN];                  // 事件名称
    double              PTS;                                        // 时间戳(单位是毫秒)
    EM_CLASS_TYPE		emClassType;						        // 智能事件所属大类
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 UTCMS;                                      // UTC时间对应的毫秒数
    int                 nEventID;                                   // 事件ID
    NET_HUMAN           stuHuman;                                   // 人员信息
    SCENE_IMAGE_INFO_EX stuSceneImage;                              // 全景图
    int                 nDetectRegionNum;                           // 检测区域顶点数
    DH_POINT            stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域
    BYTE                byReserved[1024];                           // 保留字节
}DEV_EVENT_STAY_ALONE_DETECTION_INFO;


// 事件类型 EVENT_IVS_TRAFFIC_ROAD_BLOCK (交通路障检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO
{
    int                 nChannelID;                                // 通道号
    int					nAction;							       // 事件动作, 0表示脉冲事件, 1表示持续性事件开始, 2表示持续性事件结束
    char                szName[128];                         	   // 事件名称
    double              PTS;                                	   // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                	   // 事件发生的时间
    UINT                nEventID;                           	   // 事件ID
    DH_EVENT_FILE_INFO	stuFileInfo;							   // 事件对应文件信息
	
    NET_RECT			stuBoundingBox;						       // 物体包围盒
    UINT                nLane;                                     // 车道号
    EVENT_COMM_INFO     stCommInfo;                                // 公共信息
    DWORD               dwSnapFlagMask;                            // 抓图标志(按位),具体见NET_RESERVED_COMMON 
    BYTE                bReserved[4092];                           // 预留字节
} DEV_EVENT_TRAFFIC_ROAD_BLOCK_INFO;

// 事件类型 EVENT_IVS_TRAFFIC_ROAD_CONSTRUCTION (交通道路施工检测事件) 对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO
{
    int                 nChannelID;                                // 通道号
    int					nAction;							       // 事件动作, 0表示脉冲事件, 1表示持续性事件开始, 2表示持续性事件结束
    char                szName[128];                         	   // 事件名称
    double              PTS;                                	   // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                	   // 事件发生的时间
    UINT                nEventID;                           	   // 事件ID
    DH_EVENT_FILE_INFO	stuFileInfo;							   // 事件对应文件信息
	
    NET_RECT			stuBoundingBox;						       // 物体包围盒
    UINT                nLane;                                     // 车道号
    EVENT_COMM_INFO     stCommInfo;                                // 公共信息
    DWORD               dwSnapFlagMask;                            // 抓图标志(按位),具体见NET_RESERVED_COMMON 
    BYTE                bReserved[4092];                           // 预留字节
} DEV_EVENT_TRAFFIC_ROAD_CONSTRUCTION_INFO;

// 作业行为状态信息
typedef enum tagEM_WORKACTION_STATE
{
	EM_WORKACTION_STATE_UNKNOWN,			// 未知
	EM_WORKACTION_STATE_NO_WORKER,			// 无人作业
	EEM_WORKACTION_STATE_SINGLE_WORKER,		// 单人作业
	EM_WORKACTION_STATE_NORED_VEST,			// 无红马甲作业
} EM_WORKACTION_STATE;

// 事件类型EVENT_IVS_WORKSTATDETECTION(作业统计事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WORKSTATDETECTION_INFO
{
	int                 			nChannelID;                         		// 通道号
    int								nAction;									// 0:脉冲 1:开始 2:停止
    char                			szName[128];                         		// 事件名称
    double              			PTS;                                		// 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                                		// 事件发生的时间
    UINT                			nEventID;                           		// 事件ID

	EM_CLASS_TYPE				    emClassType;								// 智能事件所属大类
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	UINT							nObjectID;									// 物体ID
	UINT							nWorkActionNum;								// 作业行为状态个数
	EM_WORKACTION_STATE				emWorkAction[32];							// 作业行为状态信息
	SCENE_IMAGE_INFO				stuSceneImage;           					// 全景大图信息
	BYTE			    			byReserved[1024];			        		// 预留字节
} DEV_EVENT_WORKSTATDETECTION_INFO;

// 人脸属性
typedef struct tagNET_FACE_ATTRIBUTES
{
    int                             nAngle[3];              // 人脸抓拍角度,三个角度分别是：仰俯角,偏航角,翻滚角；默认值[999,999,999]表示无此数据
    UINT                            nFaceQuality;           // 人脸抓拍质量分数,取值范围 0~10000
    int                             nFaceAlignScore;        // 人脸对齐得分分数,取值范围 0~10000，-1为无效值
    BYTE			    			byReserved[36];	        // 预留字节
}NET_FACE_ATTRIBUTES;

// 特征值信息
typedef struct tagNET_FEATURE_VECTOR_INFO
{
    char                            szFeatureVersion[32];   // 特征版本版本号
    EM_FEATURE_ERROR_CODE           emFeatureErrCode;       // 特征建模失败错误码
    NET_FEATURE_VECTOR              stuFeatureVector;       // 特征值的偏移和大小信息
    NET_FACE_ATTRIBUTES             stuFaceAttribute;       // 人脸属性 ,当提取人脸特征向量成功时上报        
    BYTE			    			byReserved[968];	    // 预留字节
}NET_FEATURE_VECTOR_INFO;

// 事件类型EM_ANALYSE_EVENT_FEATURE_ABSTRACT(特征提取)对应的数据块描述信息
typedef struct tagDEV_EVENT_FEATURE_ABSTRACT_INFO
{
    int                 			nChannelID;                         		// 通道号
    int								nAction;									// 0:脉冲 1:开始 2:停止
    EM_CLASS_TYPE                   emClassType;                           		// 智能事件所属大类
    UINT                            nFeatureNum;                                // 特征值数量
    NET_FEATURE_VECTOR_INFO         stuFeatureVectorList[10];                   // 特征值数组，同一个图片需要进行多个版本的特征向量提取，在一个事件中返回
    BYTE			    			byReserved[1024];			        		// 预留字节
} DEV_EVENT_FEATURE_ABSTRACT_INFO;

// 全景抓拍触发类型
typedef enum tagEM_TRIGGER_EVENT_TYPE
{
	EM_TRIGGER_EVENT_TYPE_UNKNOWN,		// 未知
	EM_TRIGGER_EVENT_TYPE_PTZ_PRESET,	// 云台预置点触发
	EM_TRIGGER_EVENT_TYPE_FIREWARNING,	// 火情触发
	EM_TRIGGER_EVENT_TYPE_MOVE_ABSOLUTELY,// 绝对移动定位触发
} EM_TRIGGER_EVENT_TYPE;

// 事件类型EVENT_IVS_PANORAMA_SHOT(全景抓拍)对应的数据块描述信息
typedef struct tagDEV_EVENT_PANORAMA_SHOT_INFO
{
	int						nChannelID;                 // 通道号

	char					szStationID[64];			// 站点ID
	char					szPictureID[128];			// 影像ID
	NET_TIME_EX				stuLocalSnapshotTime;		// 本地抓拍时间	
	int						nPitchAngleInSnapping;		// 抓拍时的俯仰角(角度精确到0.1度)，范围：【-1800~1800】，对应实际的【-180.0~180.0】度（度数扩大10倍表示）
	int						nHorizontalAngleInSnapping;	// 抓拍时的水平角度(角度精确到0.1度)，范围：【0~3599】，对应实际【0~359.9度】（度数扩大10倍表示） 
	EM_TRIGGER_EVENT_TYPE	emTriggerEventType;			// 全景抓拍类型
	DWORD					dwFireID;					// 火情ID（触发事件类型为火情触发有效）
	NET_RECT				stuFireBoundingBox;			// 火情边界框（触发事件类型为火情触发有效）				
	BYTE					byReserved[1024];			// 预留字节
} DEV_EVENT_PANORAMA_SHOT_INFO;

// 事件类型EVENT_IVS_INTELLI_SHELF(智能补货事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_INTELLI_SHELF_INFO
{
    int                 			nChannelID;                         		// 通道号
    int								nAction;									// 0:脉冲 1:开始 2:停止
    char                			szName[128];                         		// 事件名称
    double              			PTS;                                		// 时间戳(单位是毫秒)
    NET_TIME_EX         			UTC;                                		// 事件发生的时间
    UINT                			nEventID;                           		// 事件ID
    EM_CLASS_TYPE				    emClassType;								// 智能事件所属大类

    UINT                            nAreaID;                                    // 区域ID（从1开始）, 0为单区域
    UINT                            nPresetID;                                  // 事件触发的预置点号，从1开始
    int                             nPercent;                                   // 表示货架上剩余货物的百分比
    SCENE_IMAGE_INFO_EX             stuSceneImage;                              // 全景大图
	BYTE			    			byReserved1[4];								// 预留字节用于字节对齐
    BYTE			    			byReserved[1024];			        		// 预留字节
} DEV_EVENT_INTELLI_SHELF_INFO;

// 车辆行驶方向
typedef enum tagEM_DRIVING_DIRECTION
{
	EM_DRIVING_DIRECTION_UNKNOWN = 0,								// 未知 
	EM_DRIVING_DIRECTION_IN,										// 驶入
	EM_DRIVING_DIRECTION_OUT,										// 驶出
}EM_DRIVING_DIRECTION;


// 事件类型EVENT_IVS_CAR_DRIVING_IN_OUT(车辆驶入驶出状态事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CAR_DRIVING_IN_OUT_INFO
{
	int                 nChannelID;                                 // 通道号
	int                 nEventID;                                   // 事件ID
	char                szName[128];                                // 事件名称
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	DH_MSG_OBJECT       stuObject;                                  // 车牌信息
	DH_MSG_OBJECT       stuVehicle;                                 // 车身信息
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
	int					nSequence;									// 表示抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
	int					nFrameSequence;								// 帧序号
	EM_DRIVING_DIRECTION emDrivingDirection;						// 车辆行驶方向
	NET_EVENT_IMAGE_OFFSET_INFO	stuGlobalScene;						// 大图信息
	NET_EVENT_IMAGE_OFFSET_INFO	stuParkingImage;					// 车位抠图信息
	char				szParkingNum[32];							// 车位(地磁)编号 
	BYTE				byReserved[512];							// 预留字节
}DEV_EVENT_CAR_DRIVING_IN_OUT_INFO;

// 事件类型EVENT_IVS_PARKINGSPACE_STATUS(停车位状态事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_PARKINGSPACE_STATUS_INFO
{
	int                 nChannelID;                                 // 通道号
	int                 nEventID;                                   // 事件ID
	char                szName[128];                                // 事件名称
	double              PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 

	int					nSource;									// 视频分析的数据源地址
	int					nFrameSequence;								// 帧序号

	int					nMark;										// 用于标记抓拍帧
	EM_PARKINGSPACE_STATUS emParkingSpaceStatus;					// 车位的状态
	char				szParkingNum[32];							// 车位(地磁)编号 
	char				szText[32];									// 车牌号码 
	BYTE				byReserved[512];							// 预留字节
}DEV_EVENT_PARKINGSPACE_STATUS_INFO;


// 目标关联信息
typedef struct tagOBJECT_RELATED_INFO
{
	UINT							nObjectID;									// 物体ID
	UINT							nRelativeID;								// 相关物体ID
	char							szObjectType[128];							// 物体类型,如"HumanFace"
	NET_RECT						stuBoundingBox;								// 物体包围盒，坐标[0, 8192]
	NET_RECT						stuOriginalBoundingBox;						// 原始物体包围盒，坐标[0, 8192]
	BYTE							byReserved[1024];							// 预留字段
}OBJECT_RELATED_INFO;

// 事件类型EVENT_IVS_FACEBODY_DETECT(人像检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FACEBODY_DETECT_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nObjectID;									// 物体ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	UINT							nSequence;									// 帧序号
	int								nGroupID;									// 事件组ID，一次检测的多个nGroupID相同
	int								nCountInGroup;								// 一个事件组内的抓拍张数,一次检测的多个nCountInGroup相同
	int								nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
	BYTE							byReserved1[4];								// 字节对齐
	FACE_TRAIT						stuFaceTrait;								// 人脸特征
	BODY_TRAIT						stuBodyTrait;								// 人体特征
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;								// 人体图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 								// 人脸图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;								// 全景图片信息
	OBJECT_RELATED_INFO				stuFaceObject;								// 人脸关联信息
	OBJECT_RELATED_INFO				stuBodyObject;								// 人体关联信息
}DEV_EVENT_FACEBODY_DETECT_INFO;


// 事件类型EVENT_IVS_FACEBODY_ANALYSE(人像识别事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_FACEBODY_ANALYSE_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nObjectID;									// 物体ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	UINT							nSequence;									// 帧序号
	int								nGroupID;									// 事件组ID，一次检测的多个nGroupID相同
	int								nCountInGroup;								// 一个事件组内的抓拍张数,一次检测的多个nCountInGroup相同
	int 							nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
	BYTE							byReserved1[4];								// 字节对齐
	FACE_TRAIT						stuFaceTrait;								// 人脸特征
	BODY_TRAIT						stuBodyTrait;								// 人体特征
	NET_EVENT_IMAGE_OFFSET_INFO		stuBodyImage;								// 人体图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuFaceImage; 								// 人脸图片信息
	NET_EVENT_IMAGE_OFFSET_INFO		stuSceneImage;								// 全景图片信息
	OBJECT_RELATED_INFO				stuFaceObject;								// 人脸关联信息
	OBJECT_RELATED_INFO				stuBodyObject;								// 人体关联信息
	CANDIDATE_INFOEX				stuCandidate[DH_MAX_CANDIDATE_NUM];			// 候选人脸列表
	int								nCandidateNum;								// 返回的候选人脸个数
}DEV_EVENT_FACEBODY_ANALYSE_INFO;

// 事件类型EVENT_IVS_CONGESTION_DETECTION(道路场景车辆拥堵报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_CONGESTION_DETECTION_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	int 							nPresetID;									// 事件触发的预置点号，从1开始
	char							szPresetName[64];							// 事件触发的预置名称
	int								nAlarmMask;									// 报警业务掩码, 不同掩码位表示不同报警类型：bit0位表示是否有拥堵报警；bit1位表示是否有排队报警；
	int								nVehicleQuantity;							// 拥堵车辆数量
	int								nQueueLength;								// 车辆排队长度
	int								nDetectRegionNum;							// stuDetectRegion中有效坐标点个数
	DH_POINT						stuDetectRegion[32];						// 发生报警的区域坐标
	BYTE			    			byReserved[1024];			        		// 预留字节
}DEV_EVENT_CONGESTION_DETECTION_INFO;

// 事件类型EVENT_IVS_VEHICLELIMIT_DETECTION(停车场场景下停车车辆上限报警)对应的数据块描述信息
typedef struct tagDEV_EVENT_VEHICLELIMIT_DETECTION_INFO
{
	int                 			nChannelID;                                 // 通道号
	int								nAction;									// 1:开始 2:停止
	char                			szName[128];                                // 事件名称
	double              			PTS;                                        // 时间戳(单位是毫秒)
	NET_TIME_EX         			UTC;                                        // 事件发生的时间
	DH_EVENT_FILE_INFO				stuFileInfo;								// 事件对应文件信息
	EM_CLASS_TYPE					emClassType;								// 智能事件所属大类
	UINT                			nEventID;                           		// 事件ID
	UINT							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	int 							nPresetID;									// 事件触发的预置点号，从1开始
	char							szPresetName[64];							// 事件触发的预置名称
	int								nVehicleQuantity;							// 车辆数量
	int								nDetectRegionNum;							// stuDetectRegion中有效坐标点个数
	DH_POINT						stuDetectRegion[32];						// 发生报警的区域坐标
	BYTE			    			byReserved[1024];			        		// 预留字节
}DEV_EVENT_VEHICLELIMIT_DETECTION_INFO;

// 事件类型EVENT_IVS_VIOLENT_THROW_DETECTION(暴力抛物检测)对应的数据块描述信息
typedef struct tagDEV_EVENT_VIOLENT_THROW_DETECTION_INFO
{
    int                 nChannelID;                                 // 通道号
    int					nAction;									// 0:脉冲 1:开始 2:停止
    char                szName[128];                                // 事件名称
    double              PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX         UTC;                                        // 事件发生的时间
    int                 nEventID;                                   // 事件ID
    DH_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息 
    
	int                 nFrameSequence;                             // 视频分析帧序号
    char                szRegionName[64];                           // 暴力抛物检测区域名称 
    SCENE_IMAGE_INFO_EX stuSceneImage;                              // 大图信息
	BYTE				byReserver[1028];							// 保留字节
}DEV_EVENT_VIOLENT_THROW_DETECTION_INFO;

// 事件类型EVENT_IVS_TRAMCARSECTIONS_DETECTION(矿车超挂报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO
{
	int							nChannelID;                         // 通道号
	int							nAction;							// 0:脉冲 1:开始 2:停止
	char						szName[128];                        // 事件名称
	double						PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX					UTC;                                // 事件发生的时间
	int							nEventID;                           // 事件ID

	UINT						nRuleID;							// 智能事件规则编号，用于标示哪个规则触发的事件
	EM_CLASS_TYPE				emClassType;						// 智能事件所属大类
	int							nSequence;							// 帧序号

	UINT						nCarSections;						// 当前车节数
	NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;						// 全景广角图
	BYTE						byReserved[512];					// 预留字节
}DEV_EVENT_TRAMCARSECTIONS_DETECTION_INFO;

// 动物统计信息
typedef struct tagNET_ANIMAL_OBJECTS_STATISTICS
{
    UINT                nAnimalsAmount;     // 动物总数
    BYTE                bReserved[132];     // 保留字节
}NET_ANIMAL_OBJECTS_STATISTICS;


// 动物检测的大图信息
typedef struct tagNET_ANIMAL_SCENE_IMAGE_INFO
{
    UINT				nOffSet;			// 在二进制数据块中的偏移   
    UINT				nLength;		    // 图片大小,单位字节
    BYTE                bReserved[256];     // 保留字节
}NET_ANIMAL_SCENE_IMAGE_INFO;

// 事件类型EVENT_IVS_ANIMAL_DETECTION(动物检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ANIMAL_DETECTION_INFO
{
    int							    nChannelID;                         // 通道号
    int							    nAction;							// 0:脉冲 1:开始 2:停止
    char						    szName[128];                        // 事件名称
    double						    PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX					    UTC;                                // 事件发生的时间
    int							    nEventID;                           // 事件ID

    UINT						    nRuleID;							// 智能事件规则编号，用于标示哪个规则触发的事件
    int							    nSequence;							// 帧序号
    NET_ANIMAL_SCENE_IMAGE_INFO	    stuSceneImage;						// 全景广角图
    NET_ANIMAL_OBJECTS_STATISTICS   stuObjectsStatistics;               // 动物统计信息
	EM_CLASS_TYPE				    emClassType;						// 智能事件所属大类
    BYTE						    byReserved[516];					// 预留字节
}DEV_EVENT_ANIMAL_DETECTION_INFO;

// 车辆动作
typedef enum tagEM_VEHICLE_ACTION
{
    EM_VEHICLE_ACTION_UNKNOWN,          // 未知
    EM_VEHICLE_ACTION_APPEAR,           // 进入检测区域内
    EM_VEHICLE_ACTION_DISAPPEAR,        // 离开检测区域
    EM_VEHICLE_ACTION_STAY,             // 停留在检测区域内
} EM_VEHICLE_ACTION;

// 车辆动作

// 检测到的车辆信息
typedef struct tagNET_DETECT_VEHICLE_INFO
{
    EM_VEHICLE_ACTION       emAction;               // 检测车辆动作
    UINT                    nObjectID;              // 物体ID
    EVENT_PIC_INFO          stuVehicleImage;        // 车辆抓图信息
    NET_COLOR_RGBA          stuColor;               // 车身主要颜色
    EM_CATEGORY_TYPE        emCategoryType;         // 车辆类型
    UINT                    nFrameSequence;         // 帧序号
    UINT                    nCarLogoIndex;          // 车辆车标
    UINT                    nSubBrand;              // 车辆子品牌
    UINT                    nBrandYear;             // 车辆品牌年款
    UINT                    nConfidence;            // 置信度,值越大表示置信度越高, 范围 0~255
    NET_RECT                stuBoundingBox;         // 包围盒, 0-8191相对坐标
    char                    szText[128];            // 车标
    UINT                    nSpeed;                 // 车速,单位为km/h
    UINT                    nDirection;             // 车辆行驶方向, 0:未知, 1:上行方向, 2:下行方向
    BYTE                    bReserved[512];         // 保留字节
} NET_DETECT_VEHICLE_INFO;

// 检测的车牌信息
typedef struct tagNET_DETECT_PLATE_INFO
{
    UINT                    nObjectID;              // 车牌ID
    UINT                    nRelativeID;            // 关联的车辆ID
    EVENT_PIC_INFO          stuPlateImage;          // 车牌图片信息
    EM_NET_PLATE_TYPE       emPlateType;            // 车牌类型
    EM_NET_PLATE_COLOR_TYPE emPlateColor;           // 车牌颜色
    UINT                    nConfidence;            // 置信度,值越大表示置信度越高, 范围 0~255
    char                    szCountry[3];           // 车牌国家
    BYTE                    bReserved1;             // 字节对齐
    char                    szPlateNumber[128];     // 车牌号码
    BYTE                    bReserved[512];         // 保留字节
} NET_DETECT_PLATE_INFO;

// 事件类型EVENT_IVS_GASSTATION_VEHICLE_DETECT(加油站车辆检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO
{
    int                         nChannelID;                                 // 通道号
    int                         nAction;                                    // 0:脉冲 1:开始 2:停止
    char                        szName[128];                                // 事件名称
    double                      PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                                        // 事件发生的时间
    int                         nEventID;                                   // 事件ID

    UINT                        nRuleID;                                    // 智能事件规则编号，用于标示哪个规则触发的事件
    EM_CLASS_TYPE               emClassType;                                // 智能事件所属大类

    NET_DETECT_VEHICLE_INFO     stuDetectVehicleInfo;                       // 检测到的车辆信息
    NET_DETECT_PLATE_INFO       stuDetectPlateInfo;                         // 检测到的车牌信息
    BOOL                        bIsGlobalScene;                             // 是否有场景图
    EVENT_PIC_INFO              stuSceneImage;                              // 场景图信息, bIsGlobalScene 为 TRUE 时有效
    int                         nCarCandidateNum;                           // 候选车辆数量    
    NET_CAR_CANDIDATE_INFO      stuCarCandidate[MAX_CAR_CANDIDATE_NUM];     // 候选车辆数据
    BYTE                        bReserved[1024];                            // 保留字节
} DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO;


// 事件类型EVENT_IVS_SHOP_WINDOW_POST(橱窗张贴事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SHOP_WINDOW_POST_INFO
{
    int                         nChannelID;                                 // 通道号
    int                         nAction;                                    // 0:脉冲 1:开始 2:停止
    char                        szName[128];                                // 事件名称
    double                      PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                                        // 事件发生的时间
    int                         nEventID;                                   // 事件ID
    UINT                        nRuleID;                                    // 智能事件规则编号，用于标示哪个规则触发的事件
    EM_CLASS_TYPE               emClassType;                                // 智能事件所属大类
    DH_EVENT_FILE_INFO          stuFileInfo;                                // 事件对应文件信息 

    int                         nDetectRegionNum;                           // 检测区域顶点数
    DH_POINT                    stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域
    int					        nObjectNum;									// 检测到的物体个数
    DH_MSG_OBJECT		        stuObjects[HDBJ_MAX_OBJECTS_NUM];			// 检测到的物体
    
    UINT                        nPresetID;                                  // 事件触发的预置点号，从1开始
    char                        szPresetName[64];                           // 事件触发的预置点名称
    char                        szShopAddress[256];                         // 商铺地址
    UINT                        nViolationDuration;                         // 违法持续时长，单位：秒,缺省值0表示无意义
    DWORD                       dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE                        bReserved[1024];                            // 保留字节
} DEV_EVENT_SHOP_WINDOW_POST_INFO;

// 事件类型EVENT_IVS_SHOP_SIGN_ABNORMAL(店招异常事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SHOP_SIGN_ABNORMAL_INFO
{
    int                         nChannelID;                                 // 通道号
    int                         nAction;                                    // 0:脉冲 1:开始 2:停止
    char                        szName[128];                                // 事件名称
    double                      PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                                        // 事件发生的时间
    int                         nEventID;                                   // 事件ID
    UINT                        nRuleID;                                    // 智能事件规则编号，用于标示哪个规则触发的事件
    EM_CLASS_TYPE               emClassType;                                // 智能事件所属大类
    DH_EVENT_FILE_INFO          stuFileInfo;                                // 事件对应文件信息 

    int                         nDetectRegionNum;                           // 检测区域顶点数
    DH_POINT                    stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域
    int					        nObjectNum;									// 检测到的物体个数
    DH_MSG_OBJECT		        stuObjects[HDBJ_MAX_OBJECTS_NUM];			// 检测到的物体

    UINT                        nPresetID;                                  // 事件触发的预置点号，从1开始
    char                        szPresetName[64];                           // 事件触发的预置点名称
    char                        szShopAddress[256];                         // 商铺地址
    UINT                        nViolationDuration;                         // 违法持续时长，单位：秒,缺省值0表示无意义
    DWORD                       dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE                        bReserved[1024];                            // 保留字节
} DEV_EVENT_SHOP_SIGN_ABNORMAL_INFO;

// 智慧养殖检测目标子类型
typedef enum tagEM_BREED_DETECT_CATEGORY_TYPE
{
    EM_BREED_DETECT_CATEGORY_UNKNOWN,                   // 未知
    EM_BREED_DETECT_CATEGORY_PIG,                       // 猪
} EM_BREED_DETECT_CATEGORY_TYPE;

// 智慧养殖对象信息
typedef struct tagNET_VAOBJECT_ANIMAL_INFO
{
    UINT                            nObjectID;              // 物体ID，每个ID表示一个唯一的物体
    EM_BREED_DETECT_CATEGORY_TYPE   emCategoryType;         // 智慧养殖检测目标子类型
    NET_RECT                        stuBoundingBox;         // 包围盒
    UINT                            nObjectWeight;          // 对象重量, 单位: g
    SCENE_IMAGE_INFO_EX             stuImageData;           // 物体截图
    BYTE                            byReserved[1024];       // 预留字节
} NET_VAOBJECT_ANIMAL_INFO;

// 事件类型EVENT_IVS_BREED_DETECTION(智慧养殖检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_BREED_DETECTION_INFO
{
    int                         nChannelID;                         // 通道号
    int                         nAction;                            // 0:脉冲 1:开始 2:停止
    char                        szName[128];                        // 事件名称
    double                      PTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                                // 事件发生的时间
    int                         nEventID;                           // 事件ID

    UINT                        nRuleID;                            // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                          // 帧序号
    EM_CLASS_TYPE               emClassType;                        // 智能事件所属大类
    SCENE_IMAGE_INFO_EX         stuSceneImage;                      // 全景广角图
    BYTE                        byReserved1[4];                     // 字节对齐
    UINT                        nObjectNum;                         // 检测到的物体个数
    NET_VAOBJECT_ANIMAL_INFO    stuObjects[64];                     // 检测到的物体信息
    BYTE                        byReserved[512];                    // 预留字节
} DEV_EVENT_BREED_DETECTION_INFO;

// 保障车类型
typedef enum tagEM_AIRPORT_VEHICLE_TYPE
{
	EM_AIRPORT_VEHICLE_TYPE_UNKNOWN = 0,							// 未知
	EM_AIRPORT_VEHICLE_TYPE_TANKER,									// 航油车
	EM_AIRPORT_VEHICLE_TYPE_CONVEYORCAR,							// 行李传送带车
	EM_AIRPORT_VEHICLE_TYPE_TRAILERCAR,								// 行李拖车
}EM_AIRPORT_VEHICLE_TYPE;

// 保障车动作
typedef enum tagEM_AIRPORT_VEHICLE_ACTION
{
	EM_AIRPORT_VEHICLE_ACTION_UNKNOWN = 0,							// 未知
	EM_AIRPORT_VEHICLE_ACTION_ENTERREGION,							// 进入区域
	EM_AIRPORT_VEHICLE_ACTION_LEAVEREGION,							// 离开区域
	EM_AIRPORT_VEHICLE_ACTION_STARTWORK,							// 开始工作
	EM_AIRPORT_VEHICLE_ACTION_OVERWORK,								// 结束工作
	EM_AIRPORT_VEHICLE_ACTION_AIRREFUEL,							// 飞机加油
	EM_AIRPORT_VEHICLE_ACTION_OVERREFUEL,							// 结束加油
}EM_AIRPORT_VEHICLE_ACTION;

// 机场保障车对象
typedef struct tagNET_AIRPORT_VEHICLE_OBJECT
{
	int								nObjectID;						// 物体ID
	EM_AIRPORT_VEHICLE_TYPE			emType;							// 保障车类型
	NET_RECT						stuRect;						// 保障车位置
	EM_AIRPORT_VEHICLE_ACTION		emAction;						// 保障车动作
	BYTE							byReserved[1020];				// 预留字节
}NET_AIRPORT_VEHICLE_OBJECT;

// 事件类型EVENT_IVS_AIRPORT_VEHICLE_DETECT(机场智能保障车辆检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_AIRPORT_VEHICLE_DETECT_INFO
{
    int                         nChannelID;									// 通道号
    int                         nAction;									// 0:脉冲 1:开始 2:停止
    char                        szName[128];								// 事件名称
    double                      PTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;										// 事件发生的时间
    int                         nEventID;									// 事件ID

    UINT                        nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;									// 帧序号
    EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
	int                         nDetectRegionNum;                           // 检测区域顶点数
	DH_POINT                    stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域,[0,8192)
	SCENE_IMAGE_INFO_EX         stuSceneImage;								// 全景广角图
	int 						nVehicleObjectNum;							// 检测到的保障车个数
	NET_AIRPORT_VEHICLE_OBJECT	stuVehicleObjects[MAX_AIRPORT_VEHICLE_OBJECT_NUM];	// 检测保障车列表
    BYTE                        byReserved[504];							// 预留字节
} DEV_EVENT_AIRPORT_VEHICLE_DETECT_INFO;


// 事件类型EVENT_IVS_MAN_CAR_COEXISTANCE(人车共存事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_MAN_CAR_COEXISTANCE_INFO
{
    int                         nChannelID;									// 通道号
    int                         nAction;									// 0:脉冲 1:开始 2:停止
    char                        szName[128];								// 事件名称
    double                      PTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;										// 事件发生的时间
    int                         nEventID;									// 事件ID
    
    UINT                        nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;									// 帧序号
    EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
    DWORD                       dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    SCENE_IMAGE_INFO			stuSceneImage;						        // 全景广角图
    BYTE                        byReserved[512];							// 预留字节
}DEV_EVENT_MAN_CAR_COEXISTANCE_INFO;

// 车位当前状态
typedef enum tagEM_PARKING_STATE
{
    EM_PARKING_STATE_UNKNOWN = -1,               // 未知
    EM_PARKING_STATE_FREE,                       // 空闲
    EM_PARKING_STATE_BUSY,                       // 被占用
} EM_PARKING_STATE;

// 车位状态相对上次上报的变化状态
typedef enum tagEM_PARKING_CHANGE_STATUS
{
    EM_PARKING_CHANGE_STATUS_UNKNOWN = -1,               // 未知
    EM_PARKING_CHANGE_STATUS_NO_CHANGE,                  // 无变化
    EM_PARKING_CHANGE_STATUS_FREE_TO_BUSY,               // 空闲到占用
    EM_PARKING_CHANGE_STATUS_BUSY_TO_FREE,               // 占用到空闲
} EM_PARKING_CHANGE_STATUS;

// 室外停车位状态
typedef struct tagNET_PARKING_STATUS
{
    char                                              szName[32];                                               // 车位名称
    int                                               nID;                                                      // 车位ID，范围:[0,99]
    EM_PARKING_STATE                                  emStatus;                                                 // 车位当前状态
    EM_PARKING_CHANGE_STATUS                          emChangeStatus;                                           // 车位状态相对上次上报的变化状态
    BYTE                                              reserved[252];                                            // 预留字节
} NET_PARKING_STATUS;

//事件类型 EVENT_IVS_PARKING_LOT_STATUS_DETECTION(室外停车位状态检测)对应的数据块描述信息
typedef struct tagDEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO
{
    int                         nChannelID;                                 // 通道号
    int                         nAction;                                    // 0:脉冲 1:开始 2:停止
    char                        szName[128];                                // 事件名称
    EM_CLASS_TYPE               emClassType;                                // 智能事件所属大类
    NET_TIME_EX                 UTC;                                        // 事件发生的时间
    double                      PTS;                                        // 时间戳(单位是毫秒)
    unsigned int                nEventID;                                   // 事件ID
    UINT                        nRuleID;                                    // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                                  // 帧序号
    int                         nParkingStatusNum;                          // 室外停车位个数
    NET_PARKING_STATUS          stuParkingStatus[100];                      // 室外停车位状态
    SCENE_IMAGE_INFO_EX         stuSceneImage;                              // 全景广角图
    BYTE                        byReserved[1020];                           // 预留字节
} DEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO;

// 车辆信息
typedef struct tagDREGS_UNCOVERED_VEHICLE_INFO
{
    char                        szPlateNumber[64];                          // 车牌号码
    NET_RECT                    stuBoundingBox;                             // 包围盒
    BYTE                        byReserved[512];                           // 预留字节
}DREGS_UNCOVERED_VEHICLE_INFO;

//事件类型 EVENT_IVS_DREGS_UNCOVERED(渣土车未遮盖载货检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_DREGS_UNCOVERED_INFO
{
    int                         nChannelID;                                 // 通道号
    int                         nAction;                                    // 0:脉冲 
    char                        szName[128];                                // 事件名称
    double                      PTS;                                        // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                                        // 事件发生的时间
    UINT                        nEventID;                                   // 事件ID

    EM_CLASS_TYPE               emClassType;                                // 智能事件所属大类
    int                         nDetectRegionNum;                           // 检测区域顶点数
	DH_POINT                    stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域,[0,8192)
    DREGS_UNCOVERED_VEHICLE_INFO stuVehicleInfo;                            // 车辆信息
    BYTE                        byReserved[1024];                           // 预留字节
} DEV_EVENT_DREGS_UNCOVERED_INFO;

// 事件类型EVENT_IVS_HIGH_TOSS_DETECT(高空抛物检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_HIGH_TOSS_DETECT_INFO
{
    int                         nChannelID;									// 通道号
    int                         nAction;									// 0:脉冲 1:开始 2:停止
    char                        szName[128];								// 事件名称
    double                      PTS;										// 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;										// 事件发生的时间
    int                         nEventID;									// 事件ID

    UINT                        nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
    EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
    NET_HIGHTOSS_OBJECT_INFO    stuObjInfos[50];                            // 物体信息
    UINT                        nObjNum;                                    // 物体个数
    BYTE                        byReserved[1020];							// 预留字节
} DEV_EVENT_HIGH_TOSS_DETECT_INFO;

// 物体截图
typedef struct tagNET_OBJECT_IMAGE_INFO
{
    unsigned int        nOffSet;                // 在二进制数据块中的偏移   
    unsigned int        nLength;                // 图片大小,单位字节
    unsigned int        nWidth;                 // 图片宽度(像素)
    unsigned int        nHeight;                // 图片高度(像素)
    char                szFilePath[260];        // 全景图片路径
    BYTE                byReserved[508];        // 预留字节
}NET_OBJECT_IMAGE_INFO;

// 电力手套类型
typedef enum tagEM_ELECTRIC_GLOVE_TYPE
{
    EM_ELECTRIC_GLOVE_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_GLOVE_TYPE_GENERAL,         // 普通手套
    EM_ELECTRIC_GLOVE_TYPE_INSULATED,       // 绝缘手套
} EM_ELECTRIC_GLOVE_TYPE;

// 电力手套对象信息
typedef struct tagNET_ELECTRIC_GLOVE_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_GLOVE_TYPE      emGloveType;                    // 手套类型
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_GLOVE_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_GLOVE_DETECT(电力检测手套检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
{
    int                         nChannelID;                     // 通道号
    int                         nAction;                        // 0:脉冲 1:开始 2:停止
    char                        szName[128];                    // 事件名称
    double                      PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                            // 事件发生的时间
    int                         nEventID;                       // 事件ID

    UINT                        nRuleID;                        // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                      // 帧序号
    EM_CLASS_TYPE               emClassType;                    // 智能事件所属大类
    UINT                        nGloveObjNum;                   // 手套对象个数
    NET_ELECTRIC_GLOVE_OBJECT   stuGloveObjs[32];               // 手套对象信息
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // 全景广角图
    BYTE                        byReserved[1028];               // 预留字节
}DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO;

// 电力梯子类型
typedef enum tagEM_ELECTRIC_LADDER_TYPE
{
    EM_ELECTRIC_LADDER_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_LADDER_TYPE_GENERAL,         // 普通梯子
    EM_ELECTRIC_LADDER_TYPE_INSULATED,       // 绝缘梯子
} EM_ELECTRIC_LADDER_TYPE;

// 梯子对象信息
typedef struct tagNET_ELECTRIC_LADDER_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_LADDER_TYPE     emLadderType;                   // 梯子类型
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_LADDER_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_LADDER_DETECT(电力检测梯子检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
{
    int                         nChannelID;                     // 通道号
    int                         nAction;                        // 0:脉冲 1:开始 2:停止
    char                        szName[128];                    // 事件名称
    double                      PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                            // 事件发生的时间
    int                         nEventID;                       // 事件ID

    UINT                        nRuleID;                        // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                      // 帧序号
    EM_CLASS_TYPE               emClassType;                    // 智能事件所属大类
    UINT                        nLadderObjNum;                  // 梯子对象个数
    NET_ELECTRIC_LADDER_OBJECT  stuLadderObjs[32];              // 梯子对象信息
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // 全景广角图
    BYTE                        byReserved[1028];               // 预留字节
}DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO;

// 电力布幔类型
typedef enum tagEM_ELECTRIC_CURTAIN_TYPE
{
    EM_ELECTRIC_CURTAIN_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_CURTAIN_TYPE_GENERAL,         // 普通布幔
} EM_ELECTRIC_CURTAIN_TYPE;

// 布幔对象信息
typedef struct tagNET_ELECTRIC_CURTAIN_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_CURTAIN_TYPE    emCurtainType;                  // 布幔类型
    EM_UNIFIED_COLOR_TYPE       emCurtainColor;                 // 布幔颜色
    BYTE                        byReserved1[4];                 // 字节对齐
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_CURTAIN_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_CURTAIN_DETECT(电力检测布幔检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
{
    int                         nChannelID;                     // 通道号
    int                         nAction;                        // 0:脉冲 1:开始 2:停止
    char                        szName[128];                    // 事件名称
    double                      PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                            // 事件发生的时间
    int                         nEventID;                       // 事件ID

    UINT                        nRuleID;                        // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                      // 帧序号
    EM_CLASS_TYPE               emClassType;                    // 智能事件所属大类
    UINT                        nCurtainObjNum;                 // 布幔对象个数
    NET_ELECTRIC_CURTAIN_OBJECT stuCurtainObjs[32];             // 布幔对象信息
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // 全景广角图
    BYTE                        byReserved[1028];               // 预留字节
}DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO;

// 电力围栏类型
typedef enum tagEM_ELECTRIC_FENCE_TYPE
{
    EM_ELECTRIC_FENCE_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_FENCE_TYPE_GENERAL,         // 普通围栏
    EM_ELECTRIC_FENCE_TYPE_COLUMNAR,        // 柱状围栏
    EM_ELECTRIC_FENCE_TYPE_GRID,            // 网状围栏
} EM_ELECTRIC_FENCE_TYPE;

// 电力围栏对象信息
typedef struct tagNET_ELECTRIC_FENCE_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_FENCE_TYPE      emFenceType;                    // 围栏类型
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_FENCE_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_FENCE_DETECT(电力检测围栏检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
{
    int                         nChannelID;                     // 通道号
    int                         nAction;                        // 0:脉冲 1:开始 2:停止
    char                        szName[128];                    // 事件名称
    double                      PTS;                            // 时间戳(单位是毫秒)
    NET_TIME_EX                 UTC;                            // 事件发生的时间
    int                         nEventID;                       // 事件ID

    UINT                        nRuleID;                        // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                        nSequence;                      // 帧序号
    EM_CLASS_TYPE               emClassType;                    // 智能事件所属大类
    UINT                        nFenceObjNum;                   // 围栏对象个数
    NET_ELECTRIC_FENCE_OBJECT   stuFenceObjs[32];               // 围栏对象信息
    SCENE_IMAGE_INFO_EX         stuSceneImage;                  // 全景广角图
    BYTE                        byReserved[1028];               // 预留字节
}DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO;

// 电力标识牌类型
typedef enum tagEM_ELECTRIC_SIGNBOARD_TYPE
{
    EM_ELECTRIC_SIGNBOARD_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_SIGNBOARD_TYPE_GENERAL,         // 普通标识牌
    EM_ELECTRIC_SIGNBOARD_TYPE_WARNING,         // 警戒牌
    EM_ELECTRIC_SIGNBOARD_TYPE_NAMEPLATE,       // 铭牌
} EM_ELECTRIC_SIGNBOARD_TYPE;

// 电力标识牌对象信息
typedef struct tagNET_ELECTRIC_SIGNBOARD_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_SIGNBOARD_TYPE  emSignboardType;                // 围栏类型
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_SIGNBOARD_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(电力检测标识牌检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
{
    int                             nChannelID;                 // 通道号
    int                             nAction;                    // 0:脉冲 1:开始 2:停止
    char                            szName[128];                // 事件名称
    double                          PTS;                        // 时间戳(单位是毫秒)
    NET_TIME_EX                     UTC;                        // 事件发生的时间
    int                             nEventID;                   // 事件ID

    UINT                            nRuleID;                    // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                            nSequence;                  // 帧序号
    EM_CLASS_TYPE                   emClassType;                // 智能事件所属大类
    UINT                            nSignboardObjNum;           // 标识牌对象个数
    NET_ELECTRIC_SIGNBOARD_OBJECT   stuSignboardObjs[32];       // 标识牌对象信息
    SCENE_IMAGE_INFO_EX             stuSceneImage;              // 全景广角图
    BYTE                            byReserved[1028];           // 预留字节
}DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO;

// 电力安全带类型
typedef enum tagEM_ELECTRIC_BELT_TYPE
{
    EM_ELECTRIC_BELT_TYPE_UNKNOWN,         // 未知
    EM_ELECTRIC_BELT_TYPE_GENERAL,         // 普通电力安全带
} EM_ELECTRIC_BELT_TYPE;

// 电力安全带穿戴方式
typedef enum tagEM_BELT_WARE_TYPE
{
    EM_BELT_WARE_TYPE_UNKNOWN,          // 未知
    EM_BELT_WARE_TYPE_NORMAL,           // 正常穿戴
    EM_BELT_WARE_TYPE_MISS_MAIN,        // 主保护绳缺失
    EM_BELT_WARE_TYPE_MISS_BACKUP,      // 备用保护绳缺失
    EM_BELT_WARE_TYPE_LOW_HANGING,      // 作业低挂高用
} EM_BELT_WARE_TYPE;

// 安全带对象信息
typedef struct tagNET_ELECTRIC_BELT_OBJECT
{
    UINT                        nObjectID;                      // 物体ID
    EM_ELECTRIC_BELT_TYPE       emBeltType;                     // 电力安全带类型
    EM_BELT_WARE_TYPE           emBeltWareType;                 // 电力安全带穿戴方式
    BYTE                        byReserved1[4];                 // 字节对齐
    NET_RECT                    stuBoundingBox;                 // 包围盒
    NET_OBJECT_IMAGE_INFO       stuImageData;                   // 物体截图
    BYTE                        byReserved[1024];               // 预留字节
} NET_ELECTRIC_BELT_OBJECT;

// 事件类型EVENT_IVS_ELECTRIC_BELT_DETECT(电力检测安全带检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_ELECTRIC_BELT_DETECT_INFO
{
    int                             nChannelID;                 // 通道号
    int                             nAction;                    // 0:脉冲 1:开始 2:停止
    char                            szName[128];                // 事件名称
    double                          PTS;                        // 时间戳(单位是毫秒)
    NET_TIME_EX                     UTC;                        // 事件发生的时间
    int                             nEventID;                   // 事件ID

    UINT                            nRuleID;                    // 智能事件规则编号，用于标示哪个规则触发的事件
    UINT                            nSequence;                  // 帧序号
    EM_CLASS_TYPE                   emClassType;                // 智能事件所属大类
    UINT                            nBeltObjNum;                // 安全带对象个数
    NET_ELECTRIC_BELT_OBJECT        stuBeltObjs[32];            // 安全带对象信息
    SCENE_IMAGE_INFO_EX             stuSceneImage;              // 全景广角图
    BYTE                            byReserved[1028];           // 预留字节
} DEV_EVENT_ELECTRIC_BELT_DETECT_INFO;

// 雷达检测对象类型
typedef enum tagEM_RADAR_DETECT_OBJECT_TYPE
{
	EM_RADAR_DETECT_OBJECT_UNKNOWN,											// 未知
	EM_RADAR_DETECT_OBJECT_HUMAN,											// 人
	EM_RADAR_DETECT_OBJECT_VEHICLE											// 车
}EM_RADAR_DETECT_OBJECT_TYPE;

// 雷达检测对象
typedef struct tagNET_RADAR_DETECT_OBJECT
{
	int								nObjectID;								// 物体ID
	EM_RADAR_DETECT_OBJECT_TYPE		emObjectType;							// 物体类型
	BYTE							byReserved[1024];						// 预留字节				
}NET_RADAR_DETECT_OBJECT;

// 事件类型EVENT_IVS_RADAR_LINE_DETECTION(雷达警戒线/绊线检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_RADAR_LINE_DETECTION_INFO
{
	int                         nChannelID;									// 通道号
	int                         nAction;									// 0:脉冲 1:开始 2:停止
	char                        szName[128];								// 事件名称
	double                      PTS;										// 时间戳(单位是毫秒)
	NET_TIME_EX                 UTC;										// 事件发生的时间
	int                         nEventID;									// 事件ID

	UINT                        nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
	DH_EVENT_FILE_INFO          stuFileInfo;                                // 事件对应文件信息 
	int							nObjectNum;									// 检测到的对象个数
	NET_RADAR_DETECT_OBJECT		stuObjects[100];							// 雷达检测对象列表
	int							nPresetID;									// 事件触发的预置点号
	int                         nDetectRegionNum;                           // 检测区域顶点数
	NET_POINT                   stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域,[0,8192)
	SCENE_IMAGE_INFO_EX			stuSceneImage;								// 全景广角图
	BYTE						byReserved[1020];							// 预留字节
} DEV_EVENT_RADAR_LINE_DETECTION_INFO;

// 雷达报警类型
typedef enum tagEM_RADAR_ALARM_TYPE
{
	EM_RADAR_ALARM_TYPE_UNKNOWN,											// 未知
	EM_RADAR_ALARM_TYPE_ALARM,												// 报警
	EM_RADAR_ALARM_TYPE_WARNING,											// 预警
}EM_RADAR_ALARM_TYPE;

// 事件类型EVENT_IVS_RADAR_REGION_DETECTION(雷达警戒区检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_RADAR_REGION_DETECTION_INFO
{
	int                         nChannelID;									// 通道号
	int                         nAction;									// 0:脉冲 1:开始 2:停止
	char                        szName[128];								// 事件名称
	double                      PTS;										// 时间戳(单位是毫秒)
	NET_TIME_EX                 UTC;										// 事件发生的时间
	int                         nEventID;									// 事件ID

	UINT                        nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
	EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
	DH_EVENT_FILE_INFO          stuFileInfo;                                // 事件对应文件信息 
	int							nObjectNum;									// 检测到的对象个数
	NET_RADAR_DETECT_OBJECT		stuObjects[100];							// 雷达检测对象列表
	int							nPresetID;									// 事件触发的预置点号
	int                         nDetectRegionNum;                           // 检测区域顶点数
	NET_POINT                   stuDetectRegion[DH_MAX_DETECT_REGION_NUM];  // 检测区域,[0,8192)
	SCENE_IMAGE_INFO_EX			stuSceneImage;								// 全景广角图
	EM_RADAR_ALARM_TYPE			emAlarmType;								// 报警类型
	BYTE						byReserved[1016];							// 预留字节
} DEV_EVENT_RADAR_REGION_DETECTION_INFO;



// 异常音检测信息（定制）
typedef struct tagAUDIO_INTENSITY_MESSAGE_INFO
{
	char							szType[128];				// 消息类型，如"Audio Detection"
	char							szContent[128];				// 消息内容
	BYTE							byReserved[1024];			// 预留字段
}AUDIO_INTENSITY_MESSAGE_INFO;

// 事件类型EVENT_IVS_AUDIO_INTENSITY(异常音报警事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_AUDIO_INTENSITY_INFO
{
	int                         	nChannelID;					// 通道号（音频）
	int                         	nAction;					// 0:脉冲 1:开始 2:停止
	double                      	PTS;						// 时间戳(单位是毫秒)
    NET_TIME_EX                 	UTC;						// 事件发生的时间
	BYTE							byReserved1[4];				// 预留字段1
	AUDIO_INTENSITY_MESSAGE_INFO	stuAudioIntensityInfo;		// 音频检测信息
	BYTE							byReserved[1024];			// 预留字段
}DEV_EVENT_AUDIO_INTENSITY_INFO;

// 事件类型EVENT_IVS_WALK_DETECTION(走动检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WALK_DETECTION_INFO
{
    int                             nChannelID;                 // 通道号
    int                             nAction;                    // 1:开始 2:停止
    char                            szName[128];                // 事件名称
    EM_CLASS_TYPE                   emClassType;                // 智能事件所属大类
    NET_TIME_EX                     UTC;                        // 事件发生的时间
    double                          PTS;                        // 时间戳(单位是毫秒)
    UINT                            nEventID;                   // 事件ID
    UINT                            nPresetID;                  // 场景预置点号
    BYTE                            byReserved[1024];           // 预留字段
}DEV_EVENT_WALK_DETECTION_INFO;

// 事件类型 EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION(智慧厨房穿着检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO
{
	int                         nChannelID;									// 通道号
	int                         nAction;									// 0:脉冲 1:开始 2:停止
	char                        szName[128];								// 事件名称
	double                      PTS;										// 时间戳(单位是毫秒)
	NET_TIME_EX                 UTC;										// 事件发生的时间
	UINT                        nEventID;									// 事件ID
	UINT						nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件	
	
	EM_CLASS_TYPE               emClassType;								// 智能事件所属大类
	char						szClassAlias[16];							// 智能事件所属大类别名
	HUMAN_IMAGE_INFO			stuHumanImage;								// 人体图片信息
	SCENE_IMAGE_INFO			stuSceneImage;								// 全景广角图片信息
	FACE_IMAGE_INFO				stuFaceImage;								// 人脸图片信息
	UINT						nObjectID;									// 目标ID
	EM_NONMOTOR_OBJECT_STATUS	emHasMask;									// 检测是否有戴口罩
	EM_NONMOTOR_OBJECT_STATUS	emHasChefHat;								// 检测是否有戴厨师帽
	EM_NONMOTOR_OBJECT_STATUS	emHasChefClothes;							// 检测是否有穿厨师服
	EM_OBJECT_COLOR_TYPE		emChefClothesColor;							// 厨师服颜色(检测出不符合规定的厨师服颜色)
	BYTE						bReserved[1020];							// 预留字节
}DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO;

// 事件类型EVENT_IVS_BACK_TO_DETECTION(背对检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_BACK_TO_DETECTION_INFO
{
    int                             nChannelID;                 // 通道号
    int                             nAction;                    // 1:开始 2:停止
    char                            szName[128];                // 事件名称
    EM_CLASS_TYPE                   emClassType;                // 智能事件所属大类
    NET_TIME_EX                     UTC;                        // 事件发生的时间
    double                          PTS;                        // 时间戳(单位是毫秒)
    UINT                            nEventID;                   // 事件ID
    UINT                            nPresetID;                  // 场景预置点号
    BYTE                            byReserved[1024];           // 预留字段
}DEV_EVENT_BACK_TO_DETECTION_INFO;

// 事件类型EVENT_IVS_WRITE_ON_THE_BOARD_DETECTION(板书检测事件)对应的数据块描述信息
typedef struct tagDEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO
{
    int                             nChannelID;                 // 通道号
    int                             nAction;                    // 1:开始 2:停止
    char                            szName[128];                // 事件名称
    EM_CLASS_TYPE                   emClassType;                // 智能事件所属大类
    NET_TIME_EX                     UTC;                        // 事件发生的时间
    double                          PTS;                        // 时间戳(单位是毫秒)
    UINT                            nEventID;                   // 事件ID
    UINT                            nPresetID;                  // 场景预置点号
    BYTE                            byReserved[1024];           // 预留字段
}DEV_EVENT_WRITE_ON_THE_BOARD_DETECTION_INFO;

// 初始化参数
typedef struct tagNETSDK_INIT_PARAM
{
    int                 nThreadNum;         // 指定NetSDK常规网络处理线程数, 当值为0时, 使用内部默认值
    BYTE                bReserved[1024];    // 保留字节
}NETSDK_INIT_PARAM, *LPNETSDK_INIT_PARAM;

// 配置接口返回信息
typedef struct tagNET_CONFIG_RETURN_INFO
{
	DWORD				    dwSize;
	int						nRetCnt;		// 返回的实际有效的配置个数
} NET_CONFIG_RETURN_INFO;

// 叠加类型
typedef enum tagNET_EM_OSD_BLEND_TYPE
{
    NET_EM_OSD_BLEND_TYPE_UNKNOWN,                                  //未知叠加类型
    NET_EM_OSD_BLEND_TYPE_MAIN,                                     //叠加到主码流
    NET_EM_OSD_BLEND_TYPE_EXTRA1,                                   //叠加到辅码流1
    NET_EM_OSD_BLEND_TYPE_EXTRA2,                                   //叠加到辅码流2
    NET_EM_OSD_BLEND_TYPE_EXTRA3,                                   //叠加到辅码流3
    NET_EM_OSD_BLEND_TYPE_SNAPSHOT,                                 //叠加到抓图
    NET_EM_OSD_BLEND_TYPE_PREVIEW,                                  //叠加到预览视频
}NET_EM_OSD_BLEND_TYPE;

// 编码物件-通道标题
typedef struct tagNET_OSD_CHANNEL_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                 // 叠加类型，不管是获取还是设置都要设置该字段
    BOOL                    bEncodeBlend;                   // 是否叠加
	NET_COLOR_RGBA		    stuFrontColor;					// 前景色
	NET_COLOR_RGBA		    stuBackColor;					// 背景色
	NET_RECT		    	stuRect;						// 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
} NET_OSD_CHANNEL_TITLE;

// 编码物件-时间标题
typedef struct tagNET_OSD_TIME_TITLE
{
	DWORD				    dwSize;
    NET_EM_OSD_BLEND_TYPE   emOsdBlendType;             // 叠加类型，不管是获取还是设置都要设置该字段
    BOOL                    bEncodeBlend;               // 是否叠加
	NET_COLOR_RGBA		    stuFrontColor;				// 前景色
	NET_COLOR_RGBA		    stuBackColor;				// 背景色
	NET_RECT 			    stuRect;					// 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
	BOOL 				    bShowWeek;					// 是否显示星期
} NET_OSD_TIME_TITLE;

// 叠加标题用途
typedef enum tagNET_EM_TITLE_TYPE
{
    NET_EM_TITLE_UNKNOWN,              // 未知
    NET_EM_TITLE_RTINFO,               // 实时刻录信息
    NET_EM_TITLE_CUSTOM,               // 自定义叠加、温湿度叠加
    NET_EM_TITLE_TITLE,                // 片头信息
    NET_EM_TITLE_CHECK,                // 校验码
    NET_EM_TITLE_SPEEDOMETER,          // 测速仪
    NET_EM_TITLE_GEOGRAPHY,            // 地理信息
    NET_EM_TITLE_ATMCARDINFP,          // ATM卡号信息
    NET_EM_TITLE_CAMERAID,             // 摄像机编号
}NET_EM_TITLE_TYPE; 


// 编码物件-自定义标题信息
typedef struct tagNET_CUSTOM_TITLE_INFO
{
    BOOL                    bEncodeBlend;                   // 是否叠加
	NET_COLOR_RGBA		    stuFrontColor;					// 前景色
	NET_COLOR_RGBA		    stuBackColor;					// 背景色
	NET_RECT			    stuRect;						// 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
	char				    szText[CUSTOM_TITLE_LEN];		// 标题内容
    NET_EM_TITLE_TYPE       emTitleType;                    // 叠加标题用途
	BYTE                    byReserved[508];                // 保留字节 
} NET_CUSTOM_TITLE_INFO;

// 编码物件-自定义标题
typedef struct tagNET_OSD_CUSTOM_TITLE
{
	DWORD					dwSize;
	NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                         // 叠加类型，不管是获取还是设置都要设置该字段
	int						nCustomTitleNum;						// 自定义标题数量
	NET_CUSTOM_TITLE_INFO	stuCustomTitle[MAX_CUSTOM_TITLE_NUM];	// 自定义标题
} NET_OSD_CUSTOM_TITLE;

// 标题文本对齐方式
typedef enum tagEM_TITLE_TEXT_ALIGNTYPE
{
    EM_TEXT_ALIGNTYPE_INVALID,                              // 无效的对齐方式
    EM_TEXT_ALIGNTYPE_LEFT,                                 // 左对齐
    EM_TEXT_ALIGNTYPE_XCENTER,                              // X坐标中对齐
    EM_TEXT_ALIGNTYPE_YCENTER,                              // Y坐标中对齐
    EM_TEXT_ALIGNTYPE_CENTER,                               // 居中
    EM_TEXT_ALIGNTYPE_RIGHT,                                // 右对齐
    EM_TEXT_ALIGNTYPE_TOP,                                  // 按照顶部对齐
    EM_TEXT_ALIGNTYPE_BOTTOM,                               // 按照底部对齐
    EM_TEXT_ALIGNTYPE_LEFTTOP,                              // 按照左上角对齐
    EM_TEXT_ALIGNTYPE_CHANGELINE,                           // 换行对齐
}EM_TITLE_TEXT_ALIGNTYPE;

// 自定义标题文本对齐
typedef struct tagNET_OSD_CUSTOM_TITLE_TEXT_ALIGN
{
	DWORD					dwSize;
	int						nCustomTitleNum;						// 自定义标题数量
    EM_TITLE_TEXT_ALIGNTYPE emTextAlign[MAX_CUSTOM_TITLE_NUM];      // 自定义标题文本对齐方式
}NET_OSD_CUSTOM_TITLE_TEXT_ALIGN;

//编码物件-公共配置信息
typedef struct tagNET_OSD_COMM_INFO
{
	DWORD					dwSize;
	double					fFontSizeScale;			//叠加字体大小放大比例
													//当fFontSizeScale≠0时,nFontSize不起作用
													//当fFontSizeScale=0时,nFontSize起作用
													//设备默认fFontSizeScale=1.0
													//如果需要修改倍数，修改该值
													//如果需要按照像素设置，则置该值为0，nFontSize的值生效
	int						nFontSize;				//叠加到主码流上的全局字体大小,单位 px, 默认24.
													//和fFontSizeScale共同作用
	int						nFontSizeExtra1;		//叠加到辅码流1上的全局字体大小,单位 px
	int						nFontSizeExtra2;		//叠加到辅码流2上的全局字体大小,单位 px
	int						nFontSizeExtra3;		//叠加到辅码流3上的全局字体大小,单位 px
	int						nFontSizeSnapshot;		//叠加到抓图流上的全局字体大小, 单位 px
	int						nFontSizeMergeSnapshot; //叠加到抓图流上合成图片的字体大小,单位 px
} NET_OSD_COMM_INFO;

// 编码物件-变倍叠加配置
typedef struct tagNET_OSD_PTZZOOM_INFO
{
	DWORD					dwSize;
	BOOL					bMainBlend;				// 是否叠加到主码流
	BOOL					bPreviewBlend;			// 是否叠加到预览码流
	NET_COLOR_RGBA		    stuFrontColor;			// 前景色
	NET_COLOR_RGBA		    stuBackColor;			// 背景色
	NET_RECT		    	stuRect;				// 区域, 坐标取值0~8191, 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
	int						nDisplayTime;			// 显示时间，单位为妙，0表示一直显示
} NET_OSD_PTZZOOM_INFO;

// 编码物件-GPS标题显示配置
typedef struct tagNET_OSD_GPS_TITLE
{
	DWORD					dwSize; 
	BOOL					bEncodeBlend;            //叠加到主码流视频编码
}NET_OSD_GPS_TITLE;

#define MAX_COUNT_PLANE		32	// 最大人数统计计划个数

// 每个计划对应的人数统计计划OSD配置 
typedef struct tagNET_STATPLAN_INFO
{
	int						nPlanID;				// 人数统计计划号
	BOOL					bEncodeBlend;			// 是否叠加到主码流
	NET_COLOR_RGBA		    stuFrontColor;			// 前景色
	NET_COLOR_RGBA		    stuBackColor;			// 背景色
	EM_TITLE_TEXT_ALIGNTYPE emTextAlign;			// 对齐方式
	NET_RECT		    	stuRect;				// 区域, 坐标取值0~8191
	BOOL					bShowEnterNum;			// 是否显示进入人数
	BOOL					bShowExitNum;			// 是否显示离开人数
	BYTE                    byReserved[128];        // 保留字节 
} NET_STATPLAN_INFO;

// 人数统计计划叠加OSD配置
typedef struct tagNET_OSD_NUMBER_STATPLAN
{
	DWORD					dwSize;
	int						nRetPlanCount;							// 实际的统计计划个数
	NET_STATPLAN_INFO		stuStatplanInfo[MAX_COUNT_PLANE];		// OSD配置
} NET_OSD_NUMBER_STATPLAN;

// 音频编码模式
typedef enum tatNET_EM_AUDIO_FORAMT
{
	EM_AUDIO_FORMAT_UNKNOWN,							// unknown
	EM_AUDIO_FORMAT_G711A,                              // G711a
    EM_AUDIO_FORMAT_PCM,                                // PCM
    EM_AUDIO_FORMAT_G711U,                              // G711u
    EM_AUDIO_FORMAT_AMR,                                // AMR
    EM_AUDIO_FORMAT_AAC,                                // AAC
    
    EM_AUDIO_FORMAT_G726,								// G.726
    EM_AUDIO_FORMAT_G729,								// G.729
    EM_AUDIO_FORMAT_ADPCM,								// ADPCM
    EM_AUDIO_FORMAT_MPEG2,								// MPEG2
    EM_AUDIO_FORMAT_MPEG2L2,							// MPEG2-Layer2
    EM_AUDIO_FORMAT_OGG,								// OGG
    EM_AUDIO_FORMAT_MP3,								// MP3
    EM_AUDIO_FORMAT_G7221,								// G.722.1
} NET_EM_AUDIO_FORMAT;


// 视频压缩格式
typedef enum tagNET_EM_VIDEO_COMPRESSION
{
	EM_VIDEO_FORMAT_UNKNOWN = -1,						// 未知
	EM_VIDEO_FORMAT_MPEG4,								// MPEG4
	EM_VIDEO_FORMAT_MS_MPEG4,							// MS-MPEG4
	EM_VIDEO_FORMAT_MPEG2,								// MPEG2
	EM_VIDEO_FORMAT_MPEG1,								// MPEG1
	EM_VIDEO_FORMAT_H263,								// H.263
	EM_VIDEO_FORMAT_MJPG,								// MJPG
	EM_VIDEO_FORMAT_FCC_MPEG4,							// FCC-MPEG4
	EM_VIDEO_FORMAT_H264,								// H.264
    EM_VIDEO_FORMAT_H265,								// H.265
	EM_VIDEO_FORMAT_SVAC,								// SVAC
} NET_EM_VIDEO_COMPRESSION;

// 码流控制模式
typedef enum tagNET_EM_BITRATE_CONTROL
{
	EM_BITRATE_CBR,									// 固定码流
	EM_BITRATE_VBR,									// 可变码流
} NET_EM_BITRATE_CONTROL;

// 画质
typedef enum tagNET_EM_IMAGE_QUALITY
{
	EM_IMAGE_QUALITY_Q10 = 1,							// 图像质量10%
	EM_IMAGE_QUALITY_Q30,								// 图像质量30%
	EM_IMAGE_QUALITY_Q50,								// 图像质量50%
	EM_IMAGE_QUALITY_Q60,								// 图像质量60%
	EM_IMAGE_QUALITY_Q80,								// 图像质量80%
	EM_IMAGE_QUALITY_Q100,								// 图像质量100%
} NET_EM_IMAGE_QUALITY;

// H264 编码级别
typedef enum tagNET_EM_H264_PROFILE_RANK
{
	EM_PROFILE_UNKNOWN,							   // 未知类型
	EM_PROFILE_BASELINE = 1,                       // 提供I/P帧，仅支持progressive(逐行扫描)和CAVLC
	EM_PROFILE_MAIN,                               // 提供I/P/B帧，支持progressiv和interlaced，提供CAVLC或CABAC
	EM_PROFILE_EXTENDED,                           // 提供I/P/B/SP/SI帧，仅支持progressive(逐行扫描)和CAVLC
	EM_PROFILE_HIGH,                               // 即FRExt，Main_Profile基础上新增：8x8 intra prediction(8x8 帧内预测), custom 
												   // quant(自定义量化), lossless video coding(无损视频编码), 更多的yuv格式
}NET_EM_H264_PROFILE_RANK;

// 码流类型
typedef enum tagNET_EM_FORMAT_TYPE
{
	EM_FORMAT_TYPE_UNKNOWN,				// 未知类型
	/*主码流*/
	EM_FORMAT_MAIN_NORMAL,				// 主码流普通编码
	EM_FORMAT_MAIN_MOVEEXAMINE,			// 主码流动检编码
	EM_FORMAT_MAIN_ALARM,				// 主码流报警编码

	/*辅码流*/
	EM_FORMAT_EXTRA1,					// 辅码流1
	EM_FORMAT_EXTRA2,					// 辅码流2
	EM_FORMAT_EXTRA3,					// 辅码流3
} NET_EM_FORMAT_TYPE;

// 打包模式
typedef enum tagNET_EM_PACK_TYPE
{
	EM_PACK_UNKOWN,				// UNKOWN
	EM_PACK_DHAV,				// DHAV
	EM_PACK_PS,					// ps
} NET_EM_PACK_TYPE;


// 主(辅)码流视频格式(f6/f5/bin)
typedef struct tagNET_ENCODE_VIDEO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// 码流类型,设置和获取时都需要设置值
	BOOL						bVideoEnable;				// 视频使能
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// 视频压缩格式
	int							nWidth;						// 视频宽度
	int							nHeight;					// 视频高度
	NET_EM_BITRATE_CONTROL		emBitRateControl;			// 码流控制模式
	int							nBitRate;					// 视频码流(kbps)
	float						nFrameRate;					// 视频帧率
	int							nIFrameInterval;			// I帧间隔(1-100)，比如50表示每49个B帧或P帧，设置一个I帧。
	NET_EM_IMAGE_QUALITY		emImageQuality;				// 图像质量
} NET_ENCODE_VIDEO_INFO;

// 主(辅)码流视频格式打包模式配置(f6/f5)
typedef struct tagNET_ENCODE_VIDEO_PACK_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// 码流类型,设置和获取时都需要设置值
	NET_EM_PACK_TYPE			emPackType;					// 打包模式
} NET_ENCODE_VIDEO_PACK_INFO;

// 主(辅)码流视频格式SVC配置(f6)
typedef struct tagNET_ENCODE_VIDEO_SVC_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// 码流类型,设置和获取时都需要设置值
	int							nSVC;						// SVC-T层数
} NET_ENCODE_VIDEO_SVC_INFO;

// 主(辅)码流视频格式profile配置(f6/bin)编码
typedef struct tagNET_ENCODE_VIDEO_PROFILE_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;				// 码流类型,设置和获取时都需要设置值
	NET_EM_H264_PROFILE_RANK 	emProfile;                	// H.264编码级别
} NET_ENCODE_VIDEO_PROFILE_INFO;

// 主(辅)码流音频压缩格式配置
typedef struct tagNET_ENCODE_AUDIO_COMPRESSION_INFO
{
	DWORD						dwSize;
	BOOL						bAudioEnable;			// 音频使能
	NET_EM_FORMAT_TYPE			emFormatType;			// 码流类型,设置和获取时都需要设置值
	NET_EM_AUDIO_FORMAT			emCompression;			// 音频压缩模式
} NET_ENCODE_AUDIO_COMPRESSION_INFO;

//主(辅)码流音频格式其他属性配置
typedef struct tagNET_ENCODE_AUDIO_INFO
{
	DWORD						dwSize;
	NET_EM_FORMAT_TYPE			emFormatType;			// 码流类型,设置和获取时都需要设置值
	int							nDepth;					// 音频采样深度
	int							nFrequency;				// 音频采样频率
	int							nMode;					// 编码码率,不同编码类型定义不同：
                                                       /* "AMR"编码码率
                                                            0: 4.75kbps,
                                                            1: 5.15 kbps,
                                                            2: 5.9 kbps,
                                                            3: 6.7 kbps,
                                                            4: 7.4 kbps,
                                                            5: 7.95 kbps,
                                                            6: 10.2 kbps,
                                                            7: 12.2 kbps,
                                                        G726编码码率
                                                            0: 40kbps(默认)
                                                            1: 16kbps
                                                            2: 24kbps
                                                            3: 32kbps
                                                        其他: 暂无定义*/

	int							nFrameType;				// 音频打包模式, 0-DHAV, 1-PS
	int							nPacketPeriod;			// 音频打包周期, ms
} NET_ENCODE_AUDIO_INFO;

// 抓图类型
typedef enum tagNET_EM_SNAP_TYPE
{
	EM_SNAP_UNKNOWN,			// 未知类型
	EM_SNAP_NORMAL,				// 普通抓图
	EM_SNAP_MOVEEXAMINE,		// 动检抓图
	EM_SNAP_ALARM,				// 报警抓图
} NET_EM_SNAP_TYPE;

// 抓图配置
typedef struct tagNET_ENCODE_SNAP_INFO
{
	DWORD						dwSize;
	NET_EM_SNAP_TYPE			emSnapType;					// 抓图类型
	BOOL						bSnapEnable;				// 定时抓图使能
	NET_EM_VIDEO_COMPRESSION 	emCompression;				// 视频压缩格式
	int							nWidth;						// 视频宽度
	int							nHeight;					// 视频高度
	float						nFrameRate;					// 视频帧率
	int 						nQualityRange;				// 图像质量取值范围
	NET_EM_IMAGE_QUALITY		emImageQuality;				// 图像质量
} NET_ENCODE_SNAP_INFO;

// 抓图时间配置
typedef struct tagNET_ENCODE_SNAP_TIME_INFO
{
	DWORD				dwSize;
	short           	shPicTimeInterval;             	// 定时抓图时间间隔,单位为秒,目前设备支持最大的抓图时间间隔为30分钟                           
	BYTE            	bPicIntervalHour;              	// 定时抓图时间间隔小时数
	DWORD           	dwTrigPicIntervalSecond;       	// 报警触发后每次抓图时间间隔时间 单位秒
} NET_ENCODE_SNAP_TIME_INFO;

// 每个通道对应的配置类型
typedef enum tagNET_EM_CONFIG_TYPE
{
	NET_EM_CONFIG_DAYTIME,			// 白天
	NET_EM_CONFIG_NIGHT,			// 夜晚
	NET_EM_CONFIG_NORMAL,			// 普通
} NET_EM_CONFIG_TYPE;


// 通道名称配置
typedef struct tagNET_ENCODE_CHANNELTITLE_INFO
{
	DWORD				dwSize;
	char				szChannelName[MAX_CHANNEL_NAME_LEN];				// 通道名称
} NET_ENCODE_CHANNELTITLE_INFO;

// 音频输入类型
typedef enum tagNET_EM_AUDIOIN_SOURCE_TYPE
{
	NET_EM_AUDIOIN_SOURCE_UNKNOW,			// 未知
	NET_EM_AUDIOIN_SOURCE_COAXIAL,			// Coaxial
	NET_EM_AUDIOIN_SOURCE_BNC,				// BNC
	NET_EM_AUDIOIN_SOURCE_HDCVI_BNC,		// HDCVI_BNC
	NET_EM_AUDIOIN_SOURCE_LINEIN,			// LineIn
	NET_EM_AUDIOIN_SOURCE_LINEIN1,			// LineIn1
	NET_EM_AUDIOIN_SOURCE_LINEIN2,			// LineIn2
	NET_EM_AUDIOIN_SOURCE_LINEIN3,			// LineIn3
	NET_EM_AUDIOIN_SOURCE_MIC,				// Mic
	NET_EM_AUDIOIN_SOURCE_MIC1,				// Mic1
	NET_EM_AUDIOIN_SOURCE_MIC2,				// Mic2
	NET_EM_AUDIOIN_SOURCE_MIC3,				// Mic3
	NET_EM_AUDIOIN_SOURCE_MICOUT,			// MicOut
	NET_EM_AUDIOIN_SOURCE_REMOTE,			// Remote
	NET_EM_AUDIOIN_SOURCE_REMOTE1,			// Remote1
	NET_EM_AUDIOIN_SOURCE_REMOTE2,			// Remote2
	NET_EM_AUDIOIN_SOURCE_REMOTE3,			// Remote3
} NET_EM_AUDIOIN_SOURCE_TYPE;

// 音频输入类型配置
typedef struct tagNET_ENCODE_AUDIO_SOURCE_INFO
{
	DWORD						dwSize;
	int 						nMaxAudioInSource;		// 输入类型最大个数
	int							nRetAudioInSource;		// 输入类型实际返回个数
	NET_EM_AUDIOIN_SOURCE_TYPE	emAudioInSource[24];	// 输入源类型
} NET_ENCODE_AUDIO_SOURCE_INFO;

// 音频输入降噪配置
typedef struct tagNET_AUDIOIN_DENOISE_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// 降噪使能
} NET_AUDIOIN_DENOISE_INFO;

// 音频输入音量配置
typedef struct tagNET_AUDIOIN_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// 音频输入音量
} NET_AUDIOIN_VOLUME_INFO;

// 音频输出音量配置
typedef struct tagNET_AUDIOOUT_VOLUME_INFO
{
	DWORD				dwSize;
	int					nVolume;			// 音频输出音量
} NET_AUDIOOUT_VOLUME_INFO;

// 切换模式
typedef enum tagNET_EM_SWITCH_MODE
{
	NET_EM_SWITCH_MODE_WIGHT,		// 不切换，总是使用白天配置
	NET_EM_SWITCH_MODE_LIGHT,		// 根据亮度切换
	NET_EM_SWITCH_MODE_TIME,		// 根据时间切换
	NET_EM_SWITCH_MODE_NIGHT,		// 不切换，总是使用夜晚配置
	NET_EM_SWITCH_MODE_NORMAL,		// 使用普通配置
} NET_EM_SWITCH_MODE;

// 大致日出/日落时间
typedef struct tagNET_SUN_TIME
{
	int				nHour;				// 时
	int				nMinute;			// 分
	int				nSecond;			// 秒
} NET_SUN_TIME;

// 切换模式配置
typedef struct tagNET_VIDEOIN_SWITCH_MODE_INFO
{
	DWORD				dwSize;
	NET_EM_SWITCH_MODE	emSwitchMode;			// 切换模式

	/*大致日出和日落时间，日落之后日出之前，
	将采用夜晚特殊的配置,emSwitchMode为NET_EM_SWITCH_MODE_TIME是有效*/
	NET_SUN_TIME		stuSunRiseTime;			// 大致日出时间
	NET_SUN_TIME		stuSunSetTime;			// 大致日落时间
} NET_VIDEOIN_SWITCH_MODE_INFO;

// 色彩风格
typedef enum tagEM_COLOR_STYLE_TYPE
{
	EM_COLOR_STYLE_UNKNOWN,			// 未知
	EM_COLOR_STYLE_GENTLE,			// 柔和
	EM_COLOR_STYLE_STANDARD,		// 标准
	EM_COLOR_STYLE_FLAMBOYANT,		// 艳丽
} EM_COLOR_STYLE_TYPE;

// 视频输入颜色配置
typedef struct tagNET_VIDEOIN_COLOR_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// 配置类型，获取和设置时都要制定
	int					nBrightness;			// 亮度0-100
	int					nContrast;				// 对比度0-100
	int					nSaturation;			// 饱和度0-100
	int					nGamma;					// 伽马值0-100
	EM_COLOR_STYLE_TYPE	emColorStyle;			// 色彩风格
    int                 nHue;                   // 色调值0-100
    int                 nChromaSuppress;        // 色彩抑制等级值0-100
    DH_TSECT            stuTimeSection;         // 对应的时间段
} NET_VIDEOIN_COLOR_INFO;

// LED屏显示颜色
typedef enum tagNET_EM_FLIP_MODE
{
    NET_EM_FLIP_MODE_UNKNOWN = 0,     // 未知
    NET_EM_FLIP_MODE_MANUAL,          // 手动
    NET_EM_FLIP_MODE_AUTO,            // 自动  
}NET_EM_FLIP_MODE;

// 图像旋转设置能力配置,对应枚举NET_EM_CFG_VIDEO_IMAGE_CTRL
typedef struct tagNET_EM_CFG_VIDEO_IMAGE_CTRL_INFO
{
    DWORD			dwSize;
    BOOL            bMirror;                // 是否支持画面镜像功能
    BOOL            bFlip;                  // 是否支持画面180翻转功能
    BOOL            bFreeze;                // 是否支持图像冻结功能
    BOOL            bVerticalFlip;          // 是否开启垂直旋转180度功能
    BOOL            bHorizontalFlip;        // 是否开启水平旋转180度功能
    int             nRotate90;              // 90顺逆时针旋转标志 0-不旋转，1-顺时针90°，2-逆时针90°
    int             nStable;                // 支持图像防抖的功能掩码 0关闭，支持按位或 1-开启电子防抖，2-开启光学防抖，4-开启控件防抖
    int             nStableSensitivity;     // 是否支持电子防抖灵敏度, 取值范围[0-100]
    NET_EM_FLIP_MODE emFlipMode;            // 画面翻转模式
}NET_EM_CFG_VIDEO_IMAGE_CTRL_INFO;


// 图像属性配置
typedef struct tagNET_VIDEOIN_IMAGE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;				// 配置类型，获取和设置时都要制定
	BOOL				bMirror;				// 是否开启画面镜像功能
	BOOL				bFlip;					// 是否开启画面翻转功能
	int					nRotate90;				// 0-不旋转，1-顺时针90°，2-逆时针90°
} NET_VIDEOIN_IMAGE_INFO;

// 图像防抖模式
typedef enum tagNET_EM_STABLE_TYPE
{
	NET_EM_STABLE_OFF,				// 关闭
	NET_EM_STABLE_ELEC,				// 电子防抖
	NET_EM_STABLE_LIGHT,			// 光学防抖
	NET_EM_STABLE_CONTORL = 4,		// 控件防抖
} NET_EM_STABLE_TYPE;

// 图像防抖配置
typedef struct tagNET_VIDEOIN_STABLE_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;			// 配置类型，获取和设置时都要指定
	NET_EM_STABLE_TYPE	emStableType;		// 防抖配置
} NET_VIDEOIN_STABLE_INFO;

// 自动光圈配置
typedef struct tagNET_VIDEOIN_IRISAUTO_INFO
{
	DWORD				dwSize;
	NET_EM_CONFIG_TYPE	emCfgType;		// 配置类型，获取和设置时都要指定
	BOOL				bIrisAuto;		//是否使能自动光圈
} NET_VIDEOIN_IRISAUTO_INFO;

// 图像增强配置
typedef struct tagNET_VIDEOIN_IMAGEENHANCEMENT_INFO
{
	DWORD				dwSize;
	BOOL				bEnable;			// 使能
	int					nLevel;				// 图像增强等级
}NET_VIDEOIN_IMAGEENHANCEMENT_INFO;

// 双快门的支持类型
typedef enum tagEM_DOUBLE_EXPOSURE_TYPE
{
    EM_DOUBLE_EXPOSURE_UNKNOWN = -1,				// 未知
    EM_DOUBLE_EXPOSURE_NOT_SUPPORT,				    // 不支持
    EM_DOUBLE_EXPOSURE_SUPPORT_FULL_FRAM,			// 支持双快门全帧率，即图像和视频只有快门参数不同
    EM_DOUBLE_EXPOSURE_SUPPORT_HALF_FRAM,		    // 支持双快门半帧率，即图像和视频快门及白平衡参数均不同
    EM_DOUBLE_EXPOSURE_ALL,		                    // 支持双快门全帧率和半帧率
} EM_DOUBLE_EXPOSURE_TYPE;


//通用曝光属性配置
typedef struct tagNET_VIDEOIN_EXPOSURE_NORMAL_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// 配置类型，获取和设置时都要指定
	NET_EM_EXPOSURE_MODE	emExposureMode;			// 曝光模式
	int						nAntiFlicker;			// 防闪烁0-Outdoor  1-50Hz防闪烁 2-60Hz防闪烁
	int						nCompensation;			// 曝光补偿0-100
	int						nGain;					// 增益值
	int						nGainMin;				// 增益下限0-100
	int						nGainMax;				// 增益上限0-100
	int						nExposureIris;			// 光圈值，模式为光圈优先时有效，0-100
	double					dbExposureValue1;		// 自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
	double					dbExposureValue2;		// 自动曝光时间上限,毫秒为单位，取值0.1ms~80ms，且必须不小于"ExposureValue1"取值
    
    BOOL                    bIrisAuto;              // 自动光圈使能
    EM_DOUBLE_EXPOSURE_TYPE emDoubleExposure;       // 双快门的支持类型
} NET_VIDEOIN_EXPOSURE_NORMAL_INFO;

// 其他曝光属性配置
typedef struct tagNET_VIDEOIN_EXPOSURE_OTHER_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// 配置类型，获取和设置时都要指定
	BOOL					bSlowShutter;			// 慢快门使能
	int						nSlowSpeed;				// 慢曝光速度等级
	int						nSlowAutoExposure;		// 慢曝光
	int						nRecoveryTime;			// 0-表示不恢复，其他表示恢复的时间，单位为秒
	int						nIrisMin;				// 光圈区间下限，SupportIrisRange能力为true时可设置,0~100 （光圈优先下设置，与Iris互斥）
	int						nIrisMax;				// 光圈区间下限,0~100,取值不小于"IrisMin"的取值（光圈优先下设置，与Iris互斥）
} NET_VIDEOIN_EXPOSURE_OTHER_INFO;

// 曝光快门属性配置
typedef struct tagNET_VIDEOIN_EXPOSURE_SHUTTER_INFO
{
	DWORD					dwSize;
	BOOL					bAutoSyncPhase;			// 自动相位调节使能
	float					fShutter;				// 快门值，AutoSyncPhase为true时有效，毫秒为单位，取值0.1ms~80ms，
													// 且必须不小于NET_VIDEOIN_EXPOSURE_NORMAL_INFO中的"ExposureValue1"、不大于"ExposureValue2"
	int						nPhase;					// 相位值,取值0~360°
} NET_VIDEOIN_EXPOSURE_SHUTTER_INFO;


// 背光配置
typedef struct tagNET_VIDEOIN_BACKLIGHT_INFO
{
	DWORD					dwSize;
	NET_EM_CONFIG_TYPE		emCfgType;				// 配置类型，获取和设置时都要指定
	NET_EM_BACK_MODE		emBlackMode;			// 背光模式
	NET_EM_BLACKLIGHT_MODE	emBlackLightMode;		// 背光补偿模式
	NET_RECT				stuBacklightRegion;     // 背光补偿区域   
	int						nWideDynamicRange;		// 宽动态值，emBlackMode为NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC时生效
	int						nGlareInhibition;		// 强光抑制0-100，emBlackMode为NET_EM_BACKLIGHT_MODE_GLAREINHIBITION时生效
} NET_VIDEOIN_BACKLIGHT_INFO;


//场景自适应对比度强度配置，背光模式为场景自适应时有效
typedef struct tagNET_VIDEOIN_INTENSITY_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;				// 配置类型，获取和设置时都要指定
	NET_EM_BACK_INTENSITY_MODE	emIntensityMode;		// 场景自适应对比度强度调节模式
	int							nIntensity;				// SSA手动调整强度0-100, emIntensityMode为NET_EM_INTENSITY_MANUAL时有效
} NET_VIDEOIN_INTENSITY_INFO;

// 白平衡配置
typedef struct tagNET_VIDEOIN_WHITEBALANCE_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_WHITEBALANCE_TYPE	emWhiteBalanceType;			//白平衡模式
	int							nGainRed;					// 红色增益调节0-100，白平衡为"Custom"模式下有效
	int							nGainBlue;					// 蓝色增益调节0-100，白平衡为"Custom"模式下有效
	int							nGainGreen;					// 绿色增益调节0-100，白平衡为"Custom"模式下有效
	int							nColorTemperature;			// 色温等级, 白平衡为"CustomColorTemperature"模式下有效
} NET_VIDEOIN_WHITEBALANCE_INFO;

// 日夜切换模式
typedef enum tagNET_EM_DAYNIGHT_TYPE
{
	NET_EM_DAYNIGHT_COLOR,				// 总是彩色
	NET_EM_DAYNIGHT_AUTO,				// 根据亮度自动切换
	NET_EM_DAYNIGHT_WHITEBLACK,			// 总是黑白
} NET_EM_DAYNIGHT_TYPE;

//日夜模式配置
typedef struct tagNET_VIDEOIN_DAYNIGHT_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_DAYNIGHT_TYPE		emDayNightType;				// 日夜切换模式
	int							nDayNightSensitivity;		// 日夜模式切换灵敏度,范围1-3
	int							nDayNightSwitchDelay;		// 日夜模式切换延迟时间,单位秒，范围2-10
} NET_VIDEOIN_DAYNIGHT_INFO;

// 日夜模式ICR切换类型配置
typedef struct tagNET_VIDEOIN_DAYNIGHT_ICR_INFO
{
	DWORD						dwSize;
	NET_EM_CONFIG_TYPE			emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_ICR_TYPE				emType;						// ICR切换类型
} NET_VIDEOIN_DAYNIGHT_ICR_INFO;

//灯光模式
typedef enum tagNET_EM_LIGHTING_MODE
{
	NET_EM_LIGHTING_UNKNOW,			// 未知模式
	NET_EM_LIGHTING_MANUAL,			// 手动模式
	NET_EM_LIGHTING_AUTO,			// 自动模式
	NET_EM_LIGHTING_OFF,			// 关闭模式
	NET_EM_LIGHTING_ZOOMPRIO,		// 倍率优先模式
	NET_EM_LIGHTING_TIMING,			// 定时模式，本模式时LightingSchedule配置生效	
	NET_EM_LIGHTING_SMARTLIGHT,		// 智能灯光模式(仅球机使用),如果在模式选择本模式，使用新加的SmartLighting配置
    NET_EM_LIGHTING_EXCLUSIVEMANUAL,	// 支持多种灯光，但手动模式下只使用一种灯光，此时使用ManualLighting配置
} NET_EM_LIGHTING_MODE;

// 补光灯配置
typedef struct tagNET_VIDEOIN_LIGHTING_INFO
{
	DWORD						dwSize;
	NET_EM_LIGHTING_MODE		emLightMode;			// 灯光模式
	int							nCorrection;			// 灯光补偿值，倍率优先时有效0-4
	int							nSensitive;				// 灯光灵敏度，倍率优先时有效，0-5，默认为3
	int							nNearLight;				// 近光灯亮度0-100
	int							nFarLight;				// 远光灯亮度0-100
} NET_VIDEOIN_LIGHTING_INFO;

// 透雾模式
typedef enum tagNET_EM_DEFOG_MODE
{
	NET_EM_DEFOG_UNKNOW,			// 未知模式
	NET_EM_DEFOG_OFF,				// 关闭
	NET_EM_DEFOG_AUTO,				// 自动
	NET_EM_DEFOG_MANAUL,			// 手动
}NET_EM_DEFOG_MODE;

//大气光模式枚举
typedef enum tagNET_EM_INTENSITY_MODE
{
	NET_EM_INTENSITY_MODE_UNKNOW,//未知方式
	NET_EM_INTENSITY_MODE_AUTO,  //自动
	NET_EM_INTENSITY_MODE_MANUAL, //手动
}NET_EM_INTENSITY_MODE;


// 透雾配置
typedef struct tagNET_VIDEOIN_DEFOG_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_DEFOG_MODE				emDefogMode;				// 透雾模式
	int								nIntensity;					// 强度0-100
	NET_EM_INTENSITY_MODE			emIntensityMode;			//大气光模式
	int								nLightIntensityLevel;		//大气光强度(0-15)
	BOOL							bCamDefogEnable;			//光学去雾使能 (TRUE使能，FALSE去使能)
} NET_VIDEOIN_DEFOG_INFO;

// 聚焦模式配置
typedef struct tagNET_VIDEOIN_FOCUSMODE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// 配置类型，获取和设置时都要指定
	NET_EM_FOCUS_MODE				emFocusMode;			// 聚焦模式
} NET_VIDEOIN_FOCUSMODE_INFO;

// 聚焦灵敏度
typedef enum tagNET_EM_SENSITIVITY_TYPE
{
	NET_EM_SENSITIVITY_HIGH,				// 高
	NET_EM_SENSITIVITY_DEFAULT,				// 默认
	NET_EM_SENSITIVITY_LOW,					// 低
} NET_EM_SENSITIVITY_TYPE;

// 红外光聚焦修正模式
typedef enum tagNET_EM_IRC_TYPE
{
	NET_EM_IRC_DONOT,			// 不修正
	NET_EM_IRC_DOIT,			// 修正
	NET_EM_IRC_AUTO,			// 自动修正
} NET_EM_IRC_TYPE;

// 聚焦信息配置
typedef struct tagNET_VIDEOIN_FOCUSVALUE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;				// 配置类型，获取和设置时都要指定
	NET_EM_SENSITIVITY_TYPE			emSensitivity;			// 聚焦灵敏度
	NET_EM_IRC_TYPE					emIRCorrection;			// 红外光聚焦修正
	NET_EM_FOCUS_LIMITSELECT_MODE	emFocusLimitSelectMode;	// 聚焦极限选取模式
	int								nFocusLimit;			// 近端聚焦极限建议值,单位毫米
	BOOL							bAutoFocusTrace;		// 变焦跟踪使能
} NET_VIDEOIN_FOCUSVALUE_INFO;

// 锐度配置
typedef struct tagNET_VIDEOIN_SHARPNESS_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_SHARPNESS_MODE			emSharpnessMode;			// 锐度模式
	int								nSharpness;					// 锐度值0-100，手动时有效
	int								nLevel;						// 锐度抑制等级，0-100，0表示不抑制
} NET_VIDEOIN_SHARPNESS_INFO;

// 3D降噪控制类型
typedef enum tagNET_EM_3D_TYPE
{
	NET_EM_3D_UNKONW,		// 未知
	NET_EM_3D_OFF,			// 关闭
	NET_EM_3D_AUTO,			// 自动
} NET_EM_3D_TYPE;

// 高级降噪类型
typedef enum tagNET_EM_ALGORITHM_TYPE
{
	NET_EM_ALGORITHM_UNKNOW,		// 未知
	NET_EM_ALGORITHM_OFF,			// 关闭
	NET_EM_ALGORITHM_MANUAL,		// 手动
}NET_EM_ALGORITHM_TYPE;

// 高级降噪配置
typedef struct tagNET_DENOISE_ALGORITHM
{
	NET_EM_ALGORITHM_TYPE	emAlgorithmType;		// 高级降噪等级,	NET_EM_ALGORITHM_MANUAL时空域和时域有效
	int						nTnfLevel;				// 时域等级
	int						nSnfLevel;				//空域等级
	BYTE					bReserved[256];			// 保留字节
} NET_DENOISE_ALGORITHM;

// 通用降噪配置
typedef struct tagNET_VIDEOIN_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// 配置类型，获取和设置时都要指定
	BOOL							b2DEnable;					// 2D降噪使能
	int								n2DLevel;					// 2D降噪等级0-100, b2DEnable为TRUE时有效
	NET_DENOISE_ALGORITHM			stuAlgorithm;				// 高级降噪配置
} NET_VIDEOIN_DENOISE_INFO;

// 3D降噪配置
typedef struct tagNET_VIDEOIN_3D_DENOISE_INFO
{
	DWORD							dwSize;
	NET_EM_CONFIG_TYPE				emCfgType;					// 配置类型，获取和设置时都要指定
	NET_EM_3D_TYPE					em3DType;					// 3D降噪控制类型
	int								nAutoLevel;					// 3D降噪等级，em3DType为NET_EM_3D_AUTO时有效
} NET_VIDEOIN_3D_DENOISE_INFO;

// 优先聚焦模式
typedef struct tagNET_PRIOR_FOCUSMODE_INFO
{
	unsigned int					nPriorFocusMode;			// 聚焦模式:0:近景 1:远景
	BYTE							byReserved[256];			// 保留字节
}NET_PRIOR_FOCUSMODE_INFO;

// 聚焦扩展配置(对应命令 NET_EM_CFG_VIDEOIN_FOCUSEX)
typedef struct tagNET_VIDEOIN_FOCUS_INFO_EX
{
	DWORD							dwSize;											// 结构体的大小
	int								nPriorFocusModeNum;								// 优先聚焦模式个数
	NET_PRIOR_FOCUSMODE_INFO		stuPriorFocusMode[8];							// 优先聚焦模式
}NET_VIDEOIN_FOCUS_INFO_EX;

// 近光灯
typedef struct tagNET_NEAR_LIGHT
{
    int                 nLight;                     // 灯光亮度百分比值,0关闭 (1~100)灯光亮度百分比
    int                 nAngle;                     // 激光灯角度归一化值, 0~100
    BYTE                byReserved[128];            // 保留字节    
}NET_NEAR_LIGHT;

// 中光灯
typedef struct tagNET_MIDDLE_LIGHT
{
    BOOL                bEnable;                    // 使能
    int                 nLight;                     // 灯光亮度百分比值,0关闭 (1~100)灯光亮度百分比
    int                 nAngle;                     // 激光灯角度归一化值, 0~100
    BYTE                byReserved[132];            // 保留字节         
}NET_MIDDLE_LIGHT;

// 远光灯
typedef struct tagNET_FAR_LIGHT
{
    int                 nLight;                     // 灯光亮度百分比值,0关闭 (1~100)灯光亮度百分比
    int                 nAngle;                     // 激光灯角度归一化值, 0~100
    BYTE                byReserved[128];            // 保留字节
}NET_FAR_LIGHT;

// 每个通道对应的配置类型
typedef enum tagNET_EM_CONFIGEX_TYPE
{
    NET_EM_CONFIGEX_REALTIME,			// 即时生效
    NET_EM_CONFIGEX_DAYTIME,			// 白天
    NET_EM_CONFIGEX_NIGHT,			    // 夜晚
    NET_EM_CONFIGEX_NORMAL,			    // 普通
} NET_EM_CONFIGEX_TYPE;

// 补光灯配置的扩展(对应命令 NET_EM_CFG_VIDEOIN_LIGHTINGEX)
typedef struct tagNET_VIDEOIN_LIGHTINGEX_INFO
{
    DWORD				dwSize;
    NET_EM_CONFIGEX_TYPE	emCfgType;  				// 配置类型，获取和设置时都要制定
    NET_EM_LIGHTING_MODE emLightMode;			    // 灯光模式
    int                 nCorrection;                // 灯光补偿，倍率优先时有效,范围从(0~4)切换到(0~100)，存在两种范围，没有能力区分。建议用(0~100)
    int                 nSensitive;                 // 灯光灵敏度，倍率优先时有效，范围0~5，默认3
    int                 nTimes;                     // 补光灯开灯时间，自动模式有效,单位：秒 （人脸闸机需求）

    int                 nNearLight;                 // 近光灯数量
    int                 nMiddleLight;               // 中光灯数量
    int                 nFarLight;                  // 远光灯数量
    BYTE                byReserved[4];              // 保留字节,用于字节对齐
    NET_NEAR_LIGHT      stuNearLight[4];            // 近光灯组
    NET_MIDDLE_LIGHT    stuMiddleLight[4];          // 中光灯组
    NET_FAR_LIGHT       stuFarLight[4];             // 远光灯组
}NET_VIDEOIN_LIGHTINGEX_INFO;

// 抓图模式配置
typedef struct tagNET_SNAP_MODE
{
    DWORD                           dwSize;
    int                             nMode;                      // 0自动抓图，1手动抓图，2关闭抓图
    BOOL                            bDirectStorageMode;         // 直存模式，TRUE打开，FALSE关闭
}NET_SNAP_MODE;

// 刻录光盘编码计划(对应命令 CFG_CMD_ENCODEPLAN)，每个通道(包括画中画通道)一个配置结构体
typedef struct tagNET_ENCODE_PLAN_INFO
{
	DWORD				dwSize;
	BOOL                bEnable;                        // 通道是否需要配置,FALSE:没有此通道,TRUE:此通道可用
	unsigned int        nExpectTime;                    // 业务预期时长	 整型,单位：分钟
	CAPTURE_SIZE		emResolution;                   // 视频分辨率
	unsigned int        nBitRate;                       // 视频固定码流值(kbps)
	unsigned int		nPacketSize;					// 单个刻录文件打包大小(KB)
}NET_ENCODE_PLAN_INFO;

// 合成通道配置(对应命令 NET_EM_CFG_COMPOSE_CHANNEL)
typedef struct tagNET_COMPOSE_CHANNEL_INFO
{
	DWORD				dwSize;
	DH_SPLIT_MODE		emSplitMode;			// 分割模式
	int					nChannelCombination[CFG_MAX_VIDEO_CHANNEL_NUM]; // 割模式下的各子窗口显示内容
	int					nChannelCount;			// 分割窗口数量
} NET_COMPOSE_CHANNEL_INFO;

// 乐清外接灯光配置(NET_EM_CFG_YUEQING_SUPPLYLIGHTING)
typedef struct tagNET_YUEQING_SUPPLYLIGHTING_INFO
{
	DWORD				dwSize;
	BOOL				bTimeEnable;					// 定时控制使能(放弃使用)
	BOOL				bManualEnable;					// 手动控制使能，true : 打开 false : 关闭
	unsigned int		nPreferentialMode;				// 补光灯控制状态 0 ： 光敏感控制 1：手动控制 2：定时控制	
	unsigned int		nBrightness;					// 补光灯亮度 范围【1~255】
	DH_TSECT			stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// 布撤防时间段
}NET_YUEQING_SUPPLYLIGHTING_INFO;

// 分页获取信息标注信息列表输入参数(CLIENT_ScenicSpotGetPointInfos)
typedef struct tagNET_IN_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nChannelID;						// 通道号
	int					nOffset;						// 从第几位开始获取（最大 255）
	int					nLimit;							// 获取几个信息点结构（从 0 开始） 
}NET_IN_SCENICSPOT_GETPOINTINFOS_INFO;


typedef struct tagNET_POINT_INFO
{
	DH_POINT	stuMasterPoint;		// 主相机标定点
	DH_POINT	stuSlavePoint;		// 从相机(球机)标定点
	BYTE        byReserved[256];	// 保留字段
}NET_POINT_INFO;

typedef struct
{
    int                nHorizontalAngle;               // 水平角度 
    int                nVerticalAngle;                 // 垂直角度
    int                nMagnification;                 // 放大倍数
} POSTION;

typedef struct tagNET_POSTIONF
{
	float                fHorizontalAngle;               // 水平角度 [-1,1]
	float                fVerticalAngle;                 // 垂直角度 [-1,1]
	float                fMagnification;                 // 放大倍数 [-1,1]
} NET_POSTIONF;

typedef struct tagNET_POINT_PAIR_EX
{
    int					nCaliSceneID;           // 标定场景序号，拼接后的全景画面可以分成多个场景进行标定
	PTZ_SPACE_UNIT		stuSlaveCenter;			// 标定第一目时，球机转到和第一目场景近似的地方，记下此时球机中心点坐标
	NET_POINT_INFO		stuPoint[16];			// 在该场景固定球机后，记录两个画面的像素点坐标对应关系 
	int					nEffectiveNumber;		// stuPoint 有效个数
	float				fMasterZoom;			// 天枢相机(枪球一体设备)，枪机具备变倍功能，智能场景恢复时，根据这个值调整倍率,范围[0,1]
	BYTE                byReserved[252];		// 保留字段
} NET_POINT_PAIR_EX;

// 多目相机标定配置
typedef struct tagNET_CALIBRATE_MATRIX_ELEMENT_EX
{
	char                szMasterSN[48];							// 主设备序列号
    char                szSlaveSN[48];							// 从设备序列号
	PTZ_SPACE_UNIT		stuExpectRatio;							// 期望倍率(可选)
	NET_POINT_PAIR_EX	stuPointPairEx[8];						// 多目主从跟踪标定点对
	int					nEffectiveNumber;						// stuPointPairEx 有效个数
	BYTE                byReserved[256];						// 保留字段
} NET_CALIBRATE_MATRIX_ELEMENT_EX;

//主从式跟踪器标定矩阵扩展配置 多目情况下使用(对应 NET_EM_CFG_CALIBRATE_MATRIX 命令)
typedef struct tagNET_MULTI_SENSOR_INFO
{
	DWORD							 dwSize;
    DWORD							 nMaxCalibElement;			// 主从跟踪器标定矩阵配置元素最大个数(用户填写)
	DWORD							 nRetCalibElement;			// 主从跟踪器标定矩阵配置元素实际个数(仅是获取时有效)
	NET_CALIBRATE_MATRIX_ELEMENT_EX	*pstCaliMatrixElementEx;	// 内存由用户申请		  
} NET_MULTI_SENSOR_INFO;

// 标定模式
typedef enum tagNET_EM_CALIBRATION_MODES
{
	NET_EM_CALIBRATION_MODES_UNKNOWN,							// 未知标定
	NET_EM_CALIBRATION_MODES_AUTO,								// 自动标定
	NET_EM_CALIBRATION_MODES_MANUAL,							// 手动标定
	NET_EM_CALIBRATION_MODES_SEMIAUTO,							// 半自动标定
	NET_EM_CALIBRATION_MODES_CLIENTAUTO							// 客户端自动标定
}NET_EM_CALIBRATION_MODES;

// 灵瞳相机标定配置
typedef struct tagNET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE
{
	NET_EM_CALIBRATION_MODES	emMode;							// 支持多模式标定的相机，当前生效的标定模式
	char                szMasterSN[48];							// 主设备序列号
	char                szSlaveSN[48];							// 从设备序列号
	PTZ_SPACE_UNIT		stuExpectRatio;							// 期望倍率(可选)
	NET_POINT_PAIR_EX	stuPointPairEx[8];						// 多场景手动标定点对
	int					nPointPairNumber;						// stuPointPairEx 有效个数
	NET_POINT_PAIR_EX	stuAutoPointPairEx[8];					// 算法自动计算出的多个场景标定参数
	int					nAutoPointPairNumber;					// stuAutoPointPairEx 有效个数
	BYTE                byReserved[512];						// 保留字段
} NET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE;

//主从式跟踪器标定矩阵扩展配置 灵瞳相机使用(对应 NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTIMODE 命令)
typedef struct tagNET_CALIBRATEMATRIX_MULTIMODE_INFO
{
	DWORD									dwSize;
    DWORD									nMaxCalibElement;			// 主从跟踪器标定矩阵配置元素最大个数(用户填写)
	DWORD									nRetCalibElement;			// 主从跟踪器标定矩阵配置元素实际个数(仅是获取时有效)
	NET_CALIBRATE_MATRIX_ELEMENT_MULTIMODE	*pstCaliMatrixElementEx;	// 内存由用户申请		  
} NET_CALIBRATEMATRIX_MULTIMODE_INFO;

// 智能养殖定时抓图配置
typedef struct tagNET_CFG_AUTO_SNAP_SCHEDULE_INFO
{
    DWORD           dwSize;                 // 结构体大小
    BOOL            bEnable;                // 是否使能定时抓图
    UINT            nChannelNum;            // 抓图通道个数
    int             arnChannelID[2];        // 抓图通道号
    UINT            nPeriod;                // 抓图周期, 单位秒
} NET_CFG_AUTO_SNAP_SCHEDULE_INFO;

#define MAX_STAFF_COUNT		32		// 最大标定线数量

// 标定尺线信息
typedef struct tagNET_MAP_STAFF_INFOO
{
	NET_POINT	stuStartPoint;		// 起点坐标
	NET_POINT	stuEndPoint;		// 终点坐标
	double		dbLength;			// 实际长度, 单位米
	BYTE        byReserved[256];	// 保留字段
} NET_MAP_STAFF_INFO;

// 人群分布标定配置
typedef struct tagNET_CROWDDISTRIMAP_CALIBRATE_INFO
{
	DWORD							dwSize;							// 此结构体大小
	int								nStaffNum;						// 标定尺线数量
	NET_MAP_STAFF_INFO				stuStaffInfo[MAX_STAFF_COUNT];	// 标定尺线信息
} NET_CROWDDISTRIMAP_CALIBRATE_INFO;

// 时间段信息
typedef struct tagNET_TIME_SECTION 
{
	BOOL				bEnable;			// 使能 0:时间段无效  1:时间段有效
	int					nBeginHour;			// 开始 时
	int					nBeginMin;			// 开始 分
	int					nBeginSec;			// 开始 秒
	int					nEndHour;			// 结束 时
	int					nEndMin;			// 结束 分
	int					nEndSec;			// 结束 秒
	BYTE				byReserved[80];		// 保留字段
} NET_TIME_SECTION;

// 如果为周，从星期一开始；单双号取前两个元素1-单、2-双
typedef struct tagNET_NOPASSING_TIMESECTION_INFO
{
	int						nLimitedNum;											// 限制的个数
	int						nPlateTailNum[MAX_PLATE_TAILNUM];						// 限行的车牌尾号（默认为最后一个，如果为字母就倒数第二个，以此类推）
	char					szLegalPlateHead[MAX_COMMON_STRING_8];					// 合法车牌的首字符、首字母，不符合的需要抓拍。
																					// 中文编码格式为UTF8; 为空表示不按本地字规则抓拍			
	NET_TIME_SECTION		stuTimeSection;											// 抓拍时间段
	BYTE					byReserved[256];										// 保留字段
}NET_NOPASSING_TIMESECTION_INFO;

//事件类型 EVENT_IVS_TRAFFIC_NOPASSING (交通违章-禁止通行事件)对应的配置
typedef struct tagNET_TRAFFIC_NOPASSING_INFO
{
	DWORD									dwSize;													// 此结构体大小
	BOOL									bEnable;												// 时间配置使能
	int										nLaneNumber;											// 车道号
	int										nTimeSectionMode;										// 限行时间模式 0-星期(默认) 1-单双号
	int										nNoPassingTimeNumRow;									// 禁行天数
	int										nNoPassingTimeNumCol;									// 禁行时间段个数
	NET_NOPASSING_TIMESECTION_INFO			stuNoPassingTimeSection[DH_N_WEEKS][DH_N_REC_TSECT];	// 禁行时间段信息配置
}NET_TRAFFIC_NOPASSING_INFO;

// 标定区域信息
typedef struct tagNET_CALIBRATE_AREA_INFO
{
    int         nCalibratePloygonAreaNum;                                       // 标定多边形区域顶点个数
    DH_POINT	stuCalibratePloygonArea[MAX_CALIBRATE_PLOYGON_AREA_NUM];		// 标定多边形区域
    int         nCalibrateRectNum;                                              // 标定框个数
    NET_RECT    stuCalibrateRects[MAX_CALIBRATE_RECT_NUM];                      // 标定框, 需在标定多边形区域内
    BYTE        byReserved[256];	                                            // 保留字段
} NET_CALIBRATE_AREA_INFO;

// 场景信息
typedef struct tagNET_SCENE_INFO
{
    int								nSceneID;						            // 场景编号, 单场景为0, 多场景为0~N
    NET_CALIBRATE_AREA_INFO		    stuCalibrateAreaInfo;	                    // 标定区域信息
    BYTE                            byReserved[256];                            // 保留字段
} NET_SCENE_INFO;

// 打架标定配置
typedef struct tagNET_FIGHT_CALIBRATE_INFO
{
    DWORD							dwSize;							            // 结构体大小
    int								nSceneNum;						            // 场景个数
    NET_SCENE_INFO	                stuScenes[MAX_SCENE_NUM];	                // 场景信息
} NET_FIGHT_CALIBRATE_INFO;

typedef struct
{								
    int                nX;								// 第一个元素表示景物点的x坐标(0~8191) 
    int                nY;								// 第二个元素表示景物点的y坐标(0~8191)
} POINTCOORDINATE;											

// 景物形状
typedef enum tagNET_EM_SHAPE_TYPE
{
	NET_EM_SHAPE_TYPE_UNKNOWN = -1,				// 未知
	NET_EM_SHAPE_TYPE_MANSARD,					// 折线形
	NET_EM_SHAPE_TYPE_SECTOR,					// 扇形
}NET_EM_SHAPE_TYPE;

typedef struct
{
	int					nIndex;									// 信息点编号
	bool				bEnable;								// 信息点是否生效
	bool				bTitleAttribute;						// 该信息点是否有子标题
	POSTION				stuPostion;								// 云台方向与放大倍数（第一个元素为水平角度，0~3600；第二个元素为垂直角度，-1800~1800；第三个元素为放大倍数，0~127）
	POINTCOORDINATE		stuPoint;								// 景物点位置（使用相对坐标体系，取值均为0-8191在整个屏幕上的位置）
	char				szTitleName[MAX_COMMON_STRING_64];		// 一级标题名称
	BYTE				byTitleType;							// 一级标题名称类型	
	BYTE				byReserved[3];							// 预留字节
	NET_EM_SHAPE_TYPE	emShapeType;							// 景物形状
	DH_POINT		    stuPolygon[DH_MAX_POLYGON_NUM];			// 景物的轮廓,每个点依次表示轮廓顶点坐标
	int					nRetPolygonPointNum;					// 返回的景物轮廓顶点个数
	BYTE                byReserved1[184];						// 保留字段
}POINTINFOS;

// 分页获取信息标注信息列表输出参数(CLIENT_ScenicSpotGetPointInfos)
typedef struct tagNET_OUT_SCENICSPOT_GETPOINTINFOS_INFO
{
	DWORD				dwSize;
	int					nTotal;										// 设备总共多少个景物点信息
	int					nRetSceneNum;								// 当前获取到景物点个数
	POINTINFOS			stuPointInfos[MAX_SCENICSPOT_POINTS_NUM];	// 数组长度等于limit,最后一组查询可能小于limit		
}NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO;

// 设置景物点，原编号的景物点将会被覆盖 输入参数(CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_IN_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
	int					nChannel;										// 通道号
	int					nIndex;											// 信息点编号
	bool				bEnable;										// 信息点是否生效
	bool				bTitleAttribute;								// 该信息点是否有子标题
	POSTION				stuPosition;									// 云台方向与放大倍数
	POINTCOORDINATE		stuPoint;										// 景物点位置
	char				szTitleName[MAX_COMMON_STRING_64];				// 一级标题名称
	BYTE				byTitleType;									// 一级标题名称类型
	BYTE				byReserved[3];									// 预留字节
	NET_EM_SHAPE_TYPE   emShapeType;									// 景物形状
	DH_POINT		    stuPolygon[DH_MAX_POLYGON_NUM];					// 景物的轮廓,每个点依次表示轮廓顶点坐标
	int					nPolygonPointNum;								// 景物轮廓点的个数，最大不超过DH_MAX_POLYGON_NUM
}NET_IN_SCENICSPOT_SETPOINTINFO_INFO;

// 设置景物点，原编号的景物点将会被覆盖 输出参数(CLIENT_ScenicSpotSetPointInfo)
typedef struct tagNET_OUT_SCENICSPOT_SETPOINTINFO_INFO
{
	DWORD				dwSize;
}NET_OUT_SCENICSPOT_SETPOINTINFO_INFO;

// 获取景物点支持的能力(CLIENT_ScenicSpotGetCaps 输入参数) 
typedef struct tagNET_IN_SCENICSPOT_GETCAPS_INFO
{
	DWORD				dwSize;
	int					nChannel;					// 通道号
}NET_IN_SCENICSPOT_GETCAPS_INFO;

// 能力集
typedef struct tagNET_SCENICSPOT_CAPS_INFO
{
	BOOL						bEnable;			// 是否支持景物点功能
	unsigned int				nTotalNum;			// 总共最多支持多少个景物点
	unsigned int				nRegionNum;			// 单画面最多支持多少个景物点
	BYTE                		byReserved[256];	// 保留字段
}NET_SCENICSPOT_CAPS_INFO;

// 获取景物点支持的能力(CLIENT_ScenicSpotGetCaps 输出参数)
typedef struct tagNET_OUT_SCENICSPOT_GETCAPS_INFO
{
	DWORD						dwSize;
	NET_SCENICSPOT_CAPS_INFO	stuCaps;			// 能力集信息
}NET_OUT_SCENICSPOT_GETCAPS_INFO;


// 以景物标注点为中心，进行三维定位的输入参数(对应 CLIENT_ScenicSpotTurnToPoint) 
typedef struct tagNET_IN_SCENICSPOT_TURNTOPOINT_INFO
{
	DWORD						dwSize;
	int							nChannel;			// 通道号
	int							nIndex;				// 景物点编号
}NET_IN_SCENICSPOT_TURNTOPOINT_INFO;


// 以景物标注点为中心，进行三维定位的输出参数(对应 CLIENT_ScenicSpotTurnToPoint) 
typedef struct tagNET_OUT_SCENICSPOT_TURNTOPOINT_INFO
{
	DWORD						dwSize;
}NET_OUT_SCENICSPOT_TURNTOPOINT_INFO;

// 报警声音效果
typedef enum tagEM_ALARM_SOUND_EFFECT
{
    EM_ALARM_SOUND_EFFECT_UNKNOWN,                      // 未知的音效
    EM_ALARM_SOUND_EFFECT_MUTE,                         // 静音
    EM_ALARM_SOUND_EFFECT_NOTICE,                       // 较为轻柔的报警音, 起到提示作用
    EM_ALARM_SOUND_EFFECT_ALERT,                        // 尖锐响亮的报警音, 起到警示作用
}EM_ALARM_SOUND_EFFECT;

// 报警网关语音配置
typedef struct tagNET_ALARM_SOUND_INFO
{
    DWORD				dwSize;
    EM_ALARM_SOUND_EFFECT emSoundEffect;                // 声音效果
}NET_ALARM_SOUND_INFO;

// 双目标定结果配置
typedef struct tagNET_STEREO_CALIBRATE_INFO
{
	DWORD				dwSize;
	int					nCameraHeight;					// 保存上次标定高度，单位cm
	float				fCameraAngle;					// 保存上次标定角度，单位角度
} NET_STEREO_CALIBRATE_INFO;

// 网络连接模式
typedef enum tagEM_LINK_MODE
{
    EM_LINK_MODE_UNKNOWN,                                       // 未知模式
    EM_LINK_MODE_AUTO,                                          // 自动选择合适的模式
    EM_LINK_MODE_ADHOC,                                         // 是一种特殊的无线网络应用模式, 一群计算机接上无线网络卡, 即可相互连接, 资源共享, 无需透过Access Point
    EM_LINK_MODE_INFRASTRUCTURE,                                // 是一种整合有线与无线局域网络架构的应用模式, 可以网络资源共享, 此应用需透过Access Point。
}EM_LINK_MODE;

// AP加密方式
typedef enum tagEM_AP_DATA_ENCRYPT
{
    EM_AP_DATA_ENCRYPT_UNKNOWN,                           // UnKnown
    EM_AP_DATA_ENCRYPT_NONE,                              // NONE
    EM_AP_DATA_ENCRYPT_AUTO,                              // AUTO
    EM_AP_DATA_ENCRYPT_SHARED,                            // SHARED
    EM_AP_DATA_ENCRYPT_OPEN,                              // OPEN
    EM_AP_DATA_ENCRYPT_TKIP,                              // TKIP
    EM_AP_DATA_ENCRYPT_AES,                               // AES
} EM_AP_DATA_ENCRYPT;

// 功率模式
typedef enum tagEM_AP_POWER_MODE
{
    EM_AP_POWER_MODE_UNKNOWN,                             // UnKnown
    EM_AP_POWER_MODE_LOW,                                 // Low
    EM_AP_POWER_MODE_MIDDLE,                              // Middle
    EM_AP_POWER_MODE_HIGH,                                // High
}EM_AP_POWER_MODE;

// DHCP 配置
typedef struct tagNET_DHCP_INFO
{
    char                    szStartIP[NET_IPADDRSTR_LEN];       // 分配的起始IP
    char                    szStopIP[NET_IPADDRSTR_LEN];        // 分配的结束IP
    int                     nLeaseTime;                         // 续租时间 单位: 分钟
    BYTE                    byReserved[512];                    // 保留字段
}NET_DHCP_INFO;

// WEP认证配置
typedef struct tagNET_WEP_INFO
{
    int                     nKeyID;                             // 秘钥索引, 取值0~3
    char                    szKeys[MAX_WEP_KEY_NUM][MAX_COMMON_STRING_64];// 四组密码
    BYTE                    byReserved[256];                    // 保留字段
}NET_WEP_INFO;


// WPA/WPA2 PSK配置
typedef struct tagNET_WPA_PSK_INFO
{
    char                    szPassword[MAX_COMMON_STRING_64];  // 密码
    BYTE                    byReserved[256];                   // 保留字段
}NET_WPA_PSK_INFO;

// EAP方法
typedef enum tagEM_EAP_METHOD
{
    EM_EAP_METHOD_UNKNOWN,                                      // UnKnown
    EM_EAP_METHOD_PEAP,                                         // PEAP
    EM_EAP_METHOD_TLS,                                          // TLS
    EM_EAP_METHOD_TTLS,                                         // TTLS
} EM_EAP_METHOD;

// EAP身份验证方法
typedef enum tagEM_EAP_AUTH_TYPE
{
    EM_EAP_AUTH_TYPE_UNKNOWN,                                   // UnKnown
    EM_EAP_AUTH_TYPE_NONE,                                      // NONE
    EM_EAP_AUTH_TYPE_PAP,                                       // PAP
    EM_EAP_AUTH_TYPE_MSCHAP,                                    // MSCHAP
    EM_EAP_AUTH_TYPE_MSCHAPV2,                                  // MSCHAPV2
    EM_EAP_AUTH_TYPE_GTC,                                       // GTC
} EM_EAP_AUTH_TYPE;

// AP认证方式
typedef enum tagEM_AP_AUTHENTICATION
{
    EM_AP_AUTHENTICATION_UNKNOWN,                         // UnKnown
    EM_AP_AUTHENTICATION_OPEN,                            // OPEN
    EM_AP_AUTHENTICATION_WEP,                             // WEP
    EM_AP_AUTHENTICATION_WPAPSK,                          // WPA PSK
    EM_AP_AUTHENTICATION_WPA2PSK,                         // WPA2 PSK
    EM_AP_AUTHENTICATION_WPA,                             // WPA
    EM_AP_AUTHENTICATION_WPA2,                            // WPA2
} EM_AP_AUTHENTICATION;

// WPA/WPA2配置
typedef struct tagNET_EAP_INFO
{
    EM_EAP_METHOD           emMethod;                           // EAP方法
    EM_EAP_AUTH_TYPE        emAuthType;                         // EAP身份验证方法
    char                    szIdentity[MAX_COMMON_STRING_64];   // 身份
    char                    szAnonymousID[MAX_COMMON_STRING_64];// 匿名身份
    char                    szPassword[MAX_COMMON_STRING_64];   // 密码
    char                    szCaCert[MAX_COMMON_STRING_512];    // CA证书
    char                    szUserCert[MAX_COMMON_STRING_512];  // 用户证书 
    BYTE                    byReserved[256];                    // 保留字段
}NET_EAP_INFO;

// WIFI 连接方式
typedef enum tagEM_WIFI_CONNECT_TYPE
{
    EM_WIFI_CONNECT_TYPE_UNKNOWN,                               // 未知
    EM_WIFI_CONNECT_TYPE_PUSH_BUTTON,                           // 按钮方式
    EM_WIFI_CONNECT_TYPE_PIN_ENROLLEE,                          // PIN 码方式
    EM_WIFI_CONNECT_TYPE_PIN_REG,                               // PIN REG方式 目前暂不支持
}EM_WIFI_CONNECT_TYPE;

// WIFI 安全保护配置
typedef struct tagNET_WPS_INFO
{
    EM_WIFI_CONNECT_TYPE   emConnType;                          // 连接方式
    char                   szPIN[MAX_COMMON_STRING_32];         // PIN码, 当连接方式为PIN码方式时需要填写
    BYTE                   byReserved[256];                    // 保留字段
}NET_WPS_INFO;

// 地址过滤列表
typedef struct tagNET_FILTER_ADDRESS_LIST
{
    BOOL                    bEffective;                         // 在列表中有效性 true有效，false无效
    char                    szMAC[DH_MACADDR_LEN];              // 设备MAC地址
    char                    szDescribeText[DH_COMMON_STRING_256]; // 对该MAC的描述信息    
    BYTE                    byReserved[256];                    // 保留字段
}NET_FILTER_ADDRESS_LIST;

// 地址列表过滤策略
typedef enum tagEM_ADDRLIST_FILTER_POLICY
{
    EM_ADDRLIST_FILTER_POLICY_UNKNOWN,                          // 未知
    EM_ADDRLIST_FILTER_POLICY_WHITE,                            // "white" : 允许列表中的有效地址设备连接热点，白名单。
    EM_ADDRLIST_FILTER_POLICY_BLACK,                            // "black" : 禁止列表中的有效地址设备连接热点，黑名单。
}EM_ADDRLIST_FILTER_POLICY;

// AccessPoint 接入过滤配置
typedef struct tagNET_AP_FILTER
{
    BOOL                    bEnable;                            // 是否开启过滤功能
    int                     nMaxAccessNum;                      // 最大Wifi设备连接个数
    EM_ADDRLIST_FILTER_POLICY emPolicy;                         // 过滤策略
    NET_FILTER_ADDRESS_LIST *pstuAddrList;                      // 地址过滤列表，由用户申请内存和释放                     
    int                     nMaxListNum;                        // 地址最大个数
    int                     nRetListNum;                        // 返回的地址个数
    BYTE                    byReserved[256];                    // 保留字段
}NET_AP_FILTER;

//Accesspoint 工作模式
typedef enum tagEM_WORKPATTERN
{
    EM_WORKPATTERN_UNKNOWN,                          // 未知
    EM_WORKPATTERN_2_4G,                             // 默认为2.4G工作模式的配置
    EM_WORKPATTERN_5G,                               // 5G模式的配置
}EM_WORKPATTERN;

// AP 工作模式配置
typedef struct tagNET_AP_WORKPATTERN
{
    EM_WORKPATTERN          emWorkPatternType;                  // 工作模式:2.4G/5G
    BOOL                    bEnable;                            // WIFI网卡使能开关, TRUE打开, FALSE关闭
    BOOL                    bHideSSID;                          // 是否隐藏SSID, TRUE 隐藏, FALSE 显示
    char                    szSSID[DH_COMMON_STRING_36];        // 网络名称(SSID)
    EM_LINK_MODE            emLinkMode;                         // 网络连接模式
    int                     nPriority;                          // 优先级 (范围 1-32)
    int                     nChannel;                           // 信道号 (范围 1-13)
    int                     nChannelBandwidth;                  // 信道带宽 单位: M
    EM_AP_AUTHENTICATION    emAuthentication;                   // 认证方式
    EM_AP_DATA_ENCRYPT      emDataEncryption;                   // 数据加密方式
    EM_AP_POWER_MODE        emPowerMode;                        // 功率模式
    BOOL                    bDHCPEnable;                        // 是否开启DHCP方式分配IP地址
    NET_DHCP_INFO           stuDHCP;                            // DHCP详细配置信息
    char                    szIPAddresss[NET_IPADDRSTR_LEN];    // IP地址
    char                    szSubnetMask[MAX_COMMON_STRING_16]; // 子网掩码
    char                    szDefaultGateway[MAX_COMMON_STRING_16]; // 默认网关
    NET_WEP_INFO            stuWEP;                             // WEP认证配置
    NET_WPA_PSK_INFO        stuWPAPSK;                          // WPA/WPA2 PSK配置
    NET_EAP_INFO            stuEAP;                             // WPA/WPA2 配置
    NET_WPS_INFO            stuWPS;                             // WPS 安全保护配置
    NET_AP_FILTER           stuFilter;                          // 接入过滤配置
    BYTE                    byReserved[1024];                   // 保留字段
}NET_AP_WORKPATTERN;

// 热点功能的网卡配置名
typedef enum tagEM_ACCESSPOINT_NAME
{
    EM_ACCESSPOINT_NAME_UNKNOWN,                          // 未知
    EM_ACCESSPOINT_NAME_ETH2,                             // "eth2" : 前端使用的软AP网卡名
    EM_ACCESSPOINT_NAME_WALN0,                            // "wlan0" : 存储使用的软AP网卡名
    EM_ACCESSPOINT_NAME_APRA0,                            // "apra0" :  提供硬AP功能的网卡名
}EM_ACCESSPOINT_NAME;

// AccessPoint 配置信息
typedef struct tagNET_ACCESSPOINT_INFO
{
    EM_ACCESSPOINT_NAME     emAccessPointName;                  // 提供热点功能的网卡配置名
    int                     nValidPatternNum;                   // 有效工作模式个数
    NET_AP_WORKPATTERN      stuWorkPattern[MAX_WORKPATTERN_NUM];// 工作模式配置:2.4G(默认)/5G
    BYTE                    byReserved[1024];                   // 保留字段
}NET_ACCESSPOINT_INFO;

// WIFI服务器端配置 (热点功能)
typedef struct tagNET_NETAPP_ACCESSPOINT
{
    DWORD                   dwSize;
    int                     nValidAPNum;                        // AccessPoints 有效个数
    NET_ACCESSPOINT_INFO    stuAccessPoints[NET_MAX_AP_NUM];    // AP 配置信息
}NET_NETAPP_ACCESSPOINT;

//乱序窗口类型
typedef enum tagEM_DISORDERWINDOW_TYPE
{
	EM_DISORDERWINDOW_TYPE_UNKNOWN = -1,
	EM_DISORDERWINDOW_TYPE_PACKETS_NUMBER = 0,   //数据包数量,默认
	EM_DISORDERWINDOW_TYPE_DATA_DELAY = 1,       //数据延时(ms)
	EM_DISORDERWINDOW_TYPE_MEMORY_SIZE = 2,      //内存大小(KB)
}EM_DISORDERWINDOW_TYPE;

// RTSP传输配置
typedef struct tagNET_CFG_RTSP_TRANSIT
{
	int                      nUdpSndBufSize;    //UDP发送socket缓冲区大小(单位:KB) 默认512 0-使用系统默认值
	int                      nUdpRcvBufSize;    //UDP接收socket缓冲区大小(单位:KB)默认512 0-使用系统默认值
	int                      nSliceSize;        //rtp报文分包大小(单位:字节),默认1472 建议值:网卡mtu-ip头部-udp头部
	int                      nFlowControlMaxDelay;/* 流控最大延迟，表示由于流量控制和
	整形引起的延迟最大不超过此值,默认400ms */
	int                      nFlowControlCoefficient;/* 延迟系数，实际生效最大延迟= MaxDelay* Coefficient/100，
	值越大，表示容忍延迟越大，数据发送也就更均匀,范围[0,100],默认50 ,0表示关闭应用层流控*/
	EM_DISORDERWINDOW_TYPE   emDisorderWindowType;   //乱序窗口类型
	int                      nDisorderWindowValue;   //乱序窗口大小，默认为100个包
	BYTE                     byReserved[2048];  //保留字节
}NET_CFG_RTSP_TRANSIT;

//重传功能类型
typedef enum tagEM_RETRANSIT_TYPE
{
	EM_RETRANSIT_TYPE_UNKNOWN = -1,
	EM_RETRANSIT_TYPE_PACKETS_NUMBER = 0,   //数据包数量,默认
	EM_RETRANSIT_TYPE_DATA_DELAY = 1,       //数据延时(ms)
}EM_RETRANSIT_TYPE;

// DVRIP传输配置
typedef struct tagNET_CFG_DVRIP_TRANSIT
{
	int                      nUdpSndBufSize;     //UDP发送socket缓冲区大小(单位:KB),默认512 0-使用系统默认值
	int                      nMaxSize;           //最大码流数据包分包大小(单位:字节) 默认:1400 建议值:网卡mtu-ip头部-udp头部
	int 					 nFlowControlMaxDelay;/* 流控最大延迟，表示由于流量控制和
	整形引起的延迟最大不超过此值,默认400ms */
	int 					 nFlowControlCoefficient;/* 延迟系数，实际生效最大延迟= MaxDelay* Coefficient/100，
	值越大，表示容忍延迟越大，数据发送也就更均匀,范围[0,100],默认50 ,0表示关闭应用层流控*/
	EM_RETRANSIT_TYPE        emRetransitType;    //重传类型
	int                      nRetransitValue;    //重传值
	BYTE                     byReserved[2048];  //保留字节
}NET_CFG_DVRIP_TRANSIT;

// GB28181传输配置
typedef struct tagNET_CFG_GB28181_TRANSIT
{
	int                      nUdpSndBufSize;     //UDP发送socket缓冲区大小(单位:KB),默认512 0-使用系统默认值
	int                      nMaxSize;           //最大码流数据包分包大小(单位:字节) 默认:1400 建议值:网卡mtu-ip头部-udp头部
	int 					 nFlowControlMaxDelay;/* 流控最大延迟，表示由于流量控制和
	整形引起的延迟最大不超过此值,默认400ms */
	int 					 nFlowControlCoefficient;/* 延迟系数，实际生效最大延迟= MaxDelay* Coefficient/100，
	值越大，表示容忍延迟越大，数据发送也就更均匀,范围[0,100],默认50 ,0表示关闭应用层流控*/
	BYTE                     byReserved[2048];  //保留字节
}NET_CFG_GB28181_TRANSIT;

// 网络自适应传输配置对应NET_EM_CFG_NETAUTOADAPTTRANSIT
typedef struct tagNET_NETAUTOADAPTTRANSIT
{
	DWORD					dwSize;
	NET_CFG_RTSP_TRANSIT    stuRtsp;    //RTSP配置
	NET_CFG_DVRIP_TRANSIT   stuDvrip;   //DVRIP配置
	NET_CFG_GB28181_TRANSIT stuGB28181; //GB28181配置
}NET_NETAUTOADAPTTRANSIT;

// 标识名最大长度
#define	MAX_DN_LENGTH	128

// LDAP 配置
typedef struct tagNET_NETAPP_LDAP 
{
	DWORD					dwSize;
	BOOL					bEnable;							// 是否使能
	char					szServerIP[MAX_SERVER_ADDRESS_LEN];	// 服务IP地址
	int						nServerPort;						// 服务端口号
	char					szBindDN[MAX_DN_LENGTH];			// 绑定的标识名
	char					szBindPwd[MAX_PWD_LEN];				// 密码
	BOOL					bAnonymousBind;						// 是否匿名
	char					szBaseDN[MAX_DN_LENGTH];			// 基本标识名
	char					szFilter[DH_COMMON_STRING_128];		// 搜索范围
} NET_NETAPP_LDAP;


// 设备编号(与服务器配置保持一致,编号标识服务器对该设备日志具体存放路径)
typedef enum tagEM_SYSLOG_FACILITY_TYPE
{
	EM_SYSLOG_FACILITY_UNKNOWN = -1,
	EM_SYSLOG_FACILITY_KERNEL_MESSAGES,								// 0 kernel messages
	EM_SYSLOG_FACILITY_USER_LEVEL_MESSAGES,							// 1 user-level messages
	EM_SYSLOG_FACILITY_MAIL_SYSTEM,									// 2 mail system
	EM_SYSLOG_FACILITY_SYSTEM_DAEMONS,								// 3 system daemons
	EM_SYSLOG_FACILITY_SECURITY_MESSAGES,							// 4 security/authorization messages
	EM_SYSLOG_FACILITY_MESSAGES_GENERATED_INTERNALLY_BY_SYSLOGD,	// 5 messages generated internally by syslogd
	EM_SYSLOG_FACILITY_LINE_PRINTER_SUBSYSTEM,						// 6 line printer subsystem
	EM_SYSLOG_FACILITY_NETWORK_NEWS_SUBSYSTEM,						// 7 network news subsystem
	EM_SYSLOG_FACILITY_UUCP_SUBSYSTEM,								// 8 UUCP subsystem
	EM_SYSLOG_FACILITY_CLOCK_DAEMON,								// 9 clock daemon
	EM_SYSLOG_FACILITY_SECURITY_MESSAGES_2,							// 10 security/authorization messages
	EM_SYSLOG_FACILITY_FTP_DAEMON,									// 11 FTP daemon
	EM_SYSLOG_FACILITY_NTP_SUBSYSTEM,								// 12 NTP subsystem
	EM_SYSLOG_FACILITY_LOG_AUDIT,									// 13 log audit
	EM_SYSLOG_FACILITY_LOG_ALERT,									// 14 log alert
	EM_SYSLOG_FACILITY_CLOCK_DAEMON_2,								// 15 clock daemon
	EM_SYSLOG_FACILITY_LOCAL_USE_0,									// 16 local use 0
	EM_SYSLOG_FACILITY_LOCAL_USE_1,									// 17 local use 1
	EM_SYSLOG_FACILITY_LOCAL_USE_2,									// 18 local use 2
	EM_SYSLOG_FACILITY_LOCAL_USE_3,									// 19 local use 3
	EM_SYSLOG_FACILITY_LOCAL_USE_4,									// 20 local use 4
	EM_SYSLOG_FACILITY_LOCAL_USE_5,									// 21 local use 5
	EM_SYSLOG_FACILITY_LOCAL_USE_6,									// 22 local use 6
	EM_SYSLOG_FACILITY_LOCAL_USE_7,									// 23 local use 7
} EM_SYSLOG_FACILITY_TYPE;

// Syslog 配置
typedef struct tagNET_NETAPP_SYSLOG 
{
	DWORD						dwSize;
	BOOL						bEnable;							// 使能
	char						szServerIP[MAX_SERVER_IP_LEN];		// 服务器地址
	int							nServerPort;						// 服务端口号
	EM_SYSLOG_FACILITY_TYPE		emFacility;							// 设备编号
} NET_NETAPP_SYSLOG;

// 接入网络
typedef enum tagEM_WIRELESS_APN_TYPE
{
	EM_WIRELESS_APN_UNKNOWN = -1,									// 未知
	EM_WIRELESS_APN_CUSTOMIZED,										// 自定义
	EM_WIRELESS_APN_CTNET,											// 中国电信
	EM_WIRELESS_APN_CMNET,											// 中国移动
	EM_WIRELESS_APN_UNINET,											// 中国联通
}EM_WIRELESS_APN_TYPE;

// 鉴权模式
typedef enum tagEM_WIRELESS_AUTH_MODE
{
	EM_WIRELESS_AUTH_MODE_UNKNOWN = 0,
	EM_WIRELESS_AUTH_MODE_NO,										// 无需鉴权
	EM_WIRELESS_AUTH_MODE_PAP,										// PAP鉴权
	EM_WIRELESS_AUTH_MODE_CHAP,										// CHAP鉴权
}EM_WIRELESS_AUTH_MODE;

// 流量控制策略
typedef enum tagEM_WIRELESS_3GFLUX_TACTICS
{
	EM_WIRELESS_3GFLUX_TACTICS_UNKNOWN = 0,
	EM_WIRELESS_3GFLUX_TACTICS_BYFLUX_MONTHLY,							// 包月按流量
	EM_WIRELESS_3GFLUX_TACTICS_BYTIME_MONTHLY							// 包月按时长
}EM_WIRELESS_3GFLUX_TACTICS;

// 每日流量控制策略
typedef enum tagEM_WIRELESS_DAY3GFLUX_TACTICS
{
	EM_WIRELESS_DAY3GFLUX_TACTICS_UNKNOWN = 0,
	EM_WIRELESS_DAY3GFLUX_TACTICS_BYFLUX,								// 按流量
	EM_WIRELESS_DAY3GFLUX_TACTICS_BYTIME								// 按时长
}EM_WIRELESS_DAY3GFLUX_TACTICS;

// 每日达到流量上限动作
typedef enum tagEM_WIRELESS_3GFLUX_ACTION
{
	EM_WIRELESS_3GFLUX_ACTION_UNKNOWN = 0,
	EM_WIRELESS_3GFLUX_ACTION_NOTHING,									// 无动作
	EM_WIRELESS_3GFLUX_ACTION_3GNETDOWN									// 3G下线
}EM_WIRELESS_3GFLUX_ACTION;

// 工作模式选择
typedef enum tagEM_WIRELESS_WORK_MODE
{
	EM_WIRELESS_WORK_MODE_UNKNOWN = 0,
	EM_WIRELESS_WORK_MODE_CDMA1X,											// CDMA1x
	EM_WIRELESS_WORK_MODE_EVDO,												// EVDO
	EM_WIRELESS_WORK_MODE_TD_SCDMA,											// TD-SCDMA
	EM_WIRELESS_WORK_MODE_WCDMA,											// WCDMA
	EM_WIRELESS_WORK_MODE_EDGE,												// EDGE
	EM_WIRELESS_WORK_MODE_TDD_LTE,											// TDD-LTE
	EM_WIRELESS_WORK_MODE_FDD_LTE,											// FDD-LTE
}EM_WIRELESS_WORK_MODE;

#define	MAX_DAIL_NUMBER	32													// Wireless中拨号号码长度
// 蜂窝网络连接设置
typedef struct tagNET_NETAPP_WIRELESS
{
	DWORD						dwSize;
	BOOL						bEnable;					                // 蜂窝网络使能开关
	int							nIndex;										// 模块索引。只读，即PAL层获取的index
	int							nKeepAlive;						            // 保活时间, 单位为秒，0表示不自动断开
	EM_WIRELESS_APN_TYPE		emAPN;							            // 接入网络， 当为自定义时，使用szAPNName字符串透传
	char						szAPNName[DH_COMMON_STRING_32];				// 接入网络名，当emAPN为自定义时，使用szAPNName字符串透传，例如:"CTNET", "CMNET", "UNINET", "CUSTOMIZED"
	EM_WIRELESS_AUTH_MODE		emAuthMode;									// 鉴权模式
	char						szUserName[DH_COMMON_STRING_64];	        // 用户名
	char						szPassword[DH_COMMON_STRING_64];	        // 密码
	BOOL						bAutoDial;									// 按时间自动拨号开关, 默认为true，如果打开，拨号时间段使用stuTimeSection,false时，stuTimeSection配置无效
	DH_TSECT					stuTimeSection[DH_N_WEEKS][DH_N_REC_TSECT]; // 拨号时间段

	EM_WIRELESS_3GFLUX_TACTICS	em3GFluxTactic;								// 流量使用策略
	UINT						n3GFluxUp;									// 流量使用上限, [0,65535]MB或者分钟
	UINT						n3GFlux;									// 实际使用流量, [0,65535]MB或者分钟

	EM_WIRELESS_DAY3GFLUX_TACTICS emDay3GFluxTactic;						// 每日流量控制策略
	UINT						nDay3GFluxUp;								// 每日流量使用上限, [0,65535]MB或者分钟
	UINT						nDay3GFlux;									// 当日已使用流量, [0,65535]MB或者分钟
	EM_WIRELESS_3GFLUX_ACTION	emDay3GFluxAction;							// 流量报警策略,每日达到流量上限动作

	EM_WIRELESS_WORK_MODE		emWorkMode;									// 工作模式选择
	char						szDailNumber[MAX_DAIL_NUMBER];				// 拨号号码
	BOOL						bActivate;									// 是否已经被语音或短信激活
} NET_NETAPP_WIRELESS;

// 铁路记录信息
typedef struct tagNET_DEV_CAR_COACH_INFO
{
    DWORD                   dwSize;                         
    char                    szCarNo[MAX_CARNO_LEN];              // 车辆号
    char                    szCoachNo[MAX_COACHNO_LEN];          // 车厢号
}NET_DEV_CAR_COACH_INFO;

// 抓图流编码格式参照格式
typedef enum tagEM_MEDIA_GLOBAL_SNAP_FORMAT_AS
{
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_UNKNOWN,
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_MAIN_FORMAT,                  // 参照主码流
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA_FORMAT,				 // 参照辅码流1
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA2_FORMAT,				 // 参照辅码流2
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS_EXTRA3_FORMAT,				 // 参照辅码流3
}EM_MEDIA_GLOBAL_SNAP_FORMAT_AS;

// 媒体组件全局配置
typedef struct tagNET_MEDIA_GLOBAL_INFO
{
	DWORD               dwSize;
	int                 nPacketType;                          // 0:按时间,1：按大小
	BYTE                byPacketLength;                       // 录像打包时间长度,单位分钟。1-255
	BYTE                byAlign[3];                           // 对齐
	DWORD				dwPacketSize;                   	  // 录像打包文件长度,单位KB
	BOOL				bLogRecord;                           // 是否记录录像日志
	BOOL				bLogEncode;                           // 是否记录编码异常日志
	EM_MEDIA_GLOBAL_SNAP_FORMAT_AS  emSnapFormatAs;           // 抓图流编码格式参照格式；设备不支持独立配置抓图流分辨率格式时，抓图格式根据参照格式设置
}NET_MEDIA_GLOBAL_INFO;

// 车位设置(专有车位和普通车位设置) 对应 NET_EM_CFG_PARKINGSPACECELL_STATUS
// 注：数组最大16, 实际返回有效配置，请查看接口(NET_CONFIG_RETURN_INFO*)reserve参数
typedef struct tagNET_PARKINGSPACECELL_STATUS_INFO
{
	DWORD				dwSize;	
	int					nCellNumber;			// 车位号
	UINT				nCellType;				// 车位类型, -1:无效, 0:普通车位 1:专有车位 2:充电车位	
} NET_PARKINGSPACECELL_STATUS_INFO;

// 车位灯色
typedef struct tagNET_PARKINGSPACELIGHT_INFO
{
	int						nRed;					// 红灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nYellow;				// 黄灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nBlue;					// 蓝灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nGreen;					// 绿灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nPurple;				// 紫灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nWhite;					// 白灯: -1:无效, 0/灭, 1/亮, 2/闪烁
	int						nPink;					// 粉等: -1:无效, 0/灭, 1/亮, 2/闪烁
	BYTE					byReserved[32];			// 保留字节
} NET_PARKINGSPACELIGHT_INFO;

// 网络异常状态灯色
typedef struct tagNET_NETWORK_EXCEPTION_INFO
{
	NET_PARKINGSPACELIGHT_INFO  stNetPortAbortInfo[MAX_NETPORT_NUM];	// 网口断开状态灯色
	int							nRetNetPortAbortNum;					// 实际返回的个数
	NET_PARKINGSPACELIGHT_INFO	stuSpaceSpecialInfo;					// 车位专用状态灯色					
	NET_PARKINGSPACELIGHT_INFO	stuSpaceChargingInfo;					// 充电车位状态灯色
	BYTE						byReserved[256];						// 保留字节
} NET_NETWORK_EXCEPTION_INFO;

// 车位状态对应的车位指示灯色 对应 NET_EM_CFG_PARKINGSPACELIGHT_STATE
typedef struct tagNET_PARKINGSPACELIGHT_STATE_INFO
{
	DWORD								dwSize;
	NET_PARKINGSPACELIGHT_INFO			stuSpaceFreeInfo;			// 车位空闲状态灯色
	NET_PARKINGSPACELIGHT_INFO			stuSpaceFullInfo;			// 车位占满状态灯色
	NET_PARKINGSPACELIGHT_INFO			stuSpaceOverLineInfo;		// 车位压线状态灯色
	NET_PARKINGSPACELIGHT_INFO			stuSpaceOrderInfo;			// 车位预定状态灯色
	NET_NETWORK_EXCEPTION_INFO			stuNetWorkExceptionInfo;	// 网络异常状态灯色
} NET_PARKINGSPACELIGHT_STATE_INFO;

// NAS Protocol 类型
typedef enum __EM_NAS_PROTOCOL
{
	NAS_PROTOCOL_UNKNOW = 0,
	NAS_PROTOCOL_FTP,		// FTP
	NAS_PROTOCOL_SMB,		// SMB
	NAS_PROTOCOL_NFS,		// NFS
	NAS_PROTOCOL_ISCSI,		// ISCSI
	NAS_PROTOCOL_CLOUD,		// CLOUD
}EM_NAS_PROTOCOL;

// NAS 配置信息
typedef struct tagNET_NAS_INFO
{
	DWORD               dwSize;
    BOOL                bEnable;										// 是否启用	
	char				szName[MAX_COMMON_STRING_128];					// 名称
    char                szHostIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];			// IP地址或网络名
    WORD                wHostPort;										// 主机端口
	char				reserved[2];									// 保留字段
    char                szDirName[DH_FTP_MAX_PATH];						// FTP目录路径
    char                szUserName[DH_FTP_USERNAME_LEN];				// 用户名
    char                szPassword[DH_FTP_PASSWORD_LEN];				// 密码    
    int                 nInterval;										// 相邻文件时间间隔(1~600),单位秒   
	BOOL				bAnonymity;										// 匿名使能,匿名使能（Protocol为FTP时有效）
	EM_NAS_PROTOCOL     emProtocol;										// 协议类型	
}NET_NAS_INFO;

// PPPoE配置信息
typedef struct tagNET_PPPOE_INFO
{
	DWORD               dwSize; 
	BOOL				bEnable;								// 是否使能	
    char                szUserName[MAX_USER_NAME_LEN];			// 用户名
	char				szPasswd[MAX_PWD_LEN];					// 密码	
}NET_PPPOE_INFO;

// Email配置信息
typedef struct tagNET_EMAIL_INFO
{
	DWORD               dwSize;		
	BOOL                bEnable;									// 使能0:false,    1:true
	char                szMailIPAddr[DH_MAX_DOMAIN_NAME_LEN];		// 邮件服务器地址(IP或者域名)   
    WORD                wMailPort;									// 邮件服务器端口   
	char				reserved[2];								// 保留字段
    char                szSenderAddr[DH_MAX_MAIL_ADDR_LEN];			// 发送地址
    char                szUserName[DH_MAX_MAIL_NAME_LEN];			// 用户名
    char                szUserPsw[DH_MAX_MAIL_NAME_LEN];			// 用户密码
    char                szDestAddr[DH_MAX_MAIL_ADDR_LEN];			// 目的地址    
    char                szSubject[DH_MAX_MAIL_SUBJECT_LEN];			// 标题
	char				*szReceivers[DH_MAX_MAIL_ADDR_LEN];			// 收件人列表，用户分配内存 
	unsigned int		nReceiversNum;								// 收件人数量
	unsigned int		nReceiversNumRet;							// 设备返回的收件人数量    
    BOOL                bSSLEnable;									// SSL使能
	BOOL				bTLSEnable;									// TLS使能
    WORD                wSendInterval;								// 发送时间间隔,[0,3600]秒
    BYTE                bAnonymous;									// 匿名选项[0,1], 0表示FALSE,1表示TRUE.
    BYTE                bAttachEnable;								// 附件使能[0,1], 0表示FALSE,1表示TRUE.
	BOOL				bHealthReport;								// 健康邮件使能
	int					nHealthReportInterval;						// 健康邮件间隔   
}NET_EMAIL_INFO;

// DDNS配置信息
typedef struct tagNET_DDNS_INFO
{
	DWORD                dwSize;
    DWORD                dwDdnsServerNum; // DDNS 服务器数量
    DH_DDNS_SERVER_CFG   stuDdnsServer[DH_MAX_DDNS_NUM];
}NET_DDNS_INFO;

// 协议管理配置信息列表
typedef struct tagNET_PROTOCOLS_MANAGER
{
	char				szDesc[DH_COMMON_STRING_128];       // 协议描述,如:烟感探测器_DI_SMK
	BOOL				bEnable;							// 使能标志
	char				szProtocol[DH_COMMON_STRING_128];   // 协议名称,如:DI_SMK
	char				szShowType[DH_COMMON_STRING_128];	// 协议类型,如:SmokingSensor
	BYTE				byReserved[256];					// 保留字节
}NET_PROTOCOLS_MANAGER;

// 协议管理配置信息
typedef struct tagNET_SCADA_PROTOCOLS_MANAGER
{
	DWORD					dwSize;
	NET_PROTOCOLS_MANAGER*	pstProtocolsManager;		     // 协议管理配置信息
	int						nProtocolsManagerNum;		     // 协议管理配置信息个数
	int						nRetProtocolsManagerNum;		 // 实际返回的协议管理配置信息个数
															 // 如果第一次获取所有协议管理配置时，nRetProtocolsManagerNum大于nProtocolsManagerNum
															 // 那么在下一次获取所有协议管理配置时，nProtocolsManagerNum的值建议取nRetProtocolsManagerNum
}NET_SCADA_PROTOCOLS_MANAGER;

// 设备信息配置列表
typedef struct tagNET_DEVICEIDSETS
{
	char			  szDevName[DH_COMMON_STRING_32];		// 设备名称
	char			  szDevType[DH_COMMON_STRING_32];		// 设备类型
	char			  szNewDeviceId[DH_COMMON_STRING_32];   // 用户配置资产编码,szNewDeviceId实际大小要与szOldDeviceId的实际大小相同
	char			  szOldDeviceId[DH_COMMON_STRING_32];	// 默认资产编码
	BYTE			  byReserved[128];						// 保留字节
}NET_DEVICEIDSETS;

// 设备信息配置
typedef struct tagNET_SCADA_DEVICEINFO_CFG
{
	DWORD			    dwSize;
	char			    szCity[DH_COMMON_STRING_32];         // 所在城市
	char			    szProvince[DH_COMMON_STRING_32];     // 所在省份
	int				    nStation;							 // 基站类型
	NET_DEVICEIDSETS*	pstDeviceIdSets;					 // 接入设备信息
	int					nDeviceIdSetsNum;					 // 接入设备个数
	int					nRetDeviceIdSetsNum;				 // 返回的接入设备个数
}NET_SCADA_DEVICEINFO_CFG;
//控制器配置信息
typedef struct tagNET_SCADA_CONTROLLER_SITE_INFO
{
	char			szIPAddress[64];			// IP地址
	char			szDevName[64];				// 设备名称
	UINT			nPort;						// 端口
	char			szDeviceID[32];				// 设备ID.仅读不可修改，控制器唯一标识
	BYTE			bReserved[128];				// 保留字节
}NET_SCADA_CONTROLLER_SITE_INFO;
//控制器配置信息
typedef struct tagNET_CFG_SCADA_CONTROLLER_SITE_INFO
{
	DWORD								dwSize;						// 结构体大小
	int									nControllerNum;				// 控制器个数
	NET_SCADA_CONTROLLER_SITE_INFO		stuControllerInfo[128];		// 控制器信息
}NET_CFG_SCADA_CONTROLLER_SITE_INFO;

//链路层VPN类型
typedef enum tagNET_EM_LINK_LAYER_VPN_TYPE
{
	NET_EM_TYPE_UNKNOWN = 0,    // 未知类型
	NET_EM_TYPE_PPTP,           // PPTP类型的链路层VPN
	NET_EM_TYPE_L2TP,		    // L2TP类型的链路层VPN
}NET_EM_LINK_LAYER_VPN_TYPE;

//链路层VPN配置列表
typedef struct tagNET_NETAPP_LINK_LAYER_VPN
{
	char						szName[MAX_LINK_NAME_LEN];				// 连接名称
	NET_EM_LINK_LAYER_VPN_TYPE  emLinkLayerVPNType;						// 链路层VPN类型
	BOOL						bEnable;								// 使能开关
	char						szAddress[MAX_SERVER_ADDRESS_LEN];				// 服务器IP
	char						szUserName[MAX_USER_NAME_LEN];			// 用户名
	char						szPassword[MAX_PWD_LEN];				// 密码
	BYTE						byReserved[1024];						// 保留字节
}NET_NETAPP_LINK_LAYER_VPN;

//链路层VPN设置
typedef struct tagNET_NETAPP_LINK_LAYER_VPN_CFG
{
	DWORD			            dwSize;
	int							nRetLinkLayerVPNNum;					 //返回的链路层VPN配置个数
	NET_NETAPP_LINK_LAYER_VPN   stLinkLayerVPN[LINK_LAYER_VPN_NUM];   //链路层VPN设置数组
}NET_NETAPP_LINK_LAYER_VPN_CFG;

//ssh服务端配置 
typedef struct tagNET_NETAPP_SSHD_CFG 
{
	DWORD						dwSize;									// 结构体大小
	BOOL						bEnable;								// 是否开启sshd监听服务
} NET_NETAPP_SSHD_CFG;

// 联系人信息
typedef struct tagNET_MEMBERS_INFO
{
    char                        szName[MAX_COMMON_STRING_32];           // 联系人姓名
    char                        szMobile[MAX_COMMON_STRING_16];         // 设备描述
    char                        szEmail[MAX_COMMON_STRING_32];          // 电子邮箱
    char                        szOrganization[MAX_COMMON_STRING_64];   // 组织                            
}NET_MEMBERS_INFO;

// 通知类型
typedef enum tagNET_NOTIFY_TYPE
{
    NET_NOTIFY_TYPE_UNKNOWN,                    // 未知
    NET_NOTIFY_TYPE_SMS,                        // 短信
    NET_NOTIFY_TYPE_CALL,                       // 电话
    NET_NOTIFY_TYPE_ALL,                        // 短信&电话
}NET_NOTIFY_TYPE;

// 用户组关联通知信息
typedef struct tagNET_NOTIFY_INFO
{
    NET_NOTIFY_TYPE                 emType;                         // 通知类型
    BOOL                            bAlarmEvents;                   // 是否接受报警事件的推送
    BOOL                            bSystemEvents;                  // 是否接受故障事件的推送
    BOOL                            bOperationEvents;               // 是否接受操作事件的推送
}NET_NOTIFY_INFO;

// 通讯录配置列表
typedef struct tagNET_NETAPP_COMMUNICATION_LIST
{
    char                            szGroupName[MAX_COMMON_STRING_16];      // 自定义组名,不可重复命名
    int                             nMembersNum;                            // 联系人个数
    NET_MEMBERS_INFO                arrMembers[32];                         // 联系人信息
    NET_NOTIFY_INFO                 stuNotifyInfo;                          // 用户组关联通知信息
}NET_NETAPP_COMMUNICATION_LIST;

// 通讯录配置
typedef struct tagNET_NETAPP_COMMUNICATION_LIST_CFG
{
    DWORD                           dwSize;                                 // 结构体大小
    int                             nConmmunicationListNum;                 // 实际的通讯录配置个数
    NET_NETAPP_COMMUNICATION_LIST   stuCommunication[10];                   // 通讯录配置数组
}NET_NETAPP_COMMUNICATION_LIST_CFG;

// 中国铁塔平台接入配置
typedef struct tagNET_VSP_CHINA_TOWER
{
	DWORD			dwSize;
	BOOL			bEnable;                              // 接入使能,TRUE为开启,FALSE为关闭
	char			szServerIP[MAX_SERVER_IP_LEN];		  // 服务器IP
	int				nServerPort;						  // 服务器端口,取值范围0~65535
	int				nLoginInterval;						  // 注册时间间隔,单位为秒,取值范围60~180
}NET_VSP_CHINA_TOWER;

// 中国电信手机看店
typedef struct tagNET_VSP_SHDXJT 
{
    DWORD			dwSize;
    BOOL			bEnable;                              // 接入使能,TRUE为开启,FALSE为关闭
    char            szRegisterUrl[128];                   // 注册请求的URL地址
    char            szDeviceID[32];                       // 设备唯一识别码，由平台统一分配管理
    char            szDeviceKey[32];                      // 设备合法性验证码，由平台统一分配管理
    int             nEStoreFlag;                          // 云存储功能标识,	0：不支持，1：支持
    BYTE            byReserve[4];                         // 保留字节，用于字节对齐
}NET_VSP_SHDXJT;


// 消费机配置
typedef struct tagNET_CFG_VSP_CONSUME
{
	DWORD			dwSize;									// 结构体大小
	UINT			nTotalNumber;							// 消费总人数
}NET_CFG_VSP_CONSUME;

// 视频对讲电话通用配置(对应NET_EM_CFG_VTH_PASSWORD)
typedef struct tagNET_CFG_VTH_PASSWORD_INFO
{
	DWORD		   dwSize;
	char		   szUser[8];					            // 用户密码，必须为6位的数字
}NET_CFG_VTH_PASSWORD_INFO;

// sip注册服务器信息
typedef struct tagNET_CFG_SIPSERVER_INFO
{
    DWORD                   dwSize;                 
    char                    szAccoutName[MAX_COMMON_STRING_64];         // 账户名称
    char                    szAddres[DH_MAX_IPADDR_EX_LEN];             // sip服务器地址
    int                     nPort;                                      // sip服务器端口号
    char                    szProxyAdress[DH_MAX_IPADDR_EX_LEN];        // 代理服务器地址
    char                    szProxyID[MAX_COMMON_STRING_64];            // 代理服务器ID
    int                     nProxyPort;                                 // 代理服务器端口号
    char                    szUserID[MAX_COMMON_STRING_64];             // 用户ID，一般是电话号码
    int                     nUserType;                                  // 用户类型。0:SIP客户端,2:门口机做服务器,3:VTNC做服务器
    char                    szAuthID[MAX_USER_NAME_LEN];                // 身份鉴别ID
    char                    szAuthPassword[MAX_PWD_LEN];                // 身份鉴别密码
    char                    szSTUNServer[DH_MAX_IPADDR_EX_LEN];         // UDP数据报简单穿越网络地址转换器服务器
    char                    szRegisterRealm[MAX_COMMON_STRING_64];      // 注册域
    int                     nRegExpiration;                             // 注册间隔时间，单位：秒
    int                     nSipPort;                                   // 本地Sip端口
    int                     nRTPPort;                                   // 本地RTP端口
    BOOL                    bUnregisterOnReboot;                        // 重启删除注册信息使能
    char                    szDefaultCallNumber[MAX_COMMON_STRING_64];  // 默认呼叫号码
    UINT                    nVideoStreamType;                           // 视频码流，码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；
    UINT                    nAudioStreamType;                           // 音频码流，码流类型,0：主码流；1：辅码流1；2：辅码流2；3：辅码流3；
    BOOL                    bRouteEnable;                               // 是否开启Sip跨路由功能
    int                     nRouteCount;                                // 路由器数量
    char                    szRouteAddress[DH_MAX_IPADDR_EX_LEN][MAX_ROUTE_NUM]; // 路由地址
    char                    szSIPServerLoginUserName[MAX_USER_NAME_LEN];// 登陆VTNC的用户名
    char                    szSIPServerLoginPWD[MAX_PWD_LEN];           // 登录VTNC的密码
    BOOL                    bMainVTO;                                   // 是否是备用服务器使能
    char                    szRedundancyServer[DH_MAX_IPADDR_EX_LEN];   // 备用sip服务器地址
    char                    szRedundancyUserName[MAX_USER_NAME_LEN];    // 备用服务器登陆用户名
    char                    szRedundancyPassword[MAX_PWD_LEN];          // 备用服务器登陆密码
    char                    szAnalogNumberStart[MAX_COMMON_STRING_64];  // 模拟系统中支持的模拟室内机起始号码
    char                    szAnalogNumberEnd[MAX_COMMON_STRING_64];    // 模拟系统中支持的模拟室内机结束号码
	BOOL					bUserEnable;								// 注册使能
}NET_CFG_SIPSERVER_INFO; 

// 从门口机配置
typedef struct tagNET_DEVICE_LOGIN_INFO
{
	char					szAddress[DH_MAX_IPADDR_EX_LEN];			// IP地址
	char					szLongNumber[MAX_COMMON_STRING_16];			// 长号
	char					szUsername[MAX_COMMON_STRING_16];			// 用户名
	char					szPassword[MAX_COMMON_STRING_16];			// 密码
	BYTE					byReserved[512];							// 保留字节
} NET_DEVICE_LOGIN_INFO;

// 主门口机登陆从门口机配置
typedef struct tagNET_CFG_DEVICE_LOGIN_INFO 
{
	DWORD					dwSize;
	int						nCount;										// 从门口机配置个数
	NET_DEVICE_LOGIN_INFO	stDeviceLoginInfo[32];						// 从门口机配置
} NET_CFG_DEVICE_LOGIN_INFO;


// 镜头前遮挡盖配置(对应NET_EM_CFG_AELENSMASK)
typedef struct tagNET_CFG_AELENSMASK_INFO
{
	DWORD          dwSize;
	BOOL           bEnable;                       // 使能项(true时才支持遮挡盖的开和关操作)
	char           szName[MAX_COMMON_STRING_128]; // 自定义名字
	BOOL           bStatus;                       // 开关状态true:表示打开遮挡盖false:遮挡盖遮住镜头
}NET_CFG_AELENSMASK_INFO;

//单个超声波配置
typedef struct tagNET_CFG_SINGLE_ULTRASONIC
{
	BOOL      bEnable;              //是否开启超声波使能
	UINT      nFreq;                //超声波探头频率，单位hz
	int       nBurst;               //探测一次发出的脉冲个数
	int       nGain;                //超声波探头增益范围[0,100]
	int       nDriveCurrent;        //超声波探头驱动电流，单位mA
	int       nMinValidDistance;    //超声波信号最小值单位cm
	int       nMaxValidDistance;    //超声波信号最大值单位cm，表示过滤大于最大或者小于最小的物体
	int       nMinVaildSignalIntensity;   //最小超声波强度 在最小和最大之间的信号有效
	int       nMaxVaildSignalIntensity;   //最大超声波强度
	BYTE      byReserved[512];      //保留字节
}NET_CFG_SINGLE_ULTRASONIC;

//超声波信息
typedef struct tagNET_CFG_ULTRASONIC_INFO
{
	DWORD                      dwSize;
	int                        nMaxCount;         //最大超声波配置个数
	int                        nRetCount;         //返回的超声波配置个数
	NET_CFG_SINGLE_ULTRASONIC  *pstuULTRASONIC;   //超声波配置信息，由用户申请释放
}NET_CFG_ULTRASONIC_INFO;

// 门禁卡预欠费配置
typedef struct tagNET_CFG_ACCESS_DELAYSTRATEGY
{
    DWORD                   dwSize;
    BOOL                    bEnable;                                    // 是否启用
    int                     nPreArrearsTerm;                            // 预欠费期限，单位：天
    int                     nArrearsTerm;                               // 欠费期限，单位：天
}NET_CFG_ACCESS_DELAYSTRATEGY;

// 服务器类型
typedef enum tagNET_EM_REGISTAR_SERVER_TYPE
{
    NET_EM_REGISTAR_SERVER_TYPE_UNKNOWN,
    NET_EM_REGISTAR_SERVER_TYPE_VTO,
    NET_EM_REGISTAR_SERVER_TYPE_H500,
    NET_EM_REGISTAR_SERVER_TYPE_VTNC,
    NET_EM_REGISTAR_SERVER_TYPE_ZYCOO,
    NET_EM_REGISTAR_SERVER_TYPE_THIRDPARTY,
    NET_EM_REGISTAR_SERVER_TYPE_3CXSYSTEM,
    NET_EM_REGISTAR_SERVER_TYPE_ASTERISK,
}NET_EM_REGISTAR_SERVER_TYPE;

// 注册服务器配置信息
typedef struct tagNET_CFG_REGISTAR_INFO
{
    DWORD                   dwSize;
    char                    szRegistarName[MAX_COMMON_STRING_64];    // 注册服务器名称，唯一
    NET_EM_REGISTAR_SERVER_TYPE emServerType;                        // 注册服务器类型
    BOOL                    bRegistarEnable;                         // 是否注册
    char                    szAddress[DH_MAX_IPADDR_EX_LEN];         // 注册地址
    int                     nPort;                                   // 注册端口
    char                    szPassword[MAX_COMMON_STRING_64];        // 注册密码
}NET_CFG_REGISTAR_INFO;


// 辅码流录像配置时间段
typedef struct tagNET_CFG_RECORDEXTRA_INFO
{
	DWORD					dwSize;
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];   // 第一维前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段
}NET_CFG_RECORDEXTRA_INFO;

#define  NET_MAX_NUM_RECORDBACKUP_TASK       512         // 录像回传任务最大数量
#define  NET_MAX_NUM_RECORDBACKUP_CHANNEL    128         // 录像回传通道的最大数量

// 录像回传任务
typedef struct tagNET_RECORDBACKUP_TASK
{
	int                     nNumChannel;                 // 通道数量
	int                     nChannel[NET_MAX_NUM_RECORDBACKUP_CHANNEL];// 通道号列表
	NET_TIME_EX             stuStartTime;                // 开始时间 
	NET_TIME_EX             stuEndTime;                  // 结束时间
	char                    szStorageGroupName[DH_COMMON_STRING_32];   // 该通道录像要保存到的某盘组中。不存在此字段，由设备默认实现决定
	//"ReadWrite*",代表读写组,中间的"*"可以为空,可以为一个数字
	//"ReadOnly",代表只读组
	//"Redundant",冗余组,设备内置磁盘,使用大华文件系统.和"ReadWirte"组一个冗余副本
	//"NASFTP-" 或 "NASNFS-" 或 "NASSMB-" 或 "NASISCSI-" 或 "NASCloud-"
	//"Backup":备份组,设备外接的磁盘或U盘,使用标准文件系统.数据写满后停止,不会循环覆盖
	//"DrawFrame":历史抽帧组,设备内置磁盘,使用大华文件系统.实时录像在指定时间后,抽帧并写入该组
	BYTE                    byReserved[512];             // 保留字节
}NET_RECORDBACKUP_TASK;

// 自动录像回传配置(NET_EM_CFG_AUTO_RECORDBACKUP_RESTORE)
typedef struct tagNET_CFG_AUTORECORDBACKUPRESTORE_INFO
{
	DWORD					dwSize;                      // 结构体大小
	BOOL                    bEnable;                     // 使能开关
	UINT                    nSpeed;                      // 设置回传速度,单位:Kbps
	NET_TIME_EX             stuBackupTime;               // 开始录像回传时间
	int                     nNumTask;                    // 录像回传任务数量
	NET_RECORDBACKUP_TASK   stuTask[NET_MAX_NUM_RECORDBACKUP_TASK]; //录像回传任务
}NET_CFG_AUTORECORDBACKUPRESTORE_INFO;

// IPC智能人脸抓拍策略
typedef enum tagEM_FACE_SNAP_POLICY
{
	EM_FACE_SNAP_POLICY_UNKNOWN,					// 未知
	EM_FACE_SNAP_POLICY_REALTIME,					// 实时抓拍模式(当前的通用模式，实时性优先)
	EM_FACE_SNAP_POLICY_OPTIMAL,					// 优选抓拍模式，在设定的延时区间(OptimalTime)内挑选评分最高的抓图，准确性优先但延时较大
	EM_FACE_SNAP_POLICY_QUALITY,					// 质量抓拍模式，在Optimal的基础上，如果图片质量好于阈值提前结束优选，提高实时性
	EM_FACE_SNAP_POLICY_RECOGNITION,				// 识别优先抓拍模式，在优选时间内，以一定间隔帧数多次进行比对；一旦比对成功则立即结束优选，以提高对比成功率，取代质量优先模式。
	EM_FACE_SNAP_POLICY_QUICK,						// 快速优选，从检测到人脸/人体开始，抓拍一定帧数内的质量最好的人脸或人体,定制
	EM_FACE_SNAP_POLICY_FULLTRACK,					// 全程优选，抓拍全程质量最好的人脸人体，定制
	EM_FACE_SNAP_POLICY_INTERVAL,					// 间隔抓拍，定制
	EM_FACE_SNAP_POLICY_SINGLE,						// 单人模式，常用于门禁，定制
	EM_FACE_SNAP_POLICY_PRECISION,					// 高精度模式，增强人脸识别，定制
}EM_FACE_SNAP_POLICY;

//  IPC智能人脸抓拍上报图策略
typedef enum tagEM_CUTOUT_POLICY
{
	EM_CUTOUT_POLICY_UNKNOWN = -1,					// 未知
	EM_CUTOUT_POLICY_UNSUPPORT,						// 不支持抠图
	EM_CUTOUT_POLICY_ORIGINAL,						// 上报照片原始大小
	EM_CUTOUT_POLICY_HALF,							// 半身照
	EM_CUTOUT_POLICY_WHOLE,							// 全身照
	EM_CUTOUT_POLICY_CEPHALOTHORAX,					// 头肩照
}EM_CUTOUT_POLICY;

// IPC智能人脸抓拍配置
typedef struct tagNET_CFG_FACESNAPSHOT_INFO
{
	DWORD					dwSize;					// 结构体大小
	EM_FACE_SNAP_POLICY		emSnapPolicy;			// 人脸抓拍策略
	UINT					nSnapFrames;			// 抓拍帧数，用于快速抓拍模式，范围[10,1500]，默认25帧，定制
	UINT					nOptimalTime;			// 人脸优先最大延时,单位秒
													// emSnapPolicy为EM_FACE_SNAP_POLICY_OPTIMAL或EM_FACE_SNAP_POLICY_QUALITY时有效
	EM_CUTOUT_POLICY		emCutoutPolicy;			// 
	UINT					nIntervalFrmCnt;		// 识别优先抓拍间隔帧数	emSnapPolicy 为 EM_FACE_SNAP_POLICY_RECOGNITION 有效
	UINT					nOptimalInterval;		// 优选抓拍间隔帧数 emSnapPolicy 为 EM_FACE_SNAP_POLICY_INTERVAL 有效，定制
	UINT					nOptimalCount;			// 优选抓拍次数，emSnapPolicy 为 EM_FACE_SNAP_POLICY_INTERVAL 有效，定制
	UINT					nRecognizeTimeout;		// 人脸识别失败超时时间,单位秒
}NET_CFG_FACESNAPSHOT_INFO;

// 上报策略
typedef enum tagNET_EM_REPORT_POLICY
{
	NET_EM_REPORT_POLICY_UNKNOWN,
	NET_EM_REPORT_POLICY_AUTO,			    // 设备自动上报
	NET_EM_REPORT_POLICY_TIMING,			// 平台定时上报
}NET_EM_REPORT_POLICY;

// 设备自动上报信息
typedef struct tagNET_AUTO_REPORT_INFO
{
	int				nReportTime;			// 上报时间间隔，单位:秒
	int				nReportDistance;		// 上报距离，单位:米
	int				nInflectionPointAngle;	// 拐点角度，单位:度
	int				nAccOffReportTime;		// ACC关闭位置上报时间间隔,单位:秒
	BYTE			byReserved[1024];		// 保留字节
}NET_AUTO_REPORT_INFO;

// GPS位置上报策略信息(对应 NET_EM_CFG_POSITIONREPORTPOLICY)
typedef struct tagNET_CFG_POSITIONREPORTPOLICY_INFO
{
	DWORD						    dwSize;
	NET_EM_REPORT_POLICY			emReportPolicy;			// 上报策略,在设置该字段时，emReportPolicy不为NET_EM_REPORT_POLICY_UNKNOWN
	NET_AUTO_REPORT_INFO			stuAutoReportInfo;		// 自动上报信息,此字段在emReportPolicy为NET_EM_REPORT_POLICY_AUTO时有效
}NET_CFG_POSITIONREPORTPOLICY_INFO;

//运行模式参数
typedef struct tagNET_RUNMODE_PARAMS
{
	DWORD                   dwSize;                     
	//运行模式0:非内存池模式1:内存池模式 
	int                     nMode;                              
	/*针对nWinConnectBufSize (windows) 每个连接接收数据缓冲大小(字节为单位)，
	为0表示维持原来的值，250*1024最佳，最小为128*1024 */
	int                     nWinConnectBufSize;
	/*针对nWinSocketRcvBuf (windows/linux), socket接收缓存大小(字节为单位)，
	为0表示维持原来的值，64*1024最佳，最小为36*1024 */
	int                     nWinSocketRcvBuf;       
}NET_RUNMODE_PARAMS;

// 自动布撤防时间段
typedef struct tagNET_CFG_ARMSCHEDULE_INFO
{
   DWORD					dwSize;
   BOOL                     bEnable;                                               // 配置使能
   DH_TSECT                 stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];   // 第一维前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段
}NET_CFG_ARMSCHEDULE_INFO;

#define MAX_CID_NUM				    100				    // 标准CID协议最大个数
#define MAX_FTCID_NUM				100				    // 4+2型CID协议最大个数
#define MAX_TEL_NUM			        2				    // 上报的报警中心下标最大个数

//协议类型
typedef enum tagEM_CID_REPORT_PROTOCOL_TYPE
{
    EM_CID_REPORT_PROTOCOL_TYPE_UNKNOWN,               // 未知
    EM_CID_REPORT_PROTOCOL_TYPE_CID,                   // 标准CID协议
    EM_CID_REPORT_PROTOCOL_TYPE_FTCID,                 // 4+2型CID协议
}EM_CID_REPORT_PROTOCOL_TYPE;

//标准CID协议事件类型
typedef enum tagEM_CID_EVENT_CODE
{
    EM_CID_EVENT_CODE_UNKNOWN =-1,                                // -1 : 未知
    EM_CID_EVENT_CODE_DEFENCE_GENERAL_ALARM,                      // 0 : 防区一般报警
    EM_CID_EVENT_CODE_DEFENCE_PREVENT_MOVE_ALARM,                 // 1 : 防区防拆报警
    EM_CID_EVENT_CODE_DEFENCE_FAULT_ALARM,                        // 2 : 防区故障报警
    EM_CID_EVENT_CODE_DEFENCE_BYPASS,                             // 3 : 防区旁路
    EM_CID_EVENT_CODE_RAPID_ARM,                                  // 4 : 快速布防
    EM_CID_EVENT_CODE_LOCK_ARM_DISARM,                            // 5 : 锁布撤防
    EM_CID_EVENT_CODE_REMOTE_ARM_DISARM,                          // 6 : 远程布撤防
    EM_CID_EVENT_CODE_TIME_ARM_DISARM,                            // 7 : 定时布撤防
    EM_CID_EVENT_CODE_TELEOPERATION_ARM_DISARM,                   // 8 : 遥控布撤防
    EM_CID_EVENT_CODE_USER_ARM_DISARM,                            // 9 : 用户布撤防
    EM_CID_EVENT_CODE_PART_ARM_DISARM,                            // 10 : 局部布撤防
    EM_CID_EVENT_CODE_HOST_PREVENT_MOVE,                          // 11 :主机防拆
    EM_CID_EVENT_CODE_HOST_POWER_FAULT,                           // 12 :主机掉电
    EM_CID_EVENT_CODE_BATTERY_LOW,                                // 13 :电池低压
    EM_CID_EVENT_CODE_BATTERY_FAULT,                              // 14 :电池掉电
    EM_CID_EVENT_CODE_TELEPHONE_DISCONNECTION,                    // 15 :电话线断线
    EM_CID_EVENT_CODE_GSM_SIGNAl_BAD,                             // 16 :GSM信号差
    EM_CID_EVENT_CODE_ALARM_PREVENT_MOVE,                         // 17 :警号防拆
    EM_CID_EVENT_CODE_MODULE_COMMUNICATION_FAULT,                 // 18 :模块通信故障
    EM_CID_EVENT_CODE_SYSTEM_TIME_ABNORMAl,                       // 19 :系统时间异常
    EM_CID_EVENT_CODE_SIM_CAR_FAULT,                              // 20 :SIM卡故障
    EM_CID_EVENT_CODE_NETWORK_COMMUNICATION_FAULT,                // 21 :网络通信故障
    EM_CID_EVENT_CODE_FIRE_ALARM,                                 // 22 :火警
    EM_CID_EVENT_CODE_ROBBER_ALARM,                               // 23 :匪警
    EM_CID_EVENT_CODE_URGENT_MEDICAL_ALARM,                       // 24 :紧急医疗报警
    EM_CID_EVENT_CODE_DURESS_ALARM,                               // 25 :胁迫报警
    EM_CID_EVENT_CODE_PANIC_ALARM,                                // 26 :恐慌报警
    EM_CID_EVENT_CODE_PERIOD_TEST_REPORT,                         // 27 :定期测试报告
    EM_CID_EVENT_CODE_MANUAL_TEST_REPORT,                         // 28 :手动测试报告
    EM_CID_EVENT_CODE_CLEAR_ALARM_CACHE,                          // 29 :清除报警缓存
    EM_CID_EVENT_CODE_ALARM_CANCEL,                               // 30 :报警取消
    EM_CID_EVENT_CODE_EMERGENCY_ALARM,                            // 31 :软防区紧急报警事件
    EM_CID_EVENT_CODE_OUTSIDE_ZONE_ALARM,                         // 32 :外部（周界）防区报警
    EM_CID_EVENT_CODE_INSIDE_ZONE_ALARM,                          // 33 :内部防区报警
    EM_CID_EVENT_CODE_24H_ZONE_ALARM,                             // 34 :24H防区报警
    EM_CID_EVENT_CODE_DELAY_ZONE_ALARM,                           // 35 :（出入口）延时防区报警
    EM_CID_EVENT_CODE_INTIME_DOUBLEMETHOD_ZONE_ALARM,             // 36 :即时防区+双鉴传感器，上报盗警
    EM_CID_EVENT_CODE_24H_URGENCYBUTTON_ZONE_ALARM,               // 37 :24H紧急按钮防区报警（防区类型：24H、传感器感应方式：紧急按钮）
    EM_CID_EVENT_CODE_24H_FIRE_ZONE_ALARM,                        // 38 :24H火警防区报警
    EM_CID_EVENT_CODE_24H_ROBBERY_ZONE_ALARM,                     // 39 :24H匪警防区报警
    EM_CID_EVENT_CODE_24H_SILENT_ZONE_ALARM,                      // 40 :24H无声防区报警
    EM_CID_EVENT_CODE_24H_SOUND_ZONE_ALARM,                       // 41 :24H有声防区报警
    EM_CID_EVENT_CODE_24H_AUXILIARY_ZONE_ALARM,                   // 42 :24H辅助防区报警
    EM_CID_EVENT_CODE_24H_VIBRATION_ZONE_ALARM,                   // 43 :24H震动防区报警
    EM_CID_EVENT_CODE_TIMEOUT_ZONE_ALARM,                         // 44 :超时防区报警
    EM_CID_EVENT_CODE_FOLLOW_ZONE_ALARM,                          // 45 :跟随防区报警
    EM_CID_EVENT_CODE_EXMODULE_FAULT,                             // 46 :扩展模块故障
    EM_CID_EVENT_CODE_EXMODULE_DC_LOSS,                           // 47 :扩展模块直流电掉电
    EM_CID_EVENT_CODE_EXMODULE_LOW_BATTERY,                       // 48 :扩展模块电压低
    EM_CID_EVENT_CODE_EXMODULE_TAMPER,                            // 49 :扩展模块防拆
    EM_CID_EVENT_CODE_EXMODULE_AC_LOSS,                           // 50 :扩展模块交流电掉电
    EM_CID_EVENT_CODE_PRINTER_FAILURE,                            // 51 :打印机掉线
    EM_CID_EVENT_CODE_GSM_FAULT,                                  // 51 :GSM模块故障
    EM_CID_EVENT_CODE_ARMED_STAY,                                 // 53 :留守布防
    EM_CID_EVENT_CODE_AUTO_ARM_FAILED,                            // 54 :自动布防失败
    EM_CID_EVENT_CODE_SYSTEM_TROUBLE_PRESENT,                     // 55 :系统故障保持
    EM_CID_EVENT_CODE_PROGRAM_MODE_ENTRY,                         // 56 :进入编程模式
    EM_CID_EVENT_CODE_PROGRAM_MODE_EXIT,                          // 57 :退出编程模式
    EM_CID_EVENT_CODE_PANEL_PROGRAMMING_CHANGED,                  // 58 :主机编程被改动，此处特指SDK Demo的登录与退出
    EM_CID_EVENT_CODE_KEYPAD_TAMPER_ALARM,                        // 59 :键盘防拆报警
    EM_CID_EVENT_CODE_IP_CONFLICT,                                // 60 :IP冲突
}EM_CID_EVENT_CODE;

//标准CID协议配置信息
typedef struct tagNET_CFG_CID_REPORT_CID_INFO
{
    int                                       nTelNum;                            // 上报的报警中心下标个数
    int                                       nTel[MAX_TEL_NUM];                  // 上报的报警中心下标
    EM_CID_EVENT_CODE                         emEventCode;                        // 事件类型
    BOOL                                      bEventRestore;                      // 是否支持事件恢复上报
    char                                      szContactId[4];                     // 3位数字字符串事件码
    BYTE                                      bReserved[256];                       // 保留字节
}NET_CFG_CID_REPORT_CID_INFO;

//4+2型CID协议事件类型
typedef enum tagEM_FTCID_EVENT_CODE
{
    EM_FTCID_EVENT_CODE_UNKNOWN =-1,                                       // 未知
    EM_FTCID_EVENT_CODE_DEFENCE_ALARM = 0,                                 // 报警，0~15 : 防区1~16报警
    EM_FTCID_EVENT_CODE_DEFENCE_ALARM_RESTORE = 16,                        // 报警恢复，16~31 : 防区1~16报警恢复
    EM_FTCID_EVENT_CODE_DEFENCE_BYPASS = 32,                               // 旁路，32~47 : 防区1~16旁路
    EM_FTCID_EVENT_CODE_DEFENCE_BYPASS_RESTORE = 48 ,                      // 旁路恢复，48~63 : 防区1~16旁路恢复
    EM_FTCID_EVENT_CODE_ARM = 64,                                          // 64 : 布防
    EM_FTCID_EVENT_CODE_DISARM = 65,                                       // 65 : 撤防
    EM_FTCID_EVENT_CODE_ALARM_CANCEL = 66,                                 // 66 : 报警取消
    EM_FTCID_EVENT_CODE_PERIOD_TEST_REPORT = 67,                           // 67 : 定期测试报告
    EM_FTCID_EVENT_CODE_MANUAL_TEST_REPORT = 68,                           // 68 : 手动测试报告
    EM_FTCID_EVENT_CODE_HOST_POWER_FAULT = 69,                             // 69 : 主机掉电
    EM_FTCID_EVENT_CODE_HOST_POWER_FAULT_RESTORE = 70,                     // 70 : 主机掉电恢复
    EM_FTCID_EVENT_CODE_BATTERY_LOW = 71,                                  // 71 : 电池低压
    EM_FTCID_EVENT_CODE_BATTERY_LOW_RESTORE = 72,                          // 72 : 电池低压恢复
    EM_FTCID_EVENT_CODE_SOFT_KEYBOARD_REPORT_CODE = 73,                    // 73 : 软键盘报告码
}EM_FTCID_EVENT_CODE;

//4+2型CID协议配置信息
typedef struct tagNET_CFG_CID_REPORT_FTCID_INFO
{
    int                                       nTelNum;                            // 上报的报警中心下标个数
    int                                       nTel[MAX_TEL_NUM];                  // 上报的报警中心下标
    EM_FTCID_EVENT_CODE                       emEventCode;                        // 事件类型
    int                                       nDefenceChannel;                    // 防区号，当事件类型为报警、报警恢复、旁路、旁路恢复时才有效
    char                                      szContactId[3];                     // 2位数字字符串事件码
    BYTE                                      bReserved[257];                       // 保留字节
}NET_CFG_CID_REPORT_FTCID_INFO; 

//CID联动配置(对应NET_EM_CFG_CID_REPORT)
typedef struct tagNET_CFG_CID_REPORT_INFO
{
    DWORD							             dwSize;				          // 结构体大小
    EM_CID_REPORT_PROTOCOL_TYPE		             emProtocol;                      // 协议类型
    int                                          nCIDNum;                         // 标准CID协议个数
    NET_CFG_CID_REPORT_CID_INFO                  stuCID[MAX_CID_NUM];             // 标准CID协议,当emProtocol为EM_CID_REPORT_PROTOCOL_TYPE_CID时有效
    int                                          nFTCIDNum;                       // 4+2型CID协议个数,当emProtocol为EM_CID_REPORT_PROTOCOL_TYPE_FTCID时有效
    NET_CFG_CID_REPORT_FTCID_INFO                stuFTCID[MAX_FTCID_NUM];         // 4+2型CID协议
}NET_CFG_CID_REPORT_INFO;

//报警主机操作员配置信息
typedef struct tagNET_CFG_KBUSER_SERVER
{
	int								nUserCode;			//	用户编号
	char							szPasswd[7];		//	键盘密码
	BYTE							bReserved[129]; 	//	保留字节
}NET_CFG_KBUSER_SERVER;
//中信银行定制，最多支持100个用户密码参数
#define MAX_KBUSER_SERVER_NUM	100
//报警主机键盘密码配置(对应 NET_EM_CFG_KBUER_PASSWORD)
typedef struct tagNET_CFG_KBUSER_PASSWORD
{
	DWORD							dwSize;								//结构体大小
	int								nServerNum;							//操作员配置信息数量
	NET_CFG_KBUSER_SERVER			stuServers[MAX_KBUSER_SERVER_NUM];	//操作员配置信息
}NET_CFG_KBUSER_PASSWORD;

// 视频诊断任务
typedef struct tagNET_PROJECT_TASK
{
	BOOL							bEnable;									// 任务是否使能
	char							szTaskName[MAX_PATH];						// 任务名称Ansi编码
	DH_TSECT                		stuTimeSection[DH_N_WEEKS][DH_N_REC_TSECT]; // 任务时间段
	BOOL                            bIsCycle;                                   // 任务是否循环,TRUE表示循环,FALSE表示不循环
	BYTE      						byReserved[512];      						// 保留字节
}NET_PROJECT_TASK;

// 视频诊断计划配置
typedef struct tagNET_VIDEODIAGNOSIS_PROJECT_INFO
{
	DWORD					dwSize;	
	char					szProjectName[MAX_PATH];		// 计划名称
	int						nTotalTaskNum;					// 调用者分配任务列表个数, 根据能力集获取
	int						nReturnTaskNum;					// 返回实际任务列表个数
	NET_PROJECT_TASK*		pstProjectTasks;				// 任务列表 , 调用者分配内存nTotalTaskNum个
} NET_VIDEODIAGNOSIS_PROJECT_INFO;

// 视频诊断任务
typedef struct tagNET_PROJECT_TASK_INFO
{
	BOOL							bEnable;									// 任务是否使能
	char							szTaskName[260];							// 任务名称
	DH_TSECT                		stuTimeSection[32][6];						// 按月的任务时间段,第一维里的前31个元素对应每月的日期,第32个元素为预留元素
	BOOL                            bIsCycle;                                   // 任务是否循环,TRUE表示循环,FALSE表示不循环
	BYTE      						byReserved[512];      						// 保留字节
}NET_PROJECT_TASK_INFO;

// 按月的视频诊断计划扩展配置信息,对应 NET_EM_CFG_VIDEO_DIAGNOSIS_PROJECT_MONTH
typedef struct tagNET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO
{
	DWORD					dwSize;							// 结构体大小
	char					szProjectName[260];				// 计划名称
	int						nTotalTaskNum;					// 调用者分配任务列表个数, 根据能力集获取,最大不超过32
	int						nReturnTaskNum;					// 返回实际任务列表个数
	NET_PROJECT_TASK_INFO*	pstProjectTasks;				// 任务列表, 调用者分配内存nTotalTaskNum*sizeof(NET_PROJECT_TASK_INFO)个字节
}NET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO;

// GPS搜星数OSD配置
typedef struct tagNET_CFG_GPSSTARNUM_OSD_INFO
{
	DWORD                   dwSize;
	BOOL                    bBDOSDEnable;                   // 是否叠加北斗卫星数
	BOOL                    bGPSOSDEnable;                  // 是否叠加GPS卫星数
}NET_CFG_GPSSTARNUM_OSD_INFO;

// 图片标题
typedef struct tagNET_OSD_PICTURE_TITLE
{
	DWORD					dwSize;
	NET_EM_OSD_BLEND_TYPE   emOsdBlendType;                     // 叠加类型
	BOOL                    bEncodeBlend;						// 是否叠加
	NET_COLOR_RGBA			stuFrontColor;						// 前景色
	NET_COLOR_RGBA			stuBackColor;						// 背景色
	NET_RECT				stuRect;							// 区域, 坐标取值0~8191
	char					szName[DH_COMMON_STRING_64];		// 图片名称
	int						nWidth;								// 图片宽
	int						nHeight;							// 图片高	
}NET_OSD_PICTURE_TITLE;



// 预置点信息叠加 NET_EM_CFG_PTZ_PRESET
typedef struct tagNET_OSD_CFG_PTZ_PRESET
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
}NET_OSD_CFG_PTZ_PRESET;

// 显示巡迹百分比叠加配置 NET_EM_CFG_PTZ_PATTERN
typedef struct tagNET_OSD_CFG_PTZ_PATTERN
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
}NET_OSD_CFG_PTZ_PATTERN;

// 显示RS485检测结果的叠加配置 NET_EM_CFG_PTZ_RS485_DETECT
typedef struct tagNET_OSD_CFG_PTZ_RS485_DETECT
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
}NET_OSD_CFG_PTZ_RS485_DETECT;

// 显示云台坐标的叠加配置 NET_EM_CFG_PTZ_COORDINATES
typedef struct tagNET_OSD_CFG_PTZ_COORDINATES
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
}NET_OSD_CFG_PTZ_COORDINATES;

// 显示云台方向的叠加配置 NET_EM_CFG_PTZ_DIRECTION
typedef struct tagNET_OSD_CFG_PTZ_DIRECTION
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
}NET_OSD_CFG_PTZ_DIRECTION;


// 温度单位
typedef enum tagEM_TEMPERATURE_UNIT_EX
{
    EM_TEMPERATURE_EX_UNKNOWN,              // 未知
    EM_TEMPERATURE_EX_CENTIGRADE,			// 摄氏度
    EM_TEMPERATURE_EX_FAHRENHEIT,			// 华氏度
    EM_TEMPERATURE_EX_KELVIN,				// 开尔文
} EM_TEMPERATURE_UNIT_EX;

// 显示环境温度的叠加配置 NET_EM_CFG_TEMPERATURE
typedef struct tagNET_OSD_CFG_TEMPERATURE
{
    DWORD					dwSize;
    int                     nDisplayTime;           // 显示时间,单位为秒，0 表示一直显示,自定义范围：1-3600
    BOOL                    bEncodeBlend;           // 叠加到主码流视频编码
    BOOL                    bPreviewBlend;          // 是否叠加到预览显示
    NET_COLOR_RGBA			stuFrontColor;			// 前景色
    NET_COLOR_RGBA			stuBackColor;			// 背景色
    NET_RECT		    	stuRect;			    // 区域
    EM_TEMPERATURE_UNIT_EX  emTemperatureType;      // 温度单位的类型
}NET_OSD_CFG_TEMPERATURE;


//  覆盖区域
typedef struct tagNET_VEDIO_WIDGET_COVER
{
    BOOL				bPreviewBlend;					// 叠加到预览视频
    BOOL				bEncodeBlend;					// 叠加到主码流
    BOOL				bEncodeBlendExtra1;				// 叠加到辅码流1
    BOOL				bEncodeBlendExtra2;				// 叠加到辅码流2
    BOOL				bEncodeBlendExtra3;				// 叠加到辅码流3
    BOOL				bEncodeBlendSnapshot;			// 叠加到抓图
    NET_COLOR_RGBA		stuFrontColor;					// 前景色
    NET_COLOR_RGBA		stuBackColor;					// 背景色
    NET_RECT			stuRect;						// 区域, 坐标取值0~8191
    BYTE                byReserver[128];                // 保留字节
}NET_VEDIO_WIDGET_COVER;

// 区域覆盖 NET_EM_CFG_COVERS
typedef struct tagNET_OSD_CFG_COVERS
{
    DWORD				    dwSize;
    int                     nCoverCount;            // 覆盖区域个数
    NET_VEDIO_WIDGET_COVER  stuCovers[16];          // 覆盖区域
}NET_OSD_CFG_COVERS;

// 自定义的标题信息
typedef struct tagNET_USER_DEF_TITLE_INFO
{
    char				    szText[CUSTOM_TITLE_LEN];		// 标题内容
    BOOL                    bEncodeBlend;                   // 是加叠加到编码视频使能
    BOOL                    bPreviewBlend;                  // 叠加到预览视频使能
    NET_RECT			    stuRect;						// 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
    NET_COLOR_RGBA		    stuFrontColor;					// 前景色
    NET_COLOR_RGBA		    stuBackColor;					// 背景色
    EM_TITLE_TEXT_ALIGNTYPE emTextAlign;                    // 文本对齐方式
    BYTE                    byReserved[516];                // 保留字节 
}NET_USER_DEF_TITLE_INFO;

// 用户自定义OSD标题 NET_EM_CFG_USER_DEF_TITLE
typedef struct tagNET_OSD_USER_DEF_TITLE
{
    DWORD					dwSize;
    int						nUserDefTitleNum;						// 自定义标题数量
    NET_USER_DEF_TITLE_INFO	stuUserDefTitle[16];					// 自定义标题
}NET_OSD_USER_DEF_TITLE;


// 人脸数量统计OSD配置
typedef struct tagNET_OSD_FACEFLOW_STAT_INFO
{
	DWORD							dwSize;							// 结构体大小
	BOOL							bEncodeBlend;					// 是否叠加到视频码流	
	NET_COLOR_RGBA					stuFrontColor;					// 前景色
	NET_COLOR_RGBA					stuBackColor;					// 背景色
	NET_RECT						stuRect;						// 叠加区域	坐标范围 [0, 8192]
	int								nTextAlign;						// 文本对齐方式 0-左对齐  2-右对齐
	BOOL							bShowFaceRecognition;			// 是否显示识别成功(在注册库中)人数
	BOOL							bShowFaceDetection;				// 是否显示检测到的总人脸数
	BOOL							bShowBodyDetection;				// 是否叠加检测到的总人体数	
}NET_OSD_FACEFLOWSTAT_INFO;

// 水利监控OSD配置
typedef struct tagNET_WATERMONITOR_OSD_INFO
{
	BOOL							bEncodeBlend;					// 是否叠加到视频码流
	int								nTextAlign;						// 文本对齐方式 0-左对齐  2-右对齐
	NET_COLOR_RGBA					stuFrontColor;					// 前景色
	NET_COLOR_RGBA					stuBackColor;					// 背景色
	NET_RECT						stuRect;						// 叠加区域	8192相对坐标
	BYTE							byReserved[1024];				// 保留字节
}NET_WATERMONITOR_OSD_INFO;

// 智慧水利叠加OSD配置(对应枚举 NET_EM_CFG_WATER_MONITOR_TITLE) 
typedef struct tagNET_CFG_WATER_MONITOR_TITLE_INFO
{
	DWORD                           dwSize;
	NET_WATERMONITOR_OSD_INFO		stuWaterLevel;					// 水位检测OSD
	NET_WATERMONITOR_OSD_INFO		stuFlotage;						// 漂浮物OSD
}NET_CFG_WATER_MONITOR_TITLE_INFO;

// KT项目的RTSP使能的配置(对应枚举 NET_EM_CFG_KT_RTSP_FLAG) 
typedef struct tagNET_CFG_KT_RTSP_FLAG_INFO
{
    DWORD                dwSize;
    BOOL                 bEnable;    // 是否使能Rtsp的断线策略，TRUE:使能; FALSE:不使能
}NET_CFG_KT_RTSP_FLAG_INFO;

// 单个录像的名字
typedef struct tagNET_ABORT_VEDIO
{
    char                szVedio[100];
}NET_ABORT_VEDIO;

// 获取RTSP断线后存储到设备本地的录像列表（只有获取，没有设置）(对应枚举 NET_EM_CFG_RTSP_ABORT_LIST) 
typedef struct tagNET_CFG_RTSP_ABORT_LIST_INFO
{
     DWORD               dwSize;
     BYTE                byReserved[4];         // 保留字节，用于字节对齐
     int                 nMaxListCount;         // 用户分配的录像列表的数量,最大支持3000个
     UINT                nRetListCount;         // 设备返回的录像列表的数量
     NET_ABORT_VEDIO*    pVedioList;            // 具体的录像列表，需要用户申请
     char                szMark[32];            // 当前录像类型
}NET_CFG_RTSP_ABORT_LIST_INFO;






// 录像保存天数配置 (对应枚举 NET_EM_CFG_FILE_HOLD_DAYS) 
typedef struct tagNET_CFG_FILE_HOLD_DAYS_INFO
{
    DWORD               dwSize;
    UINT                nDays;       // 设置文件的保留天数，超过时间的将被删除，单位:天，取值范围0-65535，0表示没有天数限制
}NET_CFG_FILE_HOLD_DAYS_INFO;

// 接入功能配置(对应枚举 NET_EM_CFG_ACCESS_FUNCTION)
typedef struct tagNET_CFG_ACCESS_FUNCTION_INFO
{
    DWORD               dwSize;
    BOOL                bGb28181ClientEnable;                   // 是否允许接入国标前端设备
    BOOL                bGb28181ServerEnable;                   // 是否能接入国标平台
    BOOL                bONVIFClientEnable;                     // 是否允许接入ONVIF前端
    BOOL                bONVIFServerEnable;                     // 是否支持onvifserver
    BOOL                bRTSPEnable;                            // 是否支持rtsp被拉流
}NET_CFG_ACCESS_FUNCTION_INFO;
// 用户类型
typedef enum tagEM_ATTENDANCE_USER_TYPE
{
	EM_ATTENDANCE_USER_TYPE_UNKNOWN = -1,			 // 未知用户
	EM_ATTENDANCE_USER_TYPE_NORMAL,                  // 普通用户
	EM_ATTENDANCE_USER_TYPE_BLACKLIST,               // 黑名单用户	
}EM_ATTENDANCE_USER_TYPE;

// 考勤人员状态
typedef enum tagEM_ATTENDANCE_USER_STATUS
{
	EM_ATTENDANCE_USER_STATUS_UNKNOWN = -1,			// 未知
	EM_ATTENDANCE_USER_STATUS_NORMAL,				// 正常
	EM_ATTENDANCE_USER_STATUS_FROZEN,				// 冻结	
}EM_ATTENDANCE_USER_STATUS;

// 考勤人员信息
typedef struct tagNET_ATTENDANCE_USER_INFO
{
	char							szUserID[64];					// 用户ID
	EM_ATTENDANCE_USER_TYPE			emUserType;						// 用户类型
	EM_ATTENDANCE_USER_STATUS		emUserStatus;                   // 用户状态
	BYTE							byReserved[128];				// 预留字段
}NET_ATTENDANCE_USER_INFO;

// 考勤模式信息（定制，对应枚举 NET_EM_CFG_ATTENDANCE_MODEL_INFO ）
typedef struct tagNET_CFG_ATTENDANCE_MODEL_INFO
{	
	DWORD							dwSize;							// 结构体大小						
	BOOL							bEnable;						// 是否开启考勤模式
	NET_TIME						stuBeginTime;					// 考勤开启时间
	NET_TIME						stuEndTime;						// 考勤结束时间
	NET_ATTENDANCE_USER_INFO		stuUserInfo[128];				// 考勤人员信息
	UINT							nUserCount;						// 考勤人员数量
	BYTE							byReserved[4];					// 预留字段
}NET_CFG_ATTENDANCE_MODEL_INFO;

// 时间表信息
typedef struct tagNET_CFG_TIME_SCHEDULE
{
	BOOL                    bEnableHoliday;                                                 // 是否支持节假日配置，默认为不支持，除非获取配置后返回为TRUE，不要使能假日配置
	DH_TSECT                stuTimeSection[DH_N_SCHEDULE_TSECT][DH_N_REC_TSECT];            // 第一维前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段
} NET_CFG_TIME_SCHEDULE;

// 事件标题内容结构体
typedef struct tagNET_CFG_EVENT_TITLE
{
	char					szText[CFG_MAX_CHANNELNAME_LEN];
	DH_POINT				stuPoint;						// 标题左上角坐标, 采用0-8191相对坐标系
	DH_SIZE     			stuSize;						// 标题的宽度和高度,采用0-8191相对坐标系，某项或者两项为0表示按照字体自适应宽高
	NET_COLOR_RGBA			stuFrontColor;					// 前景颜色
	NET_COLOR_RGBA			stuBackColor;					// 背景颜色
} NET_CFG_EVENT_TITLE;

// 邮件附件类型
typedef enum tagNET_CFG_ATTACHMENT_TYPE
{
	NET_ATTACHMENT_TYPE_PIC,							// 图片附件
	NET_ATTACHMENT_TYPE_VIDEO,							// 视频附件
	NET_ATTACHMENT_TYPE_NUM,							// 附件类型总数
} NET_CFG_ATTACHMENT_TYPE;
// 邮件详细内容
typedef struct tagNET_CFG_MAIL_DETAIL
{
	NET_CFG_ATTACHMENT_TYPE		emAttachType;                 // 附件类型
	int							nMaxSize;                     // 文件大小上限，单位kB
	int							nMaxTimeLength;               // 最大录像时间长度，单位秒，对video有效
}NET_CFG_MAIL_DETAIL;

// 轮巡联动配置
typedef struct tagNET_CFG_TOURLINK
{
	BOOL					bEnable;									// 轮巡使能
	DH_SPLIT_MODE   	    emSplitMode;								// 轮巡时的分割模式
	int						nChannels[CFG_MAX_VIDEO_CHANNEL_NUM];		// 轮巡通道号列表
	int						nChannelCount;								// 轮巡通道数量
} NET_CFG_TOURLINK;

// 门禁操作类型
enum NET_EM_CFG_ACCESSCONTROLTYPE
{
	NET_EM_CFG_ACCESSCONTROLTYPE_NULL = 0,					// 不做操作
	NET_EM_CFG_ACCESSCONTROLTYPE_AUTO,						// 自动
	NET_EM_CFG_ACCESSCONTROLTYPE_OPEN,						// 开门
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSE,						// 关门
	NET_EM_CFG_ACCESSCONTROLTYPE_OPENALWAYS,				// 永远开启
	NET_EM_CFG_ACCESSCONTROLTYPE_CLOSEALWAYS,				// 永远关闭
};

// 语音呼叫发起方
typedef enum tagNET_EM_CALLER_TYPE
{
	NET_EM_CALLER_DEVICE = 0,								// 设备发起
}NET_EM_CALLER_TYPE;

// 呼叫协议
typedef enum tagNET_EM_CALLER_PROTOCOL_TYPE
{
	NET_EM_CALLER_PROTOCOL_CELLULAR = 0,					// 手机方式
}NET_EM_CALLER_PROTOCOL_TYPE;

// 语音呼叫联动信息
typedef struct tagNET_CFG_TALKBACK_INFO
{
	BOOL							bCallEnable;					// 语音呼叫使能
	NET_EM_CALLER_TYPE				emCallerType;					// 语音呼叫发起方
	NET_EM_CALLER_PROTOCOL_TYPE		emCallerProtocol;				// 语音呼叫协议
}NET_CFG_TALKBACK_INFO;

// 电话报警中心联动信息
typedef struct tagNET_CFG_PSTN_ALARM_SERVER
{
	BOOL				bNeedReport;									// 是否上报至电话报警中心
	int					nServerCount;									// 电话报警服务器个数					
	BYTE 				byDestination[CFG_MAX_PSTN_SERVER_NUM];			// 上报的报警中心下标
}NET_CFG_PSTN_ALARM_SERVER;

// 车载工作计划配置
typedef struct tagNET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO
{
	DWORD							dwSize;
	BOOL							bEnable;							// 使能
	NET_CFG_TIME_SCHEDULE			stuWorkSchedule;					// 工作计划表
}NET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO;

// 荷载人数
typedef struct tagNET_CFG_VEHICLE_LOAD_INFO
{
	DWORD							dwSize;
	int								nLoadNumber;					    // 荷载人数
}NET_CFG_VEHICLE_LOAD_INFO;

#define MAX_TICKETINFO_NUM 8											// 票类信息最大个数
// 票类信息
typedef struct tagNET_CFG_TICKET_INFO
{
	BOOL							bEnable;							// 是否需要显示和打印
	char							szScreenModel[32];					// 显示的屏幕上该票的简称
	char							szPrintModel[64];					// 打印出来的票名称
	unsigned int					nFare;								// 票价
}NET_CFG_TICKET_INFO;

// 公交打印票价
typedef struct tagNET_CFG_TICKETPRINT_INFO
{
	DWORD							dwSize;
	BOOL							bEncodeBlend;						// 是否叠加到主码流
	char							szRoute[32];						// 路线
	char							szNumber[32];						// 序号
	unsigned int					nNormal;							// 普通票价
	unsigned int					nDiscount;							// 优惠价
	unsigned int					nSubsidy;							// 老幼补贴价
	unsigned int					nStatisticsNum;						// 统计票打印张数, 默认为1, 范围[1,2]
	unsigned int					nTicketInfoNum;						// 票类信息个数
	NET_CFG_TICKET_INFO				stuTicketInfo[MAX_TICKETINFO_NUM];	// 票类信息
	char							szText[256];						// 备注
}NET_CFG_TICKETPRINT_INFO;

// ACC延时关机时间
typedef struct tagNET_CFG_VEHICLEAUTOMAIN_INFO
{
	DWORD							dwSize;
	int								nAutoShutDelay;						//车载延时关机时间，ACC断电后开始计数。单位：分钟,[0, 65536], 65536等效于不关机
	int								nForceShutDelay;					//延时时间达到后，再强制延时关机时间。相当于ACC断电后，共延时Auto+Force分钟关机, [0, 65536]
	int								nPercent;							//以电池剩余电量为关机条件。此条件和AutoShutDelay两个条件并用。任意一个条件满足，即关机。默认0。[0, 100]
}NET_CFG_VEHICLEAUTOMAIN_INFO;

// 车载网络服务配置（印度BRT项目）
typedef struct tagNET_CFG_VEHICLENETSERVER_INFO
{
	DWORD							dwSize;
	BOOL							bEnable;							// 服务是否开启
	UINT							nUdpPort;							// Udp端口
	UINT							nTcpPort;							// 监听端口
}NET_CFG_VEHICLENETSERVER_INFO;

// 车载布控球IMSI绑定配置
typedef struct tagNET_CFG_IMSIBIND_INFO
{
	DWORD							dwSize;
	int								nIMSI;								// IMSI的个数
	char							szIMSI[4][32];						// 绑定的IMSI号
}NET_CFG_IMSIBIND_INFO;

// 车载人员维护设置
typedef struct tagNET_CFG_VEHICLE_MAINTAINCE_INFO
{
	DWORD							dwSize;
	char							szMaintainer[32];					// 维护人员
	char							szMaintainerID[32];					// 维护人员ID
	char							szInfo[256];						// 自定义维护信息
}NET_CFG_VEHICLE_MAINTAINCE_INFO;

// 假日信息
typedef struct tagNET_ACCESSCTL_SPECIALDAY_INFO
{
    char                            szDayName[32];                      // 组名称
    NET_TIME                        stuStartTime;                       // 开始时间
    NET_TIME                        stuEndTime;                         // 结束时间
    BYTE                            byReserved[256]; 
}NET_ACCESSCTL_SPECIALDAY_INFO;

// 门禁假日组配置
typedef struct tagNET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO
{
    DWORD							dwSize;
    BOOL                            bGroupEnable;                       // 组使能
    char                            szGroupName[32];                    // 组名称
    int                             nSpeciaday;                         // 有效的节假日数量
    NET_ACCESSCTL_SPECIALDAY_INFO   stuSpeciaday[16];                   // 假日信息
}NET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO;

// 门禁假日计划配置
typedef struct tagNET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO 
{
    DWORD							dwSize;
    char                            szSchduleName[64];                  // 假日计划名称
    BOOL                            bSchdule;                           // 假日计划使能
    int                             nGroupNo;                           // NET_EM_CFG_ACCESSCTL_SPECIALDAY_GROUP 配置的下标
    int                             nTimeSection;                       // 一天的时间段个数
    DH_TSECT                        stuTimeSection[6];                  // 时间段
    int                             nDoorNum;                           // 有效的门数量
    int                             nDoors[64];                         // 生效的门通道号       
}NET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO;

// 序列号白名单下发至NVR 
typedef struct tagNET_CFG_SERIALNOWHITETABLE_INFO
{
    DWORD                           dwSize;
    int                             nCount;                         // 有效的序列号个数
    char                            szSerialNo[512][48];            // 序列号数组
}NET_CFG_SERIALNOWHITETABLE_INFO;

/////////////////////////////////////////////////////////灵信视觉定制需求-start////////////////////////////////////////////////////////////////////////
// 灵信视觉平台无锡交警信息下发定制需求 
typedef struct tagNET_CFG_LXSJ_WXJJ_INFO
{
    DWORD                           dwSize;
    BOOL                            bEnable;                            // 是否使能
    NET_TIME                        stuStartTime;                       // 开始时间
    NET_TIME                        stuEndTime;                         // 结束时间
    char                            szText[256];                        // 下发信息内容
    char                            szDisplayContent[256];              // 屏上显示的内容
}NET_CFG_LXSJ_WXJJ_INFO;

// 通讯传输方式
typedef enum tagNET_EM_LXSJ_TRANSMODE
{
	NET_EM_LXSJ_TRANSMODE_UNKNOWN = -1,									// 未知
	NET_EM_LXSJ_TRANSMODE_TCP,											// TCP方式
	NET_EM_LXSJ_TRANSMODE_UDP											// UDP方式
}NET_EM_LXSJ_TRANSMODE;

// 字体颜色
typedef enum tagNET_EM_LXSJ_FONTCOLOR
{
	NET_EM_LXSJ_FONTCOLOR_UNKNOWN = -1,									// 未知
	NET_EM_LXSJ_FONTCOLOR_R0_G0_B0,										// 0-红灯、绿灯、蓝灯都不亮
	NET_EM_LXSJ_FONTCOLOR_R1_G0_B0,										// 1-红灯亮、绿灯不亮、蓝灯不亮
	NET_EM_LXSJ_FONTCOLOR_R0_G1_B0,										// 2-红灯不亮、绿灯亮、蓝灯不亮
	NET_EM_LXSJ_FONTCOLOR_R1_G1_B0,										// 3-红灯亮、绿灯亮、蓝灯不亮
	NET_EM_LXSJ_FONTCOLOR_R0_G0_B1,										// 4-红灯不亮、绿灯不亮、蓝灯亮
	NET_EM_LXSJ_FONTCOLOR_R1_G0_B1,										// 5-红灯亮、绿灯不亮、蓝灯亮
	NET_EM_LXSJ_FONTCOLOR_R0_G1_B1,										// 6-红灯不亮、绿灯亮、蓝灯不亮
	NET_EM_LXSJ_FONTCOLOR_R1_G1_B1										// 7-红灯、绿灯、蓝灯全亮
}NET_EM_LXSJ_FONTCOLOR;

// 无车牌配置项
typedef struct tagNET_CFG_VSP_LXSJ_NOPLATE
{
	BOOL							bEnable;							// 使能
	char							szText[128];						// 无牌车内容
	BYTE							byReserved[380];					// 预留
}NET_CFG_VSP_LXSJ_NOPLATE;

// 通用违章配置项
typedef struct tagNET_CFG_VIOLATIONTYPE_NORMAL
{
	BOOL							bEnable;							// 使能
	NET_EM_LXSJ_FONTCOLOR			emTextColor;						// 文本颜色
	char							szText[128];						// 违法内容
	BYTE							byReserved[376];					// 预留
}NET_CFG_VIOLATIONTYPE_NORMAL;

typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICOVERSPEED;			// 超速 
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICCROSSLANE;			// 违法变道 
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICPARKING;			// 违法停车
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICBACKING;			// 违法倒车 
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICRETROGRADE;		// 逆行
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_PARKINGWARNING;			// 违停预警
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICPEDESTRAINPRIORITY;// 礼让行人
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICRUNREDLIGHT;		// 闯红灯
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICWRONGROUTE;		// 不按车道行驶
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICJAMFORBIDINTO;		// 车辆拥堵禁入
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICOVERLINE;			// 压白线
typedef NET_CFG_VIOLATIONTYPE_NORMAL NET_CFG_VIOLATIONTYPE_TRAFFICVEHICLEINROUTE;	// 有车占道

// 卡口违章配置项
typedef struct tagNET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION
{
	BOOL							bEnable;							// 使能
	NET_EM_LXSJ_FONTCOLOR			emTrustTextColor;					// 文本颜色
	char							szTrustText[128];					// 在白名单内时内容
	NET_EM_LXSJ_FONTCOLOR			emDisTrustTextColor;				// 文本颜色
	char							szDisTrustText[128];				// 不在白名单内时内容
	BYTE							byReserved[244];					// 预留
}NET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION;

// 违章类型使能集
typedef struct tagNET_CFG_VSP_LXSJ_VIOLATIONTYPE
{
	NET_CFG_VIOLATIONTYPE_TRAFFICOVERSPEED			stuTrafficOverSpeed;				// 超速 
	NET_CFG_VIOLATIONTYPE_TRAFFICCROSSLANE			stuTrafficCrossLane;				// 违法变道 
	NET_CFG_VIOLATIONTYPE_TRAFFICPARKING			stuTrafficParking;					// 违法停车 
	NET_CFG_VIOLATIONTYPE_TRAFFICBACKING			stuTrafficBacking;					// 违法倒车 
	NET_CFG_VIOLATIONTYPE_TRAFFICRETROGRADE			stuTrafficRetrograde;				// 逆行
	NET_CFG_VIOLATIONTYPE_PARKINGWARNING			stuParkingWarning;					// 违停预警 
	NET_CFG_VIOLATIONTYPE_TRAFFICJUNCTION			stuTrafficJunction;					// 卡口
	NET_CFG_VIOLATIONTYPE_TRAFFICPEDESTRAINPRIORITY	stuTrafficPedestrainPriority;		// 礼让行人
	NET_CFG_VIOLATIONTYPE_TRAFFICRUNREDLIGHT		stuTrafficRunRedLight;				// 闯红灯
	NET_CFG_VIOLATIONTYPE_TRAFFICWRONGROUTE			stuTrafficWrongRoute;				// 不按车道行驶
	NET_CFG_VIOLATIONTYPE_TRAFFICJAMFORBIDINTO		stuTrafficJamForbidInto;			// 车辆拥堵禁入
	NET_CFG_VIOLATIONTYPE_TRAFFICOVERLINE			stuTrafficOverLine;					// 压白线
	NET_CFG_VIOLATIONTYPE_TRAFFICVEHICLEINROUTE		stuTrafficVehicleInRoute;			// 有车占道
	BYTE											byReserved[13824];					// 预留
}NET_CFG_VSP_LXSJ_VIOLATIONTYPE;

// 颜色类型
typedef enum tagNET_EM_LXSJ_COLORTYPE
{
	NET_EM_LXSJ_COLORTYPE_UNKNOWN = -1,										// 未知
	NET_EM_LXSJ_COLORTYPE_SINGLE_COLOR = 1,									// 单色
	NET_EM_LXSJ_COLORTYPE_DOUBLE_COLOR = 2,										// 双色
	NET_EM_LXSJ_COLORTYPE_THREE_COLOR = 3,										// 三色
}NET_EM_LXSJ_COLORTYPE;

// 区域数据类型
typedef enum tagNET_EM_LXSJ_AREATYPE
{
	NET_EM_LXSJ_AREATYPE_UNKNOWN = -1, //未知
	NET_EM_LXSJ_AREATYPE_STATIC_TYPE = 0, // 0- 静态
	NET_EM_LXSJ_AREATYPE_DYNAMIC_TYPE = 1, // 1- 动态
}NET_EM_LXSJ_AREATYPE;

// 区域显示类型
typedef enum tagNET_EM_LXSJ_DISPLAYTYPE
{
	NET_EM_LXSJ_DISPLAYTYPE_UNKNOWN = -1, //未知
	NET_EM_LXSJ_DISPLAYTYPE_BACK_TYPE = 0, // 0- 背景
	NET_EM_LXSJ_DISPLAYTYPE_FRONT_TYPE = 1, // 1- 前景
}NET_EM_LXSJ_DISPLAYTYPE;

// 显示风格
typedef enum tagNET_EM_LXSJ_SHOWMODE
{
	NET_EM_LXSJ_SHOWMODE_UNKNOWN  = -1,				// 未知
	NET_EM_LXSJ_SHOWMODE_IMMEDIATELY = 1,			// 立即显示
	NET_EM_LXSJ_SHOWMODE_TO_LEFT = 2,				// 向左移动
	NET_EM_LXSJ_SHOWMODE_TO_TOP = 3,				// 向上移动
	NET_EM_LXSJ_SHOWMODE_TO_RIGHT = 4,				// 向右移动
	NET_EM_LXSJ_SHOWMODE_TO_BOTTOM = 5,				// 向下移动
	NET_EM_LXSJ_SHOWMODE_BLINK = 6,					// 闪烁 
	NET_EM_LXSJ_SHOWMODE_TO_TOP_CONTINUOUS = 94,	// 向上连移
	NET_EM_LXSJ_SHOWMODE_TO_BOTTOM_CONTINUOUS = 95,	// 向下连移
	NET_EM_LXSJ_SHOWMODE_TO_RIGHT_CONTINUOUS = 96,	// 向右连移
	NET_EM_LXSJ_SHOWMODE_TO_LEFT_CONTINUOUS = 97,	// 向左连移
}NET_EM_LXSJ_SHOWMODE;

// 文字大小(字高宽点数)
typedef enum tagNET_EM_LXSJ_FONTSIZE
{
	NET_EM_LXSJ_FONTSIZE_UNKNOWN = -1,		// 未知
	NET_EM_LXSJ_FONTSIZE_16 = 16,			// 16点阵
	NET_EM_LXSJ_FONTSIZE_32 = 32,			// 32点阵
}NET_EM_LXSJ_FONTSIZE;

// 名称类型
typedef enum tagNET_EM_LXSJ_ELEM_NAMETYPE
{
	NET_EM_LXSJ_ELEM_NAMETYPE_UNKNOWN = -1,		// 未知
	NET_EM_LXSJ_ELEM_NAMETYPE_SEPERATER = 0,			// 0-分隔符
	NET_EM_LXSJ_ELEM_NAMETYPE_NEWLINE = 1,				// 1-换行符
	NET_EM_LXSJ_ELEM_NAMETYPE_PLATE = 2,				// 2-车牌
	NET_EM_LXSJ_ELEM_NAMETYPE_VIOLATIONINFO = 3,		// 3-违章信息
	NET_EM_LXSJ_ELEM_NAMETYPE_SPEED = 4,				// 4-速度
	NET_EM_LXSJ_ELEM_NAMETYPE_CUSTOM = 5,				// 5-自定义项
}NET_EM_LXSJ_ELEM_NAMETYPE;

// 叠加元素
typedef struct tagNET_CFG_VSP_LXSJ_ELEMENT
{
	NET_EM_LXSJ_ELEM_NAMETYPE		emNameType;			// 名称类型
	char							szName[32];			// 名称
	char							szPrefix[64];		// 前缀字符串	
	char							szPostfix[64];		// 后缀字符串
	int								nSeperaterCount;	// 后面添加分隔符个数
	BYTE							byReserved[856];	// 预留
}NET_CFG_VSP_LXSJ_ELEMENT;

// 区域数据配置项
typedef struct tagNET_CFG_VSP_LXSJ_AREADATA
{
	NET_EM_LXSJ_AREATYPE			emAreaType;							// 区域数据类型
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// 区域显示类型
	UINT							nAreaX1;							// 区域开始坐标X1
	UINT							nAreaY1;							// 区域开始坐标Y1
	UINT							nAreaX2;							// 区域开始坐标X2
	UINT							nAreaY2;							// 区域开始坐标Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// 区域字体颜色
	DH_COLOR_RGBA					stuRGB;								// 区域字体RGB值
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// 显示风格
	UINT							nMoveSpeed;							// 移动速度，越小越快(单位5ms)
	UINT							nStayTime;							// 每页停留时间（单位1s）
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// 文字大小(字高宽点数)
	UINT							nMaxRollingItem;					// 区域数据最大滚动项
	int								nElement;							// 叠加元素的个数
	NET_CFG_VSP_LXSJ_ELEMENT		stuElement[16];						// 元素列表
	BYTE							byReserved[956];					// 预留
}NET_CFG_VSP_LXSJ_AREADATA;

// 自定义配置项
typedef struct tagNET_CFG_VSP_LXSJ_CUSTOM
{
	BOOL							bEnable;
	UINT							nWaitTime;							// 等待时间，单位秒
	char							szText[256];						// 自定义显示内容
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// 区域显示类型
	UINT							nAreaX1;							// 区域开始坐标X1
	UINT							nAreaY1;							// 区域开始坐标Y1
	UINT							nAreaX2;							// 区域开始坐标X2
	UINT							nAreaY2;							// 区域开始坐标Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// 区域字体颜色
	DH_COLOR_RGBA					stuRGB;								// 区域字体RGB值
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// 显示风格
	UINT							nMoveSpeed;							// 移动速度，越小越快(单位5ms)
	UINT							nStayTime;							// 每页停留时间（单位1s）
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// 文字大小(字高宽点数)
	BYTE							byReserved[704];					// 预留 
}NET_CFG_VSP_LXSJ_CUSTOM;

// 滚动配置项
typedef struct tagNET_CFG_VSP_LXSJ_ROLLCONFIG
{
	BOOL							bEnable;
	UINT							nMaxItemNum;						// 最大滚动记录数
	UINT							nPeriod;							// 周期
	BYTE							byReserved[52];						// 预留 
}NET_CFG_VSP_LXSJ_ROLLCONFIG;

// 标语配置项/警示配置
typedef struct tagNET_CFG_VSP_LXSJ_SLOGAN
{
	char							szText[256];						// 显示内容
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// 区域显示类型
	UINT							nAreaX1;							// 区域开始坐标X1
	UINT							nAreaY1;							// 区域开始坐标Y1
	UINT							nAreaX2;							// 区域开始坐标X2
	UINT							nAreaY2;							// 区域开始坐标Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// 区域字体颜色
	DH_COLOR_RGBA					stuRGB;								// 区域字体RGB值
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// 显示风格
	UINT							nMoveSpeed;							// 移动速度，越小越快(单位5ms)
	UINT							nStayTime;							// 每页停留时间（单位1s）
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// 文字大小(字高宽点数)
	BYTE							byReserved[712];					// 预留 
}NET_CFG_VSP_LXSJ_SLOGAN, NET_CFG_VSP_LXSJ_WARNNING;

// 交通拥堵事件配置项
typedef struct tagNET_CFG_VSP_LXSJ_TRAFFICJAM
{
	BOOL							bEnable;
	NET_CFG_VSP_LXSJ_SLOGAN			stuSlogan;							// 标语配置项
	NET_CFG_VSP_LXSJ_WARNNING		stuWarnning;						// 警示配置
	BYTE							byReserved[4096];					// 预留
}NET_CFG_VSP_LXSJ_TRAFFICJAM;

// 雷达预警配置项
typedef struct tagNET_CFG_VSP_LXSJ_RADARPREALARM
{
	BOOL							bEnable;
	char							szText[256];						// 显示内容
	NET_EM_LXSJ_DISPLAYTYPE			emAreaDisplayType;					// 区域显示类型
	UINT							nAreaX1;							// 区域开始坐标X1
	UINT							nAreaY1;							// 区域开始坐标Y1
	UINT							nAreaX2;							// 区域开始坐标X2
	UINT							nAreaY2;							// 区域开始坐标Y2
	NET_EM_LXSJ_FONTCOLOR			emFontColor;						// 区域字体颜色
	DH_COLOR_RGBA					stuRGB;								// 区域字体RGB值
	NET_EM_LXSJ_SHOWMODE			emShowMode;							// 显示风格
	UINT							nMoveSpeed;							// 移动速度，越小越快(单位5ms)
	UINT							nStayTime;							// 每页停留时间（单位1s）
	NET_EM_LXSJ_FONTSIZE			emFontSize;							// 文字大小(字高宽点数)
	BYTE							byReserved[708];					// 预留 
}NET_CFG_VSP_LXSJ_RADARPREALARM;

// 灵信视觉平台接入配置
typedef struct tagNET_CFG_VSP_LXSJ_INFO
{
    DWORD                           dwSize;
	BOOL                            bEnable;                            // 平台接入使能
	char							szServerIP[32];						// 平台服务器IP地址
	int								nServerPort;						// 服务器端口
	NET_EM_LXSJ_TRANSMODE			emTransMode;						// 通讯传输方式
	char							szContorlID[32];					// 控制器ID
	UINT							nWidth;								// 显示屏宽度
	UINT							nHeigth;							// 显示屏高度
	UINT							nPlayTime;							// 播放时间(秒)
	UINT							nCirclePlayTimes;					// 循环播放次数

	NET_EM_LXSJ_COLORTYPE			emColorType;						// 颜色类型
	NET_CFG_VSP_LXSJ_NOPLATE		stuNoPlate;							// 无车牌配置项
	NET_CFG_VSP_LXSJ_VIOLATIONTYPE	stuViolationType;					// 违章类型使能集
	int								nAreaDataNum;						// 区域数据配置项个数
	NET_CFG_VSP_LXSJ_AREADATA		stuAreaData[16];					// 区域数据配置项
	NET_CFG_VSP_LXSJ_CUSTOM			stuCustom;							// 自定义配置项
	NET_CFG_VSP_LXSJ_ROLLCONFIG     stuRollConfig;						// 滚动配置项
	NET_CFG_VSP_LXSJ_TRAFFICJAM		stuTrafficJam;						// 交通拥堵事件配置项
	NET_CFG_VSP_LXSJ_RADARPREALARM  stuRadarPreAlarm;					// 雷达预警配置项
}NET_CFG_VSP_LXSJ_INFO;

/////////////////////////////////////////////////////////灵信视觉定制需求-end////////////////////////////////////////////////////////////////////////

// 对应模式下的值
typedef struct tagNET_CFG_GLOBAL_MODEVALUE_INFO
{
	int				nNormal;											// 普通模式的值
	int				nAlarm;												// 报警模式的值
	BYTE			byReserved[24];										// 保留字段	
}NET_CFG_GLOBAL_MODEVALUE_INFO;

// 传感器报警全局配置 
typedef struct tagNET_CFG_SENSOR_ALARM_GLOBAL_INFO
{
	DWORD                           dwSize;
	NET_CFG_GLOBAL_MODEVALUE_INFO	stuFrequency;						// 设备采集周期
	NET_CFG_GLOBAL_MODEVALUE_INFO	stuTimes;							// 设备采集次数
}NET_CFG_SENSOR_ALARM_GLOBAL_INFO;

// 传感器信息
typedef struct tagNET_CFG_SERSOR_INFO
{
	NET_SENSE_METHOD				emSenseMethod;						// 传感器类型
	int								nAlarmLowerLimit;					// 下限报警值，低于此值会报警
	int								nAlarmHighLimit;					// 上限报警值，高于此值会报警
	BYTE							byReserved[500];					// 保留字段	
}NET_CFG_SERSOR_INFO;

// 传感器报警配置 
typedef struct tagNET_CFG_SENSOR_ALARM_INFO
{
	DWORD                           dwSize;
	int								nMaxNum;							// pstSensorList数组分配的内存的最大个数
	int								nRetNum;							// 实际传感器的个数
	NET_CFG_SERSOR_INFO*			pstSensorList;						// 传感器列表，内存由用户分配，大小为nMaxNum * sizeof(NET_CFG_SERSOR_INFO)
}NET_CFG_SENSOR_ALARM_INFO;

// 时间点
typedef struct tagNET_TIME_POINT
{
	int             bEnable;                        // 使能
	int				nHour;							// 时
	int				nMin;							// 分
	int				nSec;							// 秒
}NET_TIME_POINT;

// 定时抓拍配置(湖南河道保洁定制)(对应枚举 NET_EM_CFG_TIMINGCAPTURE) 
typedef struct tagNET_CFG_TIMINGCAPTURE_INFO
{
	DWORD                           dwSize;
	NET_TIME_POINT					stuTimeSchedule[DH_N_WEEKS];		// 定时抓拍时间（注：7个元素中，第一个是星期日，第二个是星期一，以此类推）
}NET_CFG_TIMINGCAPTURE_INFO;

// 云台速度配置
typedef struct tagNET_CFG_PTZ_SPEED
{
	DWORD                           dwSize;
	int                             nPtzSpeed;							// 云台速度 0~4
	int                             nPatternSpeed;						// 巡迹速度 1-10档可调，10档为100%速度，5档为50%速度，依此类推。
}NET_CFG_PTZ_SPEED;

// 云台水平旋转组限制信息
typedef struct tagNET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO
{
	BOOL			bLimitEnable;					// 限制使能
	int				nLimitMode;						// 限制模式 0:左右 1：上下
	BYTE			byReserved[256];				// 保留字节
} NET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO;

// 云台水平旋转组扫描配置 NET_EM_CFG_PTZ_HORIZONTAL_ROTATION_SCAN
typedef struct tagNET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO
{
	DWORD												dwSize;									// 结构体大小								
	NET_CFG_HORIZONTAL_ROTATION_LIMIT_INFO				stuHorizontalRotationInfo;				// 云台水平旋转组限制信息
} NET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO;

// 线扫信息
typedef struct tagNET_AUTOSCAN_INFO
{
	char												szName[32];				// 线扫号名称
	BOOL												bLeftEnable;			// 该线扫左边界是否生效
	BOOL												bRightEnable;			// 该线扫右边界是否生效
	UINT												nScanSpeed;				// 线扫速度,0~7
	BYTE												byReserved[948];		// 预留
}NET_AUTOSCAN_INFO;

// 自动线扫设置
typedef struct tagNET_CFG_AUTOSCAN_INFO
{
	DWORD												dwSize;					// 结构体大小
	int													nMaxScanInfoNum;		// 用户分配的pAutoScanInfos内存的个数
	NET_AUTOSCAN_INFO*									pAutoScanInfos;			// 线扫信息，内存由用户分配，大小应为 nMaxScanInfoNum * sizeof(NET_AUTOSCAN_INFO)
	int													nRetScanInfoNum;		// 实际获取/设置的配置的个数，必须小于nMaxScanInfoNum
}NET_CFG_AUTOSCAN_INFO;

// 白光灯视频通道配置 NET_PRIOR_MODE_INFO
typedef struct tagNET_CFG_COAXIAL_LIGHT_INFO 
{
	DWORD							dwSize;
	BOOL							bEnable;											// 联动使能
	DH_TSECT						stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// 白光灯联动时间段
} NET_CFG_COAXIAL_LIGHT_INFO;

// 视频输出颜色
typedef struct tagNET_VIDEO_OUT_COLOR 
{
    UINT			nBrightness;					// 亮度, 0~100
    UINT			nContrast;						// 对比度, 0~100
    UINT			nSaturation;					// 饱和度, 0~100
    UINT			nHue;							// 色调, 0~100
    UINT			nGamma;						    // Gamma值, 0~100
    BYTE            byResered[132];                 // 保留字节
} NET_VIDEO_OUT_COLOR;

// 输出信号模式
typedef enum tagEM_VIDEO_OUT_FORMAT
{
    EM_VIDEO_OUT_FORMAT_UNKNOWN,            // 未知
    EM_VIDEO_OUT_FORMAT_AUTO,               // Auto, 不允许下发
    EM_VIDEO_OUT_FORMAT_TV,                 // TV
    EM_VIDEO_OUT_FORMAT_VGA,                // VGA
    EM_VIDEO_OUT_FORMAT_DVI,                // DVI
    EM_VIDEO_OUT_FORMAT_HDMI,               // DHMI
    EM_VIDEO_OUT_FORMAT_SPOT,               // SPOT
    EM_VIDEO_OUT_FORMAT_SDI,                // SDI
} EM_VIDEO_OUT_FORMAT;

// 输出扫描模式
typedef enum tagEM_VIDEO_OUT_SCAN_FORMAT
{
    EM_VIDEO_OUT_SCAN_FORMAT_UNKNOWN,       // 未知
    EM_VIDEO_OUT_SCAN_FORMAT_PROGRESSIVE,   // 逐行
    EM_VIDEO_OUT_SCAN_FORMAT_INTERLACE,     // 隔行
} EM_VIDEO_OUT_SCAN_FORMAT;


// 视频输出模式
typedef struct tagNET_VIDEO_OUT_MODE 
{
    int			                nWidth;							// 水平分辨率
    int			                nHeight;						// 垂直分辨率
    int			                nBPP;							// 颜色深度
    int			                nRefreshRate;					// 刷新频率
    EM_VIDEO_OUT_FORMAT		    emFormat;						// 输出信号模式
    EM_VIDEO_OUT_SCAN_FORMAT    emScanFormat;					// 输出扫描模式
    BYTE                        byResered[128];                 // 保留字节
} NET_VIDEO_OUT_MODE;

// 自定义视频输出模式
typedef struct tagNET_VIDEO_OUT_USERDEF_MODE 
{
    int			                nWidth;							// 水平分辨率
    int			                nHeight;						// 垂直分辨率
    int			                nBPP;							// 颜色深度
    int			                nRefreshRate;					// 刷新频率
    EM_VIDEO_OUT_FORMAT		    emFormat;						// 输出信号模式
    EM_VIDEO_OUT_SCAN_FORMAT    emScanFormat;					// 输出扫描模式
    BYTE                        byResered[128];                 // 保留字节
} NET_VIDEO_OUT_USERDEF_MODE;

// 视频输出配置 NET_EM_CFG_VIDEO_OUT
typedef struct tagNET_CFG_VIDEO_OUT_INFO
{
    DWORD				        dwSize;
    BOOL                        bEnable;                    // 使能
    UINT		                nMargin[4];					// 缩小比率,每一项分别表示视频输出左上右下四个边的缩小比率,每项0~100
    BOOL				        bIQIMode;					// 输出图像增强
    BOOL				        bIsUserDefMode;				// 是否启用户自定义视频输出模式
    NET_VIDEO_OUT_COLOR         stuColor;                   // 视频输出颜色
    NET_VIDEO_OUT_MODE          stuMode;                    // 视频输出模式
    NET_VIDEO_OUT_USERDEF_MODE  stuSelfDefMode;             // 自定义视频输出模式, 当bIsUserDefMode为TRUE时有效
} NET_CFG_VIDEO_OUT_INFO;

// 配置录像上传到云服务器的时间段 
typedef struct tagNET_CFG_CLOUDUPLOADTIME_INFO
{
    DWORD                           dwSize;
    BOOL                            bEnable;                        // 使能
    NET_TIME                        stStartTime;                    // 开始时间段,在时间段内进行视频上传
    NET_TIME                        stEndTime;                      // 结束时间段,在时间段内进行视频上传
}NET_CFG_CLOUDUPLOADTIME_INFO;

// 单个平台接入启动选项
typedef enum tagEM_SERVER_OPTION
{
	EM_SERVER_OPTION_UNKNOWN,			// 未知
	EM_SERVER_OPTION_DISABLE,			// 平台接入不启动
	EM_SERVER_OPTION_GB28181,			// 以28181接入方式开启
	EM_SERVER_OPTION_GB35114,			// 以35114接入方式开启
}EM_SERVER_OPTION;

// 通道相关信息
typedef struct tagNET_CHANNEL_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// 通道编号
	unsigned int		nAlarmLevel;							// 报警级别,范围[1,6]
	BYTE				byReserved[1024];						// 保留字节			
}NET_CHANNEL_INFO;

// 报警相关信息
typedef struct tagNET_ALARM_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// 通道编号
	unsigned int		nAlarmLevel;							// 报警级别,范围[1,6]
	BYTE				byReserved[1024];						// 保留字节	
}NET_ALARM_INFO;

// 音频输出通道相关信息
typedef struct tagNET_AUDIO_OUTPUT_CHANNEL_INFO
{
	char				szID[MAX_CHANNEL_ID_LEN];				// 通道编号
	BYTE				byReserved[1024];						// 保留字节	
}NET_AUDIO_OUTPUT_CHANNEL_INFO;

// SIP服务器信息
typedef struct tagNET_SIP_SERVER_INFO
{
	EM_SERVER_OPTION			emServerOption;								// 单个平台接入启动选项
	char						szSipSvrId[MAX_SIP_SVR_ID_LEN];				// SIP服务器编号
	char						szDomain[MAX_SIP_DOMAIN_LEN];				// SIP域
	char						szSipSvrIp[MAX_SIP_SVR_IP_LEN];				// SIP服务器IP
	char						szDeviceId[MAX_SIP_SERVER_DEVICE_ID_LEN];	// 设备编号
	char						szPassword[MAX_REG_PASSWORD_LEN];		    // 注册密码
	unsigned short				nLocalSipPort;								// 本地SIP服务端口
	unsigned short				nSipSvrPort;								// SIP服务器端口
	unsigned int				nSipRegExpires;								// 注册有效期,单位:秒
	unsigned int				nRegInterval;								// 注册失败后重新注册间隔,单位:秒
	unsigned int				nKeepAliveCircle;							// 心跳周期,单位:秒
	unsigned int				nMaxTimeoutTimes;							// 最大心跳超时次数
	char						szCivilCode[MAX_CIVIL_CODE_LEN];			// 行政区划代码
	char						szIntervideoID[MAX_INTERVIDEO_ID_LEN];		// 接入模块识别码
	NET_CHANNEL_INFO*			pstuChannnelInfo;							// 通道相关信息,由用户申请内存,大小为sizeof(NET_CHANNEL_INFO)*nChannelInfoNum
	unsigned int				nChannelInfoNum;							// 通道信息个数,可以根据登陆时获取的通道数为准
	unsigned int				nRetChannelInfoNum;							// 实际返回的通道号信息个数
	NET_ALARM_INFO*				pstuAlarmInfo;								// 报警通道相关信息,由用户申请内存,大小为sizeof(NET_ALARM_INFO)*nAlarmInfoNum
	unsigned int				nAlarmInfoNum;								// 报警信息个数,最大值为640
	unsigned int				nRetAlarmInfoNum;							// 实际返回的报警通道信息个数
	NET_AUDIO_OUTPUT_CHANNEL_INFO*		pstuAudioOutputChnInfo;				// 音频输出通道相关信息,由用户申请内存,大小为sizeof(NET_AUDIO_OUTPUT_CHANNEL_INFO)*nAudioOutputChnInfoNum
	unsigned int				nAudioOutputChnInfoNum;						// 音频输出通道相关信息个数,最大值为181
	unsigned int				nRetAudioOutputChnInfoNum;					// 实际返回的音频输出通道信息个数
	BYTE						byReserved[1024];							// 预留字节
}NET_SIP_SERVER_INFO;


// 公安一所平台接入配置信息
typedef struct tagNET_CFG_VSP_GAYS_SERVER_INFO
{
	DWORD							dwSize;											// 结构体大小
	unsigned int					nSipServerInfoNum;								// 下发SIP服务器信息的个数,不超过MAX_SIP_SERVER_NUM
	NET_SIP_SERVER_INFO				stuSipServerInfo[MAX_SIP_SERVER_NUM];			// SIP服务器信息
	unsigned int					nRetSipServerInfoNum;							// 获取到的实际返回SIP服务器信息个数
	BYTE							byReserved[4];									// 预留对齐字节
}NET_CFG_VSP_GAYS_SERVER_INFO;

// 协同签名服务器配置信息,对应 NET_EM_CFG_VSP_CO_SIGN_SERVER
typedef struct tagNET_CFG_VSP_CO_SIGN_SERVER_INFO
{
	DWORD							dwSize;						// 结构体大小
	char							szCoSignServerIP[64];		// 协同签名服务器IP地址
	unsigned int					nCoSignServerPort;			// 协同签名服务器端口
}NET_CFG_VSP_CO_SIGN_SERVER_INFO;

// 上报对象信息
typedef struct tagNET_VSP_GAVI_NOTIFY_OBJECT
{
	BOOL							bFaceChecked;				// 人脸选中
	BOOL							bPersonChecked;				// 人体选中
	BOOL							bMotorVehicleChecked;		// 机动车选中
	BOOL							bNonMotorVehicleChecked;	// 非机动车选中
	BOOL							bImageChecked;				// 图片选中
	BYTE							byReserved[516];			// 预留字段
}NET_VSP_GAVI_NOTIFY_OBJECT;


// 通道信息
typedef struct tagNET_VSP_GAVI_CHANNEL_INFO
{
	char							szChannelEncode[24];		// 通道编码
	NET_VSP_GAVI_NOTIFY_OBJECT		stuNotifyObject;			// 上报设备信息
	BYTE							byReserved[512];			// 预留字段
}NET_VSP_GAVI_CHANNEL_INFO;

// 接入平台枚举
typedef enum tagEM_VSP_GAVI_PLATFORM_CODE
{
	EM_VSP_GAVI_PLATFORM_CODE_UNKNOWN = -1,						// 未知
	EM_VSP_GAVI_PLATFORM_CODE_DEFAULT,							// 默认，标准视图库接入平台
	EM_VSP_GAVI_PLATFORM_CODE_DAHUA,							// 大华视图库
	EM_VSP_GAVI_PLATFORM_CODE_HKTDA_CLOUDSTORAGE,				// 海康TDA+云存储
	EM_VSP_GAVI_PLATFORM_CODE_UNIVIEW,							// 宇视
	EM_VSP_GAVI_PLATFORM_CODE_HKTEST,							// 海康接口测试
	EM_VSP_GAVI_PLATFORM_CODE_SHQPNETPOSE,						// 上海清浦东方网力
	EM_VSP_GAVI_PLATFORM_CODE_HKTDA,							// 海康TDA
	EM_VSP_GAVI_PLATFORM_CODE_HARZONE,							// 华尊
	EM_VSP_GAVI_PLATFORM_CODE_NETPOSE,							// 东方网力
	EM_VSP_GAVI_PLATFORM_CODE_TAOAN,							// 韬安
	EM_VSP_GAVI_PLATFORM_CODE_RESERVED,							// 预留
	EM_VSP_GAVI_PLATFORM_CODE_HKVIEWGATEWAY,					// 海康视图网关
	EM_VSP_GAVI_PLATFORM_CODE_KODAK,							// 柯达	
}EM_VSP_GAVI_PLATFORM_CODE;

// 海康视图云存储服务器鉴权密钥
typedef struct tagNET_HKIMAGESERVER_INFO
{
	char						szAccessKey[136];				// 接入码
	char						szSecretKey[136];				// 鉴权密钥
	BYTE						szReserved[512];				// 预留字段
}NET_HKIMAGESERVER_INFO;

// 注册平台信息
typedef struct tagNET_VSP_GAVI_INFO
{
    char                			szAddress[128];    			// 注册平台IP地址或网络名。IP为空时，不做接入
    char                			szUserId[64];       		// 设备登陆帐号
    char                			szPassword[64];     		// 登陆密码
    UINT                			nPort;              		// 注册平台端口号
	BOOL							bEnable;					// 接入使能
	UINT							nKeepAliveTime;				// 会话保活周期，范围[10,90],单位秒
	UINT							nMaxTimeoutTimes;			// 最大超时次数，范围[2,5]
	UINT							nRegisterInterval;			// 注册失败后重新注册随机时间上限，范围[30,300],单位秒	
	char							szDeviceID[24];				// 注册设备ID	
	NET_VSP_GAVI_CHANNEL_INFO* 		pstuChannelInfo; 			// 通道信息，用户分配内存
	UINT							nChannelCount;				// pstuChannelInfo 个数，和通道数保持一致
	UINT							nChannelCountRet;			// 返回的 pstuChannelInfo 个数
	EM_VSP_GAVI_PLATFORM_CODE		emPlatform;					// 当前平台
	BOOL							bIsOnLine;					// 是否在线，不可修改
	NET_HKIMAGESERVER_INFO*			pHKImageServerInfo;			// 海康视图云存储服务器鉴权密钥信息，emPlatform 为 EM_VSP_GAVI_PLATFORM_CODE_HKTDA_CLOUDSTORAGE时有效
    BYTE                			byReserved[68];    			// 保留字节 
}NET_VSP_GAVI_INFO;

// 接入平台范围信息
typedef struct tagNET_VSP_GAVI_PLATFORM_INFO
{
	EM_VSP_GAVI_PLATFORM_CODE	emPlatformCode;					// 平台码
	char						szPlatformName[128];			// 平台名称
	BYTE						byReserved[132];				// 预留字段
}NET_VSP_GAVI_PLATFORM_INFO;

// 公安视频图像信息应用系统接入配置,对应 NET_EM_CFG_VSP_GAVI
typedef struct tagNET_CFG_VSP_GAVI_INFO
{
    DWORD						dwSize;				    		// 结构体大小
    int							nGaviInfoCount;         		// 注册平台个数
    NET_VSP_GAVI_INFO			stuGaviInfo[16];        		// 注册平台信息
	int							nPlatformCount;					// stuPlatformInfo个数
	NET_VSP_GAVI_PLATFORM_INFO  stuPlatformInfo[64];			// 接入平台范围信息，不允许修改		
}NET_CFG_VSP_GAVI_INFO;

// 媒体数据加密配置
typedef struct tagNET_MEDIA_ENCRYPT_INFO
{
	DWORD							dwSize;						// 结构体大小
	BOOL							bKeyFrameEncryptEnable;		// 是否开启关键帧数据加密
	unsigned int					nVKUpdateTime;				// 密钥更新周期,单位:分钟,若为0,则表示密钥不更新
	BOOL							bRTSPOverTlsEnable;			// 是否开启RTSP TLS服务
}NET_MEDIA_ENCRYPT_INFO;

// 下载数据加密配置
typedef struct tagNET_DOWNLOAD_ENCRYPT_INFO
{
	DWORD							dwSize;						// 结构体大小
	BOOL							bEncryptEnable;				// 是否开启数据加密	
	char							szEncryptPasswd[256];		// 加密下载数据密码
}NET_DOWNLOAD_ENCRYPT_INFO;

// 国家/地区配置
typedef struct tagNET_CFG_COUNTRY_INFO
{
    DWORD                           dwSize;                     // 结构体大小
    char                            szCountry[3];               // 国家/地区,2字节大写格式,符合ISO 3166规范
    BYTE                            byReserved1[1];             // 字节对齐, 非保留字节
}NET_CFG_COUNTRY_INFO;

// 视频制式
typedef enum tagEM_VIDEO_STANDARD
{
    EM_VIDEO_STANDARD_UNKNOWN,                               
	EM_VIDEO_STANDARD_PAL,      // "PAL"                               
	EM_VIDEO_STANDARD_NTSC,     // "NTSC"
	EM_VIDEO_STANDARD_SECAM,    // "SECAM"
}EM_VIDEO_STANDARD;

// 视频制式配置
typedef struct tagNET_CFG_VIDEOSTANDARD_INFO
{
    DWORD                           dwSize;                     // 结构体大小
    EM_VIDEO_STANDARD               emVideoStandard;            // 视频制式
}NET_CFG_VIDEOSTANDARD_INFO;

// NVR级联控制IPC灯光配置
typedef struct tagNET_CFG_CASCADE_LIGHT_INFO
{
	DWORD							dwSize;
	int								nCount;						// 实际灯光个数
	BOOL							bEnable[16];				// 灯光使能
} NET_CFG_CASCADE_LIGHT_INFO;

// 乐橙简易智能追踪配置
typedef struct tagNET_CFG_LE_SMARTTRACK_INFO
{
	DWORD							dwSize;                     // 结构体大小
	BOOL							bEnable;                    // 乐橙简易智能追踪使能
} NET_CFG_LE_SMARTTRACK_INFO;

// 乐橙镜头遮挡配置
typedef struct tagNET_CFG_LE_LENS_MASK_INFO
{
    DWORD                           dwSize;                         // 结构体大小
    BOOL                            bEnable;                        // 镜头是否处在遮挡位置, TRUE:遮挡位, 无视频; FALSE:正常位置
    int                             nValidLastPositionNum;          // 有效的遮挡前云台位置坐标数组个数
    BYTE                            byReserved[4];                  // 字节对齐
    double                          dbLastPosition[3];              // 遮挡前云台位置坐标数组, 记录遮挡前的云台位置, 恢复时回到该坐标
                                                                    // 第一个元素为水平角度，归一化到-1~1;第二个元素为垂直角度，归一化到-1~1;第三个元素为放大倍数，归一化到0~1。
                                                                    // 数组元素分别对应DH_PTZ_LOCATION_INFO中的pan、tilt、zoom,对应DH_DEVSTATE_PTZ_LOCATION枚举命令
                                                                    // 遮挡使能为FALSE时,无需填坐标
}NET_CFG_LE_LENS_MASK_INFO;

// 注册类型
typedef enum tagNET_EM_REGISTER_TYPE
{
	NET_EM_REGISTER_TYPE_UNKNOWN,                               // 未知
	NET_EM_REGISTER_TYPE_LECHENG,                               // 国内:lecheng
	NET_EM_REGISTER_TYPE_EASY4IP,                               // 国外:easy4ip
}NET_EM_REGISTER_TYPE;

//乐橙云注册配置(NET_EM_CFG_VSP_PAAS)
typedef struct tagNET_CFG_VSP_PAAS_INFO
{
	DWORD							dwSize;						// 结构体大小
	BOOL							bEnable;	                // 接入使能,可用于WEB端获取/设置接入使能
	BOOL							bOnline;				    // 是否在线标识,可用于判断设备是否与平台建立正常连接
	char							szRsServerIP[DH_MAX_IPADDR_EX_LEN];	    // 注册服务器地址
	int							    nRsServerPort;				// 注册服务器端口
	char							szSN[DH_DEV_SERIALNO_LEN];	// 设备序列号
	char							szCheckCode[DH_DEV_SERIALNO_LEN];       // 设备验证码
	NET_EM_REGISTER_TYPE			emType;	                    // 注册类型
}NET_CFG_VSP_PAAS_INFO;

// 人脸认证模式
typedef enum tagNET_EM_FACE_AUTH_MODE
{
	NET_EM_FACE_AUTH_MODE_UNKNOWN = 0,                          // 未知
	NET_EM_FACE_AUTH_MODE_LOCAL,                                // 本地比对认证
	NET_EM_FACE_AUTH_MODE_REMOTE,                               // 远程比对认证
}NET_EM_FACE_AUTH_MODE;

// 卡片认证模式
typedef enum tagNET_EM_CARD_AUTH_MODE
{
	NET_EM_CARD_AUTH_MODE_UNKNOWN = 0,                          // 未知
	NET_EM_CARD_AUTH_MODE_LOCAL,                                // 本地比对认证
	NET_EM_CARD_AUTH_MODE_REMOTE,                               // 远程比对认证
}NET_EM_CARD_AUTH_MODE;

// 二维码认证模式
typedef enum tagNET_EM_QR_CODE_AUTH_MODE
{
	NET_EM_QR_CODE_AUTH_MODE_UNKNOWN = 0,                       // 未知
	NET_EM_QR_CODE_AUTH_MODE_LOCAL,                             // 本地比对认证
	NET_EM_QR_CODE_AUTH_MODE_REMOTE,                            // 远程比对认证
}NET_EM_QR_CODE_AUTH_MODE;

// 所有权限认证模式
typedef enum tagNET_EM_ALL_AUTH_MODE
{
    NET_EM_ALL_AUTH_MODE_UNKNOWN = 0,                       // 未知
    NET_EM_ALL_AUTH_MODE_DISABLE,                           // 无效，当需要单独配置各个权限认证模式时使用
    NET_EM_ALL_AUTH_MODE_LOACL,                             // 本地比对认证
    NET_EM_ALL_AUTH_MODE_REMOTE,                            // 远程比对认证
}NET_EM_ALL_AUTH_MODE;

// 在离线开门认证模式配置,如果是在线模式,设备开门权限由远程鉴权,如果是离线模式,由设备端来鉴权
typedef struct tagNET_CFG_ACCESSCTL_AUTH_MODE
{
	DWORD					       dwSize;				       // 结构体大小
	NET_EM_FACE_AUTH_MODE		   emFaceAuthMode;	           // 人脸认证模式
	NET_EM_CARD_AUTH_MODE          emCardAuthMode;             // 卡片认证模式
	NET_EM_QR_CODE_AUTH_MODE       emQRCodeAuthMode;           // 二维码认证模式
    NET_EM_ALL_AUTH_MODE           emAllAuthMode;              // 所有权限认证模式,当该模式生效时，其他认证模式以此模式为准，当该模式无效时，使用各个权限各自的认证模式
}NET_CFG_ACCESSCTL_AUTH_MODE;

// LED屏显示颜色
typedef enum tagNET_EM_LED_COLOR
{
	NET_EM_LED_COLOR_UNKNOWN = 0,                                  // 未知
	NET_EM_LED_COLOR_GREEN,                                        // 绿色
	NET_EM_LED_COLOR_YELLOW,                                       // 黄色
	NET_EM_LED_COLOR_RED,                                          // 红色
}NET_EM_LED_COLOR;
 
// LED屏显示配置
typedef struct tagNET_CFG_LED_TEXT
{
    DWORD                          dwSize;                     // 结构体大小
	char                           szText[128];                // 显示内容
    NET_EM_LED_COLOR               emColor;                    // 显示颜色
}NET_CFG_LED_TEXT;

// LED屏显示批量配置
typedef struct tagNET_CFG_LED_TEXT_ARRAY
{
    DWORD                          dwSize;                     	// 结构体大小
    char                           szText[128];                	// 显示内容
    NET_EM_LED_COLOR               emColor;                    	// 显示颜色
    int                            nHoldTime;               	// 保持时间(秒)
}NET_CFG_LED_TEXT_ARRAY;

// 一键撤防配置
typedef struct tagNET_CFG_DISABLE_LINKAGE
{
	DWORD                          dwSize;                     // 结构体大小
	BOOL						   bEnable;					   // 撤防联动项功能总开关
}NET_CFG_DISABLE_LINKAGE;

// 网络键盘快速控制配置数组元素信息
typedef struct tagNET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO
{
	int						nChannel;			// 键盘操作对应的视频源通道
	char					szUserName[64];		// 键盘操作对应的用户名
	BYTE                    byReserved[260];    // 保留字节
} NET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO;

// 网络键盘快速控制配置
typedef struct tagNET_CFG_MATRIX_NETKBDFASTCTRL_INFO
{
	DWORD										dwSize;								// 结构体大小
	int											nMatrixNetKBDFastCtrlInfoNum;		// 网络键盘快速控制配置个数
	NET_MATRIX_NETKBDFASTCTRL_ELEMENTS_INFO		stuMatrixNetKBDFastCtrlInfo[128];	// 网络键盘快速控制配置
} NET_CFG_MATRIX_NETKBDFASTCTRL_INFO;

// 保密室代码和名称配置
typedef struct tagNET_CFG_VIDEO_CHANNEL_LABEL_INFO
{
	DWORD					dwSize;						// 结构体大小
	char					szSecurityRoomCode[32];		// 保密室代码
	char					szSecurityRoomName[32];		// 保密室名称
}NET_CFG_VIDEO_CHANNEL_LABEL_INFO;

// 预置点抓图数量配置，对应枚举 NET_EM_CFG_PRESET_SNAP_PICTURE_NUM
typedef struct tagNET_CFG_PRESET_SNAP_PICTURE_NUM
{
	DWORD					dwSize;						// 结构体大小
	int						nNum;						// 抓图数量	
}NET_CFG_PRESET_SNAP_PICTURE_NUM;

// 比对报警规则
typedef enum tagEM_ALARM_RULE_TYPE
{
	EM_ALARM_RULE_UNKNOWN = -1,	// 未知
	EM_ALARM_RULE_NONE,			// 不报警
	EM_ALARM_RULE_SUCCESS,		// 比对成功报警
	EM_ALARM_RULE_FAIL,			// 比对失败报警
} EM_ALARM_RULE_TYPE;

// 联动报警输出通道信息
typedef struct tagNET_ALARM_OUT_CHANNEL_INFO
{
	EM_ALARM_RULE_TYPE		emAlarmRuleType;		// 比对报警规则
	int						nAlarmOutLatch;			// 报警输出延时, 单位秒, 范围1-300
	BYTE                    byReserved[128];        // 保留字节
} NET_ALARM_OUT_CHANNEL_INFO;

// 人脸识别联动报警通道信息
typedef struct tagNET_FACE_RECOGNITION_ALARM_CHANNEL
{
	char						szGroupID[64];			// 人脸库ID
	char						szGroupName[128];		// 人脸库名称
	BOOL						bAlarmOutEnable;		// 人脸识别事件是否联动报警输出
	UINT						nAlarmChannelNum;		// 联动报警输出通道个数
	NET_ALARM_OUT_CHANNEL_INFO	stuAlarmChannel[64];		// 联动报警输出通道信息
	BYTE                    	byReserved[256];        	// 保留字节
} NET_FACE_RECOGNITION_ALARM_CHANNEL;

// 人脸识别联动报警通道配置, 对应枚举 NET_EM_CFG_FACE_RECOGNITION_ALARM
typedef struct tagNET_FACE_RECOGNITION_ALARM_INFO
{
	DWORD								dwSize;						// 结构体大小
	UINT								nFaceReconChannelNum;		// 人脸识别联动报警通道个数
	NET_FACE_RECOGNITION_ALARM_CHANNEL	stuFaceReconChannel[50];		// 人脸识别联动报警通道信息
} NET_FACE_RECOGNITION_ALARM_INFO;
// 逻辑屏显示内容
typedef enum tagNET_EM_SCREEN_SHOW_CONTENTS
{
	EM_TRAFFIC_LATTICE_SCREEN_UNKNOWN = 0,				// 未知
	EM_TRAFFIC_LATTICE_SCREEN_PLATENUMBE,				// 车牌
	EM_TRAFFIC_LATTICE_SCREEN_SYSTIME,					// 系统时间
	EM_TRAFFIC_LATTICE_SCREEN_PARKTIME,					// 停车时长
	EM_TRAFFIC_LATTICE_SCREEN_MASTEROFCAR,				// 车主姓名
	EM_TRAFFIC_LATTICE_SCREEN_USERTYPE,					// 用户类型
	EM_TRAFFIC_LATTICE_SCREEN_REMAINDAY,				// 到期天数
	EM_TRAFFIC_LATTICE_SCREEN_PARKCHARGE,				// 停车费
	EM_TRAFFIC_LATTICE_SCREEN_REMAINSPACE,				// 余位数
	EM_TRAFFIC_LATTICE_SCREEN_SYSDATE,					// 系统日期
	EM_TRAFFIC_LATTICE_SCREEN_PASSICONCIRCLE,			// 车辆通过指示灯(红圆绿圆组合指示灯)
	EM_TRAFFIC_LATTICE_SCREEN_PASSICONARROW,			// 车辆通过指示灯(红叉绿箭组合指示灯)
	EM_TRAFFIC_LATTICE_SCREEN_INTIME,					// 入场时间
	EM_TRAFFIC_LATTICE_SCREEN_OUTTIME,					// 出场时间
	EM_TRAFFIC_LATTICE_SCREEN_REMARKS,					// 备注信息
	EM_TRAFFIC_LATTICE_SCREEN_RESOURCE,					// 资源文件(视频或图片)
	EM_TRAFFIC_LATTICE_SCREEN_CUSTOM,					// 自定义信息
}NET_EM_SCREEN_SHOW_CONTENTS;

// 逻辑屏显示内容
typedef struct tagNET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS
{
	NET_EM_SCREEN_SHOW_CONTENTS	emContents;				// 逻辑屏显示的内容
	BYTE						byReserved1[4];			// 字节对齐
	char						szCustomStr[32];		// 自定义内容，emContents为	EM_TRAFFIC_LATTICE_SCREEN_CUSTOM 时有效
	BYTE						byReserved[32];			// 预留
}NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS;

// 点阵屏显示信息
typedef struct tagNET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO
{
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS	stuContents[64];		// 逻辑屏显示内容
	int											nContentsNum;			// 逻辑屏个数
	BYTE										byReserved[1020];		// 预留
}NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO;

// 点阵屏显示信息配置, 对应枚举 NET_EM_CFG_TRAFFIC_LATTICE_SCREEN
typedef struct tagNET_CFG_TRAFFIC_LATTICE_SCREEN_INFO
{
	DWORD									dwSize;						// 结构体大小
	int										nStatusChangeTime;			// 状态切换间隔，单位：秒,取值10 ~ 60
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuNormal;					// 常态下
	NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuCarPass;					// 过车时
}NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO;

#define NET_MAX_PLATEENABLE_NUM			16      // 最大使能过车车牌播报个数
#define NET_MAX_BROADCAST_ELEMENT_NUM	64      // 最大语音播报元素个数
// 使能过车车牌播报功能枚举
typedef enum tagNET_EM_PLATEENABLE_TYPE
{
	EM_PLATEENABLE_UNKNOWN = 0,					// 未定义
	EM_PLATEENABLE_TIPS,						// 播放欢迎词
	EM_PLATEENABLE_PLATE,						// 播放车牌
	EM_PLATEENABLE_ELEMENT,						// 按照配置元素播报
} NET_EM_PLATEENABLE_TYPE;

// 播报元素类型
typedef enum tagNET_EM_VOICE_BROADCAST_ELEMENT_TYPE
{
	EM_VOICE_BROADCAST_ELEMENT_UNKNOWN = 0,		// 未知
	EM_VOICE_BROADCAST_ELEMENT_PLATENUMBER,		// 车牌号码
	EM_VOICE_BROADCAST_ELEMENT_PARKTIME,		// 停车时间
	EM_VOICE_BROADCAST_ELEMENT_PARKCHARGE,		// 停车收费
	EM_VOICE_BROADCAST_ELEMENT_USERTYPE,		// 用户类型
	EM_VOICE_BROADCAST_ELEMENT_REMAINDAY,		// 剩余天数
	EM_VOICE_BROADCAST_ELEMENT_INTIME,			// 入场时间
	EM_VOICE_BROADCAST_ELEMENT_OUTTIME,			// 出场时间
	EM_VOICE_BROADCAST_ELEMENT_REMARKS,			// 备注信息
	EM_VOICE_BROADCAST_ELEMENT_CUSTOM,			// 自定义,内容为前缀+后缀字符串
}NET_EM_VOICE_BROADCAST_ELEMENT_TYPE;

// 播报元素
typedef struct tagNET_TRAFFIC_VOICE_BROADCAST_ELEMENT
{
	NET_EM_VOICE_BROADCAST_ELEMENT_TYPE	emType;		// 类型
	BYTE						byReserved1[4];		// 字节对齐
	char						szPrefix[512];		// 前缀字符串
	char						szPostfix[512];		// 后缀字符串
	BYTE						byReserved[1024];	// 预留
}NET_TRAFFIC_VOICE_BROADCAST_ELEMENT;

// 智能交通语音播报配置 对应枚举 NET_EM_CFG_TRAFFIC_VOICE_BROADCAST
typedef struct tagNET_CFG_TRAFFIC_VOICE_BROADCAST_INFO
{
	DWORD									dwSize;								// 结构体大小
	int										nEnableCount;                       // 使能播报个数
	NET_EM_PLATEENABLE_TYPE					emEnable[NET_MAX_PLATEENABLE_NUM];  // 使能过车车牌播报,见枚举 NET_EM_PLATEENABLE_TYPE
	char									szNormalCar[MAX_PATH];              // 普通车辆过车播报内容,例如:播报语音文件"欢迎光临.wav"
	char									szTrustCar[MAX_PATH];               // 信任车辆过车播报内容,例如:播报语音文件"欢迎光临.wav"
	char									szSuspiciousCar[MAX_PATH];          // 嫌疑车辆过车播报内容,例如:播报语音文件"非注册车辆.wav"
	NET_TRAFFIC_VOICE_BROADCAST_ELEMENT		stuElement[NET_MAX_BROADCAST_ELEMENT_NUM];	// 播报元素
	int										nElementNum;						// stuElement中有效数据个数
}NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO;

// 抓拍类型
typedef enum tagNET_EM_SNAP_SHOT_TYPE
{
	NET_EM_SNAP_SHOT_TYPE_UNKNOWN = 0,											// 未知
	NET_EM_SNAP_SHOT_TYPE_NEAR,													// 近景
	NET_EM_SNAP_SHOT_TYPE_MEDIUM,												// 中景
	NET_EM_SNAP_SHOT_TYPE_FAR,													// 远景
	NET_EM_SNAP_SHOT_TYPE_FEATURE,												// 车牌特写
}NET_EM_SNAP_SHOT_TYPE;				

// 抓拍间隔模式
typedef enum tagNET_EM_SNAP_SHOT_INTERVAL_MODE
{
	NET_EM_SNAP_SHOT_INTERVAL_UNKNOWN = 0,										// 未知
	NET_EM_SNAP_SHOT_INTERVAL_TIME,												// 按固定时间间隔，该模式下nSingleInterval有效
	NET_EM_SNAP_SHOT_INTERVAL_FRAMEADAPTSPEED,									// 速度自适应帧间隔
	NET_EM_SNAP_SHOT_INTERVAL_FRAME,											// 固定帧间隔
}NET_EM_SNAP_SHOT_INTERVAL_MODE;

// 规则集抓拍参数
typedef struct tagNET_SNAP_SHOT_WITH_RULE_INFO
{
	UINT							nRuleId;
	DWORD							dwRuleType;									// 规则类型，详见dhnetsdk.h中"智能分析事件类型"
	UINT							nSnapShotNum;								// 抓拍图片张数
	NET_EM_SNAP_SHOT_TYPE			emSnapShotType[MAX_SNAP_SHOT_NUM];			// 抓拍图片类型数组
	UINT							nSingleInterval[MAX_SNAP_SHOT_NUM];			// 抓图时间间隔数组,单位秒，数组第一个时间:5~180 默认10， 其余时间(N张抓拍有N-1个间隔时):1~3600 默认20
	NET_EM_SNAP_SHOT_INTERVAL_MODE	emIntervalMode;								// 抓拍间隔模式
	BYTE							byReserved[1024];							// 预留
}NET_SNAP_SHOT_WITH_RULE_INFO;

// 抓拍参数
typedef struct tagNET_SCENE_SNAP_SHOT_WITH_RULE2_INFO
{
	UINT							nPresetID;									// 场景预置点号
	UINT							nRetSnapShotRuleNum;						// stuSnapShotWithRule中有效数据个数
	NET_SNAP_SHOT_WITH_RULE_INFO	stuSnapShotWithRule[32];					// 规则集抓拍参数
	BYTE							byReserved[1024];							// 预留
}NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO;

// 场景抓拍设置 对应枚举 NET_EM_CFG_SCENE_SNAP_SHOT_WITH_RULE2
typedef struct tagNET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO
{
	DWORD									dwSize;								// 结构体大小
	UINT									nMaxRuleNum;						// pstuSnapShotWithRule中用户分配的内存个数
	UINT									nRetRuleNum;						// pstuSnapShotWithRule中实际有效的数据个数
	NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO*	pstuSceneSnapShotWithRule;			// 抓拍参数,由用户分配和释放内存，大小为nMaxRuleNum * sizeof(NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO)
}NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO;

// 门铃类型
typedef enum tagNET_EM_DOORBELL_TYPE
{
	NET_EM_DOORBELL_UNKNOWN = -1,               // 未知
    NET_EM_DOORBELL_UNCONNECTED,                // 未接
	NET_EM_DOORBELL_MECHANICAL,                 // 机械
	NET_EM_DOORBELL_ELECTRONIC,                 // 电子
} NET_EM_DOORBELL_TYPE;

// 外接门铃配置, 对应枚举 NET_EM_CFG_DOORBELL_EXTERNALDOORBELL
typedef struct tagNET_CFG_DOORBELL_EXTERNALDOORBELL
{
    DWORD                               dwSize;             // 结构体大小
    NET_EM_DOORBELL_TYPE                emDoorBellType;     // 门铃类型
    BOOL                                bEnable;            // 外接门铃使能
}NET_CFG_DOORBELL_EXTERNALDOORBELL;

// 安装模式
typedef enum tagEM_MOUNT_MODE
{
    EM_MOUNT_MODE_UNKNOWN,
    EM_MOUNT_MODE_INDOOR,       // 室内
    EM_MOUNT_MODE_OUTDOOR,      // 室外
}EM_MOUNT_MODE;

// Wifi设备安装配置, 对应枚举 NET_EM_CFG_WIFI_INSTALL_PARAM
typedef struct tagNET_CFG_WIFI_INSTALL_PARAM
{
    DWORD                       dwSize;                             // 结构体大小
    char                        szCountry[4];                       // 国家/地区, 符合ISO3166规范
    EM_MOUNT_MODE               emMountMode;                        // 安装模式
    BYTE                        byReserved[4];                     // 字节对齐, 非保留字节
}NET_CFG_WIFI_INSTALL_PARAM;

// 键盘显示器鼠标节点信息
typedef struct tagNET_CFG_KVM_MAIN_NODE_INFO
{
    int                 nLevel;                            // 等级,值越大等级越低，可根据等级来做主节点选择优先级。设备间值不能冲突
    char                szAddress[128];                    // KVM输出节点IP地址
    BYTE                byReserved[128];                   // 保留字节
} NET_CFG_KVM_MAIN_NODE_INFO;

// 键盘显示器鼠标节点配置,对应枚举NET_EM_CFG_KVM_MAIN_NODE
typedef struct tagNET_CFG_KVM_MAIN_NODE
{
    DWORD                      dwSize;                         // 结构体大小
    UINT                       nMainNodeNum;                   // 节点个数
    NET_CFG_KVM_MAIN_NODE_INFO stuMainNodeInfo[1024];          // 键盘显示器鼠标节点信息
} NET_CFG_KVM_MAIN_NODE;

//热键功能名称
typedef enum tagNET_EM_KVM_HOTKEY_FUNCTION_NAME
{
    EM_KVM_HOTKEY_FUNCTION_NAME_UNKNOWN,                // 未知
    EM_KVM_HOTKEY_FUNCTION_NAME_SPLITMENU,              // 分屏菜单调取
    EM_KVM_HOTKEY_FUNCTION_NAME_GETMENU,                // 接管菜单调取
    EM_KVM_HOTKEY_FUNCTION_NAME_PUSHMENU,               // 推送菜单调取
    EM_KVM_HOTKEY_FUNCTION_NAME_BASEINFOMENU            // 基本信息菜单调取
}EM_KVM_HOTKEY_FUNCTION_NAME;

// 键盘显示器鼠标热键信息
typedef struct tagNET_CFG_KVM_HOT_KEY_INFO
{
    int                            nKeyNum;               // 热键元素个数
    int                            szKey[3];              // 热键
    EM_KVM_HOTKEY_FUNCTION_NAME    emFuncName;            // 热键功能名称
    BYTE                           byReserved[128];       // 保留字节
}NET_CFG_KVM_HOT_KEY_INFO;

// 键盘显示器鼠标热键配置,对应枚举NET_EM_CFG_KVM_HOT_KEY
typedef struct tagNET_CFG_KVM_HOT_KEY
{
    DWORD                     dwSize;                           // 结构体大小
    int                       nHotKeyNum;                       // 热键数量
    NET_CFG_KVM_HOT_KEY_INFO  stuHotKeyInfo[64];                // 热键信息
}NET_CFG_KVM_HOT_KEY;

// 键盘鼠标加密配置,对应NET_EM_CFG_KM_TRANS_ENCRYPT
typedef struct tagNET_CFG_KM_TRANS_ENCRYPT
{
    DWORD               dwSize;                         // 结构体大小
    BOOL                bEnable;                        // 鼠标键盘消息加密传输开关； true:使能，false：不使能
}NET_CFG_KM_TRANS_ENCRYPT;

// 热成像机芯维护配置, 对应枚举 NET_EM_CFG_SENSOR_MAINTAIN
typedef struct tagNET_CFG_SENSOR_MAINTAIN
{
    DWORD                       dwSize;                     // 结构体大小
    BOOL                        bEnable;                    // 是否启用维护功能, 必填
    DH_TSECT                    stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];     // 时间段，是一个二维数组，前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段。
}NET_CFG_SENSOR_MAINTAIN;

// 激光测距俯仰角限制, 对应枚举 NET_EM_CFG_TILT_LIMIT 
typedef struct tagNET_CFG_TILT_LIMIT
{
    DWORD                       dwSize;                 // 结构体大小
    int                         nUp;                    // 上俯仰角,精度0.1, 实际值已扩大10倍，范围[0,900]
    int                         nDown;                  // 下俯仰角,精度0.1, 实际值已扩大10倍，范围[-900,0]
    BYTE                        byReserve[4];           // 保留字节，用于字节对齐
}NET_CFG_TILT_LIMIT;

// 门禁人脸识别相关配置 对应枚举 NET_EM_CFG_ACCESS_FACE_RECOGNITION
typedef struct tagNET_CFG_ACS_FACE_RECOGNITION_SCHEME
{
    DWORD                           dwSize;                 // 结构体大小 
    UINT                            nMode;                  // 人脸识别模式; 0：前智能人脸识别, 1：后智能人脸识别, 2：前智能人脸失败后到后智能人脸识别
}NET_CFG_ACS_FACE_RECOGNITION_SCHEME;

//默认组合通道绑定模式
typedef enum tagEM_COMPOSIT_CHANNEL_BIND_MODE
{
    EM_COMPOSIT_CHANNEL_BIND_MODE_UNKNOWN,                        // 未知
    EM_COMPOSIT_CHANNEL_BIND_MODE_AUTOMATIC,                      // 自动
    EM_COMPOSIT_CHANNEL_BIND_MODE_SEMIAUTOMATIC,                  // 半自动
    EM_COMPOSIT_CHANNEL_BIND_MODE_MANUAL,                         // 手动
} EM_COMPOSIT_CHANNEL_BIND_MODE; 

// 拉流使能
typedef enum tagEM_CAN_START_STREAM
{
    EM_CAN_START_STREAM_UNKNOWN = -1,                                               // 未知
    EM_CAN_START_STREAM_OFF,                                                        // 不拉流
    EM_CAN_START_STREAM_ON,                                                         // 拉流
} EM_CAN_START_STREAM;

// 录像使能
typedef enum tagEM_IS_RECORD
{                              
    EM_IS_RECORD_UNKNOWN,                                                           // 未知
    EM_IS_RECORD_ON,                                                                // 录像
    EM_IS_RECORD_OFF,                                                               // 不录像
} EM_IS_RECORD;

// 录播默认配置
typedef struct tagNET_CFG_COURSE_RECORD_DEFAULT_CONFIG
{
    DWORD                                     dwSize;                               // 结构体大小 
    UINT                                      nCompositChannelMode;                 // 组合通道默认模式; 0: 无效, 1: 电影模式, 2: 常态模式, 3: 精品模式, 小于0: 自定义模式
    int                                       nCanStartStreamNum;                   // 能否被拉流逻辑通道数
    int                                       nIsRecordNum;                         // 是否要录像逻辑通道号数
    EM_CAN_START_STREAM                       emCanStartStream[64];                 // 能否被拉流
    EM_IS_RECORD                              emIsRecord[64];                       // 是否要录像
    EM_COMPOSIT_CHANNEL_BIND_MODE             emCompositChannelBindMode;            // 默认组合通道绑定模式
    BYTE                                      byReserved[4];                        // 保留字节
}NET_CFG_COURSE_RECORD_DEFAULT_CONFIG;

// 梯控主机全局配置
typedef struct tagNET_CFG_LIFTCONTROL_OPTION
{
	DWORD										dwSize;			// 结构体大小
	BOOL										bEnable;		// 使能情况，TRUE：使能；FALSE：未使能
}NET_CFG_LIFTCONTROL_OPTION;

// 配置操作类型
typedef enum tagNET_EM_CFG_OPERATE_TYPE
{
    NET_EM_CFG_SNAP_MODE,                   // 抓图模式配置,对应结构体 NET_SNAP_MODE
    NET_EM_CFG_DEV_CAR_COACH,               // 铁路记录配置, 对应结构体 NET_DEV_CAR_COACH_INFO
	NET_EM_CFG_YUEQING_SUPPLYLIGHTING,		// 乐清外接灯光配置, 对应结构体 NET_YUEQING_SUPPLYLIGHTING_INFO
	NET_EM_CFG_MEDIA_GLOBAL,                // 媒体组件全局配置, 对应结构体 NET_MEDIA_GLOBAL_INFO
	NET_EM_CFG_PARKINGSPACECELL_STATUS,		// 车位设置(专有车位和普通车位的设置), 对应结构体 NET_PARKINGSPACECELL_STATUS_INFO
	NET_EM_CFG_PARKINGSPACELIGHT_STATE,		// 车位状态对应的车位指示灯, 对应结构体 NET_PARKINGSPACELIGHT_STATE_INFO
	NET_EM_CFG_COAXIAL_LIGHT,				// 白光灯视频通道配置, 对应结构体 NET_CFG_COAXIAL_LIGHT_INFO
    NET_EM_CFG_VIDEO_OUT,				    // 	视频输出配置, 对应结构体 NET_CFG_VIDEO_OUT_INFO
	
	NET_EM_CFG_MEDIA_ENCRYPT = 9,			// 媒体数据加密配置,对应结构体 NET_MEDIA_ENCRYPT_INFO,与通道不相关,通道号需要填成-1
    NET_EM_CFG_COUNTRY,                     // 国家/地区配置, 对应结构体 NET_CFG_COUNTRY_INFO,与通道不相关,通道号需要填成-1
    NET_EM_CFG_VIDEOSTANDARD,               // 视频制式配置, 对应结构体 NET_CFG_VIDEOSTANDARD_INFO,与通道不相关,通道号需要填成-1, 目前设备不支持配置SECAM制式
	NET_EM_CFG_SERIAL_PUSH_LOG,				// 串口服务器推送日志配置， 对应结构体 NET_CFG_SERIALPUSHLOG_INFO，与通道不相关需要填成-1
	NET_EM_CFG_PRESET_SNAP_PICTURE_NUM,		// 预置点抓拍图片数量配置,对应结构体 NET_CFG_PRESET_SNAP_PICTURE_NUM
	NET_EM_CFG_DOWNLOAD_ENCRYPT,			// 下载数据加密配置, 对应结构体 NET_DOWNLOAD_ENCRYPT_INFO,与通道不相关,通道号需要填成-1
	NET_EM_CFG_LIFT_CONTROL_OPTION,			// 梯控功能全局配置，对应结构体 NET_CFG_LIFTCONTROL_OPTION,与通道不相关,通道号需要填成-1

	/*********OSD叠加相关配置*************************************************************************************************/
	NET_EM_CFG_CHANNELTITLE = 1000,         // 叠加通道标题属性配置，对应结构体 NET_OSD_CHANNEL_TITLE,其中结构体中的emOsdBlendType为必填参数
	NET_EM_CFG_TIMETITLE,               	// 叠加时间标题属性配置，对应结构体 NET_OSD_TIME_TITLE,其中结构体中的emOsdBlendType为必填参数
	NET_EM_CFG_CUSTOMTITLE,             	// 叠加自定义标题属性配置，对应结构体 NET_OSD_CUSTOM_TITLE,其中结构体中的stuCustomTitle.emOsdBlendType为必填参数
	NET_EM_CFG_CUSTOMTITLETEXTALIGN,    	// 叠加自定义标题对齐方式属性配置，对应结构体 NET_OSD_CUSTOM_TITLE_TEXT_ALIGN
	NET_EM_CFG_OSDCOMMINFO,             	// 叠加公共属性配置，对应结构体 NET_OSD_COMM_INFO
	NET_EM_CFG_OSD_PTZZOOM,					// 变倍叠加配置，对应结构体 NET_OSD_PTZZOOM_INFO
	NET_EM_CFG_GPSTITLE,					// 叠加GPS标题显示配置，对应结构体 NET_OSD_GPS_TITLE
	NET_EM_CFG_OSD_NUMBERSTATPLAN,			// 人数统计计划叠加OSD配置, 支持NumberStatPlan算法大类时(球机)使用，对应结构体NET_OSD_NUMBER_STATPLAN
    NET_EM_CFG_GPSSTARNUM_OSD,              // GPS搜星数OSD配置, 车载定制需求, 对应结构体 NET_CFG_GPSSTARNUM_OSD_INFO
	NET_EM_CFG_PICTURETITLE,				// 图片标题,对应结构体 NET_OSD_PICTURE_TITLE
	NET_EM_CFG_OSD_FACEFLOWSTAT,			// 人脸数量统计OSD配置，对应结构体 NET_OSD_FACEFLOWSTAT_INFO 

    NET_EM_CFG_PTZ_PRESET,		            // 预置点信息叠加,对应结构体 NET_OSD_CFG_PTZ_PRESET
    NET_EM_CFG_PTZ_PATTERN,		            // 显示巡迹百分比叠加配置,对应结构体 NET_OSD_CFG_PTZ_PATTERN
    NET_EM_CFG_PTZ_RS485_DETECT,		    // 显示RS485检测结果的叠加配置,对应结构体 NET_OSD_CFG_PTZ_RS485_DETECT
    NET_EM_CFG_PTZ_COORDINATES,		        // 显示云台坐标的叠加配置,对应结构体 NET_OSD_CFG_PTZ_COORDINATES
    NET_EM_CFG_PTZ_DIRECTION,		        // 显示云台方向的叠加配置,对应结构体 NET_OSD_CFG_PTZ_DIRECTION
    NET_EM_CFG_TEMPERATURE,		            // 显示环境温度的叠加配置,对应结构体 NET_OSD_CFG_TEMPERATURE
    NET_EM_CFG_COVERS,		                // 区域覆盖,对应结构体 NET_OSD_CFG_COVERS
    NET_EM_CFG_USER_DEF_TITLE,		        // 用户自定义OSD标题，对应结构体 NET_OSD_USER_DEF_TITLE

	/*********encode 相关配置*************************************************************************************************/
	NET_EM_CFG_ENCODE_VIDEO = 1100,			// 编码视频格式属性配置，对应结构体 NET_ENCODE_VIDEO_INFO
	NET_EM_CFG_ENCODE_VIDEO_PACK,			// 编码视频格式打包模式配置，对应结构体 NET_ENCODE_VIDEO_PACK_INFO
	NET_EM_CFG_ENCODE_VIDEO_SVC,			// 编码视频格式SVC配置，对应结构体 NET_ENCODE_VIDEO_SVC_INFO
	NET_EM_CFG_ENCODE_VIDEO_PROFILE,		// 编码视频格式profile配置，对应结构体 NET_ENCODE_VIDEO_PROFILE_INFO
	NET_EM_CFG_ENCODE_AUDIO_COMPRESSION,	// 编码音频压缩格式配置，对应结构体 NET_ENCODE_AUDIO_COMPRESSION_INFO
	NET_EM_CFG_ENCODE_AUDIO_INFO,			// 编码音频格式配置，对应结构体 NET_ENCODE_AUDIO_INFO
	NET_EM_CFG_ENCODE_SNAP_INFO,			// 编码抓图配置，对应结构体 NET_ENCODE_SNAP_INFO
	NET_EM_CFG_ENCODE_SNAPTIME, 			// 编码抓图时间相关配置，对应结构体 NET_ENCODE_SNAP_TIME_INFO
	NET_EM_CFG_ENCODE_CHANNELTITLE,			// 通道名称配置，对应结构体 NET_ENCODE_CHANNELTITLE_INFO
		
	/**********音频相关配置***************************************************************************************************/
	NET_EM_CFG_AUDIOIN_SOURCE = 1200,		// 音频输入类型配置，对应结构体 NET_ENCODE_AUDIO_SOURCE_INFO
	NET_EM_CFG_AUDIOIN_DENOISE,				// 音频降噪配置，对应结构体 NET_AUDIOIN_DENOISE_INFO
	NET_EM_CFG_AUDIOIN_VOLUME,				// 音频输入音量配置，对应结构体 NET_AUDIOIN_VOLUME_INFO
	NET_EM_CFG_AUDIOOUT_VOLUME,				// 音频输出音量配置，对应结构体 NET_AUDIOOUT_VOLUME_INFO
	
	/**********videoin 相关配置***********************************************************************************************/
	NET_EM_CFG_VIDEOIN_SWITCHMODE = 1300,	// 切换模式配置，对应结构体 NET_VIDEOIN_SWITCH_MODE_INFO
	NET_EM_CFG_VIDEOIN_COLOR,				// 视频输入颜色配置，对应结构体 NET_VIDEOIN_COLOR_INFO			
	NET_EM_CFG_VIDEOIN_IMAGE_OPT,			// 图像属性配置，对应结构体 NET_VIDEOIN_IMAGE_INFO
	NET_EM_CFG_VIDEOIN_STABLE,				// 图像防抖配置，对应结构体 NET_VIDEOIN_STABLE_INFO
	NET_EM_CFG_VIDEOIN_IRISAUTO,			// 自动光圈配置，对应结构体 NET_VIDEOIN_IRISAUTO_INFO
	NET_EM_CFG_VIDEOIN_IMAGEENHANCEMENT,	// 图像增强配置，对应结构体 NET_VIDEOIN_IMAGEENHANCEMENT_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_NORMAL,		// 曝光通用属性配置，对应结构体 NET_VIDEOIN_EXPOSURE_NORMAL_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_OTHER,		// 其他曝光属性配置，对应结构体 NET_VIDEOIN_EXPOSURE_OTHER_INFO
	NET_EM_CFG_VIDEOIN_EXPOSURE_SHUTTER,	// 曝光快门配置，对应结构体 NET_VIDEOIN_EXPOSURE_SHUTTER_INFO
	NET_EM_CFG_VIDEOIN_BACKLIGHT,			// 背光配置，对应结构体 NET_VIDEOIN_BACKLIGHT_INFO
	NET_EM_CFG_VIDEOIN_INTENSITY,			// 场景自适应对比度强度配置，对应结构体 NET_VIDEOIN_INTENSITY_INFO
	NET_EM_CFG_VIDEOIN_LIGHTING,			// 补光灯配置，对应结构体 NET_VIDEOIN_LIGHTING_INFO
	NET_EM_CFG_VIDEOIN_DEFOG,				// 透雾配置，对应结构体 NET_VIDEOIN_DEFOG_INFO
	NET_EM_CFG_VIDEOIN_FOCUSMODE,			// 聚焦模式配置，对应结构体 NET_VIDEOIN_FOCUSMODE_INFO
	NET_EM_CFG_VIDEOIN_FOCUSVALUE,			// 聚焦信息配置，对应结构体 NET_VIDEOIN_FOCUSVALUE_INFO
	NET_EM_CFG_VIDEOIN_WHITEBALANCE,		// 白平衡配置，对应结构体 NET_VIDEOIN_WHITEBALANCE_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT,			// 日夜模式配置，对应结构体 NET_VIDEOIN_DAYNIGHT_INFO
	NET_EM_CFG_VIDEOIN_DAYNIGHT_ICR,		// 日夜模式ICR切换类型配置，对应结构体 NET_VIDEOIN_DAYNIGHT_ICR_INFO
	NET_EM_CFG_VIDEOIN_SHARPNESS,			// 锐度配置，对应结构体 NET_VIDEOIN_SHARPNESS_INFO
	NET_EM_CFG_VIDEOIN_COMM_DENOISE,		// 通用降噪配置，对应结构体 NET_VIDEOIN_DENOISE_INFO
	NET_EM_CFG_VIDEOIN_3D_DENOISE,			// 3D 降噪配置，对应结构体 NET_VIDEOIN_3D_DENOISE_INFO
	NET_EM_CFG_VIDEOIN_FOCUSEX,				// 聚焦扩展配置，对应结构体 NET_VIDEOIN_FOCUS_INFO_EX
    NET_EM_CFG_VIDEOIN_LIGHTINGEX,			// 补光灯配置的扩展，对应结构体 NET_VIDEOIN_LIGHTINGEX_INFO
    

	/***********庭审相关配置*****************************************************************************************/
	NET_EM_CFG_ENCODE_PLAN = 1400,			// 刻录光盘编码计划, 对应结构体 NET_ENCODE_PLAN_INFO
	NET_EM_CFG_COMPOSE_CHANNEL,				// 合成通道配置, 对应结构体NET_COMPOSE_CHANNEL_INFO
	
	/**********报警网关相关配置**************************************************************************************/
    NET_EM_CFG_ALARM_SOUND = 1500,			// 报警网关语音配置, 对应结构体 NET_ALARM_SOUND_INFO 
	NET_EM_CFG_LOCAL_EXT_ALARM = 1501,		// 报警盒子配置,对应结构体 NET_LOCAL_EXT_ALARM_INFO,通道无关
	NET_EM_CFG_REMOTE_ALARM_BELL = 1502,	 // 前端相机警号配置, 对应结构体 NET_CFG_REMOTE_ALARM_BELL_INFO
	NET_EM_CFG_FIRE_WARNINGMODE = 1503,		 // 火灾预警模式, 对应结构体 NET_FIREWARNING_MODE_INFO
	NET_EM_CFG_FIRE_WARNING = 1504,			 // 火灾预警配置(与火灾预警模式配置配合使用), 对应的结构体 NET_FIRE_WARNING_INFO
    NET_EM_CFG_HOT_COLD_SPOT_WARNING = 1505, // 热冷点报警配置, 对应的结构体 NET_HOT_COLD_SPOT_WARNING_INFO
	NET_EM_CFG_COAXIAL_ALARMLOCAL,			 // CVI 外部报警配置，对应结构体 NET_COAXIAL_ALARMLOCAL_INFO

    /**********网络应用相关配置**************************************************************************************/
    NET_EM_CFG_ACCESS_POINT = 1600,			// 用于WiFi服务端配置(热点功能), 对应结构体 NET_NETAPP_ACCESSPOINT
	NET_EM_CFG_LDAP,						// LDAP配置, 对应结构体 NET_NETAPP_LDAP
	NET_EM_CFG_SYSLOG,						// Syslog协议配置, 对应结构体 NET_NETAPP_SYSLOG	
    NET_EM_CFG_NETAUTOADAPTTRANSIT,         // 网络自适应传输配置,对应结构体NET_NETAUTOADAPTTRANSIT
	NET_EM_CFG_WIRELESS,					// 蜂窝网络(即俗称的3G/4G网络)的设置, 对应结构体 NET_NETAPP_WIRELESS

	/**************安全基线需求**************************************************************************************/
	NET_EM_CFG_NAS			= 1700,			// NAS 配置, 对应结构体 NET_NAS_INFO   
	NET_EM_CFG_PPPOE,						// PPPOE 配置，对应结构体 NET_PPPOE_INFO   
	NET_EM_CFG_EMAIL,						// Email 配置，对应结构体 NET_EMAIL_INFO  
	NET_EM_CFG_DDNS,						// DDNS 配置，对应结构体 NET_DDNS_INFO  

	/**************SCADA配置需求**************************************************************************************/
	NET_EM_CFG_SCADA_PROTOCOLS_MANAGER  = 1800,		// 协议管理配置，对应结构体 NET_SCADA_PROTOCOLS_MANAGER
	NET_EM_CFG_SCADA_DEVICEINFO_CFG,				// 设备信息配置，对应结构体 NET_SCADA_DEVICEINFO_CFG
	NET_EM_CFG_SCADA_CONTROLLER_SITE,				// 控制器配置，对应结构体 NET_CFG_SCADA_CONTROLLER_SITE_INFO

	/**************NetApp配置需求*************************************************************************************/
	NET_EM_CFG_NETAPP_LINK_LAYER_VPN = 1900,		// 链路层VPN设置,对应结构体 NET_NETAPP_LINK_LAYER_VPN_CFG
	NET_EM_CFG_NETAPP_SSHD,							// SSH服务端配置,对应结构体 NET_NETAPP_SSHD_CFG
    NET_EM_CFG_NETAPP_COMMUNICATION_LIST,			// 通讯录配置, 对应结构体 NET_NETAPP_COMMUNICATION_LIST_CFG, 与通道不相关,通道号需要填成-1  

	/**************第三方平台接入***********************************************************************************/
	NET_EM_CFG_VSP_CHINA_TOWER = 2000,				// (中国铁塔平台接入)安徽治超平台接入配置,对应结构体 NET_VSP_CHINA_TOWER 
    NET_EM_CFG_VSP_SHDXJT = 2001,				    // 中国电信手机看店接入配置,对应结构体 NET_VSP_SHDXJT 
	NET_EM_CFG_VSP_CONSUME,							// 消费机配置，对应结构体 NET_CFG_VSP_CONSUME，通道无关，通道号需要填成-1

	/**********智能相关配置*******************************************************************************************/
	NET_EM_CFG_STEREO_CALIBRATE = 2100,				// 双目标定结果, 对应结构体NET_STEREO_CALIBRATE_INFO
	NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTISENSOR,	// 多目相机标定配置CalibrateMatrix(MultiSensor), 对应的结构体 NET_MULTI_SENSOR_INFO
	NET_EM_CFG_CROWDDISTRIMAP_CALIBRATE,			// 人群分布图标定配置, 对应的结构体 NET_CROWDDISTRIMAP_CALIBRATE_INFO
	NET_EM_CFG_TRAFFIC_NOPASSING,					// 交通禁行配置, 对应的结构体 NET_TRAFFIC_NOPASSING_INFO
    NET_EM_CFG_FIGHT_CALIBRATE,                     // 打架标定配置, 对应的结构体 NET_FIGHT_CALIBRATE_INFO
	NET_EM_CFG_FACE_RECOGNITION_ALARM,				// 人脸识别联动报警通道配置, 对应结构体 NET_FACE_RECOGNITION_ALARM_INFO
	NET_EM_CFG_STEREO_CALIBRATEMATRIX_MULTIMODE,	// 灵瞳相机的标定方式 CalibrateMatrix(MultiMode), 对应的结构体 NET_CALIBRATEMATRIX_MULTIMODE_INFO
	NET_EM_CFG_AUTO_SNAP_SCHEDULE,                  // 智能养殖定时抓图配置, 对应结构体 NET_CFG_AUTO_SNAP_SCHEDULE_INFO
	
	/**********雷达配置***********************************************************************************************/
	NET_EM_CFG_RADAR            = 2200,				// 雷达配置，对应结构体 DEV_RADAR_CONFIG
	
	/**********视频对讲电话通用配置***********************************************************************************/
	NET_EM_CFG_VTH_PASSWORD			= 2300,			// 视频对讲电话通用配置,对应结构体 NET_CFG_VTH_PASSWORD_INFO
    NET_EM_CFG_REGISTAR         	= 2301,  		// 注册服务器配置,对应结构体 NET_CFG_REGISTAR_INFO
    NET_EM_CFG_SIP              	= 2302,			// sip配置, 对应结构体 NET_CFG_SIPSERVER_INFO
	NET_EM_CFG_DEVICE_LOGIN_INFO	= 2303,			// 主门口机登陆从门口机配置 NET_CFG_DEVICE_LOGIN_INFO
	
	/**********镜头前遮挡盖配置***************************************************************************************/
	NET_EM_CFG_AELENSMASK       	= 2400,     	//镜头前遮挡盖配置，对应结构体NET_CFG_AELENSMASK_INFO
	NET_EM_CFG_ULTRASONIC       	= 2500,     	//超声波配置，对应结构体NET_CFG_ULTRASONIC_INFO 
	
    /**********报警主机相关配置***************************************************************************************/
    NET_EM_CFG_ARMSCHEDULE      	= 2600,     	// 报警计划配置，对应结构体 NET_CFG_ARMSCHEDULE_INFO
    NET_EM_CFG_CID_REPORT       	= 2601,     	// CID联动配置, 对应结构体NET_CFG_CID_REPORT_INFO
	NET_EM_CFG_VSP_HONEYWELL    	= 2602,			// 霍尼服务器配置，对应结构体NET_CFG_VSP_HONEYWELL_INFO
	NET_EM_CFG_KBUSER_PASSWORD		= 2603,			// 报警主机用户权限，键盘密码配置，对应结构体 NET_CFG_KBUSER_PASSWORD	

	/**********录像抓图功能相关配置***********************************************************************************/
	NET_EM_CFG_RECORDEXTRA			= 3610,			// 录像辅码流录像配置, 对应结构体 NET_CFG_RECORDEXTRA_INFO
	NET_EM_CFG_AUTO_RECORDBACKUP_RESTORE = 3611,  	// 自动录像回传配置, 对应结构体 NET_CFG_AUTORECORDBACKUPRESTORE_INFO
	NET_EM_CFG_FACESNAPSHOT			= 3612,			// IPC智能人脸抓拍配置 对应结构体 NET_CFG_FACESNAPSHOT_INFO

	/**********视频诊断相关配置***************************************************************************************/
	NET_EM_VIDEODIAGNOSIS_PROJECT 	= 3700,			// 视频诊断计划配置, 对应结构体 NET_VIDEODIAGNOSIS_PROJECT_INFO
	NET_EM_CFG_VIDEO_DIAGNOSIS_PROJECT_MONTH  = 3701,// 按月的视频诊断计划配置, 对应结构体 NET_CFG_VIDEODIAGNOSIS_PROJECT_MONTH_INFO,对应通道为-1
	
	/***********车载相关配置******************************************************************************************/
	NET_EM_CFG_POSITIONREPORTPOLICY	= 3800,		// 车载GPS位置信息上报策略配置, 对应结构体 NET_CFG_POSITIONREPORTPOLICY_INFO
	NET_EM_CFG_VEHICLE_WORKTIMESCHEDULE,		// 车载工作计划配置，对应结构体 NET_CFG_VEHICLE_WORKTIMESCHEDULE_INFO
	NET_EM_CFG_VEHICLE_LOAD,					// 荷载人数配置, 对应结构体 NET_CFG_VEHICLE_LOAD_INFO
	NET_EM_CFG_TICKETPRINT,						// 公交打印票价, 对应结构体 NET_CFG_TICKETPRINT_INFO
	NET_EM_CFG_VEHICLEAUTOMAIN,					// ACC延时关机时间, 对应结构体 NET_CFG_VEHICLEAUTOMAIN_INFO
	NET_EM_CFG_VEHICLENETSERVER,				// 车载网络服务配置（印度BRT项目）, 对应结构体 NET_CFG_VEHICLENETSERVER_INFO
	NET_EM_CFG_IMSIBIND,						// 车载布控球IMSI绑定配置, 对应结构体 NET_CFG_IMSIBIND_INFO
	NET_EM_CFG_VEHICLE_MAINTAINCE,				// 车载人员维护设置,对应结构体 NET_CFG_VEHICLE_MAINTAINCE_INFO
	
    /***********门禁相关配置******************************************************************************************/
    NET_EM_CFG_ACCESSCTL_BLACKLIST 		= 3900,      	// 门禁黑名单报警配置，对应结构体 NET_CFG_ACCESSCTL_BLACKLIST
    NET_EM_CFG_ACCESSCTL_BLACKLIST_LINK = 3901, 		// 门禁黑名单报警联动配置,对应结构体 NET_CFG_ALARM_MSG_HANDLE
    NET_EM_CFG_ACCESSCTL_SPECIALDAY_GROUP 	  = 3902,	// 门禁节假日组配置, 对应结构体 NET_CFG_ACCESSCTL_SPECIALDAY_GROUP_INFO
    NET_EM_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE = 3903, 	// 门禁节假日计划配置, 对应结构体 NET_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE_INFO
	NET_EM_CFG_ACCESSCTL_AUTH_MODE 		= 3904,         // 在离线开门认证模式配置，对应结构体NET_CFG_ACCESSCTL_AUTH_MODE
    NET_EM_CFG_ACS_FACE_RECOGNITION_SCHEME = 3905,     //  门禁人脸识别相关配置,对应结构体 NET_CFG_ACS_FACE_RECOGNITION_SCHEME
	
    /***********定制配置************************************************************************************************/
    NET_EM_CFG_SERIALNOWHITETABLE			= 4000,    	// 前端序列号白名单下发至NVR 配置, 对应结构体 NET_CFG_SERIALNOWHITETABLE_INFO
    NET_EM_CFG_LXSJ_WXJJ					= 4001,    	// 灵信视觉平台无锡交警定制配置, 对应结构体 NET_CFG_LXSJ_WXJJ_INFO
	NET_EM_CFG_SENSOR_ALARM_GLOBAL			= 4002,		// 传感器报警全局配置(IPC定制使用) 对应结构体 NET_CFG_SENSOR_ALARM_GLOBAL_INFO
	NET_EM_CFG_SENSOR_ALARM					= 4003,		// 传感器报警配置(IPC定制使用) 对应结构体 NET_CFG_SENSOR_ALARM_INFO
	NET_EM_CFG_VSP_LXSJ						= 4004,		// 灵信视觉平台接入配置 对应结构体 NET_CFG_VSP_LXSJ_INFO，配置较大，建议内存new出来
	NET_EM_CFG_TIMINGCAPTURE				= 4005,		// 定时抓拍配置(湖南河道保洁定制) 对应结构体 NET_CFG_TIMINGCAPTURE_INFO
	NET_EM_CFG_WATER_MONITOR_TITLE			= 4006,		// 智慧水利叠加OSD配置 对应结构体 NET_CFG_WATER_MONITOR_TITLE_INFO
	NET_EM_CFG_ATTENDANCE_MODEL_INFO		= 4007,		// 考勤模式信息（定制），对应结构体 NET_CFG_ATTENDANCE_MODEL_INFO，通道无关，通道号填-1
    NET_EM_CFG_KT_RTSP_FLAG                 = 4008,		// KT的定制的RTSP的使能配置, 对应结构体 NET_CFG_KT_RTSP_FLAG_INFO ,与通道不相关,通道号需要填成-1   
    NET_EM_CFG_RTSP_ABORT_LIST              = 4009,		// 获取RTSP断线后存储到设备本地的录像列表(只有获取，没有设置), 对应结构体 NET_CFG_RTSP_ABORT_LIST_INFO ,与通道不相关,通道号需要填成-1 
    NET_EM_CFG_FILE_HOLD_DAYS               = 4010,		// 录像保存天数配置, 对应结构体NET_CFG_FILE_HOLD_DAYS_INFO
    NET_EM_CFG_ACCESS_FUNCTION              = 4011,     // 接入功能配置(定制), 对应结构体 NET_CFG_ACCESS_FUNCTION_INFO, 与通道不相关,通道号需要填成-1
    							
	/***********云操作配置************************************************************************************************/
    NET_EM_CFG_CLOUDUPLOADTIME		= 5000,		// 配置录像上传到云服务器的时间段, 对应结构体 NET_CFG_CLOUDUPLOADTIME_INFO

	/***********雷球联动配置************************************************************************************************/
	//在调用 CLIENT_SetConfig 时,restart字段无效
	NET_EM_CFG_RADAR_MAPPARA        = 6000,		// 雷达地图参数配置, 对应结构体 NET_CFG_RADAR_MAPPARA_INFO
	NET_EM_CFG_RADAR_CALIBRATION    = 6001,		// 雷球校准配置, 对应结构体 NET_CFG_RADAR_CALIBRATION_INFO
	NET_EM_CFG_RADAR_LINKSD         = 6002,     // 雷达联动球机使能配置, 对应结构体 NET_CFG_RADAR_LINKSD_INFO
	NET_EM_CFG_RADAR_RULELINE       = 6003,     // 雷达规则线配置, 对应结构体 NET_CFG_RADAR_RULELINE_INFO
	NET_EM_CFG_RADAR_ANALYSERULE    = 6004,     // 雷达报警联动配置, 对应结构体 NET_CFG_RADAR_ANALYSERULE_INFO
	NET_EM_CFG_RADAR_TRACKGLOBALCONFIG = 6005,  // 雷达跟踪全局配置, 对应结构体 NET_CFG_RADAR_TRACKGLOBALCONFIG_INFO
	NET_EM_CFG_RADAR_RADARPARA		= 6006,		// 雷达功能设置, 对应结构体 NET_CFG_RADAR_RADARPARA_INFO
	NET_EM_CFG_RADAR_REMOTESDLINK	= 6007,		// 雷达远程球机联动使能配置, 对应结构体 NET_CFG_RADAR_REMOTESDLINK_INFO
	NET_EM_CFG_RADAR_RADARLINKDEVICE= 6008,		// 雷达远程联动球机配置, 对应结构体 NET_CFG_RADAR_RADARLINKDEVICE_INFO
	NET_EM_CFG_RADAR_MAPOSDPARA		= 6009,		// 雷达地图OSD叠加配置, 对应结构体 NET_CFG_RADAR_MAPOSDPARA_INFO

	/***********云台相关配置************************************************************************************************/
	NET_EM_CFG_PTZ_SPEED			= 7000,						// 云台速度配置 对应结构体 NET_CFG_PTZ_SPEED
	NET_EM_CFG_PTZ_HORIZONTAL_ROTATION_GROUP_SCAN	= 7001,		// 云台水平旋转组扫描 对应结构体 NET_CFG_HORIZONTAL_ROTATION_GROUP_SCAN_INFO 
	NET_EM_CFG_AUTOSCAN				= 7002,						// 自动线扫设置 对应结构体 NET_CFG_AUTOSCAN_INFO 

	/***********乐橙摄像头定制配置************************************************************************************************/
	NET_EM_CFG_CASCADE_LIGHT		= 8000,		// NVR级联控制IPC灯光, 对应结构体 NET_CFG_CASCADE_LIGHT_INFO
    NET_EM_CFG_LE_SMARTTRACK        = 8001,     // 乐橙简易智能追踪, 对应结构体 NET_CFG_LE_SMARTTRACK_INFO
    NET_EM_CFG_LE_LENS_MASK         = 8002,     // 乐橙镜头遮挡配置, 对应结构体 NET_CFG_LE_LENS_MASK_INFO

	/***********第三方配置************************************************************************************************/
	NET_EM_CFG_VSP_PAAS    			= 9000,		// 乐橙云注册配置修改, 对应结构体 NET_CFG_VSP_PAAS_INFO
	NET_EM_CFG_VSP_GAYS_SERVER		= 9001,		// 公安一所平台接入配置(国标服务端),对应结构体 NET_CFG_VSP_GAYS_SERVER_INFO,对应通道为-1
	NET_EM_CFG_VSP_CO_SIGN_SERVER   = 9002,		// 协同签名服务器配置,对应结构体NET_CFG_VSP_CO_SIGN_SERVER_INFO,对应通道为-1
    NET_EM_CFG_VSP_GAVI             = 9003,		// 公安视频图像信息应用系统接入配置,对应结构体NET_CFG_VSP_GAVI_INFO,对应通道为-1

	/***********道闸配置**************************************************************************************************/
	NET_EM_CFG_TRAFFICSTROBE 		= 9100,		// 道闸配置, 对应结构体 NET_CFG_TRAFFICSTROBE_INFO

	/***********LED屏配置************************************************************************************************/
	NET_EM_CFG_LED_TEXT  			= 9200,		// LED屏显示配置, 对应结构体 NET_CFG_LED_TEXT
    NET_EM_CFG_LED_TEXT_ARRAY  		= 9201,		// LED屏显示批量配置, 对应结构体 NET_CFG_LED_TEXT_ARRAY

	/***********布撤防配置************************************************************************************************/
	NET_EM_CFG_DISABLE_LINKAGE 		= 9300,		// 一键撤防配置,对应结构体 NET_CFG_DISABLE_LINKAGE, 与通道不相关,通道号需要填成-1

	/***********矩阵相关配置************************************************************************************************/
	NET_EM_CFG_MATRIX_NETKBDFASTCTRL = 9400,	// 网络键盘快速控制配置, 对应结构体 NET_CFG_MATRIX_NETKBDFASTCTRL_INFO

	/***********Vedio相关配置************************************************************************************************/
	NET_EM_CFG_VIDEO_CHANNEL_LABEL = 9600,	// 存放保密室代码和名称， 对应结构体 NET_CFG_VIDEO_CHANNEL_LABEL_INFO
    NET_EM_CFG_VIDEO_IMAGE_CTRL = 9601,		// 图像旋转设置能力配置 ,对应结构体 NET_EM_CFG_VIDEO_IMAGE_CTRL_INFO

	/***********Traffic相关配置***************************************************************************************************/
	NET_EM_CFG_TRAFFIC_LATTICE_SCREEN = 10000,	// 点阵屏显示信息配置, 对应结构体 NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO
	NET_EM_CFG_TRAFFIC_VOICE_BROADCAST = 10001,	// 智能交通语音播报配置， 对应结构体 NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO
	NET_EM_CFG_SCENE_SNAP_SHOT_WITH_RULE2= 10002, // 场景抓拍设置， 对应结构体 NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO

    /***********DoorBell门铃相关配置******************************************************************************************/
	NET_EM_CFG_DOORBELL_EXTERNALDOORBELL = 11000,		// 外接门铃配置,对应结构体 NET_CFG_DOORBELL_EXTERNALDOORBELL, 与通道不相关,通道号需要填成-1

    /***********热成像相关配置******************************************************************************************/
    NET_EM_CFG_SENSOR_MAINTAIN = 11100,		// 热成像机芯维护配置,对应结构体 NET_CFG_SENSOR_MAINTAIN
    NET_EM_CFG_TILT_LIMIT = 11101,		    // 激光测距俯仰角限制,对应结构体 NET_CFG_TILT_LIMIT

    /***********KVM相关配置******************************************************************************************/
    NET_EM_CFG_KVM_MAIN_NODE = 12000,                    // 键盘显示器鼠标节点配置,对应结构体 NET_CFG_KVM_MAIN_NODE
    NET_EM_CFG_KVM_HOT_KEY = 12001,                      // 键盘显示器鼠标热键配置,对应结构体 NET_CFG_KVM_HOT_KEY
    NET_EM_CFG_KM_TRANS_ENCRYPT = 12002,                 // 键盘鼠标加密配置,对应结构体 NET_CFG_KM_TRANS_ENCRYPT

    /***********录播默认配置******************************************************************************************/
    NET_EM_CFG_COURSE_RECORD_DEFAULT_CONFIG = 12100,     // 录播默认配置, 对应结构体 NET_CFG_COURSE_RECORD_DEFAULT_CONFIG

    /***********AroundWifi相关配置******************************************************************************************/
    NET_EM_CFG_WIFI_INSTALL_PARAM = 12200,              // Wifi设备安装配置, 对应结构体 NET_CFG_WIFI_INSTALL_PARAM, 与通道不相关,通道号需要填成-1 
} NET_EM_CFG_OPERATE_TYPE;


//////////////////////////////////////////////////////////////////////////
// RPC方法名
//////////////////////////////////////////////////////////////////////////

#define RPC_METHOD_MONITORWALL_ADD      "monitorWallManager.addMonitorWall"     // 添加电视墙


/***********************************************************************
 ** 回调函数定义
 ***********************************************************************/

// 网络连接断开回调函数原形
typedef void (CALLBACK *fDisConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// 网络连接恢复回调函数原形
typedef void (CALLBACK *fHaveReConnect)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);

// 动态子连接断开回调函数原形
typedef void (CALLBACK *fSubDisConnect)(EM_INTERFACE_TYPE emInterfaceType, BOOL bOnline, LLONG lOperateHandle, LLONG lLoginID, LDWORD dwUser);

// 视频监视断开回调函数原形, (param内存由SDK内部申请释放 )
typedef void (CALLBACK *fRealPlayDisConnect)(LLONG lOperateHandle, EM_REALPLAY_DISCONNECT_EVENT_TYPE dwEventType, void* param, LDWORD dwUser);

// 实时监视数据回调函数原形(pBuffer内存由SDK内部申请释放)
// 通过 dwDataType 过滤得到对应码流，具体码流类型请参考 EM_REALDATA_FLAG; 转码流时 dwDataType 值请参考 NET_DATA_CALL_BACK_VALUE 说明
typedef void (CALLBACK *fRealDataCallBack)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// 实时监视数据回调函数原形--扩展(pBuffer内存由SDK内部申请释放)
// 通过 dwDataType 过滤得到对应码流，具体码流类型请参考 EM_REALDATA_FLAG; 转码流时 dwDataType 值请参考 NET_DATA_CALL_BACK_VALUE 说明
typedef void (CALLBACK *fRealDataCallBackEx)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser);

// 实时监视数据回调函数原形--扩展(pBuffer内存由SDK内部申请释放)
// 通过 dwDataType 过滤得到对应码流，具体码流类型请参考 EM_REALDATA_FLAG; 转码流时 dwDataType 值请参考 NET_DATA_CALL_BACK_VALUE 说明
// 当转码流时，param 为具体的转码信息（视频帧、音频帧等信息），对应结构体 NET_STREAMCONVERT_INFO
typedef void (CALLBACK *fRealDataCallBackEx2)(LLONG lRealHandle, DWORD dwDataType, BYTE *pBuffer, DWORD dwBufSize, LLONG param, LDWORD dwUser);


// 屏幕叠加回调函数原形
typedef void (CALLBACK *fDrawCallBack)(LLONG lLoginID, LLONG lPlayHandle, HDC hDC, LDWORD dwUser);

// 按时间回放进度回调函数原形
typedef void (CALLBACK *fTimeDownLoadPosCallBack) (LLONG lPlayHandle, DWORD dwTotalSize, DWORD dwDownLoadSize, int index, NET_RECORDFILE_INFO recordfileinfo, LDWORD dwUser);

// 消息回调函数原形(pBuf内存由SDK内部申请释放)
typedef BOOL (CALLBACK *fMessCallBack)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, LDWORD dwUser);
// 新增参数说明
// bAlarmAckFlag : TRUE,该事件为可以进行确认的事件；FALSE,该事件无法进行确认
// nEventID 用于对 CLIENT_AlarmAck 接口的入参进行赋值,当 bAlarmAckFlag 为 TRUE 时,该数据有效
// pBuf内存由SDK内部申请释放
typedef BOOL (CALLBACK *fMessCallBackEx1)(LONG lCommand, LLONG lLoginID, char *pBuf, DWORD dwBufLen, char *pchDVRIP, LONG nDVRPort, BOOL bAlarmAckFlag, LONG nEventID, LDWORD dwUser);

// 侦听服务器回调函数原形
typedef int (CALLBACK *fServiceCallBack)(LLONG lHandle, char *pIp, WORD wPort, LONG lCommand, void *pParam, DWORD dwParamLen, LDWORD dwUserData);

// 语音对讲的音频数据回调函数原形(pDataBuf内存由SDK内部申请释放)
// 当byAudioFlag为2时，pDataBuf表示为不带头的PCM数据，首先将回调中byAudioFlag为1时的数据通过CLIENT_AudioDec接口发送，再通过byAudioFlag为2时将数据回调给用户
typedef void (CALLBACK *pfAudioDataCallBack)(LLONG lTalkHandle, char *pDataBuf, DWORD dwBufSize, BYTE byAudioFlag, LDWORD dwUser);

// 升级设备程序回调函数原形
// nTotalSize = 0, nSendSize = -1 表示升级完成
// nTotalSize = 0, nSendSize = -2 表示升级出错
// nTotalSize = 0, nSendSize = -3 用户没有权限升级
// nTotalSize = 0, nSendSize = -4 升级程序版本过低
// nTotalSize = -1, nSendSize = XX 表示升级进度
// nTotalSize = XX, nSendSize = XX 表示升级文件发送进度
typedef void (CALLBACK *fUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradechannel, int nTotalSize, int nSendSize, LDWORD dwUser);

// 升级设备程序回调函数原形支持G以上升级文件
// nTotalSize = 0, nSendSize = -1 表示升级完成
// nTotalSize = 0, nSendSize = -2 表示升级出错
// nTotalSize = 0, nSendSize = -3 用户没有权限升级
// nTotalSize = 0, nSendSize = -4 升级程序版本过低
// nTotalSize = -1, nSendSize = XX 表示升级进度
// nTotalSize = XX, nSendSize = XX 表示升级文件发送进度 
typedef void (CALLBACK *fUpgradeCallBackEx) (LLONG lLoginID, LLONG lUpgradechannel, INT64 nTotalSize, INT64 nSendSize, LDWORD dwUser);

// 透明串口回调函数原形(pBuffer内存由SDK内部申请释放)
typedef void (CALLBACK *fTransComCallBack) (LLONG lLoginID, LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// 查询设备日志数据回调函数原形(pBuffer内存由SDK内部申请释放)
typedef void (CALLBACK *fLogDataCallBack)(LLONG lLoginID, char *pBuffer, DWORD dwBufSize, DWORD nTotalSize, BOOL bEnd, LDWORD dwUser);

// 抓图回调函数原形(pBuf内存由SDK内部申请释放)
// EncodeType 编码类型，10：表示jpeg图片 0：mpeg4的i帧
typedef void (CALLBACK *fSnapRev)(LLONG lLoginID, BYTE *pBuf, UINT RevLen, UINT EncodeType, DWORD CmdSerial, LDWORD dwUser);

// GPS信息订阅回调
typedef void (CALLBACK *fGPSRev)(LLONG lLoginID, GPS_Info GpsInfo, LDWORD dwUserData);

// GPS信息订阅回调--扩展
typedef void (CALLBACK *fGPSRevEx)(LLONG lLoginID, GPS_Info GpsInfo, ALARM_STATE_INFO stAlarmInfo, LDWORD dwUserData, void *reserved);

// GPS信息订阅回调--扩展2
typedef void (CALLBACK *fGPSRevEx2)(LLONG lLoginID, const LPNET_GPS_LOCATION_INFO lpData, LDWORD dwUserData, void *reserved);

// GPS温湿度信息订阅回调
typedef void (CALLBACK *fGPSTempHumidityRev)(LLONG lLoginID, GPS_TEMP_HUMIDITY_INFO GpsTHInfo, LDWORD dwUserData);

// 异步数据回调
typedef void (CALLBACK *fMessDataCallBack)(LLONG lCommand, LPNET_CALLBACK_DATA lpData, LDWORD dwUser);

// 文件传输回调
typedef void (CALLBACK *fTransFileCallBack)(LLONG lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, LDWORD dwUser);

// 智能分析数据回调;nSequence表示上传的相同图片情况,为0时表示是第一次出现,为2表示最后一次出现或仅出现一次,为1表示此次之后还有
// int nState = (int*) reserved 表示当前回调数据的状态, 为0表示当前数据为实时数据,为1表示当前回调数据是离线数据,为2时表示离线数据传送结束
typedef int  (CALLBACK *fAnalyzerDataCallBack)(LLONG lAnalyzerHandle, DWORD dwAlarmType, void* pAlarmInfo, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser, int nSequence, void *reserved);

// 异步搜索设备回调(pDevNetInfo内存由SDK内部申请释放)
typedef void (CALLBACK *fSearchDevicesCB)(DEVICE_NET_INFO_EX *pDevNetInfo, void* pUserData);

// 异步搜索设备回调(pDevNetInfo内存由SDK内部申请释放)
typedef void (CALLBACK *fSearchDevicesCBEx)(LLONG lSearchHandle,DEVICE_NET_INFO_EX2 *pDevNetInfo, void* pUserData);

// 异步注册设备回调函数原形
// typedef void (CALLBACK *fHaveLogin)(LLONG lLoginID, char *pchDVRIP, LONG nDVRPort, BOOL bOnline, NET_DEVICEINFO_Ex stuDeviceInfo, int nError, LDWORD dwUser, void *reserved);

// 回放YUV数据回调函数
typedef void (CALLBACK *fYUVDataCallBack)(LLONG lPlaybackHandle, BYTE *pBuffer, DWORD dwBufSize, LONG param, LDWORD dwUser, void *reserved);

// 日志数据回调
typedef void (CALLBACK *fSubLogDataCallBack)(LLONG lLogHandle, NET_EM_LOG_QUERY_TYPE emLogType, const DH_DEVICE_LOG_ITEM_EX *pstuLogData, const int& nCount, LDWORD dwUser, void *reserved);
/************************************************************************
 ** 接口定义
 ***********************************************************************/

// SDK初始化
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Init(fDisConnect cbDisConnect, LDWORD dwUser);

// SDK初始化, 通过NETSDK_INIT_PARAM指定初始化参数, 如定制NetSDK启用的常规网络处理线程数，
// 当lpInitParam为空时，与调用CLIENT_Init效果一致
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitEx(fDisConnect cbDisConnect, LDWORD dwUser, LPNETSDK_INIT_PARAM lpInitParam = NULL);

// SDK退出清理
CLIENT_NET_API void CALL_METHOD CLIENT_Cleanup();

//设置运行模式参数,在CLIENT_Init之后调用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRunModeParams(NET_RUNMODE_PARAMS *pstuRunParams);

//------------------------------------------------------------------------

// 设置断线重连成功回调函数,设置后SDK内部断线自动重连
CLIENT_NET_API void CALL_METHOD CLIENT_SetAutoReconnect(fHaveReConnect cbAutoConnect, LDWORD dwUser);

// 设置动态子连接断线回调函数,目前SVR设备的监视和回放是短连接的。
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubconnCallBack(fSubDisConnect cbSubDisConnect, LDWORD dwUser);

// 返回函数执行失败代码
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetLastError(void);

// 设置连接设备超时时间和尝试次数
CLIENT_NET_API void CALL_METHOD CLIENT_SetConnectTime(int nWaitTime, int nTryTimes);

// 设置登陆网络环境(pNetParam内存由用户申请释放)
CLIENT_NET_API void CALL_METHOD CLIENT_SetNetworkParam(NET_PARAM *pNetParam);

// 设置UDP和组播网络参数
CLIENT_NET_API void CALL_METHOD CLIENT_GetUdpOption(NET_UDP_OPTION *pUdpOption);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetUdpOption(NET_UDP_OPTION *pUdpOption);

// 获取SDK的版本信息
CLIENT_NET_API DWORD CALL_METHOD CLIENT_GetSDKVersion();

//------------------------------------------------------------------------

// 向设备注册(lpDeviceInfo内存由用户申请释放)
// error取值及其含义：  
//					error =	-1	设备不支持高安全等级登录
//					error = 0   无错误
//					error = 1   账号或密码错误
//                  error = 2   用户名不存在
//                  error = 3   登录超时
//                  error = 4   重复登录
//                  error = 5   帐号被锁定
//                  error = 6   帐号被列入黑名单
//                  error = 7   系统忙,资源不足
//                  error = 8   子连接失败
//                  error = 9   主连接失败
//                  error = 10  超过最大连接数
//                  error = 11  只支持3代协议
//                  error = 12  设备未插入U盾或U盾信息错误
//                  error = 13  客户端IP地址没有登录权限
//					error = 18  设备账号未初始化，无法登陆
//					error = 19  登录受限
//					error = 20  设备只支持高安全等级登陆

CLIENT_NET_API LLONG CALL_METHOD CLIENT_Login(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// 扩展接口；nSpecCap = 0为TCP方式下的登入,void* pCapParam填NULL
//			 nSpecCap = 2为主动注册的登入,void* pCapParam填NULL
//			 nSpecCap = 3为组播方式下的登入,void* pCapParam填NULL
//           nSpecCap = 4为UDP方式下的登入,void* pCapParam填NULL
//			 nSpecCap = 6为只建主连接下的登入,void* pCapParam填NULL
//			 nSpecCap = 7为SSL加密,void* pCapParam填NULL
//           nSpecCap = 9为登录远程设备,这个时候void* pCapParam填入远程设备的名字的字符串
//           nSpecCap = 12为LDAP方式登录,void* pCapParam填NULL
//           nSpecCap = 13为AD方式登录,void* pCapParam填NULL
//           nSpecCap = 14为Radius登录方式,void* pCapParam填NULL 
//           nSpecCap = 15为Socks5登陆方式,这个时候void* pCapParam填入Socks5服务器的IP&&port&&ServerName&&ServerPassword字符串
//           nSpecCap = 16为代理登陆方式,这个时候void* pCapParam填入SOCKET值
//           nSpecCap = 19为P2P登陆方式,void* pCapParam填NULL
//           nSpecCap = 20为手机客户端登入,void* pCapParam填NULL
//			 lpDeviceInfo内存由用户申请释放
// 当登入失败时：   error的错误码对应的说明参考 CLIENT_Login
//			 lpDeviceInfo, pCapParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, int nSpecCap, void* pCapParam, LPNET_DEVICEINFO lpDeviceInfo, int *error = 0);

// 登入扩展接口(lpDeviceInfo, pCapParam内存由用户申请释放)
// 当登入失败时：   error的错误码对应的说明参考 CLIENT_Login
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginEx2(const char *pchDVRIP, WORD wDVRPort, const char *pchUserName, const char *pchPassword, EM_LOGIN_SPAC_CAP_TYPE emSpecCap, void* pCapParam, LPNET_DEVICEINFO_Ex lpDeviceInfo, int *error = 0);

// 异步向设备注册 
// nSpecCap = 0为TCP方式下的登入,nSpecCap = 6为只建主连接下的登入
// nSpecCap = 19为P2P登录
// pCapParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLogin(char *pchDVRIP, WORD wDVRPort, char *pchUserName, char *pchPassword, int nSpecCap, void* pCapParam, fHaveLogin cbLogin, LDWORD dwUser);

// 只有当CLIENT_StartLogin()的回调错误为11时才使用该接口继续异步登陆(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartLoginEx(NET_IN_STARTLOGINEX* pInParam, NET_OUT_STARTLOGINEX* pOutParam);

// 停止向设备注册
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLogin(LLONG lLoginID);

CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoginEx(LLONG lLoginID);

// 向设备注销
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Logout(LLONG lLoginID);


// CLIENT_LoginWithHighLevelSecurity 输入参数
typedef struct tagNET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY
{
	DWORD						dwSize;				// 结构体大小
	char						szIP[64];			// IP
	int							nPort;				// 端口
	char						szUserName[64];		// 用户名
	char						szPassword[64];		// 密码
	EM_LOGIN_SPAC_CAP_TYPE		emSpecCap;			// 登录模式
	BYTE						byReserved[4];		// 字节对齐
	void*						pCapParam;			// 见 CLIENT_LoginEx 接口 pCapParam 与 nSpecCap 关系
}NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY;

// CLIENT_LoginWithHighLevelSecurity 输出参数
typedef struct tagNET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY
{
	DWORD						dwSize;				// 结构体大小
	NET_DEVICEINFO_Ex			stuDeviceInfo;		// 设备信息
	int							nError;				// 错误码，见 CLIENT_Login 接口错误码
	BYTE						byReserved[132];	// 预留字段
}NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY;


// 高安全级别登陆
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoginWithHighLevelSecurity(NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY* pstInParam, NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY* pstOutParam);

//------------------------------------------------------------------------

// 获取设备端协议版本类型
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevProtocolType(LLONG lLoginID, EM_DEV_PROTOCOL_TYPE *pemProtocolType);

//------------------------------------------------------------------------
// 实时流加密功能相关接口

// 加密算法类型
typedef enum tagEM_ALGORITHM_TYPE
{
	EM_ALGORITHM_TYPE_UNKNOWN,							// 未知加密算法
	EM_ALGORITHM_TYPE_AES256_OFB,						// AES256-OFB加密算法
}EM_ALGORITHM_TYPE;

// VK二值对信息
typedef struct tagNET_VKINFO
{
	char						szVKID[128];			// VKID
	char						szVK[128];				// VK
	EM_ALGORITHM_TYPE			emAlgorithmType;		// 加密算法类型
	int							nRetVKIDLen;			// 返回的VKID字段的实际大小
	int							nRetVKLen;				// 返回的VK实际大小
	BYTE						byReserved[500];		// 保留字节
}NET_VKINFO;

// VK信息回调(pBuffer内存由SDK内部申请释放),dwError值可以dhnetsdk.h中找到相应的解释,比如NET_NOERROR,NET_ERROR_VK_INFO_DECRYPT_FAILED等
typedef void (CALLBACK *fVKInfoCallBack)(LLONG lRealHandle, NET_VKINFO* pBuffer, DWORD dwError, LDWORD dwUser, void* pReserved);

// 获取VK入参
typedef struct tagNET_IN_GET_VKINFO
{
    DWORD dwSize;	  // 结构体大小
    int   nChannelID; // 通道ID
}NET_IN_GET_VKINFO;

// 获取VK出参
typedef struct tagNET_OUT_GET_VKINFO
{
    DWORD		dwSize;	   // 结构体大小	
    NET_VKINFO  stuVKInfo; // VK二值对信息
	BOOL		bContainPrevVKInfo;	// 是否含有前一个VK二值对信息,TRUE表示有前一个VK二值对，FALSE表示没有前一个VK二值对
	NET_VKINFO	stuPrevVKInfo;	// 前一个VK二值对信息
}NET_OUT_GET_VKINFO;

// 更新VK入参
typedef struct tagNET_IN_UPDATE_VKINFO
{
    DWORD		dwSize;		// 结构体大小	
    int			nChannelID;	// 通道号
}NET_IN_UPDATE_VKINFO;

// 更新VK出参
typedef struct tagNET_OUT_UPDATE_VKINFO
{
    DWORD		dwSize;			// 结构体大小
    char		szVKID[128];	// VKID
}NET_OUT_UPDATE_VKINFO;

// 订阅VK回调函数
typedef void (CALLBACK *fAttachVK)(LLONG lLoginID, LLONG lAttachHandle,int nChannelID,const NET_VKINFO* pVKInfo,LDWORD dwUser);

// 订阅VK入参
typedef struct tagNET_IN_ATTACH_VK
{
    DWORD              dwSize;                              // 结构体大小 
    int                nChannelID;							// 通道号
    fAttachVK          cbAttachVK;                          // 回调函数
    LDWORD             dwUser;                              // 用户数据
}NET_IN_ATTACH_VK;

// 订阅VK出参
typedef struct tagNET_OUT_ATTACH_VK
{
    DWORD				dwSize;                 // 结构体大小
	NET_VKINFO			stuCurrentVKInfo;		// 当前VK二值对信息
	BOOL				bContainPrevVKInfo;		// 是否含有前一个VK二值对信息,TRUE表示有前一个VK二值对，FALSE表示没有前一个VK二值对
	NET_VKINFO			stuPrevVKInfo;			// 前一个VK二值对信息
}NET_OUT_ATTACH_VK;


// 码流加密能力集信息
typedef struct tagNET_MEDIA_ENCRYPT_CAPS_INFO
{
    BOOL				bSupport;							// 是否支持码流加密
    BYTE				byReserved[256];					// 保留字节
}NET_MEDIA_ENCRYPT_CAPS_INFO;

// 获取加密能力集入参
typedef struct tagNET_IN_GET_MEDIA_ENCRYPT_CAPS
{
    DWORD              dwSize;                      // 结构体大小
    int                nChannelOffset;				// 获取的通道偏移
    int                nChannelCount;				// 一次获取的通道数量
}NET_IN_GET_MEDIA_ENCRYPT_CAPS;

// 获取加密能力集出参
typedef struct tagNET_OUT_GET_MEDIA_ENCRYPT_CAPS
{
    DWORD                           dwSize;                    // 结构体大小
    NET_MEDIA_ENCRYPT_CAPS_INFO*    pstuCapsInfo;			   // 码流加密能力集信息		
    int                             nMaxCapsInfoCount;		   // 最大获取码流加密能力集个数
    int                             nRetCapsInfoCount;		   // 返回的码流加密能力集个数
}NET_OUT_GET_MEDIA_ENCRYPT_CAPS;

// 更新VK
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateVK(LLONG lLoginID, const NET_IN_UPDATE_VKINFO* pInParam, NET_OUT_UPDATE_VKINFO* pOutParam, int nWaitTime);

// 订阅VK,另外可以获取到当前vk甚至前一个vk信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVK( LLONG lLoginID, const NET_IN_ATTACH_VK* pInParam, NET_OUT_ATTACH_VK* pOutParam, int nWaitTime);

// 取消订阅VK
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVK( LLONG lAttachHandle);

// 获取媒体文件加密能力集
CLIENT_NET_API LLONG CALL_METHOD CLIENT_GetMediaEncryptCaps( LLONG lLoginID, const NET_IN_GET_MEDIA_ENCRYPT_CAPS* pInParam, NET_OUT_GET_MEDIA_ENCRYPT_CAPS* pOutParam, int nWaitTime);
//------------------------------------------------------------------------
// 开始实时监视
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlay(LLONG lLoginID, int nChannelID, HWND hWnd);

// 开始实时监视--扩展
// 多画面预览时nChannelID NVR设备填视频输出通道号
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayEx(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType = DH_RType_Realplay);
//打开实时监视,若返回0表示打开失败
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRealPlay(LLONG lLoginID, int nChannelID, HWND hWnd, DH_RealPlayType rType, fRealDataCallBackEx cbRealData, fRealPlayDisConnect cbDisconnect, LDWORD dwUser, DWORD dwWaitTime = 10000);

// 多画面实时预览
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlay(LLONG lLoginID, HWND hWnd);

// 停止多画面实时预览
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopMultiPlay(LLONG lMultiHandle);

// 抓图；hPlayHandle为监视或回放句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePicture(LLONG hPlayHandle, const char *pchPicFileName);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx(LLONG hPlayHandle, const char *pchPicFileName, NET_CAPTURE_FORMATS eFormat);

// CLIENT_CapturePictureEx2 接口入参
typedef struct tagNET_IN_CAPTURE_PICTURE
{
    DWORD                   dwSize;                         // 结构体大小
    NET_CAPTURE_FORMATS     emFormat;                       // 图片保存格式
    char                    szPicFilePath[256];             // 图片保存路径
} NET_IN_CAPTURE_PICTURE;

// CLIENT_CapturePictureEx2 接口出参
typedef struct tagNET_OUT_CAPTURE_PICTURE
{
    DWORD                   dwSize;                         // 结构体大小
    NET_TIME_EX             stuTime;                        // 图片时间
} NET_OUT_CAPTURE_PICTURE;

// 手动抓图扩展接口(支持返回图片时间，精确到毫秒), hPlayHandle为监视或回放句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CapturePictureEx2(LLONG lPlayHandle, NET_IN_CAPTURE_PICTURE *pstInParam, NET_OUT_CAPTURE_PICTURE *pstOutParam);

// 设置实时监视数据回调
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBack(LLONG lRealHandle, fRealDataCallBack cbRealData, LDWORD dwUser);

typedef enum _PrerecordStreamType
{
	Prerecord_RType_Realplay_0,						   // 实时监视-主码流
	Prerecord_RType_Realplay_1,                        // 实时监视-从码流1
	Prerecord_RType_Realplay_2,                        // 实时监视-从码流2
	Prerecord_RType_Realplay_3,                        // 实时监视-从码流3  
}EM_PRERECODE_STREAM_TYPE;

CLIENT_NET_API LLONG CALL_METHOD CLIENT_PrerecordStream(LLONG lLoginID, int nChannelID,EM_PRERECODE_STREAM_TYPE emPreRecord, int nWaitTime);

// 实时监视的实时数据标志, 对应 CLIENT_SetRealDataCallBackEx(Ex2) 中的 dwFlag 参数
// 支持 '|' 运算符, 如 dwFlag = REALDATA_FLAG_RAW_DATA | REALDATA_FLAG_YUV_DATA
typedef enum tagEM_REALDATA_FLAG
{	
	REALDATA_FLAG_RAW_DATA				= 0x01,	// 原始数据标志,			对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为0, 0x01 = 0x01 << 0
	REALDATA_FLAG_DATA_WITH_FRAME_INFO	= 0x02,	// 带有帧信息的数据标志,	对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为1, 0x02 = 0x01 << 1
	REALDATA_FLAG_YUV_DATA				= 0x04,	// YUV 数据标志,			对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为2, 0x04 = 0x01 << 2
	REALDATA_FLAG_PCM_AUDIO_DATA		= 0x08,	// PCM 音频数据标志,		对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为3, 0x08 = 0x01 << 3
} EM_REALDATA_FLAG;

// 设置实时监视数据回调--扩展
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx(LLONG lRealHandle, fRealDataCallBackEx cbRealData, LDWORD dwUser, DWORD dwFlag);


// 实时监视加密数据回调函数(pBuffer内存由SDK内部申请释放)
typedef void (CALLBACK *fEncryptRealDataCallBackEx)(LLONG lRealHandle, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// 设置实时监视加密数据回调
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetEncryptRealDataCallBack(LLONG lRealHandle, fEncryptRealDataCallBackEx cbRealData, LDWORD dwUser);

// 设置实时监视数据回调--扩展Ex2
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealDataCallBackEx2(LLONG lRealHandle, fRealDataCallBackEx2 cbRealData, LDWORD dwUser, DWORD dwFlag);

// 实时监视原始码流数据回调函数(pBuffer内存由SDK内部申请释放)
typedef void (CALLBACK *fOriginalRealDataCallBack)(LLONG lRealHandle, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// 设置实时监视原始码流数据回调
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOriginalRealDataCallBack(LLONG lRealHandle, fOriginalRealDataCallBack cbRealData, LDWORD dwUser);


// 设置VK信息回调:lPlayHandle 是拉流和回放接口返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVKInfoCallBack(LLONG lPlayHandle, fVKInfoCallBack cbVKInfo, LDWORD dwUser);

// 设置图象流畅性
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustFluency(LLONG lRealHandle, int nLevel);

// 保存数据为文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveRealData(LLONG lRealHandle, const char *pchFileName);

// 结束保存数据为文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSaveRealData(LLONG lRealHandle);

// 设置图像属性
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientSetVideoEffect(LLONG lPlayHandle, unsigned char nBrightness, unsigned char nContrast, unsigned char nHue, unsigned char nSaturation);

// 获取图像属性
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClientGetVideoEffect(LLONG lPlayHandle, unsigned char *nBrightness, unsigned char *nContrast, unsigned char *nHue, unsigned char *nSaturation);

// 设置屏幕叠加回调
CLIENT_NET_API void CALL_METHOD CLIENT_RigisterDrawFun(fDrawCallBack cbDraw, LDWORD dwUser);

// 打开声音
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSound(LLONG hPlayHandle);

// 设置音量；lPlayHandle为监视或回放句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVolume(LLONG lPlayHandle, int nVolume);

// 是否启用高清图像内部调整策略,默认启用。该策略启用时,在快放4倍速以上时,只播放I帧,不启用时,则每帧都播放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayEnableLargePicAdjustment(LLONG lPlayHandle, BOOL bEnable);

// 关闭声音
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSound();

// 停止实时预览
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlay(LLONG lRealHandle);

// 停止实时预览--扩展
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealPlayEx(LLONG lRealHandle);

//------------------------------------------------------------------------

// 云台相对定位参数
typedef struct tagNET_IN_MOVERELATIVELY_INFO
{
	DWORD							dwSize;				// 结构体大小
	PTZ_SPACE_RELATIVELY_UNIT		stuTranslation;		// x, y, zoom 坐标归一化到 -1~1
	PTZ_SPACE_RELATIVELY_UNIT		stuSpeed;			// x, y, zoom 坐标归一化到 0~1
}NET_IN_MOVERELATIVELY_INFO;

// 云台方向
typedef enum tagNET_EM_PTZ_DIRECTION_TYPE
{
	NET_EM_PTZ_DIRECTION_TYPE_UNKNOWN,	// 未知
	NET_EM_PTZ_DIRECTION_TYPE_EAST,		// 东
	NET_EM_PTZ_DIRECTION_TYPE_SOUTH,	// 南
	NET_EM_PTZ_DIRECTION_TYPE_WEST,		// 西
	NET_EM_PTZ_DIRECTION_TYPE_NORTH,	// 北
}NET_EM_PTZ_DIRECTION_TYPE;

// 设置云台方向 DH_EXTPTZ_SET_DIRECTION
typedef struct tagNET_IN_SET_DIRECTION_INFO
{
	DWORD								dwSize;				// 结构体大小
	NET_EM_PTZ_DIRECTION_TYPE			emDirection;		// 云台方向
}NET_IN_SET_DIRECTION_INFO;

// 通用云台控制
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, DWORD dwStep, BOOL dwStop);

// 私有云台控制,param4由用户申请释放内存，内存大小参照DH_EXTPTZ_ControlType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControl(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, unsigned char param1, unsigned char param2, unsigned char param3, BOOL dwStop,void* param4=NULL);

// 私有云台控制扩展接口,支持三维快速定位
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop );

// 私有云台控制扩展接口,支持三维快速定位,鱼眼,param4由用户申请释放内存，内存大小参照DH_EXTPTZ_ControlType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZControlEx2(LLONG lLoginID, int nChannelID, DWORD dwPTZCommand, LONG lParam1, LONG lParam2, LONG lParam3, BOOL dwStop , void* param4 = NULL);

// 区域扫描接口，获取和设置信息(NET_AREASCAN_EPTZ_CMD)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DHPTZAreaScan(LLONG lLoginID ,DWORD dwPTZCommand, char* szInBuffer, DWORD dwInBufferSize,char* szOutBuffer = NULL, DWORD dwOutBufferSize = 0, int waittime=1000);



// CLIENT_DHPTZCalibrateSingleDirection 入参
typedef struct tagNET_IN_CALIBRATE_SINGLEDIRECTION
{
    DWORD                       dwSize;
    int                         nMode;                      // 校准模式，1：水平校准，2：垂直校准
}NET_IN_CALIBRATE_SINGLEDIRECTION;

//------------------------------------------------------------------------
// 查询某月的各天是否存在录像文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordStatus(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmMonth, char* pchCardid, LPNET_RECORD_STATUS pRecordStatus, int waittime=1000);
// 查询时间段内是否有录像文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, BOOL *bResult, int waittime=1000);
// 查询时间段内的所有录像文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);

// 异步查询时间段内的所有录像文件(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartQueryRecordFile(LLONG lLoginID, NET_IN_START_QUERY_RECORDFILE *pInParam, NET_OUT_START_QUERY_RECORDFILE *pOutParam);

// 停止异步录像查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryRecordFile(LLONG lQueryHandle);

// 快速查询时间段内的录像文件,如果时间段内录像超过16条时,只返回时间最早的16段录像。
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuickQueryRecordFile(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char* pchCardid, LPNET_RECORDFILE_INFO nriFileinfo, int maxlen, int *filecount, int waittime=1000, BOOL bTime = FALSE);

// 查询最早录像时间(pFurthrestTime内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryFurthestRecordTime(LLONG lLoginID, int nRecordFileType, char *pchCardid, NET_FURTHEST_RECORD_TIME* pFurthrestTime, int nWaitTime);

// 开始查找录像文件
CLIENT_NET_API LLONG    CALL_METHOD CLIENT_FindFile(LLONG lLoginID, int nChannelId, int nRecordFileType, char* cardid, LPNET_TIME time_start, LPNET_TIME time_end, BOOL bTime, int waittime);

// 查找录像文件(lpFindData内存由用户申请释放)
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextFile(LLONG lFindHandle,LPNET_RECORDFILE_INFO lpFindData);

// 结束录像文件查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindClose(LLONG lFindHandle);

// 按文件方式回放(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// 按文件方式回放--扩展(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);

// 按文件录像回放入参信息
typedef struct tagNET_IN_PLAY_BACK_BY_FILE_INFO
{
    LPNET_RECORDFILE_INFO pRecordFile;                     // 录像文件信息 
    HWND                hWnd;                              // 播放窗格, 可为NULL
    fDownLoadPosCallBack cbDownLoadPos;                    // 进度回调
    LDWORD              dwPosUser;                         // 进度回调用户信息
    fDataCallBack       fDownLoadDataCallBack;             // 数据回调
    LDWORD              dwDataUser;                        // 数据回调用户信息
    int                 nPlayDirection;                    // 播放方向, 0:正放; 1:倒放;
    int                 nWaittime;                         // 接口超时时间, 目前倒放使用
    BYTE                bReserved[1024];                   // 预留字节
}NET_IN_PLAY_BACK_BY_FILE_INFO;

// 按文件录像回放出参信息
typedef struct tagNET_OUT_PLAY_BACK_BY_FILE_INFO
{
    BYTE                bReserved[1024];                   // 预留字节
}NET_OUT_PLAY_BACK_BY_FILE_INFO;

// 按文件方式回放--扩展
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileEx2(LLONG lLoginID, const NET_IN_PLAY_BACK_BY_FILE_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_FILE_INFO *pstNetOut);

// 按文件方式回放--回调回放中断事件(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByRecordFile(LLONG lLoginID,  LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
                                                             fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                             fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
                                                             fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//按文件方式回放--抽帧播放(带宽不够时可以使用)(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, HWND hWnd, 
                                                                   fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                                   fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

// 按时间方式回放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser);




// 按时间方式回放--扩展
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                     fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser);
// 按时间方式回放--扩展第二版,支持直接倒放,pstNetIn与pstNetOut需要用户申请内存
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeEx2(LLONG lLoginID, int nChannelID, 
                        NET_IN_PLAY_BACK_BY_TIME_INFO *pstNetIn, NET_OUT_PLAY_BACK_BY_TIME_INFO *pstNetOut);

// 按时间方式回放--回调回放中断事件
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartPlayBackByTime(LLONG lLoginID, int nChannelID, 
                                                       LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                       fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser,
                                                       fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, 
                                                       fRealPlayDisConnect fDisConnectCallBack, LDWORD dwDisUser, DWORD dwWaitTime = 10000);

//按时间方式回放--抽帧播放(带宽不够时可以使用)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FramCotrolPlayBackByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, HWND hWnd, 
                                                             fDownLoadPosCallBack cbDownLoadPos, LDWORD dwPosUser, 
                                                             fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, unsigned int nCutFrameRate);

//视频浓缩文件回放(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySynopsisFile(LLONG lLoginID, 
                                                            LPNET_SYNOPSISFILE_INFO lpRecordFile, 
                                                            HWND hWnd, 
                                                            fDownLoadPosCallBack cbDownLoadPos,
                                                            LDWORD dwPosUser, 
                                                            fDataCallBack fDownLoadDataCallBack,
                                                            LDWORD dwDataUser,
                                                            LDWORD dwUser);
                                                            
// 多通道预览回放(pParam内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MultiPlayBack(LLONG lLoginID, NET_MULTI_PLAYBACK_PARAM *pParam);

// 定位录像回放起始点
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBack(LLONG lPlayHandle, unsigned int offsettime, unsigned int offsetbyte);

// 按时间定位回放起始点
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SeekPlayBackByTime(LLONG lPlayHandle, LPNET_TIME lpSeekTime);

// 暂停或恢复录像回放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayBack(LLONG lPlayHandle, BOOL bPause);

// 快进录像回放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayBack(LLONG lPlayHandle);

// 慢进录像回放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayBack(LLONG lPlayHandle);

// 设置录像回放速度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayBackSpeed(LLONG lPlayHandle, EM_PLAY_BACK_SPEED emSpeed);

// 步进录像回放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StepPlayBack(LLONG lPlayHandle, BOOL bStop);

// 控制播放方向--正放或者倒放
// bBackward FLASE 正放,TRUE 倒放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControlDirection(LLONG lPlayHandle, BOOL bBackward);

// 设置回放帧速
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFramePlayBack(LLONG lPlayHandle, int framerate);

// 获取回放帧速
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFramePlayBack(LLONG lPlayHandle, int *fileframerate, int *playframerate);

// 恢复正常回放速度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayBack(LLONG lPlayHandle);

// 智能检索回放(lpPlayBackParam内存用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SmartSearchPlayBack(LLONG lPlayHandle, LPIntelligentSearchPlay lpPlayBackParam);

// 获取回放OSD时间
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlayBackOsdTime(LLONG lPlayHandle, LPNET_TIME lpOsdTime, LPNET_TIME lpStartTime, LPNET_TIME lpEndTime);

// 停止录像回放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopPlayBack(LLONG lPlayHandle);

// 下载录像文件(lpRecordFile内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFile(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// 下载录像文件--扩展
// sSavedFileName不为空, 录像数据写入到该路径对应的文件; fDownLoadDataCallBack不为空, 录像数据通过回调函数返回
// pReserved 指加密录像的密码（长度不小于 8 的字符串）
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByRecordFileEx(LLONG lLoginID, LPNET_RECORDFILE_INFO lpRecordFile, char *sSavedFileName, 
                                                           fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData, 
                                                           fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// 通过时间下载录像
// nRecordFileType 的类型参见 枚举EM_QUERY_RECORD_TYPE
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTime(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData);

// 通过时间下载录像--扩展
// sSavedFileName不为空, 录像数据写入到该路径对应的文件; fDownLoadDataCallBack不为空, 录像数据通过回调函数返回
// pReserved 指加密录像的密码（长度不小于 8 的字符串）
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByTimeEx(LLONG lLoginID, int nChannelId, int nRecordFileType, LPNET_TIME tmStart, LPNET_TIME tmEnd, char *sSavedFileName, 
                                                     fTimeDownLoadPosCallBack cbTimeDownLoadPos, LDWORD dwUserData, 
                                                     fDataCallBack fDownLoadDataCallBack, LDWORD dwDataUser, void* pReserved = NULL);

// 查询录像下载进度,单位KB
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDownloadPos(LLONG lFileHandle, int *nTotalSize, int *nDownLoadSize);

// 停止录像下载
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownload(LLONG lFileHandle);

// 暂停或恢复录像下载
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseDownload(LLONG lFileHandle, BOOL bPause);

//------------------------------------- 指定回调数据格式 监视、回放、下载 相关接口 ---------------------

#define NET_DATA_CALL_BACK_VALUE      1000       // 配合EM_REAL_DATA_TYPE使用,码流转换后的数据回调函数(fRealDataCallBackEx,fDataCallBack)中的参数dwDataType的值
                                                 // 为所转换的码流类型加上NET_DATA_CALL_BACK_VALUE.
                                                 // 即,dwDataType = NET_DATA_CALL_BACK_VALUE + emDataType
                                                 // 在回调函数中接受码流转换后的数据,必须要先判断 dwDataType 的值是否为 NET_DATA_CALL_BACK_VALUE和emDataType之和
                                                 // 另,EM_REAL_DATA_TYPE_PRIVATE不用做此判断

// 实时监视回调数据类型
typedef enum tagEM_REAL_DATA_TYPE
{
    EM_REAL_DATA_TYPE_PRIVATE,       // 私有码流
    EM_REAL_DATA_TYPE_GBPS,          // 国标PS码流
    EM_REAL_DATA_TYPE_TS,            // TS码流
    EM_REAL_DATA_TYPE_MP4,           // MP4文件(从回调函数出来的是私有码流数据,参数dwDataType值为0)
    EM_REAL_DATA_TYPE_H264,          // 裸视频流,h264与h265都能转码成功
	EM_REAL_DATA_TYPE_FLV_STREAM,	 // 流式FLV
	EM_REAL_DATA_TYPE_PS,			 // PS码流
	EM_REAL_DATA_TYPE_DHTS,			 // DHTS
}EM_REAL_DATA_TYPE;

// 开始实时监视并指定回调数据格式入参
typedef struct tagNET_IN_REALPLAY_BY_DATA_TYPE
{
    DWORD					dwSize;                 // 结构体大小
    int						nChannelID;             // 通道编号
    HWND					hWnd;                   // 窗口句柄
    DH_RealPlayType			rType;                  // 码流类型    
    fRealDataCallBackEx		cbRealData;             // 数据回调函数
    EM_REAL_DATA_TYPE		emDataType;             // 回调的数据类型 
    LDWORD					dwUser;                 // 用户数据
    const char*				szSaveFileName;         // 转换后的文件名
	fRealDataCallBackEx2	cbRealDataEx;           // 数据回调函数-扩展
}NET_IN_REALPLAY_BY_DATA_TYPE;

// 开始实时监视并指定回调数据格式出参
typedef struct tagNET_OUT_REALPLAY_BY_DATA_TYPE
{
    DWORD               dwSize;                 // 结构体大小  
}NET_OUT_REALPLAY_BY_DATA_TYPE;

// 指定回调数据类型 实施监视(预览), 数据回调函数 cbRealData 中得到的码流类型为 emDataType 所指定的类型
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealPlayByDataType(LLONG lLoginID, const NET_IN_REALPLAY_BY_DATA_TYPE* pstInParam, NET_OUT_REALPLAY_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// 开始回放并指定回调数据格式 入参
typedef struct tagNET_IN_PLAYBACK_BY_DATA_TYPE
{
    DWORD					dwSize;                 // 结构体大小
    int						nChannelID;             // 通道编号
    NET_TIME				stStartTime;            // 开始时间
    NET_TIME				stStopTime;             // 结束时间
    HWND					hWnd;                   // 播放窗格, 可为NULL
    fDownLoadPosCallBack	cbDownLoadPos;			// 进度回调
    LDWORD					dwPosUser;              // 进度回调用户信息
    fDataCallBack			fDownLoadDataCallBack;  // 数据回调
    EM_REAL_DATA_TYPE		emDataType;             // 回调的数据类型 
    LDWORD					dwDataUser;             // 数据回调用户信息
    int						nPlayDirection;         // 播放方向, 0:正放; 1:倒放;
}NET_IN_PLAYBACK_BY_DATA_TYPE;

// 开始回放并指定回调数据格式 出参
typedef struct tagNET_OUT_PLAYBACK_BY_DATA_TYPE
{
    DWORD               	dwSize;                 // 结构体大小  
}NET_OUT_PLAYBACK_BY_DATA_TYPE;

// 指定回调数据格式  开始回放,  数据回调函数 fDownLoadDataCallBack 中得到的码流类型为 emDataType 所指定的类型
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByDataType(LLONG lLoginID, const NET_IN_PLAYBACK_BY_DATA_TYPE* pstInParam, NET_OUT_PLAYBACK_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// 开始下载并指定回调数据格式 入参
typedef struct tagNET_IN_DOWNLOAD_BY_DATA_TYPE
{
    DWORD                       dwSize;                 // 结构体大小
    int                         nChannelID;             // 通道编号
    EM_QUERY_RECORD_TYPE        emRecordType;           // 录像类型
    char*                       szSavedFileName;        // 下载的文件路径
    NET_TIME                    stStartTime;            // 开始时间
    NET_TIME                    stStopTime;             // 结束时间
    fTimeDownLoadPosCallBack    cbDownLoadPos;          // 进度回调
    LDWORD                      dwPosUser;              // 进度回调用户信息
    fDataCallBack               fDownLoadDataCallBack;  // 数据回调
    EM_REAL_DATA_TYPE           emDataType;             // 回调的数据类型 
    LDWORD                      dwDataUser;             // 数据回调用户信息
}NET_IN_DOWNLOAD_BY_DATA_TYPE;

// 开始下载并指定回调数据格式 出参
typedef struct tagNET_OUT_DOWNLOAD_BY_DATA_TYPE
{
    DWORD               dwSize;                 // 结构体大小  
}NET_OUT_DOWNLOAD_BY_DATA_TYPE;

// 指定码流类型 开始下载, 下载得到的文件和数据回调函数 fDownLoadDataCallBack 中得到的码流类型均为 emDataType 所指定的类型
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByDataType(LLONG lLoginID, const NET_IN_DOWNLOAD_BY_DATA_TYPE* pstInParam, NET_OUT_DOWNLOAD_BY_DATA_TYPE* pstOutParam, DWORD dwWaitTime);


// CLIENT_AdaptiveDownloadByTime 入参
typedef struct tagNET_IN_ADAPTIVE_DOWNLOAD_BY_TIME
{
	DWORD                       dwSize;                 // 结构体大小
	int                         nChannelID;             // 通道编号
	EM_QUERY_RECORD_TYPE        emRecordType;           // 录像类型
	char*                       szSavedFileName;        // 下载的文件路径
	NET_TIME                    stStartTime;            // 开始时间
	NET_TIME                    stStopTime;             // 结束时间
	fTimeDownLoadPosCallBack    cbDownLoadPos;          // 进度回调
	LDWORD                      dwPosUser;              // 进度回调用户信息
	fDataCallBack               fDownLoadDataCallBack;  // 数据回调
	EM_REAL_DATA_TYPE           emDataType;             // 回调的数据类型 
	LDWORD                      dwDataUser;             // 数据回调用户信息
	char						szEncryptPasswd[64];	// 加密录像密码，密码长度不小于8
}NET_IN_ADAPTIVE_DOWNLOAD_BY_TIME;

// CLIENT_AdaptiveDownloadByTime 出参
typedef struct tagNET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME
{
	DWORD               dwSize;                 // 结构体大小  
}NET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME;

// 自适应速度的下载  需要调用 CLIENT_StopDownload 来释放下载资源
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AdaptiveDownloadByTime( LLONG lLoginID, const NET_IN_ADAPTIVE_DOWNLOAD_BY_TIME* pstInParam, NET_OUT_ADAPTIVE_DOWNLOAD_BY_TIME* pstOutParam, DWORD dwWaitTime );


// CLIENT_DownloadByFileSelfAdapt 入参
typedef struct tagNET_IN_DOWNLOAD_BYFILE_SELFADAPT
{
	DWORD                       dwSize;                 // 结构体大小
	int                         nChannelID;             // 通道编号
	EM_QUERY_RECORD_TYPE        emRecordType;           // 录像类型
	char                       	szFileName[MAX_PATH];   // 下载的文件路径
	unsigned int        		size;                   // 文件长度, 单位为Kbyte
	fDownLoadPosCallBack    	cbDownLoadPos;          // 进度回调
	LDWORD                      dwPosUser;              // 进度回调用户信息
	fDataCallBack               fDownLoadDataCallBack;  // 数据回调
	EM_REAL_DATA_TYPE           emDataType;             // 回调的数据类型 
	LDWORD                      dwDataUser;             // 数据回调用户信息
}NET_IN_DOWNLOAD_BYFILE_SELFADAPT;

// CLIENT_DownloadByFileSelfAdapt 出参
typedef struct tagNET_OUT_DOWNLOAD_BYFILE_SELFADAPT
{
	DWORD               dwSize;                 // 结构体大小  
}NET_OUT_DOWNLOAD_BYFILE_SELFADAPT;

// 自适应速度的按文件下载录像, pstInParam 和pstOutParam 资源由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadByFileSelfAdapt(LLONG lLoginID, const NET_IN_DOWNLOAD_BYFILE_SELFADAPT* pstInParam, NET_OUT_DOWNLOAD_BYFILE_SELFADAPT* pstOutParam, DWORD dwWaitTime);


//-------------------------------------------------------------------

//局部放大(pSrcRect内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayRegion(LLONG lPlayHandle,DWORD nRegionNum, DH_DISPLAYRREGION *pSrcRect, HWND hDestWnd, BOOL bEnable);

// 开始查找录像文件帧信息(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindFrameInfo(LLONG lLoginID, NET_IN_FIND_FRAMEINFO_PRAM *pInParam, NET_OUT_FIND_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// 查找录像文件帧信息，按指定信息条数查询(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextFrameInfo(LLONG lFindHandle, NET_IN_FINDNEXT_FRAMEINFO_PRAM *pInParam, NET_OUT_FINDNEXT_FRAMEINFO_PRAM* pOutParam, int nWaitTime);

// 设置标签信息
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamSetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// 获取标签信息
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamGetTags(LLONG lFindHandle, NET_IN_FILE_STREAM_GET_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// 清除标签信息
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamClearTags(LLONG lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_TAGS_INFO *pOutParam, int nWaitTime);

// 过滤查询标签信息
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FileStreamFilterTags(LLONG lFindHandle, NET_IN_FILE_STREAM_FILTER_TAGS_INFO *pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO *pOutParam, int nWaitTime);

// 结束录像文件查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindFrameInfoClose(LLONG lFindHandle);
// pInParam, pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamMotionMatch(LLONG lLoginID, const NET_IN_MOTIONMATCH_PARAM *pInParam, NET_OUT_MOTIONMATCH_PARAM* pOutParam, int nWaitTime);

// 查询标签信息, lFindHandle通过CLIENT_FindFrameInfo获取，查询到的标签是CLIENT_TagManagerStartTag/CLIENT_TagManagerSetSubTag/CLIENT_TagManagerStopTag设置的
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FileStreamFindTags(LLONG lFindHandle, NET_IN_FINDTAGS_INFO *pInParam, NET_OUT_FINDTAGS_INFO *pOutParam, int nWaitTime);

// 获取标签状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerGetTagState(LLONG lLoginID, NET_IN_TAGMANAGER_GETTAGSTATE_INFO *pInParam, NET_OUT_TAGMANAGER_GETTAGSTATE_INFO *pOutParam, int nWaitTime);

// 开始打标签
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStartTag(LLONG lLoginID, NET_IN_TAGMANAGER_STARTTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STARTTAG_INFO *pOutParam, int nWaitTime);

// 打子标签, 子标签个数不应超过20，否则失败
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerSetSubTag(LLONG lLoginID, NET_IN_TAGMANAGER_SETSUBTAG_INFO *pInParam, NET_OUT_TAGMANAGER_SETSUBTAG_INFO *pOutParam, int nWaitTime);

// 停止打标签
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStopTag(LLONG lLoginID, NET_IN_TAGMANAGER_STOPTAG_INFO *pInParam, NET_OUT_TAGMANAGER_STOPTAG_INFO *pOutParam, int nWaitTime);

// 获取标签查询能力
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerGetCaps(LLONG lLoginID, NET_IN_TAGMANAGER_GETCAPS_INFO *pInParam, NET_OUT_TAGMANAGER_GETCAPS_INFO *pOutParam, int nWaitTime);

// 开始查询标签信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_TagManagerStartFind(LLONG lLoginID, NET_IN_TAGMANAGER_STARTFIND_INFO *pInParam, NET_OUT_TAGMANAGER_STARTFIND_INFO *pOutParam, int nWaitTime);

// 获取标签查询结果信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerDoFind(LLONG lFindID, NET_IN_TAGMANAGER_DOFIND_INFO *pInParam, NET_OUT_TAGMANAGER_DOFIND_INFO *pOutParam, int nWaitTime);

// 停止查询标签信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TagManagerStopFind(LLONG lFindID);


//------------------------------------------------------------------------

// 设置报警回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBack(fMessCallBack cbMessage,LDWORD dwUser);

CLIENT_NET_API void CALL_METHOD CLIENT_SetDVRMessCallBackEx1(fMessCallBackEx1 cbMessage,LDWORD dwUser);

// 向设备订阅报警
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListen(LLONG lLoginID);

// 向设备订阅报警--扩展
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartListenEx(LLONG lLoginID);

// 停止订阅报警
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListen(LLONG lLoginID);

// 报警复位
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AlarmReset(LLONG lLoginID, DWORD dwAlarmType, int nChannel, void* pReserved = NULL, int nWaitTime = 1000);

//------------------------------------------------------------------------

// CLIENT_SetServerParam 接口参数
typedef struct tagNET_ACTIVE_RIGST_PARAMS
{
    DWORD               dwSize;             // 结构体大小
    BOOL                bManualLogout;      // 是否手动登出（主动注册的设备断线后默认是SDK自动登出）
} NET_ACTIVE_RIGST_PARAMS;


// 设置主动注册的全局参数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetServerParam(NET_ACTIVE_RIGST_PARAMS* pParam);

// 主动注册功能,启动服务；nTimeout参数已无效(默认为设备断线后SDK内部登出)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ListenServer(char* ip, WORD port, int nTimeout, fServiceCallBack cbListen, LDWORD dwUserData);

// 停止服务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopListenServer(LLONG lServerHandle);

// 响应设备的注册请求
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResponseDevReg(char *devSerial, char* ip, WORD port, BOOL bAccept);

//------------------------------------------------------------------------

//------------------------------------------------------------------------

// 重定向服务器回调函数原形
// 参数说明：
// lDevHandle : 设备句柄
// pDevIp : 设备ip
// wDevPort : 设备端口
// dwUserData : 用户参数
typedef int (CALLBACK *fRedirectServerCallBack)( LLONG lDevHandle, char *pDevIp, WORD wDevPort, LDWORD dwUserData);

// 开启重定向服务
// 参数说明：
// Ip : 开启服务的IP
// port : 开启服务端口
// fRedirectServerCallBack : 设备重定向回调函数
// dwUserData : 用户参数, 与fRedirectServerCallBack绑定
// 返回值: 服务句柄
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRedirectService(char* ip, WORD port,fRedirectServerCallBack cbListen, LDWORD dwUserData);

// 停止重定向服务
// lServerHandle : 服务句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRedirectService(LLONG lServerHandle);

// 设置重定向服务器的IP和Port
// lDevHandle : 重定向设备句柄
// ARSIP : 重定向设备IP
// ARSPort : 重定向设备端口
// nRetry : 设备主动注册尝试次数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAutoRegisterServerInfo(LLONG lDevHandle, char* ARSIP, WORD ARSPort,WORD nRetry);

//------------------------------------------------------------------------

//------------------------------------------------------------------------
// 请求设备推流的码流类型
typedef enum tagEM_DEV_PUSH_STREAM_TYPE
{
	EM_DEV_PUSH_STREAM_TYPE_MAJOR,	// 主码流
	EM_DEV_PUSH_STREAM_TYPE_MINOR1, // 辅码流1
	EM_DEV_PUSH_STREAM_TYPE_MINOR2, // 辅码流2
}EM_DEV_PUSH_STREAM_TYPE;

// 请求设备开始推流入参
typedef struct tagNET_IN_REQUEST_START_PUSH_STREAM_TYPE
{
	DWORD						dwSize;				// 结构体大小
	int							nChannelID;			// 通道号
	EM_DEV_PUSH_STREAM_TYPE		emStreamType;		// 码流类型
	char						szSSID[MAX_PUSH_STREAM_AUTH_SSID];	// 推流鉴权ID，64位长度
	char						szReciveServerIP[DH_MAX_IPADDR_LEN_EX];	// 收流服务器IP
	int							nReciveServerPort;	// 收流服务器端口
}NET_IN_REQUEST_START_PUSH_STREAM_TYPE;

// 请求设备开始推流的出参
typedef struct tagNET_OUT_REQUEST_START_PUSH_STREAM_TYPE
{
	DWORD dwSize;	// 结构体大小
}NET_OUT_REQUEST_START_PUSH_STREAM_TYPE;

typedef struct tagNET_IN_REQUEST_STOP_PUSH_STREAM_TYPE
{
	DWORD	dwSize;	// 结构体大小
	char	szSSID[MAX_PUSH_STREAM_AUTH_SSID];	// 推流鉴权ID，64位长度
}NET_IN_REQUEST_STOP_PUSH_STREAM_TYPE;

typedef struct tagNET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE
{
	DWORD	dwSize;	// 结构体大小
}NET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE;

// 查询设备的某一路推流信息入参
typedef struct tagNET_IN_QUERY_PUSH_STREAM_INFO
{
	DWORD	dwSize;	// 结构体大小
	char	szSSID[MAX_PUSH_STREAM_AUTH_SSID];	// 推流鉴权ID，64位长度
}NET_IN_QUERY_PUSH_STREAM_INFO;

// 查询设备的某一路推流信息出参
typedef struct tagNET_OUT_QUERY_PUSH_STREAM_INFO
{
	DWORD	dwSize;	// 结构体大小
	char	szReciveServerIP[DH_MAX_IPADDR_LEN_EX]; // 收流服务器IP
	int		nReciveServerPort;						// 收流服务器端口
}NET_OUT_QUERY_PUSH_STREAM_INFO;

// 请求设备推流到收流服务器 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ReqDevStartPushStream(LLONG lLoginID,const NET_IN_REQUEST_START_PUSH_STREAM_TYPE* pInParam, NET_OUT_REQUEST_START_PUSH_STREAM_TYPE* pOutParam, int nWaitTime);

// 请求设备停止推流到收流服务器
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ReqDevStopPushStream(LLONG lLoginID,const NET_IN_REQUEST_STOP_PUSH_STREAM_TYPE* pInParam, NET_OUT_REQUEST_STOP_PUSH_STREAM_TYPE* pOutParam, int nWaitTime);

// 查询设备推流信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevPushStreamInfo(LLONG lLoginID, const NET_IN_QUERY_PUSH_STREAM_INFO* pInParam, NET_OUT_QUERY_PUSH_STREAM_INFO* pOutParam, int nWaitTime);
//------------------------------------------------------------------------

//------------------------------------------------------------------------
// 推流设备的链接状态
typedef enum tagEM_PUSH_STREAM_CONNECT_STATE
{
	EM_PUSH_STREAM_CONNECT_STATE_SETUP,		// 推流客户端连接建立
	EM_PUSH_STREAM_CONNECT_STATE_TEARDOWN,	// 推流客户端连接关闭
}EM_PUSH_STREAM_CONNECT_STATE;

// 推流设备的状态回调:链接建立，链接断开
// lClientHandle : 客户端链接句柄
// clientIP : 客户端链接IP
// clientPort : 客户端链接端口
// clientConState : 客户端链接状态
// dwUserData : 用户参数 
typedef void (CALLBACK *fStreamClientState)(LLONG lClientHandle, char* clientIP, int clientPort, EM_PUSH_STREAM_CONNECT_STATE clientConState, LDWORD dwUserData);

// 推流数据信息回调 
// 参数说明:
// lClientHandle : 客户端链接句柄
// pBuffer : 码流数据
// dwBufSize : 码流数据大小
// dwUserData : 用户参数 
typedef void (CALLBACK *fStreamDataComing)(LLONG lClientHandle, BYTE *pBuffer, DWORD dwBufSize,LDWORD dwUserData);

// 开启收流服务
// 参数说明:
// ip : ip地址
// port : 监听端口
// cbClientState: 客户端链接状态
// dwUserData1: 用户参数，与cbClientState绑定
// cbLiveStreamData: 码流回调函数
// dwUserData2: 用户参数，与cbLiveStreamData绑定
// 返回值: 服务句柄
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartReceiveStreamService(char *ip, WORD port,fStreamClientState cbClientState,LDWORD dwUserData1, fStreamDataComing cbLiveStreamData, LDWORD dwUserData2);

// 关闭收流服务
// 参数说明：
// lServerHandle : 收流服务句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopReceiveStreamService(LLONG lServerHandle);

// 停止某一路设备的推流
// 参数说明：
// lClientHandle : 推流连接句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopStreamClient(LLONG lClientHandle);

// 设置推流链接校验的SSID
// 参数说明：
// lServerHandle : 收流服务句柄
// pSSID : 推流客户端链接鉴权SSID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetStreamClientAuthID(LLONG lServerHandle, const char* pSSID);

//------------------------------------------------------------------------

// 报警上传功能,启动服务；dwTimeOut参数已无效
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartService(WORD wPort, char *pIp = NULL, fServiceCallBack pfscb = NULL, DWORD dwTimeOut = 0xffffffff, LDWORD dwUserData = 0);

// 停止服务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopService(LLONG lHandle);

//------------------------------------------------------------------------

// 设置语音对讲模式,客户端方式还是服务器方式(pValue内存由用户申请释放，大小参照EM_USEDEV_MODE对应的结构体)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceMode(LLONG lLoginID, EM_USEDEV_MODE emType, void* pValue);

// 打开语音对讲
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkEx(LLONG lLoginID, pfAudioDataCallBack pfcb, LDWORD dwUser);

// 对讲方向
enum EM_TALK_DIRECTION
{
	EM_TALK_DIRECTION_UNKNOWN = 0,					// 未知
	EM_TALK_DIRECTION_UNI,							// 单向对讲，包括喊话：客户端到设备
	EM_TALK_DIRECTION_BILATERAL,					// 双向对讲
	EM_TALK_DIRECTION_LISTEN,						// 单向监听：设备到客户端
};

// 获取对讲方向:lTalkHandle 为 CLIENT_StartTalkEx返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTalkDirection(LLONG lTalkHandle, EM_TALK_DIRECTION* pDirection);

// 获取对讲方向
// 开始PC端录音
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStart();

// 结束PC端录音
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStop();


// 开始PC端录音(对CLIENT_RecordStart()扩展)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStartEx(LLONG lLoginID);

// 结束PC端录音(对CLIENT_RecordStop()扩展)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordStopEx(LLONG lLoginID);


// 发送语音数据到设备(pSendBuf内存由用户申请释放)
CLIENT_NET_API LONG  CALL_METHOD CLIENT_TalkSendData(LLONG lTalkHandle, char *pSendBuf, DWORD dwBufSize);

// 解码音频数据(pAudioDataBuf内存由用户申请释放)
CLIENT_NET_API void CALL_METHOD CLIENT_AudioDec(char *pAudioDataBuf, DWORD dwBufSize);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioDecEx(LLONG lTalkHandle, char *pAudioDataBuf, DWORD dwBufSize);

// 设置语音对讲的音量
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAudioClientVolume(LLONG lTalkHandle, WORD wVolume);

// 停止语音对讲
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalkEx(LLONG lTalkHandle);

// 添加设备到广播组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastAddDev(LLONG lLoginID);

// 从广播组中删除设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AudioBroadcastDelDev(LLONG lLoginID);

// 音频编码--初始化(特定标准格式->私有格式)
CLIENT_NET_API int  CALL_METHOD CLIENT_InitAudioEncode(DH_AUDIO_FORMAT aft);

// 音频编码--数据编码(lpInBuf, lpOutBuf内存由用户申请释放)
CLIENT_NET_API int    CALL_METHOD    CLIENT_AudioEncode(LLONG lTalkHandle, BYTE *lpInBuf, DWORD *lpInLen, BYTE *lpOutBuf, DWORD *lpOutLen);

// 音频编码--完成退出
CLIENT_NET_API int    CALL_METHOD    CLIENT_ReleaseAudioEncode();

//------------------------------------------------------------------------

// 查询设备日志(pLogBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLog(LLONG lLoginID, char *pLogBuffer, int maxlen, int *nLogBufferlen, int waittime=3000);

// 查询设备日志，以分页方式查询(pQueryParam, pLogBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceLog(LLONG lLoginID, QUERY_DEVICE_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, int waittime=3000);

// 查询设备日志条数(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevLogCount(LLONG lLoginID, NET_IN_GETCOUNT_LOG_PARAM *pInParam, NET_OUT_GETCOUNT_LOG_PARAM* pOutParam , int waittime=3000);

// 设置日志回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubscribeLogCallBack(fSubLogDataCallBack pLogDataCB, LDWORD dwUser);

// 订阅设备日志
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartSubscribeLog(LLONG lLoginID, int nWaittime, void* pReserved);

// 停止订阅设备日志
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSubscribeLog(LLONG lSubLogHandle);

// 查道通道录像状态(pRSBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, int waittime=1000);

// 查道辅码流通道录像状态（返回字节数与通道数对应, 每个字节表示对应通道的辅码流录像控制状态,0-关闭,1-手动,2-自动,pRSBuffer内存由用户申请释放）
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryExtraRecordState(LLONG lLoginID, char *pRSBuffer, int maxlen, int *nRSBufferlen, void *pReserved, int waittime=1000);

// 查询设备状态(pBuf内存由用户申请释放,根据nType类型确定相应结构体，至少需要申请结构体大小的内存)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDevState(LLONG lLoginID, int nType, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// 查询远程设备状态,nType为DH_DEVSTATE_ALARM_FRONTDISCONNECT时，通道号从1开始(pBuf内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRemotDevState(LLONG lLoginID, int nType, int nChannelID, char *pBuf, int nBufLen, int *pRetLen, int waittime=1000);

// 查询系统能力信息(pSysInfoBuffer内存由用户申请释放，大小参照DH_SYS_ABILITY对应的结构体，若nSystemType为 ABILITY_DYNAMIC_CONNECT ，内存大小至少为sizeof(BOOL),若nSystemType为ABILITY_TRIGGER_MODE，内存大小为sizeof(int))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemInfo(LLONG lLoginID, int nSystemType, char *pSysInfoBuffer, int maxlen, int *nSysInfolen, int waittime=1000);

// 新系统能力查询接口，查询系统能力信息(以Json格式，具体见配置SDK)(szOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNewSystemInfo(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=1000);

// 获取通道码流
CLIENT_NET_API LONG  CALL_METHOD CLIENT_GetStatiscFlux(LLONG lLoginID, LLONG  lPlayHandle);

// 获取云台信息(lpOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetPtzOptAttr(LLONG lLoginID,DWORD dwProtocolIndex,LPVOID lpOutBuffer,DWORD dwBufLen,DWORD *lpBytesReturned,int waittime=500);

// 设备能力类型, 对应CLIENT_GetDevCaps接口
#define NET_DEV_CAP_SEQPOWER            0x01                // 电源时序器能力, pInBuf=NET_IN_CAP_SEQPOWER*, pOutBuf=NET_OUT_CAP_SEQPOWER*
#define NET_ENCODE_CFG_CAPS             0x02                // 设备编码配置对应能力, pInBuf=NET_IN_ENCODE_CFG_CAPS*, pOutBuf= NET_OUT_ENCODE_CFG_CAPS*
#define NET_VIDEOIN_FISHEYE_CAPS        0x03                // 鱼眼能力, pInBuf=NET_IN_VIDEOIN_FISHEYE_CAPS*, pOutBuf=NET_OUT_VIDEOIN_FISHEYE_CAPS*
#define NET_COMPOSITE_CAPS              0x04                // 根据指定的窗口号预先获取融合后的能力集, pInBuf=NET_IN_COMPOSITE_CAPS*, pOutBuf=NET_OUT_COMPOSITE_CAPS*
#define NET_VIDEO_DETECT_CAPS           0x05                // 获取视频检测输入能力集,pInBuf=NET_IN_VIDEO_DETECT_CAPS* , pOutBuf=NET_OUT_VIDEO_DETECT_CAPS*
#define NET_THERMO_GRAPHY_CAPS          0x06                // 热成像摄像头属性能力,pInBuf=NET_IN_THERMO_GETCAPS*, pOutBuf=NET_OUT_THERMO_GETCAPS*
#define NET_RADIOMETRY_CAPS             0x07                // 热成像测温全局配置能力,pInBuf=NET_IN_RADIOMETRY_GETCAPS*, pOutBuf=NET_OUT_RADIOMETRY_GETCAPS*
#define NET_POS_CAPS                    0x08                // POS机能力,pInBuf = NET_IN_POS_GETCAPS *, pOutBuf = NET_OUT_POS_GETCAPS *
#define NET_USER_MNG_CAPS               0x09                // 用户管理能力, pInBuf = NET_IN_USER_MNG_GETCAPS *, pOutBuf = NET_OUT_USER_MNG_GETCAPS *
#define NET_MEDIAMANAGER_CAPS           0x0a                // 获取 VideoInput 的各个能力项,pInBuf=NET_IN_MEDIAMANAGER_GETCAPS*, pOutBuf=NET_OUT_MEDIAMANAGER_GETCAPS*
#define NET_VIDEO_MOSAIC_CAPS           0x0b                // 获取通道马赛克叠加能力,pInBuf=NET_IN_MEDIA_VIDEOMOSAIC_GETCAPS*, pOutBuf=NET_OUT_MEDIA_VIDEOMOSAIC_GETCAPS*
#define NET_SNAP_CFG_CAPS               0x0c                // 设备抓图配置对应能力, pInBuf=NET_IN_SNAP_CFG_CAPS*, pOutBuf= NET_OUT_SNAP_CFG_CAPS*
#define NET_VIDEOIN_CAPS                0x0d                // 设备视频输出能力, pInBUf = NET_IN_VIDEOIN_CAPS*, pOutBuf = NET_OUT_VIDEOIN_CAPS*
#define NET_FACE_BOARD_CAPS             0x0e                // 面板设备能力集, pInBuf = NET_IN_FACEBOARD_CAPS*, pOutBuf = NET_OUT_FACEBOARD_CAPS*
#define NET_EXTERNALSENSOR_CAPS         0x0f                // 外部传感器管理能力集，pInBuf = NET_IN_EXTERNALSENSOR_CAPS*, pOutBuf = NET_OUT_EXTERNALSENSOR_CAPS*
#define NET_VIDEO_IMAGECONTROL_CAPS     0x10                // 图像旋转设置能力, pInBuf = NET_IN_VIDEO_IMAGECONTROL_CAPS*, pOutBuf = NET_OUT_VIDEO_IMAGECONTROL_CAPS*
#define NET_VIDEOIN_EXPOSURE_CAPS       0x11                // 曝光设置能力, pInBuf = NET_IN_VIDEOIN_EXPOSURE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_EXPOSURE_CAPS*
#define NET_VIDEOIN_DENOISE_CAPS        0x12                // 降噪能力, pInBuf = NET_IN_VIDEOIN_DENOISE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DENOISE_CAPS*
#define NET_VIDEOIN_BACKLIGHT_CAPS      0x13                // 背光设置能力, pInBuf = NET_IN_VIDEOIN_BACKLIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_BACKLIGHT_CAPS*
#define NET_VIDEOIN_WHITEBALANCE_CAPS   0x14                // 白平衡设置能力, pInBuf = NET_IN_VIDEOIN_WHITEBALANCE_CAPS*, pOutBuf = NET_OUT_VIDEOIN_WHITEBALANCE_CAPS*
#define NET_VIDEOIN_DAYNIGHT_CAPS       0x15                // 球机机芯日夜设置能力, pInBuf = NET_IN_VIDEOIN_DAYNIGHT_CAPS*, pOutBuf = NET_OUT_VIDEOIN_DAYNIGHT_CAPS*
#define NET_VIDEOIN_ZOOM_CAPS           0x16                // 变倍设置能力, pInBuf = NET_IN_VIDEOIN_ZOOM_CAPS*, pOutBuf = NET_OUT_VIDEOIN_ZOOM_CAPS*
#define NET_VIDEOIN_FOCUS_CAPS          0x17                // 聚焦设置能力, pInBuf = NET_IN_VIDEOIN_FOCUS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_FOCUS_CAPS*
#define NET_VIDEOIN_SHARPNESS_CAPS      0x18                // 锐度设置能力, pInBuf = NET_IN_VIDEOIN_SHARPNESS_CAPS*, pOutBuf = NET_OUT_VIDEOIN_SHARPNESS_CAPS*
#define NET_VIDEOIN_COLOR_CAPS          0x19                // 图像设置能力, pInBuf = NET_IN_VIDEOIN_COLOR_CAPS*, pOutBuf = NET_OUT_VIDEOIN_COLOR_CAPS*
#define NET_GET_MASTERSLAVEGROUP_CAPS   0x1a                // 获取跟踪业务能力, pInBuf = NET_IN_GET_MASTERSLAVEGROUP_CAPS*, pOutBuf = NET_OUT_GET_MASTERSLAVEGROUP_CAPS*
#define NET_FACERECOGNITIONSE_CAPS      0x1b                // 人脸识别服务器能力查询 pInBuf = NET_IN_FACERECOGNITIONSERVER_CAPSBILITYQUERY, pOutBuf = NET_OUT_FACERECOGNITIONSERVER_CAPSBILITYQUERY *
#define NET_STORAGE_CAPS                0x1c                // 获取存储能力集, pInBuf = NET_IN_STORAGE_CAPS*, pOutBuf = NET_OUT_STORAGE_CAPS*
#define NET_VIDEOIN_RAWFRAME_CAPS       0x1d                // 获取视频输入扩展能力集, pInBuf = NET_IN_VIDEOIN_RAWFRAME_CAPS*, pOutBuf = NET_OUT_VIDEOIN_RAWFRAME_CAPS*
#define NET_COAXIAL_CONTROL_IO_CAPS     0x1e                // 获取同轴IO控制能力, pInBuf = NET_IN_GET_COAXIAL_CONTROL_IO_CAPS*, pOutBuf = NET_OUT_GET_COAXIAL_CONTROL_IO_CAPS*
#define NET_FACEINFO_CAPS               0x1f                // 获得人脸门禁控制器能力集, pInBuf = NET_IN_GET_FACEINFO_CAPS*, pOutBuf = NET_OUT_GET_FACEINFO_CAPS*
#define NET_ACCESSCONTROL_CAPS          0x20                // 获取门禁能力, pInBuf = NET_IN_AC_CAPS*, pOutBuf = NET_OUT_AC_CAPS*
#define NET_COAXIAL_CONTROL_IO_STATUS   0x21                // 获取同轴IO白光灯和喇叭状态, pInBuf = NET_IN_GET_COAXIAL_CONTROL_IO_STATUS*, pOutBuf = NET_OUT_GET_COAXIAL_CONTROL_IO_STATUS*
#define NET_LIGHTINGCONTROL_CAPS        0x22                // 获取补光灯能力(IPC/SD使用), pInBuf =NET_IN_LIGHTINGCONTROL_CAPS* ,pOutBuf=NET_OUT_LIGHTINGCONTROL_CAPS*
#define NET_SUPPORT_GET_AUDIO_DECODE_CAPS   0x23            // 获取设备是否支持音频解码能力获取, pInBuf =NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS* ,pOutBuf=NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS*
#define NET_UNIFIEDINFOCOLLECT_CAPS     0x24                // 获取设备是否支持DMSS专用协议能力,pInBuf = NET_IN_UNIFIEDINFOCOLLECT_CAPS*, pOutBuf = NET_OUT_UNIFIEDINFOCOLLECT_CAPS*
#define NET_EXALARMBOX_CAPS             0x25                // 获取某个扩展报警盒的能力集, pInBuf = NET_IN_EXALARMBOX_CAPS*, pOutBuf = NET_OUT_EXALARMBOX_CAPS*
#define NET_ALARMBOXMANAGER_CAPS        0x26                // 获取报警盒子管理器能力集，pInBuf = NET_IN_ALARMBOXMANAGER_CAPS*, pOutBuf = NET_OUT_ALARMBOXMANAGER_CAPS* 
#define NET_GET_AUDIO_DETECT_CAPS       0x27                // 获取音频输入能力集, pInBuf = NET_IN_GET_AUDIO_DETECT_CAPS*, pOutBuf = NET_OUT_GET_AUDIO_DETECT_CAPS*                   
#define NET_SUPPORT_FACEDB_DOWNLOAD     0x28                // 获取是否支持远程人脸库下载, pInBuf = NET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS*, pOutBuf = NET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS*
#define NET_GET_LENS_FUNC_CAPS          0x29                // 获取角度调节能力集, pInBuf = NET_IN_GET_LENS_FUNC_CAPS*, pOutBuf = NET_OUT_GET_LENS_FUNC_CAPS*
#define NET_VIDEO_IN_DEFOG_CAPS         0x30                // 获取视频透雾能力集, pInBuf = NET_IN_VIDEO_IN_DEFOG_CAPS*, pOutBuf = NET_OUT_VIDEO_IN_DEFOG_CAPS*       
#define NET_DIAGNOSIS_CAPS				0x31				// 获取故障诊断能力，pInBuf = NET_IN_DIAGNOSIS_CAPS*, pOutBuf = NET_OUT_DIAGNOSIS_CAPS*
#define NET_LOWRATEWPAN_CAPS			0x32				// 获取低功率WPAN能力集，pInBuf = NET_IN_LOWRATEWPAN_CAPS*, pOutBuf = NET_OUT_LOWRATEWPAN_CAPS*
#define NET_GET_FILE_TRANSFER_CAPS      0x33                // 获取远程文件下载能力集, pInBuf = NET_IN_GET_FILE_TRANSFER_CAPS*, pOutBuf = NET_OUT_GET_FILE_TRANSFER_CAPS*

// 获取设备能力(pInBuf, pOutBuf内存由用户申请释放，根据nType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevCaps(LLONG lLoginID, int nType, void* pInBuf, void* pOutBuf, int nWaitTime);

// 设备信息类型,对应CLIENT_QueryDevInfo接口
#define NET_QUERY_DEV_STORAGE_NAMES                 0x01                // 查询设备的存储模块名列表 , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
#define NET_QUERY_DEV_STORAGE_INFOS                 0x02                // 查询设备的存储模块信息列表, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
#define NET_QUERY_RECENCY_JNNCTION_CAR_INFO         0x03                // 查询最近的卡口车辆信息接口, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
#define NET_QUERY_LANES_STATE                       0x04                // 查询车道信息,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
#define NET_QUERY_DEV_FISHEYE_WININFO               0x05                // 查询鱼眼窗口信息 , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
#define NET_QUERY_DEV_REMOTE_DEVICE_INFO            0x06                // 查询远程设备信息 , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
#define NET_QUERY_SYSTEM_INFO                       0x07                // 查询设备系统信息 , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*
#define NET_QUERY_REG_DEVICE_NET_INFO               0x08                // 查询主动注册设备的网络连接 , pInBuf=NET_IN_REGDEV_NET_INFO * , pOutBuf=NET_OUT_REGDEV_NET_INFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_PRESET          0x09                // 查询热成像预设信息 , pInBuf= NET_IN_THERMO_GET_PRESETINFO*, pOutBuf= NET_OUT_THERMO_GET_PRESETINFO *
#define NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION       0x0a                // 查询热成像感兴趣区域信息,pInBuf= NET_IN_THERMO_GET_OPTREGION*, pOutBuf= NET_OUT_THERMO_GET_OPTREGION *
#define NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO      0x0b                // 查询热成像外部系统信息, pInBuf= NET_IN_THERMO_GET_EXTSYSINFO*, pOutBuf= NET_OUT_THERMO_GET_EXTSYSINFO *
#define NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER       0x0c                // 查询测温点的参数值, pInBuf= NET_IN_RADIOMETRY_GETPOINTTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETPOINTTEMPER *
#define NET_QUERY_DEV_RADIOMETRY_TEMPER             0x0d                // 查询测温项的参数值, pInBuf= NET_IN_RADIOMETRY_GETTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETTEMPER *
#define NET_QUERY_GET_CAMERA_STATE                  0x0e                // 获取摄像机状态, pInBuf= NET_IN_GET_CAMERA_STATEINFO*, pOutBuf= NET_OUT_GET_CAMERA_STATEINFO *
#define NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE   0x0f                // 获取远程通道音频编码方式, pInBuf= NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO*, pOutBuf= NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO *
#define NET_QUERY_GET_COMM_PORT_INFO                0x10                // 获取设备串口信息, pInBuf=NET_IN_GET_COMM_PORT_INFO* , pOutBuf=NET_OUT_GET_COMM_PORT_INFO* 
#define NET_QUERY_GET_LINKCHANNELS                  0x11                // 查询某视频通道的关联通道列表,pInBuf=NET_IN_GET_LINKCHANNELS* , pOutBuf=NET_OUT_GET_LINKCHANNELS*
#define NET_QUERY_GET_VIDEOOUTPUTCHANNELS           0x12                // 获取解码通道数量统计信息, pInBuf=NET_IN_GET_VIDEOOUTPUTCHANNELS*, pOutBuf=NET_OUT_GET_VIDEOOUTPUTCHANNELS*
#define NET_QUERY_GET_VIDEOINFO                     0x13                // 获取解码通道信息, pInBuf=NET_IN_GET_VIDEOINFO*, pOutBuf=NET_OUT_GET_VIDEOINFO*
#define NET_QUERY_GET_ALLLINKCHANNELS               0x14                // 查询全部视频关联通道列表,pInBuf=NET_IN_GET_ALLLINKCHANNELS* , pOutBuf=NET_OUT_GET_ALLLINKCHANNELS*
#define NET_QUERY_VIDEOCHANNELSINFO                 0x15                // 查询视频通道信息,pInBuf=NET_IN_GET_VIDEOCHANNELSINFO* , pOutBuf=NET_OUT_GET_VIDEOCHANNELSINFO*
#define NET_QUERY_TRAFFICRADAR_VERSION              0x16                // 查询雷达设备版本,pInBuf=NET_IN_TRAFFICRADAR_VERSION* , pOutBuf=NET_OUT_TRAFFICRADAR_VERSION*
#define NET_QUERY_WORKGROUP_NAMES                   0x17                // 查询所有的工作目录组名,pInBuf=NET_IN_WORKGROUP_NAMES* , pOutBuf=NET_OUT_WORKGROUP_NAMES*
#define NET_QUERY_WORKGROUP_INFO                    0x18                // 查询工作组信息,pInBuf=NET_IN_WORKGROUP_INFO* , pOutBuf=NET_OUT_WORKGROUP_INFO*
#define NET_QUERY_WLAN_ACCESSPOINT                  0x19                // 查询无线网络接入点信息,pInBuf=NET_IN_WLAN_ACCESSPOINT* , pOutBuf=NET_OUT_WLAN_ACCESSPOINT*
#define NET_QUERY_GPS_INFO							0x1a				// 查询设备GPS信息,pInBuf=NET_IN_DEV_GPS_INFO* , pOutBuf=NET_OUT_DEV_GPS_INFO*
#define NET_QUERY_IVS_REMOTE_DEVICE_INFO            0x1b                // 查询IVS的前端设备所关联的远程设备信息, pInBuf = NET_IN_IVS_REMOTE_DEV_INFO*, pOutBuf = NET_OUT_IVS_REMOTE_DEV_INFO*
#define NET_QUERY_SMART_SWITCH_INFO                 0x1c                // 查询智能插座信息, pInBuf = NET_IN_SMART_SWITCH_INFO*,  pOutBuf = NET_OUT_SMART_SWITCH_INFO*
#define NET_QUERY_UPGRADE_STATE                     0x1d                // 查询升级状态信息, pInBuf = NET_IN_UPGRADE_STATE*, pOutBuf = NET_OUT_UPGRADE_STATE* 
#define NET_QUERY_VIDEO_ENCODE_CAPS					0x1e				// 获取视频编码能力集, pInBuf = NET_IN_VIDEO_ENCODE_CAPS*, pOutBuf = NET_OUT_VIDEO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_ENCODE_CAPS					0x1f				// 获取音频编码能力集, pInBuf = NET_IN_AUDIO_ENCODE_CAPS*, pOutBuf = NET_OUT_AUDIO_ENCODE_CAPS* 
#define NET_QUERY_AUDIO_IN_CAPS						0x20				// 获取音频输入通道能力集, pInBuf = NET_IN_AUDIO_IN_CAPS*, pOutBuf = NET_OUT_AUDIO_IN_CAPS* 
#define NET_QUERY_SMART_ENCODE_CAPS					0x21				// 查询Smart编码能力集, pInBuf = NET_IN_SMART_ENCODE_CAPS*, pOutBuf = NET_OUT_SMART_ENCODE_CAPS* 
#define NET_QUERY_HARDDISK_TEMPERATURE				0x22				// 获取硬盘温度,pInBuf = NET_IN_HDD_TEMPERATURE*, pOutBuf = NET_OUT_HDD_TEMPERATURE*
#define NET_QUERY_RAWFRAMEDATA						0x23				// 获取指定格式的YUV数据, pInBuf = NET_IN_RAWFRAMEDATA*, pOutBuf = NET_OUT_RAWFRAMEDARA*
#define NET_QUERY_GETSPLICEDATA						0x24				// 获取设备拼接参数接口, pInBuf = NET_IN_GETSPLICEDATA*, pOutBuf = NET_OUT_GETSPLICEDATA*
#define NET_QUERY_AUDIO_DECODE_CAPS					0x25				// 获取音频解码能力集, pInBuf = NET_IN_AUDIO_DECODE_CAPS*, pOutBuf = NET_OUT_AUDIO_DECODE_CAPS* 
#define	NET_QUERY_DEVICE_ID							0x26				// 获取设备ID, pInBuf = NET_IN_DEVICE_ID*, pOutBuf = NET_OUT_DEVICE_ID* 

// 查询设备信息(pInBuf, pOutBuf内存由用户申请释放,根据nQueryType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_QueryDevInfo(LLONG lLoginID, int nQueryType, void* pInBuf, void* pOutBuf, void *pReserved = NULL , int nWaitTime = 1000);
//------------------------------------------------------------------------

// 重启设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RebootDev(LLONG lLoginID);

// 关闭设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ShutDownDev(LLONG lLoginID);

// 设备控制(param内存由用户申请释放，大小参照type类型对应的结构体)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDevice(LLONG lLoginID, CtrlType type, void *param, int waittime = 1000);

// 异步设备控制(param内存由用户申请释放，大小参照type类型对应的结构体)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartControlDevice(LLONG lLoginID, CtrlType type, void *param);

// 设备控制扩展接口，兼容 CLIENT_ControlDevice (pInBuf, pOutBuf内存由用户申请释放,根据emType确定相应结构体)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDeviceEx(LLONG lLoginID, CtrlType emType, void* pInBuf, void* pOutBuf = NULL, int nWaitTime = 1000);

#define DH_POS_EXCHANGE_GOODS_MAX				4			//查询时最多支持的商品数
#define DH_POS_EXCHANGE_FUSSY_KEY_MAX			4			//模糊查询最多支持的关键字数量

// POS获取交易信息模糊查询KEY值类型
typedef enum tagEM_NET_POS_EXCHANGE_FUSSY_KEY
{
    EM_NET_POS_EXCHANGE_KEY_NULL = 0,                      // 不进行模糊查询,数组中只要有一个值为EM_NET_POS_EXCHANGE_KEY_NULL之外可用值（目前只有EM_NET_POS_EXCHANGE_KEY_GOODS）,就会进行相应字段的模糊查询
    EM_NET_POS_EXCHANGE_KEY_GOODS = 1,                     // 模糊查询的时候以 商品名 为KEY值(目前只支持模糊查询商品名)
} EM_NET_POS_EXCHANGE_FUSSY_KEY;

// 接口 CLIENT_StartFind 接口 NET_FIND_POS_EXCHANGE 命令入参
typedef struct tagNET_IN_POSEXCHANGE_STARTFIND
{
	DWORD                            dwSize;															//结构体大小
    int	                             nChannel;															//需要锁定的通道号,从0开始,元素为-1时,表示全通道。
    NET_TIME_EX	                     stuStartTime;														//开始时间,必填, 毫秒没用
    NET_TIME_EX	                     stuEndTime;														//结束时间,不填表示至今为止, 毫秒没用
	char						     szGoods[DH_POS_EXCHANGE_GOODS_MAX][DH_COMMON_STRING_32];			//商品名,可选,字符串
	EM_NET_POS_EXCHANGE_FUSSY_KEY    szFuzzyPattern[DH_POS_EXCHANGE_FUSSY_KEY_MAX];	            		//指定模糊查询的关键字,未指定关键字的使用精确查询,
																								    	//必填,不需要模糊查询时填NULL
    int                              nPosId;                                                            //Pos唯一标识, -1标识全部
} NET_IN_POSEXCHANGE_STARTFIND;

// 接口 CLIENT_StartFind 接口 NET_FIND_POS_EXCHANGE 命令出参
typedef struct tagNET_OUT_POSEXCHANGE_STARTFIND
{
    DWORD                dwSize;                         // 此结构体大小
    unsigned int		 nToken;						 // 查询令牌
    DWORD                dwTotalCount;                   // 符合条件的总个数
}NET_OUT_POSEXCHANGE_STARTFIND;

// 接口 CLIENT_DoFind 接口 NET_FIND_POS_EXCHANGE 命令入参
typedef struct tagNET_IN_POSEXCHANGE_DOFIND
{
    DWORD                dwSize;                         // 此结构体大小
	unsigned int         nToken;						 // 查询令牌
	unsigned int		 nBeginNumber;					 // 起始序号	0<=dwBeginNumber<=dwTotalCount-1
	unsigned int         nCount;						 // 每次查询的POS交易信息条数
} NET_IN_POSEXCHANGE_DOFIND;

// POS交易信息
typedef struct tagNET_POSEXCHANGE_INFO
{
	NET_TIME			stuExchangeTime;				//交易发生时间
}NET_POSEXCHANGE_INFO;

// POS交易信息扩展字段
typedef struct tagNET_POSEXCHANGE_INFO_EX
{
    int                 nPosId;                         // Pos唯一标识
    char                cDetail[512];                   // 交易的具体信息
    int                 nDetailLen;                     // 交易的具体信息长度
    BYTE                reserved[1024];                 // 预留
} NET_POSEXCHANGE_INFO_EX;

// 接口 CLIENT_DoFind 接口 NET_FIND_POS_EXCHANGE 命令出参
typedef struct tagNET_OUT_POSEXCHANGE_DOFIND
{
    DWORD						dwSize;												// 此结构体大小
    DWORD						dwFound;											// 查询到的个数
	NET_POSEXCHANGE_INFO		arrPOSExchangeInfo[DH_MAX_POS_EXCHANGE_INFO];		// 查询到的交易信息列表
    NET_POSEXCHANGE_INFO_EX     stuInfoEx[DH_MAX_POS_EXCHANGE_INFO];                // 交易信息
}NET_OUT_POSEXCHANGE_DOFIND;

// CLIENT_StopFind 接口 NET_FIND_POS_EXCHANGE 命令入参
typedef struct tagNET_IN_POSEXCHANGE_STOPFIND
{   
    DWORD               dwSize;								// 此结构体大小
    unsigned int        nToken;								// 查询令牌
} NET_IN_POSEXCHANGE_STOPFIND;

// CLIENT_StopFind 接口 NET_FIND_POS_EXCHANGE 命令出参
typedef struct tagNET_OUT_POSEXCHANGE_STOPFIND
{   
    DWORD               dwSize;								// 此结构体大小
} NET_OUT_POSEXCHANGE_STOPFIND;

// 设备信息类型,对应 CLIENT_StartFind CLIENT_DoFind CLIENT_StopFind 接口
typedef enum tagNET_FIND {
    NET_FIND_RADIOMETRY,                            // 热成像温度查询, pInBuf= NET_IN_RADIOMETRY_*FIND*, pOutBuf= NET_OUT_RADIOMETRY_*FIND*   
	NET_FIND_POS_EXCHANGE,							// POS交易信息查询,pInBuf = NET_IN_POSEXCHANGE_*FIND*,pOutBuf= NET_OUT_POSEXCHANGE_*FIND*
} NET_FIND;

// 解码回调格式
typedef enum tagNET_VIDEOSTREAM_TYPE
{
	NET_VIDEOSTREAM_NORMAL,							// 默认格式
	NET_VIDEOSTREAM_YUV,							// YUV格式
} NET_VIDEOSTREAM_TYPE;


#define MAX_EVENT_LINK_QUERY_CODE_NUMBER	8		// 每次查询最多条数
#define MAX_EVENT_LINK_NAME_NUMBER			16		// 每个事件最多联动数量

typedef enum tagEM_NET_QUERY_CODE {
		EM_NET_QUERY_CODE_UNKNOWN,					// 未知
		EM_NET_QUERY_CODE_CROSSLINEDETECTION,		// 警戒线/绊线事件	CrossLineDetection
		EM_NET_QUERY_CODE_CROSSREGIONDETECTION,		// 警戒区事件		CrossRegionDetection
		EM_NET_QUERY_CODE_TAKENAWAYDETECTION,		// 物品搬移事件		TakenAwayDetection
		EM_NET_QUERY_CODE_LEFTDETECTION,			// 物品遗留事件		LeftDetection
		EM_NET_QUERY_CODE_PARKINGDETECTION,			// 非法停车事件		ParkingDetection
		EM_NET_QUERY_CODE_WANDERDETECTION,			// 徘徊事件			WanderDetection
		EM_NET_QUERY_CODE_MOVEDETECTION,			// 运动检测事件		MoveDetection
		EM_NET_QUERY_CODE_FACEDETECTION,			// 人脸检测事件		FaceDetection
		EM_NET_QUERY_CODE_RETROGRADEDETECTION,		// 人员逆行事件		RetrogradeDetection
		EM_NET_QUERY_CODE_NUMBERSTAT,				// 人数量/客流量统计事件	NumberStat
		EM_NET_QUERY_CODE_TRAFFICJUNCTION,			// 新交通路口事件	TrafficJunction
		EM_NET_QUERY_CODE_RIOTERDETECTION,			// 聚众事件			RioterDetection
		EM_NET_QUERY_CODE_ALARMLOCAL,				// 本地外部报警事件	AlarmLocal
		EM_NET_QUERY_CODE_VIDEOMOTION,				// 视频移动侦测事件	VideoMotion
		EM_NET_QUERY_CODE_VIDEOBLIND,				// 视频遮挡事件		VideoBlind
		EM_NET_QUERY_CODE_AUDIODETECT,				// 音量检测事件		AudioDetect
		EM_NET_QUERY_CODE_AUDIOANOMALY,				// 声音异常事件		AudioAnomaly
		EM_NET_QUERY_CODE_AUDIOMUTATION,			// 声强突变事件		AudioMutation
		EM_NET_QUERY_CODE_SCENECHANGE,				// IPC场景变更事件	SceneChange
		EM_NET_QUERY_CODE_VIDEOUNFOCUS,				// 视频虚焦事件		VideoUnFocus
		EM_NET_QUERY_CODE_STORAGELOWSPACE,			// 硬盘空间低报警事件	StorageLowSpace
		EM_NET_QUERY_CODE_STORAGEFAILURE,			// 存储错误事件		StorageFailure
		EM_NET_QUERY_CODE_LOGINFAILURE,				// 登陆失败事件		LoginFailure
		EM_NET_QUERY_CODE_STORAGENOTEXIST,			// 存储组不存在事件	StorageNotExist
		EM_NET_QUERY_CODE_IPCONFLICT,				// IP冲突事件		IPConflict
		EM_NET_QUERY_CODE_NETABORT,					// 设备自身断网事件	NetAbort
		EM_NET_QUERY_CODE_HOTPLUG,					// 热插拔事件		HotPlug
		EM_NET_QUERY_CODE_STORAGEFORMAT,			// 存储格式			StorageFormat
		EM_NET_QUERY_CODE_EMERGENCYRECORDPULL,		// 紧急录像报警事件	EmergencyRecordPull
} EM_NET_QUERY_CODE;


typedef enum tagEM_NET_LINK_NAME {
		EM_NET_LINK_NAME_UNKNOWN,				// 未知
		EM_NET_LINK_NAME_DEFAULT,				// 默认能力,即eventManager.getCaps获取的能力		default
		EM_NET_LINK_NAME_TIMESECTIONENABLE,		// 时间事件响应	TimeSectionEnable
		EM_NET_LINK_NAME_RECORDENABLE,			// 录像			RecordEnable
		EM_NET_LINK_NAME_RECORDCLOUDENABLE,		// 录像云存储	RecordCloudEnable
		EM_NET_LINK_NAME_ALARMOUTENABLE,		// 报警输出		AlarmOutEnable
		EM_NET_LINK_NAME_PTZLINKENABLE,			// 云台联动		PtzLinkEnable
		EM_NET_LINK_NAME_SNAPSHOTENABLE,		// 快照			SnapshotEnable
		EM_NET_LINK_NAME_SNAPSHOTCLOUDENABLE,	// 抓图云存储	SnapshotCloudEnable
		EM_NET_LINK_NAME_MAILENABLE,			// 发送邮件		MailEnable
		EM_NET_LINK_NAME_BEEPENABLE,			// 蜂鸣			BeepEnable
		EM_NET_LINK_NAME_DEJITTERENABLE,		// 去抖动		DejitterEnable
		EM_NET_LINK_NAME_TIPENABLE,				// 本地消息框提示	TipEnable
		EM_NET_LINK_NAME_MONITORTOURENABLE,		// 轮询联动配置	MonitorTourEnable
		EM_NET_LINK_NAME_MMSENABLE,				// 短消息		MMSEnable
		EM_NET_LINK_NAME_SUPPORTALARMBELL,		// 警号输出		SupportAlarmBell
		EM_NET_LINK_NAME_SUPPORTACCESSCONTROL,	// 门禁控制		SupportAccessControl
		EM_NET_LINK_NAME_SIPCALLENABLE,			// SIP呼叫		SipCallEnable
		EM_NET_LINK_NAME_SUPPORTALARMSERVER,	// 上传至报警服务器	SupportAlarmServer
		EM_NET_LINK_NAME_SUPPORTPTZLINKDELAY,	// 云台联动延迟	SupportPtzLinkDelay
		EM_NET_LINK_NAME_SUPPORTPSTNALARMSERVER,// 上传至电话报警中心	SupportPSTNAlarmServer
		EM_NET_LINK_NAME_SUPPORTICR,			// ICR(双滤光片切换)切换	SupportICR
		EM_NET_LINK_NAME_BEEPTIME,				// 蜂鸣时长设置	BeepTime
		EM_NET_LINK_NAME_DEJITTERRANGE,			// 去抖动范围	DejitterRange
		EM_NET_LINK_NAME_ALARMOUTLATCH,			// 报警输出延时	AlarmOutLatch
		EM_NET_LINK_NAME_RECORDLATCH,			// 录像延时		RecordLatch
		EM_NET_LINK_NAME_VOICEENABLE,			// 语音提示		VoiceEnable
		EM_NET_LINK_NAME_LOGENABLE,				// 联动日志		LogEnable
		EM_NET_LINK_NAME_SUPPORTLIGHTCONTROL,	// 联动灯光控制器	SupportLightControl
		EM_NET_LINK_NAME_SUPPORTVIDEOMATRIX,	// 联动视频矩阵	SupportVideoMatrix
} EM_NET_LINK_NAME;

// CLIENT_getEventLink 接口入参
typedef struct tagNET_IN_EVENT_LINK
{   
    DWORD               dwSize;					// 此结构体大小
	int					nCodeNum;				// 查询联动事件个数
	EM_NET_QUERY_CODE	szCodeName[MAX_EVENT_LINK_QUERY_CODE_NUMBER];		// 查询联动事件列表
} NET_IN_EVENT_LINK;

// CLIENT_getEventLink 接口出参
typedef struct tagNET_OUT_EVENT_LINK
{   
    DWORD               dwSize;						// 此结构体大小
	EM_NET_LINK_NAME	szLinkName[MAX_EVENT_LINK_QUERY_CODE_NUMBER][MAX_EVENT_LINK_NAME_NUMBER];		// 联动项名称
} NET_OUT_EVENT_LINK;

// CLIENT_GetVideoInAnalyseEnableChannels 接口输入参数
typedef struct tagNET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS
{
	DWORD               dwSize;						// 此结构体大小
} NET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS;

// CLIENT_GetVideoInAnalyseEnableChannels 接口输出参数
typedef struct tagNET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS
{
	DWORD               dwSize;										// 此结构体大小
	int					nLocalChnNum;								// 已使能的后智能通道个数
	int					nLocalChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// 后智能已使能的通道列表
	int					nRemoteChnNum;								// 已使能的前智能通道个数
	int					nRemoteChannel[DH_MAX_CAMERA_CHANNEL_NUM];	// 前智能已使能的通道列表
} NET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS;

// 开始查询信息（获取查询句柄）(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// 查询信息(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);
// 停止查询信息（销毁查询句柄）(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFind(LLONG lLoginID, NET_FIND emType, void* pInBuf, void* pOutBuf, int nWaitTime = 1000);

// 设置通道录像状态(pRsBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen);

// 设置通道辅码流录像状态(pRsBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupExtraRecordState(LLONG lLoginID, char *pRSBuffer, int nRSBufferlen, void* pReserved);

// 查询IO状态(pState内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryIOControlState(LLONG lLoginID, DH_IOTYPE emType, 
                                           void *pState, int maxlen, int *nIOCount, int waittime=1000);

// IO控制(pState内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IOControl(LLONG lLoginID, DH_IOTYPE emType, void *pState, int maxlen);

// 强制I帧；nChannelID：通道号,nSubChannel：码流类型(0：主,1：子码流1)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MakeKeyFrame(LLONG lLoginID, int nChannelID, int nSubChannel=0);

// 公网代理注册
typedef void (CALLBACK *fConnectMessCallBack)(LLONG lConnectHandle, NET_CLOUDSERVICE_CONNECT_RESULT* pConnectResult, void* pReserved, LDWORD dwUser);
// 公网代理注册,pConnectParm内存由用户申请释放,大小为sizeof(NET_CLOUDSERVICE_CONNECT_PARAM)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ConnectCloudService(LLONG lLoginID, NET_CLOUDSERVICE_CONNECT_PARAM* pConnectParm, fConnectMessCallBack pConnectMessCB, LDWORD dwUser, void* pReserved);
//------------------------------------------------------------------------

// 查询用户信息(info内存由用户申请释放,大小为sizeof(USER_MANAGE_INFO))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfo(LLONG lLoginID, USER_MANAGE_INFO *info, int waittime=1000);

// 查询用户信息--扩展(info内存由用户申请释放,大小为sizeof(USER_MANAGE_INFO_EX))
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoEx(LLONG lLoginID, USER_MANAGE_INFO_EX *info, int waittime=1000);

// 查询用户信息--最大支持64通道设备(info内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryUserInfoNew(LLONG lLoginID, USER_MANAGE_INFO_NEW *info, void* pReserved, int waittime = 1000);

// 操作设备用户(opParam, subParam内存由用户申请释放,根据nOperateType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfo(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// 操作设备用户--扩展(opParam, subParam内存由用户申请释放,根据nOperateType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoEx(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, int waittime=1000);

// 操作设备用户--最大支持64通道设备(opParam, subParam内存由用户申请释放,根据nOperateType对应的类型找到相应的结构体，进而确定申请内存大小)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateUserInfoNew(LLONG lLoginID, int nOperateType, void *opParam, void *subParam, void* pRetParam, int waittime = 1000);

//------------------------------------------------------------------------

// 创建透明串口通道,TransComType高2个字节表示串口序号,低2个字节表示串口类型,目前类型支持0：串口,1:485
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CreateTransComChannel(LLONG lLoginID, int TransComType, unsigned int baudrate, unsigned int databits, unsigned int stopbits, unsigned int parity, fTransComCallBack cbTransCom, LDWORD dwUser);

// 透明串口发送数据(pBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTransComData(LLONG lTransComChannel, char *pBuffer, DWORD dwBufSize);

// 释放通明串口通道
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DestroyTransComChannel(LLONG lTransComChannel);

// 查询透明串口状态(pCommState内存由用户申请释放)
CLIENT_NET_API BOOL   CALL_METHOD CLIENT_QueryTransComParams(LLONG lLoginID, int TransComType, DH_COMM_STATE* pCommState, int nWaitTime = 500);

//------------------------------------------------------------------------

// 开始升级设备程序,pchFileName由用户申请释放内存，大小为MAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgrade(LLONG lLoginID, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

// 开始升级设备程序--扩展,pchFileName由用户申请释放内存，大小为MAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBack cbUpgrade, LDWORD dwUser);

//开始升级设备程序--扩展支持G以上文件升级
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUpgradeEx2(LLONG lLoginID, EM_UPGRADE_TYPE emType, char *pchFileName, fUpgradeCallBackEx cbUpgrade, LDWORD dwUser);

// 发送数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendUpgrade(LLONG lUpgradeID);

// 结束升级设备程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUpgrade(LLONG lUpgradeID);

//------------------------------------------------------------------------
// 远程升级回调类型
typedef enum tagEM_REMOTE_UPGRADE_CB_TYPE
{
	EM_REMOTE_UPGRADE_CB_TYPE_APPENDING,				// 推送回调	nParam1 文件总大小 nParam2 已发送大小
	EM_REMOTE_UPGRADE_CB_TYPE_EXECUTE,					// 完成回调	nParam1 错误码
	EM_REMOTE_UPGRADE_CB_TYPE_FAILED,					// 失败回调 nParam1 错误码
	EM_REMOTE_UPGRADE_CB_TYPE_CANCEL,					// 用户取消
}EM_REMOTE_UPGRADE_CB_TYPE;

// 升级远程设备程序回调函数
typedef void (CALLBACK *fRemoteUpgradeCallBack) (LLONG lLoginID, LLONG lUpgradeID, EM_REMOTE_UPGRADE_CB_TYPE emState, INT64 nParam1, INT64 nParam2, LDWORD dwUser);

// 远程通道信息
typedef struct tagNET_REMOTE_UPGRADE_CHNL_INFO
{
	UINT				nChannel;					// 远程通道号
	BYTE				byReserved[512];			// 预留字段
}NET_REMOTE_UPGRADE_CHNL_INFO;

// CLIENT_StartRemoteUpgrade-输入参数
typedef struct tagNET_IN_START_REMOTE_UPGRADE_INFO
{
	DWORD							dwSize;						// 此结构体大小
	UINT							nListNum;					// 需要升级的远程通道个数
	NET_REMOTE_UPGRADE_CHNL_INFO	*pstuList;					// 需要升级的远程通道信息
	void							*pReserved;					// 字节对齐
	char							szFileName[256];			// 升级文件名称
	fRemoteUpgradeCallBack			cbRemoteUpgrade;			// 升级进度回调函数
	LDWORD							dwUser;						// 用户数据
}NET_IN_START_REMOTE_UPGRADE_INFO;

// CLIENT_StartRemoteUpgrade-输出参数
typedef struct tagNET_OUT_START_REMOTE_UPGRADE_INFO
{
	DWORD							dwSize;						// 此结构体大小
}NET_OUT_START_REMOTE_UPGRADE_INFO;

// 远程设备升级状态
typedef enum tagEM_REMOTE_UPGRADE_STATE
{
	EM_REMOTE_UPGRADE_STATE_UNKNOWN,							// 未知
	EM_REMOTE_UPGRADE_STATE_INIT,								// 初始状态(未升级)
	EM_REMOTE_UPGRADE_STATE_DOWNLOADING,						// 正在下载数据
	EM_REMOTE_UPGRADE_STATE_UPGRADING,							// 正在升级
	EM_REMOTE_UPGRADE_STATE_FAILED,								// 升级失败
	EM_REMOTE_UPGRADE_STATE_SUCCEEDED,							// 升级成功
	EM_REMOTE_UPGRADE_STATE_CANCELLED,							// 取消升级
	EM_REMOTE_UPGRADE_STATE_PREPARING,							// 准备升级
}EM_REMOTE_UPGRADE_STATE;

// 远程设备升级状态
typedef struct tagNET_REMOTE_UPGRADER_STATE
{
	int								nChannel;					// 通道号
	EM_REMOTE_UPGRADE_STATE			emState;					// 状态
	int								nProgress;					// 进度
}NET_REMOTE_UPGRADER_STATE;

// 远程设备升级消息上报
typedef struct tagNET_REMOTE_UPGRADER_NOTIFY_INFO
{
	LDWORD							nStateNum;					// 状态数
	NET_REMOTE_UPGRADER_STATE*		pstuStates;					// 状态列表
	BYTE							byReserved[1024];			// 预留
}NET_REMOTE_UPGRADER_NOTIFY_INFO;

// 升级状态回调函数
typedef void (CALLBACK *fRemoteUpgraderStateCallback) (LLONG lLoginId, LLONG lAttachHandle, NET_REMOTE_UPGRADER_NOTIFY_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachRemoteUpgradeState-输入参数
typedef struct tagNET_IN_ATTACH_REMOTEUPGRADE_STATE
{
	DWORD							dwSize;						// 此结构体大小
	fRemoteUpgraderStateCallback	cbCallback;					// 回调
	LDWORD							dwUser;						// 用户数据
}NET_IN_ATTACH_REMOTEUPGRADE_STATE;

// CLIENT_AttachRemoteUpgradeState-输出参数
typedef struct tagNET_OUT_ATTACH_REMOTEUPGRADE_STATE
{
	DWORD							dwSize;						// 此结构体大小
}NET_OUT_ATTACH_REMOTEUPGRADE_STATE;

//开始升级远程设备程序
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRemoteUpgrade(LLONG lLoginID, const NET_IN_START_REMOTE_UPGRADE_INFO* pInParam, NET_OUT_START_REMOTE_UPGRADE_INFO* pOutParam, int nWaitTime = 500);

//结束升级远程设备程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRemoteUpgrade(LLONG lUpgradeID);

// 订阅ipc升级状态观察接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemoteUpgradeState( LLONG lLoginID, const NET_IN_ATTACH_REMOTEUPGRADE_STATE* pInParam, NET_OUT_ATTACH_REMOTEUPGRADE_STATE* pOutParam, int nWaitTime );

// 取消订阅升级状态接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemoteUpgradeState( LLONG lAttachHandle );
//------------------------------------------------------------------------

// 查询配置信息(lpOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_GetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);

// 设置配置信息(lpInBuffer内存由用户申请释放)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetDevConfig(LLONG lLoginID, DWORD dwCommand, LONG lChannel, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// 新配置接口，查询配置信息(以Json格式，具体见配置SDK)(szOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// 新配置接口，设置配置信息(以Json格式，具体见配置SDK)(szInBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfig(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// 删除配置接口(Json格式)(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteDevConfig(LLONG lLoginID, NET_IN_DELETECFG* pInParam, NET_OUT_DELETECFG* pOutParam, int waittime=500);

// 获取配置成员名称接口(Json格式)(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMemberNames(LLONG lLoginID, NET_IN_MEMBERNAME* pInParam, NET_OUT_MEMBERNAME* pOutParam, int waittime=500);

// 获取网卡信息(lpInParam, lpOutParam内存由用户申请释放,大小参照emType对应的结构体)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNetStat(LLONG lLoginID , EM_NET_QUERY_TYPE emType , void *lpInParam , int nInParamLen , void *lpOutParam , int nOutParamLen , int *pError = NULL , int nWaitTime=1000);
// VideoInAnalyse操作(szOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInAnalyse(LLONG 	lLoginID, char* szCommand, int nChannelID, EM_SCENE_CLASS_TYPE emClassType, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime);

// 获取指定事件的联动能力集(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLink(LLONG lLoginID, NET_IN_EVENT_LINK* pInParam, NET_OUT_EVENT_LINK* pOutParam, int nWaitTime);

// 获取正在执行智能分析的通道列表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInAnalyseEnableChannels(LLONG lLoginID, const NET_IN_VIDEOINANALYSE_GET_ENABLECHANNELS* pInParam, 
																	   NET_OUT_VIDEOINANALYSE_GET_ENABLECHANNELS* pOutParam, int nWaitTime);

//------------------------------------------------------------------------

// 查询设备通道名称(pChannelName内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryChannelName(LLONG lLoginID, char *pChannelName, int maxlen, int *nChannelCount, int waittime=1000);

// 设置设备通道名称(pbuf 内存由用户申请释放,建议大小至少为512字节)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelName(LLONG lLoginID,char *pbuf, int nbuflen);

// 设置设备通道字符叠加(struOsdString内存由用户申请释放)
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_SetupChannelOsdString(LLONG lLoginID, int nChannelNo, DH_CHANNEL_OSDSTRING* struOsdString, int nbuflen);

// 查询设备当前时间
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime, int waittime=1000);

// 设置设备当前时间
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTime(LLONG lLoginID, LPNET_TIME pDeviceTime);

// 查询设备当前时间扩展接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime, int waittime=1000);

// 设置设备当前时间扩展接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupDeviceTimeEx(LLONG lLoginID, LPNET_TIME_EX pDeviceTime);

// 查询设备当前UTC时间接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceUTC(LLONG lLoginID, LPNET_UTCTIME pDeviceTime, int waittime=1000);

// 设置设备当前UTC时间接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceUTC(LLONG lLoginID, LPNET_UTCTIME pDeviceTime);

// 设置设备限制码流
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMaxFlux(LLONG lLoginID, WORD wFlux);

//------------------------------------------------------------------------

// 导入配置文件,szFileName由用户申请释放内存，大小为MAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportConfigFile(LLONG lLoginID, char *szFileName, fDownLoadPosCallBack cbUploadPos, LDWORD dwUserData, DWORD param=0);

// 停止导入配置文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportCfgFile(LLONG lImportHandle);

// 导出配置文件,szSavedFilePath由用户申请释放内存，大小为MAX_PATH
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportConfigFile(LLONG lLoginID, DH_CONFIG_FILE_TYPE emConfigFileType, char *szSavedFilePath, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData);

// 停止导出配置文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportCfgFile(LLONG lExportHandle);

//------------------------------------------------------------------------

// 通过设备名字或者设备序列号向DDNS服务器查询设备IP
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDVRIPByResolveSvr(char *pchDVRIP, WORD wDVRPort, BYTE *sDVRName, WORD wDVRNameLen, BYTE *sDVRSerialNumber, WORD wDVRSerialLen, char* sGetIP);

// 搜索局域网内IPC、NVS等设备(szBuf内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevices(char* szBuf, int nBufLen, int* pRetLen, DWORD dwSearchTime, char* szLocalIp=NULL);

// 异步搜索局域网内IPC、NVS等设备,pUserData表示用户数据，不支持多线程调用, 
// 接口调用1次只发送搜索信令1次
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevices(fSearchDevicesCB cbSearchDevices, void* pUserData, char* szLocalIp=NULL);

// 停止异步搜索局域网内IPC、NVS等设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSearchDevices(LLONG lSearchHandle);

// 修改设备IP (pDevNetInfo内存由用户申请释放):不支持多线程调用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDevice(DEVICE_NET_INFO_EX *pDevNetInfo, DWORD dwWaitTime, int *iError = NULL, char* szLocalIp = NULL, void *reserved = NULL);

// 下发搜索类型
typedef enum tagEM_SEND_SEARCH_TYPE
{
    EM_SEND_SEARCH_TYPE_MULTICAST_AND_BROADCAST,        // 组播和广播搜索
    EM_SEND_SEARCH_TYPE_MULTICAST,                      // 组播搜索
    EM_SEND_SEARCH_TYPE_BROADCAST,                      // 广播搜索
}EM_SEND_SEARCH_TYPE;

// 异步搜索设备入参
typedef struct tagNET_IN_STARTSERACH_DEVICE
{
    DWORD                   dwSize;                         // 结构体大小
    char                    szLocalIp[MAX_LOCAL_IP_LEN];    // 发起搜索的本地IP
    fSearchDevicesCBEx      cbSearchDevices;                // 设备信息回调函数
    void*                   pUserData;                      // 用户自定义数据
    EM_SEND_SEARCH_TYPE     emSendType;                     // 下发搜索类型
}NET_IN_STARTSERACH_DEVICE;

// // 异步搜索设备出参
typedef struct tagNET_OUT_STARTSERACH_DEVICE
{
	DWORD                   dwSize;							// 结构体大小
}NET_OUT_STARTSERACH_DEVICE;

// 异步搜索设备
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevicesEx(NET_IN_STARTSERACH_DEVICE* pInBuf, NET_OUT_STARTSERACH_DEVICE* pOutBuf);

// 修改IP入参
typedef struct tagNET_IN_MODIFY_IP
{
	DWORD                   dwSize;			// 结构体大小
	DEVICE_NET_INFO_EX2     stuDevNetInfo;	// 设备信息结构体
}NET_IN_MODIFY_IP;

// 修改IP出参
typedef struct tagNET_OUT_MODIFY_IP
{
	DWORD                   dwSize;			// 结构体大小
}NET_OUT_MODIFY_IP;

// 修改设备IP (pDevNetInfo内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyDeviceEx(NET_IN_MODIFY_IP* pInBuf, NET_OUT_MODIFY_IP* pOutBuf, int nWaitTime);

// 跨网段搜索设备IP (pIpSearchInfo内存由用户申请释放)
// 接口调用1次只发送搜索信令1次
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPs(DEVICE_IP_SEARCH_INFO* pIpSearchInfo, fSearchDevicesCB cbSearchDevices, LDWORD dwUserData, char* szLocalIp, DWORD dwWaitTime);

// pstParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDeviceSearchParam(const NET_DEVICE_SEARCH_PARAM* pstParam);
//------------------------------------------------------------------------

// 平台接入接口(lpOutBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpOutBuffer, DWORD dwOutBufferSize, LPDWORD lpBytesReturned,int waittime=500);
// lpInBuffer内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlatFormInfo(LLONG lLoginID, DWORD dwCommand, int nSubCommand, int nParam, LPVOID lpInBuffer, DWORD dwInBufferSize, int waittime=500);

// 镜头聚焦控制
//    dwFocusCommand = 0为聚焦调节
//    dwFocusCommand = 1为连续聚焦调节
//    dwFocusCommand = 2为自动聚焦调节,调节焦点至最佳位置。nFocus和nZoom无效。
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FocusControl(LLONG lLoginID, int nChannelID, DWORD dwFocusCommand, double nFocus, double nZoom, void *reserved = NULL, int waittime=500);

///////////////////////////////车载设备接口///////////////////////////////

// 设置抓图回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetSnapRevCallBack(fSnapRev OnSnapRevMessage, LDWORD dwUser);

// 抓图请求
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPicture(LLONG lLoginID, SNAP_PARAMS par);

// 抓图请求扩展接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureEx(LLONG lLoginID, SNAP_PARAMS *par, int *reserved = 0);

// 抓图同步接口,将图片数据直接返回给用户,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureToFile(LLONG lLoginID, const NET_IN_SNAP_PIC_TO_FILE_PARAM* pInParam, NET_OUT_SNAP_PIC_TO_FILE_PARAM* pOutParam, int nWaitTime);

// 设置GPS订阅回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBack(fGPSRev OnGPSMessage, LDWORD dwUser);

// 设置GPS订阅回调函数--扩展
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX(fGPSRevEx OnGPSMessage, LDWORD dwUser);

// 设置GPS订阅回调函数--扩展2
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSCallBackEX2(fGPSRevEx2 OnGPSMessage, LDWORD dwUser);

/**************************************************************************************
*   Funcname: CLIENT_SubcribeGPS
*   Purpose:GPS信息订阅
*   InputParam:   LLONG  :lLoginID    //登陆句柄
*   InputParam:   BOOL   :bStart      //TRUE:订阅  FALSE:取消订阅
*   InputParam:   LONG   :KeepTime    //订阅持续时间(单位秒) 值为-1时,订阅时间为极大值,可视为永久订阅
*   InputParam:   LONG   :InterTime   //订阅时间内GPS发送频率(单位秒)
*   Return: BOOL
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPS (LLONG lLoginID, BOOL bStart, LONG KeepTime, LONG InterTime);

// 设置GPS温湿度订阅回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetSubcribeGPSTHCallBack(fGPSTempHumidityRev OnGPSMessage, LDWORD dwUser);

// GPS温湿度信息订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SubcribeGPSTempHumidity (LLONG lLoginID, BOOL bStart,    int InterTime, void* Reserved);

//GPS日志信息查询(pQueryParam, pLogBuffer内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryGPSLog(LLONG lLoginID,QUERY_GPS_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, BOOL *bContinue, int waittime);

// 订阅任务(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachMission(LLONG lLoginID, NET_IN_ATTACH_MISSION_PARAM *pInParam, NET_OUT_ATTACH_MISSION_PARAM *pOutParam, int nWaitTime);

// 取消任务订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMission(LLONG lAttachHandle);

// 车辆紧急报警确认(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusConfirmEvent(LLONG lLoginID, const NET_IN_BUS_CONFIRM_EVENT* pInParam, NET_OUT_BUS_CONFIRM_EVENT* pOutParam, int nWaitTime = 3000);

// 设置设备地址信息(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevicePosition(LLONG lLoginID, const NET_IN_SET_DEVICE_POSITION* pInParam, NET_OUT_SET_DEVICE_POSITION* pOutParam, int nWaitTime);

// 获取设备地址信息(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevicePosition(LLONG lLoginID, const NET_IN_GET_DEVICE_POSITION* pInParam, NET_OUT_GET_DEVICE_POSITION* pOutParam, int nWaitTime);

// 按照事件类型抓图（配合CLIENT_RealLoadPic()、CLIENT_RealLoadPicEx()接口使用, 按照手动抓拍模式(Manual)订阅,图片通过回调给用户）(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByEvent(LLONG lLoginID, const NET_IN_SNAP_BY_EVENT* pInParam, NET_OUT_SNAP_BY_EVENT* pOutParam, int nWaitTime);

//////////////////////////////解码器设备接口//////////////////////////////

// 查询解码器信息(lpDecInfo内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderInfo(LLONG lLoginID, LPDEV_DECODER_INFO lpDecInfo, int waittime=1000);

// 查询解码器当前TV信息(lpMonitorInfo内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTVInfo(LLONG lLoginID, int nMonitorID, LPDEV_DECODER_TV lpMonitorInfo, int waittime=1000);

// 查询解码通道信息(lpEncoderInfo内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecEncoderInfo(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, int waittime=1000);

// 设置解码器TV输出使能(pDecTVOutEnable内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecTVOutEnable(LLONG lLoginID, BYTE *pDecTVOutEnable, int nBufLen, int waittime=1000);

// 设置解码器显示叠加信息使能,通道号从0开始
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecLayOutEnable(LLONG lLoginID, BYTE bDecLayOutEnable, int nChannel, int waittime=1000);
// 获取解码器显示叠加信息使能,通道号从0开始
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecLayOutEnable(LLONG lLoginID, BYTE *pDecLayOutEnable, int nChannel, int waittime=1000);
//------------------------------------------------------------------------

// 设置异步回调函数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOperateCallBack(LLONG lLoginID, fMessDataCallBack cbMessData, LDWORD dwUser);

// 控制解码器TV画面分割,接口为异步方式 nSplitType=-1时,pEncoderChannel为结构体DH_CTRL_DECTV_SCREEN指针
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CtrlDecTVScreen(LLONG lLoginID, int nMonitorID, BOOL bEnable, int nSplitType, BYTE *pEncoderChannel, int nBufLen, void* userdata=NULL);

// 解码器TV画面切换,接口为异步方式(lpEncoderInfo内存由用户申请释放)
//   
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SwitchDecTVEncoder(LLONG lLoginID, int nDecoderID, LPDEV_ENCODER_INFO lpEncoderInfo, void* userdata=NULL);

//------------------------------------------------------------------------

// 增加画面组合
CLIENT_NET_API int CALL_METHOD CLIENT_AddTourCombin(LLONG lLoginID, int nMonitorID, int nSplitType, BYTE *pEncoderChannnel, int nBufLen, int waittime=1000);

// 删除画面组合
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int waittime=1000);

// 修改画面组合
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, int nSplitType, BYTE *pEncoderChannel, int nBufLen, int waittime=1000);

// 查询画面组合,nCombinID范围0～32
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryTourCombin(LLONG lLoginID, int nMonitorID, int nCombinID, LPDEC_COMBIN_INFO lpDecCombinInfo, int waittime=1000);

// 设置轮巡操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// 查询轮巡操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecoderTour(LLONG lLoginID, int nMonitorID, LPDEC_TOUR_COMBIN lpDecTourInfo, int waittime=1000);

// 查询当前解码通道流信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDecChannelFlux(LLONG lLoginID, int nDecoderID, LPDEV_DECCHANNEL_STATE lpChannelStateInfo, int waittime=1000);

// 解码器控制轮巡
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecoderTour(LLONG lLoginID, int nMonitorID, DEC_CTRL_TOUR_TYPE emActionParam, int waittime = 1000);
//------------------------------------------------------------------------

typedef void (CALLBACK *fDecPlayBackPosCallBack)(LLONG lLoginID, int nEncoderID, DWORD dwTotalSize, DWORD dwPlaySize, LDWORD dwUser);

// 设置回放进度回调函数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecPlaybackPos(LLONG lLoginID, fDecPlayBackPosCallBack cbPlaybackPos, LDWORD dwUser);

// 解码器TV画面回放,接口为异步方式
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DecTVPlayback(LLONG lLoginID, int nDecoderID, DEC_PLAYBACK_MODE emPlaybackMode, LPVOID lpInBuffer, DWORD dwInBufferSize, void* userdata=NULL);

// 解码器TV画面回放控制
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CtrlDecPlayback(LLONG lLoginID, int nDecoderID, DEC_CTRL_PLAYBACK_TYPE emCtrlType, int nValue, int waittime=1000);

///////////////////////////////智能设备接口///////////////////////////////

// 实时上传智能分析数据－图片
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPicture(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

// 实时上传智能分析数据－图片(扩展接口,bNeedPicFile表示是否订阅图片文件,Reserved类型为 RESERVED_PARA)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RealLoadPictureEx(LLONG lLoginID, int nChannelID, 
                                                     DWORD dwAlarmType, 
                                                     BOOL bNeedPicFile, 
                                                     fAnalyzerDataCallBack cbAnalyzerData, 
                                                     LDWORD dwUser, 
                                                     void* Reserved);

// 停止上传智能分析数据－图片
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadPic(LLONG lAnalyzerHandle);

// 确认上传图片是否已完成－图片
// 该接口不宜与 CLIENT_RealLoadPictureEx/CLIENT_RealLoadPicture 的回调函数在同一线程,易造成阻塞,必须在另外的线程中调用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapManagerConfirmUpload(LLONG lLoginID, const NET_IN_SNAP_MANAGER_CONFIRM_UPLOAD* pstInParam, NET_OUT_SNAP_MANAGER_CONFIRM_UPLOAD* pstOutParam, int waittime=1000);

// 按查询条件查询文件,pQueryCondition由用户申请释放内存，大小参照emType对应的结构体
CLIENT_NET_API LLONG    CALL_METHOD CLIENT_FindFileEx(LLONG lLoginID, EM_FILE_QUERY_TYPE emType, void* pQueryCondition, void *reserved, int waittime=1000);    

// 查找文件:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕
CLIENT_NET_API int    CALL_METHOD CLIENT_FindNextFileEx(LLONG lFindHandle, int nFilecount, void* pMediaFileInfo, int maxlen, void *reserved, int waittime=1000);

// 结束录像文件查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindCloseEx(LLONG lFindHandle);

// 获取符合查询条件的文件总数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTotalFileCount(LLONG lFindHandle, int* pTotalCount, void *reserved, int waittime=1000);

// 设置查询跳转条件,pOption由用户申请释放内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFindingJumpOption(LLONG lFindHandle, NET_FINDING_JUMP_OPTION_INFO* pOption, void *reserved, int waittime=1000);

// 下载指定的智能分析数据 - 图片,lpMediaFileInfo由用户申请释放内存，内存大小参照emType确定对应的结构体
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DownloadMediaFile(LLONG lLoginID,EM_FILE_QUERY_TYPE emType, void* lpMediaFileInfo, char *sSavedFileName, fDownLoadPosCallBack cbDownLoadPos, LDWORD dwUserData,  void *reserved);

// 停止下载数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDownloadMediaFile(LLONG lFileHandle);

// 批量下载文件,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadMultiFile(LLONG lLoginID, NET_IN_DOWNLOAD_MULTI_FILE *pstInParam, NET_OUT_DOWNLOAD_MULTI_FILE *pstOutParam, int waittime=1000);

// 停止下载
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadMultiFile(LLONG lDownLoadHandle);

// 下载离线智能分析数据－图片
CLIENT_NET_API LLONG CALL_METHOD CLIENT_LoadOffLineFile(LLONG lLoginID, int nChannelID, DWORD dwAlarmType, LPNET_TIME_EX lpStartTime, LPNET_TIME_EX lpEndTime, fAnalyzerDataCallBack cbAnalyzerData, LDWORD dwUser);

//暂停智能分析数据下载(bPause=TRUE 表示暂停下载, bPause=FALSE 表示恢复下载)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseLoadPic(LLONG lLoadHadle, BOOL bPause);

// 交通抓拍--网络触发方式，pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficSnapByNetwork(LLONG lLoginID, int nChannelID, NET_IN_SNAPSHOT* pstInParam, NET_OUT_SNAPSHOT* pstOutParam);

// 交通控制--强制红灯，pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TrafficForceLightState(LLONG lLoginID, int nChannelID, NET_IN_FORCELIGHTSTATE* pstInParamg, NET_OUT_FORCELIGHTSTATE* pstOutParam, int waittime=1000);

//  黑白名单操作,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTrafficList(LLONG lLoginID ,  NET_IN_OPERATE_TRAFFIC_LIST_RECORD* pstInParam , NET_OUT_OPERATE_TRAFFIC_LIST_RECORD *pstOutParam = NULL ,  int waittime = 1000);

// 交通流量统计,pstInParamg与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTrafficFluxStat(LLONG lLoginID, NET_IN_TRAFFICFLUXSTAT* pstInParam,NET_OUT_TRAFFICFLUXSTAT* pstOutParam);

// 结束流量统计
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTrafficFluxStat(LLONG lFluxStatHandle);

// 获取流量统计信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFluxStat(LLONG lLoginID, NET_IN_TRAFFICSTARTFINDSTAT* pstInParam, NET_OUT_TRAFFICSTARTFINDSTAT* pstOutParam);

// 继续查询流量统计,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API int    CALL_METHOD CLIENT_DoFindFluxStat(LLONG lFindHandle, NET_IN_TRAFFICDOFINDSTAT* pstInParam,NET_OUT_TRAFFICDOFINDSTAT* pstOutParam);

// 结束查询流量统计
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFluxStat(LLONG lFindHandle);

// 开始查询视频统计信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStat(LLONG lLoginID, NET_IN_FINDNUMBERSTAT* pstInParam, NET_OUT_FINDNUMBERSTAT* pstOutParam);

// 继续查询视频统计,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API int  CALL_METHOD CLIENT_DoFindNumberStat(LLONG lFindHandle, NET_IN_DOFINDNUMBERSTAT* pstInParam, NET_OUT_DOFINDNUMBERSTAT* pstOutParam);

// 结束查询视频统计
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStat(LLONG lFindHandle);

// 订阅视频统计摘要信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatSummary(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_SUM* pInParam, NET_OUT_ATTACH_VIDEOSTAT_SUM* pOutParam, int nWaitTime);

// 取消订阅视频统计摘要信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatSummary(LLONG lAttachHandle);

// 订阅热度图数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVideoStatHeatMap(LLONG lLoginID, const NET_IN_ATTACH_VIDEOSTAT_HEATMAP* pInParam, NET_OUT_ATTACH_VIDEOSTAT_HEATMAP* pOutParam, int nWaitTime);

// 获取热图数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoStatHeatMap(LLONG lAttachHandle, const NET_IN_GET_VIDEOSTAT_HEATMAP* pInParam, NET_OUT_GET_VIDEOSTAT_HEATMAP* pOutParam, int nWaitTime);

// 取消订阅热度图数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoStatHeatMap(LLONG lAttachHandle);

// 视频分析设备的方法调用,pstInParam与pstOutParam内存由用户申请释放，大小参照szCmd对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoAnalyseDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// 获取视频分析对象,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseGetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_GETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_GETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// 设置视频分析对象,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VideoAnalyseSetTemplateImage(LLONG lLoginID, const NET_IN_VIDEOANALYSE_SETTEMPLATEIMAGE* pstInParam, NET_OUT_VIDEOANALYSE_SETTEMPLATEIMAGE* pstOutParam, int nWaitTime=1000);

// 串口设备的方法调用,pstInParam与pstOutParam内存由用户申请释放，大小参照szCmd对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCommDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// 智能跟踪球控制接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlIntelliTracker(LLONG lLoginID, NET_IN_CONTROL_INTELLITRACKER* pstInParam, NET_OUT_CONTROL_INTELLITRACKER* pstOutParam);

// 主从式设备的方法调用,具体参数参见上面定义CLIENT_OperateMasterSlaveDevice接口参数定义
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveDevice(LLONG lLoginID, int nChannelID, char* szCmd, void *pstInParam, void *pstOutParam, int waittime=1000);

// 视频拼接方法调用,pstInParam与pstOutParam内存由用户申请释放，大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateVideoJoin(LLONG lLoginID, NET_VIDEOJOIN_OPERATE_TYPE emType, void* pstInParam, void* pstOutParam, int nWaitTime);

////  视频诊断

// 实时获取视频诊断结果,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartVideoDiagnosis(LLONG lLoginID, NET_IN_VIDEODIAGNOSIS *pstInParam, NET_OUT_VIDEODIAGNOSIS *pstOutParam);

// 停止视频诊断结果上报
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopVideoDiagnosis(LLONG hDiagnosisHandle);

// 开始视频诊断结果查询,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindDiagnosisResult(LLONG lLoginID, NET_IN_FIND_DIAGNOSIS* pstInParam, NET_OUT_FIND_DIAGNOSIS* pstOutParam);

// 获取视频诊断结果信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindDiagnosisResult(LLONG hFindHandle,NET_IN_DIAGNOSIS_INFO* pstInParam, NET_OUT_DIAGNOSIS_INFO* pstOutParam);

// 结束视频诊断结果查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindDiagnosis(LLONG hFindHandle);

// 启动实时诊断计划,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartRealTimeProject(LLONG lLoginID,NET_IN_START_RT_PROJECT_INFO* pstInParam, NET_OUT_START_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// 停止实时诊断计划,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopRealTimeProject(LLONG lLoginID,NET_IN_STOP_RT_PROJECT_INFO* pstInParam, NET_OUT_STOP_RT_PROJECT_INFO* pstOutParam, int nWaitTime);

// 启动手动诊断计划, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartManualDiagnosisProject(LLONG lLoginID, NET_IN_START_MANUAL_PROJECT_INFO* pstInParam, NET_OUT_START_MANUAL_PROJECT_INFO* pstOutParam, int nWaitTime);
// 停止手动诊断计划, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopManualDiagnosisProject(LLONG lLoginID, NET_IN_STOP_MANUAL_PROJECT_INFO* pstInParam, NET_OUT_STOP_MANUAL_PROJECT_INFO* pstOutParam, int nWaitTime);

// 更新计划或者任务的诊断背景图片, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateProjectBackGround(LLONG lLoginID, const NET_IN_UPDATE_PROJECT_BACKGROUND_INFO* pstInParam, NET_OUT_UPDATE_PROJECT_BACKGROUND_INFO* pstOutParam, int nWaitTime);

// 获取智能交通车位状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetParkingSpaceStatus(LLONG lLoginID, NET_IN_GET_PARKINGSPACE_STATUS* pstInParam, NET_OUT_GET_PARKINGSPACE_STATUS* pstOutParam);

// 订阅指定的车位图片信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachParkingSpaceData(LLONG lLoginID, NET_IN_ATTACH_PARKINGSPACE* pstInParam, NET_OUT_ATTACH_PARKINGSPACE* pstOutParam);

// 取消订阅指定的车位图片信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachParkingSpaceData(NET_IN_DETACH_PARKINGSPACE* pstInParam, NET_OUT_DETACH_PARKINGSPACE* pstOutParam);

// 订阅过车信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCarPassInfo(LLONG lLoginID, NET_IN_ATTACH_CAR_PASS_INFO* pstInParam, NET_OUT_ATTACH_CAR_PASS_INFO* pstOutParam , int nWaitTime);

// 取消订阅过车信息 lCarPassInfoHandle 为 CLIENT_AttachCarPassInfo 返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCarPassInfo(LLONG lCarPassInfoHandle);

// 订阅指定车道信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLanesState(LLONG lLoginID, NET_IN_ATTACH_LANES_STATE* pstInParam, NET_OUT_ATTACH_LANES_STATE* pstOutParam, int nWaitTime);

// 取消订阅指定车道信息 lLanesStateHandle为CLIENT_AttachLanesState返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLanesState(LLONG lLanesStateHandle);

// 获取车位灯状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCarPortLightStatus(LLONG lLoginID, NET_IN_GET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_GET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// 设置车位灯状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCarPortLightStatus(LLONG lLoginID, NET_IN_SET_CARPORTLIGHT_STATUS* pstInParam, NET_OUT_SET_CARPORTLIGHT_STATUS* pstOutParam, int waittime=1000);

// 获取车位锁状态 
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_GetParkingLockState(LLONG lLoginID, const NET_IN_GET_PARKINGLOCK_STATE_INFO *pstInParam, NET_OUT_GET_PARKINGLOCK_STATE_INFO *pstOutParam, int nWaitTime);

// 设置车位锁状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingLockState(LLONG lLoginID, const NET_IN_SET_PARKINGLOCK_STATE_INFO *pstInParm, NET_OUT_SET_PARKINGLOCK_STATE_INFO *pstOutParam, int nWaitTIme);

// 设置停车规则
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingRule(LLONG lLoginID, const NET_IN_SET_PARKINGRULE_INFO *pstInParm, NET_OUT_SET_PARKINGRULE_INFO *pstOutParam, int nWaitTime);

// 订阅智能分析进度（适用于视频分析源为录像文件时）,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AttachVideoAnalyseState(LLONG lLoginID, NET_IN_ATTACH_VIDEOANALYSE_STATE* pstInParam, NET_OUT_ATTACH_VIDEOANALYSE_STATE* pstOutParam, int nWaittime=1000);

// 停止订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVideoAnalyseState(LLONG lAttachHandle);

// 订阅前端设备对讲状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachTalkState(LLONG lLoginID, NET_IN_ATTACH_TALK_STATE* pstInParam, NET_OUT_ATTACH_TALK_STATE* pstOutParam, int nWaitTime = 1000);

// 取消订阅前端设备对讲状态, lAttachHandle为CLIENT_AttachTalkState返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachTalkState(LLONG lAttachHandle);

////////////////////////////////视频浓缩接口////////////////////////////////

// 添加视频浓缩任务,该接口把文件与分析规则绑定,不够灵活.
// 新的IVS-S已不支持这种方式,请转用CLIENT_PreHandleVideoSynopsisTask和CLIENT_RunVideoSynopsisTask的组合接口,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddVideoSynopsisTask(LLONG lLoginID,   NET_IN_ADD_VIDEOSYNOPSIS* pstInParam, NET_OUT_ADD_VIDEOSYNOPSIS* pstOutParam);

//IVS-S采用的新浓缩方式,先对视频文件进行预处理(比较耗时),在预处理的基础上可以调整视频分析规则,从而针对同一文件快速得到不同的浓缩结果.
//视频文件预处理接口
//返回TRUE表示任务全部成功,返回FALSE表示至少有一个任务失败,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreHandleVideoSynopsisTask(LLONG lLoginID,  const NET_IN_PRE_HANDLE_VIDEOSYNOPSIS* pstInParam, NET_OUT_PRE_HANDLE_VIDEOSYNOPSIS* pstOutParam);

// 按通道访问
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPreTaskByChannel(LLONG lLoginID, const NET_IN_PRETASK_BYCHANNEL* pstInParam, NET_OUT_PRETASK_BYCHANNEL* pstOutParam);

// 获取浓缩任务进度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoSynopsisState(LLONG lLoginID, const NET_IN_GET_VIDEOSYNOPSIS_STATE* pstInParam, NET_OUT_GET_VIDEOSYNOPSIS_STATE* pstOutParam);

// 开始查询智能录像浓缩历史
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_STARTFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_STARTFIND* pstOutParam);

// 获取历史搜索结果信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_DOFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_DOFIND* pstOutParam);

// 结束浓缩历史查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindVideoSynopsisHistory(LLONG lLoginID, const NET_IN_VIDEOSYNOPSIS_STOPFIND* pstInParam, NET_OUT_VIDEOSYNOPSIS_STOPFIND* pstOutParam);
//视频浓缩处理接口
//返回TRUE表示任务全部成功,返回FALSE表示至少有一个任务失败,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RunVideoSynopsisTask(LLONG lLoginID, const NET_IN_RUN_VIDEOSYNOPSIS_TASK* pstInParam, NET_OUT_RUN_VIDEOSYNOPSIS_TASK* pstOutParam);

// 暂停视频浓缩任务,pstInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseVideoSynopsisTask(LLONG lLoginID, NET_IN_PAUSE_VIDEOSYNOPSIS* pstInParam);

// 移除视频浓缩任务,pstInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveVideoSynopsisTask(LLONG lLoginID, NET_IN_REMOVE_VIDEOSYNOPSIS* pstInParam);

// 订阅实时浓缩视频物体信息pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadObjectData(LLONG lLoginID, NET_IN_REALLOAD_OBJECTDATA* pstInParam, NET_OUT_REALLOAD_OBJECTDATA* pstOutParam);

// 停止订阅实时浓缩视频物体信息,pstInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadObjectData(LLONG lRealLoadHandle, NET_IN_STOPLOAD_OBJECTDATA* pstInParam);

// 订阅实时浓缩视频进度信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RealLoadSynopsisState(LLONG lLoginID, NET_IN_REALLAOD_SYNOPSISSTATE* pstInParam, NET_OUT_REALLOAD_SYNOPSISSTATE* pstOutParam);

// 停止订阅实时浓缩视频进度信息,pstInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynopsisState(LLONG lRealLoadHandle, NET_IN_STOPLOAD_SYNOPSISSTATE* pstInParam);

// 查询浓缩视频任务相关信息接口,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoSynopsisInfo(LLONG lLoginID, NET_IN_QUERY_VIDEOSYNOPSIS* pstInParam, NET_OUT_QUERY_VIDEOSYNOPSIS* pstuOutParam);

// 按查询条件查询视频浓缩文件,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindSynopsisFile(LLONG lLoginID, NET_IN_FIND_SYNOPSISFILE *pstInParam, NET_OUT_FIND_SYNOPSISFILE *pstOutParam);    

// 查找视频浓缩文件,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL    CALL_METHOD CLIENT_FindNextSynopsisFile(LLONG lFindHandle, NET_IN_FINDNEXT_SYNOPSISFILE *pstInParam, NET_OUT_FINDNEXT_SYNOPSISFILE *pstOutParam);

// 结束视频浓缩文件查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SynopsisFindClose(LLONG lFindHandle);

// 下载视频浓缩相关文件,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownLoadSynosisFile(LLONG lLoginID, NET_IN_DOWNLOAD_SYNOPSISFILE *pstInParam, NET_OUT_DOWNLOAD_SYNOPSISFILE *pstOutParam);

// 停止下载
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLoadSynosisFile(LLONG lDownLoadHandle);

// 请求浓缩视频服务器根据文件(夹)路径,生成文件信息,pstInParam内存由用户申请释放
CLIENT_NET_API BOOL    CALL_METHOD    CLIENT_SetFilePathInfo(LLONG lLoginID, NET_IN_SET_FILEPATHINFO* pstInParam);

// 监听添加文件信息状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddFileState(LLONG lLoginID, const NET_IN_ADDFILE_STATE* pstInParam, NET_OUT_ADDFILE_STATE *pstOutParam, int nWaitTime = 1000);

// 取消监听添加文件信息状, lAttachHandle是CLIENT_AttacAddFileState返回值
CLIENT_NET_API LLONG CALL_METHOD CLIENT_DetachAddFileState(LLONG lAttachHandle);

/////////////////////////////////人脸识别接口/////////////////////////////////////////
// 人脸识别数据库信息操作（包括添加,修改和删除）,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionDB(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITIONDB* pstInParam, NET_OUT_OPERATE_FACERECONGNITIONDB *pstOutParam, int nWaitTime = 1000);

// 添加多个人员信息和人脸样本
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BatchAppendFaceRecognition(LLONG lLoginID, const NET_IN_BATCH_APPEND_FACERECONGNITION* pstInParam, NET_OUT_BATCH_APPEND_FACERECONGNITION *pstOutParam, const int nWaitTime);

// 按条件查询人脸识别结果 ,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// 开始人脸检测/注册库的多通道查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognition(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITION* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITION *pstOutParam, int nWaitTime);

// 查找人脸识别结果:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕(每次最多只能查询20条记录),pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognition(const NET_IN_DOFIND_FACERECONGNITION* pstInParam, NET_OUT_DOFIND_FACERECONGNITION *pstOutParam, int nWaitTime = 1000);

// 结束查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognition(LLONG lFindHandle);

// 开始人脸识别多通道查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartMultiFindFaceRecognitionRecord(LLONG lLoginID, const NET_IN_STARTMULTIFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// 多通道查找文件:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognitionRecord(const NET_IN_DOFIND_FACERECONGNITIONRECORD* pstInParam, NET_OUT_DOFIND_FACERECONGNITIONRECORD *pstOutParam, int nWaitTime);

// 多通道查找文件接口扩展(nTotalCount:需要查询的条数, 返回值为媒体文件条数 返回值<nTotalCount则相应时间段内的文件查询完毕)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceRecognitionRecordEx(const NET_IN_DOFIND_FACERECONGNITIONRECORD_EX* pstInParam, NET_OUT_DOFIND_FACERECONGNITIONRECORD_EX *pstOutParam, int nWaitTime);

// 结束查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceRecognitionRecord(LLONG lFindHandle);

// 订阅历史库以图搜图查询结果, 配合CLIENT_StartFindFaceRecognition使用, pstInParam和pstOutParam由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachResultOfFindHistoryByPic(LLONG lLoginID, NET_IN_ATTACH_RESULT_FINDHISTORY_BYPIC* pstInParam, NET_OUT_ATTACH_RESULT_FINDHISTORY_BYPIC* pstOutParam, int nWaitTime);
// 取消订阅历史库以图搜图查询结果, lFindHandle 为 CLIENT_AttachResultOfFindRegisterByPic接口返回的值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachResultOfFindHistoryByPic(LLONG lFindHandle);

// 订阅人体历史库以图搜图查询结果, 配合CLIENT_StartFindFaceRecognition使用, pstInParam和pstOutParam由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachResultOfHumanHistoryByPic(LLONG lLoginID, NET_IN_ATTACH_RESULT_HUMAN_HISTORY_BYPIC* pstInParam, NET_OUT_ATTACH_RESULT_HUMAN_HISTORY_BYPIC* pstOutParam, int nWaitTime);
// 取消订阅人体历史库以图搜图查询结果, lFindHandle 为CLIENT_AttachResultOfHumanHistoryByPic 接口返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachResultOfHumanHistoryByPic(LLONG lFindHandle);

// 人脸检测(输入一张大图,输入大图中被检测出来的人脸图片),pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectFace(LLONG lLoginID, const NET_IN_DETECT_FACE* pstInParam, NET_OUT_DETECT_FACE *pstOutParam, int nWaitTime = 1000);

// 人脸识别人员组操作（包括添加,修改和删除）,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionGroup(LLONG lLoginID, const NET_IN_OPERATE_FACERECONGNITION_GROUP* pstInParam, NET_OUT_OPERATE_FACERECONGNITION_GROUP *pstOutParam, int nWaitTime = 1000);

// 人脸识别人员类型操作（包括添加,修改和删除）,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_OPERATE_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_OPERATE_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// 人脸识别获取人员类型,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceRecognitionPersonType(LLONG lLoginID, const NET_IN_GET_FACERECOGNITION_PERSON_TYPE* pstInParam, NET_OUT_GET_FACERECOGNITION_PERSON_TYPE *pstOutParam, int nWaitTime);

// 查询人脸识别人员组信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindGroupInfo(LLONG lLoginID, const NET_IN_FIND_GROUP_INFO* pstInParam, NET_OUT_FIND_GROUP_INFO *pstOutParam, int nWaitTime = 1000);

// 获取布控在视频通道的组信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetGroupInfoForChannel(LLONG lLoginID, const NET_IN_GET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_GET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime = 3000);

// 布控通道人员组信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGroupInfoForChannel(LLONG lLoginID, const NET_IN_SET_GROUPINFO_FOR_CHANNEL* pstInParam, NET_OUT_SET_GROUPINFO_FOR_CHANNEL *pstOutParam, int nWaitTime = 1000);

//订阅人脸查询状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceFindState(LLONG lLoginID, const NET_IN_FACE_FIND_STATE* pstInParam, NET_OUT_FACE_FIND_STATE *pstOutParam, int nWaitTime = 1000);

//取消订阅人脸查询状态,lAttachHandle为CLIENT_AttachFaceFindState返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceFindState(LLONG lAttachHandle);

// 设置检索的图片信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionSetSearchImageInfo(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_SET_SEARCH_IMAGE_INFO *pstOutParam, int nWaitTime = 1000);

// 以人脸库的角度进行布控, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionPutDisposition(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO *pstOutParam, int nWaitTime = 1000);

// 以人脸库的角度进行撤控, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionDelDisposition(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO *pstOutParam, int nWaitTime = 1000);

// 向服务器提交多张大图，从中检测人脸图片, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_FaceRecognitionDetectMultiFace(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_DETECT_MULTI_FACE_INFO *pstOutParam, int nWaitTime);

// 订阅大图检测小图进度,配合CLIENT_FaceRecognitionDetectMultiFace使用, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDetectMultiFaceState(LLONG lLoginID, const NET_IN_MULTIFACE_DETECT_STATE* pstInParam, NET_OUT_MULTIFACE_DETECT_STATE *pstOutParam, int nWaitTime);

// 取消订阅大图检测小图进度, lAttachHandle为CLIENT_AttachDetectMultiFaceState 返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDetectMultiFaceState(LLONG lAttachHandle);

// 人员重新建模, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// 人脸组重新建模, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionGroupReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_GROUP_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_GROUP_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// 停止人脸组建模, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceRecognitionStopGroupReAbstract(LLONG lLoginID, const NET_IN_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO* pstInParam, NET_OUT_FACE_RECOGNITION_STOP_GROUP_REABSTRACT_INFO *pstOutParam, int nWaitTime);

// 获取人脸属性,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceParam(LLONG lLoginID, const NET_IN_GET_FACE_PARAM* pstInParam, NET_OUT_GET_FACE_PARAM *pstOutParam, int nWaitTime);

// 设置人脸属性,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFaceParam(LLONG lLoginID, const NET_IN_SET_FACE_PARAM* pstInParam, NET_OUT_SET_FACE_PARAM *pstOutParam, int nWaitTime);

//////////////////////////////// 刻录上传接口 /////////////////////////////////

// 打开刻录会话, 返回刻录会话句柄,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartBurnSession(LLONG lLoginID, const NET_IN_START_BURN_SESSION* pstInParam, NET_OUT_START_BURN_SESSION *pstOutParam, int nWaitTime);

// 关闭刻录会话
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurnSession(LLONG lBurnSession);

// 开始刻录,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartBurn(LLONG lBurnSession, const NET_IN_START_BURN* pstInParam, NET_OUT_START_BURN *pstOutParam, int nWaitTime);

// 停止刻录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopBurn(LLONG lBurnSession);

// 暂停/恢复刻录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PauseBurn(LLONG lBurnSession, BOOL bPause);

// 重点标记,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnMarkTag(LLONG lBurnSession, const NET_IN_BURN_MARK_TAG* pstInParam, NET_OUT_BURN_MARK_TAG *pstOutParam, int nWaitTime);

// 换盘,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnChangeDisk(LLONG lBurnSession, const NET_IN_BURN_CHANGE_DISK* pstInParam, NET_OUT_BURN_CHANGE_DISK *pstOutParam, int nWaitTime);

// 获取刻录状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BurnGetState(LLONG lBurnSession, const NET_IN_BURN_GET_STATE* pstInParam, NET_OUT_BURN_GET_STATE *pstOutParam, int nWaitTime);

// 监听刻录状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnState(LLONG lLoginID, const NET_IN_ATTACH_STATE* pstInParam, NET_OUT_ATTACH_STATE *pstOutParam, int nWaitTime = 1000);

// 取消监听刻录状态,lAttachHandle是CLIENT_AttachBurnState返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnState(LLONG lAttachHandle);

// 刻录上传开始 返回此次上传操作句柄, 注意以下接口不能在fAttachBurnStateCB回调函数里面调用,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadFileBurned(LLONG lLoginID, const NET_IN_FILEBURNED_START* pstInParam, NET_OUT_FILEBURNED_START *pstOutParam, int nWaitTime = 1000);

// 刻录上传文件,lUploadHandle是CLIENT_StartUploadFileBurned返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendFileBurned(LLONG lUploadHandle);

// 刻录上传停止,lUploadHandle是CLIENT_StartUploadFileBurned返回值,此接口不能在fBurnFileCallBack回调函数中调用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadFileBurned(LLONG lUploadHandle);

// 监听刻录校验状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCheckState(LLONG lLoginID, const NET_IN_ATTACH_BURN_CHECK* pstInParam, NET_OUT_ATTACH_BURN_CHECK* pstOutParam, int nWaitTime = 1000);

// 取消监听刻录校验状态,lAttachHandle是CLIENT_AttachBurnCheckState返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCheckState(LLONG lAttachHandle);

// 订阅刻录案件信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnCase(LLONG lLoginID, const NET_IN_ATTACH_BURN_CASE* pInParam, NET_OUT_ATTACH_BURN_CASE* pOutParam, int nWaitTime);

// 取消订阅刻录案件信息,lAttachHandle是CLIENT_AttachBurnCase返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnCase(LLONG lAttachHandle);

// 订阅刻录设备状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBurnDevState(LLONG lLoginID, const NET_IN_ATTACH_BURN_DEV_STATE* pInParam, NET_OUT_ATTACH_BURN_DEV_STATE* pOutParam, int nWaitTime = 3000);

// 取消订阅刻录设备状态, lAttachHandle 是 CLIENT_AttachBurnDevState 返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBurnDevState(LLONG lAttachHandle);


// 监护仪数据
typedef struct tagNET_BODY_MIND_DATA_INFO
{
    DWORD       dwSize;
    UINT        nECG;               // 心率值,单位bpm
    UINT        nECGMax;            // 心率报警上限值,单位bpm
    UINT        nECGMin;            // 心率报警下限值,单位bpm
    UINT        nSPO2;              // 血氧值,单位%
    UINT        nSPO2Max;           // 血氧报警值上限值,单位%
    UINT        nSPO2Min;           // 血氧报警值下限值,单位%
    UINT        nRESP;              // 呼吸值,单位BrPM
    UINT        nRESPMax;           // 呼吸报警值上限,单位BrPM
    UINT        nRESPMin;           // 呼吸报警值下限,单位BrPM
    UINT        nNIBP_SYS;          // 收缩压（高压）值,单位mmHg
    UINT        nNIBP_SYSMax;       // 收缩压报警值上限,单位mmHg
    UINT        nNIBP_SYSMin;       // 收缩压报警值下限,单位mmHg
    UINT        nNIBP_AVG;          // 平均压值,单位mmHg
    UINT        nNIBP_AVGMax;       // 平均压报警值上限,单位mmHg
    UINT        nNIBP_AVGMin;       // 平均压报警值下限,单位mmHg
    UINT        nNIBP_DIA;          // 舒张压（低压）值,单位mmHg
    UINT        nNIBP_DIAMax;       // 舒张压报警值上限,单位mmHg
    UINT        nNIBP_DIAMin;       // 舒张压报警值下限,单位mmHg
} NET_BODY_MIND_DATA_INFO;

// 监护仪数据回调函数原形,lAttachHandle是CLIENT_AttachBodyMindData返回值
typedef void (CALLBACK *fBodyMindDataCallBack) (LLONG lAttachHandle, const NET_BODY_MIND_DATA_INFO* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachBodyMindData 接口输入参数
typedef struct tagNET_IN_ATTACH_BODY_MIND_DATA
{
    DWORD                       dwSize;
    fBodyMindDataCallBack       cbBodyMindData;                    // 监护仪数据回调函数
    LDWORD                      dwUser;                            // 用户数据
} NET_IN_ATTACH_BODY_MIND_DATA;

// CLIENT_AttachBodyMindData 接口输出参数
typedef struct tagNET_OUT_ATTACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_ATTACH_BODY_MIND_DATA;

// CLIENT_DetachBodyMindData 接口输入参数
typedef struct tagNET_IN_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_IN_DETACH_BODY_MIND_DATA;

// CLIENT_DetachBodyMindData 接口输出参数
typedef struct tagNET_OUT_DETACH_BODY_MIND_DATA
{
    DWORD                dwSize;
} NET_OUT_DETACH_BODY_MIND_DATA;


// 订阅监护仪数据信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBodyMindData(LLONG lLoginID, const NET_IN_ATTACH_BODY_MIND_DATA* pstInParam, NET_OUT_ATTACH_BODY_MIND_DATA* pstOutParam, int nWaitTime);

// 取消订阅监护仪数据信息,lAttachHandle是CLIENT_AttachBodyMindData返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBodyMindData(LLONG lAttachHandle, const NET_IN_DETACH_BODY_MIND_DATA* pstInParam, NET_OUT_DETACH_BODY_MIND_DATA *pstOutParam, int nWaitTime);



//////////////////////////////// 逻辑设备 /////////////////////////////////////////

// 订阅摄像头状态,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCameraState(LLONG lLoginID, const NET_IN_CAMERASTATE* pstInParam, NET_OUT_CAMERASTATE *pstOutParam, int nWaitTime = 3000);

// 停止订阅摄像头状态,lAttachHandle是CLIENT_AttachCameraState返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCameraState(LLONG lAttachHandle);

// 获取所有有效显示源,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameras(LLONG lLoginID, const DH_IN_MATRIX_GET_CAMERAS* pInParam, DH_OUT_MATRIX_GET_CAMERAS* pOutParam, int nWaitTime = 1000);

// 添加逻辑设备,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCameras(LLONG lLoginID, const DH_IN_ADD_LOGIC_DEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_DEVICE_CAMERA* pOutParam, int nWaitTime = 1000);

// 按设备信息添加显示源,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByDevice(LLONG lLoginID, const DH_IN_ADD_LOGIC_BYDEVICE_CAMERA* pInParam, DH_OUT_ADD_LOGIC_BYDEVICE_CAMERA* pOutParam, int nWaitTime = 1000);

// 批量添加视频源,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixAddCamerasByGroup(LLONG lLoginID, const NET_IN_ADD_LOGIC_BYGROUP_CAMERA* pInParam, NET_OUT_ADD_LOGIC_BYGROUP_CAMERA* pOutParam, int nWaitTime = 1000);
//////////////////////////////// 矩阵接口 /////////////////////////////////

// 查询产品定义(pstuProdDef内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryProductionDefinition(LLONG lLoginID, DH_PRODUCTION_DEFNITION* pstuProdDef, int nWaitTime = 1000);

// 查询矩阵子卡信息(pstuCardList内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryMatrixCardInfo(LLONG lLoginID, DH_MATRIX_CARD_LIST* pstuCardList, int nWaitTime = 1000);

// 查询系统状态(pstuStatus内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QuerySystemStatus(LLONG lLoginID, DH_SYSTEM_STATUS* pstuStatus, int nWaitTime = 1000);

// 查询分割能力(pstuCaps内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCaps(LLONG lLoginID, int nChannel, DH_SPLIT_CAPS* pstuCaps, int nWaitTime = 1000);

// 查询/设置显示源(pstuSplitSrc内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitSource(LLONG lLoginID, int nChannel, int nWindow, DH_SPLIT_SOURCE* pstuSplitSrc, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSource(LLONG lLoginID, int nChannel, int nWindow, const DH_SPLIT_SOURCE* pstuSplitSrc, int nSrcCount, int nWaitTime = 1000);
// 设置显示源, 支持输出参数(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitSourceEx(LLONG lLoginID, const NET_IN_SET_SPLIT_SOURCE* pInparam, NET_OUT_SET_SPLIT_SOURCE* pOutParam, int nWaitTime = 1000);

// NVR定制需求，交换两个窗口所显示的数据源
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitExchangeSource(LLONG lLoginID, const NET_IN_SPLIT_EXCHANGE_SOURCE* pInParam, NET_OUT_SPLIT_EXCHANGE_SOURCE* pOutParam, int nWaitTime = 1000);

// 查询/设置分割模式(pstuSplitInfo内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitMode(LLONG lLoginID, int nChannel, DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitMode(LLONG lLoginID, int nChannel, const DH_SPLIT_MODE_INFO* pstuSplitInfo, int nWaitTime = 1000);

// 查询分割分组数量
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitGroupCount(LLONG lLoginID, int nChannel, DH_SPLIT_MODE emSplitMode, int* pnGroupCount, int nWaitTime = 1000);

// 查询视频输出能力(pstuCaps内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoOutCaps(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_CAPS* pstuCaps, int nWaitTime = 1000);

// 设置视频输出选项(pstuVideoOut内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetVideoOutOption(LLONG lLoginID, int nChannel, const DH_VIDEO_OUT_OPT* pstuVideoOut, int nWaitTime = 1000);

// 查询视频输入通道目前在哪个窗口输出显示(pstuWnds内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryVideoOutWindows(LLONG lLoginID, int nChannel, DH_VIDEO_OUT_WINDOW* pstuWnds, int nMaxWndCount, int* pnRetWndCount, int nWaitTime = 1000);

// 设置窗口位置(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_SET_RECT* pInParam, DH_OUT_SPLIT_SET_RECT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowRect(LLONG lLoginID, const DH_IN_SPLIT_GET_RECT* pInParam, DH_OUT_SPLIT_GET_RECT* pOutParam, int nWaitTime = 1000);

// 开窗/关窗(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_OPEN_WINDOW* pInParam, DH_OUT_SPLIT_OPEN_WINDOW* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseSplitWindow(LLONG lLoginID, const DH_IN_SPLIT_CLOSE_WINDOW* pInParam, DH_OUT_SPLIT_CLOSE_WINDOW* pOutParam, int nWaitTime = 1000);

// 设置窗口次序(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitTopWindow(LLONG lLoginID, const DH_IN_SPLIT_SET_TOP_WINDOW* pInParam, DH_OUT_SPLIT_SET_TOP_WINDOW* pOutParam, int nWaitTime = 1000);

// 获取当前显示的窗口信息(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitWindowsInfo(LLONG lLoginID, const DH_IN_SPLIT_GET_WINDOWS* pInParam, DH_OUT_SPLIT_GET_WINDOWS* pOutParam, int nWaitTime = 1000);

// 载入/保存收藏夹(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LoadSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_LOAD_COLLECTION* pInParam, DH_OUT_SPLIT_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_SAVE_COLLECTION* pInParam, DH_OUT_SPLIT_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// 获取收藏夹信息(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitCollections(LLONG lLoginID, const DH_IN_SPLIT_GET_COLLECTIONS* pInParam, DH_OUT_SPLIT_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// 重命名收藏夹(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_RENAME_COLLECTION* pInParam, DH_OUT_SPLIT_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// 删除收藏夹(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteSplitCollection(LLONG lLoginID, const DH_IN_SPLIT_DELETE_COLLECTION* pInParam, DH_OUT_SPLIT_DELETE_COLLECTION* pOutParam, int nWaitTime = 1000);

// 解码策略(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDecodePolicy(LLONG lLoginID, const DH_IN_SET_DEC_POLICY* pInParam, DH_OUT_SET_DEC_POLICY* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDecodePolicy(LLONG lLoginID, const DH_IN_GET_DEC_POLICY* pInParam, DH_OUT_GET_DEC_POLICY* pOutParam, int nWaitTime = 1000);

// 音频输出模式(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitAudioOuput(LLONG lLoginID, const DH_IN_SET_AUDIO_OUTPUT* pInParam, DH_OUT_SET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitAudioOuput(LLONG lLoginID, const DH_IN_GET_AUDIO_OUTPUT* pInParam, DH_OUT_GET_AUDIO_OUTPUT* pOutParam, int nWaitTime = 1000);

// 设置显示源(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSetCameras(LLONG lLoginID, const DH_IN_MATRIX_SET_CAMERAS* pInParam, DH_OUT_MATRIX_SET_CAMERAS* pOutParam, int nWaitTime = 1000);

// 获取视频输入能力(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoInCaps(LLONG lLoginID, const DH_IN_GET_VIDEO_IN_CAPS* pInParam, DH_OUT_GET_VIDEO_IN_CAPS* pOutParam, int nWaitTime = 1000);

// 获取视频输出模式(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnumVideoOutModes(LLONG lLoginID, const DH_IN_ENUM_VIDEO_OUT_MODES* pInParam, DH_OUT_ENUM_VIDEO_OUT_MODES* pOutParam, int nWaitTime = 1000);

// 获取/设置解码窗口输出OSD信息(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_GET_OSD* pInParam, DH_OUT_SPLIT_GET_OSD* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSD(LLONG lLoginID, const DH_IN_SPLIT_SET_OSD* pInParam, DH_OUT_SPLIT_SET_OSD* pOutParam, int nWaitTime = 1000);

// 获取/设置解码窗口输出OSD信息扩展接口(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_GET_OSD_EX* pInParam, NET_OUT_SPLIT_GET_OSD_EX* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSplitOSDEx(LLONG lLoginID, const NET_IN_SPLIT_SET_OSD_EX* pInParam, NET_OUT_SPLIT_SET_OSD_EX* pOutParam, int nWaitTime = 1000);

// 设置窗口轮巡显示源(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTourSource(LLONG lLoginID, const NET_IN_SET_TOUR_SOURCE* pInParam, NET_OUT_SET_TOUR_SOURCE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTourSource(LLONG lLoginID, const NET_IN_GET_TOUR_SOURCE* pInParam, NET_OUT_GET_TOUR_SOURCE* pOutParam, int nWaitTime);

// 订阅轮巡状态(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSplitTour(LLONG lLoginID, const NET_IN_ATTACH_SPLIT_TOUR* pInParam, NET_OUT_ATTACH_SPLIT_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSplitTour(LLONG lAttachHandle);

// 下位矩阵切换(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSwitch(LLONG lLoginID, const NET_IN_MATRIX_SWITCH* pInParam, NET_OUT_MATRIX_SWITCH* pOutParam, int nWaitTime);

// 设置显示源, 支持同时设置多个窗口(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SplitSetMultiSource(LLONG lLoginID, const NET_IN_SPLIT_SET_MULTI_SOURCE* pInParam, NET_OUT_SPLIT_SET_MULTI_SOURCE* pOutParam, int nWaitTime);

// 视频分割操作(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplit(LLONG lLoginID, NET_SPLIT_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);
// 订阅窗口显示源信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWindowsSource( LLONG lLoginID, const NET_IN_ATTACH_WINDOW_SOURCE* pInParam, NET_OUT_ATTACH_WINDOW_SOURCE* pOutParam, int nWaitTime );
// 取消订阅窗口显示源信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWindowsSource( LLONG lAttachHandle );

// 窗口图像局部放大(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowRegionEnlarge(LLONG lLoginID, const NET_IN_WINDOW_REGION_ENLARGE* pInParam, NET_OUT_WINDOW_REGION_ENLARGE* pOutParam, int nWaitTime);

// 窗口图像局部放大还原(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowEnlargeReduction(LLONG lLoginID, const NET_IN_WINDOW_ENLARGE_REDUCTION* pInParam, NET_OUT_WINDOW_ENLARGE_REDUCTION* pOutParam, int nWaitTime);

// 矩阵窗口鼠标操作(pInparam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WindowButtonAction(LLONG lLoginID, const NET_IN_WINDOW_ONBUTTON_ACTION* pInParam, NET_OUT_WINDOW_ONBUTTON_ACTION* pOutParam, int nWaitTime);

// 分割窗口播放操作类型
typedef enum tagNET_PLAYER_OPERATE_TYPE
{
    NET_PLAYER_OPERATE_OPEN,                // 打开播放器，NET_IN_PLAYER_OPEN，
    NET_PLAYER_OPERATE_CLOSE,               // 关闭播放器，NET_IN_PLAYER_CLOSE
    NET_PLAYER_OPERATE_START,               // 开始播放，NET_IN_PLAYER_START
    NET_PLAYER_OPERATE_STOP,                // 停止播放，NET_IN_PLAYER_STOP
    NET_PLAYER_OPERATE_PAUSE,               // 暂停/恢复播放，NET_IN_PLAYER_PAUSE
    NET_PLAYER_OPERATE_SEEK_TIME,           // 跳转到指定时间播放，NET_IN_PLAYER_SEEK_TIME
    NET_PLAYER_OPERATE_STEP_FRAME,          // 单帧回放, 需要暂停后使用，NET_IN_PLAYER_STEP_FRAME
    NET_PLAYER_OPERATE_GET_STATE,           // 取当前回放状态，NET_IN_PLAYER_GET_STATE
    NET_PLAYER_OPERATE_GET_TIME,            // 获取当前回放时间，NET_IN_PLAYER_GET_TIME与NET_OUT_PLAYER_GET_TIME
    NET_PLAYER_OPERATE_GET_SPEED,           // 获取播放速度，NET_IN_PLAYER_GET_SPEED与NET_OUT_PLAYER_GET_SPEED
    NET_PLAYER_OPERATE_SET_SPEED,           // 设置播放速度，NET_IN_PLAYER_SET_SPEED
    NET_PLAYER_OPERATE_GET_VOLUME,          // 获取音量，NET_IN_PLAYER_GET_VOLUME与NET_OUT_PLAYER_GET_VOLUME
    NET_PLAYER_OPERATE_SET_VOLUME,          // 设置音量，NET_IN_PLAYER_SET_VOLUME
    NET_PLAYER_OPERATE_GET_PLAYLIST,        // 获取文件列表，NET_IN_PLAYER_GET_PLAYLIST与NET_OUT_PLAYER_GET_PLAYLIST
    NET_PLAYER_OPERATE_GET_PLAYLIST_TS,     // 获取当前文件列表全部时间段信息，NET_IN_PLAYER_GET_PLAYLIST_TS与NET_OUT_PLAYER_GET_PLAYLIST_TS
}NET_PLAYER_OPERATE_TYPE;

// 播放条件
typedef struct tagNET_PLAYER_OPEN_CONDITION 
{
    DWORD               dwSize;
    char                szDevice[DH_DEV_ID_LEN];        // 指明远端的设备
    int                 nChannel;                       // 通道号
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
    NET_STREAM_TYPE     emStreamType;                   // 码流类型
    int                 nEventNum;                      // 事件类型个数
    int                 nEvent[MAX_IVS_EVENT_NUM];      // 事件类型
}NET_PLAYER_OPEN_CONDITION;

// 窗口码流发送模式
typedef enum tagNET_EM_SPLIT_TRANS_MODE
{
	NET_EM_SPLIT_TRANS_DIRECT,			// 直连
	NET_EM_SPLIT_TRANS_TRANSFER,		// 转发
} NET_EM_SPLIT_TRANS_MODE;

// 矩阵前端设备连接方式
typedef enum tagNET_EM_SPLIT_CONNECT_TYPE
{
	NET_EM_SPLIT_CONNECT_TCP,			// tcp
	NET_EM_SPLIT_CONNECT_UDP,			// udp
} NET_EM_SPLIT_CONNECT_TYPE;

// 打开播放器输入参数, 对应 NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_IN_PLAYER_OPEN 
{
    DWORD               		dwSize;
    LLONG               		lPlayerID;              // 播放实例ID
	const char*         		pszDevice;              // 指明从本地还是远端取录像, 为null代表从本地取录像,
														// bDeviceInfo为FALSE时有效
                                                        // 如果是从远端设备取,需要保持与NET_PLAYER_OPEN_CONDITION的szDevice一致
    NET_PLAYER_OPEN_CONDITION 	stuCondition;           // 查询条件
	BOOL						bDeviceInfo;			// 表示stuDeviceInfo是否有效
	DH_REMOTE_DEVICE			stuDeviceInfo;			// 设备信息, bDeviceInfo为TRUE时deviceInfo有效
	NET_EM_SPLIT_TRANS_MODE		emTransferMode;			// 窗口码流发送模式
	NET_EM_SPLIT_CONNECT_TYPE	emConnectType;			// 矩阵前端设备连接类型, 码流发送模式为转发模式下有效, 直连模式下采用默认拉流方式
	EM_SRC_PUSHSTREAM_TYPE  	emPushStream;           // 推流方式的码流类型,码流发送模式为转发模式, 并且连接类型为TCP或者UDP时有效
}NET_IN_PLAYER_OPEN;

// 打开播放器输出参数, 对应 NET_PLAYER_OPERATE_OPEN
typedef struct tagNET_OUT_PLAYER_OPEN 
{
    DWORD               dwSize;
}NET_OUT_PLAYER_OPEN;

// 关闭播放器输入参数, 对应 NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_IN_PLAYER_CLOSE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_CLOSE;

// 关闭播放器输出参数, 对应 NET_PLAYER_OPERATE_CLOSE
typedef struct tagNET_OUT_PLAYER_CLOSE
{
    DWORD               dwSize;
}NET_OUT_PLAYER_CLOSE;

// 开始播放输入参数, 对应 NET_PLAYER_OPERATE_START
typedef struct tagNET_IN_PLAYER_START
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_START;

// 开始播放输出参数, 对应 NET_PLAYER_OPERATE_START
typedef struct tagNET_OUT_PLAYER_START
{
    DWORD               dwSize;
}NET_OUT_PLAYER_START;

// 停止播放输入参数, 对应 NET_PLAYER_OPERATE_STOP
typedef struct tagNET_IN_PLAYER_STOP
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_STOP;

// 停止播放输出参数, 对应 NET_PLAYER_OPERATE_STOP
typedef struct tagNET_OUT_PLAYER_STOP
{
    DWORD               dwSize;
}NET_OUT_PLAYER_STOP;

// 暂停/恢复播放输入参数, 对应 NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_IN_PLAYER_PAUSE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    BOOL                bPause;                         // 是否暂停, TRUE-暂停播放, FALSE-恢复播放
}NET_IN_PLAYER_PAUSE;

// 暂停/恢复播放输出参数, 对应 NET_PLAYER_OPERATE_PAUSE
typedef struct tagNET_OUT_PLAYER_PAUSE
{
    DWORD               dwSize;
}NET_OUT_PLAYER_PAUSE;

// 跳转到指定时间播放输入参数, 对应 NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_IN_PLAYER_SEEK_TIME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    NET_TIME            stuTime;                        // 跳转时间
}NET_IN_PLAYER_SEEK_TIME;

// 跳转到指定时间播放输出参数, 对应 NET_PLAYER_OPERATE_SEEK_TIME
typedef struct tagNET_OUT_PLAYER_SEEK_TIME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SEEK_TIME;

// 单帧播放输入参数, 对应 NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_IN_PLAYER_STEP_FRAME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    BOOL                bForward;                       // 是否正向, TRUE-正向, FALSE-反向
}NET_IN_PLAYER_STEP_FRAME;

// 单帧播放输出参数, 对应 NET_PLAYER_OPERATE_STEP_FRAME
typedef struct tagNET_OUT_PLAYER_STEP_FRAME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_STEP_FRAME;

// 播放状态
typedef enum tagNET_PLAYER_STATE 
{
    NET_PLAYER_STATE_UNKNOWN,               // 未知
    NET_PLAYER_STATE_ERROR,                 // 有错误发生
    NET_PLAYER_STATE_READING,               // 就绪, 可以开启回放
    NET_PLAYER_STATE_STANDBY,               // 当前文件回放停止, 只能从头开始重新回放
    NET_PLAYER_STATE_RUNNING,               // 运行中
    NET_PLAYER_STATE_PAUSED,                // 已暂停, 可以从暂停点继续回放
    NET_PLAYER_STATE_CLOSED,                // 已关闭, 无法播放, 必须重新open进入Reading状态后才能回放
}NET_PLAYER_STATE;

// 查询播放状态输入参数, 对应 NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_IN_PLAYER_GET_STATE
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_GET_STATE;

// 查询播放状态输出参数, 对应 NET_PLAYER_OPERATE_GET_STATE
typedef struct tagNET_OUT_PLAYER_GET_STATE
{
    DWORD               dwSize;
    NET_PLAYER_STATE    emState;                        // 状态
}NET_OUT_PLAYER_GET_STATE;

// 获取当前回放时间输入参数, 对应 NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_IN_PLAYER_GET_TIME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_GET_TIME;

// 获取当前回放时间输出参数, 对应 NET_PLAYER_OPERATE_GET_TIME
typedef struct tagNET_OUT_PLAYER_GET_TIME
{
    DWORD               dwSize;
    NET_TIME            stuTime;                        // 当前播放时间
}NET_OUT_PLAYER_GET_TIME;

// 获取播放速度输入参数, 对应 NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_IN_PLAYER_GET_SPEED
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_GET_SPEED;

// 获取播放速度输出参数, 对应 NET_PLAYER_OPERATE_GET_SPEED
typedef struct tagNET_OUT_PLAYER_GET_SPEED
{
    DWORD               dwSize;
    float               fSpeed;                         // 播放速度, >0正向播放, <0方向播放
                                                        // 绝对值表示速度, =1正常速度, >1快放, <1慢放
}NET_OUT_PLAYER_GET_SPEED;

// 设置播放速度输入参数, 对应 NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_IN_PLAYER_SET_SPEED
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    float               fSpeed;                         // 播放速度, >0正向播放, <0方向播放
                                                        // 绝对值表示速度, =1正常速度, >1快放, <1慢放
}NET_IN_PLAYER_SET_SPEED;

// 设置播放速度输出参数, 对应 NET_PLAYER_OPERATE_SET_SPEED
typedef struct tagNET_OUT_PLAYER_SET_SPPED
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SET_SPEED;

// 获取播放音量输入参数, 对应 NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_IN_PLAYER_GET_VOLUME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_GET_VOLUME;

// 获取播放音量输出参数, 对应 NET_PLAYER_OPERATE_GET_VOLUME
typedef struct tagNET_OUT_PLAYER_GET_VOLUME
{
    DWORD               dwSize;
    int                 nVolume;                        // 播放音量, 0~100
}NET_OUT_PLAYER_GET_VOLUME;

// 设置播放音量输入参数, 对应 NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_IN_PLAYER_SET_VOLUME
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    int                 nVolume;                        // 播放音量, 0~100
}NET_IN_PLAYER_SET_VOLUME;

// 设置播放音量输出参数, 对应 NET_PLAYER_OPERATE_SET_VOLUME
typedef struct tagNET_OUT_PLAYER_SET_VOLUME
{
    DWORD               dwSize;
}NET_OUT_PLAYER_SET_VOLUME;

// 播放列表信息
typedef struct tagNET_PLAYER_PLAYLIST
{
    DWORD               dwSize;
    char                szFilePath[MAX_PATH];           // 文件路径, 与Url二者选一
    char                szUrl[MAX_PATH];                // URL, 与FilePath二者选一
    DH_DEVICE_PROTOCOL  emUrlProtocol;                  // URL协议类型
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
}NET_PLAYER_PLAYLIST;

// 获取当前播放列表输入参数, 对应 NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
    NET_TIME            stuStartTime;                   // 起始时间
    NET_TIME            stuEndTime;                     // 结束时间
    int                 nLimit;                         // 查询的文件数上限, 0表示无上限
}NET_IN_PLAYER_GET_PLAYLIST;

// 获取当前播放列表输出参数, 对应 NET_PLAYER_OPERATE_GET_PLAYLIST
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST
{
    DWORD               dwSize;
    NET_PLAYER_PLAYLIST* pstuPlayLists;                 // 播放列表, 用户分配内存
    int                 nMaxPlayListCount;              // 最大播放列表数量, 用户填写
    int                 nRetPlayListCount;              // 返回播放列表数量
}NET_OUT_PLAYER_GET_PLAYLIST;

// 获取当前文件列表全部时间段信息输入参数, 对应 NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_IN_PLAYER_GET_PLAYLIST_TS
{
    DWORD               dwSize;
    LLONG               lPlayerID;                      // 播放实例ID
}NET_IN_PLAYER_GET_PLAYLIST_TS;

typedef struct tagNET_PLAYLIST_TIMESECTION
{
    DWORD               dwSize;
    int                 nEvent;                         // 录像事件类型, 目前有
                                                        // EVENT_ALARM_COMMON, EVENT_ALARM_VIDEOBLIND, EVENT_ALARM_VIDEOLOSS, 
                                                        // EVENT_ALARM_MOTIONDETECT, EVENT_ALARM_LOCALALARM
    LPDH_TSECT          pstuTSs;                        // 时间段信息
    DWORD               unMaxTS;                        // 时间段最大个数
    DWORD               unRetTS;                        // 实际返回的时间段个数
}NET_PLAYLIST_TIMESECTION;

// 获取当前文件列表全部时间段信息输出参数, 对应 NET_PLAYER_OPERATE_GET_PLAYLIST_TS
typedef struct tagNET_OUT_PLAYER_GET_PLAYLIST_TS
{
    DWORD                    dwSize;
    DWORD                    dwEventNum;                // 录像类型数量
    NET_PLAYLIST_TIMESECTION stuTS[MAX_IVS_EVENT_NUM];  // 当前回放列表的时间段信息
}NET_OUT_PLAYER_GET_PLAYLIST_TS;

// 分割窗口播放操作,pInParam与pOutParam内存由用户申请释放，内存大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateSplitPlayer(LLONG lLoginID, NET_PLAYER_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// NET_ACCESS_LOCK_VER 入参
typedef struct tagNET_ACCESS_LOCK_VER_IN
{
    int                 nChannel;                       // 通道号
    char                reserved[128];                  // 保留
} NET_ACCESS_LOCK_VER_IN;

// NET_ACCESS_LOCK_VER 出参
typedef struct tagNET_ACCESS_LOCK_VER_OUT
{
    char                szVersion[32];                  // 版本
    NET_TIME            stuTime;                        // 时间
    char                reserved[512];                  // 保留
} NET_ACCESS_LOCK_VER_OUT;

// 门锁版本号, CLIENT_QueryDevState 查询类型 DH_DEVSTATE_ACCESS_LOCK_VER
typedef struct tagNET_ACCESS_LOCK_VER
{
    DWORD                    dwSize;
    NET_ACCESS_LOCK_VER_IN   stuIn;                     // 入参
    NET_ACCESS_LOCK_VER_OUT  stuOut;                    // 出参
} NET_ACCESS_LOCK_VER;

//////////////////////////////////// 电视墙控制 //////////////////////////////////////

// 电源控制,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PowerControl(LLONG lLoginID, const DH_IN_WM_POWER_CTRL* pInParam, DH_OUT_WM_POWER_CTRL* pOutParam, int nWaitTime = 1000);

// 获取/设置显示模式,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDisplayMode(LLONG lLoginID, const DH_IN_WM_SET_DISPLAY_MODE* pInParam, DH_OUT_WM_SET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDisplayMode(LLONG lLoginID, const DH_IN_WM_GET_DISPLAY_MODE* pInParam, DH_OUT_WM_GET_DISPLAY_MODE* pOutParam, int nWaitTime = 1000);

// 载入/保存预案,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LoadMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_LOAD_COLLECTION* pInParam, DH_OUT_WM_LOAD_COLLECTION* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SaveMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_SAVE_COLLECTION* pInParam, DH_OUT_WM_SAVE_COLLECTION* pOutParam, int nWaitTime = 1000);

// 获取电视墙预案,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMonitorWallCollections(LLONG lLoginID, const DH_IN_WM_GET_COLLECTIONS* pInParam, DH_OUT_WM_GET_COLLECTIONS* pOutParam, int nWaitTime = 1000);

// 电视墙预案重命名,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameMonitorWallCollection(LLONG lLoginID, const DH_IN_WM_RENAME_COLLECTION* pInParam, DH_OUT_WM_RENAME_COLLECTION* pOutParam, int nWaitTime = 1000);

// 获取/设置电视墙场景,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScene(LLONG lLoginID, const DH_IN_MONITORWALL_GET_SCENE* pInParam, DH_OUT_MONITORWALL_GET_SCENE* pOutParam, int nWaitTime = 1000);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScene(LLONG lLoginID, const DH_IN_MONITORWALL_SET_SCENE* pInParam, DH_OUT_MONITORWALL_SET_SCENE* pOutParam, int nWaitTime = 1000);

// CLIENT_GetCountOfMonitorWallScene接口输入参数(获取电视墙场景的个数)
typedef struct tagNET_IN_GET_COUNT_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    int                     nMonitorWallID;                 // 电视墙序号
} NET_IN_GET_COUNT_MONITORWALL_SCENE;

// CLIENT_GetCountOfMonitorWallScene接口输出参数(获取电视墙场景的个数)
typedef struct tagNET_OUT_GET_COUNT_MONITORWALL_SCENE
{
    DWORD                   dwSize;
    unsigned int            nSplitSceneCount;           // 获取到拼接屏场景的个数
    unsigned int            nSplitWndCount[300];            // 窗口信息的数组，数组的每个元素表示每个拼接屏场景中的窗口信息的个数
} NET_OUT_GET_COUNT_MONITORWALL_SCENE;

// 获取电视墙场景的个数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCountOfMonitorWallScene(LLONG lLoginID, const NET_IN_GET_COUNT_MONITORWALL_SCENE* pInParam, NET_OUT_GET_COUNT_MONITORWALL_SCENE* pOutParam, int nWaitTime);

// 获取电视墙显示单元能力集,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetAttributeCaps(LLONG lLoginID, const DH_IN_MONITORWALL_GET_ARRT_CAPS* pInParam, DH_OUT_MONITORWALL_GET_ARRT_CAPS* pOutParam, int nWaitTime = 1000);

// 电视墙显示单元自动调节,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallAutoAdjust(LLONG lLoginID, const DH_IN_MONITORWALL_AUTO_ADJUST* pInParam, DH_OUT_MONITORWALL_AUTO_ADJUST* pOutParam, int nWaitTime = 1000);

// 设置电视墙显示单元属性,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetAttribute(LLONG lLoginID, const DH_IN_MONITORWALL_SET_ATTR* pInParam, DH_OUT_MONITORWALL_SET_ATTR* pOutParam, int nWaitTime = 1000);

// 设置背光模式,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackLight(LLONG lLoginID, const DH_IN_MONITORWALL_SET_BACK_LIGHT* pInParam, DH_OUT_MONITORWALL_SET_BACK_LIGHT* pOutParam, int nWaitTime = 1000);

// 查询/设置屏幕开关计划,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetPowerSchedule(LLONG lLoginID, const NET_IN_MW_GET_POWER_SCHEDULE* pInParam, NET_OUT_MW_GET_POWER_SCHEDULE* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetPowerSchedule(LLONG lLoginID, const NET_IN_MW_SET_POWER_SCHEDULE* pInParam, NET_OUT_MW_SET_POWER_SCHEDULE* pOutParam, int nWaitTime);

// 查询/设置屏幕控制参数,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_GET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_GET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetScrnCtrlParam(LLONG lLoginID, const NET_IN_MW_SET_SCRN_CTRL_PARAM* pInParam, NET_OUT_MW_SET_SCRN_CTRL_PARAM* pOutParam, int nWaitTime);

// 查询/设置屏幕和窗口背景颜色,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetBackgroudColor(LLONG lLoginID, const NET_IN_MW_GET_BACKGROUDND_COLOR* pInParam, NET_OUT_MW_GET_BACKGROUDND_COLOR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSetBackgroudColor(LLONG lLoginID, const NET_IN_MW_SET_BACKGROUD_COLOR* pInParam, NET_OUT_MW_SET_BACKGROUD_COLOR* pOutParam, int nWaitTime);

// 订阅预案轮巡状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_MonitorWallAttachTour(LLONG lLoginID, const NET_IN_WM_ATTACH_TOUR* pInParam, NET_OUT_WM_ATTACH_TOUR* pOutParam, int nWaitTime);
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallDetachTour(LLONG lAttachHandle);

// 电视墙操作,pInParam与pOutParam内存由用户申请释放,大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMonitorWall(LLONG lLoginID, NET_MONITORWALL_OPERATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime);

// 切换显示屏的输入信号类型,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallSwitchDisplaySignal(LLONG lLoginID, const NET_IN_MW_SWITCH_DISPLAY_SIGNAL* pInParam, NET_OUT_MW_SWITCH_DISPLAY_SIGNAL* pOutParam, int nWaitTime);

//获取屏幕窗口解码信息CLIENT_MonitorWallGetWindowInfo入参
typedef struct tagNET_IN_MW_GET_WINODW_INFO
{
	DWORD                      dwSize;                     //结构体大小
	int                        nMonitorWallID;             //电视墙序号
	const char*                pszCompositeID;             //拼接屏或者单屏ID
}NET_IN_MW_GET_WINODW_INFO;

//码流的编码方式
typedef enum tagEM_NET_ENCODE_COMPRESSION
{
	EM_NET_ENCODE_COMPRESSION_UNKNOWN,                     //未知
	EM_NET_ENCODE_COMPRESSION_H264,                        //H264
	EM_NET_ENCODE_COMPRESSION_MPEG4,                       //MPEG4
	EM_NET_ENCODE_COMPRESSION_MJPEG,                       //MJPEG
	EM_NET_ENCODE_COMPRESSION_SVAC,                        //SVAC
	EM_NET_ENCODE_COMPRESSION_HIK,                         //HIK
	EM_NET_ENCODE_COMPRESSION_H265,                        //H265
}EM_NET_ENCODE_COMPRESSION;

//解码通道信息
typedef struct tagNET_MW_GET_WINDOW_INFO
{
	BOOL                       bEnable;                    //窗口使能状态
	NET_VIDEOCHANNEL_STATE     emState;                    //窗口解码状态
	UINT                       unNetflow;                  //网络流量(单位：kbps)
	UINT                       unBitrate;                  //码率(单位：kbps)
	UINT                       nFrame;                     //帧率
	CAPTURE_SIZE               emResolution;               //分辨率
	UINT                       unRealTimeFrame;            //实时统计的帧率
	EM_NET_ENCODE_COMPRESSION  emCompression;              //码流的编码方式
	BYTE                       byReserved[512];            //预留字节
}NET_MW_GET_WINDOW_INFO;

//获取屏幕窗口解码信息CLIENT_MonitorWallGetWindowInfo出参
typedef struct tagNET_OUT_MW_GET_WINDOW_INFO
{
	DWORD                      dwSize;                     //用户使用该结构体时,dwSize 需赋值为 sizeof(NET_OUT_MW_GET_WINDOW_INFO)
	int                        nVideoInfoNum;              //用户需要获取的解码通道信息个数,从0开始获取,用户指定
	NET_MW_GET_WINDOW_INFO*    pNetVideoChannelInfo;       //解码通道信息列表,用户申请空间,用户申请列表个数和nVideoInfoNum一致,申请内存大小为sizeof(NET_MW_GET_WINDOW_INFO)*nVideoInfoNum
	int                        nRetVideoInfoNum;           //返回实际获取到的解码通道信息个数,SDK返回
}NET_OUT_MW_GET_WINDOW_INFO;

//获取电视墙上屏幕窗口解码信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MonitorWallGetWindowInfo(LLONG lLoginID, const NET_IN_MW_GET_WINODW_INFO* pInParam, NET_OUT_MW_GET_WINDOW_INFO* pOutParam,int nWaitTime);

///////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////全景拼接服务器相关接口 start ///////////////////////////////////////////////
/////////////////////////////////////////////////////// ///////////////////////////////////////////////
// 全景拼接分组信息
typedef struct tagPANO_COMPOSITE_GROUP_INFO
{
    char                szGroupName[64];                // 全景拼接组名称
    /*以下行数和列数的乘积需大于1小于65*/
    int                 nRow;                           // 行数
    int                 nColumn;                        // 列数
    int                 nEncChannel;                    // 所关联的编码通道号, 可通过CLIENT_QueryMatrixCardInfo 接口获取
    BYTE                byReserved[1028];               //预留字节
} PANO_COMPOSITE_GROUP_INFO;

// 创建全景拼接分组 输入参数
typedef struct tagNET_IN_ADD_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
    BYTE                        byReserved[4];                  // 字节对齐
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // 全景拼接组信息
} NET_IN_ADD_PANO_COMPOSITE_GROUP;

// 创建全景拼接分组 输出参数
typedef struct tagNET_OUT_ADD_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
    BYTE                        byReserved[4];                  // 字节对齐
    char                        szGroupID[32];                  // 组ID
} NET_OUT_ADD_PANO_COMPOSITE_GROUP;

// 删除全景拼接分组 输入参数
typedef struct tagNET_IN_REMOVE_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
    UINT                        nGroupNum;                      // 要删除的组个数
    char                        szGroupIdList[16][32];          // 要删除的组ID列表
} NET_IN_REMOVE_PANO_COMPOSITE_GROUP;

// 删除全景拼接分组 输出参数
typedef struct tagNET_OUT_REMOVE_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
} NET_OUT_REMOVE_PANO_COMPOSITE_GROUP;

// 修改全景拼接分组输入参数
typedef struct tagNET_IN_MODIFY_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
    BYTE                        byReserved[4];                  // 字节对齐
    char                        szGroupID[32];                  // 组ID
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // 全景拼接组信息
} NET_IN_MODIFY_PANO_COMPOSITE_GROUP;

// 修改全景拼接分组输出参数
typedef struct tagNET_OUT_MODIFY_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
} NET_OUT_MODIFY_PANO_COMPOSITE_GROUP;

// 获取所有全景拼接分组信息输入参数
typedef struct tagNET_IN_GET_ALL_PANO_COMPOSITE_GROUP
{
    DWORD                       dwSize;                         // 结构体大小
} NET_IN_GET_ALL_PANO_COMPOSITE_GROUP;

// 全景拼接分组列表
typedef struct tagPANO_COMPOSITE_GROUP_LIST_INFO
{
    char                        szGroupID[32];                  // 组ID
    PANO_COMPOSITE_GROUP_INFO   stuPanoCompositeGroup;          // 全景拼接组信息
    BYTE                        byReserved[1024];               //预留字节
} PANO_COMPOSITE_GROUP_LIST_INFO;

// 获取所有全景拼接分组信息输出参数
typedef struct tagNET_OUT_GET_ALL_PANO_COMPOSITE_GROUP
{
    DWORD                           dwSize;                         // 结构体大小
    UINT                            nGroupNum;                      // 全景拼接组个数
    PANO_COMPOSITE_GROUP_LIST_INFO  stuGroupInfoList[16];           // 全景拼接组列表
} NET_OUT_GET_ALL_PANO_COMPOSITE_GROUP;

// 显示源视频码流类型
typedef enum tagEM_SOURCE_STREAM_TYPE
{
    EM_SOURCE_STREAM_UNKNOWN     = -1,  // 未知
    EM_SOURCE_STREAM_MAIN,              // 主码流
    EM_SOURCE_STREAM_EXTRA1,            // 辅码流1
    EM_SOURCE_STREAM_EXTRA2,            // 辅码流2
    EM_SOURCE_STREAM_EXTRA3,            // 辅码流3
    EM_SOURCE_STREAM_AUTO,              // 自动选择合适码流
    EM_SOURCE_STREAM_PREVIEW,           // 预览码流
} EM_SOURCE_STREAM_TYPE;

// 显示源设备信息
typedef struct tagNET_SOURCE_DEVICE_INFO
{
    int                         nDefinition;                        // 清晰度, 0-标清, 1-高清
    DH_DEVICE_PROTOCOL          emProtocol;                         // 协议类型
    char                        szIp[32];                           // IP, 空表示没有设置
    char                        szUser[64];                         // 用户名
    char                        szPwd[64];                          // 密码
    int                         nPort;                              // 端口
    int                         nVideoInputChannelNum;              // 视频输入通道数
    int                         nAudioInputChannelNum;              // 音频输入通道数
    DWORD                       dwHttpPort;                         // Http端口号, 0-65535
    DWORD                       dwRtspPort;                         // Rtsp端口号, 0-65535
    int                         nHint;                              // 0-普通视频源, 1-报警视频源
    char                        szDevClass[DH_DEV_TYPE_LEN];        // 设备类型, 如IPC, DVR, NVR等
    char                        szDevType[DH_DEV_TYPE_LEN];         // 设备具体型号, 如IPC-HF3300
    char                        szMainStreamUrl[MAX_PATH];          // 主码流url地址
    BYTE                        byReserved[1028];                   //预留字节
} NET_SOURCE_DEVICE_INFO;

// 全景拼接分组视频源信息
typedef struct tagPANO_COMPOSITE_GROUP_SOURCE_INFO
{
    UINT                            nChannelID;                     // 视频通道号
    EM_SOURCE_STREAM_TYPE           emStreamType;                   // 视频码流类型
    char                            szDeviceID[64];                 // 设备ID, 与stuDeviceInfo 互斥
    NET_SOURCE_DEVICE_INFO          stuDeviceInfo;                  // 显示源设备信息, szDeviceID 为空时有效
    BYTE                            byReserved[1024];               //预留字节
} PANO_COMPOSITE_GROUP_SOURCE_INFO;

// 设置全景拼接分组视频源输入参数
typedef struct tagNET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // 结构体大小
    char                                szGroupID[32];                  // 分组ID
    UINT                                nGroupSourceNum;                // 分组视频源个数, 与PANO_COMPOSITE_GROUP_INFO中行列数乘积相同，布局从左到右，从上到下
    PANO_COMPOSITE_GROUP_SOURCE_INFO    *pstGroupSourceInfo;            // 分组视频源信息, 资源由用户申请和释放, 申请大小为nGroupSourceNum * sizeof(PANO_COMPOSITE_GROUP_SOURCE_INFO)
} NET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE;

// 设置全景拼接分组视频源输出参数
typedef struct tagNET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // 结构体大小
} NET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE;

// 获取全景拼接分组视频源输入参数
typedef struct tagNET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // 结构体大小
} NET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE;

// 全景拼接分组视频源信息列表
typedef struct tagNET_COMPOSITE_GROUP_SOURCE_LIST
{
    char                                szGroupID[32];                  // 分组ID
    UINT                                nMaxGroupSrcNum;                // 分组视频源个数, 最大支持64个
    UINT                                nGroupSourceNum;                // 实际返回的分组视频源个数
    PANO_COMPOSITE_GROUP_SOURCE_INFO    *pstGroupSourceInfo;            // 分组视频源信息
    BYTE                                byReserved[1024];               //预留字节
} NET_COMPOSITE_GROUP_SOURCE_LIST;

// 获取全景拼接分组视频源输出参数
typedef struct tagNET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE
{
    DWORD                               dwSize;                         // 结构体大小
    UINT                                nGroupSourceListNum;            // 全景拼接分组视频源信息列表个数
    NET_COMPOSITE_GROUP_SOURCE_LIST     stuGroupSourceList[16];         // 全景拼接分组视频源信息列表
} NET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE;

// 全景拼接分组操作类型
typedef enum tagEM_PANOCOMPOSITE_GROUP_OPERATE_TYPE
{
    EM_PANOCOMPOSITE_GROUP_OPERATE_ADD,                 // 创建全景拼接分组,  对应NET_IN_ADD_PANO_COMPOSITE_GROUP 和 NET_OUT_ADD_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_REMOVE,              // 删除全景拼接分组, 对应NET_IN_REMOVE_PANO_COMPOSITE_GROUP 和 NET_OUT_REMOVE_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_MODIFY,              // 修改全景拼接分组, 对应NET_IN_MODIFY_PANO_COMPOSITE_GROUP 和 NET_OUT_MODIFY_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_GET_ALL,             // 获取所有全景拼接分组信息, 对应NET_IN_GET_ALL_PANO_COMPOSITE_GROUP 和 NET_OUT_GET_ALL_PANO_COMPOSITE_GROUP
    EM_PANOCOMPOSITE_GROUP_OPERATE_SET_SOURCE,          // 设置全景拼接分组视频源, 对应NET_IN_SET_PANO_COMPOSITE_GROUP_SOURCE 和 NET_OUT_SET_PANO_COMPOSITE_GROUP_SOURCE
    EM_PANOCOMPOSITE_GROUP_OPERATE_GET_SOURCE,          // 获取全景拼接分组视频源, 对应NET_IN_GET_PANO_COMPOSITE_GROUP_SOURCE 和 NET_OUT_GET_PANO_COMPOSITE_GROUP_SOURCE
} EM_PANOCOMPOSITE_GROUP_OPERATE_TYPE;

// 全景拼接分组操作函数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperatePanoCompositeGroup(LLONG lLoginID, EM_PANOCOMPOSITE_GROUP_OPERATE_TYPE emOperateType, void* pInParam, void* pOutParam, int nWaitTime);
///////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////全景拼接服务器相关接口 end ////////////////////////////////////////////////
/////////////////////////////////////////////////////// ///////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// LED接口////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////

// 设置LED输出画面控制命令类型
typedef enum tagEM_LED_SET_CMD_TYPE
{
	EM_LED_SET_CMD_DISPLAY_ENABLE,		// 开关屏命令
	EM_LED_SET_CMD_DISPLAY_LOCK,		// 画面锁定命令
	EM_LED_SET_CMD_DISPLAY_TEST,		// 画面测试命令
} EM_LED_SET_CMD_TYPE;

// LED输出画面类型
typedef enum tagEM_LED_IMAGE_TYPE
{
	EM_LED_IMAGE_UNKNOWN	= -1,	// 未知
	EM_LED_IMAGE_NORMAL,			// 正常视频
	EM_LED_IMAGE_RED,				// 红色屏
	EM_LED_IMAGE_GREEN,				// 绿色屏
	EM_LED_IMAGE_BLUE,				// 蓝色屏
	EM_LED_IMAGE_WHITE,				// 白色屏
	EM_LED_IMAGE_BLACK,				// 黑色屏
	EM_LED_IMAGE_TRANSVERSE,		// 横条纹
	EM_LED_IMAGE_VERTICAL,			// 竖条纹
	EM_LED_IMAGE_DIAGONAL,			// 斜条纹
	EM_LED_IMAGE_256GREY,			// 256灰度屏
	EM_LED_IMAGE_AGINGSCREEN,		// 老化屏
} EM_LED_IMAGE_TYPE;

// CLIENT_SetLedDisplayCtrlParams接口输入参数
typedef struct tagNET_IN_LED_SET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // 用户使用该结构体时,dwSize 需赋值为该结构体大小
	int							nChannel;			// 通道号
	EM_LED_SET_CMD_TYPE			emCmdType;			// 设置LED输出画面控制命令类型
	BOOL						bDisplayEnable;		// 开关屏使能,emCmdType为 EM_LED_SET_CMD_DISPLAY_ENABLE 时有效
	BOOL						bDisplayBlack;		// 屏幕黑屏使能, emCmdType 为 EM_LED_SET_CMD_DISPLAY_ENABLE 时有效
	BOOL						bDisplayLock;		// 画面锁定使能, emCmdType 为 EM_LED_SET_CMD_DISPLAY_LOCK 时有效
	EM_LED_IMAGE_TYPE			emImageType;		// 输出画面类型, emCmdType 为 EM_LED_SET_CMD_DISPLAY_TEST 时有效
} NET_IN_LED_SET_DISPLAY_CTRL_PARAMS;

// CLIENT_SetLedDisplayCtrlParams接口输出参数
typedef struct tagNET_OUT_LED_SET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // 用户使用该结构体时,dwSize 需赋值为该结构体大小
} NET_OUT_LED_SET_DISPLAY_CTRL_PARAMS;

// CLIENT_GetLedDisplayCtrlParams接口输入参数
typedef struct tagNET_IN_LED_GET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // 用户使用该结构体时,dwSize 需赋值为该结构体大小
	int							nChannel;			// 通道号
} NET_IN_LED_GET_DISPLAY_CTRL_PARAMS;

// CLIENT_GetLedDisplayCtrlParams接口输出参数
typedef struct tagNET_OUT_LED_GET_DISPLAY_CTRL_PARAMS
{
	DWORD                      	dwSize;             // 用户使用该结构体时,dwSize 需赋值为该结构体大小
	BOOL						bDisplayEnable;		// 开关屏使能
	BOOL						bDisplayBlack;		// 屏幕黑屏使能
	BOOL						bDisplayLock;		// 画面锁定使能
	EM_LED_IMAGE_TYPE			emImageType;		// 输出画面类型
} NET_OUT_LED_GET_DISPLAY_CTRL_PARAMS;

// 设置LED输出画面控制参数 (pInParam和pOutParam资源由用户申请和释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLedDisplayCtrlParams(LLONG lLoginID, const NET_IN_LED_SET_DISPLAY_CTRL_PARAMS* pInParam, NET_OUT_LED_SET_DISPLAY_CTRL_PARAMS* pOutParam,int nWaitTime);

// 获取LED输出画面控制参数 (pInParam和pOutParam资源由用户申请和释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLedDisplayCtrlParams(LLONG lLoginID, const NET_IN_LED_GET_DISPLAY_CTRL_PARAMS* pInParam, NET_OUT_LED_GET_DISPLAY_CTRL_PARAMS* pOutParam,int nWaitTime);

///////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// 诱导屏接口////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
#define MAX_PLAYDATES_COUNT		32		// 最大日期个数
#define	MAX_SCREENTIME_COUNT	8		// 诱导屏最大开关屏时间个数
#define MAX_WINDOWS_COUNT		16		// 诱导屏最大窗口个数
#define MAX_ELEMENTS_COUNT		8		// 诱导屏窗口支持的最大元素个数
#define MAX_ELEMENTTEXT_LENGTH	512		// 文本元素最大文本长度
#define MAX_NOTE_COUNT			4		// 诱导屏窗口元素注释信息最大个数
#define MAX_PROGRAMMES_COUNT	32		// 最多支持的节目个数

// 日期类型
typedef enum tagEM_SCREEN_DATE_TYPE
{
	EM_SCREEN_DATE_UNKNOWN,				// 未知
	EM_SCREEN_DATE_MONTH,				// 每月
	EM_SCREEN_DATE_WEEK,				// 每周
	EM_SCREEN_DATE_DAY,					// 每日
} EM_SCREEN_DATE_TYPE;

// 节目时间信息
typedef struct tagNET_PROGRAMME_TIME_INFO
{
	DWORD                dwHour;                  // 时
    DWORD                dwMinute;                // 分
    DWORD                dwSecond;                // 秒
} NET_PROGRAMME_TIME_INFO;

//开关屏时间信息
typedef struct tagNET_SCREEN_TIME_INFO
{
	BOOL					bEnable;							// 是否启用
	EM_SCREEN_DATE_TYPE		emDateType;							// 开关屏日期类型
	UINT					nDateCount;							// 开关屏日期个数'
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];	// 开关屏日期
	NET_PROGRAMME_TIME_INFO	stuOpenTime;						// 开屏时间
	NET_PROGRAMME_TIME_INFO	stuCloseTime;						// 关屏时间
	BYTE        			byReserved[128];                 	// 保留
} NET_SCREEN_TIME_INFO;

// 诱导屏窗口坐标信息
typedef struct NET_GUIDESCREEN_WINDOW_RECT_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// 窗口ID
	NET_RECT			stuRect;									// 窗口坐标
	UINT				nWindowBright;								// 诱导屏窗口亮度，单独配置某个子屏的亮度，填0时以整屏亮度为准
	BYTE				byReserved[132];							// 保留
} NET_GUIDESCREEN_WINDOW_RECT_INFO;

// 显示屏开关状态
typedef enum tagEM_SCREEN_STATUS_TYPE
{
	EM_SCREEN_STATUS_UNKNOWN,		// 未知
	EM_SCREEN_STATUS_ON,			// 开
	EM_SCREEN_STATUS_OFF,			// 关
} EM_SCREEN_STATUS_TYPE;

#define MAX_MONTH_COUNT	12    // 一年中的月数

// 诱导屏配置日出日落时间
typedef struct tagNET_SUN_RISE_SET_TIME
{
	/*日出日落时间采用24小时制, 当不配置, 即都为0 的情况时采用默认时间*/
	UINT					nSunrise;					// 日出时间, 默认上午6 时
	UINT					nSunset;					// 日落时间, 默认下午18 时
	BYTE        			byReserved[32];				// 保留字节
} NET_SUN_RISE_SET_TIME;

// 诱导屏自动调节屏幕亮度信息
typedef struct tagNET_GUIDESCREEN_AUTO_BRIGHT
{
	BOOL					bEnable;							// 是否使能自动亮度配置
	UINT					nLightBright;						// 白天的亮度
	UINT					nDarkBright;						// 夜间的亮度
	NET_SUN_RISE_SET_TIME	stuSunTime[MAX_MONTH_COUNT];		// 日出日落时间
	BYTE        			byReserved[128];					// 保留字节
} NET_GUIDESCREEN_AUTO_BRIGHT;

// 诱导屏属性配置信息
typedef struct tagNET_GUIDESCREEN_ATTRIBUTE_INFO
{
	DWORD           		dwSize;
	char					szScreenID[MAX_COMMON_STRING_64];			// 屏ID
	EM_SCREEN_STATUS_TYPE	emStatus;									// 显示屏开关状态
	BOOL					bIsForeverOpen;								// 是否永久开屏
	UINT					nScreenTime;								// 开关屏时间个数
	NET_SCREEN_TIME_INFO	stuScreenTime[MAX_SCREENTIME_COUNT];		// 开关屏时间数组
	UINT					nBright;									// 显示屏亮度, 1-100 
	UINT					nContrast;									// 显示屏对比度, 1-100
	UINT					nSaturation;								// 显示屏饱和度, 1-100
	UINT					nVolume;									// 屏幕整体音量
	UINT					nWidth;										// 宽度
	UINT					nHeight;									// 高度
	UINT					nWindowsCount;								// 窗口个数
	NET_GUIDESCREEN_WINDOW_RECT_INFO	stuWindows[MAX_WINDOWS_COUNT];	// 窗口信息
	NET_GUIDESCREEN_AUTO_BRIGHT			stuAutoBright;					// 诱导屏自动调节屏幕亮度信息
	BYTE        			byReserved[512];							// 保留字节
} NET_GUIDESCREEN_ATTRIBUTE_INFO;

// 设置诱导屏屏幕配置信息输入参数
typedef struct tagNET_IN_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nScreenCount;		// 诱导屏属性配置信息个数, 值由用户指定
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;	// 诱导屏属性配置信息, 内存由用户维护,
														// 大小为nScreenCount 个NET_GUIDEESCREEN_ATTRIBUTE_INFO
} NET_IN_SET_GUIDESCREEN_CFG;

// 设置诱导屏屏幕配置信息输出参数
typedef struct tagNET_OUT_SET_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_OUT_SET_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenCfg
*   Purpose: 设置诱导屏配置信息接口
*   InputParam:	LLONG								:lLoginID		// 登陆句柄
*   InputParam:	NET_IN_SET_GUIDESCREEN_CFG*			:pInParam 		// 接口输入参数
*   OutParam:		NET_OUT_SET_GUIDESCREEN_CFG*	:pstOutPqram	// 接口输出参数
*   InputParam:	int									:nWaitTime		// 等待超时时间
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenCfg(LLONG lLoginID, const NET_IN_SET_GUIDESCREEN_CFG* pInParam, NET_OUT_SET_GUIDESCREEN_CFG *pstOutPqram, const int nWaitTime);


// 通过诱导屏ID 获取诱导屏配置信息输入参数
typedef struct tagNET_IN_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	char							szScreenID[MAX_COMMON_STRING_64];		// 屏ID
} NET_IN_GET_GUIDESCREEN_CFG_BYID;

// 通过诱导屏ID 获取诱导屏配置信息输出参数
typedef struct tagNET_OUT_GET_GUIDESCREEN_CFG_BYID
{
	DWORD           				dwSize;
	NET_GUIDESCREEN_ATTRIBUTE_INFO	stuGuideScreenCfg;			// 诱导屏属性信息
} NET_OUT_GET_GUIDESCREEN_CFG_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneGuideScreenCfgById
*   Purpose: 通过诱导屏ID 获取诱导屏配置信息
*   InputParam:		LLONG								:lLoginID	// 登陆句柄
*   InputParam:		NET_IN_GET_GUIDESCREEN_CFG_BYID*	:pInParam	// 输入参数
*   OutPutParam:	NET_OUT_GET_GUIDESCREEN_CFG_BYID*	:pOutParam 	// 输出参数
*   InputParam:		int									:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneGuideScreenCfgById(
										LLONG lLoginID, const NET_IN_GET_GUIDESCREEN_CFG_BYID *pInParam, 
										NET_OUT_GET_GUIDESCREEN_CFG_BYID* pOutParam, const int nWaitTime);



// 获取所有诱导屏配置信息输入参数
typedef struct tagNET_IN_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_GUIDESCREEN_CFG;

// 获取所有诱导屏配置信息输出参数
typedef struct tagNET_OUT_GET_ALL_GUIDESCREEN_CFG
{
	DWORD           				dwSize;
	UINT							nMaxScreen;					// 最大诱导屏个数, 值由用户指定
	UINT							nRetScreen;					// 实际返回的诱导屏个数
	NET_GUIDESCREEN_ATTRIBUTE_INFO	*pstGuideScreenCfg;			// 用于存放获取到的诱导屏属性信息, 内存由用户维护 
																// 大小为nMaxScreen 个NET_GUIDESCREEN_ATTRIBUTE_INFO
} NET_OUT_GET_ALL_GUIDESCREEN_CFG;

/**************************************************************************************
*   Funcname: CLIENT_GetAllGuideScreenCfg
*   Purpose: 获取所有诱导屏配置信息
*   InputParam:		LLONG									:lLoginID	// 登陆句柄
*   InputParam:		NET_IN_GET_ALL_GUIDESCREEN_CFG*			:pInParam	// 输入参数
*   OutPutParam:	NET_OUT_GET_ALL_GUIDESCREEN_CFG*		:pOutParam 	// 输出参数
*   InputParam:		int										:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllGuideScreenCfg(
										LLONG lLoginID, const NET_IN_GET_ALL_GUIDESCREEN_CFG *pInParam, 
										NET_OUT_GET_ALL_GUIDESCREEN_CFG* pOutParam, const int nWaitTime);

// 水平对齐类型
typedef enum tagEM_HORI_ALIGN_TYPE
{
	EM_HORI_ALIGN_UNKNOWN,				// 未知
	EM_HORI_ALIGN_LEFT,					// 左对齐
	EM_HORI_ALIGN_CENTER,				// 居中
	EM_HORI_ALIGN_RIGHT,				// 右对齐
} EM_HORI_ALIGN_TYPE;

// 垂直对齐类型
typedef enum tagEM_VERT_ALIGN_TYPE
{
	EM_VERT_ALIGN_UNKNOWN,				// 未知
	EM_VERT_ALIGN_UP,					// 上对齐
	EM_VERT_ALIGN_CENTER,				// 居中
	EM_VERT_ALIGN_DOWN,					// 下对齐
} EM_VERT_ALIGN_TYPE;

// 切入(切出) 风格
typedef enum tagEM_PIC_STYLE_TYPE
{
	EM_PIC_STYLE_UNKNOWN,		// 未知
	EM_PIC_STYLE_DEFAULT,		// 默认
	EM_PIC_STYLE_UP,			// 上移
	EM_PIC_STYLE_DOWN,			// 下移
	EM_PIC_STYLE_LEFT,			// 左移
	EM_PIC_STYLE_RIGHT,			// 右移
} EM_PIC_STYLE_TYPE;


//  文本信息
typedef struct tagNET_GUIDESCREEN_TEXT_INFO
{
	char					szContent[MAX_ELEMENTTEXT_LENGTH];		// 文本内容
	UINT					nFontSize;								// 字体大小
	NET_COLOR_RGBA			stuFontColor;							// 字体颜色
	char					szFontStyle[MAX_COMMON_STRING_32];		// 字体类型
	double					dbLineHeight;							// 行高
	EM_HORI_ALIGN_TYPE		emHoriAlign;							// 水平对齐方向
	EM_VERT_ALIGN_TYPE		emVertAlign;							// 垂直对齐方向
	UINT					nPlayTime;								// 播放时间, 单位秒
	UINT					nPlayCount;								// 播放次数
	UINT					nStayTime;								// 停留间隔（切入切出的间隔时间）单位：s
	EM_PIC_STYLE_TYPE		emEnterStyle;							// 切入风格
	EM_PIC_STYLE_TYPE		emExitStyle;							// 切出风格
	BYTE        			byReserved[128];						// 保留字节
} NET_GUIDESCREEN_TEXT_INFO;

// 诱导屏窗口元素注释信息
typedef struct tagNET_GUIDESCREEN_NOTE_INFO
{
	BOOL						bEnable;			// 是否有效
	NET_GUIDESCREEN_TEXT_INFO	stuTextInfo;		// 文字注释信息
	NET_RECT					stuRect;			// 文字注释的坐标
	BYTE        				byReserved[128];	// 保留字节
} NET_GUIDESCREEN_NOTE_INFO;

// 视频元素信息
typedef struct tagNET_VIDEO_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	char						szPath[MAX_COMMON_STRING_128];			// 文件地址
	UINT						nPlayCount;								// 播放次数
	UINT						nNote;									// 注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 注释信息
	BYTE        				byReserved[128];						// 保留字节
} NET_VIDEO_ELEMENT_INFO;

// 图片元素信息
typedef struct tagNET_PICTURE_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	char						szPath[MAX_COMMON_STRING_128];			// 图片文件地址
	UINT						nPlayTime;								// 播放时间, 单位秒
	UINT						nPlayCount;								// 播放次数
	UINT						nDiaphaneity;							// 透明度, 0-100
	UINT						nStayTime;								// 停留时间, 单位秒
	EM_PIC_STYLE_TYPE			emEnterStyle;							// 切入风格
	EM_PIC_STYLE_TYPE			emExitStyle;							// 切出风格
	UINT						nNote;									// 注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 注释信息 
	BYTE        				byReserved[128];						// 保留字节
} NET_PICTURE_ELEMENT_INFO;

// 诱导屏窗口文本元素信息
typedef struct tagNET_TEXT_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	NET_GUIDESCREEN_TEXT_INFO	stuElementsText;						// 文本元素信息
	UINT						nNote;									// 注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 注释信息 
	BYTE        				byReserved[128];						// 保留字节
} NET_TEXT_ELEMENT_INFO;

// 诱导屏窗口占位符元素信息
typedef struct tagNET_PLACEHOLDER_ELEMENT_INFO
{
	char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	UINT						nNote;									// 注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 注释信息
	BYTE        				byReserved[128];						// 保留字节
} NET_PLACEHOLDER_ELEMENT_INFO;

// 抓拍类型
typedef enum tagEM_CAPTURE_TYPE
{
	EM_CAPTURE_UNKNOWN,			// 未知
	EM_CAPTURE_VIDEO,			// 视频
	EM_CAPTURE_PICTURE,			// 图片
} EM_CAPTURE_TYPE;

// osd叠加信息
typedef struct tagNET_CAPTURE_OSD_INFO
{
    BOOL                        bEnable;                                // 叠加使能
	NET_COLOR_RGBA		        stuFontColor;					        // 文字颜色
	NET_COLOR_RGBA		        stuBackGroundColor;					    // 背景颜色
	UINT                        nFontSize;                              // 字体大小
	char                        szContent[MAX_COMMON_STRING_512];       // OSD内容
	BYTE        				byReserved[1024];						// 保留字节
} NET_CAPTURE_OSD_INFO;

// 抓拍元素信息
typedef struct tagNET_CAPTURE_ELEMENT_INFO
{
	
	char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	char						szUserName[DH_USER_NAME_LEN_EX];		// 用户名
	char						szPassWord[DH_USER_PSW_LEN_EX];			// 密码
	char						szIP[DH_MAX_IPADDR_LEN_EX];				// IP地址
	UINT						nPort;									// 端口号
	UINT						nChannel;								// 通道号
	EM_CAPTURE_TYPE				emCaptureType;							// 抓拍类型
	UINT						nPlayTime;								// 播放时间, 单位秒
	UINT						nNote;									// 注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 注释信息 
	NET_CAPTURE_OSD_INFO        *pstOsdInfo;                            // OSD叠加信息, 由用户申请和释放内存，若为NULL，则不下发(获取)OSD信息
	BYTE        				byReserved[124];						// 保留字节
} NET_CAPTURE_ELEMENT_INFO;

// PDF元素信息
typedef struct tagNET_PDF_ELEMENT_INFO
{
    char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	char                        szPdfPath[MAX_COMMON_STRING_128];       // PDF文件路径
	UINT                        nPlayTime;                              // 播放时间, 单位: 秒
	UINT                        nPlayCount;                             // 播放次数
	UINT                        nStayTime;                              // 停留间隔, 单位: 秒
	EM_PIC_STYLE_TYPE			emEnterStyle;							// 切入风格
	EM_PIC_STYLE_TYPE			emExitStyle;							// 切出风格
	UINT						nTextNote;								// 文字注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 文字注释信息 
	BYTE        				byReserved[1024];						// 保留字节
} NET_PDF_ELEMENT_INFO;

// 音频元素信息
typedef struct tagNET_AUDIO_ELEMENT_INFO
{
    char 						szName[MAX_COMMON_STRING_64];			// 素材名称
	BOOL						bFillerState;							// 是否垫片, 如果两个素材间有时间间隙，没有素材播放，如果设置了垫片则播放垫片
	char                        szAudioPath[MAX_COMMON_STRING_128];     // 音频文件地址
	UINT                        nPlayCount;                             // 播放次数
	UINT						nTextNote;								// 文字注释信息个数
	NET_GUIDESCREEN_NOTE_INFO	stuNoteInfo[MAX_NOTE_COUNT];			// 文字注释信息 
	BYTE        				byReserved[1024];						// 保留字节
} NET_AUDIO_ELEMENT_INFO;

// 诱导屏窗口元素类型
typedef enum tagEM_ELEMENTS_TYPE
{
	EM_ELEMENTS_UNKNOWN,			// 未知
	EM_ELEMENTS_VIDEO,				// 视频元素, 对应NET_VIDEO_ELEMENT_INFO
	EM_ELEMENTS_PICTURE,			// 图片元素, 对应NET_PICTURE_ELEMENT_INFO
	EM_ELEMENTS_TEXT,				// 文本元素, 对应NET_TEXT_ELEMENT_INFO
	EM_ELEMENTS_PLACEHOLDER,		// 占位符元素, 对应NET_PLACEHOLDER_ELEMENT_INFO
	EM_ELEMENTS_CAPTURE,			// 抓拍元素, 对应NET_CAPTURE_ELEMENT_INFO
	EM_ELEMENTS_PDF,                // PDF文档元素, 对应NET_PDF_ELEMENT_INFO
	EM_ELEMENTS_AUDIO,              // 音频元素, 对应NET_AUDIO_ELEMENT_INFO
} EM_ELEMENTS_TYPE;

//窗口轮训周期类型
typedef enum tagEM_TOURPERIOD_TYPE
{
	EM_TOURPERIOD_UNKNOWN,		// 未知
	EM_TOURPERIOD_PROGRAMME,	// 节目周期
	EM_TOURPERIOD_PLAN,			// 计划周期
	EM_TOURPERIOD_CUSTOM,		// 自定义周期
} EM_TOURPERIOD_TYPE;

// 窗口元素通有信息
typedef struct tagNET_ELEMENT_COMMON_INFO
{
	EM_ELEMENTS_TYPE	emElementsType;								// 窗口元素类型
	BYTE        		byReserved[128];							// 保留字节
} NET_ELEMENT_COMMON_INFO;

// 诱导屏窗口信息
typedef struct tagNET_GUIDESCREEN_WINDOW_INFO
{
	char				szWindowID[MAX_COMMON_STRING_64];			// 窗口ID
	int					nVolume;									// 窗口音量，相对整屏音量的百分比
	NET_COLOR_RGBA		stuColor;									// 窗口背景颜色
	UINT				nDiaphaneity;								// 窗口背景透明度0-100
	EM_TOURPERIOD_TYPE	emTourPeriodType;							// 窗口轮训类型
	UINT				nTourPeriodTime;							// 自定义轮训时间，单位秒, 轮训类型为自定义轮训时有效
	BOOL				bAutoPlay;									// 预览自动播放,Video元素有效
	BOOL				bLoopPlay;									// 预览循环播放,Video元素有效
	UINT				nElementsCount;								// 诱导屏窗口元素个数
	char*				pstElementsBuf;								// 诱导屏窗口元素信息缓存区, 根据类型对应不同的结构体
																	// 填充多个元素信息, 每个元素信息内容为NET_ELEMENT_COMMON_INFO + 元素类型对应的结构体
	UINT				nBufLen;									// 诱导屏窗口元素信息缓存区大小
	BYTE        		byReserved[128];							// 保留字节
} NET_GUIDESCREEN_WINDOW_INFO;

// 诱导屏普通节目信息
typedef struct tagNET_ORDINARY_INFO
{
	BOOL						bTempletState;							// 节目是否保存为模板
	char						szDescription[MAX_COMMON_STRING_128];	// 节目描述信息
	UINT						nWhnCount;								// 诱导屏窗口个数
	NET_GUIDESCREEN_WINDOW_INFO	stuWindowsInfo[MAX_WINDOWS_COUNT];		// 诱导屏窗口信息	
	BYTE        				byReserved[128];						// 保留字节
} NET_ORDINARY_INFO;

// 诱导屏节目配置信息
typedef struct tagNET_PROGRAMME_INFO
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// 节目名称
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID, 添加节目的时候无需填写, 由设备生成
	BOOL						bEnable;								// 节目是否启用		
	NET_ORDINARY_INFO			stuOrdinaryInfo;						// 普通节目信息
	BYTE        				byReserved[512];						// 保留字节
} NET_PROGRAMME_INFO;

// 通过节目ID 获取节目信息输入参数
typedef struct tagNET_IN_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
} NET_IN_GET_PROGRAMME_BYID;

// 通过节目ID 获取节目信息输出参数
typedef struct tagNET_OUT_GET_PROGRAMME_BYID
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;			// 节目配置信息
} NET_OUT_GET_PROGRAMME_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammeById
*   Purpose: 通过节目ID 获取节目信息
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_GET_PROGRAMME_BYID*		:pInParam	// 输入参数
*   OutPutParam:	NET_OUT_GET_PROGRAMME_BYID*		:pOutParam 	// 输出参数
*   InputParam:		int								:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammeById(LLONG lLoginID, const NET_IN_GET_PROGRAMME_BYID *pInParam, NET_OUT_GET_PROGRAMME_BYID *pOutParam, const int nWaitTime);


// 获取所有节目信息输入参数
typedef struct tagNET_IN_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMES;

// 获取所有节目信息输出参数
typedef struct tagNET_OUT_GET_ALL_PROGRAMMES
{
	DWORD           			dwSize;
	UINT						nMaxCnt;					// pstProgrammeInfo最大NET_PROGRAMME_INFO 个数
	UINT						nRetCnt;					// pstProgrammeInfo实际返回的 NET_PROGRAMME_INFO 个数
	NET_PROGRAMME_INFO			*pstProgrammeInfo;			// 节目配置信息, 内存由用户维护
} NET_OUT_GET_ALL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammes
*   Purpose: 获取所有节目信息
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_GET_ALL_PROGRAMMES*		:pInParam		// 输入参数
*   OutPutParam:	NET_OUT_GET_ALL_PROGRAMMES*		:pOutParam 		// 输出参数
*   InputParam:		int								:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_PROGRAMMES* pOutParam, const int nWaitTime);

// 简要节目信息类型
typedef enum tagEM_BRIEFLYPROGRAM_TYPE
{
	EM_BRIEFLYPROGRAM_UNKNOWN,		// 未知
	EM_BRIEFLYPROGRAM_BAR,			// 广告节目
	EM_BRIEFLYPROGRAM_ORDINARY,		// 普通节目
}EM_BRIEFLYPROGRAM_TYPE;

// 节目简要信息
typedef struct tagNET_BRIEFLY_PROGRAMME_INFO
{
	char					szProgrammeName[MAX_COMMON_STRING_64];	// 节目名称
	char					szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
	EM_BRIEFLYPROGRAM_TYPE	emProgrammeType;						// 简要节目信息类型
	BOOL					bEnable;								// 节目是否启用	
	BOOL					bTempletState;							// 节目是否保存为模板
	BYTE        			byReserved[512];						// 保留字节
} NET_BRIEFLY_PROGRAMME_INFO;

// 获取所有节目的简要信息输入参数
typedef struct tagNET_IN_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
} NET_IN_GET_ALL_BRIEFLYPROGRAMMES;

// 获取所有节目的简要信息输出参数
typedef struct tagNET_OUT_GET_ALL_BRIEFLYPROGRAMMES
{
	DWORD           				dwSize;
	UINT							nRetCnt;									// 实际返回的个数
	NET_BRIEFLY_PROGRAMME_INFO		stuBriProgrammes[MAX_PROGRAMMES_COUNT];		// 节目简要信息
} NET_OUT_GET_ALL_BRIEFLYPROGRAMMES;


/**************************************************************************************
*   Funcname: CLIENT_GetAllBrieflyProgrammes
*   Purpose: 获取所有节目的简要信息
*   InputParam:		LLONG									:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_GET_ALL_BRIEFLYPROGRAMMES*		:pInParam		// 输入参数
*   OutPutParam:	NET_OUT_GET_ALL_BRIEFLYPROGRAMMES*		:pOutParam 		// 输出参数
*   InputParam:		int										:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllBrieflyProgrammes(
												LLONG lLoginID, const NET_IN_GET_ALL_BRIEFLYPROGRAMMES* pInParam, 
												NET_OUT_GET_ALL_BRIEFLYPROGRAMMES* pOutParam, const int nWaitTime);


// 添加节目信息接口输入参数
typedef struct tagNET_IN_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// 节目信息
} NET_IN_ADD_ONE_PROGRAMME;

// 添加节目信息接口输出参数
typedef struct tagNET_OUT_ADD_ONE_PROGRAMME
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
} NET_OUT_ADD_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_AddOneProgramme
*   Purpose: 添加一个节目信息到诱导屏
*   InputParam:		LLONG						:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_ADD_ONE_PROGRAMME*	:pInParam 		// 输入参数
*   OutPutParam:	NET_OUT_ADD_ONE_PROGRAMME* 	:pOutParam		// 输出参数
*   InputParam:		int							:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneProgramme(LLONG lLoginID, const NET_IN_ADD_ONE_PROGRAMME* pInParam, NET_OUT_ADD_ONE_PROGRAMME *pOutParam, const int nWaitTime);


// 修改节目信息接口输入参数
typedef struct tagNET_IN_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
	NET_PROGRAMME_INFO			stuProgrammeInfo;	// 节目信息
} NET_IN_MODIFY_ONE_PROGRAMME;


// 修改节目信息接口输出参数
typedef struct tagNET_OUT_MODIFY_ONE_PROGRAMME
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_ONE_PROGRAMME;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneProgrammeByID
*   Purpose: 通过节目ID 修改节目
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_MODIFY_ONE_PROGRAMME*	:pInParam 		// 输入参数
*   OutputParam:	NET_OUT_MODIFY_ONE_PROGRAMME*	:pOutParam 		// 输出参数
*   InputParam:		int								:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneProgrammeByID(LLONG lLoginID, const NET_IN_MODIFY_ONE_PROGRAMME* pInParam, NET_OUT_MODIFY_ONE_PROGRAMME* pOutParam, const int nWaitTime);


// 批量删除节目信息接口输入参数
typedef struct tagNET_IN_DEL_PROGRAMMES
{
	DWORD           dwSize;
	UINT			nProgrammeID;													// 节目ID个数
	char			szProGrammeIdList[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// 需要删除的节目ID列表, 第一个值填"all" 表示删除所有
} NET_IN_DEL_PROGRAMMES;

// 批量删除节目信息接口输出参数
typedef struct tagNET_OUT_DEL_PROGRAMMES
{
	DWORD           dwSize;
} NET_OUT_DEL_PROGRAMMES;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammesById
*   Purpose: 批量删除节目信息
*   InputParam:	LLONG					:lLoginID	// 登陆句柄
*   InputParam:	NET_IN_DEL_PROGRAMMES*	:pInParam 	// 输入参数
*   InputParam:	NET_OUT_DEL_PROGRAMMES*	:pOutParam 	// 输出参数
*   InputParam:	int						:nWaitTime	// 等待超时时间
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammesById(
											LLONG lLoginID, const NET_IN_DEL_PROGRAMMES* pInParam, 
											NET_OUT_DEL_PROGRAMMES *pOutParam, const int nWaitTime);

// 即时节目计划配置信息
typedef struct tagNET_IMMEDIATELY_PLAN_INFO
{
	char			szPlanName[MAX_COMMON_STRING_64];			// 节目计划名称
	char			szPlanID[MAX_COMMON_STRING_64];				// 节目计划ID, 添加计划时无需填写, 由设备生成
	char			szSplitScreenID[MAX_COMMON_STRING_64];		// 分屏ID
	BOOL			bEnable;									// 计划是否启用
	UINT			nPlayTime;									// 播放时长, 单位 : 分钟
	char			szProgrammeName[MAX_COMMON_STRING_64];		// 即时发布的节目名称
	char			szProgrammeID[MAX_COMMON_STRING_64];		// 即时发布的节目ID
	BYTE        	byReserved[512];							// 保留字节
} NET_IMMEDIATELY_PLAN_INFO;

// 节目日期格式
typedef struct tagNET_PROGRAMME_DATA
{
	DWORD                dwYear;                  // 年
    DWORD                dwMonth;                 // 月
    DWORD                dwDay;                	  // 日
} NET_PROGRAMME_DATA;

// 审核状态
typedef enum tagEM_REVIES_STATE
{
	EM_REVIES_UNKNOWN,			// 未知
	EM_REVIES_PASS,				// 通过
	EM_REVIES_NOTPASS,			// 不通过
} EM_REVIES_STATE;

// 节目计划中的节目信息
typedef struct tagNET_PROGRAMME_OF_PLAN
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// 节目名称
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
	BOOL						bIsBgProgramme;							// 是否背景节目
	NET_PROGRAMME_TIME_INFO		stuSatrtTime;							// 节目开始时间
	NET_PROGRAMME_TIME_INFO		stuEndTime;								// 节目结束时间
	BYTE        				byReserved[128];						// 保留字节
} NET_PROGRAMME_OF_PLAN;

// 定时计划日期类型
typedef enum tagEM_TIMERPLAN_DATE_TYPE
{
	EM_TIMERPLAN_DATE_UNKNOWN,				// 未知
	EM_TIMERPLAN_DATE_MONTH,				// 每月
	EM_TIMERPLAN_DATE_WEEK,					// 每周
	EM_TIMERPLAN_DATE_DAY,					// 每日
	EM_TIMERPLAN_DATE_CUSTOM,				// 自定义
} EM_TIMERPLAN_DATE_TYPE;

// 定时节目计划配置信息
typedef struct tagNET_TIMER_PLAN_INFO
{
	char					szPlanName[MAX_COMMON_STRING_64];			// 节目计划名称
	char					szPlanID[MAX_COMMON_STRING_64];				// 节目计划ID
	char					szSplitScreenID[MAX_COMMON_STRING_64];		// 分屏ID
	EM_TIMERPLAN_DATE_TYPE	emDataType;									// 节目计划日期类型
	UINT					nDataCount;									// 节目计划日期个数
	UINT					nPlayDates[MAX_PLAYDATES_COUNT];			// 节目播放日期列表
	NET_PROGRAMME_DATA		stuSatrtDate;								// 节目开始日期
	NET_PROGRAMME_DATA		stuEndDate;									// 节目结束日期
	EM_REVIES_STATE			emReviewState;								// 审核状态
	char					szReviewOpinion[MAX_COMMON_STRING_64];		// 审核意见
	BOOL					bOverdue;									// 计划是否过期
	UINT					nProgrammes;								// 节目个数
	NET_PROGRAMME_OF_PLAN	stuProgrammes[MAX_PROGRAMMES_COUNT];		// 节目组信息
	BYTE        			byReserved[512];							// 保留字节
} NET_TIMER_PLAN_INFO;

// 获取所有节目计划输入参数
typedef struct tagNET_IN_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PROGRAMMEPLANS;

// 获取所有节目计划输出参数
typedef struct tagNET_OUT_GET_ALL_PROGRAMMEPLANS
{
	DWORD           			dwSize;
	UINT						nMaxPlanCnt;			// 即时节目和定时节目计划最大个数, 由用户指定
	UINT						nRetImmCnt;				// 实际返回的即时节目计划个数
	NET_IMMEDIATELY_PLAN_INFO*	pstImmePlan;			// 即时节目计划信息
	UINT						nRetTimerCnt;			// 实际返回的定时节目计划个数
	NET_TIMER_PLAN_INFO*		pstTimerPlan;			// 定时节目计划信息
} NET_OUT_GET_ALL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_GetAllProgrammePlans
*   Purpose: 获取所有节目计划信息
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_GET_ALL_PROGRAMMEPLANS*	:pInParam		// 输入参数
*   OutPutParam:	NET_OUT_GET_ALL_PROGRAMMEPLANS*	:pOutParam  	// 输出参数
*   InputParam:		int								:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgrammePlans(
											LLONG lLoginID, const NET_IN_GET_ALL_PROGRAMMEPLANS *pInParam,
											NET_OUT_GET_ALL_PROGRAMMEPLANS *pOutParam, const int nWaitTime);


// 节目计划类型
typedef enum tagEM_PROGRAMMEPLAN_TYPE
{
	EM_PROGRAMMEPLAN_UNKNOWN,		// 未知
	EM_PROGRAMMEPLAN_IMME,			// 即时计划
	EM_PROGRAMMEPLAN_TIMER,			// 定时计划
} EM_PROGRAMMEPLAN_TYPE;

// 通过节目计划ID 获取节目计划输入参数
typedef struct tagNET_IN_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	char						szPlanID[MAX_COMMON_STRING_64];		// 节目计划ID
} NET_IN_GET_PROGRAMMEPLAN_BYID;

// 通过节目计划ID 获取节目计划输出参数
typedef struct tagNET_OUT_GET_PROGRAMMEPLAN_BYID
{
	DWORD           			dwSize;
	EM_PROGRAMMEPLAN_TYPE		emPlanType;		// 节目计划类型
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;	// 即时节目计划信息, emPlanType 为EM_PROGRAMMEPLAN_IMME时有效
	NET_TIMER_PLAN_INFO			stuTimerPlan;	// 定时节目计划信息, emPlanType 为EM_PROGRAMMEPLAN_TIMER时有效
} NET_OUT_GET_PROGRAMMEPLAN_BYID;

/**************************************************************************************
*   Funcname: CLIENT_GetOneProgrammePlanByID
*   Purpose: 通过节目计划ID 获取节目计划
*   InputParam:		LLONG								:lLoginID	// 登陆句柄
*   InputParam:		NET_IN_GET_PROGRAMMEPLAN_BYID*		:pInParam	// 输入参数
*   OutPutParam:	NET_OUT_GET_PROGRAMMEPLAN_BYID*		:pOutParam  // 输出参数
*   InputParam:		int									:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgrammePlanByID(
										LLONG lLoginID,  NET_IN_GET_PROGRAMMEPLAN_BYID *pInParam,
										NET_OUT_GET_PROGRAMMEPLAN_BYID* pOutParam, const int nWaitTime);

// 增加即时节目计划输入参数
typedef struct tagNET_IN_ADD_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// 即时节目计划信息
} NET_IN_ADD_IMME_PROGRAMMEPLAN;

// 增加定时节目计划输入参数
typedef struct tagNET_IN_ADD_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// 定时节目计划信息
} NET_IN_ADD_TIMER_PROGRAMMEPLAN;

// 增加节目计划输出参数
typedef struct tagNET_OUT_ADD_PROGRAMMEPLAN
{
	DWORD           		dwSize;
	char					szPlanID[MAX_COMMON_STRING_64];				// 节目计划ID
} NET_OUT_ADD_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_AddOneImmediProgrammePlan
*   Purpose: 增加一个即时节目计划
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_ADD_IMME_PROGRAMMEPLAN*	:pInParam  		// 输入参数
*   OutPutParam:	NET_OUT_ADD_PROGRAMMEPLAN*		:pstOutParam  	// 输出参数
*   InputParam:		int								:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_IMME_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


/**************************************************************************************
*   Funcname: CLIENT_AddOneTimerProgrammePlan
*   Purpose: 增加一个定时节目计划
*   InputParam:		LLONG							:lLoginID		// 登陆句柄
*   InputParam:		NET_IN_ADD_TIMER_PROGRAMMEPLAN*	:pInParam		// 输入参数
*   OutPutParam:	NET_OUT_ADD_PROGRAMMEPLAN*		:pOutParam  	// 输出参数
*   InputParam:		int								:nWaitTime		// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_ADD_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_ADD_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// 修改即时节目计划输入参数
typedef struct tagNET_IN_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// 即时节目计划信息
} NET_IN_MODIFY_IMME_PROGRAMMEPLAN;

// 修改即时节目计划输出参数
typedef struct tagNET_OUT_MODIFY_IMME_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_IMME_PROGRAMMEPLAN;


/**************************************************************************************
*   Funcname: CLIENT_ModifyOneImmediProgrammePlan
*   Purpose: 修改一个即时节目计划
*   InputParam:		LLONG								:lLoginID	// 登陆句柄
*   InputParam:		NET_IN_MODIFY_IMME_PROGRAMMEPLAN*	:pInParam  	// 输入参数
*   OutPutParam:	NET_OUT_MODIFY_IMME_PROGRAMMEPLAN*	:pOutParam  // 输出参数
*   InputParam:		int									:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneImmediProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_IMME_PROGRAMMEPLAN* pInParam,
										NET_OUT_MODIFY_IMME_PROGRAMMEPLAN* pOutParam, const int nWaitTime);


// 修改定时节目计划输入参数
typedef struct tagNET_IN_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
	NET_TIMER_PLAN_INFO			stuTimerPlan;		// 定时节目计划信息
} NET_IN_MODIFY_TIMER_PROGRAMMEPLAN;

// 修改定时节目计划输出参数
typedef struct tagNET_OUT_MODIFY_TIMER_PROGRAMMEPLAN
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN;

/**************************************************************************************
*   Funcname: CLIENT_ModifyOneTimerProgrammePlan
*   Purpose: 修改一个定时节目计划
*   InputParam:		LLONG								:lLoginID	// 登陆句柄
*   InputParam:		NET_IN_MODIFY_TIMER_PROGRAMMEPLAN*	:pInParam  	// 输入参数
*   OutputParam:	NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN*	:pOutParam  // 输出参数
*   InputParam:		int									:nWaitTime	// 等待超时时间
*   Return:			BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOneTimerProgrammePlan(
										LLONG lLoginID,  const NET_IN_MODIFY_TIMER_PROGRAMMEPLAN* pInParam, 
										NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN* pOutParam, const int nWaitTime);

// 删除多个节目计划输入参数
typedef struct tagNET_IN_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
	UINT		nPlanIDNum;												// 节目计划ID个数
	char		szPlanID[MAX_PROGRAMMES_COUNT][MAX_COMMON_STRING_64];	// 节目计划ID, 第一个值填"all" 表示删除所有
} NET_IN_DEL_PROGRAMMEPLANS;

// 删除多个节目计划输出参数
typedef struct tagNET_OUT_DEL_PROGRAMMEPLANS
{
	DWORD		dwSize;
} NET_OUT_DEL_PROGRAMMEPLANS;

/**************************************************************************************
*   Funcname: CLIENT_DelMultiProgrammePlans
*   Purpose: 删除多个节目计划
*   InputParam:	LLONG							:lLoginID		// 登陆句柄
*   InputParam:	NET_IN_DEL_PROGRAMMEPLANS*		:pInParam  		// 输入参数
*   InputParam:	NET_OUT_DEL_PROGRAMMEPLANS*		:pOutParam  	// 输出参数
*   InputParam:	int								:nWaitTime		// 等待超时时间
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMultiProgrammePlans(
										LLONG lLoginID,  const NET_IN_DEL_PROGRAMMEPLANS* pInParam, 
										NET_OUT_DEL_PROGRAMMEPLANS* pOutParam, const int nWaitTime);

#define MAX_GD_COUNT	170

// 光带颜色类型
typedef enum tagEM_GD_COLOR_TYPE
{
	EM_GD_COLOR_RED,		// 红色
	EM_GD_COLOR_GREEN,		// 绿色
	EM_GD_COLOR_YELLOW,		// 黄色
} EM_GD_COLOR_TYPE;

//设置光带状态信息输入参数
typedef struct tagNET_IN_SET_GD_STATUS
{
	DWORD				dwSize;
	char				szScreenID[MAX_COMMON_STRING_64];		// 分屏ID, 即窗口ID
	UINT				nGDNum;									// 光带总数
	EM_GD_COLOR_TYPE	emStatus[MAX_GD_COUNT];					// 光带信息
} NET_IN_SET_GD_STATUS;

//设置光带状态信息输出参数
typedef struct tagNET_OUT_SET_GD_STATUS
{
	DWORD				dwSize;
} NET_OUT_SET_GD_STATUS;

/**************************************************************************************
*   Funcname: CLIENT_SetGuideScreenGDStatus
*   Purpose: 设置光带状态信息
*   InputParam:	LLONG						:lLoginID		// 登陆句柄
*   InputParam:	NET_IN_SET_GD_STATUS*		:pInParam  		// 输入参数
*   InputParam:	NET_OUT_SET_GD_STATUS*		:pOutParam  	// 输出参数
*   InputParam:	int							:nWaitTime		// 等待超时时间
*   Return:		BOOL
*   Created:		%2017%:%10%:%11%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGuideScreenGDStatus(
										LLONG lLoginID,  const NET_IN_SET_GD_STATUS* pInParam, 
										NET_OUT_SET_GD_STATUS* pOutParam, const int nWaitTime);

//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////// 播放盒接口(节目计划相关接口与诱导屏接口下的节目计划相关接口一致)//////////////////
////////////////// 获取所有节目简要信息与批量删除节目信息 同上方交通诱导屏中对应接口/////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
// LOGO节目信息
typedef struct tagNET_PROGRAM_LOGO_INFO
{
	char		szLogoPath[MAX_COMMON_STRING_128];			// Logo路径
	NET_RECT	stuBackgroundRect;							// Logo位置
	UINT		nDiaphaneity;								// 透明度, 0-100
	BYTE        byReserved[128];							// 保留字节	
} NET_PROGRAM_LOGO_INFO;

// 广告条节目信息
typedef struct tagNET_PROGRAM_BAR_INFO
{
	char			szContent[MAX_COMMON_STRING_512];		// 广告内容
	NET_COLOR_RGBA	stuFontColor;							// 字体颜色
	UINT			nFontSize;								// 字体大小
	char			szFontStyle[MAX_COMMON_STRING_32];		// 字体类型
	UINT			nPlaySpeed;								// 播放速度
	NET_RECT		stuBackgroundRect;						// 广告条位置
	NET_COLOR_RGBA	stuBackColor;							// 广告条背景颜色
	UINT			nDiaphaneity;							// 透明度, 0-100
	BYTE        	byReserved[128];						// 保留字节	
} NET_PROGRAM_BAR_INFO;

// 播放盒上窗口信息
typedef struct tagNET_PLAYBOX_WINDOWS_INFO
{
	NET_RECT			stuRect;							// 窗口位置
	UINT				nZorder;							// 窗口Z轴序	
	int					nVolume;							// 窗口音量，相对整屏音量的百分比
	NET_COLOR_RGBA		stuBackColor;						// 窗口背景颜色
	UINT				nDiaphaneity;						// 窗口背景透明度0-100
	EM_TOURPERIOD_TYPE	emTourPeriodType;					// 窗口轮训类型
	UINT				nTourPeriodTime;					// 自定义轮训时间，单位秒, 轮训类型为自定义轮训时有效
	BOOL				bAutoPlay;							// 预览自动播放,Video元素有效
	BOOL				bLoopPlay;							// 预览循环播放,Video元素有效
	UINT				nElementsCount;						// 播放盒窗口元素个数
	char*				pstElementsBuf;						// 播放盒窗口元素信息缓存区, 根据类型对应不同的结构体
															// 填充多个元素信息, 每个元素信息内容为NET_ELEMENT_COMMON_INFO + 元素类型对应的结构体
	UINT				nBufLen;							// 诱导屏窗口元素信息缓存区大小
	BYTE        		byReserved[128];					// 保留字节
} NET_PLAYBOX_WINDOWS_INFO;

// 普通广告节目信息
typedef struct tagNET_PROGRAM_ORDINARY_INFO
{
	BOOL						bTempletState;							// 节目是否保存为模板
	char						szDescription[MAX_COMMON_STRING_128];	// 节目描述信息
	UINT						nWidth;									// 画布宽度
	UINT						nHeight;								// 画布高度
	int							nWinCount;								// 窗口数量
	NET_PLAYBOX_WINDOWS_INFO	stuWindowsInfo[MAX_WINDOWS_COUNT];		// 窗口信息
	BYTE        				byReserved[128];						// 保留字节
} NET_PROGRAM_ORDINARY_INFO;

// 播放盒节目类型
typedef enum tagEM_PLAYBOXPROGRAM_TYPE
{
	EM_PROGRAM_ON_PLAYBOX_LOGO,			// LOGO, 对应结构体 NET_PROGRAM_LOGO_INFO
	EM_PROGRAM_ON_PLAYBOX_BAR,			// 广告条, 对应结构体 NET_PROGRAM_BAR_INFO
	EM_PROGRAM_ON_PLAYBOX_ORDINARY,		// 普通节目, 对应结构体 NET_PROGRAM_ORDINARY_INFO
}EM_PLAYBOXPROGRAM_TYPE;

// 播放盒节目信息
typedef struct tagNET_PROGRAM_ON_PLAYBOX
{
	char						szProgrammeName[MAX_COMMON_STRING_64];	// 节目名称
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID, 添加节目时不需要指定
	BOOL						bEnable;								// 节目是否启用	
	EM_PLAYBOXPROGRAM_TYPE		emProgramType;							// 节目类型
	NET_PROGRAM_LOGO_INFO		stuLogoInfo;							// LOGO节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_LOGO时有效
	NET_PROGRAM_BAR_INFO		stuBarInfo;								// 广告条节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_BAR时有效
	NET_PROGRAM_ORDINARY_INFO	stuOrdinaryInfo;						// 普通节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_ORDINARY时有效
	BYTE        				byReserved[512];						// 保留字节	
} NET_PROGRAM_ON_PLAYBOX;

//获取播放盒上全部节目信息接口输入参数
typedef struct tagNET_IN_GET_ALL_PLAYBOX_PROGRAM
{
	DWORD           			dwSize;
} NET_IN_GET_ALL_PLAYBOX_PROGRAM;

//获取播放盒上全部节目信息接口输出参数
typedef struct tagNET_OUT_GET_ALL_PLAYBOX_PROGRAM
{
	DWORD           			dwSize;
	UINT						nMaxProgramCount;			// 节目信息最大个数，由用户指定
	UINT						nRetProgramCount;			// 实际返回的节目信息个数
	NET_PROGRAM_ON_PLAYBOX		*pstProgramInfo;			// 播放盒上的节目信息, 内存资源由用户维护
} NET_OUT_GET_ALL_PLAYBOX_PROGRAM;

// 通过programme ID 获取播放盒上对应的节目信息输入参数
typedef struct tagNET_IN_GET_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
} NET_IN_GET_PLAYBOX_PROGRAM_BYID;

// 通过programme ID 获取播放盒上对应的节目信息输出参数
typedef struct tagNET_OUT_GET_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;			// 播放盒节目信息
} NET_OUT_GET_PLAYBOX_PROGRAM_BYID;

// 在播放盒上添加一个节目信息输入参数
typedef struct tagNET_IN_ADD_ONE_PLAYBOX_PRAGROM
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;			// 播放盒节目信息
} NET_IN_ADD_ONE_PLAYBOX_PRAGROM;

// 在播放盒上添加一个节目信息输出参数
typedef struct tagNET_OUT_ADD_ONE_PLAYBOX_PRAGROM
{
	DWORD           			dwSize;
	char						szProgrammeID[MAX_COMMON_STRING_64];	// 节目ID
} NET_OUT_ADD_ONE_PLAYBOX_PRAGROM;

// 在播放盒上修改指定ID的节目信息输入参数
typedef struct tagNET_IN_MODIFY_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
	NET_PROGRAM_ON_PLAYBOX		stuPlayBoxProgram;			// 播放盒节目信息
} NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID;

// 在播放盒上修改指定ID的节目信息输出参数
typedef struct tagNET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID
{
	DWORD           			dwSize;
} NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID;

// 获取播放盒上全部节目信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAllProgramOnPlayBox(
										LLONG lLoginID,  const NET_IN_GET_ALL_PLAYBOX_PROGRAM* pInParam, 
										NET_OUT_GET_ALL_PLAYBOX_PROGRAM* pOutParam, const int nWaitTime);

// 通过programme ID 获取播放盒上对应的节目信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOneProgramByIdOnPlayBox(
										LLONG lLoginID,  const NET_IN_GET_PLAYBOX_PROGRAM_BYID* pInParam, 
										NET_OUT_GET_PLAYBOX_PROGRAM_BYID* pOutParam, const int nWaitTime);
// 在播放盒上添加一个节目
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddOneProgramToPlayBox(
										LLONG lLoginID,  const NET_IN_ADD_ONE_PLAYBOX_PRAGROM* pInParam, 
										NET_OUT_ADD_ONE_PLAYBOX_PRAGROM* pOutParam, const int nWaitTime);


// 在播放盒上修改指定ID的节目信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyProgramOnPlayBoxById(
										LLONG lLoginID,  const NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID* pInParam, 
										NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID* pOutParam, const int nWaitTime);


///////////////////////////////// 组织目录管理 /////////////////////////////////////////

// 组织目录管理-添加节点,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationAddNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_ADD_NODES* pInParam, DH_OUT_ORGANIZATION_ADD_NODES* pOutParam, int nWaitTime = 1000);

// 组织目录管理-删除节点,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationDeleteNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_DELETE_NODES* pInParam, DH_OUT_ORGANIZATION_DELETE_NODES* pOutParam, int nWaitTime = 1000);

// 组织目录管理-获取节点信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationGetNodes(LLONG lLoginID, const DH_IN_ORGANIZATION_GET_NODES* pInParam, DH_OUT_ORGANIZATION_GET_NODES* pOutParam, int nWaitTime = 1000);

// 组织目录管理-设置节点,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OrganizationSetNode(LLONG lLoginID, const DH_IN_ORGANIZATION_SET_NODE* pInParam, DH_OUT_ORGANIZATION_SET_NODE* pOutParam, int nWaitTime = 1000);


//////////////////////////////// 网络抓包 /////////////////////////////////

// 开始抓包,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSniffer(LLONG lLoginID, const DH_IN_START_SNIFFER* pInParam, DH_OUT_START_SNIFFER* pOutParam, int nWaitTime = 1000);

// 停止抓包
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopSniffer(LLONG lLoginID, LLONG lSnifferID);

// 获取抓包状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSnifferInfo(LLONG lLoginID, const DH_IN_GET_SNIFFER_INFO* pInParam, DH_OUT_GET_SNIFFER_INFO* pOutParam, int nWaitTime = 1000);

//////////////////////////////// 播放库相关接口 /////////////////////////////////

//抓取JPEG图像
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_GetPicJPEG(LLONG lPlayHandle, BYTE* pJpegBuf, DWORD dwBufSize,DWORD *pJpegSize,int quality);


//////////////////////////////// 远程文件管理 /////////////////////////////////

// 新建文件,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CreateRemoteFile(LLONG lLoginID, const DH_IN_CREATE_REMOTE_FILE* pInParam, DH_OUT_CREATE_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// 删除文件或目录,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRemoteFiles(LLONG lLoginID, const DH_IN_REMOVE_REMOTE_FILES* pInParam, DH_OUT_REMOVE_REMOTE_FILES* pOutParam, int nWaitTime = 1000);

// 重命名,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenameRemoteFile(LLONG lLoginID, const DH_IN_RENAME_REMOTE_FILE* pInParam, DH_OUT_RENAME_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// 显示目录中文件和子目录,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ListRemoteFile(LLONG lLoginID, const DH_IN_LIST_REMOTE_FILE* pInParam, DH_OUT_LIST_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// 同步文件上传, 只适用于小文件,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

//  开始异步文件上传调函数原形,lUploadFileHandle 为 CLIENT_StartUploadRemoteFile 接口返回值
typedef void (CALLBACK *fUploadFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
// 开始异步文件上传,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadRemoteFile(LLONG lLoginID, const DH_IN_UPLOAD_REMOTE_FILE* pInParam, DH_OUT_UPLOAD_REMOTE_FILE* pOutParam, fUploadFileCallBack cbUploadFile, LDWORD dwUser);

// 停止异步文件上传
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadRemoteFile(LLONG lUploadFileID);

// 远程投放, 在设备端播放音频文件,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayAudioFile(LLONG lLoginID, const NET_IN_PLAY_AUDIO_FILE* pInParam, NET_OUT_PLAY_AUDIO_FILE* pOutParam, int nWaitTime = 1000);

// 文件下载, 只适用于小文件,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadRemoteFile(LLONG lLoginID, const DH_IN_DOWNLOAD_REMOTE_FILE* pInParam, DH_OUT_DOWNLOAD_REMOTE_FILE* pOutParam, int nWaitTime = 1000);

// 设置指定文件的属性,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetFileAttribute(LLONG lLoginID, const DH_IN_SET_FILEATTRIBUTE* pInParam, DH_OUT_SET_FILEATTRIBUTE* pOutParam, int nWaitTime = 1000);

// 文件下载，多次触发分包下载大文件，每次请求指定文件名和下载偏移，pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DownloadPieceFile(LLONG lLoginID, const NET_IN_DOWNLOAD_PIECE_FILE* pInParam, NET_OUT_DOWNLOAD_PIECE_FILE* pOutParam,int nWaitTime = 1000);
////////////////////////////////// 存储设备管理 ////////////////////////////////////////

// 获取ISCSI Target列表, pInParam == NULL获取所有targets,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetISCSITargets(LLONG lLoginID, const DH_IN_ISCSI_TARGETS* pInParam, DH_OUT_ISCSI_TARGETS* pOutParam, int nWaitTime = 1000);
// pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetBitmap(LLONG lLoginID , const DH_IN_BITMAP* pInParam, DH_OUT_BITMAP* pOutParam, int nWaitTime = 1000);

// 获取存储设备名称列表,pstuNames内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetStorageDeviceNames(LLONG lLoginID, DH_STORAGE_DEVICE_NAME* pstuNames, int nMaxCount, int* pnRetCount, int nWaitTime = 1000);

// 获取存储设备信息,pDevice内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD    CLIENT_GetStorageDeviceInfo(LLONG lLoginID, const char* pszDevName, DH_STORAGE_DEVICE* pDevice, int nWaitTime = 1000);

// 订阅录像文件更新信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordInfo(LLONG lLoginID, const NET_IN_ATTACH_RECORD_INFO* pInParam, NET_OUT_ATTACH_RECORD_INFO* pOutParam, int nWaitTime = 1000);

// 取消订阅录像文件更新信息,lAttachHandle是CLIENT_AttachRecordInfo的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordInfo(LLONG lAttachHandle);

// 订阅写入远程存储的信息状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_NetStorageAttachWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_ATTACH_WRITE_INFO* pInParam, NET_OUT_STORAGE_ATTACH_WRITE_INFO* pOutParam, int nWaitTime);

// 取消写入远程设备信息,lAttachHandle是CLIENT_NetStorageAttachWriteInfo的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageDetachWriteInfo(LLONG lAttachHandle);

// 查询远程存储的写入信息状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NetStorageGetWriteInfo(LLONG lLoginID, const NET_IN_STORAGE_GET_WRITE_INFO* pInParam, NET_OUT_STORAGE_GET_WRITE_INFO* pOutParam, int nWaitTime);

// RAID操作, 不同操作类型对应不同的结构体,pInBuf与pOutBuf内存由用户申请释放,大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateRaid(LLONG lLoginID, NET_RAID_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

/////////////////////////////////// 级联设备 ///////////////////////////////////////

// 搜索级联视频源,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixSearch(LLONG lLoginID, const DH_IN_MATRIX_SEARCH* pInParam, DH_OUT_MATRIX_SEARCH* pOutParam, int nWaitTime = 1000);

// 获取本级级联树列表,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMatrixTree(LLONG lLoginID, const DH_IN_GET_MATRIX_TREE* pInParam, DH_OUT_GET_MATRIX_TREE* pOutParam, int nWaitTime = 1000);

// 获取级联上级设备列表信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSuperiorMatrixList(LLONG lLoginID, const DH_IN_GET_SUPERIOR_MATRIX_LIST* pInParam, DH_OUT_GET_SUPERIOR_MATRIX_LIST* pOutParam, int nWaitTime = 1000);

/************************************************************************/
/*                            录像备份回传                                */
/************************************************************************/

// 开始录像备份恢复
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartRecordBackupRestore(LLONG lLoginID);

// 停止录像备份恢复
CLIENT_NET_API void CALL_METHOD CLIENT_StopRecordBackupRestore(LLONG lRestoreID);

// 添加录像备份恢复任务,pInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_ADD_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// 删除录像备份恢复任务,pInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_REMOVE_REC_BAK_RST_TASK* pInParam, int nWaitTime = 1000);

// 获取录像备份恢复任务信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordBackupRestoreTask(LLONG lRestoreID, const DH_IN_QUERY_REC_BAK_RST_TASK* pInParam, DH_OUT_QUERY_REC_BAK_RST_TASK* pOutParam, int nWaitTime = 1000);

//////////////////////////////// Encode Manager  ////////////////////////////////
// 司法刻录中获取编码计划参数,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlan(LLONG lLoginID, const DH_IN_GET_ENCODE_PLAN* pInParam, DH_OUT_GET_ENCODE_PLAN* pOutParam, int nWaitTime = 1000);

// 根据指定的光盘容量和分辨率码率计算业务时长, pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEncodePlanByResolution(LLONG lLoginID, const NET_IN_GET_ENCODEPLANE_BY_RESOLUTION* pInParam, NET_OUT_GET_ENCODEPLANE_BY_RESOLUTION* pOutParam, int nWaitTime /*= 1000*/);

/************************************************************************/
/*                           数据库记录相关操作                         */
/************************************************************************/
// 按查询条件查询记录,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecord(LLONG lLoginID, NET_IN_FIND_RECORD_PARAM* pInParam, NET_OUT_FIND_RECORD_PARAM* pOutParam, int waittime=1000);    

// 查找记录:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API int CALL_METHOD CLIENT_FindNextRecord(NET_IN_FIND_NEXT_RECORD_PARAM* pInParam, NET_OUT_FIND_NEXT_RECORD_PARAM* pOutParam, int waittime=1000);

// 查找记录条数,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRecordCount(NET_IN_QUEYT_RECORD_COUNT_PARAM* pInParam, NET_OUT_QUEYT_RECORD_COUNT_PARAM* pOutParam, int waittime=1000);

// 结束记录查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindRecordClose(LLONG lFindHandle);

/************************************************************************/
/*                            云台元数据接口订阅                         */
/************************************************************************/
// 订阅云台元数据接口,pstuInPtzStatusProc与pstuOutPtzStatusProc内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPTZStatusProc(LLONG lLoginID, NET_IN_PTZ_STATUS_PROC *pstuInPtzStatusProc,  NET_OUT_PTZ_STATUS_PROC *pstuOutPtzStatusProc, int nWaitTime = 3000);

// 停止订阅云台元数据接口,lAttachHandle是CLIENT_AttachPTZStatusProc返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPTZStatusProc(LLONG lAttachHandle);

/************************************************************************/
/*                            云台可视域订阅                               */
/************************************************************************/
// 订阅云台可视域,pstuInViewRange与pstuOutViewRange内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachViewRangeState(LLONG lLoginID, NET_IN_VIEW_RANGE_STATE *pstuInViewRange, NET_OUT_VIEW_RANGE_STATE *pstuOutViewRange, int nWaitTime = 3000);

// 停止订阅云台可视域,lAttachHandle是CLIENT_AttachViewRangeState返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachViewRangeState(LLONG lAttachHandle);

// 订阅气象信息,pstuInParam与pstuOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachWeatherInfo(LLONG lLoginID, NET_IN_WEATHER_INFO *pstuInParam, NET_OUT_WEATHER_INFO *pstuOutParam, int nWaitTime);

// 停止订阅气象信息,lAttachHandle是CLIENT_AttachWeatherInfo返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachWeatherInfo(LLONG lAttachHandle);

// 根据物距、物体大小及占屏比设置可视域,pInstuParam与pstuOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetViewRangeByObject(LLONG lLoginID, NET_IN_SET_VIEW_RANGE_BY_OBJECT *pInstuParam, NET_OUT_SET_VIEW_RANGE_BY_OBJECT *pstuOutParam,  int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 根据目标GPS位置设置可视域，设备GPS位置和目标GPS位置基本在同一区域,pInstuParam与pstuOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetViewRangeByGPS(LLONG lLoginID, NET_IN_SET_VIEW_RANGE_BY_GPS *pInstuParam, NET_OUT_SET_VIEW_RANGE_BY_GPS *pstuOutParam,  int nWaitTime);

// 分页获取信息标注信息列表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetPointInfos(LLONG lLoginID, NET_IN_SCENICSPOT_GETPOINTINFOS_INFO *pInstuParam, NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO *pstuOutParam,  int nWaitTime);

// 设置景物点，原编号的景物点将会被覆盖
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotSetPointInfo(LLONG lLoginID,  NET_IN_SCENICSPOT_SETPOINTINFO_INFO *pInstuParam,  NET_OUT_SCENICSPOT_SETPOINTINFO_INFO *pstuOutParam,  int nWaitTime);

// 获取景物点支持的能力
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotGetCaps(LLONG lLoginID,  const NET_IN_SCENICSPOT_GETCAPS_INFO *pInstuParam,  NET_OUT_SCENICSPOT_GETCAPS_INFO *pstuOutParam,  int nWaitTime);

// 以景物标注点为中心，进行三维定位(倍率不变)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ScenicSpotTurnToPoint(LLONG lLoginID,  const NET_IN_SCENICSPOT_TURNTOPOINT_INFO *pInParam,  NET_OUT_SCENICSPOT_TURNTOPOINT_INFO *pOutParam,  int nWaitTime);

// 设置备份源信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBackupSources(LLONG lLoginID, const NET_IN_SETBACKUP_SOURCES_INFO *pInstuParam, NET_OUT_SETBACKUP_SOURCES_INFO* pstuOutParam, int nWaitTime);
/************************************************************************/
/*                            BUS订阅                                   */
/************************************************************************/
// 订阅Bus状态,pstuInBus与pstuOutBus内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachBusState(LLONG lLoginID, NET_IN_BUS_ATTACH *pstuInBus, NET_OUT_BUS_ATTACH *pstuOutBus, int nWaitTime = 3000);

// 停止订阅Bus状态,lAttachHandle是CLIENT_AttachBusState返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachBusState(LLONG lAttachHandle);

/************************************************************************/
/*                            模拟量报警通道数据订阅                       */
/************************************************************************/

// 订阅模拟量报警通道数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalogAlarmData(LLONG lLoginID, const NET_IN_ANALOGALARM_DATA* pInParam, NET_OUT_ANALOGALARM_DATA* pOutParam, int nWaitTime);

// 停止订阅模拟量报警通道数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalogAlarmData(LLONG lAttachHandle);

/************************************************************************/
/*                            记录变更接口订阅                           */
/************************************************************************/

// 订阅记录变更接口,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordUpdater(LLONG lLoginID, const NET_IN_RECORDUPDATER_DATA* pInParam, NET_OUT_RECORDUPDATER_DATA* pOutParam, int nWaitTime);

// 停止订阅记录变更接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordUpdater(LLONG lAttachHandle);

///////////////////////////////特殊版本接口///////////////////////////////
// 打开日志功能，pstLogPrintInfo内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogOpen(LOG_SET_PRINT_INFO *pstLogPrintInfo);

// 关闭日志功能
CLIENT_NET_API BOOL CALL_METHOD CLIENT_LogClose();

// 查询设备日志--扩展,pLogBuffer内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogEx(LLONG lLoginID, DH_LOG_QUERY_TYPE logType, char *pLogBuffer, int maxlen, int *nLogBufferlen, void* reserved, int waittime=3000);

// 开始查询日志(目前只支持门禁BSC系列),pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartQueryLog(LLONG lLoginID, const NET_IN_START_QUERYLOG* pInParam, NET_OUT_START_QUERYLOG* pOutParam, int nWaitTime);

// 获取日志(目前只支持门禁BSC系列),pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryNextLog(LLONG lLogID, NET_IN_QUERYNEXTLOG* pInParam, NET_OUT_QUERYNEXTLOG* pOutParam, int nWaitTime);

// 结束查询日志(目前只支持门禁BSC系列)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopQueryLog(LLONG lLogID);

/************************************************************************/
/*                            主动注册相关接口                          */
/************************************************************************/
// 主动注册重定向功能,建立定向连接
CLIENT_NET_API LONG CALL_METHOD CLIENT_ControlConnectServer(LLONG lLoginID, char* RegServerIP, WORD RegServerPort, int TimeOut=3000);

// 连接主动注册
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterServer(LLONG lLoginID, LONG ConnectionID, int waittime=1000);

// 断开定向连接
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlDisconnectRegServer(LLONG lLoginID, LONG ConnectionID);

// 查询设备上主动注册服务器信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryControlRegServerInfo(LLONG lLoginID, LPDEV_SERVER_AUTOREGISTER lpRegServerInfo, int waittime=2000);

// 对应 CLIENT_ControlRegisterOtherServer 接口,输入参数
typedef struct tagNET_IN_REGISTER_INFO 
{
	DWORD               dwSize;										 	 // 结构体大小
    char                szRegServerIP[DH_MAX_IPADDR_LEN_EX];             // 主动注册IP地址
    int                 nRegServerPort;                                  // 主动注册端口
} NET_IN_REGISTER_INFO;

// CLIENT_ControlRegisterOtherServer 输出参数
typedef struct tagNET_OUT_REGISTER_INFO 
{
    DWORD       dwSize;			// 结构体大小
}NET_OUT_REGISTER_INFO;

// 临时主动注册功能,车载群组对讲需求,控制设备注册到其他服务上
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlRegisterOtherServer(LLONG lLoginID, NET_IN_REGISTER_INFO* pInParam, NET_OUT_REGISTER_INFO* pOutParam, int waittime);

// 文件上传接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_FileTransmit(LLONG lLoginID, int nTransType, char* szInBuf, int nInBufLen, fTransFileCallBack cbTransFile, LDWORD dwUserData, int waittime);

// web信息上传接口
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TransmitInfoForWeb(LLONG lLoginID, char* szInBuffer, DWORD dwInBufferSize, char* szOutBuffer, DWORD dwOutBufferSize, void* pExtData, int waittime=500);

// 水印检测, *nResult = 0-表示当前图片未被修改 *nResult = 1-表示当前图片已被修改
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_WatermarkVerifyForPicture(char* szFilePath, int* nResult, void* pReserved);

// 多通道组合打开监视,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MultiRealPlay(LLONG lLoginID, DHDEV_IN_MULTIPLAY_PARAM* pInBuf, int nInBufLen, DHDEV_OUT_MULTIPLAY_PARAM* pOutBuf, int nOutBufLen, int* pRetLen);
 
// 多通道停止监视
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopMultiRealPlay(LLONG* lRealHandles, int nNumOfHandles);

// 设置回放的YUV数据回调接口,当hwnd不为空时有效
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlaybackYUVCallBack(LLONG lPlayHandle, fYUVDataCallBack cYUVData, LDWORD dwUser);

// web获取配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szOutBuffer, DWORD dwOutBufferSize, int *error, int waittime=500);

// web设置配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetNewDevConfigForWeb(LLONG lLoginID, char* szCommand, int nChannelID, char* szInBuffer, DWORD dwInBufferSize, int *error, int *restart, int waittime=500);

// 设置播放策略参数,只对实时流有效
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayMethod(LLONG lRealHandle, int nStartTime, int nSlowTime, int nFastTime, int nFailedTime);

// 关闭设备主动注册上来的链接
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseRegConnect(LLONG lHandle, char *pIp, WORD wPort, void *pParam);

// 按文件回放输入参数-代理使用
typedef struct tagNET_IN_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
    LPNET_RECORDFILE_INFO   lpRecordFile;                   // 录像文件信息
    HWND                    hWnd;                           // 窗口句柄
    fDownLoadPosCallBack    cbDownLoadPos;                  // 回放进度回调
    LDWORD                  dwPosUser;                      // 进度回调用户数据
    fDataCallBack           fDownLoadDataCallBack;          // 回放数据回调
    LDWORD                  dwDataUser;                     // 数据回调用户数据
    char                    szDstIP[DH_COMMON_STRING_128];  // 设备IP
}NET_IN_PLAYBACK_BYFILE_PROXY;

// 按文件回放输出参数-代理使用
typedef struct tagNET_OUT_PLAYBACK_BYFILE_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYFILE_PROXY;

// 按时间回放输入参数-代理使用
typedef struct tagNET_IN_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
    int                     nChannelID;                     // 通道号
    LPNET_TIME              lpStartTime;                    // 开始时间
    LPNET_TIME              lpStopTime;                     // 结束时间
    HWND                    hWnd;                           // 窗口句柄
    fDownLoadPosCallBack    cbDownLoadPos;                  // 回放进度回调
    LDWORD                  dwPosUser;                      // 进度回调用户数据
    fDataCallBack           fDownLoadDataCallBack;          // 回放数据回调
    LDWORD                  dwDataUser;                     // 数据回调用户数据
    char                    szDstIP[DH_COMMON_STRING_128];  // 设备IP
}NET_IN_PLAYBACK_BYTIME_PROXY;

// 按时间回放输出参数-代理使用
typedef struct tagNET_OUT_PLAYBACK_BYTIME_PROXY 
{
    DWORD                   dwSize;
}NET_OUT_PLAYBACK_BYTIME_PROXY;

// 按文件方式回放--附带设备IP,仅代理使用,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByRecordFileProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYFILE_PROXY* pInParam, NET_OUT_PLAYBACK_BYFILE_PROXY* pOutParam);

// 按时间方式回放--附带设备IP,仅代理使用,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackByTimeProxy(LLONG lLoginID, NET_IN_PLAYBACK_BYTIME_PROXY* pInParam, NET_OUT_PLAYBACK_BYTIME_PROXY* pOutParam);

// 级联调用方式
typedef enum tagEM_CASCADE_TYPE
{
    EM_CASCADE_TYPE_UNKNOWN     = -1,   // 未知
    EM_CASCADE_TYPE_CHANNEL,            // 视频通道方式
} EM_CASCADE_TYPE;

// 级联参数
typedef struct tagNET_CASCADE_CALL_INFO
{
    BOOL                bCascadeCall;           // 是否级联
    EM_CASCADE_TYPE     emType;                 // 级联方式
    UINT                nChannel;               // 级联通道号
    BYTE                bReserved[1020];        // 保留字节
} NET_CASCADE_CALL_INFO;

// CLIENT_ImportConfigFileJson接口的扩展参数
typedef struct tagNET_IMPORT_CONFIG_EXTEND_PARAM
{
    DWORD                   dwSize;                 // 结构体大小
    NET_CASCADE_CALL_INFO   stuCascadeCallInfo;     // 级联信息
} NET_IMPORT_CONFIG_EXTEND_PARAM;

// 导入配置文件(以JSON格式) pSendBuf: 待发送数据,用户分配内存, nSendBufLen: 待发送长度, reserved: 保留参数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportConfigFileJson(LLONG lLoginID, char *pSendBuf, int nSendBufLen, void* reserved=NULL, int nWaitTime=3000);
// 导出配置文件(以JSON格式) pOutBuffer: 接收缓冲,用户分配内存, maxlen: 接收缓冲长度, nRetlen: 实际导出长度, reserved: 保留参数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExportConfigFileJson(LLONG lLoginID, char *pOutBuffer, int maxlen, int *nRetlen, void* reserved=NULL, int nWaitTime=3000);

// 设置安全密钥(播放加密码流使用)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSecurityKey(LLONG lPlayHandle, char* szKey, DWORD nKeyLen);

// RPC能力查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryRpcMethod(LLONG lLoginID, const char* pszMethod, BOOL* pResult, int nWaitTime);

// 打开或者关闭隐私遮挡
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPrivacyRecover(LLONG lPlayHandle, BOOL bRecover);

//////////////////////////////////////////////////////////////////////////
// 公交业务相关接口
//////////////////////////////////////////////////////////////////////////

// 检查公交线路,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckBusLine(LLONG lLoginID, const NET_IN_CHECK_BUS_LINE* pstInParam, NET_OUT_CHECK_BUS_LINE* pstOutParam, int nWaitTime = 5000);

// 下发公交线路信息,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfo(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO* pstOutParam, int nWaitTime = 5000);

// 下发公交线路信息扩展接口,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchBusLineInfoEx(LLONG lLoginID, const NET_IN_DISPATCH_BUS_LINE_INFO_EX* pstInParam, NET_OUT_DISPATCH_BUS_LINE_INFO_EX* pstOutParam, int nWaitTime);

// 车辆运营调度,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_BusSchedule(LLONG lLoginID, const NET_IN_BUS_SCHEDULE_INFO* pstInParam, NET_OUT_BUS_SCHEDULE_INFO* pstOutParam, int nWaitTime = 5000);

// 下发车辆排班计划,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DispatchWorkPlan(LLONG lLoginID, const NET_IN_BUS_DISPATCH_WORK_PLAN* pstInParam, NET_OUT_BUS_DISPATCH_WORK_PLAN* pstOutParam, int nWaitTime);

// 天气预报信息
typedef struct tagNET_WEATHERFORCAST_INFO
{
	int								nHighTemperature;					// 高温（当天），单位：摄氏度
	int								nLowTemperature;					// 低温（当天），单位：摄氏度
	int								nCurrentTemperature;				// 当前温度，单位：摄氏度
	char							szWeatherState[64];					// 天气描述状态
	int								nWeatherCode;						// 天气状态code值
	BYTE							byReserved[1024];					// 保留字节
}NET_WEATHERFORCAST_INFO;

// 推送天气预报入参
typedef struct tagNET_IN_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
	NET_WEATHERFORCAST_INFO			stuWeatherInfo;						// 天气预报信息
}NET_IN_PUSH_WEATHERFORCAST;

// 推送天气预报出参
typedef struct tagNET_OUT_PUSH_WEATHERFORCAST
{
	DWORD							dwSize;
}NET_OUT_PUSH_WEATHERFORCAST;

// 推送天气预报
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PushWeatherForecast(LLONG lLoginID, const NET_IN_PUSH_WEATHERFORCAST* pstInParam, NET_OUT_PUSH_WEATHERFORCAST* pstOutParam, int nWaitTime);
//////////////////////////////////////////////////////////////////////////

// 添加任务后的反馈类型
typedef enum tagNET_MISSION_FEEDBACK_TYPE
{
    NET_MISSION_FEEDBACK_NO = 0,                        // 不需要反馈
    NET_MISSION_FEEDBACK_YES,                           // 需要对方反馈, 对方应当回复DH_ALARM_MISSION_CONFIRM任务确认事件
}NET_MISSION_FEEDBACK_TYPE;

// 消息类型(车载)
typedef enum tagNET_MISSION_MESSAGE_TYPE
{
    NET_MISSION_MESSAGE_TEXT = 0 ,      //文本消息 
    NET_MISSION_MESSAGE_AD ,            //广告信息
    NET_MISSION_MESSAGE_BROAD ,         //广播消息
    NET_MISSION_MESSAGE_DRIVER ,        //司机消息
    NET_MISSION_MESSAGE_DISPATCH ,      //调度指令
    NET_MISSION_MESSAGE_TRANSPARENT ,   //透明数据      
    NET_MISSION_MESSAGE_URGENT,         //紧急事件
    NET_MISSION_MESSAGE_MAX  ,
}NET_MISSION_MESSAGE_TYPE;

// CLIENT_AddMission()接口输入参数
typedef struct tagNET_IN_ADD_MISSION 
{
    DWORD           dwSize;
    char            szTitle[DH_COMMON_STRING_256];      // 任务名称
    char            szMissionID[DH_COMMON_STRING_256];  // 任务ID
    char            szComment[DH_COMMON_STRING_256];    // 回复内容
    NET_MISSION_FEEDBACK_TYPE   emFeedBack;             // 添加后反馈类型
    NET_MISSION_MESSAGE_TYPE    emMessageType;          // 消息类型
	BOOL            bComment;                           // FALSE时，szComment有效；TRUE时，szCommentEx有效
	char            szCommentEx[DH_COMMON_STRING_2048]; // 回复内容，不可以为空
	int				nChannel[DH_MAX_CHANNEL_COUNT];		// 在哪几个通道进行叠加，支持多通道同时叠加
	int				nDuration;							// 叠加显示时长，0表示一直叠加至下一次协议下发，其它数字表示显示时长，单位秒
	int				nCount;								//  nChannel实际长度
}NET_IN_ADD_MISSION;

// CLIENT_AddMission()接口输出参数
typedef struct tagNET_OUT_ADD_MISSION 
{
    DWORD           dwSize;
}NET_OUT_ADD_MISSION;
//pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMission(LLONG lLoginID, const NET_IN_ADD_MISSION* pstInParam, NET_OUT_ADD_MISSION* pstOutParam, int nWaitTime = 3000);

// CLIENT_ParkingControlStartFind接口输入参数
typedef struct tagNET_IN_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    BOOL                      bSearchCount;    // 查询记录调试是否有效
    DWORD                     dwSearchCount;   // 查询记录条数, 数值范围1~100
    BOOL                      bBegin;          // 查询开始时间是否有效
    NET_TIME                  stuBegin;        // 查询开始时间
    BOOL                      bEnd;            // 查询结束时间是否有效
    NET_TIME                  stuEnd;          // 查询结束时间
    BOOL                      bCardType;       // 卡类型是否有效
    NET_ECK_IC_CARD_USER_TYPE emCardType;      // 卡类型
    BOOL                      bFlag;           // 过车标记是否有效
    NET_ECK_CAR_PASS_FLAG     emFlag;          // 过车标记
} NET_IN_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlStartFind接口输出参数
typedef struct tagNET_OUT_PARKING_CONTROL_START_FIND_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    DWORD                     dwTotalCount;    // 符合此次查询条件的结果总条数
} NET_OUT_PARKING_CONTROL_START_FIND_PARAM;

// CLIENT_ParkingControlDoFind接口输入参数
typedef struct tagNET_IN_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    DWORD                     dwFileCount;     // 当前想查询的记录条数
} NET_IN_PARKING_CONTROL_DO_FIND_PARAM;

// 过车记录信息
typedef struct tagNET_CAR_PASS_ITEM
{
    DWORD                      dwSize; 
    NET_TIME                   stuTime;          // 过车时间
    DWORD                      dwCardNo;         // 卡号
    NET_ECK_IC_CARD_USER_TYPE  emCardType;       // 卡类型
    NET_ECK_CAR_PASS_FLAG      emFlag;           // 过车记录类型
} NET_CAR_PASS_ITEM;

// CLIENT_ParkingControlDoFind接口输出参数
typedef struct tagNET_OUT_PARKING_CONTROL_DO_FIND_PARAM
{
    DWORD                     dwSize;          // 结构体大小
    NET_CAR_PASS_ITEM        *pstuRecordList;  // 记录列表,用户分配内存,大小为sizeof(NET_CAR_PASS_ITEM)*nMaxRecordNum
    int                       nMaxRecordNum;   // 列表记录数
    int                       nRetRecordNum;   // 查询到的记录条数,当查询到的条数小于想查询的条数时,查询结束
} NET_OUT_PARKING_CONTROL_DO_FIND_PARAM;

// 开始过车记录查询,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlStartFind(LLONG lLoginID, NET_IN_PARKING_CONTROL_START_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_START_FIND_PARAM* pOutParam, int waittime);

// 获取过车记录,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDoFind(LLONG lFindeHandle, NET_IN_PARKING_CONTROL_DO_FIND_PARAM* pInParam, NET_OUT_PARKING_CONTROL_DO_FIND_PARAM* pOutParam, int waittime);

// 结束过车记录查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlStopFind(LLONG lFindHandle);

// 订阅过车记录数据回调函数原型
typedef void (CALLBACK *fParkingControlRecordCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CAR_PASS_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// CLIENT_ParkingControlAttachRecord()接口输入参数
typedef struct tagNET_IN_PARKING_CONTROL_PARAM
{
    DWORD                           dwSize;
    fParkingControlRecordCallBack   cbCallBack;                 // 数据回调函数
    LDWORD                          dwUser;                     // 用户定义参数
} NET_IN_PARKING_CONTROL_PARAM;

// CLIENT_ParkingControlDetachRecord()接口输出参数
typedef struct tagNET_OUT_PARKING_CONTROL_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARKING_CONTROL_PARAM;

// 过车记录订阅,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachRecord(LLONG lLoginID, const NET_IN_PARKING_CONTROL_PARAM* pInParam, NET_OUT_PARKING_CONTROL_PARAM* pOutParam, int nWaitTime);

// 取消过车记录订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachRecord(LLONG lAttachHandle);

// 车检器状态
typedef enum tagNET_CAR_DETECTOR_STATE
{
    NET_CAR_DETECTOR_STATE_UNKNOWN = -1,
    NET_CAR_DETECTOR_STATE_OFFLINE = 0,                   // 掉线
    NET_CAR_DETECTOR_STATE_ONLINE,                        // 在线
    NET_CAR_DETECTOR_STATE_LOOPOFFLINE,                   // 地感线圈掉线
} NET_CAR_DETECTOR_STATE;

// 辅助设备通用状态
typedef enum tagNET_AUXILIARY_DEV_STATE
{
    NET_AUXILIARY_DEV_STATE_UNKNOWN = -1,
    NET_AUXILIARY_DEV_STATE_OFFLINE = 0,                   // 掉线
    NET_AUXILIARY_DEV_STATE_ONLINE,                        // 在线
} NET_AUXILIARY_DEV_STATE;

// 卡机IC卡的数量情况
typedef enum tagNET_IC_CARD_STATUS
{
    NET_IC_CARD_STATUS_UNKNOWN = -1,
    NET_IC_CARD_STATUS_NORMAL = 0,                         // 正常
    NET_IC_CARD_STATUS_NOCARD,                             // 无卡
    NET_IC_CARD_STATUS_LOWCARD,                            // 少卡
    NET_IC_CARD_STATUS_FULLCARDS,                          // 回收卡满
} NET_IC_CARD_STATUS;

// 辅助设备运行模式
typedef enum tagNET_AUXILIARY_WORK_MODE
{
    NET_AUXILIARY_WORK_MODE_UNKNOWN = 0,
    NET_AUXILIARY_WORK_MODE_OFFLINE,                       // 脱机运行
    NET_AUXILIARY_WORK_MODE_ONLINE,                        // 联机运行
} NET_AUXILIARY_WORK_MODE;

// 报警事件类型DH_ALARM_AUXILIARY_DEV_STATE(辅助设备状态事件)对应的数据描述信息
typedef struct tagALARM_AUXILIARY_DEV_STATE
{
    DWORD                   dwSize;
    NET_CAR_DETECTOR_STATE  emDetector;                   // 车检器状态
    NET_AUXILIARY_DEV_STATE emLed;                        // LED状态点阵屏状态
    NET_AUXILIARY_DEV_STATE emICDetectBoard;              // 面板刷卡板
    NET_AUXILIARY_DEV_STATE emICSenderBoard;              // 发卡刷卡板
    NET_IC_CARD_STATUS      emICCardStatus;               // 卡机IC卡的数量情况
    NET_AUXILIARY_WORK_MODE emWorkMode;                   // 运行模式
} ALARM_AUXILIARY_DEV_STATE;

// 停车发卡刷卡类型
typedef enum tagNET_PARKING_CARD_TYPE
{
    NET_PARKING_CARD_TYPE_UNKNOWN,
    NET_PARKING_CARD_TYPE_SEND,                             // 发卡
    NET_PARKING_CARD_TYPE_DETECT,                           // 刷卡
} NET_PARKING_CARD_TYPE;

// 报警事件类型DH_ALARM_PARKING_CARD(停车刷卡事件)对应的数据描述信息
typedef struct tagALARM_PARKING_CARD
{
    DWORD                   dwSize;
    NET_PARKING_CARD_TYPE   emType;                       // 类型
    DWORD                   dwCardNo;                     // 卡号
    char                    szPlate[DH_COMMON_STRING_16]; // 车牌
} ALARM_PARKING_CARD;

// 报警源设备的类型
typedef enum tagEM_ALARM_TRANSMIT_DEV_SRC_TYPE
{
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_UNKNOWN,             // 未知
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_DIGIT,               // Digit   数字
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_ANALOG,              // Analog 模拟
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE_SMARTLOCK,           // SmartLock 智能锁
}EM_ALARM_TRANSMIT_DEV_SRC_TYPE;

// 报警类型
typedef enum tagEM_ALARM_TRANSMIT_ALARM_TYPE
{
    EM_ALARM_TRANSMIT_ALARM_TYPE_UNKNOWN,               // 未知
    EM_ALARM_TRANSMIT_ALARM_TYPE_PREVENTREMOVE,         // "PreventRemove"   防拆
    EM_ALARM_TRANSMIT_ALARM_TYPE_LOWERPOWER,            // "LowerPower"  低电压
    EM_ALARM_TRANSMIT_ALARM_TYPE_KEY,                   // "Key"          钥匙
    EM_ALARM_TRANSMIT_ALARM_TYPE_DURESS,                // "Duress"       胁迫
}EM_ALARM_TRANSMIT_ALARM_TYPE;

// 报警传输事件(对应结构体ALARM_PROFILE_ALARM_TRANSMIT_INFO)
typedef struct tagALARM_PROFILE_ALARM_TRANSMIT_INFO
{
    DWORD                           dwSize;
    int                             nChannelID;                             // 通道号
    int                             nAction;                                // 0:开始 1:停止
    NET_TIME                        stuTime;                                // 事件发生时间
    NET_SENSE_METHOD                emSenseMethod;                          // 传感器类型
    char                            szUserID[DH_COMMON_STRING_128];         // 报警用户,用于区分
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // 报警源设备的类型
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // 报警类型
}ALARM_PROFILE_ALARM_TRANSMIT_INFO;

// 事件类型EVENT_IVS_PROFILEALARMTRANSMIT(报警传输事件)对应数据块描述信息, 
typedef struct tagDEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO
{
    int                             nChannelID;                             // 通道号
    int                             nEventID;                               // 事件ID
    char                            szName[128];                            // 事件名称
    double                          PTS;                                    // 时间戳(单位是毫秒)
    int                             nAction;                                // 0:开始 1:停止
    NET_TIME_EX                     stuTime;                                // 事件发生时间
    NET_SENSE_METHOD                emSenseMethod;                          // 传感器类型
    EM_ALARM_TRANSMIT_DEV_SRC_TYPE  emDevSrcType;                           // 报警源设备的类型
    char                            szUserID[32];                           // 报警用户,用于区分
    EM_ALARM_TRANSMIT_ALARM_TYPE    emAlarmType;                            // 报警类型
    BYTE                            reserved[1020];                         // 预留
} DEV_EVENT_PROFILE_ALARM_TRANSMIT_INFO;  

// 订阅监测点位信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ATTACH_INFO* pInParam, NET_OUT_SCADA_ATTACH_INFO* pOutParam, int nWaitTime);

// 取消监测点位信息订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADADetachInfo(LLONG lAttachHandle);

// 获取阈值,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAGetThreshold(LLONG lLoginID, const NET_IN_SCADA_GET_THRESHOLD* pInParam, NET_OUT_SCADA_GET_THRESHOLD* pOutParam, int nWaitTime);

// 设置阈值,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetThreshold(LLONG lLoginID, const NET_IN_SCADA_SET_THRESHOLD* pInParam, NET_OUT_SCADA_SET_THRESHOLD* pOutParam, int nWaitTime);

// 开始查询SCADA点位历史数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindSCADA(LLONG lLoginID, const NET_IN_SCADA_START_FIND* pInParam, NET_OUT_SCADA_START_FIND* pOutParam, int nWaitTime);

// 获取SCADA点位历史数据,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindSCADA(LLONG lFindHandle, const NET_IN_SCADA_DO_FIND* pInParam, NET_OUT_SCADA_DO_FIND* pOutParam, int nWaitTime);

// 停止查询SCADA点位历史数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindSCADA(LLONG lFindHandle);

// 订阅监测点位报警信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SCADAAlarmAttachInfo(LLONG lLoginID, const NET_IN_SCADA_ALARM_ATTACH_INFO* pInParam, NET_OUT_SCADA_ALARM_ATTACH_INFO* pOutParam, int nWaitTime = 3000);

// 取消订阅监测点位报警信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADAAlarmDetachInfo(LLONG lAttachHandle);

// 设置监测点位信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SCADASetInfo(LLONG lLoginID, const NET_IN_SCADA_POINT_SET_INFO_LIST* pInParam, NET_OUT_SCADA_POINT_SET_INFO_LIST* pOutParam, int nWaitTime = 3000);

//////////////////////////////////////////////////////////////////////////

// 订阅无线对码信息接口,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachLowRateWPAN(LLONG lLoginID, const NET_IN_ATTACH_LOWRATEWPAN* pstInParam, NET_OUT_ATTACH_LOWRATEWPAN* pstOutParam, int nWaitTime = 3000);

// 取消订阅无线对码信息接口,lAttachHandle是CLIENT_AttachLowRateWPAN返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachLowRateWPAN(LLONG lAttachHandle);

//获取预览时用来解码显示的播放库端口,对获取到的端口做关闭资源类型的操作,会影响正常功能的使用
CLIENT_NET_API LONG CALL_METHOD CLIENT_GetRealPlayPort(LLONG lRealPlayHandle);

//获取回放时用来解码显示的播放库端口,,对获取到的端口做关闭资源类型的操作,会影响正常功能的使用
CLIENT_NET_API LONG CALL_METHOD  CLIENT_GetPlayBackPort(LLONG lPlayBackHandle);

// 智能停车系统车位状态
typedef enum tagNET_ECK_PARK_STATE
{
    NET_ECK_PARK_STATE_UNKOWN,
    NET_ECK_PARK_STATE_PARK,                     // 车位有车
    NET_ECK_PARK_STATE_NOPARK,                   // 车位无车
} NET_ECK_PARK_STATE;

// 车位信息
typedef struct tagNET_PARK_INFO_ITEM
{
    DWORD                      dwSize; 
    char                       szParkNo[DH_COMMON_STRING_32];   // 车位号
    NET_ECK_PARK_STATE         emState;                         // 车位状态
    DWORD                      dwScreenIndex;                   // 车位号显示对应的诱导屏分屏号
    DWORD                      dwFreeParkNum;                   // 屏号显示的当前空余车位数目
} NET_PARK_INFO_ITEM;

// 订阅车位信息回调函数原型
typedef void (CALLBACK *fParkInfoCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_PARK_INFO_ITEM *pInfo, int nBufLen, LDWORD dwUser);

// 车位检测器类型
typedef enum tagNET_ECK_PARK_DETECTOR_TYPE
{
    NET_ECK_PARK_DETECTOR_TYPE_SONIC,                     // 超声波探测器
    NET_ECK_PARK_DETECTOR_TYPE_CAMERA,                    // 相机检测器
    NET_ECK_PARK_DETECTOR_TYPE_ALL,
} NET_ECK_PARK_DETECTOR_TYPE;

// 车位检测器信息查询条件
typedef struct tagNET_PARK_INFO_FILTER
{
    DWORD                      dwSize; 
    DWORD                      dwNum;                                  // 车位检测器类型数量
    NET_ECK_PARK_DETECTOR_TYPE emType[NET_ECK_PARK_DETECTOR_TYPE_ALL]; // 车位检测器类型
} NET_PARK_INFO_FILTER;

// CLIENT_ParkingControlAttachParkInfo()接口输入参数
typedef struct tagNET_IN_PARK_INFO_PARAM
{
    DWORD                           dwSize;
    NET_PARK_INFO_FILTER            stuFilter;
    fParkInfoCallBack               cbCallBack;                 // 数据回调函数
    LDWORD                          dwUser;                     // 用户定义参数
} NET_IN_PARK_INFO_PARAM;

// CLIENT_ParkingControlAttachParkInfo()接口输出参数
typedef struct tagNET_OUT_PARK_INFO_PARAM
{
    DWORD    dwSize;
} NET_OUT_PARK_INFO_PARAM;

// 车位状态订阅,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ParkingControlAttachParkInfo(LLONG lLoginID, const NET_IN_PARK_INFO_PARAM* pInParam, NET_OUT_PARK_INFO_PARAM* pOutParam, int nWaitTime);

// 取消车位状态订阅
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ParkingControlDetachParkInfo(LLONG lAttachHandle);

// 订阅视频电话状态信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVTPCallState(LLONG lLoginID, const NET_IN_VTP_CALL_STATE_ATTACH* pInParam, NET_OUT_VTP_CALL_STATE_ATTACH* pOutParam, int nWaitTime);

// 取消订阅视频电话状态信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVTPCallState(LLONG lCallStateHandle);

// 手机订阅推送信息, 使用RegisterID标识配置项,pstuCfg内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// 删除手机订阅推送信息, 使用RegisterID标识配置项,pstuIn与pstuOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribe(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

// 获取手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuCfg内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobileSubscribeCfg(LLONG lLoginID, NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int nWaitTime = 1000);

// 手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuCfg内存由用户申请释放 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// 删除手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuIn与pstuOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobileSubscribeCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

////////////////////////////////////////////////////////////////////////////////
// 网络应用组件 操作类型
typedef enum tagEM_RPC_NETAPP_TYPE
{
    EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT,      //  获得网络资源统计, pstuIn 对应 NET_IN_NETAPP_GET_NET_RESOURCE_STAT*,pstuOut对应 NET_OUT_NETAPP_GET_NET_RESOURCE_STAT*
}EM_RPC_NETAPP_TYPE;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT 入参
typedef struct tagNET_IN_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
}NET_IN_NETAPP_GET_NET_RESOURCE_STAT;

// EM_RPC_NETAPP_TYPE_GET_NET_RESOURCE_STAT 出参
typedef struct tagNET_OUT_NETAPP_GET_NET_RESOURCE_STAT
{
    DWORD               dwSize;
    int                 nIPChanneIn;             // IP通道接入          单位：kbps
    int                 nNetRemain;              // 网络接收剩余        单位：kbps
    int                 nNetCapability;          // 网络接收总能力      单位：Mbps
    int                 nRemotePreview;          // 远程预览            单位：kbps
    int                 nRemotePlayAndDownload;  // 远程回放及下载      单位：kbps
    int                 nRemoteSendRemain;       // 远程发送剩余        单位：kbps
    int                 nRemoteSendCapability;   // 远程发送总能力      单位：Mbps
}NET_OUT_NETAPP_GET_NET_RESOURCE_STAT;

// 网络应用组件,公司内部定制接口
// 可用于获取前端设备的网络资源数据,如网络收发数据的速率等,pstuIn与pstuOut内存由用户申请释放，大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RPC_NetApp(LLONG lLoginID, EM_RPC_NETAPP_TYPE emType, const void* pstuIn, void* pstuOut, int nWaitTime = 1000);
//pParam内存由用户申请释放，大小参照emType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetOptimizeMode(EM_OPTIMIZE_TYPE emType, void *pParam);

// 全景云台操作类型
typedef enum tagEM_NET_WIDE_VIEW_CTRL
{
    EM_NET_WIDE_VIEW_CTRL_START,                      // 开始产生全景图, startGenerateWideView, 结构体 NET_IN_WIDE_VIEW_GENERATE_START 和 NET_OUT_WIDE_VIEW_GENERATE_START
    EM_NET_WIDE_VIEW_CTRL_STOP,                       // 停止产生全景图, stopGenerateWideView, 结构体 NET_IN_WIDE_VIEW_GENERATE_STOP 和 NET_OUT_WIDE_VIEW_GENERATE_STOP
    EM_NET_WIDE_VIEW_CTRL_PROGRESS,                   // 获取全景图生成的当前进度, getWideViewProgress, 结构体 NET_IN_WIDE_VIEW_PROGRESS 和 NET_OUT_WIDE_VIEW_PROGRESS
    EM_NET_WIDE_VIEW_CTRL_IMAGEINFO,                  // 获取全景图信息, getImageInfo, 结构体 NET_IN_WIDE_VIEW_IMAGE 和 NET_OUT_WIDE_VIEW_IMAGE
    EM_NET_WIDE_VIEW_CTRL_WV_COORD,                   // 从云台坐标转换到全景图坐标, getWideViewCoordinates, 结构体 NET_IN_WIDE_VIEW_WV 和 NET_OUT_WIDE_VIEW_WV
    EM_NET_WIDE_VIEW_CTRL_PTZ_COORD,                  // 从全景图转换到云台绝对坐标, getPtzCoordinates, 结构体 NET_IN_WIDE_VIEW_PTZ 和 NET_OUT_WIDE_VIEW_PTZ
} EM_NET_WIDE_VIEW_CTRL;

// 开始产生全景图入参
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
} NET_IN_WIDE_VIEW_GENERATE_START;

// 开始产生全景图出参
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_START
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_START;

//  停止产生全景图入参
typedef struct tagNET_IN_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
} NET_IN_WIDE_VIEW_GENERATE_STOP;

//  停止产生全景图出参
typedef struct tagNET_OUT_WIDE_VIEW_GENERATE_STOP
{
    DWORD                    dwSize;
} NET_OUT_WIDE_VIEW_GENERATE_STOP;

//  获取全景图生成的当前进度入参
typedef struct tagNET_IN_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
} NET_IN_WIDE_VIEW_PROGRESS;

//  获取全景图生成的当前进度出参
typedef struct tagNET_OUT_WIDE_VIEW_PROGRESS
{
    DWORD                    dwSize;
    int                      nProgress;               // 全景图生成的当前进度, 范围0-100
} NET_OUT_WIDE_VIEW_PROGRESS;

//  获取全景图信息入参
typedef struct tagNET_IN_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
} NET_IN_WIDE_VIEW_IMAGE;

//  全景图信息
typedef struct tagNET_WIDE_VIEW_IMAGE_INFO
{
    char                     szImageUrl[MAX_PATH];    // URL
} NET_WIDE_VIEW_IMAGE_INFO;

// 获取全景图信息出参
typedef struct tagNET_OUT_WIDE_VIEW_IMAGE
{
    DWORD                    dwSize;
    NET_WIDE_VIEW_IMAGE_INFO stuImageInfo;             // 全景图信息
} NET_OUT_WIDE_VIEW_IMAGE;

#define NET_WIDE_VIEW_COORDINATES_MAX (64)

//  从云台坐标转换到全景图坐标入参
typedef struct tagNET_IN_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
    int                      nNum;                    // 有效的云台坐标个数
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // 云台方向与放大倍数
} NET_IN_WIDE_VIEW_WV;

//  从云台坐标转换到全景图坐标出参
typedef struct tagNET_OUT_WIDE_VIEW_WV
{
    DWORD                    dwSize;
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // 全景图坐标
} NET_OUT_WIDE_VIEW_WV;

//  从全景图转换到云台绝对坐标入参
typedef struct tagNET_IN_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    int                      nChannel;                // 通道号
    int                      nNum;                    // 有效的全景坐标个数
    NET_RECT                 stuRect[NET_WIDE_VIEW_COORDINATES_MAX];  // 全景图坐标
} NET_IN_WIDE_VIEW_PTZ;

//  从全景图转换到云台绝对坐标出参
typedef struct tagNET_OUT_WIDE_VIEW_PTZ
{
    DWORD                    dwSize;
    PTZ_SPEED_UNIT           stuPTZ[NET_WIDE_VIEW_COORDINATES_MAX];   // 云台方向与放大倍数
} NET_OUT_WIDE_VIEW_PTZ;

// 全景云台相关操作接口, 操作类型参照 EM_NET_WIDE_VIEW_CTRL,pstuInParam与pstuOutParam内存由用户申请释放,大小参照emCtrlType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WideViewCtrl(LLONG lLoginID, EM_NET_WIDE_VIEW_CTRL emCtrlType, const void *pstuInParam, void *pstuOutParam, int nWaitTime = 1000);
// pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFile(LLONG lLoginID,const NET_IN_SET_MARK_FILE* pInParam, NET_OUT_SET_MARK_FILE* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );
//按时间标记录像，pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMarkFileByTime(LLONG lLoginID, const NET_IN_SET_MARK_FILE_BY_TIME* pInParam, NET_OUT_SET_MARK_FILE_BY_TIME* pOutParam, int nWaitTime = 1000);

//按时间标记录像&&兼容C5协议

//获取标记录像信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarkInfo(LLONG lLoginID, const NET_IN_GET_MARK_INFO* pInParam, NET_OUT_GET_MARK_INFO* pOutParam, int nWaitTime = 1000);

// 录音码流类型
typedef enum tagEM_NET_AUDIO_REC_STREAM
{
    EM_NET_AUDIO_REC_STREAM_UNKNOWN,
    EM_NET_AUDIO_REC_STREAM_MAIN,                    // Main
    EM_NET_AUDIO_REC_STREAM_EXTRA1,                  // Extra1
    EM_NET_AUDIO_REC_STREAM_EXTRA2,                  // Extra2
    EM_NET_AUDIO_REC_STREAM_EXTRA3,                  // Extra3
    EM_NET_AUDIO_REC_STREAM_TALKBACK,                // Talkback
} EM_NET_AUDIO_REC_STREAM;

// 开启/关闭音频录音并得到录音名入参, 对应命令DH_CTRL_AUDIO_REC_START_NAME和DH_CTRL_AUDIO_REC_STOP_NAME
typedef struct tagNET_IN_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // 该结构体大小
    int                      nChannel;               // 音频通道号
    EM_NET_AUDIO_REC_STREAM  emStream;               // 码流类型
} NET_IN_AUDIO_REC_MNG_NAME;

// 开启/关闭音频录音并得到录音名出参, 对应命令DH_CTRL_AUDIO_REC_START_NAME和DH_CTRL_AUDIO_REC_STOP_NAME
typedef struct tagNET_OUT_AUDIO_REC_MNG_NAME
{
    DWORD                    dwSize;                 // 该结构体大小
    char                     szFileName[MAX_PATH];   // 录音文件名
} NET_OUT_AUDIO_REC_MNG_NAME;

// 开启录像类型
typedef enum tagEM_NET_REC_EVENT
{
    EM_NET_REC_EVENT_UNKNOWN,                       // 未知
    EM_NET_REC_EVENT_ALARM,                         // Alarm
} EM_NET_REC_EVENT;

// 开启/关闭指定通道录像入参, 可以指定录像类型
typedef struct tagNET_IN_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // 该结构体大小
    int                      nChannel;               // 通道号
    EM_NET_REC_EVENT         emType;                 // 录像类型, nAction为0时有效
    int                      nAction;                // 0:开启, 1:关闭
} NET_IN_REC_MNG_CTRL_MPT300;

// 开启/关闭指定通道录像出参
typedef struct tagNET_OUT_REC_MNG_CTRL_MPT300
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_OUT_REC_MNG_CTRL_MPT300;

// 即时抓图(又名手动抓图)入参, 对应命令DH_CTRL_SNAP_MNG_SNAP_SHOT
typedef struct tagNET_IN_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // 该结构体大小
    int                      nChannel;               // 通道号
    int                      nTime;                  // 连拍次数, 0表示停止抓拍,正数表示连续抓拍的张数
} NET_IN_SNAP_MNG_SHOT;

// 即时抓图(又名手动抓图)出参, 对应命令DH_CTRL_SNAP_MNG_SNAP_SHOT
typedef struct tagNET_OUT_SNAP_MNG_SHOT
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_OUT_SNAP_MNG_SHOT;

// 关闭数据库/恢复数据库入参, 对应命令DH_CTRL_LOG_STOP和DH_CTRL_LOG_RESUME
typedef struct tagNET_IN_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_IN_LOG_MNG_CTRL;

// 关闭数据库/恢复数据库出参, 对应命令DH_CTRL_LOG_STOP和DH_CTRL_LOG_RESUME
typedef struct tagNET_OUT_LOG_MNG_CTRL
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_OUT_LOG_MNG_CTRL;

// 直接透传入参
typedef struct tagNET_IN_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // 结构体大小
    char                    *szInBuffer;              // 传送给设备的数据
    DWORD                    dwInBufferSize;          // 传送给设备的数据大小
    NET_TRANSMIT_EXT_INFO    stExtData;               // 传送给设备的数据扩展, 二进制数据
} NET_IN_TRANSMIT_DIRECTLY;

// 直接透传出参
typedef struct tagNET_OUT_TRANSMIT_DIRECTLY
{
    DWORD                    dwSize;                  // 结构体大小
    char                    *szOutBuffer;             // 设备返回的数据
    DWORD                    dwOutBufferSize;         // 设备返回的数据缓冲大小
    DWORD                    dwRetBufferSize;         // 实际返回的数据大小
} NET_OUT_TRANSMIT_DIRECTLY;

//消除反潜报警,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClearRepeatEnter(LLONG lLoginID, const NET_IN_CLEAR_REPEAT_ENTER* pInParam, NET_OUT_CLEAR_REPEAT_ENTER* pOutParam, int nWaitTime = 1000);

// 获取操作员用户名,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOperatorName(LLONG lLoginID, const NET_IN_GET_OPERATOR_NAME* pInParam, NET_OUT_GET_OPERATOR_NAME* pOutParam, int nWaitTime = 1000);

// POS机连接方式
typedef enum tagEM_CONN_TYPE
{
    EM_CONN_TYPE_UNKNOWN,                            // 未知
    EM_CONN_TYPE_NET,                                // 网络连接
    EM_CONN_TYPE_RS232,                              // RS232
    EM_CONN_TYPE_RS485,                              // RS485
} EM_CONN_TYPE;

// POS机连接协议
typedef enum tagEM_CONN_PROT
{
    EM_CONN_PROT_UNKNOWN,                            // 未知
    EM_CONN_PROT_NONE,                               // 自定义
    EM_CONN_PROT_POS,                                // POS
} EM_CONN_PROT;

// POS机状态
typedef enum tagEM_POS_STATUS
{
    EM_POS_STATUS_OTHER = -1,                        // 其他错误
    EM_POS_STATUS_NO,                                // 无错误
    EM_POS_STATUS_PROT_FORMAT,                       // 不符合协议格式
    EM_POS_STATUS_NET_ADDR_CONFLICT,                 // 网络地址冲突
    EM_POS_STATUS_RS232_ADDR_CONFLICT,               // 232串口地址冲突
    EM_POS_STATUS_RS485_ADDR_CONFLICT,               // 485串口地址冲突
    EM_POS_STATUS_LINK_CHANNEL_CONFLICT,             // 关联远程通道冲突
    EM_POS_STATUS_NOT_EXIST,                         // 指定POS不存在
    EM_POS_STATUS_NUM_LIMIT,                         // 添加的POS已超过上限
    EM_POS_STATUS_NAME_CONFLICT,                     // POS名称冲突
} EM_POS_STATUS;

// POS机网络连接配置
typedef struct tagNET_POS_NET_ATT
{
    char                     szSrcIp[DH_MAX_IPADDR_LEN_EX];              // POS机IP地址
    int                      nSrcPort;                                   // POS机端口
    char                     szDstIp[DH_MAX_IPADDR_LEN_EX];              // NVR的IP地址
    int                      nDstPort;                                   // NVR的端口号
} NET_POS_NET_ATT;

// POS机COM连接配置, RS232, RS485
typedef struct tagNET_POS_COM_ATT
{
    int                      nCommChannel;                               // 串口号（comm配置的下标号）
    int                      nAddress;                                   // RS485地址
    DH_COMM_PROP             stuAttr;                                    // RS485串口属性
} NET_POS_COM_ATT;

// POS机自定义连接协议
typedef struct tagNET_POS_CUSTOM_PROT
{
    char                     szStartStr[DH_COMMON_STRING_32];            // 开始字符
    BOOL                     bAnyCharater;                               // 开始字符限制, TRUE表示开始字符为任何字符,FALSE则使用szStartStr字符
    char                     szEndStr[DH_COMMON_STRING_32];              // 结束字符
    char                     szLineDelimiter[DH_COMMON_STRING_32];       // 换行字符
    int                      nMoreLine;                                  // POS交易信息在视频上显示的行数
    char                     szIgnoreStr[DH_COMMON_STRING_32];           // 协议解析忽略字符
    BOOL                     bCaseSensitive;                             // 是否区分大小写
    BYTE                     reserved[1024];                             // 预留
} NET_POS_CUSTOM_PROT;

// 联动类型
typedef enum tagEM_PTZ_LINK_TYPE
{
	EM_PTZ_LINK_TYPE_NONE,							// none
	EM_PTZ_LINK_TYPE_PRESET,						// "Preset" 联动预置点
	EM_PTZ_LINK_TYPE_TOUR,							// "Tour" 联动巡航
	EM_PTZ_LINK_TYPE_PATTERN,						// "Pattern" 联动模式
	EM_PTZ_LINK_TYPE_ZOOM,							// "Zoom" 联动变倍
	EM_PTZ_LINK_TYPE_SINGLESCENE,					// "SingleScene" 联动智能单场景
	EM_PTZ_LINK_TYPE_QUICKFOCUS,					// "QuickFocus" 热成像云台联动快速定位
} EM_PTZ_LINK_TYPE;

// 联动云台信息
typedef struct tagNET_CFG_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;						// 联动类型
	int						nValue;						// 联动取值分别对应预置点号，巡航号等等
} NET_CFG_PTZ_LINK;

// 云台联动项
typedef struct tagNET_PTZ_LINK
{
	EM_PTZ_LINK_TYPE		emType;					// 云台联动类型
	int						nParam1;				// 联动参数1
	int						nParam2;				// 联动参数2
	int						nParam3;				// 联动参数3
	int						nChannelID;				// 所联动云台通道
} NET_PTZ_LINK;

// 轮询联动配置
typedef struct tagNET_MONITOR_TOUR
{
	BOOL					bEnable;				// 轮询使能
	int						nChannels[256];			// 轮训通道号列表
	int						nChannelCount;			// 轮巡通道数量
	BYTE					reserved[32];			// 保留字节
} NET_MONITOR_TOUR;

#define MAX_NUMBER_PTZLINK		256	// 云台最大数量
#define	MAX_NUMBER_TOUR			32	// 轮训联动配置最大数量

// POS事件联动结构体
typedef struct tagNET_POS_EVENT_LINK
{
	DWORD					dwSize;									// 结构体大小
	DH_TSECT				stuTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// 布撤防时间段
	BOOL					bRecordEnable;							// 录像使能
	BOOL					bRecordCloudEnable;						// 是否开启录像云存储
	DWORD					dwRecordMask[DH_MAX_CHANNUM];			// 录像通道掩码(按位)
	int						nRecordLatch;							// 录像延时时间,单位:秒,范围:10-300
	BOOL					bAlarmOutEnable;						// 报警输出使能
	DWORD					dwAlarmOutMask[DH_MAX_CHANNUM];			// 报警输出通道掩码(按位)
	int						nAlarmOutLatch;							// 报警输入停止后,输出延时时间,单位:秒,范围1-300
	int						nPtzLinkNum;							// 云台配置数
	NET_PTZ_LINK			stuPtzLink[MAX_NUMBER_PTZLINK];			// 云台联动项
	BOOL					bPtzLinkEnable;							// 云台联动使能
	int						nPtzLinkDelay;							// 云台联动延迟,单位:秒,范围1-10
	BOOL					bSnapshotEnable;						// 快照使能
	BOOL					bSnapshotCloudEnable;					// 是否开启抓图云存储
	DWORD					dwSnapshotMask[DH_MAX_CHANNUM];			// 快照通道号掩码(按位)
	int						nSnapshotPeriod;						// 帧间隔,每隔多少帧抓一张图片
	int						nSnapshotTimes;							// 连拍次数
	BOOL					bTipEnable;								// 本地消息框提示
	BOOL					bMailEnable;							// 发送邮件,如果有图片,作为附件
	BOOL					bMessageEnable;							// 上传到报警中心服务器
	BOOL					bBeepEnable;							// 蜂鸣
	BOOL					bVoiceEnable;							// 语音提示
	DWORD					dwVoiceMask[DH_MAX_CHANNUM];			// 语音提示播放通道号掩码
	char					szAudioFileName[MAX_PATH];				// 联动语音文件绝对路径
	int						nPlayTimes;								// 联动语音播放次数

	int						nDejitter;								// 去抖动时间,只对部分start/stop型事件有意义,单位:秒,范围0-600
	BOOL					bLogEnable;								// 是否记录日志
	int						nMonitorTourNum;                        // 轮询联动数目
	NET_MONITOR_TOUR		stuMonitorTour[MAX_NUMBER_TOUR];		// 轮询联动配置
} NET_POS_EVENT_LINK;

// POS机信息
typedef struct tagNET_POS_INFO
{
    BOOL                     bEnable;                // 使能开关
    DWORD                    dwPosId;                // Pos的ID号,添加POS时无效
    char                     szName[64];             // POS机名称
    EM_CONN_TYPE             emConnType;             // 连接方式
    NET_POS_NET_ATT          stuNetAtt;              // 网络连接配置, emConnType为EM_CONN_TYPE_NET时有效
    NET_POS_COM_ATT          stuComAtt;              // 串口属性, emConnType为EM_CONN_TYPE_RS232或者EM_CONN_TYPE_RS485时有效
    EM_CONN_PROT             emConnProt;             // 连接协议
    NET_POS_CUSTOM_PROT      stuCustom;              // emConnProt为EM_CONN_PROT_NONE时有效
    int                      nTimeOut;               // 接收消息超时时间, 单位秒
    int                      nLinkChannel[32];       // 每台POS接关联的通道
    int                      nLinkChannelNum;        // nLinkChannel有效数量
    int                      nPlayBackTime;          // POS消息关联视频的时间, 单位秒

	BOOL					 bPreviewBlend;			 // 叠加到预览视频
    BYTE                     reserved[1020];         // 预留
} NET_POS_INFO;

// 增加/修改一个Pos设备入参, 对应命令DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_IN_POS_ADD
{
    DWORD                    dwSize;                 // 该结构体大小
    NET_POS_INFO             stuPosInfo;             // POS机信息
	NET_POS_EVENT_LINK		 stuPosEventLink;		 // EventLink格式
} NET_IN_POS_ADD;

// 增加/修改一个Pos设备出参, 对应命令DH_CTRL_POS_ADD/DH_CTRL_POS_MODIFY
typedef struct tagNET_OUT_POS_ADD
{
    DWORD                    dwSize;                 // 该结构体大小
    DWORD                    dwPosId;                // Pos的ID号, 设备中唯一, DH_CTRL_POS_MODIFY无效
    EM_POS_STATUS            emStatus;               // 操作状态
} NET_OUT_POS_ADD;

// 删除一个Pos设备入参, 对应命令DH_CTRL_POS_REMOVE
typedef struct tagNET_IN_POS_REMOVE
{
    DWORD                    dwSize;                 // 该结构体大小
    DWORD                    dwPosId;                // Pos的ID号
} NET_IN_POS_REMOVE;

// 删除一个Pos设备出参, 对应命令DH_CTRL_POS_REMOVE
typedef struct tagNET_OUT_POS_REMOVE
{
    DWORD                    dwSize;                 // 该结构体大小
    EM_POS_STATUS            emStatus;               // 操作状态
} NET_OUT_POS_REMOVE;

// 批量删除Pos设备入参, 对应命令DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_IN_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // 该结构体大小
    DWORD                    dwPosId[16];            // Pos的ID号, -1表示全部
    int                      nPosNum;                // dwPosId个数
} NET_IN_POS_REMOVE_MULTI;

// 批量删除Pos设备出参, 对应命令DH_CTRL_POS_REMOVE_MULTI
typedef struct tagNET_OUT_POS_REMOVE_MULTI
{
    DWORD                    dwSize;                 // 该结构体大小
    EM_POS_STATUS            emStatus;               // 操作状态, 如果失败返回第一个删除失败时的错误状态
    DWORD                    dwPosIdFailed[16];      // 失败的Pos的ID号
    int                      nPosNum;                // dwPosIdFailed个数
} NET_OUT_POS_REMOVE_MULTI;

// 获取全部Pos设备, 对应命令DH_DEVSTATE_GET_ALL_POS
typedef struct tagNET_POS_ALL_INFO
{
    DWORD                    dwSize;                 // 该结构体大小
	int						 nMaxNum;				 // POS机最大个数
	int                      nRetPosNum;             // pos实际返回个数
    NET_POS_INFO             stuPos[256];            // pos信息
	NET_POS_EVENT_LINK		 *pstuPosEventLink;		 // EventLink格式,和stuPos一一对应, 用户分配内存,大小为sizeof(NET_POS_EVENT_LINK)*nMaxNum
} NET_POS_ALL_INFO;

// 事件类型 DH_ALARM_POS_MANAGE (POS管理事件事件)对应的数据描述信息
typedef struct tagALARM_POS_MANAGE_INFO
{
    int                      nEventAction;                   // 事件动作, 0:Pulse, 1:Start, 2:Stop
    int                      nType;                          // 操作类型, 0:add, 1:remove, 2:modify
    DWORD                    dwPosId;                        // Pos的ID号
    char                     szName[DH_COMMON_STRING_64];    // Pos自定义名称
    int                      nLinkChannel[32];               // 每台POS接关联的通道
    int                      nLinkChannelNum;                // nLinkChannel有效数量
    EM_CONN_PROT             emConnProt;                     // 连接协议
    BYTE                     reserved[1024];                 // 预留
} ALARM_POS_MANAGE_INFO;

// 事件类型 DH_ALARM_LOCK_BREAK (撬锁事件)对应的结构体
typedef struct tagALARM_LOCK_BREAK_INFO
{
    int                      nDoor;                          // 门通道号
    int                      nAction;                        // 0:开始 1:停止
    NET_TIME_EX              UTC;                            // 事件发生的时间
    BYTE                     reserved[1024];                 // 预留字段
}ALARM_LOCK_BREAK_INFO;
 
// 后增字段的数据类型
typedef enum tagEM_POS_DATA_TYPE
{
	EM_POS_DATA_TYPE_UNKNOWN,				// 未知数据类型
	EM_POS_DATA_TYPE_STORE_INF0,			// 商家信息
	EM_POS_DATA_TYPE_PRODUCT_INFO,			// 商品信息
}EM_POS_DATA_TYPE;

// 商家信息
typedef struct tagNET_STORE_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];				// 小票交易号，用于识别商品信息属于哪张小票
	char					 szNo[MAX_STORE_NO_LEN];					// 店号
	char					 szName[MAX_STORE_NAME_LEN];				// 店名
	char					 szEmPloyeeID[MAX_STORE_EMPLOYEE_ID_LEN];	// 收银员工号长度
	unsigned int			 nSeviceType;								// 交易类型,0-销售,1-退货
	unsigned int			 nAmount;									// 总价，单位：分
	BYTE					 byReserved[1024];							// 预留字节
}NET_STORE_INFO;

// 商品信息
typedef struct tagNET_PRODUCT_INFO
{
	char					 szDealNum[MAX_DEAL_NUM_LEN];			// 小票交易号，用于识别商品信息属于哪张小票
	char					 szNo[MAX_PRODUCT_NO_LEN];				// 商品代码
	char					 szName[MAX_PRODUCT_NAME_LEN];			// 商品名称
	char					 szCategory[MAX_PRODUCT_CATEGORY_LEN];	// 商品类别
	unsigned int			 nPrice;								// 商品单价，单位:分
	double					 dbQuantity;							// 商品数量，件或千克
	BYTE					 byReserved[1024];						// 预留字节
}NET_PRODUCT_INFO;

// POS交易信息
typedef struct tagNET_POS_TRADE_INFO
{
    DWORD				dwPosId;										// Pos的ID号
    NET_TIME			stuTime;										// 交易时设备的时间
    BYTE				*pbyComment;									// 交易的内容, 二进制数据
    DWORD				dwCommentLen;									// pbyComment长度
	EM_POS_DATA_TYPE	emDataType;										// 后增字段的数据类型
	BOOL				bEnd;											// 结束符，由该字段判断一张小票是否结束。End值为true表示一张小票结束。
	void*				pPosData;										// 传输的信息，由emDataType决定是哪种信息
																		// 如果emDataType为EM_POS_DATA_TYPE_STORE_INF0,则传输的是商家信息,对应的结构体为NET_STORE_INFO
																		// 如果emDataType为EM_POS_DATA_TYPE_PRODUCT_INFO,则传输的是商品信息,对应的结构体为NET_PRODUCT_INFO
	char				szOSDInfo[2048];								// OSD叠加信息
	BYTE				reserved[1024];									// 预留字节
} NET_POS_TRADE_INFO;

// 订阅POS交易信息回调函数原型
typedef void (CALLBACK *fPosTradeCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_POS_TRADE_INFO *pInfo, int nBufLen, LDWORD dwUser);

// 订阅POS交易信息 输入参数
typedef struct tagNET_IN_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // 该结构体大小
    fPosTradeCallBack           cbCallState;            // 状态回调函数
    LDWORD                      dwUser;                 // 用户参数
} NET_IN_POS_TRADE_ATTACH;

// 订阅POS交易信息 输出参数
typedef struct tagNET_OUT_POS_TRADE_ATTACH 
{
    DWORD                       dwSize;                 // 该结构体大小
} NET_OUT_POS_TRADE_ATTACH;

// CLIENT_GetDevCaps 接口 NET_POS_CAPS 命令入参
typedef struct tagNET_IN_POS_GETCAPS
{
    DWORD               dwSize;
} NET_IN_POS_GETCAPS;

// CLIENT_GetDevCaps 接口 NET_POS_CAPS 命令出参
typedef struct tagNET_OUT_POS_GETCAPS
{
    DWORD               dwSize;
    EM_CONN_TYPE        emConnType[10];                    // 连接方式
    int                 nConnTypeNum;                      // 连接方式种类
    EM_CONN_PROT        emConnProt[10];                    // Pos机与设备的连接协议
    int                 nConnProtNum;                      // 连接协议种类
    int                 nMaxPos;                           // 设备支持添加的POS机数目
	BOOL				bSupportPosRecord;				   // 是否支持POS录像
} NET_OUT_POS_GETCAPS;

// 订阅POS传送过来的物品清单,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPosTrade(LLONG lLoginID, const NET_IN_POS_TRADE_ATTACH* pInParam, NET_OUT_POS_TRADE_ATTACH* pOutParam, int nWaitTime);

// 取消订阅POS传送过来的物品清单
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPosTrade(LLONG lAttachHandle);

// CLIENT_GetDevCaps 接口 NET_USER_MNG_CAPS 命令入参
typedef struct tagNET_IN_USER_MNG_GETCAPS
{
    DWORD               dwSize;
} NET_IN_USER_MNG_GETCAPS;

// CLIENT_GetDevCaps 接口 NET_USER_MNG_CAPS 命令出参
typedef struct tagNET_OUT_USER_MNG_GETCAPS
{
    DWORD               dwSize;
    BOOL                bAccountLimitation;							// 账户限制,可以精确控制每个用户允许同时进行的请求
    BOOL                bIndividualAccessFilter;					// 黑白名单是否支持针对单个IP的过滤
    DWORD               dwMaxPageSize;								// 分页查询时单次查询的最大用户信息条数
	unsigned int		nMaxPwdLen;									// 最大密码长度
	unsigned int		nMinPwdLen;									// 最小密码长度	
	char				szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// 支持的基本字符类型列表：其中Number数字；Lower小写字母；Upper大写字母，字符串形式:"Number,Lower,Upper"
	char				szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// 支持的特殊字符，如"~!@#$%^" 
	int					nCombine;									// 密码组合要求：0-无特殊要求；1-必须有特殊字符，其它不限；2-必须包含2种类型以上(数字、大写、小写、特殊字符)
} NET_OUT_USER_MNG_GETCAPS;

//CLIENT_GetDevCaps 接口 NET_EXTERNALSENSOR_CAPS 命令入参
typedef struct tagNET_IN_EXTERNALSENSOR_CAPS
{
	DWORD				dwSize;
}NET_IN_EXTERNALSENSOR_CAPS;

// CLIENT_GetDevCaps 接口 NET_GET_MASTERSLAVEGROUP_CAPS 命令入参
typedef struct tagNET_IN_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD				dwSize;
	int					nChannel;			// 本地通道号，对应本地视频通道号，从0开始。（老设备及前端设备不支持多通道，设置为0）
}NET_IN_GET_MASTERSLAVEGROUP_CAPS;

typedef enum tagEM_MASTERSLAVEGROUP_MODE
{
	EM_MASTERSLAVEGROUP_MODE_UNKNOWN,		//  未知
	EM_MASTERSLAVEGROUP_MODE_COMMANDER,	    //  Commander 指挥官，如一枪一球的枪
	EM_MASTERSLAVEGROUP_MODE_PROPOSER,      //  Proposer 申请人，两枪一球业务的枪
	EM_MASTERSLAVEGROUP_MODE_JUDGE,			//  Judge裁判员，两枪一球业务的球
	EM_MASTERSLAVEGROUP_MODE_HAWKEYE,		//  HawkEye鹰眼
	EM_MASTERSLAVEGROUP_MODE_MULTISENSOR,	//  MultiSensor多目,标定算法不同,配置使用的字段也不同
	EM_MASTERSLAVEGROUP_MODE_GLOBALCAMERA,	//  GlobalCamera枪球一体式相机
	EM_MASTERSLAVEGROUP_MODE_NEWCOMMANDER,  //  NewCommander新指挥官,标定使用CalibrateMatrix(MultiSensor)配置
	EM_MASTERSLAVEGROUP_MODE_NEWHAWEYE,     //  NewHawEye新鹰眼(守望者),标定使用CalibrateMatrix(MultiSensor)配置
	EM_MASTERSLAVEGROUP_MODE_GLOBALCAMERA2,	//  GlobalCamera2二代灵瞳相机,标定使用CalibrateMatrix(MultiMode)配置，与一代的差异是二代各自通道出各自的图，不再所有图片通过一个通道出
	EM_MASTERSLAVEGROUP_MODE_CLOSEUP,       //  CloseUp全景特写，标定使用CalibrateMatrix(MultiSensor)配置
}EM_MASTERSLAVEGROUP_MODE;

//支持的标定方式
typedef enum tagEM_MASTERSLAVE_CALIBRATIONMODES
{
	EM_MASTERSLAVE_CALIBRATIONMODES_UNKNOWN,                  //未知
	EM_MASTERSLAVE_CALIBRATIONMODES_AUTO,                     //自动
	EM_MASTERSLAVE_CALIBRATIONMODES_MANUAL,                   //手动
}EM_MASTERSLAVE_CALIBRATIONMODES;

//手动标定场景分割类型
typedef enum tagEM_MASTERSLAVE_CALISCENCESPLIT
{
	EM_MASTERSLAVE_CALISCENCESPLIT_UNKNOWN,                   //未知
	EM_MASTERSLAVE_CALISCENCESPLIT_NOSPLIT,                   //不分割
	EM_MASTERSLAVE_CALISCENCESPLIT_HORIZONTALSPLIT,           //水平分割
}EM_MASTERSLAVE_CALISCENCESPLIT;

// 智能方案存在模式
typedef enum tagEM_INTELLIGENT_SCHEME_SUPPORTMODE
{
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_UNKNOWN,              // 未知
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_LINK,                 // 只存在联动态智能方案
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_INDEPENT,             // 只存在独立态智能方案
    EM_INTELLIGENT_SCHEME_SUPPORTMODE_DEFAULT,              // 联动态和独力态智能方案都存在(如果没有SupportMode字段, 默认为此值)
}EM_INTELLIGENT_SCHEME_SUPPORTMODE;


//枪球一体式设备(如鹰眼,全局摄像机),主-从关系定义
typedef struct tagNET_MASTERSLAVE_TRACK
{
	BOOL                                    bSupport;         //是否支持主从跟踪
	int                                     nMasterCount;     //主机数量
	int                                     nMasterChn[16];   //主机对应本地视频通道号，从0开始
	int                                     nSlaverCount;     //从机数量
	int                                     nSlaverChn[16];   //从机对应本地视频通道号，从0开始
    EM_INTELLIGENT_SCHEME_SUPPORTMODE       emSupportMode;    //智能方案存在模式
	BYTE                                    bReserved[508];   //保留字节
}NET_MASTERSLAVE_TRACK;

// CLIENT_GetDevCaps 接口 NET_GET_MASTERSLAVEGROUP_CAPS 命令出参
typedef struct tagNET_OUT_GET_MASTERSLAVEGROUP_CAPS
{
	DWORD									dwSize;
	EM_MASTERSLAVEGROUP_MODE				emRole;             //主从跟踪的身份
	int                                     nCalibrationModeCount;     //支持标定方式的数量
	EM_MASTERSLAVE_CALIBRATIONMODES         emCalibrationModes[4];     //支持的标定方式
	int                                     nCaliSceneCnt;      //每组主从关系手动标定场景数
	EM_MASTERSLAVE_CALISCENCESPLIT          emCaliSceneSplit;   //手动标定场景分割类型
	NET_MASTERSLAVE_TRACK                   stuMasterSlaveTrack;//枪球一体式设备(如鹰眼,全局摄像机),主-从关系定义
}NET_OUT_GET_MASTERSLAVEGROUP_CAPS;

// CLIENT_GetDevCaps 接口 NET_STORAGE_CAPS命令入参
typedef struct tagNET_IN_STORAGE_CAPS
{
	DWORD									dwSize;
}NET_IN_STORAGE_CAPS;

// 格式化硬盘后是否需要重启
typedef enum tagNET_EM_FORMAT_NEEDREBOOT
{
	EM_FORMAT_NEEDREBOOT_UNKNOWN,					// 未知
	EM_FORMAT_NEEDREBOOT_NOREBOOT,					// 不需要重启
	EM_FORMAT_NEEDREBOOT_REBOOT						// 需要重启, 调用CLIENT_ControlDevice格式化使用命令DH_CTRL_SDCARD或DH_CTRL_DISK后自动执行重启，
													// 使用命令DH_CTRL_FORMAT_PATITION需要客户端发起重启
}NET_EM_FORMAT_NEEDREBOOT;

// CLIENT_GetDevCaps 接口 NET_STORAGE_CAPS命令出参
typedef struct tagNET_OUT_STORAGE_CAPS
{
	DWORD									dwSize;
	NET_EM_FORMAT_NEEDREBOOT				emReboot;	// 格式化硬盘后是否需要重启
}NET_OUT_STORAGE_CAPS;

// 外部传感器组网方式
typedef enum tagEM_SENSOR_NERWORKING_MODE
{
	EM_SENSOR_NERWORKING_MODE_UNKNOWN,			// 未知方式
	EM_SENSOR_NETWORKING_MODE_RS485,			// RS-485
	EM_SENSOR_NETWORKING_MODE_RFID,				// RFID
}EM_SENSOR_NERWORKING_MODE;
// CLIENT_GetDevCaps 接口 NET_EXTERNALSENSOR_CAPS 命令出参
typedef struct tagNET_OUT_EXTERNALSENSOR_CAPS
{
	DWORD								dwSize;
	BOOL								bIsSupport;								// 是否支持外部传感器数据采集
	EM_SENSOR_NERWORKING_MODE			emNetworkingMode;						// 外部传感器组网方式
	int									nChannel;								// 支持的最大采集路数
}NET_OUT_EXTERNALSENSOR_CAPS;



// 无线遥控器工作模式
typedef enum tagEM_WIRELESS_CTRL_WORK_MODE
{
    EM_WIRELESS_CTRL_WORK_MODE_UNKNOWN,                     // 未知
    EM_WIRELESS_CTRL_WORK_MODE_NORMAL,                      // 普通模式
    EM_WIRELESS_CTRL_WORK_MODE_POLLING,                     // 巡检模式
} EM_WIRELESS_CTRL_WORK_MODE;

// 事件类型 DH_ALARM_REMOTE_CTRL_STATUS (无线遥控器状态事件)对应的数据描述信息
typedef struct tagALARM_REMOTE_CTRL_STATUS
{
    NET_TIME_EX              UTC;                            // 事件发生的时间
    DWORD                    dwID;                           // 遥控器ID
    char                     szName[32];                     // 名称
    char                     szUser[32];                     // 用户名,指无线设备关联到报警主机的某个用户名,操作权限跟随这个用户
    EM_WIRELESS_CTRL_WORK_MODE emMode;                       // 工作模式
    BYTE                     reserved[1024];                 // 预留
} ALARM_REMOTE_CTRL_STATUS;

typedef enum tagEM_PASSENGER_CARD_CHECK_TYPE
{
    EM_PASSENGER_CARD_CHECK_TYPE_UNKOWN = 0,                // 未知
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNIN,                    // 签到/上车
    EM_PASSENGER_CARD_CHECK_TYPE_SIGNOUT,                   // 签出/下车
    EM_PASSENGER_CARD_CHECK_TYPE_NORMAL,                    // 正常刷卡，不区分上下车
}EM_PASSENGER_CARD_CHECK_TYPE;

// 事件类型 DH_ALARM_PASSENGER_CARD_CHECK (乘客刷卡事件)对应的数据描述信息
typedef struct tagALARM_PASSENGER_CARD_CHECK
{
    BOOL                     bEventConfirm;                  // 是否需要回复
    char                     szCardNum[DH_MAX_BUSCARD_NUM];  // 公交卡号
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS信息
    NET_TIME_EX              UTC;                            // 刷卡时间
    int                      nTime;                          // UTC整型
    EM_PASSENGER_CARD_CHECK_TYPE    emType;                  // 刷卡类型
    char                     szMac[DH_MAX_POS_MAC_NUM];      // 刷卡机Mac码 (默认"0000",兼容老设备)
    BYTE                     reserved[1012];                 // 预留
} ALARM_PASSENGER_CARD_CHECK;

// 事件类型 DH_ALARM_BUS_TIRED_DRIVE_CHECK (疲劳驾驶事件)对应的数据描述信息
typedef struct tagALARM_TIRED_DRIVE_CHECK_INFO
{
    BOOL                     bEventConfirm;                  // 是否需要回复
    int                      nAction;                        // 事件动作, 0:Start, 1:Stop
    int                      nDriveTime;                     // 驾驶时间 单位分钟
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS信息
    NET_TIME_EX              UTC;                            // 事件上报时间
    int                      nTime;                          // 事件上报时间,UTC整型
    BYTE                     reserved[1024];                 // 预留
} ALARM_TIRED_DRIVE_CHECK_INFO;

// 事件类型 DH_ALARM_SOUND (声音事件)对应的数据描述信息
typedef struct tagALARM_SOUND
{
    int                      nChannel;                       // 通道号
    NET_TIME_EX              UTC;                            // 刷卡时间
    BYTE                     reserved[1024];                 // 预留
} ALARM_SOUND;

// 触发有声报警入参, 对应命令 DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_IN_SOUND_ALARM
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_IN_SOUND_ALARM;

// 触发有声报警出参, 对应命令 DH_CTRL_SET_SOUND_ALARM
typedef struct tagNET_OUT_SOUND_ALARM
{
    DWORD                    dwSize;                 // 该结构体大小
} NET_OUT_SOUND_ALARM;

//音频矩阵上控制静音的输出通道
typedef struct tagNET_SILENCE_CHANNEL
{
	int				nMatrix;										//需要静音的矩阵号
	int				nOutChannel;									// 需要静音的输出通道数
	int				nOutPutChannel[DH_MAX_AUDIO_MATRIX_OUTPUT];	    //该矩阵下需要静音的输出通道
	BYTE			bReserved[512];									//保留字节
}NET_SILENCE_CHANNEL;

// 音频矩阵一键静音操作输入参数
typedef struct tagNET_IN_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;				// 用户使用时赋值sizeof(NET_IN_AUDIO_MATRIX_SILENCE)
	BOOL					bEnable;			// 一键静音使能开启或关闭(true:静音 false:开启声音)
	int						nListCount;			// 需要控制静音的输出通道数
	NET_SILENCE_CHANNEL*	pstSlienceChannel;	// 需要控制静音的输出通道信息,用户分配内存,大小为sizeof(NET_SILENCE_CHANNEL)*nListCount
} NET_IN_AUDIO_MATRIX_SILENCE;

//音频矩阵一键静音控制操作输出参数 
typedef struct tagNET_OUT_AUDIO_MATRIX_SILENCE
{
	DWORD					dwSize;		//用户使用时赋值sizeof(NET_OUT_AUDIO_MATRIX_SILENCE)
} NET_OUT_AUDIO_MATRIX_SILENCE;

// 目的端类型
typedef enum tagEM_TARGET_TYPE
{
    EM_TARGET_TYPE_CLIENT,              // "client"    客户端
    EM_TARGET_TYPE_FTP_SERVER,          // "FTPServer" FTP服务器
}EM_TARGET_TYPE;

// 过滤器信息
typedef struct tagNET_MANUAL_UPLOAD_FILTER_INFO
{
    EM_TARGET_TYPE           emTargetType;                      //目的端类型, "Client" - 客户端, "FTPServer" - FTP服务器
    char                     szClientIP[DH_MAX_IPADDR_LEN];     //客户端IP地址,类型为 "Client"有效
    NET_TIME                 stuStartTime;                      //图片开始时间
    NET_TIME                 stuEndTime;                        //图片结束时间
}NET_MANUAL_UPLOAD_FILTER_INFO;

// 设置手动上传输入参数,对应命令 DH_CTRL_MANUAL_UPLOAD_PICTURE
typedef struct tagNET_IN_MANUAL_UPLOAD_PICTURE
{
    DWORD                                 dwSize;               //用户使用时赋值sizeof(NET_IN_MANUAL_UPLOAD_PICTURE)
    NET_MANUAL_UPLOAD_FILTER_INFO         stuFilter;            //手动上传过滤器             
}NET_IN_MANUAL_UPLOAD_PICTURE;

// 设置手动上传输出参数,对应命令 DH_CTRL_MANUAL_UPLOAD_PICTURE
typedef struct tagNET_OUT_MANUAL_UPLOAD_PICTURE
{
    DWORD					dwSize;		                        //用户使用时赋值sizeof(NET_OUT_MANUAL_UPLOAD_PICTURE)
}NET_OUT_MANUAL_UPLOAD_PICTURE;

// 重启网络解码设备输入参数，对应命令DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_IN_REBOOT_NET_DECODING_DEV
{
    DWORD               dwSize;                                 //该结构体大小，用户使用时赋值sizeof(NET_IN_REBOOT_NET_DECODING_DEV)
    char				szDeviceID[DH_COMMON_STRING_64];	    //设备ID
    int                 nRebootDelayTime;                       //重启延时时间, 单位为秒
}NET_IN_REBOOT_NET_DECODING_DEV;


//单防区布撤防操作入参，对应接口CLIENT_SetDefenceArmMode
typedef struct tagNET_IN_SET_DEFENCEMODE 
{
    DWORD                   dwSize;
    char                    szPassword[DH_COMMON_STRING_64];           // 用户登录密码
    int                     nChannel;                                  // 通道号
    EM_DEFENCEMODE          emDefenceMode;                             // 工作模式
}NET_IN_SET_DEFENCEMODE;

//单防区布撤防操作出参，对应接口 CLIENT_SetDefenceArmMode
typedef struct tagNET_OUT_SET_DEFENCEMODE
{
    DWORD                   dwSize;
}NET_OUT_SET_DEFENCEMODE;

//子系统布撤防操作入参，对应接口 CLIENT_SetSubSystemArmMode
typedef struct tagNET_IN_SET_SUBSYSTEMMODE 
{
    DWORD                   dwSize;
    int                     nChannel;                                  // 子系统号,从0开始
    char                    szPassword[DH_COMMON_STRING_64];           // 用户登录密码
    EM_DEFENCEMODE          emDefenceMode;                             // 工作模式
}NET_IN_SET_SUBSYSTEMMODE;

//子系统布撤防操作出参，对应接口 CLIENT_SetSubSystemArmMode
typedef struct tagNET_OUT_SET_SUBSYSTEMMODE
{
    DWORD               dwSize;
    DWORD               dwSourceNum;                        // 有报警源输入布防失败的子系统个数
    int                 nSource[ARM_DISARM_ZONE_MAX];       // 有报警源输入失败的子系统号, 子系统号从0开始
    DWORD               dwLinkNum;                          // 有联动报警布防失败的子系统个数
    int                 nLink[ARM_DISARM_ZONE_MAX];         // 有联动报警失败的子系统号, 子系统号从0开始
}NET_OUT_SET_SUBSYSTEMMODE;

// 获取防区布撤防状态入参，对应接口 CLIENT_GetDefenceArmMode
typedef struct tagNET_IN_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // 防区有效个数
    int                      anDefence[DH_MAX_ALARMIN];              // 待查询的防区号
}NET_IN_GET_DEFENCEMODE;

// 获取防区布撤防状态出参，对应接口 CLIENT_GetDefenceArmMode
typedef struct tagNET_OUT_GET_DEFENCEMODE
{
    DWORD                    dwSize;
    int                      nDefenceNum;                            // 防区有效个数
    EM_DEFENCEMODE           anDefenceState[DH_MAX_ALARMIN];         // 防区状态信息
}NET_OUT_GET_DEFENCEMODE;

// 获取子系统布撤防状态入参，对应接口 CLIENT_GetSubSystemArmMode
typedef struct tagNET_IN_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
}NET_IN_GET_SUBSYSTEMMODE;

// 获取子系统布撤防状态出参，对应接口 CLIENT_GetSubSystemArmMode
typedef struct tagNET_OUT_GET_SUBSYSTEMMODE
{
    DWORD                    dwSize;
    int                      nSubSystemNum;                            // 子系统有效个数
    EM_SUBSYSTEMMODE         anSubSystemState[DH_MAX_ALARM_SUBSYSTEM_NUM];         // 子系统状态信息
}NET_OUT_GET_SUBSYSTEMMODE;

// 手动测试PSTN连接状态入参,对应接口 CLIENT_ManualCheckPSTN
typedef struct tagNET_IN_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
}NET_IN_PSTN_MANUALCHECK_STATE;

// 手动测试PSTN连接状态出参,对应接口 CLIENT_ManualCheckPSTN
typedef struct tagNET_OUT_PSTN_MANUALCHECK_STATE
{
    DWORD                    dwSize;
    NET_THREE_STATUS_BOOL    emState;            //测试结果 
}NET_OUT_PSTN_MANUALCHECK_STATE;

// 重启网络解码设备输出参数，对应命令 DH_CTRL_REBOOT_NET_DECODING_DEV
typedef struct tagNET_OUT_REBOOT_NET_DECODING_DEV
{
    DWORD					dwSize;		                        //该结构体大小，用户使用时赋值sizeof(NET_OUT_REBOOT_NET_DECODING_DEV)
}NET_OUT_REBOOT_NET_DECODING_DEV;

// 设置发卡设备输入参数，对应命令 DH_CTRL_SET_IC_SENDER
typedef struct tagNET_IN_SET_IC_SENDER
{
	DWORD					dwSize;								// 该结构体大小，用户使用时赋值sizeof(NET_IN_SET_IC_SENDER)
	BOOL					bEnable;							// True：允许发卡，False：禁止发卡，设备启动时默认允许发卡
}NET_IN_SET_IC_SENDER;

// 设置发卡设备输出参数，对应命令 DH_CTRL_SET_IC_SENDER
typedef struct tagNET_OUT_SET_IC_SENDER
{
	DWORD					dwSize;								// 该结构体大小，用户使用时赋值sizeof(NET_OUT_SET_IC_SENDER)
}NET_OUT_SET_IC_SENDER;


// 事件类型 DH_ALARM_DRIVE_AFTER_WORK (非工作时间事件)对应的数据描述信息
typedef struct tagALARM_DVRIVE_AFTER_WORK
{
    BOOL                     bEventConfirm;                  // 是否需要回复
    NET_GPS_STATUS_INFO      stuGPS;                         // GPS信息
    NET_TIME_EX              stuUtc;                         // 刷卡时间
    DWORD                    dwUtc;                          // 刷卡时间, 与stuUtc值一样,格式不同,用于事件确认接口入参
    BYTE                     reserved[1024];                 // 预留
} ALARM_DVRIVE_AFTER_WORK;

// 事件类型 DH_ALARM_UPLOAD_PIC_FAILED (违章数据上传失败事件)对应的数据描述信息
typedef struct tagALARM_UPLOAD_PIC_FAILED_INFO
{
    int                      nAction;                        // 0:检测到违章数据上传失败, 1:违章数据上传失败后第一次上传成功
    BYTE                     reserved[1024];                 // 预留
} ALARM_UPLOAD_PIC_FAILED_INFO;

// 获取城市及路段编码信息, 对应命令DH_DEVSTATE_GET_ROAD_LIST
typedef struct tagNET_ROAD_LIST_INFO
{
    DWORD                    dwSize;                 // 该结构体大小
    char                     szCity[32];             // 车辆所处的城市信息
    char                     szRoadList[2048][256];  // 道路编码信息
    int                      nRoadNum;               // 道路信息个数, 指示szRoadList的第1维
} NET_ROAD_LIST_INFO;

// 无线设备类型
typedef enum tagEM_WIRELESS_DEV_TYPE
{
    EM_WIRELESS_DEV_TYPE_UNKNOWN,                            // 未知
    EM_WIRELESS_DEV_TYPE_STATION,                            // "Station":站点
    EM_WIRELESS_DEV_TYPE_AP,                                 // "AccessPoint":无线接入点
} EM_WIRELESS_DEV_TYPE;

// 无线设备认证方式
typedef enum tagEM_WIRELESS_AUTHENTICATION
{
    EM_WIRELESS_AUTHENTICATION_UNKNOWN,                             // UnKnown
    EM_WIRELESS_AUTHENTICATION_OPEN,                                // OPEN
    EM_WIRELESS_AUTHENTICATION_SHARED,                              // SHARED
    EM_WIRELESS_AUTHENTICATION_WPA,                                 // WPA
    EM_WIRELESS_AUTHENTICATION_WPAPSK,                              // WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2,                                // WPA2
    EM_WIRELESS_AUTHENTICATION_WPA2PSK,                             // WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPANONE,                             // WPA-NONE
    EM_WIRELESS_AUTHENTICATION_WPAPSK_WPA2PSK,                      // WPA-PSK|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPA2,                            // WPA|WPA2
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK,                          // WPA | WPA-PSK
    EM_WIRELESS_AUTHENTICATION_WPA2_WPA2PSK,                        // WPA2|WPA2-PSK
    EM_WIRELESS_AUTHENTICATION_WPA_WPAPSK_WPA2_WPA2PSK,             // WPA|WPA-PSK|WPA2|WPA2-PSK
} EM_WIRELESS_AUTHENTICATION;

// 无线数据加密方式方式
typedef enum tagEM_WIRELESS_DATA_ENCRYPT
{
    EM_WIRELESS_DATA_ENCRYPT_UNKNOWN,                            // UnKnown
    EM_WIRELESS_DATA_ENCRYPT_NONE,                               // NONE
    EM_WIRELESS_DATA_ENCRYPT_WEP,                                // WEP
    EM_WIRELESS_DATA_ENCRYPT_TKIP,                               // TKIP
    EM_WIRELESS_DATA_ENCRYPT_AES,                                // AES(CCMP)
    EM_WIRELESS_DATA_ENCRYPT_TKIP_AES,                           // TKIP+AES
} EM_WIRELESS_DATA_ENCRYPT;

// 搜索到的WIFI设备信息
typedef struct tagNET_WIFI_DEV_INFO
{
    char                     szMac[DH_MACADDR_LEN];          // Wifi设备的Mac地址
    int                      nLinkQuality;                   // 链接质量百分比, 0~100
    NET_TIME_EX              stuEnterTime;                   // 第一被搜索到的时间
    NET_TIME_EX              stuLeaveTime;                   // 消失的时间
    int                      nSearchedCount;                 // 被搜索到的次数
    char                     szSSID[24];                     // 网络名称
    NET_TIME_EX              UTC;                            // 事件发生时间
    EM_WIRELESS_DEV_TYPE     emDevType;                      // WIFI设备类型
    int                      nChannel;                       // Wifi设备当前所在的信道
    EM_WIRELESS_AUTHENTICATION emAuth;                       // 认证方式
    EM_WIRELESS_DATA_ENCRYPT emEncrypt;                      // 数据加密方式
    char                     szAPMac[DH_MACADDR_LEN];        // 接入热点Mac
    int                      nAPChannel;                     // 接入热点频道
    char                     szAPSSID[24];                   // 接入热点SSID
    EM_WIRELESS_DATA_ENCRYPT emAPEncrypt;                    // 接入热点加密类型
	int						 nRssiQuality;                   // 信号强度
	char					 szManufacturer[MAX_MANUFACTURER_LEN];			// Mac地址所属制造商
	char					 szMacHistorySSID[MAX_MACHISTORY_SSID_NUM][MAX_MACHISTORY_SSID_LEN];     // 此设备曾经连接过的历史SSID列表
	unsigned int			 nRetMacHistorySSIDNum;			 // 此设备实际连接过的SSID个数
    BYTE                     reserved[264];                  // 预留
   
} NET_WIFI_DEV_INFO;

// 搜索到的WIFI基本信息
typedef struct tagNET_WIFI_BASIC_INFO
{
	UINT nPeriodUTC;      //本周期上报的起始时间，为同一上报周期的标识；当同一上报周期内设备总数超过单次上报数量上限时需要多次上报事件，该值作为同一上报周期内多次上报事件的标识码；
	int  nDeviceSum;      //本周期上报的wifi总数，同一上报周期内的事件中的该值均应为本周期上报的wifi总数
	int  nCurDeviceCount; //本次事件上报的Wifi设备数量，应与ALARM_WIFI_SEARCH_INFO结构体中的nWifiNum值一致；同一上报周期内该值的累积总数与nDeviceSum一致。
	BYTE reserved[500];   //预留字节
}NET_WIFI_BASIC_INFO;

// 定位结果
typedef enum tagNET_GPS_POSITION_RESULT
{			
	NET_GPS_POSITION_RESULT_UNKNOWN = 0,					// 未知
	NET_GPS_POSITION_RESULT_FAILED = 1,						// 有GPS数据,但定位失败,此时定位数据无意义
	NET_GPS_POSITION_RESULT_SUCCEED = 2,					// 有GPS数据,且定位成功,此时定位数据有意义
} NET_GPS_POSITION_RESULT;

// 搜索到的地点信息
typedef struct tagNET_WIFI_GPS_INFO
{
	NET_GPS_POSITION_RESULT			emPositioningResult;	// 定位结果
	unsigned int 					nLongitude;				// 经度(单位是百万分之一度)
															// 西经：0 - 180000000				实际值应为: 180*1000000 C dwLongitude
															// 东经：180000000 - 360000000		实际值应为: dwLongitude C 180*1000000
															// 如: 300168866应为（300168866 - 180*1000000）/1000000 即东经120.168866度
	unsigned int					nLatidude;				// 纬度(单位是百万分之一度)
															// 南纬：0 - 90000000				实际值应为: 90*1000000 C dwLatidude
															// 北纬：90000000 C 180000000		实际值应为: dwLatidude C 90*1000000
															// 如: 120186268应为 (120186268 - 90*1000000)/1000000 即北纬30. 186268度
	unsigned int					nSpeed;					// 速度, 单位千分之一km/H
	BYTE							reserved[112];			// 保留字段
} NET_WIFI_GPS_INFO;

// 事件类型 DH_ALARM_WIFI_SEARCH (搜索WIFI设备)对应的数据描述信息
typedef struct tagALARM_WIFI_SEARCH_INFO
{
    int                      nWifiNum;                       // WIFI设备数量, 指示stuWifi的有效数量
    NET_WIFI_DEV_INFO        stuWifi[1024];                  // 周围Wifi设备的信息
	int                      nChannel;                       // 通道号
	NET_WIFI_BASIC_INFO      stuWifiBasiInfo;				 // Wifi事件上报基础信息
	BOOL					 bGPSinfo;						 // 是否包含GPS信息
	NET_WIFI_GPS_INFO		 stuWifiGPSInfo;				 // GPS信息
    BYTE                     reserved[376];                  // 预留
} ALARM_WIFI_SEARCH_INFO;


// 搜索到的WIFI设备虚拟身份信息
typedef struct tagNET_WIFI_VIRTUALINFO
{
	NET_TIME_EX				stuAccessTime;								// 访问时间，时间不精确仅供参考
	char					szSrcMac[DH_MACADDR_LEN];					// 虚拟信息的来源MAC,字母大写，用"-"分隔
    char					szDstMac[DH_MACADDR_LEN];					// 虚拟信息的目标MAC,字母大写，用"-"分隔
	int						nProtocal;									// 协议代号，上网应用对应的标识码
	char					szUrl[DH_MAX_URL_LEN];						// 上网url
	char					szDomain[MAX_VIRTUALINFO_DOMAIN_LEN];		// 上网域
	char					szTitle[MAX_VIRTUALINFO_TITLE_LEN];			// 上网标题
	char					szUsrName[MAX_VIRTUALINFO_USERNAME_LEN];	// 用户名
	char					szPassWord[MAX_VIRTUALINFO_PASSWORD_LEN];	// 密码
	char					szPhoneNum[MAX_VIRTUALINFO_PHONENUM_LEN];	// 手机号
	char					szImei[MAX_VIRTUALINFO_IMEI_LEN];			// 国际移动设备标识
	char					szImsi[MAX_VIRTUALINFO_IMSI_LEN];			// 国际移动用户识别码
	char					szLatitude[MAX_VIRTUALINFO_LATITUDE_LEN];	// 经度
	char					szLongitude[MAX_VIRTUALINFO_LONGITUDE_LEN];	// 纬度
	char					szSrcIP[DH_MAX_IPADDR_LEN_EX];				// 源IP
	char					szDstIP[DH_MAX_IPADDR_LEN_EX];				// 目的IP
	UINT					nSrcPort;									// 源端口
	UINT					nDstPort;									// 目的端口
    char                    szSiteNum[MAX_COMMON_STRING_16];            // 场所编号
    char                    szDevNum[MAX_COMMON_STRING_32];             // 采集设备编号
    char                    szUserID[MAX_COMMON_STRING_32];             // 虚拟用户ID
    char                    szIDFA[MAX_COMMON_STRING_64];               // 苹果手机的IDFA
	BYTE                    reserved[368];								// 预留
}NET_WIFI_VIRTUALINFO;

// 事件类型 DH_ALARM_WIFI_VIRTUALINFO_SEARCH (获取周围wifi设备虚拟信息事件)对应的数据描述信息
typedef struct tagALARM_WIFI_VIRTUALINFO_SEARCH_INFO
{
    int                      nVirtualInfoNum;								// WIFI设备虚拟身份数量, 指示stuVirtualInfo的有效数量
    NET_WIFI_VIRTUALINFO     stuVirtualInfo[MAX_VIRTUALINFO_NUM];           // 周围Wifi虚拟身份信息
	int                      nChannel;										// 通道号
	BYTE                     reserved[512];									// 预留 
} ALARM_WIFI_VIRTUALINFO_SEARCH_INFO;

// 事件类型 DH_ALARM_USER_LOCK_EVENT (用户锁定报警事件)对应的数据描述信息
typedef struct tagALARM_USER_LOCK_EVENT_INFO
{	 
    char                    szUser[DH_NEW_USER_NAME_LENGTH];				// 用户名
	char					szGroup[DH_NEW_USER_NAME_LENGTH];				// 组名
	char                    szIP[DH_MAX_IPADDR_LEN_EX];						// 设备IP
	BYTE                    reserved[512];									// 预留 
} ALARM_USER_LOCK_EVENT_INFO;

//无线设备类型
typedef enum tagNET_WIRELESSDEV_LOWPOWER_TYPE
{
    NET_WIRELESSDEV_UNKNOWN = 0,                                // 未知设备
    NET_WIRELESSDEV_CONTROL = 1,                                // 无线遥控器
    NET_WIRELESSDEV_DEFENCE = 2,                                // 无线防区
    NET_WIRELESSDEV_KEYBOARD = 3,                               // 无线键盘
    NET_WIRELESSDEV_MAGNETOMER = 4,                             // 无线门磁
	NET_WIRELESSDEV_ALARMBELL = 5,								// 无线警号
    NET_WIRELESSDEV_SMARTLOCK = 6,                              // 智能锁
} NET_WIRELESSDEV_LOWPOWER_TYPE;

//无线设备低电量报警事件结构体
typedef struct tagALARM_WIRELESSDEV_LOWPOWER_INFO
{
    NET_THREE_STATUS_BOOL         emResult;                  // 是否为低电量true低电量,false 电量正常,unknown未知
    NET_TIME                      stuTime;                   // 事件发生的时间
    int                           nId;                       // 无线设备ID
    NET_WIRELESSDEV_LOWPOWER_TYPE emType;                    // 无线设备类型
    char                          szSN[32];                  // 无线配件序列号
    float                         fPercent;                  // 电量百分比
    BYTE                          reserved[988];             // 预留
} ALARM_WIRELESSDEV_LOWPOWER_INFO;

// 报警事件类型 DH_ALARM_BUS_PAD_SHUTDOWN(PAD关机事件)对应的数据描述信息
typedef struct tagALARM_BUS_PAD_SHUTDOWN_INFO
{
    int                nDelayTime;                      // 关机延时时间,单位：秒
    BOOL               bConfirm;                        // 是否需要确认
    NET_TIME_EX        stuUtcTime;                      // 事件发生的时间
    DWORD              dwUtc;                           // 事件发生的时间, 用于确认
    BYTE               byReserved[512];                 // 预留字节
} ALARM_BUS_PAD_SHUTDOWN_INFO;

// 热度图数据类型
typedef enum tagEM_HEAT_PIC_DATA_TYPE
{
	EM_HEAT_PIC_DATA_TYPE_UNKNOWN,					// 未知类型
	EM_HEAT_PIC_DATA_TYPE_GRAYDATA,					// 灰度数据
	EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,				// 原始数据
}EM_HEAT_PIC_DATA_TYPE;
// 获取热度统计信息入参
typedef struct tagNET_IN_QUERY_HEAT_MAP
{
    int                      nChannel;                       // 通道号
    NET_TIME_EX              stuBegin;                       // 开始时间    
    NET_TIME_EX              stuEnd;                         // 结束时间
    UINT                     nPlanID;                        // 计划ID,仅球机有效,从1开始 (热度图统一之前使用, 统一之后使用byPtzPresetID)
	EM_HEAT_PIC_DATA_TYPE	 emDataType;					 // 希望获取的数据类型
	BYTE                     byPtzPresetID;                  // 预置点号, 热度图统一之后使用
    BYTE                     reserved[1015];                 // 预留
} NET_IN_QUERY_HEAT_MAP;

// 获取热度统计信息出参
typedef struct tagNET_OUT_QUERY_HEAT_MAP
{
    int                      nWidth;                         // 图片宽度
    int                      nHeight;                        // 图片高度
    char *                   pBufData;                       // 热度数据灰阶位图, 用户申请内存,大小为nBufLen
															 // 若emDataType为EM_HEAT_PIC_DATA_TYPE_GRAYDATA,则一个字节表示一个点
															 // 若emDataType为EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,则四个字节表示一个点
    int                      nBufLen;                        // pBufData最大长度
    int                      nBufRet;                        // 实际返回的长度
    int                      nAverage;                       // 均值信息
	UINT					 nPlanID;						 // 计划ID,与请求NET_IN_QUERY_HEAT_MAP的nPlanID对应 (热度图统一之前使用, 统一之后使用byPtzPresetID)
	EM_HEAT_PIC_DATA_TYPE    emDataType;					 // 获取到的数据类型
	UINT					 nPixelMax;						 // 实际像素点的最大值
	UINT					 nPixelMin;						 // 实际像素点的最小值
	BYTE                     byPtzPresetID;                  // 预置点号, 与请求NET_IN_QUERY_HEAT_MAP的byPtzPresetID对应, 热度图统一之后使用
    BYTE                     reserved[1003];                 // 预留
} NET_OUT_QUERY_HEAT_MAP;

// 获取热度统计信息, 对应命令DH_DEVSTATE_GET_HEAT_MAP
typedef struct tagNET_QUERY_HEAT_MAP
{
    DWORD                    dwSize;                         // 该结构体大小
    NET_IN_QUERY_HEAT_MAP    stuIn;                          // 热度统计信息查询条件
    NET_OUT_QUERY_HEAT_MAP   stuOut;                         // 热度统计信息查询结果
} NET_QUERY_HEAT_MAP;

//GPS信息查询条件
typedef struct tagNET_IN_DEV_GPS_INFO
{
	DWORD                    dwSize;                         // 该结构体大小
    int                      nChannel;                       // 设备通道号
} NET_IN_DEV_GPS_INFO;

//GPS工作状态
typedef enum tagNET_GPS_WORK_STATUS
{
	EM_WORK_STATE_UNKNOWN = 0,			//未知工作状态
	EM_NO_POSITIONING,					//未定位
	EM_NO_DIFFERENTIAL_POSITIONING,		//非差分定位
	EM_DIFFERENTIAL_POSITIONING,		//差分定位
	EM_INVALID_PPS,						//无效PPS
	EM_EVALUATING,						//正在估算
}NET_GPS_WORK_STATUS;


//GPS信息查询结果
typedef struct tagNET_OUT_DEV_GPS_INFO
{
	DWORD                   dwSize;                          // 该结构体大小
    NET_TIME				stuLocalTime;                    // 当前时间 
	double                  dbLongitude;                     // 经度(单位是百万分之度,范围0-360度)
    double                  dbLatitude;                      // 纬度(单位是百万分之度,范围0-180度)
	double                  dbAltitude;                      // 高度(单位:米)
	double                  dbSpeed;                         // 速度(单位:km/H)
	double                  dbBearing;                       // 方向角(单位:度)
	NET_THREE_STATUS_BOOL   emAntennasStatus;				 // 天线状态(0:坏 1:好)
	NET_THREE_STATUS_BOOL   emPositioningResult;             // 定位状态(0:不定位 1:定位)
	DWORD					dwSatelliteCount;				 // 卫星个数
	NET_GPS_WORK_STATUS     emworkStatus;                    // 工作状态
	int                     nAlarmCount;					 // 报警个数
	int                     nAlarmState[128];                // 发生的报警位置,值可能多个
	float					fHDOP;							 // 水平精度因子
} NET_OUT_DEV_GPS_INFO;

// GPS状态信息
typedef struct tagNET_SET_GPS_STATUS_INFO
{
	EM_DATE_SOURCE          emDateSource;						// 数据来源
	NET_TIME				stuLocalTime;						// 当前时间 
	double                  dbLongitude;						// 经度(单位是度,范围0-360度)
    double                  dbLatitude;							// 纬度(单位是度,范围0-180度)
	double                  dbAltitude;							// 高度(单位:米)
	double                  dbSpeed;							// 速度(单位:km/H)
	double                  dbBearing;							// 方向角(单位:度)
	NET_THREE_STATUS_BOOL   emAntennasStatus;					// 天线状态(0:坏 1:好)
	NET_THREE_STATUS_BOOL   emPositioningResult;				// 定位状态(0:不定位 1:定位)
	int						nSatelliteCount;					// 卫星个数
	NET_GPS_WORK_STATUS     emWorkStatus;						// 工作状态
	int                     nAlarmCount;						// 报警个数
	int                     nAlarmState[128];					// 发生的报警位置,值可能多个
	double					dbHDOP;								// 水平精度因子
	BYTE					byReserved[1024];					// 保留字节
} NET_SET_GPS_STATUS_INFO;

// CLIENT_SetGPSStatus 设置GPS状态输入参数
typedef struct tagNET_IN_SET_GPS_STATUS
{
	DWORD						dwSize;	
	BOOL						bEnable;						// 使能项, 是否使用设置的数据
	int							nChannel;						// 通道号
	NET_SET_GPS_STATUS_INFO		stGPSInfo;						// GPS 状态信息
} NET_IN_SET_GPS_STATUS;

// CLIENT_SetPositionStatus 设置GPS状态输出参数
typedef struct tagNET_OUT_SET_GPS_STATUS
{
	DWORD					dwSize;								
} NET_OUT_SET_GPS_STATUS;

// 设置GPS状态信息(pInParam, pOutParam内存由用户申请释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetGPSStatus(LLONG lLoginID, const NET_IN_SET_GPS_STATUS* pInParam, NET_OUT_SET_GPS_STATUS* pOutParam, int nWaitTime);


// 查询 IVS 前端设备入参
typedef struct tagNET_IN_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // 该结构体大小   
    int                     nChannel;                       // 通道号
}NET_IN_IVS_REMOTE_DEV_INFO;

// 查询 IVS 前端设备出参
typedef struct tagNET_OUT_IVS_REMOTE_DEV_INFO
{
    DWORD                   dwSize;                         // 该结构体大小 
    int                     nPort;                          // 端口
    char                    szIP[64];                       // 设备IP
    char                    szUser[64];                     // 用户名
    char                    szPassword[64];                 // 密码    
    char                    szAddress[128];	                // 机器部署地点
}NET_OUT_IVS_REMOTE_DEV_INFO;

// 查询智能插座信息入参 
typedef struct tagNET_IN_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // 该结构体大小 
    char                    szSerialNumber[DH_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 设备序列号 
}NET_IN_SMART_SWITCH_INFO;

// 查询智能插座信息出参
typedef struct tagNET_OUT_SMART_SWITCH_INFO
{
    DWORD                   dwSize;                         // 该结构体大小 
    BOOL                    bSwitchEable;                   // 开关状态, TRUE 开, FALSE 关
    double                  dbCurrentPower;                 // 及时功率, unit: W 
    double                  dbHistoryPowerUsed;             // 历史用电量, unit: kw/h
    double                  dbTodayPowerUsed;               // 当天用电量, unit: kw/h
    double                  dbMonthPowerUsed[NET_MAX_MONTH_NUM]; // 每月用电量, unit: kw/h
}NET_OUT_SMART_SWITCH_INFO; 

// 查询升级状态入参
typedef struct tagNET_IN_UPGRADE_STATE
{
    DWORD                   dwSize;                         // 该结构体大小 
}NET_IN_UPGRADE_STATE;

// 码流类型
enum CFG_EM_STREAM_TYPES
{
	CFG_EM_STREAMTYPE_ERR,                  // 其它
	CFG_EM_STREAMTYPE_MAIN,					// "Main"-主码流
	CFG_EM_STREAMTYPE_EXTRA_1,				// "Extra1"-辅码流1
	CFG_EM_STREAMTYPE_EXTRA_2,				// "Extra2"-辅码流2
	CFG_EM_STREAMTYPE_EXTRA_3,				// "Extra3"-辅码流3
	CFG_EM_STREAMTYPE_SNAPSHOT,				// "Snapshot"-抓图码流
	CFG_EM_STREAMTYPE_TALKBACK,				// "Talkback"-对讲码流
};

// 获取视频编码能力集入参
typedef struct tagNET_IN_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;                         // 该结构体大小
	int						nChannel;						// 通道号
	int						nGroup;							// 组号
	CFG_EM_STREAM_TYPES		stStreamType;					// 码流类型
}NET_IN_VIDEO_ENCODE_CAPS;

// 获取视频编码能力集出参
typedef struct tagNET_OUT_VIDEO_ENCODE_CAPS
{
	DWORD					dwSize;																// 该结构体大小
	int						nSvcEncodeTypesNum;													// 支持SVC编码的视频格式个数
	char					szSvcEncodeTypes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];			// 支持SVC编码的视频格式
	int						nGOPCustomEncodesNum;												// 支持自定义I帧间隔的码流个数
	char					szGOPCustomEncodes[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// 支持自定义I帧间隔的码流
	int						nMaxSVCTLevel;														// 最大SVC-T支持层数
}NET_OUT_VIDEO_ENCODE_CAPS;

// 获取音频编码能力集入参
typedef struct tagNET_IN_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;                         // 该结构体大小
	int						nChannel;						// 通道号
	CFG_EM_STREAM_TYPES		stStreamType;					// 码流类型
}NET_IN_AUDIO_ENCODE_CAPS;

// 获取音频编码能力集出参
typedef struct tagNET_OUT_AUDIO_ENCODE_CAPS
{
	DWORD					dwSize;														// 该结构体大小
	BOOL					bSupportSourceSelect;										// 是否支持多路音频输入
	int						nSourceTypeNum;												// 音频源类型个数
	char					szSourceType[DH_COMMON_STRING_32][DH_COMMON_STRING_32];		// 音频源类型列表
}NET_OUT_AUDIO_ENCODE_CAPS;

// 音频解码能力数据流源类型
enum EM_AUDIO_DATA_SOURCE_TYPE
{
	EM_AUDIO_DATA_SOURCE_TYPE_UNKNOWN = -1,		// 未知数据类型
	EM_AUDIO_DATA_SOURCE_TYPE_TALK,				// 对讲数据
	EM_AUDIO_DATA_SOURCE_TYPE_NORMAL,			// 普通音频数据，如伴音
	EM_AUDIO_DATA_SOURCE_TYPE_ALARM,			// 报警音频数据流
};

// 获取音频解码能力集入参
typedef struct tagNET_IN_AUDIO_DECODE_CAPS
{
	DWORD								dwSize;                         // 该结构体大小
	int									nChannel;						// 通道号
	EM_AUDIO_DATA_SOURCE_TYPE			emSourceType;					// 数据流源类型
}NET_IN_AUDIO_DECODE_CAPS;


// 音频解码能力信息
typedef struct tagNET_AUDIO_DECODE_FORMAT
{	
	NET_EM_AUDIO_FORMAT			emCompression;				// 音频编码格式
	int							nFrequency;					// 音频采样频率：8K ~ 192K
	int							nDepth;						// 音频采样深度：8,16,24	
	int							nPacketPeriod;				// 音频打包周期, [10, 250],ms
	BYTE						szReserved[512];			// 保留字段
}NET_AUDIO_DECODE_FORMAT;

// 获取音频解码能力集出参
typedef struct tagNET_OUT_AUDIO_DECODE_CAPS
{
	DWORD					dwSize;							// 结构体大小，赋值为 sizeof(NET_OUT_AUDIO_DECODE_CAPS)
	NET_AUDIO_DECODE_FORMAT	stuDecodeFormats[64];			// 音频解码格式信息		
	int						nFormatsRet;					// 返回的音频解码格式信息数量	
}NET_OUT_AUDIO_DECODE_CAPS;

// 获取当前布撤防状态入参
typedef struct tagNET_IN_GET_ARM_MODE
{
    DWORD                   dwSize;                         // 结构体大小，赋值为 sizeof(NET_IN_GET_ARM_MODE)
}NET_IN_GET_ARM_MODE;

// 布撤防状态
typedef enum tagEM_ARM_MODE_MODE
{
    EM_ARM_MODE_MODE_UNKNOWN,                               // 未知类型
    EM_ARM_MODE_MODE_ARMING,                                // 布防
    EM_ARM_MODE_MODE_DISARMING,                             // 撤防
}EM_ARM_MODE_MODE;

// 获取当前布撤防状态出参
typedef struct NET_OUT_GET_ARM_MODE
{
    DWORD                   dwSize;                         // 结构体大小，赋值为 sizeof(NET_OUT_GET_ARM_MODE)
    int                     nDelay;                         // 延迟
    EM_ARM_MODE_MODE        emMode;                         // 布撤防状态
    BYTE                    byReserved[4];                  // 预留字段
}NET_OUT_GET_ARM_MODE;

// 获取音频输入通道能力集入参
typedef struct tagNET_IN_AUDIO_IN_CAPS
{
	DWORD					dwSize;                         // 该结构体大小
	int						nChannel;						// 通道号
}NET_IN_AUDIO_IN_CAPS;

// 获取音频输入通道能力集出参
typedef struct tagNET_IN_AUDIO_OUT_CAPS
{
	DWORD					dwSize;                         // 该结构体大小
	int						nMicNum;						// 麦克风输入个数,大于0表示支持对讲输入
	int						nLineInNum;						// 线性输入个数,大于0表示支持伴音输入
}NET_OUT_AUDIO_IN_CAPS;

// Smart编码信息
typedef struct tagSMART_ENCODE_INFO
{
	DWORD					dwSize;							   // 该结构体大小
	char					szCompression[MAX_COMMON_STRING_8]; // 视频编码压缩格式，如"H.264", "H.265"
	int						nPolicy;						   // Smart编码策略
	bool					bEnable;						   // 码流是否使能
	int						nWidth;							   // 视频宽度，选填
	int						nHeight;						   // 视频高度，选填
	float					fFPS;							   // 视频帧率，选填
}SMART_ENCODE_INFO;

// 查询Smart编码能力集入参
typedef struct tagNET_IN_SMART_ENCODE_CAPS
{
	DWORD					dwSize;								// 该结构体大小
	int						nChannel;							// 通道号
	int						nStreamNum;							// 实际码流个数
	SMART_ENCODE_INFO		stSmartEncodeInfo[MAX_STREAM_NUM];  // 每个码流对应的Smart编码信息，如果实际码流个数为3，则下标0、1、2分辨代表主码流、辅码流1、辅码流2的编码信息	
}NET_IN_SMART_ENCODE_CAPS;

// Smart编码使能
typedef struct tagSMART_ENCODE_CAPS_INFO
{
	DWORD					dwSize;																// 该结构体大小
	int						nSmartEncodeCap;													// 1支持开启编码重定位P帧功能；0不支持Smart编码(但能输出普通码流)；-1不支持编码(比如主码流分辨率过大，导致资源不足，辅码流2不能编码，但降低主码流分辨率，辅2可以正常编码)
}SMART_ENCODE_CAPS_INFO;

//查询Smart编码能力集出参
typedef struct tagNET_OUT_SMART_ENCODE_CAPS
{
	DWORD						dwSize;															// 该结构体大小
	int							nSmartEncodeCapsNum;											// Smart编码使能组个数
	SMART_ENCODE_CAPS_INFO		stSmartEncodeCaps[MAX_STREAM_NUM];								// 每个码流Smart编码信息对应编码使能。
}NET_OUT_SMART_ENCODE_CAPS;

// 查询设备ID入参
typedef struct tagNET_IN_DEVICE_ID
{
	DWORD						dwSize;															// 结构体大小
}NET_IN_DEVICE_ID;

// 查询设备ID出参
typedef struct tagNET_OUT_DEVICE_ID
{
	DWORD						dwSize;															// 结构体大小
	char						szDeviceID[48];													// 设备传过来的序列号，唯一标识某个设备
}NET_OUT_DEVICE_ID;

// 升级包类型
typedef enum tagEM_UPGRADE_PACKAGE_TYPE
{
    EM_UPGRADE_PACKAGE_TYPE_UNKNOWN,                       // 未知类型
    EM_UPGRADE_PACKAGE_TYPE_REGULAR,                       // 一般升级
    EM_UPGRADE_PACKAGE_TYPE_EMERGENCY,                     // 强制升级
}EM_UPGRADE_PACKAGE_TYPE;

// 升级包和升级状态
typedef enum tagEM_UPGRADE_STATE
{
    EM_UPGRADE_STATE_UNKNOWN,                               // 未知状态
    EM_UPGRADE_STATE_NONE,                                  // 没有检测到更新状态
    EM_UPGRADE_STATE_INVALID,                               // 升级包不正确
    EM_UPGRADE_STATE_NOT_ENOUGH_MEMORY,                     // 内存不够
    EM_UPGRADE_STATE_DOWNLOADING,                           // 正在下载数据
    EM_UPGRADE_STATE_DOWNLOAD_FAILED,                       // 下载失败
    EM_UPGRADE_STATE_DOWNLOAD_SUCCESSED,                    // 下载成功
    EM_UPGRADE_STATE_PREPARING,                             // 准备升级
    EM_UPGRADE_STATE_UPGRADING,                             // 升级中
    EM_UPGRADE_STATE_UPGRADE_FAILED,                        // 升级失败
    EM_UPGRADE_STATE_UPGRADE_SUCCESSED,                     // 升级成功
    EM_UPGRADE_STATE_UPGRADE_CANCELLED,                     // 取消升级 
    EM_UPGRADE_STATE_FILE_UNMATCH,                          // 升级包不匹配
}EM_UPGRADE_STATE;

// 设备升级状态事件
typedef struct tagALARM_UPGRADE_STATE
{
    EM_UPGRADE_STATE        emState;                        // 升级包和升级状态
    int                     nProgress;                      // 升级进度, 0 ~ 100
    char                    szFileName[DH_COMMON_STRING_64];// 正在操作的文件名
    BYTE		            byReserved[1024];
}ALARM_UPGRADE_STATE;

// 存储设备工作状态
typedef enum tagEM_LABELDATA_STATE
{
	EM_LABELDATA_STATE_ENTER,		                            // Enter (进入)
	EM_LABELDATA_STATE_LEAVE,									// Leave (离开)
}EM_LABELDATA_STATE;

// IPC新增(2017.4),RFID标签信息采集事件
typedef struct tagALARM_LABELINFO
{
	int						nChannelID;							// 通道号
	char					szIndexIs[DH_COMMON_STRING_8];		// 事件Index代表的含义，如无该字段，无法级联
	int						nVideoIndex;						// 视频通道号
	UINT					nACK;								// 确认ID
	char					szReceiverID[DH_COMMON_STRING_16];	// 接收器ID
	char					szLabelID[DH_COMMON_STRING_16];		// RFID标签
	NET_TIME_EX				stuDateTime;						// 采集时间UTC
	EM_LABELDATA_STATE		emLabelDataState;					// 标签的数据状态（进入、离开）
	BYTE					byReserve[1024];					// 保留字节
}ALARM_LABELINFO;
				
// 查询升级状态出参
typedef struct tagNET_OUT_UPGRADE_STATE
{
    DWORD                   dwSize;                         // 该结构体大小
    char                    szOldVersion[DH_COMMON_STRING_64]; // 旧版本号
    char                    szNewVersion[DH_COMMON_STRING_64];  // 新版本号
    EM_UPGRADE_STATE        emState;                        // 升级包和升级状态
    EM_UPGRADE_PACKAGE_TYPE emType;                         // 升级包类型
    int                     nProgress;                      // 升级进度, 0 ~ 100
}NET_OUT_UPGRADE_STATE;

//查询硬盘温度入参
typedef struct tagNET_IN_HDD_TEMPERATURE
{
	DWORD					dwSize;
	char					szHardDiskName[DH_COMMON_STRING_16];		//存储设备名称
	
}NET_IN_HDD_TEMPERATURE;

//查询硬盘温度出参
typedef struct tagNET_OUT_HDD_TEMPERATURE
{
	DWORD					dwSize;
	int						nID;										// 属性ID
	char					szName[DH_COMMON_STRING_64];				// 属性名
	int						nCurrent;									// 属性值
	int						nWorst;										// 最大出错值
	int						nThreshold;									// 阈值
	char					szRaw[DH_COMMON_STRING_32];					// 实际值
	int						nPredict;									// 状态
	int						nSync;										// Raid同步状态,0 自适应；1 同步优先，I/O优先分给Raid同步;2 业务优先，I/O优先分给硬盘写数据;3 均衡																		
}NET_OUT_HDD_TEMPERATURE; 

// 获取指定格式的YUV数据入参
typedef struct tagNET_IN_RAWFRAMEDATA
{
	DWORD					dwSize;										
	int						nChannel;									// 视频输入通道号
	int						nSensorID;									// sensor ID
	char					szRawFrameType[DH_COMMON_STRING_32];		// YUV数据格式,支持的范围通过CLIENT_GetDevCaps方法, 命令: NET_VIDEOIN_RAWFRAME_CAPS获取
}NET_IN_RAWFRAMEDATA;

// 获取指定格式的YUV数据出参
typedef struct tagNET_OUT_RAWFRAMEDATA
{
	DWORD					dwSize;
	UINT					nHeight;									// 返回图片的高度
	UINT					nWidth;										// 返回图片的宽
	UINT					nDataLen;									// YUV二进制数据大小，单位字节
	char*					pszBuffer;									// YUV数据，由用户申请内存，大小为，nBufferLen
	int						nBufferLen;									// 用户申请YUV数据内存大小
}NET_OUT_RAWFRAMEDARA;

#define NET_MAX_NUM_CHANNEL_WATCHER 16     // 守望者最大通道数量
#define NET_MAX_NUM_SPLICEDATA 8           // 守望者最大拼接文件数量(即镜头数量)

// 获取设备拼接参数入参(对应 NET_QUERY_GETSPLICEDATA)
typedef struct tagNET_IN_GETSPLICEDATA
{
	DWORD					dwSize;                                     // 结构体大小
}NET_IN_GETSPLICEDATA;

// 单个拼接文件数据
typedef struct tagNET_SINGLE_SPLICEDATA
{
	int                     nScale;                                     // 拼接参数中球面模型的半径，以像素点为单位
	int                     nOffsetX;                                   // 图像在球面展开图上的x坐标，以像素点为单位
	int                     nOffsetY;                                   // 图像在球面展开图上的y坐标，以像素点为单位
	BYTE                    byReserved[128];                            // 保留字节
}NET_SINGLE_SPLICEDATA;

// 单个通道拼接数据
typedef struct tagNET_MULTIVIDEO_SPLICEINFO
{
	UINT                    nChannelID;                                 // 视频通道号
	int                     nNumSplice;                                 // 实际拼接文件的数量
	NET_SINGLE_SPLICEDATA   stuSpliceData[NET_MAX_NUM_SPLICEDATA];      // 单个拼接文件数据
	BYTE                    byReserved[512];                            // 保留字节
}NET_MULTIVIDEO_SPLICEINFO;

// 获取设备拼接参数出参(对应 NET_QUERY_GETSPLICEDATA)
typedef struct tagNET_OUT_GETSPLICEDATA
{
	DWORD					dwSize;                                     // 结构体大小
	int                     nNumChannel;                                // 实际通道拼接信息的数量
	NET_MULTIVIDEO_SPLICEINFO   stuSpliceInfo[NET_MAX_NUM_CHANNEL_WATCHER];      // 通道拼接信息,每个元素对应一个通道的拼接参数信息
}NET_OUT_GETSPLICEDATA;

// 门禁AC服务协议能力获取入参
typedef struct tagNET_IN_AC_CAPS
{
    DWORD					dwSize;                                     // 结构体大小
}NET_IN_AC_CAPS;

// 假日计划能力
typedef struct tagNET_SPECIAL_DAYS_SCHEDULE_CAPS
{
    BOOL								bSupport;						// 是否支持假日计划
    int									nMaxSpecialDaysSchedules;		// 设备支持的最大计划数量
    int									nMaxTimePeriodsPerDay;			// 每天最多的时间段
    int									nMaxSpecialDayGroups;			// 设备支持的最大假日组数
    int									nMaxDaysInSpecialDayGroup;		// 每个假日组里最大的假日数
    BYTE								byReserved[128];				// 保留字节
} NET_SPECIAL_DAYS_SCHEDULE_CAPS;

// AC服务能力集
typedef struct tagNET_AC_CAPS
{
    int                     nChannels;                                  // 支持的门禁通道数量
    BOOL					bSupAccessControlAlarmRecord;               // 是否支持门禁报警日志记录在记录集中
    int                     nCustomPasswordEncryption;		            // AccessControlCustomPassword记录集中密码的保存方式,0:明文,默认值0, 1:MD5
    int                 	nSupportFingerPrint;			            // 是否支持指纹功能,0:未知，默认,1:不支持, 2:支持
    BOOL                    bHasCardAuth;                               // 是否支持卡片鉴权
    BOOL                    bHasFaceAuth;                               // 是否支持人脸识别鉴权
    BOOL                    bOnlySingleDoorAuth;	                    // 是否只支持单门授权(发卡)
    BOOL					bAsynAuth;                                  // 是否支持授权异步返回 
    BOOL                    bUserlsoLate;                               // 是否支持人卡分离方案
    int                     nMaxInsertRate;                             // 机器数据下发插入最大数量
    NET_SPECIAL_DAYS_SCHEDULE_CAPS  stuSpecialDaysSchedule;			    // 假日计划能力 
    int                     nUnlockModes;                               // 设备支持的开锁模式组合数量
    NET_ACCESS_DOOROPEN_METHOD  emUnlockModes[128];                     // 设备支持的开锁模式组合
    BYTE					byReserved[256];				            // 保留字节
}NET_AC_CAPS;

// user操作能力集
typedef struct tagNET_ACCESS_USER_CAPS
{
    int                     nMaxInsertRate;                             // 每次下发的最大数量
    int                     nMaxUsers;                                  // 用户数量上限
    int                     nMaxFingerPrintsPerUser;                    // 每个用户可以记录的最大指纹数量
    int                     nMaxCardsPerUser;                           // 每个用户可以记录的最大卡片数量
    BYTE					byReserved[512];				            // 保留字节
}NET_ACCESS_USER_CAPS;

// card操作能力集
typedef struct tagNET_ACCESS_CARD_CAPS
{
    int                     nMaxInsertRate;                             // 每次下发的最大数量
    int                     nMaxCards;                                  // 卡片数量上限
    BYTE					byReserved[512];				            // 保留字节
}NET_ACCESS_CARD_CAPS;

// fingerprint操作能力集
typedef struct tagNET_ACCESS_FINGERPRINT_CAPS
{
    int                     nMaxInsertRate;                             // 每次下发的最大数量
    int                     nMaxFingerprintSize;                        // 单指纹数据的最大字节数
    int                     nMaxFingerprint;                            // 指纹数量上限
    BYTE					byReserved[512];				            // 保留字节
}NET_ACCESS_FINGERPRINT_CAPS;

// face操作能力集
typedef struct tagNET_ACCESS_FACE_CAPS
{
    int                     nMaxInsertRate;                             // 每次下发的最大数量
    int                     nMaxFace;                                   // 人脸存储上限
    int                     nRecognitionType;                           // 人脸识别类型，0:白光 1:红外
    int                     nRecognitionAlgorithm;                      // 人脸识别算法，0:未知1:大华2:商汤3:依图4:汉王5:火眼
    DWORD                   dwRecognitionVersion;                       // 人脸识别算法(模型)版本号，0x00010502 为1.5.2
    int                     nMinPhotoSize;                              // 白光人脸照片的最小尺寸 ,单位 KB
    int                     nMaxPhotoSize;                              // 白光人脸照片的最大尺寸 ,单位 KB
    int                     nMaxGetPhotoNumber;                         // 批量获取白光人脸的最大数量
    BOOL                    bIsSupportGetPhoto;                         // 是否支持获取白光照片	
    BYTE					byReserved[504];				            // 保留字节
}NET_ACCESS_FACE_CAPS;

// 门禁AC服务协议与设备能力获取出参
typedef struct tagNET_OUT_AC_CAPS
{
    DWORD					    dwSize;                                     // 结构体大小
    NET_AC_CAPS                 stuACCaps;                                  // ACCaps能力集
    NET_ACCESS_USER_CAPS        stuUserCaps;                                // user操作能力集
    NET_ACCESS_CARD_CAPS        stuCardCaps;                                // card操作能力集
    NET_ACCESS_FINGERPRINT_CAPS stuFingerprintCaps;                         // 指纹操作能力集
    NET_ACCESS_FACE_CAPS        stuFaceCaps;                                // 人脸操作能力集
}NET_OUT_AC_CAPS;

//获取补光灯能力入参(对应:NET_LIGHTINGCONTROL_CAPS)
typedef struct tagNET_IN_LIGHTINGCONTROL_CAPS
{
	DWORD						dwSize;										//结构体大小
	int 						nChannel;											// 通道号
}NET_IN_LIGHTINGCONTROL_CAPS;

//支持灯光配置的版本
typedef enum tagEM_LC_CONFIG_VERSION
{
	EM_LC_CONFIG_VERSION_UNKNOWN,					//未知	
	EM_LC_CONFIG_VERSION_LIGHTING,					//使用Lighting配置，默认
	EM_LC_CONFIG_VERSION_LIGHTING_V2,				//使用Lighting_V2配置
}EM_LC_CONFIG_VERSION;	

//灯光类型
typedef enum tagEM_LC_LIGHT_TYPE
{
	EM_LC_LIGHT_TYPE_UNKNOWN,						//未知
	EM_LC_LIGHT_TYPE_INFRAREDLIGHT,					//红外灯
	EM_LC_LIGHT_TYPE_WIHTELIGHT,					//白光灯
	EM_LC_LIGHT_TYPE_LASERLIGHT,					//激光灯
}EM_LC_LIGHT_TYPE;

//支持的模式
typedef enum tagEM_LC_MODE
{
	EM_LC_MODE_UNKNOWN,								//未知
	EM_LC_MODE_MANUAL,								//手动
	EM_LC_MODE_ZOOMPRIO,							//倍率优先
	EM_LC_MODE_TIMING,								//定时
	EM_LC_MODE_AUTO,								//自动
	EM_LC_MODE_OFF,									//关闭灯光
	EM_LC_MODE_EXCLUSIVEMANUAL,						//支持多种灯光
	EM_LC_MODE_SMARTLIGHT,							//智能灯光
	EM_LC_MODE_LINKING,								//事件联动
	EM_LC_MODE_DUSKTODAWN							//光敏
}EM_LC_MODE;

#define SUPPORTED_LC_COMPLEX_MODES 3				//灯光支持的模式数量

//灯光支持的模式信息
typedef struct tagNET_MODES_COMPLEX_LIGHT
{
	EM_LC_MODE		anInfraredLight[SUPPORTED_LC_COMPLEX_MODES];		//红外灯支持的模式
	int				nInfraredLightLen;									//红外灯支持的模式数量
	EM_LC_MODE		anWhiteLight[SUPPORTED_LC_COMPLEX_MODES];			//白光灯支持的模式
	int				nWhiteLightLen;										//白光灯支持的模式数量
	EM_LC_MODE		anLaserLight[SUPPORTED_LC_COMPLEX_MODES];			//激光灯支持的模式
	int				nLaserLightLen;										//激光灯支持的模式数量
	BYTE			byReserved[128];				            		//保留字节
}NET_MODES_COMPLEX_LIGHT;

#define LC_LIGHT_COUNT 4			//灯光组灯光数量

//灯光组信息
typedef struct tagNET_LIGHT_TYPE_COMPLEX_DETAIL
{
	EM_LC_LIGHT_TYPE		anNearLight[LC_LIGHT_COUNT];		//近光灯组灯类型
	int						nNearLightLen;						//近光灯组灯数量
	EM_LC_LIGHT_TYPE		anMiddleLight[LC_LIGHT_COUNT];		//中光灯组灯类型
	int						nMiddleLightLen;					//中光灯组灯数量
	EM_LC_LIGHT_TYPE		anFarLight[LC_LIGHT_COUNT];			//远光灯组灯类型
	int						nFarLightLen;						//远光灯组灯数量
	BYTE					byReserved[128];				    // 保留字节
}NET_LIGHT_TYPE_COMPLEX_DETAIL;

//支持灯光联动的非智能事件
typedef enum tagEM_LC_SUPPORT_EVENTS
{
	EM_LC_SUPPORT_EVENTS_UNKNOWN,							//未知
	EM_LC_SUPPORT_EVENTS_MOTIONDETECT,						//动态检测
	EM_LC_SUPPORT_EVENTS_MASK,								//遮挡
	EM_LC_SUPPORT_EVENTS_ALARM,								//报警
	EM_LC_SUPPORT_EVENTS_ALL,								//所有事件
}EM_LC_SUPPORT_EVENTS;

#define MAX_SUPPORT_EVENT_NUM 10					//非智能事件数量
#define MAX_SUPPORT_INTELLISCENE_NUM 40				//智能事件数量

//支持灯光联动的能力集
typedef struct tagNET_LINKING_ABILITY
{
	EM_LC_SUPPORT_EVENTS		anSupportEvents[MAX_SUPPORT_EVENT_NUM];						//支持的非智能事件
	int							nSupportEventsLen;											//支持的非智能事件数量
	EM_SCENE_CLASS_TYPE			anSupportIntelliScence[MAX_SUPPORT_INTELLISCENE_NUM];		//支持的智能规则
	int							nSupportIntelliScenceLen;									//支持的智能规则数量
	BYTE						byReserved[128];				            				// 保留字节
}NET_LINKING_ABILITY;

#define LC_LIGHT_TYPE_NUM 3							//灯光类型数量

//灯光闪烁相关信息
typedef struct tagNET_FILCKER_LIGHTING
{
	BOOL				bSupported;							//是否支持灯光闪烁
	NET_LINKING_ABILITY	stuAbility;							//支持灯光联动能力集
	EM_LC_LIGHT_TYPE	anLightType[LC_LIGHT_TYPE_NUM];		//闪烁灯光类型
	int					nLightTypeLen;						//闪烁灯光数量
	int					anFilckerIntevalTime[2];			//闪烁间隔时间范围
	int					anFilckerTimes[2];					//闪烁可配置次数
	BYTE				byReserved[128];				    //保留字节
}NET_FILCKER_LIGHTING;

//灯光常亮信息
typedef struct tagNET_KEEP_LIGHTING
{
	BOOL				bSupported;							//是否支持灯光常亮
	NET_LINKING_ABILITY	stuAbility;							//支持灯光联动能力集
	EM_LC_LIGHT_TYPE	anLightType[LC_LIGHT_TYPE_NUM];		//常亮灯光类型
	int					nLightTypeLen;						//常亮灯光数量
	BYTE				byReserved[128];				    // 保留字节
}NET_KEEP_LIGHTING;

//云台联动灯光类型
typedef struct tagNET_LINKING_DETAIL
{
	NET_FILCKER_LIGHTING	stuFilckerLighting;			//闪烁灯光信息
	NET_KEEP_LIGHTING		stuKeepLighting;			//常亮灯光信息
	BYTE					byReserved[128];			// 保留字节
}NET_LINKING_DETAIL;

//灯光补偿信息
typedef struct tagNET_CORRECTION
{
	BOOL				bSupported;					//是否支持灯光补偿
	int					nRange;						//补偿范围最大值
	BYTE				byReserved[128];			// 保留字节	
}NET_CORRECTION;
//灯光灵敏度信息
typedef struct tagNET_SENSITIVITY
{
	BOOL				bSupported;					//是否支持灯光灵敏度
	int					nRange;						//灯光灵敏度最大值
	BYTE				byReserved[128];			// 保留字节
}NET_SENSITIVITY;

#define LC_POWER_NUM 3								//功率数量
#define LC_ANGLECONTROL_NUM 3						//激光角度数量
#define LC_LIGHT_MODE_NUM 20						//模式数量

//获取补光灯能力出参(对应:NET_LIGHTINGCONTROL_CAPS)
typedef struct tagNET_OUT_LIGHTINGCONTROL_CAPS
{
	DWORD							dwSize;										//结构体大小
	BOOL							bSupport;									//是否支持灯光控制
	EM_LC_CONFIG_VERSION			emConfigVersion;							//支持的灯光配置版本						
	EM_LC_LIGHT_TYPE				emLightType;								//灯光类型
	EM_LC_LIGHT_TYPE				anLightTypeComplex[LC_LIGHT_TYPE_NUM];		//复合灯光类型
	int								nLightTypeComplexLen;						//复合灯光类型数量
	int								nNearLightNumber;							//近光灯组数量
	int								nMiddleLightNumber;							//中光灯组数量
	int								nFarLightNumber;							//远光灯组数量
	EM_LC_MODE						emDefaultMode;								//默认支持的模式
	EM_LC_MODE						anModes[LC_LIGHT_MODE_NUM];					//支持的模式类型
	int								nModesLen;									//支持的模式数量
	NET_MODES_COMPLEX_LIGHT			stuModesComplex;							//复合灯模式信息
	NET_LIGHT_TYPE_COMPLEX_DETAIL	stuLightTypeComplexDetail;					//灯光组信息
	NET_LINKING_DETAIL				stuLinkingDetail;							//云台联动灯光信息
	int								anPower[LC_POWER_NUM];							//灯光组功率控制掩码
	int								anAngleControl[LC_ANGLECONTROL_NUM];			//灯光组激光角度控制掩码
	NET_CORRECTION					stuCorrection;								//灯光补偿信息
	NET_SENSITIVITY					stuSensitivity;								//灯光灵敏度信息
	BOOL							bSupportLaserLightMove;						//是否支持激光灯光轴调节
	int								nLightingTimeSectionNum;					//定时模式支持的时间段数量
	BOOL							bSupportByTime;								//是否支持分时配置
}NET_OUT_LIGHTINGCONTROL_CAPS;

// CLIENT_GetDevCaps接口 NET_COAXIAL_CONTROL_IO_STATUS 命令入参
typedef struct tagNET_IN_GET_COAXIAL_CONTROL_IO_STATUS
{
	DWORD							dwSize;							// 结构体大小
	UINT							nChannel;						// 通道号
} NET_IN_GET_COAXIAL_CONTROL_IO_STATUS;

//  同轴IO操作类型状态
typedef enum tagEM_COAXIAL_CONTROL_IO_STATUS
{
	EM_COAXIAL_CONTROL_IO_STATUS_UNKNOWN,							// 未知
	EM_COAXIAL_CONTROL_IO_STATUS_ON,								// 开
	EM_COAXIAL_CONTROL_IO_STATUS_OFF,								// 关闭
} EM_COAXIAL_CONTROL_IO_STATUS;

// CLIENT_GetDevCaps接口 NET_COAXIAL_CONTROL_IO_STATUS 命令出参
typedef struct tagNET_OUT_GET_COAXIAL_CONTROL_IO_STATUS
{
	DWORD							dwSize;							// 结构体大小
	EM_COAXIAL_CONTROL_IO_STATUS	emWhiteLight;					// 白光灯操作类型
	EM_COAXIAL_CONTROL_IO_STATUS	emSpeaker;						// 喇叭操作类型
} NET_OUT_GET_COAXIAL_CONTROL_IO_STATUS;


// CLIENT_GetDevCaps接口 NET_SUPPORT_GET_AUDIO_DECODE_CAPS 命令入参
typedef struct tagNET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS
{
	DWORD							dwSize;							// 结构体大小，赋值为 sizeof(NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS)
}NET_IN_SUPPORT_GET_AUDIO_DECODE_CAPS;

// CLIENT_GetDevCaps接口 NET_SUPPORT_GET_AUDIO_DECODE_CAPS 命令出参
typedef struct tagNET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS
{
	DWORD							dwSize;							// 结构体大小，赋值为 sizeof(NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS)
	BOOL							bSupport;						// 是否支持获取音频解码能力：TRUE表示支持，否则不支持
}NET_OUT_SUPPORT_GET_AUDIO_DECODE_CAPS;

// CLIENT_GetDevCaps接口 NET_UNIFIEDINFOCOLLECT_CAPS 命令入参 
typedef struct tagNET_IN_UNIFIEDINFOCOLLECT_CAPS
{
    DWORD                           dwSize;                         // 结构体大小
}NET_IN_UNIFIEDINFOCOLLECT_CAPS;

// CLIENT_GetDevCaps接口 NET_UNIFIEDINFOCOLLECT_CAPS命令出参
typedef struct tagNET_OUT_UNIFIEDINFOCOLLECT_CAPS
{
    DWORD                           dwSize;                         // 结构体大小
    BOOL                            bSupportUnifiedInfoCollect;     // 是否支持DMSS专有协议         
}NET_OUT_UNIFIEDINFOCOLLECT_CAPS;

// CLIENT_GetDevCaps 接口 NET_EXALARMBOX_CAPS 命令入参
typedef struct tagNET_IN_EXALARMBOX_CAPS
{
	DWORD							dwSize;							// 结构体大小
	int								nChannel;						// 通道
}NET_IN_EXALARMBOX_CAPS;

// CLIENT_GetDevCaps 接口 NET_EXALARMBOX_CAPS 命令出参
typedef struct tagNET_OUT_EXALARMBOX_CAPS
{
	DWORD							dwSize;							// 结构体大小
	int								nAlarmIn;						// 支持的报警输入路数
	int								nAlarmOut;						// 支持的报警输出路数
	int								nRemoteControl;					// 支持的遥控器路数
}NET_OUT_EXALARMBOX_CAPS;

// CLIENT_GetDevCaps 接口 NET_ALARMBOXMANAGER_CAPS 命令入参
typedef struct tagNET_IN_ALARMBOXMANAGER_CAPS
{
	DWORD							dwSize;							// 结构体大小
}NET_IN_ALARMBOXMANAGER_CAPS;


// CLIENT_GetDevCaps 接口 NET_ALARMBOXMANAGER_CAPS 命令出参
typedef struct tagNET_OUT_ALARMBOXMANAGER_CAPS
{
	DWORD							dwSize;							// 结构体大小
	int								nMaxBoxNumber;					// 最大支持几个盒子
	int								nMaxInputPerBox;				// 每个盒子支持最大报警输入个数
	int								nMaxOutputPerBox;				// 每个盒子支持最大报警输出个数
}NET_OUT_ALARMBOXMANAGER_CAPS;

// CLIENT_GetDevCaps接口 NET_GET_AUDIO_DETECT_CAPS命令入参
typedef struct tagNET_IN_GET_AUDIO_DETECT_CAPS 
{
    DWORD                           dwSize;                         // 结构体大小
    int                             nChannel;                       //通道号 
}NET_IN_GET_AUDIO_DETECT_CAPS;


// CLIENT_GetDevCaps接口 NET_GET_AUDIO_DETECT_CAPS命令出参
typedef struct tagNET_OUT_GET_AUDIO_DETECT_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
    BOOL                            bVolumeDetect;                                  // 是否支持音量检测
    BOOL                            bAnomalyDetect;                                 // 是否支持声音异常检测
    unsigned int                    nAnomalySensitiveRange[2];                      // 声音异常检测灵敏度范围数组,第一个元素为最小值,第二个元素为最大值
    BOOL                            bMutationDetect;                                // 是否支持声强突变检测
    unsigned int                    nMutationThresholdRange[2];                     // 声强突变检测门限范围数组,第一个元素为最小值,第二个元素为最大值
    BOOL                            bInfantCryDetect;                               // 是否支持婴儿啼哭检测
    BOOL                            bIntensityDetect;                               // 是否支持音频强度检测
    unsigned int                    nIntensityDecibelGateRange[2];                  // 音频强度检测分贝阈值数组, 单位分贝;第一个元素为最小值,第二个元素为最大值
}NET_OUT_GET_AUDIO_DETECT_CAPS;  

// CLIENT_GetDevCaps接口 NET_VIDEO_IN_DEFOG_CAPS命令入参
typedef struct tagNET_IN_VIDEO_IN_DEFOG_CAPS
{
    DWORD                      dwSize;          // 结构体大小
    int                        nChannel;        // 通道号
}NET_IN_VIDEO_IN_DEFOG_CAPS;

//  大气光模式能力
typedef struct tagNET_LIGHT_INTENSITY_CAPS
{   
    BOOL            bSupportLightMode;  // 是否支持大气光模式能力
    BYTE            byReserved[68];     // 保留字节
}NET_LIGHT_INTENSITY_CAPS;

// 透雾模式
typedef enum tagEM_IN_DEFOG_MODE
{
    EM_IN_DEFOG_MODE_UNKNOWN,          // 未知
    EM_IN_DEFOG_MODE_OFF,              // 关闭
    EM_IN_DEFOG_MODE_MANUAL,           // 手动
    EM_IN_DEFOG_MODE_AUTO,             // 自动
} EM_IN_DEFOG_MODE;

// CLIENT_GetDevCaps接口 NET_VIDEO_IN_DEFOG_CAPS命令处参
typedef struct tagNET_OUT_VIDEO_IN_DEFOG_CAPS
{
    DWORD                       dwSize;             // 结构体大小
    BOOL                        bSupportInDefog;    // 是否支持透雾设置能力
    BOOL                        bSupportCamDefog;   // 是否支持光学物理透雾
    UINT                        nModeCount;         // 透雾模式的个数    
    EM_IN_DEFOG_MODE            emMode[8];          // 透雾模式
    NET_LIGHT_INTENSITY_CAPS    stuLightIntensity;  // 大气光模式能力
}NET_OUT_VIDEO_IN_DEFOG_CAPS;

// CLIENT_GetDevCaps接口 NET_SUPPORT_FACE_LIB_DOWNLOAD命令入参
typedef struct tagNET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
} NET_IN_SUPPORT_FACEDB_DOWNLOAD_CAPS;

// CLIENT_GetDevCaps接口 NET_SUPPORT_FACE_LIB_DOWNLOAD命令出参
typedef struct tagNET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
    BOOL                            bSupportFaceDbDownload;                         // 是否支持远程人脸库下载
} NET_OUT_SUPPORT_FACEDB_DOWNLOAD_CAPS;


// CLIENT_GetDevCaps 接口 NET_DIAGNOSIS_CAPS 命令入参
typedef struct tagNET_IN_DIAGNOSIS_CAPS
{
	DWORD							dwSize;									// 结构体大小
}NET_IN_DIAGNOSIS_CAPS;


// CLIENT_GetDevCaps 接口 NET_DIAGNOSIS_CAPS 命令出参
typedef struct tagNET_OUT_DIAGNOSIS_CAPS
{
	DWORD							dwSize;									// 结构体大小
	BOOL							bSupportReport;							// 是否支持故障码主动上报
	BOOL							bSupportDelInfo;						// 是否支持删除指定故障码
	BOOL							bSupportDelAllInfo;						// 是否支持删除所有故障码
}NET_OUT_DIAGNOSIS_CAPS;


// 智能锁能力集
typedef struct tagNET_SMARTLOCKER_CAPS
{
	UINT							nMaxFpAmount;									// 最大支持的指纹数量
	UINT							nMaxPwdAmount;									// 最大支持的密码数量
	UINT							nMaxCardAmount;									// 最大支持的卡号数量
	BYTE							byReserved[132];								// 预留字段
}NET_SMARTLOCKER_CAPS;

// LowRateWPAN 类型
typedef enum tagEM_LOWRATEWPAN_CAPS_TYPE
{
	EM_LOWRATEWPAN_CAPS_TYPE_UNKNOWN = -1,											// 未知
	EM_LOWRATEWPAN_CAPS_TYPE_SMARTLOCKER,											// 智能锁
}EM_LOWRATEWPAN_CAPS_TYPE;

// CLIENT_GetDevCaps接口 NET_LOWRATEWPAN_CAPS 命令入参
typedef struct tagNET_IN_LOWRATEWPAN_CAPS
{
	DWORD							dwSize;											// 结构体大小
	int								nChannelID;										// 通道号(当前未用到)
	EM_LOWRATEWPAN_CAPS_TYPE		emType;											// 类型
	char							szModuleSNList[16][32];							// 模块列表
}NET_IN_LOWRATEWPAN_CAPS;

// CLIENT_GetDevCaps接口 NET_LOWRATEWPAN_CAPS 命令出参
typedef struct tagNET_OUT_LOWRATEWPAN_CAPS
{
	DWORD							dwSize;											// 结构体大小
	NET_SMARTLOCKER_CAPS			stuSmartLockerCaps[16];							// 智能锁能力集
	UINT							nSmartLockerCapsRet;							// 返回的 stuSmartLockerCaps 个数
}NET_OUT_LOWRATEWPAN_CAPS;


// CLIENT_StopAdjustingAngle 入参
typedef struct tagNET_IN_STOP_ADJUSTING_ANGLE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nChannel;                                       // 通道号 
}NET_IN_STOP_ADJUSTING_ANGLE;

// CLIENT_StopAdjustingAngle 出参
typedef struct tagNET_OUT_STOP_ADJUSTING_ANGLE
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_OUT_STOP_ADJUSTING_ANGLE;

// 镜头停止调整角度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopAdjustingAngle(LLONG lLoginID, const NET_IN_STOP_ADJUSTING_ANGLE *pstInParam, NET_OUT_STOP_ADJUSTING_ANGLE *pstOutParam, int nWaitTime);

// 运动方向
typedef enum tagEM_ADJUST_ANGLE_DIRECTION
{
    EM_ADJUST_ANGLE_DIRECTION_UNKNOWN,                                  // 未知
    EM_ADJUST_ANGLE_DIRECTION_NEGATIVE_X,                               // 负X轴方向
    EM_ADJUST_ANGLE_DIRECTION_POSITIVE_X,                               // 正X轴方向
    EM_ADJUST_ANGLE_DIRECTION_NEGATIVE_Y,                               // 负Y轴方向
    EM_ADJUST_ANGLE_DIRECTION_POSITIVE_Y,                               // 正Y轴方向
} EM_ADJUST_ANGLE_DIRECTION;

// CLIENT_AdjustingAngleContinuously 入参
typedef struct tagNET_IN_ADJUST_ANGLE_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nChannel;                                       // 通道号 
    EM_ADJUST_ANGLE_DIRECTION       emDirection;                                    // 运动方向
    UINT                            nVelocity;                                      // 速度
}NET_IN_ADJUST_ANGLE_CONTINUOUSLY;

//CLIENT_AdjustingAngleContinuously 出参
typedef struct tagNET_OUT_ADJUST_ANGLE_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_OUT_ADJUST_ANGLE_CONTINUOUSLY;

// 镜头连续方式调整位置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustingAngleContinuously(LLONG lLoginID, const NET_IN_ADJUST_ANGLE_CONTINUOUSLY *pstInParam, NET_OUT_ADJUST_ANGLE_CONTINUOUSLY *pstOutParam, int nWaitTime);

// CLIENT_GetDevCaps接口 NET_GET_LENS_FUNC_CAPS 命令入参
typedef struct tagNET_IN_GET_LENS_FUNC_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nChannel;                                       // 通道号 
}NET_IN_GET_LENS_FUNC_CAPS;

// 是否支持角度调整
typedef enum tagEM_SUPPORT_ANGLE_ADJUST
{
    EM_SUPPORT_ANGLE_ADJUST_UNKNOWN,                          // 未知
    EM_SUPPORT_ANGLE_ADJUST_NO,                               // 不支持
    EM_SUPPORT_ANGLE_ADJUST_X,                                // 只支持水平方向
    EM_SUPPORT_ANGLE_ADJUST_Y,                                // 只支持竖直方向
    EM_SUPPORT_ANGLE_ADJUST_XY,                               // 同时支持水平及竖直方向
} EM_SUPPORT_ANGLE_ADJUST;

// CLIENT_GetDevCaps接口 NET_GET_LENS_FUNC_CAPS 命令出参
typedef struct tagNET_OUT_GET_LENS_FUNC_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
    UINT                            nDepthField;                                    // 是否支持景深调节; 0-不支持，1-支持
    EM_SUPPORT_ANGLE_ADJUST         emSupportAngleAdjust;                           // 是否支持角度调整
    UINT                            nMaxVelocity;                                   // 最大角度调整速度, 表示速度调整范围1~8         
}NET_OUT_GET_LENS_FUNC_CAPS;

//CLIENT_AdjustDepthField 入参
typedef struct tagNET_IN_ADJUST_DEPTH_FIELD
{
    DWORD                           dwSize;                                         // 结构体大小
    UINT                            nChannel;                                       // 通道号 
    float                           fDepthField;                                    // 景深相对位置，归一化到0-1
}NET_IN_ADJUST_DEPTH_FIELD;

// CLIENT_AdjustDepthField 出参
typedef struct tagNET_OUT_ADJUST_DEPTH_FIELD
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_OUT_ADJUST_DEPTH_FIELD;

// CLIENT_AdjustDepthFieldContinuously 入参
typedef struct tagNET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // 结构体大小
    UINT                            nChannel;                                       // 通道号 
    float                           fDepthFieldSpeed;                               // 相对景深变化速率,归一化到-1~1，0表示停止。正负表示方向, 数字越大速度越快。
}NET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY;

// CLIENT_AdjustDepthFieldContinuously 出参
typedef struct tagNET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY;

// CLIENT_GetDepthFieldStatus 入参
typedef struct tagNET_IN_GET_DEPTH_FIELD_STATUS
{
    DWORD                           dwSize;                                         // 结构体大小
    UINT                            nChannel;                                       // 通道号 
}NET_IN_GET_DEPTH_FIELD_STATUS;

// 景深调节状态
typedef enum tagEM_DEPTH_FIELD_STATUS
{
    EM_DEPTH_FIELD_STATUS_UNKNOWN,                                                  // 未知
    EM_DEPTH_FIELD_STATUS_NORMAL,                                                   // 正常状态
    EM_DEPTH_FIELD_STATUS_AUTODEPTHFIELD,                                           // 正在调节景深
}EM_DEPTH_FIELD_STATUS;

// CLIENT_GetDepthFieldStatus 出参
typedef struct tagNET_OUT_GET_DEPTH_FIELD_STATUS
{
    DWORD                            dwSize;                                        // 结构体大小
    float                            fDepthField;                                   // 景深相对位置，归一化到0-1
    UINT                             nTotalDepthFieldSteps;                         // 总步长
    EM_DEPTH_FIELD_STATUS            emStatus;                                      // 景深调节状态
}NET_OUT_GET_DEPTH_FIELD_STATUS;

// CLIENT_AutoAdjustDepthField 入参
typedef struct tagNET_IN_AUTO_ADJUST_DEPTH_FIELD
{
    DWORD                            dwSize;                                        // 结构体大小
    UINT                             nChannel;                                      // 通道号 
}NET_IN_AUTO_ADJUST_DEPTH_FIELD;

// CLIENT_AutoAdjustDepthField 出参
typedef struct tagNET_OUT_AUTO_ADJUST_DEPTH_FIELD
{
    DWORD                            dwSize;                                        // 结构体大小
}NET_OUT_AUTO_ADJUST_DEPTH_FIELD;

// 镜头调节景深
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustDepthField(LLONG lLoginID, const NET_IN_ADJUST_DEPTH_FIELD *pstInParam, NET_OUT_ADJUST_DEPTH_FIELD *pstOutParam, int nWaitTime);

// 镜头连续调节景深
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustDepthFieldContinuously(LLONG lLoginID, const NET_IN_ADJUST_DEPTH_FIELD_CONTINUOUSLY *pstInParam, NET_OUT_ADJUST_DEPTH_FIELD_CONTINUOUSLY *pstOutParam, int nWaitTime);

// 获取镜头景深状态信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDepthFieldStatus(LLONG lLoginID, const NET_IN_GET_DEPTH_FIELD_STATUS *pstInParam, NET_OUT_GET_DEPTH_FIELD_STATUS *pstOutParam, int nWaitTime);

// 调节镜头景深至最佳位置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AutoAdjustDepthField(LLONG lLoginID, const NET_IN_AUTO_ADJUST_DEPTH_FIELD *pstInParam, NET_OUT_AUTO_ADJUST_DEPTH_FIELD *pstOutParam, int nWaitTime);

//CLIENT_GetDevCaps 对应的类型(NET_GET_FILE_TRANSFER_CAPS)入参
typedef struct tagNET_IN_GET_FILE_TRANSFER_CAPS
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_IN_GET_FILE_TRANSFER_CAPS;

// CLIENT_GetDevCaps 对应的类型(NET_GET_FILE_TRANSFER_CAPS)出参
typedef struct tagNET_OUT_GET_FILE_TRANSFER_CAPS
{
    DWORD                           dwSize;                                        // 结构体大小
    BOOL                            bSupportFaceDbDownload;                        // 是否支持远程人脸库下载
    BOOL                            bSupportPlateNumberDbDownload;                 // 是否支持远程车牌库下载
    BYTE                            byReserved[4];                                 // 字节对齐 
}NET_OUT_GET_FILE_TRANSFER_CAPS;

//门锁控制模式
typedef enum tagNET_DOORWORK_MODE
{
    NET_DOORWORK_MODE_UNKNOWN = 0,                                // 未知
    NET_DOORWORK_MODE_NORMAL = 1,                                 // 正常模式
    NET_DOORWORK_MODE_SHUTLOCK = 2,                               // 闭锁
    NET_DOORWORK_MODE_UNUSED = 3,                                 // 停用
    NET_DOORWORK_MODE_OPENDOORCONTINUE = 4,                       // 持续打开
} NET_DOORWORK_MODE;

// 获取门锁控制模式，对应命令DH_DEVSTATE_GET_ACCESSCONTROLMODE
typedef struct tagNET_GET_DOORWORK_MODE
{
    DWORD                    dwSize;
    int                      nChannel;              // 门禁通道号
    NET_DOORWORK_MODE   emControlMode;              // 门锁控制模式      
}NET_GET_DOORWORK_MODE;

// VT事件类型
typedef enum tagEM_AUDIO_CB_FLAG
{
    EM_AUDIO_CB_FLAG_UNKNOWN,
    EM_AUDIO_CB_FLAG_NEWCALL,                   // 有呼叫进来
    EM_AUDIO_CB_FLAG_REMOTE_HANGUP,             // 对方挂断
    EM_AUDIO_CB_FLAG_DISCONNECT,                // 断线
    EM_AUDIO_CB_FLAG_RING,                      // 对端响铃
} EM_AUDIO_CB_FLAG;

// VT回调函数
typedef int (CALLBACK *pfVtEventCallBack)(LLONG instId, LLONG ulRegisterId, LLONG ulSessionId, int nEvent, char *pDataBuf, DWORD dwBufSize, LDWORD dwUser);

// 呼叫事件处理动作EM_AUDIO_CB_FLAG_NEWCALL
typedef enum tagEM_NEWCALL_ACTION
{
    EM_NEWCALL_ACTION_UNKNOWN,                  // 无操作
    EM_NEWCALL_ACTION_REFUSE,                   // 拒接
    EM_NEWCALL_ACTION_ACCEPT,                   // 接入
} EM_NEWCALL_ACTION;

typedef enum tagEM_VT_PARAM_VALID
{
    EM_VT_PARAM_VALID_EVENT_CB     = 0x0001,
    EM_VT_PARAM_VALID_USER_DATA    = 0x0002,
    EM_VT_PARAM_VALID_MID_NUM      = 0x0004,
    EM_VT_PARAM_VALID_ACTION       = 0x0008,
    EM_VT_PARAM_VALID_WAITTIME     = 0x0010,
    EM_VT_PARAM_VALID_VIDEOWND     = 0x0020,
    EM_VT_PARAM_VALID_CSMODE       = 0x0040,
    EM_VT_PARAM_VALID_AUDIO_ENCODE = 0x0080,
    EM_VT_PARAM_VALID_LOCAL_IP     = 0x0100,
} EM_VT_PARAM_VALID;

// VT对讲参数
typedef struct tagNET_VT_TALK_PARAM
{
    DWORD               dwSize;                  // 结构体大小
    int                 nValidFlag;              // 按位标识后面的字段是否有效, EM_VT_PARAM_VALID的组合
    pfVtEventCallBack   pfEventCb;               // 事件回调函数, EM_VT_PARAM_VALID_EVENT_CB
    LDWORD              dwUser;                  // 事件回调函数自定义数据, EM_VT_PARAM_VALID_USER_DATA
    char                szPeerMidNum[16];        // 被叫中号, 8位, EM_VT_PARAM_VALID_MID_NUM
    EM_NEWCALL_ACTION   emAction;                // 对呼叫的操作, 0:无操作, 1:拒接, 2:接入, EM_VT_PARAM_VALID_ACTION
    int                 nWaitTime;               // 超时时间, 单位ms, EM_VT_PARAM_VALID_WAITTIME
    HWND                hVideoWnd;               // 可视对讲视频显示窗口, EM_VT_PARAM_VALID_VIDEOWND
    BOOL                bClient;                 // 客户端/服务器模式, TRUE:客户端, FALSE:服务器, EM_VT_PARAM_VALID_CSMODE
    DHDEV_TALKDECODE_INFO stAudioEncode;         // 语音编码信息, EM_VT_PARAM_VALID_AUDIO_ENCODE
} NET_VT_TALK_PARAM;

// VTC登录VTO
CLIENT_NET_API LLONG CALL_METHOD CLIENT_VT_RegisterVto(const char *pszIp, int nPort = 13801);

// VTC登出VTO
CLIENT_NET_API BOOL CALL_METHOD CLIENT_VT_UnRegisterVto(LLONG ulLongId);

/////////////////////////////////// 无人机接口 ///////////////////////////////////////

// 无人机飞行信息结构
typedef struct tagNET_UAV_FLY_INFO 
{
    float               fAltitude;                          // 垂直高度,相对于水平面	单位：米
    float               fDistance;                          // 水平距离,相对于遥控器	单位：米
    float               fHorizontalSpeed;                   // 水平速度,飞行器在水平方向的飞行速度	单位：米/秒
    float               fVerticalSpeed;                     // 垂直速度,飞行器在垂直方向的飞行速度	单位：米/秒
    int                 nRCLinkQuality;                     // 遥控器链路信号质量 范围：0~100
    char                reserved[512];
} NET_UAV_FLY_INFO;

// 无人机飞行信息回调函数原形,lAttachHandle 是 CLIENT_AttachUavFly 返回值
typedef void (CALLBACK *fUavFlyCallBack) (LLONG lAttachHandle, NET_UAV_FLY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachUavFly 入参
typedef struct tagNET_IN_ATTACH_UAV_FLY 
{
    DWORD               dwSize;
    fUavFlyCallBack     cbUavFly;                           // 飞行信息回调函数
    DWORD               dwUser;                             // 用户数据                   
} NET_IN_ATTACH_UAV_FLY;

// CLIENT_AttachUavFly 出参
typedef struct tagNET_OUT_ATTACH_UAV_FLY 
{
    DWORD                dwSize;
} NET_OUT_ATTACH_UAV_FLY;

// 订阅无人机飞行信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachUavFly(LLONG lLoginID, const NET_IN_ATTACH_UAV_FLY* pInParam, NET_OUT_ATTACH_UAV_FLY* pOutParam, int nWaitTime);

// 取消订阅无人机飞行信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachUavFly(LLONG lAttachHandle);

////////////////////////////////////////////////////////////////////////////////

// 获取设备自检信息,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSelfCheckInfo(LLONG lLoginID, const NET_IN_GET_SELTCHECK_INFO* pInParam, NET_SELFCHECK_INFO* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

/////////////////////////////////激光器与电子稳像器接口/////////////////////////////////

// 打开或关闭激光器入参
typedef struct tagLASER_IN_INFO
{
	DWORD		dwSize;				// 结构体大小
	UINT		nChannelID;			// 通道号
} LASER_IN_INFO;

// 打开或关闭激光器出参
typedef struct tagLaser_OUT_INFO 
{
	DWORD		dwSize;			// 结构体大小
} LASER_OUT_INFO;

//打开或关闭电子稳像器入参
typedef struct tagEIS_IN_INFO 
{
	DWORD		dwSize;				// 结构体大小
	UINT		nChannelID;			// 通道号
} EIS_IN_INFO;

//打开关闭电子稳像器接口出参
typedef struct tagEIS_OUT_INFO 
{
	DWORD		dwSize;			// 结构体大小
} EIS_OUT_INFO;


//打开激光器,pLaserDataIn与pLaserDataOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

//关闭激光器,pLaserDataIn与pLaserDataOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopLaser(LLONG lLoginID,const LASER_IN_INFO* pLaserDataIn, LASER_OUT_INFO* pLaserDataOut,int nWaitTime = 1000);

//打开电子稳像器,pEISDataIn与pEISDataOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);

//关闭电子稳像器,pEISDataIn与pEISDataOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopEIS(LLONG lLoginID,const EIS_IN_INFO* pEISDataIn, EIS_OUT_INFO* pEISDataOut,int nWaitTime = 1000);

// 手动测试PSTN连接状态,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ManualCheckPSTN(LLONG lLoginID, const NET_IN_PSTN_MANUALCHECK_STATE* pInBuf, NET_OUT_PSTN_MANUALCHECK_STATE* pOutBuf, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

#define  MAX_NUM_EX_MODULE          16              // 扩展模块最大数量
#define  MAX_NUM_ADDR_IN_BUS        256             // 总线上的地址号的最大数量

// 获取扩展模块使用情况入参
typedef struct tagNET_IN_EXMODULE_INFO 
{
    DWORD		dwSize;				                                        // 结构体大小
} NET_IN_EXMODULE_INFO;

// 单个扩展模块使用情况
typedef struct tagNET_OUT_EXMODULE_INFO
{
    NET_BUS_TYPE		emBusType;                                          // 总线类型
    int                 nChannelID;	                                        // 总线号
    int                 nAddrCount;                                         // 有效的地址号个数
    int                 nAddr[MAX_NUM_ADDR_IN_BUS];                         // 总线上的地址号
    char                reserved[1024];                                     // 保留字节
} NET_OUT_EXMODULE_INFO;

// 获取扩展模块使用情况接口出参
typedef struct tagNET_OUT_EXMODULE_INFO_ALL
{
    DWORD		                dwSize;			                            // 结构体大小
    int                         nExModuleCount;                             // 总线数量
    NET_OUT_EXMODULE_INFO       stuExModuleInfo[MAX_NUM_EX_MODULE];         // 扩展模块使用情况数组
} NET_OUT_EXMODULE_INFO_ALL;

/**************************************************************************************
*   Funcname: CLIENT_GetExModuleState
*   Purpose:获取扩展模块使用情况
*   InputParam:   LLONG                        :lLoginID        //登陆句柄
*   InputParam:   NET_IN_EXMODULE_INFO*        :pInParam        //传入参数,必填,不能为NULL,需设置dwSize,由用户申请释放内存
*   InputParam:   NET_OUT_EXMODULE_INFO_ALL*   :pOutParam       //传出参数,必填,不能为NULL,需设置dwSize,由用户申请释放内存
*   InputParam:   int                          :nWaitTime       //超时时间
*   Return: BOOL
*   *该接口已废弃，请使用CLINET_GetExModuleInfo接口*
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetExModuleState(LLONG lLoginID, const NET_IN_EXMODULE_INFO* pInParam, NET_OUT_EXMODULE_INFO_ALL* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

///////////////////////////////主从设备组操作接口//////////////////////////

#define MASTERSALVE_CLASS_LEN           16

typedef struct tagNET_IN_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;                              // 结构体大
    int                    nGroupID;                            // 设备组号
    int                    nSlaveID;                            // 从机序号 
	int				       nMasterID;							// 对应主从组的主机序号, 例如三枪一球，则nMasterID取值0、1和2
	int					   nChannel;							// 本地通道号，对应本地视频通道号，从0开始。（老设备及前端设备不支持多通道，设置为0）
}NET_IN_MSGROUP_OPEN_INFO;

typedef struct tagNET_OUT_MSGROUP_OPEN_INFO
{
    DWORD                  dwSize;                              // 结构体大小
    DWORD                  dwToken;                             // 主从跟踪组句柄
}NET_OUT_MSGROUP_OPEN_INFO;

typedef struct tagNET_IN_MSGROUP_LOCATE_INFO
{
    DWORD                   dwSize;                             // 结构体大小
    DWORD                   dwToken;                            // 主从跟踪组句柄
    DH_POINT                stuPoint;                           // 主机坐标
    short                   snMasterInfo[3];                    // 鱼眼圆心坐标与半径, 依次为[横坐标, 纵坐标, 半径]
}NET_IN_MSGROUP_LOCATE_INFO;

typedef struct tagNET_OUT_MSGROUP_LOCATE_INTO
{
    DWORD                   dwSize;                             // 结构体大小
    short                   snPTZ[3];                           // 联动到球机上的绝对坐标
}NET_OUT_MSGROUP_LOCATE_INTO;

typedef struct tagNET_IN_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;                             // 结构体大小
    DWORD                   dwToken;                            // 主从跟踪组句柄
    char                    szClass[MASTERSALVE_CLASS_LEN];     // 算法方案类型
    DWORD                   dwObjectID;                         // 算法目标ID
}NET_IN_MSGROUP_TRACK_INFO;

typedef struct tagNET_OUT_MSGROUP_TRACK_INFO
{
    DWORD                   dwSize;                             // 结构体大小
}NET_OUT_MSGROUP_TRACK_INFO;

typedef struct tagNET_IN_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;                             // 结构体大小
    DWORD                   dwToken;                            // 主从跟踪组句柄
}NET_IN_MSGROUP_CLOSE_INFO;

typedef struct tagNET_OUT_MSGROUP_CLOSE_INFO
{
    DWORD                   dwSize;                             // 结构体大小
}NET_OUT_MSGROUP_CLOSE_INFO;

// 主动跟踪主操作命令 EM_MSGROUP_OPERATE_RECTLOCATE 入参
typedef struct tagNET_IN_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                             // 结构体大小
    DWORD                   dwToken;                            // 主从跟踪组句柄, 从 EM_MSGROUP_OPERATE_OPEN 操作获取
    NET_RECT                stuRect;                            // 选定的矩形框坐标
    int                     nRectDirection;                     // 框选的方向, 0-从左上到右下, 表示放大; 1-从右下到左上，表示缩小
}NET_IN_MSGROUP_RECTLOCATE_INFO;

// 主动跟踪主操作命令, EM_MSGROUP_OPERATE_RECTLOCATE 出参
typedef struct tagNET_OUT_MSGROUP_RECTLOCATE_INFO
{
    DWORD                   dwSize;                             // 结构体大小
    int                     nPTZ[3];                            // 联动到球机上的绝对坐标
}NET_OUT_MSGROUP_RECTLOCATE_INFO;

// 跟踪报警信息
typedef struct tagNET_MSGROUP_NOTIFY_INFO 
{
    DWORD                    dwSubscribeID;                     // 服务端订阅ID
    int                      nSlaveID;                          // 跟踪组中从机序号
    char                     szClass[MASTERSALVE_CLASS_LEN];    // 算法方案类型
    DWORD                    dwObjectID;                        // 算法目标ID
    NET_RECT                 stuBoundingBox;                    // 跟踪物体包围盒
    BYTE                     byReserved[512];                   // 保留字节 
}NET_MSGROUP_NOTIFY_INFO;

// 自动跟踪回调函数, lAttachHandle 为 CLIENT_AttachMasterSlaveGroup 返回的结果
typedef void (CALLBACK *fMasterSlaveCallBack)(LLONG lAttachHandle, NET_MSGROUP_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachMasterSlaveGroup 入参
typedef struct tagNET_IN_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
    fMasterSlaveCallBack     cbNotify;                          // 回调函数
    LDWORD                   dwUser;                            // 用户信息
	int                      nGroupID;                          // 设备组号
	int					     nChannel;							// 本地通道号，对应本地视频通道号，从0开始。（老设备及前端设备不支持多通道，设置为0）
}NET_IN_MSGROUP_ATTACH_INFO;

// CLIENT_AttachMasterSlaveGroup 出参
typedef struct tagNET_OUT_MSGROUP_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
}NET_OUT_MSGROUP_ATTACH_INFO;

// 主动跟踪主操作命令, 接口 CLIENT_OperateMasterSlaveGroup
typedef enum tagEM_MSGROUP_OPERATE_TYPE
{
    EM_MSGROUP_OPERATE_OPEN,                                    // 打开主从跟踪组, 对应 NET_IN_MSGROUP_OPEN_INFO 和 NET_OUT_MSGROUP_OPEN_INFO
    EM_MSGROUP_OPERATE_LOCATE,                                  // 联动主从跟踪组, 对应 NET_IN_MSGROUP_LOCATE_INFO 和 NET_OUT_MSGROUP_LOCATE_INTO
    EM_MSGROUP_OPERATE_TRACK,                                   // 手动选定目标跟踪, 对应 NET_IN_MSGROUP_TRACK_INFO 和 NET_OUT_MSGROUP_TRACK_INFO
    EM_MSGROUP_OPERATE_CLOSE,                                   // 关闭主从式跟踪器实例, 对应 NET_IN_MSGROUP_CLOSE_INFO 和 NET_OUT_MSGROUP_CLOSE_INFO
    EM_MSGROUP_OPERATE_RECTLOCATE,                              // 从主设备选择矩形框联动从设备, 对应 NET_IN_MSGROUP_RECTLOCATE_INFO 和 NET_OUT_MSGROUP_RECTLOCATE_INFO
}EM_MSGROUP_OPERATE_TYPE;

// 主从联动组, 操作接口,pInParam与pOutParam内存由用户申请释放,大小参照emOperateType对应的结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateMasterSlaveGroup(LLONG lLoginID, EM_MSGROUP_OPERATE_TYPE emOperateType, void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 订阅自动跟踪目标 ,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMasterSlaveGroup(LLONG lLoginID, const NET_IN_MSGROUP_ATTACH_INFO *pInParam, NET_OUT_MSGROUP_ATTACH_INFO *pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 退订自动跟踪目标
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMasterSlaveGroup(LLONG lAttachHandle);
//////////////////////////////////////////////////////////////////////////

#define     MAX_TRAFFIC_LANE_NUM            16                  // 最大车道个数
#define     MAX_CAMERA_PERIPHERAL_NUM       8                   // 照相机外设最大个数
#define     MAX_STORAGE_NUM                 8                   // 存储设备最大个数
#define     MAX_PARTITION_NUM               8                   // 最大分区个数

// 存储设备分区信息
typedef struct tagNET_PARTITION_INFO
{
    double                      dbTotalBytes;                   // 分区总空间
    double                      dbUsedBytes;                    // 分区使用的空间
    BOOL                        bError;                         // 是否异常
    BYTE                        byReserved[64];                 // 保留字段
}NET_PARTITION_INFO;

// 存储设备工作状态
typedef enum tagENUM_STORAGE_STATE
{
    ENUM_STORAGE_STATE_UNKONWN,                                 // 未知状态
    ENUM_STORGAE_STATE_READ_ERROR,                              // 设备读取失败
    ENUM_STORAGE_STATE_INITIALIZING,                            // 正在读取设备
    ENUM_STORAGE_STATE_READ_SUCCESS,                            // 设备读取成功
}ENUM_STORAGE_STATE;

// 存储设备信息
typedef struct tagNET_STORAGE_INFO
{
    ENUM_STORAGE_STATE       emState;                           // 存储设备状态
    int                      nPartitonNum;                      // 分区个数
    NET_PARTITION_INFO       stuPartions[MAX_PARTITION_NUM];    // 分区信息
    BYTE                     byReserved[128];                   // 保留字段
}NET_STORAGE_INFO;

// 网络资源
typedef struct tagNET_RESOURCE_STATE
{
	int						nIPChanneIn;					// IP通道接入速度, 单位: kbps
	int						nNetRemain;						// 网络接收剩余能力, 单位: kbps
	int						nNetCapability;					// 网络接收总能力, 单位: kbps
	int						nRemotePreview;					// 远程预览能力, 单位: kbps
	int						nRmtPlayDownload;				// 远程回放及下载能力, 单位: kbps
	int						nRemoteSendRemain;				// 远程发送剩余能力, 单位: kbps
	int						nRemoteSendCapability;			// 远程发送总能力, 单位: kbps
	BYTE                    byReserved[32];                 // 保留字节
} NET_RESOURCE_STATE;

// 设备工作状态
typedef struct tagNET_WORKSTATE
{
    BOOL                     bOnline;                           // 设备是否在线
    char                     szFirmwareVersion[DH_COMMON_STRING_128];  // 固件版本号
    float                    fTemperature;                      // 温度值, 单位摄氏度
    float                    fPowerDissipation;                 // 功耗, 单位W
    int                      nUtilizationOfCPU;                 // CPU 使用率
    
    int                      nStorageNum;                       // 存储设备个数
    NET_STORAGE_INFO         stuStorages[MAX_STORAGE_NUM];      // 存储设备信息
    int					 	 nUpTimeLast;						// 上次上电时间, 单位: 秒
    int					 	 nUpTimeTotal;						// 总共上电时间, 单位: 秒
    double					 dbMemInfoTotal;					// 总内存大小, 单位: 字节
    double					 dbMemInfoFree;						// 剩余内存大小, 单位: 字节
    BYTE					 byReserved1[4];					// 字节对齐，非保留字节
    char					 szDevType[32];						// 设备型号
    NET_RESOURCE_STATE		 stuResourceStat;					// 网络资源
    BYTE                     byReserved[8];                     // 保留字节
}NET_WORKSTATE;

// 查询盒子工作状态, 对应命令 DH_DEVSTATE_GET_WORK_STATE
typedef struct tagNET_QUERY_WORK_STATE
{
    DWORD                    dwSize;                            // 保留字段
    NET_WORKSTATE            stuWorkState;                      // 运行状态
}NET_QUERY_WORK_STATE;

// 查询防护舱门锁状态入参,对应接口 CLIENT_GetCapsuleLockState
typedef struct tagNET_IN_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                       dwSize;                         // 结构体大小
    int                         nChannel;                       // 通道号
}NET_IN_QUERY_CAPSULE_LOCKSTATE;

// 在线状态
typedef enum tagNET_EM_ONLINESTATE
{
	NET_EM_ONLINESTATE_UNKNOWN,									 // 未知
    NET_EM_ONLINESTATE_ONLINE,                                   // 在线
    NET_EM_ONLINESTATE_OFFLINE,                                  // 离线
}NET_EM_ONLINESTATE;

// 门锁状态
typedef enum  tagNET_EM_LOCKSTATE
{
    NET_EM_LOCKSTATE_UNKNOWN,                                   // 未知
    NET_EM_LOCKSTATE_Open,                                      // 打开
    NET_EM_LOCKSTATE_CLOSE,                                     // 关闭
    NET_EM_LOCKSTATE_ABNORMAL,                                  // 异常
    NET_EM_LOCKSTATE_FAKELOCKED,                                // 假锁
}NET_EM_LOCKSTATE;

// 查询防护舱门锁状态出参，对应接口 CLIENT_GetCapsuleLockState
typedef struct tagNET_OUT_QUERY_CAPSULE_LOCKSTATE
{
    DWORD                       dwSize;                         // 结构体大小
    NET_EM_LOCKSTATE            emLockState;                    // 门锁状态    
    NET_EM_ONLINESTATE			emOnLineState;					// 在线状态
}NET_OUT_QUERY_CAPSULE_LOCKSTATE;

// 获取防护舱内人数入参
typedef struct tagNET_IN_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // 结构体大小
    int                         nChannel;                       // 通道号
}NET_IN_QUERY_CAPSULE_HUMANNUM;

// 获取防护舱内人数出参
typedef struct tagNET_OUT_QUERY_CAPSULE_HUMANNUM
{
    DWORD                       dwSize;                         // 结构体大小
    UINT                        nHumanNum;                      // 人数
}NET_OUT_QUERY_CAPSULE_HUMANNUM;

// 录像模式
typedef enum tagNET_EM_RECORD_MODE
{
    NET_EM_RECORD_MODE_UNKNOWN,                                 // 未知
    NET_EM_RECORD_MODE_COURSE,                                  // 课程录像模式
    NET_EM_RECORD_MODE_NORMAL,                                  // 普通模式
}NET_EM_RECORD_MODE;

// 设置录像模式入参，对应接口CLIENT_SetCourseRecordMode
typedef struct tagNET_IN_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
    NET_EM_RECORD_MODE          emRecordMode;                   // 录像模式
    int                         nClassRoomID;                   // 教室id号
}NET_IN_SET_COURSE_RECORD_MODE;

// 设置录像模式出参，对应接口CLIENT_SetCourseRecordMode
typedef struct tagNET_OUT_SET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;                         
}NET_OUT_SET_COURSE_RECORD_MODE;

// 获取录像模式入参，对应接口CLIENT_GetCourseRecordMode
typedef struct tagNET_IN_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize;  
    int                         nClassRoomID;                   // 教室id号
}NET_IN_GET_COURSE_RECORD_MODE;

// 获取录像模式出参，对应接口CLIENT_GetCourseRecordMode
typedef struct tagNET_OUT_GET_COURSE_RECORD_MODE
{
    DWORD                       dwSize; 
    NET_EM_RECORD_MODE          emRecordMode;                   // 录像模式
}NET_OUT_GET_COURSE_RECORD_MODE;

// 设备公共信息
typedef struct tagNET_DEVICE_COMMON_INFO
{
    char                     szVendor[DH_COMMON_STRING_32];     // 生产厂商
    char                     szDviceType[DH_COMMON_STRING_32];  // 设备型号
    char                     szVersion[DH_COMMON_STRING_128];   // 设备版本信息
    char                     szSerialNo[DH_COMMON_STRING_128];  // 设备编号
    BYTE                     byReserved[128];                   // 保留字节
}NET_DEVICE_COMMON_INFO;

// 车检器信息
typedef struct tagNET_VEHICLE_DETECTOR_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    int                      nLaneNum;                          // 车道个数
    int                      nUsageOfLane[MAX_TRAFFIC_LANE_NUM];// 每个车道占有率, 0-100
    BYTE                     byReserved[128];                   // 保留字节
}NET_VEHICLE_DETECTOR_INFO;

// 信号检测器信息
typedef struct tagNET_SIGNAL_DETECTOR_INFO 
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    BYTE                     byReserved[128];                   // 保留字节
}NET_SIGNAL_DETECTOR_INFO;

// 频闪灯信息
typedef struct tagNET_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    BYTE                     byReserved[128];                   // 保留字节
}NET_STROBOSCOPIC_LAMP_INFO;

// RS485 频闪灯信息
typedef struct tagNET_RS485_STROBOSCOPIC_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测

    int                      nPeripheralAddress;                // 外设地址
    int                      nPeripheralStateCode;              // 外设故障码: 1-设备无响应, 2-灯珠故障, 3-未接频闪信号     
    int                      nLuminance;                        // 亮度, 1-20
    int                      nSensibility;                      // 灵敏度, 1-255
    float                    fPowerDissipation;                 // 功耗

    BYTE                     byReserved[128];                   // 保留字节
}NET_RS485_STROBOSCOPIC_LAMP_INFO;

// 爆闪灯信息
typedef struct tagNET_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    BYTE                     byReserved[128];                   // 保留字节
}NET_FLASH_LAMP_INFO;

// RS485 爆闪灯信息
typedef struct tagNET_RS485_FLASH_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    
    int                      nPeripheralAddress;                // 外设地址
    int                      nPeripheralStateCode;              // 外设故障码: 1-设备无响应, 2-灯珠故障, 3-未接频闪信号     
    int                      nLuminance;                        // 亮度, 1-20
    int                      nSensibility;                      // 灵敏度, 1-255
    float                    fPowerDissipation;                 // 功耗
    
    BYTE                     byReserved[128];                   // 保留字节
}NET_RS485_FLASH_LAMP_INFO;

// RS485 常亮灯信息
typedef struct tagNET_RS485_STEADY_LAMP_INFO
{
    NET_DEVICE_COMMON_INFO   stuDevice;                         // 设备信息
    int                      nWokingState;                      // 工作状态: 0-故障, 1-正常工作, 2-关闭
    int                      nMatchState;                       // 线圈匹配状态: 0-不匹配, 1-匹配, 2-不检测
    
    int                      nPeripheralAddress;                // 外设地址
    int                      nPeripheralStateCode;              // 外设故障码: 1-设备无响应, 2-灯珠故障, 3-未接频闪信号     
    int                      nLuminance;                        // 亮度, 1-20
    int                      nSensibility;                      // 灵敏度, 1-255
    float                    fPowerDissipation;                 // 功耗
    
    BYTE                     byReserved[128];                   // 保留字节
}NET_RS485_STEADY_LAMP_INFO;

// 摄像机外设状态
typedef struct tagNET_CAMERA_PERIPHERAL_INFO
{
    int                         nVehicleDetectorNum;                                // 车检器个数
    NET_VEHICLE_DETECTOR_INFO   stuVehicleDetectors[MAX_CAMERA_PERIPHERAL_NUM];     // 车检器信息

    int                         nSignalDetectorNum;                                 // 信号检测器个数
    NET_SIGNAL_DETECTOR_INFO    stuSignalDetectors[MAX_CAMERA_PERIPHERAL_NUM];      // 信号检测器信息
    
    int                         nStroboscopicLampNum;                               // 频闪灯个数
    NET_STROBOSCOPIC_LAMP_INFO  stuStroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM];    // 频闪灯信息

    int                         nFlashLampNum;                                      // 爆闪灯个数
    NET_FLASH_LAMP_INFO         stuFlashLamps[MAX_CAMERA_PERIPHERAL_NUM];           // 爆闪灯信息

    int                         nRS485StroboscopicLampNum;                          // RS485 频闪灯个数
    NET_RS485_STROBOSCOPIC_LAMP_INFO    stuRS485StroboscopicLamps[MAX_CAMERA_PERIPHERAL_NUM]; // RS485 频闪灯信息
    
    int                         nRS485FlashLampNum;                                 // RS485 爆闪灯个数
    NET_RS485_FLASH_LAMP_INFO   stuRS485FlashLamps[MAX_CAMERA_PERIPHERAL_NUM];      // RS485 爆闪灯信息

    int                         nRS485SteadyLampNum;                                // RS485 常亮灯个数
    NET_RS485_STEADY_LAMP_INFO  stuRS485SteadyLamps[MAX_CAMERA_PERIPHERAL_NUM];     // RS485 常亮灯信息

    BYTE                        byReserved[128];                                    // 保留字节
}NET_CAMERA_PERIPHERAL_INFO;

// 设备运行状态回调信息
typedef struct tagNET_REMOTECAMERA_NOTIFY_INFO
{
    int                         nChannelID;                     // 相机通道号
    NET_WORKSTATE               stuNative;                      // 摄像机状态
    NET_CAMERA_PERIPHERAL_INFO  stuPeripherals;                 // 摄像机所有外设信息
    BYTE                        byReserved[128];                // 保留字节
}NET_REMOTECAMERA_NOTIFY_INFO;

// 设备运行状态回调函数, lAttachHandle 为 CLIENT_AttachRemoteCameraState 返回的结果
typedef void (CALLBACK *fRemoteCameraStateCallBack)(LLONG lAttachHandle, NET_REMOTECAMERA_NOTIFY_INFO* pstuState, DWORD dwStateSize, LDWORD dwUser);

// CLIENT_AttachRemoteCameraState 入参
typedef struct tagNET_IN_REMOTECAMERA_ATTACH_INFO
{
    DWORD                       dwSize;                         // 结构体大小
    fRemoteCameraStateCallBack  cbNotify;                       // 回调函数
    LDWORD                      dwUser;                         // 用户信息
}NET_IN_REMOTECAMERA_ATTACH_INFO;

// CLIENT_AttachRemoteCameraState 出参
typedef struct tagNET_OUT_REMOTECAMERA_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
}NET_OUT_REMOTECAMERA_ATTACH_INFO;

// 订阅相机设备状态,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemoteCameraState(LLONG lLoginID, const NET_IN_REMOTECAMERA_ATTACH_INFO *pInParam, NET_OUT_REMOTECAMERA_ATTACH_INFO *pOutParam, int nWaitTime);

// 取消订阅相机设备状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemoteCameraState(LLONG lAttachHandle);

// 码流类型
typedef enum tagEM_STREAM_TYPE
{
    EM_STREAM_TYPE_UNKNOWN,                               // 未知状态
    EM_STREAM_TYPE_MAIN,                                  // 主码流
    EM_STREAM_TYPE_EXTRA1,                                // 辅码流1
    EM_STREAM_TYPE_EXTRA2,                                // 辅码流2
    EM_STREAM_TYPE_EXTRA3,                                // 辅码流3
}EM_STREAM_TYPE;

// 向客户端发送录像文件回调信息
typedef struct tagNET_RECORDMANAGER_NOTIFY_INFO
{
    int                         nChannelID;                     // 通道号
    EM_STREAM_TYPE              emStreamType;                   // 码流类型
    BOOL                        bState;                         // 是否在录像
    BYTE                        byReserved[128];                // 保留字节
}NET_RECORDMANAGER_NOTIFY_INFO;

// 向客户端发送录像文件回调函数, lAttachHandle 为 CLIENT_AttachRecordManagerState 返回的结果
typedef void (CALLBACK *fRecordManagerStateCallBack)(LLONG lAttachHandle, NET_RECORDMANAGER_NOTIFY_INFO* pstuState, DWORD dwStateSize, LDWORD dwUser);

// CLIENT_AttachRecordManagerState 入参
typedef struct tagNET_IN_RECORDMANAGER_ATTACH_INFO
{
    DWORD                        dwSize;                         // 结构体大小
    fRecordManagerStateCallBack  cbNotify;                       // 回调函数
    LDWORD                       dwUser;                         // 用户信息
}NET_IN_RECORDMANAGER_ATTACH_INFO;

// CLIENT_AttachRecordManagerState 出参
typedef struct tagNET_OUT_RECORDMANAGER_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
}NET_OUT_RECORDMANAGER_ATTACH_INFO;

// 订阅录像状态变化,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordManagerState(LLONG lLoginID, const NET_IN_RECORDMANAGER_ATTACH_INFO *pInParam, NET_OUT_RECORDMANAGER_ATTACH_INFO *pOutParam, int nWaitTime);

// 取消订阅录像状态变化
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordManagerState(LLONG lAttachHandle);

// 巡更状态
typedef enum tagNET_EM_PATROL_STATUS
{
    NET_EM_PATROL_STATUS_UNKNOWN,                               // 未知状态
    NET_EM_PATROL_STATUS_BEGIN,                                 // 巡更开始
    NET_EM_PATROL_STATUS_END,                                   // 巡更结束
    NET_EM_PATROL_STATUS_FAIL,                                  // 巡更失败
}NET_EM_PATROL_STATUS;

// CLIENT_SendNotifyToDev 入参 (对应枚举 NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_IN_PATROL_STATUS_INFO
{
    DWORD                       dwSize;                         // 结构体大小
    NET_EM_PATROL_STATUS        emPatrolStatus;                 // 巡更状态

}NET_IN_PATROL_STATUS_INFO;

// CLIENT_SendNotifyToDev 出参 (对应枚举 NET_EM_NOTIFY_PATROL_STATUS)
typedef struct tagNET_OUT_PATROL_STATUS_INFO
{
    DWORD                    dwSize;                            // 结构体大小
}NET_OUT_PATROL_STATUS_INFO;

// 发送的通知类型,对应CLIENT_SendNotifyToDev接口
typedef enum tagNET_EM_NOTIFY_TYPE
{
    NET_EM_NOTIFY_PATROL_STATUS = 1,                            // 发送巡更通知 (对应结构体 NET_IN_PATROL_STATUS_INFO, NET_OUT_PATROL_STATUS_INFO)
}NET_EM_NOTIFY_TYPE;

// 下发通知到设备 接口, 以emNotifyType来区分下发的通知类型, pInParam 和 pOutParam 都由用户来分配和释放,大小参照emNotifyType对应结构体
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendNotifyToDev(LLONG lLoginID, NET_EM_NOTIFY_TYPE emNotifyType, const void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );

// 热度图原始数据信息
typedef struct tagNET_RAWSTREAM_NOTIFY_INFO 
{
    int                      nWidth;                            // 图片宽度
    int                      nHeight;                           // 图片高度
    NET_TIME                 stuStartTime;                      // 开始时间
    NET_TIME                 stuEndTime;                        // 结束时间
    char*                    pStream;                           // 图片数据
    int                      nLength;                           // 图片数据长度
    BYTE                     byReserved[512];                   // 保留字节 
}NET_RAWSTREAM_NOTIFY_INFO;

// 热度图原始数据回调函数, lAttachHandle 为 CLIENT_AttachHeatMapRawStream 返回的结果
typedef void (CALLBACK *fRawStreamCallBack)(LLONG lAttachHandle, NET_RAWSTREAM_NOTIFY_INFO* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachHeatMapRawStream 入参
typedef struct tagNET_IN_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
    fRawStreamCallBack       cbNotify;                          // 回调函数
    LDWORD                   dwUser;                            // 用户信息
    int                      nChannel;                          // 通道号
}NET_IN_RAWSTREAM_ATTACH_INFO;

// CLIENT_AttachHeatMapRawStream 出参
typedef struct tagNET_OUT_RAWSTREAM_ATTACH_INFO
{
    DWORD                    dwSize;                            // 结构体大小
}NET_OUT_RAWSTREAM_ATTACH_INFO;

// 订阅热度图原始数据接口,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachHeatMapRawStream(LLONG lLoginID, const NET_IN_RAWSTREAM_ATTACH_INFO *pInParam, NET_OUT_RAWSTREAM_ATTACH_INFO *pOutParam, int nWaitTime);

// 退订热度图原始数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachHeatMapRawStream(LLONG lAttachHandle);

//车牌信息
typedef struct tagNET_ANALYSERESULT
{
    char                      szPlateNumber[64];                // 车牌号
    NET_RECT                  stuRect;                          // 车牌包围盒坐标,绝对坐标
    BYTE                      byReserved[128];                  // 保留字节 
}NET_ANALYSERESULT;

// CLIENT_SetIVSServerAnalyseResult 接口入参
typedef struct tagNET_IN_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           // 结构体大小
    int                       nChannel;                         // 通道号 从0开始
    int                       nAnalyseResultCount;              // 车牌识别结果数量
    NET_ANALYSERESULT         stuAnalyseResult[MAX_PLATE_NUM];  // 车牌信息
	unsigned int			  nFrameSequence;					// 序号,用于和后端IVS识别确认,必填
	unsigned int			  nPhysicalLane;					// 物理车位号
}NET_IN_SET_ANALYSERESULT_INFO;

// CLIENT_SetIVSServerAnalyseResult 接口出参
typedef struct tagNET_OUT_SET_ANALYSERESULT_INFO
{
    DWORD                     dwSize;                           // 结构体大小
}NET_OUT_SET_ANALYSERESULT_INFO;

// CLIENT_AttachEventRestore 接口输入参数
typedef struct tagNET_IN_ATTACH_EVENT_RESTORE
{
    DWORD                dwSize;															//结构体大小
	char 				 szUuid[MAX_EVENT_RESTORE_UUID];									//客户端惟一标识
}NET_IN_ATTACH_EVENT_RESTORE;

// 算法服务器回传针对图片的识别结果,和EVENT_IVS_TRAFFIC_ANALYSE_PRESNAP事件配合使用,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetIVSServerAnalyseResult(LLONG lLoginID, const NET_IN_SET_ANALYSERESULT_INFO* pInBuf,NET_OUT_SET_ANALYSERESULT_INFO* pOutBuf,int nWaitTime);


// 获取防护舱门锁状态接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleLockState(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_LOCKSTATE* pInBuf,NET_OUT_QUERY_CAPSULE_LOCKSTATE* pOutBuf, int nWaitTime);

// 获取防护舱内人数,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsuleHumanNum(LLONG lLoginID, const NET_IN_QUERY_CAPSULE_HUMANNUM* pInBuf, NET_OUT_QUERY_CAPSULE_HUMANNUM* pOutBuf, int nWaitTime);

// 设置课程录像模式,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordMode(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_MODE* pInBuf, NET_OUT_SET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// 获取课程录像模式,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCourseRecordMode(LLONG lLoginID, const NET_IN_GET_COURSE_RECORD_MODE* pInBuf, NET_OUT_GET_COURSE_RECORD_MODE* pOutBuf, int nWaitTime);

// 逻辑通道号
typedef enum tagNET_EM_LOGIC_CHANNEL
{
    NET_EM_LOGIC_CHANNEL_INVALID = -1,                          // 无效
    NET_EM_LOGIC_CHANNEL_COMPOSITE,                             // 视频组合通道号
    NET_EM_LOGIC_CHANNEL_PPT,                                   // PPT显示逻辑通道号
    NET_EM_LOGIC_CHANNEL_BLACKBOARD,                            // 板书特写逻辑通道号
    NET_EM_LOGIC_CHANNEL_STUDENTFEATURE,                        // 学生特写逻辑通道号
    NET_EM_LOGIC_CHANNEL_STUDENTFULLVIEW,                       // 学生全景逻辑通道号
    NET_EM_LOGIC_CHANNEL_TEACHERFEATURE,                        // 教师特写逻辑通道号
    NET_EM_LOGIC_CHANNEL_TEACHERFULLVIEW,                       // 教师全景逻辑通道号
    NET_EM_LOGIC_CHANNEL_TEACHERDETECT,                         // 教师检测逻辑通道号
    NET_EM_LOGIC_CHANNEL_BLACKBOARDDETECT,                      // 板书检测逻辑通道号
    NET_EM_LOGIC_CHANNEL_BLACKBOARD1,                           // 板书特写1逻辑通道号
    NET_EM_LOGIC_CHANNEL_BLACKBOARDDETECT1,                     // 板书检测1逻辑通道号
    NET_EM_LOGIC_CHANNEL_VISUALPRESENTER,                       // 展台显示逻辑通道号
    NET_EM_LOGIC_CHANNEL_VIDEOSURVEILLANCE,                     // 视频监控逻辑通道号
	NET_EM_LOGIC_CHANNEL_VIDEOCONFERENCE,					    // 互动会议逻辑通道号
	NET_EM_LOGIC_CHANNEL_VIDEO_PRESENTATION,					// 互动演示逻辑通道
}NET_EM_LOGIC_CHANNEL;

// 通道信息
typedef struct  tagNET_LOGIC_CHANNEL_INFO
{
    int                         nRoomID;                        // 教室ID号
    NET_EM_LOGIC_CHANNEL        emLogicChannel;                 // 逻辑通道号
    BYTE                        byReserved[32];                 // 保留字节
}NET_LOGIC_CHANNEL_INFO;

// 获取真实通道号入参，对应接口 CLIENT_GetRealPreviewChannel
typedef struct tagNET_IN_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelCount;                  // 需要获取的通道数
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];             // 逻辑通道信息，下标为将要获取的真实通道数
}NET_IN_GET_REAL_PREVIEW_CHANNEL;

// 获取真实通道号出参，对应接口 CLIENT_GetRealPreviewChannel
typedef struct tagNET_OUT_GET_REAL_PREVIEW_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                       // 通道数量
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM]; // 通道号
}NET_OUT_GET_REAL_PREVIEW_CHANNEL;

// 获取真实预览通道号,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRealPreviewChannel(LLONG lLoginID, const NET_IN_GET_REAL_PREVIEW_CHANNEL* pInBuf, NET_OUT_GET_REAL_PREVIEW_CHANNEL* pOutBuf, int nWaitTime);

// 获取默认真实通道号入参，对应接口 CLIENT_GetDefaultRealChannel
typedef struct tagNET_IN_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelCount;                  // 需要获取的通道数
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];             // 逻辑通道信息，下标为将要获取的真实通道数
}NET_IN_GET_DEFAULT_REAL_CHANNEL;

// 获取默认真实通道号出参，对应接口 CLIENT_GetDefaultRealChannel
typedef struct tagNET_OUT_GET_DEFAULT_REAL_CHANNEL
{
    DWORD                    dwSize;
    int                      nChannelNum;                       // 通道数量
    int                      nChannel[MAX_PREVIEW_CHANNEL_NUM]; // 通道号
}NET_OUT_GET_DEFAULT_REAL_CHANNEL;

// 获取录播主机默认真实通道号,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefaultRealChannel(LLONG lLoginID, const NET_IN_GET_DEFAULT_REAL_CHANNEL* pInBuf, NET_OUT_GET_DEFAULT_REAL_CHANNEL* pOutBuf, int nWaitTime);

// 获取录播主机默认真实通道号入参，对应接口 CLIENT_GetLogicChannel
typedef struct tagNET_IN_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                       // 通道数量
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM]; // 通道号
}NET_IN_GET_COURSE_LOGIC_CHANNEL;

// 获取录播主机默认真实通道号出参，对应接口 CLIENT_GetLogicChannel
typedef struct tagNET_OUT_GET_COURSE_LOGIC_CHANNEL
{
    DWORD                       dwSize;
    int                         nChannelCount;                                          // 获取到的逻辑通道数
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // 逻辑通道信息，下标为将要获取的真实通道数
}NET_OUT_GET_COURSE_LOGIC_CHANNEL;

// 获取录播主机逻辑通道号,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLogicChannel(LLONG lLoginID, const NET_IN_GET_COURSE_LOGIC_CHANNEL* pInBuf,NET_OUT_GET_COURSE_LOGIC_CHANNEL* pOutBuf, int nWaitTime);

// 设置逻辑通道号和真实通道号的绑定关系入参 ，对应接口CLIENT_SetBlindRealChannel
typedef struct tagNET_IN_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
    int                         nChannelNum;                                            // 通道数量
    int                         nChannel[MAX_PREVIEW_CHANNEL_NUM];                      // 通道号
    NET_LOGIC_CHANNEL_INFO      stuChannelInfo[MAX_PREVIEW_CHANNEL_NUM];                // 逻辑通道信息，下标为将要设置的真实通道数
}NET_IN_SET_BLIND_REAL_CHANNEL;

// 设置逻辑通道号和真实通道号的绑定关系出参 ，对应接口CLIENT_SetBlindRealChannel
typedef struct tagNET_OUT_SET_BLIND_REAL_CHANNEL
{
    DWORD                       dwSize; 
}NET_OUT_SET_BLIND_REAL_CHANNEL;

// 设置逻辑通道号和真实通道号的绑定关系,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetBlindRealChannel(LLONG lLoginID, const NET_IN_SET_BLIND_REAL_CHANNEL* pInBuf,NET_OUT_SET_BLIND_REAL_CHANNEL* pOutBuf, int nWaitTime);

// 获取录播主机通道输入媒体介质入参 ，对应接口CLIENT_GetInputChannelMedia
typedef struct tagNET_IN_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize; 
    int                             nChannelNum;                       // 通道数量
    int                             nChannel[MAX_PREVIEW_CHANNEL_NUM]; // 通道号
}NET_IN_GET_INPUT_CHANNEL_MEDIA;

// 输入媒体介质
typedef enum tagNET_ENUM_INPUT_CHANNEL_MEDIA
{
    NET_ENUM_INPUT_MEDIA_UNKNOWN,                                       // 未知
    NET_ENUM_INPUT_MEDIA_VGA,                                           // VGA
    NET_ENUM_INPUT_MEDIA_HDMI,                                          // HDMI
}NET_ENUM_INPUT_CHANNEL_MEDIA;

// 获取录播主机通道输入媒体介质出参 ，对应接口CLIENT_GetInputChannelMedia
typedef struct tagNET_OUT_GET_INPUT_CHANNEL_MEDIA
{
    DWORD                           dwSize;
    int                             nChannelNum;                              // 通道数量
    NET_ENUM_INPUT_CHANNEL_MEDIA    emInputMedia[MAX_PREVIEW_CHANNEL_NUM];    // 输入媒体介质
}NET_OUT_GET_INPUT_CHANNEL_MEDIA;

// 获取录播主机通道输入媒体介质,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInputChannelMedia(LLONG lLoginID, const NET_IN_GET_INPUT_CHANNEL_MEDIA* pInBuf,NET_OUT_GET_INPUT_CHANNEL_MEDIA* pOutBuf, int nWaitTime);

//订阅事件重传,pInParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachEventRestore(LLONG lLoginID, const NET_IN_ATTACH_EVENT_RESTORE *pInParam, int nWaitTime);

// 停止订阅事件重传,pInParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachEventRestore(LLONG lAttachHandle);

// CLIENT_GetLaserDistance 接口入参
typedef struct tagNET_IN_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // 结构体大小
    int                       nChannel;                         // 通道号,从0开始
}NET_IN_GET_LASER_DISTANCE;

// CLIENT_GetLaserDistance 接口出参
typedef struct tagNET_OUT_GET_LASER_DISTANCE
{
    DWORD                     dwSize;                           // 结构体大小
    UINT                      unDistance;                       // 目标距离 单位:米
}NET_OUT_GET_LASER_DISTANCE;


// 获取画面中心位置目标的距离,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLaserDistance(LLONG lLoginID, const NET_IN_GET_LASER_DISTANCE* pInBuf, NET_OUT_GET_LASER_DISTANCE* pOutBuf, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT );

// CLIENT_GetAtomsphData接口入参
typedef struct tagNET_IN_GET_ATOMSPHDATA
{
    DWORD                     dwSize;                           
}NET_IN_GET_ATOMSPHDATA;

// CLIENT_GetAtomsphData接口出参
typedef struct tagNET_OUT_GET_ATOMSPHDATA
{
    DWORD                     dwSize;
    float                     fWindSpeed;                       // 风速，单位m/s
    float                     fWindDirection;                   // 风向，单位度
    float                     fHumidity;                        // 湿度，单位%
    float                     fTemperture;                      // 温度，单位摄氏度
    float                     fAirPressure;                     // 气压，单位百帕
    float                     fSunBathe;                        // 光照，单位w/m2
}NET_OUT_GET_ATOMSPHDATA;

// 获取气象信息,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAtomsphData(LLONG lLoginID, const NET_IN_GET_ATOMSPHDATA* pInBuf, NET_OUT_GET_ATOMSPHDATA* pOutBuf,int nWaitTime);

// 开启/关闭指定通道录像入参
typedef struct tagNET_IN_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // 该结构体大小
    int                      nChannel;               // 通道号
    int                      nAction;                // 0:开启, 1:关闭
}NET_IN_SET_COURSE_RECORD_STATE;

// 开启/关闭指定通道录像出参
typedef struct tagNET_OUT_SET_COURSE_RECORD_STATE
{
    DWORD                    dwSize;                 // 该结构体大小
}NET_OUT_SET_COURSE_RECORD_STATE;

// 开启/关闭指定通道录像,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCourseRecordState(LLONG lLoginID, const NET_IN_SET_COURSE_RECORD_STATE *pInBuf, NET_OUT_SET_COURSE_RECORD_STATE *pOutBuf, int nWaitTime);

// 开始查询课程视频信息入参
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // 该结构体大小
    NET_TIME                 stuStartTime;                      // 查询开始时间
    NET_TIME                 stuEndTime;                        // 查询结束时间
    char                     szKeyWord[DH_COMMON_STRING_128];    // 查询关键字
}NET_IN_QUERY_COURSEMEDIA_FILEOPEN;

// 开始查询课程视频信息出参
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILEOPEN
{
    DWORD                    dwSize;                            // 该结构体大小
    UINT                     ntotalNum;                         // 查询到的总个数
    UINT                     nfindID;                           // 查询ID号
}NET_OUT_QUERY_COURSEMEDIA_FILEOPEN;

// 开始查询课程视频信息,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OpenQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILEOPEN *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILEOPEN *pOutBuf, int nWaitTime);

// 查询课程视频信息入参
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILE
{
    DWORD                    dwSize;                            // 该结构体大小
    UINT                     nfindID;                           // 查询ID号
    int                      nOffset;                           // 开始查询偏移
    int                      nCount;                            // 需要查询的个数
}NET_IN_QUERY_COURSEMEDIA_FILE;

// 录像文件信息
typedef struct tagNET_RECORD_INFO
{
    int                      nRealChannel;                      // 真实通道号
    NET_TIME                 stuStartTime;                      // 查询开始时间
    NET_TIME                 stuEndTime;                        // 查询结束时间
    UINT                     nFileLen;                          // 通道录像文件总长度低32位,0表示此通道没录像 
    UINT                     nFileLenEx;                        // 通道录像文件总长度高32位,与FileLen一起表示录像长度
    UINT                     nTime;                             // 录像时长
    UINT                     nFileType;                         // 文件类型，0:裁减文件，1:原始文件
    BYTE                     byReserved[64];                    // 保留字节 
}NET_RECORD_INFO;

// 课程信息
typedef struct tagNET_COURSE_INFO
{
    char                     szCourseName[DH_COMMON_STRING_64];                 // 课程名称
    char                     szTeacherName[DH_COMMON_STRING_64];                // 教师姓名
    char                     szIntroduction[DH_COMMON_STRING_128];              // 视频简介
    BYTE                     byReserved[64];                                    // 保留字节
}NET_COURSE_INFO;

// 视频信息
typedef struct tagNET_COURSEMEDIA_FILE_INFO
{
    int                      nID;                                               // 视频信息ID,-1表示无此记录
    NET_COURSE_INFO          stuCourseInfo;                                     // 课程信息
    int                      nChannelNum;                                       // 通道数量
    int                      nRecordNum[64];                                    // 对应通道的录像分段数
    NET_RECORD_INFO          stuRecordInfo[64][16];                             // 录像信息，第一维下标为映射通道号，第二维为录像分段数
    BYTE                     byReserved[128];                                   // 保留字节
}NET_COURSEMEDIA_FILE_INFO;

// 查询课程视频信息出参
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILE
{
    DWORD                       dwSize;                                         // 该结构体大小
    int                         nCountResult;                                   // 查询到的个数
    NET_COURSEMEDIA_FILE_INFO   stuCourseMediaFile[64];                         // 视频信息
}NET_OUT_QUERY_COURSEMEDIA_FILE;

// 查询课程视频信息,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILE *pOutBuf, int nWaitTime);

// 关闭课程视频查询入参
typedef struct tagNET_IN_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // 该结构体大小
    UINT                        nFindID;                                        // 查询ID号
}NET_IN_QUERY_COURSEMEDIA_FILECLOSE;

// 关闭课程视频查询出参
typedef struct tagNET_OUT_QUERY_COURSEMEDIA_FILECLOSE
{
    DWORD                       dwSize;                                         // 该结构体大小
}NET_OUT_QUERY_COURSEMEDIA_FILECLOSE;

// 关闭课程视频查询,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloseQueryCourseMediaFile(LLONG lLoginID, const NET_IN_QUERY_COURSEMEDIA_FILECLOSE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILECLOSE *pOutBuf, int nWaitTime);

// 文件传输状态，文件分段传输时区分开始和结束
typedef enum tagNET_EM_AIO_FILE_STATUS
{
	NET_EM_AIO_FILE_STATUS_UNKNOWN,
	NET_EM_AIO_FILE_STATUS_BEGIN,				// Begin, 标识上传开始，不带数据
	NET_EM_AIO_FILE_STATUS_UPLOADING,			// Uploading
	NET_EM_AIO_FILE_STATUS_END,					// End, 标识上传结束，不带数据
}NET_EM_AIO_FILE_STATUS;

// 文件类型
typedef enum tagNET_EM_AIO_FILE_TYPE
{
	NET_EM_AIO_FILE_TYPE_UNKNOWN,
	NET_EM_AIO_FILE_TYPE_UPSYSTEM,				// "upSystem":系统升级包
	NET_EM_AIO_FILE_TYPE_UPAPP,					// "upApp"：app升级包End
}NET_EM_AIO_FILE_TYPE;


// CLIENT_UploadAIOFile 接口输入参数(上传文件到设备)
typedef struct tagNET_IN_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
    char*         		pszFileSrc;                     // 源文件路径
    char*         		pszFileDst;                     // 目标文件路径
    char*         		pszFolderDst;                   // 目标文件夹路径：可为NULL, NULL时设备使用默认路径
    unsigned int        nPacketLen;                     // 文件分包大小(字节): 0表示不分包
	NET_EM_AIO_FILE_TYPE	emType;						// 文件类型
} NET_IN_UPLOAD_AIO_FILE;

// CLIENT_UploadAIOFile 接口输出参数(上传文件到设备)
typedef struct tagNET_OUT_UPLOAD_AIO_FILE
{
    DWORD               dwSize;
} NET_OUT_UPLOAD_AIO_FILE;


// fAttachAIOFileprocCB 参数
typedef struct tagNET_CB_AIOFILEPROC
{
    DWORD						dwSize;
    NET_EM_AIO_FILE_STATUS      emStatus;				// 文件传输状态, 文件分段传输时区分开始和结束
    NET_EM_AIO_FILE_TYPE		emType;					// 文件类型 

    unsigned int				dwLength;				// 文件大小, 单位: 字节
	char*						pbFileBuf;				// 文件缓冲区
	DWORD						dwBufSize;				// 文件缓冲区大小
}NET_CB_AIOFILEPROC;

// 注册升级文件处理回调函数原形,lAttachHandle是CLIENT_attachAIOFileProc返回值, 每次1条,pBuf->dwSize == nBufLen
typedef void (CALLBACK *fAttachAIOFileprocCB) (LLONG lAttachHandle, NET_CB_AIOFILEPROC* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_attachAIOFileProc()输入参数
typedef struct tagNET_IN_ATTACH_AIO
{
    DWORD                   dwSize;
    fAttachAIOFileprocCB    cbNotify;						// 回调函数
    LDWORD                  dwUser;                         // 用户数据
}NET_IN_ATTACH_AIO;

// CLIENT_attachAIOFileProc 输出参数
typedef struct tagNET_OUT_ATTACH_AIO
{
    DWORD                   dwSize;
}NET_OUT_ATTACH_AIO;

// 广告播放
typedef enum tagNET_EM_ADVERT_ACTION
{
	NET_EM_ADVERT_ACTION_UNKNOWN	= 0,
	NET_EM_ADVERT_ACTION_START,				// start
	NET_EM_ADVERT_ACTION_STOP,				// stop
}NET_EM_ADVERT_ACTION;

// 广告位置
typedef enum tagNET_EM_ADVERT_POSITION
{
	NET_EM_ADVERT_POSITION_UNKNOWN	= 0,
	NET_EM_ADVERT_POSITION_TOP,				// top    顶部
	NET_EM_ADVERT_POSITION_MIDDLE,			// middle 中间
	NET_EM_ADVERT_POSITION_BOTTOM,			// bottom 底部
}NET_EM_ADVERT_POSITION;

// CLIENT_SetAdvert 接口输入参数(设置NVR广告)
typedef struct tagNET_IN_SET_ADVERT 
{
    DWORD						dwSize;
    NET_EM_ADVERT_ACTION        emAction;             // 广告播放
    int							nSpeed;               // 广告滚动速度
    NET_EM_ADVERT_POSITION		emPosition;           // 广告位置
} NET_IN_SET_ADVERT;

// CLIENT_SetAdvert 接口输出参数(设置NVR广告)
typedef struct tagNET_OUT_SET_ADVERT
{
    DWORD               dwSize;
} NET_OUT_SET_ADVERT;

// CLIENT_AIOScreen 接口输入参数(NVR截屏)
typedef struct tagNET_IN_AIO_SCREEN
{
    DWORD						dwSize;
} NET_IN_AIO_SCREEN;

// CLIENT_AIOScreen 接口输出参数(NVR截屏)
typedef struct tagNET_OUT_AIO_SCREEN
{
    DWORD               dwSize;
	char				szName[DH_COMMON_STRING_256];	// 截屏图片路径
} NET_OUT_AIO_SCREEN;

// CLIENT_AIOandroidAdb 接口输入参数(控制安卓adb开启或关闭)
typedef struct tagNET_IN_CONTROL_ANDROID_ADB 
{
    DWORD						dwSize;
	BOOL						bEnable;				// 是否开启adb
} NET_IN_CONTROL_ANDROID_ADB;

// CLIENT_AIOandroidAdb 接口输出参数(控制安卓adb开启或关闭)
typedef struct tagNET_OUT_CONTROL_ANDROID_ADB
{
    DWORD               dwSize;
} NET_OUT_CONTROL_ANDROID_ADB;

// 报警联动信息
typedef struct tagNET_ALARM_MSG_HANDLE
{
	//能力
	bool                				abChannelCount;                                 // 是否支持通道数量
	bool                				abAlarmOutCount;                                // 是否支持报警输出数量

	bool								abRecordMask;                                   // 是否支持录像通道
	bool								abRecordEnable;                                 // 是否支持录像使能
	bool								abRecordLatch;                                  // 是否支持录像延时

	bool								abAlarmOutMask;                                 // 是否支持报警输出通道

	bool								abAlarmOutEn;                                   // 是否支持报警输出使能
	bool								abAlarmOutLatch;                                // 是否支持报警输出延时
	bool								abExAlarmOutMask;                               // 是否支持扩展报警输出通道
	bool								abExAlarmOutEn;                                 // 是否支持扩展报警输出使能

	bool								abPtzLinkEn;                                    // 是否支持云台联动使能
	bool								abTourMask;                                     // 是否支持轮巡掩码
	bool								abTourEnable;                                   // 是否支持轮巡使能

	bool								abSnapshot;                                     // 是否支持快照
	bool								abSnapshotEn;                                   // 是否支持快照使能
	bool								abSnapshotPeriod;                               // 是否支持帧间隔，每隔多少帧抓一张图片
	bool								abSnapshotTimes;                                // 是否支持连拍次数
	bool								abTipEnable;                                    // 是否支持本地消息框提示

	bool								abMailEnable;                                   // 是否支持发送邮件
	bool								abMessageEnable;                                // 是否支持上传到报警中心服务器
	bool								abBeepEnable;                                   // 是否支持蜂鸣
	bool								abVoiceEnable;                                  // 是否支持语音提示

	bool								abMatrixMask;                                   // 是否支持联动视频矩阵掩码
	bool								abMatrixEnable;                                 // 是否支持联动视频矩阵使能
	bool								abEventLatch;                                   // 是否支持联动开始延时时间
	bool								abLogEnable;                                    // 是否支持日志使能

	bool								abDelay;                                        // 是否支持报警延时
	bool								abVideoMessageEn;                               // 是否支持叠加提示字幕到视频
	bool								abMMSEnable;                                    // 是否支持发送短消息
	bool								abMessageToNetEn;                               // 是否支持消息上传给网络使能
	bool								abTourSplit;                                    // 是否支持换面分割轮巡

	bool								abSnapshotTitleEn;                              // 是否支持叠加图片标题使能
	bool                				abPtzLinkEx;                                    // 是否支持云台联动使能
	bool                				abSnapshotTitle;                                // 是否支持叠加图片标题
	bool                				abMailDetail;                                   // 是否支持邮件详情
	bool                				abVideoTitleEn;                                 // 是否支持叠加视频标题，主要指主码流
	bool                				abVideoTitle;                                   // 是否支持视频标题内容

	bool                				abTour;                                         // 是否支持轮巡
	bool                				abDBKeys;                                       // 是否支持指定事件详细信息里需要写到数据库的关键字
	bool                				abJpegSummary;                                  // 是否支持叠加到JPEG图片的摘要信息
	bool                				abFlashEn;                                      // 是否支持补光灯使能
	bool                				abFlashLatch;                                   // 是否支持补光灯延时

	bool								abAudioFileName;                                // 是否支持联动语音文件绝对路径
	bool								abAlarmBellEn;                                  // 是否支持警号使能
	bool								abAccessControlEn;                              // 是否支持门禁控制使能
	bool								abAccessControl;                                // 是否支持门禁控制

	bool								abTalkBack;	                                    // 是否支持语音呼叫
	bool								abPSTNAlarmServer;                              // 是否支持电话报警中心
	bool								abAlarmBellLatch;                               // 是否支持警号输出延时

	bool                                abPlayTimes;                                    // 是否支持联动语音播放次数
	bool                                abReboot;                                        // 是否支持重启使能
	bool                                abBeepTime;                                     // 是否支持蜂鸣时长

	BYTE                                byReserved[68];                                 // 能力保留字段

	//信息
	NET_CFG_TIME_SCHEDULE				stuTimeSection;									// 事件响应时间表

	int									nChannelCount;									// 设备的视频通道数
	int									nAlarmOutCount;									// 设备的报警输出个数

	DWORD								dwRecordMask[CFG_MAX_CHANNEL_COUNT];			// 录像通道掩码(按位)
	BOOL								bRecordEnable;									// 录像使能
	int									nRecordLatch;									// 录像延时时间(秒)
	DWORD								dwAlarmOutMask[CFG_MAX_CHANNEL_COUNT];			// 报警输出通道掩码

	BOOL								bAlarmOutEn;									// 报警输出使能
	int									nAlarmOutLatch;									// 报警输出延时时间(秒)
	DWORD								dwExAlarmOutMask[CFG_MAX_CHANNEL_COUNT];		// 扩展报警输出通道掩码
	BOOL								bExAlarmOutEn;									// 扩展报警输出使能

	NET_CFG_PTZ_LINK					stuPtzLink[CFG_MAX_VIDEO_CHANNEL_NUM];			// 云台联动项		//这个参数并没有被解析，应该是被扩展替代
	BOOL								bPtzLinkEn;										// 云台联动使能
	DWORD								dwTourMask[CFG_MAX_CHANNEL_COUNT];				// 轮询通道掩码
	BOOL								bTourEnable;									// 轮询使能

	DWORD								dwSnapshot[CFG_MAX_CHANNEL_COUNT];				// 快照通道号掩码
	BOOL								bSnapshotEn;									// 快照使能
	int									nSnapshotPeriod;								// 连拍周期(秒)
	int									nSnapshotTimes;									// 连拍次数
	BOOL								bTipEnable;										// 本地消息框提示

	BOOL								bMailEnable;									// 发送邮件，如果有图片，作为附件
	BOOL								bMessageEnable;									// 上传到报警服务器
	BOOL								bBeepEnable;							 		// 蜂鸣

	BOOL								bVoiceEnable;									// 语音提示
	int                                 nPlayTimes;                                     // 联动语音播放次数bVoiceEnable=TRUE时生效

	DWORD								dwMatrixMask[CFG_MAX_CHANNEL_COUNT];			// 联动视频矩阵通道掩码
	BOOL								bMatrixEnable;									// 联动视频矩阵
	int									nEventLatch;									// 联动开始延时时间(秒)，0－15
	BOOL								bLogEnable;										// 是否记录日志

	int									nDelay;											// 设置时先延时再生效，单位为秒
	BOOL								bVideoMessageEn;								// 叠加提示字幕到视频。叠加的字幕包括事件类型，通道号，秒计时。
	BOOL								bMMSEnable;										// 发送彩信使能
	BOOL								bMessageToNetEn;								// 消息上传给网络使能
	int									nTourSplit;										// 轮巡时的分割模式 0: 1画面; 1: 8画面

	BOOL								bSnapshotTitleEn;								// 是否叠加图片标题
	int                 				nPtzLinkExNum;									// 云台配置数
	NET_PTZ_LINK 						stuPtzLinkEx[CFG_MAX_VIDEO_CHANNEL_NUM];        // 扩展云台信息
	int                 				nSnapTitleNum;									// 图片标题内容数
	NET_CFG_EVENT_TITLE 				stuSnapshotTitle[CFG_MAX_VIDEO_CHANNEL_NUM];	// 图片标题内容
	NET_CFG_MAIL_DETAIL 				stuMailDetail;									// 邮件详细内容
	BOOL                				bVideoTitleEn;									// 是否叠加视频标题，主要指主码流
	int                 				nVideoTitleNum;									// 视频标题内容数目
	NET_CFG_EVENT_TITLE 				stuVideoTitle[CFG_MAX_VIDEO_CHANNEL_NUM];		// 视频标题内容

	int                 				nTourNum;										// 轮询联动数目
	NET_CFG_TOURLINK    				stuTour[CFG_MAX_VIDEO_CHANNEL_NUM];				// 轮询联动配置
	int                 				nDBKeysNum;										// 指定数据库关键字的有效数
	char                				szDBKeys[CFG_MAX_DBKEY_NUM][CFG_MAX_CHANNELNAME_LEN];	// 指定事件详细信息里需要写到数据库的关键字
	BYTE                				byJpegSummary[CFG_MAX_SUMMARY_LEN];						// 叠加到JPEG图片的摘要信息
	BOOL                				bFlashEnable;											// 是否使能补光灯
	int                 				nFlashLatch;											// 补光灯延时时间(秒),延时时间范围：[10,300]

	char								szAudioFileName[MAX_PATH];						// 联动语音文件绝对路径
	BOOL								bAlarmBellEn;									// 警号使能
	BOOL								bAccessControlEn;								// 门禁使能
	DWORD								dwAccessControl;								// 门禁组数
	NET_EM_CFG_ACCESSCONTROLTYPE		emAccessControlType[CFG_MAX_ACCESSCONTROL_NUM];	// 门禁联动操作信息

	NET_CFG_TALKBACK_INFO				stuTalkback;									// 语音呼叫联动信息
	NET_CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// 电话报警中心联动信息
	int									nAlarmBellLatch;								// 警号输出延时时间(10-300秒)

	BOOL                                bReboot;                                        //重启使能TRUE:使能 FALSE:不使能
	int                                 nBeepTime;                                      //蜂鸣时长最大值为3600，0代表持续蜂鸣
	BOOL								abAudioLinkTime;								// 联动语音时间使能
	int									nAudioLinkTime;									// 联动语音播放的时间, 单位：秒
	BOOL								abAudioPlayTimes;								// 联动语音播放使能
	int									nAudioPlayTimes;								// 联动语音播放次数
	BYTE								byReserve[2032];								// 预留字节
} NET_ALARM_MSG_HANDLE;

// 报警联动信息
typedef struct tagNET_CFG_ALARM_MSG_HANDLE
{
    DWORD                               dwSize;

	//能力
    bool                				abChannelCount;                                 // 是否支持通道数量
	bool                				abAlarmOutCount;                                // 是否支持报警输出数量

	bool								abRecordMask;                                   // 是否支持录像通道
	bool								abRecordEnable;                                 // 是否支持录像使能
	bool								abRecordLatch;                                  // 是否支持录像延时

	bool								abAlarmOutMask;                                 // 是否支持报警输出通道

	bool								abAlarmOutEn;                                   // 是否支持报警输出使能
	bool								abAlarmOutLatch;                                // 是否支持报警输出延时
	bool								abExAlarmOutMask;                               // 是否支持扩展报警输出通道
	bool								abExAlarmOutEn;                                 // 是否支持扩展报警输出使能

	bool								abPtzLinkEn;                                    // 是否支持云台联动使能
	bool								abTourMask;                                     // 是否支持轮巡掩码
	bool								abTourEnable;                                   // 是否支持轮巡使能

	bool								abSnapshot;                                     // 是否支持快照
	bool								abSnapshotEn;                                   // 是否支持快照使能
	bool								abSnapshotPeriod;                               // 是否支持帧间隔，每隔多少帧抓一张图片
	bool								abSnapshotTimes;                                // 是否支持连拍次数
	bool								abTipEnable;                                    // 是否支持本地消息框提示

	bool								abMailEnable;                                   // 是否支持发送邮件
	bool								abMessageEnable;                                // 是否支持上传到报警中心服务器
	bool								abBeepEnable;                                   // 是否支持蜂鸣
	bool								abVoiceEnable;                                  // 是否支持语音提示

	bool								abMatrixMask;                                   // 是否支持联动视频矩阵掩码
	bool								abMatrixEnable;                                 // 是否支持联动视频矩阵使能
	bool								abEventLatch;                                   // 是否支持联动开始延时时间
	bool								abLogEnable;                                    // 是否支持日志使能

	bool								abDelay;                                        // 是否支持报警延时
	bool								abVideoMessageEn;                               // 是否支持叠加提示字幕到视频
	bool								abMMSEnable;                                    // 是否支持发送短消息
	bool								abMessageToNetEn;                               // 是否支持消息上传给网络使能
	bool								abTourSplit;                                    // 是否支持换面分割轮巡

	bool								abSnapshotTitleEn;                              // 是否支持叠加图片标题使能
	bool                				abPtzLinkEx;                                    // 是否支持云台联动使能
	bool                				abSnapshotTitle;                                // 是否支持叠加图片标题
	bool                				abMailDetail;                                   // 是否支持邮件详情
	bool                				abVideoTitleEn;                                 // 是否支持叠加视频标题，主要指主码流
	bool                				abVideoTitle;                                   // 是否支持视频标题内容

	bool                				abTour;                                         // 是否支持轮巡
	bool                				abDBKeys;                                       // 是否支持指定事件详细信息里需要写到数据库的关键字
	bool                				abJpegSummary;                                  // 是否支持叠加到JPEG图片的摘要信息
	bool                				abFlashEn;                                      // 是否支持补光灯使能
	bool                				abFlashLatch;                                   // 是否支持补光灯延时

    bool								abAudioFileName;                                // 是否支持联动语音文件绝对路径
    bool								abAlarmBellEn;                                  // 是否支持警号使能
    bool								abAccessControlEn;                              // 是否支持门禁控制使能
    bool								abAccessControl;                                // 是否支持门禁控制

    bool								abTalkBack;	                                    // 是否支持语音呼叫
    bool								abPSTNAlarmServer;                              // 是否支持电话报警中心
    bool								abAlarmBellLatch;                               // 是否支持警号输出延时

	bool                                abPlayTimes;                                    // 是否支持联动语音播放次数
	bool                                abReboot;                                        // 是否支持重启使能
	bool                                abBeepTime;                                     // 是否支持蜂鸣时长

    BYTE                                byReserved[68];                                 // 能力保留字段

	//信息
	NET_CFG_TIME_SCHEDULE				stuTimeSection;									// 事件响应时间表

	int									nChannelCount;									// 设备的视频通道数
	int									nAlarmOutCount;									// 设备的报警输出个数

	DWORD								dwRecordMask[CFG_MAX_CHANNEL_COUNT];			// 录像通道掩码(按位)
	BOOL								bRecordEnable;									// 录像使能
	int									nRecordLatch;									// 录像延时时间(秒)
	DWORD								dwAlarmOutMask[CFG_MAX_CHANNEL_COUNT];			// 报警输出通道掩码

	BOOL								bAlarmOutEn;									// 报警输出使能
	int									nAlarmOutLatch;									// 报警输出延时时间(秒)
	DWORD								dwExAlarmOutMask[CFG_MAX_CHANNEL_COUNT];		// 扩展报警输出通道掩码
	BOOL								bExAlarmOutEn;									// 扩展报警输出使能

	NET_CFG_PTZ_LINK					stuPtzLink[CFG_MAX_VIDEO_CHANNEL_NUM];			// 云台联动项		//这个参数并没有被解析，应该是被扩展替代
	BOOL								bPtzLinkEn;										// 云台联动使能
	DWORD								dwTourMask[CFG_MAX_CHANNEL_COUNT];				// 轮询通道掩码
	BOOL								bTourEnable;									// 轮询使能

	DWORD								dwSnapshot[CFG_MAX_CHANNEL_COUNT];				// 快照通道号掩码
	BOOL								bSnapshotEn;									// 快照使能
	int									nSnapshotPeriod;								// 连拍周期(秒)
	int									nSnapshotTimes;									// 连拍次数
	BOOL								bTipEnable;										// 本地消息框提示

	BOOL								bMailEnable;									// 发送邮件，如果有图片，作为附件
	BOOL								bMessageEnable;									// 上传到报警服务器
	BOOL								bBeepEnable;							 		// 蜂鸣
	
	BOOL								bVoiceEnable;									// 语音提示
	int                                 nPlayTimes;                                     // 联动语音播放次数bVoiceEnable=TRUE时生效

	DWORD								dwMatrixMask[CFG_MAX_CHANNEL_COUNT];			// 联动视频矩阵通道掩码
	BOOL								bMatrixEnable;									// 联动视频矩阵
	int									nEventLatch;									// 联动开始延时时间(秒)，0－15
	BOOL								bLogEnable;										// 是否记录日志

	int									nDelay;											// 设置时先延时再生效，单位为秒
	BOOL								bVideoMessageEn;								// 叠加提示字幕到视频。叠加的字幕包括事件类型，通道号，秒计时。
	BOOL								bMMSEnable;										// 发送彩信使能
	BOOL								bMessageToNetEn;								// 消息上传给网络使能
	int									nTourSplit;										// 轮巡时的分割模式 0: 1画面; 1: 8画面

	BOOL								bSnapshotTitleEn;								// 是否叠加图片标题
	int                 				nPtzLinkExNum;									// 云台配置数
	NET_PTZ_LINK 						stuPtzLinkEx[CFG_MAX_VIDEO_CHANNEL_NUM];        // 扩展云台信息
	int                 				nSnapTitleNum;									// 图片标题内容数
	NET_CFG_EVENT_TITLE 				stuSnapshotTitle[CFG_MAX_VIDEO_CHANNEL_NUM];	// 图片标题内容
	NET_CFG_MAIL_DETAIL 				stuMailDetail;									// 邮件详细内容
	BOOL                				bVideoTitleEn;									// 是否叠加视频标题，主要指主码流
	int                 				nVideoTitleNum;									// 视频标题内容数目
	NET_CFG_EVENT_TITLE 				stuVideoTitle[CFG_MAX_VIDEO_CHANNEL_NUM];		// 视频标题内容

	int                 				nTourNum;										// 轮询联动数目
	NET_CFG_TOURLINK    				stuTour[CFG_MAX_VIDEO_CHANNEL_NUM];				// 轮询联动配置
	int                 				nDBKeysNum;										// 指定数据库关键字的有效数
	char                				szDBKeys[CFG_MAX_DBKEY_NUM][CFG_MAX_CHANNELNAME_LEN];	// 指定事件详细信息里需要写到数据库的关键字
	BYTE                				byJpegSummary[CFG_MAX_SUMMARY_LEN];						// 叠加到JPEG图片的摘要信息
	BOOL                				bFlashEnable;											// 是否使能补光灯
	int                 				nFlashLatch;											// 补光灯延时时间(秒),延时时间范围：[10,300]

	char								szAudioFileName[MAX_PATH];						// 联动语音文件绝对路径
	BOOL								bAlarmBellEn;									// 警号使能
	BOOL								bAccessControlEn;								// 门禁使能
	DWORD								dwAccessControl;								// 门禁组数
	NET_EM_CFG_ACCESSCONTROLTYPE		emAccessControlType[CFG_MAX_ACCESSCONTROL_NUM];	// 门禁联动操作信息

	NET_CFG_TALKBACK_INFO				stuTalkback;									// 语音呼叫联动信息
	NET_CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// 电话报警中心联动信息
	int									nAlarmBellLatch;								// 警号输出延时时间(10-300秒)

	BOOL                                bReboot;                                        //重启使能TRUE:使能 FALSE:不使能
	int                                 nBeepTime;                                      //蜂鸣时长最大值为3600，0代表持续蜂鸣
} NET_CFG_ALARM_MSG_HANDLE;

// 联动的布控组
typedef struct tagNET_CFG_LINKGROUP_INFO
{
	BOOL 						bEnable;							// 布控组是否启用
	char						szGroupID[64];						// 布控组ID
	BYTE                		bySimilarity;                       // 相似度阈值
	BYTE						bReserved1[3];						// 字节对齐
	char						szColorName[32];						// 事件触发时绘制人脸框的颜色
	BOOL 						bShowTitle;							// 事件触发时规则框上是否显示报警标题
	BOOL 						bShowPlate;							// 事件触发时是否显示比对面板	
	NET_ALARM_MSG_HANDLE 		stuEventHandler;					// 报警联动
	BYTE						bReserved[512];						// 保留字段
}NET_CFG_LINKGROUP_INFO;

// 陌生人布防模式
typedef struct tagNET_CFG_STRANGERMODE_INFO
{
	BOOL 						bEnable;							// 模式是否启用
	char						szColorHex[8];						// 事件触发时绘制人脸框的颜色
	BOOL 						bShowTitle;							// 事件触发时规则框上是否显示报警标题
	BOOL 						bShowPlate;							// 事件触发时是否显示比对面板
	NET_ALARM_MSG_HANDLE 		stuEventHandler;					// 报警联动
	BYTE						bReserved[512];						// 保留字段	
}NET_CFG_STRANGERMODE_INFO;

// 校准框信息
typedef struct tagNET_CFG_CALIBRATEBOX_INFO
{
	POINTCOORDINATE     stuCenterPoint;                       // 校准框中心点坐标(点的坐标归一化到[0,8191]区间)
	float               fRatio;                               // 相对基准校准框的比率(比如1表示基准框大小，0.5表示基准框大小的一半)
}NET_CFG_CALIBRATEBOX_INFO;

// 物体尺寸
typedef struct tagNET_CFG_SIZE
{
	union
	{
		float				nWidth;			// 宽
		float				nArea;			// 面积
	};
	float					nHeight;		// 高
	
} NET_CFG_SIZE;

// 尺寸过滤器
typedef struct tagNET_CFG_SIZEFILTER_INFO
{
	int                   nCalibrateBoxNum;                       // 校准框个数
	NET_CFG_CALIBRATEBOX_INFO stuCalibrateBoxs[10]; 				  // 校准框(远端近端标定模式下有效)
	bool                bMeasureModeEnable;                       // 计量方式参数是否有效
	BYTE                bMeasureMode;                             // 计量方式,0-像素，不需要远端、近端标定, 1-实际长度，单位：米, 2-远端近端标定后的像素
	bool                bFilterTypeEnable;                        // 过滤类型参数是否有效
	// ByArea,ByRatio仅作兼容，使用独立的ByArea和ByRatio选项代替 2012/03/06
	BYTE				bFilterType;			 				  // 过滤类型:0:"ByLength",1:"ByArea", 2"ByWidthHeight"
	bool                bFilterMinSizeEnable;                     // 物体最小尺寸参数是否有效
	bool                bFilterMaxSizeEnable;                     // 物体最大尺寸参数是否有效
	bool                abByArea;
	bool                abMinArea;
	bool                abMaxArea;
	bool                abMinAreaSize;
	bool                abMaxAreaSize;
	bool                bByArea;                                  // 是否按面积过滤 通过能力ComplexSizeFilter判断是否可用
	NET_CFG_SIZE		stuFilterMinSize;						  // 物体最小尺寸 "ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效(远端近端标定模式下表示基准框的宽高尺寸)。
	NET_CFG_SIZE		stuFilterMaxSize;				          // 物体最大尺寸 "ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效(远端近端标定模式下表示基准框的宽高尺寸)。
	float               nMinArea;                                 // 最小面积
	float               nMaxArea;                                 // 最大面积
	NET_CFG_SIZE        stuMinAreaSize;                           // 最小面积矩形框尺寸 "计量方式"为"像素"时，表示最小面积矩形框的宽高尺寸；"计量方式"为"远端近端标定模式"时，表示基准框的最小宽高尺寸；
	NET_CFG_SIZE        stuMaxAreaSize;                           // 最大面积矩形框尺寸, 同上
	bool                abByRatio;
	bool                abMinRatio;
	bool                abMaxRatio;
	bool                abMinRatioSize;
	bool                abMaxRatioSize;
	bool                bByRatio;                                 // 是否按宽高比过滤 通过能力ComplexSizeFilter判断是否可用
	bool                bReserved1[2];
	double              dMinRatio;                                // 最小宽高比
	double              dMaxRatio;                                // 最大宽高比
	NET_CFG_SIZE        stuMinRatioSize;                          // 最小宽高比矩形框尺寸，最小宽高比对应矩形框的宽高尺寸。
	NET_CFG_SIZE        stuMaxRatioSize;                          // 最大宽高比矩形框尺寸，同上
	int                 nAreaCalibrateBoxNum;                     // 面积校准框个数
	NET_CFG_CALIBRATEBOX_INFO stuAreaCalibrateBoxs[10];			  // 面积校准框
	int                 nRatioCalibrateBoxs;                      // 宽高校准框个数
	NET_CFG_CALIBRATEBOX_INFO stuRatioCalibrateBoxs[10];			  // 宽高校准框
	bool                abBySize;                                 // 长宽过滤使能参数是否有效
	bool                bBySize;                                  // 长宽过滤使能
	BYTE				bReserved[518];							  // 保留字段	
}NET_CFG_SIZEFILTER_INFO;

// 传感器类型
typedef enum tagEM_SENSOR_TYPE
{
	EM_SENSOR_TYPE_UNKNOWN,		// 未知
	EM_SENSOR_TYPE_NC,			// 常闭
	EM_SENSOR_TYPE_NO,			// 常开
}EM_SENSOR_TYPE;

// 报警盒子配置
typedef struct tagNET_LOCAL_EXT_ALARM_INFO
{
	DWORD						dwSize;									// 结构体大小
	BOOL						bEnable;								// 使能开关
	char						szName[MAX_LOCAL_EXT_ALARM_NAME_LEN];	// 报警通道名称
	EM_SENSOR_TYPE				emSensorType;							// 传感器类型
	NET_CFG_ALARM_MSG_HANDLE	stuEventHandler;						// 报警联动	
}NET_LOCAL_EXT_ALARM_INFO;

// 火灾配置类型
typedef enum tagNET_EM_FIREWARNING_MODE_TYPE
{
	NET_EM_FIREWARNING_TYPE_PTZPRESET,		// 云台预置点模式（默认）	
	NET_EM_FIREWARNING_TYPE_SPACEEXCLUDE,	// 空间排除模式
} NET_EM_FIREWARNING_MODE_TYPE;

// 火灾预警模式配置 NET_EM_CFG_FIRE_WARNINGMODE
typedef struct tagNET_FIREWARNING_MODE_INFO
{
	DWORD							dwSize;								// 结构体大小
	NET_EM_FIREWARNING_MODE_TYPE	emFireWarningMode;					// 火灾预警模式
} NET_FIREWARNING_MODE_INFO;

// 火警检测类型
typedef enum tagNET_EM_FIREWARNING_DETECTMODE_TYPE
{
	NET_EM_FIREWARNING_DETECTMODE_TYPE_AUTO,			// 自动(默认)
	NET_EM_FIREWARNING_DETECTMODE_TYPE_NORMAL,		    // 正常
} NET_EM_FIREWARNING_DETECTMODE_TYPE;

// 检测目标
typedef enum tagNET_EM_FIREWARNING_DETECTTARGET_TYPE
{
	NET_EM_FIREWARNING_DETECTTARGET_TYPE_FIRE,		// 火点检测(默认)
	NET_EM_FIREWARNING_DETECTTARGET_TYPE_SMOKE,		// 吸烟检测
} NET_EM_FIREWARNING_DETECTTARGET_TYPE;

#define  MAX_FIREWARNING_DETECTRGN_NUM			32			// 最大火警区域检测的个数
#define  MAX_FIREWARNING_RULE_NUM				32			// 最大火警规则
#define  MAX_FIREWARNING_DETECTWND_NUM			8			// 最大火警检测窗口个数

// 火灾预警联动项
typedef struct tagNET_FIREWARN_EVENTHANDLE_INFO
{
	NET_CFG_TIME_SCHEDULE   stuTimeSection;										            // 报警时间段
	BOOL					bRecordEnable;													// 录像使能，必须同时有RecordChannels。使能为TRUE，且事件action为start开始录像，stop停止录像。如果FALSE，则不做录像
	int						nRecordChannelNum;												// 录像通道个数
	int						nRecordChannels[32];											// 录像通道号列表
	int						nRecordLatch;													// 录像延时时间（单位：秒）范围[10,300]
	BOOL					bAlarmOutEnable;												// 报警输出使能
	int						nAlarmOutChannelNum;											// 报警输出通道个数
	int						nAlarmOutChannels[32];											// 报警输出通道号列表
	int						nAlarmOutLatch;													// 报警输入停止后，输出延时时间（单位：秒）范围[10, 300]
 	int						nPtzLinkNum;													// 云台配置数   
	DH_PTZ_LINK				struPtzLink[16];												// 云台联动 
	BOOL					bPtzLinkEnable;													// 云台联动使能
	BOOL					bSnapshotEnable;												// 快照使能
	int						nSnapshotChannelNum;											// 快照通道个数
	int						nSnapshotChannels[32];											// 快照通道号列表
	BOOL					bMailEnable;													// 发送邮件，如果有图片，作为附件
	BYTE					byReserved[1024];												// 保留字节
} NET_FIREWARN_EVENTHANDLE_INFO;

// 火警检测窗口
typedef struct tagNET_FIREWARN_DETECTWND_INFO
{
	int				nRgnNum;												// 检测区域的个数
	BYTE            byReservedAlign[4];										// 保留字节
	INT64			nRegions[MAX_FIREWARNING_DETECTRGN_NUM];				// 检测区域
	NET_POSTIONF	stuPostion;												// 空间排除信息
	int				nTargetSize;											// 目标的尺寸(火警配置为:Normal有效,单位：像素)
	int				nSensitivity;											// 检测灵敏度（火警配置为:Normal有效）
	int				nWindowsID;												// 窗口ID
	char			szName[32];												// 窗口名称
	BYTE			byReserved[256];										// 保留字节
} NET_FIREWARN_DETECTWND_INFO;

// 火灾预警规则信息
typedef struct tagNET_FIREWARN_RULE_INFO
{
	BOOL							bEnable;								// 火灾预警功能是否开启
	int								nPresetId;								// 预置点编号,火灾预警模式为预置点模式生效
	int								nRow;									// 火灾检测区域的行数
	int								nCol;									// 火灾检测区域的列数
	NET_EM_FIREWARNING_DETECTMODE_TYPE		emFireWarningDetectMode;		// 火警检测模式
	NET_EM_FIREWARNING_DETECTTARGET_TYPE	emFireWarningDetectTragetType;	// 火警检测目标类型
	BOOL							bTimeDurationEnable;					// 是否启用持续时间
	int								nFireDuration;							// 观察火情持续时间，单位秒。水平旋转组检测火点时，为避免同一点重复检测，
																			// 设置超时时间，超过此时间，跳过此点
	
	NET_FIREWARN_EVENTHANDLE_INFO	stuEventHandler;						// 火警联动信息
	int								nDetectWindowNum;						// 窗口个数
	NET_FIREWARN_DETECTWND_INFO		stuDetectWnd[MAX_FIREWARNING_DETECTWND_NUM]; // 火警检测窗口
	BYTE							byReserved[256];						// 保留字节
} NET_FIREWARN_RULE_INFO;

// 火灾预警配置(结构体较大，建议用New分配内存) NET_EM_CFG_FIRE_WARNING
typedef struct tagNET_FIRE_WARNING_INFO
{
	DWORD							dwSize;																// 结构体大小
	int								nFireWarnRuleNum;													// 火灾预警配置个数
	NET_FIREWARN_RULE_INFO			stuFireWarnRule[MAX_FIREWARNING_RULE_NUM];							// 火灾预警配置规则
} NET_FIRE_WARNING_INFO;

// 热点报警条件
typedef enum tagEM_HOT_ALARM_CONDITION
{
    EM_HOT_ALARM_CONDITION_UNKNOWN,						               // 未知
    EM_HOT_ALARM_CONDITION_ABOVE_MAX,								   // 高于高温阈值
    EM_HOT_ALARM_CONDITION_ABOVE_MAX_AND_BELOW_MIN,					   // 最低温低于低温阈值，最高温高于高温阈值(冷点报警条件也取此值时生效)
} EM_HOT_ALARM_CONDITION;

// 冷点报警条件
typedef enum tagEM_COLD_ALARM_CONDITION
{
    EM_COLD_ALARM_CONDITION_UNKNOWN,						           // 未知
    EM_COLD_ALARM_CONDITION_BELOW_MIN,								   // 低于低温阈值
    EM_COLD_ALARM_CONDITION_ABOVE_MAX_AND_BELOW_MIN,				   // 最低温低于低温阈值，最高温高于高温阈值(热点报警条件也取此值时生效)
} EM_COLD_ALARM_CONDITION;

// 热冷点报警配置(结构体较大，建议用New分配内存) NET_EM_CFG_HOT_COLD_SPOT_WARNING
typedef struct tagNET_HOT_COLD_SPOT_WARNING_INFO
{
    DWORD							dwSize;								// 结构体大小
    BOOL                            bHotAlarmEnable;                    // 热点报警使能
    BOOL                            bColdAlarmEnable;                   // 冷点报警使能
    EM_HOT_ALARM_CONDITION			emHotAlarmCondition;				// 热点报警条件
    EM_COLD_ALARM_CONDITION			emColdAlarmCondition;				// 冷点报警条件
    BYTE				            byReserved[4];		                // 字节对齐
    double                          dHotThreshold;                      // 热点报警温度阈值
    double                          dColdThreshold;                     // 冷点报警温度阈值
    BOOL                            bHotSpotLinkEnable;                 // 热点联动使能
    BOOL                            bColdSpotLinkEnable;                // 冷点联动使能
    NET_CFG_ALARM_MSG_HANDLE        stuEventHandler;		            // 报警联动     
} NET_HOT_COLD_SPOT_WARNING_INFO;

// 报警输出模式
typedef enum tagEM_ALARM_OUT_MODE
{
	EM_ALARM_OUT_MODE_UNKNOWN = -1,						// 未知
	EM_ALARM_OUT_MODE_AUTO,								// 自动
	EM_ALARM_OUT_MODE_FORCED,							// 强制报警
	EM_ALARM_OUT_MODE_CLOSE,							// 关闭报警
} EM_ALARM_OUT_MODE;

// 前端相机警号配置 (对应枚举 NET_EM_CFG_REMOTE_ALARM_BELL)
typedef struct tagNET_CFG_REMOTE_ALARM_BELL_INFO
{
	DWORD							dwSize;							// 结构体大小
	EM_ALARM_OUT_MODE				emMode;							// 报警输出模式
} NET_CFG_REMOTE_ALARM_BELL_INFO;
 
// 门禁黑名单报警配置
typedef struct tagNET_CFG_ACCESSCTL_BLACKLIST
{
    DWORD                           dwSize;                             
    BOOL                            bEnable;                               // 配置使能   
}NET_CFG_ACCESSCTL_BLACKLIST;

typedef struct tagNET_CFG_VSP_HONEYWELL_INFO
{
	DWORD                   dwSize;                 //结构体大小
	BOOL                    bEnable;                //使能
	char                    szIPAddress[64];        //服务器IP地址
	int                     nPort;                  //服务器端口
	char                    szUserName[128];        //用户名
	char                    szPassword[128];        //密码
	char					szUserCode[8];			//用户码
}NET_CFG_VSP_HONEYWELL_INFO;

// 日志打包方式
typedef struct tagNET_CFG_LOG_GROUP_INFO
{
	UINT				nSize;			// 数据量大小，对大值：1400
	UINT				nBatch;			// 日志条数，最大值：20 默认：1
	UINT				nDelay;			// 队列中延时时间, 最大值：60000 默认：60000 单位：毫秒
	BYTE				byReserved[32];		// 保留字节
}NET_CFG_LOG_GROUP_INFO;
// 服务器信息配置
typedef struct tagNET_CFG_LOG_SERVER_INFO
{
	BOOL						bEnable;		// 服务器使能
	char						szIP[40];		// IP
	UINT						nPort;			// 端口
	UINT						nProtocol;		// 协议类型  0: TCP 1: UDP
	UINT						nSerial;		// 关联串口号，最大值：0xFFFF。第1位(0x0001)对应串口1；第2位(0x0002)对应串口2；第3位(0x0004)对应串口3；依次类推
	NET_CFG_LOG_GROUP_INFO		stuLogGroup;	// 日志打包方式
	BYTE						byReserved[256];		// 保留字节
}NET_CFG_LOG_SERVER_INFO;
// 追加配置
typedef struct tagNET_CFG_LOG_APPEND_INFO
{
	BOOL		bSequence;			// 自增序列号使能
	BOOL		bDate;				// 日期字段使能
	BOOL		bTime;				// 时间字段使能
	char		szCustom[32];		// 自定义字段
	BYTE		byReserved[32];		// 保留字节
}NET_CFG_LOG_APPEND_INFO;
// 串口服务器日志推送服务（对应枚举 NET_EM_CFG_SERIAL_PUSH_LOG）
typedef struct tagNET_CFG_SERIALPUSHLOG_INFO
{
	DWORD						dwSize;				// 结构体大小
	BOOL						bEnable;			// 使能
	NET_CFG_LOG_SERVER_INFO		stuServerInfo[16];	// 服务器信息
	int							nServerCount;		// 服务器信息个数
	NET_CFG_LOG_APPEND_INFO		stuAppendInfo[16];	// 追加信息
	int							nAppendCount;		// 追加信息格式
}NET_CFG_SERIALPUSHLOG_INFO;


// CVI 外部报警信息
typedef struct tagNET_CFG_COAXIAL_ALARMLOCAL
{
	BOOL							bEnable;				// 使能
	char							szName[64];				// 报警通道名
	NET_SENSE_METHOD				emSenseMethod;			// 传感器类型
	NET_ALARM_MSG_HANDLE			stuEventHandler;		// 事件联动信息	
	BYTE							byReserved[1024];		// 预留字节	
}NET_CFG_COAXIAL_ALARMLOCAL;

// CVI外部报警配置
typedef struct tagNET_COAXIAL_ALARMLOCAL_INFO
{
	DWORD							dwSize;					// 结构体大小
	NET_CFG_COAXIAL_ALARMLOCAL*		pstuAlaramCfg;			// 配置信息
	int								nCount;					// pstuAlaramCfg 个数
	int								nCountRet;				// 实际返回的配置个数
}NET_COAXIAL_ALARMLOCAL_INFO;

// 注册升级文件处理
CLIENT_NET_API LLONG CALL_METHOD CLIENT_attachAIOFileProc(LLONG lLoginID, const NET_IN_ATTACH_AIO* pstInParam, NET_OUT_ATTACH_AIO *pstOutParam, int nWaitTime);

// 注销文件处理,lAttachHandle是CLIENT_attachAIOFileProc返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_detachAIOFileproc(LLONG lAttachHandle);

// 设置NVR广告
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SetAIOAdvert(LLONG lLoginID, const NET_IN_SET_ADVERT* pstInParam, NET_OUT_SET_ADVERT *pstOutParam, int nWaitTime);

// NVR截屏
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AIOScreen(LLONG lLoginID, const NET_IN_AIO_SCREEN* pstInParam, NET_OUT_AIO_SCREEN *pstOutParam, int nWaitTime);

//  开始异步文件上传调函数原形,lUploadFileHandle 为 CLIENT_StartUploadAIOFile 接口返回值, nError是失败的错误码
typedef void (CALLBACK *fUploadAIOFileCallBack) (LLONG lUploadFileHandle, int nTotalSize, int nSendSize, LDWORD dwUser, int nError);

// 开始异步文件上传
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartUploadAIOFile(LLONG lLoginID, const NET_IN_UPLOAD_AIO_FILE* pInParam, NET_OUT_UPLOAD_AIO_FILE* pOutParam, fUploadAIOFileCallBack cbUploadFile, LDWORD dwUser);

// 停止异步文件上传
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopUploadAIOFile(LLONG lUploadFileID);

// 控制安卓adb开启或关闭
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ControlAndroidAdb(LLONG lLoginID, const NET_IN_CONTROL_ANDROID_ADB* pstInParam, NET_OUT_CONTROL_ANDROID_ADB *pstOutParam, int nWaitTime);

// 获取配置信息(szOutBuffer内存由用户申请释放, 具体见枚举类型说明)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szOutBuffer, DWORD dwOutBufferSize, int waittime=NET_INTERFACE_DEFAULT_TIMEOUT, void *reserve = NULL);

// 设置配置信息(szInBuffer内存由用户申请释放, 具体见枚举类型说明)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                                         void* szInBuffer, DWORD dwInBufferSize, int waittime=NET_INTERFACE_DEFAULT_TIMEOUT, int *restart = NULL, void *reserve = NULL);
														 
// 设置网络自适应编码缓冲策略入参
typedef struct tagNET_IN_BUFFER_POLICY
{
    DWORD                   dwSize;             
    DH_RealPlayType         emRealPlayType;          // 码流类型。只支持主码流，辅码流，自适应测试码流
    UINT                    nPolicy;                 // 缓冲策略，0默认，1流畅，2实时
}NET_IN_BUFFER_POLICY; 

// 设置编码缓冲策略,pInBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetRealplayBufferPolicy(LLONG lPlayHandle,NET_IN_BUFFER_POLICY* pInBuf,int nWaitTime);
  
//////////////////////////////////////////////////////////////////////////
// TestOSD 操作类型
typedef enum tagEM_TESTOSD_OPERATE_TYPE
{
    EM_TESTOSD_ADD_TEXT,          // 添加文字信息 对应 NET_IN_TESTOSD_ADD_TEXT 和 NET_OUT_TESTOSD_ADD_TEXT
    EM_TESTOSD_GET_TEXT,          // 获取文字信息 对应 NET_IN_TESTOSD_GET_TEXT 和 NET_OUT_TESTOSD_GET_TEXT
    EM_TESTOSD_MODIFY_TEXT,       // 修改文字信息 对应 NET_IN_TESTOSD_MODIFY_TEXT 和 NET_OUT_TESTOSD_MODIFY_TEXT
    EM_TESTOSD_DELETE_TEXT,       // 删除文字信息 对应 NET_IN_TESTOSD_DELETE_TEXT 和 NET_OUT_TESTOSD_DELETE_TEXT
    EM_TESTOSD_ADD_PICTURE,       // 增加图片信息 对应 NET_IN_TESTOSD_ADD_PIC 和 NET_OUT_TESTOSD_ADD_PIC
    EM_TESTOSD_GET_PICTURE,       // 获取图片信息 对应 NET_IN_TESTOSD_GET_PIC 和 NET_OUT_TESTOSD_GET_PIC
    EM_TESTOSD_DELETE_PICTURE,    // 删除图片信息 对应 NET_IN_TESTOSD_DELETE_PIC 和 NET_OUT_TESTOSD_DELETE_PIC
}EM_TESTOSD_OPERATE_TYPE;

// 文本信息
typedef struct tagNET_TEXT_OSD
{   
    char                    szText[DH_COMMON_STRING_256];   // 文本内容
    DH_POINT                stuPoint;                       // 文本位置
	NET_COLOR_RGBA			stuTextColor;					// 文本颜色
	int						nFontSize;						// 文本字体大小 0-正常大小 1-小字体 2-大号字体
    BYTE                    byReserved[44];                 // 保留字节
}NET_TEXT_OSD;

// 图片类型
typedef enum tagEM_OSDPIC_TYPE
{
    EM_OSDPIC_UNKNOWN,                                      // 未知照片
    EM_OSDPIC_HEADONFACE,                                   // 正面照
    EM_OSDPIC_SIDEFACE,                                     // 侧面照
    EM_OSDPIC_MAP,                                          // 地图
}EM_OSDPIC_TYPE;

// 图片信息
typedef struct tagNET_PICTURE_OSD
{
    EM_OSDPIC_TYPE          emPictureType;                  // 图片类型
	NET_RECT				stuPictureLocation;				// 图片位置
    BYTE                    byReserved[48];                 // 保留字节
}NET_PICTURE_OSD;

// 添加文字信息入参 
typedef struct tagNET_IN_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize; 
    int                     nMaxCount;                      // 输入最大有效个数
    NET_TEXT_OSD            *pstuTextInfo;                  // 文字信息, 用户申请, 个数为 nMaxCount   
}NET_IN_TESTOSD_ADD_TEXT;

// 添加文字信息出参 
typedef struct tagNET_OUT_TESTOSD_ADD_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    int                     *pnTextID;                      // 文字信息对应的ID号, 用户申请, 个数为 nMaxCount
    int                     *pnReturnCode;                  // 操作返回码, 0-成功 1-失败, 用户申请, 个数为 nMaxCount
}NET_OUT_TESTOSD_ADD_TEXT;

// 获取文字信息入参
typedef struct tagNET_IN_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // 输入最大有效个数
    int                     *pnTextID;                      // 文字信息对应的ID号, 用户申请, 个数为 nMaxCount
}NET_IN_TESTOSD_GET_TEXT;

// 获取文字信息出参
typedef struct tagNET_OUT_TESTOSD_GET_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    NET_TEXT_OSD            *pstuTextInfo;                  // 文字信息, 用户申请, 个数为 nMaxCount
}NET_OUT_TESTOSD_GET_TEXT;

// 修改文字信息入参
typedef struct tagNET_IN_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // 输入最大有效个数
    int                     *pnTextID;                      // 文字信息对应的ID号, 用户申请, 个数为 nMaxCount
    NET_TEXT_OSD            *pstuTextInfo;                  // 文字信息, 用户申请, 个数为 nMaxCount
}NET_IN_TESTOSD_MODIFY_TEXT;

// 修改文字信息出参
typedef struct tagNET_OUT_TESTOSD_MODIFY_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    int                     *pnReturnCode;                  // 操作返回码, 0-成功 1-失败 用户申请, 个数为入参的nValidCount
}NET_OUT_TESTOSD_MODIFY_TEXT;

// 删除文字信息入参
typedef struct tagNET_IN_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // 输入最大有效个数
    int                     *pnTextID;                      // 文字信息对应的ID号
}NET_IN_TESTOSD_DELETE_TEXT;

// 删除文字信息出参
typedef struct tagNET_OUT_TESTOSD_DELETE_TEXT
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    int                     *pnReturnCode;                  // 操作返回码, 0-成功 1-失败
}NET_OUT_TESTOSD_DELETE_TEXT;

// 添加图片入参
typedef struct tagNET_IN_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // 输入最大有效个数
    char                    (*pszFilePath)[MAX_PATH];       // 图片存储完整路径
    NET_PICTURE_OSD         *pstuPicture;
}NET_IN_TESTOSD_ADD_PIC;

// 添加图片出参
typedef struct tagNET_OUT_TESTOSD_ADD_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    int                     *pnReturnCode;                  // 操作返回码, 0-成功 1-失败
}NET_OUT_TESTOSD_ADD_PIC;

// 获取图片入参
typedef struct tagNET_IN_TESTOSD_GET_PIC
{
    DWORD                   dwSize;
    int                     nCount;                         // 获取图片张数
}NET_IN_TESTOSD_GET_PIC;

// 获取图片出参
typedef struct tagNET_OUT_TESTOSD_GET_PIC
{
    DWORD                   dwSize;    
    int                     nReturnCount;                   // 返回有效个数
    char                    (*pszFilePath)[MAX_PATH];       // 图片存储完整路径
    NET_PICTURE_OSD         *pstuPicture;
}NET_OUT_TESTOSD_GET_PIC;

// 删除图片入参
typedef struct tagNET_IN_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nMaxCount;                      // 输入最大有效个数
    char                    (*pszFilePath)[MAX_PATH];       // 图片存储完整路径    
}NET_IN_TESTOSD_DELETE_PIC;

// 删除图片 出参
typedef struct tagNET_OUT_TESTOSD_DELETE_PIC
{
    DWORD                   dwSize;
    int                     nReturnCount;                   // 返回有效个数
    int                     *pnReturnCode;                  // 操作返回码, 0-成功 1-失败
}NET_OUT_TESTOSD_DELETE_PIC;


//获取报警事件日志入参
typedef struct tagNET_IN_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	UINT 	                nEventID;				        // 事件ID
}NET_IN_GET_ALARM_EVENT_LOG;

// 获取报警事件日志出参
typedef struct tagNET_OUT_GET_ALARM_EVENT_LOG
{
	DWORD                   dwSize;
	DWORD			        dwAlarmType;			   // 报警事件类型	
	BYTE 			       *byAlarmData;               // 报警事件数据，由用户申请,最少申请2*1024字节
	int 			        nMaxDataLen;		       // 报警事件数据申请最大长度
	int						nRetDataLen;               // 实际返回的事件长度
}NET_OUT_GET_ALARM_EVENT_LOG;

// 获取报警事件日志
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetEventLog(LLONG lLoginID, const NET_IN_GET_ALARM_EVENT_LOG *pstuInParam, NET_OUT_GET_ALARM_EVENT_LOG *pstuOutParam, int nWaitTime);

// TestOSD操作接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateTestOSD(LLONG lLoginID, EM_TESTOSD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// 锁定和解锁组合通道和逻辑通道入参
typedef struct tagNET_IN_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
    BOOL                    bLock;                         // TRUE锁定，FALSE 解锁
    int                     nClassRoomID;                  // 教室ID号        
    int                     nLogicChannel;                 // 逻辑通道号
}NET_IN_COURSECOMPOSITE_LOCK_CONTROL;

// 锁定和解锁组合通道和逻辑通道出参
typedef struct tagNET_OUT_COURSECOMPOSITE_LOCK_CONTROL
{
    DWORD                   dwSize;
}NET_OUT_COURSECOMPOSITE_LOCK_CONTROL;

// 获取锁定状态入参
typedef struct tagNET_IN_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;
    int                     nClassRoomID;                  // 教室ID号
    int                     nLogicChannel;                 // 逻辑通道号
}NET_IN_COURSECOMPOSITE_GET_LOCKINFO;

// 获取锁定状态出参
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_LOCKINFO
{
    DWORD                   dwSize;             
    BOOL                    bState;                        // 锁定状态
}NET_OUT_COURSECOMPOSITE_GET_LOCKINFO;

// 获取组合通道信息入参
typedef struct tagNET_IN_COURSECOMPOSITE_GET_INFO
{
    DWORD                   dwSize;                        
    int                     nClassRoomId;                  // 教室ID号
}NET_IN_COURSECOMPOSITE_GET_INFO;

// 录制模式
typedef enum tagEM_COMPOSITECHANNEL_MODE
{
    EM_COMPOSITECHANNEL_CUSTOMER = -1,                      // 自定义
    EM_COMPOSITECHANNEL_INVALID,                            // 无效
    EM_COMPOSITECHANNEL_MOVIE,                              // 电影模式
    EM_COMPOSITECHANNEL_NORMALCY,                           // 常态模式
    EM_COMPOSITECHANNEL_PICK,                               // 精品模式
}EM_COMPOSITECHANNEL_MODE;

// 组合通道信息
typedef struct tagNET_COMPOSITECHANNEL_INFO
{
    char                        szCourseName[DH_COMMON_STRING_128];     // 课程名称
    char                        szTeacherName[DH_COMMON_STRING_64];     // 教师名称
    int						    nCompositeChannelMode;                 // 录制模式; 0:无效；1:电影模式； 2:常态模式； 3:精品模式； <0:用户自定义模式
    int                         nChannelNum;                            // 逻辑通道数量
    BOOL                        bCanStream[MAX_COURSE_LOGIC_CHANNEL];   // 是否能拉流，下标对应为逻辑通道号
    BYTE                        byReserved[256];                                                  
}NET_COMPOSITECHANNEL_INFO;

// 获取组合通道信息出参
typedef struct tagNET_OUT_COURSECOMPOSITE_GET_INFO
{
    DWORD                       dwSize;     
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // 组合通道信息
}NET_OUT_COURSECOMPOSITE_GET_INFO;

// 设置组合通道信息入参
typedef struct tagNET_IN_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
    int                         nClassRoomId;                            // 教室ID号
    NET_COMPOSITECHANNEL_INFO   stuChannelInfo;                          // 组合通道信息
}NET_IN_COURSECOMPOSITE_SET_INFO;

// 设置组合通道信息出参
typedef struct tagNET_OUT_COURSECOMPOSITE_SET_INFO
{
    DWORD                       dwSize;                        
}NET_OUT_COURSECOMPOSITE_SET_INFO;

// 组合通道信息更新到time入参
typedef struct tagNET_IN_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize;      
    int                         nClassRoomId;                        // 教室ID号
    NET_TIME                    stuTime;                             // 查询时间                     
}NET_IN_COURSECOMPOSITE_UPDATE_INFO;

// 组合通道信息更新到time出参
typedef struct tagNET_OUT_COURSECOMPOSITE_UPDATE_INFO
{
    DWORD                       dwSize;                          
}NET_OUT_COURSECOMPOSITE_UPDATE_INFO;

// 录播主机组合通道操作
typedef enum tagEM_COURSECOMPOSITE_OPERATE_TYPE
{
    EM_COURSECOMPOSITE_TYPE_LOCK_CONTROL,                   //控制组合通道与逻辑通道，对应结构体pInParam = NET_IN_COURSECOMPOSITE_LOCK_CONTROL,pOutParam = NET_OUT_COURSECOMPOSITE_LOCK_CONTROL
    EM_COURSECOMPOSITE_TYPE_GET_LOCKINFO,                   //获取组合通道与逻辑通道的锁定信息，对应结构体pInParam = NET_IN_COURSECOMPOSITE_GET_LOCKINFO，pOutParam = NET_OUT_COURSECOMPOSITE_GET_LOCKINFO 
    EM_COURSECOMPOSITE_TYPE_GET_INFO,                       //获取组合通道信息,对应结构体pInParam = NET_IN_COURSECOMPOSITE_GET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_GET_INFO 
    EM_COURSECOMPOSITE_TYPE_SET_INFO,                       //设置组合通道信息,对应结构体pInParam = NET_IN_COURSECOMPOSITE_SET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_SET_INFO 
    EM_COURSECOMPOSITE_TYPE_UPDATE_INFO,                    //将组合通道信息更新到time时的信息，对应结构体 pInParam = NET_IN_COURSECOMPOSITE_UPDATE_INFO, pOutParam = NET_OUT_COURSECOMPOSITE_UPDATE_INFO
}EM_COURSECOMPOSITE_OPERATE_TYPE;

CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannel(LLONG lLoginID, EM_COURSECOMPOSITE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// 录播主机窗口最大个数
#define NET_MAX_WINDOWS_NUMBER	64
// 录播主机模式最大个数
#define NET_MAX_MODE_NUMBER		64

// 录播主机窗口信息
typedef struct tagNET_COMPOSITECHANNELMODE_WINDOWS
{
	DH_RECT					stRect;					// 窗口坐标, 采用8192坐标体系
	int						nLogicChannel;			// 逻辑通道号, 为-1表示此窗口没有绑定通道
	int						nZOrder;				// Z序
	BYTE                    byReserved[64];         // 保留字节
}NET_COMPOSITECHANNELMODE_WINDOWS;

// 录播主机模式信息
typedef struct tagNET_COMPOSITECHANNELMODE_INFO
{
	char									szName[DH_COMMON_STRING_128];			// 模式名称
	int										nWindowNum;								// 实际窗口个数
	NET_COMPOSITECHANNELMODE_WINDOWS		stWindows[NET_MAX_WINDOWS_NUMBER];		// 窗口信息
	BYTE									byReserved[64];							// 保留字节
}NET_COMPOSITECHANNELMODE_INFO;

// 录播主机添加模式入参
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD							dwSize;								// 结构体大小
    int								nCount;								// 要添加的模式数目
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// 模式信息
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// 录播主机添加模式返回信息
typedef struct tagNET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT
{
	int						nMode;					// 模式, 0 无效, 1 电影模式, 2 常态模式, 3 精品模式, 小于0 自定义模式
	int						nReturnCode;			// 返回码, 1 成功, 2 失败, 3 已满, 4 资源不足
	BYTE                    byReserved[64];         // 保留字节
}NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT;

// 录播主机添加模式出参
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
{
    DWORD											dwSize;								// 结构体大小
	int												nCount;								// 实际返回个数
	NET_COURSECOMPOSITE_CHANNEL_MODE_ADD_RESULT		stResult[NET_MAX_MODE_NUMBER];		// 返回数组
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD;

// 录播主机删除模式入参
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;							// 结构体大小
	int						nModeNum;						// 删除的模式个数
	int						nMode[NET_MAX_MODE_NUMBER];		// 删除的模式编号
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// 录播主机删除模式出参
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
{
	DWORD					dwSize;									// 结构体大小
	int						nReturnNum;								// 删除的模式个数
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// 返回码: 1 成功, 2 失败
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE;

// 录播主机修改模式入参
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY 
{
	DWORD							dwSize;								// 结构体大小
	int								nModeNum;							// 修改的模式个数
	int								nMode[NET_MAX_MODE_NUMBER];			// 模式编号
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// 模式信息
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// 录播主机修改模式出参
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
{
	DWORD					dwSize;									// 结构体大小
	int						nReturnNum;								// 修改的模式个数, 和修改的模式个数相同
	int						nReturnCode[NET_MAX_MODE_NUMBER];		// 返回码: 1 成功, 2 失败, 3, 已满, 4 资源不足
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY;

// 录播主机获取模式入参
typedef struct tagNET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET 
{
	DWORD					dwSize;					// 结构体大小
	int						nCount;					// 要获取的模式个数
}NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET;

// 录播主机获取模式出参
typedef struct tagNET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
{
	DWORD							dwSize;								// 结构体大小
	int								nReturnNum;							// 实际获取的模式个数
	int								nMode[NET_MAX_MODE_NUMBER];			// 模式编号
	NET_COMPOSITECHANNELMODE_INFO	stModeInfo[NET_MAX_MODE_NUMBER];	// 模式信息
}NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET;

// 录播主机组合通道模式操作
typedef enum tagNET_COURSECOMPOSITE_MODE_OPERATE_TYPE
{
    NET_COURSECOMPOSITE_MODE_ADD,                   // 添加模式,对应结构体pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD,	 pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
	NET_COURSECOMPOSITE_MODE_DELETE,                // 删除模式,对应结构体pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
	NET_COURSECOMPOSITE_MODE_MODIFY,                // 修改模式,对应结构体pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY, pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
	NET_COURSECOMPOSITE_MODE_GET,                   // 获取模式,对应结构体pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET,	 pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
}NET_COURSECOMPOSITE_MODE_OPERATE_TYPE;

// 录播主机组合通道模式操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseCompositeChannelMode(LLONG lLoginID, NET_COURSECOMPOSITE_MODE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

///////////////////////////////////////////////////////////////////////
#define NET_UPGRADE_COUNT_MAX    256  //最大升级个数

//设备制造商
typedef enum tagENUM_VENDOR_TYPE
{
    ENUM_VENDOR_TYPE_UNKNOWN,              //未知
	ENUM_VENDOR_TYPE_GENERAL,              //General 
	ENUM_VENDOR_TYPE_DH,                   //DH 
	ENUM_VENDOR_TYPE_OEM,                  //OEM
	ENUM_VENDOR_TYPE_LC,				   //LC
	ENUM_VENDOR_TYPE_EZIP,				   //EZIP
}ENUM_VENDOR_TYPE;

//视频制式
typedef enum tagENUM_STANDARD_TYPE
{
    ENUM_STANDARD_TYPE_UNKNOWN,              //未知
	ENUM_STANDARD_TYPE_PAL,                  //P-PAL
	ENUM_STANDARD_TYPE_NTSC,                 //N-NTSC
	ENUM_STANDARD_TYPE_PAL_NTSC,             //PN-PAL/NTSC默认P制
	ENUM_STANDARD_TYPE_NTSC_PAL,             //NP-NTSC/PAL默认N制
	ENUM_STANDARD_TYPE_SECAM,                //S-SECAM
}ENUM_STANDARD_TYPE;

//获取云升级信息入参
typedef struct tagNET_IN_UPGRADER_GETSERIAL
{   
    DWORD               dwSize;					// 此结构体大小
} NET_IN_UPGRADER_GETSERIAL;


//云升级信息
typedef struct tagNET_UPGRADER_SERIAL_INO
{
    ENUM_VENDOR_TYPE    emVendor;               //厂商    
    ENUM_STANDARD_TYPE  emStandard;             //视频制式
    NET_TIME_EX  stuBuild;                      //发布日期
    char    szChip[DH_COMMON_STRING_16];        //可升级的程序名
    char    szSerial[DH_COMMON_STRING_256];     // 内部型号
    char    szLanguage[DH_COMMON_STRING_128];   //语言
    char    szSn[DH_COMMON_STRING_64];          // 序列号
    char    szSWVersion[DH_COMMON_STRING_64];   // 软件版本    
    char    szTag[DH_COMMON_STRING_256];        //自定义标记
    char    szTag2[DH_COMMON_STRING_256];       //自定义标记2
    char    reserved[1024];                         
}NET_UPGRADER_SERIAL_INO;

#define MAX_UPGRADER_SERIAL_INFO  8

//获取云升级信息出参
typedef struct tagNET_OUT_UPGRADER_GETSERIAL
{   
    DWORD                     dwSize;					               // 此结构体大小
    NET_UPGRADER_SERIAL_INO   stuSerialInfo[MAX_UPGRADER_SERIAL_INFO]; // 云升级信息
    int                       nRetNum;                                 // 返回个数
} NET_OUT_UPGRADER_GETSERIAL;

//从设备获取信息，用于向大华云确认是否有升级包
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetUpdateSerial(LLONG lLoginID, NET_IN_UPGRADER_GETSERIAL *pstuInGetSerial, NET_OUT_UPGRADER_GETSERIAL *pstuOutGetSerial, int nWaitTime);

// 云升级软件检查入参
typedef struct tagNET_IN_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    ENUM_VENDOR_TYPE       emVendor;                          //厂商
    ENUM_STANDARD_TYPE     emStandard;                        //视频制式
    NET_TIME_EX            stuBuild;                          //编译时间，用于比较版本
    char                   szUrl[DH_COMMON_STRING_1024];      // 云URL
    char                   szClass[DH_COMMON_STRING_64];      // 设备大类
    char                   szSerial[DH_COMMON_STRING_256];    // 设备硬件信号系列
    char                   szLanguage[DH_COMMON_STRING_128];  // 语言
    char                   szSN[DH_COMMON_STRING_64];         // 设备序列号
    char                   szSWVersion[DH_COMMON_STRING_64];  // 版本号，用于显示
    char                   szTag1[DH_COMMON_STRING_256];      // 预留字段，可用于后续定制或扩展
    char                   szTag2[DH_COMMON_STRING_256];        // 预留字段，可用于后续定制或扩展
    char                   szAccessKeyId[DH_COMMON_STRING_128];//Access Key ID
    char                   szSecretAccessKey[DH_COMMON_STRING_128];//Secret Access Key
}NET_IN_CLOUD_UPGRADER_CHECK;

// 云升级软件检查出参
typedef struct tagNET_OUT_CLOUD_UPGRADER_CHECK
{
    DWORD                  dwSize;
    BOOL                   bHasNewVersion;                  // 是否有可升级版本
    char                   szVersion[DH_COMMON_STRING_64];  //版本信息
    char                   szAttention[DH_COMMON_STRING_1024]; // 提醒设备升级的提示信息
    char                   szPackageUrl[DH_COMMON_STRING_1024]; // 设备升级包的URL
	char 			       szPackageId[DH_COMMON_STRING_64];    //升级包ID
}NET_OUT_CLOUD_UPGRADER_CHECK;

// 检查云端是否有可升级软件, 使用HTTP协议
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderCheck(NET_IN_CLOUD_UPGRADER_CHECK *pIn, NET_OUT_CLOUD_UPGRADER_CHECK *pOut, DWORD dwWaitTime);

//云下载状态
typedef enum tagemCloudDownloadState
{
    emCloudDownloadState_Unknown,            //未知
    emCloudDownloadState_Success,            //云下载成功(需要关闭句柄)
    emCloudDownloadState_Failed,             //云下载失败(不需要关闭句柄，会不断尝试下载)
    emCloudDownloadState_Downloading,        //正在下载中
    emCloudDownloadState_NoEnoughDiskSpace,  //磁盘空间不足
}emCloudDownloadState;

//云下载回调函数指针
typedef void (CALLBACK *fCloudDownload_Process_callback)(LLONG lDownHandle, emCloudDownloadState emState, double dwDownloadSpeed, DWORD dwProgressPercentage, LDWORD dwUser);

// 云升级下载升级包入参
typedef struct tagNET_IN_CLOUD_UPGRADER_DOWN
{
    DWORD                               dwSize;
    char                                szPackageUrl[DH_COMMON_STRING_1024]; // 设备升级包的URL
    char                                szSaveFile[DH_COMMON_STRING_1024];    //保存文件名
    fCloudDownload_Process_callback     pfProcessCallback;                   //进度回调
    LDWORD                              dwUser;                              //回调用户数据
}NET_IN_CLOUD_UPGRADER_DOWN;

// 云升级下载升级包出参
typedef struct tagNET_OUT_CLOUD_UPGRADER_DOWN
{
    DWORD                  dwSize;
}NET_OUT_CLOUD_UPGRADER_DOWN;

//云 下载升级软件, 使用HTTP协议
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CloudUpgraderDownLoad(NET_IN_CLOUD_UPGRADER_DOWN *pIn, NET_OUT_CLOUD_UPGRADER_DOWN *pOut);

//停止云下载, 使用HTTP协议
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderStop(LLONG lDownloadHandle);

//暂停云下载, 使用HTTP协议
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderPause(LLONG lDownloadHandle, BOOL bPause);

//升级结果
typedef enum tagNET_UPGRADE_REPORT_RESULT
{
    NET_UPGRADE_REPORT_RESULT_UNKNWON,         //未知
    NET_UPGRADE_REPORT_RESULT_SUCCESS,         //成功
    NET_UPGRADE_REPORT_RESULT_FAILED,          //失败
}NET_UPGRADE_REPORT_RESULT;

//上报升级结果结构体
typedef struct tagNET_UPGRADE_REPORT
{
    int     nDeviceNum;                                                 //设备个数
    char    szDevSerial[NET_UPGRADE_COUNT_MAX][MAX_COMMON_STRING_64];   // 序列号
    char    szPacketID[MAX_COMMON_STRING_128];                          //升级包ID
    NET_UPGRADE_REPORT_RESULT emResult;                                 //升级结果
    char    szCode[MAX_COMMON_STRING_128];                              // 错误码信息      
    char    reserved[256];
}NET_UPGRADE_REPORT;

//上报升级结果入参
typedef struct tagNET_IN_UPGRADE_REPORT
{
    DWORD                   dwSize;
    int                     nCount;                                  // 升级包个数
    NET_UPGRADE_REPORT      *pstuUpgradeReport;                      //升级结果信息  
    char                    szAccessKeyId[DH_COMMON_STRING_128];     //访问ID
    char                    szSecretAccessKey[DH_COMMON_STRING_128]; //访问秘钥
    char                    szUrl[DH_COMMON_STRING_1024];            // 云URL
}NET_IN_UPGRADE_REPORT;

//上报升级结果出参
typedef struct tagNET_OUT_UPGRADE_REPORT
{
    DWORD                  dwSize;
}NET_OUT_UPGRADE_REPORT;

//上报升级结果, 使用HTTP协议
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderReport(NET_IN_UPGRADE_REPORT *pIn, NET_OUT_UPGRADE_REPORT *pOut, DWORD dwWaitTime);

// 升级状态回调结构体
typedef struct tagNET_CLOUD_UPGRADER_STATE
{
	DWORD					dwSize;
	EM_UPGRADE_STATE		emState;							// 升级状态
	int						nProgress;							// 升级百分比
	char					szFileName[DH_COMMON_STRING_128];	// 升级文件
} NET_CLOUD_UPGRADER_STATE;

// 升级状态回调函数
typedef void (CALLBACK *fUpgraderStateCallback) (LLONG lLoginId, LLONG lAttachHandle, NET_CLOUD_UPGRADER_STATE* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// 订阅升级状态入参
typedef struct tagNET_IN_CLOUD_UPGRADER_ATTACH_STATE
{
	DWORD					dwSize;
	fUpgraderStateCallback	cbUpgraderState;
	LDWORD					dwUser;
} NET_IN_CLOUD_UPGRADER_ATTACH_STATE;

// 订阅升级状态出参
typedef struct tagNET_OUT_CLOUD_UPGRADER_ATTACH_STATE
{
	DWORD					dwSize;
} NET_OUT_CLOUD_UPGRADER_ATTACH_STATE;

// 获取升级状态入参
typedef struct tagNET_IN_CLOUD_UPGRADER_GET_STATE
{
	DWORD					dwSize;
} NET_IN_CLOUD_UPGRADER_GET_STATE;

// 获取升级状态出参
typedef struct tagNET_OUT_CLOUD_UPGRADER_GET_STATE
{
	DWORD					dwSize;
	EM_UPGRADE_STATE		emState;							// 升级状态
	int						nProgress;							// 升级进度
	char					szFileName[DH_COMMON_STRING_128];	// 升级文件
} NET_OUT_CLOUD_UPGRADER_GET_STATE;


// 获取升级相关能力集入参
typedef struct tagNET_IN_UPGRADER_GET_CAPS
{
    DWORD					dwSize;
} NET_IN_UPGRADER_GET_CAPS;

// 具体能力集信息
typedef struct tagNET_UPGRADER_CAPS
{
    UINT            nOfflineTransfer;    // 支持远程下载升级包断点续传,0 不支持,默认值; 1 支持  
    UINT            nRemoteDownload;     // 支持远程下载升级包并升级,0 不支持; 1 支持,默认值
    BYTE            byReserved[128];      // 保留字节
}NET_UPGRADER_CAPS;

// 获取升级相关能力集出参
typedef struct tagNET_OUT_UPGRADER_GET_CAPS
{
    DWORD					dwSize;
    NET_UPGRADER_CAPS       stuCaps; // 能力集   
} NET_OUT_UPGRADER_GET_CAPS;


// 取消升级程序输入参数
typedef struct tagNET_IN_UPGRADER_CANCEL 
{
    DWORD					dwSize;
} NET_IN_UPGRADER_CANCEL;

// 取消升级程序输出参数
typedef struct tagNET_OUT_UPGRADER_CANCEL
{
    DWORD					dwSize;
} NET_OUT_UPGRADER_CANCEL;

// 订阅升级状态观察接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_CloudUpgraderAttachState(LLONG lLoginID, const NET_IN_CLOUD_UPGRADER_ATTACH_STATE *pInParam, NET_OUT_CLOUD_UPGRADER_ATTACH_STATE *pOutParam, int nWaitTime);

// 退订升级状态观察接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderDetachState(LLONG lAttachHandle);

// 获取升级状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUpgraderGetState(LLONG lLoginID, const NET_IN_CLOUD_UPGRADER_GET_STATE *pInParam, NET_OUT_CLOUD_UPGRADER_GET_STATE *pOutParam, int nWaitTime);

// 获取升级相关能力集
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpgraderGetCaps(LLONG lLoginID, const NET_IN_UPGRADER_GET_CAPS *pInParam, NET_OUT_UPGRADER_GET_CAPS *pOutParam, int nWaitTime);

// 取消升级程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpgraderCancel(LLONG lLoginID, const NET_IN_UPGRADER_CANCEL *pInParam, NET_OUT_UPGRADER_CANCEL *pOutParam, int nWaitTime);


// 获取上传能力集入参
typedef struct tagNET_IN_CLOUDUPLOAD_GETCAPS
{
	DWORD				dwSize;							// 结构体大小			
}NET_IN_CLOUDUPLOAD_GETCAPS;

// 获取上传能力集出参
typedef struct tagNET_OUT_CLOUDUPLOAD_GETCAPS
{
	DWORD				dwSize;							// 结构体大小	
	BOOL				bAsyncUpload;					// 是否支持异步上传,TRUE:支持,FALSE:不支持	
}NET_OUT_CLOUDUPLOAD_GETCAPS;

// 云上传图片入参
typedef struct tagNET_IN_CLOUD_UPLOAD_PICTURE
{
    DWORD					dwSize;
    int                     nChannelID;                                     // 通道号
    int                     nServerType;                                    // 上传的服务器类型,0-云服务器 1-FTP服务器 
    int                     nPicType;                                       // 图片类型 0-司机举手照片 1-12张连拍照片 2-一寸照片
    char                    szFileName[256];               // Ocx存储的文件名称(web客户端使用)    
    char                    szAccessKeyId[DH_COMMON_STRING_64];             // 服务器访问用户名       
    char                    szAccessKeySecret[DH_COMMON_STRING_64];         // 服务器访问密码
    char                    szBucketName[DH_COMMON_STRING_32];              // 服务器存储空间名字
    char                    szFileKey[256];                // 服务器上存储的文件名
    char                    szEndPoint[DH_COMMON_STRING_64];                // 文件对外服务的访问域名    

    UINT                    nFileLength;                                    // 文件长度,单位:字节
    char*                   pFileData;                                      // 文件数据
    
} NET_IN_CLOUD_UPLOAD_PICTURE;

// 云上传图片出参
typedef struct tagNET_OUT_CLOUD_UPLOAD_PICTURE
{
    DWORD					dwSize;
    char                    szFileName[256];               // 本次上传成功的文件名，主要给ocx匹配用
    char                    szFileURL[DH_COMMON_STRING_2048];               // 访问上传文件的域名,供web显示使用
	BOOL					bAsyncUploadPic;								// 上传图片是否为异步,TRUE:异步,FALSE:同步
} NET_OUT_CLOUD_UPLOAD_PICTURE;

// 云上传图片到服务器
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUploadPicture(LLONG lLoginID, const NET_IN_CLOUD_UPLOAD_PICTURE *pInParam, NET_OUT_CLOUD_UPLOAD_PICTURE *pOutParam, int nWaitTime);

// 云上传视频入参
typedef struct tagNET_IN_CLOUD_UPLOAD_VIDEO
{
    DWORD					dwSize;
    int                     nChannelID;                                     // 通道号
    int                     nServerType;                                    // 上传的服务器类型,0-云服务器 1-FTP服务器
    int                     nAction;                                        // 手动录像状态,0-结束手动录像 1-开始手动录像
    int                     nStrategy;                                      // 上传录像的策略,0-实时上传 1-策略上传(在时间段内上传，即夜间空闲上传)
    char                    szAccessKeyId[DH_COMMON_STRING_64];             // 服务器访问用户名    
    char                    szAccessKeySecret[DH_COMMON_STRING_64];         // 服务器访问密码
    char                    szBucketName[DH_COMMON_STRING_32];              // 服务器存储空间名字
    char                    szFileKey[256];									// 服务器上存储的文件名
    char                    szEndPoint[DH_COMMON_STRING_64];                // 文件对外服务的访问域名
} NET_IN_CLOUD_UPLOAD_VIDEO;

// 云上传视频出参
typedef struct tagNET_OUT_CLOUD_UPLOAD_VIDEO
{
    DWORD					dwSize;
	BOOL					bAsyncUploadVideo;								// 上传视频是否为异步,TRUE:异步,FALSE:同步
} NET_OUT_CLOUD_UPLOAD_VIDEO;

// 云上传视频到服务器
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CloudUploadVideo(LLONG lLoginID, const NET_IN_CLOUD_UPLOAD_VIDEO *pInParam, NET_OUT_CLOUD_UPLOAD_VIDEO *pOutParam, int nWaitTime);

// 抓图图片上传状态信息
typedef struct tagNET_SNAPPIC_INFO
{
	char				szFileName[256];  // Ocx存储的文件名称
	BOOL				bState;							   // 图片是否上传成功,FALSE:失败,TRUE:成功
	char				szUrl[2048];	   // 上传服务器后，图片的访问URL
	BYTE				byReserved[1024];				   // 预留字节	
}NET_SNAPPIC_INFO;

// 录像上传状态信息
typedef struct tagNET_VIDEO_INFO
{
	char				szFileName[256];		// 录像上传到服务器的名称
	unsigned int	    nChannel;								// 通道号
	NET_TIME			stuStartTime;							// 需要上传的录像段的开始时间	
	NET_TIME			stuEndTime;								// 需要上传的录像段的结束时间
	BOOL				bState;									// 录像是否上传成功,FALSE:失败,TRUE:成功
	BYTE				byReserved[1024];						// 预留字节
}NET_VIDEO_INFO;

// 上传录像或者图片的进度状态信息
typedef struct tagNET_CLOUDUPLOAD_STATE
{
	NET_SNAPPIC_INFO     stuSnapPicInfo;			// 抓图图片上传状态信息
	NET_VIDEO_INFO		 stuVideoInfo;				// 录像上传状态信息
	BYTE				 byReserved[2048];			// 预留字节
}NET_CLOUDUPLOAD_STATE;

// 订阅订阅上传录像或者图片的进度状态
typedef void (CALLBACK *fCloudUploadStateCallBack)(LLONG lLoginID, LLONG lAttachHandle, NET_CLOUDUPLOAD_STATE* pBuf, int nBufLen, LDWORD dwUser);

// CLIENT_AttachCloudUploadState接口入参
typedef struct tagNET_IN_ATTACH_CLOUDUPLOAD_STATE
{
	DWORD						dwSize;
	fCloudUploadStateCallBack	cbCloudUploadState;    // 回调函数
	LDWORD						dwUser;                // 用户数据
}NET_IN_ATTACH_CLOUDUPLOAD_STATE;

// CLIENT_AttachCloudUploadState接口出参
typedef struct tagNET_OUT_ATTACH_CLOUDUPLOAD_STATE
{
	DWORD				dwSize;
}NET_OUT_ATTACH_CLOUDUPLOAD_STATE;

// 订阅上传录像或者图片的进度状态
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCloudUploadState(LLONG lLoginID, NET_IN_ATTACH_CLOUDUPLOAD_STATE *pInBuf,NET_OUT_ATTACH_CLOUDUPLOAD_STATE *pOutBuf, int nWaitTime);

// 取消订阅上传录像或者图片的进度状态 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCloudUploadState(LLONG lAttachHandle);

////////////////////////////////////////////////////////////

// CLIENT_GetRecordState 入参
typedef struct tagNET_IN_GET_RECORD_STATE
{
	DWORD				dwSize;				// 结构体大小
	int					nChannel;			// 通道号
} NET_IN_GET_RECORD_STATE;

// CLIENT_GetRecordState 出参
typedef struct tagNET_OUT_GET_RECORD_STATE
{
	DWORD				dwSize;				// 结构体大小
	BOOL				bState;				// 是否在录像
} NET_OUT_GET_RECORD_STATE;

// 获取录像状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRecordState(LLONG lLoginID, const NET_IN_GET_RECORD_STATE *pInParam, NET_OUT_GET_RECORD_STATE *pOutParam, int nWaitTime);

//  获取指定教室的录像信息入参
typedef struct tagNET_IN_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // 教室ID,0为默认教室
}NET_IN_COURSERECORD_GETINFO;

//  获取指定教室的录像信息出参
typedef struct tagNET_OUT_COURSERECORD_GETINFO
{
    DWORD                       dwSize;
    int                         nChannelNum;                            // 逻辑通道数量
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:无效,1:录像,2不录像,下标对应为逻辑通道号
}NET_OUT_COURSERECORD_GETINFO;

//  设置指定教室的录像信息入参
typedef struct tagNET_IN_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                           // 教室ID,0为默认教室
    int                         nChannelNum;                            // 逻辑通道数量
    int                         nCanRecord[MAX_COURSE_LOGIC_CHANNEL];   // 0:无效,1:录像,2不录像,下标对应为逻辑通道号
}NET_IN_COURSERECORD_SETINFO;

//  设置指定教室的录像信息出参
typedef struct tagNET_OUT_COURSERECORD_SETINFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_SETINFO;

// 录像信息更新到time入参
typedef struct tagNET_IN_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // 教室ID,0为默认教室
    NET_TIME                    stuTime;                             // 查询时间
}NET_IN_COURSERECORD_UPDATE_INFO;

// 录像信息更新到time出参
typedef struct tagNET_OUT_COURSERECORD_UPDATE_INFO
{
    DWORD                       dwSize;
}NET_OUT_COURSERECORD_UPDATE_INFO;

// 获取当前课程已录制时间入参
typedef struct tagNET_IN_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    int                         nClassRoomID;                        // 教室ID，0为默认教室
}NET_IN_COURSERECORD_GET_TIME;

// 获取当前课程已录制时间出参
typedef struct tagNET_OUT_COURSERECORD_GET_TIME
{
    DWORD                       dwSize;
    UINT                        nTime;                               // 已录制时间，单位:秒
}NET_OUT_COURSERECORD_GET_TIME;

// 录播主机录像信息操作
typedef enum tagEM_COURSERECORD_OPERATE_TYPE
{
    EM_COURSERECORDE_TYPE_GET_INFO,                       //获取教室录像信息,对应结构体pInParam = NET_IN_COURSERECORD_GETINFO,pOutParam = NET_OUT_COURSERECORD_GETINFO 
    EM_COURSERECORDE_TYPE_SET_INFO,                       //设置教室录像信息,对应结构体pInParam = NET_IN_COURSERECORD_SETINFO,pOutParam = NET_OUT_COURSERECORD_SETINFO 
    EM_COURSERECORDE_TYPE_UPDATE_INFO,                    //将录像信息更新到time时的信息,对应结构体 pInParam = NET_IN_COURSERECORD_UPDATE_INFO, pOutParam = NET_OUT_COURSERECORD_UPDATE_INFO
    EM_COURSERECORDE_TYPE_GET_TIME,                       //获取当前课程教室已录制时间,对应结构体 pInParam = NET_IN_COURSERECORD_GET_TIME, pOutParam = NET_OUT_COURSERECORD_GET_TIME
}EM_COURSERECORD_OPERATE_TYPE;

// 录播主机录像信息操作接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCourseRecordManager(LLONG lLoginID, EM_COURSERECORD_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

typedef void(CALLBACK *fConfigChangeCallBack)(LLONG lAttachHandle, char* szCommand, char* szBuffer, LDWORD dwUser);
// 订阅配置变化入参
typedef struct tagNET_IN_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
    char*                           szCfgName;           // 配置名称,参见dhconfigsdk.h的CLIENT_GetNewDevConfig和CLIENT_SetNewDevConfig接口的配置命令
    fConfigChangeCallBack           cbNotify;            // 回调函数
    LDWORD                          dwUser;              // 用户信息
}NET_IN_ATTACH_CONFIGCHANNGE;

// 订阅配置变化出参
typedef struct tagNET_OUT_ATTACH_CONFIGCHANNGE
{
    DWORD                           dwSize;
}NET_OUT_ATTACH_CONFIGCHANNGE;

// 订阅配置变化接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachConfigChange(LLONG lLoginID, NET_IN_ATTACH_CONFIGCHANNGE *pInBuf,NET_OUT_ATTACH_CONFIGCHANNGE *pOutBuf, int nWaitTime);

// 取消订阅配置变化 
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachConfigChange(LLONG lAttachHandle);

//CLIENT_GetRingFileList 入参
typedef struct tagNET_IN_GET_RINGFILELIST
{
	DWORD 		dwSize;
}NET_IN_GET_RINGFILELIST;

//CLIENT_GetRingFileList 出参
typedef struct tagNET_OUT_GET_RINGFILELIST
{
	DWORD       dwSize;
	UINT        nRingFileNum;                                         // 返回音频文件个数
	char        szRingFileList[MAX_RINGFILE_NUM][DH_COMMON_STRING_64];// 音频文件列表
}NET_OUT_GET_RINGFILELIST;

//获取门铃音频文件列表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRingFileList(LLONG lLoginID, NET_IN_GET_RINGFILELIST *pstuInParam, NET_OUT_GET_RINGFILELIST *pstuOutParam, int nWaitTime);

// CLIENT_GetConnetionStatus 入参
typedef struct tagNET_IN_GETCONNECTION_STATUS
{
    DWORD       dwSize;                                               
} NET_IN_GETCONNECTION_STATUS;

// CLIENT_GetConnetionStatus 出参
typedef struct tagNET_OUT_GETCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                        // 通道数量
    int         nStatus[MAX_ALARMEXT_MODULE_NUM];                   // 下标表示报警通道号,取值含义0:未分配1:离线2:在线
} NET_OUT_GETCONNECTION_STATUS;

// 报警主机获取扩展模块在线状态接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetConnectionStatus(LLONG lLoginID,const NET_IN_GETCONNECTION_STATUS* pstuInParam, NET_OUT_GETCONNECTION_STATUS *pstuOutParam, int nWaitTime);

#define MAX_ALARM_BOX_VIDEO_NUM		16

// CLIENT_GetAlarmBoxVideoConnectionStatus 入参
typedef struct tagNET_IN_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;                                               
} NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS;

// CLIENT_GetAlarmBoxVideoConnectionStatus 出参
typedef struct tagNET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS
{
    DWORD       dwSize;  
    int         nChannelNum;                                        // 报警盒通道个数
    int         nStatus[MAX_ALARM_BOX_VIDEO_NUM];                   // 下标表示报警盒通道号,取值含义 0:未接入报警盒 1:离线 2:上线
} NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS;

// 报警主机获取获取报警盒上下线状态接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmBoxVideoConnectionStatus(LLONG lLoginID,const NET_IN_GETALARMBOXVIDEOCONNECTION_STATUS* pstuInParam, NET_OUT_GETALARMBOXVIDEOCONNECTION_STATUS *pstuOutParam, int nWaitTime);

//用户权限
typedef enum tagNET_ATTENDANCE_AUTHORITY
{
    NET_ATTENDANCE_AUTHORITY_UNKNOWN = -1,
    NET_ATTENDANCE_AUTHORITY_CUSTOMER,           //普通用户
    NET_ATTENDANCE_AUTHORITY_ADMINISTRATORS,     //管理员
}NET_ATTENDANCE_AUTHORITY;

#define MAX_ATTENDANCE_USERNAME_LEN 36
//考勤用户信息
typedef struct tagNET_ATTENDANCE_USERINFO
{
    char                     szUserID[MAX_COMMON_STRING_32];			//用户编号ID     
    char                     szUserName[MAX_ATTENDANCE_USERNAME_LEN];	//人员姓名
    char                     szCardNo[MAX_COMMON_STRING_32];			// 卡号
    NET_ATTENDANCE_AUTHORITY emAuthority;								// 用户权限
    char                     szPassword[MAX_COMMON_STRING_32];			// 密码
    int                      nPhotoLength;								// 照片数据长度   
	char					 szClassNumber[MAX_CLASS_NUMBER_LEN];		// 班级（肯尼亚定制）
	char					 szPhoneNumber[MAX_PHONENUMBER_LEN];		// 电话（肯尼亚定制）
	NET_ACCESSCTLCARD_TYPE   emCardType;								// 卡类型
	BYTE					 byReserved[204];							// 保留字节    
}NET_ATTENDANCE_USERINFO;

//CLIENT_Attendance_InsertFingerByUserID 入参
typedef struct tagNET_IN_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    char 						szUserID[DH_COMMON_STRING_32];			// 用户ID
    int 						nSinglePacketLen;						// 单个指纹数据包长度
    int 						nPacketCount;							// 指纹数据包的个数
	char*						szFingerPrintInfo;						// 指纹数据(数据总长度即nSinglePacketLen*nPacketCount)
}NET_IN_FINGERPRINT_INSERT_BY_USERID;


//CLIENT_Attendance_InsertFingerByUserID 出参
typedef struct tagNET_OUT_FINGERPRINT_INSERT_BY_USERID
{
	DWORD						dwSize;
    int							nFingerPrintID[DH_MAX_FINGER_PRINT];	//指纹ID数组
	int 						nReturnedCount;							//数组中实际返回的个数
	int							nFailedCode;							//错误码  0：成功;   1：其他错误;  2：超过本用户下指纹能力的限制.
}NET_OUT_FINGERPRINT_INSERT_BY_USERID;
		

//CLIENT_Attendance_RemoveFingerByUserID 入参(removeByUserID)
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			// 用户ID
}NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID;

//CLIENT_Attendance_RemoveFingerByUserID 出参
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID;


//CLIENT_Attendance_RemoveFingerRecord 入参(remove) 
typedef struct tagNET_CTRL_IN_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
	int							nFingerPrintID;							//指纹编号
}NET_CTRL_IN_FINGERPRINT_REMOVE;

//CLIENT_Attendance_RemoveFingerRecord 出参
typedef struct tagNET_CTRL_OUT_FINGERPRINT_REMOVE
{
	DWORD						dwSize;
}NET_CTRL_OUT_FINGERPRINT_REMOVE;


//CLIENT_Attendance_GetFingerRecord 入参
typedef struct tagNET_CTRL_IN_FINGERPRINT_GET
{
	DWORD						dwSize;
	int							nFingerPrintID;							//指纹编号
}NET_CTRL_IN_FINGERPRINT_GET;

//CLIENT_Attendance_GetFingerRecord 出参
typedef struct tagNET_CTRL_OUT_FINGERPRINT_GET
{
	DWORD						dwSize;
	char 						szUserID[DH_COMMON_STRING_32];			// 所属用户的用户ID
	char 						szFingerPrintName[DH_COMMON_STRING_32]; // 指纹名称
	int							nFingerPrintID;							// 指纹ID
	int							nRetLength;								// 实际返回的二进制指纹数据长度
	int							nMaxFingerDataLength;					// 二进制指纹数据的最大长度
	char*						szFingerPrintInfo;						// 指纹数据
}NET_CTRL_OUT_FINGERPRINT_GET;

//CLIENT_Attendance_FindUser 入参
typedef struct tagNET_IN_ATTENDANCE_FINDUSER
{
	DWORD			dwSize;
	int				nOffset;										// 查询偏移
	int				nPagedQueryCount;								// 查询个数，分页查询，最多不超过100
}NET_IN_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_FindUser 出参
typedef struct tagNET_OUT_ATTENDANCE_FINDUSER
{
	DWORD 							dwSize;
	int								nTotalUser;					// 总的用户数
	int								nMaxUserCount;				// 用户信息最大缓存数
	NET_ATTENDANCE_USERINFO*       	stuUserInfo;            	// 用户信息，内存由用户申请，大小为(sizeof(NET_ATTENDANCE_USERINFO)*nMaxUserCount) 
	int								nRetUserCount;				// 实际返回的用户个数
	int                           	nMaxPhotoDataLength;        // 照片数据最大长度
	int								nRetPhoteLength;			// 实际返回的照片数据长度
	BYTE *                        	pbyPhotoData;           	// 照片数据
}NET_OUT_ATTENDANCE_FINDUSER;

//CLIENT_Attendance_GetFingerByUserID 入参
typedef struct tagNET_IN_FINGERPRINT_GETBYUSER
{
	DWORD						 dwSize;
	char                         szUserID[MAX_COMMON_STRING_32];      // 用户ID
}NET_IN_FINGERPRINT_GETBYUSER;

//CLIENT_Attendance_GetFingerByUserID 出参
typedef struct tagNET_OUT_FINGERPRINT_GETBYUSER
{
	DWORD						dwSize;
	int							nFingerPrintIDs[DH_MAX_FINGER_PRINT];	// 指纹ID数组
	int							nRetFingerPrintCount;					// 实际返回的指纹ID个数，即nFingerPrintIDs数组中实际有效个数
	int							nSinglePacketLength;					// 单个指纹数据包长度
	int							nMaxFingerDataLength;					// 接受指纹数据的缓存的最大长度
	int							nRetFingerDataLength;					// 实际返回的总的指纹数据包的长度
	BYTE*                       pbyFingerData;                       	// 指纹数据	
}NET_OUT_FINGERPRINT_GETBYUSER;


// CLIENT_Attendance_AddUser 入参
typedef struct tagNET_IN_ATTENDANCE_ADDUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;           //用户信息
    BYTE                       *pbyPhotoData;         // 照片数据
}NET_IN_ATTENDANCE_ADDUSER;

// CLIENT_Attendance_AddUser出参
typedef struct tagNET_OUT_ATTENDANCE_ADDUSER
{
    DWORD         dwSize; 
}NET_OUT_ATTENDANCE_ADDUSER;

//考勤新增加用户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_AddUser(LLONG lLoginID, NET_IN_ATTENDANCE_ADDUSER *pstuInAddUser, NET_OUT_ATTENDANCE_ADDUSER *pstuOutAddUser, int nWaitTime);

// CLIENT_Attendance_DelUser 入参
typedef struct tagNET_IN_ATTENDANCE_DELUSER
{
    DWORD                      dwSize;  
    char                       szUserID[MAX_COMMON_STRING_32];      //用户ID
}NET_IN_ATTENDANCE_DELUSER;

// CLIENT_Attendance_DelUser出参
typedef struct tagNET_OUT_ATTENDANCE_DELUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_DELUSER;

//考勤删除用户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_DelUser(LLONG lLoginID, NET_IN_ATTENDANCE_DELUSER *pstuInDelUser, NET_OUT_ATTENDANCE_DELUSER *pstuOutDelUser, int nWaitTime);

// CLIENT_Attendance_ModifyUser 入参
typedef struct tagNET_IN_ATTENDANCE_ModifyUSER
{
    DWORD                      dwSize;  
    NET_ATTENDANCE_USERINFO    stuUserInfo;                         //用户信息
    BYTE                       *pbyPhotoData;                       // 照片数据
}NET_IN_ATTENDANCE_ModifyUSER;

// CLIENT_Attendance_ModifyUser出参
typedef struct tagNET_OUT_ATTENDANCE_ModifyUSER
{
    DWORD         dwSize;   
}NET_OUT_ATTENDANCE_ModifyUSER;

//考勤修改用户信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_ModifyUser(LLONG lLoginID, NET_IN_ATTENDANCE_ModifyUSER *pstuInModifyUser, NET_OUT_ATTENDANCE_ModifyUSER *pstuOutModifyUser, int nWaitTime);

// CLIENT_Attendance_GetUser 入参
typedef struct tagNET_IN_ATTENDANCE_GetUSER
{
    DWORD                        dwSize;  
    char                         szUserID[MAX_COMMON_STRING_32];      //用户ID    
}NET_IN_ATTENDANCE_GetUSER;

// CLIENT_Attendance_GetUser出参
typedef struct tagNET_OUT_ATTENDANCE_GetUSER
{
    DWORD                         dwSize;   
    NET_ATTENDANCE_USERINFO       stuUserInfo;            //用户信息    
    int                           nMaxLength;             // 最大存放照片数据的长度
    BYTE *                        pbyPhotoData;           // 照片数据
}NET_OUT_ATTENDANCE_GetUSER;

//考勤机 获取用户信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetUser(LLONG lLoginID, NET_IN_ATTENDANCE_GetUSER *pstuInGetUser, NET_OUT_ATTENDANCE_GetUSER *pstuOutGetUser, int nWaitTime);

//考勤机  通过用户ID插入指纹数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_InsertFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_INSERT_BY_USERID* pstuInInsert, NET_OUT_FINGERPRINT_INSERT_BY_USERID* pstuOutInsert, int nWaitTime);

//考勤机 删除单个用户下所有指纹数据
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_RemoveFingerByUserID(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID* pstuOutRemove, int nWaitTime);

//考勤机 通过指纹ID获取指纹数据
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_Attendance_GetFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_GET* pstuInGet, NET_CTRL_OUT_FINGERPRINT_GET* pstuOutGet, int nWaitTime);

//考勤机 通过指纹ID删除指纹数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_RemoveFingerRecord(LLONG lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE* pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE* pstuOutRemove, int nWaitTime);

//考勤机 查找用户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_FindUser(LLONG lLoginID, NET_IN_ATTENDANCE_FINDUSER *pstuInFindUser, NET_OUT_ATTENDANCE_FINDUSER *pstuOutFindUser, int nWaitTime);

//考勤机 通过用户ID查找该用户下的所有指纹数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetFingerByUserID(LLONG lLoginID, NET_IN_FINGERPRINT_GETBYUSER *pstuIn, NET_OUT_FINGERPRINT_GETBYUSER *pstuOut, int nWaitTime);


// 搜索设备接口子类型
typedef enum tagEM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE
{
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UNKNOWN = -1,					// 未知
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_NONE = 0,						// 私有标准规范
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_ONVIF,                          // Onvif标准规范
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE_UPNP,                           // UPnP标准规范
}EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE;

// fAttachDeviceDiscoveryCB 参数
typedef struct tagNET_DEVICE_DISCOVERY_INFO
{
	DWORD				dwSize;
	char				szMachineName[DH_COMMON_STRING_32];					// 设备名称
	char				szDeviceClass[DH_COMMON_STRING_32];					// 设备类型
	char				szDeviceType[DH_COMMON_STRING_32];					// 设备型号
	char				szSerialNo[DH_COMMON_STRING_32];					// 设备序列号
	char				szVersion[DH_COMMON_STRING_32];						// 设备软件版本号
	char				szMac[DH_COMMON_STRING_32];							// 设备MAC地址
	int					nVideoInputChannels;								// 设备视频输入通道号
	int					nRemoteVideoInputChannels;							// 远程视频输入通道数
	int					nVideoOutputChannels;								// 视频输出通道数
	int					nAlarmInputChannels;								// 报警输入通道数
	int					nAlarmOutputChannels;								// 报警输出通道数
	int					nAudioInputChannels;								// 设备音频输入通道数
	int					nPort;												// 登陆端口
	char				szVendor[DH_COMMON_STRING_32];						// 客户名称
	int					nInit;												// 设备是否已初始化:0不具备初始化功能的设备,可以等同于已初始化 1未初始化 2已初始化
	char				szIPv4Address[DH_COMMON_STRING_32];					// IPv4地址
	char				szIPv4SubnetMask[DH_COMMON_STRING_32];				// IPv4子网掩码
	char				szIPv4DefaultGateway[DH_COMMON_STRING_32];			// IPv4默认网关
	BOOL				bIPv4DhcpEnable;									// IPv4是否使能DHCP
	char				szIPv6Address[DH_COMMON_STRING_32];					// IPv6地址
	char				szIPv6DefaultGateway[DH_COMMON_STRING_32];			// IPv6默认网关
	char				szIPv6LinkLocalAddress[DH_COMMON_STRING_32];		// IPv6本地链路地址,该地址只能直连,不需要Gateway
	BOOL				bIPv6DhcpEnable;									// IPv6是否使能Dhcp
	char				szProtocol[DH_COMMON_STRING_32];					// 设备搜索标准
}NET_DEVICE_DISCOVERY_INFO;


// 注册设备搜索处理回调函数原形,lAttachHandle是CLIENT_AttachDeviceDiscovery返回值, pDeviceInfo为设备信息, nDeviceNum为设备信息数组个数
typedef void (CALLBACK *fAttachDeviceDiscoveryCB) (LLONG lAttachHandle, NET_DEVICE_DISCOVERY_INFO* pDeviceInfo, int nDeviceNum, LDWORD dwUser);


// CLIENT_AttachDeviceDiscovery 接口输入参数
typedef struct tagNET_IN_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;
    EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// 接口子类型
	fAttachDeviceDiscoveryCB						cbNotify;				// 回调函数
	LDWORD											dwUser;					// 用户数据
} NET_IN_ATTACH_DEVICE_DISCOVERY;

// CLIENT_AttachDeviceDiscovery 接口输出参数
typedef struct tagNET_OUT_ATTACH_DEVICE_DISCOVERY
{
    DWORD											dwSize;
} NET_OUT_ATTACH_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery 接口输入参数
typedef struct tagNET_IN_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// 接口子类型
    int												nTimeOut;				// 搜索超时,搜索结果上报时间,超过此时间后,不再上报设备信息. 单位秒
} NET_IN_START_DEVICE_DISCOVERY;

// CLIENT_StartDeviceDiscovery 接口输出参数
typedef struct tagNET_OUT_START_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_START_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery 接口输入参数
typedef struct tagNET_IN_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
	EM_NET_DEVICE_DISCOVERY_SUBCLASSID_TYPE 		emSubClassID;			// 接口子类型
} NET_IN_STOP_DEVICE_DISCOVERY;

// CLIENT_StopDeviceDiscovery 接口输出参数
typedef struct tagNET_OUT_STOP_DEVICE_DISCOVERY 
{
    DWORD											dwSize;
} NET_OUT_STOP_DEVICE_DISCOVERY;

// 注册设备搜索
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDeviceDiscovery(LLONG lLoginID, const NET_IN_ATTACH_DEVICE_DISCOVERY *pInParam, NET_OUT_ATTACH_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// 注销设备搜索, lAttachHandle为CLIENT_AttachDeviceDiscovery 返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDeviceDiscovery(LLONG lAttachHandle);

// 启动设备搜索
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartDeviceDiscovery(LLONG lLoginID, const NET_IN_START_DEVICE_DISCOVERY *pInParam, NET_OUT_START_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// 停止设备搜索
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopDeviceDiscovery(LLONG lLoginID, const NET_IN_STOP_DEVICE_DISCOVERY *pInParam, NET_OUT_STOP_DEVICE_DISCOVERY *pOutParam, int nWaitTime);

// 设置单防区布撤防接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDefenceArmMode(LLONG lLoginID, NET_IN_SET_DEFENCEMODE* pInBuf, NET_OUT_SET_DEFENCEMODE* pOutBuf = NULL, int nWaitTime = 1000);

// 获取单防区布撤防状态接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDefenceArmMode(LLONG lLoginID, NET_IN_GET_DEFENCEMODE* pInBuf, NET_OUT_GET_DEFENCEMODE* pOutBuf, int nWaitTime = 1000);

// 设置子系统布撤防接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSubSystemArmMode(LLONG lLoginID, NET_IN_SET_SUBSYSTEMMODE* pInBuf, NET_OUT_SET_SUBSYSTEMMODE* pOutBuf = NULL, int nWaitTime = 1000);

// 获取子系统布撤防状态接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSubSystemArmMode(LLONG lLoginID, NET_IN_GET_SUBSYSTEMMODE* pInBuf, NET_OUT_GET_SUBSYSTEMMODE* pOutBuf, int nWaitTime = 1000);

// 获取主机布撤防状态接口,pInBuf与pOutBuf内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetArmMode(LLONG lLoginID, NET_IN_GET_ARM_MODE* pInBuf, NET_OUT_GET_ARM_MODE* pOutBuf, int nWaitTime);

// 手机订阅推送信息, 使用RegisterID标识配置项,pstuCfg内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// 删除手机订阅推送信息, 使用RegisterID标识配置项,pstuIn与pstuOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotify(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);

// 获取手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuCfg内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobilePushNotifyCfg(LLONG lLoginID, NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int nWaitTime = 1000);

// 设置手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuCfg内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG *pstuCfg, int *nError, int *nRestart, int nWaitTime = 1000);

// 删除手机订阅推送信息, 使用RegisterID+AppID标识配置项,AppID内容不能带点号,点号可以用下划线代替,pstuIn与pstuOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePushNotifyCfg(LLONG lLoginID, const NET_MOBILE_PUSH_NOTIFY_CFG_DEL *pstuIn, NET_OUT_DELETECFG* pstuOut, int nWaitTime = 1000);




// 批量下发门禁控制卡
// nInsertCount: 下发卡片数量，不大于 20
// pInsertCards: 需要下发的卡片信息，指向用户分配并填充的 NET_RECORDSET_ACCESS_CTL_CARD 结构体缓存，个数为 nInsertCount
// nRecNo: 下发后的记录编号，与 pInsertCards 一一对应，-1 表示该项插入失败，指向用户分配的 int 缓存，个数为 nInsertCount
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InsertAccessControlCards(LLONG lLoginID, int nInsertCount, const NET_RECORDSET_ACCESS_CTL_CARD* pInsertCards, int* pRecNo, void* reserved = NULL, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);
 
//人脸图片比较信息
typedef struct tagNET_IMAGE_COMPARE_INFO
{
	DWORD 			   	    dwoffset;			// 在二进制数据块中的偏移,单位:字节
	DWORD					dwLength;			// 图片大小,单位:字节
	DWORD					dwWidth;			// 图片宽度
	DWORD					dwHeight;			// 图片高度
	BYTE                    byReserved[128];    // 保留字节
} NET_IMAGE_COMPARE_INFO;

//CLIENT_MatchTwoFace 输入参数
typedef struct tagNET_MATCH_TWO_FACE_IN
{
	DWORD					dwSize;
	NET_IMAGE_COMPARE_INFO  stuOriginalImage;	// 原图
	NET_IMAGE_COMPARE_INFO  stuCompareImage;	// 比较图
	char 			   	   *pSendBuf;			// 两张人脸图片数据
	DWORD 					dwSendBufLen;		// 数据大小
} NET_MATCH_TWO_FACE_IN;

//CLIENT_MatchTwoFace 输出参数
typedef struct tagNET_MATCH_TWO_FACE_OUT
{
	DWORD					dwSize;
	int						nSimilarity;		// 两张图片的相似度,范围0~100
} NET_MATCH_TWO_FACE_OUT;

// 计算两张人脸图片的相似度faceRecognitionServer.matchTwoFace,pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_MatchTwoFaceImage(LLONG lLoginID, const NET_MATCH_TWO_FACE_IN *pstInParam, NET_MATCH_TWO_FACE_OUT *pstOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// 解码帧类型
typedef enum tagEM_DECODE_FRAME_TYPE
{
    EM_FRAME_TYPE_UNKNOWN   = -1,               // 未知的
    EM_FRAME_TYPE_VIDEO     = 0,				// 视频帧
    EM_FRAME_TYPE_AUDIO     = 1,				// 音频帧
}EM_DECODE_FRAME_TYPE;

// 解码帧扩展信息
typedef struct tagNET_FRAME_INFO_EX
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//视频帧类型,见上面定义
    int				        nFrameSeq;				//帧序号
    int				        nStamp;					//时标信息,单位毫秒
    int				        nWidth;					//画面宽,单位像素.如果是音频数据则为0.
    int 			        nHeight;				//画面高,如果是音频数据则为0
    int				        nFrameRate;				//编码时产生的图像帧率
    int				        nChannels;				//音频通道数
    int				        nBitPerSample;			//音频采样位数
    int				        nSamplesPerSec;			//音频采样频率
    int				        nRemainData;			//缓冲剩余数据量
    NET_TIME_EX		        nDataTime;				//时间
    
}NET_FRAME_INFO_EX;

// 解码帧信息
typedef struct tagNET_FRAME_DECODE_INFO 
{
    DWORD                   dwSize;
    EM_DECODE_FRAME_TYPE    emFrameType;			//帧类型,定义见FRAME_INFO_EX里nFrameType字段

    void*			        pAudioData;				//音频数据,如果是音频帧
    int				        nAudioDataLen;			//音频数据长度

    void*			        pVideoData[3];			//分别表示视频的YUV三个分量
    int				        nStride[3];				//分别表示YUV三个分量的跨距
    int				        nWidth[3];				//分别表示YUV三个分量的宽度
    int				        nHeight[3];				//分别表示YUV三个分量的高度  
}NET_FRAME_DECODE_INFO;

// 解码回调函数
typedef void (CALLBACK *fDecCallBack)(LLONG lLoginID, LLONG lPlayHandle, NET_FRAME_DECODE_INFO* pFrameDecodeInfo, NET_FRAME_INFO_EX* pFrameInfo, LDWORD dwUserData, LLONG nReserved);

// 设置解码回调函数
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBack(fDecCallBack cbDecCallBack, LDWORD dwUserData, LLONG nReserved = 0);

// 设置解码回调函数----扩展
CLIENT_NET_API void CALL_METHOD CLIENT_SetDecCallBackEx(fDecCallBack cbDecCallBack, LDWORD dwUserData, NET_VIDEOSTREAM_TYPE emVideoStreamType, LLONG nReserved);

// 获取默认配置(目前只实现了EncodePlane配置emCfgOpType == NET_EM_CFG_ENCODE_PLAN)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevDefaultConfig(LLONG lLoginID, NET_EM_CFG_OPERATE_TYPE emCfgOpType, int nChannelID,
                                          LPVOID lpOutBuffer, DWORD dwOutBufferSize, int nWaittime/*=NET_INTERFACE_DEFAULT_TIMEOUT*/);

#define NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN 32                        // 自定义车位号最大长度

// 车位指示灯颜色
typedef enum tagEM_PARKINGSPACE_LIGHT_COLOR
{
    EM_PARKINGSPACE_LIGHT_COLOR_UNKNOWN,                                    // 未知  
    EM_PARKINGSPACE_LIGHT_COLOR_RED,                                        // 红色
    EM_PARKINGSPACE_LIGHT_COLOR_YELLOW,                                     // 黄色    
	EM_PARKINGSPACE_LIGHT_COLOR_GREEN,                                      // 绿色   
	EM_PARKINGSPACE_LIGHT_COLOR_BLUE,										// 蓝色    
	EM_PARKINGSPACE_LIGHT_COLOR_PURPLE,                                     // 紫色   
	EM_PARKINGSPACE_LIGHT_COLOR_WHITE,										// 白色    
	EM_PARKINGSPACE_LIGHT_COLOR_PINK,										// 粉色   
}EM_PARKINGSPACE_LIGHT_COLOR;

// 车位指示灯状态
typedef enum tagEM_PARKINGSPACE_LIGHT_STATE
{
    EM_PARKINGSPACE_LIGHT_STATE_UNKNOWN = -1,                               // 未知  
    EM_PARKINGSPACE_LIGHT_STATE_OFF,                                        // 灭
    EM_PARKINGSPACE_LIGHT_STATE_ON,                                         // 亮
    EM_PARKINGSPACE_LIGHT_STATE_GLINT,                                      // 闪烁
    EM_PARKINGSPACE_LIGHT_STATE_LAST_STATE,                                 // 上一个状态
}EM_PARKINGSPACE_LIGHT_STATE;

// 停车场车位指示灯亮灯计划信息
typedef struct tagNET_PARKING_SPACE_LIGHT_PLAN_INFO
{
    EM_PARKINGSPACE_LIGHT_COLOR emColor;                                    // 颜色
    EM_PARKINGSPACE_LIGHT_STATE emState;                                    // 状态
    int nKeepTime;                                                          // 持续时间,单位秒，-1表示常亮
    BYTE byReserved[128];                                                   // 保留字节
}NET_PARKING_SPACE_LIGHT_PLAN_INFO;

// 设置车位指示灯亮灯计划入参
typedef struct tagNET_IN_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // 结构体大小                                                           
    int nPhysicalLane;                                                      // 物理车位号，请优先使用此字段.值为负数时表示此字段无效
    char szCustomParkNo[NET_CUSTOM_PARKING_SPACE_NUMBER_MAX_LEN];           // 自定义车位编号，物理车位号字段无效时，使用此字段
    int nLightPlanNum;                                                      // 亮灯计划数目
    NET_PARKING_SPACE_LIGHT_PLAN_INFO* pstuLightPlan;                       // 亮灯计划信息，由用户申请和释放内存
}NET_IN_SET_PARKING_SPACE_LIGHT_PLAN;

// 设置车位指示灯亮灯计划出参
typedef struct tagNET_OUT_SET_PARKING_SPACE_LIGHT_PLAN
{
    DWORD dwSize;                                                           // 结构体大小
}NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN;


// 设置车位检测器车灯亮灯计划,pNetDataIn与pNetDataOut由用户申请内存
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetParkingSpaceLightPlan(LLONG lLoginID,const NET_IN_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataIn,NET_OUT_SET_PARKING_SPACE_LIGHT_PLAN* pNetDataOut,int nWaitTime);

// CLIENT_SyncParkingInfo 地磁车位同步上报车位信息入参
typedef struct tagNET_IN_SYNC_PARKING_INFO
{
	DWORD			dwSize;													// 结构体大小
	int				nChannel;												// 通道号
	char			szParkingNum[32];											// 车位编号
	DWORD			dwPresetNum;											// 预置点编号
	BOOL			bHaveCar;												// 车位是否有车
	BOOL			bParkingFault;											// 车位是否有故障
	int				nSnapTimes;												// 补拍次数（取值范围：0-5）
	int				nSnapIntervel;											// 补拍间隔（取值范围：3-10）
}NET_IN_SYNC_PARKING_INFO;

// CLIENT_SyncParkingInfo 地磁车位同步上报车位信息出参
typedef struct tagNET_OUT_SYNC_PARKING_INFO
{
	DWORD			dwSize;													// 结构体大小
}NET_OUT_SYNC_PARKING_INFO;

// 球机定制，地磁车位同步上报车位信息,如有车停入、或车从车位开出
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SyncParkingInfo(LLONG lLoginID, const NET_IN_SYNC_PARKING_INFO* pNetIn, NET_OUT_SYNC_PARKING_INFO* pNetOut, int nWaitTime);


/************************************************************************
 ** 分布式车辆人员结构化查询协议
 ***********************************************************************/
//结构化事件中图片信息
typedef struct tagDEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO
{
    char                     szCutPicPath[MAX_PATH];          // 此字段表示抠图的HTTP路径
    DWORD                    dwWidth;                         // 图片宽度
    DWORD                    dwHeight;                        // 图片高度
    BYTE                     byReserved[256];                 // 保留字节
} DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO;

//人员结构化查找条件或者结果，人员信息
typedef struct tagDEV_PERSON_CONDITION_RESULT_FEATURE_INFO 
{
    EM_DEV_EVENT_FACEDETECT_SEX_TYPE        emSex;                      // 性别
    BYTE                                    byAge;                      // 年龄
    BYTE                                    byCall;                     // 是否在打电话 , 0-未识别 1-不打电话 2-打电话
    BYTE                                    byHat;                      // 是否戴帽子   , 0-未识别 1-不戴帽子 2-戴帽子
    BYTE                                    byBag;                      // 是否背包     , 0-未识别 1-不背包   2-背包
    BYTE                                    byUmbrella;                 // 是否打伞     , 0-未识别 1-不打伞   2-打伞
    BYTE                                    byGlasses;                  // 是否戴眼镜   , 0-未识别 1-不戴眼镜 2-戴眼镜
    BYTE                                    byReserved1[2];             // 字节对齐
    EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE    emEmotion;                  // 表情:微笑,愤怒, 悲伤, 厌恶, 害怕, 惊讶, 正常, 大笑
    NET_COLOR_RGBA                          stuUpperBodyColor;          // 上半身颜色
    NET_COLOR_RGBA                          stuLowerBodyColor;          // 下半身颜色
    BYTE                                    byReserved[256];            // 保留字节
} DEV_PERSON_CONDITION_FEATURE_INFO,DEV_PERSON_RESULT_FEATURE_INFO;

// 行人特征检测事件 EVENT_IVS_OBJECTSTRUCTLIZE_PERSON
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO
{
    int                                    nChannelID;                           // 通道号
    char                                   szName[DH_EVENT_NAME_LEN];            // 事件名称
    BYTE                                   bReserved1[4];                        // 字节对齐
    double                                 dbPTS;                                // 时间戳(单位是毫秒)
    NET_TIME_EX                            stuUTC;                               // 事件发生的时间
    int                                    nEventID;                             // 事件ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                          // 事件对应文件信息
    int                                    nEventAction;                         // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

	char                                   szFilePath[MAX_PATH];                 // 大图文件路径
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                     // 行人特征
    NET_RECT                               stuBoundingBoxRect;                   // 行人在大图中的包围盒坐标,Rect格式8192坐标系
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                         // 大图中行人抠图图片信息

    int                                    nImageIndex;                          // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD                                  dwSnapFlagMask;                       // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE                                   bReserved[1024];                      // 保留字节,留待扩展. 
} DEV_EVENT_OBJECTSTRUCTLIZE_PERSON_INFO;

//非机动车特征检测事件(三轮车、摩托车、自动车etc),由于非机动上一定有人，因此事件的内容和行人特征检测事件有重叠，但算法的检测主体是非机动车.
typedef struct tagDEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO
{
    int                                    nChannelID;                            // 通道号
    char                                   szName[DH_EVENT_NAME_LEN];             // 事件名称
    BYTE                                   bReserved1[4];                         // 字节对齐
    double                                 dbPTS;                                 // 时间戳(单位是毫秒)
    NET_TIME_EX                            stuUTC;                                // 事件发生的时间
    int                                    nEventID;                              // 事件ID
    DH_EVENT_FILE_INFO                     stuFileInfo;                           // 事件对应文件信息
    int                                    nEventAction;                          // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
    
	char                                   szFilePath[MAX_PATH];                  // 大图文件路径
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];// 车牌号码 
    DEV_PERSON_RESULT_FEATURE_INFO         stuPersonFeatrue;                      // 非机动车上人员特征
    NET_RECT                               stuBoundingBoxRect;                    // 非机动车在大图中的包围盒坐标,Rect格式8192坐标系
    DEV_ALARM_OBJECTSTRUCTLIZE_PIC_INFO    stuImageInfo;                          // 大图中的非机动车抠图信息

    int                                    nImageIndex;                           // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
    DWORD                                  dwSnapFlagMask;                        // 抓图标志(按位),具体见 NET_RESERVED_COMMON    
    BYTE                                   bReserved[1024];                       // 保留字节,留待扩展. 
} DEV_EVENT_OBJECTSTRUCTLIZE_NONMOTOR_INFO;


//倒地报警事件信息，对应 DH_ALARM_TUMBLE_DETECTION 报警
typedef struct tagALARM_TUMBLE_DETECTION_INFO       
{     
	int									nAction;							// 事件动作,1表示报警开始,2表示报警结束;
	int									nChannelID;							// 通道号
    double								PTS;								// 时间戳(单位是毫秒)
    NET_TIME_EX							UTC;								// 事件发生的时间
    int									nEventID;							// 事件ID
	int									UTCMS;								// UTC时间对应的毫秒数
	EM_CLASS_TYPE						emClassType;						// 智能事件所属大类
	int									nObjectID;							// 目标ID
	char								szObjectType[DH_COMMON_STRING_16];	// 物体类型,支持以下:
																			// "Unknown", "Human", "Vehicle", "Fire", "Smoke", "Plate", "HumanFace",
																			// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole", "Entity"
	NET_RECT							stuBoundingBox;						// 物体包围盒
	BYTE                				byReserved[1024];   				// 保留字节     
}ALARM_TUMBLE_DETECTION_INFO; 

//事件类型 EVENT_IVS_TUMBLE_DETECTION(倒地报警事件)对应数据块描述信息
typedef struct tagDEV_EVENT_TUMBLE_DETECTION_INFO
{
    int                     nChannelID;                             // 通道号
    char                    szName[DH_EVENT_NAME_LEN];              // 事件名称
	int						nAction;								// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
    double                  PTS;                                    // 时间戳(单位是毫秒)
    NET_TIME_EX             UTC;                                    // 事件发生的时间
    int                     nEventID;                               // 事件ID
	int						UTCMS;									// UTC时间对应的毫秒数	

	EM_CLASS_TYPE			emClassType;							// 智能事件所属大类		
	int						nObjectID;								// 目标ID
	char					szObjectType[DH_COMMON_STRING_16];		// 物体类型,支持以下:
																	//"Unknown", "Human", "Vehicle", "Fire", "Smoke", "Plate", "HumanFace",
																	// "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole", "Entity"
	NET_RECT				stuBoundingBox;							// 物体包围盒

	BYTE                    bReserved[1024];                        // 保留字节
} DEV_EVENT_TUMBLE_DETECTION_INFO;

//事件类型 EVENT_IVS_SPILLEDMATERIAL_DETECTION (抛洒物检测事件)对应数据块描述信息
typedef struct tagDEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO
{
	int						nChannelID;                         // 通道号
	char					szName[128];                        // 事件名称
	char					bReserved[4];						// 字节对齐
	double					PTS;                                // 时间戳(单位是毫秒)
	NET_TIME_EX				UTC;                                // 事件发生的时间
	int						nEventID;                           // 事件ID

	DH_MSG_OBJECT_EX		stuObjects[MAX_OBJECT_NUM_EX];      // 检测到的物体
	int						nObjectNum;							// 检测到的物体数量
	DH_EVENT_FILE_INFO		stuFileInfo;                        // 事件对应文件信息
	DH_POINT				stuDetectLine[DH_MAX_DETECT_LINE_NUM]; // 规则检测线
	int						nDetectLineNum;                     // 规则检测线顶点数
	DH_POINT				stuTrackLine[DH_MAX_TRACK_LINE_NUM];// 物体运动轨迹
	int						nTrackLineNum;                      // 物体运动轨迹顶点数
	BYTE					bEventAction;						// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
	BYTE					bReserved1[3];						// 保留字节
	NET_CROSSLINE_DIRECTION_INFO	emDirection;                // 表示入侵方向,（nObjectNum > 0时此字段无效，由stuObjects格式下emPersonDirection字段代替）
	int						nImageIndex;						// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
	DWORD					dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
	int						nSourceIndex;                       // 事件源设备上的index,-1表示数据无效,-1表示数据无效
	char					szSourceDevice[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
	unsigned int			nOccurrenceCount;                   // 事件触发累计次数
	EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;					// 智能事件公共信息
	NET_EXTENSION_INFO		stuExtensionInfo;                   // 扩展信息
	BYTE					byReserved[1028];                   // 保留字节,留待扩展.
}DEV_EVENT_SPILLEDMATERIAL_DETECTION_INFO;

// 人证对比图片信息
typedef struct tagCITIZEN_PICTURE_COMPARE_IMAGE_INFO
{
    DWORD           dwOffSet;                       // 文件在二进制数据块中的偏移位置, 单位:字节
    DWORD           dwFileLenth;                    // 文件大小, 单位:字节
    WORD            wWidth;                         // 图片宽度, 单位:像素
    WORD            wHeight;                        // 图片高度, 单位:像素
    BYTE            byReserved[256];                // 保留字节
}CITIZEN_PICTURE_COMPARE_IMAGE_INFO;

// 图片类型
typedef enum tagCITIZEN_PICTURE_COMPARE_TYPE
{
	CITIZEN_PICTURE_COMPARE_TYPE_UNKNOWN = -1,
	CITIZEN_PICTURE_COMPARE_TYPE_LOCAL,				// 本地人脸库图
	CITIZEN_PICTURE_COMPARE_TYPE_FACEMAP,			// 拍摄场景图
}CITIZEN_PICTURE_COMPARE_TYPE;

// 人证对比扩展图片信息
typedef struct tagCITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX
{
	CITIZEN_PICTURE_COMPARE_TYPE		emType;					// 图片类型
	DWORD								dwOffSet;               // 文件在二进制数据块中的偏移位置, 单位:字节
	DWORD								dwFileLenth;            // 文件大小, 单位:字节
	WORD								wWidth;                 // 图片宽度, 单位:像素
	WORD								wHeight;                // 图片高度, 单位:像素
	BYTE								byReserved[64];        // 保留字节
}CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX;

// 人证比对事件，用实时拍摄的人脸照片，和该人持有的身份证照片进行比对，并上报检测结果
// 对应事件类型为 EVENT_IVS_CITIZEN_PICTURE_COMPARE
typedef struct tagDEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO
{
    //公共字段
    int                 nChannelID;                         // 通道号,从0开始
    int                 nEventAction;					    // 事件动作, 0表示脉冲, -1表示未知
    double              dbPTS;                              // 时间戳(单位是毫秒)
    char                szName[DH_EVENT_NAME_LEN];          // 事件名称    
    NET_TIME_EX         stuUTC;                             // 事件发生的时间
    int                 nEventID;                           // 事件ID

    //事件对应字段
    bool                bCompareResult;                     // 人证比对结果,相似度大于等于阈值认为比对成功,true表示成功,false表示失败
    BYTE                nSimilarity;                        // 两张图片的相似度,单位百分比,范围[1,100]
    BYTE                nThreshold;                         // 检测阈值,范围[1,100]
    EM_CITIZENIDCARD_SEX_TYPE emSex;                        // 性别
    int                 nEthnicity;                         // 民族(参照DEV_EVENT_ALARM_CITIZENIDCARD_INFO的nEthnicity定义)
    char                szCitizen[DH_COMMON_STRING_64];     // 居民姓名    
    char                szAddress[DH_COMMON_STRING_256];    // 住址
    char                szNumber[DH_COMMON_STRING_64];      // 身份证号
    char                szAuthority[DH_COMMON_STRING_256];  // 签发机关
    NET_TIME            stuBirth;                           // 出生日期(年月日)
    NET_TIME            stuValidityStart;                   // 有效期限起始日期(年月日)
    BOOL                bLongTimeValidFlag;                 // 该值为 TRUE, 截止日期 表示长期有效,此时 stuValidityEnd 值无意义
                                                            // 该值为 FALSE, 此时 截止日期 查看 stuValidityEnd 值
    NET_TIME            stuValidityEnd;                     // 有效期限结束日期(年月日)
    CITIZEN_PICTURE_COMPARE_IMAGE_INFO stuImageInfo[2];     // 图片信息，第一张为拍摄照片，第二张为身份证照片
	char                szCardNo[DH_COMMON_STRING_32];      // IC卡号
	char                szCellPhone[DH_COMMON_STRING_20];   // 手机号（比对时先输入手机号）
	NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
	CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX	stuImageInfoEx[6];	// 图片扩展信息
	char				szCallNumber[20];					// 呼叫号码		
	NET_ACCESS_DOOROPEN_METHOD	emDoorOpenMethod;			// 开门方式（人证照片或者人证指纹）  
	UINT				nEventGroupID;						// 事件ID,用于不同事件进行关联
	UINT				nEventType;							// 事件类型：0：人证比对结果	1：人证人脸采集
	char				szUserID[32];						// 人证人脸采集时人员ID（定制）
    BYTE                byReserved[296];                    // 保留字节
}DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO;

// 物体查询范围
typedef struct tagDEV_OBJECT_FIND_SCOPE_INFO
{
    BOOL                bEnable;                    // 是否开启物体数量查询
	int                 nMinValue;                  // 最小查询值
	int                 nMaxValue;                  // 最大查询值
} DEV_OBJECT_FIND_SCOPE_INFO;

// 遮阳板查询范围
typedef struct tagDEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO
{
    BYTE                                   byFindType;                 // 查找遮阳板方式:1 按数量查找 2 按座位查找(必填,其他值无效)
	int                                    nMinSunShieldNum;           // 遮阳板个数最小查询值(选填)byFindType  为1时使用
    int                                    nMaxSunShieldNum;           // 遮阳板个数最大查询值(选填)byFindType  为1时使用
	NET_SUNSHADE_STATE                     emMasterShield;             // 主驾驶座位遮阳板状态(选填)byFindType  为2时使用
    NET_SUNSHADE_STATE                     emSlaveShield;              // 副驾驶座位遮阳板状态(选填)byFindType  为2时使用
} DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO;

//车辆结构化查找条件
typedef struct tagDEV_VEHICLE_CONDITION_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // 车牌号码 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // 车牌类型
	NET_COLOR_RGBA                         stuPlateColor;                                 // 车牌颜色
    EM_NET_VEHICLE_TYPE                    emVehicleType;                                 // 车辆类型 
	NET_COLOR_RGBA                         stuVehicleColor;                               // 车身颜色
    char                                   szVehicleLogo[32];                             // 车标
    WORD                                   wVehicleSubBrand;                              // 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
    WORD                                   wVehicleYearModel;                             // 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // 抓拍车的位置

    NET_SAFEBELT_STATE                     emMainSeat;                                    // 主驾驶座位安全带状态(选填)
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // 副驾驶座位安全带状态(选填)
	DEV_OBJECT_SUNSHIELD_FIND_SCOPE_INFO   stuSunShieldInfo;                              // 遮阳板查询信息(必填)
    DEV_OBJECT_FIND_SCOPE_INFO             stuDropInfo;                                   // 挂坠个数范围(选填)
    DEV_OBJECT_FIND_SCOPE_INFO             stuPaperBoxInfo;                               // 纸巾盒个数范围(选填)
    DEV_OBJECT_FIND_SCOPE_INFO             stuAnnualInspectionInfo;                       // 年检标个数范围(选填)
    BYTE                                   byReserved[256];                               // 保留字节
} DEV_VEHICLE_CONDITION_FEATURE_INFO;

//车辆结构化查询结果
typedef struct tagDEV_VEHICLE_RESULT_FEATURE_INFO 
{
    char                                   szPlateNumber[DH_MAX_PLATE_NUMBER_LEN];        // 车牌号码 
    EM_NET_PLATE_TYPE                      emPlateType;                                   // 车牌类型
	NET_COLOR_RGBA                         stuPlateColor;                                 // 车牌颜色
    NET_COLOR_RGBA                         stuVehicleColor;                               // 车身颜色
    char                                   szVehicleLogo[32];                             // 车标
    WORD                                   wVehicleSubBrand;                              // 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
    WORD                                   wVehicleYearModel;                             // 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
    int                                    nVehicleWindowNum;                             // 车窗个数                                        
    NET_RECT                               stuVehicleWindow[4];                           // 车窗位置,下标0表示前车窗，下标1表示后车窗，其余表示侧车窗
    EM_VEHICLE_DIRECTION                   emVehicleDirection;                            // 抓拍车的位置
    
    NET_SAFEBELT_STATE                     emMainSeat;                                    // 主驾驶座位安全带状态
    NET_SAFEBELT_STATE                     emSlaveSeat;                                   // 副驾驶座位安全带状态
    NET_RECT                               stuMasterShield;                               // 主驾驶座位遮阳板位置
    NET_RECT                               stuSlaveShield;                                // 副驾驶座位遮阳板位置
    int                                    nAnnualInspectionNum;                          // 年检标志个数                                        
    NET_RECT                               stuAnnualInspection[8];                        // 年检标志
    int                                    nDropNum;                                      // 挂坠个数                                        
    NET_RECT                               stuDrop[4];                                    // 挂坠位置
    int                                    nPaperBoxNum;                                  // 纸巾盒个数                                        
    NET_RECT                               stuPaperBox[4];                                // 纸巾盒位置
    BYTE                                   byReserved[256];                               // 保留字节
} DEV_VEHICLE_RESULT_FEATURE_INFO;

// 特征图片类型
typedef enum tagEM_PIC_FEATURE_TYPE
{
    EM_PIC_FEATURE_TYPE_UNKOWN,            // 未知类型
    EM_PIC_FEATURE_TYPE_GLOBAL_SENCE,      // 全景大图
    EM_PIC_FEATURE_TYPE_SMALL,             // 特写图
}EM_PIC_FEATURE_TYPE;

//图片请求信息,
typedef struct tagDEV_IMAGE_REQUEST_FEATURE_INFO
{
    EM_PIC_FEATURE_TYPE      emPicType;            // 图片类型(必填)
    DWORD                    dwoffset;             // 在二进制数据块中的偏移,单位:字节
    DWORD                    dwLength;             // 图片大小,单位:字节
    DWORD                    dwWidth;              // 图片宽度
    DWORD                    dwHeight;             // 图片高度
	BOOL                     bEnableRect;          // 是否开启Rect查询
    NET_RECT                 stuRect;              // (选填)图片为GlobalScene时，标示大图中的物体坐标，使用绝对坐标，即像素点实际位置
    BYTE                     byReserved[256];      // 保留字节
} DEV_IMAGE_REQUEST_FEATURE_INFO;

//图片结果信息
typedef struct tagDEV_IMAGE_RESULT_FEATURE_INFO
{
    DWORD                   dwSimilarity;                   // 图片的相似度,范围0~100
    NET_TIME                stuTime;                        // 图片检测/入库时间

	DWORD                   dwObjectOffset;                 // 特写图在二进制数据块中的偏移,单位字节(取决于请求的NeedData)
	DWORD                   dwObjectLength;                 // 特写图片大小,单位字节(取决于请求的NeedData)
    char                    szObjectFilePath[MAX_PATH];     // 特写图HTTP文件路径(取决于请求的NeedData)

	DWORD                   dwSceneOffset;                  // 全景图在二进制数据块中的偏移,单位字节(取决于请求的NeedData)
	DWORD                   dwSceneLength;                  // 全景图图片大小,单位字节(取决于请求的NeedData)
    char                    szSceneFilePath[MAX_PATH];      // 全景图HTTP文件路径(取决于请求的NeedData)

    NET_RECT                stuObjectRect;                  // 小图在大图的位置，绝对像素点
    BYTE                    byReserved[256];                // 保留字节
} DEV_IMAGE_RESULT_FEATURE_INFO;

// CLIENT_DetectObjectStructlize 接口输入参数
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                                    dwSize; 
    int					                     nWidth;              // 图片宽度
    int                                      nHeight;             // 图片高度
    char                                     *pBuffer;            // 图片二进制数据缓冲地址, 由用户申请
    int                                      nBufferLen;          // 图片二进制数据缓冲数据长度
}NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC;

// 检测到的物体信息
typedef struct tagNET_OBJECT_DETECTED_INFO
{
    DH_POINT                         stuPoint;                       // 小图左上角在大图的位置, 使用绝对坐标系
    DWORD                            dwWidth;                        // 图片宽度
    DWORD                            dwHeight;                       // 图片高度
    char                             szObjectType[16];               // 物体类型, 参考 NET_OBJFILTER_INFO 的 szObjectType 说明
    char                             szObjectSubType[32];            // 物体类型中的子类别, 参考 NET_OBJFILTER_INFO 的 szObjectSubType 说明
    DEV_PERSON_RESULT_FEATURE_INFO   stuPersonResult;                // 人员结构化查询结果
    DEV_VEHICLE_RESULT_FEATURE_INFO  stuVehicleResult;               // 车辆结构化查询结果
    BYTE                             byReserved[512];                // 保留字节
} NET_OBJECT_DETECTED_INFO;

// CLIENT_DetectObjectStructlize 接口输出参数
typedef struct tagNET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC
{
    DWORD                          dwSize; 
    int                            nObjectNum;                                // 检测到的物体个数
    NET_OBJECT_DETECTED_INFO       stuObjectinfos[DH_MAX_OBJECT_LIST];        // 检测到的物体
}NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC;

// 结构化查询状态信息回调函数, lAttachHandle是 CLIENT_AttachObjectStructlizeFindState 的返回值
typedef struct tagNET_CB_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD               dwSize;     
    int                 nToken;         //查询令牌
    int                 nProgress;      //正常取值范围：0-100,-1,表示查询token不存在(当订阅一个不存在或结束的查询时)
    int                 nCurrentCount;  //目前符合查询条件的数量
}NET_OBJECTSTRUCTLIZE_FIND_STATE;

// 结构化查询订阅状态回调函数
// pstStates 的个数由 nStateNum 指出 
typedef void (CALLBACK *fObjectStructlizeFindState)(LLONG lLoginID, LLONG lAttachHandle, NET_OBJECTSTRUCTLIZE_FIND_STATE* pstStates, int nStateNum, LDWORD dwUser);

// CLIENT_AttachObjectStructlizeFindState 接口输入参数
typedef struct tagNET_IN_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD                              dwSize;             //结构体大小,必须填写
    
    int                                nTokenNum;          //查询令牌数,为0时,表示订阅所有的查询任务
    int                                nTokens[8];         //查询令牌
    fObjectStructlizeFindState         cbObjectSFindState; //回调函数
    LDWORD                             dwUser;             //用户数据
}NET_IN_OBJECTSTRUCTLIZE_FIND_STATE;

// CLIENT_AttachObjectStructlizeFindState 接口输出参数
typedef struct  tagNET_OUT_OBJECTSTRUCTLIZE_FIND_STATE
{
    DWORD           dwSize;
 }NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE;

// CLIENT_StartFindObjectStructlize 接口输入参数
typedef struct tagNET_IN_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD                                      dwSize;
    int                                        nChannelNum;                    // 通道数量
    int                                        stuChannelID[16];               // 所有的通道号
	BOOL                                       bTimeEnable;                    // 启用时间段查询
    NET_TIME                                   stStartTime;                    // (选填)开始时间,查询抓拍库需要,注册库不需要
    NET_TIME                                   stEndTime;                      // (选填)结束时间,查询抓拍库需要,注册库不需要
    //以下为查询过滤条件
    char                                       szObjectType[16];               // (必填)物体类型, 同 NET_OBJFILTER_INFO 字段
    char                                       szObjectSubType[32];            // (选填)物体类型中的子类别，同 NET_OBJFILTER_INFO 字段
    int                                        nSimilarity;                    // (必填)和查询图片的相似度，百分比,范围0~100

    DEV_PERSON_CONDITION_FEATURE_INFO          stuPersonCondition;             // 人员查找信息，可以只填部分，多个条件是AND关系
    DEV_VEHICLE_CONDITION_FEATURE_INFO         stuVehicleCondition;            // 车辆查找条件，可以只填部分，多个条件是AND关系
    DEV_IMAGE_REQUEST_FEATURE_INFO             stuImageRequestInfo;            // 图片信息
    int                                        nRectNum;                       // 有效的特征框坐标个数
    NET_RECT                                   stuRect[4];                     // 特征框坐标
    
    // 图片二进制数据
    char                                       *pBuffer;                       // 缓冲地址, 有用户申请
    int                                        nBufferLen;                     // 缓冲数据长度         
}NET_IN_STARTFIND_OBJECTSTRUCTLIZE;

// CLIENT_StartFindObjectStructlize 接口输出参数
typedef struct tagNET_OUT_STARTFIND_OBJECTSTRUCTLIZE
{
    DWORD               dwSize;
    int                 nTotalCount;                   // 返回的符合查询条件的记录个数 
    // -1表示总条数未生成,要推迟获取
    // 使用 CLIENT_AttachObjectStructlizeFindState 接口状态
    
    LLONG               lFindHandle;                   // 查询句柄
    int                 nToken;                        // 获取到的查询令牌
}NET_OUT_STARTFIND_OBJECTSTRUCTLIZE;



// CLIENT_DoFindObjectStructlize 接口输入参数
typedef struct tagNET_IN_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                          dwSize;
    LLONG                          lFindHandle;                // (必填)查询句柄
    int                            nBeginNum;                  // (必填)查询起始序号,0<=beginNumber<= totalCount-1
    int                            nCount;                     // (必填)当前想查询的记录条数 
    EM_NEEDED_PIC_RETURN_TYPE      emNeededData;               // (必填)查询结果返回图片格式    
}NET_IN_DOFIND_OBJECTSTRUCTLIZE;

// doFind检测到的物体信息
typedef struct tagNET_DODBFIND_OBJECT_DETECTED_INFO
{
    int                                nChannelID;                       // 通道号
    char                               szObjectType[16];                 // 物体类型, 同 NET_OBJFILTER_INFO 字段
    char                               szObjectSubType[32];              // 物体类型中的子类别, 同 NET_OBJFILTER_INFO 字段
    DEV_PERSON_RESULT_FEATURE_INFO     stuPersonResult;                  // 人员结构化查询结果
    DEV_VEHICLE_RESULT_FEATURE_INFO    stuVehicleResult;                 // 车辆结构化查询结果
    int                                nImageNum;                        // 检测到的图片个数，查询抓拍库数组长度1;注册库数组长度可能大于1
    DEV_IMAGE_RESULT_FEATURE_INFO      stuImageResults[4];               // 检测到的图片信息结果
    BYTE                               byReserved[512];                  // 保留字节
} NET_DODBFIND_OBJECT_DETECTED_INFO;

// CLIENT_DoFindObjectStructlize 接口输出参数
typedef struct tagNET_OUT_DOFIND_OBJECTSTRUCTLIZE
{
    DWORD                                  dwSize;
    int                                    nfoundNum;                                // 查询到的条数
    int                                    nObjectNum;                               // 检测到的物体个数
    NET_DODBFIND_OBJECT_DETECTED_INFO      stuObjectinfos[DH_MAX_OBJECT_LIST];       // 检测到的物体
    
    // 图片二进制数据
    char                                   *pBuffer;                                // 缓冲地址, 有用户申请
    int                                    nBufferLen;                              // 缓冲数据长度
	int                                    nBufRet;                                 // 实际返回的长度
}NET_OUT_DOFIND_OBJECTSTRUCTLIZE;

// 进行特征值提取, 以图搜图 pstInParam 与 pstOutPara m内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetectObjectStructlize(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_DETECT_PIC* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_DETECT_PIC *pstOutParam, int nWaitTime );

// 订阅结构化查询状态 pstInParam 与 pstOutParam 内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachObjectStructlizeFindState(LLONG lLoginID, const NET_IN_OBJECTSTRUCTLIZE_FIND_STATE* pstInParam, NET_OUT_OBJECTSTRUCTLIZE_FIND_STATE *pstOutParam, int nWaitTime );

// 取消结构化查询状态 lAttachHandle 为 CLIENT_AttachObjectStructlizeFindState 返回的句柄
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachObjectStructlizeFindState(LLONG lAttachHandle);

// 按条件查询结构化识别结果 pstInParam 与 pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartFindObjectStructlize(LLONG lLoginID, const NET_IN_STARTFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_STARTFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// 查找结构化识别结果:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕(每次最多只能查询20条记录),pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindObjectStructlize(const NET_IN_DOFIND_OBJECTSTRUCTLIZE* pstInParam, NET_OUT_DOFIND_OBJECTSTRUCTLIZE *pstOutParam, int nWaitTime );

// 结束结构化查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindObjectStructlize(LLONG lFindHandle);

// 接口 CLIENT_GetSubModuleInfo 输入参数
typedef struct tagNET_IN_GET_SUBMODULES_INFO
{
    DWORD                       dwSize;    
}NET_IN_GET_SUBMODULES_INFO;

// 模块状态
typedef enum tagEM_STATE_SUBMODULE
{
    EM_STATE_SUBMODULES_UNKNOWN,
    EM_STATE_SUBMODULES_NORMAL,                  // 正常
    EM_STATE_SUBMODULES_EXCEPTION,               // 异常
}EM_STATE_SUBMODULE;

// 子模块信息
typedef struct tagNET_SUBMODULES_INFO 
{
    char                        szModuleName[DH_COMMON_STRING_32];      // 模块名称
    char                        szHardwareVersion[DH_COMMON_STRING_64]; // 硬件版本信息
    char                        szSoftwareVersion[DH_COMMON_STRING_64]; // 软件版本信息
    EM_STATE_SUBMODULE          emState;                                // 模块状态    
    BYTE                        byReserve[512];             
}NET_SUBMODULES_INFO;

// 接口CLIENT_GetSubModuleInfo 输出参数
typedef struct tagNET_OUT_GET_SUBMODULES_INFO
{
    DWORD                       dwSize; 
    int                         nRetNum;                                // 返回的子模块数量
    NET_SUBMODULES_INFO         stuSubModuleInfo[MAX_SUBMODULE_NUM];    // 子模块信息
}NET_OUT_GET_SUBMODULES_INFO;

// 获取子模块信息
CLIENT_NET_API  BOOL  CALL_METHOD  CLIENT_GetSubModuleInfo(LLONG lLoginID, const NET_IN_GET_SUBMODULES_INFO* pstInParam, NET_OUT_GET_SUBMODULES_INFO* pstOutParam, int nWaitTime);

// CLIENT_GetSoftwareVersion 入参
typedef struct tagNET_IN_GET_SOFTWAREVERSION_INFO
{
	DWORD                       dwSize;                                 // 结构体大小
}NET_IN_GET_SOFTWAREVERSION_INFO;

// CLIENT_GetSoftwareVersion 出参
typedef struct tagNET_OUT_GET_SOFTWAREVERSION_INFO
{
	DWORD                       dwSize;                                 // 结构体大小
	char                        szVersion[DH_COMMON_STRING_64];         // 软件版本
	NET_TIME                    stuBuildDate;                           // 日期
	char                        szWebVersion[DH_COMMON_STRING_16];      // web软件信息
	char                        szSecurityVersion[DH_COMMON_STRING_64]; // 安全基线版本
}NET_OUT_GET_SOFTWAREVERSION_INFO;

// 获取软件版本
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSoftwareVersion(LLONG lLoginID, const NET_IN_GET_SOFTWAREVERSION_INFO* pstInParam, NET_OUT_GET_SOFTWAREVERSION_INFO* pstOutParam, int nWaitTime);

// CLIENT_GetDeviceType 入参
typedef struct tagNET_IN_GET_DEVICETYPE_INFO
{
	DWORD                       dwSize;                                 // 结构体大小
}NET_IN_GET_DEVICETYPE_INFO;

// CLIENT_GetDeviceType 出参
typedef struct tagNET_OUT_GET_DEVICETYPE_INFO
{
	DWORD                       dwSize;                                 // 结构体大小
	char                        szType[DH_COMMON_STRING_32];            // 设备类型,该字段被废弃
    char                        szTypeEx[DH_COMMON_STRING_256];            // 设备类型, 扩展设备类型建议使用此字段
}NET_OUT_GET_DEVICETYPE_INFO;

// 获取设备类型
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDeviceType(LLONG lLoginID, const NET_IN_GET_DEVICETYPE_INFO* pstInParam, NET_OUT_GET_DEVICETYPE_INFO* pstOutParam, int nWaitTime);



typedef enum tagEM_STATIS_GRANULARITY
{
	EM_STATIS_GRANULARITY_UNKNOWN,					// 未知类型
	EM_STATIS_GRANULARITY_BY_HOUR,					// 按小时取一个样本点数据
	EM_STATIS_GRANULARITY_BY_DAY,					// 按天取一个样本点数据
	EM_STATIS_GRANULARITY_BY_MONTH,					// 按月取一个样本点数据
}EM_STATIS_GRANULARITY;
//CLIENT_StartFindExternalSensor 接口输入参数
typedef struct tagNET_IN_STARTFIND_EXTERNALSENSOR
{
	DWORD						dwSize;
	NET_TIME					stStartTime;					// 开始时间
	NET_TIME					stEndTime;						// 结束时间
	EM_STATIS_GRANULARITY		emGranularity;					// 查询要求返回的统计信息粒度："Hour"按小时；"Day"每天取一个样本点数据；"Month"每月每天取一个样本点数据
	UINT						nVideoChannel;					// 视频通道号，DVR/NVR对接时需要。单目IPC可以不填或填0
	UINT						nIndex;							// 外部传感器通道号
	UINT						nRecordHour;					// 样本时间点，单位小时,范围[0,23],"szGranularity"值为"Day"或"Month"时有效

}NET_IN_STARTFIND_EXTERNALSENSOR;

// CLIENT_StartFindExternalSensor 接口输出参数
typedef struct tagNET_OUT_STARTFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// 查询令牌
	UINT				nTotalCount;									// 符合此次查询条件的总条数
}NET_OUT_STARTFIND_EXTERNALSENSOR;

// 开始查询外部传感器数据
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindExternalSensor(LLONG lLoginID, const NET_IN_STARTFIND_EXTERNALSENSOR* pstInParam, NET_OUT_STARTFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// CLIENT_DoFindExternalSensor 接口输入参数
typedef struct tagNET_IN_DOFIND_EXTERNALSENSOR
{
	DWORD				dwSize;
	UINT				nToken;											// 查询令牌
	UINT				nBegin;											// 查询起始序号，表示从begin条记录开始，取nCount条记录返回
	UINT				nCount;											// 每次查询的条数
}NET_IN_DOFIND_EXTERNALSENSOR;

typedef struct tagNET_FIND_EXTERNALSENSOR_INFO
{
	UINT				nVideoChannel;									// 视频通道号
	UINT				nIndex;											// 外部传感器通道号
	NET_TIME			stRecordTime;									// 外部传感器数据存储时间
	double				dbData;											// 外部传感器数据
	BYTE				byReserve[1024];								// 保留字节
}NET_FIND_EXTERNALSENSOR_INFO;

// CLIENT_DoFindExternalSensor 接口输出参数
typedef struct tagNET_OUT_DOFIND_EXTERNALSENSOR
{
	DWORD								dwSize;
	UINT								nFound;							// 查询到的条数
	UINT								nMazNum;						// 查询条数
	NET_FIND_EXTERNALSENSOR_INFO*		pstuInfo;						// 外部传感器数据查询结果，用户分配内存,大小为sizeof(NET_FIND_EXTERNALSENSOR_INFO)*nMazNum
}NET_OUT_DOFIND_EXTERNALSENSOR;

// 获取符合查询条件的外部传感器数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindExternalSensor(LLONG lFindHandle, const NET_IN_DOFIND_EXTERNALSENSOR* pstInParam, NET_OUT_DOFIND_EXTERNALSENSOR* pstOutParam, int nWaitTime);

// 停止查询外部传感器数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindExternalSensor(LLONG lFindHandle);

// 获取跟踪盒显示配置
typedef struct tagNET_CFG_TRACKBOX
{
	int				nVideoChannel;				// 视频通道号
	BOOL			bTargetBox;					// 是否显示目标框
	BOOL			bTrackBox;					// 是否显示跟踪框
	BOOL			bTargetNumber;				// 是否显示目标编号
	BYTE			byReserved[1024];
}NET_CFG_TRACKBOX;

typedef struct tagNET_IN_GET_TRACKBOX
{
	DWORD				dwSize;
	int					nVideoChannel;				// 视频通道号
}NET_IN_GET_TRACKBOX;

typedef struct tagNET_OUT_GET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuGetTrackBox;
}NET_OUT_GET_TRACKBOX;

// 获取跟踪盒显示配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackBox(LLONG lLoginID, const NET_IN_GET_TRACKBOX* pstInParam, NET_OUT_GET_TRACKBOX *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKBOX
{
	DWORD				dwSize;
	NET_CFG_TRACKBOX	stuSetTrackBox;
}NET_IN_SET_TRACKBOX;

typedef struct tagNET_OUT_SET_TRACKBOX
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKBOX;

// 设置跟踪盒显示配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackBox(LLONG lLoginID, const NET_IN_SET_TRACKBOX* pstInParam, NET_OUT_SET_TRACKBOX *pstOutParam, int nWaitTime);

// 跟踪模式
typedef enum tagEM_TRACK_MODE
{
	EM_TRACK_MODE_UNKNOWN = -1,						// 未知模式
	EM_TRACK_MODE_AUTO,								// 自动跟踪
	EM_TRACK_MODE_SINGLE,							// 单目标跟踪
	EM_TRACK_MODE_MANUAL,							// 手动控制
	EM_TRACK_MODE_ALARM								// 报警跟踪
}EM_TRACK_MODE;

typedef struct tagNET_CFG_TRACKMODE
{
	int					nVideoChannel;				// 视频通道号
	EM_TRACK_MODE		emTrackMode;				// 跟踪模式
	BYTE				byReserved[1024];			// 保留字段
}NET_CFG_TRACKMODE;

typedef struct tagNET_IN_GET_TRACKMODE
{
	DWORD				dwSize;
	int					nVideoChannel;				// 视频通道号
}NET_IN_GET_TRACKMODE;

typedef struct tagNET_OUT_GET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuGetTrackMode;
}NET_OUT_GET_TRACKMODE;

// 获取跟踪模式
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetTrackMode(LLONG lLoginID, const NET_IN_GET_TRACKMODE* pstInParam, NET_OUT_GET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_IN_SET_TRACKMODE
{
	DWORD				dwSize;
	NET_CFG_TRACKMODE	stuSetTrackMode;
}NET_IN_SET_TRACKMODE;

typedef struct tagNET_OUT_SET_TRACKMODE
{
	DWORD			dwSize;
}NET_OUT_SET_TRACKMODE;

// 设置跟踪模式
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetTrackMode(LLONG lLoginID, const NET_IN_SET_TRACKMODE* pstInParam, NET_OUT_SET_TRACKMODE *pstOutParam, int nWaitTime);

typedef struct tagNET_CFG_LINKPOS
{
	int					nVideoChannel;						// 视频通道号
	char				szBallip[DH_COMMON_STRING_64];		// 联动球机IP地址，可以忽略不填
	unsigned short		nX;									// 鼠标点击跟踪盒视频x坐标归一化值或鼠标框选矩形中心，范围[0,8191]
	unsigned short		nY;									// 鼠标点击跟踪盒视频y坐标归一化值或鼠标框选矩形中心y坐标归一化值，范围[0,8191]
	float				fZoom;								// zoom为负数表示点选联动，只联动不变倍。大于等于0，表示框选联动
	BYTE				byReserved[1024];					// 保留字段
}NET_CFG_LINKPOS;

typedef struct tagNET_IN_SET_LINKPOS
{
	DWORD				dwSize;
	NET_CFG_LINKPOS		stuSetLinkPos; 
}NET_IN_SET_LINKPOS;

typedef struct tagNET_OUT_SET_LINKPOS
{
	DWORD			dwSize;
}NET_OUT_SET_LINKPOS;

// 点选联动和框选联动
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLinkPos(LLONG lLoginID, const NET_IN_SET_LINKPOS* pstInParam, NET_OUT_SET_LINKPOS *pstOutParam, int nWaitTime);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++云存储服务器相关接口+++++++++++++++++++++++++++++++++++++++++++

// bucket名称信息
typedef struct tagNET_BUCKET_NAME_INFO
{
    char szName[DH_COMMON_STRING_64];                       // 名称
    BYTE byReserved[256];                                   // 保留字节
}NET_BUCKET_NAME_INFO;

// 开始查询bucket名称入参
typedef struct tagNET_IN_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // 结构体大小
    UINT nOffset;                                           // 查询偏移值
    UINT nCount;                                            // 查询数量    
}NET_IN_FIND_BUCKET_NAME;

// 开始查询bucket名称出参
typedef struct tagNET_OUT_FIND_BUCKET_NAME
{
    DWORD dwSize;                                           // 结构体大小
    UINT nTotalCount;                                       // 总的bucket名称数量
    UINT nFindCount;                                        // 实际查询到bucket名称数量
    NET_BUCKET_NAME_INFO* pBucketName;                      // bucket名称指针，由用户申请/释放内存，sdk会填充这块内存
    UINT nNameCount;                                        // bucket名称个数，用户填写    
}NET_OUT_FIND_BUCKET_NAME;

// bucket下面的文件名称信息
typedef struct tagNET_BUCKET_FILE_NAME_INFO
{
    char szName[DH_COMMON_STRING_1024];                     // 文件名称
    BYTE byReserved[256];                                   // 保留字节
}NET_BUCKET_FILE_NAME_INFO;

// 开始查询某个bucket下的文件名称信息入参
typedef struct tagNET_IN_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // 结构体大小    
    UINT nOffset;                                           // 查询偏移量
    UINT nCount;                                            // 查询数量
    char szBucketName[DH_COMMON_STRING_64];                 // bucket名称    
}NET_IN_FIND_BUCKET_FILE_NAME;

// 开始查询某个bucket下的文件名称信息出参
typedef struct tagNET_OUT_FIND_BUCKET_FILE_NAME
{
    DWORD dwSize;                                           // 结构体大小
    UINT nTotalCount;                                       // 总的文件名称数量
    UINT nFindCount;                                        // 查询到的文件名称数量
    NET_BUCKET_FILE_NAME_INFO* pFileName;                   // file名称指针，由用户申请/释放内存，sdk会填充这块内存
    UINT nFileCount;                                        // file名称个数，用户填写
}NET_OUT_FIND_BUCKET_FILE_NAME;

// 查询EFS设备系统中的bucket名称信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketName(LLONG lLoginID, const NET_IN_FIND_BUCKET_NAME* pstInParam, NET_OUT_FIND_BUCKET_NAME *pstOutParam, int nWaitTime );

// 查询某个bucket下面的文件名称信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindBucketFileName(LLONG lLoginID, const NET_IN_FIND_BUCKET_FILE_NAME* pstInParam, NET_OUT_FIND_BUCKET_FILE_NAME *pstOutParam, int nWaitTime );

// +++++++++++++++++++++++++++++++++++++++++++++++++++++云存储服务器相关接口+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++语音广播相关接口+++++++++++++++++++++++++++++++++++++++++++
//广播语音对讲数据回调函数原形
typedef void (CALLBACK *pfAudioBroadcastDataCallBack)(LLONG lSpeakHandle, char *pDataBuf, DWORD dwBufSize, int nToken, LDWORD dwUser);

// 对指定的通道进行语音广播的输入参数
typedef struct tagNET_IN_START_CHANNEL_INFO
{
	DWORD							dwSize;
	int 							nChannelCount;			// 指定的通道数量
	int								nChannel[32];			// 指定的通道号的列表
	pfAudioBroadcastDataCallBack 	pfcb;					// 广播语音对讲数据回调函数
	LDWORD 							dwUser;					// 用户数据
} NET_IN_START_CHANNEL_INFO;

// 对指定的通道进行语音广播的输出参数
typedef struct tagNET_OUT_START_CHANNEL_INFO
{
	DWORD					dwSize;
	int						nToken;					// 广播令牌
	int						nFrequency;				// 音频采样频率
	int						nDepth;					// 采样深度
	DH_TALK_CODING_TYPE		emCompressionType;		// 音频编码类型
} NET_OUT_START_CHANNEL_INFO;

//CLIENT_TalkChannelSendData输入参数
typedef struct tagNET_TALK_CHANNEL_SENDDATA_IN
{
	DWORD					dwSize;
	char 			   	   *pSendBuf;		// 需要发送的语音数据
	int 					nSendBufLen;	// 语音数据长度
} NET_TALK_CHANNEL_SENDDATA_IN;

//CLIENT_TalkChannelSendData输出参数
typedef struct tagNET_TALK_CHANNEL_SENDDATA_OUT
{
	DWORD					dwSize;
} NET_TALK_CHANNEL_SENDDATA_OUT;

// 对指定的通道进行广播语音
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTalkChannel(LLONG lLoginID, const NET_IN_START_CHANNEL_INFO *pstInParam, NET_OUT_START_CHANNEL_INFO *pstOutParam, int nWaitTime);

// 对指定的通道发送语音数据
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_TalkChannelSendData(LLONG lSpeakHandle, const NET_TALK_CHANNEL_SENDDATA_IN *pstInParam, NET_TALK_CHANNEL_SENDDATA_OUT *pstOutParam, int nWaitTime);

// 结束语音广播
CLIENT_NET_API BOOL  CALL_METHOD CLIENT_StopTalkChannel(LLONG lSpeakHandle);
// +++++++++++++++++++++++++++++++++++++++++++++++++++++语音广播相关接口+++++++++++++++++++++++++++++++++++++++++++



// 初始化设备账户输入结构体
typedef struct tagNET_IN_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;										// 结构体大小:初始化结构体时赋值
	char					szMac[DH_MACADDR_LEN];						// 设备mac地址	
	char					szUserName[MAX_USER_NAME_LEN];				// 用户名
	char					szPwd[MAX_PWD_LEN];							// 设备密码
	char					szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// 预留手机号
	char					szMail[MAX_MAIL_LEN];						// 预留邮箱
	BYTE					byInitStatus;								// 此字段已经废弃															
	BYTE					byPwdResetWay;								// 设备支持的密码重置方式：搜索设备接口(CLIENT_SearchDevices、CLIENT_StartSearchDevices的回调函数、CLIENT_SearchDevicesByIPs)返回字段byPwdResetWay的值	
																		// 该值的具体含义见 DEVICE_NET_INFO_EX 结构体，需要与设备搜索接口返回的 byPwdResetWay 值保持一致
																		// bit0 : 1-支持预留手机号，此时需要在szCellPhone数组中填入预留手机号(如果需要设置预留手机) ; 
																		// bit1 : 1-支持预留邮箱，此时需要在szMail数组中填入预留邮箱(如果需要设置预留邮箱)
	BYTE					byReserved[2];								// 保留字段
}NET_IN_INIT_DEVICE_ACCOUNT;

// 初始化设备账户输出结构体
typedef struct tagNET_OUT_INIT_DEVICE_ACCOUNT
{
	DWORD					dwSize;// 结构体大小:初始化结构体时赋值
}NET_OUT_INIT_DEVICE_ACCOUNT;

// 初始化账户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccount(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, char* szLocalIp);

// 根据设备IP初始化账户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccountByIP(const NET_IN_INIT_DEVICE_ACCOUNT* pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT* pInitAccountOut, DWORD dwWaitTime, const char* szLocalIp,const char* szDeviceIP);

//开机向导流程入参
typedef struct tagNET_IN_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                       //结构体大小:初始化结构体时赋值
	char			  szMac[DH_MACADDR_LEN];	    // 设备mac地址	
	char			  szUserName[MAX_USER_NAME_LEN];// 账号名
	char			  szPwd[MAX_PWD_LEN];		    // 账号密码
	BYTE              byNetAccess;                  // 是否使能接入公网(Easy4IP/乐橙)0-不涉及，不处理1-关闭接入公网2-打开接入公网
	BYTE              byUpgradeCheck;               // 是否打开在线升级自动检测0-不涉及，不处理1-关闭在线升级自动检测2-开启在线升级自动检测
	BYTE              byReserved[2];                // 保留字节
	EM_VIDEO_STANDARD emVideoStandard;				// 视频制式
}NET_IN_INIT_DEVICE_ACCESS;

//开机向导流程出参
typedef struct tagNET_OUT_INIT_DEVICE_ACCESS
{
	DWORD             dwSize;                   // 结构体大小:初始化结构体时赋值
}NET_OUT_INIT_DEVICE_ACCESS;

// 开机向导流程，接入公网、在线升级检测等功能
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitDevAccess(const NET_IN_INIT_DEVICE_ACCESS* pInitAccessIn, NET_OUT_INIT_DEVICE_ACCESS* pInitAccessOut, DWORD dwWaitTime, char* szLocalIp);

// 获取重置密码信息输入结构体
typedef struct tagNET_IN_DESCRIPTION_FOR_RESET_PWD
{
	DWORD					dwSize;								// 结构体大小:初始化结构体时赋值
	char					szMac[DH_MACADDR_LEN];				// 设备mac地址
	char					szUserName[MAX_USER_NAME_LEN];		// 用户名	
	BYTE					byInitStatus;						// 设备初始化状态：搜索设备接口(CLIENT_SearchDevices、CLIENT_StartSearchDevices的回调函数、CLIENT_SearchDevicesByIPs)返回字段byInitStatus的值
	BYTE					byReserved[3];						// 保留字段
}NET_IN_DESCRIPTION_FOR_RESET_PWD;

// 获取重置密码信息输出结构体
typedef struct tagNET_OUT_DESCRIPTION_FOR_RESET_PWD
{
	DWORD			dwSize;										// 结构体大小:初始化结构体时赋值
	char			szCellPhone[MAX_CELL_PHONE_NUMBER_LEN];		// 预留手机号
	char			szMailAddr[MAX_MAIL_LEN];					// 预留邮箱
	char*			pQrCode;									// 二维码信息,用户分配内存（当前大小为360字节）
	unsigned int	nQrCodeLen;									// 用户分配的二维码信息长度
	unsigned int    nQrCodeLenRet;								// 设备返回的二维码信息长度
}NET_OUT_DESCRIPTION_FOR_RESET_PWD;

// 获取重置信息:手机号、邮箱、二维码信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDescriptionForResetPwd(const NET_IN_DESCRIPTION_FOR_RESET_PWD* pDescriptionIn, NET_OUT_DESCRIPTION_FOR_RESET_PWD* pDescriptionOut, DWORD dwWaitTime, char* szLocalIp);


// 重置密码输入结构体
typedef struct tagNET_IN_RESET_PWD
{
	DWORD					dwSize;								// 结构体大小:初始化结构体时赋值
	char					szMac[DH_MACADDR_LEN];				// 设备mac地址	
	char					szUserName[MAX_USER_NAME_LEN];		// 用户名
	char					szPwd[MAX_PWD_LEN];					// 密码
	char					szSecurity[MAX_SECURITY_CODE_LEN];	// 平台发送到预留手机或邮箱中的安全码
	BYTE					byInitStaus;						// 设备初始化状态：搜索设备接口(CLIENT_SearchDevices、CLIENT_StartSearchDevices的回调函数、CLIENT_SearchDevicesByIPs)返回字段byInitStatus的值
	BYTE					byPwdResetWay;						// 设备支持的密码重置方式：搜索设备接口(CLIENT_SearchDevices、CLIENT_StartSearchDevices的回调函数、CLIENT_SearchDevicesByIPs)返回字段byPwdResetWay的值
    BYTE					byReserved[2];						// 保留字段			
    char                    szContact[MAX_CONTACT_LEN];         // 用户输入安全码需输入接收安全码的联系方式，如果bSetContact为TRUE，则该联系方式将作为预留联系方式
    BOOL                    bSetContact;                        // 是否同意设置为预留手机号, TRUE:同意; FALSE:不同意		
}NET_IN_RESET_PWD;

// 重置密码输出结构体
typedef struct tagNET_OUT_RESET_PWD
{
	DWORD					dwSize;// 结构体大小:初始化结构体时赋值
}NET_OUT_RESET_PWD;

// 重置密码
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetPwd(const NET_IN_RESET_PWD* pResetPwdIn, NET_OUT_RESET_PWD* pResetPwdOut, DWORD dwWaitTime, char* szLocalIp);

// 账户类型
typedef enum tagEM_ACCOUNT_TYPE
{
    EM_ACCOUNT_TYPE_UNKNOWN,                                    // 未知的
    EM_ACCOUNT_TYPE_SDK,                                        // sdk账户体系
    EM_ACCOUNT_TYPE_WEB,                                        // web账户体系
}EM_ACCOUNT_TYPE;

// 初始化账户入参
typedef struct tagNET_IN_INIT_ACCOUNT
{
    DWORD					dwSize;								// 结构体大小:初始化结构体时赋值    
    char					szUser[MAX_USER_NAME_LEN];		    // 用户名
    char					szPwd[MAX_PWD_LEN];					// 密码
    char                    szMac[DH_MACADDR_LEN];              // 设备的Mac地址
    EM_ACCOUNT_TYPE         emAccountType;                      // 账号类型
}NET_IN_INIT_ACCOUNT;

// 初始化账户出参
typedef struct tagNET_OUT_INIT_ACCOUNT
{
    DWORD               dwSize;								// 结构体大小:初始化结构体时赋值  		
}NET_OUT_INIT_ACCOUNT;

// 重置WEB密码入参
typedef struct tagNET_IN_REST_WEB_PWD
{
    DWORD					dwSize;								// 结构体大小:初始化结构体时赋值   
    char					szWebUser[MAX_USER_NAME_LEN];		// web用户名
    char					szWebPwd[MAX_PWD_LEN];			    // 重置后的web密码
}NET_IN_REST_WEB_PWD;

// 重置WEB密码出参
typedef struct tagNET_OUT_REST_WEB_PWD
{
    DWORD               dwSize;								// 结构体大小:初始化结构体时赋值  		
}NET_OUT_REST_WEB_PWD;

// 初始化账户
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitAccount(const NET_IN_INIT_ACCOUNT* pInitAccountIn, NET_OUT_INIT_ACCOUNT* pInitAccountOut, int nWaitTime, char* szLocalIp);

// 指定设备IP进行账号初始化
CLIENT_NET_API BOOL CALL_METHOD CLIENT_InitAccountByIP( const NET_IN_INIT_ACCOUNT* pInitAccountIn, NET_OUT_INIT_ACCOUNT* pInitAccountOut, int nWaitTime, char* szLocalIp, const char* szDeviceIP);

// 重置web账户密码
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetWebPwd(LLONG lLoginID,const NET_IN_REST_WEB_PWD* pstInParam, NET_OUT_REST_WEB_PWD* pstOutParam, int nWaitTime);


// 校验安全码输入结构体
typedef struct tagNET_IN_CHECK_AUTHCODE
{
	DWORD					dwSize;									// 结构体大小:初始化结构体时赋值
	char					szMac[DH_MACADDR_LEN];					// 设备mac地址
	char					szSecurity[MAX_SECURITY_CODE_LEN];		// 平台发送到预留手机或邮箱中的安全码
    char                    szContact[MAX_CONTACT_LEN];             // 用户输入安全码需输入接收安全码的联系方式
}NET_IN_CHECK_AUTHCODE;


// 校验安全码输出结构体
typedef struct tagNET_OUT_CHECK_AUTHCODE
{
	DWORD					dwSize;//结构体大小:初始化结构体时赋值
}NET_OUT_CHECK_AUTHCODE;

// 检验安全码
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckAuthCode(const NET_IN_CHECK_AUTHCODE* pCheckAuthCodeIn, NET_OUT_CHECK_AUTHCODE* pCheckAuthCodeOut, DWORD dwWaitTime, char* szLocalIp);



// 设置360全景运动相机媒体工作模式入参
typedef struct tagNET_IN_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
    UINT                    nMediaMode;                             // 相机工作模式,0:抓图模式,1:录像模式,2:Live模式
}NET_IN_SET_EVEREST360_MEDIAMODE;


// 设置360全景运动相机媒体工作模式出参
typedef struct tagNET_OUT_SET_EVEREST360_MEDIAMODE
{
    DWORD					dwSize;				
}NET_OUT_SET_EVEREST360_MEDIAMODE;

// 设置360全景运动相机媒体工作模式
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetEverest360MediaMode(LLONG lLoginID, const NET_IN_SET_EVEREST360_MEDIAMODE *pstInParam, NET_OUT_SET_EVEREST360_MEDIAMODE *pstOutParam, int nWaitTime);

// CLIENT_GetPwdSpecification 输入结构体
typedef struct tagNET_IN_PWD_SPECI
{
	DWORD		dwSize;					// 结构体大小
	char		szMac[DH_MACADDR_LEN];	// 设备mac地址
}NET_IN_PWD_SPECI;

// CLIENT_GetPwdSpecification 输出结构体
typedef struct tagNET_OUT_PWD_SPECI
{
	DWORD			dwSize;										// 结构体大小
	unsigned int	nMaxPwdLen;									// 最大密码长度
	unsigned int	nMinPwdLen;									// 最小密码长度	
	char			szType[MAX_PWD_BASIC_CHARS_ARRAY_LEN];		// 支持的基本字符类型列表：其中Number数字；Lower小写字母；Upper大写字母，字符串形式:"Number,Lower,Upper"
	char			szCharList[MAX_PWD_SPEC_CHARS_ARRAY_LEN];	// 支持的特殊字符，如"~!@#$%^" 
	int				nCombine;									// 密码组合要求：0-无特殊要求；1-必须有特殊字符，其它不限；2-必须包含2种类型以上(数字、大写、小写、特殊字符)
}NET_OUT_PWD_SPECI;

// 获取密码规范
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPwdSpecification(const NET_IN_PWD_SPECI* pPwdSpeciIn, NET_OUT_PWD_SPECI* pPwdSpeciOut, DWORD dwWaitTime, char* szLocalIp);

// CLIENT_SetLowRateWPANPower入参
typedef struct tagNET_IN_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// 结构体大小
    int             nPower;                                     // 发射功率
    char            szSmartLockNum[MAX_COMMON_STRING_32];       // 智能锁序列号
}NET_IN_SET_LOWRATEWPAN_POWER;

// CLIENT_SetLowRateWPANPower出参
typedef struct tagNET_OUT_SET_LOWRATEWPAN_POWER
{
    DWORD			dwSize;										// 结构体大小   
}NET_OUT_SET_LOWRATEWPAN_POWER;

// 设置无线门锁发射功率
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetLowRateWPANPower(LLONG lLoginID, const NET_IN_SET_LOWRATEWPAN_POWER *pstInParam, NET_OUT_SET_LOWRATEWPAN_POWER *pstOutParam, int nWaitTime);

// 门禁控制器操作类型
typedef enum tagNET_EM_ACCESS_CTL_MANAGER
{
    NET_EM_ACCESS_CTL_MANAGER_ADDDEVICE,                        // 添加单个分控器, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
    NET_EM_ACCESS_CTL_MANAGER_MODIFYDEVICE,                     // 修改分控器名称, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
    NET_EM_ACCESS_CTL_MANAGER_REMOVEDEVICE,                     // 删除分控器, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_INFO,                    // 获取分控器信息, 对应结构体 pstInParam = NET_IN_GET_SUB_CONTROLLER_INFO, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_INFO
    NET_EM_ACCESS_CTL_GETSUBCONTROLLER_STATE,                   // 获取分控器状态, 对应结构体 pstInParam = NET_IN_GET_SUB_CONTROLLER_STATE, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_STATE
    NET_EM_ACCESS_CTL_SET_REPEAT_ENTERROUTE,                    // 设置反潜路径信息, 对应结构体 pstInparam = NET_IN_SET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_SET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_GET_REPEAT_ENTERROUTE,                    // 获取反潜路径信息, 对应结构体 pstInparam = NET_IN_GET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_GET_REPEAT_ENTERROUTE
    NET_EM_ACCESS_CTL_SET_ABLOCK_ROUTE,                         // 设置AB互锁路径信息, 对应结构体 pstInparam = NET_IN_SET_ABLOCK_ROUTE, pstOutParam = NET_OUT_SET_ABLOCK_ROUTE
    NET_EM_ACCESS_CTL_GET_ABLOCK_ROUTE,                         // 获取AB互锁路径信息, 对应结构体 pstInparam = NET_IN_GET_ABLOCK_ROUTE, pstOutParam = NET_OUT_GET_ABLOCK_ROUTE
    NET_EM_ACCESS_CTL_GET_LOGSTATUS,                            // 获取日志同步状态,对应结构体 pstInparam = NET_IN_GET_LOGSTATUS, pstOutParam = NET_OUT_GET_LOGSTATUS 
    NET_EM_ACCESS_CTL_SYNCHRO_OFFLINE_LOG,                      // 同步离线日志, 对应结构体 pstInparam = NET_IN_SYNCHRO_OFFLINE_LOG, pstOutParam = NET_OUT_SYNCHRO_OFFLINE_LOG 
    NET_EM_ACCESS_CTL_SYNCHRO_TIME,                             // 同步分控器时间,对应结构体 pstInparam = NET_IN_SYNCHRO_CONTROLLER_TIME, pstOutParam = NET_OUT_SYNCHRO_CONTROLLER_TIME 
    NET_EM_ACCESS_CTL_SET_QRCODEDECODE_INFO,                    // 设置二维码的解码信息, 对应结构体 pstInparam = NET_IN_SET_QRCODE_DECODE_INFO, pstOutParam = NET_OUT_SET_QRCODE_DECODE_INFO 
}NET_EM_ACCESS_CTL_MANAGER;

// 添加分控器入参
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // 分控器ID，取值范围 1~255
    char            szSubControllerName[MAX_COMMON_STRING_128]; // 分控器名称
}NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE;

// 添加分控器出参
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
{
    DWORD           dwSize;   
    int             nErrorCode;                                 // 错误码0-	添加成功, 1-重复添加,2-已满,3-其他类型失败
}NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE;

// 修改分控器入参
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID;                           // 分控器ID，取值范围 0~255,0为本地
    char            szSubControllerName[MAX_COMMON_STRING_128]; // 分控器名称
}NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// 修改分控器出参
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
{
    DWORD           dwSize;
}NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE;

// 删除分控器入参
typedef struct tagNET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD           dwSize;
    int             nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM]; // 分控器ID, 取值范围 1~255
    int             nSubControllerNum;                          // 需要删除的分控器数量
}NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// 删除返回结果
typedef struct tagNET_REMOVEDEVICE_RESULT
{
    int             nSubControllerID;                           // 分控器ID
    int             nErrorCode;                                 // 返回结果, 0-删除成功,1-删除失败 2-未分配
    BYTE            byReserved[128];                            
}NET_REMOVEDEVICE_RESULT;

// 删除分控器出参
typedef struct tagNET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
{
    DWORD                       dwSize;
    int                         nResultNum;
    NET_REMOVEDEVICE_RESULT     stuResult[MAX_ACCESSSUBCONTROLLER_NUM];     
}NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE;

// 获取分控器信息入参
typedef struct tagNET_IN_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器ID, 取值范围 -1~255, -1:获取所有,0:获取本地,1~255:外置分控
    int                         nSubControllerNum;                              // 需要查询的分控器数量
}NET_IN_GET_SUB_CONTROLLER_INFO;

// 单双向
typedef enum  tagNET_EM_ACCESS_PROPERTY
{
    NET_EM_ACCESS_PROPERTY_UNKNOWN,                                             // 未知
    NET_EM_ACCESS_PROPERTY_BIDIRECT,                                            // 双向门禁
    NET_EM_ACCESS_PROPERTY_UNIDIRECT,                                           // 单向门径
}NET_ACCESS_PROPERTY;

// 读卡器信息
typedef struct tagNET_CARDREAD_INFO 
{
    int                         nDoor;                                          // 门序号
    int                         nReadNum;                                       // 读卡器数量
    char                        szReadID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32];  // 读卡器ID
    BYTE                        byReserved[64];  
}NET_CARDREAD_INFO;

// 分控器信息
typedef struct tagNET_SUB_CONTROLLER_INFO 
{
    int                         nSubControllerID;                               // 分控器ID，取值范围 0~255,0为本地
    char                        szSubControllerName[MAX_COMMON_STRING_128];     // 分控器名称
    NET_ACCESS_PROPERTY         emProperty;                                     // 门禁单双向
    char                        szDeviceType[MAX_COMMON_STRING_128];            // 分控器型号
    char                        szVesion[MAX_COMMON_STRING_128];                // 分控器版本号
    int                         nDoorNum;                                       // 门数量
    NET_CARDREAD_INFO           stuReaderInfo[MAX_ACCESSDOOR_NUM];              // 门对应的读卡器号
    BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_INFO;

// 获取分控器信息出参
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_INFO
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_INFO     stuSubControllerInfo[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器信息
    int                         nRetNum;                                            // 查询到的分控器数量
}NET_OUT_GET_SUB_CONTROLLER_INFO;

// 获取分控器状态入参
typedef struct tagNET_IN_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];      // 分控器ID, 取值范围 -1~255, -1:获取所有,0:获取本地,1~255:外置分控
    int                         nSubControllerNum;                                  // 需要查询的分控器数量
}NET_IN_GET_SUB_CONTROLLER_STATE;

// 分控器状态信息
typedef struct tagNET_SUB_CONTROLLER_STATE
{
    int                         nSubControllerID;                                   // 分控器ID
    int                         nState;                                             // 0:离线 1:在线 2:未分配
    BYTE                        byReserved[128];
}NET_SUB_CONTROLLER_STATE;

// 获取分控器状态出参
typedef struct tagNET_OUT_GET_SUB_CONTROLLER_STATE
{
    DWORD                       dwSize;
    NET_SUB_CONTROLLER_STATE    stuSubControllerState[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器信息
    int                         nRetNum;                                             // 查询到的分控器数量
}NET_OUT_GET_SUB_CONTROLLER_STATE;

// 反潜路径点信息
typedef struct tagNET_POINT_READER_INFO
{
    int                         nReaderNum;                                         // 反潜点的读卡器数量
    char                        szReaderID[MAX_ACCESS_READER_NUM][DH_COMMON_STRING_32]; // 读卡器ID 
    BYTE                        byReserved[128];
}NET_POINT_READER_INFO;

// 设置反潜路径入参
typedef struct tagNET_IN_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // 反潜路径索引号
    int                         nPointNum;                                           // 路径上的点数量
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // 点信息
    int                         nTimeSection;                                        // 门禁时间段配置AccessTimeSchedule下标，详细请查询dhconfigsdk.h
    BOOL                        bFlag;                                               // 是否启用
    char                        szRouteName[MAX_COMMON_STRING_128];                  // 路径名称
}NET_IN_SET_REPEAT_ENTERROUTE;

// 设置反潜路径出参
typedef struct tagNET_OUT_SET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_REPEAT_ENTERROUTE;

// 获取反潜路径入参
typedef struct tagNET_IN_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // 反潜路径索引号
}NET_IN_GET_REPEAT_ENTERROUTE;

// 获取反潜路径出参
typedef struct tagNET_OUT_GET_REPEAT_ENTERROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // 路径上的点数量
    NET_POINT_READER_INFO       stuPointInfo[MAX_ACCESS_POINT_NUM];                  // 点信息
    int                         nTimeSection;                                        // 门禁时间段配置AccessTimeSchedule下标，详细请查询dhconfigsdk.h
    BOOL                        bFlag;                                               // 是否启用
    char                        szRouteName[MAX_COMMON_STRING_128];                  // 路径名称
}NET_OUT_GET_REPEAT_ENTERROUTE;

// AB互锁门信息
typedef struct tagNET_POINT_DOOR_INFO
{
    int                         nDoorNum;                                           // AB互锁门数量
    int                         nDoorID[MAX_ACCESSDOOR_NUM];                        // AB互锁门组合
    BYTE                        byReserved[128];
}NET_POINT_DOOR_INFO;

// 设置AB互锁入参
typedef struct tagNET_IN_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // AB互锁路径索引号
    int                         nPointNum;                                           // AB互锁的点数量
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // 点信息
    int                         nTimeSection;                                        // 门禁时间段配置AccessTimeSchedule下标，详细请查询dhconfigsdk.h
    BOOL                        bFlag;                                               // 是否启用
    char                        szRouteName[MAX_COMMON_STRING_128];                  // AB互锁路线名称
}NET_IN_SET_ABLOCK_ROUTE;

// 设置AB互锁出参
typedef struct tagNET_OUT_SET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
}NET_OUT_SET_ABLOCK_ROUTE;

// 获取AB互锁路径信息入参
typedef struct tagNET_IN_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    UINT                        nIndex;                                              // AB互锁路径索引号
}NET_IN_GET_ABLOCK_ROUTE;

// 获取AB互锁路径信息出参
typedef struct tagNET_OUT_GET_ABLOCK_ROUTE
{
    DWORD                       dwSize;
    int                         nPointNum;                                           // AB互锁的点数量
    NET_POINT_DOOR_INFO         stuPointInfo[MAX_ACCESS_POINT_NUM];                  // 点信息
    int                         nTimeSection;                                        // 门禁时间段配置AccessTimeSchedule下标，详细请查询dhconfigsdk.h
    BOOL                        bFlag;                                               // 是否启用
    char                        szRouteName[MAX_COMMON_STRING_128];                  // AB互锁路线名称
}NET_OUT_GET_ABLOCK_ROUTE;

// 获取离线日志状态入参
typedef struct tagNET_IN_GET_LOGSTATUS
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // 分控器ID   范围1 ~255
}NET_IN_GET_LOGSTATUS;

// 获取离线日志状态出参
typedef struct tagNET_OUT_GET_LOGSTATUS
{
    DWORD                       dwSize;
    BOOL                        bsynchronize;                                         // true 正在同步 false 没有同步
}NET_OUT_GET_LOGSTATUS;

// 同步离线日志入参
typedef struct tagNET_IN_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
    int                         nControllerID;                                        // 分控器ID   范围0 ~255
}NET_IN_SYNCHRO_OFFLINE_LOG;

// 同步离线日志出参
typedef struct tagNET_OUT_SYNCHRO_OFFLINE_LOG
{
    DWORD                       dwSize;
}NET_OUT_SYNCHRO_OFFLINE_LOG;

// 同步分控器时间入参
typedef struct tagNET_IN_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器ID, 取值范围 -1~255, -1:获取所有,0:获取本地,1~255:外置分控
    int                         nSubControllerNum;                              // 同步的分控器数量    
}NET_IN_SYNCHRO_CONTROLLER_TIME;

// 同步分控器时间出参
typedef struct tagNET_OUT_SYNCHRO_CONTROLLER_TIME
{
    DWORD                       dwSize;
    int                         nSubControllerID[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器信息
    int                         nRetNum;                                        // 返回失败的分控器数量, 0表示全部成功    
}NET_OUT_SYNCHRO_CONTROLLER_TIME;

// 使用的加密算法
typedef enum tagNET_ENUM_QRCODE_CIPHER
{
	NET_ENUM_QRCODE_CIPHER_UNKNOWN, 
    NET_ENUM_QRCODE_CIPHER_AES256,                                              // AES-256
}NET_ENUM_QRCODE_CIPHER;

// 设置二维码的解码信息入参
typedef struct tagNET_IN_SET_QRCODE_DECODE_INFO
{
    DWORD                       dwSize;
    NET_ENUM_QRCODE_CIPHER      emCipher;                                       // 加密方式
    char                        szKey[33];                                      // 秘钥
    BYTE                        byReserved[3];                                  // 字节对齐
}NET_IN_SET_QRCODE_DECODE_INFO;

// 设置二维码的解码信息出参
typedef struct tagNET_OUT_SET_QRCODE_DECODE_INFO
{
    DWORD                       dwSize;

}NET_OUT_SET_QRCODE_DECODE_INFO;

//设置门禁安全等级入参
typedef struct tagNET_IN_SET_SAFE_LEVEL
{
	DWORD 						dwSize;							//结构体大小
	BYTE						byLevel;						//安全等级:1.安全 2.消防 3.紧急
	BYTE						byReserved[3];					//字节对齐
}NET_IN_SET_SAFE_LEVEL;

//设置门禁安全等级出参
typedef struct tagNET_OUT_SET_SAFE_LEVEL
{
	DWORD						dwSize;
}NET_OUT_SET_SAFE_LEVEL;


//门禁控制器操作接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessControlManager(LLONG lLoginID, NET_EM_ACCESS_CTL_MANAGER emtype, const void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_SetSmartLockUserName 入参
typedef struct tagNET_IN_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// 结构体大小
	NET_ACCESS_METHOD			emType;										// 开锁方式类型
    char						szSerialNumber[MAX_COMMON_STRING_32];       // 智能锁序列号
	char						szUserID[MAX_COMMON_STRING_16];				// 用户ID(非AccessControlCard记录集中的UserID概念)
	char						szName[MAX_COMMON_STRING_32];				// 需要修改成的名称
} NET_IN_SET_SMART_LOCK_USERNAME;

// CLIENT_SetSmartLockUserName 出参
typedef struct tagNET_OUT_SET_SMART_LOCK_USERNAME
{
    DWORD						dwSize;										// 结构体大小   
} NET_OUT_SET_SMART_LOCK_USERNAME;

// 智能锁修改用户信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetSmartLockUsername(LLONG lLoginID, const NET_IN_SET_SMART_LOCK_USERNAME *pstInParam, NET_OUT_SET_SMART_LOCK_USERNAME *pstOutParam, int nWaitTime);

#define MAX_NUMBER_REGISTER_INFO	32

// CLIENT_GetSmartLockRegisterInfo 入参 (每次获取最多获取32条信息)
typedef struct tagNET_IN_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD			dwSize;										// 结构体大小
    char            szSerialNumber[MAX_COMMON_STRING_32];       // 设备序列号
	int				nOffset;									// 用户列表的偏移量
} NET_IN_GET_SMART_LOCK_REGISTER_INFO;

// 注册用户的信息
typedef struct tagNET_SMART_LOCK_REGISTER_INFO
{
	NET_ACCESS_METHOD			emType;										// 开锁方式类型
	char						szUserID[MAX_COMMON_STRING_16];				// 用户ID(非AccessControlCard记录集中的UserID概念)
	char						szName[MAX_COMMON_STRING_32];				// 用户名称
	BYTE						byReserved[512];							// 保留字段	
} NET_SMART_LOCK_REGISTER_INFO;

// CLIENT_GetSmartLockRegisterInfo 出参
typedef struct tagNET_OUT_GET_SMART_LOCK_REGISTER_INFO
{
    DWORD							dwSize;						// 结构体大小   
	int								nTotalCount;				// 总的用户数量
	int								nReturnCount;				// 实际返回的用户数量
	NET_SMART_LOCK_REGISTER_INFO	stuRegisterInfo[MAX_NUMBER_REGISTER_INFO];	// 注册用户的信息
} NET_OUT_GET_SMART_LOCK_REGISTER_INFO;

// 获取当前智能锁的注册用户信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSmartLockRegisterInfo(LLONG lLoginID, const NET_IN_GET_SMART_LOCK_REGISTER_INFO *pstInParam, NET_OUT_GET_SMART_LOCK_REGISTER_INFO *pstOutParam, int nWaitTime);

// 卡片信息
typedef struct tagNET_SMARTLOCK_CARDINFO
{
    NET_ACCESS_METHOD			    emType;                                     // 开门类型
    int                             nIndex;                                     // 用户信息序号
    char                            szCardNo[32];                               // 卡号
    NET_ACCESSCTLCARD_TYPE          emCardType;                                 // 卡类型
    char						    szReserve[512];					            // 保留字段
}NET_SMARTLOCK_CARDINFO;

// 密码信息
typedef struct tagNET_SMARTLOCK_PWDINFO
{
    NET_ACCESS_METHOD			    emType;                                     // 开门类型
    int                             nIndex;                                     // 用户信息序号
    char                            szPassword[32];                             // 密码
    UINT                            dwUseTime;                                  // 使用次数
    char						    szReserve[512];					            // 保留字段
}NET_SMARTLOCK_PWDINFO;

// 指纹信息
typedef struct tagNET_SMARTLOCK_FPINFO
{
    NET_ACCESS_METHOD			    emType;                                     // 开门类型
    int                             nIndex;                                     // 用户信息序号
    int                             nFingerprintLen;                            // 指纹数据长度,不超过1.5K
    char*                           pFingerprintData;                           // 指纹数据
    char						    szReserve[512];					            // 保留字段
}NET_SMARTLOCK_FPINFO;

// CLIENT_UpdateSmartLockUser 入参
typedef struct tagNET_IN_SMARTLOCK_UPDATE_USER_INFO 
{
    DWORD							dwSize;						                // 结构体大小
    char                            szSerialNumber[32];                         // 设备序列号
    char                            szCredentialHolder[16];                     // 身份拥有者(与AccessControlCard记录集中的UserID概念一致)
    char                            szUserName[32];                             // 用户名称
    NET_TIME                        stuStartTime;                               // 起始时间
    NET_TIME                        stuEndTime;                                 // 结束时间
    char						    szReserve[512];					            // 保留字段
    int                             nCardInfoNum;                               // 卡信息数量
    NET_SMARTLOCK_CARDINFO          stuCardInfo[4];                             // 卡的信息
    int                             nPwdInfoNum;                                // 密码信息数量
    NET_SMARTLOCK_PWDINFO           stuPwdInfo[4];                              // 密码信息
    int                             nFingerPrintInfoNum;                        // 密码信息数量
    NET_SMARTLOCK_FPINFO            stuFingerPrintInfo[4];                      // 指纹信息
	int								nTaskID;									// 任务ID
}NET_IN_SMARTLOCK_UPDATE_USER_INFO;

// CLIENT_UpdateSmartLockUser 出参
typedef struct tagNET_OUT_SMARTLOCK_UPDATE_USER_INFO 
{
    DWORD							dwSize;						                // 结构体大小      
}NET_OUT_SMARTLOCK_UPDATE_USER_INFO;

// 智能锁添加更新用户信息接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_UpdateSmartLockUser(LLONG lLoginID, const NET_IN_SMARTLOCK_UPDATE_USER_INFO *pstInParam,NET_OUT_SMARTLOCK_UPDATE_USER_INFO *pstOutParam, int nWaitTime);

// CLIENT_RemoveSmartLockUser 入参
typedef struct tagNET_IN_SMARTLOCK_REMOVE_USER_INFO
{
    DWORD							dwSize;						                // 结构体大小
    char                            szSerialNumber[32];                         // 设备序列号
    char                            szCredentialHolder[16];                     // 身份拥有者(与AccessControlCard记录集中的UserID概念一致)
    NET_ACCESS_METHOD			    emType;                                     // 开门类型,unknown 表示全部
    int                             nIndex;                                     // 某种开门方式的索引号，-1表示全部
	int								nTaskID;									// 任务ID
}NET_IN_SMARTLOCK_REMOVE_USER_INFO;

// CLIENT_RemoveSmartLockUser 出参
typedef struct tagNET_OUT_SMARTLOCK_REMOVE_USER_INFO
{
    DWORD							dwSize;						                // 结构体大小
}NET_OUT_SMARTLOCK_REMOVE_USER_INFO;

// 智能锁删除用户接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveSmartLockUser(LLONG lLoginID, const NET_IN_SMARTLOCK_REMOVE_USER_INFO *pstInParam, NET_OUT_SMARTLOCK_REMOVE_USER_INFO *pstOutParam, int nWaitTime);

// 用户信息
typedef struct tagMATRIX_CAMERA_USERS_INFO 
{	
	unsigned int				nChannel;						// 通道
	char						szUser[MAX_USER_NAME_LEN];		// 用户名
    char						szPwd[MAX_PWD_LEN];				// 密码
	char						szReserve[512];					// 保留字段
}MATRIX_CAMERA_USERS_INFO;

// CLIENT_MatrixGetCameraUsers 输入结构体
typedef struct tagNET_IN_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;							// 结构体大小	
	unsigned int				nStartChannel;					// 起始查询通道
	unsigned int				nChannelCount;					// 一次获取的通道数量	
}NET_IN_MATRIX_GET_CAMERA_USERS;

// CLIENT_MatrixGetCameraUsers 输出结构体
typedef struct tagNET_OUT_MATRIX_GET_CAMERA_USERS
{
	DWORD						dwSize;							// 结构体大小
	MATRIX_CAMERA_USERS_INFO*	pstuUserInfo;					// 返回的用户信息数组，用户分配及释放内存，大小为sizeof(MATRIX_CAMERA_USERS_INFO)*nChannelCount,其中nChannelCount为NET_IN_MATRIX_GET_CAMERA_USERS中字段																
	unsigned int				nChannelCountRet;				// 返回的通道数量
}NET_OUT_MATRIX_GET_CAMERA_USERS;

// 获取前端设备用户名密码信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MatrixGetCameraUsers(LLONG lLoginID, const NET_IN_MATRIX_GET_CAMERA_USERS* pInParam, NET_OUT_MATRIX_GET_CAMERA_USERS* pOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++MPT接入NVR相关接口+++++++++++++++++++++++++++++++++++++++++++

// MPT状态
typedef struct tagNET_MPT_STATUS
{
    EM_MPT_STATE eState;                                            // MPT接入状态
    char szSerialNumber[DH_COMMON_STRING_32];                       // MPT设备序列号,在state为2或3时有值
    BYTE byReserved[256];                                           // 保留字节
}NET_MPT_STATUS;

// 获取MPT设备状态入参
typedef struct tagNET_IN_GET_MPT_STATUS
{
    DWORD					dwSize;									// 结构体大小:初始化结构体时赋值
    UINT                    nOffset;                                // 从第几个USB槽开始
    UINT                    nCount;                                 // 获取几个USB槽
}NET_IN_GET_MPT_STATUS;

#define MAX_MPT_STATUS_NUM (64)                                     // MPT状态信息最大个数

// 获取MPT设备状态出参
typedef struct tagNET_OUT_GET_MPT_STATUS
{
    DWORD					dwSize;									// 结构体大小:初始化结构体时赋值
    UINT                    nTotalUsbNum;                           // 总的USB槽数量
    UINT                    nStatusNum;                             // 获取的MPT状态数量
    NET_MPT_STATUS          stuStatus[MAX_MPT_STATUS_NUM];          // 获取的MPT状态数据
}NET_OUT_GET_MPT_STATUS;

// 获取USB槽接入的MPT状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMPTStatus(LLONG lLoginID,const NET_IN_GET_MPT_STATUS* pstInParam, NET_OUT_GET_MPT_STATUS* pstOutParam, DWORD dwWaitTime);

//  MPT状态类型
typedef enum tagEM_MPTSTATUS_TYPE
{
    EM_MPTSTATUS_UNKNOWN,           // 未知
    EM_MPTSTATUS_MPTBASE,           // MPT底座连接状态,  pOutParam = NET_MPTBASE_STATUS_INFO
    EM_MPTSTATUS_EXTCAMERA,         // 外置摄像头工作状态, pOutParam = NET_EXTCAMERA_STATUS_INFO
    EM_MPTSTATUS_NETCONNECT,        // 网络连接方式, pOutParam = NET_NETCONNECT_STATUS_INFO
} EM_MPTSTATUS_TYPE;

// MPT 底座连接状态类型
typedef enum tagNEM_MPTBASE_TYPE
{
    NEM_MPTBASE_UNKNOWN,                // 未知
    NEM_MPTBASE_ON,                     // ON
    NEM_MPTBASE_OFF,                    // OFF
} NEM_MPTBASE_TYPE;

// 外置摄像头工作状态类型
typedef enum tagEM_EXTCAMERA_TYPE
{
    EM_EXTCAMERA_UNKNOWN,               // 未知
    EM_EXTCAMERA_NORMAL,                //Normal
    EM_EXTCAMERA_ABNORMAL,              //Abnormal
} EM_EXTCAMERA_TYPE;

// 网络连接方式类型
typedef enum tagEM_NETCONNECT_TYPE
{
    EM_NETCONNECT_UNKNOWN,              // 未知
    EM_NETCONNECT_WIFI,                 // WIFI
    EM_NETCONNECT_MOBILE,               // Mobile
    EM_NETCONNECT_CABLE,                // Cable
    EM_NETCONNECT_MPTBASE,              // MptBase
} EM_NETCONNECT_TYPE;

// MPT底座连接状态信息
typedef struct tagNET_MPTBASE_STATUS_INFO
{
    DWORD                   dwSize;                                 // 结构体大小:初始化结构体时赋值
    NEM_MPTBASE_TYPE        emMptBase;                              // MPT 底座连接状态类型
} NET_MPTBASE_STATUS_INFO;

// 外置摄像头工作状态信息
typedef struct tagNET_EXTCAMERA_STATUS_INFO
{
    DWORD                   dwSize;                                 // 结构体大小:初始化结构体时赋值
    EM_EXTCAMERA_TYPE       emExtCamera;                            // 外置摄像头工作状态类型
} NET_EXTCAMERA_STATUS_INFO;

// 网络连接方式信息
typedef struct tagNET_NETCONNECT_STATUS_INFO
{
    DWORD                   dwSize;                                 // 结构体大小:初始化结构体时赋值
    EM_NETCONNECT_TYPE      emNetConnect;                           // 网络连接方式类型
} NET_NETCONNECT_STATUS_INFO;


// 获取MPT 设备的信息状态
CLIENT_NET_API BOOL CALL_METHOD	CLIENT_QueryMPTStatus(LLONG lLoginID, const EM_MPTSTATUS_TYPE emStatusType, void* pstOutParam, DWORD dwWaitTime);

#define MAX_POLICE_ID_NUM 32                                        // 写入的警员ID最大数量

// 需要写入的警员ID信息
typedef struct tagNET_WRITE_POLICE_ID_INFO
{
    int                     nUsbSlot;                                               // 要写入警员ID的usb槽编号
    int                     nPoliceIDCount;                                         // 要写入的警员ID的数量                         
    char                    szPoliceID[MAX_POLICE_ID_NUM][DH_COMMON_STRING_32];     // 要写入的警员ID数据
    BYTE                    byReserved[512];                                        // 保留字节
}NET_WRITE_POLICE_ID_INFO;

#define MAX_POLICE_ID_INFO_NUM 64                                                   // 最大警员信息数量

// 向MPT设备写入警员ID信息入参
typedef struct tagNET_IN_WRITE_POLICE_ID
{
    DWORD					    dwSize;						                        // 结构体大小:初始化结构体时赋值
    int                         nIDInfoNum;                                         // 警员ID信息数量
    NET_WRITE_POLICE_ID_INFO    stuIDInfo[MAX_POLICE_ID_INFO_NUM];                  // 警员ID信息数据
}NET_IN_WRITE_POLICE_ID;

// 向MPT设备写入警员ID信息出参
typedef struct tagNET_OUT_WRITE_POLICE_ID
{
    DWORD					dwSize;									                // 结构体大小:初始化结构体时赋值
    int                     nResultCount;                                           // 写入结果数量
    BOOL                    bResult[MAX_POLICE_ID_INFO_NUM];                        // 接入结果数据 0-成功,1-失败
}NET_OUT_WRITE_POLICE_ID;

// 向MPT写入警员ID信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WritePoliceID(LLONG lLoginID,const NET_IN_WRITE_POLICE_ID* pstInParam, NET_OUT_WRITE_POLICE_ID* pstOutParam, DWORD dwWaitTime);

#define MAX_MPT_MEDIA_TYPE_NUM 64                                                   // MPT录像文件类型最大个数

// 水平旋转组边界模式
typedef enum tagNET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE
{
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_UNKNOWN,			// 未知
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_LEFT,				// 左边界
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_RIGHT,				// 右边界
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_UP,					// 上边界
	NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE_DOWN,				// 下边界
} NET_EM_HORIZONTAL_ROTATION_GROUP_LIMITMODE_TYPE; 

// 标记MPT录像文件入参
typedef struct tagNET_IN_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// 结构体大小:初始化结构体时赋值
    int                     nChannelID;                             // 通道号
    NET_TIME                stuStartTime;                           // 起始时间
    NET_TIME                stuEndTime;                             // 结束时间
    int                     nMediaTypeCount;                        // 文件类型个数                        
    int                     nMediaType[MAX_MPT_MEDIA_TYPE_NUM];     // 文件类型数据,0:任意类型, 1:jpg图片, 2:dav文件
    int                     nCrimeType;                             // 犯罪类型
    int                     nCrimeTag;                              // 犯罪标记
    char                    szComment[DH_COMMON_STRING_256];        // 用户对文件做的备注
}NET_IN_MARK_MPT_RECORD_FILE;

// 标记MPT录像文件出参
typedef struct tagNET_OUT_MARK_MPT_RECORD_FILE
{
    DWORD					dwSize;									// 结构体大小:初始化结构体时赋值   
}NET_OUT_MARK_MPT_RECORD_FILE;

// 标记MPT录像文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MarkMPTRecordFile(LLONG lLoginID,const NET_IN_MARK_MPT_RECORD_FILE* pstInParam, NET_OUT_MARK_MPT_RECORD_FILE* pstOutParam, DWORD dwWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++MPT接入NVR相关接口+++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++设备诊断功能接口+++++++++++++++++++++++++++++++++++++++++++

// 查询设备诊断信息入参
typedef struct tagNET_IN_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // 结构体大小
    UINT nOffset;                                   // 查询偏移量
    UINT nCount;                                    // 查询个数
}NET_IN_QUERY_DIAGNOSIS_INFO;

// 设备诊断条目信息
typedef struct tagNET_DIAGNOSIS_ITEM_INFO
{
    NET_TIME stuOccurTime;                          // 事件发生的时间 
    UINT nFaultCode;                                // 错误码 
    BYTE byReserved[256];                           // 保留字节
}NET_DIAGNOSIS_ITEM_INFO;

// 查询设备诊断信息出参
typedef struct tagNET_OUT_QUERY_DIAGNOSIS_INFO
{
    DWORD dwSize;                                   // 结构体大小
    UINT nTotalCount;                               // 总的信息数量    
    NET_DIAGNOSIS_ITEM_INFO* pstuItemInfo;          // 诊断信息数据指针(由用户申请内存,sdk负责填充)
    UINT nMaxCount;                                 // 诊断信息数据最大条目数量
    UINT nRetCount;                                 // 查询结果
}NET_OUT_QUERY_DIAGNOSIS_INFO;

// 查询诊断信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDiagnosisInfo(LLONG lLoginID,const NET_IN_QUERY_DIAGNOSIS_INFO* pstInParam, NET_OUT_QUERY_DIAGNOSIS_INFO* pstOutParam, int nWaitTime);


// 恢复出厂设置入参
typedef struct tagNET_IN_RESET_SYSTEM
{
    DWORD dwSize;
}NET_IN_RESET_SYSTEM;

// 恢复出厂设置出参
typedef struct tagNET_OUT_RESET_SYSTEM
{
    DWORD dwSize;
}NET_OUT_RESET_SYSTEM;

// 重启系统,恢复出厂默认(包括清空配置和删除账户)并重启，实现硬复位功能
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetSystem(LLONG lLoginID,const NET_IN_RESET_SYSTEM* pstInParam, NET_OUT_RESET_SYSTEM* pstOutParam, int nWaitTime);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++设备诊断功能接口+++++++++++++++++++++++++++++++++++++++++++

#define MAX_IMSI_LEN		32		// IMSI值最大长度
#define MAX_ICCID_LEN		32		// ICCID值最大长度

// 无线模块类型
typedef enum tagEM_WIRELESS_MODE
{
	EM_WIRELESS_UNKNOWN,
		EM_WIRELESS_3G,
		EM_WIRELESS_3G1,
		EM_WIRELESS_3G2,
		EM_WIRELESS_3G3,
} EM_WIRELESS_MODE;

// CLIENT_MobileGetIMSI 接口入参
typedef struct tagNET_IN_GET_IMSI
{
	DWORD 				dwSize;
	EM_WIRELESS_MODE	emMode;		// 无线模块名称
} NET_IN_GET_IMSI;

// CLIENT_MobileGetIMSI 接口出参
typedef struct tagNET_OUT_GET_IMSI
{
	DWORD 		dwSize;
	char 		szIMSI[MAX_IMSI_LEN];			// IMSI值
	char		szICCID[MAX_ICCID_LEN];			// ICCID号
} NET_OUT_GET_IMSI;

// 获取SIM卡的IMSI 值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_MobileGetIMSI(LLONG lLoginID, const NET_IN_GET_IMSI* pstInParam, NET_OUT_GET_IMSI* pstOutParam, int nWaitTime);   //逐渐废弃,功能见CLIENT_GetMobileSIMInfo

// 获取SIM卡的IMSI值入参
typedef struct tagNET_IN_SIMINFO_GET_IMSI
{
	DWORD				dwSize;					// 赋值为结构体大小
	EM_WIRELESS_MODE	emMode;					// 无线模块名称
} NET_IN_SIMINFO_GET_IMSI;

// 获取SIM卡的IMSI值出参
typedef struct tagNET_OUT_SIMINFO_GET_IMSI
{
	DWORD		dwSize;                         // 赋值为结构体大小
	char 		szIMSI[MAX_IMSI_LEN];			// IMSI值
	char		szICCID[MAX_ICCID_LEN];			// ICCID号
} NET_OUT_SIMINFO_GET_IMSI;

// SIM卡状态类型
typedef enum tagEM_SIMSTATE_MODE
{
		EM_SIMSTATE_UNKNOWN,					// 状态未知
		EM_SIMSTATE_UNEXIST,					// 不存在
		EM_SIMSTATE_EXIST,						// 存在
		EM_SIMSTATE_UNMATCH,					// 移动网络号码不匹配
		EM_SIMSTATE_PINLOCK,					// Pin码锁
		EM_SIMSTATE_PUKLOCK,					// Puk码锁
} EM_SIMSTATE_MODE;

// 获取SIM卡的状态类型入参
typedef struct tagNET_IN_SIMINFO_GET_SIM_STATE
{
	DWORD 				dwSize;					// 赋值为结构体大小
	EM_WIRELESS_MODE	emMode;					// 无线模块名称
} NET_IN_SIMINFO_GET_SIMSTATE;

// 获取SIM卡的状态类型出参
typedef struct tagNET_OUT_SIMINFO_GET_SIM_STATE
{
	DWORD 				dwSize;					//赋值为结构体大小
	EM_SIMSTATE_MODE	emMode;					// SIM卡状态类型
} NET_OUT_SIMINFO_GET_SIMSTATE;

// SIM卡信息
typedef enum tagEM_SIMINFO_TYPE
{
	EM_SIMINFO_TYPE_GET_IMSI,					// 获取SIM卡的IMSI值,对应结构体pInParam = NET_IN_SIMINFO_GET_IMSI,pOutParam = NET_OUT_SIMINFO_GET_IMSI,替代CLIENT_MobileGetIMSI接口功能 
	EM_SIMINFO_TYPE_GET_SIMState,				// 获取SIM卡的状态类型,对应结构体pInParam = NET_IN_SIMINFO_GET_SIMSTATE,pOutParam = NET_OUT_SIMINFO_GET_SIMSTATE 
}EM_SIMINFO_TYPE;

// 获取SIM卡信息接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobileSIMInfo(LLONG lLoginID, EM_SIMINFO_TYPE emType, void *pInParam, void *pOutParam, int nWaitTime);


#define MAX_ROOMNUM_COUNT		32		// 房间最大个数
#define MAX_FACE_COUTN			20		// 人脸模板数据最大个数
// 人脸信息
typedef struct tagNET_FACE_RECORD_INFO
{
	char		szUserName[MAX_USER_NAME_LEN];						// 用户名
	int			nRoom;												// 房间个数
	char		szRoomNo[MAX_ROOMNUM_COUNT][DH_COMMON_STRING_16]; 	// 房间号列表
	int 		nFaceData;											// 人脸模板数据个数
	char		szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// 人脸模板数据
    int         nFaceDataLen[MAX_FACE_COUTN];                       // 人脸模版数据大小
    int         nFacePhoto;                                         // 人脸照片个数
    int         nFacePhotoLen[MAX_PHOTO_COUNT];                     // 每张图片的大小
    char*       pszFacePhoto[MAX_PHOTO_COUNT];                      // 人脸照片数据,大小不超过120K
	BOOL    bValidDate;                                         //是否设置人脸有效时间
	NET_TIME      stuValidDateStart;                               //人脸有效开始时间
	NET_TIME      stuValidDateEnd;                                 //人脸有效结束时间
	int			nValidCounts;										// 刷脸有效次数：小于0表示不限次数， 等于0刷脸次数已用完
	BOOL		bValidCountsEnable;									// 次数字段使能 
    BOOL        bFaceDataExEnable;                                   // 人脸模板数据扩展使能
    char*       pszFaceDataEx[MAX_FACE_COUTN];                      // 人脸模板数据扩展, 由用户申请释放, 每张照片最大为8K
    BYTE        byReserved[240];                                    // 保留字节
} NET_FACE_RECORD_INFO;

// 添加人脸记录信息输入参数
typedef struct tagNET_IN_ADD_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// 用户ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// 人脸数据
} NET_IN_ADD_FACE_INFO;

// 添加人脸记录信息输出参数
typedef struct tagNET_OUT_ADD_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_ADD_FACE_INFO;

// 获取人脸记录信息输入参数
typedef struct tagNET_IN_GET_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// 用户ID
} NET_IN_GET_FACE_INFO;

// 获取人脸记录信息输出参数
typedef struct tagNET_OUT_GET_FACE_INFO
{
	DWORD 			dwSize;
	int 			nFaceData;											// 人脸模板数据个数
	char			szFaceData[MAX_FACE_COUTN][MAX_FACE_DATA_LEN];		// 人脸模板数据
    int             nPhotoData;                                         // 白光人脸照片数据个数, 最大个数：5
    int             nInPhotoDataLen[MAX_PHOTO_COUNT];                   // 用户申请的每张白光人脸照片大小
    int             nOutPhotoDataLen[MAX_PHOTO_COUNT];                  // 每张白光人脸照片实际的大小
    char*           pPhotoData[MAX_PHOTO_COUNT];                        // 白光人脸照片数据, 由用户申请释放, 每张照片最大为200K
} NET_OUT_GET_FACE_INFO;

// 更新人脸记录信息输入参数
typedef struct tagNET_IN_UPDATE_FACE_INFO
{
	DWORD 					dwSize;
	char					szUserID[DH_MAX_USERID_LEN];	// 用户ID
	NET_FACE_RECORD_INFO	stuFaceInfo;					// 人脸数据
} NET_IN_UPDATE_FACE_INFO;

// 更新人脸记录信息输出参数
typedef struct tagNET_OUT_UPDATE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_UPDATE_FACE_INFO;


// 删除人脸记录信息输入参数
typedef struct tagNET_IN_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
	char			szUserID[DH_MAX_USERID_LEN];	// 用户ID
} NET_IN_REMOVE_FACE_INFO;

// 删除人脸记录信息输出参数
typedef struct tagNET_OUT_REMOVE_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_REMOVE_FACE_INFO;

// 清除人脸记录信息输入参数
typedef struct tagNET_IN_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_IN_CLEAR_FACE_INFO;

// 清除人脸记录信息输出参数
typedef struct tagNET_OUT_CLEAR_FACE_INFO
{
	DWORD 			dwSize;
} NET_OUT_CLEAR_FACE_INFO;


// 获取人脸特征值信息输入参数
typedef struct tagNET_IN_GETFACEEIGEN_INFO
{
    DWORD 			dwSize;
    int            nPhotoDataLen;          // 人脸照片数据大小
    char*          pszPhotoData;           // 人脸照片数据, 由用户申请释放, 每张照片最大为200K
} NET_IN_GETFACEEIGEN_INFO;

// 获取人脸特征值信息输出参数
typedef struct tagNET_OUT_GETFACEEIGEN_INFO
{
    DWORD 			dwSize;
    int             nInFaceEigenLen;          // 用户申请的人脸特征值数据大小
    int             nOutFaceEigenLen;         // 人脸特征值数据实际的大小
    char*           pszFaceEigen;             // 人脸特征值数据, 由用户申请释放, 每张照片最大为8K
} NET_OUT_GETFACEEIGEN_INFO;

// 人脸信息记录操作类型
typedef enum tagEM_FACEINFO_OPREATE_TYPE
{
	EM_FACEINFO_OPREATE_ADD,				// 添加, pInbuf = NET_IN_ADD_FACE_INFO , pOutBuf = NET_OUT_ADD_FACE_INFO
	EM_FACEINFO_OPREATE_GET,				// 获取, pInBuf = NET_IN_GET_FACE_INFO , pOutBuf = NET_OUT_GET_FACE_INFO
	EM_FACEINFO_OPREATE_UPDATE,				// 更新, pInbuf = NET_IN_UPDATE_FACE_INFO , pOutBuf = NET_OUT_UPDATE_FACE_INFO
	EM_FACEINFO_OPREATE_REMOVE,				// 删除, pInbuf = NET_IN_REMOVE_FACE_INFO , pOutBuf = NET_OUT_REMOVE_FACE_INFO
	EM_FACEINFO_OPREATE_CLEAR,				// 清除, pInbuf = NET_IN_CLEAR_FACE_INFO, pOutBuf = NET_OUT_CLEAR_FACE_INFO
    EM_FACEINFO_OPREATE_GETFACEEIGEN,	    // 获取人脸特征值, pInbuf = NET_IN_GETFACEEIGEN_INFO, pOutBuf = NET_OUT_GETFACEEIGEN_INFO
} EM_FACEINFO_OPREATE_TYPE;

/**************************************************************************************
*   Funcname: CLIENT_FaceInfoOpreate
*   Purpose:人脸信息记录操作函数
*   InputParam:	LLONG		:lLoginID		// 登陆句柄
*   InputParam:     EM_FACEINFO_OPREATE_TYPE: emType //操作类型
*   InputParam:	void*		:pInParam	// 接口输入参数, 资源由用户维护
*   OutputParam:	void*		:pOutParam	// 接口输出参数, 资源由用户维护
*   InputParam:	int			:nWaitTime	// 等待超时时间
*   Return:		BOOL
*   Created:		%2017%:%08%:%30%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceInfoOpreate(LLONG lLoginID, EM_FACEINFO_OPREATE_TYPE emType, void* pInParam, void* pOutParam, int nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_StartFindFaceInfo 输入参数
typedef struct tagNET_IN_FACEINFO_START_FIND
{
    DWORD 			dwSize;
   	char			szUserID[DH_MAX_USERID_LEN];	// 用户ID
}NET_IN_FACEINFO_START_FIND;

// CLIENT_StartFindFaceInfo 输出参数
typedef struct tagNET_OUT_FACEINFO_START_FIND
{
    DWORD 			dwSize;
    UINT            nTotalCount;                   // 符合查询条件的总数
}NET_OUT_FACEINFO_START_FIND;

// CLIENT_DoFindFaceInfo 输入参数
typedef struct tagNET_IN_FACEINFO_DO_FIND
{
    DWORD 			dwSize;
    int             nStartNo;                       // 起始序号
    int             nCount;                         // 本次查询的条数
}NET_IN_FACEINFO_DO_FIND;

// 人脸信息
typedef struct tagNET_FACEINFO
{
    char			szUserID[DH_MAX_USERID_LEN];	// 用户ID
    int             nMD5;                           // 有效的MD5编码数量
    char            szMD5[5][DH_COMMON_STRING_64];  // 图片对应的32字节MD5编码加密
    BYTE            byReserved[512];                
}NET_FACEINFO;

// CLIENT_DoFindFaceInfo 输出参数
typedef struct tagNET_OUT_FACEINFO_DO_FIND
{
    DWORD 			dwSize;
   	int             nRetNum;                        // 本次查询到的个数
    NET_FACEINFO*   pstuInfo;                       // 查询结果, 用户分配内存,大小为sizeof(NET_FACEINFO)*nMaxNum
    int	            nMaxNum;                        // 用户分配内存的个数
    BYTE            byReserved[4];
}NET_OUT_FACEINFO_DO_FIND;

// 开始查询人脸信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindFaceInfo(LLONG lLoginID, NET_IN_FACEINFO_START_FIND* pstIn, NET_OUT_FACEINFO_START_FIND* pstOut, int nWaitTime);

// 获取人脸信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindFaceInfo(LLONG lFindHandle, NET_IN_FACEINFO_DO_FIND* pstIn, NET_OUT_FACEINFO_DO_FIND* pstOut, int nWaitTime);

// 停止查询人脸信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindFaceInfo(LLONG lFindHandle);

// 用户类型
typedef enum tagNET_ENUM_USER_TYPE
{
    NET_ENUM_USER_TYPE_UNKNOWN = -1,            // 未知用户
    NET_ENUM_USER_TYPE_NORMAL,                  // 普通用户
    NET_ENUM_USER_TYPE_BLACKLIST,               // 黑名单用户
    NET_ENUM_USER_TYPE_GUEST,                   // 来宾账户
    NET_ENUM_USER_TYPE_PATROL,                  // 巡逻用户
    NET_ENUM_USER_TYPE_VIP,                     // VIP用户
    NET_ENUM_USER_TYPE_HANDICAP,                // 残疾用户
}NET_ENUM_USER_TYPE;
// 用户信息
typedef struct tagNET_ACCESS_USER_INFO
{
    char						szUserID[DH_MAX_USERID_LEN];				// 用户ID
	char						szName[MAX_COMMON_STRING_32];				// 人员名称
    NET_ENUM_USER_TYPE          emUserType;                                 // 用户类型
    UINT                        nUserStatus;                                // 用户状态, 0 正常, 1 冻结
    int                         nUserTime;                                  // 来宾卡的通行次数
    char			            szCitizenIDNo[MAX_COMMON_STRING_32];		// 身份证号码
    char                        szPsw[DH_MAX_CARDPWD_LEN];                  // UserID+密码开门时密码
    int                         nDoorNum;                                   // 有效的门数目;
    int                         nDoors[DH_MAX_DOOR_NUM];                    // 有权限的门序号,即 CFG_CMD_ACCESS_EVENT 配置的数组下标
    int                         nTimeSectionNum;                            // 有效的的开门时间段数目
    int                         nTimeSectionNo[DH_MAX_TIMESECTION_NUM];     // 开门时间段索引,即 CFG_ACCESS_TIMESCHEDULE_INFO 的数组下标
    int				            nSpecialDaysScheduleNum;					// 假日计划表示数量
	int				            nSpecialDaysSchedule[MAX_ACCESSDOOR_NUM];	// 假日计划标识, 即 NET_EM_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE 配置的下标
    NET_TIME                    stuValidBeginTime;                          // 开始有效期
    NET_TIME                    stuValidEndTime;                            // 结束有效期
    BOOL                        bFirstEnter;                                // 是否拥有首卡权限
    int                         nFirstEnterDoorsNum;                        // 拥有首用户权限的门数量
    int                         nFirstEnterDoors[DH_MAX_DOOR_NUM];          // 拥有首用户权限的门序号，bFirstEnter为TRUE时有效,-1表示全通道
    NET_ATTENDANCE_AUTHORITY    emAuthority;                                // 用户权限，可选
    int                         nRepeatEnterRouteTimeout;                   // 反潜超时时间
    int                         nFloorNum;                                              // 有效的楼层数量
    char                        szFloorNo[MAX_ACCESS_FLOOR_NUM][DH_COMMON_STRING_16];   // 楼层号
    int			                nRoom;												    // 房间个数
	char		                szRoomNo[MAX_ROOMNUM_COUNT][DH_COMMON_STRING_16]; 	    // 房间号列表
	BOOL						bFloorNoExValid;										// szFloorNoEx 是否有效
	int                         nFloorNumEx;											// 有效的楼层数量扩展
	char                        szFloorNoEx[256][4];									// 楼层号扩展
    BYTE                        byReserved[3064];										// 保留字节
}NET_ACCESS_USER_INFO;

// 新增或更新用户信息入参
typedef struct tagNET_IN_ACCESS_USER_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nInfoNum;                                   // 用户信息数量
    NET_ACCESS_USER_INFO*       pUserInfo;                                  // 用户信息,内存由用户申请释放，申请大小不小于nInfoNum*sizeof(NET_ACCESS_USER_INFO);
}NET_IN_ACCESS_USER_SERVICE_INSERT;

// 操作错误码
typedef enum tagNET_EM_FAILCODE
{
    NET_EM_FAILCODE_NOERROR,                                                // 没有错误
    NET_EM_FAILCODE_UNKNOWN,                                                // 未知错误
    NET_EM_FAILCODE_INVALID_PARAM,                                          // 参数错误
    NET_EM_FAILCODE_INVALID_PASSWORD,                                       // 无效密码
    NET_EM_FAILCODE_INVALID_FP,                                             // 无效指纹数据
    NET_EM_FAILCODE_INVALID_FACE,                                           // 无效人脸数据
    NET_EM_FAILCODE_INVALID_CARD,                                           // 无效卡数据
    NET_EM_FAILCODE_INVALID_USER,                                           // 无效人数据
    NET_EM_FAILCODE_FAILED_GET_SUBSERVICE,                                  // 能力集子服务获取失败
    NET_EM_FAILCODE_FAILED_GET_METHOD,                                      // 获取组件的方法集失败
    NET_EM_FAILCODE_FAILED_GET_SUBCAPS,                                     // 获取资源实体能力集失败
	NET_EM_FAILCODE_ERROR_INSERT_LIMIT,                                     // 已达插入上限
    NET_EM_FAILCODE_ERROR_MAX_INSERT_RATE,                                  // 已达最大插入速度
	NET_EM_FAILCODE_FAILED_ERASE_FP,										// 清除指纹数据失败
	NET_EM_FAILCODE_FAILED_ERASE_FACE,										// 清除人脸数据失败
	NET_EM_FAILCODE_FAILED_ERASE_CARD,										// 清除卡数据失败
	NET_EM_FAILCODE_NO_RECORD,												// 没有记录
	NET_EM_FAILCODE_NOMORE_RECORD,											// 查找到最后，没有更多记录
	NET_EM_FAILCODE_RECORD_ALREADY_EXISTS,									// 下发卡或指纹时，数据重复
	NET_EM_FAILCODE_MAX_FP_PERUSER,											// 超过个人最大指纹记录数
	NET_EM_FAILCODE_MAX_CARD_PERUSER,										// 超过个人最大卡片记录数
	NET_EM_FAILCODE_EXCEED_MAX_PHOTOSIZE,									// 超出最大照片大小
	NET_EM_FAILCODE_INVALID_USERID,											// 用户ID无效（未找到客户）
	NET_EM_FAILCODE_EXTRACTFEATURE_FAIL,									// 提取人脸特征失败
	NET_EM_FAILCODE_PHOTO_EXIST,											// 人脸照片已存在
	NET_EM_FAILCODE_PHOTO_OVERFLOW,											// 超出最大人脸照片数
	NET_EM_FAILCODE_INVALID_PHOTO_FORMAT,									// 照片格式无效
	NET_EM_FAILCODE_EXCEED_ADMINISTRATOR_LIMIT,								// 超出管理员人数限制
	
}NET_EM_FAILCODE;

// 新增或更新用户信息出参
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 申请的最大返回的错误信息数量,不小于NET_IN_ACCESS_USER_SERVICE_INSERT中nInfoNum
    NET_EM_FAILCODE*            pFailCode;                                  // 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_USER_SERVICE_INSERT中nInfoNum
}NET_OUT_ACCESS_USER_SERVICE_INSERT;

// 获取用户信息入参
typedef struct tagNET_IN_ACCESS_USER_SERVICE_GET
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nUserNum;                                   // 查询的数量
    char						szUserID[100][32];				            // 用户ID
}NET_IN_ACCESS_USER_SERVICE_GET;

// 获取用户信息出参
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_GET
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 查询返回的最大数量
    NET_ACCESS_USER_INFO*       pUserInfo;                                  // 用户信息,内存由用户申请释放，申请大小不小于 nUserNum*sizeof(NET_ACCESS_USER_INFO)                                                                           // 返回个数同NET_IN_ACCESS_USER_SERVICE_GET中nUserNum
    NET_EM_FAILCODE*            pFailCode;                                  // 查询失败时，内存由用户申请释放,对应查询的每一项的结果，返回个数同NET_IN_ACCESS_USER_SERVICE_GET中nUserNum
}NET_OUT_ACCESS_USER_SERVICE_GET;

// 删除指定ID人员信息入参
typedef struct tagNET_IN_ACCESS_USER_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nUserNum;                                   // 删除的数量
    char						szUserID[100][32];				            // 用户ID
}NET_IN_ACCESS_USER_SERVICE_REMOVE;

// 删除指定ID人员信息出参
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 返回的最大数量,不小于 NET_IN_ACCESS_USER_SERVICE_REMOVE中nUserNum
    NET_EM_FAILCODE*            pFailCode;                                  // 插入失败时，内存由用户申请释放,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_USER_SERVICE_REMOVE中nUserNum
}NET_OUT_ACCESS_USER_SERVICE_REMOVE;

// 删除所有人员信息入参
typedef struct tagNET_IN_ACCESS_USER_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // 结构体大小
}NET_IN_ACCESS_USER_SERVICE_CLEAR;

// 删除所有人员信息出参
typedef struct tagNET_OUT_ACCESS_USER_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // 结构体大小
}NET_OUT_ACCESS_USER_SERVICE_CLEAR;

// 人员信息操作类型
typedef enum tagNET_EM_ACCESS_CTL_USER_SERVICE
{
    NET_EM_ACCESS_CTL_USER_SERVICE_INSERT = 0,                              // 添加人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_INSERT
    NET_EM_ACCESS_CTL_USER_SERVICE_GET,                                     // 获取人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_GET
    NET_EM_ACCESS_CTL_USER_SERVICE_REMOVE,                                  // 删除人员信息,包含所有授权信息 pstInParam = NET_IN_ACCESS_USER_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_USER_SERVICE_CLEAR,                                   // 清空所有人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_CLEAR    
}NET_EM_ACCESS_CTL_USER_SERVICE;

// 门禁人员信息管理接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessUserService(LLONG lLoginID, NET_EM_ACCESS_CTL_USER_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_StartFindUserInfo 输入参数
typedef struct tagNET_IN_USERINFO_START_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
   	char			            szUserID[MAX_COMMON_STRING_32];	            // 用户ID
}NET_IN_USERINFO_START_FIND;

// CLIENT_StartFindUserInfo 输出参数
typedef struct tagNET_OUT_USERINFO_START_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
    int                         nTotalCount;                                // 符合查询条件的总数
    int                         nCapNum;                                    // doFind一次查询的最大数量
}NET_OUT_USERINFO_START_FIND;

// CLIENT_DoFindUserInfo 输入参数
typedef struct tagNET_IN_USERINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
    int                         nStartNo;                                   // 起始序号
    int                         nCount;                                     // 本次查询的条数
}NET_IN_USERINFO_DO_FIND;

// CLIENT_DoFindUserInfo 输出参数
typedef struct tagNET_OUT_USERINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
   	int                         nRetNum;                                    // 本次查询到的个数
    NET_ACCESS_USER_INFO*       pstuInfo;                                   // 查询结果, 用户分配释放内存,大小为sizeof(NET_ACCESS_USER_INFO)*nMaxNum
    int	                        nMaxNum;                                    // 用户分配内存的个数
    BYTE                        byReserved[4];
}NET_OUT_USERINFO_DO_FIND;

// 开始查询人员信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindUserInfo(LLONG lLoginID, NET_IN_USERINFO_START_FIND* pstIn, NET_OUT_USERINFO_START_FIND* pstOut, int nWaitTime);

// 获取人员信息 ,lFindHandle 为 CLIENT_StartFindUserInfo 接口返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindUserInfo(LLONG lFindHandle, NET_IN_USERINFO_DO_FIND* pstIn, NET_OUT_USERINFO_DO_FIND* pstOut, int nWaitTime);

// 停止查询人员信息 ,lFindHandle 为 CLIENT_StartFindUserInfo 接口返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindUserInfo(LLONG lFindHandle);

// 卡片信息
typedef struct tagNET_ACCESS_CARD_INFO
{
    char                        szCardNo[DH_MAX_CARDNO_LEN];                // 卡号 
    char						szUserID[DH_MAX_USERID_LEN];				// 用户ID
    NET_ACCESSCTLCARD_TYPE      emType;                                     // 卡类型,只支持一般卡、胁迫卡和母卡
    char			            szDynamicCheckCode[MAX_COMMON_STRING_16];	// 动态校验码
    BYTE                        byReserved[4096];                           // 保留字节
}NET_ACCESS_CARD_INFO;

// 新增卡片信息入参
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nInfoNum;                                   // 用户信息数量
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // 卡片信息,用户分配释放内存,大小为sizeof(NET_ACCESS_CARD_INFO)*nInfoNum
}NET_IN_ACCESS_CARD_SERVICE_INSERT;

// 新增卡片信息出参
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_INSERT
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 最大返回的用户信息数量,不小于NET_IN_ACCESS_CARD_SERVICE_INSERT中nInfoNum
    NET_EM_FAILCODE*            pFailCode;                                  // 用户分配释放内存,插入失败时,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_INSERT中nInfoNum 
    BYTE                        byReserved[4];
}NET_OUT_ACCESS_CARD_SERVICE_INSERT;

// 获取卡片信息入参
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_GET
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nCardNum;                                   // 查询的数量
    char                        szCardNo[100][32];                          // 卡号 
}NET_IN_ACCESS_CARD_SERVICE_GET;

// 获取卡片信息出参
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_GET
{
    DWORD                       dwSize;                                     // 结构体大小
    int                         nMaxRetNum;                                 // 查询返回的最大数量
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // 卡片信息,内存由用户申请释放，申请大小不小于nCardNum*sizeof(NET_ACCESS_CARD_INFO);                                                                           // 返回个数同NET_IN_ACCESS_CARD_SERVICE_GET中nCardNum
    NET_EM_FAILCODE*            pFailCode;                                  // 查询失败时，对应查询的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_GET中nCardNum
}NET_OUT_ACCESS_CARD_SERVICE_GET;

// 更新卡片信息入参
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_UPDATE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nInfoNum;                                   // 用户信息数量
    NET_ACCESS_CARD_INFO*       pCardInfo;                                  // 卡片信息,用户分配释放内存,大小为sizeof(NET_ACCESS_CARD_INFO)*nInfoNum
}NET_IN_ACCESS_CARD_SERVICE_UPDATE;

// 更新卡片信息出参
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_UPDATE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 最大返回的用户信息数量,不小于NET_IN_ACCESS_CARD_SERVICE_UPDATE中nInfoNum
    NET_EM_FAILCODE*            pFailCode;                                  // 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_UPDATE中nInfoNum
    BYTE                        byReserved[4];
}NET_OUT_ACCESS_CARD_SERVICE_UPDATE;

// 删除指定卡号信息入参
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nCardNum;                                   // 删除的数量
    char                        szCardNo[100][32];                          // 卡号 
}NET_IN_ACCESS_CARD_SERVICE_REMOVE;

// 删除指定卡号信息出参
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_REMOVE
{
    DWORD                       dwSize;	                                    // 结构体大小
    int                         nMaxRetNum;                                 // 最大返回信息数量,不小于 NET_IN_ACCESS_CARD_SERVICE_REMOVE中nCardNum
    NET_EM_FAILCODE*            pFailCode;                                  // 用户分配释放内存,插入失败时,对应删除的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_REMOVE中nCardNum
    BYTE                        byReserved[4];
}NET_OUT_ACCESS_CARD_SERVICE_REMOVE;

// 删除所有卡片信息入参
typedef struct tagNET_IN_ACCESS_CARD_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // 结构体大小
}NET_IN_ACCESS_CARD_SERVICE_CLEAR;

// 删除所有卡片信息出参
typedef struct tagNET_OUT_ACCESS_CARD_SERVICE_CLEAR
{
    DWORD                       dwSize;	                                    // 结构体大小
}NET_OUT_ACCESS_CARD_SERVICE_CLEAR;

// 卡片信息操作类型
typedef enum tagNET_EM_ACCESS_CTL_CARD_SERVICE
{
    NET_EM_ACCESS_CTL_CARD_SERVICE_INSERT = 0,                              // 添加, pstInParam = NET_IN_ACCESS_CARD_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_INSERT
    NET_EM_ACCESS_CTL_CARD_SERVICE_GET,                                     // 获取, pstInParam = NET_IN_ACCESS_CARD_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_GET
    NET_EM_ACCESS_CTL_CARD_SERVICE_UPDATE,                                  // 更新, pstInParam = NET_IN_ACCESS_CARD_SERVICE_UPDATE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_UPDATE
    NET_EM_ACCESS_CTL_CARD_SERVICE_REMOVE,                                  // 删除, pstInParam = NET_IN_ACCESS_CARD_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_CARD_SERVICE_CLEAR,                                   // 清空, pstInParam = NET_IN_ACCESS_CARD_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_CARD_SERVICE;

// 门禁卡片信息管理接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessCardService(LLONG lLoginID, NET_EM_ACCESS_CTL_CARD_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_StartFindCardInfo 输入参数
typedef struct tagNET_IN_CARDINFO_START_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
   	char			            szUserID[32];	                            // 用户ID
    char                        szCardNo[32];                               // 卡号 
    NET_ACCESSCTLCARD_TYPE      emType;                                     // 卡类型,只支持一般卡、胁迫卡和母卡                        
}NET_IN_CARDINFO_START_FIND;

// CLIENT_StartFindCardInfo 输出参数
typedef struct tagNET_OUT_CARDINFO_START_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
    int                         nTotalCount;                                // 符合查询条件的总数
    int                         nCapNum;                                    // CLIENT_DoFindCardInfo接口一次查询的最大数量
}NET_OUT_CARDINFO_START_FIND;

// CLIENT_DoFindCardInfo 输入参数
typedef struct tagNET_IN_CARDINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
    int                         nStartNo;                                   // 起始序号
    int                         nCount;                                     // 本次查询的条数
}NET_IN_CARDINFO_DO_FIND;

// CLIENT_DoFindCardInfo 输出参数
typedef struct tagNET_OUT_CARDINFO_DO_FIND
{
    DWORD 			            dwSize;                                     // 结构体大小
   	int                         nRetNum;                                    // 本次查询到的个数
    NET_ACCESS_CARD_INFO*       pstuInfo;                                   // 查询结果, 用户分配释放内存,大小为sizeof(NET_FACEINFO)*nMaxNum
    int	                        nMaxNum;                                    // 用户分配内存的个数
    BYTE                        byReserved[4];                              // 保留字节
}NET_OUT_CARDINFO_DO_FIND;

// 开始查询卡片信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindCardInfo(LLONG lLoginID, NET_IN_CARDINFO_START_FIND* pstIn, NET_OUT_CARDINFO_START_FIND* pstOut, int nWaitTime);

// 获取卡片信息,lFindHandle 为CLIENT_StartFindCardInfo接口返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindCardInfo(LLONG lFindHandle, NET_IN_CARDINFO_DO_FIND* pstIn, NET_OUT_CARDINFO_DO_FIND* pstOut, int nWaitTime);

// 停止查询卡片信息,lFindHandle 为CLIENT_StartFindCardInfo接口返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindCardInfo(LLONG lFindHandle);

// 指纹信息
typedef struct tagNET_ACCESS_FINGERPRINT_INFO
{
    char			            szUserID[DH_MAX_USERID_LEN];	                // 用户ID
    int                         nPacketLen;                                     // 单个指纹数据包长度
    int                         nPacketNum;                                     // 指纹数据包个数
    char*                       szFingerPrintInfo;                              // 指纹数据(数据总长度即nPacketLen*nPacketNum),用户分配释放内存
    int                         nDuressIndex;                                   // 胁迫指纹序号,取值范围[1,nPacketNum] 非法取值的话，该字段无效
    BYTE                        byReserved[4096];                               // 保留字节
}NET_ACCESS_FINGERPRINT_INFO;

// 插入指纹信息入参
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nFpNum;                                     // 指纹信息的数量
    NET_ACCESS_FINGERPRINT_INFO*    pFingerPrintInfo;                           // 指纹信息,用户分配释放内存
}NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT;

// 插入指纹信息出参
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nMaxRetNum;                                 // 返回信息数量,不小于NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT 中 nFpNum
    NET_EM_FAILCODE*                pFailCode;                                  // 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT 中nFpNum
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT;

// 更新指纹信息入参
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nFpNum;                                     // 指纹信息的数量
    NET_ACCESS_FINGERPRINT_INFO*    pFingerPrintInfo;                           // 指纹信息,用户分配释放内存
}NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE;

// 更新指纹信息出参
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nMaxRetNum;                                 // 最大返回信息数量,不小于 NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE中nFpNum
    NET_EM_FAILCODE*                pFailCode;                                  // 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE中nFpNum
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE;

// 获取指纹信息入参
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_GET
{
    DWORD 			                dwSize;                                     // 结构体大小
    char			                szUserID[DH_MAX_USERID_LEN];	            // 用户ID
}NET_IN_ACCESS_FINGERPRINT_SERVICE_GET;

// 获取指纹信息出参
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_GET
{
    DWORD 			                dwSize;                                     // 结构体大小
    int							    nRetFingerPrintCount;					    // 实际返回的指纹个数
    int							    nSinglePacketLength;					    // 单个指纹数据包长度
    int                             nDuressIndex;                               // 胁迫指纹序号
    int							    nMaxFingerDataLength;					    // 接受指纹数据的缓存的最大长度
    int							    nRetFingerDataLength;					    // 实际返回的总的指纹数据包的长度
	BYTE*                           pbyFingerData;                       	    // 用户分配释放内存,指纹数据
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET;

// 删除用户指纹信息入参
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nUserNum;                                   // 删除的用户数量
    char                            szUserID[100][32];                          // 用户ID
}NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE;

// 删除用户指纹信息出参
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE
{
    DWORD 			                dwSize;                                     // 结构体大小
    int                             nMaxRetNum;                                 // 最大返回数量,不小于 NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE中nUserNum
    NET_EM_FAILCODE*                pFailCode;                                  // 用户分配释放内存,删除失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE中nUserNum
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE;

// 清除所有指纹信息入参
typedef struct tagNET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                         // 结构体大小
}NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR;

// 清除所有指纹信息出参
typedef struct tagNET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                         // 结构体大小
}NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR;

// 指纹信息操作类型
typedef enum tagNET_EM_ACCESS_CTL_FINGERPRINT_SERVICE
{
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_INSERT = 0,                               // 添加, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_GET,                                      // 获取, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_GET , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_UPDATE,                                   // 更新, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_REMOVE,                                   // 删除, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_CLEAR,                                    // 清空, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE;

// 指纹信息管理接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessFingerprintService(LLONG lLoginID, NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// 人脸信息
typedef struct tagNET_ACCESS_FACE_INFO
{
    char					    szUserID[32];	                                    // 用户ID
    int 		                nFaceData;											// 人脸模板数据个数,最大20
    char		                szFaceData[20][2048];		                        // 人脸模板数据
    int                         nFaceDataLen[20];                                   // 人脸模版数据大小
    int                         nFacePhoto;                                         // 人脸照片个数,不超过5个
    int                         nInFacePhotoLen[5];                                 // 用户申请的每张图片的大小
	int                         nOutFacePhotoLen[5];                                // 每张图片实际的大小
    char*                       pFacePhoto[5];                                      // 人脸照片数据,大小不超过200K
    BYTE                        byReserved[2048];                                   // 保留字节
} NET_ACCESS_FACE_INFO;

// 添加人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_INSERT
{
    DWORD 					    dwSize;                                             // 结构体大小
    int                         nFaceInfoNum;                                       // 人脸信息数量
    NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // 人脸数据,用户自行分配数据
}NET_IN_ACCESS_FACE_SERVICE_INSERT;

// 添加人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_INSERT
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_INSERT 中的nFaceInfoNum
    NET_EM_FAILCODE*            pFailCode;                                          // 用户分配内存,添加失败时,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_INSERT中的nFaceInfoNum
}NET_OUT_ACCESS_FACE_SERVICE_INSERT;

// 批量获取多用户多个人脸输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_GET
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nUserNum;                                           // 用户ID数量,最大100
    char			            szUserID[100][32];	                                // 用户ID
}NET_IN_ACCESS_FACE_SERVICE_GET;

// 批量获取多用户多个人脸输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_GET
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_GET 中的 nUserNum
    NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // 人脸数据,用户分配内存,返回个数同NET_IN_ACCESS_FACE_SERVICE_GET中的nUserNum,只返回人脸模版数据
    NET_EM_FAILCODE*            pFailCode;                                          // 用户分配内存,获取失败时,对应获取的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_GET中的nUserNum
}NET_OUT_ACCESS_FACE_SERVICE_GET;

// 更新多用户多个人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_UPDATE
{
    DWORD 					    dwSize;                                             // 结构体大小
    int                         nFaceInfoNum;                                       // 人脸信息数量
    NET_ACCESS_FACE_INFO*	    pFaceInfo;					                        // 人脸数据,用户分配内存
}NET_IN_ACCESS_FACE_SERVICE_UPDATE;

// 更新多用户多个人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_UPDATE
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_UPDATE中的nFaceInfoNum
    NET_EM_FAILCODE*            pFailCode;                                          // 用户分配内存.更新失败时,对应更新的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_UPDATE中的nFaceInfoNum
}NET_OUT_ACCESS_FACE_SERVICE_UPDATE;

// 删除多用户的多个人脸信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_REMOVE
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nUserNum;                                           // 用户ID数量,最大100
    char			            szUserID[100][32];	                                // 用户ID
}NET_IN_ACCESS_FACE_SERVICE_REMOVE;

// 删除多用户的多个人脸信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_REMOVE
{
    DWORD 			            dwSize;                                             // 结构体大小
    int                         nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_REMOVE中的nUserNum
    NET_EM_FAILCODE*            pFailCode;                                          // 用户分配内存.删除失败时,对应删除的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_REMOVE中的nUserNum
}NET_OUT_ACCESS_FACE_SERVICE_REMOVE;

// 清空所有人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
typedef struct tagNET_IN_ACCESS_FACE_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                             // 结构体大小
}NET_IN_ACCESS_FACE_SERVICE_CLEAR;

// 清空所有人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
typedef struct tagNET_OUT_ACCESS_FACE_SERVICE_CLEAR
{
    DWORD 			            dwSize;                                             // 结构体大小
}NET_OUT_ACCESS_FACE_SERVICE_CLEAR;

// 人脸信息操作类型
typedef enum tagNET_EM_ACCESS_CTL_FACE_SERVICE
{
    NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT = 0,                      // 添加, pInbuf = NET_IN_ACCESS_FACE_SERVICE_INSERT , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_INSERT
    NET_EM_ACCESS_CTL_FACE_SERVICE_GET,                             // 获取, pInbuf = NET_IN_ACCESS_FACE_SERVICE_GET , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_GET
    NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE,                          // 更新, pInbuf = NET_IN_ACCESS_FACE_SERVICE_UPDATE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_UPDATE
    NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE,                          // 删除, pInbuf = NET_IN_ACCESS_FACE_SERVICE_REMOVE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_REMOVE
    NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR,                           // 清空, pInbuf = NET_IN_ACCESS_FACE_SERVICE_CLEAR , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_CLEAR
}NET_EM_ACCESS_CTL_FACE_SERVICE;

// 门禁人脸信息管理接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateAccessFaceService(LLONG lLoginID, NET_EM_ACCESS_CTL_FACE_SERVICE emtype, void *pstInParam, void *pstOutParam, int nWaitTime);

// CLIENT_AccessStartFindFaceInfo 输入参数
typedef struct tagNET_IN_ACCESS_FACEINFO_START_FIND
{
    DWORD 			dwSize;                        // 结构体大小
   	char			szUserID[32];	               // 用户ID
}NET_IN_ACCESS_FACEINFO_START_FIND;

// CLIENT_AccessStartFindFaceInfo 输出参数
typedef struct tagNET_OUT_ACCESS_FACEINFO_START_FIND
{
    DWORD 			dwSize;                        // 结构体大小
    int             nCapNum;                       // 单次查询最大数量
    int             nTotalCount;                   // 符合查询条件的总数
}NET_OUT_ACCESS_FACEINFO_START_FIND;

// CLIENT_AccessDoFindFaceInfo 输入参数
typedef struct tagNET_IN_ACCESS_FACEINFO_DO_FIND
{
    DWORD 			dwSize;                         // 结构体大小
    int             nStartNo;                       // 起始序号
    int             nCount;                         // 本次查询的条数,不能大于NET_OUT_ACCESS_FACEINFO_START_FIND中的nCapNum
}NET_IN_ACCESS_FACEINFO_DO_FIND;

// CLIENT_AccessDoFindFaceInfo 输出参数
typedef struct tagNET_OUT_ACCESS_FACEINFO_DO_FIND
{
    DWORD 			dwSize;                         // 结构体大小
   	int             nRetNum;                        // 本次查询到的个数
    NET_FACEINFO*   pstuInfo;                       // 查询结果, 用户分配内存,大小为sizeof(NET_FACEINFO)*nMaxNum
    int	            nMaxNum;                        // 用户分配内存的个数
    BYTE            byReserved[4];
}NET_OUT_ACCESS_FACEINFO_DO_FIND;

// 开始查询人脸信息,接口返回值为CLIENT_AccessDoFindFaceInfo、CLIENT_AccessStopFindFaceInfo接口入参lFindHandle字段
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AccessStartFindFaceInfo(LLONG lLoginID, NET_IN_ACCESS_FACEINFO_START_FIND* pstIn, NET_OUT_ACCESS_FACEINFO_START_FIND* pstOut, int nWaitTime);

// 获取人脸信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AccessDoFindFaceInfo(LLONG lFindHandle, NET_IN_ACCESS_FACEINFO_DO_FIND* pstIn, NET_OUT_ACCESS_FACEINFO_DO_FIND* pstOut, int nWaitTime);

// 停止查询人脸信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AccessStopFindFaceInfo(LLONG lFindHandle);
/**************************************************************************************
*   Funcname: CLIENT_RenderPrivateData
*   Purpose:显示私有数据，例如规则框，规则框报警，移动侦测等
*   InputParam:     LLONG		:lPlayHandle        	// 播放句柄
*   InputParam:     BOOL		:bTrue        		// TRUE:打开 FALSE:关闭
*   Return:		BOOL:TRUE 成功 FALSE 失败
*   Created:	       %2017%:%09%:%25%  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RenderPrivateData(LLONG lPlayHandle, BOOL bTrue);

// 获取考勤机在线状态入参
typedef struct tagNET_IN_ATTENDANCE_GETDEVSTATE
{
	DWORD 			dwSize;
} NET_IN_ATTENDANCE_GETDEVSTATE;

// 获取考勤机在线状态出参
typedef struct tagNET_OUT_ATTENDANCE_GETDEVSTATE
{
	DWORD 			           dwSize;
	int                        nState;     // 0:离线;1:在线;其他:未知;考勤机状态
} NET_OUT_ATTENDANCE_GETDEVSTATE;

//获取考勤机在线状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Attendance_GetDevState(LLONG lLoginID, const NET_IN_ATTENDANCE_GETDEVSTATE *pstuInParam, NET_OUT_ATTENDANCE_GETDEVSTATE *pstuOutParam, int nWaitTime);

//设置升级包URL入参
typedef struct tagNET_IN_UPGRADER_SETURL
{
	DWORD       dwSize;                                //结构体大小
	char        szUrl[DH_COMMON_STRING_256];           //升级包下载地址
	UINT        nCheckType;                            //升级包校验方式0:传入MD5值校验
	char        szCheckSum[DH_COMMON_STRING_128];      //升级包校验值
    int         nSpareUrl;                             //备选升级包的个数 
    char        szSpareUrl[4][256];                    //备选升级包下载地址
}NET_IN_UPGRADER_SETURL;

//设置升级包URL出参
typedef struct tagNET_OUT_UPGRADER_SETURL
{
	DWORD        dwSize;                               //结构体大小
}NET_OUT_UPGRADER_SETURL;

//设置升级包的URL,并从此下载地址下载升级包
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Upgrader_SetUrl(LLONG lLoginID, NET_IN_UPGRADER_SETURL *pInParam, NET_OUT_UPGRADER_SETURL *pOutParam, int nWaitTime);

// X光检包裹的查询条件
typedef struct tagNET_XRAY_PACK_CONDITION
{
	NET_TIME_EX			stuStartTime;				// 开始时间(含时区)
	NET_TIME_EX			stuEndTime;					// 结束时间(含时区)
	BYTE				byReserved[1024];			// 预留字节
}NET_XRAY_PACK_CONDITION;

// 获取X光检各类包裹数量统计信息入参
typedef struct tagNET_IN_XRAY_GETPACKTOTALINFO
{
	DWORD							dwSize;											// 结构体大小
	int								nChannelNum;									// 有效通道号的个数
	int								nChannelsID[MAX_XRAY_CHANNEL_NUM];				// 通道号 
	NET_XRAY_PACK_CONDITION			stuCondition;									// 查询条件
}NET_IN_XRAY_GETPACKTOTALINFO;

// 按危险等级统计的包裹数量信息
typedef struct tagNET_GRADE_PACK_NUM_INFO
{
	unsigned int	nNormalPackNum;			// 普通包裹个数
	unsigned int	nWarnPackNum;			// 警示包裹个数
	unsigned int	nDangerPackNum;			// 危险包裹个数
	BYTE			byReserved[20];			// 预留字节
}NET_GRADE_PACK_NUM_INFO;

// 按物品类型统计的包裹数信息 
typedef struct tagNET_PACK_TYPE_NUM_INFO
{
	unsigned int     nUnknownNum;				// 未识别物品的包裹数量
	unsigned int	 nKnifeNum;					// 包含刀具的包裹数量
	unsigned int	 nBottleLiquidNum;			// 含瓶装液体的包裹数量
	unsigned int	 nGunNum;					// 含枪支的包裹数量
	unsigned int	 nUmbrellaNum;				// 含雨伞的包裹数量
	unsigned int	 nPhoneNum;					// 含手机的包裹数量
	unsigned int     nNotebookNum;				// 含笔记本的包裹数量
	unsigned int	 nPowerbankNum;				// 含充电宝的包裹数量
	unsigned int	 nShoesNum;					// 含鞋子的包裹数量
	unsigned int	 nRodNum;					// 含杆子的包裹数量
	unsigned int	 nMetalNum;					// 含金属的包裹数量
	unsigned int	 nExplosiveNum;				// 含爆炸物的包裹数量
	unsigned int	 nContainerSprayNum;		// 含喷雾喷灌的包裹数量
	unsigned int	 nExplosiveFireworksNum;    // 含烟花爆竹的包裹数量
	unsigned int	 nLighterNum;               // 含打火机的包裹数量
	unsigned int	 nStickNum;                 // 含警棍的包裹数量
	unsigned int	 nBrassknuckleNum;          // 含有指虎的包裹的数量
	unsigned int	 nHandcuffsNum;             // 含有手铐的包裹的数量
	unsigned int	 nIvoryNum;                 // 含有象牙的包裹的数量
	BYTE			 byReserved[996];			// 预留字节
}NET_PACK_TYPE_NUM_INFO;
// 包裹信息
typedef struct tagNET_XRAY_PACKINFO
{
	unsigned int				nTotalNum;						// 所有包裹总数
	NET_GRADE_PACK_NUM_INFO		stuGradePackNumInfo;			// 按危险等级统计的包裹数量信息
	NET_PACK_TYPE_NUM_INFO		stuPackTypeNumInfo;				// 按物品类型统计的包裹数信息
	int							nChannel;						// 统计信息通道号
	BYTE						byReserved[1024];				// 预留字节
}NET_XRAY_PACKINFO;

// 获取X光检各类包裹数量统计信息出参
typedef struct tagNET_OUT_XRAY_GETPACKTOTALINFO
{
	DWORD							dwSize;										// 结构体大小
	NET_XRAY_PACKINFO				stuXrayPackInfo[MAX_XRAY_CHANNEL_NUM];		// X光检各类包裹数量统计信息 	
	int								nRetXrayPackInfoNum;						// 返回的统计信息个数
}NET_OUT_XRAY_GETPACKTOTALINFO;

// 获取X光检各类包裹数量统计信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Xray_GetPackTotalInfo(LLONG lLoginID, const NET_IN_XRAY_GETPACKTOTALINFO* pInParam, NET_OUT_XRAY_GETPACKTOTALINFO* pOutParam,int nWaitTime);

// 通过危险物等级统计的包裹信息
typedef struct tagNET_IN_PACKAGE_STATISTICS_BYGRADE
{
	EM_DANGER_GRADE_TYPE		emGrade;										// 危险物等级
	UINT						nCount;											// 危险物数量
	BYTE						byReserved[64];									// 预留字段
}NET_IN_PACKAGE_STATISTICS_BYGRADE;

// 通过物品类型统计的包裹信息
typedef struct tagNET_IN_PACKAGE_STATISTICS_BYTYPE
{
	EM_INSIDE_OBJECT_TYPE		emType;											// 危险物类型
	UINT						nCount;											// 危险物数量
	BYTE						byReserved[64];									// 预留字段
}NET_IN_PACKAGE_STATISTICS_BYTYPE;

// 包裹信息
typedef struct tagNET_IN_XRAY_STATISTICS_INFO
{
	char								szUUID[36];								// UUID	
	UINT								nStatisticsInfoID;						// 统计信息ID
	NET_TIME_EX							stuBeginTime;							// 开始时间
	NET_TIME_EX							stuEndTime;								// 结束时间
	UINT								nTotalCount;							// 包裹总数
	UINT								nStatisticsInfoByGradeNum;				// 按危险等级统计的信息的数量
	NET_IN_PACKAGE_STATISTICS_BYGRADE	stuStatisticsInfoByGrade[16];			// 按危险等级统计的信息
	UINT								nStatisticsInfoByTypeNum;				// 按危险类型统计的信息的数量
	NET_IN_PACKAGE_STATISTICS_BYTYPE	stuStatisticsInfoByType[64];			// 按危险类型统计的信息
	BYTE								byReserved[1024];						// 保留字段
}NET_IN_XRAY_PACKAGE_STATISTICS_INFO;

// 包裹信息回调函数
typedef void (CALLBACK *fXRayAttachPackageStatistics)(LLONG lAttachHandle, NET_IN_XRAY_PACKAGE_STATISTICS_INFO* pInfo, LDWORD dwUser);

// CLIENT_XRayAttachPackageStatistics 输入结构体
typedef struct tagNET_IN_XRAY_ATTACH_PACKAGE_STATISTICS
{
	DWORD							dwSize;										// 赋值为结构体大小
	char							szUUID[36];									// UUID
	fXRayAttachPackageStatistics	cbNotify;									// 回调函数
	LDWORD							dwUser;										// 用户信息
}NET_IN_XRAY_ATTACH_PACKAGE_STATISTICS;

// CLIENT_XRayAttachPackageStatistics 输出结构体
typedef struct tagNET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS
{
	DWORD							dwSize;										// 赋值为结构体大小
}NET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS;

// 订阅X光机包裹数量统计信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_XRayAttachPackageStatistics(LLONG lLoginID, const NET_IN_XRAY_ATTACH_PACKAGE_STATISTICS* pInParam, NET_OUT_XRAY_ATTACH_PACKAGE_STATISTICS* pOutParam, int nWaitTime);


// 取消订阅X光机包裹数量统计信息
// lAttachHandle 为 CLIENT_XRayAttachPackageStatistics 返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_XRayDetachPackageStatistics(LLONG lAttachHandle);

// 温度类型
typedef enum tagNET_TEMPERATURE_TYPE
{
	NET_TEMPERATURE_TYPE_CPU,			    // 处理器
}NET_TEMPERATURE_TYPE;

// CLIENT_FaceBoard_GetHistoryTemperature的入参
typedef struct tagNET_IN_GET_HISTORY_TEMPERATURE
{
	DWORD					dwSize;							// 结构体大小
	NET_TEMPERATURE_TYPE	emTemperatureType;				// 温度类型
}NET_IN_GET_HISTORY_TEMPERATURE;

// 每个温度监测点的历史温度
typedef struct tagNET_TEMPERATURE_VALUE
{
	double				dbHistoryTemperature[MAX_HISTORY_TEMPERATURE_NUM];	// 历史温度值,单位:摄氏度
	int					nRetHistoryTemperatureNum;							// 返回的有效历史温度值个数
	BYTE				byReserved[4];										// 保留字节
}NET_TEMPERATURE_VALUE;

// 历史温度信息
typedef struct tagNET_HISTORY_TEMPERATURE_INFO
{
	int						nRetMonitorPointNum;										// 返回的有效温度监测点的个数
	BYTE					byReserved[4];												// 保留字节，为了字节对齐
	NET_TEMPERATURE_VALUE   stuMonitorPointTemperature[MAX_TEMPERATURE_POINT_NUM];		// 监测点历史温度
	BYTE					byReserved1[1024];											// 保留字节
}NET_HISTORY_TEMPERATURE_INFO;

// CLIENT_FaceBoard_GetHistoryTemperature的出参
typedef struct tagNET_OUT_GET_HISTORY_TEMPERATURE
{
	DWORD							dwSize;							// 结构体大小
	BYTE							byReserved[4];					// 保留字节，为了字节对齐
	NET_HISTORY_TEMPERATURE_INFO	stuHistoryTemperatureInfo;		// 历史温度信息
}NET_OUT_GET_HISTORY_TEMPERATURE;

// 获取历史温度值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceBoard_GetHistoryTemperature(LLONG lLoginID, const NET_IN_GET_HISTORY_TEMPERATURE *pInParam, NET_OUT_GET_HISTORY_TEMPERATURE *pOutParam, int nWaitTime);

// 温度类型
typedef enum tagEM_TEMPERATUREEX_TYPE
{
	EM_TEMPERATUREEX_TYPE_UNKNOWN,          // 未知
	EM_TEMPERATUREEX_TYPE_ALL,			    // 全部
	EM_TEMPERATUREEX_TYPE_POWER,			// 电源
	EM_TEMPERATUREEX_TYPE_CABINET,			// 机柜
	EM_TEMPERATUREEX_TYPE_GLOBAL,			// 环境
	EM_TEMPERATUREEX_TYPE_MAINBOARD,	    // 主板
	EM_TEMPERATUREEX_TYPE_CARD,			    // 子卡
	EM_TEMPERATUREEX_TYPE_BACKBOARD,	    // 背板
	EM_TEMPERATUREEX_TYPE_CPU,			    // 处理器
}EM_TEMPERATUREEX_TYPE;

// CLIENT_FaceBoard_GetTemperatureEx的入参
typedef struct tagNET_IN_GET_TEMPERATUREEX
{
	DWORD                           dwSize;   						// 结构体大小
	EM_TEMPERATUREEX_TYPE	        emTemperatureType;				// 温度类型
}NET_IN_GET_TEMPERATUREEX;

// 每个监测点的温度
typedef struct tagNET_TEMPERATUREEX_VALUE
{
	EM_TEMPERATUREEX_TYPE	        emTemperatureType;				// 温度类型
	int					nRetTemperatureNum;							// 返回的有效温度值个数
	float				fTemperature[MAX_HISTORY_TEMPERATURE_NUM];	// 温度值,单位:摄氏度
	BYTE				byReserved[128];						    // 保留字节
}NET_TEMPERATUREEX_VALUE;

// CLIENT_FaceBoard_GetTemperatureEx的出参
typedef struct tagNET_OUT_GET_TEMPERATUREEX
{
	DWORD                    dwSize;   						        // 结构体大小
	int						 nRetMonitorPointNum;					// 返回的有效温度监测点的个数,num>1时,对应emTemperatureType为ALL
	NET_TEMPERATUREEX_VALUE  stuTemperatureEx[MAX_TEMPERATUREEX_POINT_NUM];	// 监测点温度
}NET_OUT_GET_TEMPERATUREEX;

// 获取温度值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceBoard_GetTemperatureEx(LLONG lLoginID, const NET_IN_GET_TEMPERATUREEX *pInParam, NET_OUT_GET_TEMPERATUREEX *pOutParam, int nWaitTime);


// CLIENT_GetAlarmOutState 入参
typedef struct tagNET_IN_GET_ALARM_OUT_STATE 
{
	DWORD							dwSize; 						// 结构体大小
} NET_IN_GET_ALARM_OUT_STATE;

#define	MAX_OUT_STATE_COUNT	32

//CLIENT_GetAlarmOutState 出参
typedef struct tagNET_OUT_GET_ALARM_OUT_STATE 
{
	DWORD							dwSize;							// 结构体大小
	int								nState[MAX_OUT_STATE_COUNT];	// 输出端口状态, 0表示没有, 1表示有
} NET_OUT_GET_ALARM_OUT_STATE;

// 获得每个报警输出端口的状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmOutState(LLONG lLoginID, const NET_IN_GET_ALARM_OUT_STATE *pInParam, NET_OUT_GET_ALARM_OUT_STATE *pOutParam, int nWaitTime);

// 二维码类型
typedef enum tagNET_EM_2DCODE_TYPE
{
    NET_EM_2DCODE_TYPE_OZVISION,                                     // TYCO客户的P2P功能
    NET_EM_2DCODE_TYPE_LCWEBSITE,                                    // 乐橙手机客户端
    NET_EM_2DCODE_TYPE_EASY4IP,                                      // easy4ip手机客户端
    NET_EM_2DCODE_TYPE_DMSS,                                         // i/gDMSS手机客户端
    NET_EM_2DCODE_TYPE_VIDEOTALK,                                    // 可视对讲客户端
    NET_EM_2DCODE_TYPE_APPREGISTER,                                  // app注册信息二维码
	NET_EM_2DCODE_TYPE_DEVAUTH,										 // H500平台向美的平台获取授权
}NET_EM_2DCODE_TYPE;


// 获取工作目录实例 入参
typedef struct tagNET_IN_WORKDIRECTORY_GETGROUP_INFO
{
	DWORD				dwSize;
	char				szDirectoryName[DH_COMMON_STRING_256];		// 磁盘目录名称
}NET_IN_WORKDIRECTORY_GETGROUP_INFO;

// 获取工作目录实例 出参
typedef struct tagNET_OUT_WORKDIRECTORY_GETGROUP_INFO
{
	DWORD				dwSize;			
	char				szGroupName[DH_COMMON_STRING_256];			// 工作目录组名
}NET_OUT_WORKDIRECTORY_GETGROUP_INFO;

// 获取工作目录组名
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WorkDirectoryGetGroup(LLONG lLoginID, const NET_IN_WORKDIRECTORY_GETGROUP_INFO *pInParam,  NET_OUT_WORKDIRECTORY_GETGROUP_INFO *pOutParam, int nWaitTime);

// 设置工作目录组名 入参
typedef struct tagNET_IN_WORKDIRECTORY_SETGROUP_INFO
{
	DWORD				dwSize;
	char				szGroupName[DH_COMMON_STRING_256];			// 工作目录组名
	char				szDirectoryName[DH_COMMON_STRING_256];		// 磁盘目录名称
}NET_IN_WORKDIRECTORY_SETGROUP_INFO;

// 设置工作目录组名 出参
typedef struct tagNET_OUT_WORKDIRECTORY_SETGROUP_INFO
{
	DWORD				dwSize;
}NET_OUT_WORKDIRECTORY_SETGROUP_INFO;

// 设置工作目录组名
CLIENT_NET_API BOOL CALL_METHOD CLIENT_WorkDirectorySetGroup(LLONG lLoginID, const NET_IN_WORKDIRECTORY_SETGROUP_INFO *pInParam, NET_OUT_WORKDIRECTORY_SETGROUP_INFO *pOutParam, int nWaitTime);

// CLIENT_Get2DCode 入参
typedef struct tagNET_IN_GET_2DCODE
{
    DWORD							dwSize;							// 结构体大小
    NET_EM_2DCODE_TYPE              em2DCodeType;                   // 二维码类型
}NET_IN_GET_2DCODE;

// CLIENT_Get2DCode 出参
typedef struct tagNET_OUT_GET_2DCODE
{
    DWORD							dwSize;							// 结构体大小
    char                            sz2DCode[DH_COMMON_STRING_512]; // 二维码信息
}NET_OUT_GET_2DCODE;

// 获取二维码信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Get2DCode(LLONG lLoginID, const NET_IN_GET_2DCODE *pInParam, NET_OUT_GET_2DCODE *pOutParam, int nWaitTime);

// CLIENT_Set2DCode 入参
typedef struct tagNET_IN_SET_2DCODE
{
    DWORD							dwSize;							// 结构体大小
    NET_EM_2DCODE_TYPE              em2DCodeType;                   // 二维码类型
    char                            sz2DCode[DH_COMMON_STRING_512]; // 二维码信息
}NET_IN_SET_2DCODE;

// CLIENT_Set2DCode 出参
typedef struct tagNET_OUT_SET_2DCODE
{
    DWORD							dwSize;							// 结构体大小
}NET_OUT_SET_2DCODE;

// 设置二维码信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Set2DCode(LLONG lLoginID, const NET_IN_SET_2DCODE *pInParam, NET_OUT_SET_2DCODE *pOutParam, int nWaitTime);

// 人脸库导入状态
typedef enum tagEM_IMPORT_FACEDB_STATE
{
	EM_IMPORT_FACEDB_UNKNOWN,			// 未知
	EM_IMPORT_FACEDB_ONGING,			// 导入中
	EM_IMPORT_FACEDB_END,				// 导入结束, 开始生成数据库
	EM_IMPORT_FACEDB_BUSY,				// 系统忙，已经有导入任务
	EM_IMPORT_FACEDB_DATAERROR,			// 数据包检验失败
	EM_IMPORT_FACEDB_INVALID,			// 数据包非法
	EM_IMPORT_FACEDB_SYNC_SUCCESS,		// 同步成功, 数据库已生成
	EM_IMPORT_FACEDB_SYNC_FALIED,		// 同步失败, 数据库无法生成
	EM_IMPORT_FACEDB_DBFULL,			// 数据库已满无法导入
	EM_IMPORT_FACEDB_SDFULL,			// 存储空间满无法导入
	EM_IMPORT_FACEDB_CIPHER_ERROR,		// 导入压缩包密码不对
} EM_IMPORT_FACEDB_STATE;

// 人脸对比库进度类型
typedef enum tagEM_FACEDB_PROGRESS_TYPE
{
	EM_FACEDB_PROGRESS_IMPORT,			// 人脸库导入进度
	EM_FACEDB_PROGRESS_DEPLOY,			// 人脸库部署进度
} EM_FACEDB_PROGRESS_TYPE;

// 导入人脸库状态信息
typedef struct tagNET_IMPORT_FACEDB_STATE
{
	unsigned int	        	nProgress;			// 进度, 百分比
	EM_FACEDB_PROGRESS_TYPE		emType;				// 进度类型
	EM_IMPORT_FACEDB_STATE		emState;			// 状态信息
	BYTE			        	byReserved[512];	// 保留字节
} NET_IMPORT_FACEDB_STATE;

// 导入人脸库回调函数原形
typedef void (CALLBACK *fImportFaceDbCallBack) (LLONG lImportFaceDbHandle, NET_IMPORT_FACEDB_STATE *pstFaceDbState, LDWORD dwUser);

// CLIENT_ImportFaceDB 接口输入参数
typedef struct tagNET_IN_IMPORT_FACE_DB
{
	DWORD							dwSize;								// 结构体大小
	char                			szGroupId[DH_COMMON_STRING_64];		// 人员组ID
	char							szPassWord[DH_COMMON_STRING_64];	// 压缩密码
	char							*pszFaceDBPath;						// 人脸库路径, 由用户指定
	fImportFaceDbCallBack			cbImportState;						// 上传状态回调函数
	LDWORD 							dwUser;								// 用户数据
    int                             nWaitTime;                          // 超时时间
} NET_IN_IMPORT_FACE_DB;

// CLIENT_ImportFaceDB 接口输出参数
typedef struct tagNET_OUT_IMPORT_FACE_DB
{
	DWORD							dwSize;							// 结构体大小
} NET_OUT_IMPORT_FACE_DB;

// 人脸库导入接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportFaceDB(LLONG lLoginID, const NET_IN_IMPORT_FACE_DB *pInParam, NET_OUT_IMPORT_FACE_DB *pOutParam);

// 停止人脸库导入
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportFaceDB(LLONG lImportFaceDbHandle);

// 导出人脸对比库错误码
typedef enum tagEM_EXPORT_FACEDB_ERRORCODE
{
	EM_EXPORT_FACEDB_REQUEST_SUCCESS	= 1,		// 人脸库导出请求成功
	EM_EXPORT_FACEDB_NO_AUTHORITY		= 2,		//无权限
	EM_EXPORT_FACEDB_NO_THIS_FILE		= 3,		// 文件不存在
	EM_EXPORT_FACEDB_EXPORT_END			= 4,		// 导出结束
	EM_EXPORT_FACEDB_EXPORTING			= 5,		// 导出中
	EM_EXPORT_FACEDB_FILE_READY			= 8,		// 文件准备完成
	EM_EXPORT_FACEDB_FILE_FAILED		= 9,		// 文件准备失败
	EM_EXPORT_FACEDB_WAIT_FILE			= 10,		// 人脸库导出请求成功, 需要等待设备准备数据
	EM_EXPORT_FACEDB_SYSTEM_BUSY		= 11,		// 系统忙, 暂时无法导出数据
	EM_EXPORT_FACEDB_NO_PASSWORD		= 12,		// 人脸库数据未定义密码, 不允许导出
} EM_EXPORT_FACEDB_ERRORCODE;

// 导出人脸库状态信息
typedef struct tagNET_EXPORT_FACEDB_STATE
{
	unsigned int					nProgress;			// 进度, 百分比
	EM_EXPORT_FACEDB_ERRORCODE		emErrorCode;		// 错误码
	char							*pDataBuf;			// 人脸库导出数据
	DWORD							dwDataLen;			// 数据长度
	BYTE							byReserved[512];	// 保留字节
} NET_EXPORT_FACEDB_STATE;

// 导出人脸库回调函数原形
typedef void (CALLBACK *fExportStateCallBack)(LLONG lExportFaceDbHandle, NET_EXPORT_FACEDB_STATE *pstFaceDbState, LDWORD dwUser);

// CLIENT_ExportFaceDB 接口输入参数
typedef struct tagNET_IN_EXPORT_FACE_DB
{
	DWORD							dwSize;								// 结构体大小
	char                			szGroupId[DH_COMMON_STRING_64];		// 人员组ID
	char							szPassWord[DH_COMMON_STRING_64];	// 压缩密码
	fExportStateCallBack			cbExportFaceDbCallBack;				// 导出人脸库回调函数
	LDWORD 							dwUser;								// 用户数据
	int                             nWaitTime;                          // 超时时间
} NET_IN_EXPORT_FACE_DB;

// CLIENT_ExportFaceDB 接口输出参数
typedef struct tagNET_OUT_EXPORT_FACE_DB
{
	DWORD							dwSize;							// 结构体大小
} NET_OUT_EXPORT_FACE_DB;

// 人脸库导出接口
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportFaceDB(LLONG lLoginID, const NET_IN_EXPORT_FACE_DB *pInParam, NET_OUT_EXPORT_FACE_DB *pOutParam);

// 停止人脸库导出
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportFaceDB(LLONG lExportFaceDbHandle);


// PIR检测区域信息
typedef struct tagNET_DETECT_WINDOW_IFNO
{
	int				    nRegionID;									// 动态窗口ID
    char                szRegionName[DH_COMMON_STRING_128];			// 动态窗口名称
    int                 nThreshold;                                 // 面积阀值, 取值[0, 100]
	int					nSensitive;									// 灵敏度, 取值[0, 100]
	int					nRegionRow;									// 动态检测区域的行数
	int					nRegionCol;									// 动态检测区域的列数
	BYTE				byRegion[DH_MOTION_ROW][DH_MOTION_COL];		// 检测区域, 最多32*32块区域
	int					nLevel;										// 灵敏度,取值[1,6]
	BYTE				byReserved[508];							// 保留字节
} NET_DETECT_WINDOW_IFNO;

// 灯光联动方式
typedef enum tagEM_PIR_LIGHT_LINK_TYPE
{
	EM_PIR_LIGHT_LINK_TYPE_UNKNOWN,									// 未知
	EM_PIR_LIGHT_LINK_TYPE_FILCKER,									// 闪烁
	EM_PIR_LIGHT_LINK_TYPE_KEEPLIGHTING,							// 常亮
} EM_PIR_LIGHT_LINK_TYPE;


// 联动白光灯威慑
typedef struct tagNET_LIGHTINGLINK_INFO 
{
	BOOL					bEnable;								// 是否联动
	EM_PIR_LIGHT_LINK_TYPE	emLightLinkType;						// 灯光联动方式
	int						nFilckerIntevalTime;					// 闪烁间隔时间, 单位为0.1s
	int						nLightDuration;							// 灯光闪烁或常亮持续时间, 单位秒
	DH_TSECT				stuWhiteLightTimeSection[DH_TSCHE_DAY_NUM][DH_TSCHE_SEC_NUM];	// 联动白光灯威慑时间段
	BYTE					byReserved[512];						// 保留字节
} NET_LIGHTINGLINK_INFO ;

// 报警联动信息
typedef struct tagNET_PIR_LINK_INFO
{
	BOOL						bRecordEnable;							// 录像使能
	BOOL						bAlarmOutEnable;						// 报警输出使能
	BOOL						bSnapshotEnable;						// 快照使能
	BOOL						bMailEnable;							// 发送邮件，如果有图片，作为附件
	BOOL						bAlarmBellEnable;						// 警号输出使能
	BOOL						bLogEnable;								// 是否记录报警日志
	int							nRecordChannelNum;						// 录像通道个数
	int							nRecordChannels[DH_COMMON_STRING_64];					// 录像通道号列表
	int							nRecordLatch;							// 录像延时时间, 范围[10,300]
	int							nAlarmOutChannelNum;					// 报警输出通道个数
	int							AlarmOutChannels[DH_COMMON_STRING_32];					// 报警输出通道号列表
	int							nAlarmOutLatch;							// 报警输入停止后，输出延时时间,范围[1,300]
	int							nSnapshotChannelNum;					// 快照通道个数
	int							SnapshotChannels[DH_COMMON_STRING_32];					// 快照通道号列表	
	int							nAlarmBellLatch;						// 警号输出延时时间,10~300
	int							nDejitter;								// 去抖动时间	
	NET_LIGHTINGLINK_INFO		stLightingLink;							// 联动白光灯威慑
	NET_CFG_TIME_SCHEDULE		stTimeShecule;							// 报警时间段
	BYTE						byReserved1[512];						// 保留字段
}NET_PIR_LINK_INFO;
// PIR检测区域最大个数
#define MAX_DETECT_WINDOW	4

// PIR配置信息
typedef struct tagNET_PIR_ALARM_INFO
{
	BOOL					bEnable;									
	int						nDetectWindowCount;						// PIR检测区域个数
	NET_DETECT_WINDOW_IFNO	stDetectWindow[MAX_DETECT_WINDOW];		// PIR检测区域
	NET_PIR_LINK_INFO		stPirLink;								// 报警联动信息
} NET_PIR_ALARM_INFO;

// CLIENT_GetPirAlarmParam 入参
typedef struct tagNET_IN_GET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	int					nChannel;									// 视频通道号
} NET_IN_GET_PIR_ALARM_PARAM;

// CLIENT_GetPirAlarmParam 出参
typedef struct tagNET_OUT_GET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	NET_PIR_ALARM_INFO	stPirAlarmInfo;								// PIR配置信息
	int					nPirAlarmNum;								// 实际获取到的个数
	NET_PIR_ALARM_INFO	stPirAlarmInfoEx[MAX_PIRPARAM_NUM];			// 用于有多个pir的设备，最大10
} NET_OUT_GET_PIR_ALARM_PARAM;

// CLIENT_SetPirAlarmParam 入参
typedef struct tagNET_IN_SET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
	int					nChannel;									// 视频通道号
	NET_PIR_ALARM_INFO	stPirAlarmInfo;								// PIR配置信息
	int					nPirAlarmNum;								// 需要设置的个数
	NET_PIR_ALARM_INFO	stPirAlarmInfoEx[MAX_PIRPARAM_NUM];			// 用于有多个pir的设备
} NET_IN_SET_PIR_ALARM_PARAM;

// CLIENT_SetPirAlarmParam 出参
typedef struct tagNET_OUT_SET_PIR_ALARM_PARAM
{
	DWORD				dwSize;
} NET_OUT_SET_PIR_ALARM_PARAM;

// 获取PIR配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPirAlarmParam(LLONG lLoginID, const NET_IN_GET_PIR_ALARM_PARAM *pstInParam, NET_OUT_GET_PIR_ALARM_PARAM *pstOutParam, int nWaitTime);

// 设置PIR配置
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPirAlarmParam(LLONG lLoginID, const NET_IN_SET_PIR_ALARM_PARAM *pstInParam, NET_OUT_SET_PIR_ALARM_PARAM *pstOutParam, int nWaitTime);

//Onvif 用户所在组
typedef enum tagEM_GROUP_TYPE
{
	EM_GROUP_TYPE_UNKNOWN,		// UnKnown	
	EM_GROUP_TYPE_ADMIN,		// admin
	EM_GROUP_TYPE_OPERATOR,		// operator
	EM_GROUP_TYPE_USER,			// user
	EM_GROUP_TYPE_ANONYMOUS,	// anonymous
} EM_GROUP_TYPE;

// 动检数据
typedef struct tagNET_MOTION_DATA
{
	int				    nRegionID;									// 动态窗口ID
    int                 nThreshold;                                 // 面积阀值, 取值[0, 100]
	BYTE				byReserved[512];							// 保留字节
} NET_MOTION_DATA;



// Onvif 新用户信息
typedef struct tagNET_ONVIF_USER_INFO
{
	char			szName[DH_COMMON_STRING_128];						// 用户名
	char			szPassword[DH_COMMON_STRING_128];					// 密码
	NET_TIME		stuPasswordModifiedTime;							// 最近修改密码的时间
	EM_GROUP_TYPE	emGroupType;										// 用户所在的组
	BOOL			bReserved;											// 用户是否为保留用户，保留用户不可删除
	BYTE			byReserved[512];									// 保留字节
} NET_ONVIF_USER_INFO;

// 修改 Onvif用户，CLIENT_ModifyOnvifUser 入参
typedef struct tagNET_IN_MODIFYONVIF_USER_INFO
{
	DWORD					dwSize;											// 结构体大小
	char					szName[DH_COMMON_STRING_128];					// 需要修改的用户名称
	NET_ONVIF_USER_INFO		stUserInfo;										// 新用户信息
} NET_IN_MODIFYONVIF_USER_INFO;

// 修改 Onvif用户，CLIENT_ModifyOnvifUser 出参
typedef struct tagNET_OUT_MODIFYONVIF_USER_INFO
{
	DWORD				dwSize;		// 结构体大小
} NET_OUT_MODIFYONVIF_USER_INFO;

// 获取所有 Onvif 用户信息，CLIENT_GetOnvifUserInfoAll 入参
typedef struct tagNET_IN_GETONVIF_USERINFO_ALL_INFO
{
	DWORD				dwSize;		// 结构体大小
} NET_IN_GETONVIF_USERINFO_ALL_INFO;

// 获取所有 Onvif 用户信息， CLIENT_GetOnvifUserInfoAll 出参
typedef struct tagNET_OUT_GETONVIF_USERINFO_ALL_INFO
{
	DWORD					dwSize;										// 结构体大小
	int						nRetUserInfoNumber;							// 本次已查询到的个数
	NET_ONVIF_USER_INFO		stuUserInfo[MAX_ONVIF_USER_NUM];			// 用户信息列表(无法获取到密码信息)
} NET_OUT_GETONVIF_USERINFO_ALL_INFO;

// 修改 Onvif 用户密码， CLIENT_ModifyOnvifUserPassword 入参
typedef struct tagNET_IN_MODIFYONVIF_PASSWORD_INFO
{
	DWORD				dwSize;							// 结构体大小
	char				szName[DH_COMMON_STRING_128];	// 用户名称
	char				szPwd[DH_COMMON_STRING_128];	// 用户密码
	char				szPwdOld[DH_COMMON_STRING_128];	// 旧密码
} NET_IN_MODIFYONVIF_PASSWORD_INFO;

// 修改 Onvif 用户密码，CLIENT_ModifyOnvifUserPassword 出参
typedef	struct tagNET_OUT_MODIFYONVIF_PASSWORD_INFO
{
	DWORD				dwSize;							// 结构体大小
} NET_OUT_MODIFYONVIF_PASSWORD_INFO;

// 修改 Onvif 用户（只能修改非 admin用户）pstInParam、pstOutParam 内存由用户申请、释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyOnvifUser(LLONG lLoginID, const NET_IN_MODIFYONVIF_USER_INFO *pstInParam, NET_OUT_MODIFYONVIF_USER_INFO *pstOutParam, int nWaitTime);

// 获取所有 Onvif 用户信息，pstInParam、pstOutParam 内存由用户申请、释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetOnvifUserInfoAll(LLONG lLoginID, const NET_IN_GETONVIF_USERINFO_ALL_INFO *pstInParam, NET_OUT_GETONVIF_USERINFO_ALL_INFO *pstOutParam, int nWaitTime);

// 修改 Onvif 用户密码， pstInParam、pstOutParam 内存由用户申请、释放
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_ModifyOnvifUserPassword(LLONG lLoginID, const NET_IN_MODIFYONVIF_PASSWORD_INFO *pstInParam, NET_OUT_MODIFYONVIF_PASSWORD_INFO *pstOutParam, int nWaitTime);


// 动检窗口最大个数
#define	MAX_MOTION_DATA_COUNT	4

// 回调元数据消息
typedef struct tagNET_CB_MOTION_DATA
{
	DWORD				dwSize;
	int				    nMotionDataCount;							// 动检窗口个数
	NET_MOTION_DATA		stMotionData[MAX_MOTION_DATA_COUNT];		// 动检数据
	int					nRegionRow;									// 动态检测区域的行数
	int					nRegionCol;									// 动态检测区域的列数
	BYTE				byRegion[DH_MOTION_ROW][DH_MOTION_COL];		// 检测区域, 最多32*32块区域
} NET_CB_MOTION_DATA;

// 订阅动检元数据处理回调函数原形,lAttachHandle是CLIENT_attachMotionData返回值, 每次1条
typedef void (CALLBACK *fAttachMotionDataCB) (LLONG lAttachHandle, NET_CB_MOTION_DATA* pBuf, LDWORD dwUser);

// CLIENT_AttachMotionData 输入参数
typedef struct tagNET_IN_ATTACH_MOTION_DATA
{
    DWORD                   dwSize;
	int						nChannel;						// 通道号
    fAttachMotionDataCB	    cbNotify;						// 回调函数
    LDWORD                  dwUser;                         // 用户数据
} NET_IN_ATTACH_MOTION_DATA;

// CLIENT_AttachMotionData 输出参数
typedef struct tagNET_OUT_ATTACH_MOTION_DATA
{
    DWORD                   dwSize;
} NET_OUT_ATTACH_MOTION_DATA;

// 订阅动检元数据
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMotionData(LLONG lLoginID, const NET_IN_ATTACH_MOTION_DATA* pstInParam, NET_OUT_ATTACH_MOTION_DATA *pstOutParam, int nWaitTime);

// 退订事件元数据,lAttachHandle是CLIENT_attachMotionData返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMotionData(LLONG lAttachHandle);

// 指令源
typedef enum tagEM_SRC_INSRUCTION
{
    EM_SRC_INSRUCTION_VTO_CALL,                      // 门口机呼叫
    EM_SRC_INSRUCTION_VTO_CARD,                      // 门口机刷卡
    EM_SRC_INSRUCTION_LIFT_CARD,                     // 梯控机刷卡
    EM_SRC_INSRUCTION_VTH_CALL,                      // 室内机招梯
    EM_SRC_INSRUCTION_VTO_FINGERPRINT,               // 门口机刷指纹
    EM_SRC_INSRUCTION_VTO_PSW,                       // 门口机刷密码
}EM_SRC_INSRUCTION;

// CLIENT_CallLift 入参
typedef struct tagNET_IN_LIFTCONTROL_CALLLIFT_INFO
{
    DWORD				    dwSize;
    char                    szFloorNo[4];                   // 楼层号
    char                    szRoomNo[12];                   // 房间号
    char                    szUserID[8];                    // 用户ID
    char                    szCardNo[32];                   // 卡号
    EM_SRC_INSRUCTION       emSrcInstruction;               // 指令源
}NET_IN_LIFTCONTROL_CALLLIFT_INFO;

// CLIENT_CallLift 出参
typedef struct tagNET_OUT_LIFTCONTROL_CALLLIFT_INFO
{
    DWORD				    dwSize;
}NET_OUT_LIFTCONTROL_CALLLIFT_INFO;

// 招梯控制。点亮上下行按钮
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CallLift(LLONG lLoginID, const NET_IN_LIFTCONTROL_CALLLIFT_INFO *pstInParam, NET_OUT_LIFTCONTROL_CALLLIFT_INFO *pstOutParam, int nWaitTime);

// CLIENT_ControlLift 入参
typedef struct tagNET_IN_LIFTCONTROL_CONTROLLIFT_INFO
{
    DWORD				    dwSize;
    int                     nFloorNum;                      // 楼层数量            
    char                    szFloorNo[32][4];               // 楼层号
    char                    szRoomNo[12];                   // 房间号
    char                    szUserID[8];                    // 用户ID
    char                    szCardNo[32];                   // 卡号
    EM_SRC_INSRUCTION       emSrcInstruction;               // 指令源
}NET_IN_LIFTCONTROL_CONTROLLIFT_INFO;

// CLIENT_ControlLift 出参
typedef struct tagNET_OUT_LIFTCONTROL_CONTROLLIFT_INFO
{
    DWORD				    dwSize;
}NET_OUT_LIFTCONTROL_CONTROLLIFT_INFO;

// 梯控控制。使用场景:门口机刷卡招梯，那么点亮电梯里有权限的楼层按钮
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlLift(LLONG lLoginID, const NET_IN_LIFTCONTROL_CONTROLLIFT_INFO *pstInParam, NET_OUT_LIFTCONTROL_CONTROLLIFT_INFO *pstOutParam, int nWaitTime);

// 无线配置类型
typedef enum tagNET_ENUM_LOWRATEWPAN_CONFIG
{
    NET_ENUM_LOWRATEWPAN_ACCESS_WORKMODE,               // 工作模式配置，对应结构体 NET_LOWRATEWPAN_WORKMODE
}NET_ENUM_LOWRATEWPAN_CONFIG;

// 工作模式
typedef enum tagNET_ENUM_LOWRATEWPAN_WORKMODE
{
    NET_ENUM_LOWRATEWPAN_WORKMODE_UNKNOWN,              // 未知
    NET_ENUM_LOWRATEWPAN_WORKMODE_NORMAL,               // 正常
    NET_ENUM_LOWRATEWPAN_WORKMODE_CLEAN,				// 打扫
    NET_ENUM_LOWRATEWPAN_WORKMODE_DECORATION,			// 装修
    NET_ENUM_LOWRATEWPAN_WORKMODE_UNUSED,				// 停用
    NET_ENUM_LOWRATEWPAN_WORKMODE_OUTSTANDING,			// 欠费
}NET_ENUM_LOWRATEWPAN_WORKMODE;

// 工作模式配置
typedef struct tagNET_LOWRATEWPAN_WORKMODE
{
    DWORD				                dwSize;
    NET_ENUM_LOWRATEWPAN_WORKMODE       emWorkMode;                 // 工作模式
}NET_LOWRATEWPAN_WORKMODE;

// 无线配置获取接口
CLIENT_NET_API  BOOL CALL_METHOD CLIENT_GetLowRateWPANConfig(LLONG lLoginID,NET_ENUM_LOWRATEWPAN_CONFIG emType,char* SN,void* szOutBuffer, DWORD dwOutBufferSize, int nWaitTime, void *reserve);

// 无线配置设置接口
CLIENT_NET_API  BOOL CALL_METHOD CLIENT_SetLowRateWPANConfig(LLONG lLoginID,NET_ENUM_LOWRATEWPAN_CONFIG emType,char* SN,void* szInBuffer, DWORD dwInBufferSize, int nWaitTime, int *restart, void *reserve);

// CLIENT_GetVideoDiagnosisState 入参
typedef struct tagNET_IN_GET_VIDEODIAGNOSIS_STATE
{
     DWORD				            dwSize;                                     //  结构体大小
     char                           szProject[128];                             //  计划名，为空表示所有执行的计划
}NET_IN_GET_VIDEODIAGNOSIS_STATE;
// 诊断状态
typedef struct tagVIDEODIAGNOSIS_STATE
{
    BOOL                            bEnable;                                     // 是否使能
    BOOL                            bRunning;                                    // 是否正在运行	使能开启，并且当前有工作任务正在进行，没有错误发生。
    char                            szCurrentProject[MAX_PATH];                  // 当前计划名称
    char                            szCurrentTask[MAX_PATH];                     // 当前任务名称
    char                            szCurrentProfile[MAX_PATH];                  // 当前任务配置参数表名称
    int                             nCurrentSourceCount;                         // 当前任务轮训视频源个数
    int                             nCurrentSourceIndex;                         // 当前任务当前视频源序号	从0开始
    DH_TSECT                        stCurrentTimeSection;                        // 当前计划时间段
    int                             nTaskCountOfProject;                         // 当前计划总任务数
    int                             nIndexOfCurrentTask;                         // 当前任务序号 从0开始
    BYTE				            byReserved[512];							 // 保留字节
}VIDEODIAGNOSIS_STATE;
// CLIENT_GetVideoDiagnosisState 出参
typedef struct tagNET_OUT_GET_VIDEODIAGNOSIS_STATE
{
    DWORD				            dwSize;                                      //  结构体大小
    VIDEODIAGNOSIS_STATE            stuState[2];                                 //  工作状态,数组下标0:Tour,1:RealTime                         
}NET_OUT_GET_VIDEODIAGNOSIS_STATE;

// 获取视频诊断进行状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoDiagnosisState(LLONG lLoginID, const NET_IN_GET_VIDEODIAGNOSIS_STATE *pstInParam, NET_OUT_GET_VIDEODIAGNOSIS_STATE *pstOutParam, int nWaitTime);


#define LOGIN_TYPE_DEVICE_NOT_SUPPORT 100			// 设备不支持此种登录
// CLIENT_PostLoginTask 登录结果回调
// CLIENT_PostLoginTask 输入参数
typedef struct tagNET_POST_LOGIN_TASK
{
	LLONG						lLoginID;			//登录句柄
	char*						pchDVRIP;			//设备IP
	LONG						nDVRPort;			//设备端口
	BOOL						bOnline;			//设备状态 bOnline为TRUE表示登录成功，为FALSE时表示登录失败。
	NET_DEVICEINFO_Ex			stuDeviceInfo;		//设备信息扩展
	int							nError;				//当登陆失败时（bOnline为FALSE），nError 的错误码含义说明参考 CLIENT_Login 中的 error 说明，同时，当nError为 LOGIN_TYPE_DEVICE_NOT_SUPPORT 时，表示设备不支持此种登录方式
	char						szReserve[1024];	//保留字段
}NET_POST_LOGIN_TASK;

typedef void (CALLBACK *fPostLoginTask)(DWORD dwTaskID, NET_POST_LOGIN_TASK* pOutParam, LDWORD dwUser);

typedef enum tagEM_TCP_LOGIN_CONFIG_TYPE
{
	EM_TCP_LOGIN_CONFIG_TYPE_UNKNOWN = 0,			// 未知配置
	EM_TCP_LOGIN_CONFIG_TYPE_MULTICAST,				// 组播配置
}EM_TCP_LOGIN_CONFIG_TYPE;

// CLIENT_PostLoginTask 输入参数
typedef struct tagNET_IN_POST_LOGIN_TASK
{
	DWORD						dwSize;				// 赋值为结构体大小
	char						szReserve1[4];		// 保留字段1
	char*						szIp;				// 设备ip
	unsigned int				nPort;				// 登陆端口
	char						szReserve2[4];		// 保留字段2
	char*						szName;				// 用户名
	char*						szPwd;				// 密码
	EM_LOGIN_SPAC_CAP_TYPE		emSpecCap;			// 登录方式，目前只支持 EM_LOGIN_SPEC_CAP_TCP、
													// EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY、EM_LOGIN_SPEC_CAP_P2P
	EM_TCP_LOGIN_CONFIG_TYPE	emConfigType;		// 当emSpecCap为EM_LOGIN_SPEC_CAP_TCP时，需要获取的配置类型,此时获取的配置和拉流相关
													// 当为EM_TCP_LOGIN_CONFIG_TYPE_UNKNOWN时，码流通过TCP传输，为EM_TCP_LOGIN_CONFIG_TYPE_MULTICAST时，码流通过组播传输
	fPostLoginTask				cbLogin;			// 登陆结果回调
	void*						pUser;				// 回调用户参数
	BOOL						bHighLevelSecurity;	// 是否高安全等级登陆
	BYTE						byReserved[132];	// 预留字段
}NET_IN_POST_LOGIN_TASK;

// CLIENT_PostLoginTask 输出参数
typedef struct tagNET_OUT_POST_LOGIN_TASK 
{
	DWORD						dwSize;				// 赋值为结构体大小
}NET_OUT_POST_LOGIN_TASK;

// 投递异步登录任务
CLIENT_NET_API DWORD CALL_METHOD CLIENT_PostLoginTask(const NET_IN_POST_LOGIN_TASK* pInParam, NET_OUT_POST_LOGIN_TASK* pOutParam);

// 取消 CLIENT_PostLoginTask 接口的异步登录任务，dwTaskID 为 CLIENT_PostLoginTask 返回值
CLIENT_NET_API BOOL CALL_METHOD  CLIENT_CancelLoginTask(DWORD dwTaskID);


/****************************** start 西欧报警主机接口 与老报警主机不兼容***************************************/
// 获取能力 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALARMCAPS
typedef struct tagNET_IN_GET_ALARMCAPS
{
	DWORD			dwSize;				// 结构体大小
}NET_IN_GET_ALARMCAPS;



// 获取能力 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALARMCAPS
typedef struct tagNET_OUT_GET_ALARMCAPS
{
	DWORD			dwSize;				// 结构体大小
	int             nSiren;             // 支持的警号数量

	int             nAlarmIn;           // 支持的报警输入数量
	int             nAlarmOut;          // 支持的报警输出数量
	int             nRemoteControl;     // 支持的遥控器数量
}NET_OUT_GET_ALARMCAPS;

// 获取布防模式 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ARMMODE
typedef struct tagNET_IN_GET_ALARMMODE
{
	DWORD			dwSize;				// 结构体大小
}NET_IN_GET_ALARMMODE;

// 布撤防信息
typedef struct tagNET_ARMMODE_INFO
{
	EM_ARM_STATE   emArmState;   	     // 布撤防状态
	BYTE           byReserved[1024];     // 保留字节
}NET_ARMMODE_INFO;

// 获取布防模式 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ARMMODE
typedef struct tagNET_OUT_GET_ALARMMODE
{
	DWORD			      dwSize;				                 // 结构体大小
	int                   nArmModeRet;                           // 布撤防状态个数
	NET_ARMMODE_INFO      stuArmMode[MAX_AREA_NUMBER];           // 布撤防信息
}NET_OUT_GET_ALARMMODE;

// 布撤防类型
typedef enum tagEM_ARM_TYPE
{
	EM_ARM_TYPE_UNKNOWN,           	   // 未知
	EM_ARM_TYPE_TOTAL_ARMING,          // Total布防
	EM_ARM_TYPE_PARTIAL1_ARMING,       // partial1布防
	EM_ARM_TYPE_PARTIAL2_ARMING,       // partial2布防
	EM_ARM_TYPE_DISARMING,             // 撤防
}EM_ARM_TYPE;

// 设置布防模式 输入参数。此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_ARMMODE
typedef struct tagNET_IN_SET_ALARMMODE
{
	DWORD			dwSize;				                // 结构体大小
	EM_ARM_TYPE     emArmType;                          // 布撤防类型
	char            szPwd[256];                         // 密码
	int             nAreaNum;                           // 区域的个数
	int             arrAreas[MAX_AREA_NUMBER];          // 区域号
}NET_IN_SET_ALARMMODE;

// 布防失败细节
typedef struct tagARM_FAILED_DETAIL
{
	int       nArea;                                      //布防失败的区域号
	int       nAlarmSourceRet;                            // 报警源输入返回个数
	int       arrAlarmSource[MAX_ZONE_NUMBER];            // 区域下包含的有源输入的防区
	BYTE      byReserved[1024];                           // 保留字节
}ARM_FAILED_DETAIL;

// 设置布防模式 输出参数。此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_ARMMODE
typedef struct tagNET_OUT_SET_ALARMMODE
{
	DWORD			      dwSize;			                  // 结构体大小
	int                   nArmResult;                         // 布防结果 0:成功 1:失败
	int                   nFailedAreaRet;                     // 布防失败的区域个数
	ARM_FAILED_DETAIL     stuFailedDetail[MAX_AREA_NUMBER];   // 布防失败的细节
}NET_OUT_SET_ALARMMODE;

// 旁路模式类型
typedef enum tagEM_BYPASSMODE_TYPE
{
	EM_BYPASSMODE_TYPE_UNKNOWN,          // 未知
	EM_BYPASSMODE_TYPE_OFF,              // 不使用
	EM_BYPASSMODE_TYPE_ACTIVE,           // 正常
	EM_BYPASSMODE_TYPE_BYPASSED,         // 旁路
	EM_BYPASSMODE_TYPE_ISOLATED,         // 隔离
	EM_BYPASSMODE_TYPE_TEST,             // 测试
}EM_BYPASSMODE_TYPE;

// 设置旁路状态 输入参数。此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_BYPASSMODE
typedef struct tagNET_IN_SET_BYPASSMODE
{
	DWORD			          dwSize;				      // 结构体大小
	char                      szPwd[256];                 // 密码
	EM_BYPASSMODE_TYPE        emType;                     // 旁路模式
	int                       nZoneNum;                   // 防区个数
	int                       arrZones[MAX_ZONE_NUMBER];  // 防区号
}NET_IN_SET_BYPASSMODE;

// 设置旁路状态 输出参数，此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_BYPASSMODE
typedef struct tagNET_OUT_SET_BYPASSMODE
{
	DWORD			      dwSize;			                  // 结构体大小
}NET_OUT_SET_BYPASSMODE;

// 获取旁路状态 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_BYPASSMODE
typedef struct tagNET_IN_GET_BYPASSMODE
{
	DWORD			          dwSize;				      // 结构体大小
	int                       nZoneNum;                   // 防区个数
	int                       arrZones[MAX_ZONE_NUMBER];  // 防区号	
}NET_IN_GET_BYPASSMODE;

// 获取旁路状态 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_BYPASSMODE
typedef struct tagNET_OUT_GET_BYPASSMODE
{
	DWORD			      			dwSize;			                 // 结构体大小
	int                   			nZoneRet;                        // 防区个数	
	EM_BYPASSMODE_TYPE        		arrModes[MAX_ZONE_NUMBER];       // 防区工作模式
}NET_OUT_GET_BYPASSMODE;

// 获取区域防区信息 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_AREAZONES
typedef struct tagNET_IN_GET_AREAZONES
{
	DWORD			          dwSize;				      // 结构体大小
	int                       nAreaNum;                   // 区域个数
	int                       arrArea[MAX_AREA_NUMBER];   // 区域号
}NET_IN_GET_AREAZONES;

// 区域信息
typedef struct tagNET_AREA_INFO
{
	int      		nArea;       //区域号
	int             nZoneRet;    // 区域下的防区个数
	int             arrZones[MAX_ZONE_NUMBER]; //区域下的防区号
	BYTE            byReserved[1024];		   // 保留字段
}NET_AREA_INFO;

// 获取区域防区信息 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_AREAZONES
typedef struct tagNET_OUT_GET_AREAZONES
{
	DWORD			      			dwSize;			               // 结构体大小
	int                             nAreaRet;                      // 区域个数
	NET_AREA_INFO                   stuAreaInfo[MAX_AREA_NUMBER];  // 区域信息
}NET_OUT_GET_AREAZONES;

// 获取所有报警防区 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS
typedef struct tagNET_IN_GET_ALLINSLOTS
{
	DWORD			          dwSize;				      // 结构体大小
}NET_IN_GET_ALLINSLOTS;

// 获取所有报警防区 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS
typedef struct tagNET_OUT_GET_ALLINSLOTS
{
	DWORD			      			dwSize;			               // 结构体大小
	int                             nLocol;                        // 本地防区数量
	int                             nWired;                        // 有线防区数量
	int                             nWireless;                     // 无线防区数量
}NET_OUT_GET_ALLINSLOTS;

// 获取所有报警输出 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS
typedef struct tagNET_IN_GET_ALLOUTSLOTS
{
	DWORD			          dwSize;				      // 结构体大小
}NET_IN_GET_ALLOUTSLOTS;

// 获取所有报警输出 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS
typedef struct tagNET_OUT_GET_ALLOUTSLOTS
{
	DWORD			      			dwSize;			               // 结构体大小
	int                             nLocol;                        // 本地报警输出数量
	int                             nWired;                        // 扩展有线报警输出数量
}NET_OUT_GET_ALLOUTSLOTS;


// 获取防区练连接状态 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS
typedef struct tagNET_IN_GET_CONNECTIONSTATUS
{
	DWORD			          dwSize;				      // 结构体大小
}NET_IN_GET_CONNECTIONSTATUS;

// 获取防区连接状态 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS
typedef struct tagNET_OUT_GET_CONNECTIONSTATUS
{
	DWORD			      			dwSize;			               // 结构体大小
	int                             nZoneRet;                      // 防区个数
	bool                            arrZoneStates[MAX_ZONE_NUMBER];// 防区在线状态false:离线 true:在线
}NET_OUT_GET_CONNECTIONSTATUS;

// 获取异常防区类型
typedef enum tagEM_GET_AREASSTATUS_TYPE
{
	EM_GET_AREASSTATUS_TYPE_UNKNOWN,     // 未知
	EM_GET_AREASSTATUS_TYPE_ACTIVE,      // 激活
	EM_GET_AREASSTATUS_TYPE_OPEN,        // 打开
}EM_GET_AREASSTATUS_TYPE;

// 获取区域状态 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_AREASTATUS
typedef struct tagNET_IN_GET_AREAS_STATUS
{
	DWORD			            dwSize;				      // 结构体大小
	EM_GET_AREASSTATUS_TYPE     emType;                   // 获取异常防区类型
}NET_IN_GET_AREAS_STATUS;

//防区异常状态
typedef enum tagEM_ZONE_STATUS
{
	EM_ZONE_STATUS_UNKNOWN, 	// 未知
	EM_ZONE_STATUS_ALARM,       // 通道打开
	EM_ZONE_STATUS_TAMPER,      // 通道防拆
	EM_ZONE_STATUS_MASK,        // 通道遮挡
	EM_ZONE_STATUS_SHORT, 		// 通道防短
}EM_ZONE_STATUS; 

//防区异常信息
typedef struct tagNET_ZONE_STATUS
{
	int              nIndex;               // 防区号
	EM_ZONE_STATUS	 emStatus;             // 防区异常状态
	BYTE             byReserved[1024];     // 保留字节
}NET_ZONE_STATUS;

//区域异常防区信息
typedef struct tagNET_AREA_STATUS
{
	int               nArea;                                  // 区域号
	int               nZoneRet;                               // 防区个数
	NET_ZONE_STATUS   stuZoneStatus[MAX_ZONE_NUMBER];         // 防区异常状态
	BYTE              byReserved[1024];                       // 保留字节
}NET_AREA_STATUS;

// 获取区域状态 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_AREASTATUS
typedef struct tagNET_OUT_GET_AREAS_STATUS
{
	DWORD			      dwSize;			   // 结构体大小
	int                   nAreaRet;            // 区域个数
	NET_AREA_STATUS       stuAreaStatus[MAX_AREA_NUMBER]; //区域防区异常状态信息   
}NET_OUT_GET_AREAS_STATUS;

// 输出通道类型
typedef enum tagEM_OUTPUT_TYPE
{
	EM_OUTPUT_TYPE_UNKNOWN,      // 未知
	EM_OUTPUT_TYPE_SIREN,        // 警号
	EM_OUTPUT_TYPE_ALARMOUT,     // 输出通道
}EM_OUTPUT_TYPE;

// 获取输出状态 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE
typedef struct tagNET_IN_GET_OUTPUT_STATE
{
	DWORD			          dwSize;				      // 结构体大小
	EM_OUTPUT_TYPE            emType;                     // 通道类型
}NET_IN_GET_OUTPUT_STATE;

// 获取输出状态 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE
typedef struct tagNET_OUT_GET_OUTPUT_STATE
{
	DWORD			      			dwSize;			               // 结构体大小
	int                             nStateRet;                     // 状态个数
	bool                            arrStates[MAX_ZONE_NUMBER];    // 状态false:关闭true打开
}NET_OUT_GET_OUTPUT_STATE;

// 设置输出状态 输入参数。此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE
typedef struct tagNET_IN_SET_OUTPUT_STATE
{
	DWORD			          		dwSize;				           // 结构体大小
	EM_OUTPUT_TYPE					emType; 					   // 输出类型
	int 							nChannel;					   /* emType= EM_OUTPUT_TYPE_SIREN时表示警号号
	emType= EM_OUTPUT_TYPE_ALARMOUT时表示通道号*/
	bool							action; 					   // 输出动作false:关闭true:打开
	BYTE							byReserved[3];				   // 字节对齐
}NET_IN_SET_OUTPUT_STATE;

//设置输出状态输出参数。此时CLIENT_SetAlarmRegionInfo的emType参数为NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE
typedef struct tagNET_OUT_SET_OUTPUT_STATE
{
	DWORD			      			dwSize;			               // 结构体大小
}NET_OUT_SET_OUTPUT_STATE;

// 获取防区故障 输入参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE
typedef struct tagNET_IN_GET_ZONES_TROUBLE
{
	DWORD			          		dwSize;				      // 结构体大小
}NET_IN_GET_ZONES_TROUBLE;

//防区故障类型
typedef enum tagEM_ZONE_TROUBLE_TYPE
{
	EM_ZONE_TROUBLE_TYPE_UNKNOWN,  // 未知
	EM_ZONE_TROUBLE_TYPE_TAMPER,   // 通道防拆
	EM_ZONE_TROUBLE_TYPE_MASK,     // 通道遮挡
	EM_ZONE_TROUBLE_TYPE_SHORT,    // 通道防短
}EM_ZONE_TROUBLE_TYPE;

//防区故障信息
typedef struct tagNET_ZONE_TROUBLE_INFO
{
	int                    nIndex;           // 防区号
	EM_ZONE_TROUBLE_TYPE   emTroubleType;    // 故障类型
	BYTE                   byReserved[1024]; // 保留字节
}NET_ZONE_TROUBLE_INFO;

//获取防区故障 输出参数。此时CLIENT_GetAlarmRegionInfo的emType参数为NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE
typedef struct tagNET_OUT_GET_ZONES_TROUBLE
{
	DWORD			      			dwSize;			                  // 结构体大小
	int                             nZoneRet;                         //故障防区个数
	NET_ZONE_TROUBLE_INFO           stuTroubleInfo[MAX_ZONE_NUMBER];  //防区故障信息
}NET_OUT_GET_ZONES_TROUBLE;

//获取的操作类型
typedef enum tagNET_EM_GET_ALARMREGION_INFO
{ 
	NET_EM_GET_ALARMREGION_INFO_UNKNOWN,						//未知
	NET_EM_GET_ALARMREGION_INFO_ALARMCAPS,						//获取防区能力，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_ALARMCAPS， pstuOutParam类型为NET_OUT_GET_ALARMCAPS
	NET_EM_GET_ALARMREGION_INFO_ARMMODE,						//获取布防状态，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_ALARMMODE， pstuOutParam类型为NET_OUT_GET_ALARMMODE
	NET_EM_GET_ALARMREGION_INFO_BYPASSMODE,						//获取旁路状态，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_BYPASSMODE， pstuOutParam类型为NET_OUT_GET_BYPASSMODE
	NET_EM_GET_ALARMREGION_INFO_AREAZONES,						//获取区域防区，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_AREAZONES， pstuOutParam类型为NET_IN_GET_AREAZONES
	NET_EM_GET_ALARMREGION_INFO_ALLINSLOTS,						//获取所有的报警防区，	此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_ALLINSLOTS， pstuOutParam类型为NET_OUT_GET_ALLINSLOTS
	NET_EM_GET_ALARMREGION_INFO_ALLOUTSLOTS,					//获取所有的报警输出，	此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_ALLOUTSLOTS， pstuOutParam类型为NET_OUT_GET_ALLOUTSLOTS
	NET_EM_GET_ALARMREGION_INFO_ZONECONNECTIONSSTATUS,			//获取防区连接状态，	此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_CONNECTIONSTATUS， pstuOutParam类型为NET_OUT_GET_CONNECTIONSTATUS
	NET_EM_GET_ALARMREGION_INFO_AREASTATUS,						//获取区域状态，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_AREAS_STATUS， pstuOutParam类型为NET_IN_OUT_AREAS_STATUS
	NET_EM_GET_ALARMREGION_INFO_OUTPUTSTATE,					//获取输出状态，		此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_OUTPUT_STATE， pstuOutParam类型为NET_OUT_GET_OUTPUT_STATE
	NET_EM_GET_ALARMREGION_INFO_ZONESTROUBLE,					//获取防区故障信息，	此时CLIENT_GetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_GET_ZONES_TROUBLE， pstuOutParam类型为NET_OUT_GET_ZONES_TROUBLE
}NET_EM_GET_ALARMREGION_INFO;

//西欧报警主机获取操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAlarmRegionInfo(LLONG lLoginID, NET_EM_GET_ALARMREGION_INFO emType, const void *pstuInParam, void *pstuOutParam, int nWaitTime);

//设置的操作类型
typedef enum tagNET_EM_SET_ALARMREGION_INFO
{
	NET_EM_SET_ALARMREGION_INFO_UNKNOWN,						//未知
	NET_EM_SET_ALARMREGION_INFO_ARMMODE,						//设置布防模式，	此时CLIENT_SetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_SET_ALARMMODE， pstuOutParam类型为NET_OUT_SET_ALARMMODE
	NET_EM_SET_ALARMREGION_INFO_BYPASSMODE,						//设置旁路模式，	此时CLIENT_SetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_SET_BYPASSMODE， pstuOutParam类型为NET_OUT_SET_BYPASSMODE
	NET_EM_SET_ALARMREGION_INFO_OUTPUTSTATE,					//设置输出状态，	此时CLIENT_SetAlarmRegionInfo接口中的pstuInParam类型为NET_IN_SET_OUTPUT_STATE， pstuOutParam类型为NET_OUT_SET_OUTPUT_STATE
}NET_EM_SET_ALARMREGION_INFO;

//西欧报警主机设置操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAlarmRegionInfo(LLONG lLoginID, NET_EM_SET_ALARMREGION_INFO emType, const void *pstuInParam, void *pstuOutParam, int nWaitTime);
/****************************** end 西欧报警主机接口 与老报警主机不兼容***************************************/

// 设备通知类型
typedef enum tagEM_DEVICE_NOTIFY_TYPE
{
	EM_DEVICE_NOTIFY_TYPE_UNKNOWN,							// 未知
	EM_DEVICE_NOTIFY_TYPE_NEW,								// 新设备添加
	EM_DEVICE_NOTIFY_TYPE_UPDATE,							// 设备信息更新
	EM_DEVICE_NOTIFY_TYPE_REMOVE,							// 设备删除
	EM_DEVICE_NOTIFY_TYPE_CONNECT,							// 设备有通道上下线
} EM_DEVICE_NOTIFY_TYPE;

// 向设备注册的回调返回信息
typedef struct tagNET_CB_ATTACH_DEVICE_STATE
{
	EM_DEVICE_NOTIFY_TYPE   		emNotifyType;    									// 通知类型
	int 							nRetCount;											// 设备个数
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];	// 设备列表
	BYTE 							byReserved[512];    								// 保留字节
}NET_CB_ATTACH_DEVICE_STATE;

// 向设备注册的回调函数原型
typedef void (CALLBACK *fDeviceStateCallBack)(LLONG lAttachHandle, NET_CB_ATTACH_DEVICE_STATE* pstDeviceState, LDWORD dwUser);

// CLIENT_AttachDeviceState 接口输入参数
typedef struct tagNET_IN_ATTACH_DEVICE_STATE
{
	DWORD                           dwSize;
	fDeviceStateCallBack         	cbDeviceState; 		//回调函数
	LDWORD                          dwUser;             //用户数据
}NET_IN_ATTACH_DEVICE_STATE;

// CLIENT_AttachDeviceState 接口输出参数
typedef struct  tagNET_OUT_ATTACH_DEVICE_STATE
{
	DWORD           dwSize;
}NET_OUT_ATTACH_DEVICE_STATE;


// CLIENT_AsyncAddDevice 接口输入参数
typedef struct tagNET_IN_ASYNC_ADD_DEVICE
{
	DWORD                           dwSize;
	int								nCount;													//URL个数
	char         					szUrls[MAX_ADD_DEVICE_NUM][MAX_COMMON_STRING_512]; 		//URL格式：协议名://用户名:密码@IP:端口 端口不填则用协议默认端口
}NET_IN_ASYNC_ADD_DEVICE;

// CLIENT_AsyncAddDevice 接口输出参数
typedef struct  tagNET_OUT_ASYNC_ADD_DEVICE
{
	DWORD           				dwSize;
	UINT							nTaskID;		//任务ID
}NET_OUT_ASYNC_ADD_DEVICE;

// 设备的添加状态
typedef enum tagEM_DEVICE_ADD_STATE
{
	EM_DEVICE_ADD_STATE_UNKNOWN,							// 未知
	EM_DEVICE_ADD_STATE_WAIT,								// 等待添加
	EM_DEVICE_ADD_STATE_CONNECT,							// 连接中
	EM_DEVICE_ADD_STATE_FAILURE,							// 添加失败
	EM_DEVICE_ADD_STATE_SUCCESS,							// 添加成功
	EM_DEVICE_ADD_STATE_STOP,								// 停止添加
} EM_DEVICE_ADD_STATE;

// 注册添加设备的回调返回信息
typedef struct tagNET_CB_ATTACH_ADD_DEVICE
{
	UINT                	nTaskID;       				// 任务ID
	EM_DEVICE_ADD_STATE		emAddState;					// 添加设备结果
	UINT					nIndex;						// 任务中设备序号(从0开始)
	BYTE 					byReserved[512];            // 保留字节
}NET_CB_ATTACH_ADD_DEVICE;

// 注册添加设备的回调函数原型
typedef void (CALLBACK *fAddDeviceCallBack)(LLONG lAttachHandle, NET_CB_ATTACH_ADD_DEVICE* pstAddDevice, LDWORD dwUser);

// CLIENT_AttachAddDevice 接口输入参数
typedef struct tagNET_IN_ATTACH_ADD_DEVICE
{
	DWORD                           dwSize;
	fAddDeviceCallBack         		cbAddDevice; 		//回调函数
	LDWORD                          dwUser;             //用户数据
}NET_IN_ATTACH_ADD_DEVICE;

// CLIENT_AttachAddDevice 接口输出参数
typedef struct  tagNET_OUT_ATTACH_ADD_DEVICE
{
	DWORD           dwSize;
}NET_OUT_ATTACH_ADD_DEVICE;

// CLIENT_GetAddDeviceInfo 接口输入参数
typedef struct tagNET_IN_GET_ADD_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	UINT 							nTaskID;						// 任务ID
	int								nCount;							// 设备个数
	UINT							nIndex[MAX_ADD_DEVICE_NUM];		// 设备序号列表(NET_IN_ADD_DEVICE中szUrls的序号，从0开始)
}NET_IN_GET_ADD_DEVICE_LIST_INFO;

// 添加中设备的结果信息
typedef struct tagNET_GET_ADD_DEVICE_INFO
{
	char                	szDeviceID[DH_DEV_ID_LEN_EX];       // 设备ID
	char                	szUrl[DH_COMMON_STRING_512];        // url
	EM_DEVICE_ADD_STATE		emAddState;							// 当前添加状态
	UINT					nErrorCode;							// 错误码
	BYTE 					byReserved[512];                    // 保留字节
}NET_GET_ADD_DEVICE_INFO;

// CLIENT_GetAddDeviceInfo 接口输出参数
typedef struct tagNET_OUT_GET_ADD_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int 							nRetCount;								// 设备个数
	NET_GET_ADD_DEVICE_INFO			stuDeviceInfo[MAX_ADD_DEVICE_NUM];		// 设备信息列表
}NET_OUT_GET_ADD_DEVICE_LIST_INFO;

// CLIENT_GetDeviceInfo 接口输入参数
typedef struct tagNET_IN_GET_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int 							nCount;												// 设备个数
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];	// 设备信息列表
}NET_IN_GET_DEVICE_LIST_INFO;


// 已添加设备的结果信息
typedef struct tagNET_GET_DEVICE_INFO
{
	char                szDeviceID[DH_DEV_ID_LEN_EX];           		// 设备ID
	char                szUrl[DH_COMMON_STRING_512];           			// url
	char                szSerialNo[DH_COMMON_STRING_32];           		// 设备序列号
	char                szDeviceType[DH_COMMON_STRING_64];      		// 设备类型
	char                szDeviceClass[DH_DEV_CLASS_LEN];        		// 设备大类
	int					nMacCount;										// 设备mac个数	
	char                szMacs[MAX_MACADDR_NUM][DH_MACADDR_LEN];     	// 设备mac地址组
	char                szDevSoftVersion[DH_COMMON_STRING_128];       	// 设备软件版本号
	char                szDeviceName[DH_DEV_NAME_LEN];          		// 设备名称
	char                szDetail[DH_COMMON_STRING_512];          		// 设备详细信息
	UINT                nVideoInputCh;                          		// 视频输入通道数
	UINT               	nVideoOutputCh;                         		// 视频输出通道数
	UINT               	nAudioInputCh;                          		// 音频输入通道数
	UINT               	nAudioOutputCh;                         		// 音频输出通道数
	UINT               	nAlarmInputCh;                          		// 报警输入通道数
	UINT                nAlarmOutputCh;                         		// 报警输出通道数
	UINT				nErrorCode;										// 设备离线错误码
	UINT				nVtoDoors;										// 门禁设备可控制的门的总数
	BYTE				byOnline;										// 设备是否在线 0:离线 1：在线
	BYTE 				byReserved[511];                    			// 保留字节
}NET_GET_DEVICE_INFO;

// CLIENT_GetDeviceInfo 接口输出参数
typedef struct tagNET_OUT_GET_DEVICE_LIST_INFO
{
	DWORD                           dwSize;
	int								nMaxCount;								// 用户申请的设备个数
	int								nRetCount;								// 实际返回的设备个数
	NET_GET_DEVICE_INFO*			pstuDeviceInfo;							// 设备信息列表, 由用户申请和释放内存, 申请大小为sizeof(NET_GET_DEVICE_INFO)*nMaxCount
}NET_OUT_GET_DEVICE_LIST_INFO;


// CLIENT_SetConnectChannel 接口输入参数
typedef struct tagNET_IN_SET_CONNECT_CHANNEL
{
	DWORD               dwSize;
	char                szDeviceID[DH_DEV_ID_LEN_EX];    			// 设备ID
	int					nCount;										// 通道个数
	UINT            	nChannels[MAX_DEVICE_CHANNEL_NUM];          // 通道列表
}NET_IN_SET_CONNECT_CHANNEL;

// CLIENT_SetConnectChannel 接口输出参数
typedef struct tagNET_OUT_SET_CONNECT_CHANNEL
{
	DWORD                           dwSize;
}NET_OUT_SET_CONNECT_CHANNEL;

// CLIENT_GetChannelInfo 接口输入参数
typedef struct tagNET_IN_GET_CHANNEL_INFO
{
	DWORD               dwSize;
	char                szDeviceID[DH_DEV_ID_LEN_EX];    	// 设备ID
}NET_IN_GET_CHANNEL_INFO;

// 获取设备通道信息结果信息
typedef struct tagNET_GET_CHANNEL_INFO
{
	UINT                nRemoteChannel;           						// 远程通道号
	int                 nLogicChannel;           						// 分配的逻辑通道,-1表示未分配
	char                szName[DH_DEV_NAME_LEN];          				// 名称
	char                szDetail[DH_COMMON_STRING_512];          		// 设备详细信息
	char                szDeviceType[DH_COMMON_STRING_64];      		// 设备类型
	char                szDeviceClass[DH_DEV_CLASS_LEN];        		// 设备大类
	char                szIP[DH_MAX_IPADDR_LEN];          				// ip地址
	char                szMac[DH_MACADDR_LEN];     						// 设备mac地址
	char                szSerialNo[DH_DEV_SERIALNO_LEN];           		// 设备序列号
	char                szDevSoftVersion[DH_COMMON_STRING_128];       	// 设备软件版本号
	UINT                nVideoInputCh;                          		// 视频输入通道数
	UINT               	nVideoOutputCh;                         		// 视频输出通道数
	UINT               	nAudioInputCh;                          		// 音频输入通道数
	UINT               	nAudioOutputCh;                         		// 音频输出通道数
	UINT               	nAlarmInputCh;                          		// 报警输入通道数
	UINT                nAlarmOutputCh;                         		// 报警输出通道数
	BYTE				byOnline;										// 通道是否在线0:离线 1：在线
	BYTE				byUsed;											// 该通道是否被本地设备使用 0：未使用 1：使用
	BYTE 				byReserved[510];                    			// 保留字节
}NET_GET_CHANNEL_INFO;

// CLIENT_GetChannelInfo 接口输出参数
typedef struct tagNET_OUT_GET_CHANNEL_INFO
{
	DWORD                           dwSize;
	int								nMaxCount;									// 用户申请的通道个数
	int								nRetCount;									// 实际返回的通道个数
	NET_GET_CHANNEL_INFO*			pstuChannelInfo;							// 通道信息列表, 由用户申请和释放内存, 申请大小为sizeof(NET_GET_CHANNEL_INFO)*nMaxCount
}NET_OUT_GET_CHANNEL_INFO;

// CLIENT_RemoveDevice 接口输入参数
typedef struct tagNET_IN_REMOVE_DEVICE
{
	DWORD                           dwSize;
	int 							nCount;													// 设备个数
	char							szDeviceIDs[MAX_LINK_DEVICE_NUM][DH_DEV_ID_LEN_EX];		// 设备信息列表
}NET_IN_REMOVE_DEVICE;

// CLIENT_RemoveDevice 接口输出参数
typedef struct  tagNET_OUT_REMOVE_DEVICE
{
	DWORD           dwSize;
}NET_OUT_REMOVE_DEVICE;

// CLIENT_CancelAddDeviceTask 接口输入参数
typedef struct tagNET_IN_CANCEL_ADD_TASK
{
	DWORD                           dwSize;
	UINT 							nTaskID;		 // 任务ID
}NET_IN_CANCEL_ADD_TASK;

// CLIENT_CancelAddDeviceTask 接口输出参数
typedef struct  tagNET_OUT_CANCEL_ADD_TASK
{
	DWORD           dwSize;
}NET_OUT_CANCEL_ADD_TASK;

// CLIENT_ConfirmAddDeviceTask 接口输入参数
typedef struct tagNET_IN_CONFIRM_ADD_TASK
{
	DWORD                           dwSize;
	UINT 							nTaskID;		 // 任务ID
}NET_IN_CONFIRM_ADD_TASK;

// CLIENT_ConfirmAddDeviceTask 接口输出参数
typedef struct  tagNET_OUT_CONFIRM_ADD_TASK
{
	DWORD           dwSize;
}NET_OUT_CONFIRM_ADD_TASK;

// CLIENT_GetNMPDevInfo 接口输入参数
typedef struct tagNET_IN_GET_NMPDEV_INFO
{
	DWORD			dwSize;			// 结构体大小
}NET_IN_GET_NMPDEV_INFO;

// 交换机下挂的设备信息
typedef struct tagNET_NEM_CONNECT_DEVICE_INFO
{
	char		szAddress[40];				// 设备地址或者域名
	char		szProtocolType[32];			// 连接设备的协议类型
	char		szDeviceType[64];			// 设备型号
	char		szMac[18];					// 设备mac地址，冒号+大写
	char		szName[64];					// 设备名称
	char		szVendor[32];				// 设备厂商
	BYTE		byReserved[126];			// 保留字节
}NET_NEM_CONNECT_DEVICE_INFO;

// 邻居设备数组
typedef struct tagNET_NEIGHBORS_INFO
{
	char						szRemotePortId[64];				// 邻居设备连接端口描述
	char						szRemoteDevice[128];			// 邻居设备的唯一值
	NET_NEM_CONNECT_DEVICE_INFO	stuDeviceInfo;					// 设备信息
	BYTE						byReserved[128];				// 保留字节
}NET_NEIGHBORS_INFO;

// 设备状态
typedef enum tagEM_DEV_STATUS
{
	EM_DEV_STATUS_UNKNOWN = -1,					// 未知
	EM_DEV_STATUS_OFFLINE,						// 离线
	EM_DEV_STATUS_ONLINE,						// 在线
}EM_DEV_STATUS;

// 端口连接状态
typedef enum tagEM_PORT_STATUS
{
	EM_PORT_STATUS_UNKNOWN = -1,				// 未知
	EM_PORT_STATUS_DOWN,						// 未连接
	EM_PORT_STATUS_UP,							// 连接
}EM_PORT_STATUS;

// 端口传输介质
typedef	enum tagEM_MEDIA_TYPE
{
	EM_MEDIA_TYPE_UNKNOWN,						// 未知
	EM_MEDIA_TYPE_COPPER,						// 电口
	EM_MEDIA_TYPE_FIBER,						// 光口
}EM_MEDIA_TYPE;

// 端口双工状态
typedef enum tagEM_DUPLEX_MODE
{
	EM_DUPLEX_MODE_UNKNOWN,						// 未知
	EM_DUPLEX_MODE_HALFDUPLEX,					// 半双工
	EM_DUPLEX_MODE_FULLDUPLEX,					// 全双工
}EM_DUPLEX_MODE;

// PoE状态
typedef enum tagEM_POE_STATUS
{
	EM_POE_STATUS_UNKNOWN = -1,					// 未知
	EM_POE_STATUS_NONENABLE,					// 非使能状态
	EM_POE_STATUS_ENABLE,						// 使能状态
	EM_POE_STATUS_UNSUPPORTED,					// 不支持
}EM_POE_STATUS;

// 端口流量状态
typedef enum tagEM_FLOW_STATUS
{
	EM_FLOW_STATUS_UNKNOWN = -1,				// 未知
	EM_FLOW_STATUS_NORMAL,						// 正常
	EM_FLOW_STATUS_ABNORMAL,					// 异常
}EM_FLOW_STATUS;

// 设备端口信息
typedef struct tagNET_NMPDEVPORT_INFO
{
	DWORD			dwLocalPortId;				// 设备连接端口号
	EM_POE_STATUS	emPoEStatus;				// PoE状态
	char			szLocalPortDescr[64];		// 设备连接端口描述
	int				nChassisId;					// 端口所在框ID
	int				nSlotId;					// 端口所在槽ID
	char			szAliasName[64];			// 设备端口别名
	DWORD			dwAggregationId;			// 聚合ID（0表示不属于聚合）
	DWORD			dwSpeed;					// 端口协商速率，单位：mbps
	EM_PORT_STATUS	emStatus;					// 端口连接状态
	EM_MEDIA_TYPE	emMedia;					// 端口传输介质
	EM_DUPLEX_MODE	emDuplexMode;				// 端口双工状态
	float			fPoEPower;					// PoE功耗
	TP_U64			dwInUcastPkts;				// 单播接收报文数
	TP_U64			dwOutUcastPkts;				// 单播发送报文数
	TP_U64			dwInBroadcastPkts;			// 广播接收报文数
	TP_U64			dwOutBroadcastPkts;			// 广播发送报文数
	TP_U64			dwInMulticastPkts;			// 组播接收报文数
	TP_U64			dwOutMulticastPkts;			// 组播发送报文数
	TP_U64			dwInDiscardPkts;			// 接收丢包数
	TP_U64			dwOutDiscardPkts;			// 发送丢包数
	INT64			nInPausePkts;				// 接收Pause帧总数（-1表示非法值）
	INT64			nOutPausePkts;				// 发送Pause帧总数（-1表示非法值）
	INT64			nInFilterPkts;				// 接收包过滤总包数（-1表示非法值）
	TP_U64			dwInOctets;					// 接收包字节总数
	TP_U64			dwOutOctets;				// 发送包字节总数
	TP_U64			dwInRate;					// 接收实时速率，单位：Byte
	TP_U64			dwOutRate;					// 发送实时速率，单位：Byte
	EM_FLOW_STATUS	emFlowStatus;				// 端口流量状态
	int				nRetNeighborsNum;			// 邻居设备数组个数
	NET_NEIGHBORS_INFO	stuNeighbors[255];		// 邻居设备数组
	BYTE			byReserved[1024];			// 保留字节
}NET_NMPDEVPORT_INFO;

// 设备信息
typedef struct tagNET_NMPDEV_INFO
{
	char			szAddress[40];				// 设备地址或者域名
	char			szDeviceClass[64];			// 设备类型
	char			szDeviceType[64];			// 设备型号
	char			szMac[18];					// 设备mac地址，冒号+大写
	BYTE			byReserved2[6];				// 字节对齐
	char			szProtocolType[32];			// 连接设备的协议类型
	char			szVersion[32];				// 设备版本号
	char			szSerialNo[64];				// 设备序列号
	char			szName[64];					// 设备名称
	DWORD			dwRetPortNum;				// 设备返回端口个数
	int				nPortListMaxNum;			// 用户分配端口信息个数
	NET_NMPDEVPORT_INFO	*pstuPorList;			// 端口信息组
	BOOL			bPoESupport;				// 是否支持Poe
	float			fPoETotalPower;				// PoE总功耗
	float			fPoERemainPower;			// PoE剩余功耗
	DWORD			dwUptime;					// 本次上电运行时间（单位：分钟）
	int				nCPUUsage;					// CPU使用率（百分比），-1为非法值
	EM_DEV_STATUS	emStatus;					// 设备状态
	char			szSubnetMask[40];			// 子网掩码
	char			szParent[128];				// 父亲设备的唯一值
	char			szVendor[32];				// 设备厂商
	DWORD			dwPortNumber;				// 设备总端口数
	BYTE			byReserved[1020];			// 保留字节
}NET_NMPDEV_INFO;

// CLIENT_GetNMPDevInfo 接口输出参数
typedef struct tagNET_OUT_GET_NMPDEV_INFO
{
	DWORD					dwSize;					// 结构体大小
	BYTE					byReserved[4];			// 字节对齐
	NET_NMPDEV_INFO         stuNMPDevInfo;			// 设备信息
}NET_OUT_GET_NMPDEV_INFO;

// 注册设备状态回调
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDeviceState(LLONG lLoginID, const NET_IN_ATTACH_DEVICE_STATE *pInParam, NET_OUT_ATTACH_DEVICE_STATE *pOutParam, int nWaitTime);

// 注销设备状态回调
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDeviceState(LLONG lAttachHandle);

// 异步添加设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AsyncAddDevice(LLONG lLoginID, const NET_IN_ASYNC_ADD_DEVICE *pInParam, NET_OUT_ASYNC_ADD_DEVICE *pOutParam, int nWaitTime);

// 注册添加设备回调
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAddDevice(LLONG lLoginID, const NET_IN_ATTACH_ADD_DEVICE *pInParam, NET_OUT_ATTACH_ADD_DEVICE *pOutParam, int nWaitTime);

// 注销添加设备回调
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAddDevice(LLONG lAttachHandle);

// 获取添加中的设备状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAddDeviceInfo(LLONG lLoginID, const NET_IN_GET_ADD_DEVICE_LIST_INFO *pInParam, NET_OUT_GET_ADD_DEVICE_LIST_INFO *pOutParam, int nWaitTime);

// 获取已添加的设备状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDeviceInfo(LLONG lLoginID, const NET_IN_GET_DEVICE_LIST_INFO *pInParam, NET_OUT_GET_DEVICE_LIST_INFO *pOutParam, int nWaitTime);

// 设置连接通道
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetConnectChannel(LLONG lLoginID, const NET_IN_SET_CONNECT_CHANNEL *pInParam, NET_OUT_SET_CONNECT_CHANNEL *pOutParam, int nWaitTime);

// 获取设备通道信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelInfo(LLONG lLoginID, const NET_IN_GET_CHANNEL_INFO *pInParam, NET_OUT_GET_CHANNEL_INFO *pOutParam, int nWaitTime);

// 删除设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveDevice(LLONG lLoginID, const NET_IN_REMOVE_DEVICE *pInParam, NET_OUT_REMOVE_DEVICE *pOutParam, int nWaitTime);

// 中止添加设备任务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CancelAddDeviceTask(LLONG lLoginID, const NET_IN_CANCEL_ADD_TASK *pInParam, NET_OUT_CANCEL_ADD_TASK *pOutParam, int nWaitTime);

// 确认添加设备任务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmAddDeviceTask(LLONG lLoginID, const NET_IN_CONFIRM_ADD_TASK *pInParam, NET_OUT_CONFIRM_ADD_TASK *pOutParam, int nWaitTime);

// 获取NMP设备信息
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_GetNMPDevInfo(LLONG lLoginID, const NET_IN_GET_NMPDEV_INFO *pInParam, NET_OUT_GET_NMPDEV_INFO *pOutParam, int nWaitTime);

#define MAX_BOARD_NUM 2												// 工作板最大个数

// 工作板状态
typedef enum tagNET_EM_BOARD_STATE
{
	NET_EM_BOARD_STATE_UNKNOWN = 0,									// 未知
	NET_EM_BOARD_STATE_MASTER,										// 主板
	NET_EM_BOARD_STATE_SLAVE										// 备板
}NET_EM_BOARD_STATE;

// 工作板信息
typedef struct tagNET_BOARD_STATE_INFO
{
	char				szTarget[DH_COMMON_STRING_64];				// 工作板名称
	NET_EM_BOARD_STATE  emState;									// 工作板当前状态
	int					nBoardSlot;									// 工作板卡槽序号
	BYTE				byReserved[1024];							// 保留字节
}NET_BOARD_STATE_INFO;

// CLIENT_GetDCSDoubleDevBoardState输入参数
typedef struct tagNET_IN_GET_BOARD_STATE
{
	DWORD		dwSize;												// 结构体大小
}NET_IN_GET_BOARD_STATE;

// CLIENT_GetDCSDoubleDevBoardState输出参数
typedef struct tagNET_OUT_GET_BOARD_STATE
{
	DWORD						dwSize;								// 结构体大小
	int							nBoardRet;							// 返回的工作板个数
	NET_BOARD_STATE_INFO		stuBoardStateList[MAX_BOARD_NUM];	// 工作板列表
}NET_OUT_GET_BOARD_STATE;

// 获取双控工作板的状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDCSDoubleDevBoardState(LLONG lLoginID, const NET_IN_GET_BOARD_STATE* pInParam, NET_OUT_GET_BOARD_STATE* pOutParam, int waittime);

//CLIENT_GetDiagnosisEncryptSystemInfo输入参数
typedef struct tagNET_IN_GET_ENCRYPT_SYSTEM_INFO
{
	DWORD					dwSize;
}NET_IN_GET_ENCRYPT_SYSTEM_INFO;

//CLIENT_GetDiagnosisEncryptSystemInfo输出参数
typedef struct tagNET_OUT_GET_ENCRYPT_SYSTEM_INFO
{
	DWORD					dwSize;
	char					szEncryptContent[MAX_ENCRYPT_SYSTEM_INFO_CONTENT_LEN];    // 系统信息内容(密文)
}NET_OUT_GET_ENCRYPT_SYSTEM_INFO;

// 用于故障分析,获取加密系统信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDiagnosisEncryptSystemInfo(LLONG lLoginID, const NET_IN_GET_ENCRYPT_SYSTEM_INFO* pInParam, NET_OUT_GET_ENCRYPT_SYSTEM_INFO* pOutParam, int nWaitTime);

// 设备日志最大个数
#define	MAX_LOG_LIST_COUNT	100

// 报警事件类型
typedef enum tagEM_QUERY_EVENT_LOG_TYPE
{
	EM_QUERY_EVENT_LOG_TYPE_UNKNOWN,								// 未知
	EM_QUERY_EVENT_LOG_TYPE_MOTION_DETECT,							// 动检报警事件
	EM_QUERY_EVENT_LOG_TYPE_INPUT_ALARM,							// 报警输入事件
	EM_QUERY_EVENT_LOG_TYPE_VIDEO_LOSS,								// 视频丢失事件
	EM_QUERY_EVENT_LOG_TYPE_NO_DISK,								// 无硬盘事件
	EM_QUERY_EVENT_LOG_TYPE_DISK_ERROR,								// 硬盘出错事件
	EM_QUERY_EVENT_LOG_TYPE_DISK_FULL,								// 硬盘满事件
	EM_QUERY_EVENT_LOG_TYPE_NET_ABORT,								// 网络中断事件
	EM_QUERY_EVENT_LOG_TYPE_IP_CONFLICT,							// IP冲突事件
	EM_QUERY_EVENT_LOG_TYPE_TEMPERATURE_ALARM,						// 温度报警事件
	EM_QUERY_EVENT_LOG_TYPE_POWER_FAULT,							// 电源故障事件
} EM_QUERY_EVENT_LOG_TYPE;

// 设备报警信息
typedef struct tagNET_LOG_LIST_INFO 
{
	EM_QUERY_EVENT_LOG_TYPE		emEventType;						// 报警事件
	int							nChannel;							// 事件发生的通道号, -1表示该报警与通道无关
	NET_TIME					stStartTime;						// 开始时间
	BYTE						byReserved[1024];					// 保留字节
} NET_LOG_LIST_INFO;

// CLIENT_QueryEventLog 输入参数
typedef struct tagNET_IN_QUERY_EVENT_LOG
{
	DWORD						dwSize;								// 结构体大小
	char						szUUID[MAX_COMMON_STRING_128];		// 手机ID
} NET_IN_QUERY_EVENT_LOG;

// CLIENT_QueryEventLog 输出参数
typedef struct tagNET_OUT_QUERY_EVENT_LOG
{
	DWORD						dwSize;								// 结构体大小
	int							nLogListCount;						// 日志个数
	NET_LOG_LIST_INFO			stLogList[MAX_LOG_LIST_COUNT];		// 日志列表
	char						szDeviceName[MAX_COMMON_STRING_64];	// 设备名称
	int							nQueryID;							// 查询ID
} NET_OUT_QUERY_EVENT_LOG;

// 获取设备报警日志(Bosch定制)(pInParam和pOutParam资源由用户申请和释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryEventLog(LLONG lLoginID, const NET_IN_QUERY_EVENT_LOG* pInParam, NET_OUT_QUERY_EVENT_LOG* pOutParam, int nWaitTime);

// CLIENT_ConfirmEventLog 输入参数
typedef struct tagNET_IN_CONFIRM_EVENT_LOG
{
	DWORD						dwSize;								// 结构体大小
	char						szUUID[MAX_COMMON_STRING_64];		// 手机ID
	int							nQueryID;							// 查询ID
} NET_IN_CONFIRM_EVENT_LOG;

// CLIENT_ConfirmEventLog 输出参数
typedef struct tagNET_OUT_CONFIRM_EVENT_LOG
{
	DWORD						dwSize;								// 结构体大小
} NET_OUT_CONFIRM_EVENT_LOG;

// 确认已经获取到设备报警日志(Bosch定制)(pInParam和pOutParam资源由用户申请和释放)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmEventLog(LLONG lLoginID, const NET_IN_CONFIRM_EVENT_LOG* pInParam, NET_OUT_CONFIRM_EVENT_LOG* pOutParam, int nWaitTime);

#define DH_MAX_DISKLISK_NUM 1024                                    // 磁盘号最大值

// CLIENT_GetStorageBoundTimeEx 入参
typedef struct tagNET_IN_GET_BOUND_TIMEEX
{
	DWORD						dwSize;								// 结构体大小
	int                         nDiskCount;                         // 磁盘数量
	int                         nDiskList[DH_MAX_DISKLISK_NUM];     // 磁盘号列表
}NET_IN_GET_BOUND_TIMEEX;

// 硬盘录像时间信息
typedef struct tagNET_BOUND_TIME_INFO
{
	UINT                        nDiskNO;				            // 磁盘号
	NET_TIME_EX                 stuStartTime;				        // 开始时间
	NET_TIME_EX                 stuEndTime;				            // 结束时间
	BYTE				        byReserved[1024];					// 保留字节
}NET_BOUND_TIME_INFO;

// CLIENT_GetStorageBoundTimeEx 出参
typedef struct tagNET_OUT_GET_BOUND_TIMEEX
{
	DWORD						dwSize;								// 结构体大小
	int                         nRetDiskCount;                      // 返回的磁盘数量
	NET_BOUND_TIME_INFO         stuBoundTime[DH_MAX_DISKLISK_NUM];  // 硬盘录像时间信息
}NET_OUT_GET_BOUND_TIMEEX;

// 获取录像时间范围
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetStorageBoundTimeEx(LLONG lLoginID, const NET_IN_GET_BOUND_TIMEEX* pInParam, NET_OUT_GET_BOUND_TIMEEX* pOutParam, int waittime);

// CLIENT_GetStoragePortInfo 入参
typedef struct tagNET_IN_GET_PORTINFO
{
	DWORD						dwSize;								// 结构体大小
}NET_IN_GET_PORTINFO;

// CLIENT_GetStoragePortInfo 出参
typedef struct tagNET_OUT_GET_PORTINFO
{
	DWORD						dwSize;								// 结构体大小
	UINT                        nTotal;                             // 总线的接口数目，包括扩展的总线
	UINT                        nPlug;                              // 已挂载的硬盘的数量, 不包括坏盘
	UINT                        nMask;                              // 指示各个总线通道上是否挂载硬盘，包括坏盘
	UINT                        nBadDisk;                           // 指示各个通道上是否挂载了坏的硬盘
	UINT                        nIDEDisk;                           // 已挂载的IDE硬盘数
	UINT                        nESATA;                             // eSATA的接口总数
	UINT                        nUSB2;                              // 工作在USB2.0模式下的USB设备个数
	UINT                        nUSB3;                              // 工作在USB3.0模式下的USB设备个数
}NET_OUT_GET_PORTINFO;

// 获取存储端口信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetStoragePortInfo(LLONG lLoginID, const NET_IN_GET_PORTINFO* pInParam, NET_OUT_GET_PORTINFO* pOutParam, int waittime);

// NAS文件操作最大数量
#define MAX_NASFILE_COUNT	1024

// NAS文件操作类型
typedef enum tagEM_NAS_FILE_OPERATE_TYPE
{
	EM_NAS_FILE_OPERATE_TYPE_COPY,					// 复制, 对应结构体pInParam = NET_IN_COPY_NAS_FILE,pOutParam = NET_OUT_COPY_NAS_FILE
	EM_NAS_FILE_OPERATE_TYPE_MOVE,					// 移动, 对应结构体pInParam = NET_IN_MOVE_NAS_FILE,pOutParam = NET_OUT_MOVE_NAS_FILE
	EM_NAS_FILE_OPERATE_TYPE_REMOVE,				// 删除, 对应结构体pInParam = NET_IN_REMOVE_NAS_FILE,pOutParam = NET_OUT_REMOVE_NAS_FILE
} EM_NAS_FILE_OPERATE_TYPE;

// NAS文件复制移动方式
typedef enum tagEM_NAS_FILE_OPTION 
{
	EM_NAS_FILE_OPTION_UNKNOWN,						// 未知
	EM_NAS_FILE_OPTION_U,							// 表示源目标比目标文件新或目标文件不存在才拷贝
	EM_NAS_FILE_OPTION_F,							// 表示直接使用源文件覆盖目标文件
} EM_NAS_FILE_OPTION;

// NAS文件复制输入参数
typedef struct tagNET_IN_COPY_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// 客户端分配任务ID
	int							nSrcNum;												// 源文件(夹)名数量
	char						szSrcList[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// 源文件(夹)名列表
	char						szDstPath[MAX_COMMON_STRING_128];						// 目的路径
	EM_NAS_FILE_OPTION			emOption;												// 拷贝选项
} NET_IN_COPY_NAS_FILE ;

// NAS文件复制输出参数
typedef struct tagNET_OUT_COPY_NAS_FILE
{
	DWORD						dwSize;
} NET_OUT_COPY_NAS_FILE;

// NAS文件移动输入参数
typedef struct tagNET_IN_MOVE_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// 客户端分配任务ID
	int							nSrcNum;												// 源文件(夹)名数量
	char						szSrcList[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// 源文件(夹)名列表
	char						szDstPath[MAX_COMMON_STRING_128];						// 目的路径
	EM_NAS_FILE_OPTION			emOption;												// 移动选项
} NET_IN_MOVE_NAS_FILE;

// NAS文件移动输出参数
typedef struct tagNET_OUT_MOVE_NAS_FILE 
{
	DWORD						dwSize;
} NET_OUT_MOVE_NAS_FILE;

// NAS文件删除输入参数
typedef struct tagNET_IN_REMOVE_NAS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];							// 任务ID
	int							nFileNum;												// 删除文件数量
	char						szFileName[MAX_NASFILE_COUNT][MAX_COMMON_STRING_128];	// 源删除文件列表
} NET_IN_REMOVE_NAS_FILE;

// NAS文件删除输出参数
typedef struct tagNET_OUT_REMOVE_NAS_FILE 
{
	DWORD						dwSize;
} NET_OUT_REMOVE_NAS_FILE;

// NAS文件操作接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateNASFile(LLONG lLoginID, EM_NAS_FILE_OPERATE_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);

// 文件压缩最大个数
#define MAX_FILE_COMPRESS_COUNT	8

// 文件压缩格式
typedef enum tagEM_COMPRESS_TYPE
{
	EM_COMPRESS_TYPE_UNKNWON,						// 未知
	EM_COMPRESS_TYPE_ZIP,							// zip格式
} EM_COMPRESS_TYPE;

// 压缩文件操作输入参数
typedef struct tagNET_IN_COMPRESS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];			// 任务ID
	int							nSrcNum;								// 源文件(夹)名数量
	char						szSrcFileList[MAX_FILE_COMPRESS_COUNT][MAX_COMMON_STRING_128];	// 源文件(夹)名列表
	char						szDstFile[MAX_COMMON_STRING_128];		// 目的文件
	char						szPassword[MAX_COMMON_STRING_64];		// 密码
	EM_COMPRESS_TYPE			emCompressType;							// 压缩格式
} NET_IN_COMPRESS_FILE;

// 压缩文件操作输出参数
typedef struct tagNET_OUT_COMPRESS_FILE 
{
	DWORD						dwSize;
} NET_OUT_COMPRESS_FILE;

// 压缩文件操作输入参数
typedef struct tagNET_IN_DECOMPRESS_FILE 
{
	DWORD						dwSize;
	char						szID[MAX_COMMON_STRING_128];			// 任务ID
	char						szSrcFile[MAX_COMMON_STRING_128];		// 源文件名
	char						szDstPath[MAX_COMMON_STRING_128];		// 解压到指定目录
	char						szPassword[MAX_COMMON_STRING_64];		// 密码
} NET_IN_DECOMPRESS_FILE;

// 压缩文件操作输出参数
typedef struct tagNET_OUT_DECOMPRESS_FILE 
{
	DWORD						dwSize;
} NET_OUT_DECOMPRESS_FILE;

// 文件压缩解压操作接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateFileCompress(LLONG lLoginID, EM_FILE_COMPRESS_TYPE emOperateType, void *pInParam, void *pOutParam, int nWaitTime);


///////////////////////////////////////////分组流量统计//////////////////////////////////////////////////////////////////
#define MAX_GROUP_CHANNEL_NUM 1024		// 一个组最大关联的通道个数
#define MAX_GROUPID_LEN 64				// 组ID的最大字符长度
#define MAX_GROUPNAME_LEN 128			// 组名称的最大字符长度

//统计小计信息
typedef struct tagNET_NUMBERSTATGROUP_SUBTOTAL
{
	int                 nTotal;                         // 设备运行后人数统计总数
	int                 nHour;                          // 小时内的总人数
	int                 nToday;                         // 当天的总人数, 不可手动清除
	int                 nTotalInTimeSection;			// IPC专用，如果不执行clearSectionStat操作，等同于Today人数
	BYTE				byReserved[252];
} NET_NUMBERSTATGROUP_SUBTOTAL;

// 分组客流统计数据
typedef struct tagNET_NUMBERSTATGROUP_SUMMARY
{
	char							szGroupID[MAX_GROUPID_LEN];					// 组ID
	char							szGroupName[MAX_GROUPNAME_LEN];				// 组名
	int								nChannelNum;								// 通道号数
	int								arChannelList[MAX_GROUP_CHANNEL_NUM];		// 通道号列表
	NET_TIME_EX						stuUTC;										// 统计时间秒数，已包含时区偏移
	int								nTimeZone;									// 时区索引号
	NET_NUMBERSTATGROUP_SUBTOTAL	stuEnteredSubtotal;							// 进入小计
	NET_NUMBERSTATGROUP_SUBTOTAL	stuExitedSubtotal;							// 出去小计
	int								nInsideSubtotal;							// 区域内人数
	BYTE							byReserved[1024];							// 保留
} NET_NUMBERSTATGROUP_SUMMARY;

// 分组客流统计数据回调函数原形，lAttachHandle 是 CLIENT_AttachNumberStatGroupSummary 返回值
typedef void (CALLBACK *fNumberStatGroupSumCallBack) (LLONG lAttachHandle, NET_NUMBERSTATGROUP_SUMMARY* pBuf, DWORD dwBufLen, LDWORD dwUser);

// 订阅分组客流量统计数据--输入参数
typedef struct tagNET_IN_ATTACH_NUMBERSTATGROUP_SUM
{
	DWORD						dwSize;								// 结构体大小
	fNumberStatGroupSumCallBack cbNumberStatGroupSum;				// 分组客流量统计数据回调
	LDWORD						dwUser;								// 用户数据   
}NET_IN_ATTACH_NUMBERSTATGROUP_SUM;

// 订阅分组客流量统计数据--输出参数
typedef struct tagNET_OUT_ATTACH_NUMBERSTATGROUP_SUM
{
	DWORD						dwSize;								// 结构体大小
}NET_OUT_ATTACH_NUMBERSTATGROUP_SUM;

// 订阅分组客流量统计数据
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNumberStatGroupSummary(LLONG lLoginID, const NET_IN_ATTACH_NUMBERSTATGROUP_SUM* pInParam, NET_OUT_ATTACH_NUMBERSTATGROUP_SUM* pOutParam, int waittime);

// 取消订阅分组客流量统计数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNumberStatGroupSummary(LLONG lAttachHandle);

// 分组人员统计--添加组 输入参数
typedef struct tagNET_IN_ADD_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// 结构体大小
	char						szGroupName[MAX_GROUPNAME_LEN];		// 组名
	int							nChannelNum;						// 通道数
	int							arChannelList[MAX_GROUP_CHANNEL_NUM];	// 通道列表
}NET_IN_ADD_NUMBERSTATGROUP_INFO;

// 分组人员统计--添加组 输出参数
typedef struct tagNET_OUT_ADD_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// 结构体大小
	char						szGroupID[MAX_GROUPID_LEN];			// GroupID
}NET_OUT_ADD_NUMBERSTATGROUP_INFO;

// 分组人员统计--添加组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddNumberStatGroup(LLONG lLoginID, const NET_IN_ADD_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_ADD_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// 分组人员统计--删除组 输入参数
typedef struct tagNET_IN_DEL_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// 结构体大小
	char						szGroupID[MAX_GROUPID_LEN];			// GroupID
}NET_IN_DEL_NUMBERSTATGROUP_INFO;

// 分组人员统计--删除组 输入参数
typedef struct tagNET_OUT_DEL_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;								// 结构体大小
}NET_OUT_DEL_NUMBERSTATGROUP_INFO;

// 分组人员统计--删除组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelNumberStatGroup(LLONG lLoginID, const NET_IN_DEL_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_DEL_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// 组信息
typedef struct tagNET_NUMBERSTATGROUP_INFO
{
	char						szGroupID[MAX_GROUPID_LEN];				// GroupID
	char						szGroupName[MAX_GROUPNAME_LEN];			// 组名称
	int							nChannelNum;							// 通道个数
	int							arChannelList[MAX_GROUP_CHANNEL_NUM];	// 通道号列表
	BYTE						byReserved[512];						// 保留
}NET_NUMBERSTATGROUP_INFO;

// 分组人员统计--修改组 输入参数
typedef struct tagNET_IN_MODIFY_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;									// 结构体大小
	NET_NUMBERSTATGROUP_INFO	stuGroupInfo;
}NET_IN_MODIFY_NUMBERSTATGROUP_INFO;

// 分组人员统计--修改组 输出参数
typedef struct tagNET_OUT_MODIFY_NUMBERSTATGROUP_INFO
{
	DWORD						dwSize;									// 结构体大小
}NET_OUT_MODIFY_NUMBERSTATGROUP_INFO;

// 分组人员统计--修改组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyNumberStatGroup(LLONG lLoginID, const NET_IN_MODIFY_NUMBERSTATGROUP_INFO* pInParam, NET_OUT_MODIFY_NUMBERSTATGROUP_INFO* pOutParam, int waittime);

// 分组人员统计--获取组 输入参数
typedef struct tagNET_IN_NUMBERSTATGROUPS_INFO
{
	DWORD						dwSize;									// 结构体大小
	char						szGroupID[MAX_GROUPID_LEN];				// GroupID
}NET_IN_NUMBERSTATGROUPS_INFO;

// 分组人员统计--获取组 输出参数
typedef struct tagNET_OUT_NUMBERSTATGROUPS_INFO
{
	DWORD						dwSize;									// 结构体大小
	int							nGroupsRetNum;							// 返回的组个数
	int							nGroupsMaxNum;							// 用户分配的数组个数
	NET_NUMBERSTATGROUP_INFO*	pstuGroupList;							// 组列表, 由用户分配，大小为sizeof(NET_NUMBERSTATGROUP_INFO) * nGroupsMaxNum
}NET_OUT_NUMBERSTATGROUPS_INFO;

// 分组人员统计--获取组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNumberStatGroups(LLONG lLoginID, const NET_IN_NUMBERSTATGROUPS_INFO* pInParam, NET_OUT_NUMBERSTATGROUPS_INFO* pOutParam, int waittime);

// 分组人员统计--获取摘要信息 输入参数
typedef struct tagNET_IN_NUMBERSTATGROUPSUMMARY_INFO
{
	DWORD						dwSize;									// 结构体大小
	char						szGroupID[MAX_GROUPID_LEN];				// GroupID
}NET_IN_NUMBERSTATGROUPSUMMARY_INFO;

// 分组人员统计--获取摘要信息 输出参数
typedef struct tagNET_OUT_NUMBERSTATGROUPSUMMARY_INFO
{
	DWORD						dwSize;									// 结构体大小
	NET_NUMBERSTATGROUP_SUMMARY	stuSummary;								// 摘要信息
}NET_OUT_NUMBERSTATGROUPSUMMARY_INFO;

// 分组人员统计--获取摘要信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNumberStatGroupSummary(LLONG lLoginID, const NET_IN_NUMBERSTATGROUPSUMMARY_INFO* pInParam, NET_OUT_NUMBERSTATGROUPSUMMARY_INFO* pOutParam, int waittime);

// 待查询数据的规则类型
typedef enum tagEM_NUMBERSTATGROUP_RULE_TYPE
{
	EM_NUMBERSTATGROUP_RULE_UNKNOWN = 0,
	EM_NUMBERSTATGROUP_RULE_NUMBERSTAT,								// 返回Entered和Exited
	EM_NUMBERSTATGROUP_RULE_MANNUMBERDETECTION,						// 返回Inside统计
}EM_NUMBERSTATGROUP_RULE_TYPE;

// 统计信息粒度
typedef enum tagEM_GRANULARITY_TYPE
{
	EM_GRANULARITY_UNKNOWN = 0,
	EM_GRANULARITY_MINUTE,												// 按分钟
	EM_GRANULARITY_HOUR,												// 按小时
	EM_GRANULARITY_DAY,												// 按天
	EM_GRANULARITY_WEEK,												// 按周
	EM_GRANULARITY_MONTH,												// 按月
	EM_GRANULARITY_SEASON,												// 按季
	EM_GRANULARITY_YEAR												// 按年
}EM_GRANULARITY_TYPE;

// 查询条件
typedef struct tagNET_IN_NUMBERSTATGROUP_START_FIND_INFO
{
	DWORD							dwSize;									// 结构体大小
	char							szGroupID[MAX_GROUPID_LEN];				// 组ID,为""则查询所有组
	NET_TIME						stStartTime;							// 开始时间
	NET_TIME						stEndTime;								// 结束时间
	EM_NUMBERSTATGROUP_RULE_TYPE	emRuleType;								// 待查询数据的规则类型
	EM_GRANULARITY_TYPE				emGranularity;							// 查询粒度
	UINT							nPlanID;								// 计划ID,仅球机有效,从1开始
}NET_IN_NUMBERSTATGROUP_START_FIND_INFO;

// 查询输出
typedef struct tagNET_OUT_NUMBERSTATGROUP_START_FIND_INFO
{
	DWORD							dwSize;									// 结构体大小
	UINT							nTotalCount;							// 符合查询条件的总数
}NET_OUT_NUMBERSTATGROUP_START_FIND_INFO;

// 分组人员统计--开始查找
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindNumberStatGroup(LLONG lLoginID, const NET_IN_NUMBERSTATGROUP_START_FIND_INFO* pInParam, NET_OUT_NUMBERSTATGROUP_START_FIND_INFO* pOutParam, int nWaitTime);

// 分组客流统计记录
typedef struct tagNET_NUMBERSTATGROUP_RECORD
{
	char							szGroupID[MAX_GROUPID_LEN];					// 组ID
	char							szGroupName[MAX_GROUPNAME_LEN];				// 组名
	int								nChannelNum;								// 通道号数
	int								arChannelList[MAX_GROUP_CHANNEL_NUM];		// 通道号列表
	EM_NUMBERSTATGROUP_RULE_TYPE	emRuleName;									// 规则类型
	NET_TIME_EX						stuStartTime;								// 统计开始时间
	NET_TIME_EX						stuEndTime;									// 统计结束时间,和开始时间一样表示统计人数是个瞬时值

	UINT							nEnteredSubtotal;							// 进入小计
	UINT							nExitedSubtotal;							// 出去小计
	UINT							nInsideSubtotal;							// 区域内人数
	BYTE							byReserved[1024];							// 保留
} NET_NUMBERSTATGROUP_RECORD;

// CLIENT_DoFindNumberStatGroup输入参数
typedef struct tagNET_IN_NUMBERSTATGROUP_DO_FIND_INFO 
{
	DWORD                       dwSize;
	int                         nStartNo;           // 起始序号
	int                         nCount;             // 本次欲获得结果的个数
}NET_IN_NUMBERSTATGROUP_DO_FIND_INFO;

// CLIENT_DoFindNumberStatGroup输出参数
typedef struct tagNET_OUT_NUMBERSTATGROUP_DO_FIND_INFO
{
	DWORD                       dwSize;
	int                         nRetNum;            // 本次查询到的个数
	int	                        nMaxNum;            // 用户分配内存的个数
	NET_NUMBERSTATGROUP_RECORD* pstuInfo;           // 查询结果, 用户分配内存,大小为sizeof(NET_NUMBERSTATGROUP_RECORD)*nMaxNum
}NET_OUT_NUMBERSTATGROUP_DO_FIND_INFO;

// 分组人员统计--查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindNumberStatGroup(LLONG lFindHandle, const NET_IN_NUMBERSTATGROUP_DO_FIND_INFO* pInParam, NET_OUT_NUMBERSTATGROUP_DO_FIND_INFO* pOutParam, int nWaitTime);

// 分组人员统计--停止查找
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindNumberStatGroup(LLONG lFindHandle);

/**************************录像二次分析接口*************************/
#define MAX_SECONDARY_ANALYSE_TASK_NUM		32  // 二次分析任务支持的最大个数
#define MAX_SECONDARY_ANALYSE_RULE_NUM		8	// 二次分析规则支持的最大个数
#define MAX_SECONDARY_ANALYSE_EVENT_NUM		8	// 二次分析事件支持的最大个数

// 录像二次分析任务状态
typedef enum tagEM_SECONDARY_ANALYSE_STATE
{
	EM_SECONDARY_ANALYSE_UNKNOWN,				// 未知
	EM_SECONDARY_ANALYSE_WAIT_DOWNLOAD,			// 等待下载
	EM_SECONDARY_ANALYSE_DOWNLOADING,			// 下载中
	EM_SECONDARY_ANALYSE_WAIT_ANALYSE,			// 等待分析
	EM_SECONDARY_ANALYSE_ANALYSING,				// 分析中
	EM_SECONDARY_ANALYSE_FINISH_ANALYSE,		// 完成分析
	EM_SECONDARY_ANALYSE_DOWNLOAD_FAILED,		// 下载失败
	EM_SECONDARY_ANALYSE_CANCELLED,				// 任务取消
	EM_SECONDARY_ANALYSE_NOTENOUGH_ANALYSER,	// 分析器不够
	EM_SECONDARY_ANALYSE_ANALYSER_ERROR,		// 分析器异常
	EM_SECONDARY_ANALYSE_PAUSE_DOWNLOAD,		// 下载暂停
	EM_SECONDARY_ANALYSE_PAUSE_ANALYSE,			// 分析暂停
} EM_SECONDARY_ANALYSE_STATE;

// 录像二次分析任务状态信息
typedef struct tagNET_ANALYSE_TASK_INFO
{
	UINT							nTaskID;							// 任务ID
	EM_SECONDARY_ANALYSE_STATE		emAnalyseState;						// 当前任务状态
	char							szTaskName[DH_COMMON_STRING_128];	// 当前任务名称
	UINT							nProgress;							// 当前分析进度
	BYTE				            byReserved[516];					// 保留字节
} NET_ANALYSE_TASK_INFO;

// 录像二次分析状态订阅回调函数出参
typedef struct tagNET_CB_SECONDARY_ANALYSE_INFO
{
	int						nRetAnalyseTaskCount;			// 实际返回的二次分析任务个数
	BYTE					byReserved1[4];					// 字节对齐
	NET_ANALYSE_TASK_INFO	stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// 二次分析任务信息
	LDWORD 					dwUser;							// 用户数据
	BYTE				    byReserved[512];				// 保留字节
} NET_CB_SECONDARY_ANALYSE_INFO;

// 录像二次分析状态订阅回调函数原型
typedef int  (CALLBACK *fSecondaryAnalyseCallBack)(LLONG lAnalyseHandle, NET_CB_SECONDARY_ANALYSE_INFO *pstSecondaryAnalyseInfo);

// 订阅录像二次分析进度输入参数
typedef struct tagNET_IN_ATTACH_SECONDARY_ANALYSE_STATE
{
	DWORD							dwSize;					// 赋值为结构体大小
	BYTE							byReserved[4];			// 字节对齐
    fSecondaryAnalyseCallBack	    cbSecondaryAnalyse;		// 回调函数
    LDWORD                  		dwUser;                 // 用户数据
} NET_IN_ATTACH_SECONDARY_ANALYSE_STATE;

// 订阅录像二次分析进度输出参数
typedef struct tagNET_OUT_ATTACH_SECONDARY_ANALYSE_STATE
{
	DWORD							dwSize;					// 赋值为结构体大小
} NET_OUT_ATTACH_SECONDARY_ANALYSE_STATE;

// 人脸分析规则信息
typedef struct tagNET_ANALYSE_RULE_FACE_ANALYSIS_INFO
{
	UINT			nSimilarity;										// 相似度
	UINT			nGroupNum;											// 人脸组个数
	char			szGroupID[MAX_FACE_DB_NUM][DH_COMMON_STRING_64]; 	// 人脸组ID
	BYTE			byReserved[1024];									// 保留字节
} NET_ANALYSE_RULE_FACE_ANALYSIS_INFO;

// 规则类型
typedef enum tagEM_ANALYSE_RULE_TYPE
{
	EM_ANALYSE_RULE_UNKNOWN,			// 未知
	EM_ANALYSE_RULE_FACE_ANALYSIS,		// 人脸分析, 对应结构体 NET_ANALYSE_RULE_FACE_ANALYSIS_INFO
	EM_ANALYSE_RULE_FACE_ATTRIBUTE,		// 人脸检测, 无配置结构体
} EM_ANALYSE_RULE_TYPE;

// 事件类型
typedef enum tagEM_ANALYSE_EVENT_TYPE
{
    EM_ANALYSE_EVENT_UNKNOWN,                   // 未知
    EM_ANALYSE_EVENT_ALL,                       // 所有事件
    EM_ANALYSE_EVENT_FACE_DETECTION,            // 人脸检测事件, 对应结构体 DEV_EVENT_FACEDETECT_INFO
    EM_ANALYSE_EVENT_FACE_RECOGNITION,          // 人脸识别事件, 对应结构体 DEV_EVENT_FACERECOGNITION_INFO
    EM_ANALYSE_EVENT_TRAFFICJUNCTION,           // 交通路口事件, 对应结构体 DEV_EVENT_TRAFFICJUNCTION_INFO
    EM_ANALYSE_EVENT_HUMANTRAIT,                // 人体特征事件, 对应结构体 DEV_EVENT_HUMANTRAIT_INFO
    EM_ANALYSE_EVENT_XRAY_DETECTION,            // X光机检测事件, 对应结构体 DEV_EVENT_XRAY_DETECTION_INFO
    EM_ANALYSE_EVENT_WORKCLOTHESDETECT,         // 工装(安全帽/工作服等)检测事件, 对应结构体 DEV_EVENT_WORKCLOTHESDETECT_INFO
    EM_ANALYSE_EVENT_WORKSTATDETECTION,         // 作业检测事件, 对应结构体 DEV_EVENT_WORKSTATDETECTION_INFO
    EM_ANALYSE_EVENT_CORSSLINEDETECTION,        // 警戒线事件, 对应结构体 DEV_EVENT_CROSSLINE_INFO
    EM_ANALYSE_EVENT_CROSSREGIONDETECTION,      // 警戒区事件, 对应结构体 DEV_EVENT_CROSSREGION_INFO
    EM_ANALYSE_EVENT_FEATURE_ABSTRACT,          // 特征提取事件 DEV_EVENT_FEATURE_ABSTRACT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT,     // 电力检测手套检测事件,  对应结构体 DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT,    // 电力检测梯子检测事件,  对应结构体 DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT,   // 电力检测布幔检测事件,  对应结构体 DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT,     // 电力检测围栏检测事件,  对应结构体 DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT, // 电力检测标识牌检测事件,  对应结构体 DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
    EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT,      // 电力检测安全带检测事件,  对应结构体 DEV_EVENT_ELECTRIC_BELT_DETECT_INFO
    
    EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX = 2000, // 警戒线事件(扩展), 对应结构体 DEV_EVENT_CROSSLINE_INFO_EX
}  EM_ANALYSE_EVENT_TYPE;

// 录像二次分析规则信息
typedef struct tagNET_ANALYSE_INFO
{
	EM_ANALYSE_RULE_TYPE	emAnalyseType;		// 规则类型
	BYTE					byReserved1[4];		// 字节对齐
	void					*pRuleInfo;			// 规则具体信息, 根据emAnalyseType来确定具体的结构体
	BYTE					byReserved[512];	// 保留字节
} NET_ANALYSE_INFO;

// 	需要添加的录像二次分析任务信息
typedef struct tagNET_SECONDARY_ANALYSE_TASK_INFO
{
	char				szRecordPath[DH_COMMON_STRING_256];				// 录像文件路径
	int					nAnalyseCount;									// 录像二次分析的规则个数
	NET_ANALYSE_INFO	stuAnalyseInfo[MAX_SECONDARY_ANALYSE_RULE_NUM];	// 录像二次分析的规则信息
	char				szTaskName[DH_COMMON_STRING_128];				// 任务名称
	BOOL				bNeedSave;										// 录像是否保存到设备端
	BYTE				byReserved[1024];								// 保留字节
} NET_SECONDARY_ANALYSE_TASK_INFO;

// 添加录像二次分析任务输入参数
typedef struct  tagNET_IN_SECONDARY_ANALYSE_ADDTASK
{
	DWORD								dwSize;					// 赋值为结构体大小
	int									nAnalyseTaskCount;		// 实际的二次分析任务个数
	NET_SECONDARY_ANALYSE_TASK_INFO		stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// 二次分析任务信息
} NET_IN_SECONDARY_ANALYSE_ADDTASK;

// 添加任务返回的信息
typedef struct tagNET_TASK_ADD_RESULT_INFO
{
	UINT		nTaskID;										// 任务ID, 大于0。失败返回0，与文件列表一一对应
	char		szLocalPath[DH_COMMON_STRING_256];				// 将要保存在设备端的录像文件路径
	BYTE		byReserved[1024];								// 保留字节
} NET_TASK_ADD_RESULT_INFO;

// 添加录像二次分析任务输出参数
typedef struct  tagNET_OUT_SECONDARY_ANALYSE_ADDTASK
{
	DWORD						dwSize;									      // 赋值为结构体大小
	UINT						nRetTaskResultNum;							  // 实际返回的任务添加结果信息
	NET_TASK_ADD_RESULT_INFO	stuResultInfo[MAX_SECONDARY_ANALYSE_TASK_NUM];// 添加任务返回的结果信息
} NET_OUT_SECONDARY_ANALYSE_ADDTASK;

// 开始录像二次分析任务输入参数
typedef struct tagNET_IN_SECONDARY_ANALYSE_STARTTASK
{
	DWORD		dwSize;									// 赋值为结构体大小
	UINT		nTaskIdNum;								// 任务ID个数, 为0表示全部
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// 任务ID，0表示全部
} NET_IN_SECONDARY_ANALYSE_STARTTASK;

// 开始录像二次分析任务输出参数
typedef struct tagNET_OUT_SECONDARY_ANALYSE_STARTTASK
{
	DWORD		dwSize;									// 赋值为结构体大小
} NET_OUT_SECONDARY_ANALYSE_STARTTASK;

// 暂停录像二次分析任务输入参数
typedef struct tagNET_IN_SECONDARY_ANALYSE_PAUSETASK
{
	DWORD		dwSize;									// 赋值为结构体大小
	UINT		nTaskIdNum;								// 任务数量
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// 任务ID
} NET_IN_SECONDARY_ANALYSE_PAUSETASK;

// 暂停录像二次分析任务输出参数
typedef struct tagNET_OUT_SECONDARY_ANALYSE_PAUSETASK
{
	DWORD		dwSize;									// 赋值为结构体大小
} NET_OUT_SECONDARY_ANALYSE_PAUSETASK;

// 删除录像二次分析任务输入参数
typedef struct tagNET_IN_SECONDARY_ANALYSE_REMOVETASK
{
	DWORD		dwSize;									// 赋值为结构体大小
	UINT		nTaskIdNum;								// 任务数量, 0表示删除全部
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// 任务ID
} NET_IN_SECONDARY_ANALYSE_REMOVETASK;

// 删除录像二次分析任务输出参数
typedef struct tagNET_OUT_SECONDARY_ANALYSE_REMOVETASK
{
	DWORD		dwSize;									// 赋值为结构体大小
} NET_OUT_SECONDARY_ANALYSE_REMOVETASK;

// 开始查询录像二次分析任务信息输入参数
typedef struct tagNET_IN_SECONDARY_ANALYSE_STARTFIND_TASK
{
	DWORD		dwSize;									// 赋值为结构体大小
	UINT		nTaskNum;								// 任务个数, 为0表示查找全部
	UINT		nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];// 任务ID
} NET_IN_SECONDARY_ANALYSE_STARTFIND_TASK;

// 开始查询录像二次分析任务信息输出参数
typedef struct tagNET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK
{
	DWORD		dwSize;						// 赋值为结构体大小
	UINT        nTotalCount;                // 符合条件的任务总数
} NET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK;

// 录像二次分析任务状态信息
typedef struct tagNET_SECONDARY_ANALYSE_TASK_STATE_INFO
{
	UINT				nTaskID;							// 任务ID
	char				szTaskName[DH_COMMON_STRING_256];	// 任务名称
	char				szRecordPath[DH_COMMON_STRING_256];	// 录像文件路径
	BOOL				bNeedSave;							// 录像是否保存到设备端
	char				szLoaclPath[DH_COMMON_STRING_256];	// 将要保存在设备端的录像文件路径
	EM_SECONDARY_ANALYSE_STATE		emAnalyseState;			// 当前任务状态
	NET_TIME			stuStartTime;						// 任务开始时间
	NET_TIME			stuFinishTime;						// 任务结束时间
	UINT				nProgress;							// 当前分析进度
	int					nAnalyseCount;									// 录像二次分析的规则个数
	NET_ANALYSE_INFO	stuAnalyseInfo[MAX_SECONDARY_ANALYSE_RULE_NUM];	// 录像二次分析的规则信息
	BYTE				byReserved[1024];								// 保留字节
} NET_SECONDARY_ANALYSE_TASK_STATE_INFO;

// 执行查询录像二次分析任务信息输入参数
typedef struct tagNET_IN_SECONDARY_ANALYSE_DOFIND_TASK
{
	DWORD		dwSize;						// 赋值为结构体大小
	UINT		nBeginNumber;				// 开始查询的起始编号
	UINT		nCount;						// 本次要查询的任务条数
} NET_IN_SECONDARY_ANALYSE_DOFIND_TASK;

// 执行查询录像二次分析任务信息输出参数
typedef struct tagNET_OUT_SECONDARY_ANALYSE_DOFIND_TASK
{
	DWORD		dwSize;						// 赋值为结构体大小
	UINT		nFoundCount;				// 查询到的任务数量	
	NET_SECONDARY_ANALYSE_TASK_STATE_INFO	stuAnalyseTaskInfo[MAX_SECONDARY_ANALYSE_TASK_NUM]; // 录像二次分析任务状态信息
} NET_OUT_SECONDARY_ANALYSE_DOFIND_TASK;

// 二次录像分析事件信息
typedef struct tagNET_SECONDARY_ANALYSE_EVENT_INFO
{
	EM_ANALYSE_EVENT_TYPE		emEventType;		// 事件类型
	BYTE						byReserved1[4];		// 字节对齐
	void						*pstEventInfo;		// 事件信息, 根据emEventType确定不同的结构体
													// EM_ANALYSE_EVENT_FACE_DETECTION (人脸检测事件), 对应结构体 DEV_EVENT_FACEDETECT_INFO
													// EM_ANALYSE_EVENT_FACE_RECOGNITION (人脸识别事件), 对应结构体 DEV_EVENT_FACERECOGNITION_INFO
													// EM_ANALYSE_EVENT_TRAFFICJUNCTION (交通路口事件), 对应结构体 DEV_EVENT_TRAFFICJUNCTION_INFO
													// EM_ANALYSE_EVENT_HUMANTRAIT (人体特征事件), 对应结构体 DEV_EVENT_HUMANTRAIT_INFO
													// EM_ANALYSE_EVENT_XRAY_DETECTION(X光机检测事件), 对应结构体 DEV_EVENT_XRAY_DETECTION_INFO
													// EM_ANALYSE_EVENT_WORKCLOTHESDETECT (工装(安全帽/工作服等)检测事件), 对应结构体 DEV_EVENT_WORKCLOTHES_DETECT_INFO
													// EM_ANALYSE_EVENT_WORKSTATDETECTION (作业检测事件), 对应结构体 DEV_EVENT_WORKSTATDETECTION_INFO
													// EM_ANALYSE_EVENT_CORSSLINEDETECTION (警戒线事件), 对应结构体 DEV_EVENT_CROSSLINE_INFO
													// EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX (警戒线事件(扩展)), 对应结构体 DEV_EVENT_CROSSLINE_INFO_EX
													// EM_ANALYSE_EVENT_CROSSREGIONDETECTION (警戒区事件), 对应结构体 DEV_EVENT_CROSSREGION_INFO
                                                    // EM_ANALYSE_EVENT_FEATURE_ABSTRACT(特征提取), 对应结构体 DEV_EVENT_FEATURE_ABSTRACT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT(电力检测手套检测事件),  对应结构体 DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT(电力检测梯子检测事件),  对应结构体 DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT(电力检测布幔检测事件),  对应结构体 DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT(电力检测围栏检测事件),  对应结构体 DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT(电力检测标识牌检测事件),  对应结构体 DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
                                                    // EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT(电力检测安全带检测事件),  对应结构体 DEV_EVENT_ELECTRIC_BELT_DETECT_INFO
	BYTE						byReserved[1024];	// 保留字节
} NET_SECONDARY_ANALYSE_EVENT_INFO;

// 二次录像分析实时结果订阅回调结果结构体
typedef struct tagNET_CB_ANALYSE_RESULT_INFO
{
	UINT								nTaskID;			// 任务ID
	NET_TIME							stuPicTime;			// 图片时间
	int									nRetEventCount;		// 实际的事件个数
	NET_SECONDARY_ANALYSE_EVENT_INFO	stuEventInfo[MAX_SECONDARY_ANALYSE_EVENT_NUM];// 录像二次分析事件信息
	LDWORD 								dwUser;				// 用户数据
	BYTE								byReserved[1024];	// 保留字节
} NET_CB_ANALYSE_RESULT_INFO;

// 二次录像分析实时结果订阅函数原型
typedef int  (CALLBACK *fAnalyseResultCallBack)(LLONG lAnalyseHandle, NET_CB_ANALYSE_RESULT_INFO *pstAnalyseResultInfo, BYTE *pBuffer, DWORD dwBufSize);

// 订阅二次录像分析实时结果输入参数
typedef struct tagNET_IN_ATTACH_SECONDARY_ANALYSE_RESULT
{
	DWORD					dwSize;										// 赋值为结构体大小
	int						nTaskNum;									// 需要订阅的任务个数, 0表示订阅全部
	UINT					nTaskID[MAX_SECONDARY_ANALYSE_TASK_NUM];	// 任务ID
	int						nEventCount;								// 需要订阅的事件个数
	EM_ANALYSE_EVENT_TYPE	emEventType[MAX_SECONDARY_ANALYSE_TASK_NUM];// 需要订阅的事件
	BOOL					bNeedPicData;								// 是否需要图片数据
	fAnalyseResultCallBack	cbAnalyseResult;							// 二次录像分析实时结果订阅函数
	LDWORD                  dwUser;                 					// 用户数据
} NET_IN_ATTACH_SECONDARY_ANALYSE_RESULT;

// 订阅二次录像分析实时结果输出参数
typedef struct tagNET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT
{
	DWORD				dwSize;										// 赋值为结构体大小
} NET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT;

// 订阅录像二次分析任务进度, pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordSecondaryAnalyseTaskState(LLONG lLoginID, NET_IN_ATTACH_SECONDARY_ANALYSE_STATE *pstInParam, NET_OUT_ATTACH_SECONDARY_ANALYSE_STATE *pstOutParam, int nWaitTime);

// 取消订阅录像二次分析进度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordSecondaryAnalyseState(LLONG lAnalyseHandle);

// 添加录像二次分析任务 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseAddTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_ADDTASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_ADDTASK *pstOutParam, int nWaitTime);

// 开始录像二次分析任务 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseStartTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_STARTTASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_STARTTASK *pstOutParam, int nWaitTime);

// 暂停录像二次分析任务 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalysePauseTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_PAUSETASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_PAUSETASK *pstOutParam, int nWaitTime);

// 删除录像二次分析任务 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseRemoveTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_REMOVETASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_REMOVETASK *pstOutParam, int nWaitTime);

// 开始查询录像二次分为任务信息 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_RecordSecondaryAnalyseStartFindTask(LLONG lLoginID, NET_IN_SECONDARY_ANALYSE_STARTFIND_TASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_STARTFIND_TASK *pstOutParam, int nWaitTime);

// 执行查询录像二次分为任务信息 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseDoFindTask(LLONG lFindHandle, NET_IN_SECONDARY_ANALYSE_DOFIND_TASK *pstInParam, NET_OUT_SECONDARY_ANALYSE_DOFIND_TASK *pstOutParam, int nWaitTime);

// 停止查询录像二次分为任务信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecordSecondaryAnalyseStopFindTask(LLONG lFindHandle);

// 订阅录像二次分析实时结果 pstInParam与pstOutParam内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRecordSecondaryAnalyseResult(LLONG lLoginID, NET_IN_ATTACH_SECONDARY_ANALYSE_RESULT *pstInParam, NET_OUT_ATTACH_SECONDARY_ANALYSE_RESULT *pstOutParam, int nWaitTime);

// 取消订阅录像二次分析实时结果
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRecordSecondaryAnalyseResult(LLONG	lAttachHandle);

//比对结果
typedef enum tagEM_COMPARE_RESULT
{
    EM_COMPARE_RESULT_UNKNOWN=-1,
	EM_COMPARE_RESULT_SUCCESS,      //成功
	EM_COMPARE_RESULT_OTHERERROR,   //其他错误
	EM_COMPARE_RESULT_NOTINDATABASE //不在人脸库中
}EM_COMPARE_RESULT;

//开门方式
typedef enum tagEM_FACE_OPEN_DOOR_TYPE
{
	EM_FACE_OPEN_DOOR_TYPE_UNKNOWN = 0,   //未知
	EM_FACE_OPEN_DOOR_TYPE_REMOTEFACE,     //远程人脸
	EM_FACE_OPEN_DOOR_TYPE_REMOTEQRCODE    //远程二维码
}EM_FACE_OPEN_DOOR_TYPE;

//用户类型
typedef enum tagEM_USER_TYPE
{
    EM_USER_TYPE_UNKNOWN=-1,
	EM_USER_TYPE_ORDINARY,   //普通用户
	EM_USER_TYPE_BLACKLIST,  //黑名单用户
	EM_USER_TYPE_VIP,        //VIP用户
	EM_USER_TYPE_GUEST,      //来宾用户
	EM_USER_TYPE_PATROL,     //巡逻用户
	EM_USER_TYPE_DISABLED,   //残疾用户
	EM_USER_TYPE_FROZEN,     //冻结用户
	EM_USER_TYPE_LOGOUT,     //注销用户
	EM_USER_TYPE_LOSSCARD    //挂失卡
}EM_USER_TYPE;

// 信息类型
typedef enum tagEM_EDUCATION_INFO_TYPE
{
    EM_EDUCATION_INFO_TYPE_UNKNOWN,                         // 未知
    EM_EDUCATION_INFO_TYPE_CHECK_IN,                        // 签到
    EM_EDUCATION_INFO_TYPE_SIGN_BACK,                       // 签退
    EM_EDUCATION_INFO_TYPE_ROLL_CALL,                       // 点名
    EM_EDUCATION_INFO_TYPE_LEARNING_ABNORMAL,               // 学习异常
    EM_EDUCATION_INFO_TYPE_EXAMINATION,                     // 考试
    EM_EDUCATION_INFO_TYPE_END_OF_STUDY,                    // 结束学习
    EM_EDUCATION_INFO_TYPE_EXPERIENCE_LEARNING,             // 体验学习
    EM_EDUCATION_INFO_TYPE_NOT_LEARNING,                    // 未学习
    EM_EDUCATION_INFO_TYPE_MIDWAY_IN,                       // 中途进入
    EM_EDUCATION_INFO_TYPE_MIDWAY_LEAVE                     // 中途离开
} EM_EDUCATION_INFO_TYPE;

// 教育信息
typedef struct tagNET_CUSTOM_EDUCATION_INFO
{
    EM_EDUCATION_INFO_TYPE                emInfoType;                      // 信息类型
    int                                   nStudentSeatNumber;              // 座位号,最小值为1
    char                                  szInfoContent[128];              // 消息内容
} NET_CUSTOM_EDUCATION_INFO;
 
//匹配信息
typedef struct tagNET_OPENDOOR_MATCHINFO
{
	char                                  szUserID[32];     //远程用户ID
	char                                  szUserName[32];   //用户名
	EM_USER_TYPE                          emUserType;       //用户类型
	char                                  szName[64];       //门禁名称
	UINT                                  nMatchRate;       //匹配度，范围为0-100
    EM_FACE_OPEN_DOOR_TYPE                emOpenDoorType;   //开门方式
    NET_TIME                              stuActivationTime;                         //(卡、头像)生效日期 
    NET_TIME                              stuExpiryTime;                             //(卡、头像)截止日期
    int                                   nScore;                                    // 信用积分
    char                                  szCompanyName[MAX_COMPANY_NAME_LEN];       //单位名称
    char                                  szCompanionName[120];                      //陪同人员姓名
    char                                  szCompanionCompany[MAX_COMPANY_NAME_LEN];  //陪同人员单位名称
    char                                  szPermissibleArea[MAX_COMMON_STRING_128];  //准许通行区域
	char								  szSection[200];		//部门名称
    NET_CUSTOM_EDUCATION_INFO*            pstuCustomEducationInfo;                   // 教育信息(两个教育定制使用)
	BYTE         byReserved[112];
}NET_OPENDOOR_MATCHINFO;

//图片信息
typedef struct tagNET_OPENDOOR_IMAGEINFO
{
	int nLibImageLen;    //人脸库照片长度，限制为150k
    int nSnapImageLen;   //抓拍照片长度，限制为150k
	char *pLibImage;     //人脸库照片，内存由用户申请
	char *pSnapImage;    //抓拍照片，内存由用户申请
    BYTE byReserved[1024];
}NET_OPENDOOR_IMAGEINFO;

//人脸开门输入参数
typedef struct tagNET_IN_FACE_OPEN_DOOR
{
    DWORD                  dwSize;         
    UINT                   nChannel;     //门通道号
    EM_COMPARE_RESULT      emCompareResult;//比对结果
    NET_OPENDOOR_MATCHINFO stuMatchInfo;    //匹配信息
    NET_OPENDOOR_IMAGEINFO stuImageInfo;   //图片信息
}NET_IN_FACE_OPEN_DOOR;

//人脸开门输出参数
typedef struct tagNET_OUT_FACE_OPEN_DOOR
{
    DWORD dwSize;
}NET_OUT_FACE_OPEN_DOOR;

//人脸开门
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FaceOpenDoor(LLONG lLoginID, NET_IN_FACE_OPEN_DOOR* pInParam, NET_OUT_FACE_OPEN_DOOR* pOutParam,int nWaitTime);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 分区状态
typedef enum tagEM_LOGIC_VOLUME_STATUS
{	
	EM_LOGIC_VOLUME_STATUS_UNKNOWN = -1,					// 未知
	EM_LOGIC_VOLUME_STATUS_NOT_NEED_REPAIR,					// 没有分区需要修复
	EM_LOGIC_VOLUME_STATUS_LV_NEED_REPAIR,					// 有分区需要修复
	EM_LOGIC_VOLUME_STATUS_LV_REPAIRING,					// 分区正在修复
	EM_LOGIC_VOLUME_STATUS_LV_REPAIR_COMPLETE,				// 分区已经修复完成
}EM_LOGIC_VOLUME_STATUS;

// CLIENT_NASGetLogicVolumeStatus接口入参
typedef struct tagNET_IN_NAS_GETLOGICVOLUMESTATUS
{
	DWORD			dwSize;									// 结构体大小
}NET_IN_NAS_GETLOGICVOLUMESTATUS;

// CLIENT_NASGetLogicVolumeStatus接口出参
typedef struct tagNET_OUT_NAS_GETLOGICVOLUMESTATUS
{
	DWORD						dwSize;											// 结构体大小
	EM_LOGIC_VOLUME_STATUS		emLVStatus;										// 分区状态
	char						szLvName[MAX_LV_NAME_NUM][MAX_LV_NAME_LEN];		// 分区名称,当emLVStatus为EM_LOGIC_VOLUME_STATUS_LV_NEED_REPAIR或EM_LOGIC_VOLUME_STATUS_LV_REPAIRING时有效
	int							nRetLvNameNum;									// 返回的分区名称个数
}NET_OUT_NAS_GETLOGICVOLUMESTATUS;

// 获取分区状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASGetLogicVolumeStatus(LLONG lLoginID, const NET_IN_NAS_GETLOGICVOLUMESTATUS *pInParam, NET_OUT_NAS_GETLOGICVOLUMESTATUS *pOutParam, int nWaitTime);

// 分区修复状态
typedef enum tagEM_LOGIC_VOLUME_REPAIR_STATUS
{	
	EM_LOGIC_VOLUME_REPAIR_STATUS_UNKNOWN = -1,				// 未知
	EM_LOGIC_VOLUME_REPAIR_STATUS_FAILED,					// 修复失败
	EM_LOGIC_VOLUME_REPAIR_STATUS_SUCCESS,					// 修复成功
}EM_LOGIC_VOLUME_REPAIR_STATUS;

// 分区信息
typedef struct tagNET_LV_STATE
{
	EM_LOGIC_VOLUME_REPAIR_STATUS	emLVRepairStatus;							// 修复状态
	char						    szLvName[MAX_LV_NAME_NUM][MAX_LV_NAME_LEN];	// 分区名称
	int								nRetLvNameNum;								// 返回的分区名称个数
	BYTE							byReserved[1024];							// 保留
}NET_LV_STATE;

// 分区修复状态回调函数原形，lAttachHandle 是 CLIENT_AttachNASRepairState 返回值
typedef void (CALLBACK *fLVRepairStateCallBack) (LLONG lAttachHandle, NET_LV_STATE* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachNASRepairState接口入参
typedef struct tagNET_IN_ATTACH_NAS_REPAIRSTATE
{
	DWORD						dwSize;								// 结构体大小
	fLVRepairStateCallBack      cbLVRepairState;					// 分区修复状态回调
	BYTE						byReserved[4];						// 预留对齐字节
	LDWORD						dwUser;								// 用户数据   
}NET_IN_ATTACH_NAS_REPAIRSTATE;

// CLIENT_AttachNASRepairState接口出参
typedef struct tagNET_OUT_ATTACH_NAS_REPAIRSTATE
{
	DWORD						dwSize;								// 结构体大小
}NET_OUT_ATTACH_NAS_REPAIRSTATE;

// 订阅分区修复状态
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNASRepairState(LLONG lLoginID, const NET_IN_ATTACH_NAS_REPAIRSTATE* pInParam, NET_OUT_ATTACH_NAS_REPAIRSTATE* pOutParam, int nWaitTime);

// 取消订阅分区修复状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNASRepairState(LLONG lAttachHandle);

// 文件查询结果
typedef struct tagNET_FILE_FINEDER
{
	unsigned int				nRetFileListsCount;												// 实际返回的文件名条数
	char						szFileLists[MAX_FILE_LIST_NUM][MAX_FILE_LIST_LEN];				// 查找结果文件名列表
	BOOL						bFindFinished;													// 是否查找完成,TRUE表示查找完成,FALSE表示正在查找
	BYTE						byReserved[1024];												// 保留字节
}NET_FILE_FINEDER;

// 异步查找文件回调函数原形，lAttachHandle 是 CLIENT_AttachNASFileFinder 返回值
typedef void (CALLBACK *fNasFileFinderCallback) (LLONG lAttachHandle, NET_FILE_FINEDER* pBuf, DWORD dwBufLen, LDWORD dwUser);

// CLIENT_AttachNASFileFinder接口入参 
typedef struct tagNET_IN_ATTACHNASFILEFINDER
{
	DWORD						dwSize;						   // 结构体大小
	int							nFindPathsNum;				   // 请求的查找路径个数
	char						szFindPaths[MAX_FILE_FINDER_PATH_NUM][MAX_FILE_FINDER_PATH_LEN];		   // 查找路径名列表
	char						szKey[MAX_KEY_LEN];			   // 查找的关键字
	unsigned int				nOffset;					   // 查找偏移量
	unsigned int				nCount;						   // 查找数量
	fNasFileFinderCallback		cbNasFileFinder;			   // 查找文件结果回调
	LDWORD						dwUser;						   // 用户数据  
}NET_IN_ATTACHNASFILEFINDER;

// CLIENT_AttachNASFileFinder接口出参 
typedef struct tagNET_OUT_ATTACHNASFILEFINDER
{
	DWORD						dwSize;							// 结构体大小
}NET_OUT_ATTACHNASFILEFINDER;

// 异步查找文件
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachNASFileFinder(LLONG lLoginID, const NET_IN_ATTACHNASFILEFINDER* pInParam, NET_OUT_ATTACHNASFILEFINDER* pOutParam, int nWaitTime);

// 取消异步查找文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachNASFileFinder(LLONG lAttachHandle);

// 回放回调码流类型
typedef enum tagEM_PLAYBACK_STREAM_TYPE
{
	EM_PLAYBACK_STREAM_TYPE_UNKNOWN = -1,       // 未知
	EM_PLAYBACK_STREAM_TYPE_ORIGINAL_STREAM,	// 只回调原始码流
	EM_PLAYBACK_STREAM_TYPE_MAX,				// 最大值
}EM_PLAYBACK_STREAM_TYPE;

// 设置回放回调码流类型
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayBackStreamType(LLONG lLoginID, EM_PLAYBACK_STREAM_TYPE emStreamType);

// CLIENT_GetFingerprintCaps接口入参 
typedef struct tagNET_IN_GET_FINGERPRINTCAPS
{
	DWORD						dwSize;						   // 结构体大小
}NET_IN_GET_FINGERPRINTCAPS;

// CLIENT_GetFingerprintCaps接口出参 
typedef struct tagNET_OUT_GET_FINGERPRINTCAPS
{
	DWORD						dwSize;							// 结构体大小
	BOOL                        bSupportFingerprint;            // 是否支持指纹, TRUE:支持; FALSE:不支持
}NET_OUT_GET_FINGERPRINTCAPS;

// 获取指纹能力
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFingerprintCaps(LLONG lLoginID, NET_IN_GET_FINGERPRINTCAPS* pInParam, NET_OUT_GET_FINGERPRINTCAPS* pOutParam, int nWaitTime);

// 设备程序所在的市场区域
typedef enum tagEM_DEVICE_MARKET_AREA
{
	EM_DEVICE_MARKET_AREA_UNKNOWN,		// 未知
	EM_DEVICE_MARKET_AREA_MAINLAND,		// 国内
	EM_DEVICE_MARKET_AREA_OVERSEA,		// 海外
}EM_DEVICE_MARKET_AREA;

// CLIENT_GetMarketArea接口入参
typedef struct tagNET_IN_GET_MARKET_AREA
{
	DWORD						dwSize;				// 结构体大小
}NET_IN_GET_MARKET_AREA;

// CLIENT_GetMarketArea接口出参
typedef struct tagNET_OUT_GET_MARKET_AREA
{
	DWORD						dwSize;				// 结构体大小
	EM_DEVICE_MARKET_AREA		emMarketArea;		// 市场区域
}NET_OUT_GET_MARKET_AREA;

// 得到市场区域
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMarketArea(LLONG lLoginID, const NET_IN_GET_MARKET_AREA* pInParam, NET_OUT_GET_MARKET_AREA* pOutParam, int nWaitTime);

/////////////////////////////////雷球联动接口 start//////////////////////////////

//雷达开始升级通知入参(对应 EM_RADAR_OPERATE_TYPE_STARTUPGRADE)
typedef struct tagNET_IN_RADAR_STARTUPGRADE
{
	DWORD                       dwSize;                  // 结构体大小
}NET_IN_RADAR_STARTUPGRADE;

//雷达开始升级通知出参(对应 EM_RADAR_OPERATE_TYPE_STARTUPGRADE)
typedef struct tagNET_OUT_RADAR_STARTUPGRADE
{
	DWORD                       dwSize;                  // 结构体大小
}NET_OUT_RADAR_STARTUPGRADE;

//获取雷达能力入参(对应 EM_RADAR_OPERATE_TYPE_GETCAPS)
typedef struct tagNET_IN_RADAR_GETCAPS
{
	DWORD                       dwSize;                  // 结构体大小
	int							nChannel;				 // 通道号
}NET_IN_RADAR_GETCAPS;

//获取雷达能力出参(对应 EM_RADAR_OPERATE_TYPE_GETCAPS)
typedef struct tagNET_OUT_RADAR_GETCAPS
{
	DWORD                       dwSize;                  // 结构体大小
	int                         nDetectionRange;         // 雷达探测距离，实际距离扩大100倍,单位米
	int                         nDetectionAngle;         // 雷达探测角度，实际角度扩大100倍,单位度
	int                         nDetectionHuman;         // 雷达人探测距离，实际距离扩大100倍,单位米
}NET_OUT_RADAR_GETCAPS;

//获取雷达状态入参(对应 EM_RADAR_OPERATE_TYPE_GETSTATUS)
typedef struct tagNET_IN_RADAR_GETSTATUS
{
	DWORD                       dwSize;                  // 结构体大小
	int							nChannel;				 // 通道号
}NET_IN_RADAR_GETSTATUS;

//雷达状态
typedef enum tagEM_RADAR_STATUS
{
	EM_RADAR_STATUS_UNKNOWN,                             // 未知
	EM_RADAR_STATUS_NORMAL,                              // 正常
	EM_RADAR_STATUS_ABNORMAL,                            // 异常
}EM_RADAR_STATUS;

//获取雷达状态出参(对应 EM_RADAR_OPERATE_TYPE_GETSTATUS)
typedef struct tagNET_OUT_RADAR_GETSTATUS
{
	DWORD                       dwSize;                  // 结构体大小
	EM_RADAR_STATUS             emRadarStatus;           // 雷达状态
}NET_OUT_RADAR_GETSTATUS;

//图片中线段的像素坐标
typedef struct tagNET_RADAR_PIXELLINE
{
	int                         nLeftX;                  // 左顶点的X坐标
	int                         nLeftY;                  // 左顶点的Y坐标
	int                         nRightX;                 // 右顶点的X坐标
	int                         nRightY;                 // 右顶点的Y坐标
	BYTE                        byReserved[64];          // 保留字节
}NET_RADAR_PIXELLINE;

//计算图片对应的地图实际长度入参(对应 EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE)
typedef struct tagNET_IN_RADAR_CALCULATEREALSIZE
{
	DWORD                       dwSize;                  // 结构体大小
	int							nChannel;				 // 通道号
	NET_RADAR_PIXELLINE         stuPixelLine;            // 图片中线段的像素坐标
	double                      dDistance;               // 图片中线段代表的实际长度，单位米
}NET_IN_RADAR_CALCULATEREALSIZE;

//计算图片对应的地图实际长度出参(对应 EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE)
typedef struct tagNET_OUT_RADAR_CALCULATEREALSIZE
{
	DWORD                       dwSize;                  // 结构体大小
	int                         nRealMapLength;          // 实际地图的高度，单位米（实际长度扩大100倍表示）
	int                         nRealMapWidth;           // 实际地图的宽度，单位米（实际宽度扩大100倍表示）
}NET_OUT_RADAR_CALCULATEREALSIZE;

//图片中校准点的像素坐标
typedef struct tagNET_RADAR_PIXELPOINT
{								
	int                         nPixelPointX;			 // X像素坐标(0~8191) 
	int                         nPixelPointY;			 // Y像素坐标(0~8191)
}NET_RADAR_PIXELPOINT;

//雷球校准配置入参(对应 EM_RADAR_OPERATE_TYPE_SETCALIBRATION)
typedef struct tagNET_IN_RADAR_SETCALIBRATION
{
	DWORD                       dwSize;                  // 结构体大小
	BYTE                        byReserved[4];           // 保留字节
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // 图片中校准点的像素坐标
	double                      dInstallHeigt;           // 球机的安装高度，单位米
}NET_IN_RADAR_SETCALIBRATION;

//雷球校准配置出参(对应 EM_RADAR_OPERATE_TYPE_SETCALIBRATION)
typedef struct tagNET_OUT_RADAR_SETCALIBRATION
{
	DWORD                       dwSize;                  // 结构体大小
}NET_OUT_RADAR_SETCALIBRATION;

//雷达操作类型
typedef enum tagEM_RADAR_OPERATE_TYPE
{
	EM_RADAR_OPERATE_TYPE_STARTUPGRADE = 0,              // 雷达开始升级通知,入参:NET_IN_RADAR_STARTUPGRADE,出参:NET_OUT_RADAR_STARTUPGRADE
	EM_RADAR_OPERATE_TYPE_GETCAPS = 1,                   // 获取雷达能力,入参:NET_IN_RADAR_GETCAPS,出参:NET_OUT_RADAR_GETCAPS
	EM_RADAR_OPERATE_TYPE_GETSTATUS = 2,                 // 获取雷达状态,入参:NET_IN_RADAR_GETSTATUS,出参:NET_OUT_RADAR_GETSTATUS
	EM_RADAR_OPERATE_TYPE_CALCULATEREALSIZE = 3,         // 计算图片对应的地图实际长度,入参:NET_IN_RADAR_CALCULATEREALSIZE,出参:NET_OUT_RADAR_CALCULATEREALSIZE
	EM_RADAR_OPERATE_TYPE_SETCALIBRATION = 4,            // 雷球校准配置下发,入参:NET_IN_RADAR_SETCALIBRATION,出参:NET_OUT_RADAR_SETCALIBRATION
}EM_RADAR_OPERATE_TYPE;

//雷达操作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadarOperate(LLONG lLoginID, EM_RADAR_OPERATE_TYPE emType, void* pInBuf, void* pOutBuf, int nWaitTime);

#define NET_RADAR_MAX_NUM_ALARMPOINT    64               // 雷达报警点的最大数量

//点类型的掩码
typedef enum tagEM_RADAR_POINTTYPE
{
	EM_RADAR_POINTTYPE_UNKNOWN,                          // 未知
	EM_RADAR_POINTTYPE_ALARMPOINT,                       // 当前点是报警区的报警点
	EM_RADAR_POINTTYPE_LINKMONITORPOINT,                 // 当前点是正在被联动监控的点
	EM_RADAR_POINTTYPE_DISAPPEARTRACKPOINT,              // 当前点是消失的轨迹点
}EM_RADAR_POINTTYPE;

//点所指对象的类型的掩码
typedef enum tagEM_RADAR_OBJECTTYPE
{
	EM_RADAR_OBJECTTYPE_UNKNOWN,                         // 未识别目标
	EM_RADAR_OBJECTTYPE_PERSON,                          // 目标为人
	EM_RADAR_OBJECTTYPE_VEHICLE,                         // 目标为交通工具
	EM_RADAR_OBJECTTYPE_TREE,                            // 目标为树
	EM_RADAR_OBJECTTYPE_BUILIDING,                       // 目标为建筑物
	EM_RADAR_OBJECTTYPE_SCREEN,                          // 目标为屏幕
}EM_RADAR_OBJECTTYPE;

//单个雷达报警点信息
typedef struct tagNET_RADAR_ALARMPOINT_INFO
{
	EM_RADAR_POINTTYPE          emPointType;             // 点类型的掩码,该字段废弃,请不要使用,请使用nPointType
	int                         nPointType;              // 点类型的掩码
	//bit0：无效
	//bit1：当前点是消失的轨迹点
	//bit2：当前点是正在被联动监控的点
	//bit3：当前点是报警区的报警点
	//备注：点的状态可能有多个，例如值为0xC时，表示当前的点既是正在被联动监控的点，又是报警区的报警点
	int                         nRegionNumber;           // 当前点所属的防区编号,范围[0,10]([1,10]为防区编号,0表示当前点不属于任何一个防区)
	EM_RADAR_OBJECTTYPE         emObjectType;            // 点所指对象的类型的掩码
	int                         nTrackID;                // 点所属的轨迹号,范围[0,63]
	int                         nDistance;               // 当前点像素极坐标值-距离，实际长度扩大100倍的结果,单位米
	int                         nAngle;                  // 当前点像素极坐标值-角度，实际角度扩大100倍的结果，单位度
	int                         nSpeed;                  // 当前点速度，扩大100倍的结果，单位米/秒
	BYTE                        byReserved[512];         // 保留字节
}NET_RADAR_ALARMPOINT_INFO;

//上报的雷达报警点信息
typedef struct tagNET_RADAR_NOTIFY_ALARMPOINTINFO
{
	int                         nNumAlarmPoint;          // 雷达报警点的数量
	NET_RADAR_ALARMPOINT_INFO   stuAlarmPoint[NET_RADAR_MAX_NUM_ALARMPOINT];  // 雷达报警点信息
	int							nChannel;				 // 通道号
	BYTE                        byReserved[1020];        // 保留字节
}NET_RADAR_NOTIFY_ALARMPOINTINFO;

//雷达报警点信息回调函数指针
typedef void (CALLBACK *fRadarAlarmPointInfoCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_RADAR_NOTIFY_ALARMPOINTINFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

//订阅雷达的报警点信息入参(对应接口 CLIENT_AttachRadarAlarmPointInfo)
typedef struct tagNET_IN_RADAR_ALARMPOINTINFO
{
	DWORD                       dwSize;                  // 结构体大小
	fRadarAlarmPointInfoCallBack    cbAlarmPointInfo;    // 雷达报警点信息回调
	LDWORD                      dwUser;                  // 用户数据
	int							nChannel;				 // 通道号
}NET_IN_RADAR_ALARMPOINTINFO;

//订阅雷达的报警点信息出参(对应接口 CLIENT_AttachRadarAlarmPointInfo)
typedef struct tagNET_OUT_RADAR_ALARMPOINTINFO
{
	DWORD                       dwSize;                  // 结构体大小
}NET_OUT_RADAR_ALARMPOINTINFO;

//订阅雷达的报警点信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRadarAlarmPointInfo(LLONG lLoginID, const NET_IN_RADAR_ALARMPOINTINFO * pstInParam, NET_OUT_RADAR_ALARMPOINTINFO* pstOutParam, int nWaitTime);

//取消订阅雷达的报警点信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRadarAlarmPointInfo(LLONG lAttachHandle);

// 获取雷达联动的远程球机状态输入参数
typedef struct tagNET_IN_RADAR_GET_LINKSTATE
{
	DWORD						dwSize;					// 结构体大小
	int							nChannel;				// 通道号
	int							nSDLinkNum;				// 待查的联动设备ip个数（当个数为0时，会返回当前设备所有的联动设备状态）
	char						szSDLinkIP[MAX_RADAR_SD_NUM][32];//待查联动设备ip数组
}NET_IN_RADAR_GET_LINKSTATE;

// 联动设备状态
typedef enum tagNET_EM_RADAR_LINK_SD_STATE
{
	NET_EM_RADAR_LINK_SD_STATE_UNKNOWN = -1,					// 未知
	NET_EM_RADAR_LINK_SD_STATE_NORMAL,							// 正常
	NET_EM_RADAR_LINK_SD_STATE_TIMEOUT,							// 超时
	NET_EM_RADAR_LINK_SD_STATE_OFFLINE,							// 离线
	NET_EM_RADAR_LINK_SD_STATE_NOT_LINK,						// 未连接
}NET_EM_RADAR_LINK_SD_STATE;

// 联动设备状态信息
typedef struct tagNET_LINKSTATE_INFO
{
	char						szSDLinkIP[32];			// 联动设备ip
	NET_EM_RADAR_LINK_SD_STATE	emState;				// 联动设备状态
	int							nVirtualChannel;		// 虚拟视频通道号，用于雷达控多球,通道号1开始
	BYTE						byReserved[1020];		// 保留	
}NET_LINKSTATE_INFO;

// 获取雷达联动的远程球机状态输出参数
typedef struct tagNET_OUT_RADAR_GET_LINKSTATE
{
	DWORD						dwSize;					// 结构体大小
	int							nSDLinkNum;				// 联动设备个数
	NET_LINKSTATE_INFO			stuSDLinkState[MAX_RADAR_SD_NUM];// 联动设备状态信息
}NET_OUT_RADAR_GET_LINKSTATE;

// 待添加的远程联动设备连接信息
typedef struct tagNET_RADARLINKDEVICE_ADD_INFO
{
	char						szSDLinkIP[32];			 // 被控制的设备ip
	char						szUserName[128];		 // 用户名
	char						szPassword[32];			 // 密码
	int							nPort;					 // 服务端口
	BYTE						byReserved[316];		 // 保留
}NET_RADARLINKDEVICE_ADD_INFO;

// CLIENT_AddRadarLinkSD接口入参
typedef struct tagNET_IN_RADAR_ADD_RADARLINKSD
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 通道号
	NET_RADARLINKDEVICE_ADD_INFO	stuDevices[MAX_RADAR_SD_NUM];	// 联动球机数组
	int								nDevicesNum;					// 有效数据个数
}NET_IN_RADAR_ADD_RADARLINKSD;

// 错误码
typedef enum tagNET_EM_RADARLINKDEVICE_ADD_ERRORCODE
{
	EM_EM_RADARLINKDEVICE_ADD_UNKNOWN = -1,							// 未知
	EM_EM_RADARLINKDEVICE_ADD_SUCCESS = 0,							// 正常
	EM_EM_RADARLINKDEVICE_ADD_TIMEOUT,								// 超时
	EM_EM_RADARLINKDEVICE_ADD_ACCOUNTERROR,							// 用户名或者密码错误
	EM_EM_RADARLINKDEVICE_ADD_NOTSUPPORT,							// 设备不支持联动
}NET_EM_RADARLINKDEVICE_ADD_ERRORCODE;

// 添加联动球机接口返回的结果
typedef struct tagNET_RADARLINKDEVICE_ADD_RESULT
{
	NET_EM_RADARLINKDEVICE_ADD_ERRORCODE	emErrorCode;			// 错误码
	BYTE									byReserved[252];		// 保留
}NET_RADARLINKDEVICE_ADD_RESULT;

// CLIENT_AddRadarLinkSD接口出参
typedef struct tagNET_OUT_RADAR_ADD_RADARLINKSD
{
	DWORD							dwSize;							// 结构体大小
	int								nRetResultNum;					// 有效数据个数
	NET_RADARLINKDEVICE_ADD_RESULT	stuAddResult[MAX_RADAR_SD_NUM];	// 添加结果，下标对应入参中的设备信息
}NET_OUT_RADAR_ADD_RADARLINKSD;

// 待删除的远程联动设备信息
typedef struct tagNET_RADARLINKDEVICE_DEL_INFO
{
	char						szSDLinkIP[32];			 // 被控制的设备ip
	BYTE						byReserved[224];		 // 保留
}NET_RADARLINKDEVICE_DEL_INFO;

// CLIENT_DelRadarLinkSD接口入参
typedef struct tagNET_IN_RADAR_DEL_RADARLINKSD
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 通道号
	NET_RADARLINKDEVICE_DEL_INFO	stuDevices[MAX_RADAR_SD_NUM];	// 联动球机数组
	int								nDevicesNum;					// 有效数据个数,为0表示删除所有联动设备
}NET_IN_RADAR_DEL_RADARLINKSD;

// CLIENT_DelRadarLinkSD接口出参
typedef struct tagNET_OUT_RADAR_DEL_RADARLINKSD
{
	DWORD							dwSize;							// 结构体大小
}NET_OUT_RADAR_DEL_RADARLINKSD;

// CLIENT_RadarManualLocate接口入参
typedef struct tagNET_IN_RADAR_MANUAL_LOCATE
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 通道号
	NET_POINT						stuLocatePoint;					// 定位点的像素坐标
}NET_IN_RADAR_MANUAL_LOCATE;

// CLIENT_RadarManualLocate接口出参
typedef struct tagNET_OUT_RADAR_MANUAL_LOCATE
{
	DWORD							dwSize;							// 结构体大小
}NET_OUT_RADAR_MANUAL_LOCATE;

// 卡片行为
typedef enum tagNET_EM_RADAR_RFIDCARD_ACTION
{
	EM_RADAR_RFIDCARD_ACTION_UNKNOWN = 0,							// 未知
	EM_RADAR_RFIDCARD_ACTION_LEAVE,									// 卡片离开
	EM_RADAR_RFIDCARD_ACTION_ENTER,									// 卡片进入
}NET_EM_RADAR_RFIDCARD_ACTION;

// RFID卡片信息
typedef struct tagNET_RADAR_RFIDCARD_INFO
{
	char							szCardID[24];					// 卡片ID
	NET_EM_RADAR_RFIDCARD_ACTION	emCardAction;					// 卡片行为
	BYTE							byReserved[124];				// 保留字节
}NET_RADAR_RFIDCARD_INFO;

//上报的雷达RFID信息
typedef struct tagNET_RADAR_NOTIFY_RFIDCARD_INFO
{
	int							nChannel;
	int							nCardNum;
	NET_RADAR_RFIDCARD_INFO		stuCardInfo[256];		 // RFID卡片信息
	BYTE                        byReserved[1024];        // 保留字节
}NET_RADAR_NOTIFY_RFIDCARD_INFO;

//雷达RFID信息回调函数指针
typedef void (CALLBACK *fRadarRFIDCardInfoCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_RADAR_NOTIFY_RFIDCARD_INFO* pBuf, DWORD dwBufLen, void* pReserved, LDWORD dwUser);

// CLIENT_AttachRadarRFIDCardInfo接口入参
typedef struct tagNET_IN_ATTACH_RADAR_RFIDCARD_INFO
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 通道号
	fRadarRFIDCardInfoCallBack		cbRFIDCardInfo;					// 雷达RFIDCard信息回调
	LDWORD							dwUser;							// 用户数据
}NET_IN_ATTACH_RADAR_RFIDCARD_INFO;

// CLIENT_AttachRadarRFIDCardInfo接口出参
typedef struct tagNET_OUT_ATTACH_RADAR_RFIDCARD_INFO
{
	DWORD							dwSize;							// 结构体大小
}NET_OUT_ATTACH_RADAR_RFIDCARD_INFO;

// 获取雷达联动的远程球机状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRadarLinkSDState(LLONG lLoginID, const NET_IN_RADAR_GET_LINKSTATE * pstInParam, NET_OUT_RADAR_GET_LINKSTATE* pstOutParam, int nWaitTime);

// 用于雷达联动球机添加
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddRadarLinkSD(LLONG lLoginID, const NET_IN_RADAR_ADD_RADARLINKSD * pstInParam, NET_OUT_RADAR_ADD_RADARLINKSD* pstOutParam, int nWaitTime);

// 用于雷达联动球机删除
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelRadarLinkSD(LLONG lLoginID, const NET_IN_RADAR_DEL_RADARLINKSD * pstInParam, NET_OUT_RADAR_DEL_RADARLINKSD* pstOutParam, int nWaitTime);

// 手动定位功能，用于雷达控制球机云台转动用于定位
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RadarManualLocate(LLONG lLoginID, const NET_IN_RADAR_MANUAL_LOCATE * pstInParam, NET_OUT_RADAR_MANUAL_LOCATE* pstOutParam, int nWaitTime);

// 雷达订阅RFID卡片信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRadarRFIDCardInfo(LLONG lLoginID, const NET_IN_ATTACH_RADAR_RFIDCARD_INFO * pstInParam, NET_OUT_ATTACH_RADAR_RFIDCARD_INFO* pstOutParam, int nWaitTime);

// 雷达取消订阅RFID卡片信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRadarRFIDCardInfo(LLONG lAttachHandle);

//雷达区域检测事件(对应 DH_ALARM_RADAR_REGIONDETECTION)
typedef struct tagALARM_RADAR_REGIONDETECTION_INFO
{
	int                         nAction;                 // 事件动作1:Start 2:Stop
	NET_TIME_EX			        stuTime;				 // 事件发生的时间
	BYTE                	    byReserved[512];       	 // 保留字节 
}ALARM_RADAR_REGIONDETECTION_INFO;

//雷达地图尺寸配置(对应 NET_EM_CFG_RADAR_MAPPARA)
typedef struct tagNET_CFG_RADAR_MAPPARA_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	BYTE                        byReserved[4];           // 字节对齐
	NET_RADAR_PIXELLINE         stuPixelLine;            // 图片中线段的像素坐标
	double                      dDistance;               // 图片中线段代表的实际长度,单位米
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // 雷达在地图上的像素坐标
	double                      dRadarDirectionAngle;    // 雷达朝向配置,单位度
}NET_CFG_RADAR_MAPPARA_INFO;

// 校准点
typedef struct tagNET_RADAR_CALIBRATIONPOS
{
	NET_RADAR_PIXELPOINT        stuPixelPoint;           // 校准点的像素坐标
	double                      dPositionX;              // 水平角度,归一化到-1~1
	double                      dPositionY;              // 垂直角度,归一化到-1~1
	double                      dZoom;                   // 放大倍数,归一化到 0~1
	BYTE                	    byReserved[512];       	 // 保留字节 
}NET_RADAR_CALIBRATIONPOS;

// 校准参数
typedef struct tagNET_RADAR_CALIBRATION_PARAS
{
	int							nCalibrationPosNum;		 // 校准点个数
	BYTE                	    byReserved1[4];       	 // 字节对齐 
	NET_RADAR_CALIBRATIONPOS	stuCalibrationPos[4];	 // 校准点数组
	char						szSDLinkIP[32];			 // 被控制的设备ip
	double                      dLinkSDHeight;			 // 联动的球机安装高度，单位米
	double                      dTiltRecoupAngle;		 // 联动球机垂直补偿角
	BYTE                	    byReserved[1024];        // 保留字节 
}NET_RADAR_CALIBRATION_PARAS;

//雷球校准配置(对应 NET_EM_CFG_RADAR_CALIBRATION)
typedef struct tagNET_CFG_RADAR_CALIBRATION_INFO
{
	DWORD                       dwSize;									// 结构体大小
	int							nCalibrationParasNum;					// 校准参数组数
	NET_RADAR_CALIBRATION_PARAS	stuCalibrationParas[MAX_RADAR_SD_NUM];	// 校准参数
	double                      dInstallHeight;							// 安装高度，单位米
	double                      dSlopeAngle;							// 斜坡补偿角度
}NET_CFG_RADAR_CALIBRATION_INFO;

//雷达联动球机使能配置(对应 NET_EM_CFG_RADAR_LINKSD)
typedef struct tagNET_CFG_RADAR_LINKSD_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	BOOL                        bRadarLink;              // 雷达联动球机使能
}NET_CFG_RADAR_LINKSD_INFO;

#define NET_RADAR_MAX_NUM_RULELINE       10              // 规则线的最大数量
#define NET_RADAR_MAX_NUM_POLYGON         24             // 规则线顶点的最大数量

//雷达规则类型
typedef enum tagEM_RADAR_RULETYPE
{
	EM_RADAR_RULETYPE_UNKNOWN,                           // 未知
	EM_RADAR_RULETYPE_ALARM,                             // 预警
	EM_RADAR_RULETYPE_SHIELD,                            // 屏蔽
	EM_RADAR_RULETYPE_HIGHALARM,                         // 报警，高级别
}EM_RADAR_RULETYPE;

#define RADAR_TARGET_FILTER_HUMAN	0x01				 // 人
#define RADAR_TARGET_FILTER_CAR		0x02				 // 车
#define RADAR_TARGET_FILTER_ANIMAL	0x04				 // 动物

//规则线
typedef struct tagNET_RADAR_RULELINE
{
	char                        szName[DH_COMMON_STRING_128];// 规则名称,不能重名
	int                         nRegionNumber;               // 规则线编号,范围[1,10]
	BOOL                        bEnable;                     // 规则是否使能
	EM_RADAR_RULETYPE           emRuleType;                  // 规则类型,告警或者屏蔽类型
	DH_POINT		            stuPolygon[DH_MAX_POLYGON_NUM];		// 规则点,每个点依次表示规则线的顶点坐标
	int					        nPolygonPointNum;	         // 规则线顶点的个数,点的个数范围[3, 24]
	int							nTargetFilter;				 // 目标过滤 bit1:人, bit2:车, bit3:动物 配置使用|，校验使用&
	int							nAlarmOutNumber;			 // 关联的报警输出配置的编号，对应NET_RADAR_ANALYSERULE配置nAlarmOutNumber字段
	BYTE                        byReserved[504];             // 保留字节
}NET_RADAR_RULELINE;

//雷达规则线配置(对应 NET_EM_CFG_RADAR_RULELINE)
typedef struct tagNET_CFG_RADAR_RULELINE_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	int                         nNumRuleLine;            // 要配置的规则线数量
	NET_RADAR_RULELINE          stuRuleLine[NET_RADAR_MAX_NUM_RULELINE];   //规则线
}NET_CFG_RADAR_RULELINE_INFO;

// 报警联动配置
typedef struct tagNET_RADAR_ANALYSERULE
{
	char						szSDLinkIP[32];			 // 被控制的球机IP
	int							nAlarmOutNumber;		 // 报警配置编号，编号唯一
	BOOL                        bEnable;                 // 报警使能
	NET_CFG_ALARM_MSG_HANDLE    stuEventHandler;         // 报警联动配置
	BYTE                        byReserved[1024];        // 保留字节
}NET_RADAR_ANALYSERULE;

//雷达报警联动配置(对应 NET_EM_CFG_RADAR_ANALYSERULE)
typedef struct tagNET_CFG_RADAR_ANALYSERULE_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	int							nAnalyseRuleNum;		 // 报警联动配置个数
	NET_RADAR_ANALYSERULE		stuAnalyseRules[MAX_RADAR_SD_NUM]; // 报警联动配置数组
}NET_CFG_RADAR_ANALYSERULE_INFO;

//跟踪切换模式
typedef enum tagEM_RADAR_TRACKSWITCHMODE
{
	EM_RADAR_TRACKSWITCHMODE_UNKNOWN,                    // 未知
	EM_RADAR_TRACKSWITCHMODE_ROTATION,                   // 轮巡
	EM_RADAR_TRACKSWITCHMODE_TIMEFIRST,                  // 时间优先
	EM_RADAR_TRACKSWITCHMODE_DISTANCEFIRST,              // 距离优先
}EM_RADAR_TRACKSWITCHMODE;

//雷达跟踪全局配置(对应 NET_EM_CFG_RADAR_TRACKGLOBALCONFIG)
typedef struct tagNET_CFG_RADAR_TRACKGLOBALCONFIG_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	BOOL                        bSectorDisable;          // 防区隐藏使能
	int                         nTrajectoryTime;         // 轨迹时长,单位秒,范围[3,30]
	int                         nTrackSwitchTime;        // 跟踪切换时间,单位秒,范围[1,15]
	EM_RADAR_TRACKSWITCHMODE    emTrackSwitchMode;       // 跟踪切换模式
}NET_CFG_RADAR_TRACKGLOBALCONFIG_INFO;

// 雷达场景类型
typedef enum tagNET_EM_RADAR_SCENE_TYPE
{
	NET_EM_RADAR_SCENE_UNKNOWN = 0,						// 未知
	NET_EM_RADAR_SCENE_DEFAULT,							// 默认
	NET_EM_RADAR_SCENE_SHRUB,							// 灌木
	NET_EM_RADAR_SCENE_ROOMY,							// 宽敞
	NET_EM_RADAR_SCENE_CUSTOM,							// 自定义
}NET_EM_RADAR_SCENE_TYPE;

// 雷达场景
typedef struct tagNET_RADAR_SCENE
{
	NET_EM_RADAR_SCENE_TYPE emType;						// 雷达场景类型
	BYTE					byReserved[508];			// 保留
}NET_RADAR_SCENE;

// 结构信息配置
typedef struct tagNET_RADAR_STRUCTURED
{
	BOOL					bEnable;					// 结构信息显示使能
	BYTE					byReserved[508];			// 保留
}NET_RADAR_STRUCTURED;

// 雷达发射功率
typedef struct tagNET_RADAR_CAPACITY
{
	int						nPower;						// 功率 1:50米; 2:100米; 3:150米
	BYTE					byReserved[508];			// 保留
}NET_RADAR_CAPACITY;

// 雷达信道设置
typedef struct tagNET_RADAR_RADARCHANNEL
{
	int						nRoute;						// 信道选择, 1: 信道1   2:信道2
	BYTE					byReserved[508];			// 保留
}NET_RADAR_RADARCHANNEL;

// 雷达控球跟踪画面占比
typedef struct tagNET_RADAR_TARGETRATIO
{
	int						nRatio;						// 画面占比比例倒数
	BYTE					byReserved[60];				// 保留
}NET_RADAR_TARGETRATIO;

//雷达功能设置(对应 NET_EM_CFG_RADAR_RADARPARA)
typedef struct tagNET_CFG_RADAR_RADARPARA_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	NET_RADAR_SCENE				stuScene;			     // 雷达场景
	NET_RADAR_STRUCTURED		stuStructured;			 // 结构信息配置
	NET_RADAR_CAPACITY			stuCapacity;			 // 雷达发射功率
	NET_RADAR_RADARCHANNEL		stuRadarChannel;		 // 雷达信道设置
	NET_RADAR_TARGETRATIO		stuTargetRatio;			 // 雷达控球跟踪画面占比
}NET_CFG_RADAR_RADARPARA_INFO;

//远程球机联动使能信息
typedef struct tagNET_REMOTESDLINK_INFO
{
	char						szSDLinkIP[32];			 // 被控制的设备ip
	BOOL						bRadarLink;				 // 联动使能
	BYTE						byReserved[476];		 // 保留
}NET_REMOTESDLINK_INFO;

//雷达远程球机联动使能配置(对应 NET_EM_CFG_RADAR_REMOTESDLINK)
typedef struct tagNET_CFG_RADAR_REMOTESDLINK_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	int							nLinkNum;				 // 联动个数
	NET_REMOTESDLINK_INFO		stuLinkInfos[MAX_RADAR_SD_NUM];// 远程球机联动使能信息
}NET_CFG_RADAR_REMOTESDLINK_INFO;

//远程联动设备信息
typedef struct tagNET_RADARLINKDEVICE_INFO
{
	char						szSDLinkIP[32];			 // 设备ip
	char						szVendor[32];			 // 设备来源
	int							nPort;					 // 服务端口(已废弃,请使用CLIENT_AddRadarLinkSD)
	char						szUserName[128];		 // 用户名(已废弃,请使用CLIENT_AddRadarLinkSD)
	char						szPassword[32];			 // 密码(已废弃,请使用CLIENT_AddRadarLinkSD)
	char						szDeviceType[32];		 // 设备类型
	char						szDeviceName[128];		 // 设备名称
	BYTE						byReserved[124];		 // 保留
}NET_RADARLINKDEVICE_INFO;

//雷达远程联动设备配置(对应 NET_EM_CFG_RADAR_RADARLINKDEVICE)
typedef struct tagNET_CFG_RADAR_RADARLINKDEVICE_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	int							nDevNum;				 // 球机个数
	NET_RADARLINKDEVICE_INFO	stuDevInfo[MAX_RADAR_SD_NUM]; // 远程设备信息
}NET_CFG_RADAR_RADARLINKDEVICE_INFO;

// OSD 叠加位置
typedef enum tagNET_EM_OSD_AREA
{
	NET_EM_OSD_AREA_UNKNOWN,							 // 未知
	NET_EM_OSD_AREA_LEFT_TOP,							 // 左上
	NET_EM_OSD_AREA_MID_TOP,							 // 中上
	NET_EM_OSD_AREA_RIGHT_TOP,							 // 右上
	NET_EM_OSD_AREA_MID_LEFT,							 // 中左
	NET_EM_OSD_AREA_MID_RIGHT,							 // 中右
	NET_EM_OSD_AREA_LEFT_BOTTOM,						 // 左下
	NET_EM_OSD_AREA_MID_BOTTOM,							 // 中下
	NET_EM_OSD_AREA_RIGHT_BOTTOM,						 // 右下
}NET_EM_OSD_AREA;

//雷达地图OSD叠加配置(对应 NET_EM_CFG_RADAR_MAPOSDPARA)
typedef struct tagNET_CFG_RADAR_MAPOSDPARA_INFO
{
	DWORD                       dwSize;                  // 结构体大小
	NET_EM_OSD_AREA				emOSDArea;				 // 叠加位置
}NET_CFG_RADAR_MAPOSDPARA_INFO;

/////////////////////////////////雷球联动接口 end////////////////////////////////

#define NET_CFG_MAX_CTRLTYPE_NUM       16            // 最大道闸控制方式
#define NET_MAX_ALL_SNAP_CAR_COUNT	   32			 // 所有车开闸种类个数

// 道闸控制方式枚举
typedef enum tagNET_EM_CFG_TRAFFICSTROBE_CTRTYPE
{
	NET_EM_CFG_CTRTYPE_UNKNOWN = 0,                 // 未定义
	NET_EM_CFG_CTRTYPE_TRAFFICTRUSTLIST,            // 通过白名单控制是否开闸；只有白名单内车辆才开闸
	NET_EM_CFG_CTRTYPE_ALLSNAPCAR,                  // 针对所有抓拍车辆都开闸
	NET_EM_CFG_CTRTYPE_ORDER,                       // 通过上层下发的命令开闸
} NET_EM_CFG_TRAFFICSTROBE_CTRTYPE;

// 所有车开闸种类
typedef enum tagNET_EM_CFG_ALL_SNAP_CAR
{
	NET_EM_CFG_ALL_SNAP_CAR_UNKNOWN,				// 未知开闸种类
	NET_EM_CFG_ALL_SNAP_CAR_PLATE,					// 所有有牌车车辆
	NET_EM_CFG_ALL_SNAP_CAR_NOPLATE,				// 所有无牌车车辆
}NET_EM_CFG_ALL_SNAP_CAR;

// 道闸常开配置
typedef struct tagNET_CFG_STATIONARY_OPEN
{
	BOOL							bEnable;			// 使能
	NET_CFG_TIME_SCHEDULE			stTimeShecule;		// 常开模式执行时间段
}NET_CFG_STATIONARY_OPEN;

// 道闸配置信息(对应 NET_EM_CFG_TRAFFICSTROBE 命令)
typedef struct tagNET_CFG_TRAFFICSTROBE_INFO
{
	DWORD								dwSize;										// 结构体大小
	BOOL								bEnable;									// 使能
	int									nCtrlTypeCount;								// 道闸控制方式个数
	NET_EM_CFG_TRAFFICSTROBE_CTRTYPE    emCtrlType[NET_CFG_MAX_CTRLTYPE_NUM];		// 道闸控制方式
	int									nAllSnapCarCount;							// 所有车开闸种类个数
	NET_EM_CFG_ALL_SNAP_CAR				emAllSnapCar[NET_MAX_ALL_SNAP_CAR_COUNT];	// 所有车开闸种类	
	NET_ALARM_MSG_HANDLE				stuEventHandler;							// 开启道闸联动参数
	NET_ALARM_MSG_HANDLE				stuEventHandlerClose;						// 关闭道闸联动参数
	char								szOrderIP[DH_MAX_IPADDR_EX_LEN];			// 负责命令开闸的平台IP
	NET_EM_CFG_TRAFFICSTROBE_CTRTYPE	emCtrlTypeOnDisconnect;						// 平台IP与设备断开连接后，设备采用的开闸方式
	NET_CFG_STATIONARY_OPEN				stuStationaryOpen;							// 道闸常开配置
}NET_CFG_TRAFFICSTROBE_INFO;

// CLIENT_DialRecognitionAddTask接口入参
typedef struct tagNET_IN_DIALRECOGNITION_ADD_TASK
{
	DWORD				dwSize;				// 结构体大小
	unsigned int		nChannel;			// 通道号
	unsigned int		nPresetID;			// 预置点ID,如果是普通IPC,只能设置为0,否则添加任务会失败
}NET_IN_DIALRECOGNITION_ADD_TASK;

// 添加结果
typedef enum tagEM_ADD_RESULT
{
	EM_ADD_RESULT_UNKNOWN,			// 未知错误
	EM_ADD_RESULT_SUCCESS,			// 添加成功
	EM_ADD_RESULT_PRESET_ERROR,		// 预置点错误
}EM_ADD_RESULT;

// CLIENT_DialRecognitionAddTask接口出参
typedef struct tagNET_OUT_DIALRECOGNITION_ADD_TASK
{
	DWORD				dwSize;								// 结构体大小
	EM_ADD_RESULT		emAddResult;						// 添加结果
	char				szTaskID[MAX_TASK_ID_LEN];			// 任务ID,只有在emAddResult为EM_ADD_RESULT_SUCCESS时有效
}NET_OUT_DIALRECOGNITION_ADD_TASK;

// 添加仪表识别任务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DialRecognitionAddTask(LLONG lLoginID, const NET_IN_DIALRECOGNITION_ADD_TASK* pInParam, NET_OUT_DIALRECOGNITION_ADD_TASK* pOutParam, int nWaitTime);

// 当前任务处理状态
typedef enum tagEM_CURRENT_TASK_STATE
{
	EM_CURRENT_TASK_STATE_UNKNWON,			// 未知
	EM_CURRENT_TASK_STATE_FAILED,			// 任务处理失败
	EM_CURRENT_TASK_STATE_SUCCEEDED,		// 任务处理成功
}EM_CURRENT_TASK_STATE;

// 错误码
typedef enum tagEM_ERROR_CODE_TYPE
{
	EM_ERROR_CODE_TYPE_UNKNOWN,				// 未知错误
	EM_ERROR_CODE_TYPE_NORMAL,				// 正常
	EM_ERROR_CODE_TYPE_GET_PICTURE_ERROR,	// 图片获取失败
	EM_ERROR_CODE_TYPE_ALGO_ERROR,			// 算法错误
}EM_ERROR_CODE_TYPE;

// 仪表类型
typedef enum tagEM_INSTRUMENT_TYPE
{
	EM_INSTRUMENT_TYPE_UNKNOWN,			// 未知
	EM_INSTRUMENT_TYPE_STATE,			// 状态识别类型
	EM_INSTRUMENT_TYPE_STATEMATCH,		// 状态匹配类型
	EM_INSTRUMENT_TYPE_METER,			// 指针式表计类型
	EM_INSTRUMENT_TYPE_CHAR,			// 数字识别类型
	EM_INSTRUMENT_TYPE_OIL,				// 油表类型
	EM_INSTRUMENT_TYPE_SWIIDEN,			// 开关标识
	EM_INSTRUMENT_TYPE_LIGHT,			// 指示灯类型
	EM_INSTRUMENT_TYPE_SWITCH,			// 室内开关类型
	EM_INSTRUMENT_TYPE_APPEARANCE,		// 外观检测类型
}EM_INSTRUMENT_TYPE;

// 图片类型
typedef enum tagEM_PIC_TYPE
{
	EM_PIC_TYPE_UNKNOWN = -1,		// 未知
	EM_PIC_TYPE_ALGORITHMICALLY_PROCESSED,			// 算法处理后的图片
}EM_PIC_TYPE;

// 图片信息 
typedef struct tagNET_IMAGE_INFO
{
	EM_PIC_TYPE			emPicType;							// 图片类型
	unsigned int		nOffset;							// 在二进制数据块中的偏移
	unsigned int		nLength;							// 图片大小,单位:字节
	char				szFilePath[MAX_FILE_PATH_LEN];		// 图片路径
	BYTE				byReserved[1024];					// 预留字节
}NET_IMAGE_INFO;

// 节点信息
typedef struct tagNET_NODE_INFO
{
	unsigned int			nChannel;									// 视频通道号
	unsigned int			nPresetID;									// 预置点ID
	EM_INSTRUMENT_TYPE		emInstrumentType;							// 仪表类型
	NET_IMAGE_INFO			stuImgaeInfo[MAX_IMAGE_INFO_NUM];			// 图片信息
	int						nRetImageInfoNum;							// 返回的图片信息个数
	char					szDialResult[MAX_DIAL_RESULT_LEN];			// 分析结果字符串
}NET_NODE_INFO;

// 任务状态结果
typedef struct tagNET_TASK_STATE
{
	char					szTaskID[MAX_TASK_ID_LEN];			// 任务ID
	EM_CURRENT_TASK_STATE	emTaskState;						// 当前任务处理状态
	EM_ERROR_CODE_TYPE		emErrorCode;						// 错误码
	NET_NODE_INFO			stuNodeInfo;						// 节点信息,当emTaskState为EM_CURRENT_TASK_STATE_SUCCEEDED时返回
}NET_TASK_STATE;

// 任务状态结果回调函数原形，lAttachHandle 是 CLIENT_AttachDialRecognitionTaskProc 返回值
typedef void (CALLBACK *fTaskStateCallback) (LLONG lAttachHandle, NET_TASK_STATE* pBuf, BYTE *pBuffer, DWORD dwBufSize, LDWORD dwUser);

// CLIENT_AttachDialRecognitionTaskProc接口入参
typedef struct tagNET_IN_ATTACH_TASK_PROC
{
	DWORD									dwSize;								// 结构体大小
	BYTE									byReserved[4];						// 预留对齐字节
	fTaskStateCallback						cbTaskState;						// 任务状态结果回调
	LDWORD									dwUser;								// 用户数据  
}NET_IN_ATTACH_TASK_PROC;

// CLIENT_AttachDialRecognitionTaskProc接口出参
typedef struct tagNET_OUT_ATTACH_TASK_PROC
{
	DWORD									dwSize;								// 结构体大小
}NET_OUT_ATTACH_TASK_PROC;

// 注册仪表任务状态
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachDialRecognitionTaskProc(LLONG lLoginID, const NET_IN_ATTACH_TASK_PROC* pInParam, NET_OUT_ATTACH_TASK_PROC* pOutParam, int nWaitTime);

// 取消注册仪表任务状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachDialRecognitionTaskProc(LLONG lAttachHandle);

// 本地实体证书类型
typedef enum tagEM_LOCAL_CERTIFICATE_TYPE
{
	EM_LOCAL_CERTIFICATE_TYPE_UNKNOWN,				// 未知
	EM_LOCAL_CERTIFICATE_TYPE_IDENTITY_AUTH_CERT,   // 供身份认证使用的本地实体证书
	EM_LOCAL_CERTIFICATE_TYPE_DATA_AUTH_CERT,		// 供信令及码流数据签名使用的本地实体证书
}EM_LOCAL_CERTIFICATE_TYPE;

// 国密特定网络类型
typedef enum tagEM_NETWORK_TYPE
{
	EM_NETWORK_TYPE_PUBLIC_SECURITY_INFO_NETWORK,		// 公安信息网
	EM_NETWORK_TYPE_VIDEO_PRIVATE_NETWORK,				// 视频专网
}EM_NETWORK_TYPE;

// 证书管理类型
typedef enum tagEM_DIGITAL_CERTIFICATE_TYPE
{
	EM_DIGITAL_CERTIFICATE_TYPE_UNKNOWN,			// 未知
	EM_DIGITAL_CERTIFICATE_TYPE_GM,					// 国密类型
	EM_DIGITAL_CERTIFICATE_TYPE_GENERAL,			// 通用类型

	EM_DIGITAL_CERTIFICATE_TYPE_MAX,				// 枚举最大值,若增加枚举,则在这之前增加
}EM_DIGITAL_CERTIFICATE_TYPE;

// CLIENT_GetCertReqInfo接口入参 
typedef struct tagNET_IN_GET_CERT_REQINFO
{	
	DWORD						dwSize;					// 结构体大小
	EM_LOCAL_CERTIFICATE_TYPE   emLocalCertType;		// 本地实体证书类型
	int							nForm;					// 请求文件的类型,0表示PKCS#10,默认为0
	char						szCountry[MAX_COUNTRY_CODE_LEN];		// 证书持有者所在国家代号
	char						szProvince[MAX_PROVINCE_CODE_LEN];		// 证书持有者所在省份代号
	char						szCity[MAX_CITY_CODE_LEN];				// 证书持有者所在城市代号
	char						szArea[MAX_AREA_CODE_LEN];				// 证书持有者所在区域代号
	EM_NETWORK_TYPE				emSpecificNetworkType;					// 国密特定网络类型
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;				// 证书管理类型 
	char						szCommonName[160];						// 使用者名称
	char						szOrganization[64];						// 组织名称
	char						szOrganizationUnit[64];					// 组织单元
}NET_IN_GET_CERT_REQINFO;

// CLIENT_GetCertReqInfo接口出参 
typedef struct tagNET_OUT_GET_CERT_REQINFO
{	
	DWORD						dwSize;									// 结构体大小
	int							nReqInfoLen;							// 返回的请求文件实际大小
	char						szReqInfo[MAX_REQ_INFO_LEN];			// 返回的请求文件
	char						szSigInfo[1024];						// 证书文件签名
	char						szSigAlg[64];							// 签名算法
	char						szCACertSN[40];							// 证书SN号
	char						szIssuer[512];							// 颁发者信息
}NET_OUT_GET_CERT_REQINFO;

// 获取制作证书时的请求文件,pstInParam和pstOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCertReqInfo(LLONG lLoginID, NET_IN_GET_CERT_REQINFO *pstInParam, NET_OUT_GET_CERT_REQINFO *pstOutParam, int nWaitTime);

// 证书类型
typedef enum tagEM_CERT_TYPE
{
	EM_CERT_TYPE_UNKNWON,					// 未知
	EM_CERT_TYPE_CA_CERT,					// 根级CA证书
	EM_CERT_TYPE_ADMIN_CERT,				// 本地管理员登录证书IdentityAuthCert
	EM_CERT_TYPE_IDENTITY_AUTH_CERT,		// 本地实体证书, 身份认证使用
	EM_CERT_TYPE_DATA_AUTH_CERT,	     	// 本地实体证书,信令及码流数据签名使用
	EM_CERT_TYPE_REMOTE_IDENTITY_AUTH_CERT,	// 远端实体证书, 身份认证使用(仅过检时使用)
	EM_CERT_TYPE_REMOTE_DATA_AUTH_CERT,		// 远端实体证书,信令及码流数据签名使用(仅过检时使用)
	EM_CERT_TYPE_MAX,						// 枚举最大值,以后再增加枚举往EM_CERT_TYPE_MAX前加
}EM_CERT_TYPE;

// 证书使用的服务列表
typedef enum tagEM_CERT_SERVER_NAME
{
	EM_CERT_SERVER_NAME_GENERAL,				// General
	EM_CERT_SERVER_NAME_802_1X,					// 802.1x
	EM_CERT_SERVER_NAME_HTTPS,					// HTTP over ssl/tls

	EM_CERT_SERVER_NAME_MAX,					// 枚举最大值,以后再增加枚举往EM_SERVER_NAME_MAX前增加
}EM_CERT_SERVER_NAME;

// CLIENT_ImportCert 接口入参
typedef struct tagNET_IN_IMPORT_CERT
{
	DWORD					dwSize;						// 结构体大小
	EM_CERT_TYPE			emCertType;					// 证书类型 
	char*					pszCert;					// 证书内容,由用户申请内存,大小为nCertLen
	int						nCertLen;					// 证书内容实际长度,不能超过5300个字节	
	BOOL					bActiveCert;				// 是否有激活证书,当emDigitalCertificateType为EM_DIGITAL_CERTIFICATE_TYPE_GENERAL时有效
	char					szUserName[64];				// 管理员用户,当emCertType为EM_CERT_TYPE_ADMIN_CERT时有效
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;	// 证书管理类型 
	int						nKeyLen;					// 与证书对应的私钥的实际长度,不能超过8192个字节
	char*					pszKey;						// 与证书对应的私钥,由用户申请内存,大小为nKeyLen,当emDigitalCertificateType为EM_DIGITAL_CERTIFICATE_TYPE_GENERAL时有效
	char					szKeyPassword[64];			// 密钥文件加密密钥,当emDigitalCertificateType为EM_DIGITAL_CERTIFICATE_TYPE_GENERAL时有效
	int						nKeyPasswordLen;			// 密钥文件加密密钥的实际长度
	EM_CERT_SERVER_NAME		emServerNames[8];			// 证书使用的服务列表,当emDigitalCertificateType为EM_DIGITAL_CERTIFICATE_TYPE_GENERAL时有效
														// General和其他服务互斥,如果需要下发General,则nServerNameNum为1,emServerNames[0]=EM_CERT_SERVER_NAME_GENERAL
	int						nServerNameNum;				// 实际的证书使用的服务列表个数									
}NET_IN_IMPORT_CERT;

// 支持证书链信息
typedef struct tagNET_SUPPORT_CERT_LIST_INFO
{
	EM_CERT_TYPE			emCertType;					// 证书类型
	NET_TIME				stuEffectiveDate;			// 证书生效日期
	NET_TIME				stuExpirationDate;			// 证书失效日期
	char					szCertSN[40];				// 证书序列号
	char					szDeviceIdentifier[160];	// 设备标识
	char					szRealCertSN[80];			// 证书真实序列号
	BYTE					byReserved[944];			// 预留字节
}NET_SUPPORT_CERT_LIST_INFO;

// CLIENT_ImportCert 接口出参
typedef struct tagNET_OUT_IMPORT_CERT
{
	DWORD							dwSize;							// 结构体大小
	int								nRetSupportCertListNum;			// 返回的支持证书链个数
	NET_SUPPORT_CERT_LIST_INFO		stuSupportCertList[8];			// 支持证书链信息
}NET_OUT_IMPORT_CERT;

// 导入已制作的数字证书,pstInParam和pstOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportCert(LLONG lLoginID, NET_IN_IMPORT_CERT *pstInParam, NET_OUT_IMPORT_CERT *pstOutParam, int nWaitTime);

// CLIENT_ImportCRL接口入参
typedef struct tagNET_IN_IMPORT_CRL
{
	DWORD				dwSize;						// 结构体大小
	int					nCRLLen;					// CRL内容实际长度，大小不能超过5300个字节
	char*				pszCRL;						// CRL内容,由用户申请内存,大小为nCRLLen
	EM_DIGITAL_CERTIFICATE_TYPE	 emDigitalCertificateType;	// 证书管理类型
	BYTE				byReserved[4];						// 预留对齐字节
}NET_IN_IMPORT_CRL;

// CLIENT_ImportCRL接口出参
typedef struct tagNET_OUT_IMPORT_CRL
{
	DWORD				dwSize;						// 结构体大小
}NET_OUT_IMPORT_CRL;

// 导入已制作的证书吊销列表,pstInParam和pstOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ImportCRL(LLONG lLoginID, NET_IN_IMPORT_CRL *pstInParam, NET_OUT_IMPORT_CRL *pstOutParam, int nWaitTime);

// 协议名称
typedef enum tagEM_PROTOCOL_NAME
{
	EM_PROTOCOL_NAME_UNKNOWN,		// 未知		
	EM_PROTOCOL_NAME_GB28181,		// Gb28181
	EM_PROTOCOL_NAME_MAX,			// 最大值
}EM_PROTOCOL_NAME;

// CLIENT_IntervideoManagerGetVersion接口入参
typedef struct tagNET_IN_GET_VERSION
{
	DWORD				dwSize;					// 结构体大小
	EM_PROTOCOL_NAME	emProtocolName;			// 协议名称			
}NET_IN_GET_VERSION;

// CLIENT_IntervideoManagerGetVersion接口出参
typedef struct tagNET_OUT_GET_VERSION
{
	DWORD				dwSize;													// 结构体大小
	char				szGB28181Version[MAX_GB28181_PROTOCOL_VERSION];			// GB28181协议版本
}NET_OUT_GET_VERSION;

// 获取协议版本,pstInParam和pstOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_IntervideoManagerGetVersion(LLONG lLoginID, NET_IN_GET_VERSION *pstInParam, NET_OUT_GET_VERSION *pstOutParam, int nWaitTime);

// CLIENT_NASFileSetUserAuthInfo接口入参
typedef struct tagNET_IN_SET_USER_AUTH_INFO
{
	DWORD			dwSize;										// 结构体大小
	char			szPassword[DH_COMMON_STRING_128];			// 密码
	char			szPasswordHint[DH_COMMON_STRING_128];		// 密码提示问题
	char			szPhoneNo[DH_COMMON_STRING_32];				// 手机号,可选
	char			szEmail[DH_COMMON_STRING_128];				// 邮箱,可选
}NET_IN_SET_USER_AUTH_INFO;

// CLIENT_NASFileSetUserAuthInfo接口出参
typedef struct tagNET_OUT_SET_USER_AUTH_INFO
{
	DWORD			dwSize;										// 结构体大小
}NET_OUT_SET_USER_AUTH_INFO;

// 配置隐私空间信息,pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileSetUserAuthInfo(LLONG lLoginID, const NET_IN_SET_USER_AUTH_INFO* pInParam, NET_OUT_SET_USER_AUTH_INFO* pOutParam, int nWaitTime);

// CLIENT_NASFileModifyPassword接口入参
typedef struct tagNET_IN_MODIFY_PASSWORD
{
	DWORD			dwSize;										// 结构体大小
	char			szOldPassword[DH_COMMON_STRING_128];		// 旧密码
	char			szNewPassword[DH_COMMON_STRING_128];		// 新密码
	char			szPasswordHint[DH_COMMON_STRING_128];		// 密码提示问题
}NET_IN_MODIFY_PASSWORD;

// CLIENT_NASFileModifyPassword接口出参
typedef struct tagNET_OUT_MODIFY_PASSWORD
{
	DWORD			dwSize;										// 结构体大小
}NET_OUT_MODIFY_PASSWORD;

// 修改隐私空间密码,pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileModifyPassword(LLONG lLoginID, const NET_IN_MODIFY_PASSWORD* pInParam, NET_OUT_MODIFY_PASSWORD* pOutParam, int nWaitTime);

// CLIENT_NASFileAuthenticate接口入参
typedef struct tagNET_IN_AUTHENTICATE
{
	DWORD			dwSize;									// 结构体大小
	char			szPassword[DH_COMMON_STRING_128];		// 验证密码
}NET_IN_AUTHENTICATE;

// CLIENT_NASFileAuthenticate接口出参
typedef struct tagNET_OUT_AUTHENTICATE
{
	DWORD			dwSize;										// 结构体大小
}NET_OUT_AUTHENTICATE;

// 鉴权密码功能,pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NASFileAuthenticate(LLONG lLoginID, const NET_IN_AUTHENTICATE* pInParam, NET_OUT_AUTHENTICATE* pOutParam, int nWaitTime);

//扩展模块类型
typedef enum tagEM_EXMODULE_TYPE
{
	EM_EXMODULE_TYPE_UNKNOWN,			//未知
	EM_EXMODULE_TYPE_M_BUS,				//M-BUS
	EM_EXMODULE_TYPE_RS_485,			//RS-485
}EM_EXMODULE_TYPE;

//CLIENT_GetExModuleInfo接口入参(对应枚举NET_EM_GET_EXMODULE_INFO_DETAIL)
typedef struct tagNET_IN_GETEXMODULEDETAIL
{
	DWORD 				dwSize;					//结构体大小
	EM_EXMODULE_TYPE 	emType;					//扩展模块类型
	int					nAddr;					//扩展模块编号
}NET_IN_GETEXMODULEDETAIL;

//CLIENT_GetExModuleInfo接口出参(对应枚举NET_EM_GET_EXMODULE_INFO_DETAIL)
typedef struct tagNET_OUT_GETEXMODULEDETAIL
{
	DWORD					dwSize;					//结构体大小
	int						nAlarmInChannelCount;	//报警输入通道号数量
	int						alarmInChannels[16];		//报警输入对应的通道号。模块报警输入对应的通道号，没有映射时为-1
	int						nAlarmOutChannelCount;	//报警输出通道号数量
	int						alarmOutChannels[16];	//报警输出对应的通道号。模块报警输出对应的通道号，没有映射时为-1
}NET_OUT_GETEXMODULEDETAIL;

typedef enum tagNET_EM_GET_EXMODULE_INFO
{
	NET_EM_GET_EXMODULE_INFO_UNKNOWN,				//未知
	NET_EM_GET_EXMODULE_INFO_DETAIL,				//获取扩展模块详细信息。（入参NET_IN_GETEXMODULEDETAIL，出参NET_OUT_GETEXMODULEDETAIL）
	NET_EM_GET_EXMODULE_INFO_STATE,					//获取扩展模块状态。（入参NET_IN_EXMODULE_INFO，出参NET_OUT_EXMODULE_INFO_ALL）
}NET_EM_GET_EXMODULE_INFO;
//获取扩展模块信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetExModuleInfo(LLONG lLoginID, NET_EM_GET_EXMODULE_INFO emType,const void *pstuInParam, void *pstuOutParam, int nWaitTime);

// CLIENT_GetNationInfo 入参
typedef struct tagNET_IN_GET_NATIONINFO
{
	DWORD                       dwSize;                                     // 结构体大小
}NET_IN_GET_NATIONINFO;

#define NET_COUNTRYZONE_LENGTH 64                                           // 国家/地区名称长度
#define NET_COUNTRYABBR_LENGTH 4                                            // 国家/地区简称长度
#define NET_LANGUAGE_LENGTH 12                                              // 默认语言长度
#define NET_TIMEZONE_LENGTH 80                                              // 默认时区值描述长度

typedef struct tagNET_NATION_INFO{
	char                        szCountry[NET_COUNTRYZONE_LENGTH];          // 国家/地区名称,符合ISO3166标准
	char                        szAbbreviation[NET_COUNTRYABBR_LENGTH];     // 国家/地区简称,符合ISO3166标准
	char                        szLanguage[NET_LANGUAGE_LENGTH];            // 默认语言
	EM_VIDEO_STANDARD           emVideoStandard;                            // 默认视频制式
	char                        szTimeZoneDesc[NET_TIMEZONE_LENGTH];        // 默认时区值描述
	BYTE                        byReserved[128];                            // 保留字节
}NET_NATION_INFO;

// CLIENT_GetNationInfo 出参
typedef struct tagNET_OUT_GET_NATIONINFO
{
	DWORD                       dwSize;                                     // 结构体大小
	int                         nNationInfoCnt;                             // 国家的个数
	NET_NATION_INFO             arrNationInfo[300];                         // 国家/地区相关信息，是个数组
}NET_OUT_GET_NATIONINFO;

// 获取设备国家语言制式等对应表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetNationInfo(LLONG lLoginID, NET_IN_GET_NATIONINFO* pInParam, NET_OUT_GET_NATIONINFO* pOutParam, int waittime);

// CLIENT_GetLanguageList 入参
typedef struct tagNET_IN_GET_LANGUAGELIST
{
	DWORD                       dwSize;                                         // 结构体大小
}NET_IN_GET_LANGUAGELIST;

#define NET_LANGUAGELIST_LENGTH 12                                              // 语言列表的长度			

// CLIENT_GetLanguageList 出参
typedef struct tagNET_OUT_GET_LANGUAGELIST
{
	DWORD                       dwSize;                                         // 结构体大小
	int                         nLangueListCnt;                                 // 语言列表的个数
	char                        arrLanguageList[50][NET_LANGUAGELIST_LENGTH];   // 语言列表是个数组							
}NET_OUT_GET_LANGUAGELIST;

// 获取设备支持的语言列表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLanguageList(LLONG lLoginID, NET_IN_GET_LANGUAGELIST* pInParam, NET_OUT_GET_LANGUAGELIST* pOutParam, int waittime);

#define MAX_SCENEID_LEN 32			//场景ID最大长度

// CLIENT_ConfirmSceneChangeResult 输入参数  
typedef struct tagNET_IN_CONFIRMSCENECHANGERESULT_INFO
{
	DWORD 	dwSize;								// 结构体大小
	char	szSceneID[MAX_SCENEID_LEN];			// 场景ID
	BOOL 	bResult;							// 处理结果: TRUE表示成功  FALSE表示失败
}NET_IN_CONFIRMSCENECHANGERESULT_INFO;

// CLIENT_ConfirmSceneChangeResult 输出参数
typedef struct tagNET_OUT_CONFIRMSCENECHANGERESULT_INFO
{
	DWORD dwSize;								// 结构体大小
}NET_OUT_CONFIRMSCENECHANGERESULT_INFO;

// 确认智能家居场景切换结果 pstuInParam和pstuOutParam内存由用户分配和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmSceneChangeResult(LLONG lLoginID, const NET_IN_CONFIRMSCENECHANGERESULT_INFO *pstuInParam, NET_OUT_CONFIRMSCENECHANGERESULT_INFO *pstuOutParam, int nWaitTime);

// CLIENT_ConfirmAuthorizedResult 输入参数
typedef struct tagNET_IN_CONFIRM_AUTHORIZED_RESULT
{
	DWORD					dwSize;				// 结构体大小
	int						nResult;			// 0:二维码信息有效，非0:二维码信息无效
	char*					pszQRCode;			// 二维码信息，base64编码	
}NET_IN_CONFIRM_AUTHORIZED_RESULT;

// CLIENT_ConfirmAuthorizedResult 输出参数
typedef struct tagNET_OUT_CONFIRM_AUTHORIZED_RESULT
{
	DWORD					dwSize;				// 结构体大小
}NET_OUT_CONFIRM_AUTHORIZED_RESULT;

// 确认智能家居授权二维码信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ConfirmAuthorizedResult(LLONG lLoginID, const NET_IN_CONFIRM_AUTHORIZED_RESULT* pstInParam, NET_OUT_CONFIRM_AUTHORIZED_RESULT* pstOutParam, int nWaitTime);


typedef struct tagNET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST
{
	DWORD								dwSize;						// 结构体大小
} NET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST;

// 传感器传输介质
typedef enum tagEM_SENSOR_MEDIA_TYPE
{
	EM_SENSOR_MEDIA_TYPE_UNKNOWN,									// 未知
	EM_SENSOR_MEDIA_TYPE_COAXIAL,									// 同轴接入的传感器
	EM_SENSOR_MEDIA_TYPE_433,										// 通过433接入的传感器
} EM_SENSOR_MEDIA_TYPE;

// 无线传感器类型
typedef enum tagEM_WIRELESS_SENSOR_TYPE
{
	EM_WIRELESS_SENSOR_TYPE_UNKNOWN,								// 未知类型
	EM_WIRELESS_SENSOR_TYPE_HUMIDITY_SENSOR,						// 湿度传感器
	EM_WIRELESS_SENSOR_TYPE_TEMP_SENSOR,							// 温度传感器
	EM_WIRELESS_SENSOR_TYPE_DOOR_MAGNETISM,							// 门磁传感器
	EM_WIRELESS_SENSOR_TYPE_URGENCY_BUTTON,							// 紧急按钮
	EM_WIRELESS_SENSOR_TYPE_PASSIVE_INFRARED,						// 被动红外
	EM_WIRELESS_SENSOR_TYPE_CURTAIN_SENSOR,							// 幕帘
	EM_WIRELESS_SENSOR_TYPE_WATER_SENSOR,							// 水浸传感
	EM_WIRELESS_SENSOR_TYPE_SMOKING_SENSOR,							// 烟雾传感
	EM_WIRELESS_SENSOR_TYPE_COAXIAL_EXTALARM,						// 同轴外部报警
} EM_WIRELESS_SENSOR_TYPE;


// 传感器ID信息
typedef struct tagNET_SENSOR_ID_INFO 
{
	EM_SENSOR_MEDIA_TYPE				emMediaType;				// 传感器传输介质
	DWORD								nAPIndex;					// 接入点序号
	DWORD								nAlarmChannel;				// 报警通道号
	NET_WIRELESS_DEVICE_TYPE			emDeviceType;				// 无线设备类型
	EM_WIRELESS_SENSOR_TYPE				emSensorType;				// 传感器类型
	BYTE								byReserved[128];			// 保留字节
} NET_SENSOR_ID_INFO;

// 传感器ID数组最大个数
#define	MAX_SENSOR_ID_COUNT				256

// CLIENT_GetSensorCollectSupportList接口出参
typedef struct tagNET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST
{
	DWORD								dwSize;						// 结构体大小
	int									nCount;						// 传感器ID数量
	NET_SENSOR_ID_INFO					stInfo[MAX_SENSOR_ID_COUNT];// 传感器ID数组		
} NET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST;

// 获取可采集的传感器列表, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSensorCollectSupportList(LLONG lLoginID, const NET_IN_GET_SENSOR_COLLECT_SUPPORT_LIST* pInParam, NET_OUT_GET_SENSOR_COLLECT_SUPPORT_LIST* pOutParam, int nWaitTime);


// CLIENT_ControlDevice接口的 DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL命令参数
typedef struct tagNET_IN_START_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// 结构体大小
    int									nChannelID;					// 视频通道号(-1表示全通道)            
} NET_IN_START_REMOTELOWRATEWPAN_ALARMBELL;

// CLIENT_ControlDevice接口的 DH_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL命令参数
typedef struct tagNET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// 结构体大小         
} NET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL;

// CLIENT_ControlDevice接口的 DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL命令参数
typedef struct tagNET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// 结构体大小
    int									nChannelID;					// 视频通道号(-1表示全通道)            
} NET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL;

// CLIENT_ControlDevice接口的  DH_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL命令参数
typedef struct tagNET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL
{
    DWORD								dwSize;						// 结构体大小         
} NET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL;

// 门禁对讲状态
typedef enum tagEM_CALL_STATUS
{
	EM_CALL_STATUS_UNKNOWN,
	EM_CALL_STATUS_TRYING,					// 通话请求正在处理事件
	EM_CALL_STATUS_RINGING,					// 主叫时，被叫回铃事件
	EM_CALL_STATUS_PREPARECONNECTED,		// 收到对端通话接通
	EM_CALL_STATUS_CONNECTED,				// 双方通话已经正式建立
	EM_CALL_STATUS_CALLED,					// 被叫来电事件
	EM_CALL_STATUS_PREPARELEAVINGMESSAGE,	// 收到留言请求事件
	EM_CALL_STATUS_LEAVINGMESSAGECONNECTED,	// 留言通话接通事件
	EM_CALL_STATUS_CALLEND,					// 呼叫结束事件
	EM_CALL_STATUS_CALLTRANSFER,			// 转移呼叫到其他设备
	EM_CALL_STATUS_CALLTRANSFERCONNECTED,	// 呼叫转移接通
	EM_CALL_STATUS_HELD,					// 呼叫保持
	EM_CALL_STATUS_RESUME,					// 呼叫召回
	EM_CALL_STATUS_DND,						// 免打扰
	EM_CALL_STATUS_REMOTESDPCHANGE,			// 远端SDP改变
	EM_CALL_STATUS_REFUSE,					// 拒接
}EM_CALL_STATUS;

// CLIENT_ControlDeviceEx接口的  DH_CTRL_SET_THIRD_CALLSTATUS 命令参数入参
typedef struct tagNET_IN_VTP_THIRDCALL_STATUS
{
	DWORD			dwSize;
	EM_CALL_STATUS	emCallStatus;           // 门禁对讲状态
}NET_IN_VTP_THIRDCALL_STATUS;

// CLIENT_ControlDeviceEx接口的  DH_CTRL_SET_THIRD_CALLSTATUS 命令参数出参
typedef struct tagNET_OUT_VTP_THIRDCALL_STATUS
{
	DWORD			dwSize;
	char			szCallID[64];           // 对讲id
}NET_OUT_VTP_THIRDCALL_STATUS;

// 代理服务器地址
typedef struct tagNET_PROXY_SERVER_INFO 
{
	char								szIP[DH_MAX_IPADDR_LEN_EX];		// IP地址
	UINT								nPort;							// 端口
	BYTE								byReserved[84];
} NET_PROXY_SERVER_INFO ;

// CLIENT_CheckCloudUpgrader 入参
typedef struct tagNET_IN_CHECK_CLOUD_UPGRADER
{
	DWORD								dwSize;			// 结构体大小
	UINT								nWay;			// 检测路径, 0-直连升级服务器检测, 1-通过代理服务器检测, 2-获取缓存的检测结果
	NET_PROXY_SERVER_INFO				stProxy;		// 代理服务器地址, way==1时有意义
} NET_IN_CHECK_CLOUD_UPGRADER;

// 云升级状态
typedef enum tagEM_CLOUD_UPGRADER_CHECK_STATE
{
	EM_CLOUD_UPGRADER_CHECK_STATE_UNKNOWN,				// 未知
	EM_CLOUD_UPGRADER_CHECK_STATE_NONE,					// 没有检测到更新
	EM_CLOUD_UPGRADER_CHECK_STATE_REGULAR,				// 一般升级 (需要用户确认, 只能向高版本)
	EM_CLOUD_UPGRADER_CHECK_STATE_EMERGENCY,			// 强制升级 (设备自动检测执行, 可以向低版本)
	EM_CLOUD_UPGRADER_CHECK_STATE_AUTOMATIC,			// 自动升级 (有新升级包, 自动升级, 当前为定制使用, 需使能页面自动升级选项)
} EM_CLOUD_UPGRADER_CHECK_STATE;

// 云升级新版本升级包类型
typedef enum tagEM_CLOUD_UPGRADER_PACKAGE_TYPE
{
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_UNKNOWN,				// 未知
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_ALL,					// 整包
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ,					// 云台主控包
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_WEB,					// Web
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_LOGO,				// Logo
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_CUSTOM,				// Custom
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_GUI,					// Gui
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PD,					// PD
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_DATA,				// Data
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_POWER,			// 云台电源
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_LIGHT,			// 云台灯光
	EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_HEATER,			// 云台加热器
} EM_CLOUD_UPGRADER_PACKAGE_TYPE;

// CLIENT_CheckCloudUpgrader 出参
typedef struct tagNET_OUT_CHECK_CLOUD_UPGRADER 
{
	DWORD								dwSize;									// 结构体大小
	EM_CLOUD_UPGRADER_CHECK_STATE		emState;								// 升级状态
	EM_CLOUD_UPGRADER_PACKAGE_TYPE		emPackageType;							// 新版本升级包类型, State不为None需要返回
	char								szOldVersion[MAX_COMMON_STRING_64];		// 旧版本号, State不为None需要返回
	char								szNewVersion[MAX_COMMON_STRING_64];		// 新版本号,State不为None需要返回
	char								szAttention[MAX_COMMON_STRING_2048];	// 新的升级包更新内容
	char								szPackageURL[MAX_COMMON_STRING_256];	// 升级包下载地址(代理升级需要)
	char								szPackageID[MAX_COMMON_STRING_64];		// 升级包ID
	char								szCheckSum[MAX_COMMON_STRING_64];		// 升级包的SHA-256校验和
	char								szBuildTime[MAX_COMMON_STRING_32];		// 升级包构建时间
} NET_OUT_CHECK_CLOUD_UPGRADER;

// 在线升级检查是否有可用升级包, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_CheckCloudUpgrader(LLONG lLoginID, const NET_IN_CHECK_CLOUD_UPGRADER* pInParam, NET_OUT_CHECK_CLOUD_UPGRADER* pOutParam, int nWaitTime);

// 升级包信息
typedef struct tagNET_CLOUD_UPGRADER_INFO
{
	char								szPackageURL[MAX_COMMON_STRING_256];	// 升级包下载地址(代理升级需要)
	char								szPackageID[MAX_COMMON_STRING_64];		// 升级包ID
	char								szCheckSum[MAX_COMMON_STRING_64];		// 升级包的SHA-256校验和
	BYTE								byReserved[1024];						// 保留字节
} NET_CLOUD_UPGRADER_INFO;

// CLIENT_ExecuteCloudUpgrader 入参
typedef struct tagNET_IN_EXECUTE_CLOUD_UPGRADER
{
	DWORD								dwSize;									// 结构体大小
	char								szNewVersion[MAX_COMMON_STRING_64];		// 上一次check得到的新版本号
	UINT								nWay;									// 检测路径, 0-直连升级服务器检测, 1-通过代理服务器检测
	NET_PROXY_SERVER_INFO				stProxy;								// 代理服务器地址, nWay==1时有意义
	NET_CLOUD_UPGRADER_INFO				stInfo;									// 升级包信息
} NET_IN_EXECUTE_CLOUD_UPGRADER;

// CLIENT_ExecuteCloudUpgrader 出参
typedef struct tagNET_OUT_EXECUTE_CLOUD_UPGRADER
{
	DWORD								dwSize;									// 结构体大小
} NET_OUT_EXECUTE_CLOUD_UPGRADER;

// 执行在线云升级, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExecuteCloudUpgrader(LLONG lLoginID, const NET_IN_EXECUTE_CLOUD_UPGRADER* pInParam, NET_OUT_EXECUTE_CLOUD_UPGRADER* pOutParam, int nWaitTime);

// CLIENT_GetCloudUpgraderState 入参
typedef struct tagNET_IN_GET_CLOUD_UPGRADER_STATE 
{
	DWORD								dwSize;									// 结构体大小
} NET_IN_GET_CLOUD_UPGRADER_STATE;

// 在线升级状态
typedef enum tagEM_CLOUD_UPGRADER_STATE
{
	EM_CLOUD_UPGRADER_STATE_UNKNOWN,				// 未知
	EM_CLOUD_UPGRADER_STATE_NOUPGRADE,				// "Noupgrade"-未进行升级
	EM_CLOUD_UPGRADER_STATE_PREPARING,				// "Preparing"-准备升级
	EM_CLOUD_UPGRADER_STATE_DOWNLOADING,			// "Downloading"-正在下载数据
	EM_CLOUD_UPGRADER_STATE_DOWNLOADFAILED,			// "DownloadFailed"-下载失败
	EM_CLOUD_UPGRADER_STATE_UPGRADING,				// "Upgrading"-正在升级
	EM_CLOUD_UPGRADER_STATE_INVALID,				// "Invalid"-升级包不正确
	EM_CLOUD_UPGRADER_STATE_FAILED,					// "Failed"-升级包写入Flash失败
	EM_CLOUD_UPGRADER_STATE_SUCCEEDED,				// "Succeeded"-升级包写入Flash成功
} EM_CLOUD_UPGRADER_STATE;

// CLIENT_GetCloudUpgraderState 出参
typedef struct tagNET_OUT_GET_CLOUD_UPGRADER_STATE 
{
	DWORD								dwSize;					// 结构体大小
	EM_CLOUD_UPGRADER_STATE				emState;				// 升级状态
	UINT								nProgress;				// 升级进度, 状态是Downloading/Upgrading时有意义
} NET_OUT_GET_CLOUD_UPGRADER_STATE;

// 获取云升级在线升级状态, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCloudUpgraderState(LLONG lLoginID, const NET_IN_GET_CLOUD_UPGRADER_STATE* pInParam, NET_OUT_GET_CLOUD_UPGRADER_STATE* pOutParam, int nWaitTime);

// CLIENT_GetVideoDiagnosisChannelNumber 接口入参
typedef struct tagNET_IN_GET_SUPPORT_CHANNEL_NUM
{
	DWORD				dwSize;						// 结构体大小
}NET_IN_GET_SUPPORT_CHANNEL_NUM;

// CLIENT_GetVideoDiagnosisChannelNumber 接口出参
typedef struct tagNET_OUT_GET_SUPPORT_CHANNEL_NUM
{
	DWORD				dwSize;					// 结构体大小
	int					nCount;					// IVS-V支持的检测通道数目
}NET_OUT_GET_SUPPORT_CHANNEL_NUM;

// 获取IVS-V支持的检测通道数目
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVideoDiagnosisChannelNumber(LLONG lLoginID, const NET_IN_GET_SUPPORT_CHANNEL_NUM* pInParam, NET_OUT_GET_SUPPORT_CHANNEL_NUM* pOutParam, int nWaitTime);


#define	MAX_VIDEO_CHANNEL_COUNT		128											//	最大视频通道号

// CLIENT_GetRemoteLowRateWPANCaps 入参
typedef struct tagNET_IN_GET_REMOTELOWRATEWPAN_CAPS
{
	DWORD								dwSize;									// 结构体大小 
	int									nChannelCount;							// 实际要获取的视频通道个数
	int									stChannels[MAX_VIDEO_CHANNEL_COUNT];	// 视频通道号, 每一项对应单个通道的结果
} NET_IN_GET_REMOTELOWRATEWPAN_CAPS;

// 设备能力
typedef struct tagNET_REMOTE_LOW_RATE_WPAN_CAPS 
{
	BOOL								bSupportWirelessGateway;				// 设备是否支持无线网关
	BYTE								byRevserved[256];						// 保留字节
} NET_REMOTE_LOW_RATE_WPAN_CAPS;

// 返回结果
typedef enum tagEM_RETURN_CODE_TYPE
{
	EM_RETURN_CODE_TYPE_UNKNOWN,				// 未知
	EM_RETURN_CODE_TYPE_OK,						// 返回成功
	EM_RETURN_CODE_TYPE_FAILED,					// 返回失败
	EM_RETURN_CODE_TYPE_TIMEOUT,				// 返回超时
} EM_RETURN_CODE_TYPE;

// CLIENT_GetRemoteLowRateWPANCaps 出参
typedef struct tagNET_OUT_GET_REMOTELOWRATEWPAN_CAPS
{
	DWORD								dwSize;									// 结构体大小
	int									nRetChannelCount;						// 实际返回的通道个数
	NET_REMOTE_LOW_RATE_WPAN_CAPS		stCaps[MAX_VIDEO_CHANNEL_COUNT];		// 每个视频通道对应的设备能力
	int									nRetCodeCount;							// 实际返回的结果个数
	EM_RETURN_CODE_TYPE					stReturnCode[MAX_VIDEO_CHANNEL_COUNT];	// 每个视频通道对应的返回结果
} NET_OUT_GET_REMOTELOWRATEWPAN_CAPS;

// 获取对应视频通道的设备能力, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRemoteLowRateWPANCaps(LLONG lLoginID, const NET_IN_GET_REMOTELOWRATEWPAN_CAPS* pInParam, NET_OUT_GET_REMOTELOWRATEWPAN_CAPS* pOutParam, int nWaitTime);


// CLIENT_GetCoaxialSensorInfo 入参
typedef struct tagNET_IN_GET_COAXIAL_SENSOR_INFO 
{
	DWORD								dwSize;							// 结构体大小	
	int									nChannel;						// 视频通道, -1表示全部通道
} NET_IN_GET_COAXIAL_SENSOR_INFO;

// 传感器大类
typedef enum tagEM_SENSOR_CLASS_TYPE
{
	EM_SENSOR_CLASS_TYPE_UNKOWN,				// 未知
	EM_SENSOR_CLASS_TYPE_ALARM_IN,				// 开关量报警输入类
	EM_SENSOR_CLASS_TYPE_ALARM_OUT,				// 报警输出类
	EM_SENSOR_CLASS_TYPE_ANALOGALARM,			// 模拟量输入
} EM_SENSOR_CLASS_TYPE;

#define MAX_COAXIAL_SENSOR_INFO_COUNT	256			// 传感器信息最大个数

// 传感器信息
typedef struct tagNET_COAXIAL_SENSOR_INFO 
{
	NET_SENSOR_ID_INFO					stSensorID;							// 传感器ID信息
	BOOL								bIsOnLine;							// 传感器是否在线
	char								szAlarmName[MAX_COMMON_STRING_128];	// 报警通道名称
	EM_SENSOR_CLASS_TYPE				emSensorClass;						// 传感器大类
	char								szSN[MAX_COMMON_STRING_32];			// 传感器序列号
	BYTE								byRevserved[256];					// 保留字节
} NET_COAXIAL_SENSOR_INFO;

// CLIENT_GetCoaxialSensorInfo 出参
typedef struct tagNET_OUT_GET_COAXIAL_SENSOR_INFO 
{
	DWORD								dwSize;											// 结构体大小
	int									nRetCount;										// 返回的传感器ID数量
	NET_COAXIAL_SENSOR_INFO				stSensorInfo[MAX_COAXIAL_SENSOR_INFO_COUNT];	// 传感器信息数组	
} NET_OUT_GET_COAXIAL_SENSOR_INFO;


// 获取接入的传感器信息, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCoaxialSensorInfo(LLONG lLoginID, const NET_IN_GET_COAXIAL_SENSOR_INFO* pInParam, NET_OUT_GET_COAXIAL_SENSOR_INFO* pOutParam, int nWaitTime);

#define MAX_VIDEO_URL_LEN       256         // 视频源URL地址长度

// 视频源信息
typedef struct tagNET_VIDEO_SOURCE_INFO
{
	EM_DEV_PROTOCOL_TYPE	emProtocolType;						// 设备协议类型
	char                	szIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];  // 前端设备IP 地址
	int                 	nPort;                      		// 前端设备端口号
	char                	szUser[DH_NEW_USER_NAME_LENGTH];    // 前端设备用户名
    char                	szPwd[DH_NEW_USER_PSW_LENGTH];      // 前端设备密码
    int                 	nChannelID;                         // 前端设备通道号
    char                	szStreamUrl[MAX_VIDEO_URL_LEN];     // 视频源url地址, emProtocolType为EM_DEV_PROTOCOL_GENERAL 时有效
	BYTE					byReserved[512];					// 保留字节
} NET_VIDEO_SOURCE_INFO;

// 图像质量
 typedef enum tagEM_TRANSCODE_IMAGE_QUALITY
{
    EM_TRANSCODE_IMAGE_QUALITY_SELFADAPT,               // 自适应
    EM_TRANSCODE_IMAGE_QUALITY_Q10,                     // 10%
    EM_TRANSCODE_IMAGE_QUALITY_Q30,                     // 30%
    EM_TRANSCODE_IMAGE_QUALITY_Q50,                     // 50%
    EM_TRANSCODE_IMAGE_QUALITY_Q60,                     // 60%
    EM_TRANSCODE_IMAGE_QUALITY_Q80,                     // 80%
    EM_TRANSCODE_IMAGE_QUALITY_Q100,                   // 100%
} EM_TRANSCODE_IMAGE_QUALITY;

// 虚拟转码视频压缩格式
typedef enum tagEM_TRANSCODE_VIDEO_COMPRESSION
{
	EM_TRANSCODE_VIDEO_AUTO,							// auto
	EM_TRANSCODE_VIDEO_MPEG4,							// MPEG4
	EM_TRANSCODE_VIDEO_MPEG2,							// MPEG2
	EM_TRANSCODE_VIDEO_MPEG1,							// MPEG1
	EM_TRANSCODE_VIDEO_MJPG,							// MJPG
	EM_TRANSCODE_VIDEO_H263,							// H.263
	EM_TRANSCODE_VIDEO_H264,							// H.264
    EM_TRANSCODE_VIDEO_H265,							// H.265
} EM_TRANSCODE_VIDEO_COMPRESSION;

// 转码视频格式
typedef struct tagNET_TRANSCODE_VIDEO_FORMAT
{
	EM_TRANSCODE_VIDEO_COMPRESSION 	emCompression;				// 视频压缩格式
	UINT							nWidth;						// 视频宽度
	UINT							nHeight;					// 视频高度
	NET_EM_BITRATE_CONTROL			emBitRateControl;			// 码流控制模式
	UINT							nBitRate;					// 视频码流(kbps)
	float							fFrameRate;					// 视频帧率
	UINT							nIFrameInterval;			// I帧间隔(1-100)，比如50表示每49个B帧或P帧，设置一个I帧。
	EM_TRANSCODE_IMAGE_QUALITY		emImageQuality;				// 图像质量
	BYTE							byReserved[512];				// 保留字节
} NET_TRANSCODE_VIDEO_FORMAT;

// 转码音频格式
typedef struct tagNET_TRANSCODE_AUDIO_FORMAT
{
	NET_EM_AUDIO_FORMAT			emCompression;				// 音频压缩模式
	UINT						nFrequency;					// 音频采样频率
	BYTE						byReserved[512];			// 保留字节
} NET_TRANSCODE_AUDIO_FORMAT;

// CLIENT_GetVirtualChannelOfTransCode 接口输入参数
typedef struct tagNET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE
{
	DWORD						dwSize;							// 结构体大小
	NET_VIDEO_SOURCE_INFO		stuVideoSourceInfo;				// 视频源信息		
	NET_TRANSCODE_VIDEO_FORMAT	stuTransVideoFormat;			// 转码视频格式
	NET_TRANSCODE_AUDIO_FORMAT	stuTransAudioFormat;			// 转码音频格式
} NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE;

// CLIENT_GetVirtualChannelOfTransCode 接口输出参数
typedef struct tagNET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE
{
	DWORD						dwSize;							// 结构体大小
	UINT						nVirtualChannel;				// 虚拟通道号
} NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE;

// CLIENT_GetCapsOfTransCode 接口输入参数
typedef struct tagNET_IN_TRANDCODE_GET_CAPS
{
    DWORD						dwSize;							// 结构体大小
} NET_IN_TRANDCODE_GET_CAPS;

// CLIENT_GetCapsOfTransCode 接口输出参数
typedef struct tagNET_OUT_TRANSCODE_GET_CAPS
{
    DWORD						dwSize;							// 结构体大小
    int                         nMinVirtualChannel;             // 最小虚拟通道号
    int                         nMaxVirtualChannel;             // 最大虚拟通道号
    BOOL                        bSupportErrorCode;              // 是否支持压缩错误码实时上报
} NET_OUT_TRANSCODE_GET_CAPS;

// 虚拟转码通道状态
typedef enum tagEM_VIRCHANNEL_STATUS
{
    EM_VIRCHANNEL_STATUS_UNKNOWN    		= -1,   // 未知
    EM_VIRCHANNEL_STATUS_OVER_DECODE,               // 超出解码
    EM_VIRCHANNEL_STATUS_OVER_COMPRESS,             // 超出压缩
    EM_VIRCHANNEL_STATUS_NO_ORIGI_STREAM,           // 无原始码流
    EM_VIRCHANNEL_STATUS_SLAVE_OFFLINE,				// 压缩通道所在的从片掉线
	EM_VIRCHANNEL_STATUS_UNKNOWN_FAILURE 	= 255,	// 未知的失败原因
} EM_VIRCHANNEL_STATUS;

// 虚拟转码通道状态信息
typedef struct tagNET_CB_VIRTUALCHANNEL_STATUS_INFO
{
    UINT                        nVirChannelID;                  // 虚拟转码通道号
    EM_VIRCHANNEL_STATUS        emVirChannelStatus;             // 虚拟转码通道状态
    BYTE						byReserved[1024];			    // 保留字节
} NET_CB_VIRTUALCHANNEL_STATUS_INFO;

// 虚拟转码通道状态订阅函数原型, lAttachHandle 为 CLIENT_AttachVirtualChannelStatus 函数的返回值
typedef int  (CALLBACK *fVirtualChannelStatusCallBack)(const LLONG lAttachHandle, const NET_CB_VIRTUALCHANNEL_STATUS_INFO *pstVirChnStatusInfo, const LDWORD dwUser);

// CLIENT_AttachVirtualChannelStatus 接口输入参数
typedef struct tagNET_IN_ATTACH_VIRTUALCHANNEL_STATUS
{
    DWORD						    dwSize;							// 结构体大小
    BYTE                            byReserved[4];                  // 用于字节对齐
    fVirtualChannelStatusCallBack   cbVirtualChannelStatus;         // 虚拟转码通道状态订阅函数
    LDWORD                          dwUser;                 	    // 用户数据
} NET_IN_ATTACH_VIRTUALCHANNEL_STATUS;

// 获取转码虚拟通道号(虚拟通道号用于预览与回放), pInParam 和pOutParam 由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVirtualChannelOfTransCode(LLONG lLoginID, const NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE* pInParam, NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE* pOutParam, int nWaitTime);

// 获取转码能力集, pInParam 和pOutParam 由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCapsOfTransCode(LLONG lLoginID, const NET_IN_TRANDCODE_GET_CAPS* pInParam, NET_OUT_TRANSCODE_GET_CAPS* pOutParam, int nWaitTime);

// 订阅虚拟转码通道状态, pInParam 由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachVirtualChannelStatus(LLONG lLoginID, const NET_IN_ATTACH_VIRTUALCHANNEL_STATUS* pInParam, const int nWaitTime);

// 取消订阅虚拟转码通道状态, lAttachHandle 为 CLIENT_AttachVirtualChannelStatus 函数的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachVirtualChannelStatus(LLONG lAttachHandle);

/////////////////////////////////手机报警推送订阅新协议  Start/////////////////////////////////
// CLIENT_GetMobilePusherCaps 入参
typedef struct tagNET_IN_GET_MOBILE_PUSHER_CAPS 
{
	DWORD						dwSize;					// 结构体大小
} NET_IN_GET_MOBILE_PUSHER_CAPS;

// CLIENT_GetMobilePusherCaps 出参
typedef struct tagNET_OUT_GET_MOBILE_PUSHER_CAPS 
{
	DWORD						dwSize;					// 结构体大小
	BOOL						bEnablePush;			// 设备是否支持设置手机报警推送使能
	BOOL						bAddNotification;		// 设备是否支持添加推送订阅
	BOOL						bDelNotification;		// 设备是否支持取消推送订阅
    BOOL                        bSupportPriority;       // DMSS手机推送,是否支持优先级,手机APP需要根据此字段来判断下发的主服务器配置
    BOOL                        bPushEventSchedule;     // 是否支持订制时间段内推送
} NET_OUT_GET_MOBILE_PUSHER_CAPS;

// 获取手机推送支持能力, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetMobilePusherCaps(LLONG lLoginID, NET_IN_GET_MOBILE_PUSHER_CAPS *pInParam, NET_OUT_GET_MOBILE_PUSHER_CAPS *pOutParam, int nWaitTime);

// CLIENT_EnablePushMobilePusher 入参
typedef struct tagNET_IN_ENABLE_PUSH_MOBILE_PUSHER
{
	DWORD						dwSize;					// 结构体大小
	BOOL						bEnablePush;			// 是否开启手机推送
} NET_IN_ENABLE_PUSH_MOBILE_PUSHER;

// CLIENT_EnablePushMobilePusher 出参
typedef struct tagNET_OUT_ENABLE_PUSH_MOBILE_PUSHER 
{
	DWORD						dwSize;					// 结构体大小
} NET_OUT_ENABLE_PUSH_MOBILE_PUSHER;

// 设置手机报警推送使能, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EnablePushMobilePusher(LLONG lLoginID, NET_IN_ENABLE_PUSH_MOBILE_PUSHER *pInParam, NET_OUT_ENABLE_PUSH_MOBILE_PUSHER *pOutParam, int nWaitTime);

// 推送服务器配置
typedef struct tagNET_PUSH_SERVER_INFO_EX
{
    char                            szAddress[MAX_URL_LEN];                     // 地址
    int                             nPort;                                      // 端口
	BYTE							byReserved[512];							// 保留字节
} NET_PUSH_SERVER_INFO_EX;

// 订阅组
typedef struct tagNET_REGISTER_GROUP
{
   int                  nIndex;                 // 通道号,-1表示按库订阅，不区分通道,为MobilePushNotification 中indexs的子集
   int                  nGroupCount;            // 人脸库ID集合的数量
   char                 szGroup[64][64];        // 人脸库ID集合
   BYTE		            byReserved[128];	    // 保留字节
} NET_REGISTER_GROUP;

// 人脸比对事件过滤器
typedef struct tagNET_CUSTOM_TILTER_OF_FACE_COMPARISION
{
    int                 nRegisterGroupCount;    // 订阅组数量
    NET_REGISTER_GROUP  stuRegisterGroup[256];  // 订阅组
    BYTE		        byReserved[1028];	    // 保留字节
} NET_CUSTOM_TILTER_OF_FACE_COMPARISION;

// 订阅类型
typedef struct tagNET_SUBSCRIBE_INFO_EX
{
    char                            szCode[MAX_COMMON_STRING_64];				// 事件码
    char				            szSubCode[MAX_COMMON_STRING_64];			// 事件子类型
																				// 仅对VideoAbnormalDetection,AlarmLocal等包含多种类型的报警事件有效
    int                             nChnNum;									// 订阅的通道数量, 若无通道概念则为0
    int                             nIndexs[MAX_MOBILE_CHANNEL_NUM];			// 通道号集合
    char                            szNumber[DH_COMMON_STRING_16];				// 订阅"CallNoAnswered "事件时有效
																				// 无应答号码（设备呼叫这些号码,无应答时,将向手机推送消息）
																				// CFG_CMD_MOBILE_PUSH_NOFITY_CFG时有效
    char                            szSound[DH_COMMON_STRING_64];				// 手机端收到此事件时播放需播放的声音文件
    char                            szIndexsExt[DH_COMMON_STRING_32][DH_COMMON_STRING_16];     //通道号集合扩展
    void*                           pstuCustomFilter;                           // 定制过滤器, 由szCode的类型决定,其他未支持类型则填NULL
                                                                                // 当szCode为"FaceComparision"时，类型为：NET_CUSTOM_TILTER_OF_FACE_COMPARISION(目前只支持这种)
	BYTE							byReserved[504];							// 保留字节
} NET_SUBSCRIBE_INFO_EX;

// CLIENT_AddMobilePusherNotification 入参
typedef struct tagNET_IN_ADD_MOBILE_PUSHER_NOTIFICATION
{
	DWORD						dwSize;									// 结构体大小
	char						szRegisterID[MAX_REGISTER_ID_LEN];		// RegisterID, 机向Appple/Android服务器注册返回的, 每次不同
	char						szAppID[MAX_APP_ID_LEN];				// AppID
	EM_MOBILE_SERVER_TYPE		emServerType;							// 平台类型
	EM_PUSH_GATEWAY_TYPE        emPushGatewayType;                      // 推送网关类型, emServerType为EM_MOBILE_SERVER_TYPE_SDKCLOUD时有效
	int                         nPeriodOfValidity;						// 有效时间,单位为秒
    char                        szAuthServerAddr[MAX_URL_LEN];			// Android验证服务器地址
    int                         nAuthServerPort;						// Android验证服务器端口
	NET_PUSH_SERVER_INFO_EX     stuPushServerMain;						// 推送服务器配置, 官方。首选服务器,如果推送失败,再尝试重定向或代理服务器
    char                        szPushServerAddr[MAX_URL_LEN];			// 推送服务器地址(大华代理,末选服务器,供兼容)
																		// 由大华服务器按官方服务器要求,选用最新的加密算法再转发给官方服务器
    int                         nPushServerPort;						// 推送服务器端口(大华代理)
    char                        szDevName[MAX_COMMON_STRING_64];		// 设备别名,手机端设置显示
    char                        szDevID[MAX_COMMON_STRING_64];			// 设备标识,手机端设置使用
    char                        szUser[MAX_COMMON_STRING_64];			// google的GCM/C2DM推送验证用户名
    char                        szCertificate[MAX_IOS_CERTIFICATE_LEN]; // 证书信息,base64之后的字符串,需要采用TLS加密时有效, iOS需要
    char                        szSecretKey[MAX_IOS_SECRET_KEY_LEN];    // 极光(Jpush)推送密钥, 明文字符串, Android极光Jpush推送需要
    int                         nSubScribeNum;                          // 实际的订阅类型个数, 获取配置有效
    NET_SUBSCRIBE_INFO_EX*      pstuSubscribes;                         // 订阅类型,由用户申请内存，大小为sizeof(NET_SUBSCRIBE_INFO)*nSubScribeMax
	DH_TSECT                    stuAllEventPushTime[DH_N_WEEKS][DH_N_TSECT]; // 设备推送时间段，为一个7*6的二维数组，7个元素对应每周7天（第一个为星期日），每天内最多6个单独时间段。//每个时间段的第一个数字1代表该时间段使能，0为非使能状态。默认下发七天，每天全时间段（24小时）使能的配置。若无此字段，则设备所有时间段都进行推送。
																		// 每个时间段的第一个数字1代表该时间段使能，0为非使能状态。
																		// 当bIsTimeEnable为TRUE时，必须设置有效推送时间段; bIsTimeEnable为FALSE时,设备推送不受时间限制
	BOOL                        bIsTimeEnable;                          // 设备推送时间段(stuAllEventPushTime)字段是否有效,默认为false
} NET_IN_ADD_MOBILE_PUSHER_NOTIFICATION;


// CLIENT_AddMobilePusherNotification 出参
typedef struct tagNET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION 
{
	DWORD						dwSize;									// 结构体大小
} NET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION;

// 手机APP向设备添加一个推送订阅, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddMobilePusherNotification(LLONG lLoginID, NET_IN_ADD_MOBILE_PUSHER_NOTIFICATION *pInParam, NET_OUT_ADD_MOBILE_PUSHER_NOTIFICATION *pOutParam, int nWaitTime);

// CLIENT_DelMobilePusherNotification 入参
typedef struct tagNET_IN_DEL_MOBILE_PUSHER_NOTIFICATION
{
	DWORD						dwSize;									// 结构体大小
	char						szRegisterID[MAX_REGISTER_ID_LEN];		// RegisterID, 手机向Appple/Android服务器注册返回的，每次不同；
	char						szAppID[MAX_APP_ID_LEN];				// AppID（手机每开一个客户端，会产生一个）
} NET_IN_DEL_MOBILE_PUSHER_NOTIFICATION;

// CLIENT_DelMobilePusherNotification 出参
typedef struct tagNET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION 
{
	DWORD						dwSize;									// 结构体大小
} NET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION;

// 手机APP向设备删除一个推送订阅, pInParam和pOutParam内存由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DelMobilePusherNotification(LLONG lLoginID, NET_IN_DEL_MOBILE_PUSHER_NOTIFICATION *pInParam, NET_OUT_DEL_MOBILE_PUSHER_NOTIFICATION *pOutParam, int nWaitTime);
/////////////////////////////////手机报警推送订阅新协议  End/////////////////////////////////

// 凭证信息
typedef struct tagNET_CREDENTIAL_INFO
{
    char                        CredentialHolder[16];                           // 身份拥有者
    NET_TIME                    stuValidDateStart;                              // 开始有效期
    NET_TIME                    stuValidDateEnd;                                // 截止有效期
    NET_ACCESS_METHOD           emType;                                         // 开门类型
    DWORD                       nIndex;                                         // 索引号
    char                        szCardNo[DH_MAX_CARDINFO_LEN];                  // 卡号
    BYTE                        byReserved[1024];                               // 保留字节
}NET_CREDENTIAL_INFO;

// 上报的离线授权信息
typedef struct tagNET_SMARTLOCK_NOTIFY_OFFLINEAUTH
{
    char                        szSerialNumber[32];                             // 无线设备序列号(智能锁)
    DWORD                       nACK;                                           // 确认号
    NET_CREDENTIAL_INFO         stCredentialInfo;                               // 凭证信息
    BYTE                        byReserved[1024];                               // 保留字节
}NET_SMARTLOCK_NOTIFY_OFFLINEAUTH;

// 离线授权信息回调函数指针
typedef void (CALLBACK *fSmartLockOfflineAuthCallBack) (LLONG lLoginId, LLONG lAttachHandle, const NET_SMARTLOCK_NOTIFY_OFFLINEAUTH* pBuf, LDWORD dwUser);

// 智能锁离线授权订阅入参(对应接口 CLIENT_AttachSmartLockOfflineAuth)
typedef struct tagNET_IN_SMARTLOCK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // 结构体大小
    char                                szUUID[36];                             // 客户端惟一标识
    fSmartLockOfflineAuthCallBack       cbOfflineAuth;                          // 离线授权信息回调
    LDWORD                              dwUser;                                 // 用户数据
}NET_IN_SMARTLOCK_OFFLINEAUTH;

// 智能锁离线授权订阅出参(对应接口 CLIENT_AttachSmartLockOfflineAuth)
typedef struct tagNET_OUT_SMARTLOCK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // 结构体大小
}NET_OUT_SMARTLOCK_OFFLINEAUTH;

// 智能锁离线授权订阅
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachSmartLockOfflineAuth(LLONG lLoginID, const NET_IN_SMARTLOCK_OFFLINEAUTH* pstInParam, NET_OUT_SMARTLOCK_OFFLINEAUTH* pstOutParam, int nWaitTime);

// 智能锁退订事件重传
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachSmartLockOfflineAuth(LLONG lAttachHandle);

// 智能锁确认离线授权入参(对应接口 CLIENT_AckSmartLockOfflineAuth)
typedef struct tagNET_IN_SMARTLOCK_ACK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // 结构体大小
    char                                szUUID[36];                             // 客户端惟一标识
    char                                szSerialNumber[32];                     // 无线设备序列号(智能锁)
    DWORD                               nACK;                                   // 事件的确认ID
}NET_IN_SMARTLOCK_ACK_OFFLINEAUTH;

// 智能锁确认离线授权出参(对应接口 CLIENT_AckSmartLockOfflineAuth)
typedef struct tagNET_OUT_SMARTLOCK_ACK_OFFLINEAUTH
{
    DWORD                               dwSize;                                 // 结构体大小
}NET_OUT_SMARTLOCK_ACK_OFFLINEAUTH;

// 智能锁确认离线授权
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AckSmartLockOfflineAuth(LLONG lLoginID, NET_IN_SMARTLOCK_ACK_OFFLINEAUTH* pstInParam, NET_OUT_SMARTLOCK_ACK_OFFLINEAUTH* pstOutParam, int nWaitTime);

// CLIENT_EncryptString 接口入参
typedef struct tagNET_IN_ENCRYPT_STRING
{
	DWORD						dwSize;							// 结构体大小
	char						szCard[33];						// 卡号
	BYTE                        byReserved1[3];                 // 字节对齐	
    char                        szKey[33];                      // 秘钥
    BYTE                        byReserved2[3];                 // 字节对齐	
} NET_IN_ENCRYPT_STRING;

// CLIENT_EncryptString 接口出参
typedef struct tagNET_OUT_ENCRYPT_STRING 
{
	DWORD						dwSize;							// 结构体大小
	char						szEncryptString[1024];			// 加密后字符串
} NET_OUT_ENCRYPT_STRING;

// 字符串加密接口 (pInParam, pOutParam内存由用户申请释放) 定制接口
CLIENT_NET_API BOOL CALL_METHOD CLIENT_EncryptString(const NET_IN_ENCRYPT_STRING *pInParam, NET_OUT_ENCRYPT_STRING *pOutParam, int nWaitTime);

// CLIENT_PreUploadRemoteFile 接口输入参数(设置文件长度)
typedef struct tagNET_IN_PRE_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;                         // 结构体大小
    char*               pszFileSrc;                     // 源文件路径
    char*               pszFileDst;                     // 保存在设备端的文件路径
} NET_IN_PRE_UPLOAD_REMOTE_FILE;

// 错误原因类型
typedef enum tagEM_REASON_TYPE
{
    EM_REASON_TYPE_UNKNOWN,                             // 未知原因
    EM_REASON_TYPE_OVERNUMBER,                          // 文件个数超出
    EM_REASON_TYPE_FULLSTORAGE,                         // 文件存储空间已满
    EM_REASON_TYPE_TOOLARGE_FILE,                       // 该文件太大
    EM_REASON_TYPE_INVALID_FILETYPE,                    // 无效的文件类型
    EM_REASON_TYPE_UNAUTH_UPLOAD,                       // 没有上传权限
    EM_REASON_TYPE_EXCEPTION_NAME,                      // 文件命名异常
    EM_REASON_TYPE_TOOLONG_NAME,                        // 文件名太长
    EM_REASON_TYPE_EXIST_NAME,                          // 文件名已存在
} EM_REASON_TYPE;

// CLIENT_PreUploadRemoteFile 接口输出参数(设置文件长度)
typedef struct tagNET_OUT_PRE_UPLOAD_REMOTE_FILE
{
    DWORD               dwSize;                         // 结构体大小
    BOOL                bContinue2Upload;               // 标志是否继续上传该文件, true:上传 false:不上传
    EM_REASON_TYPE      emType;                         // 错误原因, 当bContinue2Upload为false时emType有效                    
} NET_OUT_PRE_UPLOAD_REMOTE_FILE;

// 设置文件长度, pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PreUploadRemoteFile(LLONG lLoginID, const NET_IN_PRE_UPLOAD_REMOTE_FILE* pInParam, NET_OUT_PRE_UPLOAD_REMOTE_FILE* pOutParam, int nWaitTime);

//CLIENT_GetInstallDiagnosticStatCaps入参
typedef struct tagNET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT
{
	DWORD				dwSize;
}NET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT;

//通道信息
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO
{
	int									nChannel;				//视频通道号
	int									nEventNum;				//事件数量
	int									nEventsCode[32];		//事件列表
	BYTE								bReserved[256];			//保留字节
}NET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO;
//CLIENT_GetInstallDiagnosticStatCaps出参
typedef struct tagNET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT
{
	DWORD									dwSize;				//结构体大小
	int										nCapsNum;			//通道数量
	NET_INSTALL_DIAGNOSTIC_STAT_CAPS_INFO	stuCaps[16];		//通道信息数组
}NET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT;

//获取设备能提供诊断的事件,pInParam与pOutParam内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInstallDiagnosticStatCaps(LLONG lLoginID, const NET_IN_GET_CAPS_INSTALL_DIAGNOSTIC_STAT* pInParam, NET_OUT_GET_CAPS_INSTALL_DIAGNOSTIC_STAT* pOutParam, int nWaitTime);

//数据结构体
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_DATALIST
{
	int						nPitchAngle;			//俯仰角(抬头，低头)。范围[-90,90],0为正脸 180为无效值
	int						nYawAngle;				//偏航角(左右转头)。范围[-90,90],0为正脸 180为无效值
	int						nRollAngle;				//侧滚角(平面左偏右偏)。范围[-90,90],0为正脸 180为无效值
	int						nQuality;				//人脸质量分值。范围[1,100],0为无效值
	int						nWidth;					//像素点宽度
	int						nHeight;				//像素点高度
	BYTE					byReserved[64];			//保留字节
}NET_INSTALL_DIAGNOSTIC_STAT_DATALIST;
//安装数据信息
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT_RESULT
{
	int										nEventCode;			// 事件码
	int										nDatalistLen;		// 数据个数 
	NET_INSTALL_DIAGNOSTIC_STAT_DATALIST	stuDataList[128];	// 数据列表
	BYTE									byReserved[256];	// 保留字节
}NET_INSTALL_DIAGNOSTIC_STAT_RESULT;
//订阅安装诊断数据回调出参
typedef struct tagNET_INSTALL_DIAGNOSTIC_STAT
{
	int										nChannel;			// 通道号
	int										nResultNum;			// 数据个数
	NET_INSTALL_DIAGNOSTIC_STAT_RESULT		stuResult[32];		// 数据列表
	BYTE									byReserved[512];	// 保留字节
}NET_INSTALL_DIAGNOSTIC_STAT;
//订阅安装诊断数据回调
typedef void (CALLBACK	*fInstallDiagnosticStatCallBack)(LLONG lAttachHandle, NET_INSTALL_DIAGNOSTIC_STAT* pBuf, DWORD dwBufLen, LDWORD dwUser);
//过滤信息
typedef struct tagNET_ATTACH_DIAGNOSTIC_FILTER
{
	int								nChannelNum;					// 通道数量
	int								nChannels[16];					// 通道号列表
	int								nEventNum;						// 事件数量
	int								nEventsCode[32];				// 事件列表
	BYTE							byReserved[128];				// 保留字节
}NET_ATTACH_DIAGNOSTIC_FILTER;
//订阅安装回调入参
typedef struct tagNET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT
{
	DWORD								dwSize;				// 结构体大小
	NET_ATTACH_DIAGNOSTIC_FILTER		stuFilter;			// 过滤信息
	fInstallDiagnosticStatCallBack		cbDiagnosticStat;	// 订阅回调函数
	LDWORD								dwUser;				// 用户数据
}NET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT;
//订阅安装回调出参
typedef struct tagNET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT
{
	DWORD					dwSize;					// 结构体大小
}NET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT;
//订阅安装诊断数据
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachInstallDiagnosticStat(LLONG lLoginID, const NET_IN_ATTACH_INSTALL_DIAGNOSTIC_STAT* pInParam, NET_OUT_ATTACH_INSTALL_DIAGNOSTIC_STAT* pOutParam, int nWaitTime);
//取消订阅安装诊断数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachInstallDiagnosticStat(LLONG lAttachHandle);

//CLIENT_GetSCADADeviceStatus入参
typedef struct tagNET_IN_GET_SCADA_STATUS
{
	DWORD				dwSize;										// 结构体大小
}NET_IN_GET_SCADA_STATUS;
//设备状态信息
typedef struct tagNET_SCADA_DEV_INFO
{
	char						szDeviceID[32];						// 设备ID
	char						szDeviceName[32];					// 设备名称
	EM_SCADA_DEVICE_STATUS		emDevStatus;						// 设备状态
}NET_SCADA_DEV_INFO;
//设备信息
typedef struct tagNET_SCADA_STATUS_INFO
{
	EM_ALARM_SCADA_DEV_TYPE					emDevType;				// 设备类型
	int										nDevInfoNum;			// 设备信息个数
	NET_SCADA_DEV_INFO						stuDevInfo[128];		// 设备信息
}NET_SCADA_STATUS_INFO;
//CLIENT_GetSCADADeviceStatus出参
typedef struct tagNET_OUT_GET_SCADA_STATUS
{
	DWORD					dwSize;									// 结构体大小
	int						nDevStatusNum;							// 设备状态信息个数
	NET_SCADA_STATUS_INFO	stuStatusInfo[64];						// 设备状态信息
}NET_OUT_GET_SCADA_STATUS;
//获取控制器设备列表及状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSCADADeviceStatus(LLONG lLoginID, const NET_IN_GET_SCADA_STATUS* pInParam, NET_OUT_GET_SCADA_STATUS* pOutParam, int nWaitTime);

// 获取标定点信息入参
typedef struct tagNET_IN_GET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// 结构体大小
	UINT		nID;		// 标定点编号
}NET_IN_GET_CALIBRATEINFO_INFO;
// 标定点位置信息
typedef struct tagNET_GET_CALIBRATEINFO_CALCINFO_INFO
{
	float		fPosition[3];	// 标定点坐标及倍率
	UINT		nLocation[2];	// 标定点在图像中坐标  
}NET_GET_CALIBRATEINFO_CALCINFO_INFO;
// 标定点参数信息
typedef struct tagNET_GET_CALIBRATEINFO_POINT_INFO
{
	UINT		nID;			// 标定点编号
	char		szName[DH_COMMON_STRING_128];		// 标定点名称
	BOOL		bEnable;		// 使能
	UINT		nLongitude;		// 经度
	UINT		nLatitude;		// 纬度
	double		fAltitude;		// 海拔
	NET_GET_CALIBRATEINFO_CALCINFO_INFO stuCalcInfo[5][2];	// 标定点坐标 第一维表示不同位置， 第二位表示可见光或热成像
	int			nPointNum;		// 标定点个数
	BYTE		byReserved[4];	// 字节对齐
}NET_GET_CALIBRATEINFO_POINT_INFO;
// 获取标定点信息出参
typedef struct tagNET_OUT_GET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// 结构体大小
	NET_GET_CALIBRATEINFO_POINT_INFO	stuPointInfo; // 标定点信息
}NET_OUT_GET_CALIBRATEINFO_INFO;

// 设置标定点信息入参
typedef struct tagNET_IN_SET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;			// 结构体大小
	NET_GET_CALIBRATEINFO_POINT_INFO	stuPointInfo;	//标定点信息
}NET_IN_SET_CALIBRATEINFO_INFO;
// 设置标定点信息出参
typedef struct tagNET_OUT_SET_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// 结构体大小
}NET_OUT_SET_CALIBRATEINFO_INFO;

// 删除标定点信息入参
typedef struct tagNET_IN_DELETE_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// 结构体大小
	UINT		nID;		// 标定点ID
}NET_IN_DELETE_CALIBRATEINFO_INFO;
// 删除标定点信息出参
typedef struct tagNET_OUT_DELETE_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		// 结构体大小
}NET_OUT_DELETE_CALIBRATEINFO_INFO;

// 获取所有标定点信息入参
typedef struct tagNET_IN_GETALL_CALIBRATEINFO_INFO
{
	DWORD		dwSize;		//结构体大小
}NET_IN_GETALL_CALIBRATEINFO_INFO;
// GPS信息
typedef struct tagNET_DEVLOCATION_INFO
{
	UINT							unLongitude;							                    // 经度 单位百万分之一度，范围0-360度
	UINT							unLatitude;								                    // 纬度 单位百万分之一度，范围0-360度
	double                          dbAltitude;                                                 // 海拔 单位米
	BOOL                            bConfigEnable;                                              // true：GPS信息按照配置上报
	float							fHeight;													// 设备高度 单位米
}NET_DEVLOCATION_INFO;
// 标定基本信息
typedef struct tagNET_CALIBRATE_UNIT_INFO
{
	UINT		nHeight;			// 分辨率高
	UINT		nWidth;				// 分辨率宽
	float		nPosition[3];		// 云台位置(P/T/Z 归一化)
	UINT		nLocation[2];		// 标定点坐标
	UINT		nHFOV;				// 横向视场角(单位：0.01度)
	UINT		nVFOV;				// 纵向视场角(单位：0.01度)
}NET_CALIBRATE_UNIT_INFO;
// 标定详细信息
typedef struct tagNET_CALIBRATE_INFO
{
	NET_CALIBRATE_UNIT_INFO stuCalibrateUnitInfo[5][2];		//标定点基本信息
	int nInfoNum;			// 基本信息数量
}NET_CALIBRATE_INFO;
// 标定点信息
typedef struct tagNET_LOCATION_CALIBRATE_POINT_INFO
{
	UINT		nID;							// 标定点ID
	char		szName[DH_COMMON_STRING_128];	// 标定点名称
	BOOL		bEnable;						// 使能
	UINT		nLongitude;						// 经度
	UINT		nLatitude;						// 纬度
	double		fAltitude;						// 海拔
	NET_CALIBRATE_INFO	stuCalibrateInfo;		// 标定点基本信息
	BYTE		byReserved1[4];					// 字节对齐
}NET_LOCATION_CALIBRATE_POINT_INFO;

//设备标定信息
#define MAX_CALIBRATE_POINT_NUM 64  //标定点最大个数
typedef struct tagNET_LOCATION_CALIBRATE_INFO
{
	UINT		nVisualMaxHFOV;				// 可见光横向视角
	UINT		nVisualMaxVFOV;				// 可见光纵向视角
	UINT		nThermoMaxHFOV;				// 热成像横向视角
	UINT		nThermoMaxVFOV;				// 热成像纵向视角
	NET_LOCATION_CALIBRATE_POINT_INFO	stuPointInfo[MAX_CALIBRATE_POINT_NUM];	// 标定点信息
	int			nPointNum;					// 标定点个数
	BYTE		byReserved1[4];					// 字节对齐
}NET_LOCATION_CALIBRATE_INFO;
// 获取所有标定信息出参
typedef struct tagNET_OUT_GETALL_CALIBRATEINFO_INFO
{
	DWORD		dwSize;											// 结构体大小
	NET_DEVLOCATION_INFO			stuGPSInfo;					// GPS信息
	NET_LOCATION_CALIBRATE_INFO		stuLocationCalibrateInfo;	// 标定信息
}NET_OUT_GETALL_CALIBRATEINFO_INFO;

// 设备标定信息操作类型
typedef enum tagEM_CALIBRATEINFO_OPERATE_TYPE
{
	EM_CALIBRATEINFO_OPERATE_GET,			// 获取指定点标定信息,	pStuInParam = NET_IN_GET_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_GET_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_SET,			// 设置指定点标定信息,	pStuInParam = NET_IN_SET_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_SET_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_DELETE,		// 删除指定点标定信息,	pStuInParam = NET_IN_DELETE_CALIBRATEINFO_INFO,	  pStuOutParam = NET_OUT_DELETE_CALIBRATEINFO_INFO
	EM_CALIBRATEINFO_OPERATE_GETALL,		// 获取所有标定信息,	pStuInParam = NET_IN_GETALL_CALIBRATEINFO_INFO,   pStuOutParam = NET_OUT_GETALL_CALIBRATEINFO_INFO
}EM_CALIBRATEINFO_OPERATE_TYPE;
// 操作设备标定信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_OperateCalibrateInfo(LLONG lLoginID, EM_CALIBRATEINFO_OPERATE_TYPE emType, const	void* pStuInParam, void* pStuOutParam, int nWaitTime);


// 云台水平旋转组信息
typedef struct tagNET_PAN_GROUP_INFO
{
	char					szName[32];								// 水平旋转组名称
	unsigned int 			nSpeed;									// 水平旋转速度0~7
	BOOL 					bEnable;								// 使能
	unsigned int 			nInterval;								// 停留时间,单位:秒
	BYTE					byReserved[64];							// 保留字节
}NET_PAN_GROUP_INFO;

// CLIENT_PTZSetPanGroup入参数结构体
typedef struct tagNET_IN_SET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// 结构体大小
	int						nChannel;								// 通道号
	unsigned int			nIndex;									// 旋转组内元素序号从1开始
	NET_PAN_GROUP_INFO		stuPanGroupInfo;						// 水平旋转组信息
}NET_IN_SET_PAN_GROUP_PARAM;

// CLIENT_PTZSetPanGroup出参数结构体
typedef struct tagNET_OUT_SET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// 结构体大小
}NET_OUT_SET_PAN_GROUP_PARAM;

//设置云台水平旋转组信息(热成像专用)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZSetPanGroup(LLONG lLoginID, const NET_IN_SET_PAN_GROUP_PARAM* pInParam, NET_OUT_SET_PAN_GROUP_PARAM* pOutParam, int nWaitTime);


// CLIENT_PTZGetPanGroup入参结构体
typedef struct tagNET_IN_GET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// 结构体大小
	int						nChannel;								// 通道号
}NET_IN_GET_PAN_GROUP_PARAM;

// CLIENT_PTZGetPanGroup出参结构体
typedef struct tagNET_OUT_GET_PAN_GROUP_PARAM
{
	DWORD					dwSize;									// 结构体大小
	int						nRetNum;								// 实际返回个数
	NET_PAN_GROUP_INFO		stuPanGroupInfo[8];						// 水平旋转组信息
}NET_OUT_GET_PAN_GROUP_PARAM;
//获取云台水平旋转组信息(热成像专用)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZGetPanGroup(LLONG lLoginID, const NET_IN_GET_PAN_GROUP_PARAM* pInParam, NET_OUT_GET_PAN_GROUP_PARAM* pOutParam, int nWaitTime);


//CLIENT_PTZGotoPanPosition 入参结构体
typedef struct tagNET_IN_GOTO_PAN_POSITION
{
	DWORD					dwSize;									// 结构体大小
	int						nChannel;								// 通道号
	unsigned int			nIndex;									// 旋转组内序号从1开始
}NET_IN_GOTO_PAN_POSITION;

//CLIENT_PTZGotoPanPosition 出参结构体
typedef struct tagNET_OUT_GOTO_PAN_POSITION
{
	DWORD					dwSize;									// 结构体大小
}NET_OUT_GOTO_PAN_POSITION;

//云台转动到指定水平(热成像专用)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZGotoPanPosition(LLONG lLogindID, const NET_IN_GOTO_PAN_POSITION* pInParam, NET_OUT_GOTO_PAN_POSITION* pOutParam, int nWaitTime);

// 水平旋转组边界模式
typedef enum tagNET_EM_PAN_GROUP_LIMIT_MODE
{
	NET_EM_PAN_GROUP_LIMIT_MODE_LEFT = 1,				// 左边界
	NET_EM_PAN_GROUP_LIMIT_MODE_RIGHT,					// 右边界
	NET_EM_PAN_GROUP_LIMIT_MODE_UP,						// 上边界
	NET_EM_PAN_GROUP_LIMIT_MODE_DOWN,					// 下边界
} NET_EM_PAN_GROUP_LIMIT_MODE; 

// 设置水平旋转边界值 输入参数
typedef struct tagNET_IN_PAN_GROUP_LIMIT_INFO
{
	DWORD							dwSize;									// 结构体大小
	int								nChannelID;								// 正确通道号，范围 0~设备通道数
	unsigned int					nIndex;									// 旋转组内序号从1开始
	NET_EM_PAN_GROUP_LIMIT_MODE	emPanGroupLimitMode;						// 水平旋转组限界类型							 		 							 
} NET_IN_PAN_GROUP_LIMIT_INFO;

// 设置水平旋转边界值 输出参数
typedef struct tagNET_OUT_PAN_GROUP_LIMIT_INFO
{
	DWORD							dwSize;
} NET_OUT_PAN_GROUP_LIMIT_INFO;

// 设置水平旋转组边界值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PTZSetPanGroupLimit(LLONG lLoginID, const NET_IN_PAN_GROUP_LIMIT_INFO *pstInParam, NET_OUT_PAN_GROUP_LIMIT_INFO *pstOutParam, DWORD dwWaitTime);

// 执行上次被打断的历史任务, 入参
typedef struct tagNET_IN_RESUME_PTZ_LASTTASK_INFO
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 正确通道号，范围 0~设备通道数
} NET_IN_RESUME_PTZ_LASTTASK_INFO;

// 执行上次被打断的历史任务, 出参
typedef struct tagNET_OUT_RESUME_PTZ_LASTTASK_INFO
{
	DWORD							dwSize;							// 结构体大小
} NET_OUT_RESUME_PTZ_LASTTASK_INFO;

// 两个作用：
//			1、执行上次被打断的历史任务包括：循迹、巡航、线扫、水平旋转，命令执行中被人为移动云台打断，而非正常结束
//			2、该命令将启用火情报警联动动作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResumePtzLastTask(LLONG lLoginID, const NET_IN_RESUME_PTZ_LASTTASK_INFO *pstInParam, NET_OUT_RESUME_PTZ_LASTTASK_INFO *pstOutParam, DWORD dwWaitTime);

// 暂停当前云台动作, 入参
typedef struct tagNET_IN_PAUSE_PTZ_ACTION_INFO
{
	DWORD							dwSize;							// 结构体大小
	int								nChannelID;						// 通道ID
} NET_IN_PAUSE_PTZ_ACTION_INFO;

// 暂停当前云台动作，出参
typedef struct tagNET_OUT_PAUSE_PTZ_ACTION_INFO
{
	DWORD							dwSize;							// 结构体大小
} NET_OUT_PAUSE_PTZ_ACTION_INFO;

// 暂停云台当前动作
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePtzAction(LLONG lLoginID, const NET_IN_PAUSE_PTZ_ACTION_INFO *pstInParam, NET_OUT_PAUSE_PTZ_ACTION_INFO *pstOutParam, DWORD dwWaitTime);


/////////////////////////////////智能分析服务接口 开始/////////////////////////////////
#define MAX_ANALYSE_REMAIN_CAPACITY_NUM     32      // 智能分析最大剩余数量
#define MAX_ANALYSE_RULE_COUNT              32      // 最大分析规则条数
#define MAX_ANALYSE_PICTURE_FILE_NUM        32      // 图片文件最大数量
#define MAX_ANALYSE_TASK_NUM                64      // 最大智能分析任务个数
#define MAX_ANALYSE_FILTER_EVENT_NUM        64      // 最大支持过滤的事件个数
#define MAX_ANALYSE_ALGORITHM_NUM           16      // 最大算法数量
#define MAX_ANALYSE_TOTALCAPS_NUM           32      // 最大的智能分析总能力数量

// 智能分析剩余能力具体信息
typedef struct tagNET_REMAIN_ANALYSE_CAPACITY
{
    UINT                    nMaxStreamNum;      // 剩余能分析的视频流数目
    EM_SCENE_CLASS_TYPE     emClassType;        // 大类业务方案
    BYTE                    byReserved[1024];   // 保留字节
} NET_REMAIN_ANALYSE_CAPACITY;

// 智能分析剩余能力
typedef struct tagNET_CB_REMAIN_CAPACITY
{
    UINT                            nRemainCapacityNum;                                     // 智能分析剩余能力数量
    NET_REMAIN_ANALYSE_CAPACITY     stuRemainCapacities[MAX_ANALYSE_REMAIN_CAPACITY_NUM];   // 智能分析剩余能力
    BYTE                            byReserved[1024];                                       // 保留字节
} NET_CB_REMAIN_CAPACITY;

// 订阅剩余智能分析资源回调函数原形,lAttachHandle是CLIENT_IntelliAttachResource返回值
typedef void (CALLBACK *fAttachRemainAnalyseResourceCB) (LLONG lAttachHandle, NET_CB_REMAIN_CAPACITY* pstRemainCapacity, LDWORD dwUser);

// CLIENT_AttachRemainAnalyseResource 接入输出参数
typedef struct tagNET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE
{
    DWORD                             dwSize;                             // 结构体大小
    BYTE                              byReserved[4];                      // 用于字节对齐
    fAttachRemainAnalyseResourceCB    cbAttachResource;                   // 剩余智能分析资源回调函数
    LDWORD                            dwUser;                             // 用户数据
} NET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE;

// 智能分析数据源类型
typedef enum tagEM_DATA_SOURCE_TYPE
{
    EM_DATA_SOURCE_REMOTE_REALTIME_STREAM = 1,  // 远程实时流 , 对应 NET_REMOTE_REALTIME_STREAM_INFO
    EM_DATA_SOURCE_PUSH_PICFILE,                // 主动推送图片文件, 对应 NET_PUSH_PICFILE_INFO
} EM_DATA_SOURCE_TYPE;

// 人脸属性类型
typedef enum tagNET_EM_FACEFEATURE_TYPE
{
	NET_EM_FACEFEATURE_UNKNOWN,			// 未知
	NET_EM_FACEFEATURE_SEX,				// 性别
	NET_EM_FACEFEATURE_AGE,				// 年龄
	NET_EM_FACEFEATURE_EMOTION,			// 表情
	NET_EM_FACEFEATURE_GLASSES,			// 眼镜状态
	NET_EM_FACEFEATURE_RACE,			// 人种
	NET_EM_FACEFEATURE_EYE,				// 眼睛状态
	NET_EM_FACEFEATURE_MOUTH,			// 嘴巴状态
	NET_EM_FACEFEATURE_MASK,			// 口罩状态
	NET_EM_FACEFEATURE_BEARD,			// 胡子状态
	NET_EM_FACEFEATURE_ATTRACTIVE,		// 魅力值
} NET_EM_FACEFEATURE_TYPE;

// 事件类型EVENT_IVS_FACEANALYSIS(人脸分析事件) 对应的规则配置
typedef struct tagNET_FACEANALYSIS_RULE_INFO
{
	DWORD                   	dwSize;                             	// 结构体大小
	int							nDetectRegionPoint;						// 检测区顶点数
	POINTCOORDINATE				stuDetectRegion[20];					// 检测区
	int                 		nSensitivity;                           // 灵敏度,范围[1,10],灵敏度越高越容易检测
	int							nLinkGroupNum;							// 联动布控个数 
	NET_CFG_LINKGROUP_INFO		stuLinkGroup[20];						// 联动的布控组
	NET_CFG_STRANGERMODE_INFO	stuStrangerMode;						// 陌生人布防模式
    BOOL                		bSizeFileter;                           // 规则特定的尺寸过滤器是否有效
	NET_CFG_SIZEFILTER_INFO 	stuSizeFileter;                         // 规则特定的尺寸过滤器
	BOOL						bFeatureEnable;							// 是否开启人脸属性识别, IPC增加
	int							nFaceFeatureNum;						// 需要检测的人脸属性个数
	NET_EM_FACEFEATURE_TYPE 	emFaceFeatureType[32];					// 需检测的人脸属性
	BOOL						bFeatureFilter;							// 在人脸属性开启前提下，如果人脸图像质量太差，是否不上报属性
																		// true-图像太差不上报属性 false-图像很差也上报属性(可能会非常不准，影响用户体验)
	int							nMinQuality;							// 人脸图片质量阈值,和bFeatureFilter一起使用 范围[1,100]
} NET_FACEANALYSIS_RULE_INFO;

// 视频支持的人脸类型
typedef enum tagNET_ANALYSE_HUMANFACE_TYPE
{
    NET_ANALYSE_HUMANFACE_TYPE_UNKNOWN,        // 未知类型
    NET_ANALYSE_HUMANFACE_TYPE_NORMAL,         // 普通人脸
    NET_ANALYSE_HUMANFACE_TYPE_HIDEEYE,        // 眼部遮挡
    NET_ANALYSE_HUMANFACE_TYPE_HIDENOSE,       // 鼻子遮挡
    NET_ANALYSE_HUMANFACE_TYPE_HIDEMOUTH,      // 嘴部遮挡
    NET_ANALYSE_HUMANFACE_TYPE_ADJACENTFACE,   // 相邻人脸 (注，ATM，尾随)
    NET_ANALYSE_HUMANFACE_TYPE_ABNORMALFACE,   // 异常人脸
    NET_ANALYSE_HUMANFACE_TYPE_HELMETFACE,     // 头盔人脸(如摩托车盔)
}NET_ANALYSE_HUMANFACE_TYPE;

// 事件类型EVENT_IVS_HUMANTRAIT(人员检测规则)对应的规则配置
typedef struct tagNET_HUMANTRAIT_RULE_INFO
{
	DWORD                   	dwSize;                             			// 结构体大小
    int                    		nHumanFaceTypeNum;                              // 支持的人脸检测类型个数
    NET_ANALYSE_HUMANFACE_TYPE 	emHumanFaceType[8];           					// 支持的人脸检测类型列表

    int                         nMinDuration;                                   // 最短触发时间,单位：秒
    int                         nTriggerTargets;                                // 触发报警的人脸个数
    int                         nSensitivity;                                   // 灵敏度,越高越容易检测, 0-10
    BOOL                        bSizeFileter;                                   // 是否使用尺寸过滤器
    NET_CFG_SIZEFILTER_INFO     stuSizeFileter;                             	// 规则特定的尺寸过滤器，提高判断精度
    BOOL                        bFeatureEnable;                                 // 是否开启人脸属性识别
    BOOL                        bFeatureFilter;                                 // 在人脸属性开启前提下，如果人脸图像质量太差，是否不上报属性  true-图像太差不上报属性;false-图像很差也上报属性(可能会非常不准，影响用户体验)
    int                         nMinQuality;                                    // 人脸图片质量阈值,和bFeatureFilter一起使用

    int					        nFaceFeatureNum;								// 需要检测的人脸属性个数
    NET_EM_FACEFEATURE_TYPE     emFaceFeatureType[32];							// 需检测的人脸属性
}NET_HUMANTRAIT_RULE_INFO;

//检测方向
typedef enum tagEM_DETECT_DIRECTION_TYPE
{
	EM_DETECT_DIRECTION_UNKNOWN = 0,											// 未知
	EM_DETECT_DIRECTION_LEFT_TO_RIGHT,											// 从左向右
	EM_DETECT_DIRECTION_RIGHT_TO_LEFT,											// 从右向左
}EM_DETECT_DIRECTION_TYPE;

// XRAY检测方案
typedef enum tagEM_XRAY_SCHEME_TYPE
{
	EM_XRAY_SCHEME_UNKNOWN,			// 未知
	EM_XRAY_SCHEME_TONGFANG_100,	// 同方100
	EM_XRAY_SCHEME_TONGFANG_200,	// 同方200
	EM_XRAY_SCHEME_TONGFANG_300,	// 同方300
	EM_XRAY_SCHEME_TONGFANG_400,	// 同方400
	EM_XRAY_SCHEME_ANTIANXIA_100,	// 安天下100
	EM_XRAY_SCHEME_ANTIANXIA_200,	// 安天下200
	EM_XRAY_SCHEME_DAHUA_100,		// 大华100
	EM_XRAY_SCHEME_DAHUA_200,		// 大华200
	EM_XRAY_SCHEME_DAHUA_300,		// 大华300
	EM_XRAY_SCHEME_DAHUA_400,		// 大华400
	EM_XRAY_SCHEME_DAHUA_301,		// 大华301
	EM_XRAY_SCHEME_SHANGCHEN_HIGH,	// 上琛高检出
	EM_XRAY_SCHEME_SHANGCHEN_LOW,	// 上琛低误检
} EM_XRAY_SCHEME_TYPE;

// XRAY物体上报规则
typedef struct tagNET_XRAY_OBJECT_UPLOAD_RULE
{
	BOOL					bUploadEnable;				// 上报使能
	UINT					nSimilarity;				// 物体上报相似度, [1,100]
	BYTE                    byReserved[128];            // 保留字节
} NET_XRAY_OBJECT_UPLOAD_RULE;

// XRAY物体检测规则
typedef struct tagNET_XRAY_OBJECT_DETECT_RULE
{
	EM_INSIDE_OBJECT_TYPE		emObjectType;				// 物体名称
	BOOL						bDetectEnable;				// 检测使能
	EM_DANGER_GRADE_TYPE		emDangerGrade;				// 安全等级
	NET_XRAY_OBJECT_UPLOAD_RULE	stuUploadRuleInfo;			// 物体上报规则信息
	BYTE                    	byReserved[512];            // 保留字节
} NET_XRAY_OBJECT_DETECT_RULE;

// EVENT_IVS_XRAY_DETECT_BYOBJECT(X光按物体检测)对应的规则配置
typedef struct tagNET_XRAY_DETECT_BYPBJECT_RULE_INFO
{
    DWORD                       dwSize;                             // 结构体大小
    int                         nDetectRegionPoint;                 // 检测区顶点数
    POINTCOORDINATE             stuDetectRegion[20];                // 检测区
    UINT                        nSensitivity;                       // 灵敏度,[1,10]
    EM_DETECT_DIRECTION_TYPE    emDirectionType;                    // 检测方向
    EM_XRAY_SCHEME_TYPE         emSchemeType;                       // 检查方案
    UINT                        nObjectRuleNum;                     // XRAY物体检测规则数量
    NET_XRAY_OBJECT_DETECT_RULE stuObjectRuleInfo[128];             // XRAY物体检测规则信息
    EM_XRAY_VIEW_TYPE           emViewType;                         // 视角类型
} NET_XRAY_DETECT_BYPBJECT_RULE_INFO;

// 非机动车属性类型
typedef enum tagEM_NONMOTOR_FEATURE
{
    EM_NONMOTOR_FEATURE_UNKNOWN,                    // 未知
    EM_NONMOTOR_FEATURE_HELMET,                     // 头盔
    EM_NONMOTOR_FEATURE_NUMOFCYCLING,               // 车上人数
    EM_NONMOTOR_FEATURE_NONMOTORCOLOR,              // 车身颜色
    EM_NONMOTOR_FEATURE_SEX,                        // 性别
    EM_NONMOTOR_FEATURE_AGE,                        // 年龄
    EM_NONMOTOR_FEATURE_HAT,                        // 帽子
    EM_NONMOTOR_FEATURE_BAG,                        // 背包
    EM_NONMOTOR_FEATURE_CARRIERBAG,                 // 手提包
    EM_NONMOTOR_FEATURE_UMBRELLA,                   // 雨伞
    EM_NONMOTOR_FEATURE_UPPERBODYCOLOR,             // 上衣颜色
    EM_NONMOTOR_FEATURE_LOWERBODYCOLOR,             // 下衣颜色
    EM_NONMOTOR_FEATURE_UPCLOTHES,                  // 上衣类型
    EM_NONMOTOR_FEATURE_DOWNCLOTHES,                // 下衣类型
    EM_NONMOTOR_FEATURE_CATEGORY,                   // 车类型
}EM_NONMOTOR_FEATURE;

// 事件类型EVENT_IVS_NONMOTORDETECT(非机动车事件)对应的规则配置
typedef struct tagNET_NONMOTORDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             			// 结构体大小
    int					        nFeatureNum;								    // 支持的非机动车属性个数
    EM_NONMOTOR_FEATURE      	emFeatureList[32];             					// 支持的非机动车属性列表
}NET_NONMOTORDETECT_RULE_INFO;

// 事件类型EVENT_IVS_VEHICLEDETECT(机动车事件)对应的规则配置
typedef struct tagNET_VEHICLEDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             			// 结构体大小
    int                         nSnapThreshold;                                 // 车辆抓拍阈值,是一个百分数，表示当车辆检测框高度占画面百分比大于这个阈值时，触发规则进行抓拍。
}NET_VEHICLEDETECT_RULE_INFO;

// 安全帽检测规则
typedef struct tagNET_HELMET_DETECT_RULE
{
	BOOL				bEnable;			// 是否检测安全帽
	BOOL				bWear;				// 是否检测穿戴安全帽
	BOOL				bDetectColor;		// 是否指定检测的颜色
	EM_CLOTHES_COLOR	emHelmetColor;		// 安全帽颜色, bDetectColor 为 TRUE 时有效
	BYTE                byReserved[128];	// 保留字节
} NET_HELMET_DETECT_RULE;

// 工作服检测规则
typedef struct tagNET_WORKCLOTH_DETECT_RULE
{
	BOOL				bEnable;			// 是否检测工作服
	BOOL				bWear;				// 是否检测穿着工作服
	BOOL				bDetectColor;		// 是否指定检测的颜色
	EM_CLOTHES_COLOR	emClothesColor;		// 工作服颜色, bDetectColor 为 TRUE 时有效
	BYTE                byReserved[128];	// 保留字节
} NET_WORKCLOTH_DETECT_RULE;

// 工作马甲检测规则
typedef struct tagNET_WORKVEST_DETECT_RULE
{
	BOOL				bEnable;			// 是否检测马甲
	BOOL				bWear;				// 是否检测穿着马甲
	BOOL				bDetectColor;		// 是否指定检测的颜色
	EM_CLOTHES_COLOR	emVestColor;		// 马甲颜色, bDetectColor 为 TRUE 时有效
	BYTE                byReserved[128];	// 保留字节
} NET_WORKVEST_DETECT_RULE;

// 工装特征描述信息
typedef struct tagNET_WORKCLOTHES_DESCRIPT
{
	NET_HELMET_DETECT_RULE		stuHelemetRule;		// 安全帽检测规则
	NET_WORKCLOTH_DETECT_RULE	stuWorkClothRule;	// 工作服检测规则
	NET_WORKVEST_DETECT_RULE	stuWorkVestRule;	// 工作马甲检测规则
	BYTE                		byReserved[1024];	// 保留字节
} NET_WORKCLOTHES_DESCRIPT;

// 事件类型EVENT_IVS_WORKCLOTHDETECT(工装检测事件)对应的规则配置
typedef struct tagNET_WORKCLOTHDETECT_RULE_INFO
{
	DWORD                   	dwSize;                             	// 结构体大小
	UINT						nDetectRegionPoint;						// 检测区顶点数
	POINTCOORDINATE				stuDetectRegion[20];					// 检测区
	UINT						nDescriptNum;							// 工装描述信息个数
	NET_WORKCLOTHES_DESCRIPT	stuWorkClothesDescript[64];				// 工装描述信息, 数组各项是逻辑或关系
} NET_WORKCLOTHDETECT_RULE_INFO;

// 触发报警的条件表达式
typedef enum tagEM_CONDITION_EXPR_TYPE
{
	EM_CONDITION_EXPR_UNKNOWN		= 0,	// 未知
	EM_CONDITION_EXPR_GREATER,				// 大于
	EM_CONDITION_EXPR_LESS, 				// 小于
	EM_CONDITION_EXPR_EQUAL,				// 等于
} EM_CONDITION_EXPR_TYPE;

// 作业统计描述信息
typedef struct tagNET_WORKSTAT_DESCRIPT
{
	NET_WORKCLOTHES_DESCRIPT	stuWorkClothesDescript;	// 工装特征描述信息
	UINT						nTriggerNum;			// 触发报警的人员数量
	EM_CONDITION_EXPR_TYPE		emConditionExpr;		// 条件表达式，与nTriggerNum组合使用，当满足(emConditionExpr nTriggerNum) 条件时触发报警
	UINT						nStatInterval;			// 统计时长，单位秒，范围1-86400
	BYTE                		byReserved[1024];		// 保留字节
} NET_WORKSTAT_DESCRIPT;

// 事件类型EVENT_IVS_WORKSTATDETECTION(作业统计)对应的规则配置
typedef struct tagNET_WORKSTATDETECTION_RULE_INFO
{
	DWORD                   	dwSize;                             	// 结构体大小
	UINT						nStatDescriptNum;						// 作业统计描述信息个数
	NET_WORKSTAT_DESCRIPT		stuWorkStatDescript[64];				// 作业统计描述信息
} NET_WORKSTATDETECTION_RULE_INFO;

// 事件类型EVENT_IVS_CROSSLINEDETECTION(警戒线事件)对应的规则配置
typedef struct tagNET_CROSSLINE_RULE_INFO
{
	DWORD                   dwSize;                             					// 结构体大小
	int						nDirection;												// 检测方向:0:由左至右;1:由右至左;2:两者都可以
	int						nDetectLinePoint;										// 警戒线顶点数
	POINTCOORDINATE			stuDetectLine[20];										// 警戒线
	int                 	nPtzPresetId;											// 云台预置点编号	0~65535
	BOOL                	bSizeFileter;                                           // 规则特定的尺寸过滤器是否有效
	NET_CFG_SIZEFILTER_INFO stuSizeFileter;                                         // 规则特定的尺寸过滤器
	int                 	nTriggerPosition;                                       // 触发报警位置数
	BYTE                	bTriggerPosition[8];                                    // 触发报警位置,0-目标外接框中心, 1-目标外接框左端中心, 2-目标外接框顶端中心, 3-目标外接框右端中心, 4-目标外接框底端中心
	int						nTrackDuration;											// 跟踪持续时间,单位秒, 范围[0-300]，0秒:一直跟踪, 1~300秒:跟踪持续时间
	UINT					nVehicleSubTypeNum;										// 检测的车辆子类型个数
	EM_CATEGORY_TYPE		emVehicleSubType[128];									// 检测的车辆子类型列表
} NET_CROSSLINE_RULE_INFO;

// 事件类型EVENT_IVS_CROSSREGIONDETECTION(警戒区事件)对应的规则配置
typedef struct tagNET_CROSSREGION_RULE_INFO
{
	DWORD                   dwSize;                             					// 结构体大小
	int						nDirection;												// 检测方向:0:Enter;1:Leave;2:Both
	int						nDetectRegionPoint;										// 警戒区顶点数
	POINTCOORDINATE			stuDetectRegion[20];									// 警戒区
	BOOL                	bSizeFileter;                                           // 规则特定的尺寸过滤器是否有效
	NET_CFG_SIZEFILTER_INFO stuSizeFileter;                                         // 规则特定的尺寸过滤器
	int                 	nActionType;                                            // 检测动作个数
	BYTE                	bActionType[4];                                         // 检测动作列表,0-出现 1-消失 2-在区域内 3-穿越区域
	int                 	nMinTargets;                                            // 最小目标个数(当bActionType中包含"2-在区域内"时有效)
	int                 	nMaxTargets;                                            // 最大目标个数(当bActionType中包含"2-在区域内"时有效)
	int                 	nMinDuration;                                           // 最短持续时间， 单位秒(当bActionType中包含"2-在区域内"时有效)
	int                 	nReportInterval;                                        // 报告时间间隔， 单位秒(当bActionType中包含"2-在区域内"时有效)
	int						nTrackDuration;											// 跟踪持续时间,0秒:一直跟踪,1~300秒:跟踪持续时间
	UINT					nVehicleSubTypeNum;										// 检测的车辆子类型个数
	EM_CATEGORY_TYPE		emVehicleSubType[128];									// 检测的车辆子类型列表
} NET_CROSSREGION_RULE_INFO;


// 进行特征提取的类型
typedef enum tagEM_FEATURE_ABSTRACT_TYPE
{
    EM_FEATURE_ABSTRACT_UNKNOWN = -1,      // 未知 
    EM_FEATURE_ABSTRACT_FACE,              // 人脸 
    EM_FEATURE_ABSTRACT_HUMAN_TRAIT,       // 人体 
    EM_FEATURE_ABSTRACT_VEHICLE,           // 机动车
    EM_FEATURE_ABSTRACT_NON_MOTOR_VEHICLE, // 非机动车 
}EM_FEATURE_ABSTRACT_TYPE;

// 事件类型EVENT_IVS_FEATURE_ABSTRACT(提取特征)对应的规则配置
typedef struct tagNET_FEATURE_ABSTRACT_RULE_INFO
{
    DWORD                   dwSize;                     // 结构体大小
    int                     nFeature;                   // 特征的数量
    char                    szFeatureVersions[10][32];  // 对图片进行特征向量提取时使用，需要对图片进行同一种特征向量多个版本进行提取,最大是10个版本
	EM_FEATURE_ABSTRACT_TYPE emAbstractType;            // 进行特征提取的类型
}NET_FEATURE_ABSTRACT_RULE_INFO;

// 电力手套特征
typedef struct tagNET_ELECTRIC_GLOVE_FEATURE
{
    BOOL                bInsulate;              // 是否绝缘, TRUE:绝缘手套, FALSE:普通手套
    BYTE                byReserved[1028];	    // 保留字节
} NET_ELECTRIC_GLOVE_FEATURE;

// 电力检测手套检测规则条件
typedef struct tagNET_ELECTRIC_GLOVE_DETECT_CONDITION
{
    BOOL                        bExist;             // 是否检测, 与bGloveFeature 和stuGloveFeature配合使用
                                                    // (1) 若bGloveFeature=FALSE， 则表示检测是否有手套
                                                    // (2) 若bGloveFeature=TRUE, bExist=TRUE, 则表示检测符合stuGloveFeature的手套
                                                    // (3) 若bGloveFeature=TRUE, bExist=FALSE, 则表示检测不符合stuGloveFeature的手套
    BOOL                        bGloveFeature;      // 手套特征是否有效
    NET_ELECTRIC_GLOVE_FEATURE  stuGloveFeature;    // 手套特征
    BYTE                		byReserved[512];	// 保留字节
} NET_ELECTRIC_GLOVE_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_GLOVE_DETECT(电力检测手套检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_GLOVE_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_GLOVE_DETECT_CONDITION     stuGloveDetectCondition[32];    // 手套检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_GLOVE_DETECT_RULE_INFO;

// 电力梯子特征
typedef struct tagNET_ELECTRIC_LADDER_FEATURE
{
    BOOL                bInsulate;              // 是否绝缘 , TRUE:绝缘梯子, FALSE:普通梯子
    BYTE                byReserved[1028];	    // 保留字节
} NET_ELECTRIC_LADDER_FEATURE;

// 电力检测梯子检测规则条件
typedef struct tagNET_ELECTRIC_LADDER_DETECT_CONDITION
{
    BOOL                        bExist;             // 是否检测, 与bLadderFeature 和stuLadderFeature配合使用
                                                    // (1) 若bLadderFeature=FALSE， 则表示检测是否有梯子
                                                    // (2) 若bLadderFeature=TRUE, bExist=TRUE, 则表示检测符合stuLadderFeature的梯子
                                                    // (3) 若bLadderFeature=TRUE, bExist=FALSE, 则表示检测不符合stuLadderFeature的梯子
    BOOL                        bLadderFeature;     // 梯子特征是否有效
    NET_ELECTRIC_LADDER_FEATURE stuLadderFeature;   // 梯子特征
    BYTE                		byReserved[512];    // 保留字节
} NET_ELECTRIC_LADDER_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_LADDER_DETECT(电力检测梯子检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_LADDER_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_LADDER_DETECT_CONDITION    stuLadderDetectCondition[32];   // 梯子检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_LADDER_DETECT_RULE_INFO;

//颜色操作关系
typedef enum tagEM_COLOR_OPERATE_TYPE
{
    EM_COLOR_OPERATE_TYPE_UNKNOWN   = -1,   // 未知
    EM_COLOR_OPERATE_TYPE_UNEQUAL,          // !=
    EM_COLOR_OPERATE_TYPE_EQUAL,            // == 
} EM_COLOR_OPERATE_TYPE;

// 颜色特征
typedef struct tagNET_COLOR_FEATRUE
{
    EM_COLOR_OPERATE_TYPE   emColorOperate;     // 颜色操作关系
    EM_UNIFIED_COLOR_TYPE   emColor;            // 颜色
    BYTE                    byReserved[128];    // 保留字节
} NET_COLOR_FEATRUE;

// 电力布幔特征
typedef struct tagNET_ELECTRIC_CURTAIN_FEATURE
{
    NET_COLOR_FEATRUE   stuColorFeature;        // 颜色特征
    BYTE                byReserved[1024];	    // 保留字节
} NET_ELECTRIC_CURTAIN_FEATURE;

// 电力检测布幔检测规则条件
typedef struct tagNET_ELECTRIC_CURTAIN_DETECT_CONDITION
{
    BOOL                            bExist;             // 是否检测, 与bCurtainFeature 和stuCurtainFeature配合使用
                                                        // (1) 若bCurtainFeature=FALSE， 则表示检测是否有布幔
                                                        // (2) 若bCurtainFeature=TRUE, bExist=TRUE, 则表示检测符合stuCurtainFeature的布幔
                                                        // (3) 若bCurtainFeature=TRUE, bExist=FALSE, 则表示检测不符合stuCurtainFeature的布幔
    BOOL                            bCurtainFeature;    // 布幔特征是否有效
    NET_ELECTRIC_CURTAIN_FEATURE    stuCurtainFeature;  // 布幔特征
    BYTE                		    byReserved[512];    // 保留字节
} NET_ELECTRIC_CURTAIN_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_CURTAIN_DETECT(电力检测布幔检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_CURTAIN_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_CURTAIN_DETECT_CONDITION   stuCurtainDetectCondition[32];  // 布幔检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_CURTAIN_DETECT_RULE_INFO;

// 电力围栏特征
typedef struct tagNET_ELECTRIC_FENCE_FEATURE
{
    EM_ELECTRIC_FENCE_TYPE  emFenceType;            // 围栏类型
    BYTE                    byReserved[1028];	    // 保留字节
} NET_ELECTRIC_FENCE_FEATURE;

// 电力检测围栏检测规则条件
typedef struct tagNET_ELECTRIC_FENCE_DETECT_CONDITION
{
    BOOL                            bExist;             // 是否检测, 与bFenceFeature 和stuFenceFeature配合使用
                                                        // (1) 若bFenceFeature=FALSE， 则表示检测是否有围栏
                                                        // (2) 若bFenceFeature=TRUE, bExist=TRUE, 则表示检测符合stuFenceFeature的围栏
                                                        // (3) 若bFenceFeature=TRUE, bExist=FALSE, 则表示检测不符合stuFenceFeature的围栏
    BOOL                            bFenceFeature;      // 围栏特征是否有效
    NET_ELECTRIC_FENCE_FEATURE      stuFenceFeature;    // 围栏特征
    BYTE                		    byReserved[512];    // 保留字节
} NET_ELECTRIC_FENCE_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_FENCE_DETECT(电力检测围栏检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_FENCE_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_FENCE_DETECT_CONDITION     stuFenceDetectCondition[32];    // 围栏检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_FENCE_DETECT_RULE_INFO;

// 电力标识牌特征
typedef struct tagNET_ELECTRIC_SIGNBOARD_FEATURE
{
    EM_ELECTRIC_SIGNBOARD_TYPE  emSignboardType;        // 标识牌类型
    BYTE                        byReserved[1028];	    // 保留字节
} NET_ELECTRIC_SIGNBOARD_FEATURE;

// 电力检测标识牌检测规则条件
typedef struct tagNET_ELECTRIC_SIGNBOARD_DETECT_CONDITION
{
    BOOL                            bExist;                 // 是否检测, 与bSignboardFeature 和stuSignboardFeature配合使用
                                                            // (1) 若bSignboardFeature=FALSE， 则表示检测是否有标识牌
                                                            // (2) 若bSignboardFeature=TRUE, bExist=TRUE, 则表示检测符合stuSignboardFeature的标识牌
                                                            // (3) 若bSignboardFeature=TRUE, bExist=FALSE, 则表示检测不符合stuSignboardFeature的标识牌
    BOOL                            bSignboardFeature;      // 标识牌特征是否有效
    NET_ELECTRIC_SIGNBOARD_FEATURE  stuSignboardFeature;    // 标识牌特征
    BYTE                		    byReserved[512];        // 保留字节
} NET_ELECTRIC_SIGNBOARD_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(电力检测标识牌检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_SIGNBOARD_DETECT_CONDITION stuSignboardCondition[32];      // 标识牌检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO;

// 电力安全带特征
typedef struct tagNET_ELECTRIC_BELT_FEATURE
{
    EM_BELT_WARE_TYPE           emBeltWareType;         // 安全带穿戴方式
    BYTE                        byReserved[1028];	    // 保留字节
} NET_ELECTRIC_BELT_FEATURE;

// 电力安全带检测规则条件
typedef struct tagNET_ELECTRIC_BELT_DETECT_CONDITION
{
    BOOL                            bExist;                 // 是否检测, 与bBeltFeature 和stuBeltFeature配合使用
                                                            // (1) 若bBeltFeature=FALSE， 则表示检测是否有安全带
                                                            // (2) 若bBeltFeature=TRUE, bExist=TRUE, 则表示检测符合stuBeltFeature的安全带
                                                            // (3) 若bBeltFeature=TRUE, bExist=FALSE, 则表示检测不符合stuBeltFeature的安全带
    BOOL                            bBeltFeature;           // 安全带特征是否有效
    NET_ELECTRIC_BELT_FEATURE       stuBeltFeature;         // 安全带特征
    BYTE                		    byReserved[512];        // 保留字节
} NET_ELECTRIC_BELT_DETECT_CONDITION;

// 事件类型EVENT_IVS_ELECTRIC_BELT_DETECT(电力检测安全带检测事件)对应的规则配置
typedef struct tagNET_ELECTRIC_BELT_DETECT_RULE_INFO
{
    DWORD                                   dwSize;                         // 结构体大小
    int						                nDetectRegionPoint;             // 检测区顶点数
	POINTCOORDINATE			                stuDetectRegion[20];            // 检测区域
	NET_CFG_SIZEFILTER_INFO                 stuSizeFileter;                 // 规则特定的尺寸过滤器
	BOOL                	                bSizeFileter;                   // 规则特定的尺寸过滤器是否有效
	
	UINT                                    nDetectConditionNum;            // 检测条件个数
	NET_ELECTRIC_BELT_DETECT_CONDITION      stuBeltCondition[32];           // 安全带检测条件, 各个条件之间是逻辑或的关系
} NET_ELECTRIC_BELT_DETECT_RULE_INFO;

// 智能分析规则信息
typedef struct tagNET_ANALYSE_RULE_INFO
{
    EM_SCENE_CLASS_TYPE             emClassType;                        // 分析大类类型
    DWORD                           dwRuleType;                         // 规则类型, 详见dhnetsdk.h中"智能分析事件类型"
    																	// EVENT_IVS_FACEANALYSIS(人脸分析)对应结构体 NET_FACEANALYSIS_RULE_INFO
    																	// EVENT_IVS_NONMOTORDETECT(非机动车)对应结构体 NET_NONMOTORDETECT_RULE_INFO
    																	// EVENT_IVS_VEHICLEDETECT(机动车) 对应结构体 NET_VEHICLEDETECT_RULE_INFO
    																	// EVENT_IVS_HUMANTRAIT(人体) 对应结构体NET_HUMANTRAIT_RULE_INFO
    																	// EVENT_IVS_XRAY_DETECT_BYOBJECT(X光按物体检测) 对应结构体 NET_XRAY_DETECT_BYPBJECT_RULE_INFO
																		// EVENT_IVS_WORKCLOTHES_DETECT(工装检测)对应结构体NET_WORKCLOTHDETECT_RULE_INFO
    																	// EVENT_IVS_WORKSTATDETECTION(作业统计)对应结构体NET_WORKSTATDETECTION_RULE_INFO
    																	// EVENT_IVS_CROSSLINEDETECTION(警戒线)对应结构体NET_CROSSLINE_RULE_INFO
    																	// EVENT_IVS_CROSSREGIONDETECTION(警戒区)对应结构体 NET_CROSSREGION_RULE_INFO
                                                                        // EVENT_IVS_FEATURE_ABSTRACT(特征提取)对应结构体 NET_FEATURE_ABSTRACT_RULE_INFO  
                                                                        // EVENT_IVS_ELECTRIC_GLOVE_DETECT(电力检测手套检测事件)对应结构体NET_ELECTRIC_GLOVE_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_LADDER_DETECT(电力检测梯子检测事件)对应结构体NET_ELECTRIC_LADDER_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_CURTAIN_DETECT(电力检测布幔检测事件)对应结构体NET_ELECTRIC_CURTAIN_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_FENCE_DETECT(电力检测围栏检测事件)对应结构体NET_ELECTRIC_FENCE_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_SIGNBOARD_DETECT(电力检测标识牌检测事件)对应结构体NET_ELECTRIC_SIGNBOARD_DETECT_RULE_INFO
                                                                        // EVENT_IVS_ELECTRIC_BELT_DETECT(电力检测安全带检测事件)对应结构体NET_ELECTRIC_BELT_DETECT_RULE_INFO
    void*				            pReserved;							// 规则配置, 具体结构体类型根据dwRuleType来确定, 具体信息见dwRuleType的注释
    UINT							nObjectTypeNum;						// 检测物体类型个数, 为0 表示不指定物体类型
    EM_ANALYSE_OBJECT_TYPE			emObjectTypes[16];					// 检测物体类型列表
    BYTE                            byReserved[956];                    // 保留字节
} NET_ANALYSE_RULE_INFO;

// 智能分析规则
typedef struct tagNET_ANALYSE_RULE
{
    NET_ANALYSE_RULE_INFO           stuRuleInfos[MAX_ANALYSE_RULE_COUNT];       // 分析规则信息
    UINT                            nRuleCount;                                 // 分析规则条数
    BYTE                            byReserved[1028];                           // 保留字节
} NET_ANALYSE_RULE;

// 视频流协议类型
typedef enum tagEM_STREAM_PROTOCOL_TYPE
{
    EM_STREAM_PROTOCOL_UNKNOWN,         // 未知
    EM_STREAM_PROTOCOL_PRIVATE_V2,      // 私有二代
    EM_STREAM_PROTOCOL_PRIVATE_V3,      // 私有三代
    EM_STREAM_PROTOCOL_RTSP,            // rtsp
    EM_STREAM_PROTOCOL_ONVIF,           // Onvif
    EM_STREAM_PROTOCOL_GB28181,         // GB28181
} EM_STREAM_PROTOCOL_TYPE;

typedef enum tagEM_ANALYSE_TASK_START_RULE
{
    EM_ANALYSE_TASK_START_NOW,          // 立刻启动
    EM_ANALYSE_TASK_START_LATER,        // 稍候手动启动
} EM_ANALYSE_TASK_START_RULE;

// 远程实时视频源信息
typedef struct tagNET_REMOTE_REALTIME_STREAM_INFO
{
    DWORD                           dwSize;                                 // 结构体大小
    EM_ANALYSE_TASK_START_RULE      emStartRule;                            // 智能任务启动规则
    NET_ANALYSE_RULE                stuRuleInfo;                            // 分析规则信息
    EM_STREAM_PROTOCOL_TYPE         emStreamProtocolType;                   // 视频流协议类型
    char                            szPath[DH_COMMON_STRING_256];           // 视频流地址
    char                	        szIp[DH_MAX_IPADDR_OR_DOMAIN_LEN];      // IP 地址
	WORD                 	        wPort;                      		    // 端口号
    BYTE                            byReserved[2];                          // 用于字节对齐
    char                	        szUser[DH_COMMON_STRING_64];            // 用户名
    char                	        szPwd[DH_COMMON_STRING_64];             // 密码
    int                 	        nChannelID;                             // 通道号
    UINT                            nStreamType;                            // 码流类型, 0:主码流; 1:辅1码流; 2:辅2码流;
} NET_REMOTE_REALTIME_STREAM_INFO;

// 推送图片文件信息
typedef struct tagNET_PUSH_PICFILE_INFO
{
    DWORD                           dwSize;                                 // 结构体大小
    EM_ANALYSE_TASK_START_RULE      emStartRule;                            // 智能任务启动规则
    NET_ANALYSE_RULE                stuRuleInfo;                            // 分析规则信息
} NET_PUSH_PICFILE_INFO;

// CLIENT_AddAnalyseTask 接口输出参数
typedef struct tagNET_OUT_ADD_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskID;                                // 任务ID
    UINT                            nVirtualChannel;                        // 任务对应的虚拟通道号
} NET_OUT_ADD_ANALYSE_TASK;

// CLIENT_StartAnalyseTask 接口输入参数
typedef struct tagNET_IN_START_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskID;                                // 任务ID
} NET_IN_START_ANALYSE_TASK;

// CLIENT_StartAnalyseTask 接口输出参数
typedef struct tagNET_OUT_START_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_START_ANALYSE_TASK;

// CLIENT_RemoveAnalyseTask 接口输入参数
typedef struct tagNET_IN_REMOVE_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskID;                                // 任务ID
} NET_IN_REMOVE_ANALYSE_TASK;

// CLIENT_RemoveAnalyseTask 接口输出参数
typedef struct tagNET_OUT_REMOVE_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_REMOVE_ANALYSE_TASK;

// 分析状态
typedef enum tagEM_ANALYSE_STATE
{
    EM_ANALYSE_STATE_UNKNOWN,             // 未知
    EM_ANALYSE_STATE_IDLE,                // 已创建但未运行
    EM_ANALYSE_STATE_ANALYSING,           // 分析中
    EM_ANALYSE_STATE_ANALYSING_WAITPUSH,  // 分析中并等待push数据
    EM_ANALYSE_STATE_FINISH,              // 正常完成
    EM_ANALYSE_STATE_ERROR,               // 执行异常
    EM_ANALYSE_STATE_REMOVED,             // 被删除
} EM_ANALYSE_STATE;

// 智能分析任务信息
typedef struct tagNET_ANALYSE_TASKS_INFO
{
    UINT                            nTaskID;                                // 任务ID
    EM_ANALYSE_STATE                emAnalyseState;                         // 分析状态
    BYTE                            byReserved[1024];                       // 保留字节
} NET_ANALYSE_TASKS_INFO;

// CLIENT_FindAnalyseTask 接口输入参数
typedef struct tagNET_IN_FIND_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_IN_FIND_ANALYSE_TASK;

// CLIENT_FindAnalyseTask 接口输出参数
typedef struct tagNET_OUT_FIND_ANALYSE_TASK
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskNum;                               // 智能分析任务个数
    NET_ANALYSE_TASKS_INFO          stuTaskInfos[MAX_ANALYSE_TASK_NUM];     // 智能分析任务信息
} NET_OUT_FIND_ANALYSE_TASK;

// 智能分析图片信息
typedef struct tagNET_PUSH_PICTURE_INFO
{
    char                            szFileID[DH_COMMON_STRING_128];         // 文件ID
    UINT                            nOffset;                                // 文件数据在二进制数据中的偏移, 单位:字节
    UINT                            nLength;                                // 文件数据长度, 单位:字节
    NET_XRAY_CUSTOM_INFO            stuXRayCustomInfo;                      // 客户自定义信息, X光机定制专用
    BYTE                            byReserved[768];                        // 保留字节
} NET_PUSH_PICTURE_INFO;

// CLIENT_PushAnalysePictureFile 接口输入参数
typedef struct tagNET_IN_PUSH_ANALYSE_PICTURE_FILE
{
    DWORD                           dwSize;                                         // 结构体大小
    UINT                            nTaskID;                                        // 任务ID
    NET_PUSH_PICTURE_INFO           stuPushPicInfos[MAX_ANALYSE_PICTURE_FILE_NUM];  // 推送图片信息
    UINT                            nPicNum;                                        // 推送图片数量
    UINT                            nBinBufLen;                                     // 数据缓冲区长度, 单位:字节
    char*                           pBinBuf;                                        // 数据缓冲区, 由用户申请和释放
} NET_IN_PUSH_ANALYSE_PICTURE_FILE;

// CLIENT_PushAnalysePictureFile 接口输出参数
typedef struct tagNET_OUT_PUSH_ANALYSE_PICTURE_FILE
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_PUSH_ANALYSE_PICTURE_FILE;

// 智能分析任务状态回调信息
typedef struct tagNET_CB_ANALYSE_TASK_STATE_INFO
{
    NET_ANALYSE_TASKS_INFO          stuTaskInfos[MAX_ANALYSE_TASK_NUM];     // 智能分析任务信息
    UINT                            nTaskNum;                               // 任务个数
    BYTE                            byReserved[1024];                       // 保留字节
} NET_CB_ANALYSE_TASK_STATE_INFO;

// 智能分析状态订阅函数原型, lAttachHandle 为 CLIENT_AttachAnalyseTaskState 函数的返回值
typedef int  (CALLBACK *fAnalyseTaskStateCallBack)(LLONG lAttachHandle, NET_CB_ANALYSE_TASK_STATE_INFO *pstAnalyseTaskStateInfo, LDWORD dwUser);

// CLIENT_AttachAnalyseTaskState 接口输入参数
typedef struct tagNET_IN_ATTACH_ANALYSE_TASK_STATE
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskIDs[MAX_ANALYSE_TASK_NUM];         // 智能分析任务ID
    UINT                            nTaskIdNum;                             // 智能分析任务个数, 0表示订阅全部任务
    fAnalyseTaskStateCallBack       cbAnalyseTaskState;                     // 智能分析任务状态订阅函数
    LDWORD                          dwUser;                 			    // 用户数据
} NET_IN_ATTACH_ANALYSE_TASK_STATE;

// 智能分析结果订阅的过滤条件
typedef struct tagNET_ANALYSE_RESULT_FILTER
{
    DWORD                           dwAlarmTypes[MAX_ANALYSE_FILTER_EVENT_NUM];     // 过滤事件, 详见dhnetsdk.h中"智能分析事件类型"
    UINT                            nEventNum;                                      // 过滤事件数量
    BYTE                            byReserved[1024];                               // 保留字节
} NET_ANALYSE_RESULT_FILTER;

// 文件分析状态
typedef enum tagEM_FILE_ANALYSE_STATE
{
    EM_FILE_ANALYSE_UNKNOWN     = -1,   // 未知
    EM_FILE_ANALYSE_EXECUTING,          // 分析中
    EM_FILE_ANALYSE_FINISH,             // 分析完成
    EM_FILE_ANALYSE_FAILED,             // 分析失败
} EM_FILE_ANALYSE_STATE;

// 任务自定义数据
typedef struct tagNET_TASK_CUSTOM_DATA
{
    char                    szClientIP[128];            // 客户端IP
    char                    szDeviceID[128];            // 设备ID
    BYTE                    byReserved[256];            // 保留字节
} NET_TASK_CUSTOM_DATA;

// 智能分析任务结果信息
typedef struct tagNET_ANALYSE_TASK_RESULT
{
    UINT                            nTaskID;                                // 任务ID
    char                            szFileID[DH_COMMON_STRING_128];         // 文件ID, 分析文件时有效
    EM_FILE_ANALYSE_STATE           emFileAnalyseState;                     // 文件分析状态
    char                            szFileAnalyseMsg[DH_COMMON_STRING_256]; // 文件分析额外信息, 一般都是分析失败的原因
    NET_SECONDARY_ANALYSE_EVENT_INFO stuEventInfos[MAX_SECONDARY_ANALYSE_EVENT_NUM];// 事件信息
    int                             nEventCount;                            // 实际的事件个数
    NET_TASK_CUSTOM_DATA            stuCustomData;                          // 自定义数据
    BYTE                            byReserved[512];                        // 保留字节
} NET_ANALYSE_TASK_RESULT;

// 智能分析任务结果回调信息
typedef struct tagNET_CB_ANALYSE_TASK_RESULT_INFO
{
    NET_ANALYSE_TASK_RESULT         stuTaskResultInfos[MAX_ANALYSE_TASK_NUM];   // 智能分析任务结果信息
    UINT                            nTaskResultNum;                             // 任务个数
    BYTE                            byReserved[1028];                           // 保留字节
} NET_CB_ANALYSE_TASK_RESULT_INFO;

// 智能分析状态订阅函数原型, lAttachHandle 是 CLIENT_AttachAnalyseTaskResult接口的返回值
typedef int  (CALLBACK *fAnalyseTaskResultCallBack)(LLONG lAttachHandle, NET_CB_ANALYSE_TASK_RESULT_INFO *pstAnalyseTaskResult, const char *pBuf, const DWORD dwBufSize, LDWORD dwUser);

// CLIENT_AttachAnalyseTaskResult 接口输入参数
typedef struct tagNET_IN_ATTACH_ANALYSE_RESULT
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskIDs[MAX_ANALYSE_TASK_NUM];         // 智能分析任务ID
    UINT                            nTaskIdNum;                             // 智能分析任务个数, 0表示订阅全部任务
    NET_ANALYSE_RESULT_FILTER       stuFilter;                              // 过滤条件
    BYTE                            byReserved[4];                          // 字节对齐
    fAnalyseTaskResultCallBack      cbAnalyseTaskResult;                    // 智能分析任务结果订阅函数
    LDWORD                          dwUser;                                 // 用户数据
} NET_IN_ATTACH_ANALYSE_RESULT;

// CLIENT_SetAnalyseTaskCustomData 接口输入参数
typedef struct tagNET_IN_SET_ANALYSE_TASK_CUSTOM_DATA
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nTaskID;                                // 任务ID
    NET_TASK_CUSTOM_DATA            stuTaskCustomData;                      // 自定义数据
} NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA;

// CLIENT_SetAnalyseTaskCustomData 接口输出参数
typedef struct tagNET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA;

// 算法厂商
typedef enum tagEM_ALGORITHM_VENDOR
{
    EM_ALGORITHM_VENDOR_UNKNOWN,               // 未知
    EM_ALGORITHM_VENDOR_DAHUA,                 // 大华
    EM_ALGORITHM_VENDOR_SHANGTANG,             // 商汤
    EM_ALGORITHM_VENDOR_HUAFU,                 // 华富
    EM_ALGORITHM_VENDOR_SHENMO,                // 深晶
} EM_ALGORITHM_VENDOR;

// 算法版本信息
typedef struct tagNET_ALGORITHM_INFO
{
    EM_SCENE_CLASS_TYPE             emClassType;                        // 业务大类
    char                            szVersion[DH_COMMON_STRING_32];     // 算法版本
    EM_ALGORITHM_VENDOR             emAlgorithmVendor;                  // 算法厂商
    char                            szAlgorithmLibVersion[DH_COMMON_STRING_32];  // 算法库文件版本
    BYTE                            byReserved[992];                   // 保留字节
} NET_ALGORITHM_INFO;

// 智能分析总能力
typedef struct tagNET_TOTAL_CAP
{
    EM_SCENE_CLASS_TYPE             emClassType;                                // 业务大类
    DWORD                           dwRuleTypes[MAX_ANALYSE_RULE_COUNT];        // 规则类型, 详见dhnetsdk.h中"智能分析事件类型"
    UINT                            nRuleNum;                                   // 规则数量
    UINT                            nMaxStreamNum;                              // 最多支持同时分析的视频流数目
    BYTE                            byReserved[1024];                           // 保留字节
} NET_TOTAL_CAP;

// 智能分析的算法版本信息
typedef struct tagNET_ANALYSE_CAPS_ALGORITHM
{
    DWORD                           dwSize;                                         // 结构体大小
    NET_ALGORITHM_INFO              stuAlgorithmInfos[MAX_ANALYSE_ALGORITHM_NUM];   // 算法版本信息
    UINT                            nAlgorithmNum;                                  // 算法个数
} NET_ANALYSE_CAPS_ALGORITHM;

// 智能分析的总能力
typedef struct tagNET_ANALYSE_CAPS_TOTAL
{
    DWORD                           dwSize;                                         // 结构体大小
    NET_TOTAL_CAP                   stuTotalCaps[MAX_ANALYSE_TOTALCAPS_NUM];        // 智能分析总能力
    UINT                            nTotalCapsNum;                                  // 智能分析总能力个数
} NET_ANALYSE_CAPS_TOTAL;

// 算法独立升级能力
typedef struct tagNET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE
{
    DWORD                           dwSize;                                         // 结构体大小
    BOOL                            bSupportOnlyAlgorithmUpgrade;                   // 是否支持算法独立升级能力
} NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE;

// 智能分析服务能力类型
typedef enum tagEM_ANALYSE_CAPS_TYPE
{
    EM_ANALYSE_CAPS_ALGORITHM = 1,      // 算法版本, 对应输出结构体 NET_ANALYSE_CAPS_ALGORITHM
    EM_ANALYSE_CAPS_TOTALCAPS,          // 智能分析总能力, 对应输出结构体 NET_ANALYSE_CAPS_TOTAL
    EM_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE,  // 算法独立升级能力, 对应输出结构体 NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE
} EM_ANALYSE_CAPS_TYPE;

// 获取视频分析服务智能能力集, pstOutParam根据emCapsType的值取对应的结构体, pstOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAnalyseCaps(LLONG lLoginID, EM_ANALYSE_CAPS_TYPE emCapsType, void *pOutParam, int nWaitTime);

// 添加智能分析任务, 输入参数pInParam的结构体类型根据emDataSourceType的值来决定, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddAnalyseTask(LLONG lLoginID, EM_DATA_SOURCE_TYPE emDataSourceType, void *pInParam, NET_OUT_ADD_ANALYSE_TASK *pOutParam, int nWaitTime);

// 启动智能分析任务, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartAnalyseTask(LLONG lLoginID, NET_IN_START_ANALYSE_TASK *pInParam, NET_OUT_START_ANALYSE_TASK *pOutParam, int nWaitTime);

// 删除(停止)智能分析任务, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveAnalyseTask(LLONG lLoginID, NET_IN_REMOVE_ANALYSE_TASK *pInParam, NET_OUT_REMOVE_ANALYSE_TASK *pOutParam, int nWaitTime);

// 查找智能分析任务信息, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FindAnalyseTask(LLONG lLoginID, NET_IN_FIND_ANALYSE_TASK *pInParam, NET_OUT_FIND_ANALYSE_TASK *pOutParam, int nWaitTime);

// 推送智能分析图片文件，当CLIENT_AddAnalyseTask的数据源类型emDataSourceType为 EM_DATA_SOURCE_PUSH_PICFILE 时使用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PushAnalysePictureFile(LLONG lLoginID, NET_IN_PUSH_ANALYSE_PICTURE_FILE *pInParam, NET_OUT_PUSH_ANALYSE_PICTURE_FILE *pOutParam, int nWaitTime);

// 订阅智能分析任务状态, pInParam 资源由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalyseTaskState(LLONG lLoginID, NET_IN_ATTACH_ANALYSE_TASK_STATE *pInParam, int nWaitTime);

// 取消订阅智能分析任务状态, lAttachHandle 为 CLIENT_AttachAnalyseTaskState接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalyseTaskState(LLONG lAttachHandle);

// 订阅智能分析结果, pInParam 资源由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachAnalyseTaskResult(LLONG lLoginID, NET_IN_ATTACH_ANALYSE_RESULT *pInParam, int nWaitTime);

// 取消订阅智能分析结果, lAttachHandle 为 CLIENT_AttachAnalyseTaskResult接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachAnalyseTaskResult(LLONG lAttachHandle);

// 订阅剩余智能分析资源接口, pstInParam资源由用户申请和释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachRemainAnalyseResource(LLONG lLoginID, NET_IN_ATTACH_REMAIN_ANALYSE_RESOURCE *pInParam, int nWaitTime);

// 取消订阅智能分析结果, lAttachHandle 为 CLIENT_AttachAnalyseTaskResult接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachRemainAnalyseResource(LLONG lAttachHandle);

// 设置任务的自定义数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetAnalyseTaskCustomData(LLONG lLoginID, const NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA *pInParam, NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA *pOutParam, const int nWaitTime);
/////////////////////////////////智能分析服务接口 结束/////////////////////////////////

// CLIENT_GetLensInfo 接口输入参数
typedef struct tagNET_IN_GETLENSINFO
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nChannel;                               // 视频通道号
} NET_IN_GETLENSINFO;

// 镜头类型
typedef enum tagEM_LENS_TYPE
{
    EM_LENS_TYPE_UNKNOWN = -1,                  // 未知
    EM_LENS_TYPE_FIXED_FOCUS,                   // 定焦
    EM_LENS_TYPE_INTERNEL_ZOOM,                 // 内置变焦镜头
    EM_LENS_TYPE_MANUAL_ZOOM,                   // 手动变焦镜头
    EM_LENS_TYPE_EXTERNEL_ZOOM,                 // 外置变焦镜头
} EM_LENS_TYPE;

// CLIENT_GetLensInfo 接口输出参数
typedef struct tagNET_OUT_GETLENSINFO
{
    DWORD                           dwSize;                                 // 结构体大小
    EM_LENS_TYPE                    emLensType;                             // 镜头类型
} NET_OUT_GETLENSINFO;

// 获取镜头信息, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetLensInfo(LLONG lLoginID, NET_IN_GETLENSINFO *pInParam, NET_OUT_GETLENSINFO *pOutParam, int nWaitTime);

// 镜头行为
typedef enum tagEM_LENS_ACTION
{
    EM_LENS_ACTION_UNKNOWN = -1,                                // 未知
    EM_LENS_ACTION_SINGLE_STEP,                                 // 单步(单击+-)
    EM_LENS_ACTION_START_CONTINUOUS_ADJUSTMENT,                 // 开始持续调整(长按+-)
    EM_LENS_ACTION_END_CONTINUOUS_ADJUSTMENT,                   // 结束持续调整(结束长按+-)
} EM_LENS_ACTION;

// 命令信息
typedef struct tagNET_CMD_INFO
{
    int                            nZoom;                                     // 变倍步长, 负数表示减量方向, focus非0时, zoom必须为0
    int                            nFocus;                                    // 聚焦步长, 负数表示减量方向, zoom非0时, focus必须为0
    EM_LENS_ACTION                 emLensAction;                              // 镜头行为
    BYTE                           byReserved[1024];                          // 保留字节
} NET_CMD_INFO;

// CLIENT_AdjustRelativeLensFocus 接口输入参数
typedef struct tagNET_IN_ADJUSTRELATIVELENSFOCUS
{
    DWORD                           dwSize;                                 // 结构体大小
    UINT                            nChannel;                               // 视频通道号
    NET_CMD_INFO                    stuCmdInfo;                             // 命令信息
} NET_IN_ADJUSTRELATIVELENSFOCUS;

// CLIENT_AdjustRelativeLensFocus 接口输出参数
typedef struct tagNET_OUT_ADJUSTRELATIVELENSFOCUS
{
    DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_ADJUSTRELATIVELENSFOCUS;

// 相对焦距调节, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AdjustRelativeLensFocus(LLONG lLoginID, NET_IN_ADJUSTRELATIVELENSFOCUS *pInParam, NET_OUT_ADJUSTRELATIVELENSFOCUS *pOutParam, int nWaitTime);

// 安全门报警统计信息
typedef struct tagNET_SECURITYGATE_ALARM_STATISTICS_INFO
{
	char								szUUID[36];							// UUID	
	UINT								nStatisticsInfoID;					// 统计信息ID
	NET_TIME_EX							stuBeginTime;						// 开始时间
	NET_TIME_EX							stuEndTime;							// 结束时间
	UINT								nPassIn;							// 进入通过人数
	UINT								nAlarmIn;							// 进入报警人数
	UINT								nPassOut;							// 离开通过人数
	UINT								nAlarmOut;							// 离开报警人数
	BYTE								byReserved[1024];					// 保留字段
}NET_SECURITYGATE_ALARM_STATISTICS_INFO;

// 安全门报警订阅回调函数
typedef void (CALLBACK *fSecurityGateAttachAlarmStatistics)(LLONG lAttachHandle, NET_SECURITYGATE_ALARM_STATISTICS_INFO* pInfo, LDWORD dwUser);

// CLIENT_SecurityGateAttachAlarmStatistics 输入结构体
typedef struct tagNET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS
{
	DWORD								dwSize;								// 赋值为结构体大小
	char								szUUID[36];							// UUID
	fSecurityGateAttachAlarmStatistics	cbNotify;							// 回调函数
	LDWORD								dwUser;								// 用户信息
}NET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS;

// CLIENT_SecurityGateAttachAlarmStatistics 输出结构体
typedef struct tagNET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS
{
	DWORD								dwSize;								// 赋值为结构体大小
}NET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS;

// 订阅安全门报警统计信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_SecurityGateAttachAlarmStatistics(LLONG lLoginID, const NET_IN_SECURITYGATE_ATTACH_ALARM_STATISTICS* pInParam, NET_OUT_SECURITYGATE_ATTACH_ALARM_STATISTICS* pOutParam, int nWaitTime);


// 取消订阅安全门报警统计信息
// lAttachHandle 为 CLIENT_SecurityGateAttachAlarmStatistics 返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SecurityGateDetachAlarmStatistics(LLONG lAttachHandle);

// 相机的信息
typedef struct tagNET_CAMERA_CFG_INFO
{
    char        szIP[32];           // IP地址
    UINT        nPort;              // 端口
    char        szLoginName[32];    // 登陆用户名
    char        szLoginPwd[32];     // 登陆密码，设置的时候不填表示不修改密码
    BYTE        byReserved[1024];   // 保留字节
}NET_CAMERA_CFG_INFO;

// CLIENT_SetCameraCfg 接口输入参数
typedef struct tagNET_IN_SET_CAMERA_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nCameraNo;          // 相机编号
    NET_CAMERA_CFG_INFO     stuCameraInfo;      // 相机的信息
} NET_IN_SET_CAMERA_CFG;

// CLIENT_SetCameraCfg 接口输出参数
typedef struct tagNET_OUT_SET_CAMERA_CFG
{
    DWORD                           dwSize;     // 结构体大小
} NET_OUT_SET_CAMERA_CFG;

// CLIENT_GetCameraCfg 接口输入参数
typedef struct tagNET_IN_GET_CAMERA_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nCameraNo;          // 相机编号
} NET_IN_GET_CAMERA_CFG;

// CLIENT_GetCameraCfg 接口输出参数
typedef struct tagNET_OUT_GET_CAMERA_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nCameraNo;          // 相机编号
    NET_CAMERA_CFG_INFO     stuCameraInfo;      // 相机的信息
} NET_OUT_GET_CAMERA_CFG;

// 进口方向
typedef enum tagEM_ENTRY_DIRECTION
{
    EM_ENTRY_UNKNOWN,                            // 未知
    EM_ENTRY_NORTH_TO_SOUTH,                     // 北向南            
    EM_ENTRY_EASTNORTH_TO_WESTSOUTH,             // 东北向西南
    EM_ENTRY_EAST_TO_WEST,                       // 东向西
    EM_ENTRY_EASTSOUTH_TO_WESTNORTH,             // 东南向西北
    EM_ENTRY_SOUTH_TO_NORTH,                     // 南向北
    EM_ENTRY_WESTSOUTH_TO_EASTSOUTH,             // 西南向东北
    EM_ENTRY_WEST_TO_EAST,                       // 西向东
    EM_ENTRY_WESTNORTH_TO_EASTSOUTH,             // 西北向东南
} EM_ENTRY_DIRECTION;

// 进口类型
typedef enum tagEM_ENTRY_TYPE
{
    EM_ENTRY_TYPE_UNKNOWN,                        // 未知
    EM_ENTRY_TYPE_TURN_LEFT,                      // 左转
    EM_ENTRY_TYPE_STRAIGHT,                       // 直行
    EM_ENTRY_TYPE_TRUN_RIGHT,                     // 右转
    EM_ENTRY_TYPE_TURN_ROUND,                     // 掉头
}EM_ENTRY_TYPE;

// 通道信息
typedef struct tagNET_CHANNEL_CFG_INFO
{
    int                     nCameraNo;          // 上报的相机编号
    EM_ENTRY_DIRECTION      emEntryDirection;   // 进口方向
    EM_ENTRY_TYPE           emEntryType[16];	// 进口类型
	int						nRetEntryTypeNum;	// 进口类型个数
	int						nLaneNo;			// 车道号
    BYTE                    byReserved[956];    // 保留字节
}NET_CHANNEL_CFG_INFO;

// CLIENT_SetChannelCfg 接口输入参数
typedef struct tagNET_IN_SET_CHANNEL_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nChannelNo;         // 检测通道
    NET_CHANNEL_CFG_INFO    stuChannelInfo;     // 通道信息
} NET_IN_SET_CHANNEL_CFG;

// CLIENT_SetChannelCfg 接口输出参数
typedef struct tagNET_OUT_SET_CHANNEL_CFG
{
    DWORD                   dwSize;             // 结构体大小
} NET_OUT_SET_CHANNEL_CFG;


// CLIENT_GetChannelCfg 接口输入参数
typedef struct tagNET_IN_GET_CHANNEL_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nChannelNo;         // 检测通道
} NET_IN_GET_CHANNEL_CFG;

// CLIENT_GetChannelCfg 接口输出参数
typedef struct tagNET_OUT_GET_CHANNEL_CFG
{
    DWORD                   dwSize;             // 结构体大小
    int                     nChannelNo;         // 检测通道
    NET_CHANNEL_CFG_INFO    stuChannelInfo;     // 通道信息
} NET_OUT_GET_CHANNEL_CFG;

// 红绿灯检测类型
typedef enum tagEM_TRAFFIC_LIGHT_DETECT_MODE
{
    EM_TRAFFIC_DETECT_UNKNOWN = -1,              // 未知
    EM_TRAFFIC_DETECT_RED,                       // 红灯模式
    EM_TRAFFIC_DETECT_GREEN,                     // 绿灯模式
}EM_TRAFFIC_LIGHT_DETECT_MODE;

// CLIENT_SetDetectMode 接口输入参数
typedef struct tagNET_IN_SET_DETECT_MODE
{
    DWORD                     dwSize;            // 结构体大小
    int                       nDetectTimeout;    // 异常超时时间
    EM_TRAFFIC_LIGHT_DETECT_MODE    emDetectionMode;   // 模式
    
} NET_IN_SET_DETECT_MODE;

// CLIENT_SetDetectMode 接口输出参数
typedef struct tagNET_OUT_SET_DETECT_MODE
{
    DWORD                     dwSize;            // 结构体大小
} NET_OUT_SET_DETECT_MODE;

// CLIENT_GetDetectMode 接口输入参数
typedef struct tagNET_IN_GET_DETECT_MODE
{
    DWORD                     dwSize;            // 结构体大小
} NET_IN_GET_DETECT_MODE;

// CLIENT_GetDetectMode 接口输出参数
typedef struct tagNET_OUT_GET_DETECT_MODE
{
    DWORD                     dwSize;            // 结构体大小
    int                       nDetectTimeout;    // 异常超时时间
    EM_TRAFFIC_LIGHT_DETECT_MODE    emDetectionMode;   // 模式
} NET_OUT_GET_DETECT_MODE;

// 相机连接状态
typedef enum tagEM_CAMERA_CONNECT_STATE
{
	EM_CAMERA_CONNECT_STATE_UNKNOWN = -1,				// 未知
	EM_CAMERA_CONNECT_STATE_UNCONNECT,					// 未连接
	EM_CAMERA_CONNECT_STATE_CONNECTED,					// 已连接
}EM_CAMERA_CONNECT_STATE;

// 红绿灯状态
typedef enum tagEM_TRAFFIC_LIGHT_DETECT_STATE
{
	EM_TRAFFIC_DETECT_STATE_UNKNOWN = -1,              // 未知
	EM_TRAFFIC_DETECT_STATE_RED,                       // 红灯
	EM_TRAFFIC_DETECT_STATE_GREEN,                     // 绿灯
}EM_TRAFFIC_LIGHT_DETECT_STATE;

// 相机对应的红绿灯通道状态
typedef struct tagNET_LIGHTINFO_CFG
{
	int								nLightNo;			// 红绿灯通道
	EM_TRAFFIC_LIGHT_DETECT_STATE	emLightState;		// 红绿灯状态
	BYTE							byReserved[504];	// 预留
}NET_LIGHTINFO_CFG;

// CLIENT_GetCameraInfo 接口输入参数
typedef struct tagNET_IN_GET_CAMERA_INFO
{
	DWORD						dwSize;				// 结构体大小
	int							nCameraNo;			// 相机编号
}NET_IN_GET_CAMERA_INFO;

// CLIENT_GetCameraInfo 接口输出参数
typedef struct tagNET_OUT_GET_CAMERA_INFO
{
	DWORD						dwSize;				// 结构体大小
	int							nCameraNo;			// 相机编号
	EM_CAMERA_CONNECT_STATE		emConnectState;		// 相机连接状态
	int							nRetLightInfoNum;	// 返回的红绿灯通道数
	NET_LIGHTINFO_CFG			stuLightInfos[16];	// 相机对应的红绿灯通道状态
}NET_OUT_GET_CAMERA_INFO;


// 设置相机参数, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetCameraCfg(LLONG lLoginID, NET_IN_SET_CAMERA_CFG *pInParam, NET_OUT_SET_CAMERA_CFG *pOutParam, int nWaitTime);

// 获取相机参数, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCameraCfg(LLONG lLoginID, NET_IN_GET_CAMERA_CFG *pInParam, NET_OUT_GET_CAMERA_CFG *pOutParam, int nWaitTime);

// 设置通道参数, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetChannelCfg(LLONG lLoginID, NET_IN_SET_CHANNEL_CFG *pInParam, NET_OUT_SET_CHANNEL_CFG *pOutParam, int nWaitTime);

// 获取通道参数, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelCfg(LLONG lLoginID, NET_IN_GET_CHANNEL_CFG *pInParam, NET_OUT_GET_CHANNEL_CFG *pOutParam, int nWaitTime);

// 设置检测模式, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDetectMode(LLONG lLoginID, NET_IN_SET_DETECT_MODE *pInParam, NET_OUT_SET_DETECT_MODE *pOutParam, int nWaitTime);

// 获取检测模式, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDetectMode(LLONG lLoginID, NET_IN_GET_DETECT_MODE *pInParam, NET_OUT_GET_DETECT_MODE *pOutParam, int nWaitTime);

// 交通灯信号检测-获取相机信息, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetCameraInfo(LLONG lLoginID, NET_IN_GET_CAMERA_INFO *pInParam, NET_OUT_GET_CAMERA_INFO *pOutParam, int nWaitTime);

// CLIENT_GetAreaInfo 输入结构体
typedef struct tagNET_IN_GETAREA_INFO
{
    DWORD						dwSize;				// 赋值为结构体大小
    int                         nChannel;           // 通道
}NET_IN_GETAREA_INFO;


// 区域规则类型
typedef enum tagEM_AREA_RULE_TYPE
{
    EM_AREA_RULE_UNKNOWN,                           // 未知
    EM_AREA_RULE_QUEUE_DETECTION,                   // 队列检测区域
    EM_AREA_RULE_MAN_NUM_DETECTION,                 // 人数检测区域
}EM_AREA_RULE_TYPE;

// 区域信息
typedef struct tagNET_GETAREA_INFO
{
    unsigned short              nAreaId;                // 区域ID
    BYTE                        byReserved1[2];          // 保留字节，用于字节对齐
    EM_AREA_RULE_TYPE           emAreaRuleType;         // 区域规则类型
    int                         nPointNum;              // 检测区域的点数
    NET_POINT                   stuDetectRegion[20];    // 检测区域，多边形，多边形中每个顶点的坐标坐标归一化到[0,8192)区间
    char                        szAreaName[64];         // 区域名称
    BYTE                        byReserved[1024];       // 保留字节
}NET_GETAREA_INFO;

// CLIENT_GetAreaInfo 输出结构体
typedef struct tagNET_OUT_GETAREA_INFO
{
    DWORD						dwSize;					// 赋值为结构体大小
    int                         nChannle;               // 通道数
    int                         nAreaCount;             // 区域个数
    NET_GETAREA_INFO            stuAreaInfo[20];        // 区域信息
}NET_OUT_GETAREA_INFO;

// 获取区域人数统计区域信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetAreaInfo(LLONG lLoginID, const NET_IN_GETAREA_INFO* pInParam, NET_OUT_GETAREA_INFO* pOutParam, int nWaitTime);

// CLIENT_GetRealTimeVehiclesInfoByRegion 接口输入参数
typedef struct tagNET_IN_GET_VEHICLES_INFO
{
    DWORD                       dwSize;             // 结构体大小
    UINT                        nChannel;           // 通道
    int                         nPointNum;          // 多边形点的个数，最少4个点
    NET_POINT                   stuPoint[32];       // 多边形区域，8192坐标系，即X轴和Y轴的范围都是0到8192
}NET_IN_GET_VEHICLES_INFO;

// 区域内车辆信息
typedef struct tagNET_VEHICLES_INFO_IN_REGION
{
    UINT                        nVehicleQuantity;   // 区域内车辆数量
    BYTE                        byReserved[1024];   // 保留字节
}NET_VEHICLES_INFO_IN_REGION;

// CLIENT_GetRealTimeVehiclesInfoByRegion 接口输出参数
typedef struct tagNET_OUT_GET_VEHICLES_INFO
{
    DWORD                       dwSize;             // 结构体大小
    NET_VEHICLES_INFO_IN_REGION stuVehiclesInfo;    // 区域内车辆信息
}NET_OUT_GET_VEHICLES_INFO;

// 获取指定视频通道下矩形区域内的车辆统计信息, pInParam 和 pOutParam 资源由用户申请和释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetRealTimeVehiclesInfoByRegion(LLONG lLoginID, NET_IN_GET_VEHICLES_INFO *pInParam, NET_OUT_GET_VEHICLES_INFO *pOutParam, int nWaitTime);

// 检测区区域人数统计信息
typedef struct tagNET_REGION_PEOPLE_STAT_INFO
{
	UINT					nRegionID;				// 区域ID
	char					szRegionName[128];		// 区域名称
	UINT					nRegionPointNum;		// 区域顶点个数
	NET_POINT				stuRegionPoint[20];		// 区域顶点坐标
	UINT					nPeopleNum;				// 区域内人数
	BYTE                    byReserved[1024];       // 保留字节
} NET_REGION_PEOPLE_STAT_INFO;

// 检测区统计信息
typedef struct tagNET_CROWD_STAT_DATA
{
	UINT							nChannelID;				// 通道号
	UINT							nGloabalPeopleNum;		// 检测区内总人数
	UINT							nRegionNum;				// 检测区内区域个数
	NET_REGION_PEOPLE_STAT_INFO		stuRegionPeople[8];		// 检测区内区域人数统计信息
	BYTE                    		byReserved[1024];		// 保留字节
} NET_CROWD_STAT_DATA;

//  订阅人群分布图实时统回调信息
typedef struct tagNET_CB_CROWD_DISTRI_STREAM_INFO
{
	UINT					nCrowStatNum;				// 检测区个数
	NET_CROWD_STAT_DATA		stuCrowdStatData[8];			// 检测区统计信息
	BYTE                    byReserved[2048];			// 保留字节
} NET_CB_CROWD_DISTRI_STREAM_INFO;

// 订阅人群分布图实时统计信息回调函数原型, lAttachHandle为CLIENT_AttachCrowdDistriMap接口的返回值
typedef void (CALLBACK *fCrowdDistriStream)(LLONG lAttachHandle, NET_CB_CROWD_DISTRI_STREAM_INFO* pstResult, LDWORD dwUser);

// CLIENT_AttachCrowdDistriMap接口输入参数
typedef struct tagNET_IN_ATTACH_CROWDDISTRI_MAP_INFO
{
	DWORD                           dwSize;                                 // 结构体大小
	UINT							nChannelID;								// 通道号
	fCrowdDistriStream				cbCrowdDistriStream;					// 订阅人群分布图实时统计信息回调函数
	LDWORD                  		dwUser;                     			// 用户数据
} NET_IN_ATTACH_CROWDDISTRI_MAP_INFO;

// CLIENT_AttachCrowdDistriMap 接口输出参数
typedef struct tagNET_OUT_ATTACH_CROWDDISTRI_MAP_INFO
{
	DWORD                           dwSize;                                 // 结构体大小
} NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO;

/**************************************************************************************
*   Funcname: CLIENT_AttachCrowdDistriMap
*   Purpose: 订阅人群分布图实时统计信息
*   InputParam:	LLONG							:lLoginID			// 登陆句柄
*   InputParam:	NET_IN_ATTACH_CROWDDISTRI_MAP_INFO*	:pstInParam		// 输入参数, 由用户申请资源
*   OutPutParam:	NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO*	:pstOutParam 		// 输出参数, 由用户申请资源
*   InputParam:	int								:nWaitTime		// 等待超时时间
*   Return:		LLONG
*   Created:		%2019%:%06%:%11% by 27774  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCrowdDistriMap(LLONG lLoginID, NET_IN_ATTACH_CROWDDISTRI_MAP_INFO *pstInParam, NET_OUT_ATTACH_CROWDDISTRI_MAP_INFO *pstOutParam, int nWaitTime);

/**************************************************************************************
*   Funcname: CLIENT_DetachCrowdDistriMap
*   Purpose: 取消订阅人群分布图实时统计信息
*   InputParam:	LLONG					:lAttachHandle			// 订阅句柄，为接口CLIENT_AttachCrowdDistriMap的返回值
*   Return:		LLONG
*   Created:		%2019%:%06%:%11% by 27774  
*   Revision Record:    date:author:modify sth
**************************************************************************************/
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCrowdDistriMap(LLONG lAttachHandle);









// Ping的信息
typedef struct tagNET_PING_INFO
{
    char                        szAddress[128];      // Ping的地址或者域名
    BYTE                        byReserved[512];     // 保留字节        
}NET_PING_INFO;

// CLIENT_GetPingStatus 接口输入参数
typedef struct tagNET_IN_GET_PING_STATUS_INFO
{
    DWORD                       dwSize;             // 结构体大小
    NET_PING_INFO               stuPingInfo;        // Ping的信息
}NET_IN_GET_PING_STATUS_INFO;

// ping的状态
typedef struct tagNET_PING_STATUS_INFO
{
    float                       fAveDelay;           // 平均网络延迟，单位秒
    float                       fLossRate;           // 丢包率,大小[0-1]
    BYTE                        byReserved[512];     // 保留字节        
}NET_PING_STATUS_INFO;

// CLIENT_GetPingStatus 接口输出参数
typedef struct tagNET_OUT_GET_PING_STATUS_INFO
{
    DWORD                       dwSize;             // 结构体大小
    NET_PING_STATUS_INFO        stuPingStatus;      // ping的状态
}NET_OUT_GET_PING_STATUS_INFO;

// 获取指定ip的ping状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPingStatus(LLONG lLoginID, NET_IN_GET_PING_STATUS_INFO *pInParam, NET_OUT_GET_PING_STATUS_INFO *pOutParam, int nWaitTime);

// CLIENT_GetDevRemoteChannelAlarmState 接口输入参数
typedef struct tagNET_IN_GET_REMOTE_CHANNEL_ALARM_STATE
{
	DWORD           dwSize;                 // 结构体大小
	UINT			nChannelNum;			// 通道个数
	UINT			nChannel[128];			// 通道列表
} NET_IN_GET_REMOTE_CHANNEL_ALARM_STATE;

// 报警通道状态
typedef struct tagNET_ALARM_CHANNEL_STATE
{
	int				nChannel;				// 视频通道号
	DWORD			dwAlatmInState;			// 远程设备报警输入通道状态。按位表示，每一位表示一个远程设备的报警输入通道的状态;
	BYTE            byReserved[256];			// 保留字节
} NET_ALARM_CHANNEL_STATE;

// CLIENT_GetDevRemoteChannelAlarmState 接口输出参数
typedef struct tagNET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE
{
	DWORD           			dwSize;                 	// 结构体大小
	UINT						nAlarmChannelNum;			// 报警通道个数
	NET_ALARM_CHANNEL_STATE		stuAlarmChannelState[128];	// 报警通道状态
} NET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE;

// 获取设备通道报警状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevRemoteChannelAlarmState(LLONG lLoginID, NET_IN_GET_REMOTE_CHANNEL_ALARM_STATE *pstInParam, NET_OUT_GET_REMOTE_CHANNEL_ALARM_STATE *pstOutParam, int nWaitTime);

// 门禁数据进度类型
typedef enum tagEM_ACCESSCONTROL_PROGRESS_TYPE
{
	EM_ACCESSCONTROL_PROGRESS_IMPORT,			// 数据导入进度
	EM_ACCESSCONTROL_PROGRESS_DEPLOY,			// 数据同步进度
} EM_ACCESSCONTROL_PROGRESS_TYPE;

// 门禁数据导入返回状态
typedef enum tagEM_ACCESSCONTROL_IMPORT_STATE
{
	EM_ACCESSCONTROL_IMPORT_UNKNOWN,		// 未知
	EM_ACCESSCONTROL_IMPORT_ONGING,			// 导入中
	EM_ACCESSCONTROL_IMPORT_END,			// 导入结束, 开始生成数据库
	EM_ACCESSCONTROL_IMPORT_BUSY,			// 系统忙，已经有导入任务
	EM_ACCESSCONTROL_IMPORT_DATAERROR,		// 数据包检验失败
	EM_ACCESSCONTROL_IMPORT_INVALID,		// 数据包非法
	EM_ACCESSCONTROL_IMPORT_SYNC_SUCCESS,	// 同步成功, 数据库已生成
	EM_ACCESSCONTROL_IMPORT_SYNC_FALIED,	// 同步失败, 数据库无法生成
	EM_ACCESSCONTROL_IMPORT_DBFULL,			// 数据库已满无法导入
	EM_ACCESSCONTROL_IMPORT_SDFULL,			// 存储空间满无法导入
	EM_ACCESSCONTROL_IMPORT_CIPHER_ERROR,	// 导入压缩包密码不对
	EM_ACCESSCONTROL_IMPORT_SEND_FAIL,		// 发送门禁数据失败
} EM_ACCESSCONTROL_IMPORT_STATE;

// 导入门禁数据状态信息
typedef struct tagNET_IMPORT_ACCESSCONTROL_STATE
{
	unsigned int	        			nProgress;			// 进度, 百分比
	EM_ACCESSCONTROL_PROGRESS_TYPE		emProcessType;		// 进度类型
	EM_ACCESSCONTROL_IMPORT_STATE		emState;			// 状态信息
	BYTE			        			byReserved[512];		// 保留字节
} NET_IMPORT_ACCESSCONTROL_STATE;

// 导入人脸库回调函数原形
typedef void (CALLBACK *fImportAccessControlDataCallBack) (LLONG lImportHandle, NET_IMPORT_ACCESSCONTROL_STATE *pstAccessControlState, LDWORD dwUser);

// CLIENT_ImportAccessControlData 接口输入参数
typedef struct tagNET_IN_IMPORT_ACCESS_CONTROL_DATA
{
	DWORD								dwSize;								// 结构体大小
	DWORD								dwDataType;							// 数据类型掩码, 0x01 门禁对讲通信录; 0x02 门禁自定义密码; 0x04 门禁卡片信息;
																			// 0x08 门禁人脸信息; 0x10 门禁指纹信息; 0x20 门禁对讲远程设备信息
	char								szPassWord[DH_COMMON_STRING_64];	// 压缩密码
	char								szFilePath[MAX_FILE_PATH_LEN];		// 门禁数据路径, 由用户指定
	UINT								nBeforeLen;							// 文件压缩前大小
	BYTE			        			byReserved[4];						// 对齐
	fImportAccessControlDataCallBack	cbImportState;						// 上传状态回调函数
	LDWORD 								dwUser;								// 用户数据
} NET_IN_IMPORT_ACCESS_CONTROL_DATA;

// CLIENT_ImportAccessControlData 接口输出参数
typedef struct tagNET_OUT_IMPORT_ACCESS_CONTROL_DATA
{
	DWORD								dwSize;								// 结构体大小
} NET_OUT_IMPORT_ACCESS_CONTROL_DATA;

// 导入门禁数据
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ImportAccessControlData(LLONG lLoginID, NET_IN_IMPORT_ACCESS_CONTROL_DATA* pstInParam, 
																NET_OUT_IMPORT_ACCESS_CONTROL_DATA* pstOutParam, const int nWaitTime);

// 停止导入门禁数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopImportAccessControlData(LLONG lImportHandle);

// 导出门禁快速复核信息错误码
typedef enum tagEM_EXPORT_FAST_CHECK_ERRORCODE
{
	EM_EXPORT_FAST_CHECK_SUCCESS			= 1,		// 导出请求成功
	EM_EXPORT_FAST_CHECK_NO_AUTHORITY		= 2,		// 无权限
	EM_EXPORT_FAST_CHECK_NO_THIS_FILE		= 3,		// 文件不存在
	EM_EXPORT_FAST_CHECK_EXPORT_END			= 4,		// 导出结束
	EM_EXPORT_FAST_CHECK_EXPORTING			= 5,		// 导出中
	EM_EXPORT_FAST_CHECK_FILE_READY			= 8,		// 文件准备完成
	EM_EXPORT_FAST_CHECK_FILE_FAILED		= 9,		// 文件准备失败
	EM_EXPORT_FAST_CHECK_WAIT_FILE			= 10,		// 导出请求成功, 需要等待设备准备数据
	EM_EXPORT_FAST_CHECK_SYSTEM_BUSY		= 11,		// 系统忙, 暂时无法导出数据
	EM_EXPORT_FAST_CHECK_NO_PASSWORD		= 12,		// 数据未定义密码, 不允许导出
} EM_EXPORT_FAST_CHECK_ERRORCODE;

// 门禁快速复核信息状态信息
typedef struct tagNET_EXPORT_FAST_CHECK_STATE
{
	unsigned int					nProgress;			// 进度, 百分比
	EM_EXPORT_FAST_CHECK_ERRORCODE	emErrorCode;		// 错误码
	char							*pDataBuf;			// 导出数据
	DWORD							dwDataLen;			// 数据长度
	BYTE							byReserved[516];	// 保留字节
} NET_EXPORT_FAST_CHECK_STATE;

// 导出门禁快速复核信息回调函数原形
typedef void (CALLBACK *fExportFastCheckCallBack)(LLONG lExportHandle, NET_EXPORT_FAST_CHECK_STATE *pstFastCheckState, LDWORD dwUser);

// CLIENT_ExportAccessControlFastCheckData 接口输入参数
typedef struct tagNET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA
{
	DWORD							dwSize;								// 结构体大小
	DWORD							dwDataType;							// 数据类型掩码, 0x01 门禁对讲通信录; 0x02 门禁自定义密码; 0x04 门禁卡片信息;
																		// 0x08 门禁人脸信息; 0x10 门禁指纹信息; 0x20 门禁对讲远程设备信息; 0x40 人员数据
	char							szPassWord[DH_COMMON_STRING_64];	// 压缩密码
	fExportFastCheckCallBack		cbExportFastCheckCallBack;			// 导出快速复核信息回调函数
	LDWORD 							dwUser;								// 用户数据
} NET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA;

// CLIENT_ExportAccessControlFastCheckData 接口输出参数
typedef struct tagNET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA
{
	DWORD							dwSize;							// 结构体大小
} NET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA;

// 导出门禁快速复核信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportAccessControlFastCheckData(LLONG lLoginID, NET_IN_EXPORT_ACCESSCONTROL_FASTCHECK_DATA* pstInParam, 
																NET_OUT_EXPORT_ACCESSCONTROL_FASTCHECK_DATA* pstOutParam, const int nWaitTime);

// 停止导出门禁快速复核数据
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportAccessControlFastCheckData(LLONG lExportHandle);

// CLIENT_GetUSBInfo 输入结构体
typedef struct tagNET_IN_GET_USB_INFO
{
	DWORD		dwSize;						// 赋值为结构体大小
}NET_IN_GET_USB_INFO;

// USB 传输协议类型
enum EM_USB_PROTOCOL_TYPE
{
	EM_USB_PROTOCOL_TYPE_UNKNOWN,			// 未知
	EM_USB_PROTOCOL_TYPE_V2,				// USB 2.0
	EM_USB_PROTOCOL_TYPE_V3,				// USB 3.0
};

// CLIENT_GetUSBInfo 输出结构体
typedef struct tagNET_OUT_GET_USB_INFO
{
	DWORD					dwSize;			// 赋值为结构体大小
	EM_USB_PROTOCOL_TYPE	emType;			// USB传输协议类型
}NET_OUT_GET_USB_INFO;


// 获取USB传输协议类型
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetUSBInfo(LLONG lLoginID, NET_IN_GET_USB_INFO* pstuIn, NET_OUT_GET_USB_INFO* pstuOut, int nWaitTime);



// 充值机查询类型
enum EM_RECHARGE_BUSINESS_QUERY_TYPE
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE_UNKNOWN = 0,			// 未知
	EM_RECHARGE_BUSINESS_QUERY_TYPE_CARD,					// 卡号查询
	EM_RECHARGE_BUSINESS_QUERY_TYPE_HUMANFACE,				// 人脸查询
};

// 充值机操作类型
enum EM_RECHARGE_BUSINESS_OPERATE_TYPE
{
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_UNKNOWN = 0,			// 未知
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_QUERY,				// 账户查询
	EM_RECHARGE_BUSINESS_OPERATE_TYPE_RECHARGE,				// 账户充值
};

// 充值机账户查询事件信息
typedef struct tagNET_RECHARGE_BUSINESS_QUERY_EVENT_INFO
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE		emQueryType;		// 查询类型
	char								szCardNo[32];		// 查询账户卡号
	char								szUserID[32];		// 查询账户的用户ID
	NET_TIME_EX							stuTime;			// 查询账户时设备本地时间
	char*								pszFaceData;		// 人脸照片：emType 为 EM_RECHARGE_BUSINESS_TYPE_CARD 时无意义
	int									nFaceDataLen;		// 人脸照片长度	
}NET_RECHARGE_BUSINESS_QUERY_EVENT_INFO;

// 充值机账户充值事件信息
typedef struct tagNET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO
{
	EM_RECHARGE_BUSINESS_QUERY_TYPE		emQueryType;		// 查询类型
	char								szCardNo[32];		// 查询账户卡号
	char								szUserID[32];		// 查询账户的用户ID
	NET_TIME_EX							stuTime;			// 查询账户时设备本地时间
	char*								pszFaceData;		// 人脸照片：emType 为 EM_RECHARGE_BUSINESS_TYPE_CARD 时无意义
	int									nFaceDataLen;		// 人脸照片长度	
	int									nAmount;			// 充值金额,[100, 9999900],单位：分，必须是100的整数倍
}NET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO;


// 充值机订阅回调信息
typedef struct tagNET_RECHARGE_BUSINESS_INFO
{
	EM_RECHARGE_BUSINESS_OPERATE_TYPE	emOperateType;		// 操作类型
	BYTE								byReserved[4];		// 字节对齐
	char								szBusinessID[32];	// 业务ID
	void*								pstuEventInfo;		// 操作信息
															// 当 emOperateType 为 EM_RECHARGE_BUSINESS_OPERATE_TYPE_QUERY，类型为 NET_RECHARGE_BUSINESS_QUERY_EVENT_INFO
															// 当 emOperateType 为 EM_RECHARGE_BUSINESS_OPERATE_TYPE_RECHARGE，类型为 NET_RECHARGE_BUSINESS_RECHARGE_EVENT_INFO
}NET_RECHARGE_BUSINESS_INFO;

// 充值机订阅信息回调函数
typedef void (CALLBACK *fRechargeBusiness)(LLONG lAttachHandle, NET_RECHARGE_BUSINESS_INFO* pInfo, LDWORD dwUser);

// CLIENT_AttachRechargeBusiness 输入结构体
typedef struct tagNET_IN_ATTACH_RECHARGE_BUSINESS
{
	DWORD								dwSize;				// 赋值为结构体大小
	BYTE								szReserved[4];		// 保留字段
	fRechargeBusiness					cbNotify;			// 回调函数
	LDWORD								dwUser;				// 用户信息
}NET_IN_ATTACH_RECHARGE_BUSINESS;


// CLIENT_AttachRechargeBusiness 输出结构体
typedef struct tagNET_OUT_ATTACH_RECHARGE_BUSINESS
{
	DWORD								dwSize;					// 赋值为结构体大小
}NET_OUT_ATTACH_RECHARGE_BUSINESS;

// 订阅充值机业务
CLIENT_NET_API	LLONG CALL_METHOD CLIENT_AttachRechargeBusiness(LLONG lLoginID, NET_IN_ATTACH_RECHARGE_BUSINESS* pInParam, NET_OUT_ATTACH_RECHARGE_BUSINESS* pOutParam, int nWaitTime);

// 取消订阅充值机业务
// lAttachHandle 为 CLIENT_AttachRechargeBusiness 返回值
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_DetachRechargeBusiness(LLONG lAttachHandle);

// 充值错误码
enum EM_RECHARGE_BUSINESS_ERROR_CODE
{
	EM_RECHARGE_BUSINESS_ERRORCODE_UNKNOWN = -1,				// 未知
	EM_RECHARGE_BUSINESS_ERRORCODE_NONE,						// 无错误
	EM_RECHARGE_BUSINESS_ERRORCODE_UNAUTHORIZED_CARD = 11,		// 卡片未授权
	EM_RECHARGE_BUSINESS_ERRORCODE_INVALID_CARD = 14,			// 无效卡号
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_MAX_AMOUNT = 48,		// 超出卡最大金额
	EM_RECHARGE_BUSINESS_ERRORCODE_INVALID_TERMINAL = 89,		// 无效终端
	EM_RECHARGE_BUSINESS_ERRORCODE_SYSTEM_EXCEPTION = 96,		// 系统异常
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_DAY_RECHARGE_NUM = 107,				// 超出日最大充值次数
	EM_RECHARGE_BUSINESS_ERRORCODE_EXCEED_SINGLE_MAX_RECHARGE_AMOUNT = 108,		// 超出单次最大充值金额
};

// CLIENT_SetRechargeBusinessQueryResult 输入结构体
typedef struct tagNET_IN_RECHARGE_BUSINESS_QUERY_RESULT
{
	DWORD								dwSize;						// 赋值为结构体大小
	char								szCardNo[32];				// 卡号
	char								szUserID[32];				// 用户ID
	char								szBusinessID[32];			// 业务ID，CLIENT_AttachRechargeBusiness 回调函数上报的 szBusinessID
	UINT								nBalance;					// 账户余额，单位：分
	EM_RECHARGE_BUSINESS_ERROR_CODE		emErrorCode;				// 错误码
}NET_IN_RECHARGE_BUSINESS_QUERY_RESULT;

// CLIENT_SetRechargeBusinessQueryResult 输出结构体
typedef struct tagNET_OUT_RECHARGE_BUSINESS_QUERY_RESULT 
{
	DWORD								dwSize;						// 赋值为结构体大小
}NET_OUT_RECHARGE_BUSINESS_QUERY_RESULT;

// 设置充值机查询结果
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_SetRechargeBusinessQueryResult(LLONG lLoginID, NET_IN_RECHARGE_BUSINESS_QUERY_RESULT* pInParam, NET_OUT_RECHARGE_BUSINESS_QUERY_RESULT* pOutParam, int nWaitTime);

// CLIENT_SetRechargeBusinessRechargeResult 输入结构体
typedef struct tagNET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT 
{
	DWORD								dwSize;						// 赋值为结构体大小
	char								szCardNo[32];				// 卡号
	char								szUserID[32];				// 用户ID
	char								szBusinessID[32];			// 业务ID，CLIENT_AttachRechargeBusiness 回调函数上报的 szBusinessID
	UINT								nBalance;					// 账户余额，单位：分
	EM_RECHARGE_BUSINESS_ERROR_CODE		emErrorCode;				// 错误码
}NET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT;

// CLIENT_SetRechargeBusinessRechargeResult 输出结构体
typedef struct tagNET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT 
{
	DWORD								dwSize;						// 赋值为结构体大小
}NET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT;

// 设置充值机充值结果
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_SetRechargeBusinessRechargeResult(LLONG lLoginID, NET_IN_RECHARGE_BUSINESS_RECHARGE_RESULT* pInParam, NET_OUT_RECHARGE_BUSINESS_RECHARGE_RESULT* pOutParam, int nWaitTime);



// CLIENT_SetPersonInfoInputResult 输入参数
typedef struct tagNET_IN_PERSON_INFO_INPUT_RESULT
{
	DWORD								dwSize;						// 结构体大小
	int									nChannelID;					// 通道ID
	UINT								nResult;					// 0 : 成功  1 : 人员信息不在人员库中
	BYTE								byReserved[4];				// 字节对齐
	char								szCitizenID[64];			// 身份证号码
}NET_IN_PERSON_INFO_INPUT_RESULT;

// CLIENT_SetPersonInfoInputResult 输出参数
typedef struct tagNET_OUT_PERSON_INFO_INPUT_RESULT
{
	DWORD								dwSize;						// 结构体大小
}NET_OUT_PERSON_INFO_INPUT_RESULT;

// 下发人员信息录入结果
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPersonInfoInputResult(LLONG lLoginID, NET_IN_PERSON_INFO_INPUT_RESULT* pInParam, NET_OUT_PERSON_INFO_INPUT_RESULT* pOutParam, int nWaitTime);

// CLIENT_PlayBackBySecondaryAnalyse 输入结构体
typedef struct tagNET_IN_PLAYBACK_BY_SECONDARYANALYSE
{
	DWORD								dwSize;					// 结构体大小
	int									nChannelID;				// 通道
	NET_TIME							stBeginTime;			// 开始时间
	NET_TIME							stEndTime;				// 结束时间
	HWND								hWnd;					// 播放窗口, 可为NULL
	fDownLoadPosCallBack				cbDownLoadPos;			// 进度回调
	LDWORD								dwPosUser;				// 进度回调用户信息
	fDataCallBack						fDownLoadDataCallBack;	// 数据回调
	LDWORD								dwDataUser;				// 数据回调用户信息
	int									nPlayDirection;			// 播放方向, 0:正放; 1:倒放;	
	int									nTaskID;				// 任务ID，浓缩视频回放使用
}NET_IN_PLAYBACK_BY_SECONDARYANALYSE;


// CLIENT_PlayBackBySecondaryAnalyse 输出结构体
typedef struct tagNET_OUT_PLAYBACK_BY_SECONDARYANALYSE
{
	DWORD								dwSize;					// 结构体大小
}NET_OUT_PLAYBACK_BY_SECONDARYANALYSE;


// 二次分析回放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_PlayBackBySecondaryAnalyse(LLONG lLoginID, NET_IN_PLAYBACK_BY_SECONDARYANALYSE* pInParam, NET_OUT_PLAYBACK_BY_SECONDARYANALYSE* pOutParam,int nWaitTime);

// CLIENT_GetDevWifiListInfo 接口输入参数
typedef struct tagNET_IN_GET_DEV_WIFI_LIST
{
    DWORD                   dwSize;             // 结构体大小
    UINT                    nPort;              // 设备端口号
    char                    szDevIP[64];        // 设备IP
} NET_IN_GET_DEV_WIFI_LIST;

// CLIENT_GetDevWifiListInfo 接口输出参数
typedef struct tagNET_OUT_GET_DEV_WIFI_LIST
{
    DWORD                   dwSize;                             // 结构体大小
    UINT                    nWlanDevCount;                      // 搜索到的无线设备个数
    DHDEV_WLAN_DEVICE_EX    stuWlanDev[MAX_WLAN_DEVICE_NUM];    // 搜索到的无线设备信息
} NET_OUT_GET_DEV_WIFI_LIST;

// CLIENT_SetDevWifiInfo 接口输入参数
typedef struct tagNET_IN_SET_DEV_WIFI
{
    DWORD               dwSize;                     // 结构体大小
    UINT                nPort;                      // 设备端口号
    char                szDevIP[64];                // 设备IP
    int                 nEnable;                    // 无线使能, 0: 使能, 1: 关闭
    char                szSSID[36];                 // SSID
    int                 nLinkMode;                  // 连接模式；0：auto,1：adhoc,2：Infrastructure
    int                 nEncryption;                // 加密；0：off,2：WEP64bit,3：WEP128bit, 4:WPA-PSK-TKIP, 5: WPA-PSK-CCMP(AES), 6:WPA2-PSK-TKIP 7:WPA2-PSK-AES 8:WPA-TKIP 9:WPA-AES 
                                                    // 10:WPA2-TKIP 11:WPA2-AES 12:AUTO 13:WEP-OPEN 14:WEP-SHARED   
    int                 nKeyType;                   // 0：Hex,1：ASCII
    int                 nKeyID;                     // 序号
    char                szKeys[4][32];              // 四组密码, nEncryption为非WPA方式时使用
    char                szWPAKeys[128];             // nEncryption为WPA相关方式时使用,传128长度,不用结束符。
    int                 nKeyFlag;
    int                 nConnectedFlag;            // 0: 无连接, 1: 连接 
} NET_IN_SET_DEV_WIFI;

// CLIENT_SetDevWifiInfo 接口输出参数
typedef struct tagNET_OUT_SET_DEV_WIFI
{
    DWORD               dwSize;                     // 结构体大小
} NET_OUT_SET_DEV_WIFI;

// 获取设备wifi信息列表, 无需鉴权
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDevWifiListInfo(NET_IN_GET_DEV_WIFI_LIST *pInParam, NET_OUT_GET_DEV_WIFI_LIST *pOutParam, const int nWaitTime);

// 下发wifi信息，无需鉴权
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetDevWifiInfo(NET_IN_SET_DEV_WIFI *pInParam, NET_OUT_SET_DEV_WIFI *pOutParam, const int nWaitTime);


// 抓拍物体信息
typedef struct tagNET_SNAP_OBJECT_INFO
{
    NET_RECT             stuBoundingBox;                        // 物体包围盒, 点坐标归一化到[0, 8192]坐标
    BYTE                 byReserved[512];                       // 保留字节   
} NET_SNAP_OBJECT_INFO;

// CLIENT_SnapPictureByAnalyseObject 接口输入参数
typedef struct tagNET_IN_SNAP_BY_ANALYSE_OBJECT
{
    DWORD                               dwSize;             // 结构体大小
    UINT                                nChannelID;         // 通道号
    BYTE                                byReserved[4];      // 字节对齐
    UINT                                nSnapObjectNum;     // 抓拍物体个数
    NET_SNAP_OBJECT_INFO                stuSnapObjects[32]; // 抓拍物体信息
} NET_IN_SNAP_BY_ANALYSE_OBJECT;

// CLIENT_SnapPictureByAnalyseObject 接口输出参数
typedef struct tagNET_OUT_SNAP_BY_ANALYSE_OBJECT
{
    DWORD                               dwSize;             // 结构体大小
} NET_OUT_SNAP_BY_ANALYSE_OBJECT;

// 选中目标进行抓拍
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SnapPictureByAnalyseObject(LLONG lLoginID, NET_IN_SNAP_BY_ANALYSE_OBJECT* pInParam, NET_OUT_SNAP_BY_ANALYSE_OBJECT* pOutParam,int nWaitTime);


// 智能算法的状态信息
typedef struct tagNET_INTELLI_STATE_INFO
{
    BOOL                            bSupportOnlyAlgorithmUpgrade;                   // 是否支持算法独立升级
    UINT                            nAlgorithmNum;                                  // 算法个数
    NET_ALGORITHM_INFO              stuAlgorithmInfos[MAX_ANALYSE_ALGORITHM_NUM];   // 算法版本信息
	BYTE							byReserve[1024];								// 保留字节
}NET_INTELLI_STATE_INFO;


// 智能算法的状态信息回调函数
typedef void (CALLBACK *fIntelliState)(LLONG lAttachHandle, NET_INTELLI_STATE_INFO* pInfo, LDWORD dwUser);

// CLIENT_AttachIntelliState 输入结构体
typedef struct tagNET_IN_ATTACH_INTELLI_STATE
{
    DWORD								dwSize;				// 结构体大小
    BYTE								szReserved[4];		// 保留字段
    fIntelliState					    cbNotify;			// 回调函数
    LDWORD								dwUser;				// 用户信息
}NET_IN_ATTACH_INTELLI_STATE;


// CLIENT_AttachIntelliState 输出结构体
typedef struct tagNET_OUT_ATTACH_INTELLI_STATE
{
    DWORD								dwSize;				// 结构体大小
}NET_OUT_ATTACH_INTELLI_STATE;

// 订阅智能算法的状态信息
CLIENT_NET_API	LLONG CALL_METHOD CLIENT_AttachIntelliState(LLONG lLoginID, NET_IN_ATTACH_INTELLI_STATE* pInParam, NET_OUT_ATTACH_INTELLI_STATE* pOutParam, int nWaitTime);

// 取消订阅智能算法的状态信息
// lAttachHandle 为 CLIENT_AttachIntelliState 返回值
CLIENT_NET_API	BOOL CALL_METHOD CLIENT_DetachIntelliState(LLONG lAttachHandle);


// CLIENT_GetGDPRAbility 输入参数
typedef struct tagNET_IN_GET_GDPR_ABILITY
{
	DWORD						dwSize;			// 结构体大小
}NET_IN_GET_GDPR_ABILITY;

// GDPR能力集
enum EM_GDPR_ABILITY
{
	EM_GDPR_ABILITY_V1_STREAM = 0x01,			// 支持GDPRV1版本的拉流、回放
	EM_GDPR_ABILITY_V2_STREAM = 0x02,			// 支持GDPRV2版本的拉流、回放
	EM_GDPR_ABILITY_DOWNLOAD  = 0x04,			// 支持GDPR下载
};

// CLIENT_GetGDPRAbility 输出参数
typedef struct tagNET_OUT_GET_GDPR_ABILITY
{
	DWORD						dwSize;			// 结构体大小
	int							nAbility;		// 能力，取值见 EM_GDPR_ABILITY，支持 '|' 运算
}NET_OUT_GET_GDPR_ABILITY;


// 获取设备GDPR能力集
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetGDPRAbility(LLONG lLoginID, NET_IN_GET_GDPR_ABILITY* pInParam, NET_OUT_GET_GDPR_ABILITY* pOutParam, int nWaitTime);

// GDPR使能全局开关
CLIENT_NET_API void	CALL_METHOD CLIENT_SetGDPREnable(BOOL bEnable);

// 人脸下载失败错误码
typedef enum tagEM_FACEDB_ERRCODE
{
    EM_FACEDB_ERRCODE_UNKNOWN  = -1,       // 未知
    EM_FACEDB_ERRCODE_SUCCESS,             // 成功
    EM_FACEDB_ERRCODE_CONNECT_FAIL = 2,    // 连接失败
    EM_FACEDB_ERRCODE_LOGIN_FAIL,          // 登陆失败
    EM_FACEDB_ERRCODE_RECV_TIMEOUT,        // 接收数据超时
    EM_FACEDB_ERRCODE_STRING_NULL,         // 目标字符串为空
    EM_FACEDB_ERRCODE_FILE_DIRECTORY_NOT_EXIST,    // 目录或文件不存在
    EM_FACEDB_ERRCODE_STORAGE_FAIL,        // 文件存储失败
} EM_FACEDB_ERRCODE;

// 人脸库下载进度回调信息
typedef struct tagNET_CB_FACEDB_DOWNLOAD_RESULT
{
    char                szFaceDbVersion[32];                    // 人脸库版本号
    UINT                nTotalDownloadCount;                    // 总下载文件个数
    UINT                nSuccessDownloadCount;                  // 已下载文件个数
    EM_FACEDB_ERRCODE   emFaceDbErrCode;                        // 人脸下载失败错误码
    BYTE                byReserved[1024];                       // 保留字节
} NET_CB_FACEDB_DOWNLOAD_RESULT;

// 订阅人脸库下载进度回调函数原型, lAttachHandle为 CLIENT_AttachFaceDbDownLoadResult 接口的返回值
typedef void (CALLBACK *fFaceDbDownLoadResult)(LLONG lAttachHandle, NET_CB_FACEDB_DOWNLOAD_RESULT* pstResult, LDWORD dwUser);

// CLIENT_AttachFaceDbDownLoadResult 接口输入参数
typedef struct tagNET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT
{
    DWORD                           dwSize;                         // 结构体大小
    BYTE                            byReserved[4];                  // 字节对齐
    fFaceDbDownLoadResult           cbFaceDbDownLoadResult;         // 人脸库下载进度回调函数
    LDWORD                          dwUser;                         // 用户数据
} NET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT;

// CLIENT_AttachFaceDbDownLoadResult 接口输出参数
typedef struct tagNET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT
{
    DWORD                           dwSize;                 // 结构体大小
} NET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT;

// 订阅人脸库下载结果
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFaceDbDownLoadResult(LLONG lLoginID, NET_IN_ATTACH_FACEDB_DOWNLOAD_RESULT* pInParam, NET_OUT_ATTACH_FACEDB_DOWNLOAD_RESULT* pOutParam, int nWaitTime);

// 取消订阅人脸库下载结果, lAttachHandle为 CLIENT_AttachFaceDbDownLoadResult 接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFaceDbDownLoadResult(LLONG lAttachHandle);

// 人脸库下载任务信息
typedef struct tagNET_FACEDB_DOWNLOAD_TASK_INFO
{
    UINT                nURLNum;                            // 图片URL个数
    char                szURLList[4][256];                  // 图片URL地址列表, 一张人脸图片的地址可能存放在多个ftp服务器上
    char                szID[32];                           // ID
    char                szFaceUUID[32];                     // 人脸唯一码，每次平台更新人脸图片都需要更新该字段，用于设备端比较是否重新下载人脸图片
    BYTE                byReserved[2048];                   // 保留字节
} NET_FACEDB_DOWNLOAD_TASK_INFO;

// CLIENT_AddFaceDbDownLoadTask 接口输入参数
typedef struct tagNET_IN_ADD_FACEDB_DOWNLOAD_TASK
{
    DWORD                               dwSize;                 // 结构体大小
    BOOL                                bIsEnd;                 // 是否为最后一包(此字段废弃)
    char                                szFaceDbVersion[32];    // 人脸库版本号
    BYTE                                byReserved[4];          // 字节对齐
    UINT                                nTaskNum;               // 人脸库下载任务个数, 由用户指定个数, 最多支持100个
    NET_FACEDB_DOWNLOAD_TASK_INFO       *pstTaskInfo;           // 人脸库下载任务信息, 由用户申请空间, 大小为nTaskNum*sizeof(NET_FACELIB_DOWNLOAD_TASK_INFO)
    UINT                                nPacketTotal;           // 表示当前任务总共有几个包
    UINT                                nPacketIndex;           // 表示当前是第几个包，下标从1开始
} NET_IN_ADD_FACEDB_DOWNLOAD_TASK;

// CLIENT_AddFaceDbDownLoadTask 接口输出参数
typedef struct tagNET_OUT_ADD_FACEDB_DOWNLOAD_TASK
{
    DWORD                           dwSize;						// 结构体大小
} NET_OUT_ADD_FACEDB_DOWNLOAD_TASK;


// 添加人脸库下载任务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddFaceDbDownLoadTask(LLONG lLoginID, NET_IN_ADD_FACEDB_DOWNLOAD_TASK* pInParam, NET_OUT_ADD_FACEDB_DOWNLOAD_TASK* pOutParam, int nWaitTime);

// 车牌库下载进度回调信息
typedef struct tagNET_CB_PLATENUMBERDB_DOWNLOAD_RESULT
{
    char                               szPlateNumberDbVersion[32];                     // 车牌库版本号
    UINT                               nTotalDownloadCount;                            // 需要下载文件个数
    UINT                               nSuccessDownloadCount;                          // 已下载文件个数
    EM_FACEDB_ERRCODE                  emPlateNumberDbErrorCode;                       // 车牌下载失败错误码
    BYTE                               byReserved[1020];                               // 保留字节
} NET_CB_PLATENUMBERDB_DOWNLOAD_RESULT;

// 订阅车牌库下载进度回调函数原型, lAttachHandle为 CLIENT_AttachPlateNumberDbDownloadResult 接口的返回值
typedef void (CALLBACK *fPlateNumberDbDownloadResult)(LLONG lAttachHandle, NET_CB_PLATENUMBERDB_DOWNLOAD_RESULT* pstResult, LDWORD dwUser);

// CLIENT_AttachPlateNumberDbDownloadResult 接口输入参数
typedef struct tagNET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT
{
    DWORD                              dwSize;                                         // 结构体大小
    BYTE                               byReserved[4];                                  // 字节对齐
    fPlateNumberDbDownloadResult       cbPlateNumberDbDownloadResult;                  // 车牌库下载进度回调函数
    LDWORD                             dwUser;                                         // 用户数据
} NET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT;

// CLIENT_AttachPlateNumberDbDownloadResult 接口输出参数
typedef struct tagNET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT
{
    DWORD                              dwSize;                                         // 结构体大小
} NET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT;

// 订阅车牌库下载进度
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachPlateNumberDbDownloadResult(LLONG lLoginID, NET_IN_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT* pInParam, NET_OUT_ATTACH_PLATENUMBERDB_DOWNLOAD_RESULT* pOutParam, int nWaitTime);

// 取消订阅车牌库下载进度, lAttachHandle为 CLIENT_AttachPlateNumberDbDownloadResult 接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachPlateNumberDbDownloadResult(LLONG lAttachHandle);

// 车牌库下载任务信息
typedef struct tagNET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO
{
    UINT                                          nURLNum;                        // 图片URL个数
    char                                          szURLList[4][256];              // 图片URL地址列表, 一张车牌图片的地址可能存放在多个ftp服务器上
    BYTE                                          byReserved[1020];               // 保留字节
} NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO;

// CLIENT_AddPlateNumberDbDownloadTask 接口输入参数
typedef struct tagNET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK
{
    DWORD                                         dwSize;                         // 结构体大小
    UINT                                          nTaskNum;                       // 车辆库下载任务个数, 由用户指定个数, 最多支持100个
    NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO       *pstTaskInfo;                    // 车辆库下载任务信息, 由用户申请空间, 大小为nTaskNum*sizeof(NET_PLATE_NUMBER_DB_DOWNLOAD_TASK_INFO)
    char                                          szPlateNumberDbVersion[32];     // 车辆库版本
    UINT                                          nPacketTotal;                   // 表示当前任务总共有几个包
    UINT                                          nPacketIndex;                   // 表示当前是第几个包，下标从1开始
} NET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK;

// CLIENT_AddPlateNumberDbDownloadTask 接口输出参数
typedef struct tagNET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK
{
    DWORD                                         dwSize;                         // 结构体大小
} NET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK;

// 添加车牌库下载任务
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPlateNumberDbDownloadTask(LLONG lLoginID, NET_IN_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK* pInParam, NET_OUT_ADD_PLATE_NUMBER_DB_DOWNLOAD_TASK* pOutParam, int nWaitTime);

// CLIENT_GetPlateNumberDbVersion 接口输入参数
typedef struct tagNET_IN_GET_PLATE_NUMBER_DB_VERSION
{
    DWORD                                         dwSize;                         // 结构体大小
} NET_IN_GET_PLATE_NUMBER_DB_VERSION;

// CLIENT_GetPlateNumberDbVersion 接口输出参数
typedef struct tagNET_OUT_GET_PLATE_NUMBER_DB_VERSION
{
    DWORD                                         dwSize;                         // 结构体大小
    char                                          szPlateNumberDbVersion[32];     // 车牌库版本号,如果从来未下发或者设备异常没有下发完，车牌库版本号”0”
} NET_OUT_GET_PLATE_NUMBER_DB_VERSION;

// 平台主动查询设备端车牌库版本信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetPlateNumberDbVersion(LLONG lLoginID, NET_IN_GET_PLATE_NUMBER_DB_VERSION* pInParam, NET_OUT_GET_PLATE_NUMBER_DB_VERSION* pOutParam, int nWaitTime);

// FTP服务协议类型
typedef enum tagEM_FTP_PROTOCOL_TYPE
{
    EM_FTP_PROTOCOL_TYPE_UNKNOWN        = -1,           // 未知
    EM_FTP_PROTOCOL_TYPE_FTPS,                          // ftps
} EM_FTP_PROTOCOL_TYPE;

// FTP服务信息
typedef struct tagNET_FTP_SERVER_INFO
{
    char                    szIP[32];               // IP地址
    char                    szUserName[32];         // 用户名
    char                    szPassword[32];         // 密码
    UINT                    nPort;                  // 端口号
    EM_FTP_PROTOCOL_TYPE    emFtpProtocolType;      // FTP服务协议类型
    UINT                    nTimeOut;               // 连接超时时间, 单位: 毫秒
    char                    szDirectory[128];       // 存放视频的根目录
    BYTE                    byReserved[1020];       // 保留字节
} NET_FTP_SERVER_INFO;

// CLIENT_SendFtpUploadServerInfo 接口输入参数
typedef struct tagNET_IN_SEND_FTP_UPLOAD_SERVER_INFO
{
    DWORD                   dwSize;                 // 结构体大小
    UINT                    nFtpServerNum;          // FTP 服务个数
    NET_FTP_SERVER_INFO     stuFtpServerInfo[4];    // FTP 服务信息
} NET_IN_SEND_FTP_UPLOAD_SERVER_INFO;

// CLIENT_SendFtpUploadServerInfo 接口输出参数
typedef struct tagNET_OUT_SEND_FTP_UPLOAD_SERVER_INFO
{
    DWORD                           dwSize;                 // 结构体大小
} NET_OUT_SEND_FTP_UPLOAD_SERVER_INFO;

// 下发补传视频ftp服务器信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendFtpUploadServerInfo(LLONG lLoginID, NET_IN_SEND_FTP_UPLOAD_SERVER_INFO* pInParam, NET_OUT_SEND_FTP_UPLOAD_SERVER_INFO* pOutParam, int nWaitTime);

// 文件上传结果码
typedef enum tagEM_FILE_UPLOAD_RESULT_CODE
{
    EM_FILE_UPLOAD_RESULT_CODE_UNKNOWN      = -1,       // 未知
    EM_FILE_UPLOAD_RESULT_CODE_SUCCESS,                 // 成功
    EM_FILE_UPLOAD_RESULT_CODE_CONNECT_FAIL = 2,        // 连接失败
    EM_FILE_UPLOAD_RESULT_CODE_LOGIN_FAIL,              // 登录失败
    EM_FILE_UPLOAD_RESULT_CODE_RCV_TIMEOUT,             // 接收数据超时
    EM_FILE_UPLOAD_RESULT_CODE_OBJ_STR_NULL,            // 目标字符串为空
    EM_FILE_UPLOAD_RESULT_CODE_NO_FOLD_FILE,            // 目录或文件不存在
    EM_FILE_UPLOAD_RESULT_CODE_STORE_FAIL,              // 文件存储失败
    EM_FILE_UPLOAD_RESULT_CODE_SEND_FAIL,               // 发送数据失败
} EM_FILE_UPLOAD_RESULT_CODE;

// 文件上传结果信息
typedef struct tagNET_FILE_UPLOAD_RESULT_INFO
{
    char                        szFileUrl[256];             // 文件路径
    EM_FILE_UPLOAD_RESULT_CODE  emResultCode;               // 文件上传结果码
    BYTE                        byReserved[1020];           // 保留字节
} NET_FILE_UPLOAD_RESULT_INFO;

// 文件上传结果回调信息
typedef struct tagNET_CB_FILE_UPLOAD_RESULT
{
    UINT                            nResultNum;                     // 文件上传结果个数
    NET_FILE_UPLOAD_RESULT_INFO     stuUploadResultInfo[4];         // 文件上传结果信息
    BYTE                            byReserved[1024];               // 保留字节
} NET_CB_FILE_UPLOAD_RESULT;

// 订阅文件上传结果信息回调函数原型, lAttachHandle为 CLIENT_AttachFileUploadResult 接口的返回值
typedef void (CALLBACK *fFileUploadResult)(LLONG lAttachHandle, NET_CB_FILE_UPLOAD_RESULT* pstResult, LDWORD dwUser);

// CLIENT_AttachFileUploadResult 接口输入参数
typedef struct tagNET_IN_ATTACH_FILE_UPLOAD_RESULT
{
    DWORD                           dwSize;                         // 结构体大小
    BYTE                            byReserved[4];                  // 字节对齐
    fFileUploadResult               cbFileUploadResult;             // 文件上传结果回调函数
    LDWORD                          dwUser;                         // 用户数据
} NET_IN_ATTACH_FILE_UPLOAD_RESULT;

// CLIENT_AttachFileUploadResult 接口输出参数
typedef struct tagNET_OUT_ATTACH_FILE_UPLOAD_RESULT
{
    DWORD                           dwSize;                         // 结构体大小
} NET_OUT_ATTACH_FILE_UPLOAD_RESULT;

// 订阅文件上传结果信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachFileUploadResult(LLONG lLoginID, NET_IN_ATTACH_FILE_UPLOAD_RESULT* pInParam, NET_OUT_ATTACH_FILE_UPLOAD_RESULT* pOutParam, const int nWaitTime);

// 取消订阅文件上传结果信息, lAttachHandle为 CLIENT_AttachFileUploadResult 接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachFileUploadResult(LLONG lAttachHandle);

// CLIENT_GetFaceDbVersion 接口输入参数
typedef struct tagNET_IN_GET_FACE_DB_VERSION
{
	DWORD                           dwSize;                         // 结构体大小
} NET_IN_GET_FACE_DB_VERSION;

// CLIENT_GetFaceDbVersion 接口输出参数
typedef struct tagNET_OUT_GET_FACE_DB_VERSION
{
	DWORD                           dwSize;                         // 结构体大小
	char                            szFaceDbVersion[32];            // 人脸库版本号, 没下发过人脸或者设备异常人脸未下载完全，人脸库版本号为"0"
	UINT                            nTotalCount;                    // 总共需要下载的文件个数
	UINT                            nSuccessDCount;                 // 已下载的文件个数
} NET_OUT_GET_FACE_DB_VERSION;

// 主动查询设备端人脸库版本信息
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFaceDbVersion(LLONG lLoginID, NET_IN_GET_FACE_DB_VERSION* pInParam, NET_OUT_GET_FACE_DB_VERSION* pOutParam, const int nWaitTime);

// CLIENT_ControlThermoSensor 接口输入参数
typedef struct tagNET_IN_CONTROL_THERMO_SENSOR
{
    DWORD               dwSize;             // 结构体大小
    int                 nChannel;           // 通道
    int                 nState;             // 热成像机芯开关, 0 - 关闭;1 - 开启
    BYTE                byReserverd[4];     // 保留字节，用于字节对齐
} NET_IN_CONTROL_THERMO_SENSOR;

// CLIENT_ControlThermoSensor 接口输出参数
typedef struct tagNET_OUT_CONTROL_THERMO_SENSOR
{
    DWORD               dwSize;             // 结构体大小
} NET_OUT_CONTROL_THERMO_SENSOR;


// CLIENT_GetDistanceRes 接口输入参数
typedef struct tagNET_IN_GET_DISTANCE_RES
{
    DWORD               dwSize;             // 结构体大小
    UINT                nChannel;           // 通道
} NET_IN_GET_DISTANCE_RES;


// 查询的的热成像日志类型
typedef enum tagEM_GET_DISTANCE_RES_STATUS
{
    EM_GET_DISTANCE_RES_UNKNOWN = -1,               // 未知
    EM_GET_DISTANCE_RES_SUCCESS,                    // 成功
    EM_GET_DISTANCE_RES_BEYOND_PITCH_LIMIT,         // 超出俯仰角限制
    EM_GET_DISTANCE_RES_INTERFACE_EXCEPTION,        // 接口异常
    EM_GET_DISTANCE_RES_GENERAL_ERROR,              // 通用错误
    EM_GET_DISTANCE_RES_LASER_NO_DATA_RETURN,       // 激光测距仪无数据返回。
    EM_GET_DISTANCE_RES_LASER_DATA_LENGTH_ERROR,    // 激光测距仪返回的数据长度错误
    EM_GET_DISTANCE_RES_LASER_DATA_FORMAT_ERROR,    // 激光测距仪返回的数据格式不正确
    EM_GET_DISTANCE_RES_LASER_DATA_VERIFIED_ERROR,  // 激光测距仪返回的数据校验失败
}EM_GET_DISTANCE_RES_STATUS;

// CLIENT_GetDistanceRes 接口输出参数
typedef struct tagNET_OUT_GET_DISTANCE_RES
{
    DWORD                       dwSize;             // 结构体大小
    UINT                        nDistance;          // 目标距离，单位米
    int                         nOverTimeStatus;    // 超时状态（0,超时 1未超时）
    EM_GET_DISTANCE_RES_STATUS  emStatus;           // 结果状态
} NET_OUT_GET_DISTANCE_RES;

// 热成像制冷机芯强制开启或关闭
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ControlThermoSensor(LLONG lLoginID, NET_IN_CONTROL_THERMO_SENSOR* pInParam, NET_OUT_CONTROL_THERMO_SENSOR* pOutParam,int nWaitTime);

// 获取画面中心位置目标的距离
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDistanceRes(LLONG lLoginID, NET_IN_GET_DISTANCE_RES* pInParam, NET_OUT_GET_DISTANCE_RES* pOutParam,int nWaitTime);

// 查询的的热成像日志类型
typedef enum tagEM_THREM_LOG_TYPE
{
    EM_THREM_LOG_UNKNOWN = -1,              // 未知,只用于查询结果，不用于查询条件
    EM_THREM_LOG_ALL,                       // 全部,只用于查询条件，不用于查询结果
    EM_THREM_LOG_CORE_OP,                   // 机芯开光操作相关
    EM_THREM_LOG_LASER,                     // 激光测距操作相关
    EM_THREM_LOG_PTZ,                       // 云台运动相关
    EM_THREM_LOG_VISUAL_ZOOM,               // 可见光变倍
    EM_THREM_LOG_VISUAL_FOCUS,              // 可见光聚焦
    EM_THREM_LOG_THERM_ZOOM,                // 热成像变倍
    EM_THREM_LOG_THERM_FOCUS,               // 热成像聚焦
    EM_THREM_LOG_CLEAR_LOG,                 // 日志清除
    EM_THREM_LOG_TEMPERATURE,               // 记录的温度信息
}EM_THREM_LOG_TYPE;

// CLIENT_StartFindThermLog 接口输入参数
typedef struct tagNET_IN_START_FIND_THERM_LOG
{
    DWORD               dwSize;             // 结构体大小
    EM_THREM_LOG_TYPE	emLogType;		// 查询的日志类型
    NET_TIME			stuStartTime;		// 查询的开始时间
    NET_TIME			stuEndTime;			// 查询的结束时间
} NET_IN_START_FIND_THERM_LOG;

// CLIENT_StartFindThermLog 接口输出参数
typedef struct tagNET_OUT_START_FIND_THERM_LOG
{
    DWORD               dwSize;             // 结构体大小
} NET_OUT_START_FIND_THERM_LOG;

// CLIENT_GetThermLogCount 接口输入参数
typedef struct tagNET_IN_GET_THERM_LOG_COUNT
{
    DWORD               dwSize;             // 结构体大小
} NET_IN_GET_THERM_LOG_COUNT;

// CLIENT_GetThermLogCount 接口输出参数
typedef struct tagNET_OUT_GET_THERM_LOG_COUNT
{
    DWORD               dwSize;             // 结构体大小
    int                 nLogCount;          // 日志数量
} NET_OUT_GET_THERM_LOG_COUNT;

// CLIENT_DoSeekFindThermLog 接口输入参数
typedef struct tagNET_IN_DO_SEEK_FIND_THERM_LOG
{
    DWORD               dwSize;             // 结构体大小
    int                 nOffset;            // 从满足条件开始，偏移offset条记录开始查询
    int                 nCount;             // 每次查询的日志条数
    BYTE                byReserve[4];       // 保留字节，用于字节对齐
} NET_IN_DO_SEEK_FIND_THERM_LOG;

// 热成像日志信息
typedef struct tagNET_THERM_LOG
{
    NET_TIME             stuTime;            // 日志时间
    EM_THREM_LOG_TYPE	 emLogType;			 // 日志类型
    char                 szDetail[512];      // 日志内容
    BYTE                 byReserve[1024];    // 保留字节
} NET_THERM_LOG;

// CLIENT_DoSeekFindThermLog 接口输出参数
typedef struct tagNET_OUT_DO_SEEK_FIND_THERM_LOG
{
    DWORD               dwSize;             // 结构体大小
    int                 nMaxCount;          // 用户指定分配结构体个数,需大于等于NET_IN_DO_SEEK_FIND_THERM_LOG的nCount
    NET_THERM_LOG*      pstuLogInfo;        // 返回日志信息,缓存大小由用户指定
    int                 nRetCount;          // 查询到的条数,0 表示没有更多日志可以查询（不能以found小于请求的count作为判断的依据。设备有可能受内存等限制，无法一次性返回。）
    BYTE                byReserve[4];       // 保留字节，用于字节对齐
} NET_OUT_DO_SEEK_FIND_THERM_LOG;

// 开始查询热成像日志
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindThermLog(LLONG lLoginID, const NET_IN_START_FIND_THERM_LOG* pInParam, NET_OUT_START_FIND_THERM_LOG* pOutParam, int nWaitTime);

// 查询当前的热成像日志数量
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetThermLogCount(LLONG lLogID, NET_IN_GET_THERM_LOG_COUNT* pInParam, NET_OUT_GET_THERM_LOG_COUNT* pOutParam, int nWaitTime);

// 查询当前热成像日志记录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoSeekFindThermLog(LLONG lLogID, NET_IN_DO_SEEK_FIND_THERM_LOG* pInParam, NET_OUT_DO_SEEK_FIND_THERM_LOG* pOutParam, int nWaitTime);

// 结束查询热成像日志
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindThermLog(LLONG lLogID);

// 课程状态
typedef enum tagEM_COURSE_STATE
{
    EM_COURSE_STATE_UNKNOWN,                                                        // 未知
    EM_COURSE_STATE_NOT_RECORD,                                                     // 未录制
    EM_COURSE_STATE_IN_RECORDING,                                                   // 录制中
    EM_COURSE_STATE_ALREADY_RECORDED,                                               // 已录制
} EM_COURSE_STATE;

// 课程信息
typedef struct tagNET_COURSE
{
    NET_TIME                        stuStartTime;                                   // 开始时间
    NET_TIME                        stuEndTime;                                     // 结束时间
    char                            szCourseName[DH_COMMON_STRING_64];              // 课程名称
    char                            szTeacherName[DH_COMMON_STRING_64];             // 教师姓名
    char                            szIntroduction[DH_COMMON_STRING_128];           // 课程简介
    int                             nCanStartStreamNum;                             // 能否被拉流逻辑通道数
    int                             nIsRecordNum;                                   // 是否要录像逻辑通道号数
    EM_CAN_START_STREAM             emCanStartStream[64];                           // 能否被拉流
    EM_IS_RECORD                    emIsRecord[64];                                 // 是否要录像
    int                             nCompositeChannelMode;                          // 组合通道模式; 0: 无效, 1: 电影模式, 2: 常态模式, 3: 精品模式, <0:自定义模式
    EM_COURSE_STATE                 emCourseState;                                  // 课程状态
    BYTE                            byReserved[128];                                // 保留字节
} NET_COURSE;

// CLIENT_AddCourse 入参
typedef struct tagNET_IN_ADD_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nCourseNum;                                     // 课程数量
    NET_COURSE                      stuCourseInfo[64];                              // 课程信息
}NET_IN_ADD_COURSE; 

// CLIENT_AddCourse 出参
typedef struct tagNET_OUT_ADD_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nIdNum;                                         // 课程ID数量
    int                             nId[64];                                        // 返回新增的课程ID; -1:数据库中无此记录, -2:记录已存在, -3:数据库已满
}NET_OUT_ADD_COURSE;

// 添加新的课程记录
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddCourse(LLONG lLoginID, const NET_IN_ADD_COURSE *pstInParam, NET_OUT_ADD_COURSE *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_DeleteCourse 入参
typedef struct tagNET_IN_DELETE_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nIdNum;                                         // 课程ID数量
    int                             nId[64];                                        // 课程ID
}NET_IN_DELETE_COURSE; 

// CLIENT_DeleteCourse 出参
typedef struct tagNET_OUT_DELETE_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nResultIdNum;                                   // 课程ID数量
    int                             nResultId[64];                                  // 课程ID; -1:删除成功, 原id:删除失败
}NET_OUT_DELETE_COURSE;

// 删除课程
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteCourse(LLONG lLoginID, const NET_IN_DELETE_COURSE *pstInParam, NET_OUT_DELETE_COURSE *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_ModifyCourse 入参
typedef struct tagNET_IN_MODIFY_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nCourseNum;                                     // 课程数量
    NET_COURSE                      stuCourseInfo[64];                              // 课程信息
    int                             nId[64];                                        // 课程ID
}NET_IN_MODIFY_COURSE; 

// CLIENT_ModifyCourse 出参
typedef struct tagNET_OUT_MODIFY_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nResultIDNum;                                   // 修改的课程ID数量
    int                             nResultID[64];                                  // 修改的课程ID; 原ID: 修改成功, -1: 数据库中无此记录, -2: 时间冲突
}NET_OUT_MODIFY_COURSE;

// 修改课程
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ModifyCourse(LLONG lLoginID, const NET_IN_MODIFY_COURSE *pstInParam, NET_OUT_MODIFY_COURSE *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_QueryCourseOpen 入参
typedef struct tagNET_IN_QUERY_COURSE_OPEN
{
    DWORD                           dwSize;                                         // 结构体大小
    NET_TIME                        stuStartTime;                                   // 查询开始时间
    NET_TIME                        stuEndTime;                                     // 查询结束时间
}NET_IN_QUERY_COURSE_OPEN; 

// CLIENT_QueryCourseOpen 出参
typedef struct tagNET_OUT_QUERY_COURSE_OPEN
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nTotalNum;                                      // 查询到的总个数
    int                             nFindID;                                        // 查询的句柄号
}NET_OUT_QUERY_COURSE_OPEN;

// 开始查询课程
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourseOpen(LLONG lLoginID, const NET_IN_QUERY_COURSE_OPEN *pstInParam, NET_OUT_QUERY_COURSE_OPEN *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_QueryCourse 入参
typedef struct tagNET_IN_QUERY_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nFindID;                                        // 查询句柄号
    int                             nOffset;                                        // 开始查询偏移
    int                             nCount;                                         // 需要查询的个数
}NET_IN_QUERY_COURSE; 
// 课程信息和ID
typedef struct tagNET_COURSE_RESULT
{
    NET_COURSE                      stuCourseInfo;                                  // 课程信息
    int                             nId;                                            // 课程ID
    BYTE                            byReserved[4];                                  // 保留字节
} NET_COURSE_RESULT;
// CLIENT_QueryCourse 出参
typedef struct tagNET_OUT_QUERY_COURSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nCountResult;                                   // 查找到的个数
    NET_COURSE_RESULT               stuCourseResult[64];                            // 查询的课程信息结果
}NET_OUT_QUERY_COURSE;

// 查询课程
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourse(LLONG lLoginID, const NET_IN_QUERY_COURSE *pstInParam, NET_OUT_QUERY_COURSE *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// CLIENT_QueryCourseClose 入参
typedef struct tagNET_IN_QUERY_COURSE_CLOSE
{
    DWORD                           dwSize;                                         // 结构体大小
    int                             nFindID;                                        // 课程数量
}NET_IN_QUERY_COURSE_CLOSE; 

// CLIENT_QueryCourseClose 出参
typedef struct tagNET_OUT_QUERY_COURSE_CLOSE
{
    DWORD                           dwSize;                                         // 结构体大小
}NET_OUT_QUERY_COURSE_CLOSE;

// 关闭课程查询
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryCourseClose(LLONG lLoginID, const NET_IN_QUERY_COURSE_CLOSE *pstInParam, NET_OUT_QUERY_COURSE_CLOSE *pstOutParam, int nWaitTime= NET_INTERFACE_DEFAULT_TIMEOUT);

// 打开播放组
CLIENT_NET_API LLONG CALL_METHOD CLIENT_OpenPlayGroup();

// CLIENT_AddPlayHandleToPlayGroup 输入参数
typedef struct tagNET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP
{
	DWORD			dwSize;					// 结构体大小
	BYTE			byReserved[4];			// 字节对齐
	LLONG			lPlayGroupHandle;		// 播放组句柄，CLIENT_OpenPlayGroup 返回
	LLONG			lPlayHandle;			// 播放句柄（当前只支持回放）	
}NET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP;

// CLIENT_AddPlayHandleToPlayGroup 输出参数
typedef struct tagNET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP
{
	DWORD			dwSize;					// 结构体大小	
}NET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP;

// 将播放句柄加入播放组，保证同步播放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_AddPlayHandleToPlayGroup(const NET_IN_ADD_PLAYHANDLE_TO_PLAYGROUP* pInParam, NET_OUT_ADD_PLAYHANDLE_TO_PLAYGROUP* pOutParam);

// 暂停/恢复播放组
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PausePlayGroup(LLONG lPlayGroupHandle, BOOL bPause);

// CLIENT_QueryPlayGroupTime 输入参数
typedef struct tagNET_IN_QUERY_PLAYGROUP_TIME
{
	DWORD			dwSize;					// 结构体大小	
	BYTE			byReserved[4];			// 字节对齐
	LLONG			lPlayGroupHandle;		// 播放组句柄，CLIENT_OpenPlayGroup 返回值
}NET_IN_QUERY_PLAYGROUP_TIME;

// CLIENT_QueryPlayGroupTime 输出参数
typedef struct tagNET_OUT_QUERY_PLAYGROUP_TIME
{
	DWORD			dwSize;					// 结构体大小	
	NET_TIME_EX		stuTime;				// 时间
}NET_OUT_QUERY_PLAYGROUP_TIME;

// 获取播放组时间
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryPlayGroupTime(const NET_IN_QUERY_PLAYGROUP_TIME* pInParam, NET_OUT_QUERY_PLAYGROUP_TIME* pOutParam);

// CLIENT_SetPlayGroupBaseChannel 输入参数
typedef struct tagNET_IN_SET_PLAYGROUP_BASECHANNEL
{
	DWORD			dwSize;					// 结构体大小
	BYTE			byReserved[4];			// 字节对齐	
	LLONG			lPlayGroupHandle;		// 播放组句柄，CLIENT_OpenPlayGroup 返回值
	LLONG			lPlayHandle;			// 播放句柄（当前只支持回放）
}NET_IN_SET_PLAYGROUP_BASECHANNEL;

// CLIENT_SetPlayGroupBaseChannel 输出参数
typedef struct tagNET_OUT_SET_PLAYGROUP_BASECHANNEL
{
	DWORD			dwSize;					// 结构体大小	
}NET_OUT_SET_PLAYGROUP_BASECHANNEL;

// 设置播放组基准通道
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupBaseChannel(const NET_IN_SET_PLAYGROUP_BASECHANNEL* pInParam, NET_OUT_SET_PLAYGROUP_BASECHANNEL* pOutParam);

// CLIENT_DeleteFromPlayGroup 输入参数
typedef struct tagNET_IN_DELETE_FROM_PLAYGROUP
{
	DWORD			dwSize;					// 结构体大小
	BYTE			byReserved[4];			// 字节对齐	
	LLONG			lPlayGroupHandle;		// 播放组句柄，CLIENT_OpenPlayGroup 返回值
	LLONG			lPlayHandle;			// 播放句柄（当前只支持回放）
}NET_IN_DELETE_FROM_PLAYGROUP;

// CLIENT_DeleteFromPlayGroup 输出参数
typedef struct tagNET_OUT_DELETE_FROM_PLAYGROUP
{
	DWORD			dwSize;					// 结构体大小	
}NET_OUT_DELETE_FROM_PLAYGROUP;

// 将播放句柄从播放组中移除
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteFromPlayGroup(const NET_IN_DELETE_FROM_PLAYGROUP* pInParam, NET_OUT_DELETE_FROM_PLAYGROUP* pOutParam);

// 关闭播放组
// lPlayGroupHandle 是 CLIENT_OpenPlayGroup 的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ClosePlayGroup(LLONG lPlayGroupHandle);

// CLIENT_GetChannelOfAudioInput 输入结构体
typedef struct tagNET_IN_GET_CHANNEL_OF_AUDIO_INPUT
{
    DWORD								dwSize;					// 结构体大小
}NET_IN_GET_CHANNEL_OF_AUDIO_INPUT;

// CLIENT_GetChannelOfAudioInput 输出结构体
typedef struct tagNET_OUT_GET_CHANNEL_OF_AUDIO_INPUT
{
    DWORD								dwSize;					// 结构体大小
    UINT                                nChannels;              // 支持的音频输入通道数
}NET_OUT_GET_CHANNEL_OF_AUDIO_INPUT;

// CLIENT_GetChannelOfAudioOutput 输入结构体
typedef struct tagNET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT
{
    DWORD								dwSize;					// 结构体大小
}NET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT;

// CLIENT_GetChannelOfAudioOutput 输出结构体
typedef struct tagNET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT
{
    DWORD								dwSize;					// 结构体大小
    UINT                                nChannels;              // 支持的音频输出通道数
}NET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT;


// 获取音频输入的通道数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelOfAudioInput(LLONG lLoginID, NET_IN_GET_CHANNEL_OF_AUDIO_INPUT* pInParam, NET_OUT_GET_CHANNEL_OF_AUDIO_INPUT* pOutParam,int nWaitTime);

// 获取音频输出的通道数
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetChannelOfAudioOutput(LLONG lLoginID, NET_IN_GET_CHANNEL_OF_AUDIO_OUTPUT* pInParam, NET_OUT_GET_CHANNEL_OF_AUDIO_OUTPUT* pOutParam,int nWaitTime);

// CLIENT_ExitApp 接口输入参数
typedef struct tagNET_IN_EXIT_APP
{
    DWORD               dwSize;             // 结构体大小
} NET_IN_EXIT_APP;

// CLIENT_ExitApp 接口输出参数
typedef struct tagNET_OUT_EXIT_APP
{
    DWORD               dwSize;             // 结构体大小
} NET_OUT_EXIT_APP;

// 退出应用程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ExitApp(LLONG lLoginID, NET_IN_EXIT_APP* pInParam, NET_OUT_EXIT_APP* pOutParam, int nWaitTime);


// CLIENT_SetPlayGroupDirection 输入参数
typedef struct tagNET_IN_SET_PLAYGROUP_DIRECTION
{
	DWORD				dwSize;								// 结构体大小
	int					nPlayDirection;						// 播放方向, 0:正放; 1:倒放
	LLONG				lPlayGroupHandle;					// 播放组句柄，由 CLIENT_OpenPlayGroup 返回	
}NET_IN_SET_PLAYGROUP_DIRECTION;

// CLIENT_SetPlayGroupDirection 输出参数
typedef struct tagNET_OUT_SET_PLAYGROUP_DIRECTION
{
	DWORD				dwSize;								// 结构体大小	
}NET_OUT_SET_PLAYGROUP_DIRECTION;

// 设置播放组播放方向
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupDirection(const NET_IN_SET_PLAYGROUP_DIRECTION* pInParam, NET_OUT_SET_PLAYGROUP_DIRECTION* pOutParam);


// CLIENT_SetPlayGroupSpeed 输入参数
typedef struct tagNET_IN_SET_PLAYGROUP_SPEED
{
	DWORD				dwSize;								// 结构体大小
	EM_PLAY_BACK_SPEED	emSpeed;							// 播放速度
	LLONG				lPlayGroupHandle;					// 播放组句柄，由 CLIENT_OpenPlayGroup 返回	
}NET_IN_SET_PLAYGROUP_SPEED;

// CLIENT_SetPlayGroupSpeed 输出参数
typedef struct tagNET_OUT_SET_PLAYGROUP_SPEED
{
	DWORD				dwSize;								// 结构体大小	
}NET_OUT_SET_PLAYGROUP_SPEED;

// 设置播放组播放速度
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayGroupSpeed(const NET_IN_SET_PLAYGROUP_SPEED* pInParam, NET_OUT_SET_PLAYGROUP_SPEED* pOutParam);

// 播放组快放
// lPlayGroupHandle 是播放组句柄，由 CLIENT_OpenPlayGroup 返回
CLIENT_NET_API BOOL CALL_METHOD CLIENT_FastPlayGroup(LLONG lPlayGroupHandle);

// 播放组慢放
// lPlayGroupHandle 是播放组句柄，由 CLIENT_OpenPlayGroup 返回
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SlowPlayGroup(LLONG lPlayGroupHandle);

// 播放组正常播放
// lPlayGroupHandle 是播放组句柄，由 CLIENT_OpenPlayGroup 返回
CLIENT_NET_API BOOL CALL_METHOD CLIENT_NormalPlayGroup(LLONG lPlayGroupHandle);


// AOL异步搜索设备入参（组播）
typedef struct tagNET_IN_AOL_STARTSEARCH_DEVICE
{
	DWORD                   dwSize;								// 结构体大小
	char                    szLocalIp[MAX_LOCAL_IP_LEN];		// 发起搜索的本地IP
	fSearchDevicesCBEx      cbSearchDevices;					// 设备信息回调函数
	void*                   pUserData;							// 用户自定义数据	
}NET_IN_AOL_STARTSEARCH_DEVICE;

// AOL异步搜索设备出参
typedef struct tagNET_OUT_AOL_STARTSEARCH_DEVICE
{
	DWORD                   dwSize;								// 结构体大小
}NET_OUT_AOL_STARTSEARCH_DEVICE;

// AOL异步搜索设备
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartSearchDevicesForAOL(NET_IN_AOL_STARTSEARCH_DEVICE* pInParam, NET_OUT_AOL_STARTSEARCH_DEVICE* pOutParam);

// CLIENT_SearchDevicesByIPsForAOL 输入参数
typedef struct tagNET_IN_AOL_SEARCHDEVICE_BYIPS
{		
	DWORD					dwSize;								// 结构体大小	
	int                 	nIpNum;								// 当前搜索的IP个数
    char                	szIP[DH_MAX_SAERCH_IP_NUM][64];		// 具体待搜索的IP信息	
	char*					szLocalIp;							// 发起搜索的本地IP
	fSearchDevicesCB		cbSearchDevices;					// 回调函数
	LDWORD					dwUserData;							// 用户数据	
}NET_IN_AOL_SEARCHDEVICE_BYIPS;

// CLIENT_SearchDevicesByIPsForAOL 输出参数
typedef struct tagNET_OUT_AOL_SEARCHDEVICE_BYIPS
{
	DWORD					dwSize;								// 结构体大小
}NET_OUT_AOL_SEARCHDEVICE_BYIPS;

// AOL 指定IP搜索设备
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SearchDevicesByIPsForAOL(NET_IN_AOL_SEARCHDEVICE_BYIPS* pInParam, NET_OUT_AOL_SEARCHDEVICE_BYIPS* pOutParam, int nWaitTime);



// CLIENT_ResetSystemEx 输入参数
typedef struct tagNET_IN_RESET_SYSTEM_EX
{
	DWORD 					dwSize;										// 结构体大小
	UINT					nType;										// 0: 硬恢复; 1:软恢复
}NET_IN_RESET_SYSTEM_EX;

// CLIENT_ResetSystemEx 输出参数
typedef struct tagNET_OUT_RESET_SYSTEM_EX
{
	DWORD 					dwSize;										// 结构体大小
}NET_OUT_RESET_SYSTEM_EX;

// 恢复出厂配置扩展接口(包括清空配置和删除账户)，实现硬复位及软复位功能
CLIENT_NET_API BOOL CALL_METHOD CLIENT_ResetSystemEx(LLONG lLoginID,const NET_IN_RESET_SYSTEM_EX* pstInParam, NET_OUT_RESET_SYSTEM_EX* pstOutParam, int nWaitTime);

// 导出 AOL 日志文件错误码
typedef enum tagEM_EXPORT_AOL_LOGFILE_ERRORCODE
{
	EM_EXPORT_AOL_LOGFILE_SUCCESS			= 1,						// 导出请求成功
	EM_EXPORT_AOL_LOGFILE_NO_AUTHORITY		= 2,						// 无权限
	EM_EXPORT_AOL_LOGFILE_NO_THIS_FILE		= 3,						// 文件不存在	
	EM_EXPORT_AOL_LOGFILE_EXPORT_END		= 4,						// 文件下载结束
	EM_EXPORT_AOL_LOGFILE_EXPORTING			= 5,						// 文件下载中
	EM_EXPORT_AOL_LOGFILE_FILE_SUCCESS		= 6,						// 文件终止下载请求成功
	EM_EXPORT_AOL_LOGFILE_FILE_FAIL			= 7,						// 文件终止下载请求失败
	EM_EXPORT_AOL_LOGFILE_FILE_READY		= 8,						// 文件准备完成
	EM_EXPORT_AOL_LOGFILE_FILE_FAILED		= 9,						// 文件准备失败	
	EM_EXPORT_AOL_LOGFILE_WAIT_FILE			= 10,						// 导出请求成功, 需要等待设备准备数据
	EM_EXPORT_AOL_LOGFILE_SYSTEM_BUSY		= 11,						// 系统忙, 暂时无法导出数据
} EM_EXPORT_AOL_LOGFILE_ERRORCODE;

// 导出AOL日志文件状态信息
typedef struct tagNET_EXPORT_AOL_LOGFILE_STATE
{
	unsigned int					nProgress;							// 进度, 百分比
	EM_EXPORT_AOL_LOGFILE_ERRORCODE	emErrorCode;						// 错误码
	char							*pDataBuf;							// 导出数据
	DWORD							dwDataLen;							// 数据长度
	BYTE							byReserved[516];					// 保留字节
} NET_EXPORT_AOL_LOGFILE_STATE;

// 导出AOL日志文件回调函数原形
typedef void (CALLBACK *fExportAOLLogFileCallBack)(LLONG lExportHandle, NET_EXPORT_AOL_LOGFILE_STATE *pstLogFileState, LDWORD dwUser);

// CLIENT_ExportAOLLogFile 接口输入参数
typedef struct tagNET_IN_EXPORT_AOL_LOGFILE
{
	DWORD							dwSize;								// 结构体大小	
	BYTE							byReserved[4];						// 字节对齐
	fExportAOLLogFileCallBack		cbExport;							// 导出日志文件回调函数
	LDWORD 							dwUser;								// 用户数据
}NET_IN_EXPORT_AOL_LOGFILE;

// CLIENT_ExportAOLLogFile 接口输出参数
typedef struct tagNET_OUT_EXPORT_AOL_LOGFILE
{
	DWORD							dwSize;								// 结构体大小
}NET_OUT_EXPORT_AOL_LOGFILE;

// 导出AOL日志文件
CLIENT_NET_API LLONG CALL_METHOD CLIENT_ExportAOLLogFile(LLONG lLoginID, const NET_IN_EXPORT_AOL_LOGFILE* pInParam, NET_OUT_EXPORT_AOL_LOGFILE* pOutParam, int nWaitTime);

// 停止导出AOL日志文件
// lExportHandle 为 CLIENT_ExportAOLLogFile 返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopExportAOLLogFile(LLONG lExportHandle);

// CLIENT_DeleteAllDiagnosisFaultCode 输入参数
typedef struct tagNET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE
{
	DWORD							dwSize;								// 结构体大小
}NET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE;

//
typedef struct tagNET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE
{
	DWORD							dwSize;								// 结构体大小
}NET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE;

// 删除所有故障码
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DeleteAllDiagnosisFaultCode(LLONG lLoginID, const NET_IN_DELETE_ALLDIAGNOSIS_FAULTCODE* pInParam, NET_OUT_DELETE_ALLDIAGNOSIS_FAULTCODE* pOutParam, int nWaitTime);

// 猪体温信息
typedef struct tagNET_PIG_TEMPERATURE_DATA
{
    NET_RECT            stuRect;                // 物体位置 
    UINT                nID;                    // 物体编号
    float               fMaxTemperature;        // 最高温
    float               fMinTemperature;        // 最低温
    float               fAverageTemperature;    // 平均温
    BYTE                byReserve[1024];        // 保留字节
} NET_PIG_TEMPERATURE_DATA;

// 猪体温信息数组
typedef struct tagNET_PIG_TEMPERATURE_INFO
{
    UINT                        nPigNum;            // 猪的数量
    NET_PIG_TEMPERATURE_DATA    stuPigInfo[48];     // 猪的信息
    BYTE                        byReserve[1024];    // 保留字节
} NET_PIG_TEMPERATURE_INFO;

// 自定义抓图类型
typedef enum tagEM_CUSTOM_SNAP_TYPE
{
    EM_CUSTOM_SNAP_UNKNOWN,            // 未知
    EM_CUSTOM_SNAP_PIG_TEMPERATURE,    // 猪体温检测, 对应结构体 NET_PIG_TEMPERATURE_INFO
} EM_CUSTOM_SNAP_TYPE;

// 图片文件订阅回调信息
typedef struct tagNET_CB_CUSTOM_SNAP_INFO
{
    UINT                        nChannelID;         // 通道号
    NET_TIME                    stuSnapTime;        // 抓图时间
    EM_CUSTOM_SNAP_TYPE         emCustomSnapType;   // 自定义抓图类型
    void*                       pDetailInfo;        // 图片包含数据, 根据emCustomSnapType值来确定具体的结构体类型
    BYTE                        byReserve[1024];    // 保留字节
} NET_CB_CUSTOM_SNAP_INFO;

// 自定义定时抓图订阅回调函数原型, lAttachHandle为 CLIENT_AttachCustomSnapInfo 接口的返回值
typedef void (CALLBACK *fAttachCustomSnapInfo)(LLONG lAttachHandle, NET_CB_CUSTOM_SNAP_INFO* pstResult, const char *pBuf, const DWORD dwBufSize, LDWORD dwUser);

// CLIENT_AttachCustomSnapInfo 接口输入参数
typedef struct tagNET_IN_ATTACH_CUSTOM_SNAP_INFO
{
    DWORD                           dwSize;                         // 结构体大小
    int                             nChannelID;                     // 订阅通道号
    fAttachCustomSnapInfo           cbCustomSnapInfo;               // 自定义定时抓图订阅回调函数
    LDWORD                          dwUser;                         // 用户数据
} NET_IN_ATTACH_CUSTOM_SNAP_INFO;

// CLIENT_AttachCustomSnapInfo 接口输出参数
typedef struct tagNET_OUT_ATTACH_CUSTOM_SNAP_INFO
{
    DWORD                           dwSize;                         // 结构体大小
} NET_OUT_ATTACH_CUSTOM_SNAP_INFO;

// 自定义定时抓图订阅接口(目前智慧养殖猪温检测在用)
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachCustomSnapInfo(LLONG lLoginID, NET_IN_ATTACH_CUSTOM_SNAP_INFO* pInParam, NET_OUT_ATTACH_CUSTOM_SNAP_INFO* pOutParam, const int nWaitTime);

// 取消自定义定时抓图订阅接口(目前智慧养殖猪温检测在用)
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachCustomSnapInfo(LLONG lAttachHandle);


// CLIENT_GetInstalledAppInfo 接口输入参数
typedef struct tagNET_IN_GET_INSTALLED_APP_INFO
{
    DWORD                           dwSize;                     // 结构体大小
} NET_IN_GET_INSTALLED_APP_INFO;

// APP的能力信息
typedef struct tagNET_APP_CAPS
{
    BOOL                bShowWebConsole;        // 是否支持 web Console
    BOOL                bShowPerformance;       // 是否支持查看性能
    BOOL                bShowDebug;             // 是否支持调试
    BYTE                byReserved[128];        // 保留字节
}NET_APP_CAPS;

// APP的运行状态
typedef enum tagEM_APP_RUNNING_STATE
{
    EM_APP_RUNNING_STATE_UNKNOWN,           // 未知
    EM_APP_RUNNING_STATE_RUNNING,           // 运行中
    EM_APP_RUNNING_STATE_STOP,              // 已停止
    EM_APP_RUNNING_STATE_ERROR,             // 异常状态
} EM_APP_RUNNING_STATE;

// APP的证书状态
typedef enum tagEM_APP_LICENSE_STATE
{
    EM_APP_LICENSE_STATE_UNKNOEN,        // 未知
    EM_APP_LICENSE_STATE_IN_TRAL,        // 证书试用期
    EM_APP_LICENSE_STATE_IN_LICENSE,     // 证书正式合法
    EM_APP_LICENSE_STATE_EXPIRED,        // 证书过期
}EM_APP_LICENSE_STATE;

// APP的调试状态
typedef enum tagEM_APP_DEBUG_STATE
{
    EM_APP_DEBUG_STATE_UNKNOWN,         // 未知
    EM_APP_DEBUG_STATE_ENABLE,          // 开启调试
    EM_APP_DEBUG_STATE_DISABLE,         // 关闭调试
}EM_APP_DEBUG_STATE;

// 安装的应用信息
typedef struct tagNET_INSTALLED_APP_INFO
{
    char                    szAppName[128];         // APP的名称
    char                    szVersion[64];          // APP的版本
    char                    szExtend[64];           // 扩展信息
    UINT                    nAppID;                 // APP的ID
    EM_APP_DEBUG_STATE      emAppDebugState;        // APP的调试状态
    EM_APP_RUNNING_STATE    emAppRunningState;      // APP的运行状态
    EM_APP_LICENSE_STATE    emAppLicenseState;      // APP的license状态
    NET_APP_CAPS            stuAppCaps;             // APP的能力信息
    BYTE                    byReserved[256];        // 保留字节
} NET_INSTALLED_APP_INFO;


// CLIENT_GetInstalledAppInfo 接口输出参数
typedef struct tagNET_OUT_GET_INSTALLED_APP_INFO
{
    DWORD                           dwSize;                     // 结构体大小
    UINT                            nListCount;                 // 返回以安装的应用列表信息的数量
    NET_INSTALLED_APP_INFO          stuAppInfoList[16];         // 安装的应用列表信息
} NET_OUT_GET_INSTALLED_APP_INFO;

// CLIENT_StartApp  接口输入参数
typedef struct tagNET_IN_START_APP
{
    DWORD                           dwSize;                     // 结构体大小
    UINT                            nAppID;                     // APP的ID
    char                            szAppName[128];             // APP的名称
} NET_IN_START_APP;

// CLIENT_StartApp 接口输出参数
typedef struct tagNET_OUT_START_APP
{
    DWORD                           dwSize;                     // 结构体大小
} NET_OUT_START_APP;


// CLIENT_StopApp 接口输出参数
typedef struct tagNET_IN_STOP_APP
{
    DWORD                           dwSize;                     // 结构体大小
    UINT                            nAppID;                     // APP的ID
    char                            szAppName[128];             // APP的名称
} NET_IN_STOP_APP;

// CLIENT_StopApp 接口输出参数
typedef struct tagNET_OUT_STOP_APP
{
    DWORD                           dwSize;                     // 结构体大小
} NET_OUT_STOP_APP;

// CLIENT_RemoveApp 接口输入参数
typedef struct tagNET_IN_REMOVE_APP
{
    DWORD                           dwSize;                     // 结构体大小
    UINT                            nAppID;                     // APP的ID
    char                            szAppName[128];             // APP的名称
} NET_IN_REMOVE_APP;

// CLIENT_RemoveApp 接口输出参数
typedef struct tagNET_OUT_REMOVE_APP
{
    DWORD                           dwSize;                     // 结构体大小
} NET_OUT_REMOVE_APP;

// 获取安装的应用列表
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetInstalledAppInfo(LLONG lLoginID, const NET_IN_GET_INSTALLED_APP_INFO* pInParam, NET_OUT_GET_INSTALLED_APP_INFO* pOutParam, int nWaitTime);

// 启动程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartApp(LLONG lLoginID, const NET_IN_START_APP* pInParam, NET_OUT_START_APP* pOutParam, int nWaitTime);

// 停止程序运行
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopApp(LLONG lLoginID, const NET_IN_STOP_APP* pInParam, NET_OUT_STOP_APP* pOutParam, int nWaitTime);

// 卸载程序
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RemoveApp(LLONG lLoginID, const NET_IN_REMOVE_APP* pInParam, NET_OUT_REMOVE_APP* pOutParam, int nWaitTime);

// CLIENT_GetASGState 接口输入参数
typedef struct tagNET_IN_ACCESS_GET_ASG_STATE
{
    DWORD           dwSize;                            
}NET_IN_ACCESS_GET_ASG_STATE;

// 门翼状态
typedef enum tagEM_DOOR_WING_STATE
{
    EM_DOOR_WING_STATE_UNKNOWN,                      // 未知
    EM_DOOR_WING_STATE_CLOSE,                        // 关门
    EM_DOOR_WING_STATE_ENTER_OPEN,                   // 进口打开
    EM_DOOR_WING_STATE_LEAVE_OPEN,                   // 出口打开
} EM_DOOR_WING_STATE;

// Can通信状态
typedef enum tagEM_CAN_COMMUNICATE_STATE
{
    EM_CAN_COMMUNICATE_STATE_UNKNOWN = -1,           // 未知
    EM_CAN_COMMUNICATE_STATE_NORMAL,                 // 正常
    EM_CAN_COMMUNICATE_STATE_ABNORMAL,               // 异常 
} EM_CAN_COMMUNICATE_STATE;

// CLIENT_GetASGState 接口输出参数
typedef struct tagNET_OUT_ACCESS_GET_ASG_STATE
{
    DWORD                             dwSize;
    int                               nInfraredStateNum;              // 红外状态个数
    int                               szInfraredStateMask[6];         // 红外状态掩码; 
                                                                      // 数组[0] Bit0 表示第1路，Bit7表示第8路, 数组[1] Bit0 表示第9路，Bit7表示第16路;
                                                                      // 位定义为 0：灭(未遮挡),1：亮(被遮挡)
    EM_DOOR_WING_STATE                emDoorWingState;                // 门翼状态
    EM_CAN_COMMUNICATE_STATE          emCanState;                     // Can通信状态
    int                               nEnterNum;                      // 进通行人数
    int                               nLeaveNum;                      // 出通行人数       
}NET_OUT_ACCESS_GET_ASG_STATE;

// 获取闸机状态
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetASGState(LLONG lLoginID, const NET_IN_ACCESS_GET_ASG_STATE* pInParam, NET_OUT_ACCESS_GET_ASG_STATE* pOutParam, int nWaitTime);

// CLIENT_StartFindXRayPkg 接口输入参数
typedef struct tagNET_IN_START_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // 结构体大小
    EM_RESULT_ORDER_TYPE    emTimeOrder;            // 查询结果按时间排序
	NET_TIME			    stuStartTime;		    // 查询的开始时间
    NET_TIME			    stuEndTime;			    // 查询的结束时间
    UINT                    nSimilarityRange[2];    // 相似度范围,下标0:表示最小值, 下标1:表示最大值
    UINT                    nObjTypeNum;            // 物体类型的数量
    EM_INSIDE_OBJECT_TYPE	emObjType[32];		    // 物品类型
} NET_IN_START_FIND_XRAY_PKG;

// CLIENT_StartFindXRayPkg 接口输出参数
typedef struct tagNET_OUT_START_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // 结构体大小
    UINT                    nTotal;                 // 包裹总数    
} NET_OUT_START_FIND_XRAY_PKG;

// CLIENT_DoFindXRayPkg 接口输出参数
typedef struct tagNET_IN_DO_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // 结构体大小
    UINT                    nOffset;                // 查询偏移  
    UINT                    nCount;                 // 需要查找的数目
} NET_IN_DO_FIND_XRAY_PKG;

// X光机物体信息
typedef struct tagNET_PKG_OBJECT_INFO
{
    EM_INSIDE_OBJECT_TYPE	emObjType;		    	// 物品类型
    EM_DANGER_GRADE_TYPE	emDangerGrade;			// 物品危险等级
    UINT                    nSimilarity;	    	// 相似度,0~100
    BYTE                    byReserved[132];    	// 保留字节
}NET_PKG_OBJECT_INFO;

// 视角信息数
typedef struct tagNET_PKG_VIEW_INFO
{
    EM_XRAY_VIEW_TYPE       emViewType;				    // 视图类型
    UINT                    nEnergyImageLength;         // 能量图大小 单位字节
    char                    szEnergyImagePath[128];     // 能量图绝对路径
    UINT                    nColorImageLength;          // 彩图大小单位字节
    char                    szColorImagePath[128];      // 彩图绝对路径
    UINT                    nColorOverlayImageLength;   // 彩图叠加图大小单位字节
    char                    szColorOverlayImagePath[128];// 彩图叠加图绝对路径
    NET_PKG_OBJECT_INFO     stuObject[32];              // 物体数组
	UINT                    nObjectCount;               // 物体数量
    BYTE                    byReserved[1024];           // 保留字节
} NET_PKG_VIEW_INFO;

// X光机的包裹信息
typedef struct tagNET_XRAY_PKG_INFO
{
    NET_TIME			    stuTime;		    	// 包裹产生时间(含时区)
    int                     nChannelIn;             // 关联的进口IPC通道号,从0开始,-1表示无效
    int                     nChannelOut;            // 关联的出口IPC通道号,从0开始,-1表示无效
    char                    szUser[128];            // 用户名
    NET_PKG_VIEW_INFO       stuViewInfo[2];         // 视角信息数组
    BYTE                    byReserved[1024];        // 保留字节
} NET_XRAY_PKG_INFO;

// CLIENT_DoFindXRayPkg 接口输出参数
typedef struct tagNET_OUT_DO_FIND_XRAY_PKG
{
    DWORD                   dwSize;                 // 结构体大小
    UINT                    nMaxCount;              // 用户指定分配结构体个数,需大于等于NET_IN_DO_FIND_XRAY_PKG的nCount
    UINT                    nRetCount;              // 实际返回的查询数量
    NET_XRAY_PKG_INFO*      pstuXRayPkgInfo;        // X光机的包裹信息,缓存大小由用户指定
} NET_OUT_DO_FIND_XRAY_PKG;


// 开始查找X光机包裹信息
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartFindXRayPkg(LLONG lLoginID, const NET_IN_START_FIND_XRAY_PKG* pInParam, NET_OUT_START_FIND_XRAY_PKG* pOutParam, int nWaitTime);

// 查询X光机包裹的信息,lFindID为CLIENT_StartFindXRayPkg接口返回的查找ID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DoFindXRayPkg(LLONG lFindID, const NET_IN_DO_FIND_XRAY_PKG* pInParam, NET_OUT_DO_FIND_XRAY_PKG* pOutParam, int nWaitTime);

// 结束查询X光机包裹的信息, lFindID为CLIENT_StartFindXRayPkg接口返回的查找ID
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopFindXRayPkg(LLONG lFindID);


// 电视墙场景回调信息
typedef struct tagNET_CB_MONITOR_WALL_SCENE
{
    char                        szCurrentCollectionName[32];    // 当前预案名称
    DH_MONITORWALL_SCENE        stuScene;                       // 电视墙场景
    BYTE                        byReserve[1024];                // 保留字节
} NET_CB_MONITOR_WALL_SCENE;

// 电视墙场景订阅回调函数原型, lAttachHandle为 CLIENT_AttachMonitorWallScene 接口的返回值
typedef void (CALLBACK *fMonitorWallScene)(LLONG lAttachHandle, NET_CB_MONITOR_WALL_SCENE* pstResult, LDWORD dwUser);

// CLIENT_AttachMonitorWallScene 接口输入参数
typedef struct tagNET_IN_ATTACH_MONITOR_WALL_SCENE
{
    DWORD                           dwSize;                         // 结构体大小
    int                             nMonitorWallID;                 // 电视墙ID
    fMonitorWallScene               cbMonitorWallScene;             // 电视墙场景订阅回调函数
    LDWORD                          dwUser;                         // 用户数据
} NET_IN_ATTACH_MONITOR_WALL_SCENE;

// CLIENT_AttachMonitorWallScene 接口输出参数
typedef struct tagNET_OUT_ATTACH_MONITOR_WALL_SCENE
{
    DWORD                           dwSize;                         // 结构体大小
} NET_OUT_ATTACH_MONITOR_WALL_SCENE;

// 订阅电视墙场景
CLIENT_NET_API LLONG CALL_METHOD CLIENT_AttachMonitorWallScene(LLONG lLoginID, NET_IN_ATTACH_MONITOR_WALL_SCENE* pInParam, NET_OUT_ATTACH_MONITOR_WALL_SCENE* pOutParam, const int nWaitTime);

// 取消订阅电视墙场景,, lAttachHandle为 CLIENT_AttachMonitorWallScene 接口的返回值
CLIENT_NET_API BOOL CALL_METHOD CLIENT_DetachMonitorWallScene(LLONG lAttachHandle);

// CLIENT_GetSystemCaps 接口输入参数
typedef struct tagNET_IN_SYSTEM_GETCAPS
{
	DWORD     dwSize;                   // 结构体大小
}NET_IN_SYSTEM_GETCAPS;

// CLIENT_GetSystemCaps 接口输出参数
typedef struct tagNET_OUT_SYSTEM_GETCAPS
{
	DWORD               dwSize;                     // 结构体大小
	BOOL                bSupportCascadeCall;        // 是否支持级联调用
	DWORD               dwCascadeType;              // 级联调用方式, bSupportCascadeCall 为TRUE时有效
	                                                // 值为掩码方式, 第一位表示通道方式
}NET_OUT_SYSTEM_GETCAPS;

// 获取设备系统能力
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetSystemCaps(LLONG lLoginID, const NET_IN_SYSTEM_GETCAPS* pInParam, NET_OUT_SYSTEM_GETCAPS* pOutParam, const int nWaitTime);

/////////////////////////////////淘汰接口  Start/////////////////////////////////

// 查询系统服务器配置；该接口已淘汰,请使用CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int maxlen, int *nConfigbuflen, int waittime=1000);

// 设置系统服务器配置；该接口已淘汰,请使用CLIENT_SetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetupConfig(LLONG lLoginID, int nConfigType, char *pConfigbuf, int nConfigbuflen, int waittime=1000);

// 该接口已淘汰,请不要使用
CLIENT_NET_API BOOL CALL_METHOD CLIENT_Reset(LLONG lLoginID, BOOL bReset);

// 查询串口协议 － 该接口已淘汰,请使用CLIENT_GetDevConfig
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryComProtocol(LLONG lLoginID, int nProtocolType, char *pProtocolBuffer, int maxlen, int *nProtocollen, int waittime=1000);

// 开始对讲；该接口已淘汰,请使用CLIENT_StartTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StartTalk(LLONG lRealHandle, BOOL bCustomSend=false);

// 结束对讲；该接口已淘汰,请使用CLIENT_StopTalkEx
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTalk(LLONG lRealHandle);

// 发送自定义对讲数据；该接口已淘汰,请使用CLIENT_TalkSendData
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SendTalkData_Custom(LLONG lRealHandle, char *pBuffer, DWORD dwBufSize);

// 设置实时预览缓冲大小
CLIENT_NET_API BOOL CALL_METHOD CLIENT_SetPlayerBufNumber(LLONG lRealHandle, DWORD dwBufNum);

// 通过时间下载文件
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetFileByTime(LLONG lLoginID, int nChannelID, LPNET_TIME lpStartTime, LPNET_TIME lpStopTime, char *sSavedFileName);

// 网络回放控制
CLIENT_NET_API BOOL CALL_METHOD CLIENT_PlayBackControl(LLONG lPlayHandle, DWORD dwControlCode, DWORD dwInValue, DWORD *lpOutValue);

// 查询设备工作状态 该接口已淘汰,请使用CLIENT_QueryDevState
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetDEVWorkState(LLONG lLoginID, LPNET_DEV_WORKSTATE lpWorkState, int waittime=1000);

// 异步查询设备日志
CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryLogCallback(LLONG lLoginID, fLogDataCallBack cbLogData, LDWORD dwUser);

// mpt300定制录像开启和关闭,pstRecIn与pstRecOut内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_RecMngCtrlMpt300(LLONG lLoginID, const NET_IN_REC_MNG_CTRL_MPT300 *pstRecIn, NET_OUT_REC_MNG_CTRL_MPT300 *pstRecOut, int nWaitTime);

// 同步直接透传接口,pstInTransmit与pstOutTransmit内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_TransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaittime = 1000);

// 异步直接透传回调函数原型
typedef void (CALLBACK *fTransmitInfoDirectlyCallBack)(LLONG lLoginID, LLONG lStartHandle, const char *pszOutBuf, DWORD dwBufLen, LDWORD dwUser);

// 异步直接透传接口,pstInTransmit与pstOutTransmit内存由用户申请释放
CLIENT_NET_API LLONG CALL_METHOD CLIENT_StartTransmitInfoDirectly(LLONG lLoginID, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, fTransmitInfoDirectlyCallBack cbDirectly, LDWORD dwUser, int nWaitTime = 1000);

// 取消异步直接透传接口,pstInTransmit与pstOutTransmit内存由用户申请释放
CLIENT_NET_API BOOL CALL_METHOD CLIENT_StopTransmitInfoDirectly(LLONG lStartHandle, const NET_IN_TRANSMIT_DIRECTLY *pstInTransmit, NET_OUT_TRANSMIT_DIRECTLY *pstOutTransmit, int nWaitTime = 1000);

// 获取VK,淘汰废弃接口,请使用CLIENT_AttachVK获取当前甚至前一个vk并订阅vk
CLIENT_NET_API BOOL CALL_METHOD CLIENT_GetVK(LLONG lLoginID, const NET_IN_GET_VKINFO* pInParam, NET_OUT_GET_VKINFO* pOutParam, int nWaitTime);

// GDPR版本信息
enum EM_GDPR_VERSION
{
	EM_GDPR_VERSION_NON = 0,				// 非GDPR设备
	EM_GDPR_VERSION_V1,						// GDPR V1设备：支持V1版本的拉流、回放
	EM_GDPR_VERSION_V2,						// GDPR V2设备：支持V2版本的拉流、回放
};

// 获取GDPR版本信息，废弃接口，请使用 CLIENT_GetGDPRAbility 接口
CLIENT_NET_API BOOL	CALL_METHOD CLIENT_GetGDPRVersion(LLONG lLoginID, EM_GDPR_VERSION* pVersion, int nWaitTime);

/////////////////////////////////淘汰接口  End/////////////////////////////////

#ifdef __cplusplus
}
#endif
#endif // DHNETSDK_H



